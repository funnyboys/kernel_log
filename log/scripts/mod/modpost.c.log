commit cff11abeca78aa782378401ca2800bd2194aa14e
Merge: 6f2dc3d33545 8dfb61dcbace
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 6 12:00:25 2020 -0700

    Merge tag 'kbuild-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild
    
    Pull Kbuild updates from Masahiro Yamada:
    
     - fix warnings in 'make clean' for ARCH=um, hexagon, h8300, unicore32
    
     - ensure to rebuild all objects when the compiler is upgraded
    
     - exclude system headers from dependency tracking and fixdep processing
    
     - fix potential bit-size mismatch between the kernel and BPF user-mode
       helper
    
     - add the new syntax 'userprogs' to build user-space programs for the
       target architecture (the same arch as the kernel)
    
     - compile user-space sample code under samples/ for the target arch
       instead of the host arch
    
     - make headers_install fail if a CONFIG option is leaked to user-space
    
     - sanitize the output format of scripts/checkstack.pl
    
     - handle ARM 'push' instruction in scripts/checkstack.pl
    
     - error out before modpost if a module name conflict is found
    
     - error out when multiple directories are passed to M= because this
       feature is broken for a long time
    
     - add CONFIG_DEBUG_INFO_COMPRESSED to support compressed debug info
    
     - a lot of cleanups of modpost
    
     - dump vmlinux symbols out into vmlinux.symvers, and reuse it in the
       second pass of modpost
    
     - do not run the second pass of modpost if nothing in modules is
       updated
    
     - install modules.builtin(.modinfo) by 'make install' as well as by
       'make modules_install' because it is useful even when
       CONFIG_MODULES=n
    
     - add new command line variables, GZIP, BZIP2, LZOP, LZMA, LZ4, and XZ
       to allow users to use alternatives such as pigz, pbzip2, etc.
    
    * tag 'kbuild-v5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild: (96 commits)
      kbuild: add variables for compression tools
      Makefile: install modules.builtin even if CONFIG_MODULES=n
      mksysmap: Fix the mismatch of '.L' symbols in System.map
      kbuild: doc: rename LDFLAGS to KBUILD_LDFLAGS
      modpost: change elf_info->size to size_t
      modpost: remove is_vmlinux() helper
      modpost: strip .o from modname before calling new_module()
      modpost: set have_vmlinux in new_module()
      modpost: remove mod->skip struct member
      modpost: add mod->is_vmlinux struct member
      modpost: remove is_vmlinux() call in check_for_{gpl_usage,unused}()
      modpost: remove mod->is_dot_o struct member
      modpost: move -d option in scripts/Makefile.modpost
      modpost: remove -s option
      modpost: remove get_next_text() and make {grab,release_}file static
      modpost: use read_text_file() and get_line() for reading text files
      modpost: avoid false-positive file open error
      modpost: fix potential mmap'ed file overrun in get_src_version()
      modpost: add read_text_file() and get_line() helpers
      modpost: do not call get_modinfo() for vmlinux(.o)
      ...

commit 3b09efc4f0c94669a928c0453d2dcb54c59543f2
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:31 2020 +0900

    modpost: change elf_info->size to size_t
    
    Align with the mmap / munmap APIs.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a3ffabf4eca5..e5cee2367d5e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -443,7 +443,7 @@ static void sym_set_crc(const char *name, unsigned int crc)
 	s->crc_valid = 1;
 }
 
-static void *grab_file(const char *filename, unsigned long *size)
+static void *grab_file(const char *filename, size_t *size)
 {
 	struct stat st;
 	void *map = MAP_FAILED;
@@ -465,7 +465,7 @@ static void *grab_file(const char *filename, unsigned long *size)
 	return map;
 }
 
-static void release_file(void *file, unsigned long size)
+static void release_file(void *file, size_t size)
 {
 	munmap(file, size);
 }
@@ -521,9 +521,8 @@ static int parse_elf(struct elf_info *info, const char *filename)
 
 	/* Check if file offset is correct */
 	if (hdr->e_shoff > info->size) {
-		fatal("section header offset=%lu in file '%s' is bigger than "
-		      "filesize=%lu\n", (unsigned long)hdr->e_shoff,
-		      filename, info->size);
+		fatal("section header offset=%lu in file '%s' is bigger than filesize=%zu\n",
+		      (unsigned long)hdr->e_shoff, filename, info->size);
 		return 0;
 	}
 

commit 4de7b62936122570408357417f21072e78292926
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:30 2020 +0900

    modpost: remove is_vmlinux() helper
    
    Now that is_vmlinux() is called only in new_module(), we can inline
    the function call.
    
    modname is the basename with '.o' is stripped. No need to compare it
    with 'vmlinux.o'.
    
    vmlinux is always located at the current working directory. No need
    to strip the directory path.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ebfa9b76ba92..a3ffabf4eca5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -88,20 +88,6 @@ static inline bool strends(const char *str, const char *postfix)
 	return strcmp(str + strlen(str) - strlen(postfix), postfix) == 0;
 }
 
-static int is_vmlinux(const char *modname)
-{
-	const char *myname;
-
-	myname = strrchr(modname, '/');
-	if (myname)
-		myname++;
-	else
-		myname = modname;
-
-	return (strcmp(myname, "vmlinux") == 0) ||
-	       (strcmp(myname, "vmlinux.o") == 0);
-}
-
 void *do_nofail(void *ptr, const char *expr)
 {
 	if (!ptr)
@@ -181,7 +167,7 @@ static struct module *new_module(const char *modname)
 
 	/* add to list */
 	strcpy(mod->name, modname);
-	mod->is_vmlinux = is_vmlinux(modname);
+	mod->is_vmlinux = (strcmp(modname, "vmlinux") == 0);
 	mod->gpl_compatible = -1;
 	mod->next = modules;
 	modules = mod;

commit a82f794c41ab51f088af325f5d9acba30a6facdb
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:29 2020 +0900

    modpost: strip .o from modname before calling new_module()
    
    new_module() conditionally strips the .o because the modname has .o
    suffix when it is called from read_symbols(), but no .o when it is
    called from read_dump().
    
    It is clearer to strip .o in read_symbols().
    
    I also used flexible-array for mod->name.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b317328ae21b..ebfa9b76ba92 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -175,18 +175,12 @@ static struct module *find_module(const char *modname)
 static struct module *new_module(const char *modname)
 {
 	struct module *mod;
-	char *p;
 
-	mod = NOFAIL(malloc(sizeof(*mod)));
+	mod = NOFAIL(malloc(sizeof(*mod) + strlen(modname) + 1));
 	memset(mod, 0, sizeof(*mod));
-	p = NOFAIL(strdup(modname));
-
-	/* strip trailing .o */
-	if (strends(p, ".o"))
-		p[strlen(p) - 2] = '\0';
 
 	/* add to list */
-	mod->name = p;
+	strcpy(mod->name, modname);
 	mod->is_vmlinux = is_vmlinux(modname);
 	mod->gpl_compatible = -1;
 	mod->next = modules;
@@ -2013,7 +2007,15 @@ static void read_symbols(const char *modname)
 	if (!parse_elf(&info, modname))
 		return;
 
-	mod = new_module(modname);
+	{
+		char *tmp;
+
+		/* strip trailing .o */
+		tmp = NOFAIL(strdup(modname));
+		tmp[strlen(tmp) - 2] = '\0';
+		mod = new_module(tmp);
+		free(tmp);
+	}
 
 	if (!mod->is_vmlinux) {
 		license = get_modinfo(&info, "license");

commit 858b937d289bbf7551d496100c1fa9efcad5796e
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:28 2020 +0900

    modpost: set have_vmlinux in new_module()
    
    Set have_vmlinux flag in a single place.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 925c1a1856aa..b317328ae21b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -192,6 +192,9 @@ static struct module *new_module(const char *modname)
 	mod->next = modules;
 	modules = mod;
 
+	if (mod->is_vmlinux)
+		have_vmlinux = 1;
+
 	return mod;
 }
 
@@ -2012,9 +2015,6 @@ static void read_symbols(const char *modname)
 
 	mod = new_module(modname);
 
-	if (mod->is_vmlinux)
-		have_vmlinux = 1;
-
 	if (!mod->is_vmlinux) {
 		license = get_modinfo(&info, "license");
 		if (!license)
@@ -2470,8 +2470,6 @@ static void read_dump(const char *fname)
 		mod = find_module(modname);
 		if (!mod) {
 			mod = new_module(modname);
-			if (mod->is_vmlinux)
-				have_vmlinux = 1;
 			mod->from_dump = 1;
 		}
 		s = sym_add_exported(symname, mod, export_no(export));

commit 0b19d54cae11bd5b9e208f52e42d88ad33a3b1d9
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:27 2020 +0900

    modpost: remove mod->skip struct member
    
    The meaning of 'skip' is obscure since it does not explain
    "what to skip".
    
    mod->skip is set when it is vmlinux or the module info came from
    a dump file.
    
    So, mod->skip is equivalent to (mod->is_vmlinux || mod->from_dump).
    
    For the check in write_namespace_deps_files(), mod->is_vmlinux is
    unneeded because the -d option is not passed in the first pass of
    modpost.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 167700a7b80f..925c1a1856aa 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2012,10 +2012,8 @@ static void read_symbols(const char *modname)
 
 	mod = new_module(modname);
 
-	if (mod->is_vmlinux) {
+	if (mod->is_vmlinux)
 		have_vmlinux = 1;
-		mod->skip = 1;
-	}
 
 	if (!mod->is_vmlinux) {
 		license = get_modinfo(&info, "license");
@@ -2474,7 +2472,6 @@ static void read_dump(const char *fname)
 			mod = new_module(modname);
 			if (mod->is_vmlinux)
 				have_vmlinux = 1;
-			mod->skip = 1;
 			mod->from_dump = 1;
 		}
 		s = sym_add_exported(symname, mod, export_no(export));
@@ -2535,7 +2532,7 @@ static void write_namespace_deps_files(const char *fname)
 
 	for (mod = modules; mod; mod = mod->next) {
 
-		if (mod->skip || !mod->missing_namespaces)
+		if (mod->from_dump || !mod->missing_namespaces)
 			continue;
 
 		buf_printf(&ns_deps_buf, "%s.ko:", mod->name);
@@ -2637,7 +2634,7 @@ int main(int argc, char **argv)
 	for (mod = modules; mod; mod = mod->next) {
 		char fname[PATH_MAX];
 
-		if (mod->skip)
+		if (mod->is_vmlinux || mod->from_dump)
 			continue;
 
 		buf.pos = 0;

commit 5a438af9db2c4a0b80d51d8c1c9c623b0c0de967
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:26 2020 +0900

    modpost: add mod->is_vmlinux struct member
    
    is_vmlinux() is called in several places to check whether the current
    module is vmlinux or not.
    
    It is faster and clearer to check mod->is_vmlinux flag.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 84a642c14775..167700a7b80f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -187,6 +187,7 @@ static struct module *new_module(const char *modname)
 
 	/* add to list */
 	mod->name = p;
+	mod->is_vmlinux = is_vmlinux(modname);
 	mod->gpl_compatible = -1;
 	mod->next = modules;
 	modules = mod;
@@ -431,11 +432,11 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 
 	if (!s) {
 		s = new_symbol(name, mod, export);
-	} else if (!external_module || is_vmlinux(s->module->name) ||
+	} else if (!external_module || s->module->is_vmlinux ||
 		   s->module == mod) {
 		warn("%s: '%s' exported twice. Previous export was in %s%s\n",
 		     mod->name, name, s->module->name,
-		     is_vmlinux(s->module->name) ? "" : ".ko");
+		     s->module->is_vmlinux ? "" : ".ko");
 		return s;
 	}
 
@@ -692,7 +693,7 @@ static void handle_modversion(const struct module *mod,
 
 	if (sym->st_shndx == SHN_UNDEF) {
 		warn("EXPORT symbol \"%s\" [%s%s] version generation failed, symbol will not be versioned.\n",
-		     symname, mod->name, is_vmlinux(mod->name) ? "":".ko");
+		     symname, mod->name, mod->is_vmlinux ? "" : ".ko");
 		return;
 	}
 
@@ -2011,12 +2012,12 @@ static void read_symbols(const char *modname)
 
 	mod = new_module(modname);
 
-	if (is_vmlinux(modname)) {
+	if (mod->is_vmlinux) {
 		have_vmlinux = 1;
 		mod->skip = 1;
 	}
 
-	if (!is_vmlinux(modname)) {
+	if (!mod->is_vmlinux) {
 		license = get_modinfo(&info, "license");
 		if (!license)
 			warn("missing MODULE_LICENSE() in %s\n", modname);
@@ -2075,7 +2076,7 @@ static void read_symbols(const char *modname)
 
 	check_sec_ref(mod, modname, &info);
 
-	if (!is_vmlinux(modname)) {
+	if (!mod->is_vmlinux) {
 		version = get_modinfo(&info, "version");
 		if (version || all_versions)
 			get_src_version(modname, mod->srcversion,
@@ -2345,7 +2346,7 @@ static void add_depends(struct buffer *b, struct module *mod)
 	/* Clear ->seen flag of modules that own symbols needed by this. */
 	for (s = mod->unres; s; s = s->next)
 		if (s->module)
-			s->module->seen = is_vmlinux(s->module->name);
+			s->module->seen = s->module->is_vmlinux;
 
 	buf_printf(b, "\n");
 	buf_printf(b, "MODULE_INFO(depends, \"");
@@ -2470,9 +2471,9 @@ static void read_dump(const char *fname)
 			goto fail;
 		mod = find_module(modname);
 		if (!mod) {
-			if (is_vmlinux(modname))
-				have_vmlinux = 1;
 			mod = new_module(modname);
+			if (mod->is_vmlinux)
+				have_vmlinux = 1;
 			mod->skip = 1;
 			mod->from_dump = 1;
 		}

commit 1be5fa6c948533bb95ac783010ef686261be5384
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:25 2020 +0900

    modpost: remove is_vmlinux() call in check_for_{gpl_usage,unused}()
    
    check_exports() is never called for vmlinux because mod->skip is set
    for vmlinux.
    
    Hence, check_for_gpl_usage() and check_for_unused() are not called
    for vmlinux, either. is_vmlinux() is always false here.
    
    Remove the is_vmlinux() calls, and hard-code the ".ko" suffix.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index bc00bbac50bb..84a642c14775 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2144,20 +2144,18 @@ void buf_write(struct buffer *buf, const char *s, int len)
 
 static void check_for_gpl_usage(enum export exp, const char *m, const char *s)
 {
-	const char *e = is_vmlinux(m) ?"":".ko";
-
 	switch (exp) {
 	case export_gpl:
-		fatal("GPL-incompatible module %s%s "
-		      "uses GPL-only symbol '%s'\n", m, e, s);
+		fatal("GPL-incompatible module %s.ko uses GPL-only symbol '%s'\n",
+		      m, s);
 		break;
 	case export_unused_gpl:
-		fatal("GPL-incompatible module %s%s "
-		      "uses GPL-only symbol marked UNUSED '%s'\n", m, e, s);
+		fatal("GPL-incompatible module %s.ko uses GPL-only symbol marked UNUSED '%s'\n",
+		      m, s);
 		break;
 	case export_gpl_future:
-		warn("GPL-incompatible module %s%s "
-		      "uses future GPL-only symbol '%s'\n", m, e, s);
+		warn("GPL-incompatible module %s.ko uses future GPL-only symbol '%s'\n",
+		     m, s);
 		break;
 	case export_plain:
 	case export_unused:
@@ -2169,13 +2167,11 @@ static void check_for_gpl_usage(enum export exp, const char *m, const char *s)
 
 static void check_for_unused(enum export exp, const char *m, const char *s)
 {
-	const char *e = is_vmlinux(m) ?"":".ko";
-
 	switch (exp) {
 	case export_unused:
 	case export_unused_gpl:
-		warn("module %s%s "
-		      "uses symbol '%s' marked UNUSED\n", m, e, s);
+		warn("module %s.ko uses symbol '%s' marked UNUSED\n",
+		     m, s);
 		break;
 	default:
 		/* ignore */

commit 3379576dd6e708f66498d49b4cec5f9b198791a0
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:24 2020 +0900

    modpost: remove mod->is_dot_o struct member
    
    Previously, there were two cases where mod->is_dot_o is unset:
    
    [1] the executable 'vmlinux' in the second pass of modpost
    [2] modules loaded by read_dump()
    
    I think [1] was intended usage to distinguish 'vmlinux.o' and 'vmlinux'.
    Now that modpost does not parse the executable 'vmlinux', this case
    does not happen.
    
    [2] is obscure, maybe a bug. Module.symver stores module paths without
    extension. So, none of modules loaded by read_dump() has the .o suffix,
    and new_module() unsets ->is_dot_o. Anyway, it is not a big deal because
    handle_symbol() is not called for the case.
    
    To sum up, all the parsed ELF files are .o files.
    
    mod->is_dot_o is unneeded.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b667f531a645..bc00bbac50bb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -182,10 +182,8 @@ static struct module *new_module(const char *modname)
 	p = NOFAIL(strdup(modname));
 
 	/* strip trailing .o */
-	if (strends(p, ".o")) {
+	if (strends(p, ".o"))
 		p[strlen(p) - 2] = '\0';
-		mod->is_dot_o = 1;
-	}
 
 	/* add to list */
 	mod->name = p;
@@ -716,8 +714,7 @@ static void handle_symbol(struct module *mod, struct elf_info *info,
 	enum export export;
 	const char *name;
 
-	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
-	    strstarts(symname, "__ksymtab"))
+	if (strstarts(symname, "__ksymtab"))
 		export = export_from_secname(info, get_secindex(info, sym));
 	else
 		export = export_from_sec(info, get_secindex(info, sym));
@@ -2676,13 +2673,6 @@ int main(int argc, char **argv)
 		struct symbol *s;
 
 		for (s = symbolhash[n]; s; s = s->next) {
-			/*
-			 * Do not check "vmlinux". This avoids the same warnings
-			 * shown twice, and false-positives for ARCH=um.
-			 */
-			if (is_vmlinux(s->module->name) && !s->module->is_dot_o)
-				continue;
-
 			if (s->is_static)
 				warn("\"%s\" [%s] is a static %s\n",
 				     s->name, s->module->name,

commit 467b82d7cee4373aa7bc47fd3043e2fa0a3440f5
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:22 2020 +0900

    modpost: remove -s option
    
    The -s option was added by commit 8d8d8289df65 ("kbuild: do not do
    section mismatch checks on vmlinux in 2nd pass").
    
    Now that the second pass does not parse vmlinux, this option is
    unneeded.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 93019349f022..b667f531a645 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -30,8 +30,6 @@ static int have_vmlinux = 0;
 static int all_versions = 0;
 /* If we are modposting external module set to 1 */
 static int external_module = 0;
-/* Warn about section mismatch in vmlinux if set to 1 */
-static int vmlinux_section_warnings = 1;
 /* Only warn about unresolved symbols */
 static int warn_unresolved = 0;
 /* How a symbol is exported */
@@ -2078,8 +2076,7 @@ static void read_symbols(const char *modname)
 		}
 	}
 
-	if (!is_vmlinux(modname) || vmlinux_section_warnings)
-		check_sec_ref(mod, modname, &info);
+	check_sec_ref(mod, modname, &info);
 
 	if (!is_vmlinux(modname)) {
 		version = get_modinfo(&info, "version");
@@ -2576,7 +2573,7 @@ int main(int argc, char **argv)
 	struct dump_list *dump_read_start = NULL;
 	struct dump_list **dump_read_iter = &dump_read_start;
 
-	while ((opt = getopt(argc, argv, "ei:mnsT:o:awENd:")) != -1) {
+	while ((opt = getopt(argc, argv, "ei:mnT:o:awENd:")) != -1) {
 		switch (opt) {
 		case 'e':
 			external_module = 1;
@@ -2599,9 +2596,6 @@ int main(int argc, char **argv)
 		case 'a':
 			all_versions = 1;
 			break;
-		case 's':
-			vmlinux_section_warnings = 0;
-			break;
 		case 'T':
 			files_source = optarg;
 			break;

commit 75893572d45399cefbb88443d0878adae9cb0b41
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:21 2020 +0900

    modpost: remove get_next_text() and make {grab,release_}file static
    
    get_next_line() is no longer used. Remove.
    
    grab_file() and release_file() are only used in modpost.c. Make them
    static.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4fdf992e9729..93019349f022 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -463,7 +463,7 @@ static void sym_set_crc(const char *name, unsigned int crc)
 	s->crc_valid = 1;
 }
 
-void *grab_file(const char *filename, unsigned long *size)
+static void *grab_file(const char *filename, unsigned long *size)
 {
 	struct stat st;
 	void *map = MAP_FAILED;
@@ -485,41 +485,7 @@ void *grab_file(const char *filename, unsigned long *size)
 	return map;
 }
 
-/**
-  * Return a copy of the next line in a mmap'ed file.
-  * spaces in the beginning of the line is trimmed away.
-  * Return a pointer to a static buffer.
-  **/
-char *get_next_line(unsigned long *pos, void *file, unsigned long size)
-{
-	static char line[4096];
-	int skip = 1;
-	size_t len = 0;
-	signed char *p = (signed char *)file + *pos;
-	char *s = line;
-
-	for (; *pos < size ; (*pos)++) {
-		if (skip && isspace(*p)) {
-			p++;
-			continue;
-		}
-		skip = 0;
-		if (*p != '\n' && (*pos < size)) {
-			len++;
-			*s++ = *p++;
-			if (len > 4095)
-				break; /* Too long, stop */
-		} else {
-			/* End of string */
-			*s = '\0';
-			return line;
-		}
-	}
-	/* End of buffer */
-	return NULL;
-}
-
-void release_file(void *file, unsigned long size)
+static void release_file(void *file, unsigned long size)
 {
 	munmap(file, size);
 }

commit 70f30cfe5b892fcb7f98e7df72ed6ccfe3225628
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:20 2020 +0900

    modpost: use read_text_file() and get_line() for reading text files
    
    grab_file() mmaps a file, but it is not so efficient here because
    get_next_line() copies every line to the temporary buffer anyway.
    
    read_text_file() and get_line() are simpler. get_line() exploits the
    library function strchr().
    
    Going forward, the missing *.symvers or *.cmd is a fatal error.
    This should not happen because scripts/Makefile.modpost guards the
    -i option files with $(wildcard $(input-symdump)).
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0a844902998e..4fdf992e9729 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2481,15 +2481,16 @@ static void write_if_changed(struct buffer *b, const char *fname)
  **/
 static void read_dump(const char *fname)
 {
-	unsigned long size, pos = 0;
-	void *file = grab_file(fname, &size);
-	char *line;
+	char *buf, *pos, *line;
 
-	if (!file)
+	buf = read_text_file(fname);
+	if (!buf)
 		/* No symbol versions, silently ignore */
 		return;
 
-	while ((line = get_next_line(&pos, file, size))) {
+	pos = buf;
+
+	while ((line = get_line(&pos))) {
 		char *symname, *namespace, *modname, *d, *export;
 		unsigned int crc;
 		struct module *mod;
@@ -2524,10 +2525,10 @@ static void read_dump(const char *fname)
 		sym_set_crc(symname, crc);
 		sym_update_namespace(symname, namespace);
 	}
-	release_file(file, size);
+	free(buf);
 	return;
 fail:
-	release_file(file, size);
+	free(buf);
 	fatal("parse error in symbol dump file\n");
 }
 

commit ac5100f54329676469688d1b5415cd8d6428c909
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:17 2020 +0900

    modpost: add read_text_file() and get_line() helpers
    
    modpost uses grab_file() to open a file, but it is not suitable for
    a text file because the mmap'ed file is not terminated by null byte.
    Actually, I see some issues for the use of grab_file().
    
    The new helper, read_text_file() loads the whole file content into a
    malloc'ed buffer, and appends a null byte. Then, get_line() reads
    each line.
    
    To handle text files, I intend to replace as follows:
    
      grab_file()    -> read_text_file()
      get_new_line() -> get_line()
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a5da633af700..0a844902998e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -112,6 +112,55 @@ void *do_nofail(void *ptr, const char *expr)
 	return ptr;
 }
 
+char *read_text_file(const char *filename)
+{
+	struct stat st;
+	size_t nbytes;
+	int fd;
+	char *buf;
+
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) {
+		perror(filename);
+		exit(1);
+	}
+
+	if (fstat(fd, &st) < 0) {
+		perror(filename);
+		exit(1);
+	}
+
+	buf = NOFAIL(malloc(st.st_size + 1));
+
+	nbytes = st.st_size;
+
+	while (nbytes) {
+		ssize_t bytes_read;
+
+		bytes_read = read(fd, buf, nbytes);
+		if (bytes_read < 0) {
+			perror(filename);
+			exit(1);
+		}
+
+		nbytes -= bytes_read;
+	}
+	buf[st.st_size] = '\0';
+
+	close(fd);
+
+	return buf;
+}
+
+char *get_line(char **stringp)
+{
+	/* do not return the unwanted extra line at EOF */
+	if (*stringp && **stringp == '\0')
+		return NULL;
+
+	return strsep(stringp, "\n");
+}
+
 /* A list of all modules we processed */
 static struct module *modules;
 

commit 4ddea2f8e825a86e94011ebc32eb1dce220b2316
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:16 2020 +0900

    modpost: do not call get_modinfo() for vmlinux(.o)
    
    The three calls of get_modinfo() ("license", "import_ns", "version")
    always return NULL for vmlinux(.o) because the built-in module info is
    prefixed with __MODULE_INFO_PREFIX.
    
    It is harmless to call get_modinfo(), but there is no point to search
    for what apparently does not exist.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index fbb3d3391e52..a5da633af700 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2006,25 +2006,26 @@ static void read_symbols(const char *modname)
 		mod->skip = 1;
 	}
 
-	license = get_modinfo(&info, "license");
-	if (!license && !is_vmlinux(modname))
-		warn("missing MODULE_LICENSE() in %s\n"
-		     "see include/linux/module.h for "
-		     "more information\n", modname);
-	while (license) {
-		if (license_is_gpl_compatible(license))
-			mod->gpl_compatible = 1;
-		else {
-			mod->gpl_compatible = 0;
-			break;
+	if (!is_vmlinux(modname)) {
+		license = get_modinfo(&info, "license");
+		if (!license)
+			warn("missing MODULE_LICENSE() in %s\n", modname);
+		while (license) {
+			if (license_is_gpl_compatible(license))
+				mod->gpl_compatible = 1;
+			else {
+				mod->gpl_compatible = 0;
+				break;
+			}
+			license = get_next_modinfo(&info, "license", license);
 		}
-		license = get_next_modinfo(&info, "license", license);
-	}
 
-	namespace = get_modinfo(&info, "import_ns");
-	while (namespace) {
-		add_namespace(&mod->imported_namespaces, namespace);
-		namespace = get_next_modinfo(&info, "import_ns", namespace);
+		namespace = get_modinfo(&info, "import_ns");
+		while (namespace) {
+			add_namespace(&mod->imported_namespaces, namespace);
+			namespace = get_next_modinfo(&info, "import_ns",
+						     namespace);
+		}
 	}
 
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
@@ -2065,10 +2066,12 @@ static void read_symbols(const char *modname)
 	if (!is_vmlinux(modname) || vmlinux_section_warnings)
 		check_sec_ref(mod, modname, &info);
 
-	version = get_modinfo(&info, "version");
-	if (version || (all_versions && !is_vmlinux(modname)))
-		get_src_version(modname, mod->srcversion,
-				sizeof(mod->srcversion)-1);
+	if (!is_vmlinux(modname)) {
+		version = get_modinfo(&info, "version");
+		if (version || all_versions)
+			get_src_version(modname, mod->srcversion,
+					sizeof(mod->srcversion) - 1);
+	}
 
 	parse_elf_finish(&info);
 

commit f693153519607449d3e270d9e6af20b032543c05
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:15 2020 +0900

    modpost: drop RCS/CVS $Revision handling in MODULE_VERSION()
    
    As far as I understood, this code gets rid of '$Revision$' or '$Revision:'
    of CVS, RCS or whatever in MODULE_VERSION() tags.
    
    Remove the primeval code.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3df26789c2e6..fbb3d3391e52 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2066,9 +2066,6 @@ static void read_symbols(const char *modname)
 		check_sec_ref(mod, modname, &info);
 
 	version = get_modinfo(&info, "version");
-	if (version)
-		maybe_frob_rcs_version(modname, version, info.modinfo,
-				       version - (char *)info.hdr);
 	if (version || (all_versions && !is_vmlinux(modname)))
 		get_src_version(modname, mod->srcversion,
 				sizeof(mod->srcversion)-1);

commit 7e8a3235823bcb779acf92de630edd5ddffaf886
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:13 2020 +0900

    modpost: show warning if vmlinux is not found when processing modules
    
    check_exports() does not print warnings about unresolved symbols if
    vmlinux is missing because there would be too many.
    
    This situation happens when you do 'make modules' from the clean
    tree, or compile external modules against a kernel tree that has
    not been completely built.
    
    It is dangerous to not check unresolved symbols because you might be
    building useless modules. At least it should be warned.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b839c48689df..3df26789c2e6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2001,8 +2001,6 @@ static void read_symbols(const char *modname)
 
 	mod = new_module(modname);
 
-	/* When there's no vmlinux, don't print warnings about
-	 * unresolved symbols (since there'll be too many ;) */
 	if (is_vmlinux(modname)) {
 		have_vmlinux = 1;
 		mod->skip = 1;
@@ -2623,6 +2621,13 @@ int main(int argc, char **argv)
 	if (files_source)
 		read_symbols_from_files(files_source);
 
+	/*
+	 * When there's no vmlinux, don't print warnings about
+	 * unresolved symbols (since there'll be too many ;)
+	 */
+	if (!have_vmlinux)
+		warn("Symbol info of vmlinux is missing. Unresolved symbol check will be entirely skipped.\n");
+
 	err = 0;
 
 	for (mod = modules; mod; mod = mod->next) {

commit 436b2ac603d58504f38041a0cd8adb5aeace992b
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:12 2020 +0900

    modpost: invoke modpost only when input files are updated
    
    Currently, the second pass of modpost is always invoked when you run
    'make' or 'make modules' even if none of modules is changed.
    
    Use if_changed to invoke it only when it is necessary.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4a2f27d97bf1..b839c48689df 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2375,6 +2375,25 @@ static void add_srcversion(struct buffer *b, struct module *mod)
 	}
 }
 
+static void write_buf(struct buffer *b, const char *fname)
+{
+	FILE *file;
+
+	file = fopen(fname, "w");
+	if (!file) {
+		perror(fname);
+		exit(1);
+	}
+	if (fwrite(b->p, 1, b->pos, file) != b->pos) {
+		perror(fname);
+		exit(1);
+	}
+	if (fclose(file) != 0) {
+		perror(fname);
+		exit(1);
+	}
+}
+
 static void write_if_changed(struct buffer *b, const char *fname)
 {
 	char *tmp;
@@ -2407,16 +2426,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
  close_write:
 	fclose(file);
  write:
-	file = fopen(fname, "w");
-	if (!file) {
-		perror(fname);
-		exit(1);
-	}
-	if (fwrite(b->p, 1, b->pos, file) != b->pos) {
-		perror(fname);
-		exit(1);
-	}
-	fclose(file);
+	write_buf(b, fname);
 }
 
 /* parse Module.symvers file. line format:
@@ -2508,7 +2518,7 @@ static void write_dump(const char *fname)
 			symbol = symbol->next;
 		}
 	}
-	write_if_changed(&buf, fname);
+	write_buf(&buf, fname);
 	free(buf.p);
 }
 

commit e3fb4df7fe4e8636de32a1e4ff5ebc75257f5570
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:08 2020 +0900

    modpost: re-add -e to set external_module flag
    
    Previously, the -i option had two functions; load a symbol dump file,
    and set the external_module flag.
    
    I want to assign a dedicate option for each of them.
    
    Going forward, the -i is used to load a symbol dump file, and the -e
    to set the external_module flag.
    
    With this, we will be able to use -i for loading in-kernel symbols.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b8e521f50b2d..4a2f27d97bf1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2552,10 +2552,12 @@ int main(int argc, char **argv)
 	struct dump_list *dump_read_start = NULL;
 	struct dump_list **dump_read_iter = &dump_read_start;
 
-	while ((opt = getopt(argc, argv, "i:mnsT:o:awENd:")) != -1) {
+	while ((opt = getopt(argc, argv, "ei:mnsT:o:awENd:")) != -1) {
 		switch (opt) {
-		case 'i':
+		case 'e':
 			external_module = 1;
+			break;
+		case 'i':
 			*dump_read_iter =
 				NOFAIL(calloc(1, sizeof(**dump_read_iter)));
 			(*dump_read_iter)->file = optarg;

commit 7924799ed2ddaa393c2ef0c4cd13a81d122bffde
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:07 2020 +0900

    modpost: rename ext_sym_list to dump_list
    
    The -i option is used to include Modules.symver as well as files from
    $(KBUILD_EXTRA_SYMBOLS).
    
    Make the struct and variable names more generic.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 28d8f5377c62..b8e521f50b2d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2535,8 +2535,8 @@ static void write_namespace_deps_files(const char *fname)
 	free(ns_deps_buf.p);
 }
 
-struct ext_sym_list {
-	struct ext_sym_list *next;
+struct dump_list {
+	struct dump_list *next;
 	const char *file;
 };
 
@@ -2549,16 +2549,17 @@ int main(int argc, char **argv)
 	int opt;
 	int err;
 	int n;
-	struct ext_sym_list *extsym_start = NULL;
-	struct ext_sym_list **extsym_iter = &extsym_start;
+	struct dump_list *dump_read_start = NULL;
+	struct dump_list **dump_read_iter = &dump_read_start;
 
 	while ((opt = getopt(argc, argv, "i:mnsT:o:awENd:")) != -1) {
 		switch (opt) {
 		case 'i':
 			external_module = 1;
-			*extsym_iter = NOFAIL(calloc(1, sizeof(**extsym_iter)));
-			(*extsym_iter)->file = optarg;
-			extsym_iter = &(*extsym_iter)->next;
+			*dump_read_iter =
+				NOFAIL(calloc(1, sizeof(**dump_read_iter)));
+			(*dump_read_iter)->file = optarg;
+			dump_read_iter = &(*dump_read_iter)->next;
 			break;
 		case 'm':
 			modversions = 1;
@@ -2595,13 +2596,13 @@ int main(int argc, char **argv)
 		}
 	}
 
-	while (extsym_start) {
-		struct ext_sym_list *tmp;
+	while (dump_read_start) {
+		struct dump_list *tmp;
 
-		read_dump(extsym_start->file);
-		tmp = extsym_start->next;
-		free(extsym_start);
-		extsym_start = tmp;
+		read_dump(dump_read_start->file);
+		tmp = dump_read_start->next;
+		free(dump_read_start);
+		dump_read_start = tmp;
 	}
 
 	while (optind < argc)

commit ce2ddd6d6ab3b343837d5c8e17538a5f67fa400e
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:06 2020 +0900

    modpost: allow to pass -i option multiple times to remove -e option
    
    Now that there is no difference between -i and -e, they can be unified.
    
    Make modpost accept the -i option multiple times, then remove -e.
    
    I will reuse -e for a different purpose.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 60f35b89cea2..28d8f5377c62 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2544,7 +2544,6 @@ int main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
-	char *kernel_read = NULL;
 	char *missing_namespace_deps = NULL;
 	char *dump_write = NULL, *files_source = NULL;
 	int opt;
@@ -2553,13 +2552,9 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_start = NULL;
 	struct ext_sym_list **extsym_iter = &extsym_start;
 
-	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awENd:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:mnsT:o:awENd:")) != -1) {
 		switch (opt) {
 		case 'i':
-			kernel_read = optarg;
-			external_module = 1;
-			break;
-		case 'e':
 			external_module = 1;
 			*extsym_iter = NOFAIL(calloc(1, sizeof(**extsym_iter)));
 			(*extsym_iter)->file = optarg;
@@ -2600,8 +2595,6 @@ int main(int argc, char **argv)
 		}
 	}
 
-	if (kernel_read)
-		read_dump(kernel_read);
 	while (extsym_start) {
 		struct ext_sym_list *tmp;
 

commit 52c3416db00d970c91a6992ab6e5ff48e077ad29
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:05 2020 +0900

    modpost: track if the symbol origin is a dump file or ELF object
    
    The meaning of sym->kernel is obscure; it is set for in-kernel symbols
    loaded from Modules.symvers. This happens only when we are building
    external modules, and it is used to determine whether to dump symbols
    to $(KBUILD_EXTMOD)/Modules.symvers
    
    It is clearer to remember whether the symbol or module came from a dump
    file or ELF object.
    
    This changes the KBUILD_EXTRA_SYMBOLS behavior. Previously, symbols
    loaded from KBUILD_EXTRA_SYMBOLS are accumulated into the current
    $(KBUILD_EXTMOD)/Modules.symvers
    
    Going forward, they will be only used to check symbol references, but
    not dumped into the current $(KBUILD_EXTMOD)/Modules.symvers. I believe
    this makes more sense.
    
    sym->vmlinux will have no user. Remove it too.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5224a02edbf2..60f35b89cea2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -161,9 +161,6 @@ struct symbol {
 	int crc_valid;
 	char *namespace;
 	unsigned int weak:1;
-	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
-	unsigned int kernel:1;     /* 1 if symbol is from kernel
-				    *  (only for external modules) **/
 	unsigned int is_static:1;  /* 1 if symbol is not global */
 	enum export  export;       /* Type of export */
 	char name[];
@@ -398,8 +395,6 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 	}
 
 	s->module = mod;
-	s->vmlinux   = is_vmlinux(mod->name);
-	s->kernel    = 0;
 	s->export    = export;
 	return s;
 }
@@ -2427,7 +2422,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
 /* parse Module.symvers file. line format:
  * 0x12345678<tab>symbol<tab>module<tab>export<tab>namespace
  **/
-static void read_dump(const char *fname, unsigned int kernel)
+static void read_dump(const char *fname)
 {
 	unsigned long size, pos = 0;
 	void *file = grab_file(fname, &size);
@@ -2465,9 +2460,9 @@ static void read_dump(const char *fname, unsigned int kernel)
 				have_vmlinux = 1;
 			mod = new_module(modname);
 			mod->skip = 1;
+			mod->from_dump = 1;
 		}
 		s = sym_add_exported(symname, mod, export_no(export));
-		s->kernel    = kernel;
 		s->is_static = 0;
 		sym_set_crc(symname, crc);
 		sym_update_namespace(symname, namespace);
@@ -2487,7 +2482,7 @@ static int dump_sym(struct symbol *sym)
 {
 	if (!external_module)
 		return 1;
-	if (sym->vmlinux || sym->kernel)
+	if (sym->module->from_dump)
 		return 0;
 	return 1;
 }
@@ -2606,11 +2601,11 @@ int main(int argc, char **argv)
 	}
 
 	if (kernel_read)
-		read_dump(kernel_read, 1);
+		read_dump(kernel_read);
 	while (extsym_start) {
 		struct ext_sym_list *tmp;
 
-		read_dump(extsym_start->file, 0);
+		read_dump(extsym_start->file);
 		tmp = extsym_start->next;
 		free(extsym_start);
 		extsym_start = tmp;

commit cb8e59cc87201af93dfbb6c3dccc8fcad72a09c2
Merge: 2e63f6ce7ed2 065fcfd49763
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 3 16:27:18 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next
    
    Pull networking updates from David Miller:
    
     1) Allow setting bluetooth L2CAP modes via socket option, from Luiz
        Augusto von Dentz.
    
     2) Add GSO partial support to igc, from Sasha Neftin.
    
     3) Several cleanups and improvements to r8169 from Heiner Kallweit.
    
     4) Add IF_OPER_TESTING link state and use it when ethtool triggers a
        device self-test. From Andrew Lunn.
    
     5) Start moving away from custom driver versions, use the globally
        defined kernel version instead, from Leon Romanovsky.
    
     6) Support GRO vis gro_cells in DSA layer, from Alexander Lobakin.
    
     7) Allow hard IRQ deferral during NAPI, from Eric Dumazet.
    
     8) Add sriov and vf support to hinic, from Luo bin.
    
     9) Support Media Redundancy Protocol (MRP) in the bridging code, from
        Horatiu Vultur.
    
    10) Support netmap in the nft_nat code, from Pablo Neira Ayuso.
    
    11) Allow UDPv6 encapsulation of ESP in the ipsec code, from Sabrina
        Dubroca. Also add ipv6 support for espintcp.
    
    12) Lots of ReST conversions of the networking documentation, from Mauro
        Carvalho Chehab.
    
    13) Support configuration of ethtool rxnfc flows in bcmgenet driver,
        from Doug Berger.
    
    14) Allow to dump cgroup id and filter by it in inet_diag code, from
        Dmitry Yakunin.
    
    15) Add infrastructure to export netlink attribute policies to
        userspace, from Johannes Berg.
    
    16) Several optimizations to sch_fq scheduler, from Eric Dumazet.
    
    17) Fallback to the default qdisc if qdisc init fails because otherwise
        a packet scheduler init failure will make a device inoperative. From
        Jesper Dangaard Brouer.
    
    18) Several RISCV bpf jit optimizations, from Luke Nelson.
    
    19) Correct the return type of the ->ndo_start_xmit() method in several
        drivers, it's netdev_tx_t but many drivers were using
        'int'. From Yunjian Wang.
    
    20) Add an ethtool interface for PHY master/slave config, from Oleksij
        Rempel.
    
    21) Add BPF iterators, from Yonghang Song.
    
    22) Add cable test infrastructure, including ethool interfaces, from
        Andrew Lunn. Marvell PHY driver is the first to support this
        facility.
    
    23) Remove zero-length arrays all over, from Gustavo A. R. Silva.
    
    24) Calculate and maintain an explicit frame size in XDP, from Jesper
        Dangaard Brouer.
    
    25) Add CAP_BPF, from Alexei Starovoitov.
    
    26) Support terse dumps in the packet scheduler, from Vlad Buslov.
    
    27) Support XDP_TX bulking in dpaa2 driver, from Ioana Ciornei.
    
    28) Add devm_register_netdev(), from Bartosz Golaszewski.
    
    29) Minimize qdisc resets, from Cong Wang.
    
    30) Get rid of kernel_getsockopt and kernel_setsockopt in order to
        eliminate set_fs/get_fs calls. From Christoph Hellwig.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next: (2517 commits)
      selftests: net: ip_defrag: ignore EPERM
      net_failover: fixed rollback in net_failover_open()
      Revert "tipc: Fix potential tipc_aead refcnt leak in tipc_crypto_rcv"
      Revert "tipc: Fix potential tipc_node refcnt leak in tipc_rcv"
      vmxnet3: allow rx flow hash ops only when rss is enabled
      hinic: add set_channels ethtool_ops support
      selftests/bpf: Add a default $(CXX) value
      tools/bpf: Don't use $(COMPILE.c)
      bpf, selftests: Use bpf_probe_read_kernel
      s390/bpf: Use bcr 0,%0 as tail call nop filler
      s390/bpf: Maintain 8-byte stack alignment
      selftests/bpf: Fix verifier test
      selftests/bpf: Fix sample_cnt shared between two threads
      bpf, selftests: Adapt cls_redirect to call csum_level helper
      bpf: Add csum_level helper for fixing up csum levels
      bpf: Fix up bpf_skb_adjust_room helper's skb csum setting
      sfc: add missing annotation for efx_ef10_try_update_nic_stats_vf()
      crypto/chtls: IPv6 support for inline TLS
      Crypto/chcr: Fixes a coccinile check error
      Crypto/chcr: Fixes compilations warnings
      ...

commit 2beee868997485a5718a349c7868260d5ee7378f
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon Jun 1 14:57:04 2020 +0900

    modpost: load KBUILD_EXTRA_SYMBOLS files in order
    
    Currently, modpost reads extra symbol dump files in the reverse order.
    If '-e foo -e bar' is given, modpost reads bar, foo, in this order.
    
    This is probably not a big deal, but there is no good reason to reverse
    the order. Read files in the given order.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 160139508821..5224a02edbf2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2555,8 +2555,8 @@ int main(int argc, char **argv)
 	int opt;
 	int err;
 	int n;
-	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
+	struct ext_sym_list **extsym_iter = &extsym_start;
 
 	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awENd:")) != -1) {
 		switch (opt) {
@@ -2566,11 +2566,9 @@ int main(int argc, char **argv)
 			break;
 		case 'e':
 			external_module = 1;
-			extsym_iter =
-			   NOFAIL(malloc(sizeof(*extsym_iter)));
-			extsym_iter->next = extsym_start;
-			extsym_iter->file = optarg;
-			extsym_start = extsym_iter;
+			*extsym_iter = NOFAIL(calloc(1, sizeof(**extsym_iter)));
+			(*extsym_iter)->file = optarg;
+			extsym_iter = &(*extsym_iter)->next;
 			break;
 		case 'm':
 			modversions = 1;
@@ -2610,10 +2608,12 @@ int main(int argc, char **argv)
 	if (kernel_read)
 		read_dump(kernel_read, 1);
 	while (extsym_start) {
+		struct ext_sym_list *tmp;
+
 		read_dump(extsym_start->file, 0);
-		extsym_iter = extsym_start->next;
+		tmp = extsym_start->next;
 		free(extsym_start);
-		extsym_start = extsym_iter;
+		extsym_start = tmp;
 	}
 
 	while (optind < argc)

commit 565587d8d5b518234652063820561587fc269c11
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon May 25 14:47:05 2020 +0900

    modpost: refactor sech_name()
    
    Use sym_get_data_by_offset() helper to get access to the .shstrtab
    section data. No functional change is intended because
    elf->sechdrs[elf->secindex_strings].sh_addr is 0 for both ET_REL
    and ET_EXEC object types.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8c5f1bd75481..160139508821 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -288,18 +288,6 @@ static enum export export_no(const char *s)
 	return export_unknown;
 }
 
-static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
-{
-	return (void *)elf->hdr +
-		elf->sechdrs[elf->secindex_strings].sh_offset +
-		sechdr->sh_name;
-}
-
-static const char *sec_name(struct elf_info *elf, int secindex)
-{
-	return sech_name(elf, &elf->sechdrs[secindex]);
-}
-
 static void *sym_get_data_by_offset(const struct elf_info *info,
 				    unsigned int secindex, unsigned long offset)
 {
@@ -317,6 +305,17 @@ static void *sym_get_data(const struct elf_info *info, const Elf_Sym *sym)
 				      sym->st_value);
 }
 
+static const char *sech_name(const struct elf_info *info, Elf_Shdr *sechdr)
+{
+	return sym_get_data_by_offset(info, info->secindex_strings,
+				      sechdr->sh_name);
+}
+
+static const char *sec_name(const struct elf_info *info, int secindex)
+{
+	return sech_name(info, &info->sechdrs[secindex]);
+}
+
 #define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)
 
 static enum export export_from_secname(struct elf_info *elf, unsigned int sec)

commit d2e4d05cf1a1f8bfe168ea29b217355be7a4e9ec
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Mon May 25 14:47:04 2020 +0900

    modpost: fix potential segmentation fault for addend_i386_rel()
    
    This may not be a practical problem, but the second pass of ARCH=i386
    modpost causes segmentation fault if the -s option is not passed.
    
        MODPOST 12 modules
      Segmentation fault (core dumped)
      make[2]: *** [scripts/Makefile.modpost:94: __modpost] Error 139
      make[1]: *** [Makefile:1339: modules] Error 2
      make[1]: *** Waiting for unfinished jobs....
    
    The segmentation fault occurs when section_rel() is called for vmlinux,
    which is untested in regular builds. The cause of the problem is
    reloc_location() returning a wrong pointer for ET_EXEC object type.
    In this case, you need to subtract sechdr->sh_addr, otherwise it would
    get access beyond the mmap'ed memory.
    
    Add sym_get_data_by_offset() helper to avoid code duplication.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4d4b979d76be..8c5f1bd75481 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -300,19 +300,23 @@ static const char *sec_name(struct elf_info *elf, int secindex)
 	return sech_name(elf, &elf->sechdrs[secindex]);
 }
 
-static void *sym_get_data(const struct elf_info *info, const Elf_Sym *sym)
+static void *sym_get_data_by_offset(const struct elf_info *info,
+				    unsigned int secindex, unsigned long offset)
 {
-	unsigned int secindex = get_secindex(info, sym);
 	Elf_Shdr *sechdr = &info->sechdrs[secindex];
-	unsigned long offset;
 
-	offset = sym->st_value;
 	if (info->hdr->e_type != ET_REL)
 		offset -= sechdr->sh_addr;
 
 	return (void *)info->hdr + sechdr->sh_offset + offset;
 }
 
+static void *sym_get_data(const struct elf_info *info, const Elf_Sym *sym)
+{
+	return sym_get_data_by_offset(info, get_secindex(info, sym),
+				      sym->st_value);
+}
+
 #define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)
 
 static enum export export_from_secname(struct elf_info *elf, unsigned int sec)
@@ -1752,11 +1756,7 @@ static void check_section_mismatch(const char *modname, struct elf_info *elf,
 static unsigned int *reloc_location(struct elf_info *elf,
 				    Elf_Shdr *sechdr, Elf_Rela *r)
 {
-	Elf_Shdr *sechdrs = elf->sechdrs;
-	int section = sechdr->sh_info;
-
-	return (void *)elf->hdr + sechdrs[section].sh_offset +
-		r->r_offset;
+	return sym_get_data_by_offset(elf, sechdr->sh_info, r->r_offset);
 }
 
 static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)

commit 859c81750130844590a83eff847c6c55e2340ab1
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 13:56:01 2020 -0500

    modpost,fixdep: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5c3c50c5ec52..4d4b979d76be 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -166,7 +166,7 @@ struct symbol {
 				    *  (only for external modules) **/
 	unsigned int is_static:1;  /* 1 if symbol is not global */
 	enum export  export;       /* Type of export */
-	char name[0];
+	char name[];
 };
 
 static struct symbol *symbolhash[SYMBOL_HASH_SIZE];

commit 6553896666433e7efec589838b400a2a652b3ffa
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 9 22:47:17 2020 +0100

    vmlinux.lds.h: Create section for protection against instrumentation
    
    Some code pathes, especially the low level entry code, must be protected
    against instrumentation for various reasons:
    
     - Low level entry code can be a fragile beast, especially on x86.
    
     - With NO_HZ_FULL RCU state needs to be established before using it.
    
    Having a dedicated section for such code allows to validate with tooling
    that no unsafe functions are invoked.
    
    Add the .noinstr.text section and the noinstr attribute to mark
    functions. noinstr implies notrace. Kprobes will gain a section check
    later.
    
    Provide also a set of markers: instrumentation_begin()/end()
    
    These are used to mark code inside a noinstr function which calls
    into regular instrumentable text section as safe.
    
    The instrumentation markers are only active when CONFIG_DEBUG_ENTRY is
    enabled as the end marker emits a NOP to prevent the compiler from merging
    the annotation points. This means the objtool verification requires a
    kernel compiled with this option.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200505134100.075416272@linutronix.de

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5c3c50c5ec52..0053d4fea847 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -948,7 +948,7 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 #define DATA_SECTIONS ".data", ".data.rel"
 #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
-		".kprobes.text", ".cpuidle.text"
+		".kprobes.text", ".cpuidle.text", ".noinstr.text"
 #define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
 		".fixup", ".entry.text", ".exception.text", ".text.*", \
 		".coldtext"

commit 51161bfc66a68d21f13d15a689b3ea7980457790
Author: Leon Romanovsky <leonro@mellanox.com>
Date:   Sun Apr 19 18:55:06 2020 +0300

    kernel/module: Hide vermagic header file from general use
    
    VERMAGIC* definitions are not supposed to be used by the drivers,
    see this [1] bug report, so introduce special define to guard inclusion
    of this header file and define it in kernel/modules.h and in internal
    script that generates *.mod.c files.
    
    In-tree module build:
      kernel git:(vermagic)  make clean
      kernel git:(vermagic)  make M=drivers/infiniband/hw/mlx5
      kernel git:(vermagic)  modinfo drivers/infiniband/hw/mlx5/mlx5_ib.ko
    filename:       /images/leonro/src/kernel/drivers/infiniband/hw/mlx5/mlx5_ib.ko
    <...>
    vermagic:       5.6.0+ SMP mod_unload modversions
    
    Out-of-tree module build:
      mlx5 make -C /images/leonro/src/kernel clean M=/tmp/mlx5
      mlx5 make -C /images/leonro/src/kernel M=/tmp/mlx5
      mlx5 modinfo /tmp/mlx5/mlx5_ib.ko
    filename:       /tmp/mlx5/mlx5_ib.ko
    <...>
    vermagic:       5.6.0+ SMP mod_unload modversions
    
    [1] https://lore.kernel.org/lkml/20200411155623.GA22175@zn.tnic
    Reported-by: Borislav Petkov <bp@suse.de>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Jessica Yu <jeyu@kernel.org>
    Co-developed-by: Masahiro Yamada <masahiroy@kernel.org>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5c3c50c5ec52..7f7d4ee7b652 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2251,6 +2251,7 @@ static void add_header(struct buffer *b, struct module *mod)
 	 * Include build-salt.h after module.h in order to
 	 * inherit the definitions.
 	 */
+	buf_printf(b, "#define INCLUDE_VERMAGIC\n");
 	buf_printf(b, "#include <linux/build-salt.h>\n");
 	buf_printf(b, "#include <linux/vermagic.h>\n");
 	buf_printf(b, "#include <linux/compiler.h>\n");

commit 5b67fbfc32b544daa7f4e0f4e0ecdec4e4895938
Merge: a16298439bd5 e51d8dacf272
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 31 16:03:39 2020 -0700

    Merge tag 'kbuild-v5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild
    
    Pull Kbuild updates from Masahiro Yamada:
     "Build system:
    
       - add CONFIG_UNUSED_KSYMS_WHITELIST, which will be useful to define a
         fixed set of export symbols for Generic Kernel Image (GKI)
    
       - allow to run 'make dt_binding_check' without .config
    
       - use full schema for checking DT examples in *.yaml files
    
       - make modpost fail for missing MODULE_IMPORT_NS(), which makes more
         sense because we know the produced modules are never loadable
    
       - Remove unused 'AS' variable
    
      Kconfig:
    
       - sanitize DEFCONFIG_LIST, and remove ARCH_DEFCONFIG from Kconfig
         files
    
       - relax the 'imply' behavior so that symbols implied by 'y' can
         become 'm'
    
       - make 'imply' obey 'depends on' in order to make 'imply' really weak
    
      Misc:
    
       - add documentation on building the kernel with Clang/LLVM
    
       - revive __HAVE_ARCH_STRLEN for 32bit sparc to use optimized strlen()
    
       - fix warning from deb-pkg builds when CONFIG_DEBUG_INFO=n
    
       - various script and Makefile cleanups"
    
    * tag 'kbuild-v5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/masahiroy/linux-kbuild: (34 commits)
      Makefile: Update kselftest help information
      kbuild: deb-pkg: fix warning when CONFIG_DEBUG_INFO is unset
      kbuild: add outputmakefile to no-dot-config-targets
      kbuild: remove AS variable
      net: wan: wanxl: refactor the firmware rebuild rule
      net: wan: wanxl: use $(M68KCC) instead of $(M68KAS) for rebuilding firmware
      net: wan: wanxl: use allow to pass CROSS_COMPILE_M68k for rebuilding firmware
      kbuild: add comment about grouped target
      kbuild: add -Wall to KBUILD_HOSTCXXFLAGS
      kconfig: remove unused variable in qconf.cc
      sparc: revive __HAVE_ARCH_STRLEN for 32bit sparc
      kbuild: refactor Makefile.dtbinst more
      kbuild: compute the dtbs_install destination more simply
      Makefile: disallow data races on gcc-10 as well
      kconfig: make 'imply' obey the direct dependency
      kconfig: allow symbols implied by y to become m
      net: drop_monitor: use IS_REACHABLE() to guard net_dm_hw_report()
      modpost: return error if module is missing ns imports and MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS=n
      modpost: rework and consolidate logging interface
      kbuild: allow to run dt_binding_check without kernel configuration
      ...

commit dbb381b619aa5242c9cb1a8fd54d71c4d79c91eb
Merge: 336622e9fce7 4479730e9263
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 18:51:47 2020 -0700

    Merge tag 'timers-core-2020-03-30' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timekeeping and timer updates from Thomas Gleixner:
     "Core:
    
       - Consolidation of the vDSO build infrastructure to address the
         difficulties of cross-builds for ARM64 compat vDSO libraries by
         restricting the exposure of header content to the vDSO build.
    
         This is achieved by splitting out header content into separate
         headers. which contain only the minimaly required information which
         is necessary to build the vDSO. These new headers are included from
         the kernel headers and the vDSO specific files.
    
       - Enhancements to the generic vDSO library allowing more fine grained
         control over the compiled in code, further reducing architecture
         specific storage and preparing for adopting the generic library by
         PPC.
    
       - Cleanup and consolidation of the exit related code in posix CPU
         timers.
    
       - Small cleanups and enhancements here and there
    
      Drivers:
    
       - The obligatory new drivers: Ingenic JZ47xx and X1000 TCU support
    
       - Correct the clock rate of PIT64b global clock
    
       - setup_irq() cleanup
    
       - Preparation for PWM and suspend support for the TI DM timer
    
       - Expand the fttmr010 driver to support ast2600 systems
    
       - The usual small fixes, enhancements and cleanups all over the
         place"
    
    * tag 'timers-core-2020-03-30' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (80 commits)
      Revert "clocksource/drivers/timer-probe: Avoid creating dead devices"
      vdso: Fix clocksource.h macro detection
      um: Fix header inclusion
      arm64: vdso32: Enable Clang Compilation
      lib/vdso: Enable common headers
      arm: vdso: Enable arm to use common headers
      x86/vdso: Enable x86 to use common headers
      mips: vdso: Enable mips to use common headers
      arm64: vdso32: Include common headers in the vdso library
      arm64: vdso: Include common headers in the vdso library
      arm64: Introduce asm/vdso/processor.h
      arm64: vdso32: Code clean up
      linux/elfnote.h: Replace elf.h with UAPI equivalent
      scripts: Fix the inclusion order in modpost
      common: Introduce processor.h
      linux/ktime.h: Extract common header for vDSO
      linux/jiffies.h: Extract common header for vDSO
      linux/time64.h: Extract common header for vDSO
      linux/time32.h: Extract common header for vDSO
      linux/time.h: Extract common header for vDSO
      ...

commit f58dd03b1157bdf3b64c36e9525f8d7f69c25df2
Author: Vincenzo Frascino <vincenzo.frascino@arm.com>
Date:   Fri Mar 20 14:53:41 2020 +0000

    scripts: Fix the inclusion order in modpost
    
    In the process of creating the source file of a module modpost injects a
    set of includes that are not required if the compilation unit is
    statically built into the kernel.
    
    The order of inclusion of the headers can cause redefinition problems
    (e.g.):
    
       In file included from include/linux/elf.h:5:0,
                        from include/linux/module.h:18,
                        from crypto/arc4.mod.c:2:
        #define ELF_OSABI  ELFOSABI_LINUX
    
       In file included from include/linux/elfnote.h:62:0,
                        from include/linux/build-salt.h:4,
                        from crypto/arc4.mod.c:1:
       include/uapi/linux/elf.h:363:0: note: this is the location of
       the previous definition
        #define ELF_OSABI ELFOSABI_NONE
    
    The issue was exposed during the development of the series [1].
    
    [1] https://lore.kernel.org/lkml/20200306133242.26279-1-vincenzo.frascino@arm.com/
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Vincenzo Frascino <vincenzo.frascino@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Masahiro Yamada <masahiroy@kernel.org>
    Cc: Michal Marek <michal.lkml@markovi.net>
    Link: https://lkml.kernel.org/r/20200320145351.32292-17-vincenzo.frascino@arm.com

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7edfdb2f4497..0f354b1ee2aa 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2251,8 +2251,12 @@ static int check_modname_len(struct module *mod)
  **/
 static void add_header(struct buffer *b, struct module *mod)
 {
-	buf_printf(b, "#include <linux/build-salt.h>\n");
 	buf_printf(b, "#include <linux/module.h>\n");
+	/*
+	 * Include build-salt.h after module.h in order to
+	 * inherit the definitions.
+	 */
+	buf_printf(b, "#include <linux/build-salt.h>\n");
 	buf_printf(b, "#include <linux/vermagic.h>\n");
 	buf_printf(b, "#include <linux/compiler.h>\n");
 	buf_printf(b, "\n");

commit 4b8a5cfb5fd375cf4c7502a18f0096ed2881be27
Author: Xiao Yang <yangx.jy@cn.fujitsu.com>
Date:   Wed Mar 18 18:34:16 2020 +0800

    modpost: Get proper section index by get_secindex() instead of st_shndx
    
    (uint16_t) st_shndx is limited to 65535(i.e. SHN_XINDEX) so sym_get_data() gets
    wrong section index by st_shndx if requested symbol contains extended section
    index that is more than 65535.  In this case, we need to get proper section index
    by .symtab_shndx section.
    
    Module.symvers generated by building kernel with "-ffunction-sections -fdata-sections"
    shows the issue.
    
    Fixes: 56067812d5b0 ("kbuild: modversions: add infrastructure for emitting relative CRCs")
    Fixes: e84f9fbbece1 ("modpost: refactor namespace_from_kstrtabns() to not hard-code section name")
    Signed-off-by: Xiao Yang <yangx.jy@cn.fujitsu.com>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6ab235354f36..55a0a2eccbd2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -308,7 +308,8 @@ static const char *sec_name(struct elf_info *elf, int secindex)
 
 static void *sym_get_data(const struct elf_info *info, const Elf_Sym *sym)
 {
-	Elf_Shdr *sechdr = &info->sechdrs[sym->st_shndx];
+	unsigned int secindex = get_secindex(info, sym);
+	Elf_Shdr *sechdr = &info->sechdrs[secindex];
 	unsigned long offset;
 
 	offset = sym->st_value;

commit 5190044c2965514a973184ca68ef5fad57a24670
Author: Jessica Yu <jeyu@kernel.org>
Date:   Wed Mar 11 18:01:20 2020 +0100

    modpost: move the namespace field in Module.symvers last
    
    In order to preserve backwards compatability with kmod tools, we have to
    move the namespace field in Module.symvers last, as the depmod -e -E
    option looks at the first three fields in Module.symvers to check symbol
    versions (and it's expected they stay in the original order of crc,
    symbol, module).
    
    In addition, update an ancient comment above read_dump() in modpost that
    suggested that the export type field in Module.symvers was optional. I
    suspect that there were historical reasons behind that comment that are
    no longer accurate. We have been unconditionally printing the export
    type since 2.6.18 (commit bd5cbcedf44), which is over a decade ago now.
    
    Fix up read_dump() to treat each field as non-optional. I suspect the
    original read_dump() code treated the export field as optional in order
    to support pre <= 2.6.18 Module.symvers (which did not have the export
    type field). Note that although symbol namespaces are optional, the
    field will not be omitted from Module.symvers if a symbol does not have
    a namespace. In this case, the field will simply be empty and the next
    delimiter or end of line will follow.
    
    Cc: stable@vger.kernel.org
    Fixes: cb9b55d21fe0 ("modpost: add support for symbol namespaces")
    Tested-by: Matthias Maennich <maennich@google.com>
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7edfdb2f4497..6ab235354f36 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2427,7 +2427,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
 }
 
 /* parse Module.symvers file. line format:
- * 0x12345678<tab>symbol<tab>module[[<tab>export]<tab>something]
+ * 0x12345678<tab>symbol<tab>module<tab>export<tab>namespace
  **/
 static void read_dump(const char *fname, unsigned int kernel)
 {
@@ -2440,7 +2440,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		return;
 
 	while ((line = get_next_line(&pos, file, size))) {
-		char *symname, *namespace, *modname, *d, *export, *end;
+		char *symname, *namespace, *modname, *d, *export;
 		unsigned int crc;
 		struct module *mod;
 		struct symbol *s;
@@ -2448,16 +2448,16 @@ static void read_dump(const char *fname, unsigned int kernel)
 		if (!(symname = strchr(line, '\t')))
 			goto fail;
 		*symname++ = '\0';
-		if (!(namespace = strchr(symname, '\t')))
-			goto fail;
-		*namespace++ = '\0';
-		if (!(modname = strchr(namespace, '\t')))
+		if (!(modname = strchr(symname, '\t')))
 			goto fail;
 		*modname++ = '\0';
-		if ((export = strchr(modname, '\t')) != NULL)
-			*export++ = '\0';
-		if (export && ((end = strchr(export, '\t')) != NULL))
-			*end = '\0';
+		if (!(export = strchr(modname, '\t')))
+			goto fail;
+		*export++ = '\0';
+		if (!(namespace = strchr(export, '\t')))
+			goto fail;
+		*namespace++ = '\0';
+
 		crc = strtoul(line, &d, 16);
 		if (*symname == '\0' || *modname == '\0' || *d != '\0')
 			goto fail;
@@ -2508,9 +2508,9 @@ static void write_dump(const char *fname)
 				namespace = symbol->namespace;
 				buf_printf(&buf, "0x%08x\t%s\t%s\t%s\t%s\n",
 					   symbol->crc, symbol->name,
-					   namespace ? namespace : "",
 					   symbol->module->name,
-					   export_str(symbol->export));
+					   export_str(symbol->export),
+					   namespace ? namespace : "");
 			}
 			symbol = symbol->next;
 		}

commit 54b778476941c768ef749803167dd21385c01038
Author: Jessica Yu <jeyu@kernel.org>
Date:   Fri Mar 6 17:02:06 2020 +0100

    modpost: return error if module is missing ns imports and MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS=n
    
    Currently when CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS=n, modpost
    only warns when a module is missing namespace imports. Under this
    configuration, such a module cannot be loaded into the kernel anyway, as
    the module loader would reject it. We might as well return a build
    error when a module is missing namespace imports under
    CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS=n, so that the build
    warning does not go ignored/unnoticed.
    
    Signed-off-by: Jessica Yu <jeyu@kernel.org>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a6f7b309ac45..a3d8370f9544 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -39,6 +39,8 @@ static int sec_mismatch_count = 0;
 static int sec_mismatch_fatal = 0;
 /* ignore missing files */
 static int ignore_missing_files;
+/* If set to 1, only warn (instead of error) about missing ns imports */
+static int allow_missing_ns_imports;
 
 enum export {
 	export_plain,      export_unused,     export_gpl,
@@ -2205,8 +2207,11 @@ static int check_exports(struct module *mod)
 
 		if (exp->namespace &&
 		    !module_imports_namespace(mod, exp->namespace)) {
-			warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
-			     basename, exp->name, exp->namespace);
+			modpost_log(allow_missing_ns_imports ? LOG_WARN : LOG_ERROR,
+				    "module %s uses symbol %s from namespace %s, but does not import it.\n",
+				    basename, exp->name, exp->namespace);
+			if (!allow_missing_ns_imports)
+				err = 1;
 			add_namespace(&mod->missing_namespaces, exp->namespace);
 		}
 
@@ -2549,7 +2554,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awEd:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awENd:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2587,6 +2592,9 @@ int main(int argc, char **argv)
 		case 'E':
 			sec_mismatch_fatal = 1;
 			break;
+		case 'N':
+			allow_missing_ns_imports = 1;
+			break;
 		case 'd':
 			missing_namespace_deps = optarg;
 			break;

commit 93c95e526a4ef00eb3d5a1e0920ba5a22f32e40d
Author: Jessica Yu <jeyu@kernel.org>
Date:   Fri Mar 6 17:02:05 2020 +0100

    modpost: rework and consolidate logging interface
    
    Rework modpost's logging interface by consolidating merror(), warn(), and
    fatal() to use a single function, modpost_log(). Introduce different
    logging levels (WARN, ERROR, FATAL) as well. The purpose of this cleanup is
    to reduce code duplication when deciding whether or not to warn or error
    out based on a condition.
    
    Signed-off-by: Jessica Yu <jeyu@kernel.org>
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7edfdb2f4497..a6f7b309ac45 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -51,41 +51,33 @@ enum export {
 
 #define MODULE_NAME_LEN (64 - sizeof(Elf_Addr))
 
-#define PRINTF __attribute__ ((format (printf, 1, 2)))
-
-PRINTF void fatal(const char *fmt, ...)
+void __attribute__((format(printf, 2, 3)))
+modpost_log(enum loglevel loglevel, const char *fmt, ...)
 {
 	va_list arglist;
 
-	fprintf(stderr, "FATAL: ");
-
-	va_start(arglist, fmt);
-	vfprintf(stderr, fmt, arglist);
-	va_end(arglist);
-
-	exit(1);
-}
-
-PRINTF void warn(const char *fmt, ...)
-{
-	va_list arglist;
+	switch (loglevel) {
+	case LOG_WARN:
+		fprintf(stderr, "WARNING: ");
+		break;
+	case LOG_ERROR:
+		fprintf(stderr, "ERROR: ");
+		break;
+	case LOG_FATAL:
+		fprintf(stderr, "FATAL: ");
+		break;
+	default: /* invalid loglevel, ignore */
+		break;
+	}
 
-	fprintf(stderr, "WARNING: ");
+	fprintf(stderr, "modpost: ");
 
 	va_start(arglist, fmt);
 	vfprintf(stderr, fmt, arglist);
 	va_end(arglist);
-}
-
-PRINTF void merror(const char *fmt, ...)
-{
-	va_list arglist;
-
-	fprintf(stderr, "ERROR: ");
 
-	va_start(arglist, fmt);
-	vfprintf(stderr, fmt, arglist);
-	va_end(arglist);
+	if (loglevel == LOG_FATAL)
+		exit(1);
 }
 
 static inline bool strends(const char *str, const char *postfix)
@@ -113,7 +105,7 @@ static int is_vmlinux(const char *modname)
 void *do_nofail(void *ptr, const char *expr)
 {
 	if (!ptr)
-		fatal("modpost: Memory allocation failure: %s.\n", expr);
+		fatal("Memory allocation failure: %s.\n", expr);
 
 	return ptr;
 }
@@ -2021,7 +2013,7 @@ static void read_symbols(const char *modname)
 
 	license = get_modinfo(&info, "license");
 	if (!license && !is_vmlinux(modname))
-		warn("modpost: missing MODULE_LICENSE() in %s\n"
+		warn("missing MODULE_LICENSE() in %s\n"
 		     "see include/linux/module.h for "
 		     "more information\n", modname);
 	while (license) {
@@ -2152,15 +2144,15 @@ static void check_for_gpl_usage(enum export exp, const char *m, const char *s)
 
 	switch (exp) {
 	case export_gpl:
-		fatal("modpost: GPL-incompatible module %s%s "
+		fatal("GPL-incompatible module %s%s "
 		      "uses GPL-only symbol '%s'\n", m, e, s);
 		break;
 	case export_unused_gpl:
-		fatal("modpost: GPL-incompatible module %s%s "
+		fatal("GPL-incompatible module %s%s "
 		      "uses GPL-only symbol marked UNUSED '%s'\n", m, e, s);
 		break;
 	case export_gpl_future:
-		warn("modpost: GPL-incompatible module %s%s "
+		warn("GPL-incompatible module %s%s "
 		      "uses future GPL-only symbol '%s'\n", m, e, s);
 		break;
 	case export_plain:
@@ -2178,7 +2170,7 @@ static void check_for_unused(enum export exp, const char *m, const char *s)
 	switch (exp) {
 	case export_unused:
 	case export_unused_gpl:
-		warn("modpost: module %s%s "
+		warn("module %s%s "
 		      "uses symbol '%s' marked UNUSED\n", m, e, s);
 		break;
 	default:
@@ -2197,14 +2189,11 @@ static int check_exports(struct module *mod)
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
 			if (have_vmlinux && !s->weak) {
-				if (warn_unresolved) {
-					warn("\"%s\" [%s.ko] undefined!\n",
-					     s->name, mod->name);
-				} else {
-					merror("\"%s\" [%s.ko] undefined!\n",
-					       s->name, mod->name);
+				modpost_log(warn_unresolved ? LOG_WARN : LOG_ERROR,
+					    "\"%s\" [%s.ko] undefined!\n",
+					    s->name, mod->name);
+				if (!warn_unresolved)
 					err = 1;
-				}
 			}
 			continue;
 		}
@@ -2653,7 +2642,7 @@ int main(int argc, char **argv)
 	if (dump_write)
 		write_dump(dump_write);
 	if (sec_mismatch_count && sec_mismatch_fatal)
-		fatal("modpost: Section mismatches detected.\n"
+		fatal("Section mismatches detected.\n"
 		      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
 	for (n = 0; n < SYMBOL_HASH_SIZE; n++) {
 		struct symbol *s;

commit 5370d4acc590e5992ca4a1b9f606714fad69e88a
Author: Masahiro Yamada <masahiroy@kernel.org>
Date:   Sun Jan 5 00:36:51 2020 +0900

    modpost: assume STT_SPARC_REGISTER is defined
    
    Commit 8d5290149ee1 ("[SPARC]: Deal with glibc changing macro names in
    modpost.c") was more than 14 years ago. STT_SPARC_REGISTER is hopefully
    defined in elf.h of recent C libraries.
    
    Signed-off-by: Masahiro Yamada <masahiroy@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6e892c93d104..7edfdb2f4497 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -12,6 +12,7 @@
  */
 
 #define _GNU_SOURCE
+#include <elf.h>
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
@@ -729,12 +730,6 @@ static void handle_symbol(struct module *mod, struct elf_info *info,
 			break;
 		if (ignore_undef_symbol(info, symname))
 			break;
-/* cope with newer glibc (2.3.4 or higher) STT_ definition in elf.h */
-#if defined(STT_REGISTER) || defined(STT_SPARC_REGISTER)
-/* add compatibility with older glibc */
-#ifndef STT_SPARC_REGISTER
-#define STT_SPARC_REGISTER STT_REGISTER
-#endif
 		if (info->hdr->e_machine == EM_SPARC ||
 		    info->hdr->e_machine == EM_SPARCV9) {
 			/* Ignore register directives. */
@@ -747,7 +742,6 @@ static void handle_symbol(struct module *mod, struct elf_info *info,
 				symname = munged;
 			}
 		}
-#endif
 
 		mod->unres = alloc_symbol(symname,
 					  ELF_ST_BIND(sym->st_info) == STB_WEAK,

commit 7ef9ab3b32b4bb72a7d70b832d2eb12ceb93d9fd
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 15 02:42:26 2019 +0900

    modpost: respect the previous export when 'exported twice' is warned
    
    When 'exported twice' is warned, let sym_add_exported() return without
    updating the symbol info. This respects the previous export, which is
    ordered first in modules.order
    
    This simplifies the code too.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2fa58fbbd10b..6e892c93d104 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -211,13 +211,11 @@ static struct symbol *new_symbol(const char *name, struct module *module,
 				 enum export export)
 {
 	unsigned int hash;
-	struct symbol *new;
 
 	hash = tdb_hash(name) % SYMBOL_HASH_SIZE;
-	new = symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);
-	new->module = module;
-	new->export = export;
-	return new;
+	symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);
+
+	return symbolhash[hash];
 }
 
 static struct symbol *find_symbol(const char *name)
@@ -392,17 +390,15 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 
 	if (!s) {
 		s = new_symbol(name, mod, export);
-	} else {
-		if (!external_module || is_vmlinux(s->module->name) ||
-		    s->module == mod) {
-			warn("%s: '%s' exported twice. Previous export was in %s%s\n",
-			     mod->name, name, s->module->name,
-			     is_vmlinux(s->module->name) ? "" : ".ko");
-		} else {
-			/* In case Module.symvers was out of date */
-			s->module = mod;
-		}
+	} else if (!external_module || is_vmlinux(s->module->name) ||
+		   s->module == mod) {
+		warn("%s: '%s' exported twice. Previous export was in %s%s\n",
+		     mod->name, name, s->module->name,
+		     is_vmlinux(s->module->name) ? "" : ".ko");
+		return s;
 	}
+
+	s->module = mod;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
 	s->export    = export;

commit e4b26c9f75e48b5ef9e31ac6c8a445d4479b469c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 15 02:42:25 2019 +0900

    modpost: do not set ->preloaded for symbols from Module.symvers
    
    Now that there is no overwrap between symbols from ELF files and
    ones from Module.symvers.
    
    So, the 'exported twice' warning should be reported irrespective
    of where the symbol in question came from.
    
    The exceptional case is external module; in some cases, we build
    an external module to provide a different version/variant of the
    corresponding in-kernel module, overriding the same set of exported
    symbols.
    
    You can see this use-case in upstream; tools/testing/nvdimm/libnvdimm.ko
    replaces drivers/nvdimm/libnvdimm.ko in order to link it against mocked
    version of core kernel symbols.
    
    So, let's relax the 'exported twice' warning when building external
    modules. The multiple export from external modules is warned only
    when the previous one is from vmlinux or itself.
    
    With this refactoring, the ugly preloading goes away.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1c22cf7aa732..2fa58fbbd10b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -169,7 +169,6 @@ struct symbol {
 	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
 				    *  (only for external modules) **/
-	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers */
 	unsigned int is_static:1;  /* 1 if symbol is not global */
 	enum export  export;       /* Type of export */
 	char name[0];
@@ -394,7 +393,8 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 	if (!s) {
 		s = new_symbol(name, mod, export);
 	} else {
-		if (!s->preloaded) {
+		if (!external_module || is_vmlinux(s->module->name) ||
+		    s->module == mod) {
 			warn("%s: '%s' exported twice. Previous export was in %s%s\n",
 			     mod->name, name, s->module->name,
 			     is_vmlinux(s->module->name) ? "" : ".ko");
@@ -403,7 +403,6 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 			s->module = mod;
 		}
 	}
-	s->preloaded = 0;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
 	s->export    = export;
@@ -2481,7 +2480,6 @@ static void read_dump(const char *fname, unsigned int kernel)
 		}
 		s = sym_add_exported(symname, mod, export_no(export));
 		s->kernel    = kernel;
-		s->preloaded = 1;
 		s->is_static = 0;
 		sym_set_crc(symname, crc);
 		sym_update_namespace(symname, namespace);

commit 1743694eb2357b47cd9951079f9ab0d728c916bf
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 15 02:42:24 2019 +0900

    modpost: stop symbol preloading for modversion CRC
    
    It is complicated to add mocked-up symbols for pre-handling CRC.
    Handle CRC after all the export symbols in the relevant module
    are registered.
    
    Call handle_modversion() after the handle_symbol() iteration.
    
    In some cases, I see atand-alone __crc_* without __ksymtab_*.
    For example, ARCH=arm allyesconfig produces __crc_ccitt_veneer and
    __crc_itu_t_veneer. I guess they come from crc_ccitt, crc_itu_t,
    respectively. Since __*_veneer are auto-generated symbols, just
    ignore them.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6735ae3da4c2..1c22cf7aa732 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -169,7 +169,7 @@ struct symbol {
 	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
 				    *  (only for external modules) **/
-	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers, or crc */
+	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers */
 	unsigned int is_static:1;  /* 1 if symbol is not global */
 	enum export  export;       /* Type of export */
 	char name[0];
@@ -410,16 +410,17 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 	return s;
 }
 
-static void sym_update_crc(const char *name, struct module *mod,
-			   unsigned int crc, enum export export)
+static void sym_set_crc(const char *name, unsigned int crc)
 {
 	struct symbol *s = find_symbol(name);
 
-	if (!s) {
-		s = new_symbol(name, mod, export);
-		/* Don't complain when we find it later. */
-		s->preloaded = 1;
-	}
+	/*
+	 * Ignore stand-alone __crc_*, which might be auto-generated symbols
+	 * such as __*_veneer in ARM ELF.
+	 */
+	if (!s)
+		return;
+
 	s->crc = crc;
 	s->crc_valid = 1;
 }
@@ -683,12 +684,34 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 	return 0;
 }
 
+static void handle_modversion(const struct module *mod,
+			      const struct elf_info *info,
+			      const Elf_Sym *sym, const char *symname)
+{
+	unsigned int crc;
+
+	if (sym->st_shndx == SHN_UNDEF) {
+		warn("EXPORT symbol \"%s\" [%s%s] version generation failed, symbol will not be versioned.\n",
+		     symname, mod->name, is_vmlinux(mod->name) ? "":".ko");
+		return;
+	}
+
+	if (sym->st_shndx == SHN_ABS) {
+		crc = sym->st_value;
+	} else {
+		unsigned int *crcp;
+
+		/* symbol points to the CRC in the ELF object */
+		crcp = sym_get_data(info, sym);
+		crc = TO_NATIVE(*crcp);
+	}
+	sym_set_crc(symname, crc);
+}
+
 static void handle_symbol(struct module *mod, struct elf_info *info,
 			  const Elf_Sym *sym, const char *symname)
 {
-	unsigned int crc;
 	enum export export;
-	bool is_crc = false;
 	const char *name;
 
 	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
@@ -697,21 +720,6 @@ static void handle_symbol(struct module *mod, struct elf_info *info,
 	else
 		export = export_from_sec(info, get_secindex(info, sym));
 
-	/* CRC'd symbol */
-	if (strstarts(symname, "__crc_")) {
-		is_crc = true;
-		crc = (unsigned int) sym->st_value;
-		if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS) {
-			unsigned int *crcp;
-
-			/* symbol points to the CRC in the ELF object */
-			crcp = sym_get_data(info, sym);
-			crc = TO_NATIVE(*crcp);
-		}
-		sym_update_crc(symname + strlen("__crc_"), mod, crc,
-				export);
-	}
-
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
 		if (strstarts(symname, "__gnu_lto_")) {
@@ -746,11 +754,6 @@ static void handle_symbol(struct module *mod, struct elf_info *info,
 		}
 #endif
 
-		if (is_crc) {
-			const char *e = is_vmlinux(mod->name) ?"":".ko";
-			warn("EXPORT symbol \"%s\" [%s%s] version generation failed, symbol will not be versioned.\n",
-			     symname + strlen("__crc_"), mod->name, e);
-		}
 		mod->unres = alloc_symbol(symname,
 					  ELF_ST_BIND(sym->st_info) == STB_WEAK,
 					  mod->unres);
@@ -2055,14 +2058,18 @@ static void read_symbols(const char *modname)
 		handle_moddevtable(mod, &info, sym, symname);
 	}
 
-	/* Apply symbol namespaces from __kstrtabns_<symbol> entries. */
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		symname = remove_dot(info.strtab + sym->st_name);
 
+		/* Apply symbol namespaces from __kstrtabns_<symbol> entries. */
 		if (strstarts(symname, "__kstrtabns_"))
 			sym_update_namespace(symname + strlen("__kstrtabns_"),
 					     namespace_from_kstrtabns(&info,
 								      sym));
+
+		if (strstarts(symname, "__crc_"))
+			handle_modversion(mod, &info, sym,
+					  symname + strlen("__crc_"));
 	}
 
 	// check for static EXPORT_SYMBOL_* functions && global vars
@@ -2476,7 +2483,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		s->kernel    = kernel;
 		s->preloaded = 1;
 		s->is_static = 0;
-		sym_update_crc(symname, mod, crc, export_no(export));
+		sym_set_crc(symname, crc);
 		sym_update_namespace(symname, namespace);
 	}
 	release_file(file, size);

commit 9bd2a099d7224281dd7756efa5c79df4f3fe8daf
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 15 02:42:23 2019 +0900

    modpost: rename handle_modversions() to handle_symbol()
    
    This function handles not only modversions, but also unresolved
    symbols, export symbols, etc.
    
    Rename it to a more proper function name.
    
    While I was here, I also added the 'const' qualifier to *sym.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d9418c58a8c0..6735ae3da4c2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -683,8 +683,8 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 	return 0;
 }
 
-static void handle_modversions(struct module *mod, struct elf_info *info,
-			       Elf_Sym *sym, const char *symname)
+static void handle_symbol(struct module *mod, struct elf_info *info,
+			  const Elf_Sym *sym, const char *symname)
 {
 	unsigned int crc;
 	enum export export;
@@ -2051,7 +2051,7 @@ static void read_symbols(const char *modname)
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		symname = remove_dot(info.strtab + sym->st_name);
 
-		handle_modversions(mod, &info, sym, symname);
+		handle_symbol(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);
 	}
 

commit e84f9fbbece1585f45a03ccc11eeabe121cadc1b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 15 02:42:22 2019 +0900

    modpost: refactor namespace_from_kstrtabns() to not hard-code section name
    
    Currently, namespace_from_kstrtabns() relies on the fact that
    namespace strings are recorded in the __ksymtab_strings section.
    Actually, it is coded in include/linux/export.h, but modpost does
    not need to hard-code the section name.
    
    Elf_Sym::st_shndx holds the index of the relevant section. Using it is
    a more portable way to get the namespace string.
    
    Make namespace_from_kstrtabns() simply call sym_get_data(), and delete
    the info->ksymtab_strings .
    
    While I was here, I added more 'const' qualifiers to pointers.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index cd885573daaf..d9418c58a8c0 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -356,10 +356,10 @@ static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 		return export_unknown;
 }
 
-static const char *namespace_from_kstrtabns(struct elf_info *info,
-					    Elf_Sym *kstrtabns)
+static const char *namespace_from_kstrtabns(const struct elf_info *info,
+					    const Elf_Sym *sym)
 {
-	char *value = info->ksymtab_strings + kstrtabns->st_value;
+	const char *value = sym_get_data(info, sym);
 	return value[0] ? value : NULL;
 }
 
@@ -601,10 +601,6 @@ static int parse_elf(struct elf_info *info, const char *filename)
 			info->export_unused_gpl_sec = i;
 		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
 			info->export_gpl_future_sec = i;
-		else if (strcmp(secname, "__ksymtab_strings") == 0)
-			info->ksymtab_strings = (void *)hdr +
-						sechdrs[i].sh_offset -
-						sechdrs[i].sh_addr;
 
 		if (sechdrs[i].sh_type == SHT_SYMTAB) {
 			unsigned int sh_link_idx;

commit afa0459daa7b08c7b2c879705b69d39b734a11d0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 15 02:42:21 2019 +0900

    modpost: add a helper to get data pointed by a symbol
    
    When CONFIG_MODULE_REL_CRCS is enabled, the value of __crc_* is not
    an absolute value, but the address to the CRC data embedded in the
    .rodata section.
    
    Getting the data pointed by the symbol value is somewhat complex.
    Split it out into a new helper, sym_get_data().
    
    I will reuse it to refactor namespace_from_kstrtabns() in the next
    commit.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 46d7f695fe7f..cd885573daaf 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -308,6 +308,18 @@ static const char *sec_name(struct elf_info *elf, int secindex)
 	return sech_name(elf, &elf->sechdrs[secindex]);
 }
 
+static void *sym_get_data(const struct elf_info *info, const Elf_Sym *sym)
+{
+	Elf_Shdr *sechdr = &info->sechdrs[sym->st_shndx];
+	unsigned long offset;
+
+	offset = sym->st_value;
+	if (info->hdr->e_type != ET_REL)
+		offset -= sechdr->sh_addr;
+
+	return (void *)info->hdr + sechdr->sh_offset + offset;
+}
+
 #define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)
 
 static enum export export_from_secname(struct elf_info *elf, unsigned int sec)
@@ -697,10 +709,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			unsigned int *crcp;
 
 			/* symbol points to the CRC in the ELF object */
-			crcp = (void *)info->hdr + sym->st_value +
-			       info->sechdrs[sym->st_shndx].sh_offset -
-			       (info->hdr->e_type != ET_REL ?
-				info->sechdrs[sym->st_shndx].sh_addr : 0);
+			crcp = sym_get_data(info, sym);
 			crc = TO_NATIVE(*crcp);
 		}
 		sym_update_crc(symname + strlen("__crc_"), mod, crc,

commit 76b54cf033c9f2effc70066a2bbb2331013889a1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 29 21:38:09 2019 +0900

    modpost: remove unneeded local variable in contains_namespace()
    
    The local variable, ns_entry, is unneeded.
    
    While I was here, I also cleaned up the comparison with NULL or 0.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Matthias Maennich <maennich@google.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2cdbcdf197a3..46d7f695fe7f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -239,10 +239,8 @@ static struct symbol *find_symbol(const char *name)
 static bool contains_namespace(struct namespace_list *list,
 			       const char *namespace)
 {
-	struct namespace_list *ns_entry;
-
-	for (ns_entry = list; ns_entry != NULL; ns_entry = ns_entry->next)
-		if (strcmp(ns_entry->namespace, namespace) == 0)
+	for (; list; list = list->next)
+		if (!strcmp(list->namespace, namespace))
 			return true;
 
 	return false;

commit bbc55bded4aaf47d6f2bd9389fc8d3a3821d18c0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 29 21:38:07 2019 +0900

    modpost: dump missing namespaces into a single modules.nsdeps file
    
    The modpost, with the -d option given, generates per-module .ns_deps
    files.
    
    Kbuild generates per-module .mod files to carry module information.
    This is convenient because Make handles multiple jobs in parallel
    when the -j option is given.
    
    On the other hand, the modpost always runs as a single thread.
    I do not see a strong reason to produce separate .ns_deps files.
    
    This commit changes the modpost to generate just one file,
    modules.nsdeps, each line of which has the following format:
    
      <module_name>: <list of missing namespaces>
    
    Please note it contains *missing* namespaces instead of required ones.
    So, modules.nsdeps is empty if the namespace dependency is all good.
    
    This will work more efficiently because spatch will no longer process
    already imported namespaces. I removed the '(if needed)' from the
    nsdeps log since spatch is invoked only when needed.
    
    This also solves the stale .ns_deps problem reported by Jessica Yu:
    
      https://lkml.org/lkml/2019/10/28/467
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Jessica Yu <jeyu@kernel.org>
    Acked-by: Jessica Yu <jeyu@kernel.org>
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Tested-by: Matthias Maennich <maennich@google.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 95f440d217e5..2cdbcdf197a3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -38,8 +38,6 @@ static int sec_mismatch_count = 0;
 static int sec_mismatch_fatal = 0;
 /* ignore missing files */
 static int ignore_missing_files;
-/* write namespace dependencies */
-static int write_namespace_deps;
 
 enum export {
 	export_plain,      export_unused,     export_gpl,
@@ -2217,14 +2215,11 @@ static int check_exports(struct module *mod)
 		else
 			basename = mod->name;
 
-		if (exp->namespace) {
-			add_namespace(&mod->required_namespaces,
-				      exp->namespace);
-
-			if (!module_imports_namespace(mod, exp->namespace)) {
-				warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
-				     basename, exp->name, exp->namespace);
-			}
+		if (exp->namespace &&
+		    !module_imports_namespace(mod, exp->namespace)) {
+			warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
+			     basename, exp->name, exp->namespace);
+			add_namespace(&mod->missing_namespaces, exp->namespace);
 		}
 
 		if (!mod->gpl_compatible)
@@ -2526,30 +2521,26 @@ static void write_dump(const char *fname)
 	free(buf.p);
 }
 
-static void write_namespace_deps_files(void)
+static void write_namespace_deps_files(const char *fname)
 {
 	struct module *mod;
 	struct namespace_list *ns;
 	struct buffer ns_deps_buf = {};
 
 	for (mod = modules; mod; mod = mod->next) {
-		char fname[PATH_MAX];
 
-		if (mod->skip)
+		if (mod->skip || !mod->missing_namespaces)
 			continue;
 
-		ns_deps_buf.pos = 0;
-
-		for (ns = mod->required_namespaces; ns; ns = ns->next)
-			buf_printf(&ns_deps_buf, "%s\n", ns->namespace);
+		buf_printf(&ns_deps_buf, "%s.ko:", mod->name);
 
-		if (ns_deps_buf.pos == 0)
-			continue;
+		for (ns = mod->missing_namespaces; ns; ns = ns->next)
+			buf_printf(&ns_deps_buf, " %s", ns->namespace);
 
-		sprintf(fname, "%s.ns_deps", mod->name);
-		write_if_changed(&ns_deps_buf, fname);
+		buf_printf(&ns_deps_buf, "\n");
 	}
 
+	write_if_changed(&ns_deps_buf, fname);
 	free(ns_deps_buf.p);
 }
 
@@ -2563,6 +2554,7 @@ int main(int argc, char **argv)
 	struct module *mod;
 	struct buffer buf = { };
 	char *kernel_read = NULL;
+	char *missing_namespace_deps = NULL;
 	char *dump_write = NULL, *files_source = NULL;
 	int opt;
 	int err;
@@ -2570,7 +2562,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awEd")) != -1) {
+	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awEd:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2609,7 +2601,7 @@ int main(int argc, char **argv)
 			sec_mismatch_fatal = 1;
 			break;
 		case 'd':
-			write_namespace_deps = 1;
+			missing_namespace_deps = optarg;
 			break;
 		default:
 			exit(1);
@@ -2657,8 +2649,8 @@ int main(int argc, char **argv)
 		write_if_changed(&buf, fname);
 	}
 
-	if (write_namespace_deps)
-		write_namespace_deps_files();
+	if (missing_namespace_deps)
+		write_namespace_deps_files(missing_namespace_deps);
 
 	if (dump_write)
 		write_dump(dump_write);

commit 0241ea8cae19b49fc1b1459f7bbe9a77f4f9cc89
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Nov 7 00:19:59 2019 +0900

    modpost: free ns_deps_buf.p after writing ns_deps files
    
    buf_write() allocates memory. Free it.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1de983d9a05d..95f440d217e5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2549,6 +2549,8 @@ static void write_namespace_deps_files(void)
 		sprintf(fname, "%s.ns_deps", mod->name);
 		write_if_changed(&ns_deps_buf, fname);
 	}
+
+	free(ns_deps_buf.p);
 }
 
 struct ext_sym_list {

commit bff9c62b5d20d26f54bab81b33b6d9d1f9afcdf6
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 29 21:38:06 2019 +0900

    modpost: do not invoke extra modpost for nsdeps
    
    'make nsdeps' invokes the modpost three times at most; before linking
    vmlinux, before building modules, and finally for generating .ns_deps
    files. Running the modpost again and again is not efficient.
    
    The last two can be unified. When the -d option is given, the modpost
    still does the usual job, and in addition, generates .ns_deps files.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Matthias Maennich <maennich@google.com>
    Reviewed-by: Matthias Maennich <maennich@google.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 37fa1c65ee4d..1de983d9a05d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2221,8 +2221,7 @@ static int check_exports(struct module *mod)
 			add_namespace(&mod->required_namespaces,
 				      exp->namespace);
 
-			if (!write_namespace_deps &&
-			    !module_imports_namespace(mod, exp->namespace)) {
+			if (!module_imports_namespace(mod, exp->namespace)) {
 				warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
 				     basename, exp->name, exp->namespace);
 			}
@@ -2642,8 +2641,6 @@ int main(int argc, char **argv)
 
 		err |= check_modname_len(mod);
 		err |= check_exports(mod);
-		if (write_namespace_deps)
-			continue;
 
 		add_header(&buf, mod);
 		add_intree_flag(&buf, !external_module);
@@ -2658,10 +2655,8 @@ int main(int argc, char **argv)
 		write_if_changed(&buf, fname);
 	}
 
-	if (write_namespace_deps) {
+	if (write_namespace_deps)
 		write_namespace_deps_files();
-		return 0;
-	}
 
 	if (dump_write)
 		write_dump(dump_write);

commit 39808e451fdf30d20099a92e5185a0acb028d826
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 3 19:29:14 2019 +0900

    kbuild: do not read $(KBUILD_EXTMOD)/Module.symvers
    
    Since commit 040fcc819a2e ("kbuild: improved modversioning support for
    external modules"), the external module build reads Module.symvers in
    the directory of the module itself, then dumps symbols back into it.
    It accumulates stale symbols in the file when you build an external
    module incrementally.
    
    The idea behind it was, as the commit log explained, you can copy
    Modules.symvers from one module to another when you need to pass symbol
    information between two modules. However, the manual copy of the file
    sounds questionable to me, and containing stale symbols is a downside.
    
    Some time later, commit 0d96fb20b7ed ("kbuild: Add new Kbuild variable
    KBUILD_EXTRA_SYMBOLS") introduced a saner approach.
    
    So, this commit removes the former one. Going forward, the external
    module build dumps symbols into Module.symvers to be carried via
    KBUILD_EXTRA_SYMBOLS, but never reads it automatically.
    
    With the -I option removed, there is no one to set the external_module
    flag unless KBUILD_EXTRA_SYMBOLS is passed. Now the -i option does it
    instead.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d2a30a7b3f07..37fa1c65ee4d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2561,7 +2561,7 @@ int main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
-	char *kernel_read = NULL, *module_read = NULL;
+	char *kernel_read = NULL;
 	char *dump_write = NULL, *files_source = NULL;
 	int opt;
 	int err;
@@ -2569,13 +2569,10 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:mnsT:o:awEd")) != -1) {
+	while ((opt = getopt(argc, argv, "i:e:mnsT:o:awEd")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
-			break;
-		case 'I':
-			module_read = optarg;
 			external_module = 1;
 			break;
 		case 'e':
@@ -2620,8 +2617,6 @@ int main(int argc, char **argv)
 
 	if (kernel_read)
 		read_dump(kernel_read, 1);
-	if (module_read)
-		read_dump(module_read, 0);
 	while (extsym_start) {
 		read_dump(extsym_start->file, 0);
 		extsym_iter = extsym_start->next;

commit 69923208431e097ce3830647aee98e5bd3e889c8
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Oct 18 10:31:42 2019 +0100

    symbol namespaces: revert to previous __ksymtab name scheme
    
    The introduction of Symbol Namespaces changed the naming schema of the
    __ksymtab entries from __kysmtab__symbol to __ksymtab_NAMESPACE.symbol.
    
    That caused some breakages in tools that depend on the name layout in
    either the binaries(vmlinux,*.ko) or in System.map. E.g. kmod's depmod
    would not be able to read System.map without a patch to support symbol
    namespaces. A warning reported by depmod for namespaced symbols would
    look like
    
      depmod: WARNING: [...]/uas.ko needs unknown symbol usb_stor_adjust_quirks
    
    In order to address this issue, revert to the original naming scheme and
    rather read the __kstrtabns_<symbol> entries and their corresponding
    values from __ksymtab_strings to update the namespace values for
    symbols. After having read all symbols and handled them in
    handle_modversions(), the symbols are created. In a second pass, read
    the __kstrtabns_ entries and update the namespaces accordingly.
    
    Fixes: 8651ec01daed ("module: add support for symbol namespaces.")
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Will Deacon <will@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c43f1b1532f7..d2a30a7b3f07 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -348,18 +348,11 @@ static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 		return export_unknown;
 }
 
-static char *sym_extract_namespace(const char **symname)
+static const char *namespace_from_kstrtabns(struct elf_info *info,
+					    Elf_Sym *kstrtabns)
 {
-	char *namespace = NULL;
-	char *ns_separator;
-
-	ns_separator = strchr(*symname, '.');
-	if (ns_separator) {
-		namespace = NOFAIL(strndup(*symname, ns_separator - *symname));
-		*symname = ns_separator + 1;
-	}
-
-	return namespace;
+	char *value = info->ksymtab_strings + kstrtabns->st_value;
+	return value[0] ? value : NULL;
 }
 
 static void sym_update_namespace(const char *symname, const char *namespace)
@@ -600,6 +593,10 @@ static int parse_elf(struct elf_info *info, const char *filename)
 			info->export_unused_gpl_sec = i;
 		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
 			info->export_gpl_future_sec = i;
+		else if (strcmp(secname, "__ksymtab_strings") == 0)
+			info->ksymtab_strings = (void *)hdr +
+						sechdrs[i].sh_offset -
+						sechdrs[i].sh_addr;
 
 		if (sechdrs[i].sh_type == SHT_SYMTAB) {
 			unsigned int sh_link_idx;
@@ -689,7 +686,6 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	enum export export;
 	bool is_crc = false;
 	const char *name;
-	char *namespace;
 
 	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
 	    strstarts(symname, "__ksymtab"))
@@ -762,10 +758,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		/* All exported symbols */
 		if (strstarts(symname, "__ksymtab_")) {
 			name = symname + strlen("__ksymtab_");
-			namespace = sym_extract_namespace(&name);
 			sym_add_exported(name, mod, export);
-			sym_update_namespace(name, namespace);
-			free(namespace);
 		}
 		if (strcmp(symname, "init_module") == 0)
 			mod->has_init = 1;
@@ -2061,6 +2054,16 @@ static void read_symbols(const char *modname)
 		handle_moddevtable(mod, &info, sym, symname);
 	}
 
+	/* Apply symbol namespaces from __kstrtabns_<symbol> entries. */
+	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
+		symname = remove_dot(info.strtab + sym->st_name);
+
+		if (strstarts(symname, "__kstrtabns_"))
+			sym_update_namespace(symname + strlen("__kstrtabns_"),
+					     namespace_from_kstrtabns(&info,
+								      sym));
+	}
+
 	// check for static EXPORT_SYMBOL_* functions && global vars
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		unsigned char bind = ELF_ST_BIND(sym->st_info);

commit 9ae5bd1847566e079ffb7607394389ac54815f2b
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Oct 18 10:31:41 2019 +0100

    modpost: make updating the symbol namespace explicit
    
    Setting the symbol namespace of a symbol within sym_add_exported feels
    displaced and lead to issues in the current implementation of symbol
    namespaces. This patch makes updating the namespace an explicit call to
    decouple it from adding a symbol to the export list.
    
    Acked-by: Will Deacon <will@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4041a265d2b6..c43f1b1532f7 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -385,8 +385,8 @@ static void sym_update_namespace(const char *symname, const char *namespace)
  * Add an exported symbol - it may have already been added without a
  * CRC, in this case just update the CRC
  **/
-static struct symbol *sym_add_exported(const char *name, const char *namespace,
-				       struct module *mod, enum export export)
+static struct symbol *sym_add_exported(const char *name, struct module *mod,
+				       enum export export)
 {
 	struct symbol *s = find_symbol(name);
 
@@ -402,7 +402,6 @@ static struct symbol *sym_add_exported(const char *name, const char *namespace,
 			s->module = mod;
 		}
 	}
-	sym_update_namespace(name, namespace);
 	s->preloaded = 0;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
@@ -764,7 +763,8 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		if (strstarts(symname, "__ksymtab_")) {
 			name = symname + strlen("__ksymtab_");
 			namespace = sym_extract_namespace(&name);
-			sym_add_exported(name, namespace, mod, export);
+			sym_add_exported(name, mod, export);
+			sym_update_namespace(name, namespace);
 			free(namespace);
 		}
 		if (strcmp(symname, "init_module") == 0)
@@ -2472,12 +2472,12 @@ static void read_dump(const char *fname, unsigned int kernel)
 			mod = new_module(modname);
 			mod->skip = 1;
 		}
-		s = sym_add_exported(symname, namespace, mod,
-				     export_no(export));
+		s = sym_add_exported(symname, mod, export_no(export));
 		s->kernel    = kernel;
 		s->preloaded = 1;
 		s->is_static = 0;
 		sym_update_crc(symname, mod, crc, export_no(export));
+		sym_update_namespace(symname, namespace);
 	}
 	release_file(file, size);
 	return;

commit a2b11184389489dcca4fa899b290fc2751ea55ac
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Oct 18 10:31:40 2019 +0100

    modpost: delegate updating namespaces to separate function
    
    Let the function 'sym_update_namespace' take care of updating the
    namespace for a symbol. While this currently only replaces one single
    location where namespaces are updated, in a following patch, this
    function will get more call sites.
    
    The function signature is intentionally close to sym_update_crc and
    taking the name by char* seems like unnecessary work as the symbol has
    to be looked up again. In a later patch of this series, this concern
    will be addressed.
    
    This function ensures that symbol::namespace is either NULL or has a
    valid non-empty value. Previously, the empty string was considered 'no
    namespace' as well and this lead to confusion.
    
    Acked-by: Will Deacon <will@kernel.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 936d3ad23c83..4041a265d2b6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -362,6 +362,25 @@ static char *sym_extract_namespace(const char **symname)
 	return namespace;
 }
 
+static void sym_update_namespace(const char *symname, const char *namespace)
+{
+	struct symbol *s = find_symbol(symname);
+
+	/*
+	 * That symbol should have been created earlier and thus this is
+	 * actually an assertion.
+	 */
+	if (!s) {
+		merror("Could not update namespace(%s) for symbol %s\n",
+		       namespace, symname);
+		return;
+	}
+
+	free(s->namespace);
+	s->namespace =
+		namespace && namespace[0] ? NOFAIL(strdup(namespace)) : NULL;
+}
+
 /**
  * Add an exported symbol - it may have already been added without a
  * CRC, in this case just update the CRC
@@ -383,8 +402,7 @@ static struct symbol *sym_add_exported(const char *name, const char *namespace,
 			s->module = mod;
 		}
 	}
-	free(s->namespace);
-	s->namespace = namespace ? strdup(namespace) : NULL;
+	sym_update_namespace(name, namespace);
 	s->preloaded = 0;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
@@ -2196,7 +2214,7 @@ static int check_exports(struct module *mod)
 		else
 			basename = mod->name;
 
-		if (exp->namespace && exp->namespace[0]) {
+		if (exp->namespace) {
 			add_namespace(&mod->required_namespaces,
 				      exp->namespace);
 

commit c6f6ebd77ce1bb8931f78412a841dd1371820181
Merge: 56c642e2aa1c fcfacb9f8374
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 11 10:19:24 2019 -0700

    Merge tag 'modules-for-v5.4-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull module fixes from Jessica Yu:
     "Code cleanups and kbuild/namespace related fixups from Masahiro.
    
      Most importantly, it fixes a namespace-related modpost issue for
      external module builds
    
       - Fix broken external module builds due to a modpost bug in
         read_dump(), where the namespace was not being strdup'd and
         sym->namespace would be set to bogus data.
    
       - Various namespace-related kbuild fixes and cleanups thanks to
         Masahiro Yamada"
    
    * tag 'modules-for-v5.4-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      doc: move namespaces.rst from kbuild/ to core-api/
      nsdeps: make generated patches independent of locale
      nsdeps: fix hashbang of scripts/nsdeps
      kbuild: fix build error of 'make nsdeps' in clean tree
      module: rename __kstrtab_ns_* to __kstrtabns_* to avoid symbol conflict
      modpost: fix broken sym->namespace for external module builds
      module: swap the order of symbol.namespace
      scripts: add_namespace: Fix coccicheck failed

commit 389eb3f5f4abbdb9810458ac9b87427336ba5b91
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 3 16:58:22 2019 +0900

    modpost: fix broken sym->namespace for external module builds
    
    Currently, external module builds produce tons of false-positives:
    
      WARNING: module <mod> uses symbol <sym> from namespace <ns>, but does not import it.
    
    Here, the <ns> part shows a random string.
    
    When you build external modules, the symbol info of vmlinux and
    in-kernel modules are read from $(objtree)/Module.symvers, but
    read_dump() is buggy in multiple ways:
    
    [1] When the modpost is run for vmlinux and in-kernel modules,
    sym_extract_namespace() allocates memory for the namespace. On the
    other hand, read_dump() does not, then sym->namespace will point to
    somewhere in the line buffer of get_next_line(). The data in the
    buffer will be replaced soon, and sym->namespace will end up with
    pointing to unrelated data. As a result, check_exports() will show
    random strings in the warning messages.
    
    [2] When there is no namespace, sym_extract_namespace() returns NULL.
    On the other hand, read_dump() sets namespace to an empty string "".
    (but, it will be later replaced with unrelated data due to bug [1].)
    The check_exports() shows a warning unless exp->namespace is NULL,
    so every symbol read from read_dump() emits the warning, which is
    mostly false positive.
    
    To address [1], sym_add_exported() calls strdup() for s->namespace.
    The namespace from sym_extract_namespace() must be freed to avoid
    memory leak.
    
    For [2], I changed the if-conditional in check_exports().
    
    This commit also fixes sym_add_exported() to set s->namespace correctly
    when the symbol is preloaded.
    
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c4b536ac1327..4d2cdb4d71e3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -166,7 +166,7 @@ struct symbol {
 	struct module *module;
 	unsigned int crc;
 	int crc_valid;
-	const char *namespace;
+	char *namespace;
 	unsigned int weak:1;
 	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
@@ -348,7 +348,7 @@ static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 		return export_unknown;
 }
 
-static const char *sym_extract_namespace(const char **symname)
+static char *sym_extract_namespace(const char **symname)
 {
 	char *namespace = NULL;
 	char *ns_separator;
@@ -373,7 +373,6 @@ static struct symbol *sym_add_exported(const char *name, const char *namespace,
 
 	if (!s) {
 		s = new_symbol(name, mod, export);
-		s->namespace = namespace;
 	} else {
 		if (!s->preloaded) {
 			warn("%s: '%s' exported twice. Previous export was in %s%s\n",
@@ -384,6 +383,8 @@ static struct symbol *sym_add_exported(const char *name, const char *namespace,
 			s->module = mod;
 		}
 	}
+	free(s->namespace);
+	s->namespace = namespace ? strdup(namespace) : NULL;
 	s->preloaded = 0;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
@@ -670,7 +671,8 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	unsigned int crc;
 	enum export export;
 	bool is_crc = false;
-	const char *name, *namespace;
+	const char *name;
+	char *namespace;
 
 	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
 	    strstarts(symname, "__ksymtab"))
@@ -745,6 +747,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			name = symname + strlen("__ksymtab_");
 			namespace = sym_extract_namespace(&name);
 			sym_add_exported(name, namespace, mod, export);
+			free(namespace);
 		}
 		if (strcmp(symname, "init_module") == 0)
 			mod->has_init = 1;
@@ -2193,7 +2196,7 @@ static int check_exports(struct module *mod)
 		else
 			basename = mod->name;
 
-		if (exp->namespace) {
+		if (exp->namespace && exp->namespace[0]) {
 			add_namespace(&mod->required_namespaces,
 				      exp->namespace);
 

commit bf70b0503abd19194dba25fe383d143d0229dc6a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Oct 3 16:58:21 2019 +0900

    module: swap the order of symbol.namespace
    
    Currently, EXPORT_SYMBOL_NS(_GPL) constructs the kernel symbol as
    follows:
    
      __ksymtab_SYMBOL.NAMESPACE
    
    The sym_extract_namespace() in modpost allocates memory for the part
    SYMBOL.NAMESPACE when '.' is contained. One problem is that the pointer
    returned by strdup() is lost because the symbol name will be copied to
    malloc'ed memory by alloc_symbol(). No one will keep track of the
    pointer of strdup'ed memory.
    
    sym->namespace still points to the NAMESPACE part. So, you can free it
    with complicated code like this:
    
       free(sym->namespace - strlen(sym->name) - 1);
    
    It complicates memory free.
    
    To fix it elegantly, I swapped the order of the symbol and the
    namespace as follows:
    
      __ksymtab_NAMESPACE.SYMBOL
    
    then, simplified sym_extract_namespace() so that it allocates memory
    only for the NAMESPACE part.
    
    I prefer this order because it is intuitive and also matches to major
    languages. For example, NAMESPACE::NAME in C++, MODULE.NAME in Python.
    
    Reviewed-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3961941e8e7a..c4b536ac1327 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -350,18 +350,16 @@ static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 
 static const char *sym_extract_namespace(const char **symname)
 {
-	size_t n;
-	char *dupsymname;
+	char *namespace = NULL;
+	char *ns_separator;
 
-	n = strcspn(*symname, ".");
-	if (n < strlen(*symname) - 1) {
-		dupsymname = NOFAIL(strdup(*symname));
-		dupsymname[n] = '\0';
-		*symname = dupsymname;
-		return dupsymname + n + 1;
+	ns_separator = strchr(*symname, '.');
+	if (ns_separator) {
+		namespace = NOFAIL(strndup(*symname, ns_separator - *symname));
+		*symname = ns_separator + 1;
 	}
 
-	return NULL;
+	return namespace;
 }
 
 /**

commit 47346e96f004eca07720e1e2b24fc7f0b0df4092
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Sep 24 21:07:40 2019 +0900

    modpost: fix static EXPORT_SYMBOL warnings for UML build
    
    Johannes Berg reports lots of modpost warnings on ARCH=um builds:
    
    WARNING: "rename" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "lseek" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "ftruncate64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "getuid" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "lseek64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "unlink" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "pwrite64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "close" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "opendir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "pread64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "syscall" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "readdir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "readdir64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "futimes" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__lxstat" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "write" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "closedir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__xstat" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "fsync" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__lxstat64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__fxstat64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "telldir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "printf" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "readlink" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__sprintf_chk" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "link" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "rmdir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "fdatasync" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "truncate" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "statfs" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__errno_location" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__xmknod" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "open64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "truncate64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "open" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "read" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "chown" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "chmod" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "utime" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "fchmod" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "seekdir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "ioctl" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "dup2" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "statfs64" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "utimes" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "mkdir" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "fchown" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__guard" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "symlink" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "access" [vmlinux] is a static EXPORT_SYMBOL
    WARNING: "__stack_smash_handler" [vmlinux] is a static EXPORT_SYMBOL
    
    When you run "make", the modpost is run twice; before linking vmlinux,
    and before building modules. All the warnings above are from the second
    modpost.
    
    The offending symbols are defined not in vmlinux, but in the C library.
    The first modpost is run against the relocatable vmlinux.o, and those
    warnings are nicely suppressed because the SH_UNDEF entries from the
    symbol table clear the ->is_static flag.
    
    The second modpost is run against the executable vmlinux (+ modules),
    where those symbols have been resolved, but the definitions do not
    exist.
    
    This commit fixes it in a straightforward way; suppress the static
    EXPORT_SYMBOL warnings from "vmlinux".
    
    Without this commit, we see valid warnings twice anyway. For example,
    ARCH=arm64 defconfig shows the following warning twice:
    
    WARNING: "HYPERVISOR_platform_op" [vmlinux] is a static EXPORT_SYMBOL_GPL
    
    So, it is reasonable to suppress the second one.
    
    Fixes: 15bfc2348d54 ("modpost: check for static EXPORT_SYMBOL* functions")
    Reported-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Tested-by: Johannes Berg <johannes@sipsolutions.net>
    Tested-by: Denis Efremov <efremov@linux.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3961941e8e7a..442d5e2ad688 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2652,15 +2652,20 @@ int main(int argc, char **argv)
 		fatal("modpost: Section mismatches detected.\n"
 		      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
 	for (n = 0; n < SYMBOL_HASH_SIZE; n++) {
-		struct symbol *s = symbolhash[n];
+		struct symbol *s;
+
+		for (s = symbolhash[n]; s; s = s->next) {
+			/*
+			 * Do not check "vmlinux". This avoids the same warnings
+			 * shown twice, and false-positives for ARCH=um.
+			 */
+			if (is_vmlinux(s->module->name) && !s->module->is_dot_o)
+				continue;
 
-		while (s) {
 			if (s->is_static)
 				warn("\"%s\" [%s] is a static %s\n",
 				     s->name, s->module->name,
 				     export_str(s->export));
-
-			s = s->next;
 		}
 	}
 

commit e0703556644a531e50b5dc61b9f6ea83af5f6604
Merge: 8808cf8cbc4d 2e6fcfeb9df6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Sep 22 10:34:46 2019 -0700

    Merge tag 'modules-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull modules updates from Jessica Yu:
     "The main bulk of this pull request introduces a new exported symbol
      namespaces feature. The number of exported symbols is increasingly
      growing with each release (we're at about 31k exports as of 5.3-rc7)
      and we currently have no way of visualizing how these symbols are
      "clustered" or making sense of this huge export surface.
    
      Namespacing exported symbols allows kernel developers to more
      explicitly partition and categorize exported symbols, as well as more
      easily limiting the availability of namespaced symbols to other parts
      of the kernel. For starters, we have introduced the USB_STORAGE
      namespace to demonstrate the API's usage. I have briefly summarized
      the feature and its main motivations in the tag below.
    
      Summary:
    
       - Introduce exported symbol namespaces.
    
         This new feature allows subsystem maintainers to partition and
         categorize their exported symbols into explicit namespaces. Module
         authors are now required to import the namespaces they need.
    
         Some of the main motivations of this feature include: allowing
         kernel developers to better manage the export surface, allow
         subsystem maintainers to explicitly state that usage of some
         exported symbols should only be limited to certain users (think:
         inter-module or inter-driver symbols, debugging symbols, etc), as
         well as more easily limiting the availability of namespaced symbols
         to other parts of the kernel.
    
         With the module import requirement, it is also easier to spot the
         misuse of exported symbols during patch review.
    
         Two new macros are introduced: EXPORT_SYMBOL_NS() and
         EXPORT_SYMBOL_NS_GPL(). The API is thoroughly documented in
         Documentation/kbuild/namespaces.rst.
    
       - Some small code and kbuild cleanups here and there"
    
    * tag 'modules-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      module: Remove leftover '#undef' from export header
      module: remove unneeded casts in cmp_name()
      module: move CONFIG_UNUSED_SYMBOLS to the sub-menu of MODULES
      module: remove redundant 'depends on MODULES'
      module: Fix link failure due to invalid relocation on namespace offset
      usb-storage: export symbols in USB_STORAGE namespace
      usb-storage: remove single-use define for debugging
      docs: Add documentation for Symbol Namespaces
      scripts: Coccinelle script for namespace dependencies.
      modpost: add support for generating namespace dependencies
      export: allow definition default namespaces in Makefiles or sources
      module: add config option MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS
      modpost: add support for symbol namespaces
      module: add support for symbol namespaces.
      export: explicitly align struct kernel_symbol
      module: support reading multiple values per modinfo tag

commit a3d0cb04f7df257b4dffec5e352b8e192824619c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Sep 9 20:34:23 2019 +0900

    modpost: use __section in the output to *.mod.c
    
    Use the __section() shorthand. This avoids escaping double-quotes,
    and improves the readability.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 25036947bcb8..820eed87fb43 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2176,7 +2176,7 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
 	buf_printf(b, "\n");
 	buf_printf(b, "__visible struct module __this_module\n");
-	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
+	buf_printf(b, "__section(.gnu.linkonce.this_module) = {\n");
 	buf_printf(b, "\t.name = KBUILD_MODNAME,\n");
 	if (mod->has_init)
 		buf_printf(b, "\t.init = init_module,\n");
@@ -2230,8 +2230,7 @@ static int add_versions(struct buffer *b, struct module *mod)
 
 	buf_printf(b, "\n");
 	buf_printf(b, "static const struct modversion_info ____versions[]\n");
-	buf_printf(b, "__used\n");
-	buf_printf(b, "__attribute__((section(\"__versions\"))) = {\n");
+	buf_printf(b, "__used __section(__versions) = {\n");
 
 	for (s = mod->unres; s; s = s->next) {
 		if (!s->module)

commit 6df7e1ec932a330c931ed747ed824639fb04133e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Sep 9 20:34:22 2019 +0900

    modpost: use MODULE_INFO() for __module_depends
    
    This makes *.mod.c much more readable. I confirmed depmod still
    produced the same modules.dep file.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 76c221dd9b2b..25036947bcb8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2267,10 +2267,7 @@ static void add_depends(struct buffer *b, struct module *mod)
 			s->module->seen = is_vmlinux(s->module->name);
 
 	buf_printf(b, "\n");
-	buf_printf(b, "static const char __module_depends[]\n");
-	buf_printf(b, "__used\n");
-	buf_printf(b, "__attribute__((section(\".modinfo\"))) =\n");
-	buf_printf(b, "\"depends=");
+	buf_printf(b, "MODULE_INFO(depends, \"");
 	for (s = mod->unres; s; s = s->next) {
 		const char *p;
 		if (!s->module)
@@ -2288,7 +2285,7 @@ static void add_depends(struct buffer *b, struct module *mod)
 		buf_printf(b, "%s%s", first ? "" : ",", p);
 		first = 0;
 	}
-	buf_printf(b, "\";\n");
+	buf_printf(b, "\");\n");
 }
 
 static void add_srcversion(struct buffer *b, struct module *mod)

commit 1d082773ff30e97c8bc10b65c4aa0d073664caac
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:31 2019 +0100

    modpost: add support for generating namespace dependencies
    
    This patch adds an option to modpost to generate a <module>.ns_deps file
    per module, containing the namespace dependencies for that module.
    
    E.g. if the linked module my-module.ko would depend on the symbol
    myfunc.MY_NS in the namespace MY_NS, the my-module.ns_deps file created
    by modpost would contain the entry MY_NS to express the namespace
    dependency of my-module imposed by using the symbol myfunc.
    
    These files can subsequently be used by static analysis tools (like
    coccinelle scripts) to address issues with missing namespace imports. A
    later patch of this series will introduce such a script 'nsdeps' and a
    corresponding make target to automatically add missing
    MODULE_IMPORT_NS() definitions to the module's sources. For that it uses
    the information provided in the generated .ns_deps files.
    
    Co-developed-by: Martijn Coenen <maco@android.com>
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c2d49afaea1c..be72da25fe7c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -38,6 +38,8 @@ static int sec_mismatch_count = 0;
 static int sec_mismatch_fatal = 0;
 /* ignore missing files */
 static int ignore_missing_files;
+/* write namespace dependencies */
+static int write_namespace_deps;
 
 enum export {
 	export_plain,      export_unused,     export_gpl,
@@ -2176,10 +2178,15 @@ static int check_exports(struct module *mod)
 		else
 			basename = mod->name;
 
-		if (exp->namespace &&
-		    !module_imports_namespace(mod, exp->namespace)) {
-			warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
-			     basename, exp->name, exp->namespace);
+		if (exp->namespace) {
+			add_namespace(&mod->required_namespaces,
+				      exp->namespace);
+
+			if (!write_namespace_deps &&
+			    !module_imports_namespace(mod, exp->namespace)) {
+				warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
+				     basename, exp->name, exp->namespace);
+			}
 		}
 
 		if (!mod->gpl_compatible)
@@ -2484,6 +2491,31 @@ static void write_dump(const char *fname)
 	free(buf.p);
 }
 
+static void write_namespace_deps_files(void)
+{
+	struct module *mod;
+	struct namespace_list *ns;
+	struct buffer ns_deps_buf = {};
+
+	for (mod = modules; mod; mod = mod->next) {
+		char fname[PATH_MAX];
+
+		if (mod->skip)
+			continue;
+
+		ns_deps_buf.pos = 0;
+
+		for (ns = mod->required_namespaces; ns; ns = ns->next)
+			buf_printf(&ns_deps_buf, "%s\n", ns->namespace);
+
+		if (ns_deps_buf.pos == 0)
+			continue;
+
+		sprintf(fname, "%s.ns_deps", mod->name);
+		write_if_changed(&ns_deps_buf, fname);
+	}
+}
+
 struct ext_sym_list {
 	struct ext_sym_list *next;
 	const char *file;
@@ -2500,7 +2532,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:mnsT:o:awE")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:mnsT:o:awEd")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2541,6 +2573,9 @@ int main(int argc, char **argv)
 		case 'E':
 			sec_mismatch_fatal = 1;
 			break;
+		case 'd':
+			write_namespace_deps = 1;
+			break;
 		default:
 			exit(1);
 		}
@@ -2575,6 +2610,9 @@ int main(int argc, char **argv)
 
 		err |= check_modname_len(mod);
 		err |= check_exports(mod);
+		if (write_namespace_deps)
+			continue;
+
 		add_header(&buf, mod);
 		add_intree_flag(&buf, !external_module);
 		add_retpoline(&buf);
@@ -2587,6 +2625,12 @@ int main(int argc, char **argv)
 		sprintf(fname, "%s.mod.c", mod->name);
 		write_if_changed(&buf, fname);
 	}
+
+	if (write_namespace_deps) {
+		write_namespace_deps_files();
+		return 0;
+	}
+
 	if (dump_write)
 		write_dump(dump_write);
 	if (sec_mismatch_count && sec_mismatch_fatal)

commit cb9b55d21fe06ca5e4ba244bb5aac0afeb745c8e
Author: Matthias Maennich <maennich@google.com>
Date:   Fri Sep 6 11:32:28 2019 +0100

    modpost: add support for symbol namespaces
    
    Add support for symbols that are exported into namespaces. For that,
    extract any namespace suffix from the symbol name. In addition, emit a
    warning whenever a module refers to an exported symbol without
    explicitly importing the namespace that it is defined in. This patch
    consistently adds the namespace suffix to symbol names exported into
    Module.symvers.
    
    Example warning emitted by modpost in case of the above violation:
    
     WARNING: module ums-usbat uses symbol usb_stor_resume from namespace
     USB_STORAGE, but does not import it.
    
    Co-developed-by: Martijn Coenen <maco@android.com>
    Signed-off-by: Martijn Coenen <maco@android.com>
    Reviewed-by: Joel Fernandes (Google) <joel@joelfernandes.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Matthias Maennich <maennich@google.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f277e116e0eb..c2d49afaea1c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -164,6 +164,7 @@ struct symbol {
 	struct module *module;
 	unsigned int crc;
 	int crc_valid;
+	const char *namespace;
 	unsigned int weak:1;
 	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
@@ -233,6 +234,37 @@ static struct symbol *find_symbol(const char *name)
 	return NULL;
 }
 
+static bool contains_namespace(struct namespace_list *list,
+			       const char *namespace)
+{
+	struct namespace_list *ns_entry;
+
+	for (ns_entry = list; ns_entry != NULL; ns_entry = ns_entry->next)
+		if (strcmp(ns_entry->namespace, namespace) == 0)
+			return true;
+
+	return false;
+}
+
+static void add_namespace(struct namespace_list **list, const char *namespace)
+{
+	struct namespace_list *ns_entry;
+
+	if (!contains_namespace(*list, namespace)) {
+		ns_entry = NOFAIL(malloc(sizeof(struct namespace_list) +
+					 strlen(namespace) + 1));
+		strcpy(ns_entry->namespace, namespace);
+		ns_entry->next = *list;
+		*list = ns_entry;
+	}
+}
+
+static bool module_imports_namespace(struct module *module,
+				     const char *namespace)
+{
+	return contains_namespace(module->imported_namespaces, namespace);
+}
+
 static const struct {
 	const char *str;
 	enum export export;
@@ -312,23 +344,39 @@ static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 		return export_unknown;
 }
 
+static const char *sym_extract_namespace(const char **symname)
+{
+	size_t n;
+	char *dupsymname;
+
+	n = strcspn(*symname, ".");
+	if (n < strlen(*symname) - 1) {
+		dupsymname = NOFAIL(strdup(*symname));
+		dupsymname[n] = '\0';
+		*symname = dupsymname;
+		return dupsymname + n + 1;
+	}
+
+	return NULL;
+}
+
 /**
  * Add an exported symbol - it may have already been added without a
  * CRC, in this case just update the CRC
  **/
-static struct symbol *sym_add_exported(const char *name, struct module *mod,
-				       enum export export)
+static struct symbol *sym_add_exported(const char *name, const char *namespace,
+				       struct module *mod, enum export export)
 {
 	struct symbol *s = find_symbol(name);
 
 	if (!s) {
 		s = new_symbol(name, mod, export);
+		s->namespace = namespace;
 	} else {
 		if (!s->preloaded) {
-			warn("%s: '%s' exported twice. Previous export "
-			     "was in %s%s\n", mod->name, name,
-			     s->module->name,
-			     is_vmlinux(s->module->name) ?"":".ko");
+			warn("%s: '%s' exported twice. Previous export was in %s%s\n",
+			     mod->name, name, s->module->name,
+			     is_vmlinux(s->module->name) ? "" : ".ko");
 		} else {
 			/* In case Module.symvers was out of date */
 			s->module = mod;
@@ -620,6 +668,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	unsigned int crc;
 	enum export export;
 	bool is_crc = false;
+	const char *name, *namespace;
 
 	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
 	    strstarts(symname, "__ksymtab"))
@@ -691,8 +740,9 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	default:
 		/* All exported symbols */
 		if (strstarts(symname, "__ksymtab_")) {
-			sym_add_exported(symname + strlen("__ksymtab_"), mod,
-					export);
+			name = symname + strlen("__ksymtab_");
+			namespace = sym_extract_namespace(&name);
+			sym_add_exported(name, namespace, mod, export);
 		}
 		if (strcmp(symname, "init_module") == 0)
 			mod->has_init = 1;
@@ -1943,6 +1993,7 @@ static void read_symbols(const char *modname)
 	const char *symname;
 	char *version;
 	char *license;
+	char *namespace;
 	struct module *mod;
 	struct elf_info info = { };
 	Elf_Sym *sym;
@@ -1974,6 +2025,12 @@ static void read_symbols(const char *modname)
 		license = get_next_modinfo(&info, "license", license);
 	}
 
+	namespace = get_modinfo(&info, "import_ns");
+	while (namespace) {
+		add_namespace(&mod->imported_namespaces, namespace);
+		namespace = get_next_modinfo(&info, "import_ns", namespace);
+	}
+
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		symname = remove_dot(info.strtab + sym->st_name);
 
@@ -2118,6 +2175,13 @@ static int check_exports(struct module *mod)
 			basename++;
 		else
 			basename = mod->name;
+
+		if (exp->namespace &&
+		    !module_imports_namespace(mod, exp->namespace)) {
+			warn("module %s uses symbol %s from namespace %s, but does not import it.\n",
+			     basename, exp->name, exp->namespace);
+		}
+
 		if (!mod->gpl_compatible)
 			check_for_gpl_usage(exp->export, basename, exp->name);
 		check_for_unused(exp->export, basename, exp->name);
@@ -2341,7 +2405,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		return;
 
 	while ((line = get_next_line(&pos, file, size))) {
-		char *symname, *modname, *d, *export, *end;
+		char *symname, *namespace, *modname, *d, *export, *end;
 		unsigned int crc;
 		struct module *mod;
 		struct symbol *s;
@@ -2349,7 +2413,10 @@ static void read_dump(const char *fname, unsigned int kernel)
 		if (!(symname = strchr(line, '\t')))
 			goto fail;
 		*symname++ = '\0';
-		if (!(modname = strchr(symname, '\t')))
+		if (!(namespace = strchr(symname, '\t')))
+			goto fail;
+		*namespace++ = '\0';
+		if (!(modname = strchr(namespace, '\t')))
 			goto fail;
 		*modname++ = '\0';
 		if ((export = strchr(modname, '\t')) != NULL)
@@ -2366,7 +2433,8 @@ static void read_dump(const char *fname, unsigned int kernel)
 			mod = new_module(modname);
 			mod->skip = 1;
 		}
-		s = sym_add_exported(symname, mod, export_no(export));
+		s = sym_add_exported(symname, namespace, mod,
+				     export_no(export));
 		s->kernel    = kernel;
 		s->preloaded = 1;
 		sym_update_crc(symname, mod, crc, export_no(export));
@@ -2395,16 +2463,20 @@ static void write_dump(const char *fname)
 {
 	struct buffer buf = { };
 	struct symbol *symbol;
+	const char *namespace;
 	int n;
 
 	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
 		symbol = symbolhash[n];
 		while (symbol) {
-			if (dump_sym(symbol))
-				buf_printf(&buf, "0x%08x\t%s\t%s\t%s\n",
-					symbol->crc, symbol->name,
-					symbol->module->name,
-					export_str(symbol->export));
+			if (dump_sym(symbol)) {
+				namespace = symbol->namespace;
+				buf_printf(&buf, "0x%08x\t%s\t%s\t%s\t%s\n",
+					   symbol->crc, symbol->name,
+					   namespace ? namespace : "",
+					   symbol->module->name,
+					   export_str(symbol->export));
+			}
 			symbol = symbol->next;
 		}
 	}

commit 6f02bdfc995f098bde87216c122ade2b46f971b5
Author: Denis Efremov <efremov@linux.com>
Date:   Tue Aug 27 15:20:23 2019 +0300

    modpost: add NOFAIL to strndup
    
    Add NOFAIL check for the strndup call, because the function
    allocates memory and can return NULL. All calls to strdup in
    modpost are checked with NOFAIL.
    
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2773f9f9bae2..76c221dd9b2b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -797,9 +797,9 @@ static int match(const char *sym, const char * const pat[])
 
 		/* "*foo*" */
 		if (*p == '*' && *endp == '*') {
-			char *here, *bare = strndup(p + 1, strlen(p) - 2);
+			char *bare = NOFAIL(strndup(p + 1, strlen(p) - 2));
+			char *here = strstr(sym, bare);
 
-			here = strstr(sym, bare);
 			free(bare);
 			if (here != NULL)
 				return 1;

commit 15bfc2348d549b44bdca266747f71c0d54bc0e5f
Author: Denis Efremov <efremov@linux.com>
Date:   Thu Aug 1 09:06:57 2019 +0300

    modpost: check for static EXPORT_SYMBOL* functions
    
    This patch adds a check to warn about static EXPORT_SYMBOL* functions
    during the modpost. In most of the cases, a static symbol marked for
    exporting is an odd combination that should be fixed either by deleting
    the exporting mark or by removing the static attribute and adding the
    appropriate declaration to headers.
    
    This check could help to detect the following problems:
    1. 550113d4e9f5 ("i2c: add newly exported functions to the header, too")
    2. 54638c6eaf44 ("net: phy: make exported variables non-static")
    3. 98ef2046f28b ("mm: remove the exporting of totalram_pages")
    4. 73df167c819e ("s390/zcrypt: remove the exporting of ap_query_configuration")
    5. a57caf8c527f ("sunrpc/cache: remove the exporting of cache_seq_next")
    6. e4e4730698c9 ("crypto: skcipher - remove the exporting of skcipher_walk_next")
    7. 14b4c48bb1ce ("gve: Remove the exporting of gve_probe")
    8. 9b79ee9773a8 ("scsi: libsas: remove the exporting of sas_wait_eh")
    9. ...
    
    The build time impact is very limited and is almost at the unnoticeable
    level (< 1 sec).
    
    Acked-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f277e116e0eb..2773f9f9bae2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -169,6 +169,7 @@ struct symbol {
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
 				    *  (only for external modules) **/
 	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers, or crc */
+	unsigned int is_static:1;  /* 1 if symbol is not global */
 	enum export  export;       /* Type of export */
 	char name[0];
 };
@@ -201,6 +202,7 @@ static struct symbol *alloc_symbol(const char *name, unsigned int weak,
 	strcpy(s->name, name);
 	s->weak = weak;
 	s->next = next;
+	s->is_static = 1;
 	return s;
 }
 
@@ -1980,6 +1982,21 @@ static void read_symbols(const char *modname)
 		handle_modversions(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);
 	}
+
+	// check for static EXPORT_SYMBOL_* functions && global vars
+	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
+		unsigned char bind = ELF_ST_BIND(sym->st_info);
+
+		if (bind == STB_GLOBAL || bind == STB_WEAK) {
+			struct symbol *s =
+				find_symbol(remove_dot(info.strtab +
+						       sym->st_name));
+
+			if (s)
+				s->is_static = 0;
+		}
+	}
+
 	if (!is_vmlinux(modname) || vmlinux_section_warnings)
 		check_sec_ref(mod, modname, &info);
 
@@ -2369,6 +2386,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		s = sym_add_exported(symname, mod, export_no(export));
 		s->kernel    = kernel;
 		s->preloaded = 1;
+		s->is_static = 0;
 		sym_update_crc(symname, mod, crc, export_no(export));
 	}
 	release_file(file, size);
@@ -2425,6 +2443,7 @@ int main(int argc, char **argv)
 	char *dump_write = NULL, *files_source = NULL;
 	int opt;
 	int err;
+	int n;
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
@@ -2520,6 +2539,19 @@ int main(int argc, char **argv)
 	if (sec_mismatch_count && sec_mismatch_fatal)
 		fatal("modpost: Section mismatches detected.\n"
 		      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
+	for (n = 0; n < SYMBOL_HASH_SIZE; n++) {
+		struct symbol *s = symbolhash[n];
+
+		while (s) {
+			if (s->is_static)
+				warn("\"%s\" [%s] is a static %s\n",
+				     s->name, s->module->name,
+				     export_str(s->export));
+
+			s = s->next;
+		}
+	}
+
 	free(buf.p);
 
 	return err;

commit 54a7151b1496cddbb7a83546b7998103e98edc88
Author: Fredrik Noring <noring@nocrew.org>
Date:   Wed Mar 27 19:12:50 2019 +0100

    kbuild: modversions: Fix relative CRC byte order interpretation
    
    Fix commit 56067812d5b0 ("kbuild: modversions: add infrastructure for
    emitting relative CRCs") where CRCs are interpreted in host byte order
    rather than proper kernel byte order. The bug is conditional on
    CONFIG_MODULE_REL_CRCS.
    
    For example, when loading a BE module into a BE kernel compiled with a LE
    system, the error "disagrees about version of symbol module_layout" is
    produced. A message such as "Found checksum D7FA6856 vs module 5668FAD7"
    will be given with debug enabled, which indicates an obvious endian
    problem within __kcrctab within the kernel image.
    
    The general solution is to use the macro TO_NATIVE, as is done in
    similar cases throughout modpost.c. With this correction it has been
    verified that a BE kernel compiled with a LE system accepts BE modules.
    
    This change has also been verified with a LE kernel compiled with a LE
    system, in which case TO_NATIVE returns its value unmodified since the
    byte orders match. This is by far the common case.
    
    Fixes: 56067812d5b0 ("kbuild: modversions: add infrastructure for emitting relative CRCs")
    Signed-off-by: Fredrik Noring <noring@nocrew.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0b0d1080b1c5..f277e116e0eb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -639,7 +639,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			       info->sechdrs[sym->st_shndx].sh_offset -
 			       (info->hdr->e_type != ET_REL ?
 				info->sechdrs[sym->st_shndx].sh_addr : 0);
-			crc = *crcp;
+			crc = TO_NATIVE(*crcp);
 		}
 		sym_update_crc(symname + strlen("__crc_"), mod, crc,
 				export);

commit 46c7dd56d54133e3fb9414844d90e563627f3feb
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Feb 1 13:50:45 2019 +0900

    modpost: always show verbose warning for section mismatch
    
    Unless CONFIG_DEBUG_SECTION_MISMATCH is enabled, modpost only shows
    the number of section mismatches.
    
    If you want to know the symbols causing the issue, you need to rebuild
    with CONFIG_DEBUG_SECTION_MISMATCH. It is tedious.
    
    I think it is fine to show annoying warning when a new section mismatch
    comes in.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 26bf886bd168..0b0d1080b1c5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -35,7 +35,6 @@ static int vmlinux_section_warnings = 1;
 static int warn_unresolved = 0;
 /* How a symbol is exported */
 static int sec_mismatch_count = 0;
-static int sec_mismatch_verbose = 1;
 static int sec_mismatch_fatal = 0;
 /* ignore missing files */
 static int ignore_missing_files;
@@ -1406,8 +1405,6 @@ static void report_sec_mismatch(const char *modname,
 	char *prl_to;
 
 	sec_mismatch_count++;
-	if (!sec_mismatch_verbose)
-		return;
 
 	get_pretty_name(from_is_func, &from, &from_p);
 	get_pretty_name(to_is_func, &to, &to_p);
@@ -1655,9 +1652,7 @@ static void extable_mismatch_handler(const char* modname, struct elf_info *elf,
 
 	sec_mismatch_count++;
 
-	if (sec_mismatch_verbose)
-		report_extable_warnings(modname, elf, mismatch, r, sym,
-					fromsec, tosec);
+	report_extable_warnings(modname, elf, mismatch, r, sym, fromsec, tosec);
 
 	if (match(tosec, mismatch->bad_tosec))
 		fatal("The relocation at %s+0x%lx references\n"
@@ -2433,7 +2428,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awE")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:mnsT:o:awE")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2465,9 +2460,6 @@ int main(int argc, char **argv)
 		case 's':
 			vmlinux_section_warnings = 0;
 			break;
-		case 'S':
-			sec_mismatch_verbose = 0;
-			break;
 		case 'T':
 			files_source = optarg;
 			break;
@@ -2525,18 +2517,9 @@ int main(int argc, char **argv)
 	}
 	if (dump_write)
 		write_dump(dump_write);
-	if (sec_mismatch_count) {
-		if (!sec_mismatch_verbose) {
-			warn("modpost: Found %d section mismatch(es).\n"
-			     "To see full details build your kernel with:\n"
-			     "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
-			     sec_mismatch_count);
-		}
-		if (sec_mismatch_fatal) {
-			fatal("modpost: Section mismatches detected.\n"
-			      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
-		}
-	}
+	if (sec_mismatch_count && sec_mismatch_fatal)
+		fatal("modpost: Section mismatches detected.\n"
+		      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
 	free(buf.p);
 
 	return err;

commit e4f358916d528d479c3c12bd2fd03f2d5a576380
Author: WANG Chao <chao.wang@ucloud.cn>
Date:   Tue Dec 11 00:37:25 2018 +0800

    x86, modpost: Replace last remnants of RETPOLINE with CONFIG_RETPOLINE
    
    Commit
    
      4cd24de3a098 ("x86/retpoline: Make CONFIG_RETPOLINE depend on compiler support")
    
    replaced the RETPOLINE define with CONFIG_RETPOLINE checks. Remove the
    remaining pieces.
    
     [ bp: Massage commit message. ]
    
    Fixes: 4cd24de3a098 ("x86/retpoline: Make CONFIG_RETPOLINE depend on compiler support")
    Signed-off-by: WANG Chao <chao.wang@ucloud.cn>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Zhenzhong Duan <zhenzhong.duan@oracle.com>
    Reviewed-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: David Woodhouse <dwmw@amazon.co.uk>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Jessica Yu <jeyu@kernel.org>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Cc: Michal Marek <michal.lkml@markovi.net>
    Cc: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: linux-kbuild@vger.kernel.org
    Cc: srinivas.eeda@oracle.com
    Cc: stable <stable@vger.kernel.org>
    Cc: x86-ml <x86@kernel.org>
    Link: https://lkml.kernel.org/r/20181210163725.95977-1-chao.wang@ucloud.cn

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0de2fb236640..26bf886bd168 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2185,7 +2185,7 @@ static void add_intree_flag(struct buffer *b, int is_intree)
 /* Cannot check for assembler */
 static void add_retpoline(struct buffer *b)
 {
-	buf_printf(b, "\n#ifdef RETPOLINE\n");
+	buf_printf(b, "\n#ifdef CONFIG_RETPOLINE\n");
 	buf_printf(b, "MODULE_INFO(retpoline, \"Y\");\n");
 	buf_printf(b, "#endif\n");
 }

commit 3b4152880348287b6b3d9a0708f1e2f4c540f3d0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 23 16:57:23 2018 +0900

    modpost: move unresolved symbol checks to check_exports()
    
    This will fit better in check_exports() than add_versions().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 963a0b69b9a3..0de2fb236640 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2097,15 +2097,27 @@ static void check_for_unused(enum export exp, const char *m, const char *s)
 	}
 }
 
-static void check_exports(struct module *mod)
+static int check_exports(struct module *mod)
 {
 	struct symbol *s, *exp;
+	int err = 0;
 
 	for (s = mod->unres; s; s = s->next) {
 		const char *basename;
 		exp = find_symbol(s->name);
-		if (!exp || exp->module == mod)
+		if (!exp || exp->module == mod) {
+			if (have_vmlinux && !s->weak) {
+				if (warn_unresolved) {
+					warn("\"%s\" [%s.ko] undefined!\n",
+					     s->name, mod->name);
+				} else {
+					merror("\"%s\" [%s.ko] undefined!\n",
+					       s->name, mod->name);
+					err = 1;
+				}
+			}
 			continue;
+		}
 		basename = strrchr(mod->name, '/');
 		if (basename)
 			basename++;
@@ -2115,6 +2127,8 @@ static void check_exports(struct module *mod)
 			check_for_gpl_usage(exp->export, basename, exp->name);
 		check_for_unused(exp->export, basename, exp->name);
 	}
+
+	return err;
 }
 
 static int check_modname_len(struct module *mod)
@@ -2192,19 +2206,8 @@ static int add_versions(struct buffer *b, struct module *mod)
 
 	for (s = mod->unres; s; s = s->next) {
 		exp = find_symbol(s->name);
-		if (!exp || exp->module == mod) {
-			if (have_vmlinux && !s->weak) {
-				if (warn_unresolved) {
-					warn("\"%s\" [%s.ko] undefined!\n",
-					     s->name, mod->name);
-				} else {
-					merror("\"%s\" [%s.ko] undefined!\n",
-					       s->name, mod->name);
-					err = 1;
-				}
-			}
+		if (!exp || exp->module == mod)
 			continue;
-		}
 		s->module = exp->module;
 		s->crc_valid = exp->crc_valid;
 		s->crc = exp->crc;
@@ -2507,7 +2510,7 @@ int main(int argc, char **argv)
 		buf.pos = 0;
 
 		err |= check_modname_len(mod);
-		check_exports(mod);
+		err |= check_exports(mod);
 		add_header(&buf, mod);
 		add_intree_flag(&buf, !external_module);
 		add_retpoline(&buf);

commit c6826ad8a49f1230dcbc45dac26b54d492b13280
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 23 16:57:22 2018 +0900

    modpost: merge module iterations
    
    Probably, this is just a matter of the order of error/warning
    messages. Merge the two for-loops.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index eedc2742dc8e..963a0b69b9a3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2496,12 +2496,6 @@ int main(int argc, char **argv)
 	if (files_source)
 		read_symbols_from_files(files_source);
 
-	for (mod = modules; mod; mod = mod->next) {
-		if (mod->skip)
-			continue;
-		check_exports(mod);
-	}
-
 	err = 0;
 
 	for (mod = modules; mod; mod = mod->next) {
@@ -2513,6 +2507,7 @@ int main(int argc, char **argv)
 		buf.pos = 0;
 
 		err |= check_modname_len(mod);
+		check_exports(mod);
 		add_header(&buf, mod);
 		add_intree_flag(&buf, !external_module);
 		add_retpoline(&buf);

commit d2665ca8e3310d045b62397590ab54dc485e035e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 23 16:57:21 2018 +0900

    modpost: refactor seen flag clearing in add_depends()
    
    You do not need to iterate over all modules for resetting ->seen flag
    because add_depends() is only interested in modules that export symbols
    referenced from the given 'mod'.
    
    This also avoids shadowing the 'modules' parameter of add_depends().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3aab410f020e..eedc2742dc8e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2241,15 +2241,15 @@ static int add_versions(struct buffer *b, struct module *mod)
 	return err;
 }
 
-static void add_depends(struct buffer *b, struct module *mod,
-			struct module *modules)
+static void add_depends(struct buffer *b, struct module *mod)
 {
 	struct symbol *s;
-	struct module *m;
 	int first = 1;
 
-	for (m = modules; m; m = m->next)
-		m->seen = is_vmlinux(m->name);
+	/* Clear ->seen flag of modules that own symbols needed by this. */
+	for (s = mod->unres; s; s = s->next)
+		if (s->module)
+			s->module->seen = is_vmlinux(s->module->name);
 
 	buf_printf(b, "\n");
 	buf_printf(b, "static const char __module_depends[]\n");
@@ -2518,7 +2518,7 @@ int main(int argc, char **argv)
 		add_retpoline(&buf);
 		add_staging_flag(&buf, mod->name);
 		err |= add_versions(&buf, mod);
-		add_depends(&buf, mod, modules);
+		add_depends(&buf, mod);
 		add_moddevtable(&buf, mod);
 		add_srcversion(&buf, mod);
 

commit a4d26f1a0958bb1c2b60c6f1e67c6f5d43e2647b
Author: Paul Walmsley <paul.walmsley@sifive.com>
Date:   Wed Nov 21 13:14:13 2018 -0800

    modpost: skip ELF local symbols during section mismatch check
    
    During development of a serial console driver with a gcc 8.2.0
    toolchain for RISC-V, the following modpost warning appeared:
    
    ----
    WARNING: vmlinux.o(.data+0x19b10): Section mismatch in reference from the variable .LANCHOR1 to the function .init.text:sifive_serial_console_setup()
    The variable .LANCHOR1 references
    the function __init sifive_serial_console_setup()
    If the reference is valid then annotate the
    variable with __init* or __refdata (see linux/init.h) or name the variable:
    *_template, *_timer, *_sht, *_ops, *_probe, *_probe_one, *_console
    ----
    
    ".LANCHOR1" is an ELF local symbol, automatically created by gcc's section
    anchor generation code:
    
    https://gcc.gnu.org/onlinedocs/gccint/Anchored-Addresses.html
    
    https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=gcc/varasm.c;h=cd9591a45617464946dcf9a126dde277d9de9804;hb=9fb89fa845c1b2e0a18d85ada0b077c84508ab78#l7473
    
    This was verified by compiling the kernel with -fno-section-anchors
    and observing that the ".LANCHOR1" ELF local symbol disappeared, and
    modpost no longer warned about the section mismatch.  The serial
    driver code idiom triggering the warning is standard Linux serial
    driver practice that has a specific whitelist inclusion in modpost.c.
    
    I'm neither a modpost nor an ELF expert, but naively, it doesn't seem
    useful for modpost to report section mismatch warnings caused by ELF
    local symbols by default.  Local symbols have compiler-generated
    names, and thus bypass modpost's whitelisting algorithm, which relies
    on the presence of a non-autogenerated symbol name.  This increases
    the likelihood that false positive warnings will be generated (as in
    the above case).
    
    Thus, disable section mismatch reporting on ELF local symbols.  The
    rationale here is similar to that of commit 2e3a10a1551d ("ARM: avoid
    ARM binutils leaking ELF local symbols") and of similar code already
    present in modpost.c:
    
    https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/scripts/mod/modpost.c?h=v4.19-rc4&id=7876320f88802b22d4e2daf7eb027dd14175a0f8#n1256
    
    This third version of the patch implements a suggestion from Masahiro
    Yamada <yamada.masahiro@socionext.com> to restructure the code as an
    additional pattern matching step inside secref_whitelist(), and
    further improves the patch description.
    
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c64066dcd2e4..3aab410f020e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1163,6 +1163,14 @@ static const struct sectioncheck *section_mismatch(
  *   fromsec = text section
  *   refsymname = *.constprop.*
  *
+ * Pattern 6:
+ *   Hide section mismatch warnings for ELF local symbols.  The goal
+ *   is to eliminate false positive modpost warnings caused by
+ *   compiler-generated ELF local symbol names such as ".LANCHOR1".
+ *   Autogenerated symbol names bypass modpost's "Pattern 2"
+ *   whitelisting, which relies on pattern-matching against symbol
+ *   names to work.  (One situation where gcc can autogenerate ELF
+ *   local symbols is when "-fsection-anchors" is used.)
  **/
 static int secref_whitelist(const struct sectioncheck *mismatch,
 			    const char *fromsec, const char *fromsym,
@@ -1201,6 +1209,10 @@ static int secref_whitelist(const struct sectioncheck *mismatch,
 	    match(fromsym, optim_symbols))
 		return 0;
 
+	/* Check for pattern 6 */
+	if (strstarts(fromsym, ".L"))
+		return 0;
+
 	return 1;
 }
 

commit 0987abcbeea4c87aef80a6138efc13ed0798fcf2
Author: Paul Walmsley <paul.walmsley@sifive.com>
Date:   Wed Nov 14 16:56:01 2018 -0800

    modpost: drop unused command line switches
    
    Drop modpost command line switches that are no longer used by
    makefile.modpost, upon request from Sam Ravnborg <sam@ravnborg.org>,
    who wrote:
    
        modpost is not supposed to be used outside the kernel build. [...]
        I checked if there were any options supported by modpost that
        was not configurable in Makefile.modpost.
        And I could see that the -M and -K options in getopt() were leftovers.
        The code that used these option was dropped in:
        commit a8773769d1a1 ("Kbuild: clear marker out of modpost")
    
        Could you add a patch that delete these on top of what you already have.
    
    https://lore.kernel.org/lkml/20181020140835.GA3351@ravnborg.org/
    
    Suggested-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Paul Walmsley <paul.walmsley@sifive.com>
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b709b2e623d6..c64066dcd2e4 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2418,7 +2418,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awM:K:E")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awE")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;

commit 5818c683a619c534c113e1f66d24f636defc29bc
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Tue Oct 23 15:15:35 2018 -0700

    modpost: validate symbol names also in find_elf_symbol
    
    If an ARM mapping symbol shares an address with a valid symbol,
    find_elf_symbol can currently return the mapping symbol instead, as the
    symbol is not validated. This can result in confusing warnings:
    
      WARNING: vmlinux.o(.text+0x18f4028): Section mismatch in reference
      from the function set_reset_devices() to the variable .init.text:$x.0
    
    This change adds a call to is_valid_name to find_elf_symbol, similarly
    to how it's already used in find_elf_symbol2.
    
    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0d998c54564d..b709b2e623d6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1204,6 +1204,30 @@ static int secref_whitelist(const struct sectioncheck *mismatch,
 	return 1;
 }
 
+static inline int is_arm_mapping_symbol(const char *str)
+{
+	return str[0] == '$' && strchr("axtd", str[1])
+	       && (str[2] == '\0' || str[2] == '.');
+}
+
+/*
+ * If there's no name there, ignore it; likewise, ignore it if it's
+ * one of the magic symbols emitted used by current ARM tools.
+ *
+ * Otherwise if find_symbols_between() returns those symbols, they'll
+ * fail the whitelist tests and cause lots of false alarms ... fixable
+ * only by merging __exit and __init sections into __text, bloating
+ * the kernel (which is especially evil on embedded platforms).
+ */
+static inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)
+{
+	const char *name = elf->strtab + sym->st_name;
+
+	if (!name || !strlen(name))
+		return 0;
+	return !is_arm_mapping_symbol(name);
+}
+
 /**
  * Find symbol based on relocation record info.
  * In some cases the symbol supplied is a valid symbol so
@@ -1229,6 +1253,8 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,
 			continue;
 		if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
 			continue;
+		if (!is_valid_name(elf, sym))
+			continue;
 		if (sym->st_value == addr)
 			return sym;
 		/* Find a symbol nearby - addr are maybe negative */
@@ -1247,30 +1273,6 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,
 		return NULL;
 }
 
-static inline int is_arm_mapping_symbol(const char *str)
-{
-	return str[0] == '$' && strchr("axtd", str[1])
-	       && (str[2] == '\0' || str[2] == '.');
-}
-
-/*
- * If there's no name there, ignore it; likewise, ignore it if it's
- * one of the magic symbols emitted used by current ARM tools.
- *
- * Otherwise if find_symbols_between() returns those symbols, they'll
- * fail the whitelist tests and cause lots of false alarms ... fixable
- * only by merging __exit and __init sections into __text, bloating
- * the kernel (which is especially evil on embedded platforms).
- */
-static inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)
-{
-	const char *name = elf->strtab + sym->st_name;
-
-	if (!name || !strlen(name))
-		return 0;
-	return !is_arm_mapping_symbol(name);
-}
-
 /*
  * Find symbols before or equal addr and after addr - in the section sec.
  * If we find two symbols with equal offset prefer one with a valid name.

commit 1f3aa9002dc6a0d59a4b599b4fc8f01cf43ef014
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Wed Aug 15 12:30:38 2018 -0700

    scripts: modpost: check memory allocation results
    
    Fix missing error check for memory allocation functions in
    scripts/mod/modpost.c.
    
    Fixes kernel bugzilla #200319:
    https://bugzilla.kernel.org/show_bug.cgi?id=200319
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yuexing Wang <wangyxlandq@gmail.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index dc6d714e4dcb..0d998c54564d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -672,7 +672,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			if (ELF_ST_TYPE(sym->st_info) == STT_SPARC_REGISTER)
 				break;
 			if (symname[0] == '.') {
-				char *munged = strdup(symname);
+				char *munged = NOFAIL(strdup(symname));
 				munged[0] = '_';
 				munged[1] = toupper(munged[1]);
 				symname = munged;
@@ -1318,7 +1318,7 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 static char *sec2annotation(const char *s)
 {
 	if (match(s, init_exit_sections)) {
-		char *p = malloc(20);
+		char *p = NOFAIL(malloc(20));
 		char *r = p;
 
 		*p++ = '_';
@@ -1338,7 +1338,7 @@ static char *sec2annotation(const char *s)
 			strcat(p, " ");
 		return r;
 	} else {
-		return strdup("");
+		return NOFAIL(strdup(""));
 	}
 }
 
@@ -2036,7 +2036,7 @@ void buf_write(struct buffer *buf, const char *s, int len)
 {
 	if (buf->size - buf->pos < len) {
 		buf->size += len + SZ;
-		buf->p = realloc(buf->p, buf->size);
+		buf->p = NOFAIL(realloc(buf->p, buf->size));
 	}
 	strncpy(buf->p + buf->pos, s, len);
 	buf->pos += len;

commit 9afb719e7046c4f2462278862ab3db2961cc141c
Author: Laura Abbott <labbott@redhat.com>
Date:   Thu Jul 5 17:49:37 2018 -0700

    kbuild: Add build salt to the kernel and modules
    
    In Fedora, the debug information is packaged separately (foo-debuginfo) and
    can be installed separately. There's been a long standing issue where only
    one version of a debuginfo info package can be installed at a time. There's
    been an effort for Fedora for parallel debuginfo to rectify this problem.
    
    Part of the requirement to allow parallel debuginfo to work is that build ids
    are unique between builds. The existing upstream rpm implementation ensures
    this by re-calculating the build-id using the version and release as a
    seed. This doesn't work 100% for the kernel because of the vDSO which is
    its own binary and doesn't get updated when embedded.
    
    Fix this by adding some data in an ELF note for both the kernel and modules.
    The data is controlled via a Kconfig option so distributions can set it
    to an appropriate value to ensure uniqueness between builds.
    
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Laura Abbott <labbott@redhat.com>
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1663fb19343a..dc6d714e4dcb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2125,10 +2125,13 @@ static int check_modname_len(struct module *mod)
  **/
 static void add_header(struct buffer *b, struct module *mod)
 {
+	buf_printf(b, "#include <linux/build-salt.h>\n");
 	buf_printf(b, "#include <linux/module.h>\n");
 	buf_printf(b, "#include <linux/vermagic.h>\n");
 	buf_printf(b, "#include <linux/compiler.h>\n");
 	buf_printf(b, "\n");
+	buf_printf(b, "BUILD_SALT;\n");
+	buf_printf(b, "\n");
 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
 	buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
 	buf_printf(b, "\n");

commit 8b1857436baa2b9b6d7330715180aa47a63b15ca
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 18:50:40 2018 +0900

    modpost: constify *modname function argument where possible
    
    Neither find_module() nor read_symbols() does change *modname.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 9e70a6ac1fcb..1663fb19343a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -121,7 +121,7 @@ void *do_nofail(void *ptr, const char *expr)
 /* A list of all modules we processed */
 static struct module *modules;
 
-static struct module *find_module(char *modname)
+static struct module *find_module(const char *modname)
 {
 	struct module *mod;
 
@@ -1929,7 +1929,7 @@ static char *remove_dot(char *s)
 	return s;
 }
 
-static void read_symbols(char *modname)
+static void read_symbols(const char *modname)
 {
 	const char *symname;
 	char *version;

commit 074a04f572effefe410d7ee452cf3755e828c031
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 18:50:39 2018 +0900

    modpost: remove redundant is_vmlinux() test
    
    The second test of is_vmlinux() is redundant.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8606b6caa21b..9e70a6ac1fcb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1971,8 +1971,7 @@ static void read_symbols(char *modname)
 		handle_modversions(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);
 	}
-	if (!is_vmlinux(modname) ||
-	     (is_vmlinux(modname) && vmlinux_section_warnings))
+	if (!is_vmlinux(modname) || vmlinux_section_warnings)
 		check_sec_ref(mod, modname, &info);
 
 	version = get_modinfo(&info, "version");

commit d62c476521a63053cb28d76ac50e02c2d13b1619
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 18:50:38 2018 +0900

    modpost: use strstarts() helper more widely
    
    Currently, strstarts() is only used in export_from_secname().
    Use it more widely to improve the code readability.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 37a6a0b42846..8606b6caa21b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -596,19 +596,19 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 		return 1;
 	if (info->hdr->e_machine == EM_PPC)
 		/* Special register function linked on all modules during final link of .ko */
-		if (strncmp(symname, "_restgpr_", sizeof("_restgpr_") - 1) == 0 ||
-		    strncmp(symname, "_savegpr_", sizeof("_savegpr_") - 1) == 0 ||
-		    strncmp(symname, "_rest32gpr_", sizeof("_rest32gpr_") - 1) == 0 ||
-		    strncmp(symname, "_save32gpr_", sizeof("_save32gpr_") - 1) == 0 ||
-		    strncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||
-		    strncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0)
+		if (strstarts(symname, "_restgpr_") ||
+		    strstarts(symname, "_savegpr_") ||
+		    strstarts(symname, "_rest32gpr_") ||
+		    strstarts(symname, "_save32gpr_") ||
+		    strstarts(symname, "_restvr_") ||
+		    strstarts(symname, "_savevr_"))
 			return 1;
 	if (info->hdr->e_machine == EM_PPC64)
 		/* Special register function linked on all modules during final link of .ko */
-		if (strncmp(symname, "_restgpr0_", sizeof("_restgpr0_") - 1) == 0 ||
-		    strncmp(symname, "_savegpr0_", sizeof("_savegpr0_") - 1) == 0 ||
-		    strncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||
-		    strncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0 ||
+		if (strstarts(symname, "_restgpr0_") ||
+		    strstarts(symname, "_savegpr0_") ||
+		    strstarts(symname, "_restvr_") ||
+		    strstarts(symname, "_savevr_") ||
 		    strcmp(symname, ".TOC.") == 0)
 			return 1;
 	/* Do not ignore this symbol */
@@ -623,13 +623,13 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	bool is_crc = false;
 
 	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
-	    strncmp(symname, "__ksymtab", 9) == 0)
+	    strstarts(symname, "__ksymtab"))
 		export = export_from_secname(info, get_secindex(info, sym));
 	else
 		export = export_from_sec(info, get_secindex(info, sym));
 
 	/* CRC'd symbol */
-	if (strncmp(symname, "__crc_", strlen("__crc_")) == 0) {
+	if (strstarts(symname, "__crc_")) {
 		is_crc = true;
 		crc = (unsigned int) sym->st_value;
 		if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS) {
@@ -648,7 +648,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
-		if (!strncmp(symname, "__gnu_lto_", sizeof("__gnu_lto_")-1)) {
+		if (strstarts(symname, "__gnu_lto_")) {
 			/* Should warn here, but modpost runs before the linker */
 		} else
 			warn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);
@@ -691,7 +691,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		break;
 	default:
 		/* All exported symbols */
-		if (strncmp(symname, "__ksymtab_", strlen("__ksymtab_")) == 0) {
+		if (strstarts(symname, "__ksymtab_")) {
 			sym_add_exported(symname + strlen("__ksymtab_"), mod,
 					export);
 		}
@@ -1171,13 +1171,13 @@ static int secref_whitelist(const struct sectioncheck *mismatch,
 	/* Check for pattern 1 */
 	if (match(tosec, init_data_sections) &&
 	    match(fromsec, data_sections) &&
-	    (strncmp(fromsym, "__param", strlen("__param")) == 0))
+	    strstarts(fromsym, "__param"))
 		return 0;
 
 	/* Check for pattern 1a */
 	if (strcmp(tosec, ".init.text") == 0 &&
 	    match(fromsec, data_sections) &&
-	    (strncmp(fromsym, "__param_ops_", strlen("__param_ops_")) == 0))
+	    strstarts(fromsym, "__param_ops_"))
 		return 0;
 
 	/* Check for pattern 2 */
@@ -1532,8 +1532,7 @@ static void default_mismatch_handler(const char *modname, struct elf_info *elf,
 	from = find_elf_symbol2(elf, r->r_offset, fromsec);
 	fromsym = sym_name(elf, from);
 
-	if (!strncmp(fromsym, "reference___initcall",
-		     sizeof("reference___initcall")-1))
+	if (strstarts(fromsym, "reference___initcall"))
 		return;
 
 	tosec = sec_name(elf, get_secindex(elf, sym));
@@ -2163,9 +2162,7 @@ static void add_retpoline(struct buffer *b)
 
 static void add_staging_flag(struct buffer *b, const char *name)
 {
-	static const char *staging_dir = "drivers/staging";
-
-	if (strncmp(staging_dir, name, strlen(staging_dir)) == 0)
+	if (strstarts(name, "drivers/staging"))
 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
 }
 

commit bca2ccee4c4ac69496d3c8655d7869122fe5aeab
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 18:50:37 2018 +0900

    modpost: pass struct elf_info pointer to get_modinfo()
    
    get_(next_)modinfo takes a pointer and length pair of the .modinfo
    section.  Instead, pass struct elf_info pointer to reduce the number
    of function arguments.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index bc71925d4e9b..37a6a0b42846 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -724,16 +724,17 @@ static char *next_string(char *string, unsigned long *secsize)
 	return string;
 }
 
-static char *get_next_modinfo(void *modinfo, unsigned long modinfo_len,
-			      const char *tag, char *info)
+static char *get_next_modinfo(struct elf_info *info, const char *tag,
+			      char *prev)
 {
 	char *p;
 	unsigned int taglen = strlen(tag);
-	unsigned long size = modinfo_len;
+	char *modinfo = info->modinfo;
+	unsigned long size = info->modinfo_len;
 
-	if (info) {
-		size -= info - (char *)modinfo;
-		modinfo = next_string(info, &size);
+	if (prev) {
+		size -= prev - modinfo;
+		modinfo = next_string(prev, &size);
 	}
 
 	for (p = modinfo; p; p = next_string(p, &size)) {
@@ -743,11 +744,10 @@ static char *get_next_modinfo(void *modinfo, unsigned long modinfo_len,
 	return NULL;
 }
 
-static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
-			 const char *tag)
+static char *get_modinfo(struct elf_info *info, const char *tag)
 
 {
-	return get_next_modinfo(modinfo, modinfo_len, tag, NULL);
+	return get_next_modinfo(info, tag, NULL);
 }
 
 /**
@@ -1951,7 +1951,7 @@ static void read_symbols(char *modname)
 		mod->skip = 1;
 	}
 
-	license = get_modinfo(info.modinfo, info.modinfo_len, "license");
+	license = get_modinfo(&info, "license");
 	if (!license && !is_vmlinux(modname))
 		warn("modpost: missing MODULE_LICENSE() in %s\n"
 		     "see include/linux/module.h for "
@@ -1963,8 +1963,7 @@ static void read_symbols(char *modname)
 			mod->gpl_compatible = 0;
 			break;
 		}
-		license = get_next_modinfo(info.modinfo, info.modinfo_len,
-					   "license", license);
+		license = get_next_modinfo(&info, "license", license);
 	}
 
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
@@ -1977,7 +1976,7 @@ static void read_symbols(char *modname)
 	     (is_vmlinux(modname) && vmlinux_section_warnings))
 		check_sec_ref(mod, modname, &info);
 
-	version = get_modinfo(info.modinfo, info.modinfo_len, "version");
+	version = get_modinfo(&info, "version");
 	if (version)
 		maybe_frob_rcs_version(modname, version, info.modinfo,
 				       version - (char *)info.hdr);

commit b2c5cdcfd4bcc1fbf1caefe7f3ff909bcee10a6c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed May 9 16:23:45 2018 +0900

    modpost: remove symbol prefix support
    
    CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX was selected by BLACKFIN, METAG.
    They were removed by commit 4ba66a976072 ("arch: remove blackfin port"),
    commit bb6fb6dfcc17 ("metag: Remove arch/metag/"), respectively.
    
    No more architecture enables CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX,
    hence VMLINUX_SYMBOL_STR(foo) can be simplify replaced with "foo".
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4ff08a0ef5d3..bc71925d4e9b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -19,9 +19,7 @@
 #include <stdbool.h>
 #include <errno.h>
 #include "modpost.h"
-#include "../../include/generated/autoconf.h"
 #include "../../include/linux/license.h"
-#include "../../include/linux/export.h"
 
 /* Are we using CONFIG_MODVERSIONS? */
 static int modversions = 0;
@@ -591,7 +589,7 @@ static void parse_elf_finish(struct elf_info *info)
 static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 {
 	/* ignore __this_module, it will be resolved shortly */
-	if (strcmp(symname, VMLINUX_SYMBOL_STR(__this_module)) == 0)
+	if (strcmp(symname, "__this_module") == 0)
 		return 1;
 	/* ignore global offset table */
 	if (strcmp(symname, "_GLOBAL_OFFSET_TABLE_") == 0)
@@ -617,9 +615,6 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 	return 0;
 }
 
-#define CRC_PFX     VMLINUX_SYMBOL_STR(__crc_)
-#define KSYMTAB_PFX VMLINUX_SYMBOL_STR(__ksymtab_)
-
 static void handle_modversions(struct module *mod, struct elf_info *info,
 			       Elf_Sym *sym, const char *symname)
 {
@@ -634,7 +629,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		export = export_from_sec(info, get_secindex(info, sym));
 
 	/* CRC'd symbol */
-	if (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
+	if (strncmp(symname, "__crc_", strlen("__crc_")) == 0) {
 		is_crc = true;
 		crc = (unsigned int) sym->st_value;
 		if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS) {
@@ -647,7 +642,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 				info->sechdrs[sym->st_shndx].sh_addr : 0);
 			crc = *crcp;
 		}
-		sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
+		sym_update_crc(symname + strlen("__crc_"), mod, crc,
 				export);
 	}
 
@@ -685,15 +680,10 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		}
 #endif
 
-#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
-		if (symname[0] != '_')
-			break;
-		else
-			symname++;
-#endif
 		if (is_crc) {
 			const char *e = is_vmlinux(mod->name) ?"":".ko";
-			warn("EXPORT symbol \"%s\" [%s%s] version generation failed, symbol will not be versioned.\n", symname + strlen(CRC_PFX), mod->name, e);
+			warn("EXPORT symbol \"%s\" [%s%s] version generation failed, symbol will not be versioned.\n",
+			     symname + strlen("__crc_"), mod->name, e);
 		}
 		mod->unres = alloc_symbol(symname,
 					  ELF_ST_BIND(sym->st_info) == STB_WEAK,
@@ -701,13 +691,13 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		break;
 	default:
 		/* All exported symbols */
-		if (strncmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
-			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod,
+		if (strncmp(symname, "__ksymtab_", strlen("__ksymtab_")) == 0) {
+			sym_add_exported(symname + strlen("__ksymtab_"), mod,
 					export);
 		}
-		if (strcmp(symname, VMLINUX_SYMBOL_STR(init_module)) == 0)
+		if (strcmp(symname, "init_module") == 0)
 			mod->has_init = 1;
-		if (strcmp(symname, VMLINUX_SYMBOL_STR(cleanup_module)) == 0)
+		if (strcmp(symname, "cleanup_module") == 0)
 			mod->has_cleanup = 1;
 		break;
 	}
@@ -2230,7 +2220,7 @@ static int add_versions(struct buffer *b, struct module *mod)
 			err = 1;
 			break;
 		}
-		buf_printf(b, "\t{ %#8x, __VMLINUX_SYMBOL_STR(%s) },\n",
+		buf_printf(b, "\t{ %#8x, \"%s\" },\n",
 			   s->crc, s->name);
 	}
 

commit 739d875dd6982618020d30f58f8acf10f6076e6d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 8 09:48:46 2018 +0000

    mn10300: Remove the architecture
    
    Remove the MN10300 arch as the hardware is defunct.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    cc: linux-am33-list@redhat.com
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 9917f928d0fd..4ff08a0ef5d3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -840,8 +840,7 @@ static const char *const section_white_list[] =
 	".debug*",
 	".cranges",		/* sh64 */
 	".zdebug*",		/* Compressed debug sections. */
-	".GCC-command-line",	/* mn10300 */
-	".GCC.command.line",	/* record-gcc-switches, non mn10300 */
+	".GCC.command.line",	/* record-gcc-switches */
 	".mdebug*",        /* alpha, score, mips etc. */
 	".pdr",            /* alpha, score, mips etc. */
 	".stab*",
@@ -1104,8 +1103,8 @@ static const struct sectioncheck *section_mismatch(
 	/*
 	 * The target section could be the SHT_NUL section when we're
 	 * handling relocations to un-resolved symbols, trying to match it
-	 * doesn't make much sense and causes build failures on parisc and
-	 * mn10300 architectures.
+	 * doesn't make much sense and causes build failures on parisc
+	 * architectures.
 	 */
 	if (*tosec == '\0')
 		return NULL;

commit 581e400ff935d34d95811258586128bf11baef15
Merge: 6fbac201f95c 0cad61d7a3d5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 7 14:29:34 2018 -0800

    Merge tag 'modules-for-v4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull modules updates from Jessica Yu:
     "Minor code cleanups and MAINTAINERS update"
    
    * tag 'modules-for-v4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      modpost: Remove trailing semicolon
      ftrace/module: Move ftrace_release_mod() to ddebug_cleanup label
      MAINTAINERS: Remove from module & paravirt maintenance

commit 6304672b7f0a5c010002e63a075160856dc4f88d
Merge: 942633523cde 64e16720ea08
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 29 19:08:02 2018 -0800

    Merge branch 'x86-pti-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86/pti updates from Thomas Gleixner:
     "Another set of melted spectrum related changes:
    
       - Code simplifications and cleanups for RSB and retpolines.
    
       - Make the indirect calls in KVM speculation safe.
    
       - Whitelist CPUs which are known not to speculate from Meltdown and
         prepare for the new CPUID flag which tells the kernel that a CPU is
         not affected.
    
       - A less rigorous variant of the module retpoline check which merily
         warns when a non-retpoline protected module is loaded and reflects
         that fact in the sysfs file.
    
       - Prepare for Indirect Branch Prediction Barrier support.
    
       - Prepare for exposure of the Speculation Control MSRs to guests, so
         guest OSes which depend on those "features" can use them. Includes
         a blacklist of the broken microcodes. The actual exposure of the
         MSRs through KVM is still being worked on"
    
    * 'x86-pti-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/speculation: Simplify indirect_branch_prediction_barrier()
      x86/retpoline: Simplify vmexit_fill_RSB()
      x86/cpufeatures: Clean up Spectre v2 related CPUID flags
      x86/cpu/bugs: Make retpoline module warning conditional
      x86/bugs: Drop one "mitigation" from dmesg
      x86/nospec: Fix header guards names
      x86/alternative: Print unadorned pointers
      x86/speculation: Add basic IBPB (Indirect Branch Prediction Barrier) support
      x86/cpufeature: Blacklist SPEC_CTRL/PRED_CMD on early Spectre v2 microcodes
      x86/pti: Do not enable PTI on CPUs which are not vulnerable to Meltdown
      x86/msr: Add definitions for new speculation control MSRs
      x86/cpufeatures: Add AMD feature bits for Speculation Control
      x86/cpufeatures: Add Intel feature bits for Speculation Control
      x86/cpufeatures: Add CPUID_7_EDX CPUID leaf
      module/retpoline: Warn about missing retpoline in module
      KVM: VMX: Make indirect call speculation safe
      KVM: x86: Make indirect calls in emulator speculation safe

commit caf7501a1b4ec964190f31f9c3f163de252273b8
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Jan 25 15:50:28 2018 -0800

    module/retpoline: Warn about missing retpoline in module
    
    There's a risk that a kernel which has full retpoline mitigations becomes
    vulnerable when a module gets loaded that hasn't been compiled with the
    right compiler or the right option.
    
    To enable detection of that mismatch at module load time, add a module info
    string "retpoline" at build time when the module was compiled with
    retpoline support. This only covers compiled C source, but assembler source
    or prebuilt object files are not checked.
    
    If a retpoline enabled kernel detects a non retpoline protected module at
    load time, print a warning and report it in the sysfs vulnerability file.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: gregkh@linuxfoundation.org
    Cc: torvalds@linux-foundation.org
    Cc: jeyu@kernel.org
    Cc: arjan@linux.intel.com
    Link: https://lkml.kernel.org/r/20180125235028.31211-1-andi@firstfloor.org

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 98314b400a95..54deaa1066cf 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2165,6 +2165,14 @@ static void add_intree_flag(struct buffer *b, int is_intree)
 		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
 }
 
+/* Cannot check for assembler */
+static void add_retpoline(struct buffer *b)
+{
+	buf_printf(b, "\n#ifdef RETPOLINE\n");
+	buf_printf(b, "MODULE_INFO(retpoline, \"Y\");\n");
+	buf_printf(b, "#endif\n");
+}
+
 static void add_staging_flag(struct buffer *b, const char *name)
 {
 	static const char *staging_dir = "drivers/staging";
@@ -2506,6 +2514,7 @@ int main(int argc, char **argv)
 		err |= check_modname_len(mod);
 		add_header(&buf, mod);
 		add_intree_flag(&buf, !external_module);
+		add_retpoline(&buf);
 		add_staging_flag(&buf, mod->name);
 		err |= add_versions(&buf, mod);
 		add_depends(&buf, mod, modules);

commit 0cad61d7a3d51e0237a7e421c75b04ebbb5062d0
Author: Luis de Bethencourt <luisbg@kernel.org>
Date:   Tue Jan 16 13:21:29 2018 +0000

    modpost: Remove trailing semicolon
    
    The trailing semicolon is an empty statement that does no operation.
    Removing it since it doesn't do anything.
    
    Signed-off-by: Luis de Bethencourt <luisbg@kernel.org>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f51cf977c65b..49dfcd556c78 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1685,7 +1685,7 @@ static void extable_mismatch_handler(const char* modname, struct elf_info *elf,
 static void check_section_mismatch(const char *modname, struct elf_info *elf,
 				   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
 {
-	const char *tosec = sec_name(elf, get_secindex(elf, sym));;
+	const char *tosec = sec_name(elf, get_secindex(elf, sym));
 	const struct sectioncheck *mismatch = section_mismatch(fromsec, tosec);
 
 	if (mismatch) {

commit ba1029c9cbc5af834467bf264e58f9d1074735fb
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Nov 12 11:21:45 2017 -0800

    modpost: detect modules without a MODULE_LICENSE
    
    Partially revert commit 2fa365682943 ("kbuild: soften MODULE_LICENSE
    check") so that modpost detects modules that do not have a
    MODULE_LICENSE.
    
    Sam's commit also changed the fatal error to a warning, which I am
    leaving as is.
    
    This gives advance notice of when a module has no license and will taint
    the kernel if the module is loaded.
    
    This produces the following warnings on x86_64 allmodconfig:
    
        MODPOST 6520 modules
      WARNING: modpost: missing MODULE_LICENSE() in drivers/auxdisplay/img-ascii-lcd.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/gpio/gpio-ath79.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/gpio/gpio-iop.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/iio/accel/kxsd9-i2c.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/iio/adc/qcom-vadc-common.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/media/platform/mtk-vcodec/mtk-vcodec-common.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/media/platform/soc_camera/soc_scale_crop.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/mtd/nand/denali_pci.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/net/phy/cortina.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/pinctrl/pxa/pinctrl-pxa2xx.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/power/reset/zx-reboot.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/rpmsg/qcom_glink_native.o
      WARNING: modpost: missing MODULE_LICENSE() in drivers/staging/comedi/drivers/ni_atmio.o
      WARNING: modpost: missing MODULE_LICENSE() in net/9p/9pnet_xen.o
      WARNING: modpost: missing MODULE_LICENSE() in sound/soc/codecs/snd-soc-pcm512x-spi.o
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 98314b400a95..f51cf977c65b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1963,7 +1963,7 @@ static void read_symbols(char *modname)
 	}
 
 	license = get_modinfo(info.modinfo, info.modinfo_len, "license");
-	if (info.modinfo && !license && !is_vmlinux(modname))
+	if (!license && !is_vmlinux(modname))
 		warn("modpost: missing MODULE_LICENSE() in %s\n"
 		     "see include/linux/module.h for "
 		     "more information\n", modname);

commit 4791bcccf8ce02c2bf6f9dfbc328a3a46d9e9569
Merge: 3882a734c19b 0bf8bf50eddc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 13 11:28:19 2017 -0700

    Merge tag 'modules-for-v4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux
    
    Pull modules updates from Jessica Yu:
     "Summary of modules changes for the 4.14 merge window:
    
       - minor code cleanups and fixes
    
       - modpost: avoid building modules that have names that exceed the
         size of the name field in struct module"
    
    * tag 'modules-for-v4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux:
      module: Remove const attribute from alias for MODULE_DEVICE_TABLE
      module: fix ddebug_remove_module()
      modpost: abort if module name is too long

commit 6124c04c1344497e0cbfb505ddbd3b83090a4d51
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Sep 6 16:19:05 2017 -0700

    modpost: simplify sec_name()
    
    There is code duplication between sec_name() and sech_name().  Simplify
    sec_name() by re-using sech_name().  Also, move them up to remove the
    forward declaration of sec_name().
    
    Link: http://lkml.kernel.org/r/1502248721-22009-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Cc: Nicholas Piggin <npiggin@gmail.com>
    Cc: Jessica Yu <jeyu@redhat.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 48397feb08fb..b920d186ad4a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -261,7 +261,17 @@ static enum export export_no(const char *s)
 	return export_unknown;
 }
 
-static const char *sec_name(struct elf_info *elf, int secindex);
+static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
+{
+	return (void *)elf->hdr +
+		elf->sechdrs[elf->secindex_strings].sh_offset +
+		sechdr->sh_name;
+}
+
+static const char *sec_name(struct elf_info *elf, int secindex)
+{
+	return sech_name(elf, &elf->sechdrs[secindex]);
+}
 
 #define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)
 
@@ -775,21 +785,6 @@ static const char *sym_name(struct elf_info *elf, Elf_Sym *sym)
 		return "(unknown)";
 }
 
-static const char *sec_name(struct elf_info *elf, int secindex)
-{
-	Elf_Shdr *sechdrs = elf->sechdrs;
-	return (void *)elf->hdr +
-		elf->sechdrs[elf->secindex_strings].sh_offset +
-		sechdrs[secindex].sh_name;
-}
-
-static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
-{
-	return (void *)elf->hdr +
-		elf->sechdrs[elf->secindex_strings].sh_offset +
-		sechdr->sh_name;
-}
-
 /* The pattern is an array of simple patterns.
  * "foo" will match an exact string equal to "foo"
  * "*foo" will match a string that ends with "foo"

commit 4fd3e4ef1f7e94299b42c2f473e196d0b8c114d0
Author: Wanlong Gao <wanlong.gao@gmail.com>
Date:   Fri Jun 30 22:07:03 2017 +0800

    modpost: abort if module name is too long
    
    Module name has a limited length, but currently the build system
    allows the build finishing even if the module name is too long.
    
      CC      /root/kprobe_example/abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz.mod.o
     /root/kprobe_example/abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz.mod.c:9:2:
     warning: initializer-string for array of chars is too long [enabled by default]
      .name = KBUILD_MODNAME,
      ^
    
    but it's merely a warning.
    
    This patch adds the check of the module name length in modpost and stops
    the build properly.
    
    Signed-off-by: Wanlong Gao <wanlong.gao@gmail.com>
    Signed-off-by: Jessica Yu <jeyu@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 48397feb08fb..301c27740c5c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -47,6 +47,12 @@ enum export {
 	export_unused_gpl, export_gpl_future, export_unknown
 };
 
+/* In kernel, this size is defined in linux/module.h;
+ * here we use Elf_Addr instead of long for covering cross-compile
+ */
+
+#define MODULE_NAME_LEN (64 - sizeof(Elf_Addr))
+
 #define PRINTF __attribute__ ((format (printf, 1, 2)))
 
 PRINTF void fatal(const char *fmt, ...)
@@ -2116,6 +2122,23 @@ static void check_exports(struct module *mod)
 	}
 }
 
+static int check_modname_len(struct module *mod)
+{
+	const char *mod_name;
+
+	mod_name = strrchr(mod->name, '/');
+	if (mod_name == NULL)
+		mod_name = mod->name;
+	else
+		mod_name++;
+	if (strlen(mod_name) >= MODULE_NAME_LEN) {
+		merror("module name is too long [%s.ko]\n", mod->name);
+		return 1;
+	}
+
+	return 0;
+}
+
 /**
  * Header for the generated file
  **/
@@ -2155,11 +2178,6 @@ static void add_staging_flag(struct buffer *b, const char *name)
 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
 }
 
-/* In kernel, this size is defined in linux/module.h;
- * here we use Elf_Addr instead of long for covering cross-compile
- */
-#define MODULE_NAME_LEN (64 - sizeof(Elf_Addr))
-
 /**
  * Record CRCs for unresolved symbols
  **/
@@ -2490,6 +2508,7 @@ int main(int argc, char **argv)
 
 		buf.pos = 0;
 
+		err |= check_modname_len(mod);
 		add_header(&buf, mod);
 		add_intree_flag(&buf, !external_module);
 		add_staging_flag(&buf, mod->name);

commit 3e2e857f9c3a19d55ee0ba7b428b8be5008960bf
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Apr 21 15:35:27 2017 -0700

    module: Add module name to modinfo
    
    Accessing the mod structure (e.g. for mod->name) prior to having completed
    check_modstruct_version() can result in writing garbage to the error logs
    if the layout of the mod structure loaded from disk doesn't match the
    running kernel's mod structure layout. This kind of mismatch will become
    much more likely if a kernel is built with different randomization seed
    for the struct layout randomization plugin.
    
    Instead, add and use a new modinfo string for logging the module name.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jessica Yu <jeyu@redhat.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 30d752a4a6a6..48397feb08fb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2126,6 +2126,7 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "#include <linux/compiler.h>\n");
 	buf_printf(b, "\n");
 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
+	buf_printf(b, "MODULE_INFO(name, KBUILD_MODNAME);\n");
 	buf_printf(b, "\n");
 	buf_printf(b, "__visible struct module __this_module\n");
 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");

commit e390f9a9689a42f477a6073e2e7df530a4c1b740
Author: Josh Poimboeuf <jpoimboe@redhat.com>
Date:   Wed Mar 1 12:04:44 2017 -0600

    objtool, modules: Discard objtool annotation sections for modules
    
    The '__unreachable' and '__func_stack_frame_non_standard' sections are
    only used at compile time.  They're discarded for vmlinux but they
    should also be discarded for modules.
    
    Since this is a recurring pattern, prefix the section names with
    ".discard.".  It's a nice convention and vmlinux.lds.h already discards
    such sections.
    
    Also remove the 'a' (allocatable) flag from the __unreachable section
    since it doesn't make sense for a discarded section.
    
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Cc: Jessica Yu <jeyu@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Fixes: d1091c7fa3d5 ("objtool: Improve detection of BUG() and other dead ends")
    Link: http://lkml.kernel.org/r/20170301180444.lhd53c5tibc4ns77@treble
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4dedd0d3d3a7..30d752a4a6a6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -854,6 +854,7 @@ static const char *const section_white_list[] =
 	".cmem*",			/* EZchip */
 	".fmt_slot*",			/* EZchip */
 	".gnu.lto*",
+	".discard.*",
 	NULL
 };
 

commit 56067812d5b0e737ac2063e94a50f76b810d6ca3
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri Feb 3 09:54:05 2017 +0000

    kbuild: modversions: add infrastructure for emitting relative CRCs
    
    This add the kbuild infrastructure that will allow architectures to emit
    vmlinux symbol CRCs as 32-bit offsets to another location in the kernel
    where the actual value is stored. This works around problems with CRCs
    being mistaken for relocatable symbols on kernels that self relocate at
    runtime (i.e., powerpc with CONFIG_RELOCATABLE=y)
    
    For the kbuild side of things, this comes down to the following:
    
     - introducing a Kconfig symbol MODULE_REL_CRCS
    
     - adding a -R switch to genksyms to instruct it to emit the CRC symbols
       as references into the .rodata section
    
     - making modpost distinguish such references from absolute CRC symbols
       by the section index (SHN_ABS)
    
     - making kallsyms disregard non-absolute symbols with a __crc_ prefix
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 29c89a6bad3d..4dedd0d3d3a7 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -621,6 +621,16 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	if (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
 		is_crc = true;
 		crc = (unsigned int) sym->st_value;
+		if (sym->st_shndx != SHN_UNDEF && sym->st_shndx != SHN_ABS) {
+			unsigned int *crcp;
+
+			/* symbol points to the CRC in the ELF object */
+			crcp = (void *)info->hdr + sym->st_value +
+			       info->sechdrs[sym->st_shndx].sh_offset -
+			       (info->hdr->e_type != ET_REL ?
+				info->sechdrs[sym->st_shndx].sh_addr : 0);
+			crc = *crcp;
+		}
 		sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
 				export);
 	}

commit 41e0e24b450fadc079dfb659d81f3076afcfbd8a
Merge: 0aaf2146ecf0 334bb7738764
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 17 16:24:13 2016 -0800

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild updates from Michal Marek:
    
     - prototypes for x86 asm-exported symbols (Adam Borowski) and a warning
       about missing CRCs (Nick Piggin)
    
     - asm-exports fix for LTO (Nicolas Pitre)
    
     - thin archives improvements (Nick Piggin)
    
     - linker script fix for CONFIG_LD_DEAD_CODE_DATA_ELIMINATION (Nick
       Piggin)
    
     - genksyms support for __builtin_va_list keyword
    
     - misc minor fixes
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      x86/kbuild: enable modversions for symbols exported from asm
      kbuild: fix scripts/adjust_autoksyms.sh* for the no modules case
      scripts/kallsyms: remove last remnants of --page-offset option
      make use of make variable CURDIR instead of calling pwd
      kbuild: cmd_export_list: tighten the sed script
      kbuild: minor improvement for thin archives build
      kbuild: modpost warn if export version crc is missing
      kbuild: keep data tables through dead code elimination
      kbuild: improve linker compatibility with lib-ksyms.o build
      genksyms: Regenerate parser
      kbuild/genksyms: handle va_list type
      kbuild: thin archives for multi-y targets
      kbuild: kallsyms allow 3-pass generation if symbols size has changed

commit d8c1eb86e9528214fed7909bfef988b472a76c2c
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Thu Nov 24 03:41:42 2016 +1100

    kbuild: modpost warn if export version crc is missing
    
    This catches the failing ceph CRC on with:
    
        LD      vmlinux.o
        MODPOST vmlinux.o
      WARNING: EXPORT symbol "ceph_monc_do_statfs" [vmlinux] version
      generation failed, symbol will not be versioned.
    
    When the modules referring to exported symbols are built, there is an
    existing warning for missing CRC, but it's not always the case such
    any such module will be built, and in any case it is useful to get a
    warning at the source.
    
    This gets a little verbose with CONFIG_DEBUG_SECTION_MISMATCH,
    producing a warning with each object linked, but I didn't think
    that warranted extra complexity to avoid.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index bd8349759095..08f62a1af67d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -609,6 +609,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 {
 	unsigned int crc;
 	enum export export;
+	bool is_crc = false;
 
 	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
 	    strncmp(symname, "__ksymtab", 9) == 0)
@@ -618,6 +619,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 
 	/* CRC'd symbol */
 	if (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
+		is_crc = true;
 		crc = (unsigned int) sym->st_value;
 		sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
 				export);
@@ -663,6 +665,10 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		else
 			symname++;
 #endif
+		if (is_crc) {
+			const char *e = is_vmlinux(mod->name) ?"":".ko";
+			warn("EXPORT symbol \"%s\" [%s%s] version generation failed, symbol will not be versioned.\n", symname + strlen(CRC_PFX), mod->name, e);
+		}
 		mod->unres = alloc_symbol(symname,
 					  ELF_ST_BIND(sym->st_info) == STB_WEAK,
 					  mod->unres);

commit c7d47f26df949f0031fe2905068ee85db1b63ed9
Author: Heinrich Schuchardt <xypron.glpk@gmx.de>
Date:   Tue Aug 2 21:43:01 2016 +0200

    modpost: free allocated memory
    
    valgrind complains that memory is not freed after allocation
    with realloc() called from main() and write_dump().
    
    So let us free the allocated memory properly.
    
    Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Link: http://lkml.kernel.org/r/1470166981-6461-1-git-send-email-xypron.glpk@gmx.de
    Signed-off-by: Jessica Yu <jeyu@redhat.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index bd8349759095..5a6b39a29b7a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2371,6 +2371,7 @@ static void write_dump(const char *fname)
 		}
 	}
 	write_if_changed(&buf, fname);
+	free(buf.p);
 }
 
 struct ext_sym_list {
@@ -2496,6 +2497,7 @@ int main(int argc, char **argv)
 			      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
 		}
 	}
+	free(buf.p);
 
 	return err;
 }

commit 6727ad9e206cc08b80d8000a4d67f8417e53539d
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Fri Oct 7 17:02:55 2016 -0700

    nmi_backtrace: generate one-line reports for idle cpus
    
    When doing an nmi backtrace of many cores, most of which are idle, the
    output is a little overwhelming and very uninformative.  Suppress
    messages for cpus that are idling when they are interrupted and just
    emit one line, "NMI backtrace for N skipped: idling at pc 0xNNN".
    
    We do this by grouping all the cpuidle code together into a new
    .cpuidle.text section, and then checking the address of the interrupted
    PC to see if it lies within that section.
    
    This commit suitably tags x86 and tile idle routines, and only adds in
    the minimal framework for other architectures.
    
    Link: http://lkml.kernel.org/r/1472487169-14923-5-git-send-email-cmetcalf@mellanox.com
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Tested-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Tested-by: Daniel Thompson <daniel.thompson@linaro.org> [arm]
    Tested-by: Petr Mladek <pmladek@suse.com>
    Cc: Aaron Tomlin <atomlin@redhat.com>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 48958d3cec9e..bd8349759095 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -888,7 +888,7 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 #define DATA_SECTIONS ".data", ".data.rel"
 #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
-		".kprobes.text"
+		".kprobes.text", ".cpuidle.text"
 #define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
 		".fixup", ".entry.text", ".exception.text", ".text.*", \
 		".coldtext"

commit c153693d7eb9eeb28478aa2deaaf0b4e7b5ff5e9
Author: Alan Modra <amodra@gmail.com>
Date:   Fri Jan 15 20:52:22 2016 +1100

    powerpc: Simplify module TOC handling
    
    PowerPC64 uses the symbol .TOC. much as other targets use
    _GLOBAL_OFFSET_TABLE_. It identifies the value of the GOT pointer (or in
    powerpc parlance, the TOC pointer). Global offset tables are generally
    local to an executable or shared library, or in the kernel, module. Thus
    it does not make sense for a module to resolve a relocation against
    .TOC. to the kernel's .TOC. value. A module has its own .TOC., and
    indeed the powerpc64 module relocation processing ignores the kernel
    value of .TOC. and instead calculates a module-local value.
    
    This patch removes code involved in exporting the kernel .TOC., tweaks
    modpost to ignore an undefined .TOC., and the module loader to twiddle
    the section symbol so that .TOC. isn't seen as undefined.
    
    Note that if the kernel was compiled with -msingle-pic-base then ELFv2
    would not have function global entry code setting up r2. In that case
    the module call stubs would need to be modified to set up r2 using the
    kernel .TOC. value, requiring some of this code to be reinstated.
    
    mpe: Furthermore a change in binutils master (not yet released) causes
    the current way we handle the TOC to no longer work when building with
    MODVERSIONS=y and RELOCATABLE=n. The symptom is that modules can not be
    loaded due to there being no version found for TOC.
    
    Cc: stable@vger.kernel.org # 3.16+
    Signed-off-by: Alan Modra <amodra@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e080746e1a6b..48958d3cec9e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -594,7 +594,8 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 		if (strncmp(symname, "_restgpr0_", sizeof("_restgpr0_") - 1) == 0 ||
 		    strncmp(symname, "_savegpr0_", sizeof("_savegpr0_") - 1) == 0 ||
 		    strncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||
-		    strncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0)
+		    strncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0 ||
+		    strcmp(symname, ".TOC.") == 0)
 			return 1;
 	/* Do not ignore this symbol */
 	return 0;

commit d1189c63ea5e3272dc390a83e1235f142b739eb4
Author: Noam Camus <noamc@ezchip.com>
Date:   Mon Oct 26 19:51:46 2015 +1030

    scripts: [modpost] add new sections to white list
    
    In our ARC toolchain the default linker script includes special
    sections used for code and data located in special fast memory.
    To avoid warnings we add these sections i.e. .cmem* and .fmt_slot*
    to white list.
    
    Signed-off-by: Noam Camus <noamc@ezchip.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b2ae8afc1ab1..e080746e1a6b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -834,6 +834,8 @@ static const char *const section_white_list[] =
 	".xt.lit",         /* xtensa */
 	".arcextmap*",			/* arc */
 	".gnu.linkonce.arcext*",	/* arc : modules */
+	".cmem*",			/* EZchip */
+	".fmt_slot*",			/* EZchip */
 	".gnu.lto*",
 	NULL
 };

commit 47490ec141b9944a8a7cbe3bec8b8f4fdaaa700b
Author: Nicolas Boichat <drinkcat@chromium.org>
Date:   Tue Oct 6 09:44:42 2015 +1030

    modpost: Add flag -E for making section mismatches fatal
    
    The section mismatch warning can be easy to miss during the kernel build
    process. Allow it to be marked as fatal to be easily caught and prevent
    bugs from slipping in.
    
    Setting CONFIG_SECTION_MISMATCH_WARN_ONLY=y causes these warnings to be
    non-fatal, since there are a number of section mismatches when using
    allmodconfig on some architectures, and we do not want to break these
    builds by default.
    
    Signed-off-by: Nicolas Boichat <drinkcat@chromium.org>
    Change-Id: Ic346706e3297c9f0d790e3552aa94e5cff9897a6
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d583c98fde31..b2ae8afc1ab1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -38,6 +38,7 @@ static int warn_unresolved = 0;
 /* How a symbol is exported */
 static int sec_mismatch_count = 0;
 static int sec_mismatch_verbose = 1;
+static int sec_mismatch_fatal = 0;
 /* ignore missing files */
 static int ignore_missing_files;
 
@@ -2385,7 +2386,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awM:K:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awM:K:E")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2426,6 +2427,9 @@ int main(int argc, char **argv)
 		case 'w':
 			warn_unresolved = 1;
 			break;
+		case 'E':
+			sec_mismatch_fatal = 1;
+			break;
 		default:
 			exit(1);
 		}
@@ -2475,14 +2479,20 @@ int main(int argc, char **argv)
 		sprintf(fname, "%s.mod.c", mod->name);
 		write_if_changed(&buf, fname);
 	}
-
 	if (dump_write)
 		write_dump(dump_write);
-	if (sec_mismatch_count && !sec_mismatch_verbose)
-		warn("modpost: Found %d section mismatch(es).\n"
-		     "To see full details build your kernel with:\n"
-		     "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
-		     sec_mismatch_count);
+	if (sec_mismatch_count) {
+		if (!sec_mismatch_verbose) {
+			warn("modpost: Found %d section mismatch(es).\n"
+			     "To see full details build your kernel with:\n"
+			     "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
+			     sec_mismatch_count);
+		}
+		if (sec_mismatch_fatal) {
+			fatal("modpost: Section mismatches detected.\n"
+			      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
+		}
+	}
 
 	return err;
 }

commit 5cfb203a304deaaa8c7c5368722b214d24583137
Author: Takashi Iwai <tiwai@suse.de>
Date:   Sat Aug 8 15:16:20 2015 +0930

    modpost: abort if a module symbol is too long
    
    Module symbols have a limited length, but currently the build system
    allows the build finishing even if the driver code contains a too long
    symbol name, which eventually overflows the modversion_info[] item.
    The compiler may catch at compiling *.mod.c like
      CC      xxx.mod.o
      xxx.mod.c:18:16: warning: initializer-string for array of chars is too long
    but it's merely a warning.
    
    This patch adds the check of the symbol length in modpost and stops
    the build properly.
    
    Currently MODULE_NAME_LEN is defined in modpost.c instead of referring
    to the definition in kernel header because including linux/module.h is
    messy and we must cover cross-compilation.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 12d3db3bd46b..d583c98fde31 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2133,6 +2133,11 @@ static void add_staging_flag(struct buffer *b, const char *name)
 		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
 }
 
+/* In kernel, this size is defined in linux/module.h;
+ * here we use Elf_Addr instead of long for covering cross-compile
+ */
+#define MODULE_NAME_LEN (64 - sizeof(Elf_Addr))
+
 /**
  * Record CRCs for unresolved symbols
  **/
@@ -2177,6 +2182,12 @@ static int add_versions(struct buffer *b, struct module *mod)
 				s->name, mod->name);
 			continue;
 		}
+		if (strlen(s->name) >= MODULE_NAME_LEN) {
+			merror("too long symbol \"%s\" [%s.ko]\n",
+			       s->name, mod->name);
+			err = 1;
+			break;
+		}
 		buf_printf(b, "\t{ %#8x, __VMLINUX_SYMBOL_STR(%s) },\n",
 			   s->crc, s->name);
 	}

commit 673c2c34f684e9d4328459e426ab54d51a5865c5
Author: Chris Metcalf <cmetcalf@ezchip.com>
Date:   Wed Jul 8 17:07:41 2015 -0400

    modpost: work correctly with tile coldtext sections
    
    The tilegx and tilepro compilers use .coldtext for their unlikely
    executed text section name, so an __attribute__((cold)) function
    will (when compiled with higher optimization levels) land in
    the .coldtext section.
    
    Modify modpost to add .coldtext to the set of OTHER_TEXT_SECTIONS
    so we don't get warnings about referencing such a section in an
    __ex_table block, and then also modify arch/tile/lib/memcpy_user_64.c
    so that it uses plain ".coldtext" instead of ".coldtext.memcpy".
    The latter naming is a relic of an earlier use of -ffunction-sections,
    which we no longer use by default.
    
    Signed-off-by: Chris Metcalf <cmetcalf@ezchip.com>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 91ee1b2e0f9a..12d3db3bd46b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -886,7 +886,8 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
 		".kprobes.text"
 #define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
-		".fixup", ".entry.text", ".exception.text", ".text.*"
+		".fixup", ".entry.text", ".exception.text", ".text.*", \
+		".coldtext"
 
 #define INIT_SECTIONS      ".init.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"

commit 4a3893d069b788f3570c19c12d9e986e8e15870f
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Apr 20 10:20:40 2015 +0930

    modpost: don't emit section mismatch warnings for compiler optimizations
    
    Currently an allyesconfig build [gcc-4.9.1] can generate the following:
    
       WARNING: vmlinux.o(.text.unlikely+0x3864): Section mismatch in
       reference from the function cpumask_empty.constprop.3() to the
       variable .init.data:nmi_ipi_mask
    
    which comes from the cpumask_empty usage in arch/x86/kernel/nmi_selftest.c.
    
    Normally we would not see a symbol entry for cpumask_empty since it is:
    
            static inline bool cpumask_empty(const struct cpumask *srcp)
    
    however in this case, the variant of the symbol gets emitted when GCC does
    constant propagation optimization.
    
    Fix things up so that any locally optimized constprop variants don't warn
    when accessing variables that live in the __init sections.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1c2101bf63d2..91ee1b2e0f9a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -908,6 +908,9 @@ static const char *const init_sections[] = { ALL_INIT_SECTIONS, NULL };
 static const char *const init_exit_sections[] =
 	{ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL };
 
+/* all text sections */
+static const char *const text_sections[] = { ALL_TEXT_SECTIONS, NULL };
+
 /* data section */
 static const char *const data_sections[] = { DATA_SECTIONS, NULL };
 
@@ -926,6 +929,7 @@ static const char *const data_sections[] = { DATA_SECTIONS, NULL };
 static const char *const head_sections[] = { ".head.text*", NULL };
 static const char *const linker_symbols[] =
 	{ "__init_begin", "_sinittext", "_einittext", NULL };
+static const char *const optim_symbols[] = { "*.constprop.*", NULL };
 
 enum mismatch {
 	TEXT_TO_ANY_INIT,
@@ -1136,6 +1140,17 @@ static const struct sectioncheck *section_mismatch(
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
+ * Pattern 5:
+ *   GCC may optimize static inlines when fed constant arg(s) resulting
+ *   in functions like cpumask_empty() -- generating an associated symbol
+ *   cpumask_empty.constprop.3 that appears in the audit.  If the const that
+ *   is passed in comes from __init, like say nmi_ipi_mask, we get a
+ *   meaningless section warning.  May need to add isra symbols too...
+ *   This pattern is identified by
+ *   tosec   = init section
+ *   fromsec = text section
+ *   refsymname = *.constprop.*
+ *
  **/
 static int secref_whitelist(const struct sectioncheck *mismatch,
 			    const char *fromsec, const char *fromsym,
@@ -1168,6 +1183,12 @@ static int secref_whitelist(const struct sectioncheck *mismatch,
 	if (match(tosym, linker_symbols))
 		return 0;
 
+	/* Check for pattern 5 */
+	if (match(fromsec, text_sections) &&
+	    match(tosec, init_sections) &&
+	    match(fromsym, optim_symbols))
+		return 0;
+
 	return 1;
 }
 

commit 09c20c032b0f753969ae778d9783d946f054d7fe
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Apr 20 10:20:26 2015 +0930

    modpost: expand pattern matching to support substring matches
    
    Currently the match() function supports a leading * to match any
    prefix and a trailing * to match any suffix.  However there currently
    is not a combination of both that can be used to target matches of
    whole families of functions that share a common substring.
    
    Here we expand the *foo and foo* match to also support *foo* with
    the goal of targeting compiler generated symbol names that contain
    strings like ".constprop." and ".isra."
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 45e4027d3193..1c2101bf63d2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -776,6 +776,7 @@ static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
  * "foo" will match an exact string equal to "foo"
  * "*foo" will match a string that ends with "foo"
  * "foo*" will match a string that begins with "foo"
+ * "*foo*" will match a string that contains "foo"
  */
 static int match(const char *sym, const char * const pat[])
 {
@@ -784,8 +785,17 @@ static int match(const char *sym, const char * const pat[])
 		p = *pat++;
 		const char *endp = p + strlen(p) - 1;
 
+		/* "*foo*" */
+		if (*p == '*' && *endp == '*') {
+			char *here, *bare = strndup(p + 1, strlen(p) - 2);
+
+			here = strstr(sym, bare);
+			free(bare);
+			if (here != NULL)
+				return 1;
+		}
 		/* "*foo" */
-		if (*p == '*') {
+		else if (*p == '*') {
 			if (strrcmp(sym, p + 1) == 0)
 				return 1;
 		}

commit c5c3439af0f9c08e253d2a703a7eb3deba7d8591
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Thu Apr 16 13:16:41 2015 +0930

    modpost: do not try to match the SHT_NUL section.
    
    Trying to match the SHT_NUL section isn't useful and causes build failures
    on parisc and mn10300 since the addition of section strict white-listing
    and __ex_table sanitizing.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Fixes: 050e57fd5936 ("modpost: add strict white-listing when referencing....")
    Fixes: 52dc0595d540 ("modpost: handle relocations mismatch in __ex_table.")
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index fd949770da0c..45e4027d3193 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1064,6 +1064,15 @@ static const struct sectioncheck *section_mismatch(
 	int elems = sizeof(sectioncheck) / sizeof(struct sectioncheck);
 	const struct sectioncheck *check = &sectioncheck[0];
 
+	/*
+	 * The target section could be the SHT_NUL section when we're
+	 * handling relocations to un-resolved symbols, trying to match it
+	 * doesn't make much sense and causes build failures on parisc and
+	 * mn10300 architectures.
+	 */
+	if (*tosec == '\0')
+		return NULL;
+
 	for (i = 0; i < elems; i++) {
 		if (match(fromsec, check->fromsec)) {
 			if (check->bad_tosec[0] && match(tosec, check->bad_tosec))

commit e84048aa173f2403fa468cb189f101b57fece539
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Thu Apr 16 13:05:36 2015 +0930

    modpost: fix extable entry size calculation.
    
    As Guenter pointed out, we were never really calculating the extable entry
    size because the pointer arithmetic was simply wrong.  We want to check
    we're handling the second relocation in __ex_table to infer an entry size,
    but we were using (void*) pointers instead of Elf_Rel[a]* ones.
    
    This fixes the problem by moving that check in the caller (since we can
    deal with different types of relocations) and add is_second_extable_reloc()
    to make the whole thing more readable.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 93bb87d0e17d..fd949770da0c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1511,8 +1511,7 @@ static int is_executable_section(struct elf_info* elf, unsigned int section_inde
  * to know the sizeof(struct exception_table_entry) for the target architecture.
  */
 static unsigned int extable_entry_size = 0;
-static void find_extable_entry_size(const char* const sec, const Elf_Rela* r,
-				    const void* start, const void* cur)
+static void find_extable_entry_size(const char* const sec, const Elf_Rela* r)
 {
 	/*
 	 * If we're currently checking the second relocation within __ex_table,
@@ -1523,10 +1522,10 @@ static void find_extable_entry_size(const char* const sec, const Elf_Rela* r,
 	 * seems to go with different sized types.  Not pretty but better than
 	 * hard-coding the size for every architecture..
 	 */
-	if (!extable_entry_size && cur == start + 1 &&
-	    strcmp("__ex_table", sec) == 0)
+	if (!extable_entry_size)
 		extable_entry_size = r->r_offset * 2;
 }
+
 static inline bool is_extable_fault_address(Elf_Rela *r)
 {
 	/*
@@ -1541,6 +1540,9 @@ static inline bool is_extable_fault_address(Elf_Rela *r)
 		(r->r_offset % extable_entry_size == 0));
 }
 
+#define is_second_extable_reloc(Start, Cur, Sec)			\
+	(((Cur) == (Start) + 1) && (strcmp("__ex_table", (Sec)) == 0))
+
 static void report_extable_warnings(const char* modname, struct elf_info* elf,
 				    const struct sectioncheck* const mismatch,
 				    Elf_Rela* r, Elf_Sym* sym,
@@ -1769,7 +1771,8 @@ static void section_rela(const char *modname, struct elf_info *elf,
 		/* Skip special sections */
 		if (is_shndx_special(sym->st_shndx))
 			continue;
-		find_extable_entry_size(fromsec, &r, start, rela);
+		if (is_second_extable_reloc(start, rela, fromsec))
+			find_extable_entry_size(fromsec, &r);
 		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
 }
@@ -1828,7 +1831,8 @@ static void section_rel(const char *modname, struct elf_info *elf,
 		/* Skip special sections */
 		if (is_shndx_special(sym->st_shndx))
 			continue;
-		find_extable_entry_size(fromsec, &r, start, rel);
+		if (is_second_extable_reloc(start, rel, fromsec))
+			find_extable_entry_size(fromsec, &r);
 		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
 }

commit d3df4de7eb095cc4334759a5e65bf3bfb4be04f1
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Thu Apr 16 13:03:32 2015 +0930

    modpost: fix inverted logic in is_extable_fault_address().
    
    As Guenter pointed out, we want to assert that extable_entry_size has been
    discovered and not the other way around.  Moreover, this sanity check is
    only valid when we're not dealing with the first relocation in __ex_table,
    since we have not discovered the extable entry size at that point.
    
    This was leading to a divide-by-zero on some architectures and make the
    build fail.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 22dbc604cdb9..93bb87d0e17d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1529,7 +1529,12 @@ static void find_extable_entry_size(const char* const sec, const Elf_Rela* r,
 }
 static inline bool is_extable_fault_address(Elf_Rela *r)
 {
-	if (!extable_entry_size == 0)
+	/*
+	 * extable_entry_size is only discovered after we've handled the
+	 * _second_ relocation in __ex_table, so only abort when we're not
+	 * handling the first reloc and extable_entry_size is zero.
+	 */
+	if (r->r_offset && extable_entry_size == 0)
 		fatal("extable_entry size hasn't been discovered!\n");
 
 	return ((r->r_offset == 0) ||

commit 6c730bfc894f5d4989c2c1493512d3330402be94
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Apr 15 13:28:08 2015 +0930

    modpost: handle -ffunction-sections
    
    52dc0595d540 introduced OTHER_TEXT_SECTIONS for identifying what
    sections could validly have __ex_table entries.  Unfortunately, it
    wasn't tested with -ffunction-sections, which some architectures
    use.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Cc: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6a925f200b25..22dbc604cdb9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -876,7 +876,7 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
 		".kprobes.text"
 #define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
-		".fixup", ".entry.text", ".text.fixup", ".exception.text"
+		".fixup", ".entry.text", ".exception.text", ".text.*"
 
 #define INIT_SECTIONS      ".init.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"

commit d7e0abcf4c6d9fc4ebb948c9bbc880b2483434b4
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Apr 15 13:23:48 2015 +0930

    modpost: Whitelist .text.fixup and .exception.text
    
    32-bit and 64-bit ARM use these sections to store executable code, so
    they must be whitelisted in modpost's table of valid text sections.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index cbd53e08769d..6a925f200b25 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -876,7 +876,7 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
 		".kprobes.text"
 #define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
-		".fixup", ".entry.text"
+		".fixup", ".entry.text", ".text.fixup", ".exception.text"
 
 #define INIT_SECTIONS      ".init.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"

commit e5d8f59a5cfa76ab5ebe47622d0c569eddd42fbe
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:55:15 2015 +0930

    modpost: document the use of struct section_check.
    
    struct section_check is used as a generic way of describing what
    relocations are authorized/forbidden when running modpost.  This commit
    tries to describe how each field is used.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> (Fixed "mist"ake)

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e95aa28ce0f7..cbd53e08769d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -930,6 +930,26 @@ enum mismatch {
 	EXTABLE_TO_NON_TEXT,
 };
 
+/**
+ * Describe how to match sections on different criterias:
+ *
+ * @fromsec: Array of sections to be matched.
+ *
+ * @bad_tosec: Relocations applied to a section in @fromsec to a section in
+ * this array is forbidden (black-list).  Can be empty.
+ *
+ * @good_tosec: Relocations applied to a section in @fromsec must be
+ * targetting sections in this array (white-list).  Can be empty.
+ *
+ * @mismatch: Type of mismatch.
+ *
+ * @symbol_white_list: Do not match a relocation to a symbol in this list
+ * even if it is targetting a section in @bad_to_sec.
+ *
+ * @handler: Specific handler to call when a match is found.  If NULL,
+ * default_mismatch_handler() will be called.
+ *
+ */
 struct sectioncheck {
 	const char *fromsec[20];
 	const char *bad_tosec[20];

commit 52dc0595d540155436d91811f929bdc8afd6a2a1
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:52:53 2015 +0930

    modpost: handle relocations mismatch in __ex_table.
    
    __ex_table is a simple table section where each entry is a pair of
    addresses - the first address is an address which can fault in kernel
    space, and the second address points to where the kernel should jump to
    when handling that fault.  This is how copy_from_user() does not crash the
    kernel if userspace gives a borked pointer for example.
    
    If one of these addresses point to a non-executable section, something is
    seriously wrong since it either means the kernel will never fault from
    there or it will not be able to jump to there.  As both cases are serious
    enough, we simply error out in these cases so the build fails and the
    developper has to fix the issue.
    
    In case the section is executable, but it isn't referenced in our list of
    authorized sections to point to from __ex_table, we just dump a warning
    giving more information about it.  We do this in case the new section is
    executable but isn't supposed to be executed by the kernel.  This happened
    with .altinstr_replacement, which is executable but is only used to copy
    instructions from - we should never have our instruction pointer pointing
    in .altinstr_replacement.  Admitedly, a proper fix in that case would be to
    just set .altinstr_replacement NX, but we need to warn about future cases
    like this.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> (added long casts)

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index bf0cf8173beb..e95aa28ce0f7 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -875,6 +875,8 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define DATA_SECTIONS ".data", ".data.rel"
 #define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
 		".kprobes.text"
+#define OTHER_TEXT_SECTIONS ".ref.text", ".head.text", ".spinlock.text", \
+		".fixup", ".entry.text"
 
 #define INIT_SECTIONS      ".init.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"
@@ -882,6 +884,9 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define EXIT_SECTIONS      ".exit.*"
 #define MEM_EXIT_SECTIONS  ".memexit.*"
 
+#define ALL_TEXT_SECTIONS  ALL_INIT_TEXT_SECTIONS, ALL_EXIT_TEXT_SECTIONS, \
+		TEXT_SECTIONS, OTHER_TEXT_SECTIONS
+
 /* init data sections */
 static const char *const init_data_sections[] =
 	{ ALL_INIT_DATA_SECTIONS, NULL };
@@ -922,6 +927,7 @@ enum mismatch {
 	ANY_INIT_TO_ANY_EXIT,
 	ANY_EXIT_TO_ANY_INIT,
 	EXPORT_TO_INIT_EXIT,
+	EXTABLE_TO_NON_TEXT,
 };
 
 struct sectioncheck {
@@ -936,6 +942,11 @@ struct sectioncheck {
 
 };
 
+static void extable_mismatch_handler(const char *modname, struct elf_info *elf,
+				     const struct sectioncheck* const mismatch,
+				     Elf_Rela *r, Elf_Sym *sym,
+				     const char *fromsec);
+
 static const struct sectioncheck sectioncheck[] = {
 /* Do not reference init/exit code/data from
  * normal code and data
@@ -1013,6 +1024,16 @@ static const struct sectioncheck sectioncheck[] = {
 	.bad_tosec = { INIT_SECTIONS, EXIT_SECTIONS, NULL },
 	.mismatch = EXPORT_TO_INIT_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
+},
+{
+	.fromsec = { "__ex_table", NULL },
+	/* If you're adding any new black-listed sections in here, consider
+	 * adding a special 'printer' for them in scripts/check_extable.
+	 */
+	.bad_tosec = { ".altinstr_replacement", NULL },
+	.good_tosec = {ALL_TEXT_SECTIONS , NULL},
+	.mismatch = EXTABLE_TO_NON_TEXT,
+	.handler = extable_mismatch_handler,
 }
 };
 
@@ -1418,6 +1439,10 @@ static void report_sec_mismatch(const char *modname,
 		tosym, prl_to, prl_to, tosym);
 		free(prl_to);
 		break;
+	case EXTABLE_TO_NON_TEXT:
+		fatal("There's a special handler for this mismatch type, "
+		      "we should never get here.");
+		break;
 	}
 	fprintf(stderr, "\n");
 }
@@ -1453,6 +1478,120 @@ static void default_mismatch_handler(const char *modname, struct elf_info *elf,
 	}
 }
 
+static int is_executable_section(struct elf_info* elf, unsigned int section_index)
+{
+	if (section_index > elf->num_sections)
+		fatal("section_index is outside elf->num_sections!\n");
+
+	return ((elf->sechdrs[section_index].sh_flags & SHF_EXECINSTR) == SHF_EXECINSTR);
+}
+
+/*
+ * We rely on a gross hack in section_rel[a]() calling find_extable_entry_size()
+ * to know the sizeof(struct exception_table_entry) for the target architecture.
+ */
+static unsigned int extable_entry_size = 0;
+static void find_extable_entry_size(const char* const sec, const Elf_Rela* r,
+				    const void* start, const void* cur)
+{
+	/*
+	 * If we're currently checking the second relocation within __ex_table,
+	 * that relocation offset tells us the offsetof(struct
+	 * exception_table_entry, fixup) which is equal to sizeof(struct
+	 * exception_table_entry) divided by two.  We use that to our advantage
+	 * since there's no portable way to get that size as every architecture
+	 * seems to go with different sized types.  Not pretty but better than
+	 * hard-coding the size for every architecture..
+	 */
+	if (!extable_entry_size && cur == start + 1 &&
+	    strcmp("__ex_table", sec) == 0)
+		extable_entry_size = r->r_offset * 2;
+}
+static inline bool is_extable_fault_address(Elf_Rela *r)
+{
+	if (!extable_entry_size == 0)
+		fatal("extable_entry size hasn't been discovered!\n");
+
+	return ((r->r_offset == 0) ||
+		(r->r_offset % extable_entry_size == 0));
+}
+
+static void report_extable_warnings(const char* modname, struct elf_info* elf,
+				    const struct sectioncheck* const mismatch,
+				    Elf_Rela* r, Elf_Sym* sym,
+				    const char* fromsec, const char* tosec)
+{
+	Elf_Sym* fromsym = find_elf_symbol2(elf, r->r_offset, fromsec);
+	const char* fromsym_name = sym_name(elf, fromsym);
+	Elf_Sym* tosym = find_elf_symbol(elf, r->r_addend, sym);
+	const char* tosym_name = sym_name(elf, tosym);
+	const char* from_pretty_name;
+	const char* from_pretty_name_p;
+	const char* to_pretty_name;
+	const char* to_pretty_name_p;
+
+	get_pretty_name(is_function(fromsym),
+			&from_pretty_name, &from_pretty_name_p);
+	get_pretty_name(is_function(tosym),
+			&to_pretty_name, &to_pretty_name_p);
+
+	warn("%s(%s+0x%lx): Section mismatch in reference"
+	     " from the %s %s%s to the %s %s:%s%s\n",
+	     modname, fromsec, (long)r->r_offset, from_pretty_name,
+	     fromsym_name, from_pretty_name_p,
+	     to_pretty_name, tosec, tosym_name, to_pretty_name_p);
+
+	if (!match(tosec, mismatch->bad_tosec) &&
+	    is_executable_section(elf, get_secindex(elf, sym)))
+		fprintf(stderr,
+			"The relocation at %s+0x%lx references\n"
+			"section \"%s\" which is not in the list of\n"
+			"authorized sections.  If you're adding a new section\n"
+			"and/or if this reference is valid, add \"%s\" to the\n"
+			"list of authorized sections to jump to on fault.\n"
+			"This can be achieved by adding \"%s\" to \n"
+			"OTHER_TEXT_SECTIONS in scripts/mod/modpost.c.\n",
+			fromsec, (long)r->r_offset, tosec, tosec, tosec);
+}
+
+static void extable_mismatch_handler(const char* modname, struct elf_info *elf,
+				     const struct sectioncheck* const mismatch,
+				     Elf_Rela* r, Elf_Sym* sym,
+				     const char *fromsec)
+{
+	const char* tosec = sec_name(elf, get_secindex(elf, sym));
+
+	sec_mismatch_count++;
+
+	if (sec_mismatch_verbose)
+		report_extable_warnings(modname, elf, mismatch, r, sym,
+					fromsec, tosec);
+
+	if (match(tosec, mismatch->bad_tosec))
+		fatal("The relocation at %s+0x%lx references\n"
+		      "section \"%s\" which is black-listed.\n"
+		      "Something is seriously wrong and should be fixed.\n"
+		      "You might get more information about where this is\n"
+		      "coming from by using scripts/check_extable.sh %s\n",
+		      fromsec, (long)r->r_offset, tosec, modname);
+	else if (!is_executable_section(elf, get_secindex(elf, sym))) {
+		if (is_extable_fault_address(r))
+			fatal("The relocation at %s+0x%lx references\n"
+			      "section \"%s\" which is not executable, IOW\n"
+			      "it is not possible for the kernel to fault\n"
+			      "at that address.  Something is seriously wrong\n"
+			      "and should be fixed.\n",
+			      fromsec, (long)r->r_offset, tosec);
+		else
+			fatal("The relocation at %s+0x%lx references\n"
+			      "section \"%s\" which is not executable, IOW\n"
+			      "the kernel will fault if it ever tries to\n"
+			      "jump to it.  Something is seriously wrong\n"
+			      "and should be fixed.\n",
+			      fromsec, (long)r->r_offset, tosec);
+	}
+}
+
 static void check_section_mismatch(const char *modname, struct elf_info *elf,
 				   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
 {
@@ -1605,6 +1744,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 		/* Skip special sections */
 		if (is_shndx_special(sym->st_shndx))
 			continue;
+		find_extable_entry_size(fromsec, &r, start, rela);
 		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
 }
@@ -1663,6 +1803,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 		/* Skip special sections */
 		if (is_shndx_special(sym->st_shndx))
 			continue;
+		find_extable_entry_size(fromsec, &r, start, rel);
 		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
 }

commit c7a65e0645b2d1f8382ce27f4edaf1b4f2e09549
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:43:45 2015 +0930

    modpost: mismatch_handler: retrieve tosym information only when needed.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c69681e815b2..bf0cf8173beb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1432,16 +1432,17 @@ static void default_mismatch_handler(const char *modname, struct elf_info *elf,
 	const char *tosym;
 	const char *fromsym;
 
-	tosec = sec_name(elf, get_secindex(elf, sym));
 	from = find_elf_symbol2(elf, r->r_offset, fromsec);
 	fromsym = sym_name(elf, from);
-	to = find_elf_symbol(elf, r->r_addend, sym);
-	tosym = sym_name(elf, to);
 
 	if (!strncmp(fromsym, "reference___initcall",
 		     sizeof("reference___initcall")-1))
 		return;
 
+	tosec = sec_name(elf, get_secindex(elf, sym));
+	to = find_elf_symbol(elf, r->r_addend, sym);
+	tosym = sym_name(elf, to);
+
 	/* check whitelist - we may ignore it */
 	if (secref_whitelist(mismatch,
 			     fromsec, fromsym, tosec, tosym)) {

commit 356ad538128ed9221f7d01199a3a7d080f158a5d
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:43:34 2015 +0930

    modpost: factorize symbol pretty print in get_pretty_name().
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0f48f8b97b17..c69681e815b2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1270,6 +1270,15 @@ static void print_section_list(const char * const list[20])
 	fprintf(stderr, "\n");
 }
 
+static inline void get_pretty_name(int is_func, const char** name, const char** name_p)
+{
+	switch (is_func) {
+	case 0:	*name = "variable"; *name_p = ""; break;
+	case 1:	*name = "function"; *name_p = "()"; break;
+	default: *name = "(unknown reference)"; *name_p = ""; break;
+	}
+}
+
 /*
  * Print a warning about a section mismatch.
  * Try to find symbols near it so user can find it.
@@ -1289,21 +1298,13 @@ static void report_sec_mismatch(const char *modname,
 	char *prl_from;
 	char *prl_to;
 
-	switch (from_is_func) {
-	case 0: from = "variable"; from_p = "";   break;
-	case 1: from = "function"; from_p = "()"; break;
-	default: from = "(unknown reference)"; from_p = ""; break;
-	}
-	switch (to_is_func) {
-	case 0: to = "variable"; to_p = "";   break;
-	case 1: to = "function"; to_p = "()"; break;
-	default: to = "(unknown reference)"; to_p = ""; break;
-	}
-
 	sec_mismatch_count++;
 	if (!sec_mismatch_verbose)
 		return;
 
+	get_pretty_name(from_is_func, &from, &from_p);
+	get_pretty_name(to_is_func, &to, &to_p);
+
 	warn("%s(%s+0x%llx): Section mismatch in reference from the %s %s%s "
 	     "to the %s %s:%s%s\n",
 	     modname, fromsec, fromaddr, from, fromsym, from_p, to, tosec,

commit 644e8f14cb3bca5c66f6ddd944d9d26074eec46e
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:43:17 2015 +0930

    modpost: add handler function pointer to sectioncheck.
    
    This will be useful when we want to have special handlers which need to go
    through more hops to print useful information to the user.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8cef46b18dc6..0f48f8b97b17 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -930,6 +930,10 @@ struct sectioncheck {
 	const char *good_tosec[20];
 	enum mismatch mismatch;
 	const char *symbol_white_list[20];
+	void (*handler)(const char *modname, struct elf_info *elf,
+			const struct sectioncheck* const mismatch,
+			Elf_Rela *r, Elf_Sym *sym, const char *fromsec);
+
 };
 
 static const struct sectioncheck sectioncheck[] = {
@@ -1417,37 +1421,49 @@ static void report_sec_mismatch(const char *modname,
 	fprintf(stderr, "\n");
 }
 
-static void check_section_mismatch(const char *modname, struct elf_info *elf,
-				   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
+static void default_mismatch_handler(const char *modname, struct elf_info *elf,
+				     const struct sectioncheck* const mismatch,
+				     Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
 {
 	const char *tosec;
-	const struct sectioncheck *mismatch;
+	Elf_Sym *to;
+	Elf_Sym *from;
+	const char *tosym;
+	const char *fromsym;
 
 	tosec = sec_name(elf, get_secindex(elf, sym));
-	mismatch = section_mismatch(fromsec, tosec);
+	from = find_elf_symbol2(elf, r->r_offset, fromsec);
+	fromsym = sym_name(elf, from);
+	to = find_elf_symbol(elf, r->r_addend, sym);
+	tosym = sym_name(elf, to);
+
+	if (!strncmp(fromsym, "reference___initcall",
+		     sizeof("reference___initcall")-1))
+		return;
+
+	/* check whitelist - we may ignore it */
+	if (secref_whitelist(mismatch,
+			     fromsec, fromsym, tosec, tosym)) {
+		report_sec_mismatch(modname, mismatch,
+				    fromsec, r->r_offset, fromsym,
+				    is_function(from), tosec, tosym,
+				    is_function(to));
+	}
+}
+
+static void check_section_mismatch(const char *modname, struct elf_info *elf,
+				   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
+{
+	const char *tosec = sec_name(elf, get_secindex(elf, sym));;
+	const struct sectioncheck *mismatch = section_mismatch(fromsec, tosec);
+
 	if (mismatch) {
-		Elf_Sym *to;
-		Elf_Sym *from;
-		const char *tosym;
-		const char *fromsym;
-
-		from = find_elf_symbol2(elf, r->r_offset, fromsec);
-		fromsym = sym_name(elf, from);
-		to = find_elf_symbol(elf, r->r_addend, sym);
-		tosym = sym_name(elf, to);
-
-		if (!strncmp(fromsym, "reference___initcall",
-				sizeof("reference___initcall")-1))
-			return;
-
-		/* check whitelist - we may ignore it */
-		if (secref_whitelist(mismatch,
-					fromsec, fromsym, tosec, tosym)) {
-			report_sec_mismatch(modname, mismatch,
-			   fromsec, r->r_offset, fromsym,
-			   is_function(from), tosec, tosym,
-			   is_function(to));
-		}
+		if (mismatch->handler)
+			mismatch->handler(modname, elf,  mismatch,
+					  r, sym, fromsec);
+		else
+			default_mismatch_handler(modname, elf, mismatch,
+						 r, sym, fromsec);
 	}
 }
 

commit 157d1972d079207332d31a761cdfb81598455e0a
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:42:52 2015 +0930

    modpost: add .sched.text and .kprobes.text to the TEXT_SECTIONS list.
    
    sched.text and .kprobes.text should behave exactly like .text with regards
    to how we should warn about referencing sections which might get discarded
    at runtime.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7094a57273b9..8cef46b18dc6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -873,7 +873,8 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
 
 #define DATA_SECTIONS ".data", ".data.rel"
-#define TEXT_SECTIONS ".text", ".text.unlikely"
+#define TEXT_SECTIONS ".text", ".text.unlikely", ".sched.text", \
+		".kprobes.text"
 
 #define INIT_SECTIONS      ".init.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"

commit 050e57fd5936eb175cbb7a788252aa6867201120
Author: Quentin Casasnovas <quentin.casasnovas@oracle.com>
Date:   Mon Apr 13 20:41:04 2015 +0930

    modpost: add strict white-listing when referencing sections.
    
    Prints a warning when a section references a section outside a strict
    white-list.  This will be useful to print a warning if __ex_table
    references a non-executable section.
    
    Signed-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d439856f8176..7094a57273b9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -925,7 +925,8 @@ enum mismatch {
 
 struct sectioncheck {
 	const char *fromsec[20];
-	const char *tosec[20];
+	const char *bad_tosec[20];
+	const char *good_tosec[20];
 	enum mismatch mismatch;
 	const char *symbol_white_list[20];
 };
@@ -936,19 +937,19 @@ static const struct sectioncheck sectioncheck[] = {
  */
 {
 	.fromsec = { TEXT_SECTIONS, NULL },
-	.tosec   = { ALL_INIT_SECTIONS, NULL },
+	.bad_tosec = { ALL_INIT_SECTIONS, NULL },
 	.mismatch = TEXT_TO_ANY_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
-	.tosec   = { ALL_XXXINIT_SECTIONS, NULL },
+	.bad_tosec = { ALL_XXXINIT_SECTIONS, NULL },
 	.mismatch = DATA_TO_ANY_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
-	.tosec   = { INIT_SECTIONS, NULL },
+	.bad_tosec = { INIT_SECTIONS, NULL },
 	.mismatch = DATA_TO_ANY_INIT,
 	.symbol_white_list = {
 		"*_template", "*_timer", "*_sht", "*_ops",
@@ -957,54 +958,54 @@ static const struct sectioncheck sectioncheck[] = {
 },
 {
 	.fromsec = { TEXT_SECTIONS, NULL },
-	.tosec   = { ALL_EXIT_SECTIONS, NULL },
+	.bad_tosec = { ALL_EXIT_SECTIONS, NULL },
 	.mismatch = TEXT_TO_ANY_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
-	.tosec   = { ALL_EXIT_SECTIONS, NULL },
+	.bad_tosec = { ALL_EXIT_SECTIONS, NULL },
 	.mismatch = DATA_TO_ANY_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference init code/data from meminit code/data */
 {
 	.fromsec = { ALL_XXXINIT_SECTIONS, NULL },
-	.tosec   = { INIT_SECTIONS, NULL },
+	.bad_tosec = { INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_SOME_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference exit code/data from memexit code/data */
 {
 	.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },
-	.tosec   = { EXIT_SECTIONS, NULL },
+	.bad_tosec = { EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_SOME_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not use exit code/data from init code */
 {
 	.fromsec = { ALL_INIT_SECTIONS, NULL },
-	.tosec   = { ALL_EXIT_SECTIONS, NULL },
+	.bad_tosec = { ALL_EXIT_SECTIONS, NULL },
 	.mismatch = ANY_INIT_TO_ANY_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not use init code/data from exit code */
 {
 	.fromsec = { ALL_EXIT_SECTIONS, NULL },
-	.tosec   = { ALL_INIT_SECTIONS, NULL },
+	.bad_tosec = { ALL_INIT_SECTIONS, NULL },
 	.mismatch = ANY_EXIT_TO_ANY_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { ALL_PCI_INIT_SECTIONS, NULL },
-	.tosec   = { INIT_SECTIONS, NULL },
+	.bad_tosec = { INIT_SECTIONS, NULL },
 	.mismatch = ANY_INIT_TO_ANY_EXIT,
 	.symbol_white_list = { NULL },
 },
 /* Do not export init/exit functions or data */
 {
 	.fromsec = { "__ksymtab*", NULL },
-	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL },
+	.bad_tosec = { INIT_SECTIONS, EXIT_SECTIONS, NULL },
 	.mismatch = EXPORT_TO_INIT_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 }
@@ -1018,9 +1019,12 @@ static const struct sectioncheck *section_mismatch(
 	const struct sectioncheck *check = &sectioncheck[0];
 
 	for (i = 0; i < elems; i++) {
-		if (match(fromsec, check->fromsec) &&
-		    match(tosec, check->tosec))
-			return check;
+		if (match(fromsec, check->fromsec)) {
+			if (check->bad_tosec[0] && match(tosec, check->bad_tosec))
+				return check;
+			if (check->good_tosec[0] && !match(tosec, check->good_tosec))
+				return check;
+		}
 		check++;
 	}
 	return NULL;

commit 6325e940e7e0c690c6bdfaf5d54309e71845d3d9
Merge: 536fd93d4328 0a6479b0ffad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 8 05:34:24 2014 -0400

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Catalin Marinas:
     - eBPF JIT compiler for arm64
     - CPU suspend backend for PSCI (firmware interface) with standard idle
       states defined in DT (generic idle driver to be merged via a
       different tree)
     - Support for CONFIG_DEBUG_SET_MODULE_RONX
     - Support for unmapped cpu-release-addr (outside kernel linear mapping)
     - set_arch_dma_coherent_ops() implemented and bus notifiers removed
     - EFI_STUB improvements when base of DRAM is occupied
     - Typos in KGDB macros
     - Clean-up to (partially) allow kernel building with LLVM
     - Other clean-ups (extern keyword, phys_addr_t usage)
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (51 commits)
      arm64: Remove unneeded extern keyword
      ARM64: make of_device_ids const
      arm64: Use phys_addr_t type for physical address
      aarch64: filter $x from kallsyms
      arm64: Use DMA_ERROR_CODE to denote failed allocation
      arm64: Fix typos in KGDB macros
      arm64: insn: Add return statements after BUG_ON()
      arm64: debug: don't re-enable debug exceptions on return from el1_dbg
      Revert "arm64: dmi: Add SMBIOS/DMI support"
      arm64: Implement set_arch_dma_coherent_ops() to replace bus notifiers
      of: amba: use of_dma_configure for AMBA devices
      arm64: dmi: Add SMBIOS/DMI support
      arm64: Correct ftrace calls to aarch64_insn_gen_branch_imm()
      arm64:mm: initialize max_mapnr using function set_max_mapnr
      setup: Move unmask of async interrupts after possible earlycon setup
      arm64: LLVMLinux: Fix inline arm64 assembly for use with clang
      arm64: pageattr: Correctly adjust unaligned start addresses
      net: bpf: arm64: fix module memory leak when JIT image build fails
      arm64: add PSCI CPU_SUSPEND based cpu_suspend support
      arm64: kernel: introduce cpu_init_idle CPU operation
      ...

commit 6c34f1f5424395994c125f8c68bed395920ecc58
Author: Kyle McMartin <kyle@redhat.com>
Date:   Tue Sep 16 22:37:18 2014 +0100

    aarch64: filter $x from kallsyms
    
    Similar to ARM, AArch64 is generating $x and $d syms... which isn't
    terribly helpful when looking at %pF output and the like. Filter those
    out in kallsyms, modpost and when looking at module symbols.
    
    Seems simplest since none of these check EM_ARM anyway, to just add it
    to the strchr used, rather than trying to make things overly
    complicated.
    
    initcall_debug improves:
    dmesg_before.txt: initcall $x+0x0/0x154 [sg] returned 0 after 26331 usecs
    dmesg_after.txt: initcall init_sg+0x0/0x154 [sg] returned 0 after 15461 usecs
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 091d90573b63..3017ec20e9f8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1146,7 +1146,7 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,
 
 static inline int is_arm_mapping_symbol(const char *str)
 {
-	return str[0] == '$' && strchr("atd", str[1])
+	return str[0] == '$' && strchr("axtd", str[1])
 	       && (str[2] == '\0' || str[2] == '.');
 }
 

commit d93e1719a313ca960b38c5159be0106884317997
Author: Mathias Krause <minipli@googlemail.com>
Date:   Wed Aug 27 20:28:56 2014 +0930

    modpost: simplify file name generation of *.mod.c files
    
    Avoid the variable length array (vla), just use PATH_MAX instead.
    This not only makes this code clang friedly, it also leads to a
    code size reduction:
    
       text    data     bss     dec     hex filename
      51765    2224   12416   66405   10365 scripts/mod/modpost.old
      51677    2224   12416   66317   1030d scripts/mod/modpost.new
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c2ebdc788f4c..3b405c726ec5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2212,7 +2212,7 @@ int main(int argc, char **argv)
 	err = 0;
 
 	for (mod = modules; mod; mod = mod->next) {
-		char fname[strlen(mod->name) + 10];
+		char fname[PATH_MAX];
 
 		if (mod->skip)
 			continue;

commit 7a3ee7538598e0d60e6aa87dcf34a4e8a0adebc2
Author: Mathias Krause <minipli@googlemail.com>
Date:   Wed Aug 27 20:28:53 2014 +0930

    modpost: reduce visibility of symbols and constify r/o arrays
    
    Internally used symbols of modpost don't need to be externally visible;
    make them static. Also constify the string arrays so they resist in the
    r/o section instead of being runtime writable.
    
    Those changes lead to a small size reduction as can be seen below:
    
       text    data     bss     dec     hex filename
      51381    2640   12416   66437   10385 scripts/mod/modpost.old
      51765    2224   12416   66405   10365 scripts/mod/modpost.new
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 091d90573b63..c2ebdc788f4c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -24,9 +24,9 @@
 #include "../../include/linux/export.h"
 
 /* Are we using CONFIG_MODVERSIONS? */
-int modversions = 0;
+static int modversions = 0;
 /* Warn about undefined symbols? (do so if we have vmlinux) */
-int have_vmlinux = 0;
+static int have_vmlinux = 0;
 /* Is CONFIG_MODULE_SRCVERSION_ALL set? */
 static int all_versions = 0;
 /* If we are modposting external module set to 1 */
@@ -229,7 +229,7 @@ static struct symbol *find_symbol(const char *name)
 	return NULL;
 }
 
-static struct {
+static const struct {
 	const char *str;
 	enum export export;
 } export_list[] = {
@@ -805,7 +805,7 @@ static int match(const char *sym, const char * const pat[])
 }
 
 /* sections that we do not want to do full section mismatch check on */
-static const char *section_white_list[] =
+static const char *const section_white_list[] =
 {
 	".comment*",
 	".debug*",
@@ -882,17 +882,18 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define MEM_EXIT_SECTIONS  ".memexit.*"
 
 /* init data sections */
-static const char *init_data_sections[] = { ALL_INIT_DATA_SECTIONS, NULL };
+static const char *const init_data_sections[] =
+	{ ALL_INIT_DATA_SECTIONS, NULL };
 
 /* all init sections */
-static const char *init_sections[] = { ALL_INIT_SECTIONS, NULL };
+static const char *const init_sections[] = { ALL_INIT_SECTIONS, NULL };
 
 /* All init and exit sections (code + data) */
-static const char *init_exit_sections[] =
+static const char *const init_exit_sections[] =
 	{ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL };
 
 /* data section */
-static const char *data_sections[] = { DATA_SECTIONS, NULL };
+static const char *const data_sections[] = { DATA_SECTIONS, NULL };
 
 
 /* symbols in .data that may refer to init/exit sections */
@@ -906,8 +907,8 @@ static const char *data_sections[] = { DATA_SECTIONS, NULL };
 	"*_probe_one",							\
 	"*_console"
 
-static const char *head_sections[] = { ".head.text*", NULL };
-static const char *linker_symbols[] =
+static const char *const head_sections[] = { ".head.text*", NULL };
+static const char *const linker_symbols[] =
 	{ "__init_begin", "_sinittext", "_einittext", NULL };
 
 enum mismatch {
@@ -929,7 +930,7 @@ struct sectioncheck {
 	const char *symbol_white_list[20];
 };
 
-const struct sectioncheck sectioncheck[] = {
+static const struct sectioncheck sectioncheck[] = {
 /* Do not reference init/exit code/data from
  * normal code and data
  */

commit a0d8f8037468a3b5f964417f71853ccf301b9f39
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Sun Jul 27 07:28:01 2014 +0930

    scripts: modpost: Remove numeric suffix pattern matching
    
    For several years, the pattern "foo$" has effectively been treated as
    equivalent to "foo" due to a bug in the (misnamed) helper
    number_prefix(). This hasn't been observed to cause any problems, so
    remove the broken $ functionality and change all foo$ patterns to foo.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5ba203b9eddf..091d90573b63 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -772,32 +772,10 @@ static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
 		sechdr->sh_name;
 }
 
-/* if sym is empty or point to a string
- * like ".[0-9]+" then return 1.
- * This is the optional prefix added by ld to some sections
- */
-static int number_prefix(const char *sym)
-{
-	if (*sym++ == '\0')
-		return 1;
-	if (*sym != '.')
-		return 0;
-	do {
-		char c = *sym++;
-		if (c < '0' || c > '9')
-			return 0;
-	} while (*sym);
-	return 1;
-}
-
 /* The pattern is an array of simple patterns.
  * "foo" will match an exact string equal to "foo"
  * "*foo" will match a string that ends with "foo"
  * "foo*" will match a string that begins with "foo"
- * "foo$" will match a string equal to "foo" or "foo.1"
- *   where the '1' can be any number including several digits.
- *   The $ syntax is for sections where ld append a dot number
- *   to make section name unique.
  */
 static int match(const char *sym, const char * const pat[])
 {
@@ -816,13 +794,6 @@ static int match(const char *sym, const char * const pat[])
 			if (strncmp(sym, p, strlen(p) - 1) == 0)
 				return 1;
 		}
-		/* "foo$" */
-		else if (*endp == '$') {
-			if (strncmp(sym, p, strlen(p) - 1) == 0) {
-				if (number_prefix(sym + strlen(p) - 1))
-					return 1;
-			}
-		}
 		/* no wildcards */
 		else {
 			if (strcmp(p, sym) == 0)
@@ -880,20 +851,20 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 
 #define ALL_INIT_DATA_SECTIONS \
-	".init.setup$", ".init.rodata$", ".meminit.rodata$", \
-	".init.data$", ".meminit.data$"
+	".init.setup", ".init.rodata", ".meminit.rodata", \
+	".init.data", ".meminit.data"
 #define ALL_EXIT_DATA_SECTIONS \
-	".exit.data$", ".memexit.data$"
+	".exit.data", ".memexit.data"
 
 #define ALL_INIT_TEXT_SECTIONS \
-	".init.text$", ".meminit.text$"
+	".init.text", ".meminit.text"
 #define ALL_EXIT_TEXT_SECTIONS \
-	".exit.text$", ".memexit.text$"
+	".exit.text", ".memexit.text"
 
 #define ALL_PCI_INIT_SECTIONS	\
-	".pci_fixup_early$", ".pci_fixup_header$", ".pci_fixup_final$", \
-	".pci_fixup_enable$", ".pci_fixup_resume$", \
-	".pci_fixup_resume_early$", ".pci_fixup_suspend$"
+	".pci_fixup_early", ".pci_fixup_header", ".pci_fixup_final", \
+	".pci_fixup_enable", ".pci_fixup_resume", \
+	".pci_fixup_resume_early", ".pci_fixup_suspend"
 
 #define ALL_XXXINIT_SECTIONS MEM_INIT_SECTIONS
 #define ALL_XXXEXIT_SECTIONS MEM_EXIT_SECTIONS
@@ -901,8 +872,8 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS
 #define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
 
-#define DATA_SECTIONS ".data$", ".data.rel$"
-#define TEXT_SECTIONS ".text$", ".text.unlikely$"
+#define DATA_SECTIONS ".data", ".data.rel"
+#define TEXT_SECTIONS ".text", ".text.unlikely"
 
 #define INIT_SECTIONS      ".init.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"

commit fcd38ed0ff263156c3917c70c2fb0b7e91bfeab1
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Sun Jul 27 07:27:01 2014 +0930

    scripts: modpost: fix compilation warning
    
    The scripts/mod/modpost.c triggers the following warning:
    
    scripts/mod/modpost.c: In function remove_dot:
    scripts/mod/modpost.c:1710:10: warning: ignoring return value of strtoul, declared with attribute warn_unused_result [-Wunused-result]
    
    The remove_dot function that calls strtoul does not care about the
    numeric value of the string that is parsed but only looks for the
    end of the numeric sequence.  As such, it's equivalent to just skip
    over all digits.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 9d9c5b905b35..5ba203b9eddf 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1703,12 +1703,11 @@ static void check_sec_ref(struct module *mod, const char *modname,
 
 static char *remove_dot(char *s)
 {
-	char *end;
-	int n = strcspn(s, ".");
+	size_t n = strcspn(s, ".");
 
-	if (n > 0 && s[n] != 0) {
-		strtoul(s + n + 1, &end, 10);
-		if  (end > s + n + 1 && (*end == '.' || *end == 0))
+	if (n && s[n]) {
+		size_t m = strspn(s + n + 1, "0123456789");
+		if (m && (s[n + m] == '.' || s[n + m] == 0))
 			s[n] = 0;
 	}
 	return s;

commit c1fdb2d3389c5a1e7c559a37a4967c1d2580e75c
Merge: 1700ff823b27 7fa0e6db3ced
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 21:29:20 2014 -0700

    Merge branch 'misc' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild misc updates from Michal Marek:
     "This is the non-critical part of kbuild for v3.16-rc1:
       - make deb-pkg can do s390x and arm64
       - new patterns in scripts/tags.sh
       - scripts/tags.sh skips userspace tools' sources (which sometimes
         have copies of kernel structures) and symlinks
       - improvements to the objdiff tool
       - two new coccinelle patches
       - other minor fixes"
    
    * 'misc' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      scripts: objdiff: support directories for the augument of record command
      scripts: objdiff: fix a comment
      scripts: objdiff: change the extension of disassembly from .o to .dis
      scripts: objdiff: improve path flexibility for record command
      scripts: objdiff: remove unnecessary code
      scripts: objdiff: direct error messages to stderr
      scripts: objdiff: get the path to .tmp_objdiff more simply
      deb-pkg: Add automatic support for s390x architecture
      coccicheck: Add unneeded return variable test
      kbuild: Fix a typo in documentation
      kbuild: trivial - use tabs for code indent where possible
      kbuild: trivial - remove trailing empty lines
      coccinelle: Check for missing NULL terminators in of_device_id tables
      scripts/tags.sh: ignore symlink'ed source files
      scripts/tags.sh: add regular expression replacement pattern for memcg
      builddeb: add arm64 in the supported architectures
      builddeb: use $OBJCOPY variable instead of objcopy
      scripts/tags.sh: ignore code of user space tools
      scripts/tags.sh: add pattern for DEFINE_HASHTABLE
      .gitignore: ignore Module.symvers in all directories

commit 4251c2a67011801caecd63671f26dd8c9aedb24c
Merge: c31c24b8251f 4982223e51e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 11 16:09:14 2014 -0700

    Merge tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull module updates from Rusty Russell:
     "Most of this is cleaning up various driver sysfs permissions so we can
      re-add the perm check (we unified the module param and sysfs checks,
      but the module ones were stronger so we weakened them temporarily).
    
      Param parsing gets documented, and also "--" now forces args to be
      handed to init (and ignored by the kernel).
    
      Module NX/RO protections get tightened: we now set them before calling
      parse_args()"
    
    * tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      module: set nx before marking module MODULE_STATE_COMING.
      samples/kobject/: avoid world-writable sysfs files.
      drivers/hid/hid-picolcd_fb: avoid world-writable sysfs files.
      drivers/staging/speakup/: avoid world-writable sysfs files.
      drivers/regulator/virtual: avoid world-writable sysfs files.
      drivers/scsi/pm8001/pm8001_ctl.c: avoid world-writable sysfs files.
      drivers/hid/hid-lg4ff.c: avoid world-writable sysfs files.
      drivers/video/fbdev/sm501fb.c: avoid world-writable sysfs files.
      drivers/mtd/devices/docg3.c: avoid world-writable sysfs files.
      speakup: fix incorrect perms on speakup_acntsa.c
      cpumask.h: silence warning with -Wsign-compare
      Documentation: Update kernel-parameters.tx
      param: hand arguments after -- straight to init
      modpost: Fix resource leak in read_dump()

commit bb66fc67192bbd406fe9c22033f1bbbf3e7ec621
Author: Masahiro Yamada <yamada.m@jp.panasonic.com>
Date:   Tue Jun 10 19:08:13 2014 +0900

    kbuild: trivial - use tabs for code indent where possible
    
    Signed-off-by: Masahiro Yamada <yamada.m@jp.panasonic.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 066355673930..cd766877871e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -862,7 +862,7 @@ static const char *section_white_list[] =
  * without "ax" / "aw".
  */
 static void check_section(const char *modname, struct elf_info *elf,
-                          Elf_Shdr *sechdr)
+			  Elf_Shdr *sechdr)
 {
 	const char *sec = sech_name(elf, sechdr);
 
@@ -1296,12 +1296,12 @@ static void print_section_list(const char * const list[20])
  */
 static void report_sec_mismatch(const char *modname,
 				const struct sectioncheck *mismatch,
-                                const char *fromsec,
-                                unsigned long long fromaddr,
-                                const char *fromsym,
-                                int from_is_func,
-                                const char *tosec, const char *tosym,
-                                int to_is_func)
+				const char *fromsec,
+				unsigned long long fromaddr,
+				const char *fromsym,
+				int from_is_func,
+				const char *tosec, const char *tosym,
+				int to_is_func)
 {
 	const char *from, *from_p;
 	const char *to, *to_p;
@@ -1441,7 +1441,7 @@ static void report_sec_mismatch(const char *modname,
 }
 
 static void check_section_mismatch(const char *modname, struct elf_info *elf,
-                                   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
+				   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
 {
 	const char *tosec;
 	const struct sectioncheck *mismatch;
@@ -1528,7 +1528,7 @@ static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 	case R_ARM_ABS32:
 		/* From ARM ABI: (S + A) | T */
 		r->r_addend = (int)(long)
-		              (elf->symtab_start + ELF_R_SYM(r->r_info));
+			      (elf->symtab_start + ELF_R_SYM(r->r_info));
 		break;
 	case R_ARM_PC24:
 	case R_ARM_CALL:
@@ -1538,8 +1538,8 @@ static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 	case R_ARM_THM_JUMP19:
 		/* From ARM ABI: ((S + A) | T) - P */
 		r->r_addend = (int)(long)(elf->hdr +
-		              sechdr->sh_offset +
-		              (r->r_offset - sechdr->sh_addr));
+			      sechdr->sh_offset +
+			      (r->r_offset - sechdr->sh_addr));
 		break;
 	default:
 		return 1;
@@ -1571,7 +1571,7 @@ static int addend_mips_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 }
 
 static void section_rela(const char *modname, struct elf_info *elf,
-                         Elf_Shdr *sechdr)
+			 Elf_Shdr *sechdr)
 {
 	Elf_Sym  *sym;
 	Elf_Rela *rela;
@@ -1615,7 +1615,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 }
 
 static void section_rel(const char *modname, struct elf_info *elf,
-                        Elf_Shdr *sechdr)
+			Elf_Shdr *sechdr)
 {
 	Elf_Sym *sym;
 	Elf_Rel *rel;
@@ -1685,7 +1685,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
  * be discarded and warns about it.
  **/
 static void check_sec_ref(struct module *mod, const char *modname,
-                          struct elf_info *elf)
+			  struct elf_info *elf)
 {
 	int i;
 	Elf_Shdr *sechdrs = elf->sechdrs;
@@ -1945,7 +1945,7 @@ static int add_versions(struct buffer *b, struct module *mod)
 					     s->name, mod->name);
 				} else {
 					merror("\"%s\" [%s.ko] undefined!\n",
-					          s->name, mod->name);
+					       s->name, mod->name);
 					err = 1;
 				}
 			}

commit baec30e41957da2aa2cd9f5effa9b8f4bb755b3d
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Apr 16 18:05:35 2014 +0200

    modpost: Fix comment typo "Modules.symvers"
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 066355673930..ea7f9530afa2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -316,7 +316,7 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 			     s->module->name,
 			     is_vmlinux(s->module->name) ?"":".ko");
 		} else {
-			/* In case Modules.symvers was out of date */
+			/* In case Module.symvers was out of date */
 			s->module = mod;
 		}
 	}

commit 2ee41e62ba5b952e9d9fcba6f7079a0c608bb849
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Mon Apr 28 11:34:32 2014 +0930

    modpost: Fix resource leak in read_dump()
    
    Function read_dump() memory maps the input via grab_file(), but fails to call
    the corresponding unmap function. Add the missing call to release_file().
    Detected by Coverity: CID 1192419
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 066355673930..ea3e2bdf1825 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2113,8 +2113,10 @@ static void read_dump(const char *fname, unsigned int kernel)
 		s->preloaded = 1;
 		sym_update_crc(symname, mod, crc, export_no(export));
 	}
+	release_file(file, size);
 	return;
 fail:
+	release_file(file, size);
 	fatal("parse error in symbol dump file\n");
 }
 

commit 176ab02d4916f09d5d8cb63372d142df4378cdea
Merge: e06df6a7eae1 ef178f9238b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 31 14:13:25 2014 -0700

    Merge branch 'x86-asmlinkage-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 LTO changes from Peter Anvin:
     "More infrastructure work in preparation for link-time optimization
      (LTO).  Most of these changes is to make sure symbols accessed from
      assembly code are properly marked as visible so the linker doesn't
      remove them.
    
      My understanding is that the changes to support LTO are still not
      upstream in binutils, but are on the way there.  This patchset should
      conclude the x86-specific changes, and remaining patches to actually
      enable LTO will be fed through the Kbuild tree (other than keeping up
      with changes to the x86 code base, of course), although not
      necessarily in this merge window"
    
    * 'x86-asmlinkage-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (25 commits)
      Kbuild, lto: Handle basic LTO in modpost
      Kbuild, lto: Disable LTO for asm-offsets.c
      Kbuild, lto: Add a gcc-ld script to let run gcc as ld
      Kbuild, lto: add ld-version and ld-ifversion macros
      Kbuild, lto: Drop .number postfixes in modpost
      Kbuild, lto, workaround: Don't warn for initcall_reference in modpost
      lto: Disable LTO for sys_ni
      lto: Handle LTO common symbols in module loader
      lto, workaround: Add workaround for initcall reordering
      lto: Make asmlinkage __visible
      x86, lto: Disable LTO for the x86 VDSO
      initconst, x86: Fix initconst mistake in ts5500 code
      initconst: Fix initconst mistake in dcdbas
      asmlinkage: Make trace_hardirqs_on/off_caller visible
      asmlinkage, x86: Fix 32bit memcpy for LTO
      asmlinkage Make __stack_chk_failed and memcmp visible
      asmlinkage: Mark rwsem functions that can be called from assembler asmlinkage
      asmlinkage: Make main_extable_sort_needed visible
      asmlinkage, mutex: Mark __visible
      asmlinkage: Make trace_hardirq visible
      ...

commit c9698e5cd6ad1ff2844bc44fabddc0f2e0562047
Author: David A. Long <dave.long@linaro.org>
Date:   Fri Feb 14 22:41:18 2014 +0100

    ARM: 7964/1: Detect section mismatches in thumb relocations
    
    Add processing for normally encountered thumb relocation types so that
    section mismatches will be detected.
    
    Comment from Rusty Russell follows:
    
    Happiest for this to go through an ARM tree, so:
    
    Signed-off-by: David A. Long <dave.long@linaro.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 40610984a1b5..99a45fdc1bbf 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1502,6 +1502,16 @@ static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 #define R_ARM_JUMP24	29
 #endif
 
+#ifndef	R_ARM_THM_CALL
+#define	R_ARM_THM_CALL		10
+#endif
+#ifndef	R_ARM_THM_JUMP24
+#define	R_ARM_THM_JUMP24	30
+#endif
+#ifndef	R_ARM_THM_JUMP19
+#define	R_ARM_THM_JUMP19	51
+#endif
+
 static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	unsigned int r_typ = ELF_R_TYPE(r->r_info);
@@ -1515,6 +1525,9 @@ static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 	case R_ARM_PC24:
 	case R_ARM_CALL:
 	case R_ARM_JUMP24:
+	case R_ARM_THM_CALL:
+	case R_ARM_THM_JUMP24:
+	case R_ARM_THM_JUMP19:
 		/* From ARM ABI: ((S + A) | T) - P */
 		r->r_addend = (int)(long)(elf->hdr +
 		              sechdr->sh_offset +

commit ef178f9238b142cc1020265e176b20d27fd02ba9
Author: Andi Kleen <ak@linux.intel.com>
Date:   Sat Feb 8 09:01:17 2014 +0100

    Kbuild, lto: Handle basic LTO in modpost
    
    - Don't warn about LTO marker symbols. modpost runs before
    the linker, so the module is not necessarily LTOed yet.
    - Don't complain about .gnu.lto* sections
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1391846481-31491-13-git-send-email-ak@linux.intel.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f91dd4565b81..63804a16ba9f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -623,7 +623,10 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
-		warn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);
+		if (!strncmp(symname, "__gnu_lto_", sizeof("__gnu_lto_")-1)) {
+			/* Should warn here, but modpost runs before the linker */
+		} else
+			warn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);
 		break;
 	case SHN_UNDEF:
 		/* undefined symbol */
@@ -849,6 +852,7 @@ static const char *section_white_list[] =
 	".xt.lit",         /* xtensa */
 	".arcextmap*",			/* arc */
 	".gnu.linkonce.arcext*",	/* arc : modules */
+	".gnu.lto*",
 	NULL
 };
 

commit 7d02b490e93c199a15b3c4bce1c393588c1300ca
Author: Andi Kleen <ak@linux.intel.com>
Date:   Sat Feb 8 09:01:12 2014 +0100

    Kbuild, lto: Drop .number postfixes in modpost
    
    LTO turns all global symbols effectively into statics. This
    has the side effect that they all have a .NUMBER postfix to make
    them unique. In modpost drop this postfix because it confuses
    it.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1391846481-31491-8-git-send-email-ak@linux.intel.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1f1b1549f33f..f91dd4565b81 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1684,6 +1684,19 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	}
 }
 
+static char *remove_dot(char *s)
+{
+	char *end;
+	int n = strcspn(s, ".");
+
+	if (n > 0 && s[n] != 0) {
+		strtoul(s + n + 1, &end, 10);
+		if  (end > s + n + 1 && (*end == '.' || *end == 0))
+			s[n] = 0;
+	}
+	return s;
+}
+
 static void read_symbols(char *modname)
 {
 	const char *symname;
@@ -1722,7 +1735,7 @@ static void read_symbols(char *modname)
 	}
 
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
-		symname = info.strtab + sym->st_name;
+		symname = remove_dot(info.strtab + sym->st_name);
 
 		handle_modversions(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);

commit 77ab21adae509c5540956729e2d03bc1a59bc82a
Author: Andi Kleen <ak@linux.intel.com>
Date:   Sat Feb 8 09:01:11 2014 +0100

    Kbuild, lto, workaround: Don't warn for initcall_reference in modpost
    
    This reference is discarded, but can cause warnings when it refers to
    exit. Ignore for now.
    
    This is a workaround and can be removed once we get rid of
    -fno-toplevel-reorder
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Link: http://lkml.kernel.org/r/1391846481-31491-7-git-send-email-ak@linux.intel.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 40610984a1b5..1f1b1549f33f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1455,6 +1455,10 @@ static void check_section_mismatch(const char *modname, struct elf_info *elf,
 		to = find_elf_symbol(elf, r->r_addend, sym);
 		tosym = sym_name(elf, to);
 
+		if (!strncmp(fromsym, "reference___initcall",
+				sizeof("reference___initcall")-1))
+			return;
+
 		/* check whitelist - we may ignore it */
 		if (secref_whitelist(mismatch,
 					fromsec, fromsym, tosec, tosym)) {

commit 8fe9c93e7453e67b8bd09f263ec1bb0783c733fc
Author: Andreas Schwab <schwab@linux-m68k.org>
Date:   Mon Dec 30 15:31:17 2013 +0100

    powerpc: Add vr save/restore functions
    
    GCC 4.8 now generates out-of-line vr save/restore functions when
    optimizing for size.  They are needed for the raid6 altivec support.
    
    Signed-off-by: Andreas Schwab <schwab@linux-m68k.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 17855761e6b7..40610984a1b5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -584,12 +584,16 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 		if (strncmp(symname, "_restgpr_", sizeof("_restgpr_") - 1) == 0 ||
 		    strncmp(symname, "_savegpr_", sizeof("_savegpr_") - 1) == 0 ||
 		    strncmp(symname, "_rest32gpr_", sizeof("_rest32gpr_") - 1) == 0 ||
-		    strncmp(symname, "_save32gpr_", sizeof("_save32gpr_") - 1) == 0)
+		    strncmp(symname, "_save32gpr_", sizeof("_save32gpr_") - 1) == 0 ||
+		    strncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||
+		    strncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0)
 			return 1;
 	if (info->hdr->e_machine == EM_PPC64)
 		/* Special register function linked on all modules during final link of .ko */
 		if (strncmp(symname, "_restgpr0_", sizeof("_restgpr0_") - 1) == 0 ||
-		    strncmp(symname, "_savegpr0_", sizeof("_savegpr0_") - 1) == 0)
+		    strncmp(symname, "_savegpr0_", sizeof("_savegpr0_") - 1) == 0 ||
+		    strncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||
+		    strncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0)
 			return 1;
 	/* Do not ignore this symbol */
 	return 0;

commit ce6513f758b1852a2f24f76f07d0fae304d24ad3
Merge: d8fe4acc88da b6568b1a19ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 15 13:27:50 2013 +0900

    Merge tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull module updates from Rusty Russell:
     "Mainly boring here, too.  rmmod --wait finally removed, though"
    
    * tag 'modules-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      modpost: fix bogus 'exported twice' warnings.
      init: fix in-place parameter modification regression
      asmlinkage, module: Make ksymtab and kcrctab symbols and __this_module __visible
      kernel: add support for init_array constructors
      modpost: Optionally ignore secondary errors seen if a single module build fails
      module: remove rmmod --wait option.

commit b5064654c538ad9a2eb1195d80e7593b2e1c1452
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Nov 12 15:08:38 2013 -0800

    scripts/mod/modpost.c: handle non ABS crc symbols
    
    For some reason I managed to trick gcc into create CRC symbols that are
    not absolute anymore, but weak.
    
    Make modpost handle this case.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8247979e8f64..bfcea5d3b27d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -599,18 +599,17 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	else
 		export = export_from_sec(info, get_secindex(info, sym));
 
+	/* CRC'd symbol */
+	if (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
+		crc = (unsigned int) sym->st_value;
+		sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
+				export);
+	}
+
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
 		warn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);
 		break;
-	case SHN_ABS:
-		/* CRC'd symbol */
-		if (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
-			crc = (unsigned int) sym->st_value;
-			sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
-					export);
-		}
-		break;
 	case SHN_UNDEF:
 		/* undefined symbol */
 		if (ELF_ST_BIND(sym->st_info) != STB_GLOBAL &&

commit b6568b1a19ad995221d1816c4fcdd116d9c33e42
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Nov 7 12:09:13 2013 +1030

    modpost: fix bogus 'exported twice' warnings.
    
    Andi's change in e0f244c63fc9 ("asmlinkage, module: Make ksymtab and
    kcrctab symbols and __this_module __visible") make the crc appear
    first in the symbol table.
    
    modpost creates an entry when it sees the CRC, then when it sees the
    actual symbol, it complains that it's seen it before.  The preloaded
    flag already exists for the equivalent case where we loaded from
    Module.symvers, so use that.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Tested-by: The Awesome Power Of linux-next
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 9b873ac6ed7b..5c677a3e7487 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -164,7 +164,7 @@ struct symbol {
 	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
 				    *  (only for external modules) **/
-	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers */
+	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers, or crc */
 	enum export  export;       /* Type of export */
 	char name[0];
 };
@@ -332,8 +332,11 @@ static void sym_update_crc(const char *name, struct module *mod,
 {
 	struct symbol *s = find_symbol(name);
 
-	if (!s)
+	if (!s) {
 		s = new_symbol(name, mod, export);
+		/* Don't complain when we find it later. */
+		s->preloaded = 1;
+	}
 	s->crc = crc;
 	s->crc_valid = 1;
 }

commit e0f244c63fc9d192dfd399cc2677bbdca61994b1
Author: Andi Kleen <ak@linux.intel.com>
Date:   Wed Oct 23 10:57:58 2013 +1030

    asmlinkage, module: Make ksymtab and kcrctab symbols and __this_module __visible
    
    Make the ksymtab symbols for EXPORT_SYMBOL visible.
    This prevents the LTO compiler from adding a .NUMBER prefix,
    which avoids various problems in later export processing.
    
    Cc: rusty@rustcorp.com.au
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 393706b37774..9b873ac6ed7b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1861,7 +1861,7 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "\n");
 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
 	buf_printf(b, "\n");
-	buf_printf(b, "struct module __this_module\n");
+	buf_printf(b, "__visible struct module __this_module\n");
 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
 	buf_printf(b, "\t.name = KBUILD_MODNAME,\n");
 	if (mod->has_init)

commit eed380f3f5933edb8f4c055ba34ae7908ed38565
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Sep 23 15:23:54 2013 +0930

    modpost: Optionally ignore secondary errors seen if a single module build fails
    
    Commit ea4054a23 (modpost: handle huge numbers of modules) added
    support for building a large number of modules.
    
    Unfortunately, the commit changed the semantics of the makefile: Instead of
    passing only existing object files to modpost, make now passes all expected
    object files. If make was started with option -i, this results in a modpost
    error if a single file failed to build.
    
    Example with the current btrfs build falure on m68k:
    
    fs/btrfs/btrfs.o: No such file or directory
    make[1]: [__modpost] Error 1 (ignored)
    
    This error is followed by lots of errors such as:
    
    m68k-linux-gcc: error: arch/m68k/emu/nfcon.mod.c: No such file or directory
    m68k-linux-gcc: fatal error: no input files
    compilation terminated.
    make[1]: [arch/m68k/emu/nfcon.mod.o] Error 1 (ignored)
    
    This doesn't matter much for normal builds, but it is annoying for builds
    started with "make -i" due to the large number of secondary errors.
    Those errors unnececessarily clog any error log and make it difficult
    to find the real errors in the build.
    
    Fix the problem by adding a new parameter '-n' to modpost. If this parameter
    is specified, modpost reports but ignores missing object files.
    
    With this patch, error output from above problem is (with make -i):
    
    m68k-linux-ld: cannot find fs/btrfs/ioctl.o: No such file or directory
    make[2]: [fs/btrfs/btrfs.o] Error 1 (ignored)
    ...
    fs/btrfs/btrfs.o: No such file or directory (ignored)
    
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Michael Marek <mmarek@suse.cz>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8247979e8f64..393706b37774 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -17,6 +17,7 @@
 #include <string.h>
 #include <limits.h>
 #include <stdbool.h>
+#include <errno.h>
 #include "modpost.h"
 #include "../../include/generated/autoconf.h"
 #include "../../include/linux/license.h"
@@ -37,6 +38,8 @@ static int warn_unresolved = 0;
 /* How a symbol is exported */
 static int sec_mismatch_count = 0;
 static int sec_mismatch_verbose = 1;
+/* ignore missing files */
+static int ignore_missing_files;
 
 enum export {
 	export_plain,      export_unused,     export_gpl,
@@ -407,6 +410,11 @@ static int parse_elf(struct elf_info *info, const char *filename)
 
 	hdr = grab_file(filename, &info->size);
 	if (!hdr) {
+		if (ignore_missing_files) {
+			fprintf(stderr, "%s: %s (ignored)\n", filename,
+				strerror(errno));
+			return 0;
+		}
 		perror(filename);
 		exit(1);
 	}
@@ -2119,7 +2127,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:msST:o:awM:K:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awM:K:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2139,6 +2147,9 @@ int main(int argc, char **argv)
 		case 'm':
 			modversions = 1;
 			break;
+		case 'n':
+			ignore_missing_files = 1;
+			break;
 		case 'o':
 			dump_write = optarg;
 			break;

commit 4d10c223baab8be8f717df3625cfece5be26dead
Author: Chen Gang <gang.chen@asianux.com>
Date:   Tue Aug 20 15:33:19 2013 +0930

    scripts/mod/modpost.c: permit '.cranges' secton for sh64 architecture.
    
    Need permit '.cranges' section for sh64 architecture, or modpost will
    report warning:
    
        LD      init/built-in.o
      WARNING: init/built-in.o (.cranges): unexpected non-allocatable section.
      Did you forget to use "ax"/"aw" in a .S file?
      Note that for example <linux/init.h> contains
      section definitions for use in .S files.
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 62164348ecf7..8247979e8f64 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -821,6 +821,7 @@ static const char *section_white_list[] =
 {
 	".comment*",
 	".debug*",
+	".cranges",		/* sh64 */
 	".zdebug*",		/* Compressed debug sections. */
 	".GCC-command-line",	/* mn10300 */
 	".GCC.command.line",	/* record-gcc-switches, non mn10300 */

commit 8dce5f3dee21bf976193ddb06426b9727cf5d1a2
Merge: 21884a83b219 e24f6628811e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 7 11:01:19 2013 -0700

    Merge branch 'cpuinit-delete' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull first stage of __cpuinit removal from Paul Gortmaker:
     "The two commits here 1) dummy out all the __cpuinit macros so that we
      no longer generate such sections, and then 2) remove all the section
      processing that we used to do for those sections.
    
      This makes all the __cpuinit and friends no-ops, so that we can remove
      the use cases of it at our leisure.  Expect stage 2, which does the
      tree wide removal sweep at the end of the merge window."
    
    * 'cpuinit-delete' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      modpost: remove all traces of cpuinit/cpuexit sections
      init.h: remove __cpuinit sections from the kernel

commit e24f6628811e2d4531b443684b598f7050932012
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jun 19 19:30:48 2013 -0400

    modpost: remove all traces of cpuinit/cpuexit sections
    
    Delete all audit rules that were checking how the .cpuXYZ
    related sections were inter-operating with other __init
    like sections, now that __cpuinit is gone.  Update the linker
    script to not have any knowledge of .cpuinit sections.
    
    [lds.h update courtesy of Ralf Baechle <ralf@linux-mips.org>]
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a4be8e112bb6..3acbf0803a9b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -861,24 +861,23 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 
 #define ALL_INIT_DATA_SECTIONS \
-	".init.setup$", ".init.rodata$", \
-	".cpuinit.rodata$", ".meminit.rodata$", \
-	".init.data$", ".cpuinit.data$", ".meminit.data$"
+	".init.setup$", ".init.rodata$", ".meminit.rodata$", \
+	".init.data$", ".meminit.data$"
 #define ALL_EXIT_DATA_SECTIONS \
-	".exit.data$", ".cpuexit.data$", ".memexit.data$"
+	".exit.data$", ".memexit.data$"
 
 #define ALL_INIT_TEXT_SECTIONS \
-	".init.text$", ".cpuinit.text$", ".meminit.text$"
+	".init.text$", ".meminit.text$"
 #define ALL_EXIT_TEXT_SECTIONS \
-	".exit.text$", ".cpuexit.text$", ".memexit.text$"
+	".exit.text$", ".memexit.text$"
 
 #define ALL_PCI_INIT_SECTIONS	\
 	".pci_fixup_early$", ".pci_fixup_header$", ".pci_fixup_final$", \
 	".pci_fixup_enable$", ".pci_fixup_resume$", \
 	".pci_fixup_resume_early$", ".pci_fixup_suspend$"
 
-#define ALL_XXXINIT_SECTIONS CPU_INIT_SECTIONS, MEM_INIT_SECTIONS
-#define ALL_XXXEXIT_SECTIONS CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS
+#define ALL_XXXINIT_SECTIONS MEM_INIT_SECTIONS
+#define ALL_XXXEXIT_SECTIONS MEM_EXIT_SECTIONS
 
 #define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS
 #define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
@@ -887,11 +886,9 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define TEXT_SECTIONS ".text$"
 
 #define INIT_SECTIONS      ".init.*"
-#define CPU_INIT_SECTIONS  ".cpuinit.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"
 
 #define EXIT_SECTIONS      ".exit.*"
-#define CPU_EXIT_SECTIONS  ".cpuexit.*"
 #define MEM_EXIT_SECTIONS  ".memexit.*"
 
 /* init data sections */
@@ -979,48 +976,20 @@ const struct sectioncheck sectioncheck[] = {
 	.mismatch = DATA_TO_ANY_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
-/* Do not reference init code/data from cpuinit/meminit code/data */
+/* Do not reference init code/data from meminit code/data */
 {
 	.fromsec = { ALL_XXXINIT_SECTIONS, NULL },
 	.tosec   = { INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_SOME_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
-/* Do not reference cpuinit code/data from meminit code/data */
-{
-	.fromsec = { MEM_INIT_SECTIONS, NULL },
-	.tosec   = { CPU_INIT_SECTIONS, NULL },
-	.mismatch = XXXINIT_TO_SOME_INIT,
-	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
-},
-/* Do not reference meminit code/data from cpuinit code/data */
-{
-	.fromsec = { CPU_INIT_SECTIONS, NULL },
-	.tosec   = { MEM_INIT_SECTIONS, NULL },
-	.mismatch = XXXINIT_TO_SOME_INIT,
-	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
-},
-/* Do not reference exit code/data from cpuexit/memexit code/data */
+/* Do not reference exit code/data from memexit code/data */
 {
 	.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },
 	.tosec   = { EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_SOME_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
-/* Do not reference cpuexit code/data from memexit code/data */
-{
-	.fromsec = { MEM_EXIT_SECTIONS, NULL },
-	.tosec   = { CPU_EXIT_SECTIONS, NULL },
-	.mismatch = XXXEXIT_TO_SOME_EXIT,
-	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
-},
-/* Do not reference memexit code/data from cpuexit code/data */
-{
-	.fromsec = { CPU_EXIT_SECTIONS, NULL },
-	.tosec   = { MEM_EXIT_SECTIONS, NULL },
-	.mismatch = XXXEXIT_TO_SOME_EXIT,
-	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
-},
 /* Do not use exit code/data from init code */
 {
 	.fromsec = { ALL_INIT_SECTIONS, NULL },
@@ -1089,8 +1058,6 @@ static const struct sectioncheck *section_mismatch(
  * Pattern 2:
  *   Many drivers utilise a *driver container with references to
  *   add, remove, probe functions etc.
- *   These functions may often be marked __cpuinit and we do not want to
- *   warn here.
  *   the pattern is identified by:
  *   tosec   = init or exit section
  *   fromsec = data section
@@ -1249,7 +1216,6 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 /*
  * Convert a section name to the function/data attribute
  * .init.text => __init
- * .cpuinit.data => __cpudata
  * .memexitconst => __memconst
  * etc.
  *

commit 06df44ee41442d83be061c5fd1b1de4f5fc6fbbf
Author: Tom Rini <trini@ti.com>
Date:   Mon May 20 10:25:38 2013 +0930

    modpost.c: Add .text.unlikely to TEXT_SECTIONS
    
    gcc's places cold functions into the .text.unlikely section and we
    need to check this section as well for section mismatches otherwise we
    may have false negatives for this test.
    
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-kbuild@vger.kernel.org
    Signed-off-by: Tom Rini <trini@ti.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> (wording update)

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a4be8e112bb6..3d155dd27eb6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -884,7 +884,7 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
 
 #define DATA_SECTIONS ".data$", ".data.rel$"
-#define TEXT_SECTIONS ".text$"
+#define TEXT_SECTIONS ".text$", ".text.unlikely$"
 
 #define INIT_SECTIONS      ".init.*"
 #define CPU_INIT_SECTIONS  ".cpuinit.*"

commit a53a11f35762ff1d5e268adedf2ab9ce313f871d
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Apr 29 11:36:59 2013 +0930

    modpost: fix unwanted VMLINUX_SYMBOL_STR expansion
    
    Commit a4b6a77b77ba4f526392612c2365797fab956014 ("module: fix symbol
    versioning with symbol prefixes") broke the MODVERSIONS loading of any
    module using memcmp (e.g. ipv6) on x86_32, as it's defined to
    __builtin_memcmp which is expanded by VMLINUX_SYMBOL_STR. Use
    __VMLINUX_SYMBOL_STR instead which doesn't expand the argument.
    
    Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Tested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Tested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: <stable@vger.kernel.org> # 3.9

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1f90961ada77..a4be8e112bb6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1957,7 +1957,7 @@ static int add_versions(struct buffer *b, struct module *mod)
 				s->name, mod->name);
 			continue;
 		}
-		buf_printf(b, "\t{ %#8x, VMLINUX_SYMBOL_STR(%s) },\n",
+		buf_printf(b, "\t{ %#8x, __VMLINUX_SYMBOL_STR(%s) },\n",
 			   s->crc, s->name);
 	}
 

commit 712f9b46843d941347e86dcd2e1d63f9d3b112cb
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Apr 4 17:37:38 2013 +1030

    modpost: add -T option to read module names from file/stdin.
    
    Because there are too many modules in the world.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f7a0392ad1ca..1f90961ada77 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -15,6 +15,7 @@
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
+#include <limits.h>
 #include <stdbool.h>
 #include "modpost.h"
 #include "../../include/generated/autoconf.h"
@@ -1763,6 +1764,27 @@ static void read_symbols(char *modname)
 		mod->unres = alloc_symbol("module_layout", 0, mod->unres);
 }
 
+static void read_symbols_from_files(const char *filename)
+{
+	FILE *in = stdin;
+	char fname[PATH_MAX];
+
+	if (strcmp(filename, "-") != 0) {
+		in = fopen(filename, "r");
+		if (!in)
+			fatal("Can't open filenames file %s: %m", filename);
+	}
+
+	while (fgets(fname, PATH_MAX, in) != NULL) {
+		if (strends(fname, "\n"))
+			fname[strlen(fname)-1] = '\0';
+		read_symbols(fname);
+	}
+
+	if (in != stdin)
+		fclose(in);
+}
+
 #define SZ 500
 
 /* We first write the generated file into memory using the
@@ -2124,13 +2146,13 @@ int main(int argc, char **argv)
 	struct module *mod;
 	struct buffer buf = { };
 	char *kernel_read = NULL, *module_read = NULL;
-	char *dump_write = NULL;
+	char *dump_write = NULL, *files_source = NULL;
 	int opt;
 	int err;
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:msSo:awM:K:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:msST:o:awM:K:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2162,6 +2184,9 @@ int main(int argc, char **argv)
 		case 'S':
 			sec_mismatch_verbose = 0;
 			break;
+		case 'T':
+			files_source = optarg;
+			break;
 		case 'w':
 			warn_unresolved = 1;
 			break;
@@ -2184,6 +2209,9 @@ int main(int argc, char **argv)
 	while (optind < argc)
 		read_symbols(argv[optind++]);
 
+	if (files_source)
+		read_symbols_from_files(files_source);
+
 	for (mod = modules; mod; mod = mod->next) {
 		if (mod->skip)
 			continue;

commit d4ef1c30e89ce8e7f1030501d74b6b812c3c179d
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Apr 4 17:37:32 2013 +1030

    modpost: minor cleanup.
    
    We want a strends() function next, so make one and use it appropriately,
    making new_module() arg const while we're at it.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f6913db77627..f7a0392ad1ca 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -15,6 +15,7 @@
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
+#include <stdbool.h>
 #include "modpost.h"
 #include "../../include/generated/autoconf.h"
 #include "../../include/linux/license.h"
@@ -78,6 +79,14 @@ PRINTF void merror(const char *fmt, ...)
 	va_end(arglist);
 }
 
+static inline bool strends(const char *str, const char *postfix)
+{
+	if (strlen(str) < strlen(postfix))
+		return false;
+
+	return strcmp(str + strlen(str) - strlen(postfix), postfix) == 0;
+}
+
 static int is_vmlinux(const char *modname)
 {
 	const char *myname;
@@ -113,22 +122,20 @@ static struct module *find_module(char *modname)
 	return mod;
 }
 
-static struct module *new_module(char *modname)
+static struct module *new_module(const char *modname)
 {
 	struct module *mod;
-	char *p, *s;
+	char *p;
 
 	mod = NOFAIL(malloc(sizeof(*mod)));
 	memset(mod, 0, sizeof(*mod));
 	p = NOFAIL(strdup(modname));
 
 	/* strip trailing .o */
-	s = strrchr(p, '.');
-	if (s != NULL)
-		if (strcmp(s, ".o") == 0) {
-			*s = '\0';
-			mod->is_dot_o = 1;
-		}
+	if (strends(p, ".o")) {
+		p[strlen(p) - 2] = '\0';
+		mod->is_dot_o = 1;
+	}
 
 	/* add to list */
 	mod->name = p;

commit a4b6a77b77ba4f526392612c2365797fab956014
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Mar 18 19:38:56 2013 +1030

    module: fix symbol versioning with symbol prefixes
    
    Fix symbol versioning on architectures with symbol prefixes. Although
    the build was free from warnings the actual modules still wouldn't load
    as the ____versions table contained unprefixed symbol names, which were
    being compared against the prefixed symbol names when checking the
    symbol versions.
    
    This is fixed by modifying modpost to add the symbol prefix to the
    ____versions table it outputs (Modules.symvers still contains unprefixed
    symbol names). The check_modstruct_version() function is also fixed as
    it checks the version of the unprefixed "module_layout" symbol which
    would no longer work.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jonathan Kliegman <kliegs@chromium.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> (use VMLINUX_SYMBOL_STR)

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 282decfa29ae..f6913db77627 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1928,7 +1928,8 @@ static int add_versions(struct buffer *b, struct module *mod)
 				s->name, mod->name);
 			continue;
 		}
-		buf_printf(b, "\t{ %#8x, \"%s\" },\n", s->crc, s->name);
+		buf_printf(b, "\t{ %#8x, VMLINUX_SYMBOL_STR(%s) },\n",
+			   s->crc, s->name);
 	}
 
 	buf_printf(b, "};\n");

commit b92021b09df70c1609e3547f3d6128dd560be97f
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Mar 15 15:04:17 2013 +1030

    CONFIG_SYMBOL_PREFIX: cleanup.
    
    We have CONFIG_SYMBOL_PREFIX, which three archs define to the string
    "_".  But Al Viro broke this in "consolidate cond_syscall and
    SYSCALL_ALIAS declarations" (in linux-next), and he's not the first to
    do so.
    
    Using CONFIG_SYMBOL_PREFIX is awkward, since we usually just want to
    prefix it so something.  So various places define helpers which are
    defined to nothing if CONFIG_SYMBOL_PREFIX isn't set:
    
    1) include/asm-generic/unistd.h defines __SYMBOL_PREFIX.
    2) include/asm-generic/vmlinux.lds.h defines VMLINUX_SYMBOL(sym)
    3) include/linux/export.h defines MODULE_SYMBOL_PREFIX.
    4) include/linux/kernel.h defines SYMBOL_PREFIX (which differs from #7)
    5) kernel/modsign_certificate.S defines ASM_SYMBOL(sym)
    6) scripts/modpost.c defines MODULE_SYMBOL_PREFIX
    7) scripts/Makefile.lib defines SYMBOL_PREFIX on the commandline if
       CONFIG_SYMBOL_PREFIX is set, so that we have a non-string version
       for pasting.
    
    (arch/h8300/include/asm/linkage.h defines SYMBOL_NAME(), too).
    
    Let's solve this properly:
    1) No more generic prefix, just CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX.
    2) Make linux/export.h usable from asm.
    3) Define VMLINUX_SYMBOL() and VMLINUX_SYMBOL_STR().
    4) Make everyone use them.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Tested-by: James Hogan <james.hogan@imgtec.com> (metag)

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 78b30c1548e9..282decfa29ae 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -18,14 +18,7 @@
 #include "modpost.h"
 #include "../../include/generated/autoconf.h"
 #include "../../include/linux/license.h"
-
-/* Some toolchains use a `_' prefix for all user symbols. */
-#ifdef CONFIG_SYMBOL_PREFIX
-#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
-#else
-#define MODULE_SYMBOL_PREFIX ""
-#endif
-
+#include "../../include/linux/export.h"
 
 /* Are we using CONFIG_MODVERSIONS? */
 int modversions = 0;
@@ -562,7 +555,7 @@ static void parse_elf_finish(struct elf_info *info)
 static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 {
 	/* ignore __this_module, it will be resolved shortly */
-	if (strcmp(symname, MODULE_SYMBOL_PREFIX "__this_module") == 0)
+	if (strcmp(symname, VMLINUX_SYMBOL_STR(__this_module)) == 0)
 		return 1;
 	/* ignore global offset table */
 	if (strcmp(symname, "_GLOBAL_OFFSET_TABLE_") == 0)
@@ -583,8 +576,8 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 	return 0;
 }
 
-#define CRC_PFX     MODULE_SYMBOL_PREFIX "__crc_"
-#define KSYMTAB_PFX MODULE_SYMBOL_PREFIX "__ksymtab_"
+#define CRC_PFX     VMLINUX_SYMBOL_STR(__crc_)
+#define KSYMTAB_PFX VMLINUX_SYMBOL_STR(__ksymtab_)
 
 static void handle_modversions(struct module *mod, struct elf_info *info,
 			       Elf_Sym *sym, const char *symname)
@@ -637,14 +630,15 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		}
 #endif
 
-		if (memcmp(symname, MODULE_SYMBOL_PREFIX,
-			   strlen(MODULE_SYMBOL_PREFIX)) == 0) {
-			mod->unres =
-			  alloc_symbol(symname +
-			               strlen(MODULE_SYMBOL_PREFIX),
-			               ELF_ST_BIND(sym->st_info) == STB_WEAK,
-			               mod->unres);
-		}
+#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX
+		if (symname[0] != '_')
+			break;
+		else
+			symname++;
+#endif
+		mod->unres = alloc_symbol(symname,
+					  ELF_ST_BIND(sym->st_info) == STB_WEAK,
+					  mod->unres);
 		break;
 	default:
 		/* All exported symbols */
@@ -652,9 +646,9 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod,
 					export);
 		}
-		if (strcmp(symname, MODULE_SYMBOL_PREFIX "init_module") == 0)
+		if (strcmp(symname, VMLINUX_SYMBOL_STR(init_module)) == 0)
 			mod->has_init = 1;
-		if (strcmp(symname, MODULE_SYMBOL_PREFIX "cleanup_module") == 0)
+		if (strcmp(symname, VMLINUX_SYMBOL_STR(cleanup_module)) == 0)
 			mod->has_cleanup = 1;
 		break;
 	}

commit 0ca7ffb356063c5ece847687da457dfe748612a2
Merge: 30acd906b024 423a8155facf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 27 12:25:47 2013 -0800

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild changes from Michal Marek:
    
     - Alias generation in modpost is cross-compile safe.
    
     - kernel/timeconst.h is now generated using a bc script instead of
       perl.
    
     - scripts/link-vmlinux.sh now works with an alternative
       $KCONFIG_CONFIG.
    
     - destination-y for exported headers is supported in Kbuild files
       again.
    
     - depmod is called with -P $CONFIG_SYMBOL_PREFIX on architectures that
       need it.
    
     - CONFIG_DEBUG_INFO_REDUCED disables var-tracking
    
     - scripts/setlocalversion works with too much translated locales ;)
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      kbuild: Fix reading of .config in link-vmlinux.sh
      kbuild: Unset language specific variables in setlocalversion script
      Kbuild: Disable var tracking with CONFIG_DEBUG_INFO_REDUCED
      depmod: pass -P $CONFIG_SYMBOL_PREFIX
      kbuild: Fix destination-y for installed headers
      scripts/link-vmlinux.sh: source variables from KCONFIG_CONFIG
      kernel: Replace timeconst.pl with a bc script
      mod/file2alias: make modalias generation safe for cross compiling

commit 6543becf26fff612cdadeed7250ccc8d49f67f27
Author: Andreas Schwab <schwab@linux-m68k.org>
Date:   Sun Jan 20 17:58:47 2013 +0100

    mod/file2alias: make modalias generation safe for cross compiling
    
    Use the target compiler to compute the offsets for the fields of the
    device_id structures, so that it won't be broken by different alignments
    between the host and target ABIs.
    
    This also fixes missing endian corrections for some modaliases.
    
    Signed-off-by: Andreas Schwab <schwab@linux-m68k.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ff36c508a10e..11a8c3010ed9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2126,7 +2126,7 @@ int main(int argc, char **argv)
 	struct ext_sym_list *extsym_iter;
 	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:e:cmsSo:awM:K:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:msSo:awM:K:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2135,9 +2135,6 @@ int main(int argc, char **argv)
 			module_read = optarg;
 			external_module = 1;
 			break;
-		case 'c':
-			cross_build = 1;
-			break;
 		case 'e':
 			external_module = 1;
 			extsym_iter =

commit f2e207f32422c7b9624d3393db015dfd118d9d22
Author: Vineet Gupta <Vineet.Gupta1@synopsys.com>
Date:   Mon Jan 21 17:18:57 2013 +1030

    modpost: Ignore ARC specific non-alloc sections
    
    ARC relocatable object files contain one/more .gnu.linkonce.arcextmap.*
    sections (collated by kernel/vmlinux.lds into .arcextmap in final link).
    This section is used by debuggers to display the extension instructions
    and need-not be loaded by target (hence !SHF_ALLOC)
    
    The final kernel binary only needs .arcextmap entry in modpost's ignore
    list (section_white_list[]). However when building modules, modpost scans
    each object file individually, hence tripping on non-aggregated
    .gnu.linkonce.arcextmap.* entries as well.
    
    Thus need for the 2 entires !
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ff36c508a10e..1c6fbb1a4f8e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -830,6 +830,8 @@ static const char *section_white_list[] =
 	".toc*",
 	".xt.prop",				 /* xtensa */
 	".xt.lit",         /* xtensa */
+	".arcextmap*",			/* arc */
+	".gnu.linkonce.arcext*",	/* arc : modules */
 	NULL
 };
 

commit 92e9e6d1f9844b73a26215025a922e7d7aeae361
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Nov 29 10:45:02 2012 -0800

    modpost.c: Stop checking __dev* section mismatches
    
    Now that the __dev* sections are not being generated, we don't need to
    check for them in modpost.c.
    
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0d93856a03f4..ff36c508a10e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -858,25 +858,23 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 #define ALL_INIT_DATA_SECTIONS \
 	".init.setup$", ".init.rodata$", \
-	".devinit.rodata$", ".cpuinit.rodata$", ".meminit.rodata$", \
-	".init.data$", ".devinit.data$", ".cpuinit.data$", ".meminit.data$"
+	".cpuinit.rodata$", ".meminit.rodata$", \
+	".init.data$", ".cpuinit.data$", ".meminit.data$"
 #define ALL_EXIT_DATA_SECTIONS \
-	".exit.data$", ".devexit.data$", ".cpuexit.data$", ".memexit.data$"
+	".exit.data$", ".cpuexit.data$", ".memexit.data$"
 
 #define ALL_INIT_TEXT_SECTIONS \
-	".init.text$", ".devinit.text$", ".cpuinit.text$", ".meminit.text$"
+	".init.text$", ".cpuinit.text$", ".meminit.text$"
 #define ALL_EXIT_TEXT_SECTIONS \
-	".exit.text$", ".devexit.text$", ".cpuexit.text$", ".memexit.text$"
+	".exit.text$", ".cpuexit.text$", ".memexit.text$"
 
 #define ALL_PCI_INIT_SECTIONS	\
 	".pci_fixup_early$", ".pci_fixup_header$", ".pci_fixup_final$", \
 	".pci_fixup_enable$", ".pci_fixup_resume$", \
 	".pci_fixup_resume_early$", ".pci_fixup_suspend$"
 
-#define ALL_XXXINIT_SECTIONS DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, \
-	MEM_INIT_SECTIONS
-#define ALL_XXXEXIT_SECTIONS DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, \
-	MEM_EXIT_SECTIONS
+#define ALL_XXXINIT_SECTIONS CPU_INIT_SECTIONS, MEM_INIT_SECTIONS
+#define ALL_XXXEXIT_SECTIONS CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS
 
 #define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS
 #define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
@@ -885,12 +883,10 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define TEXT_SECTIONS ".text$"
 
 #define INIT_SECTIONS      ".init.*"
-#define DEV_INIT_SECTIONS  ".devinit.*"
 #define CPU_INIT_SECTIONS  ".cpuinit.*"
 #define MEM_INIT_SECTIONS  ".meminit.*"
 
 #define EXIT_SECTIONS      ".exit.*"
-#define DEV_EXIT_SECTIONS  ".devexit.*"
 #define CPU_EXIT_SECTIONS  ".cpuexit.*"
 #define MEM_EXIT_SECTIONS  ".memexit.*"
 
@@ -979,7 +975,7 @@ const struct sectioncheck sectioncheck[] = {
 	.mismatch = DATA_TO_ANY_EXIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
-/* Do not reference init code/data from devinit/cpuinit/meminit code/data */
+/* Do not reference init code/data from cpuinit/meminit code/data */
 {
 	.fromsec = { ALL_XXXINIT_SECTIONS, NULL },
 	.tosec   = { INIT_SECTIONS, NULL },
@@ -1000,7 +996,7 @@ const struct sectioncheck sectioncheck[] = {
 	.mismatch = XXXINIT_TO_SOME_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
-/* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
+/* Do not reference exit code/data from cpuexit/memexit code/data */
 {
 	.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },
 	.tosec   = { EXIT_SECTIONS, NULL },
@@ -1089,7 +1085,7 @@ static const struct sectioncheck *section_mismatch(
  * Pattern 2:
  *   Many drivers utilise a *driver container with references to
  *   add, remove, probe functions etc.
- *   These functions may often be marked __devinit and we do not want to
+ *   These functions may often be marked __cpuinit and we do not want to
  *   warn here.
  *   the pattern is identified by:
  *   tosec   = init or exit section

commit ae3e4628287de0ab90545c14076657aeee38506b
Merge: 5f76945a9c97 415c2c525fab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 12 10:27:27 2012 +0900

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild changes from Michal Marek:
     "The main part of kbuild for v3.7 contains:
       - Fix for scripts/Makefile.modpost to not choke on a '.ko' substring
         in the build directory path
       - Two warning fixes (modpost and main Makefile)
       - __compiletime_error works also with gcc 4.3
       - make tar{gz,bz2,xz}-pkg uses default compression settings instead
         of saving as many bytes as possible (this should actually be in the
         misc branch, I don't know why I applied it here)."
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      compiler-gcc4.h: correct verion check for __compiletime_error
      modpost: Permit .GCC.command.line sections
      Kbuild: use normal compression settings for tar*-pkg
      scripts/Makefile.modpost: error in finding modules from .mod files.
      kbuild: Remove useless warning while appending KCFLAGS

commit 76b27645a5bba85bd26896811c7a25ecc37b3731
Author: Jonathan Kliegman <kliegs@chromium.org>
Date:   Thu Oct 4 16:32:19 2012 -0400

    modpost: Permit .GCC.command.line sections
    
    Allow .GCC.command.line sections in modules to prevent modpost warnings:
    WARNING: sound/usb/snd-usbmidi-lib.o (.GCC.command.line): unexpected non-allocatable section.
    Did you forget to use "ax"/"aw" in a .S file?
    Note that for example <linux/init.h> contains
    section definitions for use in .S files.
    
    Signed-off-by: Jonathan Kliegman <kliegs@chromium.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 68e9f5ed0a6f..cd5803c647fd 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -821,6 +821,7 @@ static const char *section_white_list[] =
 	".debug*",
 	".zdebug*",		/* Compressed debug sections. */
 	".GCC-command-line",	/* mn10300 */
+	".GCC.command.line",	/* record-gcc-switches, non mn10300 */
 	".mdebug*",        /* alpha, score, mips etc. */
 	".pdr",            /* alpha, score, mips etc. */
 	".stab*",

commit af42e970b6097a34cb2b93ec4c12c2a226b1d008
Author: Max Filippov <jcmvbkbc@gmail.com>
Date:   Mon Sep 17 05:44:38 2012 +0400

    modpost: fix modpost warnings for xtensa
    
    Suppress warnings for two informational sections (.xt.lit and .xt.prop)
    used by the Xtensa architecture.
    
    Signed-off-by: Max Filippov <jcmvbkbc@gmail.com>
    Signed-off-by: Chris Zankel <chris@zankel.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 68e9f5ed0a6f..00f7512a217f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -827,6 +827,8 @@ static const char *section_white_list[] =
 	".note*",
 	".got*",
 	".toc*",
+	".xt.prop",				 /* xtensa */
+	".xt.lit",         /* xtensa */
 	NULL
 };
 

commit bb15d8db7cce766b62cab624120916d25e94ac7a
Author: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date:   Sun Jun 3 20:48:17 2012 +0200

    scripts/modpost: check for bad references in .pci.fixups area
    
    Functions used for PCI fixups (like DECLARE_PCI_FIXUP_HEADER) are often
    marked __init. This is okay as long as nobody is using PCI hotplug.
    However if one does execute
    | echo 1 > /sys/bus/pci/rescan
    
    and we hit a module which is marked __init istead of __devinit then we
    go boom because the code is removed after the kernel booted. This patch
    help to see those section mismatches.
    
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: linux-kbuild@vger.kernel.org
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0f84bb38eb0d..68e9f5ed0a6f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -865,6 +865,11 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define ALL_EXIT_TEXT_SECTIONS \
 	".exit.text$", ".devexit.text$", ".cpuexit.text$", ".memexit.text$"
 
+#define ALL_PCI_INIT_SECTIONS	\
+	".pci_fixup_early$", ".pci_fixup_header$", ".pci_fixup_final$", \
+	".pci_fixup_enable$", ".pci_fixup_resume$", \
+	".pci_fixup_resume_early$", ".pci_fixup_suspend$"
+
 #define ALL_XXXINIT_SECTIONS DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, \
 	MEM_INIT_SECTIONS
 #define ALL_XXXEXIT_SECTIONS DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, \
@@ -1027,6 +1032,12 @@ const struct sectioncheck sectioncheck[] = {
 	.mismatch = ANY_EXIT_TO_ANY_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
+{
+	.fromsec = { ALL_PCI_INIT_SECTIONS, NULL },
+	.tosec   = { INIT_SECTIONS, NULL },
+	.mismatch = ANY_INIT_TO_ANY_EXIT,
+	.symbol_white_list = { NULL },
+},
 /* Do not export init/exit functions or data */
 {
 	.fromsec = { "__ksymtab*", NULL },

commit 3c7ec94d2c4a67d9663a080aa5080134308261c4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 11:10:15 2012 -0700

    modpost: use proper kernel style for autogenerated files
    
    If the kernel build process is creating files automatically, the least
    it can do is create them in a properly formatted manner.  Sure, it's a
    minor issue, but being consistent is nice.
    
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alessio Igor Bogani <abogani@kernel.org>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ea0eaca597b9..0f84bb38eb0d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1853,14 +1853,14 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "\n");
 	buf_printf(b, "struct module __this_module\n");
 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
-	buf_printf(b, " .name = KBUILD_MODNAME,\n");
+	buf_printf(b, "\t.name = KBUILD_MODNAME,\n");
 	if (mod->has_init)
-		buf_printf(b, " .init = init_module,\n");
+		buf_printf(b, "\t.init = init_module,\n");
 	if (mod->has_cleanup)
 		buf_printf(b, "#ifdef CONFIG_MODULE_UNLOAD\n"
-			      " .exit = cleanup_module,\n"
+			      "\t.exit = cleanup_module,\n"
 			      "#endif\n");
-	buf_printf(b, " .arch = MODULE_ARCH_INIT,\n");
+	buf_printf(b, "\t.arch = MODULE_ARCH_INIT,\n");
 	buf_printf(b, "};\n");
 }
 

commit eb3d5cc67a525df5115c1dc1c0ff8a111bda70e4
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Wed May 23 22:28:49 2012 +0930

    modpost: Stop grab_file() from leaking filedescriptors if fstat() fails
    
    In case the open() call succeeds but the subsequent fstat() call
    fails, then we'll return without close()'ing the filedescriptor.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c4e7d1510f9d..ea0eaca597b9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -337,17 +337,20 @@ static void sym_update_crc(const char *name, struct module *mod,
 void *grab_file(const char *filename, unsigned long *size)
 {
 	struct stat st;
-	void *map;
+	void *map = MAP_FAILED;
 	int fd;
 
 	fd = open(filename, O_RDONLY);
-	if (fd < 0 || fstat(fd, &st) != 0)
+	if (fd < 0)
 		return NULL;
+	if (fstat(fd, &st))
+		goto failed;
 
 	*size = st.st_size;
 	map = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
-	close(fd);
 
+failed:
+	close(fd);
 	if (map == MAP_FAILED)
 		return NULL;
 	return map;

commit 258f742635360175564e9470eb060ff4d4b984e7
Author: Frank Rowand <frank.rowand@am.sony.com>
Date:   Mon Apr 9 17:59:03 2012 -0700

    modpost: Fix modpost license checking of vmlinux.o
    
    Commit f02e8a6596b7 ("module: Sort exported symbols") sorts symbols
    placing each of them in its own elf section.  This sorting and merging
    into the canonical sections are done by the linker.
    
    Unfortunately modpost to generate Module.symvers file parses vmlinux.o
    (which is not linked yet) and all modules object files (which aren't
    linked yet).  These aren't sanitized by the linker yet.  That breaks
    modpost that can't detect license properly for modules.
    
    This patch makes modpost aware of the new exported symbols structure.
    
    [ This above is a slightly corrected version of the explanation of the
      problem, copied from commit 62a2635610db ("modpost: Fix modpost's
      license checking V3").  That commit fixed the problem for module
      object files, but not for vmlinux.o.  This patch fixes modpost for
      vmlinux.o. ]
    
    Signed-off-by: Frank Rowand <frank.rowand@am.sony.com>
    Signed-off-by: Alessio Igor Bogani <abogani@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3f01fd908730..c4e7d1510f9d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -132,8 +132,10 @@ static struct module *new_module(char *modname)
 	/* strip trailing .o */
 	s = strrchr(p, '.');
 	if (s != NULL)
-		if (strcmp(s, ".o") == 0)
+		if (strcmp(s, ".o") == 0) {
 			*s = '\0';
+			mod->is_dot_o = 1;
+		}
 
 	/* add to list */
 	mod->name = p;
@@ -587,7 +589,8 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	unsigned int crc;
 	enum export export;
 
-	if (!is_vmlinux(mod->name) && strncmp(symname, "__ksymtab", 9) == 0)
+	if ((!is_vmlinux(mod->name) || mod->is_dot_o) &&
+	    strncmp(symname, "__ksymtab", 9) == 0)
 		export = export_from_secname(info, get_secindex(info, sym));
 	else
 		export = export_from_sec(info, get_secindex(info, sym));

commit 923f79743c76583ed4684e2c80c8da51a7268af3
Merge: a7697b945e6e 7f3bd6c9cb8e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 30 18:15:43 2012 -0700

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild
    
    Pull kbuild changes from Michal Marek:
     - Unification of cmd_uimage among archs that use it
     - make headers_check tries harder before reporting a missing
       <linux/types.h> include
     - kbuild portability fix for shells that do not support echo -e
     - make clean descends into samples/
     - setlocalversion grep fix
     - modpost typo fix
     - dtc warnings fix
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild:
      setlocalversion: Use "grep -q" instead of piping output to "read dummy"
      modpost: fix ALL_INIT_DATA_SECTIONS
      Kbuild: centralize MKIMAGE and cmd_uimage definitions
      headers_check: recursively search for linux/types.h inclusion
      scripts/Kbuild.include: Fix portability problem of "echo -e"
      scripts: dtc: fix compile warnings
      kbuild: clean up samples directory
      kbuild: disable -Wmissing-field-initializers for W=1

commit 9aaf440f8fabcebf9ea79a62ccf4c212e6544b49
Author: Jan Beulich <JBeulich@suse.com>
Date:   Thu Mar 8 09:41:25 2012 +0000

    modpost: fix ALL_INIT_DATA_SECTIONS
    
    This was lacking a comma between two supposed to be separate strings.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2bd594e6d1b4..159b4cc084fd 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -849,7 +849,7 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 #define ALL_INIT_DATA_SECTIONS \
 	".init.setup$", ".init.rodata$", \
-	".devinit.rodata$", ".cpuinit.rodata$", ".meminit.rodata$" \
+	".devinit.rodata$", ".cpuinit.rodata$", ".meminit.rodata$", \
 	".init.data$", ".devinit.data$", ".cpuinit.data$", ".meminit.data$"
 #define ALL_EXIT_DATA_SECTIONS \
 	".exit.data$", ".devexit.data$", ".cpuexit.data$", ".memexit.data$"

commit 6e2e340b59d2d4e7b6b7f2c2d02b0d5ca4df6458
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Feb 14 21:58:56 2012 +0100

    ARM: 7324/1: modpost: Fix section warnings for ARM for many compilers
    
    It turns out that many compilers don't show section warnings on ARM
    currently because handling for ARM_CALL relocs are missing from
    modpost.c.
    
    Based on commit c2e26114 ([ARM] 3205/1: Handle new EABI relocations when
    loading kernel modules) it seems that R_ARM_PC24, R_ARM_CALL and
    R_ARM_JUMP24 can be handled the same way.
    
    Note that at least Debian libc6-dev is missing defines for both
    R_ARM_CALL and R_ARM_JUMP24 in /usr/include/elf.h. So for now
    we need to define them in modpost.c if not defined.
    
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ben Hutchings <ben@decadent.org.uk>
    Cc: Anders Kaseorg <andersk@ksplice.com>
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2bd594e6d1b4..9adb667dd31a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1494,6 +1494,13 @@ static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 	return 0;
 }
 
+#ifndef R_ARM_CALL
+#define R_ARM_CALL	28
+#endif
+#ifndef R_ARM_JUMP24
+#define R_ARM_JUMP24	29
+#endif
+
 static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	unsigned int r_typ = ELF_R_TYPE(r->r_info);
@@ -1505,6 +1512,8 @@ static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 		              (elf->symtab_start + ELF_R_SYM(r->r_info));
 		break;
 	case R_ARM_PC24:
+	case R_ARM_CALL:
+	case R_ARM_JUMP24:
 		/* From ARM ABI: ((S + A) | T) - P */
 		r->r_addend = (int)(long)(elf->hdr +
 		              sechdr->sh_offset +

commit 2449b8ba0745327c5fa49a8d9acffe03b2eded69
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Mon Oct 24 15:12:28 2011 +0200

    module,bug: Add TAINT_OOT_MODULE flag for modules not built in-tree
    
    Use of the GPL or a compatible licence doesn't necessarily make the code
    any good.  We already consider staging modules to be suspect, and this
    should also be true for out-of-tree modules which may receive very
    little review.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Reviewed-by: Dave Jones <davej@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au> (patched oops-tracing.txt)

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a509ff8f32fa..2bd594e6d1b4 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1849,6 +1849,12 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "};\n");
 }
 
+static void add_intree_flag(struct buffer *b, int is_intree)
+{
+	if (is_intree)
+		buf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");
+}
+
 static void add_staging_flag(struct buffer *b, const char *name)
 {
 	static const char *staging_dir = "drivers/staging";
@@ -2169,6 +2175,7 @@ int main(int argc, char **argv)
 		buf.pos = 0;
 
 		add_header(&buf, mod);
+		add_intree_flag(&buf, !external_module);
 		add_staging_flag(&buf, mod->name);
 		err |= add_versions(&buf, mod);
 		add_depends(&buf, mod, modules);

commit 62a2635610dbc83c5e8d724e00941eee4d18c186
Author: Alessio Igor Bogani <abogani@kernel.org>
Date:   Thu Jul 14 08:51:16 2011 +0200

    modpost: Fix modpost's license checking V3
    
    The commit f02e8a6 sorts symbols placing each of them in its own elf section.
    The sorting and merging into the canonical sections are done by the linker.
    Unfortunately modpost to generate Module.symvers file parses vmlinux
    (already linked) and all modules object files (which aren't linked yet).
    These aren't sanitized by the linker yet. That breaks modpost that can't
    detect license properly for modules. This patch makes modpost aware of
    the new exported symbols structure.
    
    Thanks to Arnaud Lacombe <lacombar@gmail.com> and Anders Kaseorg
    <andersk@ksplice.com> for providing useful suggestions about code.
    
    This work was supported by a hardware donation from the CE Linux Forum.
    
    Reported-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Alessio Igor Bogani <abogani@kernel.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 413c53693e62..a509ff8f32fa 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -254,6 +254,28 @@ static enum export export_no(const char *s)
 	return export_unknown;
 }
 
+static const char *sec_name(struct elf_info *elf, int secindex);
+
+#define strstarts(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)
+
+static enum export export_from_secname(struct elf_info *elf, unsigned int sec)
+{
+	const char *secname = sec_name(elf, sec);
+
+	if (strstarts(secname, "___ksymtab+"))
+		return export_plain;
+	else if (strstarts(secname, "___ksymtab_unused+"))
+		return export_unused;
+	else if (strstarts(secname, "___ksymtab_gpl+"))
+		return export_gpl;
+	else if (strstarts(secname, "___ksymtab_unused_gpl+"))
+		return export_unused_gpl;
+	else if (strstarts(secname, "___ksymtab_gpl_future+"))
+		return export_gpl_future;
+	else
+		return export_unknown;
+}
+
 static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 {
 	if (sec == elf->export_sec)
@@ -563,7 +585,12 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			       Elf_Sym *sym, const char *symname)
 {
 	unsigned int crc;
-	enum export export = export_from_sec(info, get_secindex(info, sym));
+	enum export export;
+
+	if (!is_vmlinux(mod->name) && strncmp(symname, "__ksymtab", 9) == 0)
+		export = export_from_secname(info, get_secindex(info, sym));
+	else
+		export = export_from_sec(info, get_secindex(info, sym));
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:

commit 6845756b29e4c4e7db41e2d75cafa9d091bc1c07
Author: Anders Kaseorg <andersk@ksplice.com>
Date:   Thu May 19 16:55:27 2011 -0600

    modpost: Update 64k section support for binutils 2.18.50
    
    Binutils 2.18.50 made a backwards-incompatible change in the way it
    writes ELF objects with over 65280 sections, to improve conformance
    with the ELF specification and interoperability with other ELF tools.
    Specifically, it no longer adds 256 to section indices SHN_LORESERVE
    and higher to skip over the reserved range SHN_LORESERVE through
    SHN_HIRESERVE; those values are only considered special in the
    st_shndx field, and not in other places where section indices are
    stored.  See:
    
    http://sourceware.org/bugzilla/show_bug.cgi?id=5900
    http://groups.google.com/group/generic-abi/browse_thread/thread/e8bb63714b072e67/6c63738f12cc8a17
    
    Signed-off-by: Anders Kaseorg <andersk@ksplice.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index cd104afcc5f2..413c53693e62 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -420,11 +420,10 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		return 0;
 	}
 
-	if (hdr->e_shnum == 0) {
+	if (hdr->e_shnum == SHN_UNDEF) {
 		/*
 		 * There are more than 64k sections,
 		 * read count from .sh_size.
-		 * note: it doesn't need shndx2secindex()
 		 */
 		info->num_sections = TO_NATIVE(sechdrs[0].sh_size);
 	}
@@ -432,8 +431,7 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		info->num_sections = hdr->e_shnum;
 	}
 	if (hdr->e_shstrndx == SHN_XINDEX) {
-		info->secindex_strings =
-		    shndx2secindex(TO_NATIVE(sechdrs[0].sh_link));
+		info->secindex_strings = TO_NATIVE(sechdrs[0].sh_link);
 	}
 	else {
 		info->secindex_strings = hdr->e_shstrndx;
@@ -489,7 +487,7 @@ static int parse_elf(struct elf_info *info, const char *filename)
 			    sechdrs[i].sh_offset;
 			info->symtab_stop  = (void *)hdr +
 			    sechdrs[i].sh_offset + sechdrs[i].sh_size;
-			sh_link_idx = shndx2secindex(sechdrs[i].sh_link);
+			sh_link_idx = sechdrs[i].sh_link;
 			info->strtab       = (void *)hdr +
 			    sechdrs[sh_link_idx].sh_offset;
 		}
@@ -516,11 +514,9 @@ static int parse_elf(struct elf_info *info, const char *filename)
 
 	if (symtab_shndx_idx != ~0U) {
 		Elf32_Word *p;
-		if (symtab_idx !=
-		    shndx2secindex(sechdrs[symtab_shndx_idx].sh_link))
+		if (symtab_idx != sechdrs[symtab_shndx_idx].sh_link)
 			fatal("%s: SYMTAB_SHNDX has bad sh_link: %u!=%u\n",
-			      filename,
-			      shndx2secindex(sechdrs[symtab_shndx_idx].sh_link),
+			      filename, sechdrs[symtab_shndx_idx].sh_link,
 			      symtab_idx);
 		/* Fix endianness */
 		for (p = info->symtab_shndx_start; p < info->symtab_shndx_stop;
@@ -1446,7 +1442,7 @@ static unsigned int *reloc_location(struct elf_info *elf,
 				    Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	Elf_Shdr *sechdrs = elf->sechdrs;
-	int section = shndx2secindex(sechdr->sh_info);
+	int section = sechdr->sh_info;
 
 	return (void *)elf->hdr + sechdrs[section].sh_offset +
 		r->r_offset;

commit 00759c0ea0d3b4c918539ddd7cbbfbbb39a38fc7
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue Mar 15 14:13:47 2011 -0700

    modpost: fix trailing comma
    
    Consolidate locations that print a section whitelist into
    calls to print_section_list().
    
    Fix print_section_list() so that it does not print a trailing
    comma & space:
    
    If the reference is valid then annotate the
    variable with __init* or __refdata (see linux/init.h) or name the variable:
    *_template, *_timer, *_sht, *_ops, *_probe, *_probe_one, *_console,
    
    becomes:
    If the reference is valid then annotate the
    variable with __init* or __refdata (see linux/init.h) or name the variable:
    *_template, *_timer, *_sht, *_ops, *_probe, *_probe_one, *_console
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e8fba959fffb..cd104afcc5f2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1248,6 +1248,19 @@ static int is_function(Elf_Sym *sym)
 		return -1;
 }
 
+static void print_section_list(const char * const list[20])
+{
+	const char *const *s = list;
+
+	while (*s) {
+		fprintf(stderr, "%s", *s);
+		s++;
+		if (*s)
+			fprintf(stderr, ", ");
+	}
+	fprintf(stderr, "\n");
+}
+
 /*
  * Print a warning about a section mismatch.
  * Try to find symbols near it so user can find it.
@@ -1304,7 +1317,6 @@ static void report_sec_mismatch(const char *modname,
 		break;
 	case DATA_TO_ANY_INIT: {
 		prl_to = sec2annotation(tosec);
-		const char *const *s = mismatch->symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
 		"the %s %s%s%s\n"
@@ -1312,9 +1324,7 @@ static void report_sec_mismatch(const char *modname,
 		"variable with __init* or __refdata (see linux/init.h) "
 		"or name the variable:\n",
 		fromsym, to, prl_to, tosym, to_p);
-		while (*s)
-			fprintf(stderr, "%s, ", *s++);
-		fprintf(stderr, "\n");
+		print_section_list(mismatch->symbol_white_list);
 		free(prl_to);
 		break;
 	}
@@ -1329,7 +1339,6 @@ static void report_sec_mismatch(const char *modname,
 		break;
 	case DATA_TO_ANY_EXIT: {
 		prl_to = sec2annotation(tosec);
-		const char *const *s = mismatch->symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
 		"the %s %s%s%s\n"
@@ -1337,9 +1346,7 @@ static void report_sec_mismatch(const char *modname,
 		"variable with __exit* (see linux/init.h) or "
 		"name the variable:\n",
 		fromsym, to, prl_to, tosym, to_p);
-		while (*s)
-			fprintf(stderr, "%s, ", *s++);
-		fprintf(stderr, "\n");
+		print_section_list(mismatch->symbol_white_list);
 		free(prl_to);
 		break;
 	}

commit 008d23e4852d78bb2618f2035f8b2110b6a6b968
Merge: 8f685fbda43d bfc672dcf323
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:05:56 2011 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (43 commits)
      Documentation/trace/events.txt: Remove obsolete sched_signal_send.
      writeback: fix global_dirty_limits comment runtime -> real-time
      ppc: fix comment typo singal -> signal
      drivers: fix comment typo diable -> disable.
      m68k: fix comment typo diable -> disable.
      wireless: comment typo fix diable -> disable.
      media: comment typo fix diable -> disable.
      remove doc for obsolete dynamic-printk kernel-parameter
      remove extraneous 'is' from Documentation/iostats.txt
      Fix spelling milisec -> ms in snd_ps3 module parameter description
      Fix spelling mistakes in comments
      Revert conflicting V4L changes
      i7core_edac: fix typos in comments
      mm/rmap.c: fix comment
      sound, ca0106: Fix assignment to 'channel'.
      hrtimer: fix a typo in comment
      init/Kconfig: fix typo
      anon_inodes: fix wrong function name in comment
      fix comment typos concerning "consistent"
      poll: fix a typo in comment
      ...
    
    Fix up trivial conflicts in:
     - drivers/net/wireless/iwlwifi/iwl-core.c (moved to iwl-legacy.c)
     - fs/ext4/ext4.h
    
    Also fix missed 'diabled' typo in drivers/net/bnx2x/bnx2x.h while at it.

commit 731ece41fb1047816303295a0cdfed90a528137e
Author: Olof Johansson <olof@lixom.net>
Date:   Fri Dec 10 02:09:23 2010 -0600

    modpost: Fix address calculation in reloc_location()
    
    This patch fixes a segfault in modpost that is observed when the gold
    linker is used to link the input objects.
    
    The problem is that reloc_location (modpost.c) is computing the
    address of the relocation target incorrectly. Here, elf->hdr points
    to the beginning of the ELF file in memory, sechdr points to the
    relocation section header, section is the index of the section
    being relocated, and sechdrs[section].sh_offset would be the offset
    of that section, relative to the beginning of the ELF file. Adding
    elf->hdr + sechdrs[section].sh_offset gives you the address of the
    beginning of the section, and adding r->r_offset to that gives you the
    address of the location to be relocated. You do not need to subtract
    sechdrs[section].sh_addr from that -- the result of this is an address
    outside the file, and causes the segfault when addend_386_rel tries to
    dereference it.
    
    This bug is not observed when GNU ld is used to link the inputs. The
    object file ubuntu/omnibook/omnibook.o is the result of an ld -r of
    several other files.  When GNU ld does an ld -r, it sets the vaddr
    field for each section to 0, but gold lays out the section addresses
    sequentially instead:
    
    Section Headers:
     [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
     [ 0]                   NULL            00000000 000000 000000 00      0   0  0
     [ 1] .text             PROGBITS        00000000 000034 004794 00  AX  0   0  4
     [ 2] .data             PROGBITS        0000b9d0 0047c8 0009c0 00  WA  0   0  4
     [ 3] .bss              NOBITS          000162f8 005188 00013c 00  WA  0   0  4
     [ 4] .rodata.str1.1    PROGBITS        00004f2d 0052c4 001b1a 01 AMS  0   0  1
     [ 5] .init.text        PROGBITS        00004794 006dde 0005fa 00  AX  0   0  1
     [ 6] .exit.text        PROGBITS        00004d8e 0073d8 00018a 00  AX  0   0  1
      ...
    
    So the bug in the tool remained undiscovered because the section's vaddr
    always happened to be 0.
    
    Signed-off-by: Raymes Khoury <raymes@google.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 194e2c453609..97d2259ae999 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1442,7 +1442,7 @@ static unsigned int *reloc_location(struct elf_info *elf,
 	int section = shndx2secindex(sechdr->sh_info);
 
 	return (void *)elf->hdr + sechdrs[section].sh_offset +
-		r->r_offset - sechdrs[section].sh_addr;
+		r->r_offset;
 }
 
 static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)

commit 1121584f5db8a99a7ad94c6c5d62431b3187ad98
Author: H.J. Lu <hjl.tools@gmail.com>
Date:   Wed Dec 15 17:11:22 2010 -0800

    modpost: Put .zdebug* section on white list
    
    "as --compress-debug-sections" will generate compressed debug sections
    with section names ".zdebug*".  This patch puts .zdebug* section on
    white list.
    
    Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 33122ca04e7c..194e2c453609 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -790,6 +790,7 @@ static const char *section_white_list[] =
 {
 	".comment*",
 	".debug*",
+	".zdebug*",		/* Compressed debug sections. */
 	".GCC-command-line",	/* mn10300 */
 	".mdebug*",        /* alpha, score, mips etc. */
 	".pdr",            /* alpha, score, mips etc. */

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 33122ca04e7c..6619ed8843f9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1614,7 +1614,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
  * A module includes a number of sections that are discarded
  * either when loaded or when used as built-in.
  * For loaded modules all functions marked __init and all data
- * marked __initdata will be discarded when the module has been intialized.
+ * marked __initdata will be discarded when the module has been initialized.
  * Likewise for modules used built-in the sections marked __exit
  * are discarded because __exit marked function are supposed to be called
  * only when a module is unloaded which never happens for built-in modules.

commit c9e2a72ff1acfdffdecb338b3d997f90c507e665
Merge: 9aca0e7c8c3a d63f6d1b4d3a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 28 15:13:55 2010 -0700

    Merge branch 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6
    
    * 'kbuild' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6:
      initramfs: Fix build break on symbol-prefixed archs
      initramfs: fix initramfs size calculation
      initramfs: generalize initramfs_data.xxx.S variants
      scripts/kallsyms: Enable error messages while hush up unnecessary warnings
      scripts/setlocalversion: update comment
      kbuild: Use a single clean rule for kernel and external modules
      kbuild: Do not run make clean in $(srctree)
      scripts/mod/modpost.c: fix commentary accordingly to last changes
      kbuild: Really don't clean bounds.h and asm-offsets.h

commit cbcf14a942eb06d031628046739b983e84b383bf
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Tue Aug 17 13:36:40 2010 +0300

    scripts/mod/modpost.c: fix commentary accordingly to last changes
    
    The last commits
     37ed19d5cce35a40d3913cf9aa208ce9f60db3d7
     5003bab82d56754b27be01eef24495a02e00039d
    have introduced new behaviour of sec2annotation() method. However, the
    commentary inside the method was left as before. Let's fix it accordingly.
    
    Signed-off-by: Andy Shevchenko <ext-andriy.shevchenko@nokia.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c827309c29cf..859bee4972e9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1193,6 +1193,9 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
  * .cpuinit.data => __cpudata
  * .memexitconst => __memconst
  * etc.
+ *
+ * The memory of returned value has been allocated on a heap. The user of this
+ * method should free it after usage.
 */
 static char *sec2annotation(const char *s)
 {
@@ -1215,7 +1218,7 @@ static char *sec2annotation(const char *s)
 			strcat(p, "data ");
 		else
 			strcat(p, " ");
-		return r; /* we leak her but we do not care */
+		return r;
 	} else {
 		return "";
 	}

commit 26df0766a73a859bb93dc58e747c5028557a23fd
Merge: 580287628cdd a6de51b27870
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 12 10:01:59 2010 -0700

    Merge branch 'params' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux-2.6-for-linus
    
    * 'params' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux-2.6-for-linus: (22 commits)
      param: don't deref arg in __same_type() checks
      param: update drivers/acpi/debug.c to new scheme
      param: use module_param in drivers/message/fusion/mptbase.c
      ide: use module_param_named rather than module_param_call
      param: update drivers/char/ipmi/ipmi_watchdog.c to new scheme
      param: lock if_sdio's lbs_helper_name and lbs_fw_name against sysfs changes.
      param: lock myri10ge_fw_name against sysfs changes.
      param: simple locking for sysfs-writable charp parameters
      param: remove unnecessary writable charp
      param: add kerneldoc to moduleparam.h
      param: locking for kernel parameters
      param: make param sections const.
      param: use free hook for charp (fix leak of charp parameters)
      param: add a free hook to kernel_param_ops.
      param: silence .init.text references from param ops
      Add param ops struct for hvc_iucv driver.
      nfs: update for module_param_named API change
      AppArmor: update for module_param_named API change
      param: use ops in struct kernel_param, rather than get and set fns directly
      param: move the EXPORT_SYMBOL to after the definitions.
      ...

commit 019fca84e7c4b94817abc77df9081ba208fcc46a
Author: David Howells <dhowells@redhat.com>
Date:   Thu Aug 12 16:54:47 2010 +0100

    MN10300: Permit .GCC-command-line sections
    
    Permit .GCC-command-line sections in modules.  Otherwise modpost says things
    like:
    
    WARNING: drivers/mtd/chips/map_ram.o (.GCC-command-line): unexpected non-allocatable section.
    Did you forget to use "ax"/"aw" in a .S file?
    Note that for example <linux/init.h> contains
    section definitions for use in .S files.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7acbdd8fcaed..253c107b9a99 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -790,6 +790,7 @@ static const char *section_white_list[] =
 {
 	".comment*",
 	".debug*",
+	".GCC-command-line",	/* mn10300 */
 	".mdebug*",        /* alpha, score, mips etc. */
 	".pdr",            /* alpha, score, mips etc. */
 	".stab*",

commit 5003bab82d56754b27be01eef24495a02e00039d
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Aug 11 00:42:26 2010 -0700

    fix "scripts/mod/modpost.c: fix memory leak"
    
    Fix error introduced by 37ed19d5cce35a40d3913cf9aa208ce9f60db3d7
    ("scripts/mod/modpost.c: fix memory leak").
    
     - don't kfree("")
    
     - fix one missed conversion
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Tested-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexey Fomenko <ext-alexey.fomenko@nokia.com>
    Cc: Trevor Keith <tsrk@tsrk.net>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1ce655dde99e..7acbdd8fcaed 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -14,6 +14,7 @@
 #define _GNU_SOURCE
 #include <stdio.h>
 #include <ctype.h>
+#include <string.h>
 #include "modpost.h"
 #include "../../include/generated/autoconf.h"
 #include "../../include/linux/license.h"
@@ -1217,7 +1218,7 @@ static char *sec2annotation(const char *s)
 			strcat(p, " ");
 		return r; /* we leak her but we do not care */
 	} else {
-		return "";
+		return strdup("");
 	}
 }
 
@@ -1352,7 +1353,7 @@ static void report_sec_mismatch(const char *modname,
 		"%s%s so it may be used outside an exit section.\n",
 		from, prl_from, fromsym, from_p,
 		to, prl_to, tosym, to_p,
-		sec2annotation(tosec), tosym, to_p);
+		prl_to, tosym, to_p);
 		free(prl_from);
 		free(prl_to);
 		break;

commit 6a841528d288ac420052f5c98fd426b0fcdc5b52
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Wed Aug 11 23:04:16 2010 -0600

    param: silence .init.text references from param ops
    
    Ideally, we'd check that it was only the "set" function which was __init,
    and that the permissions were r/o.  But that's a little hard.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Tested-by: Phil Carmody <ext-phil.2.carmody@nokia.com>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1ce655dde99e..b16044002d91 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1033,6 +1033,13 @@ static const struct sectioncheck *section_mismatch(
  *   fromsec = .data*
  *   atsym   =__param*
  *
+ * Pattern 1a:
+ *   module_param_call() ops can refer to __init set function if permissions=0
+ *   The pattern is identified by:
+ *   tosec   = .init.text
+ *   fromsec = .data*
+ *   atsym   = __param_ops_*
+ *
  * Pattern 2:
  *   Many drivers utilise a *driver container with references to
  *   add, remove, probe functions etc.
@@ -1067,6 +1074,12 @@ static int secref_whitelist(const struct sectioncheck *mismatch,
 	    (strncmp(fromsym, "__param", strlen("__param")) == 0))
 		return 0;
 
+	/* Check for pattern 1a */
+	if (strcmp(tosec, ".init.text") == 0 &&
+	    match(fromsec, data_sections) &&
+	    (strncmp(fromsym, "__param_ops_", strlen("__param_ops_")) == 0))
+		return 0;
+
 	/* Check for pattern 2 */
 	if (match(tosec, init_exit_sections) &&
 	    match(fromsec, data_sections) &&

commit 37ed19d5cce35a40d3913cf9aa208ce9f60db3d7
Author: Alexey Fomenko <ext-alexey.fomenko@nokia.com>
Date:   Mon Aug 9 17:20:24 2010 -0700

    scripts/mod/modpost.c: fix memory leak
    
    sec2annotation returns malloc'ed buffer directly to printf as an argument.
     Free this buffer after printing.
    
    Signed-off-by: Alexey Fomenko <ext-alexey.fomenko@nokia.com>
    Cc: Trevor Keith <tsrk@tsrk.net>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c827309c29cf..1ce655dde99e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1245,6 +1245,8 @@ static void report_sec_mismatch(const char *modname,
 {
 	const char *from, *from_p;
 	const char *to, *to_p;
+	char *prl_from;
+	char *prl_to;
 
 	switch (from_is_func) {
 	case 0: from = "variable"; from_p = "";   break;
@@ -1268,16 +1270,21 @@ static void report_sec_mismatch(const char *modname,
 
 	switch (mismatch->mismatch) {
 	case TEXT_TO_ANY_INIT:
+		prl_from = sec2annotation(fromsec);
+		prl_to = sec2annotation(tosec);
 		fprintf(stderr,
 		"The function %s%s() references\n"
 		"the %s %s%s%s.\n"
 		"This is often because %s lacks a %s\n"
 		"annotation or the annotation of %s is wrong.\n",
-		sec2annotation(fromsec), fromsym,
-		to, sec2annotation(tosec), tosym, to_p,
-		fromsym, sec2annotation(tosec), tosym);
+		prl_from, fromsym,
+		to, prl_to, tosym, to_p,
+		fromsym, prl_to, tosym);
+		free(prl_from);
+		free(prl_to);
 		break;
 	case DATA_TO_ANY_INIT: {
+		prl_to = sec2annotation(tosec);
 		const char *const *s = mismatch->symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
@@ -1285,20 +1292,24 @@ static void report_sec_mismatch(const char *modname,
 		"If the reference is valid then annotate the\n"
 		"variable with __init* or __refdata (see linux/init.h) "
 		"or name the variable:\n",
-		fromsym, to, sec2annotation(tosec), tosym, to_p);
+		fromsym, to, prl_to, tosym, to_p);
 		while (*s)
 			fprintf(stderr, "%s, ", *s++);
 		fprintf(stderr, "\n");
+		free(prl_to);
 		break;
 	}
 	case TEXT_TO_ANY_EXIT:
+		prl_to = sec2annotation(tosec);
 		fprintf(stderr,
 		"The function %s() references a %s in an exit section.\n"
 		"Often the %s %s%s has valid usage outside the exit section\n"
 		"and the fix is to remove the %sannotation of %s.\n",
-		fromsym, to, to, tosym, to_p, sec2annotation(tosec), tosym);
+		fromsym, to, to, tosym, to_p, prl_to, tosym);
+		free(prl_to);
 		break;
 	case DATA_TO_ANY_EXIT: {
+		prl_to = sec2annotation(tosec);
 		const char *const *s = mismatch->symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
@@ -1306,24 +1317,31 @@ static void report_sec_mismatch(const char *modname,
 		"If the reference is valid then annotate the\n"
 		"variable with __exit* (see linux/init.h) or "
 		"name the variable:\n",
-		fromsym, to, sec2annotation(tosec), tosym, to_p);
+		fromsym, to, prl_to, tosym, to_p);
 		while (*s)
 			fprintf(stderr, "%s, ", *s++);
 		fprintf(stderr, "\n");
+		free(prl_to);
 		break;
 	}
 	case XXXINIT_TO_SOME_INIT:
 	case XXXEXIT_TO_SOME_EXIT:
+		prl_from = sec2annotation(fromsec);
+		prl_to = sec2annotation(tosec);
 		fprintf(stderr,
 		"The %s %s%s%s references\n"
 		"a %s %s%s%s.\n"
 		"If %s is only used by %s then\n"
 		"annotate %s with a matching annotation.\n",
-		from, sec2annotation(fromsec), fromsym, from_p,
-		to, sec2annotation(tosec), tosym, to_p,
+		from, prl_from, fromsym, from_p,
+		to, prl_to, tosym, to_p,
 		tosym, fromsym, tosym);
+		free(prl_from);
+		free(prl_to);
 		break;
 	case ANY_INIT_TO_ANY_EXIT:
+		prl_from = sec2annotation(fromsec);
+		prl_to = sec2annotation(tosec);
 		fprintf(stderr,
 		"The %s %s%s%s references\n"
 		"a %s %s%s%s.\n"
@@ -1332,11 +1350,15 @@ static void report_sec_mismatch(const char *modname,
 		"uses functionality in the exit path.\n"
 		"The fix is often to remove the %sannotation of\n"
 		"%s%s so it may be used outside an exit section.\n",
-		from, sec2annotation(fromsec), fromsym, from_p,
-		to, sec2annotation(tosec), tosym, to_p,
+		from, prl_from, fromsym, from_p,
+		to, prl_to, tosym, to_p,
 		sec2annotation(tosec), tosym, to_p);
+		free(prl_from);
+		free(prl_to);
 		break;
 	case ANY_EXIT_TO_ANY_INIT:
+		prl_from = sec2annotation(fromsec);
+		prl_to = sec2annotation(tosec);
 		fprintf(stderr,
 		"The %s %s%s%s references\n"
 		"a %s %s%s%s.\n"
@@ -1345,16 +1367,20 @@ static void report_sec_mismatch(const char *modname,
 		"uses functionality in the init path.\n"
 		"The fix is often to remove the %sannotation of\n"
 		"%s%s so it may be used outside an init section.\n",
-		from, sec2annotation(fromsec), fromsym, from_p,
-		to, sec2annotation(tosec), tosym, to_p,
-		sec2annotation(tosec), tosym, to_p);
+		from, prl_from, fromsym, from_p,
+		to, prl_to, tosym, to_p,
+		prl_to, tosym, to_p);
+		free(prl_from);
+		free(prl_to);
 		break;
 	case EXPORT_TO_INIT_EXIT:
+		prl_to = sec2annotation(tosec);
 		fprintf(stderr,
 		"The symbol %s is exported and annotated %s\n"
 		"Fix this by removing the %sannotation of %s "
 		"or drop the export.\n",
-		tosym, sec2annotation(tosec), sec2annotation(tosec), tosym);
+		tosym, prl_to, prl_to, tosym);
+		free(prl_to);
 		break;
 	}
 	fprintf(stderr, "\n");

commit 772320e84588dcbe1600ffb83e5f328f2209ac2a
Merge: 1ce53adf13a5 9fe6206f4006
Author: Michal Marek <mmarek@suse.cz>
Date:   Wed Aug 4 13:59:13 2010 +0200

    Merge commit 'v2.6.35' into kbuild/kbuild
    
    Conflicts:
            arch/powerpc/Makefile

commit 1ce53adf13a54375d2a5c7cdbe341b2558389615
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Thu Jul 29 01:47:53 2010 +0200

    modpost: support objects with more than 64k sections
    
    This patch makes modpost able to process object files with more than
    64k sections. Needed for huge kernel builds (allyesconfig, for example)
    with -ffunction-sections. 64k sections handling is covered, for example,
    by this document:
    
    "IA-64 gABI Proposal 74: Section Indexes"
    http://www.codesourcery.com/public/cxx-abi/abi/prop-74-sindex.html
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: Anders Kaseorg <andersk@mit.edu>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3318692e4e76..7249ab44f44c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -253,7 +253,7 @@ static enum export export_no(const char *s)
 	return export_unknown;
 }
 
-static enum export export_from_sec(struct elf_info *elf, Elf_Section sec)
+static enum export export_from_sec(struct elf_info *elf, unsigned int sec)
 {
 	if (sec == elf->export_sec)
 		return export_plain;
@@ -373,6 +373,8 @@ static int parse_elf(struct elf_info *info, const char *filename)
 	Elf_Ehdr *hdr;
 	Elf_Shdr *sechdrs;
 	Elf_Sym  *sym;
+	const char *secstrings;
+	unsigned int symtab_idx = ~0U, symtab_shndx_idx = ~0U;
 
 	hdr = grab_file(filename, &info->size);
 	if (!hdr) {
@@ -417,8 +419,27 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		return 0;
 	}
 
+	if (hdr->e_shnum == 0) {
+		/*
+		 * There are more than 64k sections,
+		 * read count from .sh_size.
+		 * note: it doesn't need shndx2secindex()
+		 */
+		info->num_sections = TO_NATIVE(sechdrs[0].sh_size);
+	}
+	else {
+		info->num_sections = hdr->e_shnum;
+	}
+	if (hdr->e_shstrndx == SHN_XINDEX) {
+		info->secindex_strings =
+		    shndx2secindex(TO_NATIVE(sechdrs[0].sh_link));
+	}
+	else {
+		info->secindex_strings = hdr->e_shstrndx;
+	}
+
 	/* Fix endianness in section headers */
-	for (i = 0; i < hdr->e_shnum; i++) {
+	for (i = 0; i < info->num_sections; i++) {
 		sechdrs[i].sh_name      = TO_NATIVE(sechdrs[i].sh_name);
 		sechdrs[i].sh_type      = TO_NATIVE(sechdrs[i].sh_type);
 		sechdrs[i].sh_flags     = TO_NATIVE(sechdrs[i].sh_flags);
@@ -431,9 +452,8 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		sechdrs[i].sh_entsize   = TO_NATIVE(sechdrs[i].sh_entsize);
 	}
 	/* Find symbol table. */
-	for (i = 1; i < hdr->e_shnum; i++) {
-		const char *secstrings
-			= (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
+	secstrings = (void *)hdr + sechdrs[info->secindex_strings].sh_offset;
+	for (i = 1; i < info->num_sections; i++) {
 		const char *secname;
 		int nobits = sechdrs[i].sh_type == SHT_NOBITS;
 
@@ -461,14 +481,26 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
 			info->export_gpl_future_sec = i;
 
-		if (sechdrs[i].sh_type != SHT_SYMTAB)
-			continue;
+		if (sechdrs[i].sh_type == SHT_SYMTAB) {
+			unsigned int sh_link_idx;
+			symtab_idx = i;
+			info->symtab_start = (void *)hdr +
+			    sechdrs[i].sh_offset;
+			info->symtab_stop  = (void *)hdr +
+			    sechdrs[i].sh_offset + sechdrs[i].sh_size;
+			sh_link_idx = shndx2secindex(sechdrs[i].sh_link);
+			info->strtab       = (void *)hdr +
+			    sechdrs[sh_link_idx].sh_offset;
+		}
 
-		info->symtab_start = (void *)hdr + sechdrs[i].sh_offset;
-		info->symtab_stop  = (void *)hdr + sechdrs[i].sh_offset
-			                         + sechdrs[i].sh_size;
-		info->strtab       = (void *)hdr +
-			             sechdrs[sechdrs[i].sh_link].sh_offset;
+		/* 32bit section no. table? ("more than 64k sections") */
+		if (sechdrs[i].sh_type == SHT_SYMTAB_SHNDX) {
+			symtab_shndx_idx = i;
+			info->symtab_shndx_start = (void *)hdr +
+			    sechdrs[i].sh_offset;
+			info->symtab_shndx_stop  = (void *)hdr +
+			    sechdrs[i].sh_offset + sechdrs[i].sh_size;
+		}
 	}
 	if (!info->symtab_start)
 		fatal("%s has no symtab?\n", filename);
@@ -480,6 +512,21 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		sym->st_value = TO_NATIVE(sym->st_value);
 		sym->st_size  = TO_NATIVE(sym->st_size);
 	}
+
+	if (symtab_shndx_idx != ~0U) {
+		Elf32_Word *p;
+		if (symtab_idx !=
+		    shndx2secindex(sechdrs[symtab_shndx_idx].sh_link))
+			fatal("%s: SYMTAB_SHNDX has bad sh_link: %u!=%u\n",
+			      filename,
+			      shndx2secindex(sechdrs[symtab_shndx_idx].sh_link),
+			      symtab_idx);
+		/* Fix endianness */
+		for (p = info->symtab_shndx_start; p < info->symtab_shndx_stop;
+		     p++)
+			*p = TO_NATIVE(*p);
+	}
+
 	return 1;
 }
 
@@ -514,7 +561,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			       Elf_Sym *sym, const char *symname)
 {
 	unsigned int crc;
-	enum export export = export_from_sec(info, sym->st_shndx);
+	enum export export = export_from_sec(info, get_secindex(info, sym));
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
@@ -656,19 +703,19 @@ static const char *sym_name(struct elf_info *elf, Elf_Sym *sym)
 		return "(unknown)";
 }
 
-static const char *sec_name(struct elf_info *elf, int shndx)
+static const char *sec_name(struct elf_info *elf, int secindex)
 {
 	Elf_Shdr *sechdrs = elf->sechdrs;
 	return (void *)elf->hdr +
-	        elf->sechdrs[elf->hdr->e_shstrndx].sh_offset +
-	        sechdrs[shndx].sh_name;
+		elf->sechdrs[elf->secindex_strings].sh_offset +
+		sechdrs[secindex].sh_name;
 }
 
 static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
 {
 	return (void *)elf->hdr +
-	        elf->sechdrs[elf->hdr->e_shstrndx].sh_offset +
-	        sechdr->sh_name;
+		elf->sechdrs[elf->secindex_strings].sh_offset +
+		sechdr->sh_name;
 }
 
 /* if sym is empty or point to a string
@@ -1047,11 +1094,14 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,
 	Elf_Sym *near = NULL;
 	Elf64_Sword distance = 20;
 	Elf64_Sword d;
+	unsigned int relsym_secindex;
 
 	if (relsym->st_name != 0)
 		return relsym;
+
+	relsym_secindex = get_secindex(elf, relsym);
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
-		if (sym->st_shndx != relsym->st_shndx)
+		if (get_secindex(elf, sym) != relsym_secindex)
 			continue;
 		if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
 			continue;
@@ -1113,9 +1163,9 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
 		const char *symsec;
 
-		if (sym->st_shndx >= SHN_LORESERVE)
+		if (is_shndx_special(sym->st_shndx))
 			continue;
-		symsec = sec_name(elf, sym->st_shndx);
+		symsec = sec_name(elf, get_secindex(elf, sym));
 		if (strcmp(symsec, sec) != 0)
 			continue;
 		if (!is_valid_name(elf, sym))
@@ -1311,7 +1361,7 @@ static void check_section_mismatch(const char *modname, struct elf_info *elf,
 	const char *tosec;
 	const struct sectioncheck *mismatch;
 
-	tosec = sec_name(elf, sym->st_shndx);
+	tosec = sec_name(elf, get_secindex(elf, sym));
 	mismatch = section_mismatch(fromsec, tosec);
 	if (mismatch) {
 		Elf_Sym *to;
@@ -1339,7 +1389,7 @@ static unsigned int *reloc_location(struct elf_info *elf,
 				    Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	Elf_Shdr *sechdrs = elf->sechdrs;
-	int section = sechdr->sh_info;
+	int section = shndx2secindex(sechdr->sh_info);
 
 	return (void *)elf->hdr + sechdrs[section].sh_offset +
 		(r->r_offset - sechdrs[section].sh_addr);
@@ -1447,7 +1497,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 		r.r_addend = TO_NATIVE(rela->r_addend);
 		sym = elf->symtab_start + r_sym;
 		/* Skip special sections */
-		if (sym->st_shndx >= SHN_LORESERVE)
+		if (is_shndx_special(sym->st_shndx))
 			continue;
 		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
@@ -1505,7 +1555,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 		}
 		sym = elf->symtab_start + r_sym;
 		/* Skip special sections */
-		if (sym->st_shndx >= SHN_LORESERVE)
+		if (is_shndx_special(sym->st_shndx))
 			continue;
 		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
@@ -1530,7 +1580,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	Elf_Shdr *sechdrs = elf->sechdrs;
 
 	/* Walk through all sections */
-	for (i = 0; i < elf->hdr->e_shnum; i++) {
+	for (i = 0; i < elf->num_sections; i++) {
 		check_section(modname, elf, &elf->sechdrs[i]);
 		/* We want to process only relocation sections and not .init */
 		if (sechdrs[i].sh_type == SHT_RELA)

commit 7fca5dc8aa7aaa6a1023bd3587901b88ebfe8154
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Jun 29 20:08:42 2010 +0000

    powerpc: Fix module building for gcc 4.5 and 64 bit
    
    Gcc 4.5 is now generating out of line register save and restore
    in the function prefix and postfix when we use -Os.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f8779006986d..f6127b9f5aca 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -503,6 +503,11 @@ static int ignore_undef_symbol(struct elf_info *info, const char *symname)
 		    strncmp(symname, "_rest32gpr_", sizeof("_rest32gpr_") - 1) == 0 ||
 		    strncmp(symname, "_save32gpr_", sizeof("_save32gpr_") - 1) == 0)
 			return 1;
+	if (info->hdr->e_machine == EM_PPC64)
+		/* Special register function linked on all modules during final link of .ko */
+		if (strncmp(symname, "_restgpr0_", sizeof("_restgpr0_") - 1) == 0 ||
+		    strncmp(symname, "_savegpr0_", sizeof("_savegpr0_") - 1) == 0)
+			return 1;
 	/* Do not ignore this symbol */
 	return 0;
 }

commit 1c938663d58b5b2965976a6f54cc51b5d6f691aa
Author: Krzysztof Halasa <khc@pm.waw.pl>
Date:   Fri Jun 11 01:08:20 2010 +0200

    kbuild: Fix modpost segfault
    
    Alan <alan@clueserver.org> writes:
    
    > program: /home/alan/GitTrees/linux-2.6-mid-ref/scripts/mod/modpost -o
    > Module.symvers -S vmlinux.o
    >
    > Program received signal SIGSEGV, Segmentation fault.
    
    It just hit me.
    It's the offset calculation in reloc_location() which overflows:
            return (void *)elf->hdr + sechdrs[section].sh_offset +
                   (r->r_offset - sechdrs[section].sh_addr);
    
    E.g. for the first rodata r entry:
    r->r_offset < sechdrs[section].sh_addr
    and the expression in the parenthesis produces 0xFFFFFFE0 or something
    equally wise.
    
    Reported-by: Alan <alan@clueserver.org>
    Signed-off-by: Krzysztof Haasa <khc@pm.waw.pl>
    Tested-by: Alan <alan@clueserver.org>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3318692e4e76..f8779006986d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1342,7 +1342,7 @@ static unsigned int *reloc_location(struct elf_info *elf,
 	int section = sechdr->sh_info;
 
 	return (void *)elf->hdr + sechdrs[section].sh_offset +
-		(r->r_offset - sechdrs[section].sh_addr);
+		r->r_offset - sechdrs[section].sh_addr;
 }
 
 static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)

commit 0db252452378aa7a9e001a13226e1cd1dc61453d
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Sat Jan 30 21:14:23 2010 +0100

    modpost: don't allow *driver to reference .init.*
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5dbe4db2bd42..3318692e4e76 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -862,10 +862,19 @@ const struct sectioncheck sectioncheck[] = {
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
-	.tosec   = { ALL_INIT_SECTIONS, NULL },
+	.tosec   = { ALL_XXXINIT_SECTIONS, NULL },
 	.mismatch = DATA_TO_ANY_INIT,
 	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
+{
+	.fromsec = { DATA_SECTIONS, NULL },
+	.tosec   = { INIT_SECTIONS, NULL },
+	.mismatch = DATA_TO_ANY_INIT,
+	.symbol_white_list = {
+		"*_template", "*_timer", "*_sht", "*_ops",
+		"*_probe", "*_probe_one", "*_console", NULL
+	},
+},
 {
 	.fromsec = { TEXT_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },

commit af92a82d0fec4dfd344b2ffd7a63e30f05c53938
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Sat Jan 30 20:52:50 2010 +0100

    modpost: make symbol white list a per mismatch type variable
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a94bd10ad2de..5dbe4db2bd42 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -817,18 +817,15 @@ static const char *data_sections[] = { DATA_SECTIONS, NULL };
 
 
 /* symbols in .data that may refer to init/exit sections */
-static const char *symbol_white_list[] =
-{
-	"*driver",
-	"*_template", /* scsi uses *_template a lot */
-	"*_timer",    /* arm uses ops structures named _timer a lot */
-	"*_sht",      /* scsi also used *_sht to some extent */
-	"*_ops",
-	"*_probe",
-	"*_probe_one",
-	"*_console",
-	NULL
-};
+#define DEFAULT_SYMBOL_WHITE_LIST					\
+	"*driver",							\
+	"*_template", /* scsi uses *_template a lot */			\
+	"*_timer",    /* arm uses ops structures named _timer a lot */	\
+	"*_sht",      /* scsi also used *_sht to some extent */		\
+	"*_ops",							\
+	"*_probe",							\
+	"*_probe_one",							\
+	"*_console"
 
 static const char *head_sections[] = { ".head.text*", NULL };
 static const char *linker_symbols[] =
@@ -850,6 +847,7 @@ struct sectioncheck {
 	const char *fromsec[20];
 	const char *tosec[20];
 	enum mismatch mismatch;
+	const char *symbol_white_list[20];
 };
 
 const struct sectioncheck sectioncheck[] = {
@@ -860,75 +858,88 @@ const struct sectioncheck sectioncheck[] = {
 	.fromsec = { TEXT_SECTIONS, NULL },
 	.tosec   = { ALL_INIT_SECTIONS, NULL },
 	.mismatch = TEXT_TO_ANY_INIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
 	.tosec   = { ALL_INIT_SECTIONS, NULL },
 	.mismatch = DATA_TO_ANY_INIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { TEXT_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
 	.mismatch = TEXT_TO_ANY_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
 	.mismatch = DATA_TO_ANY_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference init code/data from devinit/cpuinit/meminit code/data */
 {
 	.fromsec = { ALL_XXXINIT_SECTIONS, NULL },
 	.tosec   = { INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_SOME_INIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference cpuinit code/data from meminit code/data */
 {
 	.fromsec = { MEM_INIT_SECTIONS, NULL },
 	.tosec   = { CPU_INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_SOME_INIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference meminit code/data from cpuinit code/data */
 {
 	.fromsec = { CPU_INIT_SECTIONS, NULL },
 	.tosec   = { MEM_INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_SOME_INIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
 {
 	.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },
 	.tosec   = { EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_SOME_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference cpuexit code/data from memexit code/data */
 {
 	.fromsec = { MEM_EXIT_SECTIONS, NULL },
 	.tosec   = { CPU_EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_SOME_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not reference memexit code/data from cpuexit code/data */
 {
 	.fromsec = { CPU_EXIT_SECTIONS, NULL },
 	.tosec   = { MEM_EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_SOME_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not use exit code/data from init code */
 {
 	.fromsec = { ALL_INIT_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
 	.mismatch = ANY_INIT_TO_ANY_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not use init code/data from exit code */
 {
 	.fromsec = { ALL_EXIT_SECTIONS, NULL },
 	.tosec   = { ALL_INIT_SECTIONS, NULL },
 	.mismatch = ANY_EXIT_TO_ANY_INIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 },
 /* Do not export init/exit functions or data */
 {
 	.fromsec = { "__ksymtab*", NULL },
 	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL },
-	.mismatch = EXPORT_TO_INIT_EXIT
+	.mismatch = EXPORT_TO_INIT_EXIT,
+	.symbol_white_list = { DEFAULT_SYMBOL_WHITE_LIST, NULL },
 }
 };
 
@@ -985,7 +996,8 @@ static const struct sectioncheck *section_mismatch(
  *   refsymname = __init_begin, _sinittext, _einittext
  *
  **/
-static int secref_whitelist(const char *fromsec, const char *fromsym,
+static int secref_whitelist(const struct sectioncheck *mismatch,
+			    const char *fromsec, const char *fromsym,
 			    const char *tosec, const char *tosym)
 {
 	/* Check for pattern 1 */
@@ -997,7 +1009,7 @@ static int secref_whitelist(const char *fromsec, const char *fromsym,
 	/* Check for pattern 2 */
 	if (match(tosec, init_exit_sections) &&
 	    match(fromsec, data_sections) &&
-	    match(fromsym, symbol_white_list))
+	    match(fromsym, mismatch->symbol_white_list))
 		return 0;
 
 	/* Check for pattern 3 */
@@ -1202,7 +1214,7 @@ static void report_sec_mismatch(const char *modname,
 		fromsym, sec2annotation(tosec), tosym);
 		break;
 	case DATA_TO_ANY_INIT: {
-		const char **s = symbol_white_list;
+		const char *const *s = mismatch->symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
 		"the %s %s%s%s\n"
@@ -1223,7 +1235,7 @@ static void report_sec_mismatch(const char *modname,
 		fromsym, to, to, tosym, to_p, sec2annotation(tosec), tosym);
 		break;
 	case DATA_TO_ANY_EXIT: {
-		const char **s = symbol_white_list;
+		const char *const *s = mismatch->symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
 		"the %s %s%s%s\n"
@@ -1304,7 +1316,8 @@ static void check_section_mismatch(const char *modname, struct elf_info *elf,
 		tosym = sym_name(elf, to);
 
 		/* check whitelist - we may ignore it */
-		if (secref_whitelist(fromsec, fromsym, tosec, tosym)) {
+		if (secref_whitelist(mismatch,
+					fromsec, fromsym, tosec, tosym)) {
 			report_sec_mismatch(modname, mismatch,
 			   fromsec, r->r_offset, fromsym,
 			   is_function(from), tosec, tosym,

commit fc2f7efadb755b020ad8fdf195515dacaf185e2d
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Sat Jan 30 16:57:48 2010 +0100

    modpost: remove now unused NO_MISMATCH constant
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3f0380b8d8f7..a94bd10ad2de 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -835,7 +835,6 @@ static const char *linker_symbols[] =
 	{ "__init_begin", "_sinittext", "_einittext", NULL };
 
 enum mismatch {
-	NO_MISMATCH,
 	TEXT_TO_ANY_INIT,
 	DATA_TO_ANY_INIT,
 	TEXT_TO_ANY_EXIT,
@@ -1280,8 +1279,6 @@ static void report_sec_mismatch(const char *modname,
 		"Fix this by removing the %sannotation of %s "
 		"or drop the export.\n",
 		tosym, sec2annotation(tosec), sec2annotation(tosec), tosym);
-	case NO_MISMATCH:
-		/* To get warnings on missing members */
 		break;
 	}
 	fprintf(stderr, "\n");

commit 0d2a636ee6c3b8c292fbaae05976fe1537b70958
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Sat Jan 30 16:56:20 2010 +0100

    modpost: pass around const struct sectioncheck * instead of enum mismatch
    
    This prepares having a per-check whitelist of symbol names.
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 598d54a0fefb..3f0380b8d8f7 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -933,7 +933,8 @@ const struct sectioncheck sectioncheck[] = {
 }
 };
 
-static int section_mismatch(const char *fromsec, const char *tosec)
+static const struct sectioncheck *section_mismatch(
+		const char *fromsec, const char *tosec)
 {
 	int i;
 	int elems = sizeof(sectioncheck) / sizeof(struct sectioncheck);
@@ -942,10 +943,10 @@ static int section_mismatch(const char *fromsec, const char *tosec)
 	for (i = 0; i < elems; i++) {
 		if (match(fromsec, check->fromsec) &&
 		    match(tosec, check->tosec))
-			return check->mismatch;
+			return check;
 		check++;
 	}
-	return NO_MISMATCH;
+	return NULL;
 }
 
 /**
@@ -1158,7 +1159,8 @@ static int is_function(Elf_Sym *sym)
  * Try to find symbols near it so user can find it.
  * Check whitelist before warning - it may be a false positive.
  */
-static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
+static void report_sec_mismatch(const char *modname,
+				const struct sectioncheck *mismatch,
                                 const char *fromsec,
                                 unsigned long long fromaddr,
                                 const char *fromsym,
@@ -1189,7 +1191,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 	     modname, fromsec, fromaddr, from, fromsym, from_p, to, tosec,
 	     tosym, to_p);
 
-	switch (mismatch) {
+	switch (mismatch->mismatch) {
 	case TEXT_TO_ANY_INIT:
 		fprintf(stderr,
 		"The function %s%s() references\n"
@@ -1289,11 +1291,11 @@ static void check_section_mismatch(const char *modname, struct elf_info *elf,
                                    Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
 {
 	const char *tosec;
-	enum mismatch mismatch;
+	const struct sectioncheck *mismatch;
 
 	tosec = sec_name(elf, sym->st_shndx);
 	mismatch = section_mismatch(fromsec, tosec);
-	if (mismatch != NO_MISMATCH) {
+	if (mismatch) {
 		Elf_Sym *to;
 		Elf_Sym *from;
 		const char *tosym;

commit bbd3f4fb84f8c4a04f22c9c6dc119b0c4856c7d9
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Sat Jan 30 16:35:47 2010 +0100

    modpost: give most mismatch constants a better name
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index dbab53a2e225..598d54a0fefb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -836,14 +836,14 @@ static const char *linker_symbols[] =
 
 enum mismatch {
 	NO_MISMATCH,
-	TEXT_TO_INIT,
-	DATA_TO_INIT,
-	TEXT_TO_EXIT,
-	DATA_TO_EXIT,
-	XXXINIT_TO_INIT,
-	XXXEXIT_TO_EXIT,
-	INIT_TO_EXIT,
-	EXIT_TO_INIT,
+	TEXT_TO_ANY_INIT,
+	DATA_TO_ANY_INIT,
+	TEXT_TO_ANY_EXIT,
+	DATA_TO_ANY_EXIT,
+	XXXINIT_TO_SOME_INIT,
+	XXXEXIT_TO_SOME_EXIT,
+	ANY_INIT_TO_ANY_EXIT,
+	ANY_EXIT_TO_ANY_INIT,
 	EXPORT_TO_INIT_EXIT,
 };
 
@@ -860,70 +860,70 @@ const struct sectioncheck sectioncheck[] = {
 {
 	.fromsec = { TEXT_SECTIONS, NULL },
 	.tosec   = { ALL_INIT_SECTIONS, NULL },
-	.mismatch = TEXT_TO_INIT,
+	.mismatch = TEXT_TO_ANY_INIT,
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
 	.tosec   = { ALL_INIT_SECTIONS, NULL },
-	.mismatch = DATA_TO_INIT,
+	.mismatch = DATA_TO_ANY_INIT,
 },
 {
 	.fromsec = { TEXT_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
-	.mismatch = TEXT_TO_EXIT,
+	.mismatch = TEXT_TO_ANY_EXIT,
 },
 {
 	.fromsec = { DATA_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
-	.mismatch = DATA_TO_EXIT,
+	.mismatch = DATA_TO_ANY_EXIT,
 },
 /* Do not reference init code/data from devinit/cpuinit/meminit code/data */
 {
 	.fromsec = { ALL_XXXINIT_SECTIONS, NULL },
 	.tosec   = { INIT_SECTIONS, NULL },
-	.mismatch = XXXINIT_TO_INIT,
+	.mismatch = XXXINIT_TO_SOME_INIT,
 },
 /* Do not reference cpuinit code/data from meminit code/data */
 {
 	.fromsec = { MEM_INIT_SECTIONS, NULL },
 	.tosec   = { CPU_INIT_SECTIONS, NULL },
-	.mismatch = XXXINIT_TO_INIT,
+	.mismatch = XXXINIT_TO_SOME_INIT,
 },
 /* Do not reference meminit code/data from cpuinit code/data */
 {
 	.fromsec = { CPU_INIT_SECTIONS, NULL },
 	.tosec   = { MEM_INIT_SECTIONS, NULL },
-	.mismatch = XXXINIT_TO_INIT,
+	.mismatch = XXXINIT_TO_SOME_INIT,
 },
 /* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
 {
 	.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },
 	.tosec   = { EXIT_SECTIONS, NULL },
-	.mismatch = XXXEXIT_TO_EXIT,
+	.mismatch = XXXEXIT_TO_SOME_EXIT,
 },
 /* Do not reference cpuexit code/data from memexit code/data */
 {
 	.fromsec = { MEM_EXIT_SECTIONS, NULL },
 	.tosec   = { CPU_EXIT_SECTIONS, NULL },
-	.mismatch = XXXEXIT_TO_EXIT,
+	.mismatch = XXXEXIT_TO_SOME_EXIT,
 },
 /* Do not reference memexit code/data from cpuexit code/data */
 {
 	.fromsec = { CPU_EXIT_SECTIONS, NULL },
 	.tosec   = { MEM_EXIT_SECTIONS, NULL },
-	.mismatch = XXXEXIT_TO_EXIT,
+	.mismatch = XXXEXIT_TO_SOME_EXIT,
 },
 /* Do not use exit code/data from init code */
 {
 	.fromsec = { ALL_INIT_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
-	.mismatch = INIT_TO_EXIT,
+	.mismatch = ANY_INIT_TO_ANY_EXIT,
 },
 /* Do not use init code/data from exit code */
 {
 	.fromsec = { ALL_EXIT_SECTIONS, NULL },
 	.tosec   = { ALL_INIT_SECTIONS, NULL },
-	.mismatch = EXIT_TO_INIT,
+	.mismatch = ANY_EXIT_TO_ANY_INIT,
 },
 /* Do not export init/exit functions or data */
 {
@@ -1190,7 +1190,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 	     tosym, to_p);
 
 	switch (mismatch) {
-	case TEXT_TO_INIT:
+	case TEXT_TO_ANY_INIT:
 		fprintf(stderr,
 		"The function %s%s() references\n"
 		"the %s %s%s%s.\n"
@@ -1200,7 +1200,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		to, sec2annotation(tosec), tosym, to_p,
 		fromsym, sec2annotation(tosec), tosym);
 		break;
-	case DATA_TO_INIT: {
+	case DATA_TO_ANY_INIT: {
 		const char **s = symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
@@ -1214,14 +1214,14 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		fprintf(stderr, "\n");
 		break;
 	}
-	case TEXT_TO_EXIT:
+	case TEXT_TO_ANY_EXIT:
 		fprintf(stderr,
 		"The function %s() references a %s in an exit section.\n"
 		"Often the %s %s%s has valid usage outside the exit section\n"
 		"and the fix is to remove the %sannotation of %s.\n",
 		fromsym, to, to, tosym, to_p, sec2annotation(tosec), tosym);
 		break;
-	case DATA_TO_EXIT: {
+	case DATA_TO_ANY_EXIT: {
 		const char **s = symbol_white_list;
 		fprintf(stderr,
 		"The variable %s references\n"
@@ -1235,8 +1235,8 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		fprintf(stderr, "\n");
 		break;
 	}
-	case XXXINIT_TO_INIT:
-	case XXXEXIT_TO_EXIT:
+	case XXXINIT_TO_SOME_INIT:
+	case XXXEXIT_TO_SOME_EXIT:
 		fprintf(stderr,
 		"The %s %s%s%s references\n"
 		"a %s %s%s%s.\n"
@@ -1246,7 +1246,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		to, sec2annotation(tosec), tosym, to_p,
 		tosym, fromsym, tosym);
 		break;
-	case INIT_TO_EXIT:
+	case ANY_INIT_TO_ANY_EXIT:
 		fprintf(stderr,
 		"The %s %s%s%s references\n"
 		"a %s %s%s%s.\n"
@@ -1259,7 +1259,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		to, sec2annotation(tosec), tosym, to_p,
 		sec2annotation(tosec), tosym, to_p);
 		break;
-	case EXIT_TO_INIT:
+	case ANY_EXIT_TO_ANY_INIT:
 		fprintf(stderr,
 		"The %s %s%s%s references\n"
 		"a %s %s%s%s.\n"

commit 4a31a229fb6cbbeabf5ca9a0dcb55d53ca052048
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Jan 29 12:04:26 2010 +0100

    modpost: define ALL_XXX{IN,EX}IT_SECTIONS
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 713b62eed875..dbab53a2e225 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -781,10 +781,13 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define ALL_EXIT_TEXT_SECTIONS \
 	".exit.text$", ".devexit.text$", ".cpuexit.text$", ".memexit.text$"
 
-#define ALL_INIT_SECTIONS INIT_SECTIONS, DEV_INIT_SECTIONS, \
-	CPU_INIT_SECTIONS, MEM_INIT_SECTIONS
-#define ALL_EXIT_SECTIONS EXIT_SECTIONS, DEV_EXIT_SECTIONS, \
-	CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS
+#define ALL_XXXINIT_SECTIONS DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, \
+	MEM_INIT_SECTIONS
+#define ALL_XXXEXIT_SECTIONS DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, \
+	MEM_EXIT_SECTIONS
+
+#define ALL_INIT_SECTIONS INIT_SECTIONS, ALL_XXXINIT_SECTIONS
+#define ALL_EXIT_SECTIONS EXIT_SECTIONS, ALL_XXXEXIT_SECTIONS
 
 #define DATA_SECTIONS ".data$", ".data.rel$"
 #define TEXT_SECTIONS ".text$"
@@ -876,7 +879,7 @@ const struct sectioncheck sectioncheck[] = {
 },
 /* Do not reference init code/data from devinit/cpuinit/meminit code/data */
 {
-	.fromsec = { DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, MEM_INIT_SECTIONS, NULL },
+	.fromsec = { ALL_XXXINIT_SECTIONS, NULL },
 	.tosec   = { INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_INIT,
 },
@@ -894,7 +897,7 @@ const struct sectioncheck sectioncheck[] = {
 },
 /* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
 {
-	.fromsec = { DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS, NULL },
+	.fromsec = { ALL_XXXEXIT_SECTIONS, NULL },
 	.tosec   = { EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_EXIT,
 },

commit b75dcabd6c6c71d7cea64f78b06d18d9cda0ddd1
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Fri Jan 29 11:40:38 2010 +0100

    modpost: members of *driver structs should not point to __init functions
    
    Either the functions referred to in a driver struct should live in
    .devinit or the driver should be registered using platform_driver_probe
    (or equivalent for different driver types) with ->probe being NULL.
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 20923613467c..713b62eed875 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -961,7 +961,7 @@ static int section_mismatch(const char *fromsec, const char *tosec)
  * Pattern 2:
  *   Many drivers utilise a *driver container with references to
  *   add, remove, probe functions etc.
- *   These functions may often be marked __init and we do not want to
+ *   These functions may often be marked __devinit and we do not want to
  *   warn here.
  *   the pattern is identified by:
  *   tosec   = init or exit section

commit 5a865c0606eb44d5d12cabb429751c83712183de
Merge: 331d9d595827 46e75f66677f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 17 07:23:42 2009 -0800

    Merge branch 'for-33' of git://repo.or.cz/linux-kbuild
    
    * 'for-33' of git://repo.or.cz/linux-kbuild: (29 commits)
      net: fix for utsrelease.h moving to generated
      gen_init_cpio: fixed fwrite warning
      kbuild: fix make clean after mismerge
      kbuild: generate modules.builtin
      genksyms: properly consider  EXPORT_UNUSED_SYMBOL{,_GPL}()
      score: add asm/asm-offsets.h wrapper
      unifdef: update to upstream revision 1.190
      kbuild: specify absolute paths for cscope
      kbuild: create include/generated in silentoldconfig
      scripts/package: deb-pkg: use fakeroot if available
      scripts/package: add KBUILD_PKG_ROOTCMD variable
      scripts/package: tar-pkg: use tar --owner=root
      Kbuild: clean up marker
      net: add net_tstamp.h to headers_install
      kbuild: move utsrelease.h to include/generated
      kbuild: move autoconf.h to include/generated
      drop explicit include of autoconf.h
      kbuild: move compile.h to include/generated
      kbuild: drop include/asm
      kbuild: do not check for include/asm-$ARCH
      ...
    
    Fixed non-conflicting clean merge of modpost.c as per comments from
    Stephen Rothwell (modpost.c had grown an include of linux/autoconf.h
    that needed to be changed to generated/autoconf.h)

commit 8d99513c1b76cfd0b2dcf061c5136cb1061e6b37
Author: Michal Marek <mmarek@suse.cz>
Date:   Sat Dec 12 12:02:24 2009 +0100

    modpost: fix segfault with short symbol names
    
    memcmp() is wrong here, the symbol name can be shorter than KSYMTAB_PFX
    or CRC_PFX.
    
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c16c0a0e2464..6c4ffc767b91 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -522,7 +522,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		break;
 	case SHN_ABS:
 		/* CRC'd symbol */
-		if (memcmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
+		if (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
 			crc = (unsigned int) sym->st_value;
 			sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
 					export);
@@ -566,7 +566,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		break;
 	default:
 		/* All exported symbols */
-		if (memcmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
+		if (strncmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
 			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod,
 					export);
 		}

commit a8773769d1a1e08d0ca15f890515401ab3860637
Author: Wenji Huang <wenji.huang@oracle.com>
Date:   Mon Nov 16 13:49:55 2009 +0800

    Kbuild: clear marker out of modpost
    
    Remove the unnecessary functions and variables.
    
    Signed-off-by: Wenji Huang <wenji.huang@oracle.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index fb0f9b711af3..c16c0a0e2464 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -460,8 +460,6 @@ static int parse_elf(struct elf_info *info, const char *filename)
 			info->export_unused_gpl_sec = i;
 		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
 			info->export_gpl_future_sec = i;
-		else if (strcmp(secname, "__markers_strings") == 0)
-			info->markers_strings_sec = i;
 
 		if (sechdrs[i].sh_type != SHT_SYMTAB)
 			continue;
@@ -1518,62 +1516,6 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	}
 }
 
-static void get_markers(struct elf_info *info, struct module *mod)
-{
-	const Elf_Shdr *sh = &info->sechdrs[info->markers_strings_sec];
-	const char *strings = (const char *) info->hdr + sh->sh_offset;
-	const Elf_Sym *sym, *first_sym, *last_sym;
-	size_t n;
-
-	if (!info->markers_strings_sec)
-		return;
-
-	/*
-	 * First count the strings.  We look for all the symbols defined
-	 * in the __markers_strings section named __mstrtab_*.  For
-	 * these local names, the compiler puts a random .NNN suffix on,
-	 * so the names don't correspond exactly.
-	 */
-	first_sym = last_sym = NULL;
-	n = 0;
-	for (sym = info->symtab_start; sym < info->symtab_stop; sym++)
-		if (ELF_ST_TYPE(sym->st_info) == STT_OBJECT &&
-		    sym->st_shndx == info->markers_strings_sec &&
-		    !strncmp(info->strtab + sym->st_name,
-			     "__mstrtab_", sizeof "__mstrtab_" - 1)) {
-			if (first_sym == NULL)
-				first_sym = sym;
-			last_sym = sym;
-			++n;
-		}
-
-	if (n == 0)
-		return;
-
-	/*
-	 * Now collect each name and format into a line for the output.
-	 * Lines look like:
-	 *	marker_name	vmlinux	marker %s format %d
-	 * The format string after the second \t can use whitespace.
-	 */
-	mod->markers = NOFAIL(malloc(sizeof mod->markers[0] * n));
-	mod->nmarkers = n;
-
-	n = 0;
-	for (sym = first_sym; sym <= last_sym; sym++)
-		if (ELF_ST_TYPE(sym->st_info) == STT_OBJECT &&
-		    sym->st_shndx == info->markers_strings_sec &&
-		    !strncmp(info->strtab + sym->st_name,
-			     "__mstrtab_", sizeof "__mstrtab_" - 1)) {
-			const char *name = strings + sym->st_value;
-			const char *fmt = strchr(name, '\0') + 1;
-			char *line = NULL;
-			asprintf(&line, "%s\t%s\t%s\n", name, mod->name, fmt);
-			NOFAIL(line);
-			mod->markers[n++] = line;
-		}
-}
-
 static void read_symbols(char *modname)
 {
 	const char *symname;
@@ -1629,8 +1571,6 @@ static void read_symbols(char *modname)
 		get_src_version(modname, mod->srcversion,
 				sizeof(mod->srcversion)-1);
 
-	get_markers(&info, mod);
-
 	parse_elf_finish(&info);
 
 	/* Our trick to get versioning for module struct etc. - it's
@@ -1985,96 +1925,6 @@ static void write_dump(const char *fname)
 	write_if_changed(&buf, fname);
 }
 
-static void add_marker(struct module *mod, const char *name, const char *fmt)
-{
-	char *line = NULL;
-	asprintf(&line, "%s\t%s\t%s\n", name, mod->name, fmt);
-	NOFAIL(line);
-
-	mod->markers = NOFAIL(realloc(mod->markers, ((mod->nmarkers + 1) *
-						     sizeof mod->markers[0])));
-	mod->markers[mod->nmarkers++] = line;
-}
-
-static void read_markers(const char *fname)
-{
-	unsigned long size, pos = 0;
-	void *file = grab_file(fname, &size);
-	char *line;
-
-	if (!file)		/* No old markers, silently ignore */
-		return;
-
-	while ((line = get_next_line(&pos, file, size))) {
-		char *marker, *modname, *fmt;
-		struct module *mod;
-
-		marker = line;
-		modname = strchr(marker, '\t');
-		if (!modname)
-			goto fail;
-		*modname++ = '\0';
-		fmt = strchr(modname, '\t');
-		if (!fmt)
-			goto fail;
-		*fmt++ = '\0';
-		if (*marker == '\0' || *modname == '\0')
-			goto fail;
-
-		mod = find_module(modname);
-		if (!mod) {
-			mod = new_module(modname);
-			mod->skip = 1;
-		}
-		if (is_vmlinux(modname)) {
-			have_vmlinux = 1;
-			mod->skip = 0;
-		}
-
-		if (!mod->skip)
-			add_marker(mod, marker, fmt);
-	}
-	release_file(file, size);
-	return;
-fail:
-	fatal("parse error in markers list file\n");
-}
-
-static int compare_strings(const void *a, const void *b)
-{
-	return strcmp(*(const char **) a, *(const char **) b);
-}
-
-static void write_markers(const char *fname)
-{
-	struct buffer buf = { };
-	struct module *mod;
-	size_t i;
-
-	for (mod = modules; mod; mod = mod->next)
-		if ((!external_module || !mod->skip) && mod->markers != NULL) {
-			/*
-			 * Sort the strings so we can skip duplicates when
-			 * we write them out.
-			 */
-			qsort(mod->markers, mod->nmarkers,
-			      sizeof mod->markers[0], &compare_strings);
-			for (i = 0; i < mod->nmarkers; ++i) {
-				char *line = mod->markers[i];
-				buf_write(&buf, line, strlen(line));
-				while (i + 1 < mod->nmarkers &&
-				       !strcmp(mod->markers[i],
-					       mod->markers[i + 1]))
-					free(mod->markers[i++]);
-				free(mod->markers[i]);
-			}
-			free(mod->markers);
-			mod->markers = NULL;
-		}
-
-	write_if_changed(&buf, fname);
-}
-
 struct ext_sym_list {
 	struct ext_sym_list *next;
 	const char *file;
@@ -2086,8 +1936,6 @@ int main(int argc, char **argv)
 	struct buffer buf = { };
 	char *kernel_read = NULL, *module_read = NULL;
 	char *dump_write = NULL;
-	char *markers_read = NULL;
-	char *markers_write = NULL;
 	int opt;
 	int err;
 	struct ext_sym_list *extsym_iter;
@@ -2131,12 +1979,6 @@ int main(int argc, char **argv)
 		case 'w':
 			warn_unresolved = 1;
 			break;
-			case 'M':
-				markers_write = optarg;
-				break;
-			case 'K':
-				markers_read = optarg;
-				break;
 		default:
 			exit(1);
 		}
@@ -2191,11 +2033,5 @@ int main(int argc, char **argv)
 		     "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
 		     sec_mismatch_count);
 
-	if (markers_read)
-		read_markers(markers_read);
-
-	if (markers_write)
-		write_markers(markers_write);
-
 	return err;
 }

commit 9e1b9b80721661bd63b3662453767b22cd614fe7
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Sat Nov 7 21:03:54 2009 +0000

    module: make MODULE_SYMBOL_PREFIX into a CONFIG option
    
    The next commit will require the use of MODULE_SYMBOL_PREFIX in
    .tmp_exports-asm.S.  Currently it is mixed in with C structure
    definitions in "asm/module.h".  Move the definition of this arch option
    into Kconfig, so it can be easily accessed by any code.
    
    This also lets modpost.c use the same definition.  Previously modpost
    relied on a hardcoded list of architectures in mk_elfconfig.c.
    
    A build test for blackfin, one of the two MODULE_SYMBOL_PREFIX archs,
    showed the generated code was unchanged.  vmlinux was identical save
    for build ids, and an apparently randomized suffix on a single "__key"
    symbol in the kallsyms data).
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Acked-by: Mike Frysinger <vapier@gentoo.org> (blackfin)
    CC: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 801a16a17545..fb0f9b711af3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -15,8 +15,17 @@
 #include <stdio.h>
 #include <ctype.h>
 #include "modpost.h"
+#include "../../include/linux/autoconf.h"
 #include "../../include/linux/license.h"
 
+/* Some toolchains use a `_' prefix for all user symbols. */
+#ifdef CONFIG_SYMBOL_PREFIX
+#define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
+#else
+#define MODULE_SYMBOL_PREFIX ""
+#endif
+
+
 /* Are we using CONFIG_MODVERSIONS? */
 int modversions = 0;
 /* Warn about undefined symbols? (do so if we have vmlinux) */

commit 5c725138437837291db5c25f4a076ee852e806e3
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Tue Sep 22 16:43:38 2009 -0700

    Fix all -Wmissing-prototypes warnings in x86 defconfig
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4522948a012e..801a16a17545 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -691,7 +691,7 @@ static int number_prefix(const char *sym)
  *   The $ syntax is for sections where ld append a dot number
  *   to make section name unique.
  */
-int match(const char *sym, const char * const pat[])
+static int match(const char *sym, const char * const pat[])
 {
 	const char *p;
 	while (*pat) {
@@ -1746,7 +1746,7 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "};\n");
 }
 
-void add_staging_flag(struct buffer *b, const char *name)
+static void add_staging_flag(struct buffer *b, const char *name)
 {
 	static const char *staging_dir = "drivers/staging";
 

commit 8b8b76c045beb85c1c2b28e07eff6599a1e95cf1
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jun 6 00:18:05 2009 +0200

    kbuild: add hint about __refdata to modpost
    
    As requested by Guennadi Liakhovetski
    
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 94e71efb2c14..4522948a012e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1196,7 +1196,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		"The variable %s references\n"
 		"the %s %s%s%s\n"
 		"If the reference is valid then annotate the\n"
-		"variable with __init* (see linux/init.h) "
+		"variable with __init* or __refdata (see linux/init.h) "
 		"or name the variable:\n",
 		fromsym, to, sec2annotation(tosec), tosym, to_p);
 		while (*s)

commit fd6c3a8dc44329d3aff9a578b5120982f63711ee
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Mar 12 10:58:33 2009 +0000

    initconst adjustments
    
    - add .init.rodata to INIT_DATA, and group all initconst flavors
      together
    - move strings generated from __setup_param() into .init.rodata
    - add .*init.rodata to modpost's sets of init sections
    - make modpost warn about references between meminit and cpuinit
      as well as memexit and cpuexit sections (as CPU and memory
      hotplug are independently selectable features)
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 161b7846733e..94e71efb2c14 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -763,6 +763,8 @@ static void check_section(const char *modname, struct elf_info *elf,
 
 
 #define ALL_INIT_DATA_SECTIONS \
+	".init.setup$", ".init.rodata$", \
+	".devinit.rodata$", ".cpuinit.rodata$", ".meminit.rodata$" \
 	".init.data$", ".devinit.data$", ".cpuinit.data$", ".meminit.data$"
 #define ALL_EXIT_DATA_SECTIONS \
 	".exit.data$", ".devexit.data$", ".cpuexit.data$", ".memexit.data$"
@@ -772,21 +774,23 @@ static void check_section(const char *modname, struct elf_info *elf,
 #define ALL_EXIT_TEXT_SECTIONS \
 	".exit.text$", ".devexit.text$", ".cpuexit.text$", ".memexit.text$"
 
-#define ALL_INIT_SECTIONS ALL_INIT_DATA_SECTIONS, ALL_INIT_TEXT_SECTIONS
-#define ALL_EXIT_SECTIONS ALL_EXIT_DATA_SECTIONS, ALL_EXIT_TEXT_SECTIONS
+#define ALL_INIT_SECTIONS INIT_SECTIONS, DEV_INIT_SECTIONS, \
+	CPU_INIT_SECTIONS, MEM_INIT_SECTIONS
+#define ALL_EXIT_SECTIONS EXIT_SECTIONS, DEV_EXIT_SECTIONS, \
+	CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS
 
 #define DATA_SECTIONS ".data$", ".data.rel$"
 #define TEXT_SECTIONS ".text$"
 
-#define INIT_SECTIONS      ".init.data$", ".init.text$"
-#define DEV_INIT_SECTIONS  ".devinit.data$", ".devinit.text$"
-#define CPU_INIT_SECTIONS  ".cpuinit.data$", ".cpuinit.text$"
-#define MEM_INIT_SECTIONS  ".meminit.data$", ".meminit.text$"
+#define INIT_SECTIONS      ".init.*"
+#define DEV_INIT_SECTIONS  ".devinit.*"
+#define CPU_INIT_SECTIONS  ".cpuinit.*"
+#define MEM_INIT_SECTIONS  ".meminit.*"
 
-#define EXIT_SECTIONS      ".exit.data$", ".exit.text$"
-#define DEV_EXIT_SECTIONS  ".devexit.data$", ".devexit.text$"
-#define CPU_EXIT_SECTIONS  ".cpuexit.data$", ".cpuexit.text$"
-#define MEM_EXIT_SECTIONS  ".memexit.data$", ".memexit.text$"
+#define EXIT_SECTIONS      ".exit.*"
+#define DEV_EXIT_SECTIONS  ".devexit.*"
+#define CPU_EXIT_SECTIONS  ".cpuexit.*"
+#define MEM_EXIT_SECTIONS  ".memexit.*"
 
 /* init data sections */
 static const char *init_data_sections[] = { ALL_INIT_DATA_SECTIONS, NULL };
@@ -869,12 +873,36 @@ const struct sectioncheck sectioncheck[] = {
 	.tosec   = { INIT_SECTIONS, NULL },
 	.mismatch = XXXINIT_TO_INIT,
 },
+/* Do not reference cpuinit code/data from meminit code/data */
+{
+	.fromsec = { MEM_INIT_SECTIONS, NULL },
+	.tosec   = { CPU_INIT_SECTIONS, NULL },
+	.mismatch = XXXINIT_TO_INIT,
+},
+/* Do not reference meminit code/data from cpuinit code/data */
+{
+	.fromsec = { CPU_INIT_SECTIONS, NULL },
+	.tosec   = { MEM_INIT_SECTIONS, NULL },
+	.mismatch = XXXINIT_TO_INIT,
+},
 /* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
 {
 	.fromsec = { DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS, NULL },
 	.tosec   = { EXIT_SECTIONS, NULL },
 	.mismatch = XXXEXIT_TO_EXIT,
 },
+/* Do not reference cpuexit code/data from memexit code/data */
+{
+	.fromsec = { MEM_EXIT_SECTIONS, NULL },
+	.tosec   = { CPU_EXIT_SECTIONS, NULL },
+	.mismatch = XXXEXIT_TO_EXIT,
+},
+/* Do not reference memexit code/data from cpuexit code/data */
+{
+	.fromsec = { CPU_EXIT_SECTIONS, NULL },
+	.tosec   = { MEM_EXIT_SECTIONS, NULL },
+	.mismatch = XXXEXIT_TO_EXIT,
+},
 /* Do not use exit code/data from init code */
 {
 	.fromsec = { ALL_INIT_SECTIONS, NULL },

commit 4391ed6aa9a38cdfb48addd7a9b24a2ff099b1a7
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon May 4 13:05:26 2009 +0200

    kbuild, modpost: fix unexpected non-allocatable warning with mips
    
    mips emit the following debug sections:
    .mdebug* and .pdr
    
    They were included in the check for non-allocatable section
    and caused modpost to warn.
    
    Manuel Lauss suggested to fix this by adding the relevant
    sections to the list of sections we do not check.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reported-by: Manuel Lauss <mano@roarinelk.homelinux.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 268d4571664d..161b7846733e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -727,7 +727,17 @@ int match(const char *sym, const char * const pat[])
 
 /* sections that we do not want to do full section mismatch check on */
 static const char *section_white_list[] =
-	{ ".comment*", ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
+{
+	".comment*",
+	".debug*",
+	".mdebug*",        /* alpha, score, mips etc. */
+	".pdr",            /* alpha, score, mips etc. */
+	".stab*",
+	".note*",
+	".got*",
+	".toc*",
+	NULL
+};
 
 /*
  * This is used to find sections missing the SHF_ALLOC flag.

commit 028ecebdd83cc4a7f8c7e96e28a5537d2ac98dae
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun May 3 22:17:37 2009 +0200

    kbuild, modpost: fix "unexpected non-allocatable" warning with SUSE gcc
    
    Jean reported that he saw one warning for each module like the one below:
    WARNING: arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.o (.comment.SUSE.OPTs): unexpected non-allocatable section.
    
    The warning appeared with the improved version of the
    check of the flags in the sections.
    
    That check already ignored sections named ".comment" - but SUSE store
    additional info in the comment section and has named it in a SUSE
    specific way. Therefore modpost failed to ignore the section.
    
    The fix is to extend the pattern so we ignore all sections
    that start with the name ".comment.".
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Reported-by: Jean Delvare <khali@linux-fr.org>
    Tested-by: Jean Delvare <khali@linux-fr.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a5c17db14ee5..268d4571664d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -727,7 +727,7 @@ int match(const char *sym, const char * const pat[])
 
 /* sections that we do not want to do full section mismatch check on */
 static const char *section_white_list[] =
-	{ ".comment", ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
+	{ ".comment*", ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
 
 /*
  * This is used to find sections missing the SHF_ALLOC flag.

commit 7d875a02864a35532543897195dfea2235815df8
Author: Anders Kaseorg <andersk@MIT.EDU>
Date:   Sun May 3 22:02:55 2009 +0200

    kbuild, modpost: fix unexpected non-allocatable section when cross compiling
    
    The missing TO_NATIVE(sechdrs[i].sh_flags) was causing many
    unexpected non-allocatable section warnings when cross-compiling
    for an architecture with a different endianness.
    
    Fix endianness of all the fields in the ELF header and
    section headers, not just some of them so we are not
    hit by this anohter time.
    
    Signed-off-by: Anders Kaseorg <andersk@mit.edu>
    Reported-by: Sean MacLennan <smaclennan@pikatech.com>
    Tested-by: Sean MacLennan <smaclennan@pikatech.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 936b6f8e46ff..a5c17db14ee5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -384,11 +384,19 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		return 0;
 	}
 	/* Fix endianness in ELF header */
-	hdr->e_shoff    = TO_NATIVE(hdr->e_shoff);
-	hdr->e_shstrndx = TO_NATIVE(hdr->e_shstrndx);
-	hdr->e_shnum    = TO_NATIVE(hdr->e_shnum);
-	hdr->e_machine  = TO_NATIVE(hdr->e_machine);
-	hdr->e_type     = TO_NATIVE(hdr->e_type);
+	hdr->e_type      = TO_NATIVE(hdr->e_type);
+	hdr->e_machine   = TO_NATIVE(hdr->e_machine);
+	hdr->e_version   = TO_NATIVE(hdr->e_version);
+	hdr->e_entry     = TO_NATIVE(hdr->e_entry);
+	hdr->e_phoff     = TO_NATIVE(hdr->e_phoff);
+	hdr->e_shoff     = TO_NATIVE(hdr->e_shoff);
+	hdr->e_flags     = TO_NATIVE(hdr->e_flags);
+	hdr->e_ehsize    = TO_NATIVE(hdr->e_ehsize);
+	hdr->e_phentsize = TO_NATIVE(hdr->e_phentsize);
+	hdr->e_phnum     = TO_NATIVE(hdr->e_phnum);
+	hdr->e_shentsize = TO_NATIVE(hdr->e_shentsize);
+	hdr->e_shnum     = TO_NATIVE(hdr->e_shnum);
+	hdr->e_shstrndx  = TO_NATIVE(hdr->e_shstrndx);
 	sechdrs = (void *)hdr + hdr->e_shoff;
 	info->sechdrs = sechdrs;
 
@@ -402,13 +410,16 @@ static int parse_elf(struct elf_info *info, const char *filename)
 
 	/* Fix endianness in section headers */
 	for (i = 0; i < hdr->e_shnum; i++) {
-		sechdrs[i].sh_type   = TO_NATIVE(sechdrs[i].sh_type);
-		sechdrs[i].sh_offset = TO_NATIVE(sechdrs[i].sh_offset);
-		sechdrs[i].sh_size   = TO_NATIVE(sechdrs[i].sh_size);
-		sechdrs[i].sh_link   = TO_NATIVE(sechdrs[i].sh_link);
-		sechdrs[i].sh_name   = TO_NATIVE(sechdrs[i].sh_name);
-		sechdrs[i].sh_info   = TO_NATIVE(sechdrs[i].sh_info);
-		sechdrs[i].sh_addr   = TO_NATIVE(sechdrs[i].sh_addr);
+		sechdrs[i].sh_name      = TO_NATIVE(sechdrs[i].sh_name);
+		sechdrs[i].sh_type      = TO_NATIVE(sechdrs[i].sh_type);
+		sechdrs[i].sh_flags     = TO_NATIVE(sechdrs[i].sh_flags);
+		sechdrs[i].sh_addr      = TO_NATIVE(sechdrs[i].sh_addr);
+		sechdrs[i].sh_offset    = TO_NATIVE(sechdrs[i].sh_offset);
+		sechdrs[i].sh_size      = TO_NATIVE(sechdrs[i].sh_size);
+		sechdrs[i].sh_link      = TO_NATIVE(sechdrs[i].sh_link);
+		sechdrs[i].sh_info      = TO_NATIVE(sechdrs[i].sh_info);
+		sechdrs[i].sh_addralign = TO_NATIVE(sechdrs[i].sh_addralign);
+		sechdrs[i].sh_entsize   = TO_NATIVE(sechdrs[i].sh_entsize);
 	}
 	/* Find symbol table. */
 	for (i = 1; i < hdr->e_shnum; i++) {

commit b614a697dc17dff82f140d72d21a095f810fa7fb
Author: Anders Kaseorg <andersk@mit.edu>
Date:   Thu Apr 23 16:49:33 2009 -0400

    kbuild, modpost: Check the section flags, to catch missing "ax"/"aw"
    
    When you put
      .section ".foo"
    in an assembly file instead of
      .section "foo", "ax"
    , one of the possible symptoms is that modpost will see an
    ld-generated section name ".foo.1" in section_rel() or section_rela().
    But this heuristic has two problems: it will miss a bad section that
    has no relocations, and it will incorrectly flag many gcc-generated
    sections as bad when compiling with -ffunction-sections
    -fdata-sections.
    
    On mips it fixes a lot of bogus warnings with gcc 4.4.0 lije this one:
    WARNING: crypto/cryptd.o (.text.T.349): unexpected section name.
    
    So instead of checking whether the section name matches a particular
    pattern, we directly check for a missing SHF_ALLOC in the section
    flags.
    
    Signed-off-by: Anders Kaseorg <andersk@mit.edu>
    Tested-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e5ae695458eb..936b6f8e46ff 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -716,41 +716,27 @@ int match(const char *sym, const char * const pat[])
 
 /* sections that we do not want to do full section mismatch check on */
 static const char *section_white_list[] =
-	{ ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
+	{ ".comment", ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
 
 /*
- * Is this section one we do not want to check?
- * This is often debug sections.
- * If we are going to check this section then
- * test if section name ends with a dot and a number.
- * This is used to find sections where the linker have
- * appended a dot-number to make the name unique.
+ * This is used to find sections missing the SHF_ALLOC flag.
  * The cause of this is often a section specified in assembler
- * without "ax" / "aw" and the same section used in .c
- * code where gcc add these.
+ * without "ax" / "aw".
  */
-static int check_section(const char *modname, const char *sec)
-{
-	const char *e = sec + strlen(sec) - 1;
-	if (match(sec, section_white_list))
-		return 1;
-
-	if (*e && isdigit(*e)) {
-		/* consume all digits */
-		while (*e && e != sec && isdigit(*e))
-			e--;
-		if (*e == '.' && !strstr(sec, ".linkonce")) {
-			warn("%s (%s): unexpected section name.\n"
-			     "The (.[number]+) following section name are "
-			     "ld generated and not expected.\n"
-			     "Did you forget to use \"ax\"/\"aw\" "
-			     "in a .S file?\n"
-			     "Note that for example <linux/init.h> contains\n"
-			     "section definitions for use in .S files.\n\n",
-			     modname, sec);
-		}
+static void check_section(const char *modname, struct elf_info *elf,
+                          Elf_Shdr *sechdr)
+{
+	const char *sec = sech_name(elf, sechdr);
+
+	if (sechdr->sh_type == SHT_PROGBITS &&
+	    !(sechdr->sh_flags & SHF_ALLOC) &&
+	    !match(sec, section_white_list)) {
+		warn("%s (%s): unexpected non-allocatable section.\n"
+		     "Did you forget to use \"ax\"/\"aw\" in a .S file?\n"
+		     "Note that for example <linux/init.h> contains\n"
+		     "section definitions for use in .S files.\n\n",
+		     modname, sec);
 	}
-	return 0;
 }
 
 
@@ -1358,7 +1344,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	fromsec = sech_name(elf, sechdr);
 	fromsec += strlen(".rela");
 	/* if from section (name) is know good then skip it */
-	if (check_section(modname, fromsec))
+	if (match(fromsec, section_white_list))
 		return;
 
 	for (rela = start; rela < stop; rela++) {
@@ -1402,7 +1388,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 	fromsec = sech_name(elf, sechdr);
 	fromsec += strlen(".rel");
 	/* if from section (name) is know good then skip it */
-	if (check_section(modname, fromsec))
+	if (match(fromsec, section_white_list))
 		return;
 
 	for (rel = start; rel < stop; rel++) {
@@ -1465,6 +1451,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 
 	/* Walk through all sections */
 	for (i = 0; i < elf->hdr->e_shnum; i++) {
+		check_section(modname, elf, &elf->sechdrs[i]);
 		/* We want to process only relocation sections and not .init */
 		if (sechdrs[i].sh_type == SHT_RELA)
 			section_rela(modname, elf, &elf->sechdrs[i]);

commit c993971f4a7dc7ae43963aecb958395353c109ae
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Apr 26 11:17:42 2009 +0200

    kbuild: fix comment in modpost.c
    
    There is some confusion on naming of the head section.
    Correct naming is .head.text.
    
    Fix comment so we use correct naming.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 57d71a5f31b6..e5ae695458eb 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -928,8 +928,7 @@ static int section_mismatch(const char *fromsec, const char *tosec)
  *           *probe_one, *_console, *_timer
  *
  * Pattern 3:
- *   Whitelist all refereces from .text.head to .init.data
- *   Whitelist all refereces from .text.head to .init.text
+ *   Whitelist all references from .head.text to any init section
  *
  * Pattern 4:
  *   Some symbols belong to init section but still it is ok to reference

commit 99e3a1eb3c22bb671c6f3d22d8244bfc9fad8185
Author: Cedric Hombourger <chombourger@gmail.com>
Date:   Sat Apr 25 09:38:21 2009 +0200

    kbuild: fix Module.markers permission error under cygwin
    
    While building the kernel, we end-up calling modpost with -K and -M
    options for the same file (Modules.markers).  This is resulting in
    modpost's main function calling read_markers() and then write_markers() on
    the same file.
    
    We then have read_markers() mmap'ing the file, and writer_markers()
    opening that same file for writing.
    
    The issue is that read_markers() exits without munmap'ing the file and is
    as a matter holding a reference on Modules.markers.  When write_markers()
    is opening that very same file for writing, we still have a reference on
    it and cygwin (Windows?) is then making fopen() fail with EPERM.
    
    Calling release_file() before exiting read_markers() clears that reference
    (and memory leak) and fopen() then succeeds.
    
    Tested on both cygwin (1.3.22) and Linux.  Also ran modpost within
    valgrind on Linux to make sure that the munmap'ed file was not accessed
    after read_markers()
    
    Signed-off-by: Cedric Hombourger <chombourger@gmail.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8d46ea7d6715..57d71a5f31b6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1990,6 +1990,7 @@ static void read_markers(const char *fname)
 		if (!mod->skip)
 			add_marker(mod, marker, fmt);
 	}
+	release_file(file, size);
 	return;
 fail:
 	fatal("parse error in markers list file\n");

commit 27b1833279995e7c290a40cac4ef36ccea7e9283
Author: Tim Abbott <tabbott@MIT.EDU>
Date:   Mon Apr 27 14:02:27 2009 -0400

    Remove unused support code for refok sections.
    
    The old refok sections
    
      .text.init.refok
      .data.init.refok
      .exit.text.refok
    
    have been deprecated since commit
    312b1485fb509c9bc32eda28ad29537896658cb8.  After the other patches in
    this patch series nothing is put in these sections, so clean things up
    by eliminating all the remaining references to them.
    
    Signed-off-by: Tim Abbott <tabbott@mit.edu>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index df6e6286a065..8d46ea7d6715 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -794,15 +794,6 @@ static const char *init_exit_sections[] =
 /* data section */
 static const char *data_sections[] = { DATA_SECTIONS, NULL };
 
-/* sections that may refer to an init/exit section with no warning */
-static const char *initref_sections[] =
-{
-	".text.init.refok*",
-	".exit.text.refok*",
-	".data.init.refok*",
-	NULL
-};
-
 
 /* symbols in .data that may refer to init/exit sections */
 static const char *symbol_white_list[] =
@@ -915,11 +906,6 @@ static int section_mismatch(const char *fromsec, const char *tosec)
 /**
  * Whitelist to allow certain references to pass with no warning.
  *
- * Pattern 0:
- *   Do not warn if funtion/data are marked with __init_refok/__initdata_refok.
- *   The pattern is identified by:
- *   fromsec = .text.init.refok* | .data.init.refok*
- *
  * Pattern 1:
  *   If a module parameter is declared __initdata and permissions=0
  *   then this is legal despite the warning generated.
@@ -958,10 +944,6 @@ static int section_mismatch(const char *fromsec, const char *tosec)
 static int secref_whitelist(const char *fromsec, const char *fromsym,
 			    const char *tosec, const char *tosym)
 {
-	/* Check for pattern 0 */
-	if (match(fromsec, initref_sections))
-		return 0;
-
 	/* Check for pattern 1 */
 	if (match(tosec, init_data_sections) &&
 	    match(fromsec, data_sections) &&

commit 0fa3a88cfdfc910d7f335aef588edf9819c05d54
Author: Jan Beulich <jbeulich@novell.com>
Date:   Thu Mar 12 12:28:30 2009 +0000

    kbuild: remove pointless strdup() on arguments passed to new_module() in modpost
    
    new_module() itself already calls strdup() on its modname parameter.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8cc70612984c..df6e6286a065 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1913,7 +1913,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		if (!mod) {
 			if (is_vmlinux(modname))
 				have_vmlinux = 1;
-			mod = new_module(NOFAIL(strdup(modname)));
+			mod = new_module(modname);
 			mod->skip = 1;
 		}
 		s = sym_add_exported(symname, mod, export_no(export));
@@ -1997,7 +1997,7 @@ static void read_markers(const char *fname)
 
 		mod = find_module(modname);
 		if (!mod) {
-			mod = new_module(NOFAIL(strdup(modname)));
+			mod = new_module(modname);
 			mod->skip = 1;
 		}
 		if (is_vmlinux(modname)) {

commit 8c8ef42aee8fcfb4128bb94c50d55c9f80ade525
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Tue Mar 31 13:05:34 2009 -0600

    module: include other structures in module version check
    
    With CONFIG_MODVERSIONS, we version 'struct module' using a dummy
    export, but other things matter too:
    
    1) 'struct modversion_info' determines the layout of the __versions section,
    2) 'struct kernel_param' determines the layout of the __params section,
    3) 'struct kernel_symbol' determines __ksymtab*.
    4) 'struct marker' determines __markers.
    5) 'struct tracepoint' determines __tracepoints.
    
    So we rename 'struct_module' to 'module_layout' and include these in
    the signature.  Now it's general we can add others later on without
    confusion.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7e62303133dc..8cc70612984c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1607,12 +1607,12 @@ static void read_symbols(char *modname)
 
 	parse_elf_finish(&info);
 
-	/* Our trick to get versioning for struct_module - it's
+	/* Our trick to get versioning for module struct etc. - it's
 	 * never passed as an argument to an exported function, so
 	 * the automatic versioning doesn't pick it up, but it's really
 	 * important anyhow */
 	if (modversions)
-		mod->unres = alloc_symbol("struct_module", 0, mod->unres);
+		mod->unres = alloc_symbol("module_layout", 0, mod->unres);
 }
 
 #define SZ 500

commit 56fc82c5360cdf0b250b5eb74f38657b0402faa5
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Feb 6 00:48:02 2009 +0900

    modpost: NOBITS sections may point beyond the end of the file
    
    Impact: fix link failure on certain toolchains with specific configs
    
    Recent percpu change made x86_64 split .data.init section into three
    separate segments - data.init, percpu and data.init2.  data.init2 gets
    .data.nosave and .bss.* and is followed by .notes segment.  Depending
    on configuration both segments might contain no data, in which case
    the tool chain makes the section header to contain offset beyond the
    end of the file.
    
    modpost isn't too happy about it and fails build - as reported by
    Pawel Dziekonski:
    
        Building modules, stage 2.
        MODPOST 416 modules
        FATAL: vmlinux is truncated. sechdrs[i].sh_offset=10354688 >
        sizeof(*hrd)=64
        make[1]: *** [__modpost] Error 1
    
    Teach modpost that NOBITS section may point beyond the end of the file
    and that .modinfo can't be NOBITS.
    
    Reported-by: Pawel Dziekonski <dzieko@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 88921611b22e..7e62303133dc 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -415,8 +415,9 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		const char *secstrings
 			= (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
 		const char *secname;
+		int nobits = sechdrs[i].sh_type == SHT_NOBITS;
 
-		if (sechdrs[i].sh_offset > info->size) {
+		if (!nobits && sechdrs[i].sh_offset > info->size) {
 			fatal("%s is truncated. sechdrs[i].sh_offset=%lu > "
 			      "sizeof(*hrd)=%zu\n", filename,
 			      (unsigned long)sechdrs[i].sh_offset,
@@ -425,6 +426,8 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		}
 		secname = secstrings + sechdrs[i].sh_name;
 		if (strcmp(secname, ".modinfo") == 0) {
+			if (nobits)
+				fatal("%s has NOBITS .modinfo\n", filename);
 			info->modinfo = (void *)hdr + sechdrs[i].sh_offset;
 			info->modinfo_len = sechdrs[i].sh_size;
 		} else if (strcmp(secname, "__ksymtab") == 0)

commit a9860bf05f4cb94f60f8f3459908d5621f75dd06
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Sep 24 14:46:44 2008 -0700

    Staging: add TAINT_CRAP flag to drivers/staging modules
    
    We need to add a flag for all code that is in the drivers/staging/
    directory to prevent all other kernel developers from worrying about
    issues here, and to notify users that the drivers might not be as good
    as they are normally used to.
    
    Based on code from Andreas Gruenbacher and Jeff Mahoney to provide a
    TAINT flag for the support level of a kernel module in the Novell
    enterprise kernel release.
    
    This is the code that actually modifies the modules, adding the flag to
    any files in the drivers/staging directory.
    
    Cc: Andreas Gruenbacher <agruen@suse.de>
    Cc: Jeff Mahoney <jeffm@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8e0de6a5e18a..88921611b22e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1726,6 +1726,14 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "};\n");
 }
 
+void add_staging_flag(struct buffer *b, const char *name)
+{
+	static const char *staging_dir = "drivers/staging";
+
+	if (strncmp(staging_dir, name, strlen(staging_dir)) == 0)
+		buf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");
+}
+
 /**
  * Record CRCs for unresolved symbols
  **/
@@ -2135,6 +2143,7 @@ int main(int argc, char **argv)
 		buf.pos = 0;
 
 		add_header(&buf, mod);
+		add_staging_flag(&buf, mod->name);
 		err |= add_versions(&buf, mod);
 		add_depends(&buf, mod, modules);
 		add_moddevtable(&buf, mod);

commit 87f3b6b6fbcbfa715f0d0db3e7a63e65716a6d4e
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Mon Oct 6 09:30:12 2008 -0400

    Marker depmod fix core kernel list
    
    * Theodore Ts'o (tytso@mit.edu) wrote:
    >
    > I've been playing with adding some markers into ext4 to see if they
    > could be useful in solving some problems along with Systemtap.  It
    > appears, though, that as of 2.6.27-rc8, markers defined in code which is
    > compiled directly into the kernel (i.e., not as modules) don't show up
    > in Module.markers:
    >
    > kvm_trace_entryexit arch/x86/kvm/kvm-intel  %u %p %u %u %u %u %u %u
    > kvm_trace_handler arch/x86/kvm/kvm-intel  %u %p %u %u %u %u %u %u
    > kvm_trace_entryexit arch/x86/kvm/kvm-amd  %u %p %u %u %u %u %u %u
    > kvm_trace_handler arch/x86/kvm/kvm-amd  %u %p %u %u %u %u %u %u
    >
    > (Note the lack of any of the kernel_sched_* markers, and the markers I
    > added for ext4_* and jbd2_* are missing as wel.)
    >
    > Systemtap apparently depends on in-kernel trace_mark being recorded in
    > Module.markers, and apparently it's been claimed that it used to be
    > there.  Is this a bug in systemtap, or in how Module.markers is getting
    > built?   And is there a file that contains the equivalent information
    > for markers located in non-modules code?
    
    I think the problem comes from "markers: fix duplicate modpost entry"
    (commit d35cb360c29956510b2fe1a953bd4968536f7216)
    
    Especially :
    
      -   add_marker(mod, marker, fmt);
      +   if (!mod->skip)
      +     add_marker(mod, marker, fmt);
        }
        return;
       fail:
    
    Here is a fix that should take care if this problem.
    
    Thanks for the bug report!
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Tested-by: "Theodore Ts'o" <tytso@mit.edu>
    CC: Greg KH <greg@kroah.com>
    CC: David Smith <dsmith@redhat.com>
    CC: Roland McGrath <roland@redhat.com>
    CC: Sam Ravnborg <sam@ravnborg.org>
    CC: Wenji Huang <wenji.huang@oracle.com>
    CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 418cd7dbbc93..8e0de6a5e18a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1986,11 +1986,13 @@ static void read_markers(const char *fname)
 
 		mod = find_module(modname);
 		if (!mod) {
-			if (is_vmlinux(modname))
-				have_vmlinux = 1;
 			mod = new_module(NOFAIL(strdup(modname)));
 			mod->skip = 1;
 		}
+		if (is_vmlinux(modname)) {
+			have_vmlinux = 1;
+			mod->skip = 0;
+		}
 
 		if (!mod->skip)
 			add_marker(mod, marker, fmt);

commit 32be1d22327743134974c7b2ec1e2a143b6b6f86
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Tue Jul 29 22:33:44 2008 -0700

    scripts/mod/modpost.c: fix spelling of module and happens
    
    Spelling fixes in scripts/mod/modpost.c
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8f038e6d5f98..418cd7dbbc93 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1468,7 +1468,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
  * marked __initdata will be discarded when the module has been intialized.
  * Likewise for modules used built-in the sections marked __exit
  * are discarded because __exit marked function are supposed to be called
- * only when a moduel is unloaded which never happes for built-in modules.
+ * only when a module is unloaded which never happens for built-in modules.
  * The check_sec_ref() function traverses all relocation records
  * to find all references to a section that reference a section that will
  * be discarded and warns about it.

commit d35cb360c29956510b2fe1a953bd4968536f7216
Author: Mathieu Desnoyers <compudj@krystal.dyndns.org>
Date:   Mon Jul 21 14:21:38 2008 -0700

    markers: fix duplicate modpost entry
    
    When a kernel was rebuilt, the previous Module.markers was not cleared.
    It caused markers with different format strings to appear as duplicates
    when a markers was changed.  This problem is present since
    scripts/mod/modpost.c started to generate Module.markers, commit
    b2e3e658b344c6bcfb8fb694100ab2f2b5b2edb0
    
    It therefore applies to 2.6.25, 2.6.26 and linux-next.
    
    I merely merged the patches from Roland, Wenji and Takashi here.
    
    Credits to
    Roland McGrath <roland@redhat.com>
    Wenji Huang <wenji.huang@oracle.com>
    and
    Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
    
    for providing the individual fixes.
    
    - Changelog :
      - Integrated Takashi's Makefile modification to clear Module.markers upon
        make clean.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Wenji Huang <wenji.huang@oracle.com>
    Cc: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
    Cc: <stable@kernel.org>         [2.6.25.x, 2.6.26.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a07f91aac920..8f038e6d5f98 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1992,7 +1992,8 @@ static void read_markers(const char *fname)
 			mod->skip = 1;
 		}
 
-		add_marker(mod, marker, fmt);
+		if (!mod->skip)
+			add_marker(mod, marker, fmt);
 	}
 	return;
 fail:

commit 4d7365d664e79710ac0e782a23443471ddf05bdd
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jun 12 15:02:55 2008 +0200

    kbuild: ignore powerpc specific symbols in modpost
    
    Kumar Gala <galak@kernel.crashing.org> wrote:
    We have a case in powerpc in which we want to link some library
    routines with all module objects.  The routines are intended for
    handling out-of-line function call register save/restore so having
    them as EXPORT_SYMBOL() is counter productive (we do also need to
    link the same "library" code into the kernel).
    
    Without this patch a powerpc build would error out and fail
    to build modules with the added register save/restore module.
    
    There were two obvious solutions:
    1) To link the .o file before the modpost stage
    2) To ignore the symbols in modpost
    
    Option 1) was ruled out because we do not have any separate
    linking stage for single file modules.
    
    This patch implements option 2 - and do so only for powerpc.
    
    The symbols we ignore are all undefined symbols named:
    _restgpr_*, _savegpr_*, _rest32gpr_*, _save32gpr_*
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Kumar Gala <galak@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 508c5895c680..a07f91aac920 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -467,6 +467,25 @@ static void parse_elf_finish(struct elf_info *info)
 	release_file(info->hdr, info->size);
 }
 
+static int ignore_undef_symbol(struct elf_info *info, const char *symname)
+{
+	/* ignore __this_module, it will be resolved shortly */
+	if (strcmp(symname, MODULE_SYMBOL_PREFIX "__this_module") == 0)
+		return 1;
+	/* ignore global offset table */
+	if (strcmp(symname, "_GLOBAL_OFFSET_TABLE_") == 0)
+		return 1;
+	if (info->hdr->e_machine == EM_PPC)
+		/* Special register function linked on all modules during final link of .ko */
+		if (strncmp(symname, "_restgpr_", sizeof("_restgpr_") - 1) == 0 ||
+		    strncmp(symname, "_savegpr_", sizeof("_savegpr_") - 1) == 0 ||
+		    strncmp(symname, "_rest32gpr_", sizeof("_rest32gpr_") - 1) == 0 ||
+		    strncmp(symname, "_save32gpr_", sizeof("_save32gpr_") - 1) == 0)
+			return 1;
+	/* Do not ignore this symbol */
+	return 0;
+}
+
 #define CRC_PFX     MODULE_SYMBOL_PREFIX "__crc_"
 #define KSYMTAB_PFX MODULE_SYMBOL_PREFIX "__ksymtab_"
 
@@ -493,11 +512,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		if (ELF_ST_BIND(sym->st_info) != STB_GLOBAL &&
 		    ELF_ST_BIND(sym->st_info) != STB_WEAK)
 			break;
-		/* ignore global offset table */
-		if (strcmp(symname, "_GLOBAL_OFFSET_TABLE_") == 0)
-			break;
-		/* ignore __this_module, it will be resolved shortly */
-		if (strcmp(symname, MODULE_SYMBOL_PREFIX "__this_module") == 0)
+		if (ignore_undef_symbol(info, symname))
 			break;
 /* cope with newer glibc (2.3.4 or higher) STT_ definition in elf.h */
 #if defined(STT_REGISTER) || defined(STT_SPARC_REGISTER)

commit fd1db0a31319bd21c521b197ce17c557556b821b
Author: Andi Kleen <andi@firstfloor.org>
Date:   Thu May 8 13:41:11 2008 +0200

    kbuild: disable modpost warnings for linkonce sections
    
    Disable modpost warnings for linkonce sections
    
    My build gives lots of warnings like
    
    WARNING: sound/core/snd.o (.gnu.linkonce.wi.mpspec_def.h.30779716): unexpected section name.
    The (.[number]+) following section name are ld generated and not expected.
    Did you forget to use "ax"/"aw" in a .S file?
    Note that for example <linux/init.h> contains
    section definitions for use in .S files.
    
    But for .linkonce. duplicated sections are actually ok and expected.
    So just disable the warning for this case.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 757294b4f322..508c5895c680 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -721,7 +721,7 @@ static int check_section(const char *modname, const char *sec)
 		/* consume all digits */
 		while (*e && e != sec && isdigit(*e))
 			e--;
-		if (*e == '.') {
+		if (*e == '.' && !strstr(sec, ".linkonce")) {
 			warn("%s (%s): unexpected section name.\n"
 			     "The (.[number]+) following section name are "
 			     "ld generated and not expected.\n"

commit 2fa365682943866baf85305ef701741fe41b27e0
Author: Sam Ravnborg <sam@uranus.ravnborg.org>
Date:   Sat Apr 26 21:07:26 2008 +0200

    kbuild: soften MODULE_LICENSE check
    
    Only modules that has other MODULE_* content
    shall have the MODULE_LICENSE() tag.
    
    This fixes allmodconfig build on my box.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f8b42ab0724b..757294b4f322 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1552,10 +1552,10 @@ static void read_symbols(char *modname)
 	}
 
 	license = get_modinfo(info.modinfo, info.modinfo_len, "license");
-	if (!license && !is_vmlinux(modname))
-		fatal("modpost: missing MODULE_LICENSE() in %s\n"
-		      "see include/linux/module.h for "
-		      "more information\n", modname);
+	if (info.modinfo && !license && !is_vmlinux(modname))
+		warn("modpost: missing MODULE_LICENSE() in %s\n"
+		     "see include/linux/module.h for "
+		     "more information\n", modname);
 	while (license) {
 		if (license_is_gpl_compatible(license))
 			mod->gpl_compatible = 1;

commit 2d04b5ae1bf527201a7505c9be7526c43ebd2930
Author: Richard Hacker <lerichi@gmx.net>
Date:   Thu Feb 28 09:40:52 2008 +0100

    kbuild: support loading extra symbols in modpost
    
    This patch adds a new command line option -E to modpost, expecting a symbol
    file as an argument which is read prior to symbol processing. -E can be
    supplied multiple times for as many files as is needed.
    
    When building kernel modules that depend on other modules not in the main
    kernel tree, modpost complains about undefined symbols:
    # make -C /path/to/linux/kernel M=/path/to/my/module
    ...
    Building modules, stage 2.
    ....
    WARNING: "rt_copy_buf" [/home/rich/osc_etl_rtw/osc_kmod.ko] undefined!
    ...etc
    
    This situation occurs when modpost processes the new module's symbols. When
    it finds symbols not exported by the mainline kernel, it issues this warning.
    
    The patch adds a new command line option -e to modpost which expects a symbol
    file as an argument. The symbols listed in this file are added to modpost's
    symbol tables during startup. -e can be supplied as often as required.
    
    This patch works together with the second patch. It introduces a new make
    variable, KBUILD_EXTRA_SYMBOLS, which is used when calling modpost.
    
    Signed-off-by: Richard Hacker <lerichi@gmx.net>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 843f6fa517cc..f8b42ab0724b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2019,6 +2019,11 @@ static void write_markers(const char *fname)
 	write_if_changed(&buf, fname);
 }
 
+struct ext_sym_list {
+	struct ext_sym_list *next;
+	const char *file;
+};
+
 int main(int argc, char **argv)
 {
 	struct module *mod;
@@ -2029,8 +2034,10 @@ int main(int argc, char **argv)
 	char *markers_write = NULL;
 	int opt;
 	int err;
+	struct ext_sym_list *extsym_iter;
+	struct ext_sym_list *extsym_start = NULL;
 
-	while ((opt = getopt(argc, argv, "i:I:cmsSo:awM:K:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:e:cmsSo:awM:K:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2042,6 +2049,14 @@ int main(int argc, char **argv)
 		case 'c':
 			cross_build = 1;
 			break;
+		case 'e':
+			external_module = 1;
+			extsym_iter =
+			   NOFAIL(malloc(sizeof(*extsym_iter)));
+			extsym_iter->next = extsym_start;
+			extsym_iter->file = optarg;
+			extsym_start = extsym_iter;
+			break;
 		case 'm':
 			modversions = 1;
 			break;
@@ -2075,6 +2090,12 @@ int main(int argc, char **argv)
 		read_dump(kernel_read, 1);
 	if (module_read)
 		read_dump(module_read, 0);
+	while (extsym_start) {
+		read_dump(extsym_start->file, 0);
+		extsym_iter = extsym_start->next;
+		free(extsym_start);
+		extsym_start = extsym_iter;
+	}
 
 	while (optind < argc)
 		read_symbols(argv[optind++]);

commit eed7d2798ce7b78547106d0c3557a88251b413d0
Author: Sam Ravnborg <sam@uranus.ravnborg.org>
Date:   Fri Apr 25 20:13:30 2008 +0200

    kbuild: error out on missing MODULE_LICENSE
    
    Adrian Bunk suggested a build time check for
    missing MODULE_LICENSE annotation in modules.
    The build time check is fatal as we really
    want this fixed for all modules.
    In-tree modules should all have been fixed up by now.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Adrian Bunk <bunk@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 110cf243fa4e..843f6fa517cc 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1552,6 +1552,10 @@ static void read_symbols(char *modname)
 	}
 
 	license = get_modinfo(info.modinfo, info.modinfo_len, "license");
+	if (!license && !is_vmlinux(modname))
+		fatal("modpost: missing MODULE_LICENSE() in %s\n"
+		      "see include/linux/module.h for "
+		      "more information\n", modname);
 	while (license) {
 		if (license_is_gpl_compatible(license))
 			mod->gpl_compatible = 1;

commit 4ce6efed48d736e3384c39ff87bda723e1f8e041
Author: Sam Ravnborg <sam@uranus.ravnborg.org>
Date:   Sun Mar 23 21:38:54 2008 +0100

    kbuild: soften modpost checks when doing cross builds
    
    The module alias support in the kernel have a consistency
    check where it is checked that the size of a structure
    in the kernel and on the build host are the same.
    For cross builds this check does not make sense so detect
    when we do cross builds and silently skip the check in these
    situations.
    This fixes a build bug for a wireless driver when cross building
    for arm.
    
    Acked-by: Michael Buesch <mb@bu3sch.de>
    Tested-by: Gordon Farquharson <gordonfarquharson@gmail.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: stable@kernel.org

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 695b5d657cf5..110cf243fa4e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2026,7 +2026,7 @@ int main(int argc, char **argv)
 	int opt;
 	int err;
 
-	while ((opt = getopt(argc, argv, "i:I:msSo:awM:K:")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:cmsSo:awM:K:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -2035,6 +2035,9 @@ int main(int argc, char **argv)
 			module_read = optarg;
 			external_module = 1;
 			break;
+		case 'c':
+			cross_build = 1;
+			break;
 		case 'm':
 			modversions = 1;
 			break;

commit b1d2675a6466090b68d4ef63f9237b4d70a18857
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Feb 17 14:12:10 2008 +0100

    kbuild: fix reversed symbol name order in modpost
    
    XXXINIT_TO_INIT and XXXEXIT_TO_EXIT warnings use the reversed symbol name order
    in the suggestion, e.g.:
    
        WARNING: vmlinux.o(.meminit.text+0x36c): Section mismatch in reference from the function free_area_init_core() to the function .init.text:setup_usemap()
        The function __meminit free_area_init_core() references
        a function __init setup_usemap().
        If free_area_init_core is only used by setup_usemap then
        annotate free_area_init_core with a matching annotation.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 61742771c65d..695b5d657cf5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1200,7 +1200,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 		"annotate %s with a matching annotation.\n",
 		from, sec2annotation(fromsec), fromsym, from_p,
 		to, sec2annotation(tosec), tosym, to_p,
-		fromsym, tosym, fromsym);
+		tosym, fromsym, tosym);
 		break;
 	case INIT_TO_EXIT:
 		fprintf(stderr,

commit b2e3e658b344c6bcfb8fb694100ab2f2b5b2edb0
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Wed Feb 13 15:03:39 2008 -0800

    Linux Kernel Markers: create modpost file
    
    This adds some new magic in the MODPOST phase for CONFIG_MARKERS.  Analogous
    to the Module.symvers file, the build will now write a Module.markers file
    when CONFIG_MARKERS=y is set.  This file lists the name, defining module, and
    format string of each marker, separated by \t characters.  This simple text
    file can be used by offline build procedures for instrumentation code,
    analogous to how System.map and Module.symvers can be useful to have for
    kernels other than the one you are running right now.
    
    The strings are made easy to extract by having the __trace_mark macro define
    the name and format together in a single array called __mstrtab_* in the
    __markers_strings section.  This is straightforward and reliable as long as
    the marker structs are always defined by this macro.  It is an unreasonable
    amount of hairy work to extract the string pointers from the __markers section
    structs, which entails handling a relocation type for every machine under the
    sun.
    
    Mathieu :
    - Ran through checkpatch.pl
    
    Signed-off-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: David Smith <dsmith@redhat.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index dbe1fb5e8cc0..61742771c65d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -11,6 +11,8 @@
  * Usage: modpost vmlinux module1.o module2.o ...
  */
 
+#define _GNU_SOURCE
+#include <stdio.h>
 #include <ctype.h>
 #include "modpost.h"
 #include "../../include/linux/license.h"
@@ -435,6 +437,8 @@ static int parse_elf(struct elf_info *info, const char *filename)
 			info->export_unused_gpl_sec = i;
 		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
 			info->export_gpl_future_sec = i;
+		else if (strcmp(secname, "__markers_strings") == 0)
+			info->markers_strings_sec = i;
 
 		if (sechdrs[i].sh_type != SHT_SYMTAB)
 			continue;
@@ -1470,6 +1474,62 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	}
 }
 
+static void get_markers(struct elf_info *info, struct module *mod)
+{
+	const Elf_Shdr *sh = &info->sechdrs[info->markers_strings_sec];
+	const char *strings = (const char *) info->hdr + sh->sh_offset;
+	const Elf_Sym *sym, *first_sym, *last_sym;
+	size_t n;
+
+	if (!info->markers_strings_sec)
+		return;
+
+	/*
+	 * First count the strings.  We look for all the symbols defined
+	 * in the __markers_strings section named __mstrtab_*.  For
+	 * these local names, the compiler puts a random .NNN suffix on,
+	 * so the names don't correspond exactly.
+	 */
+	first_sym = last_sym = NULL;
+	n = 0;
+	for (sym = info->symtab_start; sym < info->symtab_stop; sym++)
+		if (ELF_ST_TYPE(sym->st_info) == STT_OBJECT &&
+		    sym->st_shndx == info->markers_strings_sec &&
+		    !strncmp(info->strtab + sym->st_name,
+			     "__mstrtab_", sizeof "__mstrtab_" - 1)) {
+			if (first_sym == NULL)
+				first_sym = sym;
+			last_sym = sym;
+			++n;
+		}
+
+	if (n == 0)
+		return;
+
+	/*
+	 * Now collect each name and format into a line for the output.
+	 * Lines look like:
+	 *	marker_name	vmlinux	marker %s format %d
+	 * The format string after the second \t can use whitespace.
+	 */
+	mod->markers = NOFAIL(malloc(sizeof mod->markers[0] * n));
+	mod->nmarkers = n;
+
+	n = 0;
+	for (sym = first_sym; sym <= last_sym; sym++)
+		if (ELF_ST_TYPE(sym->st_info) == STT_OBJECT &&
+		    sym->st_shndx == info->markers_strings_sec &&
+		    !strncmp(info->strtab + sym->st_name,
+			     "__mstrtab_", sizeof "__mstrtab_" - 1)) {
+			const char *name = strings + sym->st_value;
+			const char *fmt = strchr(name, '\0') + 1;
+			char *line = NULL;
+			asprintf(&line, "%s\t%s\t%s\n", name, mod->name, fmt);
+			NOFAIL(line);
+			mod->markers[n++] = line;
+		}
+}
+
 static void read_symbols(char *modname)
 {
 	const char *symname;
@@ -1521,6 +1581,8 @@ static void read_symbols(char *modname)
 		get_src_version(modname, mod->srcversion,
 				sizeof(mod->srcversion)-1);
 
+	get_markers(&info, mod);
+
 	parse_elf_finish(&info);
 
 	/* Our trick to get versioning for struct_module - it's
@@ -1867,16 +1929,104 @@ static void write_dump(const char *fname)
 	write_if_changed(&buf, fname);
 }
 
+static void add_marker(struct module *mod, const char *name, const char *fmt)
+{
+	char *line = NULL;
+	asprintf(&line, "%s\t%s\t%s\n", name, mod->name, fmt);
+	NOFAIL(line);
+
+	mod->markers = NOFAIL(realloc(mod->markers, ((mod->nmarkers + 1) *
+						     sizeof mod->markers[0])));
+	mod->markers[mod->nmarkers++] = line;
+}
+
+static void read_markers(const char *fname)
+{
+	unsigned long size, pos = 0;
+	void *file = grab_file(fname, &size);
+	char *line;
+
+	if (!file)		/* No old markers, silently ignore */
+		return;
+
+	while ((line = get_next_line(&pos, file, size))) {
+		char *marker, *modname, *fmt;
+		struct module *mod;
+
+		marker = line;
+		modname = strchr(marker, '\t');
+		if (!modname)
+			goto fail;
+		*modname++ = '\0';
+		fmt = strchr(modname, '\t');
+		if (!fmt)
+			goto fail;
+		*fmt++ = '\0';
+		if (*marker == '\0' || *modname == '\0')
+			goto fail;
+
+		mod = find_module(modname);
+		if (!mod) {
+			if (is_vmlinux(modname))
+				have_vmlinux = 1;
+			mod = new_module(NOFAIL(strdup(modname)));
+			mod->skip = 1;
+		}
+
+		add_marker(mod, marker, fmt);
+	}
+	return;
+fail:
+	fatal("parse error in markers list file\n");
+}
+
+static int compare_strings(const void *a, const void *b)
+{
+	return strcmp(*(const char **) a, *(const char **) b);
+}
+
+static void write_markers(const char *fname)
+{
+	struct buffer buf = { };
+	struct module *mod;
+	size_t i;
+
+	for (mod = modules; mod; mod = mod->next)
+		if ((!external_module || !mod->skip) && mod->markers != NULL) {
+			/*
+			 * Sort the strings so we can skip duplicates when
+			 * we write them out.
+			 */
+			qsort(mod->markers, mod->nmarkers,
+			      sizeof mod->markers[0], &compare_strings);
+			for (i = 0; i < mod->nmarkers; ++i) {
+				char *line = mod->markers[i];
+				buf_write(&buf, line, strlen(line));
+				while (i + 1 < mod->nmarkers &&
+				       !strcmp(mod->markers[i],
+					       mod->markers[i + 1]))
+					free(mod->markers[i++]);
+				free(mod->markers[i]);
+			}
+			free(mod->markers);
+			mod->markers = NULL;
+		}
+
+	write_if_changed(&buf, fname);
+}
+
 int main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
 	char *kernel_read = NULL, *module_read = NULL;
 	char *dump_write = NULL;
+	char *markers_read = NULL;
+	char *markers_write = NULL;
 	int opt;
 	int err;
 
-	while ((opt = getopt(argc, argv, "i:I:msSo:aw")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:msSo:awM:K:")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -1903,6 +2053,12 @@ int main(int argc, char **argv)
 		case 'w':
 			warn_unresolved = 1;
 			break;
+			case 'M':
+				markers_write = optarg;
+				break;
+			case 'K':
+				markers_read = optarg;
+				break;
 		default:
 			exit(1);
 		}
@@ -1950,5 +2106,11 @@ int main(int argc, char **argv)
 		     "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
 		     sec_mismatch_count);
 
+	if (markers_read)
+		read_markers(markers_read);
+
+	if (markers_write)
+		write_markers(markers_write);
+
 	return err;
 }

commit 7c0ac495e30b2b9becb79be2ff87642ed8ad8f0c
Author: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
Date:   Tue Feb 5 11:38:49 2008 +0100

    kbuild/modpost: Use warn() for announcing section mismatches
    
    modpost: Use warn() for announcing section mismatches, for easy grepping for
    warnings in build logs.
    
    Also change an existing call from fprintf() to warn() while we're at it.
    
    Signed-off-by: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 32e9d8ffceef..dbe1fb5e8cc0 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1136,10 +1136,10 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 	if (!sec_mismatch_verbose)
 		return;
 
-	fprintf(stderr, "WARNING: %s(%s+0x%llx): Section mismatch in"
-	                " reference from the %s %s%s to the %s %s:%s%s\n",
-                        modname, fromsec, fromaddr, from, fromsym, from_p,
-	                to, tosec, tosym, to_p);
+	warn("%s(%s+0x%llx): Section mismatch in reference from the %s %s%s "
+	     "to the %s %s:%s%s\n",
+	     modname, fromsec, fromaddr, from, fromsym, from_p, to, tosec,
+	     tosym, to_p);
 
 	switch (mismatch) {
 	case TEXT_TO_INIT:
@@ -1945,10 +1945,10 @@ int main(int argc, char **argv)
 	if (dump_write)
 		write_dump(dump_write);
 	if (sec_mismatch_count && !sec_mismatch_verbose)
-		fprintf(stderr, "modpost: Found %d section mismatch(es).\n"
-		        "To see full details build your kernel with:\n"
-		        "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
-		        sec_mismatch_count);
+		warn("modpost: Found %d section mismatch(es).\n"
+		     "To see full details build your kernel with:\n"
+		     "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
+		     sec_mismatch_count);
 
 	return err;
 }

commit f666751a0ab1d1671855da7e98889256b9a5b1bb
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Feb 6 21:51:18 2008 +0100

    kbuild/modpost: improve warnings if symbol is unknown
    
    If we cannot determine the symbol then print
    (unknown) to hint the reader that we failed to
    find the symbol.
    This happens with REL relocation records
    in arm object files.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5d546466e6b1..32e9d8ffceef 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -613,7 +613,7 @@ static const char *sym_name(struct elf_info *elf, Elf_Sym *sym)
 	if (sym)
 		return elf->strtab + sym->st_name;
 	else
-		return "";
+		return "(unknown)";
 }
 
 static const char *sec_name(struct elf_info *elf, int shndx)
@@ -1102,7 +1102,7 @@ static int is_function(Elf_Sym *sym)
 	if (sym)
 		return ELF_ST_TYPE(sym->st_info) == STT_FUNC;
 	else
-		return 0;
+		return -1;
 }
 
 /*
@@ -1120,10 +1120,17 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 {
 	const char *from, *from_p;
 	const char *to, *to_p;
-	from = from_is_func ? "function" : "variable";
-	from_p = from_is_func ? "()" : "";
-	to = to_is_func ? "function" : "variable";
-	to_p = to_is_func ? "()" : "";
+
+	switch (from_is_func) {
+	case 0: from = "variable"; from_p = "";   break;
+	case 1: from = "function"; from_p = "()"; break;
+	default: from = "(unknown reference)"; from_p = ""; break;
+	}
+	switch (to_is_func) {
+	case 0: to = "variable"; to_p = "";   break;
+	case 1: to = "function"; to_p = "()"; break;
+	default: to = "(unknown reference)"; to_p = ""; break;
+	}
 
 	sec_mismatch_count++;
 	if (!sec_mismatch_verbose)
@@ -1137,7 +1144,7 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 	switch (mismatch) {
 	case TEXT_TO_INIT:
 		fprintf(stderr,
-		"The function %s %s() references\n"
+		"The function %s%s() references\n"
 		"the %s %s%s%s.\n"
 		"This is often because %s lacks a %s\n"
 		"annotation or the annotation of %s is wrong.\n",

commit fa95eb1f17a5fe7b3593cff4bf27dbe9ae6cac89
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Feb 2 23:30:22 2008 +0100

    kbuild: do not warn about __*init/__*exit symbols being exported
    
    We have several legitimate uses where we export symbols
    annotated with one of:
    __devinit, __cpuinit, __meminit and their exit counterpart.
    So let's stop warning about those being exported in favour
    of adding all sorts of workaround to silence the warning.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c2e918e2cef1..5d546466e6b1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -870,7 +870,7 @@ const struct sectioncheck sectioncheck[] = {
 /* Do not export init/exit functions or data */
 {
 	.fromsec = { "__ksymtab*", NULL },
-	.tosec   = { ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL },
+	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL },
 	.mismatch = EXPORT_TO_INIT_EXIT
 }
 };

commit e5f95c8b7700a7bf1c2d24eedc677954d9aa0285
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Feb 2 18:57:18 2008 +0100

    kbuild: print only total number of section mismatces found
    
    We have too many section mismatches detected at the moment.
    So silence modpost and prevent the option from being
    set in a typical allyesconfig build.
    
    Tell the user how to see all the deteils in the summary
    message from modpost.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f8efc93eb700..c2e918e2cef1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1125,15 +1125,15 @@ static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
 	to = to_is_func ? "function" : "variable";
 	to_p = to_is_func ? "()" : "";
 
+	sec_mismatch_count++;
+	if (!sec_mismatch_verbose)
+		return;
+
 	fprintf(stderr, "WARNING: %s(%s+0x%llx): Section mismatch in"
 	                " reference from the %s %s%s to the %s %s:%s%s\n",
                         modname, fromsec, fromaddr, from, fromsym, from_p,
 	                to, tosec, tosym, to_p);
 
-	sec_mismatch_count++;
-	if (!sec_mismatch_verbose)
-		return;
-
 	switch (mismatch) {
 	case TEXT_TO_INIT:
 		fprintf(stderr,
@@ -1939,10 +1939,9 @@ int main(int argc, char **argv)
 		write_dump(dump_write);
 	if (sec_mismatch_count && !sec_mismatch_verbose)
 		fprintf(stderr, "modpost: Found %d section mismatch(es).\n"
-		        "To see additional details select \"Enable full "
-		        "Section mismatch analysis\"\n"
-		        "in the Kernel Hacking menu "
-		        "(CONFIG_SECTION_MISMATCH).\n", sec_mismatch_count);
+		        "To see full details build your kernel with:\n"
+		        "'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",
+		        sec_mismatch_count);
 
 	return err;
 }

commit e241a630374e06aecdae2884af8b652d3b4d6c37
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jan 28 20:13:13 2008 +0100

    kbuild: warn about ld added unique sections
    
    If there is a mixture of specifying sections for code in gcc
    and assembler then if the assembler code do not add
    the "ax" flags the linker will see this as two different sections
    and generate unique sections for each. ld does so by adding a dot
    and a number.
    Teach modpost to warn if a section shows up that match this
    pattern - but do this only for non-debug sections.
    
    It will result in warnings like this:
    
    WARNING: vmlinux.o (.sched.text.1): unexpected section name.
    The (.[number]+) following section name are ld generated and not expected.
    Did you forget to use "ax"/"aw" in a .S file?
    Note that for example <linux/init.h> contains
    section definitions for use in .S files.
    
    All warnings seen with a defconfig build for:
    x86 (32+64bit) and sparc64 has been fixed (via respective maintainers).
    
    arm, powerpc (64 bit), s390 (32 bit), ia64, alpha, sh4 checked - no
    warnings seen with a defconfig build.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3cf1ba8220d2..f8efc93eb700 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -696,6 +696,43 @@ int match(const char *sym, const char * const pat[])
 static const char *section_white_list[] =
 	{ ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
 
+/*
+ * Is this section one we do not want to check?
+ * This is often debug sections.
+ * If we are going to check this section then
+ * test if section name ends with a dot and a number.
+ * This is used to find sections where the linker have
+ * appended a dot-number to make the name unique.
+ * The cause of this is often a section specified in assembler
+ * without "ax" / "aw" and the same section used in .c
+ * code where gcc add these.
+ */
+static int check_section(const char *modname, const char *sec)
+{
+	const char *e = sec + strlen(sec) - 1;
+	if (match(sec, section_white_list))
+		return 1;
+
+	if (*e && isdigit(*e)) {
+		/* consume all digits */
+		while (*e && e != sec && isdigit(*e))
+			e--;
+		if (*e == '.') {
+			warn("%s (%s): unexpected section name.\n"
+			     "The (.[number]+) following section name are "
+			     "ld generated and not expected.\n"
+			     "Did you forget to use \"ax\"/\"aw\" "
+			     "in a .S file?\n"
+			     "Note that for example <linux/init.h> contains\n"
+			     "section definitions for use in .S files.\n\n",
+			     modname, sec);
+		}
+	}
+	return 0;
+}
+
+
+
 #define ALL_INIT_DATA_SECTIONS \
 	".init.data$", ".devinit.data$", ".cpuinit.data$", ".meminit.data$"
 #define ALL_EXIT_DATA_SECTIONS \
@@ -1311,8 +1348,9 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	fromsec = sech_name(elf, sechdr);
 	fromsec += strlen(".rela");
 	/* if from section (name) is know good then skip it */
-	if (match(fromsec, section_white_list))
+	if (check_section(modname, fromsec))
 		return;
+
 	for (rela = start; rela < stop; rela++) {
 		r.r_offset = TO_NATIVE(rela->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
@@ -1354,7 +1392,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 	fromsec = sech_name(elf, sechdr);
 	fromsec += strlen(".rel");
 	/* if from section (name) is know good then skip it */
-	if (match(fromsec, section_white_list))
+	if (check_section(modname, fromsec))
 		return;
 
 	for (rel = start; rel < stop; rel++) {

commit 588ccd732ba2d32db8228802ef9283b583d3395f
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jan 24 21:12:37 2008 +0100

    kbuild: add verbose option to Section mismatch reporting in modpost
    
    If the config option CONFIG_SECTION_MISMATCH is not set and
    we see a Section mismatch present the following to the user:
    
    modpost: Found 1 section mismatch(es).
    To see additional details select "Enable full Section mismatch analysis"
    in the Kernel Hacking menu (CONFIG_SECTION_MISMATCH).
    
    If the option CONFIG_SECTION_MISMATCH is selected
    then be verbose in the Section mismatch reporting from mdopost.
    Sample outputs:
    
    WARNING: o-x86_64/vmlinux.o(.text+0x7396): Section mismatch in reference from the function discover_ebda() to the variable .init.data:ebda_addr
    The function  discover_ebda() references
    the variable __initdata ebda_addr.
    This is often because discover_ebda lacks a __initdata
    annotation or the annotation of ebda_addr is wrong.
    
    WARNING: o-x86_64/vmlinux.o(.data+0x74d58): Section mismatch in reference from the variable pci_serial_quirks to the function .devexit.text:pci_plx9050_exit()
    The variable pci_serial_quirks references
    the function __devexit pci_plx9050_exit()
    If the reference is valid then annotate the
    variable with __exit* (see linux/init.h) or name the variable:
    *driver, *_template, *_timer, *_sht, *_ops, *_probe, *_probe_one, *_console,
    
    WARNING: o-x86_64/vmlinux.o(__ksymtab+0x630): Section mismatch in reference from the variable __ksymtab_arch_register_cpu to the function .cpuinit.text:arch_register_cpu()
    The symbol arch_register_cpu is exported and annotated __cpuinit
    Fix this by removing the __cpuinit annotation of arch_register_cpu or drop the export.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e75739ec9c03..3cf1ba8220d2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -28,6 +28,9 @@ static int vmlinux_section_warnings = 1;
 /* Only warn about unresolved symbols */
 static int warn_unresolved = 0;
 /* How a symbol is exported */
+static int sec_mismatch_count = 0;
+static int sec_mismatch_verbose = 1;
+
 enum export {
 	export_plain,      export_unused,     export_gpl,
 	export_unused_gpl, export_gpl_future, export_unknown
@@ -760,9 +763,23 @@ static const char *head_sections[] = { ".head.text*", NULL };
 static const char *linker_symbols[] =
 	{ "__init_begin", "_sinittext", "_einittext", NULL };
 
+enum mismatch {
+	NO_MISMATCH,
+	TEXT_TO_INIT,
+	DATA_TO_INIT,
+	TEXT_TO_EXIT,
+	DATA_TO_EXIT,
+	XXXINIT_TO_INIT,
+	XXXEXIT_TO_EXIT,
+	INIT_TO_EXIT,
+	EXIT_TO_INIT,
+	EXPORT_TO_INIT_EXIT,
+};
+
 struct sectioncheck {
 	const char *fromsec[20];
 	const char *tosec[20];
+	enum mismatch mismatch;
 };
 
 const struct sectioncheck sectioncheck[] = {
@@ -770,33 +787,54 @@ const struct sectioncheck sectioncheck[] = {
  * normal code and data
  */
 {
-	.fromsec = { TEXT_SECTIONS, DATA_SECTIONS, NULL },
-	.tosec   = { ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL }
+	.fromsec = { TEXT_SECTIONS, NULL },
+	.tosec   = { ALL_INIT_SECTIONS, NULL },
+	.mismatch = TEXT_TO_INIT,
+},
+{
+	.fromsec = { DATA_SECTIONS, NULL },
+	.tosec   = { ALL_INIT_SECTIONS, NULL },
+	.mismatch = DATA_TO_INIT,
+},
+{
+	.fromsec = { TEXT_SECTIONS, NULL },
+	.tosec   = { ALL_EXIT_SECTIONS, NULL },
+	.mismatch = TEXT_TO_EXIT,
+},
+{
+	.fromsec = { DATA_SECTIONS, NULL },
+	.tosec   = { ALL_EXIT_SECTIONS, NULL },
+	.mismatch = DATA_TO_EXIT,
 },
 /* Do not reference init code/data from devinit/cpuinit/meminit code/data */
 {
 	.fromsec = { DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, MEM_INIT_SECTIONS, NULL },
-	.tosec   = { INIT_SECTIONS, NULL }
+	.tosec   = { INIT_SECTIONS, NULL },
+	.mismatch = XXXINIT_TO_INIT,
 },
 /* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
 {
 	.fromsec = { DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS, NULL },
-	.tosec   = { EXIT_SECTIONS, NULL }
+	.tosec   = { EXIT_SECTIONS, NULL },
+	.mismatch = XXXEXIT_TO_EXIT,
 },
 /* Do not use exit code/data from init code */
 {
 	.fromsec = { ALL_INIT_SECTIONS, NULL },
 	.tosec   = { ALL_EXIT_SECTIONS, NULL },
+	.mismatch = INIT_TO_EXIT,
 },
 /* Do not use init code/data from exit code */
 {
 	.fromsec = { ALL_EXIT_SECTIONS, NULL },
-	.tosec   = { ALL_INIT_SECTIONS, NULL }
+	.tosec   = { ALL_INIT_SECTIONS, NULL },
+	.mismatch = EXIT_TO_INIT,
 },
 /* Do not export init/exit functions or data */
 {
 	.fromsec = { "__ksymtab*", NULL },
-	.tosec   = { ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL }
+	.tosec   = { ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL },
+	.mismatch = EXPORT_TO_INIT_EXIT
 }
 };
 
@@ -809,10 +847,10 @@ static int section_mismatch(const char *fromsec, const char *tosec)
 	for (i = 0; i < elems; i++) {
 		if (match(fromsec, check->fromsec) &&
 		    match(tosec, check->tosec))
-			return 1;
+			return check->mismatch;
 		check++;
 	}
-	return 0;
+	return NO_MISMATCH;
 }
 
 /**
@@ -988,48 +1026,198 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 	return near;
 }
 
+/*
+ * Convert a section name to the function/data attribute
+ * .init.text => __init
+ * .cpuinit.data => __cpudata
+ * .memexitconst => __memconst
+ * etc.
+*/
+static char *sec2annotation(const char *s)
+{
+	if (match(s, init_exit_sections)) {
+		char *p = malloc(20);
+		char *r = p;
+
+		*p++ = '_';
+		*p++ = '_';
+		if (*s == '.')
+			s++;
+		while (*s && *s != '.')
+			*p++ = *s++;
+		*p = '\0';
+		if (*s == '.')
+			s++;
+		if (strstr(s, "rodata") != NULL)
+			strcat(p, "const ");
+		else if (strstr(s, "data") != NULL)
+			strcat(p, "data ");
+		else
+			strcat(p, " ");
+		return r; /* we leak her but we do not care */
+	} else {
+		return "";
+	}
+}
+
+static int is_function(Elf_Sym *sym)
+{
+	if (sym)
+		return ELF_ST_TYPE(sym->st_info) == STT_FUNC;
+	else
+		return 0;
+}
+
 /*
  * Print a warning about a section mismatch.
  * Try to find symbols near it so user can find it.
  * Check whitelist before warning - it may be a false positive.
  */
-static void report_sec_mismatch(const char *modname,
+static void report_sec_mismatch(const char *modname, enum mismatch mismatch,
                                 const char *fromsec,
                                 unsigned long long fromaddr,
                                 const char *fromsym,
-                                const char *tosec, const char *tosym)
-{
-	if (strlen(tosym)) {
-		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
-		     "in '%s'\n",
-		     modname, fromsec, fromaddr,
-		     tosec, tosym, fromsym);
-	} else {
-		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
-		     modname, fromsec, fromaddr,
-		     tosec, tosym);
+                                int from_is_func,
+                                const char *tosec, const char *tosym,
+                                int to_is_func)
+{
+	const char *from, *from_p;
+	const char *to, *to_p;
+	from = from_is_func ? "function" : "variable";
+	from_p = from_is_func ? "()" : "";
+	to = to_is_func ? "function" : "variable";
+	to_p = to_is_func ? "()" : "";
+
+	fprintf(stderr, "WARNING: %s(%s+0x%llx): Section mismatch in"
+	                " reference from the %s %s%s to the %s %s:%s%s\n",
+                        modname, fromsec, fromaddr, from, fromsym, from_p,
+	                to, tosec, tosym, to_p);
+
+	sec_mismatch_count++;
+	if (!sec_mismatch_verbose)
+		return;
+
+	switch (mismatch) {
+	case TEXT_TO_INIT:
+		fprintf(stderr,
+		"The function %s %s() references\n"
+		"the %s %s%s%s.\n"
+		"This is often because %s lacks a %s\n"
+		"annotation or the annotation of %s is wrong.\n",
+		sec2annotation(fromsec), fromsym,
+		to, sec2annotation(tosec), tosym, to_p,
+		fromsym, sec2annotation(tosec), tosym);
+		break;
+	case DATA_TO_INIT: {
+		const char **s = symbol_white_list;
+		fprintf(stderr,
+		"The variable %s references\n"
+		"the %s %s%s%s\n"
+		"If the reference is valid then annotate the\n"
+		"variable with __init* (see linux/init.h) "
+		"or name the variable:\n",
+		fromsym, to, sec2annotation(tosec), tosym, to_p);
+		while (*s)
+			fprintf(stderr, "%s, ", *s++);
+		fprintf(stderr, "\n");
+		break;
 	}
+	case TEXT_TO_EXIT:
+		fprintf(stderr,
+		"The function %s() references a %s in an exit section.\n"
+		"Often the %s %s%s has valid usage outside the exit section\n"
+		"and the fix is to remove the %sannotation of %s.\n",
+		fromsym, to, to, tosym, to_p, sec2annotation(tosec), tosym);
+		break;
+	case DATA_TO_EXIT: {
+		const char **s = symbol_white_list;
+		fprintf(stderr,
+		"The variable %s references\n"
+		"the %s %s%s%s\n"
+		"If the reference is valid then annotate the\n"
+		"variable with __exit* (see linux/init.h) or "
+		"name the variable:\n",
+		fromsym, to, sec2annotation(tosec), tosym, to_p);
+		while (*s)
+			fprintf(stderr, "%s, ", *s++);
+		fprintf(stderr, "\n");
+		break;
+	}
+	case XXXINIT_TO_INIT:
+	case XXXEXIT_TO_EXIT:
+		fprintf(stderr,
+		"The %s %s%s%s references\n"
+		"a %s %s%s%s.\n"
+		"If %s is only used by %s then\n"
+		"annotate %s with a matching annotation.\n",
+		from, sec2annotation(fromsec), fromsym, from_p,
+		to, sec2annotation(tosec), tosym, to_p,
+		fromsym, tosym, fromsym);
+		break;
+	case INIT_TO_EXIT:
+		fprintf(stderr,
+		"The %s %s%s%s references\n"
+		"a %s %s%s%s.\n"
+		"This is often seen when error handling "
+		"in the init function\n"
+		"uses functionality in the exit path.\n"
+		"The fix is often to remove the %sannotation of\n"
+		"%s%s so it may be used outside an exit section.\n",
+		from, sec2annotation(fromsec), fromsym, from_p,
+		to, sec2annotation(tosec), tosym, to_p,
+		sec2annotation(tosec), tosym, to_p);
+		break;
+	case EXIT_TO_INIT:
+		fprintf(stderr,
+		"The %s %s%s%s references\n"
+		"a %s %s%s%s.\n"
+		"This is often seen when error handling "
+		"in the exit function\n"
+		"uses functionality in the init path.\n"
+		"The fix is often to remove the %sannotation of\n"
+		"%s%s so it may be used outside an init section.\n",
+		from, sec2annotation(fromsec), fromsym, from_p,
+		to, sec2annotation(tosec), tosym, to_p,
+		sec2annotation(tosec), tosym, to_p);
+		break;
+	case EXPORT_TO_INIT_EXIT:
+		fprintf(stderr,
+		"The symbol %s is exported and annotated %s\n"
+		"Fix this by removing the %sannotation of %s "
+		"or drop the export.\n",
+		tosym, sec2annotation(tosec), sec2annotation(tosec), tosym);
+	case NO_MISMATCH:
+		/* To get warnings on missing members */
+		break;
+	}
+	fprintf(stderr, "\n");
 }
 
 static void check_section_mismatch(const char *modname, struct elf_info *elf,
                                    Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
 {
 	const char *tosec;
+	enum mismatch mismatch;
 
 	tosec = sec_name(elf, sym->st_shndx);
-	if (section_mismatch(fromsec, tosec)) {
-		const char *fromsym;
+	mismatch = section_mismatch(fromsec, tosec);
+	if (mismatch != NO_MISMATCH) {
+		Elf_Sym *to;
+		Elf_Sym *from;
 		const char *tosym;
+		const char *fromsym;
 
-		fromsym = sym_name(elf,
-		          find_elf_symbol2(elf, r->r_offset, fromsec));
-		tosym = sym_name(elf,
-		        find_elf_symbol(elf, r->r_addend, sym));
+		from = find_elf_symbol2(elf, r->r_offset, fromsec);
+		fromsym = sym_name(elf, from);
+		to = find_elf_symbol(elf, r->r_addend, sym);
+		tosym = sym_name(elf, to);
 
 		/* check whitelist - we may ignore it */
 		if (secref_whitelist(fromsec, fromsym, tosec, tosym)) {
-			report_sec_mismatch(modname, fromsec, r->r_offset,
-			                    fromsym, tosec, tosym);
+			report_sec_mismatch(modname, mismatch,
+			   fromsec, r->r_offset, fromsym,
+			   is_function(from), tosec, tosym,
+			   is_function(to));
 		}
 	}
 }
@@ -1643,7 +1831,7 @@ int main(int argc, char **argv)
 	int opt;
 	int err;
 
-	while ((opt = getopt(argc, argv, "i:I:mso:aw")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:msSo:aw")) != -1) {
 		switch (opt) {
 		case 'i':
 			kernel_read = optarg;
@@ -1664,6 +1852,9 @@ int main(int argc, char **argv)
 		case 's':
 			vmlinux_section_warnings = 0;
 			break;
+		case 'S':
+			sec_mismatch_verbose = 0;
+			break;
 		case 'w':
 			warn_unresolved = 1;
 			break;
@@ -1708,6 +1899,12 @@ int main(int argc, char **argv)
 
 	if (dump_write)
 		write_dump(dump_write);
+	if (sec_mismatch_count && !sec_mismatch_verbose)
+		fprintf(stderr, "modpost: Found %d section mismatch(es).\n"
+		        "To see additional details select \"Enable full "
+		        "Section mismatch analysis\"\n"
+		        "in the Kernel Hacking menu "
+		        "(CONFIG_SECTION_MISMATCH).\n", sec_mismatch_count);
 
 	return err;
 }

commit 3ff6eecca4e5c49a5d1dd8b58ea0e20102ce08f0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jan 24 22:16:20 2008 +0100

    remove __attribute_used__
    
    Remove the deprecated __attribute_used__.
    
    [Introduce __section in a few places to silence checkpatch /sam]
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0a80acafd212..e75739ec9c03 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1445,7 +1445,7 @@ static int add_versions(struct buffer *b, struct module *mod)
 
 	buf_printf(b, "\n");
 	buf_printf(b, "static const struct modversion_info ____versions[]\n");
-	buf_printf(b, "__attribute_used__\n");
+	buf_printf(b, "__used\n");
 	buf_printf(b, "__attribute__((section(\"__versions\"))) = {\n");
 
 	for (s = mod->unres; s; s = s->next) {
@@ -1476,7 +1476,7 @@ static void add_depends(struct buffer *b, struct module *mod,
 
 	buf_printf(b, "\n");
 	buf_printf(b, "static const char __module_depends[]\n");
-	buf_printf(b, "__attribute_used__\n");
+	buf_printf(b, "__used\n");
 	buf_printf(b, "__attribute__((section(\".modinfo\"))) =\n");
 	buf_printf(b, "\"depends=");
 	for (s = mod->unres; s; s = s->next) {

commit 58fb0d4f2fd5773ec0158d1f2774dca6a03e6984
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jan 23 21:13:50 2008 +0100

    kbuild: simplified warning report in modpost
    
    Refactor code so the warning report function
    does nothing else than reporting warnings.
    As a side effect some other code paths were cleaned
    up by this.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e4099cd5f085..0a80acafd212 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -607,7 +607,10 @@ static int strrcmp(const char *s, const char *sub)
 
 static const char *sym_name(struct elf_info *elf, Elf_Sym *sym)
 {
-	return elf->strtab + sym->st_name;
+	if (sym)
+		return elf->strtab + sym->st_name;
+	else
+		return "";
 }
 
 static const char *sec_name(struct elf_info *elf, int shndx)
@@ -812,7 +815,6 @@ static int section_mismatch(const char *fromsec, const char *tosec)
 	return 0;
 }
 
-
 /**
  * Whitelist to allow certain references to pass with no warning.
  *
@@ -856,36 +858,35 @@ static int section_mismatch(const char *fromsec, const char *tosec)
  *   refsymname = __init_begin, _sinittext, _einittext
  *
  **/
-static int secref_whitelist(const char *modname, const char *tosec,
-			    const char *fromsec, const char *atsym,
-			    const char *refsymname)
+static int secref_whitelist(const char *fromsec, const char *fromsym,
+			    const char *tosec, const char *tosym)
 {
 	/* Check for pattern 0 */
 	if (match(fromsec, initref_sections))
-		return 1;
+		return 0;
 
 	/* Check for pattern 1 */
 	if (match(tosec, init_data_sections) &&
 	    match(fromsec, data_sections) &&
-	    (strncmp(atsym, "__param", strlen("__param")) == 0))
-		return 1;
+	    (strncmp(fromsym, "__param", strlen("__param")) == 0))
+		return 0;
 
 	/* Check for pattern 2 */
 	if (match(tosec, init_exit_sections) &&
 	    match(fromsec, data_sections) &&
-	    match(atsym, symbol_white_list))
-		return 1;
+	    match(fromsym, symbol_white_list))
+		return 0;
 
 	/* Check for pattern 3 */
 	if (match(fromsec, head_sections) &&
 	    match(tosec, init_sections))
-	return 1;
+		return 0;
 
 	/* Check for pattern 4 */
-	if (match(refsymname, linker_symbols))
-		return 1;
+	if (match(tosym, linker_symbols))
+		return 0;
 
-	return 0;
+	return 1;
 }
 
 /**
@@ -987,41 +988,49 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 	return near;
 }
 
-/**
+/*
  * Print a warning about a section mismatch.
  * Try to find symbols near it so user can find it.
  * Check whitelist before warning - it may be a false positive.
- **/
-static void warn_sec_mismatch(const char *modname, const char *fromsec,
-			      struct elf_info *elf, Elf_Sym *sym, Elf_Rela r)
+ */
+static void report_sec_mismatch(const char *modname,
+                                const char *fromsec,
+                                unsigned long long fromaddr,
+                                const char *fromsym,
+                                const char *tosec, const char *tosym)
 {
-	Elf_Sym *where;
-	Elf_Sym *refsym;
-	const char *refsymname = "";
-	const char *secname;
-
-	secname = sec_name(elf, sym->st_shndx);
-	where = find_elf_symbol2(elf, r.r_offset, fromsec);
-
-	refsym = find_elf_symbol(elf, r.r_addend, sym);
-	if (refsym && strlen(sym_name(elf, refsym)))
-		refsymname = sym_name(elf, refsym);
-
-	/* check whitelist - we may ignore it */
-	if (secref_whitelist(modname, secname, fromsec,
-			     where ? sym_name(elf, where) : "",
-	                     refsymname))
-		return;
-
-	if (where) {
+	if (strlen(tosym)) {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
 		     "in '%s'\n",
-		     modname, fromsec, (unsigned long long)r.r_offset,
-		     secname, refsymname, sym_name(elf, where));
+		     modname, fromsec, fromaddr,
+		     tosec, tosym, fromsym);
 	} else {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
-		     modname, fromsec, (unsigned long long)r.r_offset,
-		     secname, refsymname);
+		     modname, fromsec, fromaddr,
+		     tosec, tosym);
+	}
+}
+
+static void check_section_mismatch(const char *modname, struct elf_info *elf,
+                                   Elf_Rela *r, Elf_Sym *sym, const char *fromsec)
+{
+	const char *tosec;
+
+	tosec = sec_name(elf, sym->st_shndx);
+	if (section_mismatch(fromsec, tosec)) {
+		const char *fromsym;
+		const char *tosym;
+
+		fromsym = sym_name(elf,
+		          find_elf_symbol2(elf, r->r_offset, fromsec));
+		tosym = sym_name(elf,
+		        find_elf_symbol(elf, r->r_addend, sym));
+
+		/* check whitelist - we may ignore it */
+		if (secref_whitelist(fromsec, fromsym, tosec, tosym)) {
+			report_sec_mismatch(modname, fromsec, r->r_offset,
+			                    fromsym, tosec, tosym);
+		}
 	}
 }
 
@@ -1107,7 +1116,6 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	Elf_Rela r;
 	unsigned int r_sym;
 	const char *fromsec;
-	const char * tosec;
 
 	Elf_Rela *start = (void *)elf->hdr + sechdr->sh_offset;
 	Elf_Rela *stop  = (void *)start + sechdr->sh_size;
@@ -1117,7 +1125,6 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	/* if from section (name) is know good then skip it */
 	if (match(fromsec, section_white_list))
 		return;
-
 	for (rela = start; rela < stop; rela++) {
 		r.r_offset = TO_NATIVE(rela->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
@@ -1140,10 +1147,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 		/* Skip special sections */
 		if (sym->st_shndx >= SHN_LORESERVE)
 			continue;
-
-		tosec = sec_name(elf, sym->st_shndx);
-		if (section_mismatch(fromsec, tosec))
-			warn_sec_mismatch(modname, fromsec, elf, sym, r);
+		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
 }
 
@@ -1155,7 +1159,6 @@ static void section_rel(const char *modname, struct elf_info *elf,
 	Elf_Rela r;
 	unsigned int r_sym;
 	const char *fromsec;
-	const char * tosec;
 
 	Elf_Rel *start = (void *)elf->hdr + sechdr->sh_offset;
 	Elf_Rel *stop  = (void *)start + sechdr->sh_size;
@@ -1202,10 +1205,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 		/* Skip special sections */
 		if (sym->st_shndx >= SHN_LORESERVE)
 			continue;
-
-		tosec = sec_name(elf, sym->st_shndx);
-		if (section_mismatch(fromsec, tosec))
-			warn_sec_mismatch(modname, fromsec, elf, sym, r);
+		check_section_mismatch(modname, elf, &r, sym, fromsec);
 	}
 }
 

commit ff13f92690249061311c7cf69a89e5a2fb068811
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jan 23 19:54:27 2008 +0100

    kbuild: introduce a few helpers in modpost
    
    Introducing helpers to retreive symbol and section
    names cleaned up the code a bit.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7dfd0395c5b0..e4099cd5f085 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -605,6 +605,26 @@ static int strrcmp(const char *s, const char *sub)
 	return memcmp(s + slen - sublen, sub, sublen);
 }
 
+static const char *sym_name(struct elf_info *elf, Elf_Sym *sym)
+{
+	return elf->strtab + sym->st_name;
+}
+
+static const char *sec_name(struct elf_info *elf, int shndx)
+{
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	return (void *)elf->hdr +
+	        elf->sechdrs[elf->hdr->e_shstrndx].sh_offset +
+	        sechdrs[shndx].sh_name;
+}
+
+static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
+{
+	return (void *)elf->hdr +
+	        elf->sechdrs[elf->hdr->e_shstrndx].sh_offset +
+	        sechdr->sh_name;
+}
+
 /* if sym is empty or point to a string
  * like ".[0-9]+" then return 1.
  * This is the optional prefix added by ld to some sections
@@ -943,17 +963,14 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 {
 	Elf_Sym *sym;
 	Elf_Sym *near = NULL;
-	Elf_Ehdr *hdr = elf->hdr;
 	Elf_Addr distance = ~0;
-	const char *secstrings = (void *)hdr +
-				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
 
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
 		const char *symsec;
 
 		if (sym->st_shndx >= SHN_LORESERVE)
 			continue;
-		symsec = secstrings + elf->sechdrs[sym->st_shndx].sh_name;
+		symsec = sec_name(elf, sym->st_shndx);
 		if (strcmp(symsec, sec) != 0)
 			continue;
 		if (!is_valid_name(elf, sym))
@@ -978,24 +995,21 @@ static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
 static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			      struct elf_info *elf, Elf_Sym *sym, Elf_Rela r)
 {
-	const char *refsymname = "";
 	Elf_Sym *where;
 	Elf_Sym *refsym;
-	Elf_Ehdr *hdr = elf->hdr;
-	Elf_Shdr *sechdrs = elf->sechdrs;
-	const char *secstrings = (void *)hdr +
-				 sechdrs[hdr->e_shstrndx].sh_offset;
-	const char *secname = secstrings + sechdrs[sym->st_shndx].sh_name;
+	const char *refsymname = "";
+	const char *secname;
 
+	secname = sec_name(elf, sym->st_shndx);
 	where = find_elf_symbol2(elf, r.r_offset, fromsec);
 
 	refsym = find_elf_symbol(elf, r.r_addend, sym);
-	if (refsym && strlen(elf->strtab + refsym->st_name))
-		refsymname = elf->strtab + refsym->st_name;
+	if (refsym && strlen(sym_name(elf, refsym)))
+		refsymname = sym_name(elf, refsym);
 
 	/* check whitelist - we may ignore it */
 	if (secref_whitelist(modname, secname, fromsec,
-			     where ? elf->strtab + where->st_name : "",
+			     where ? sym_name(elf, where) : "",
 	                     refsymname))
 		return;
 
@@ -1003,7 +1017,7 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
 		     "in '%s'\n",
 		     modname, fromsec, (unsigned long long)r.r_offset,
-		     secname, refsymname, elf->strtab + where->st_name);
+		     secname, refsymname, sym_name(elf, where));
 	} else {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
 		     modname, fromsec, (unsigned long long)r.r_offset,
@@ -1095,14 +1109,10 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	const char *fromsec;
 	const char * tosec;
 
-	Elf_Ehdr *hdr = elf->hdr;
-	Elf_Rela *start = (void *)hdr + sechdr->sh_offset;
+	Elf_Rela *start = (void *)elf->hdr + sechdr->sh_offset;
 	Elf_Rela *stop  = (void *)start + sechdr->sh_size;
 
-	const char *secstrings = (void *)hdr +
-				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
-
-	fromsec = secstrings + sechdr->sh_name;
+	fromsec = sech_name(elf, sechdr);
 	fromsec += strlen(".rela");
 	/* if from section (name) is know good then skip it */
 	if (match(fromsec, section_white_list))
@@ -1111,7 +1121,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	for (rela = start; rela < stop; rela++) {
 		r.r_offset = TO_NATIVE(rela->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
-		if (hdr->e_machine == EM_MIPS) {
+		if (elf->hdr->e_machine == EM_MIPS) {
 			unsigned int r_typ;
 			r_sym = ELF64_MIPS_R_SYM(rela->r_info);
 			r_sym = TO_NATIVE(r_sym);
@@ -1131,8 +1141,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 		if (sym->st_shndx >= SHN_LORESERVE)
 			continue;
 
-		tosec = secstrings +
-			elf->sechdrs[sym->st_shndx].sh_name;
+		tosec = sec_name(elf, sym->st_shndx);
 		if (section_mismatch(fromsec, tosec))
 			warn_sec_mismatch(modname, fromsec, elf, sym, r);
 	}
@@ -1148,14 +1157,10 @@ static void section_rel(const char *modname, struct elf_info *elf,
 	const char *fromsec;
 	const char * tosec;
 
-	Elf_Ehdr *hdr = elf->hdr;
-	Elf_Rel *start = (void *)hdr + sechdr->sh_offset;
+	Elf_Rel *start = (void *)elf->hdr + sechdr->sh_offset;
 	Elf_Rel *stop  = (void *)start + sechdr->sh_size;
 
-	const char *secstrings = (void *)hdr +
-				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
-
-	fromsec = secstrings + sechdr->sh_name;
+	fromsec = sech_name(elf, sechdr);
 	fromsec += strlen(".rel");
 	/* if from section (name) is know good then skip it */
 	if (match(fromsec, section_white_list))
@@ -1164,7 +1169,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 	for (rel = start; rel < stop; rel++) {
 		r.r_offset = TO_NATIVE(rel->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
-		if (hdr->e_machine == EM_MIPS) {
+		if (elf->hdr->e_machine == EM_MIPS) {
 			unsigned int r_typ;
 			r_sym = ELF64_MIPS_R_SYM(rel->r_info);
 			r_sym = TO_NATIVE(r_sym);
@@ -1179,7 +1184,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 		r_sym = ELF_R_SYM(r.r_info);
 #endif
 		r.r_addend = 0;
-		switch (hdr->e_machine) {
+		switch (elf->hdr->e_machine) {
 		case EM_386:
 			if (addend_386_rel(elf, sechdr, &r))
 				continue;
@@ -1198,8 +1203,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 		if (sym->st_shndx >= SHN_LORESERVE)
 			continue;
 
-		tosec = secstrings +
-			elf->sechdrs[sym->st_shndx].sh_name;
+		tosec = sec_name(elf, sym->st_shndx);
 		if (section_mismatch(fromsec, tosec))
 			warn_sec_mismatch(modname, fromsec, elf, sym, r);
 	}
@@ -1221,11 +1225,10 @@ static void check_sec_ref(struct module *mod, const char *modname,
                           struct elf_info *elf)
 {
 	int i;
-	Elf_Ehdr *hdr = elf->hdr;
 	Elf_Shdr *sechdrs = elf->sechdrs;
 
 	/* Walk through all sections */
-	for (i = 0; i < hdr->e_shnum; i++) {
+	for (i = 0; i < elf->hdr->e_shnum; i++) {
 		/* We want to process only relocation sections and not .init */
 		if (sechdrs[i].sh_type == SHT_RELA)
 			section_rela(modname, elf, &elf->sechdrs[i]);

commit 157c23c80eed84194440b487658398272eaebaf4
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jan 22 21:44:32 2008 +0100

    kbuild: use simpler section mismatch warnings in modpost
    
    The typical layout is now:
    WARNING: vmlinux.o(.text+0x372ec): Section mismatch: reference to .devinit.text:pci_scan_one_pbm in 'psycho_scan_bus'
    
    This is first step towards more readable warnings.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 730b321680cd..7dfd0395c5b0 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -938,20 +938,16 @@ static inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)
  * The ELF format may have a better way to detect what type of symbol
  * it is, but this works for now.
  **/
-static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
-				 const char *sec,
-				 Elf_Sym **before, Elf_Sym **after)
+static Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,
+				 const char *sec)
 {
 	Elf_Sym *sym;
+	Elf_Sym *near = NULL;
 	Elf_Ehdr *hdr = elf->hdr;
-	Elf_Addr beforediff = ~0;
-	Elf_Addr afterdiff = ~0;
+	Elf_Addr distance = ~0;
 	const char *secstrings = (void *)hdr +
 				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
 
-	*before = NULL;
-	*after = NULL;
-
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
 		const char *symsec;
 
@@ -963,20 +959,15 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 		if (!is_valid_name(elf, sym))
 			continue;
 		if (sym->st_value <= addr) {
-			if ((addr - sym->st_value) < beforediff) {
-				beforediff = addr - sym->st_value;
-				*before = sym;
-			} else if ((addr - sym->st_value) == beforediff) {
-				*before = sym;
+			if ((addr - sym->st_value) < distance) {
+				distance = addr - sym->st_value;
+				near = sym;
+			} else if ((addr - sym->st_value) == distance) {
+				near = sym;
 			}
-		} else {
-			if ((sym->st_value - addr) < afterdiff) {
-				afterdiff = sym->st_value - addr;
-				*after = sym;
-			} else if ((sym->st_value - addr) == afterdiff)
-				*after = sym;
 		}
 	}
+	return near;
 }
 
 /**
@@ -988,7 +979,7 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			      struct elf_info *elf, Elf_Sym *sym, Elf_Rela r)
 {
 	const char *refsymname = "";
-	Elf_Sym *before, *after;
+	Elf_Sym *where;
 	Elf_Sym *refsym;
 	Elf_Ehdr *hdr = elf->hdr;
 	Elf_Shdr *sechdrs = elf->sechdrs;
@@ -996,7 +987,7 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 				 sechdrs[hdr->e_shstrndx].sh_offset;
 	const char *secname = secstrings + sechdrs[sym->st_shndx].sh_name;
 
-	find_symbols_between(elf, r.r_offset, fromsec, &before, &after);
+	where = find_elf_symbol2(elf, r.r_offset, fromsec);
 
 	refsym = find_elf_symbol(elf, r.r_addend, sym);
 	if (refsym && strlen(elf->strtab + refsym->st_name))
@@ -1004,30 +995,15 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 
 	/* check whitelist - we may ignore it */
 	if (secref_whitelist(modname, secname, fromsec,
-			     before ? elf->strtab + before->st_name : "",
+			     where ? elf->strtab + where->st_name : "",
 	                     refsymname))
 		return;
 
-	if (before && after) {
-		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
-		     "(between '%s' and '%s')\n",
-		     modname, fromsec, (unsigned long long)r.r_offset,
-		     secname, refsymname,
-		     elf->strtab + before->st_name,
-		     elf->strtab + after->st_name);
-	} else if (before) {
-		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
-		     "(after '%s')\n",
-		     modname, fromsec, (unsigned long long)r.r_offset,
-		     secname, refsymname,
-		     elf->strtab + before->st_name);
-	} else if (after) {
+	if (where) {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
-		     "before '%s' (at offset -0x%llx)\n",
+		     "in '%s'\n",
 		     modname, fromsec, (unsigned long long)r.r_offset,
-		     secname, refsymname,
-		     elf->strtab + after->st_name,
-		     (unsigned long long)r.r_offset);
+		     secname, refsymname, elf->strtab + where->st_name);
 	} else {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
 		     modname, fromsec, (unsigned long long)r.r_offset,

commit eb8f689046b857874e964463619f09df06d59fad
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jan 20 20:07:28 2008 +0100

    Use separate sections for __dev/__cpu/__mem code/data
    
    Introducing separate sections for __dev* (HOTPLUG),
    __cpu* (HOTPLUG_CPU) and __mem* (MEMORY_HOTPLUG)
    allows us to do a much more reliable Section mismatch
    check in modpost. We are no longer dependent on the actual
    configuration of for example HOTPLUG.
    
    This has the effect that all users see much more
    Section mismatch warnings than before because they
    were almost all hidden when HOTPLUG was enabled.
    The advantage of this is that when building a piece
    of code then it is much more likely that the Section
    mismatch errors are spotted and the warnings will be
    felt less random of nature.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Adrian Bunk <bunk@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 986513dcd700..730b321680cd 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -670,27 +670,41 @@ int match(const char *sym, const char * const pat[])
 static const char *section_white_list[] =
 	{ ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
 
-#define INIT_DATA_SECTIONS ".init.data$"
-#define EXIT_DATA_SECTIONS ".exit.data$"
+#define ALL_INIT_DATA_SECTIONS \
+	".init.data$", ".devinit.data$", ".cpuinit.data$", ".meminit.data$"
+#define ALL_EXIT_DATA_SECTIONS \
+	".exit.data$", ".devexit.data$", ".cpuexit.data$", ".memexit.data$"
 
-#define INIT_TEXT_SECTIONS ".init.text$"
-#define EXIT_TEXT_SECTIONS ".exit.text$"
+#define ALL_INIT_TEXT_SECTIONS \
+	".init.text$", ".devinit.text$", ".cpuinit.text$", ".meminit.text$"
+#define ALL_EXIT_TEXT_SECTIONS \
+	".exit.text$", ".devexit.text$", ".cpuexit.text$", ".memexit.text$"
 
-#define INIT_SECTIONS INIT_DATA_SECTIONS, INIT_TEXT_SECTIONS
-#define EXIT_SECTIONS EXIT_DATA_SECTIONS, EXIT_TEXT_SECTIONS
+#define ALL_INIT_SECTIONS ALL_INIT_DATA_SECTIONS, ALL_INIT_TEXT_SECTIONS
+#define ALL_EXIT_SECTIONS ALL_EXIT_DATA_SECTIONS, ALL_EXIT_TEXT_SECTIONS
 
 #define DATA_SECTIONS ".data$", ".data.rel$"
 #define TEXT_SECTIONS ".text$"
 
+#define INIT_SECTIONS      ".init.data$", ".init.text$"
+#define DEV_INIT_SECTIONS  ".devinit.data$", ".devinit.text$"
+#define CPU_INIT_SECTIONS  ".cpuinit.data$", ".cpuinit.text$"
+#define MEM_INIT_SECTIONS  ".meminit.data$", ".meminit.text$"
+
+#define EXIT_SECTIONS      ".exit.data$", ".exit.text$"
+#define DEV_EXIT_SECTIONS  ".devexit.data$", ".devexit.text$"
+#define CPU_EXIT_SECTIONS  ".cpuexit.data$", ".cpuexit.text$"
+#define MEM_EXIT_SECTIONS  ".memexit.data$", ".memexit.text$"
+
 /* init data sections */
-static const char *init_data_sections[] = { INIT_DATA_SECTIONS, NULL };
+static const char *init_data_sections[] = { ALL_INIT_DATA_SECTIONS, NULL };
 
 /* all init sections */
-static const char *init_sections[] = { INIT_SECTIONS, NULL };
+static const char *init_sections[] = { ALL_INIT_SECTIONS, NULL };
 
 /* All init and exit sections (code + data) */
 static const char *init_exit_sections[] =
-	{INIT_SECTIONS, EXIT_SECTIONS, NULL };
+	{ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL };
 
 /* data section */
 static const char *data_sections[] = { DATA_SECTIONS, NULL };
@@ -734,22 +748,32 @@ const struct sectioncheck sectioncheck[] = {
  */
 {
 	.fromsec = { TEXT_SECTIONS, DATA_SECTIONS, NULL },
-	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL }
+	.tosec   = { ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL }
+},
+/* Do not reference init code/data from devinit/cpuinit/meminit code/data */
+{
+	.fromsec = { DEV_INIT_SECTIONS, CPU_INIT_SECTIONS, MEM_INIT_SECTIONS, NULL },
+	.tosec   = { INIT_SECTIONS, NULL }
+},
+/* Do not reference exit code/data from devexit/cpuexit/memexit code/data */
+{
+	.fromsec = { DEV_EXIT_SECTIONS, CPU_EXIT_SECTIONS, MEM_EXIT_SECTIONS, NULL },
+	.tosec   = { EXIT_SECTIONS, NULL }
 },
 /* Do not use exit code/data from init code */
 {
-	.fromsec = { INIT_SECTIONS, NULL },
-	.tosec   = { EXIT_SECTIONS, NULL },
+	.fromsec = { ALL_INIT_SECTIONS, NULL },
+	.tosec   = { ALL_EXIT_SECTIONS, NULL },
 },
 /* Do not use init code/data from exit code */
 {
-	.fromsec = { EXIT_SECTIONS, NULL },
-	.tosec   = { INIT_SECTIONS, NULL }
+	.fromsec = { ALL_EXIT_SECTIONS, NULL },
+	.tosec   = { ALL_INIT_SECTIONS, NULL }
 },
 /* Do not export init/exit functions or data */
 {
 	.fromsec = { "__ksymtab*", NULL },
-	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL }
+	.tosec   = { ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL }
 }
 };
 

commit 6c5bd235bfd0b92188915465c7dfb377c1a4d451
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jan 20 10:43:27 2008 +0100

    kbuild: check section names consistently in modpost
    
    Now that match() is introduced use it consistently so
    we can share the section name definitions.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6c206b9212b1..986513dcd700 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -625,6 +625,7 @@ static int number_prefix(const char *sym)
 
 /* The pattern is an array of simple patterns.
  * "foo" will match an exact string equal to "foo"
+ * "*foo" will match a string that ends with "foo"
  * "foo*" will match a string that begins with "foo"
  * "foo$" will match a string equal to "foo" or "foo.1"
  *   where the '1' can be any number including several digits.
@@ -638,8 +639,13 @@ int match(const char *sym, const char * const pat[])
 		p = *pat++;
 		const char *endp = p + strlen(p) - 1;
 
+		/* "*foo" */
+		if (*p == '*') {
+			if (strrcmp(sym, p + 1) == 0)
+				return 1;
+		}
 		/* "foo*" */
-		if (*endp == '*') {
+		else if (*endp == '*') {
 			if (strncmp(sym, p, strlen(p) - 1) == 0)
 				return 1;
 		}
@@ -660,54 +666,6 @@ int match(const char *sym, const char * const pat[])
 	return 0;
 }
 
-/*
- * Functions used only during module init is marked __init and is stored in
- * a .init.text section. Likewise data is marked __initdata and stored in
- * a .init.data section.
- * If this section is one of these sections return 1
- * See include/linux/init.h for the details
- */
-static int init_section(const char *name)
-{
-	if (strcmp(name, ".init") == 0)
-		return 1;
-	if (strncmp(name, ".init.", strlen(".init.")) == 0)
-		return 1;
-	return 0;
-}
-
-/*
- * Functions used only during module exit is marked __exit and is stored in
- * a .exit.text section. Likewise data is marked __exitdata and stored in
- * a .exit.data section.
- * If this section is one of these sections return 1
- * See include/linux/init.h for the details
- **/
-static int exit_section(const char *name)
-{
-	if (strcmp(name, ".exit.text") == 0)
-		return 1;
-	if (strcmp(name, ".exit.data") == 0)
-		return 1;
-	return 0;
-
-}
-
-/*
- * Data sections are named like this:
- * .data | .data.rel | .data.rel.*
- * Return 1 if the specified section is a data section
- */
-static int data_section(const char *name)
-{
-	if ((strcmp(name, ".data") == 0) ||
-	    (strcmp(name, ".data.rel") == 0) ||
-	    (strncmp(name, ".data.rel.", strlen(".data.rel.")) == 0))
-		return 1;
-	else
-		return 0;
-}
-
 /* sections that we do not want to do full section mismatch check on */
 static const char *section_white_list[] =
 	{ ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
@@ -721,9 +679,50 @@ static const char *section_white_list[] =
 #define INIT_SECTIONS INIT_DATA_SECTIONS, INIT_TEXT_SECTIONS
 #define EXIT_SECTIONS EXIT_DATA_SECTIONS, EXIT_TEXT_SECTIONS
 
-#define DATA_SECTIONS ".data$"
+#define DATA_SECTIONS ".data$", ".data.rel$"
 #define TEXT_SECTIONS ".text$"
 
+/* init data sections */
+static const char *init_data_sections[] = { INIT_DATA_SECTIONS, NULL };
+
+/* all init sections */
+static const char *init_sections[] = { INIT_SECTIONS, NULL };
+
+/* All init and exit sections (code + data) */
+static const char *init_exit_sections[] =
+	{INIT_SECTIONS, EXIT_SECTIONS, NULL };
+
+/* data section */
+static const char *data_sections[] = { DATA_SECTIONS, NULL };
+
+/* sections that may refer to an init/exit section with no warning */
+static const char *initref_sections[] =
+{
+	".text.init.refok*",
+	".exit.text.refok*",
+	".data.init.refok*",
+	NULL
+};
+
+
+/* symbols in .data that may refer to init/exit sections */
+static const char *symbol_white_list[] =
+{
+	"*driver",
+	"*_template", /* scsi uses *_template a lot */
+	"*_timer",    /* arm uses ops structures named _timer a lot */
+	"*_sht",      /* scsi also used *_sht to some extent */
+	"*_ops",
+	"*_probe",
+	"*_probe_one",
+	"*_console",
+	NULL
+};
+
+static const char *head_sections[] = { ".head.text*", NULL };
+static const char *linker_symbols[] =
+	{ "__init_begin", "_sinittext", "_einittext", NULL };
+
 struct sectioncheck {
 	const char *fromsec[20];
 	const char *tosec[20];
@@ -817,55 +816,30 @@ static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
 			    const char *refsymname)
 {
-	const char **s;
-	const char *pat2sym[] = {
-		"driver",
-		"_template", /* scsi uses *_template a lot */
-		"_timer",    /* arm uses ops structures named _timer a lot */
-		"_sht",      /* scsi also used *_sht to some extent */
-		"_ops",
-		"_probe",
-		"_probe_one",
-		"_console",
-		NULL
-	};
-
-	const char *pat3refsym[] = {
-		"__init_begin",
-		"_sinittext",
-		"_einittext",
-		NULL
-	};
-
 	/* Check for pattern 0 */
-	if ((strncmp(fromsec, ".text.init.refok", strlen(".text.init.refok")) == 0) ||
-	    (strncmp(fromsec, ".exit.text.refok", strlen(".exit.text.refok")) == 0) ||
-	    (strncmp(fromsec, ".data.init.refok", strlen(".data.init.refok")) == 0))
+	if (match(fromsec, initref_sections))
 		return 1;
 
 	/* Check for pattern 1 */
-	if ((strcmp(tosec, ".init.data") == 0) &&
-	    (strncmp(fromsec, ".data", strlen(".data")) == 0) &&
+	if (match(tosec, init_data_sections) &&
+	    match(fromsec, data_sections) &&
 	    (strncmp(atsym, "__param", strlen("__param")) == 0))
 		return 1;
 
 	/* Check for pattern 2 */
-	if ((init_section(tosec) || exit_section(tosec))
-	    && data_section(fromsec))
-		for (s = pat2sym; *s; s++)
-			if (strrcmp(atsym, *s) == 0)
-				return 1;
+	if (match(tosec, init_exit_sections) &&
+	    match(fromsec, data_sections) &&
+	    match(atsym, symbol_white_list))
+		return 1;
 
 	/* Check for pattern 3 */
-	if ((strcmp(fromsec, ".text.head") == 0) &&
-	    ((strcmp(tosec, ".init.data") == 0) ||
-	    (strcmp(tosec, ".init.text") == 0)))
+	if (match(fromsec, head_sections) &&
+	    match(tosec, init_sections))
 	return 1;
 
 	/* Check for pattern 4 */
-	for (s = pat3refsym; *s; s++)
-		if (strcmp(refsymname, *s) == 0)
-			return 1;
+	if (match(refsymname, linker_symbols))
+		return 1;
 
 	return 0;
 }

commit 10668220a97cb8b3fa1011a252175737ba750d51
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jan 13 22:21:31 2008 +0100

    kbuild: introduce blacklisting in modpost
    
    Change the logic in modpost so we identify all the
    bad combinations of sections that refer to other
    sections.
    Compared to the previous approach we are much less
    dependent on knowledge of what additional sections
    the tool chain uses and thus we can keep the false
    positives low.
    
    The implmentation is changed to use a table based
    lookup and we now check all combinations in first
    pass so we no longer need separate passes for init
    and exit sections.
    
    Tested that the same warnings are generated for
    an allyesconfig build without CONFIG_HOTPLUG.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Adrian Bunk <bunk@kernel.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e4630135979c..6c206b9212b1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -605,6 +605,61 @@ static int strrcmp(const char *s, const char *sub)
 	return memcmp(s + slen - sublen, sub, sublen);
 }
 
+/* if sym is empty or point to a string
+ * like ".[0-9]+" then return 1.
+ * This is the optional prefix added by ld to some sections
+ */
+static int number_prefix(const char *sym)
+{
+	if (*sym++ == '\0')
+		return 1;
+	if (*sym != '.')
+		return 0;
+	do {
+		char c = *sym++;
+		if (c < '0' || c > '9')
+			return 0;
+	} while (*sym);
+	return 1;
+}
+
+/* The pattern is an array of simple patterns.
+ * "foo" will match an exact string equal to "foo"
+ * "foo*" will match a string that begins with "foo"
+ * "foo$" will match a string equal to "foo" or "foo.1"
+ *   where the '1' can be any number including several digits.
+ *   The $ syntax is for sections where ld append a dot number
+ *   to make section name unique.
+ */
+int match(const char *sym, const char * const pat[])
+{
+	const char *p;
+	while (*pat) {
+		p = *pat++;
+		const char *endp = p + strlen(p) - 1;
+
+		/* "foo*" */
+		if (*endp == '*') {
+			if (strncmp(sym, p, strlen(p) - 1) == 0)
+				return 1;
+		}
+		/* "foo$" */
+		else if (*endp == '$') {
+			if (strncmp(sym, p, strlen(p) - 1) == 0) {
+				if (number_prefix(sym + strlen(p) - 1))
+					return 1;
+			}
+		}
+		/* no wildcards */
+		else {
+			if (strcmp(p, sym) == 0)
+				return 1;
+		}
+	}
+	/* no match */
+	return 0;
+}
+
 /*
  * Functions used only during module init is marked __init and is stored in
  * a .init.text section. Likewise data is marked __initdata and stored in
@@ -653,6 +708,68 @@ static int data_section(const char *name)
 		return 0;
 }
 
+/* sections that we do not want to do full section mismatch check on */
+static const char *section_white_list[] =
+	{ ".debug*", ".stab*", ".note*", ".got*", ".toc*", NULL };
+
+#define INIT_DATA_SECTIONS ".init.data$"
+#define EXIT_DATA_SECTIONS ".exit.data$"
+
+#define INIT_TEXT_SECTIONS ".init.text$"
+#define EXIT_TEXT_SECTIONS ".exit.text$"
+
+#define INIT_SECTIONS INIT_DATA_SECTIONS, INIT_TEXT_SECTIONS
+#define EXIT_SECTIONS EXIT_DATA_SECTIONS, EXIT_TEXT_SECTIONS
+
+#define DATA_SECTIONS ".data$"
+#define TEXT_SECTIONS ".text$"
+
+struct sectioncheck {
+	const char *fromsec[20];
+	const char *tosec[20];
+};
+
+const struct sectioncheck sectioncheck[] = {
+/* Do not reference init/exit code/data from
+ * normal code and data
+ */
+{
+	.fromsec = { TEXT_SECTIONS, DATA_SECTIONS, NULL },
+	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL }
+},
+/* Do not use exit code/data from init code */
+{
+	.fromsec = { INIT_SECTIONS, NULL },
+	.tosec   = { EXIT_SECTIONS, NULL },
+},
+/* Do not use init code/data from exit code */
+{
+	.fromsec = { EXIT_SECTIONS, NULL },
+	.tosec   = { INIT_SECTIONS, NULL }
+},
+/* Do not export init/exit functions or data */
+{
+	.fromsec = { "__ksymtab*", NULL },
+	.tosec   = { INIT_SECTIONS, EXIT_SECTIONS, NULL }
+}
+};
+
+static int section_mismatch(const char *fromsec, const char *tosec)
+{
+	int i;
+	int elems = sizeof(sectioncheck) / sizeof(struct sectioncheck);
+	const struct sectioncheck *check = &sectioncheck[0];
+
+	for (i = 0; i < elems; i++) {
+		if (match(fromsec, check->fromsec) &&
+		    match(tosec, check->tosec))
+			return 1;
+		check++;
+	}
+	return 0;
+}
+
+
 /**
  * Whitelist to allow certain references to pass with no warning.
  *
@@ -695,18 +812,11 @@ static int data_section(const char *name)
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
- * Pattern 5:
- *   Xtensa uses literal sections for constants that are accessed PC-relative.
- *   Literal sections may safely reference their text sections.
- *   (Note that the name for the literal section omits any trailing '.text')
- *   tosec = <section>[.text]
- *   fromsec = <section>.literal
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
 			    const char *refsymname)
 {
-	int len;
 	const char **s;
 	const char *pat2sym[] = {
 		"driver",
@@ -757,15 +867,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		if (strcmp(refsymname, *s) == 0)
 			return 1;
 
-	/* Check for pattern 5 */
-	if (strrcmp(tosec, ".text") == 0)
-		len = strlen(tosec) - strlen(".text");
-	else
-		len = strlen(tosec);
-	if ((strncmp(tosec, fromsec, len) == 0) && (strlen(fromsec) > len) &&
-	    (strcmp(fromsec + len, ".literal") == 0))
-		return 1;
-
 	return 0;
 }
 
@@ -1011,8 +1112,7 @@ static int addend_mips_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 }
 
 static void section_rela(const char *modname, struct elf_info *elf,
-                         Elf_Shdr *sechdr, int section(const char *),
-                         int section_ref_ok(const char *))
+                         Elf_Shdr *sechdr)
 {
 	Elf_Sym  *sym;
 	Elf_Rela *rela;
@@ -1031,7 +1131,7 @@ static void section_rela(const char *modname, struct elf_info *elf,
 	fromsec = secstrings + sechdr->sh_name;
 	fromsec += strlen(".rela");
 	/* if from section (name) is know good then skip it */
-	if (section_ref_ok(fromsec))
+	if (match(fromsec, section_white_list))
 		return;
 
 	for (rela = start; rela < stop; rela++) {
@@ -1059,14 +1159,13 @@ static void section_rela(const char *modname, struct elf_info *elf,
 
 		tosec = secstrings +
 			elf->sechdrs[sym->st_shndx].sh_name;
-		if (section(tosec))
+		if (section_mismatch(fromsec, tosec))
 			warn_sec_mismatch(modname, fromsec, elf, sym, r);
 	}
 }
 
 static void section_rel(const char *modname, struct elf_info *elf,
-                        Elf_Shdr *sechdr, int section(const char *),
-                        int section_ref_ok(const char *))
+                        Elf_Shdr *sechdr)
 {
 	Elf_Sym *sym;
 	Elf_Rel *rel;
@@ -1085,7 +1184,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 	fromsec = secstrings + sechdr->sh_name;
 	fromsec += strlen(".rel");
 	/* if from section (name) is know good then skip it */
-	if (section_ref_ok(fromsec))
+	if (match(fromsec, section_white_list))
 		return;
 
 	for (rel = start; rel < stop; rel++) {
@@ -1127,7 +1226,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
 
 		tosec = secstrings +
 			elf->sechdrs[sym->st_shndx].sh_name;
-		if (section(tosec))
+		if (section_mismatch(fromsec, tosec))
 			warn_sec_mismatch(modname, fromsec, elf, sym, r);
 	}
 }
@@ -1145,9 +1244,7 @@ static void section_rel(const char *modname, struct elf_info *elf,
  * be discarded and warns about it.
  **/
 static void check_sec_ref(struct module *mod, const char *modname,
-			  struct elf_info *elf,
-			  int section(const char *),
-			  int section_ref_ok(const char *))
+                          struct elf_info *elf)
 {
 	int i;
 	Elf_Ehdr *hdr = elf->hdr;
@@ -1157,156 +1254,12 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	for (i = 0; i < hdr->e_shnum; i++) {
 		/* We want to process only relocation sections and not .init */
 		if (sechdrs[i].sh_type == SHT_RELA)
-			section_rela(modname, elf, &elf->sechdrs[i],
-			             section, section_ref_ok);
+			section_rela(modname, elf, &elf->sechdrs[i]);
 		else if (sechdrs[i].sh_type == SHT_REL)
-			section_rel(modname, elf, &elf->sechdrs[i],
-			            section, section_ref_ok);
+			section_rel(modname, elf, &elf->sechdrs[i]);
 	}
 }
 
-/*
- * Identify sections from which references to either a
- * .init or a .exit section is OK.
- *
- * [OPD] Keith Ownes <kaos@sgi.com> commented:
- * For our future {in}sanity, add a comment that this is the ppc .opd
- * section, not the ia64 .opd section.
- * ia64 .opd should not point to discarded sections.
- * [.rodata] like for .init.text we ignore .rodata references -same reason
- */
-static int initexit_section_ref_ok(const char *name)
-{
-	const char **s;
-	/* Absolute section names */
-	const char *namelist1[] = {
-		"__bug_table",	/* used by powerpc for BUG() */
-		"__ex_table",
-		".altinstructions",
-		".cranges",	/* used by sh64 */
-		".fixup",
-		".machvec",	/* ia64 + powerpc uses these */
-		".machine.desc",
-		".opd",		/* See comment [OPD] */
-		"__dbe_table",
-		".parainstructions",
-		".pdr",
-		".plt",		/* seen on ARCH=um build on x86_64. Harmless */
-		".smp_locks",
-		".stab",
-		".m68k_fixup",
-		".xt.prop",	/* xtensa informational section */
-		".xt.lit",	/* xtensa informational section */
-		NULL
-	};
-	/* Start of section names */
-	const char *namelist2[] = {
-		".debug",
-		".eh_frame",
-		".note",	/* ignore ELF notes - may contain anything */
-		".got",		/* powerpc - global offset table */
-		".toc",		/* powerpc - table of contents */
-		NULL
-	};
-	/* part of section name */
-	const char *namelist3 [] = {
-		".unwind",  /* Sample: IA_64.unwind.exit.text */
-		NULL
-	};
-
-	for (s = namelist1; *s; s++)
-		if (strcmp(*s, name) == 0)
-			return 1;
-	for (s = namelist2; *s; s++)
-		if (strncmp(*s, name, strlen(*s)) == 0)
-			return 1;
-	for (s = namelist3; *s; s++)
-		if (strstr(name, *s) != NULL)
-			return 1;
-	return 0;
-}
-
-
-/*
- * Identify sections from which references to a .init section is OK.
- *
- * Unfortunately references to read only data that referenced .init
- * sections had to be excluded. Almost all of these are false
- * positives, they are created by gcc. The downside of excluding rodata
- * is that there really are some user references from rodata to
- * init code, e.g. drivers/video/vgacon.c:
- *
- * const struct consw vga_con = {
- *        con_startup:            vgacon_startup,
- *
- * where vgacon_startup is __init.  If you want to wade through the false
- * positives, take out the check for rodata.
- */
-static int init_section_ref_ok(const char *name)
-{
-	const char **s;
-	/* Absolute section names */
-	const char *namelist1[] = {
-		"__dbe_table",		/* MIPS generate these */
-		"__ftr_fixup",		/* powerpc cpu feature fixup */
-		"__fw_ftr_fixup",	/* powerpc firmware feature fixup */
-		"__param",
-		".data.rel.ro",		/* used by parisc64 */
-		".init",
-		".text.lock",
-		NULL
-	};
-	/* Start of section names */
-	const char *namelist2[] = {
-		".init.",
-		".pci_fixup",
-		".rodata",
-		NULL
-	};
-
-	if (initexit_section_ref_ok(name))
-		return 1;
-
-	for (s = namelist1; *s; s++)
-		if (strcmp(*s, name) == 0)
-			return 1;
-	for (s = namelist2; *s; s++)
-		if (strncmp(*s, name, strlen(*s)) == 0)
-			return 1;
-
-	/* If section name ends with ".init" we allow references
-	 * as is the case with .initcallN.init, .early_param.init,
-	 * .taglist.init etc
-	 */
-	if (strrcmp(name, ".init") == 0)
-		return 1;
-	return 0;
-}
-
-/*
- * Identify sections from which references to a .exit section is OK.
- */
-static int exit_section_ref_ok(const char *name)
-{
-	const char **s;
-	/* Absolute section names */
-	const char *namelist1[] = {
-		".exit.data",
-		".exit.text",
-		".exitcall.exit",
-		".rodata",
-		NULL
-	};
-
-	if (initexit_section_ref_ok(name))
-		return 1;
-
-	for (s = namelist1; *s; s++)
-		if (strcmp(*s, name) == 0)
-			return 1;
-	return 0;
-}
-
 static void read_symbols(char *modname)
 {
 	const char *symname;
@@ -1347,10 +1300,8 @@ static void read_symbols(char *modname)
 		handle_moddevtable(mod, &info, sym, symname);
 	}
 	if (!is_vmlinux(modname) ||
-	     (is_vmlinux(modname) && vmlinux_section_warnings)) {
-		check_sec_ref(mod, modname, &info, init_section, init_section_ref_ok);
-		check_sec_ref(mod, modname, &info, exit_section, exit_section_ref_ok);
-	}
+	     (is_vmlinux(modname) && vmlinux_section_warnings))
+		check_sec_ref(mod, modname, &info);
 
 	version = get_modinfo(info.modinfo, info.modinfo_len, "version");
 	if (version)

commit 5b24c0715fc4c71e60e9a684248cc49d62dfa900
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 18 21:49:29 2008 +0100

    kbuild: code refactoring in modpost
    
    Split a too long function up in smaller bits to make
    prgram logic easier to follow.
    A few related changes done due to parameter
    changes.
    
    No functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 902ee55f327f..e4630135979c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -937,19 +937,19 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 }
 
 static unsigned int *reloc_location(struct elf_info *elf,
-					   int rsection, Elf_Rela *r)
+				    Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	Elf_Shdr *sechdrs = elf->sechdrs;
-	int section = sechdrs[rsection].sh_info;
+	int section = sechdr->sh_info;
 
 	return (void *)elf->hdr + sechdrs[section].sh_offset +
 		(r->r_offset - sechdrs[section].sh_addr);
 }
 
-static int addend_386_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
+static int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	unsigned int r_typ = ELF_R_TYPE(r->r_info);
-	unsigned int *location = reloc_location(elf, rsection, r);
+	unsigned int *location = reloc_location(elf, sechdr, r);
 
 	switch (r_typ) {
 	case R_386_32:
@@ -965,7 +965,7 @@ static int addend_386_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 	return 0;
 }
 
-static int addend_arm_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
+static int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	unsigned int r_typ = ELF_R_TYPE(r->r_info);
 
@@ -978,8 +978,8 @@ static int addend_arm_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 	case R_ARM_PC24:
 		/* From ARM ABI: ((S + A) | T) - P */
 		r->r_addend = (int)(long)(elf->hdr +
-		              elf->sechdrs[rsection].sh_offset +
-		              (r->r_offset - elf->sechdrs[rsection].sh_addr));
+		              sechdr->sh_offset +
+		              (r->r_offset - sechdr->sh_addr));
 		break;
 	default:
 		return 1;
@@ -987,10 +987,10 @@ static int addend_arm_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 	return 0;
 }
 
-static int addend_mips_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
+static int addend_mips_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)
 {
 	unsigned int r_typ = ELF_R_TYPE(r->r_info);
-	unsigned int *location = reloc_location(elf, rsection, r);
+	unsigned int *location = reloc_location(elf, sechdr, r);
 	unsigned int inst;
 
 	if (r_typ == R_MIPS_HI16)
@@ -1010,6 +1010,128 @@ static int addend_mips_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 	return 0;
 }
 
+static void section_rela(const char *modname, struct elf_info *elf,
+                         Elf_Shdr *sechdr, int section(const char *),
+                         int section_ref_ok(const char *))
+{
+	Elf_Sym  *sym;
+	Elf_Rela *rela;
+	Elf_Rela r;
+	unsigned int r_sym;
+	const char *fromsec;
+	const char * tosec;
+
+	Elf_Ehdr *hdr = elf->hdr;
+	Elf_Rela *start = (void *)hdr + sechdr->sh_offset;
+	Elf_Rela *stop  = (void *)start + sechdr->sh_size;
+
+	const char *secstrings = (void *)hdr +
+				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
+
+	fromsec = secstrings + sechdr->sh_name;
+	fromsec += strlen(".rela");
+	/* if from section (name) is know good then skip it */
+	if (section_ref_ok(fromsec))
+		return;
+
+	for (rela = start; rela < stop; rela++) {
+		r.r_offset = TO_NATIVE(rela->r_offset);
+#if KERNEL_ELFCLASS == ELFCLASS64
+		if (hdr->e_machine == EM_MIPS) {
+			unsigned int r_typ;
+			r_sym = ELF64_MIPS_R_SYM(rela->r_info);
+			r_sym = TO_NATIVE(r_sym);
+			r_typ = ELF64_MIPS_R_TYPE(rela->r_info);
+			r.r_info = ELF64_R_INFO(r_sym, r_typ);
+		} else {
+			r.r_info = TO_NATIVE(rela->r_info);
+			r_sym = ELF_R_SYM(r.r_info);
+		}
+#else
+		r.r_info = TO_NATIVE(rela->r_info);
+		r_sym = ELF_R_SYM(r.r_info);
+#endif
+		r.r_addend = TO_NATIVE(rela->r_addend);
+		sym = elf->symtab_start + r_sym;
+		/* Skip special sections */
+		if (sym->st_shndx >= SHN_LORESERVE)
+			continue;
+
+		tosec = secstrings +
+			elf->sechdrs[sym->st_shndx].sh_name;
+		if (section(tosec))
+			warn_sec_mismatch(modname, fromsec, elf, sym, r);
+	}
+}
+
+static void section_rel(const char *modname, struct elf_info *elf,
+                        Elf_Shdr *sechdr, int section(const char *),
+                        int section_ref_ok(const char *))
+{
+	Elf_Sym *sym;
+	Elf_Rel *rel;
+	Elf_Rela r;
+	unsigned int r_sym;
+	const char *fromsec;
+	const char * tosec;
+
+	Elf_Ehdr *hdr = elf->hdr;
+	Elf_Rel *start = (void *)hdr + sechdr->sh_offset;
+	Elf_Rel *stop  = (void *)start + sechdr->sh_size;
+
+	const char *secstrings = (void *)hdr +
+				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
+
+	fromsec = secstrings + sechdr->sh_name;
+	fromsec += strlen(".rel");
+	/* if from section (name) is know good then skip it */
+	if (section_ref_ok(fromsec))
+		return;
+
+	for (rel = start; rel < stop; rel++) {
+		r.r_offset = TO_NATIVE(rel->r_offset);
+#if KERNEL_ELFCLASS == ELFCLASS64
+		if (hdr->e_machine == EM_MIPS) {
+			unsigned int r_typ;
+			r_sym = ELF64_MIPS_R_SYM(rel->r_info);
+			r_sym = TO_NATIVE(r_sym);
+			r_typ = ELF64_MIPS_R_TYPE(rel->r_info);
+			r.r_info = ELF64_R_INFO(r_sym, r_typ);
+		} else {
+			r.r_info = TO_NATIVE(rel->r_info);
+			r_sym = ELF_R_SYM(r.r_info);
+		}
+#else
+		r.r_info = TO_NATIVE(rel->r_info);
+		r_sym = ELF_R_SYM(r.r_info);
+#endif
+		r.r_addend = 0;
+		switch (hdr->e_machine) {
+		case EM_386:
+			if (addend_386_rel(elf, sechdr, &r))
+				continue;
+			break;
+		case EM_ARM:
+			if (addend_arm_rel(elf, sechdr, &r))
+				continue;
+			break;
+		case EM_MIPS:
+			if (addend_mips_rel(elf, sechdr, &r))
+				continue;
+			break;
+		}
+		sym = elf->symtab_start + r_sym;
+		/* Skip special sections */
+		if (sym->st_shndx >= SHN_LORESERVE)
+			continue;
+
+		tosec = secstrings +
+			elf->sechdrs[sym->st_shndx].sh_name;
+		if (section(tosec))
+			warn_sec_mismatch(modname, fromsec, elf, sym, r);
+	}
+}
+
 /**
  * A module includes a number of sections that are discarded
  * either when loaded or when used as built-in.
@@ -1028,108 +1150,18 @@ static void check_sec_ref(struct module *mod, const char *modname,
 			  int section_ref_ok(const char *))
 {
 	int i;
-	Elf_Sym  *sym;
 	Elf_Ehdr *hdr = elf->hdr;
 	Elf_Shdr *sechdrs = elf->sechdrs;
-	const char *secstrings = (void *)hdr +
-				 sechdrs[hdr->e_shstrndx].sh_offset;
 
 	/* Walk through all sections */
 	for (i = 0; i < hdr->e_shnum; i++) {
-		const char *name = secstrings + sechdrs[i].sh_name;
-		const char *secname;
-		Elf_Rela r;
-		unsigned int r_sym;
 		/* We want to process only relocation sections and not .init */
-		if (sechdrs[i].sh_type == SHT_RELA) {
-			Elf_Rela *rela;
-			Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
-			Elf_Rela *stop  = (void *)start + sechdrs[i].sh_size;
-			name += strlen(".rela");
-			if (section_ref_ok(name))
-				continue;
-
-			for (rela = start; rela < stop; rela++) {
-				r.r_offset = TO_NATIVE(rela->r_offset);
-#if KERNEL_ELFCLASS == ELFCLASS64
-				if (hdr->e_machine == EM_MIPS) {
-					unsigned int r_typ;
-					r_sym = ELF64_MIPS_R_SYM(rela->r_info);
-					r_sym = TO_NATIVE(r_sym);
-					r_typ = ELF64_MIPS_R_TYPE(rela->r_info);
-					r.r_info = ELF64_R_INFO(r_sym, r_typ);
-				} else {
-					r.r_info = TO_NATIVE(rela->r_info);
-					r_sym = ELF_R_SYM(r.r_info);
-				}
-#else
-				r.r_info = TO_NATIVE(rela->r_info);
-				r_sym = ELF_R_SYM(r.r_info);
-#endif
-				r.r_addend = TO_NATIVE(rela->r_addend);
-				sym = elf->symtab_start + r_sym;
-				/* Skip special sections */
-				if (sym->st_shndx >= SHN_LORESERVE)
-					continue;
-
-				secname = secstrings +
-					sechdrs[sym->st_shndx].sh_name;
-				if (section(secname))
-					warn_sec_mismatch(modname, name,
-							  elf, sym, r);
-			}
-		} else if (sechdrs[i].sh_type == SHT_REL) {
-			Elf_Rel *rel;
-			Elf_Rel *start = (void *)hdr + sechdrs[i].sh_offset;
-			Elf_Rel *stop  = (void *)start + sechdrs[i].sh_size;
-			name += strlen(".rel");
-			if (section_ref_ok(name))
-				continue;
-
-			for (rel = start; rel < stop; rel++) {
-				r.r_offset = TO_NATIVE(rel->r_offset);
-#if KERNEL_ELFCLASS == ELFCLASS64
-				if (hdr->e_machine == EM_MIPS) {
-					unsigned int r_typ;
-					r_sym = ELF64_MIPS_R_SYM(rel->r_info);
-					r_sym = TO_NATIVE(r_sym);
-					r_typ = ELF64_MIPS_R_TYPE(rel->r_info);
-					r.r_info = ELF64_R_INFO(r_sym, r_typ);
-				} else {
-					r.r_info = TO_NATIVE(rel->r_info);
-					r_sym = ELF_R_SYM(r.r_info);
-				}
-#else
-				r.r_info = TO_NATIVE(rel->r_info);
-				r_sym = ELF_R_SYM(r.r_info);
-#endif
-				r.r_addend = 0;
-				switch (hdr->e_machine) {
-				case EM_386:
-					if (addend_386_rel(elf, i, &r))
-						continue;
-					break;
-				case EM_ARM:
-					if (addend_arm_rel(elf, i, &r))
-						continue;
-					break;
-				case EM_MIPS:
-					if (addend_mips_rel(elf, i, &r))
-						continue;
-					break;
-				}
-				sym = elf->symtab_start + r_sym;
-				/* Skip special sections */
-				if (sym->st_shndx >= SHN_LORESERVE)
-					continue;
-
-				secname = secstrings +
-					sechdrs[sym->st_shndx].sh_name;
-				if (section(secname))
-					warn_sec_mismatch(modname, name,
-							  elf, sym, r);
-			}
-		}
+		if (sechdrs[i].sh_type == SHT_RELA)
+			section_rela(modname, elf, &elf->sechdrs[i],
+			             section, section_ref_ok);
+		else if (sechdrs[i].sh_type == SHT_REL)
+			section_rel(modname, elf, &elf->sechdrs[i],
+			            section, section_ref_ok);
 	}
 }
 

commit 9ad21c3f3ecffeb56be7b35030d7ec2f30b6fe11
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 18 21:04:34 2008 +0100

    kbuild: try harder to find symbol names in modpost
    
    The relocation record sometimes contained an address
    which was not an exactly match for a symbol.
    
    Implment some simple logic such that if there
    is a symbol within 20 bytes of the address contained
    in the relocation record then print the name of this
    symbol.
    
    With this change modpost could find symbol names
    for the remaining .init.text symbols in my
    allyesconfig build for x86_64.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 46660a4f9e22..902ee55f327f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -776,10 +776,13 @@ static int secref_whitelist(const char *modname, const char *tosec,
  * In other cases the symbol needs to be looked up in the symbol table
  * based on section and address.
  *  **/
-static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
+static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,
 				Elf_Sym *relsym)
 {
 	Elf_Sym *sym;
+	Elf_Sym *near = NULL;
+	Elf64_Sword distance = 20;
+	Elf64_Sword d;
 
 	if (relsym->st_name != 0)
 		return relsym;
@@ -790,8 +793,20 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 			continue;
 		if (sym->st_value == addr)
 			return sym;
+		/* Find a symbol nearby - addr are maybe negative */
+		d = sym->st_value - addr;
+		if (d < 0)
+			d = addr - sym->st_value;
+		if (d < distance) {
+			distance = d;
+			near = sym;
+		}
 	}
-	return NULL;
+	/* We need a close match */
+	if (distance < 20)
+		return near;
+	else
+		return NULL;
 }
 
 static inline int is_arm_mapping_symbol(const char *str)

commit d1f25e6658943569f2713dfde1b9d74e2f6c7243
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Jan 17 21:17:42 2008 +0100

    kbuild: fix so modpost can now check any .o file
    
    It is very convinient to say:
    scripts/mod/modpost mm/built-in.o
    
    to check if any section mismatch errors occured
    in mm/ (as an example).
    Fix it so this is possible again.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 696d2a59e4b8..46660a4f9e22 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1299,7 +1299,8 @@ static void read_symbols(char *modname)
 		handle_modversions(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);
 	}
-	if (is_vmlinux(modname) && vmlinux_section_warnings) {
+	if (!is_vmlinux(modname) ||
+	     (is_vmlinux(modname) && vmlinux_section_warnings)) {
 		check_sec_ref(mod, modname, &info, init_section, init_section_ref_ok);
 		check_sec_ref(mod, modname, &info, exit_section, exit_section_ref_ok);
 	}

commit df578e7d831b4d280bf7c621eafb737e78cd26eb
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 11 19:17:15 2008 +0100

    kbuild: clean up modpost.c
    
    akpm complained about overly long lines in modpost.c and
    when started additional style issues were fixed:
    
    o Updated my copyright
    o Removed unneeded {}
    o Drop assignments in if ()
    o Spaces around operators
    o Break long lines
    o locate * near variable not type
    o Fix a format specifier for sizeof()
    o Corrected placement of '{' and '}'
    o spaces to tabs (but use tabs only for indention)
    
    modpost.c is not checkpatch clean. Readability were favoured
    on top of checkpatch compliance.
    But checkpatch were used to find additional stuff to clean up.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4d1c59063b27..696d2a59e4b8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2,7 +2,7 @@
  *
  * Copyright 2003       Kai Germaschewski
  * Copyright 2002-2004  Rusty Russell, IBM Corporation
- * Copyright 2006       Sam Ravnborg
+ * Copyright 2006-2008  Sam Ravnborg
  * Based in part on module-init-tools/depmod.c,file2alias
  *
  * This software may be used and distributed according to the terms
@@ -74,7 +74,8 @@ static int is_vmlinux(const char *modname)
 {
 	const char *myname;
 
-	if ((myname = strrchr(modname, '/')))
+	myname = strrchr(modname, '/');
+	if (myname)
 		myname++;
 	else
 		myname = modname;
@@ -85,14 +86,13 @@ static int is_vmlinux(const char *modname)
 
 void *do_nofail(void *ptr, const char *expr)
 {
-	if (!ptr) {
+	if (!ptr)
 		fatal("modpost: Memory allocation failure: %s.\n", expr);
-	}
+
 	return ptr;
 }
 
 /* A list of all modules we processed */
-
 static struct module *modules;
 
 static struct module *find_module(char *modname)
@@ -115,7 +115,8 @@ static struct module *new_module(char *modname)
 	p = NOFAIL(strdup(modname));
 
 	/* strip trailing .o */
-	if ((s = strrchr(p, '.')) != NULL)
+	s = strrchr(p, '.');
+	if (s != NULL)
 		if (strcmp(s, ".o") == 0)
 			*s = '\0';
 
@@ -156,7 +157,7 @@ static inline unsigned int tdb_hash(const char *name)
 	unsigned   i;	/* Used to cycle through random values. */
 
 	/* Set the initial value from the key size. */
-	for (value = 0x238F13AF * strlen(name), i=0; name[i]; i++)
+	for (value = 0x238F13AF * strlen(name), i = 0; name[i]; i++)
 		value = (value + (((unsigned char *)name)[i] << (i*5 % 24)));
 
 	return (1103515243 * value + 12345);
@@ -200,7 +201,7 @@ static struct symbol *find_symbol(const char *name)
 	if (name[0] == '.')
 		name++;
 
-	for (s = symbolhash[tdb_hash(name) % SYMBOL_HASH_SIZE]; s; s=s->next) {
+	for (s = symbolhash[tdb_hash(name) % SYMBOL_HASH_SIZE]; s; s = s->next) {
 		if (strcmp(s->name, name) == 0)
 			return s;
 	}
@@ -225,9 +226,10 @@ static const char *export_str(enum export ex)
 	return export_list[ex].str;
 }
 
-static enum export export_no(const char * s)
+static enum export export_no(const char *s)
 {
 	int i;
+
 	if (!s)
 		return export_unknown;
 	for (i = 0; export_list[i].export != export_unknown; i++) {
@@ -317,7 +319,7 @@ void *grab_file(const char *filename, unsigned long *size)
   * spaces in the beginning of the line is trimmed away.
   * Return a pointer to a static buffer.
   **/
-char* get_next_line(unsigned long *pos, void *file, unsigned long size)
+char *get_next_line(unsigned long *pos, void *file, unsigned long size)
 {
 	static char line[4096];
 	int skip = 1;
@@ -325,8 +327,7 @@ char* get_next_line(unsigned long *pos, void *file, unsigned long size)
 	signed char *p = (signed char *)file + *pos;
 	char *s = line;
 
-	for (; *pos < size ; (*pos)++)
-	{
+	for (; *pos < size ; (*pos)++) {
 		if (skip && isspace(*p)) {
 			p++;
 			continue;
@@ -388,7 +389,9 @@ static int parse_elf(struct elf_info *info, const char *filename)
 
 	/* Check if file offset is correct */
 	if (hdr->e_shoff > info->size) {
-		fatal("section header offset=%lu in file '%s' is bigger then filesize=%lu\n", (unsigned long)hdr->e_shoff, filename, info->size);
+		fatal("section header offset=%lu in file '%s' is bigger than "
+		      "filesize=%lu\n", (unsigned long)hdr->e_shoff,
+		      filename, info->size);
 		return 0;
 	}
 
@@ -409,7 +412,10 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		const char *secname;
 
 		if (sechdrs[i].sh_offset > info->size) {
-			fatal("%s is truncated. sechdrs[i].sh_offset=%lu > sizeof(*hrd)=%lu\n", filename, (unsigned long)sechdrs[i].sh_offset, sizeof(*hdr));
+			fatal("%s is truncated. sechdrs[i].sh_offset=%lu > "
+			      "sizeof(*hrd)=%zu\n", filename,
+			      (unsigned long)sechdrs[i].sh_offset,
+			      sizeof(*hdr));
 			return 0;
 		}
 		secname = secstrings + sechdrs[i].sh_name;
@@ -436,9 +442,9 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		info->strtab       = (void *)hdr +
 			             sechdrs[sechdrs[i].sh_link].sh_offset;
 	}
-	if (!info->symtab_start) {
+	if (!info->symtab_start)
 		fatal("%s has no symtab?\n", filename);
-	}
+
 	/* Fix endianness in symbols */
 	for (sym = info->symtab_start; sym < info->symtab_stop; sym++) {
 		sym->st_shndx = TO_NATIVE(sym->st_shndx);
@@ -507,11 +513,13 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 #endif
 
 		if (memcmp(symname, MODULE_SYMBOL_PREFIX,
-			   strlen(MODULE_SYMBOL_PREFIX)) == 0)
-			mod->unres = alloc_symbol(symname +
-						  strlen(MODULE_SYMBOL_PREFIX),
-						  ELF_ST_BIND(sym->st_info) == STB_WEAK,
-						  mod->unres);
+			   strlen(MODULE_SYMBOL_PREFIX)) == 0) {
+			mod->unres =
+			  alloc_symbol(symname +
+			               strlen(MODULE_SYMBOL_PREFIX),
+			               ELF_ST_BIND(sym->st_info) == STB_WEAK,
+			               mod->unres);
+		}
 		break;
 	default:
 		/* All exported symbols */
@@ -580,21 +588,21 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
  **/
 static int strrcmp(const char *s, const char *sub)
 {
-        int slen, sublen;
+	int slen, sublen;
 
 	if (!s || !sub)
 		return 1;
 
 	slen = strlen(s);
-        sublen = strlen(sub);
+	sublen = strlen(sub);
 
 	if ((slen == 0) || (sublen == 0))
 		return 1;
 
-        if (sublen > slen)
-                return 1;
+	if (sublen > slen)
+		return 1;
 
-        return memcmp(s + slen - sublen, sub, sublen);
+	return memcmp(s + slen - sublen, sub, sublen);
 }
 
 /*
@@ -671,7 +679,8 @@ static int data_section(const char *name)
  *   the pattern is identified by:
  *   tosec   = init or exit section
  *   fromsec = data section
- *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console, *_timer
+ *   atsym = *driver, *_template, *_sht, *_ops, *_probe,
+ *           *probe_one, *_console, *_timer
  *
  * Pattern 3:
  *   Whitelist all refereces from .text.head to .init.data
@@ -731,15 +740,16 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		return 1;
 
 	/* Check for pattern 2 */
-	if ((init_section(tosec) || exit_section(tosec)) && data_section(fromsec))
+	if ((init_section(tosec) || exit_section(tosec))
+	    && data_section(fromsec))
 		for (s = pat2sym; *s; s++)
 			if (strrcmp(atsym, *s) == 0)
 				return 1;
 
 	/* Check for pattern 3 */
 	if ((strcmp(fromsec, ".text.head") == 0) &&
-		((strcmp(tosec, ".init.data") == 0) ||
-		(strcmp(tosec, ".init.text") == 0)))
+	    ((strcmp(tosec, ".init.data") == 0) ||
+	    (strcmp(tosec, ".init.text") == 0)))
 	return 1;
 
 	/* Check for pattern 4 */
@@ -816,7 +826,7 @@ static inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)
  **/
 static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 				 const char *sec,
-			         Elf_Sym **before, Elf_Sym **after)
+				 Elf_Sym **before, Elf_Sym **after)
 {
 	Elf_Sym *sym;
 	Elf_Ehdr *hdr = elf->hdr;
@@ -842,20 +852,15 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 			if ((addr - sym->st_value) < beforediff) {
 				beforediff = addr - sym->st_value;
 				*before = sym;
-			}
-			else if ((addr - sym->st_value) == beforediff) {
+			} else if ((addr - sym->st_value) == beforediff) {
 				*before = sym;
 			}
-		}
-		else
-		{
+		} else {
 			if ((sym->st_value - addr) < afterdiff) {
 				afterdiff = sym->st_value - addr;
 				*after = sym;
-			}
-			else if ((sym->st_value - addr) == afterdiff) {
+			} else if ((sym->st_value - addr) == afterdiff)
 				*after = sym;
-			}
 		}
 	}
 }
@@ -952,12 +957,14 @@ static int addend_arm_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 	switch (r_typ) {
 	case R_ARM_ABS32:
 		/* From ARM ABI: (S + A) | T */
-		r->r_addend = (int)(long)(elf->symtab_start + ELF_R_SYM(r->r_info));
+		r->r_addend = (int)(long)
+		              (elf->symtab_start + ELF_R_SYM(r->r_info));
 		break;
 	case R_ARM_PC24:
 		/* From ARM ABI: ((S + A) | T) - P */
-		r->r_addend = (int)(long)(elf->hdr + elf->sechdrs[rsection].sh_offset +
-		                          (r->r_offset - elf->sechdrs[rsection].sh_addr));
+		r->r_addend = (int)(long)(elf->hdr +
+		              elf->sechdrs[rsection].sh_offset +
+		              (r->r_offset - elf->sechdrs[rsection].sh_addr));
 		break;
 	default:
 		return 1;
@@ -1002,7 +1009,7 @@ static int addend_mips_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
  **/
 static void check_sec_ref(struct module *mod, const char *modname,
 			  struct elf_info *elf,
-			  int section(const char*),
+			  int section(const char *),
 			  int section_ref_ok(const char *))
 {
 	int i;
@@ -1022,7 +1029,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 		if (sechdrs[i].sh_type == SHT_RELA) {
 			Elf_Rela *rela;
 			Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
-			Elf_Rela *stop  = (void*)start + sechdrs[i].sh_size;
+			Elf_Rela *stop  = (void *)start + sechdrs[i].sh_size;
 			name += strlen(".rela");
 			if (section_ref_ok(name))
 				continue;
@@ -1059,7 +1066,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 		} else if (sechdrs[i].sh_type == SHT_REL) {
 			Elf_Rel *rel;
 			Elf_Rel *start = (void *)hdr + sechdrs[i].sh_offset;
-			Elf_Rel *stop  = (void*)start + sechdrs[i].sh_size;
+			Elf_Rel *stop  = (void *)start + sechdrs[i].sh_size;
 			name += strlen(".rel");
 			if (section_ref_ok(name))
 				continue;
@@ -1088,7 +1095,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 						continue;
 					break;
 				case EM_ARM:
-					if(addend_arm_rel(elf, i, &r))
+					if (addend_arm_rel(elf, i, &r))
 						continue;
 					break;
 				case EM_MIPS:
@@ -1126,32 +1133,32 @@ static int initexit_section_ref_ok(const char *name)
 	const char **s;
 	/* Absolute section names */
 	const char *namelist1[] = {
-		"__bug_table",		/* used by powerpc for BUG() */
+		"__bug_table",	/* used by powerpc for BUG() */
 		"__ex_table",
 		".altinstructions",
-		".cranges",		/* used by sh64 */
+		".cranges",	/* used by sh64 */
 		".fixup",
-		".machvec",		/* ia64 + powerpc uses these */
+		".machvec",	/* ia64 + powerpc uses these */
 		".machine.desc",
-		".opd",			/* See comment [OPD] */
+		".opd",		/* See comment [OPD] */
 		"__dbe_table",
 		".parainstructions",
 		".pdr",
-		".plt",			/* seen on ARCH=um build on x86_64. Harmless */
+		".plt",		/* seen on ARCH=um build on x86_64. Harmless */
 		".smp_locks",
 		".stab",
 		".m68k_fixup",
-		".xt.prop",		/* xtensa informational section */
-		".xt.lit",		/* xtensa informational section */
+		".xt.prop",	/* xtensa informational section */
+		".xt.lit",	/* xtensa informational section */
 		NULL
 	};
 	/* Start of section names */
 	const char *namelist2[] = {
 		".debug",
 		".eh_frame",
-		".note",		/* ignore ELF notes - may contain anything */
-		".got",			/* powerpc - global offset table */
-		".toc",			/* powerpc - table of contents */
+		".note",	/* ignore ELF notes - may contain anything */
+		".got",		/* powerpc - global offset table */
+		".toc",		/* powerpc - table of contents */
 		NULL
 	};
 	/* part of section name */
@@ -1221,7 +1228,8 @@ static int init_section_ref_ok(const char *name)
 			return 1;
 
 	/* If section name ends with ".init" we allow references
-	 * as is the case with .initcallN.init, .early_param.init, .taglist.init etc
+	 * as is the case with .initcallN.init, .early_param.init,
+	 * .taglist.init etc
 	 */
 	if (strrcmp(name, ".init") == 0)
 		return 1;
@@ -1368,7 +1376,7 @@ static void check_for_gpl_usage(enum export exp, const char *m, const char *s)
 	}
 }
 
-static void check_for_unused(enum export exp, const char* m, const char* s)
+static void check_for_unused(enum export exp, const char *m, const char *s)
 {
 	const char *e = is_vmlinux(m) ?"":".ko";
 
@@ -1401,7 +1409,7 @@ static void check_exports(struct module *mod)
 		if (!mod->gpl_compatible)
 			check_for_gpl_usage(exp->export, basename, exp->name);
 		check_for_unused(exp->export, basename, exp->name);
-        }
+	}
 }
 
 /**
@@ -1465,9 +1473,8 @@ static int add_versions(struct buffer *b, struct module *mod)
 	buf_printf(b, "__attribute__((section(\"__versions\"))) = {\n");
 
 	for (s = mod->unres; s; s = s->next) {
-		if (!s->module) {
+		if (!s->module)
 			continue;
-		}
 		if (!s->crc_valid) {
 			warn("\"%s\" [%s.ko] has no CRC!\n",
 				s->name, mod->name);
@@ -1488,9 +1495,8 @@ static void add_depends(struct buffer *b, struct module *mod,
 	struct module *m;
 	int first = 1;
 
-	for (m = modules; m; m = m->next) {
+	for (m = modules; m; m = m->next)
 		m->seen = is_vmlinux(m->name);
-	}
 
 	buf_printf(b, "\n");
 	buf_printf(b, "static const char __module_depends[]\n");
@@ -1506,7 +1512,8 @@ static void add_depends(struct buffer *b, struct module *mod,
 			continue;
 
 		s->module->seen = 1;
-		if ((p = strrchr(s->module->name, '/')) != NULL)
+		p = strrchr(s->module->name, '/');
+		if (p)
 			p++;
 		else
 			p = s->module->name;
@@ -1578,7 +1585,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 	void *file = grab_file(fname, &size);
 	char *line;
 
-        if (!file)
+	if (!file)
 		/* No symbol versions, silently ignore */
 		return;
 
@@ -1601,11 +1608,10 @@ static void read_dump(const char *fname, unsigned int kernel)
 		crc = strtoul(line, &d, 16);
 		if (*symname == '\0' || *modname == '\0' || *d != '\0')
 			goto fail;
-
-		if (!(mod = find_module(modname))) {
-			if (is_vmlinux(modname)) {
+		mod = find_module(modname);
+		if (!mod) {
+			if (is_vmlinux(modname))
 				have_vmlinux = 1;
-			}
 			mod = new_module(NOFAIL(strdup(modname)));
 			mod->skip = 1;
 		}
@@ -1662,31 +1668,31 @@ int main(int argc, char **argv)
 	int err;
 
 	while ((opt = getopt(argc, argv, "i:I:mso:aw")) != -1) {
-		switch(opt) {
-			case 'i':
-				kernel_read = optarg;
-				break;
-			case 'I':
-				module_read = optarg;
-				external_module = 1;
-				break;
-			case 'm':
-				modversions = 1;
-				break;
-			case 'o':
-				dump_write = optarg;
-				break;
-			case 'a':
-				all_versions = 1;
-				break;
-			case 's':
-				vmlinux_section_warnings = 0;
-				break;
-			case 'w':
-				warn_unresolved = 1;
-				break;
-			default:
-				exit(1);
+		switch (opt) {
+		case 'i':
+			kernel_read = optarg;
+			break;
+		case 'I':
+			module_read = optarg;
+			external_module = 1;
+			break;
+		case 'm':
+			modversions = 1;
+			break;
+		case 'o':
+			dump_write = optarg;
+			break;
+		case 'a':
+			all_versions = 1;
+			break;
+		case 's':
+			vmlinux_section_warnings = 0;
+			break;
+		case 'w':
+			warn_unresolved = 1;
+			break;
+		default:
+			exit(1);
 		}
 	}
 
@@ -1695,9 +1701,8 @@ int main(int argc, char **argv)
 	if (module_read)
 		read_dump(module_read, 0);
 
-	while (optind < argc) {
+	while (optind < argc)
 		read_symbols(argv[optind++]);
-	}
 
 	for (mod = modules; mod; mod = mod->next) {
 		if (mod->skip)

commit 666ab414fe14e8bbbe86a110437346128e1ec869
Author: Andi Kleen <ak@suse.de>
Date:   Thu Nov 22 03:43:10 2007 +0100

    kbuild: fix a buffer overflow in modpost
    
    When passing an file name > 1k the stack could be overflowed.
    Not really a security issue, but still better plugged.
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 404ee0d0aac6..4d1c59063b27 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1656,7 +1656,6 @@ int main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
-	char fname[SZ];
 	char *kernel_read = NULL, *module_read = NULL;
 	char *dump_write = NULL;
 	int opt;
@@ -1709,6 +1708,8 @@ int main(int argc, char **argv)
 	err = 0;
 
 	for (mod = modules; mod; mod = mod->next) {
+		char fname[strlen(mod->name) + 10];
+
 		if (mod->skip)
 			continue;
 

commit 58b7a68de37face98afe7c705391145795a982b5
Author: Andi Kleen <ak@suse.de>
Date:   Thu Nov 22 03:43:09 2007 +0100

    kbuild: fix format string warnings in modpost
    
    Fix wrong format strings in modpost exposed by the previous patch.
    Including one missing argument -- some random data was printed instead.
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3a12c22cc2f8..404ee0d0aac6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -388,7 +388,7 @@ static int parse_elf(struct elf_info *info, const char *filename)
 
 	/* Check if file offset is correct */
 	if (hdr->e_shoff > info->size) {
-		fatal("section header offset=%u in file '%s' is bigger then filesize=%lu\n", hdr->e_shoff, filename, info->size);
+		fatal("section header offset=%lu in file '%s' is bigger then filesize=%lu\n", (unsigned long)hdr->e_shoff, filename, info->size);
 		return 0;
 	}
 
@@ -409,7 +409,7 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		const char *secname;
 
 		if (sechdrs[i].sh_offset > info->size) {
-			fatal("%s is truncated. sechdrs[i].sh_offset=%u > sizeof(*hrd)=%ul\n", filename, (unsigned int)sechdrs[i].sh_offset, sizeof(*hdr));
+			fatal("%s is truncated. sechdrs[i].sh_offset=%lu > sizeof(*hrd)=%lu\n", filename, (unsigned long)sechdrs[i].sh_offset, sizeof(*hdr));
 			return 0;
 		}
 		secname = secstrings + sechdrs[i].sh_name;
@@ -907,7 +907,8 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		     "before '%s' (at offset -0x%llx)\n",
 		     modname, fromsec, (unsigned long long)r.r_offset,
 		     secname, refsymname,
-		     elf->strtab + after->st_name);
+		     elf->strtab + after->st_name,
+		     (unsigned long long)r.r_offset);
 	} else {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
 		     modname, fromsec, (unsigned long long)r.r_offset,

commit 6d9a89ea4b06146d29e1ffb4d6fded286fa07d29
Author: Andi Kleen <ak@suse.de>
Date:   Thu Nov 22 03:43:08 2007 +0100

    kbuild: declare the modpost error functions as printf like
    
    This way gcc can warn for wrong format strings
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 93ac52adb498..3a12c22cc2f8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -33,7 +33,9 @@ enum export {
 	export_unused_gpl, export_gpl_future, export_unknown
 };
 
-void fatal(const char *fmt, ...)
+#define PRINTF __attribute__ ((format (printf, 1, 2)))
+
+PRINTF void fatal(const char *fmt, ...)
 {
 	va_list arglist;
 
@@ -46,7 +48,7 @@ void fatal(const char *fmt, ...)
 	exit(1);
 }
 
-void warn(const char *fmt, ...)
+PRINTF void warn(const char *fmt, ...)
 {
 	va_list arglist;
 
@@ -57,7 +59,7 @@ void warn(const char *fmt, ...)
 	va_end(arglist);
 }
 
-void merror(const char *fmt, ...)
+PRINTF void merror(const char *fmt, ...)
 {
 	va_list arglist;
 

commit 4b21960f90d4d011e49e386d0525b1e89f320658
Author: Trent Piepho <xyzzy@speakeasy.org>
Date:   Thu Oct 11 16:40:10 2007 -0700

    kbuild: modpost problem when symbols move from one module to another
    
    When part of build an external module tree, modpost first reads in the
    kernel's and then the external tree's Module.symvers files.  From these files
    it establishes a symbol => module mapping.  When it later reads in each module
    built and processes the symbols it finds, it discovers the symbol=>module
    mapping from Module.symvers and leaves it as it is.
    
    The problem comes with a module has been re-named or a symbol has moved from
    one module to another, since the Module.symvers file was generated.  modpost
    does not update the symbol=>module mapping when it finds the new location of
    the symbol when scanning the newly built modules.  This results in the module
    containing incorrect dependency information and the new Module.symvers file
    written by modpost will also contain the incorrect mappings, perpetuating the
    problem to the next build, and so on.
    
    When building the out of kernel development tree for kernel subsystem, like
    v4l-dvb or ALSA, deleting the external Module.symvers file before building
    (which the kernel build system doesn't do and shouldn't be necessary anyway),
    won't fix the problem.  modpost still reads the kernel's Module.symvers, and
    since we a building a kernel subsystem, it will define the same symbols as the
    external modules.
    
    Signed-off-by: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2ef9a193fcae..93ac52adb498 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -268,6 +268,9 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod,
 			     "was in %s%s\n", mod->name, name,
 			     s->module->name,
 			     is_vmlinux(s->module->name) ?"":".ko");
+		} else {
+			/* In case Modules.symvers was out of date */
+			s->module = mod;
 		}
 	}
 	s->preloaded = 0;

commit a83710e584b8ef46fc44472ec6f0c342003416e8
Author: Petr Stetiar <ynezz@true.cz>
Date:   Mon Aug 27 12:15:07 2007 +0200

    kbuild: fix segfault in modpost
    
    Fix modpost segfault.
    
    Before:
    -------
    ynezz@ntbk:~/linux-2.6.git$ scripts/mod/modpost vmlinux ath_pci.o
    Segmentation fault
    
    After:
    ------
    ynezz@ntbk:~/linux-2.6.git$ scripts/mod/modpost vmlinux ath_pci.o
    FATAL: section header offset=815726848 in file 'ath_pci.o' is bigger then filesize=153968
    
    Sam: This seems to warn for a binutils issue. Anyway modpost should not
    segfault.
    
    Signed-off-by: Petr Stetiar <ynezz@true.cz>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0a4051fbd34e..2ef9a193fcae 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -381,6 +381,12 @@ static int parse_elf(struct elf_info *info, const char *filename)
 	sechdrs = (void *)hdr + hdr->e_shoff;
 	info->sechdrs = sechdrs;
 
+	/* Check if file offset is correct */
+	if (hdr->e_shoff > info->size) {
+		fatal("section header offset=%u in file '%s' is bigger then filesize=%lu\n", hdr->e_shoff, filename, info->size);
+		return 0;
+	}
+
 	/* Fix endianness in section headers */
 	for (i = 0; i < hdr->e_shnum; i++) {
 		sechdrs[i].sh_type   = TO_NATIVE(sechdrs[i].sh_type);

commit 4665079cbb2a3e17de82f2ab2940b9f97f37d65e
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Mon Oct 8 20:38:39 2007 -0700

    [NETNS]: Move some code into __init section when CONFIG_NET_NS=n
    
    With the net namespaces many code leaved the __init section,
    thus making the kernel occupy more memory than it did before.
    Since we have a config option that prohibits the namespace
    creation, the functions that initialize/finalize some netns
    stuff are simply not needed and can be freed after the boot.
    
    Currently, this is almost not noticeable, since few calls
    are no longer in __init, but when the namespaces will be
    merged it will be possible to free more code. I propose to
    use the __net_init, __net_exit and __net_initdata "attributes"
    for functions/variables that are not used if the CONFIG_NET_NS
    is not set to save more space in memory.
    
    The exiting functions cannot just reside in the __exit section,
    as noticed by David, since the init section will have
    references on it and the compilation will fail due to modpost
    checks. These references can exist, since the init namespace
    never dies and the exit callbacks are never called. So I
    introduce the __exit_refok attribute just like it is already
    done with the __init_refok.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6c145d6e89de..0a4051fbd34e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -709,6 +709,7 @@ static int secref_whitelist(const char *modname, const char *tosec,
 
 	/* Check for pattern 0 */
 	if ((strncmp(fromsec, ".text.init.refok", strlen(".text.init.refok")) == 0) ||
+	    (strncmp(fromsec, ".exit.text.refok", strlen(".exit.text.refok")) == 0) ||
 	    (strncmp(fromsec, ".data.init.refok", strlen(".data.init.refok")) == 0))
 		return 1;
 

commit ad0b142772eb1f88f0e77cb63c38b0005e83c2bd
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jul 31 00:38:47 2007 -0700

    kbuild: whitelist references from __dbe_table to .init
    
    This is needed on MIPS where the same mechanism as get_user() is used to
    intercept bus error exceptions for some hardware probes.  Without this
    patch modpost will throw spurious warnings:
    
      LD      vmlinux
      SYSMAP  System.map
      SYSMAP  .tmp_System.map
      MODPOST vmlinux
    WARNING: arch/mips/sgi-ip22/built-in.o(__dbe_table+0x0): Section mismatch: reference to .init.text:
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ee58ded021d7..6c145d6e89de 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1121,6 +1121,7 @@ static int initexit_section_ref_ok(const char *name)
 		".machvec",		/* ia64 + powerpc uses these */
 		".machine.desc",
 		".opd",			/* See comment [OPD] */
+		"__dbe_table",
 		".parainstructions",
 		".pdr",
 		".plt",			/* seen on ARCH=um build on x86_64. Harmless */

commit cb7e51d8b1f8e2390970f4bb7d095c414b1bf3cf
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jul 25 22:24:52 2007 +0200

    kbuild: fix modpost warnings for xtensa
    
    The Xtensa architecture places literal pools in sections separate
    from the instructions. The corresponsing text sections, therefore,
    reference the .literal section, and we have to suppress those
    warnings.
    
    The naming convention defines the name for a literal
    section as .SECTION.literal, unless .SECTION is .text. In that case
    the name is only .literal. Using strncmp() instead of strcmp()
    to compare the from-section with .SECTION.init.refok in pattern 0
    should not cause any regressions for other architectures.
    
    We also need to suppress warnings for two informational
    sections (.xt.lit and .xt.prop) used by the Xtensa architecture.
    
    Signed-off-by: Chris Zankel <chris@zankel.net>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3db4edcc5a12..ee58ded021d7 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -640,7 +640,7 @@ static int data_section(const char *name)
  * Pattern 0:
  *   Do not warn if funtion/data are marked with __init_refok/__initdata_refok.
  *   The pattern is identified by:
- *   fromsec = .text.init.refok | .data.init.refok
+ *   fromsec = .text.init.refok* | .data.init.refok*
  *
  * Pattern 1:
  *   If a module parameter is declared __initdata and permissions=0
@@ -675,11 +675,18 @@ static int data_section(const char *name)
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
+ * Pattern 5:
+ *   Xtensa uses literal sections for constants that are accessed PC-relative.
+ *   Literal sections may safely reference their text sections.
+ *   (Note that the name for the literal section omits any trailing '.text')
+ *   tosec = <section>[.text]
+ *   fromsec = <section>.literal
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
 			    const char *refsymname)
 {
+	int len;
 	const char **s;
 	const char *pat2sym[] = {
 		"driver",
@@ -701,8 +708,8 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	};
 
 	/* Check for pattern 0 */
-	if ((strcmp(fromsec, ".text.init.refok") == 0) ||
-	    (strcmp(fromsec, ".data.init.refok") == 0))
+	if ((strncmp(fromsec, ".text.init.refok", strlen(".text.init.refok")) == 0) ||
+	    (strncmp(fromsec, ".data.init.refok", strlen(".data.init.refok")) == 0))
 		return 1;
 
 	/* Check for pattern 1 */
@@ -728,6 +735,15 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		if (strcmp(refsymname, *s) == 0)
 			return 1;
 
+	/* Check for pattern 5 */
+	if (strrcmp(tosec, ".text") == 0)
+		len = strlen(tosec) - strlen(".text");
+	else
+		len = strlen(tosec);
+	if ((strncmp(tosec, fromsec, len) == 0) && (strlen(fromsec) > len) &&
+	    (strcmp(fromsec + len, ".literal") == 0))
+		return 1;
+
 	return 0;
 }
 
@@ -856,9 +872,9 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		refsymname = elf->strtab + refsym->st_name;
 
 	/* check whitelist - we may ignore it */
-	if (before &&
-	    secref_whitelist(modname, secname, fromsec,
-			     elf->strtab + before->st_name, refsymname))
+	if (secref_whitelist(modname, secname, fromsec,
+			     before ? elf->strtab + before->st_name : "",
+	                     refsymname))
 		return;
 
 	if (before && after) {
@@ -1111,6 +1127,8 @@ static int initexit_section_ref_ok(const char *name)
 		".smp_locks",
 		".stab",
 		".m68k_fixup",
+		".xt.prop",		/* xtensa informational section */
+		".xt.lit",		/* xtensa informational section */
 		NULL
 	};
 	/* Start of section names */

commit 83cda2bb37cb8476cd84659d9698ab48553be974
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jul 25 21:52:31 2007 +0200

    kbuild: be more foregiving on init section naming
    
    In the whitelist function of modpost now use the same
    check to identify init_section as in other places of modpost.
    This has the effect that we now recognize sections named
    .init.text.19 as init sections and we no longer warn
    when we see these.
    
    At the same time make surrounding code readable by dropping
    use of temporary flags.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c903a16ba0e6..3db4edcc5a12 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -658,8 +658,8 @@ static int data_section(const char *name)
  *   These functions may often be marked __init and we do not want to
  *   warn here.
  *   the pattern is identified by:
- *   tosec   = .init.text | .exit.text | .init.data
- *   fromsec = .data | .data.rel | .data.rel.*
+ *   tosec   = init or exit section
+ *   fromsec = data section
  *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console, *_timer
  *
  * Pattern 3:
@@ -680,7 +680,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
 			    const char *refsymname)
 {
-	int f1 = 1, f2 = 1;
 	const char **s;
 	const char *pat2sym[] = {
 		"driver",
@@ -707,31 +706,16 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		return 1;
 
 	/* Check for pattern 1 */
-	if (strcmp(tosec, ".init.data") != 0)
-		f1 = 0;
-	if (strncmp(fromsec, ".data", strlen(".data")) != 0)
-		f1 = 0;
-	if (strncmp(atsym, "__param", strlen("__param")) != 0)
-		f1 = 0;
-
-	if (f1)
-		return f1;
+	if ((strcmp(tosec, ".init.data") == 0) &&
+	    (strncmp(fromsec, ".data", strlen(".data")) == 0) &&
+	    (strncmp(atsym, "__param", strlen("__param")) == 0))
+		return 1;
 
 	/* Check for pattern 2 */
-	if ((strcmp(tosec, ".init.text") != 0) &&
-	    (strcmp(tosec, ".exit.text") != 0) &&
-	    (strcmp(tosec, ".init.data") != 0))
-		f2 = 0;
-	if ((strcmp(fromsec, ".data") != 0) &&
-	    (strcmp(fromsec, ".data.rel") != 0) &&
-	    (strncmp(fromsec, ".data.rel.", strlen(".data.rel.")) != 0))
-		f2 = 0;
-
-	for (s = pat2sym; *s; s++)
-		if (strrcmp(atsym, *s) == 0)
-			f1 = 1;
-	if (f1 && f2)
-		return 1;
+	if ((init_section(tosec) || exit_section(tosec)) && data_section(fromsec))
+		for (s = pat2sym; *s; s++)
+			if (strrcmp(atsym, *s) == 0)
+				return 1;
 
 	/* Check for pattern 3 */
 	if ((strcmp(fromsec, ".text.head") == 0) &&

commit 2f5ee619045d923de9137b6a263a99cc2428391a
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Wed Jul 25 21:46:40 2007 +0200

    kbuild: rearrange a few function in modpost
    
    This is a preparational patch that just move
    two functions and add one (for now unused) function.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 87e3ee56e87d..c903a16ba0e6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -586,6 +586,54 @@ static int strrcmp(const char *s, const char *sub)
         return memcmp(s + slen - sublen, sub, sublen);
 }
 
+/*
+ * Functions used only during module init is marked __init and is stored in
+ * a .init.text section. Likewise data is marked __initdata and stored in
+ * a .init.data section.
+ * If this section is one of these sections return 1
+ * See include/linux/init.h for the details
+ */
+static int init_section(const char *name)
+{
+	if (strcmp(name, ".init") == 0)
+		return 1;
+	if (strncmp(name, ".init.", strlen(".init.")) == 0)
+		return 1;
+	return 0;
+}
+
+/*
+ * Functions used only during module exit is marked __exit and is stored in
+ * a .exit.text section. Likewise data is marked __exitdata and stored in
+ * a .exit.data section.
+ * If this section is one of these sections return 1
+ * See include/linux/init.h for the details
+ **/
+static int exit_section(const char *name)
+{
+	if (strcmp(name, ".exit.text") == 0)
+		return 1;
+	if (strcmp(name, ".exit.data") == 0)
+		return 1;
+	return 0;
+
+}
+
+/*
+ * Data sections are named like this:
+ * .data | .data.rel | .data.rel.*
+ * Return 1 if the specified section is a data section
+ */
+static int data_section(const char *name)
+{
+	if ((strcmp(name, ".data") == 0) ||
+	    (strcmp(name, ".data.rel") == 0) ||
+	    (strncmp(name, ".data.rel.", strlen(".data.rel.")) == 0))
+		return 1;
+	else
+		return 0;
+}
+
 /**
  * Whitelist to allow certain references to pass with no warning.
  *
@@ -1108,21 +1156,6 @@ static int initexit_section_ref_ok(const char *name)
 	return 0;
 }
 
-/**
- * Functions used only during module init is marked __init and is stored in
- * a .init.text section. Likewise data is marked __initdata and stored in
- * a .init.data section.
- * If this section is one of these sections return 1
- * See include/linux/init.h for the details
- **/
-static int init_section(const char *name)
-{
-	if (strcmp(name, ".init") == 0)
-		return 1;
-	if (strncmp(name, ".init.", strlen(".init.")) == 0)
-		return 1;
-	return 0;
-}
 
 /*
  * Identify sections from which references to a .init section is OK.
@@ -1179,23 +1212,6 @@ static int init_section_ref_ok(const char *name)
 	return 0;
 }
 
-/*
- * Functions used only during module exit is marked __exit and is stored in
- * a .exit.text section. Likewise data is marked __exitdata and stored in
- * a .exit.data section.
- * If this section is one of these sections return 1
- * See include/linux/init.h for the details
- **/
-static int exit_section(const char *name)
-{
-	if (strcmp(name, ".exit.text") == 0)
-		return 1;
-	if (strcmp(name, ".exit.data") == 0)
-		return 1;
-	return 0;
-
-}
-
 /*
  * Identify sections from which references to a .exit section is OK.
  */

commit 8d8d8289df65cb116d2721becafb37272074f25a
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jul 20 22:36:56 2007 +0200

    kbuild: do not do section mismatch checks on vmlinux in 2nd pass
    
    We already check and warn about section mismatches from vmlinux
    (build as vmlinux.o) during first pass so skip the checks
    during the 2nd pass where we process modules.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5ab7914d30ef..87e3ee56e87d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -23,6 +23,8 @@ int have_vmlinux = 0;
 static int all_versions = 0;
 /* If we are modposting external module set to 1 */
 static int external_module = 0;
+/* Warn about section mismatch in vmlinux if set to 1 */
+static int vmlinux_section_warnings = 1;
 /* Only warn about unresolved symbols */
 static int warn_unresolved = 0;
 /* How a symbol is exported */
@@ -1257,8 +1259,10 @@ static void read_symbols(char *modname)
 		handle_modversions(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);
 	}
-	check_sec_ref(mod, modname, &info, init_section, init_section_ref_ok);
-	check_sec_ref(mod, modname, &info, exit_section, exit_section_ref_ok);
+	if (is_vmlinux(modname) && vmlinux_section_warnings) {
+		check_sec_ref(mod, modname, &info, init_section, init_section_ref_ok);
+		check_sec_ref(mod, modname, &info, exit_section, exit_section_ref_ok);
+	}
 
 	version = get_modinfo(info.modinfo, info.modinfo_len, "version");
 	if (version)
@@ -1626,7 +1630,7 @@ int main(int argc, char **argv)
 	int opt;
 	int err;
 
-	while ((opt = getopt(argc, argv, "i:I:mo:aw")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:mso:aw")) != -1) {
 		switch(opt) {
 			case 'i':
 				kernel_read = optarg;
@@ -1644,6 +1648,9 @@ int main(int argc, char **argv)
 			case 'a':
 				all_versions = 1;
 				break;
+			case 's':
+				vmlinux_section_warnings = 0;
+				break;
 			case 'w':
 				warn_unresolved = 1;
 				break;

commit 3a5df1d451cfe3a3d6d63f144554cac286eecba1
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Jul 20 04:32:48 2007 +0100

    m68k: teach modpost about .m68_fixup
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 04579a517900..5ab7914d30ef 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1076,6 +1076,7 @@ static int initexit_section_ref_ok(const char *name)
 		".plt",			/* seen on ARCH=um build on x86_64. Harmless */
 		".smp_locks",
 		".stab",
+		".m68k_fixup",
 		NULL
 	};
 	/* Start of section names */

commit eec73e887a96b50035c92c57e01137dcbe6c5a39
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jul 10 09:16:32 2007 +0100

    Whitelist references from __dbe_table to .init
    
    This is needed on MIPS where the same mechanism as get_user() is used to
    intercept bus error exceptions for some hardware probes.  Without this
    patch modpost will throw spurious warnings:
    
      LD      vmlinux
      SYSMAP  System.map
      SYSMAP  .tmp_System.map
      MODPOST vmlinux
    WARNING: arch/mips/sgi-ip22/built-in.o(__dbe_table+0x0): Section mismatch: reference to .init.text:
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3f3848f805f5..04579a517900 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1141,6 +1141,7 @@ static int init_section_ref_ok(const char *name)
 	const char **s;
 	/* Absolute section names */
 	const char *namelist1[] = {
+		"__dbe_table",		/* MIPS generate these */
 		"__ftr_fixup",		/* powerpc cpu feature fixup */
 		"__fw_ftr_fixup",	/* powerpc firmware feature fixup */
 		"__param",

commit a5eb6a502b71ee6bf1a9768b12ff4545cb7a50fe
Author: Jan Beulich <jbeulich@novell.com>
Date:   Tue Jun 12 09:29:41 2007 +0200

    modpost white list pattern adjustment
    
    gcc puts data into .data.rel or .data.rel.* on some architectures (e.g.
    ia64) or under certain conditions, so whatever is legal relative to
    .data should also be legal for those other sections. Fixes a few
    modpost warnings on ia64.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ec036c261fb1..3f3848f805f5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -609,7 +609,7 @@ static int strrcmp(const char *s, const char *sub)
  *   warn here.
  *   the pattern is identified by:
  *   tosec   = .init.text | .exit.text | .init.data
- *   fromsec = .data
+ *   fromsec = .data | .data.rel | .data.rel.*
  *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console, *_timer
  *
  * Pattern 3:
@@ -672,7 +672,9 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strcmp(tosec, ".exit.text") != 0) &&
 	    (strcmp(tosec, ".init.data") != 0))
 		f2 = 0;
-	if (strcmp(fromsec, ".data") != 0)
+	if ((strcmp(fromsec, ".data") != 0) &&
+	    (strcmp(fromsec, ".data.rel") != 0) &&
+	    (strncmp(fromsec, ".data.rel.", strlen(".data.rel.")) != 0))
 		f2 = 0;
 
 	for (s = pat2sym; *s; s++)

commit 741f98fe298a73c9d47ed53703c1279a29718581
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Jul 17 10:54:06 2007 +0200

    kbuild: do section mismatch check on full vmlinux
    
    Previously we did do the check on the .o files used to link
    vmlinux but that failed to find questionable references across
    the .o files.
    Create a dedicated vmlinux.o file used only for section mismatch checks
    that uses the defualt linker script so section does not get renamed.
    
    The vmlinux.o may later be used as part of the the final link of vmlinux
    but for now it is used fo section mismatch only.
    For a defconfig build this is instant but for an allyesconfig this
    add two minutes to a full build (that anyways takes ~2 hours).
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index bb895b13c170..ec036c261fb1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -75,7 +75,8 @@ static int is_vmlinux(const char *modname)
 	else
 		myname = modname;
 
-	return strcmp(myname, "vmlinux") == 0;
+	return (strcmp(myname, "vmlinux") == 0) ||
+	       (strcmp(myname, "vmlinux.o") == 0);
 }
 
 void *do_nofail(void *ptr, const char *expr)

commit 1e29a706eef664f2c5014462d435f54a1952cc7b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 3 22:19:24 2007 +0200

    kbuild: whitelist references from variables named _timer to .init.text
    
    arm uses a lot of ops structures named *_timer that has legitimite
    references to .init.text.
    So let's add this variable to the list of variables that may reference
    .init.text without causing any warning.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 015c6b0c8031..bb895b13c170 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -609,7 +609,7 @@ static int strrcmp(const char *s, const char *sub)
  *   the pattern is identified by:
  *   tosec   = .init.text | .exit.text | .init.data
  *   fromsec = .data
- *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console
+ *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console, *_timer
  *
  * Pattern 3:
  *   Whitelist all refereces from .text.head to .init.data
@@ -634,6 +634,7 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	const char *pat2sym[] = {
 		"driver",
 		"_template", /* scsi uses *_template a lot */
+		"_timer",    /* arm uses ops structures named _timer a lot */
 		"_sht",      /* scsi also used *_sht to some extent */
 		"_ops",
 		"_probe",

commit 92cc6b0725d800dcc3b9d62b419724050e4f7872
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 3 00:47:53 2007 +0200

    kbuild: remove hardcoded _logo names from modpost
    
    Replaced this with a __init_refok marker
    in front of fb_find_logo().
    
    I think that the __initdata marker for the logo's are
    wrong but I have not justified this so I did not remove it.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1921c43f3a3e..015c6b0c8031 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -624,14 +624,6 @@ static int strrcmp(const char *s, const char *sub)
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
- * Pattern 5:
- *  Logos used in drivers/video/logo reside in __initdata but the
- *  funtion that references them are EXPORT_SYMBOL() so cannot be
- *  marker __init. So we whitelist them here.
- *  The pattern is:
- *  tosec      = .init.data
- *  fromsec    = .text*
- *  refsymname = logo_
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -698,12 +690,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		if (strcmp(refsymname, *s) == 0)
 			return 1;
 
-	/* Check for pattern 5 */
-	if ((strcmp(tosec, ".init.data") == 0) &&
-	    (strncmp(fromsec, ".text", strlen(".text")) == 0) &&
-	    (strncmp(refsymname, "logo_", strlen("logo_")) == 0))
-		return 1;
-
 	return 0;
 }
 

commit d3ab78560b9a244bdb2ba2ef0e53193832d311c2
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 3 00:05:10 2007 +0200

    kbuild: remove hardcoded apic_es7000 from modpost
    
    Replace the hardcoded variable name apic_es7000 in modpost
    with a __initdata_refok marker.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7f5ff7e0a0f3..1921c43f3a3e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -647,7 +647,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		"_probe",
 		"_probe_one",
 		"_console",
-		"apic_es7000",
 		NULL
 	};
 

commit 6fc53bae3d5940f1b123afa5ad082359b1a376be
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jun 2 21:29:20 2007 +0200

    kbuild: warn about references from .init.text to .exit.text
    
    The .exit.text section may be discarded either at build or at runtime.
    So let modpost warn if this situation is detected.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1ef78753db97..7f5ff7e0a0f3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1214,7 +1214,6 @@ static int exit_section_ref_ok(const char *name)
 		".exit.data",
 		".exit.text",
 		".exitcall.exit",
-		".init.text",
 		".rodata",
 		NULL
 	};

commit 1d8af559f9ffd6847856f74658e501ed7ded9f01
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Jun 3 00:41:22 2007 +0200

    kbuild: consolidate section checks
    
    Move more checks from whitelist to the section check functions.
    Remove the redundent pci_fixup check.
    Renumber the patterns.
    No functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f22c8b4911bc..1ef78753db97 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -612,14 +612,10 @@ static int strrcmp(const char *s, const char *sub)
  *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console
  *
  * Pattern 3:
- *   Whitelist all references from .pci_fixup* section to .init.text
- *   This is part of the PCI init when built-in
- *
- * Pattern 4:
  *   Whitelist all refereces from .text.head to .init.data
  *   Whitelist all refereces from .text.head to .init.text
  *
- * Pattern 5:
+ * Pattern 4:
  *   Some symbols belong to init section but still it is ok to reference
  *   these from non-init sections as these symbols don't have any memory
  *   allocated for them and symbol address and value are same. So even
@@ -628,7 +624,7 @@ static int strrcmp(const char *s, const char *sub)
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
- * Pattern 7:
+ * Pattern 5:
  *  Logos used in drivers/video/logo reside in __initdata but the
  *  funtion that references them are EXPORT_SYMBOL() so cannot be
  *  marker __init. So we whitelist them here.
@@ -636,12 +632,6 @@ static int strrcmp(const char *s, const char *sub)
  *  tosec      = .init.data
  *  fromsec    = .text*
  *  refsymname = logo_
- *
- * Pattern 10:
- *  ia64 has machvec table for each platform and
- *  powerpc has a machine desc table for each platform.
- *  It is mixture of function pointers of .init.text and .text.
- *  fromsec  = .machvec | .machine.desc
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -699,32 +689,22 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		return 1;
 
 	/* Check for pattern 3 */
-	if ((strncmp(fromsec, ".pci_fixup", strlen(".pci_fixup")) == 0) &&
-	    (strcmp(tosec, ".init.text") == 0))
-	return 1;
-
-	/* Check for pattern 4 */
 	if ((strcmp(fromsec, ".text.head") == 0) &&
 		((strcmp(tosec, ".init.data") == 0) ||
 		(strcmp(tosec, ".init.text") == 0)))
 	return 1;
 
-	/* Check for pattern 5 */
+	/* Check for pattern 4 */
 	for (s = pat3refsym; *s; s++)
 		if (strcmp(refsymname, *s) == 0)
 			return 1;
 
-	/* Check for pattern 7 */
+	/* Check for pattern 5 */
 	if ((strcmp(tosec, ".init.data") == 0) &&
 	    (strncmp(fromsec, ".text", strlen(".text")) == 0) &&
 	    (strncmp(refsymname, "logo_", strlen("logo_")) == 0))
 		return 1;
 
-	/* Check for pattern 10 */
-	if ((strcmp(fromsec, ".machvec") == 0) ||
-	    (strcmp(fromsec, ".machine.desc") == 0))
-		return 1;
-
 	return 0;
 }
 
@@ -1088,7 +1068,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
  * section, not the ia64 .opd section.
  * ia64 .opd should not point to discarded sections.
  * [.rodata] like for .init.text we ignore .rodata references -same reason
- **/
+ */
 static int initexit_section_ref_ok(const char *name)
 {
 	const char **s;
@@ -1099,6 +1079,8 @@ static int initexit_section_ref_ok(const char *name)
 		".altinstructions",
 		".cranges",		/* used by sh64 */
 		".fixup",
+		".machvec",		/* ia64 + powerpc uses these */
+		".machine.desc",
 		".opd",			/* See comment [OPD] */
 		".parainstructions",
 		".pdr",

commit 1087247b7d8f1938425906d2ac983df76c6dcc18
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Jun 2 21:18:51 2007 +0200

    kbuild: refactor code in modpost to improve maintainability
    
    There were a great deal of overlap between the two functions
    that check which sections may reference .init.text and .exit.text.
    Factor out common check to a separate function and
    sort entries in the original functions.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 9c35f30d2eda..f22c8b4911bc 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -858,14 +858,6 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			     elf->strtab + before->st_name, refsymname))
 		return;
 
-	/* fromsec whitelist - without a valid 'before'
-	 * powerpc has a GOT table in .got2 section
-	 * and also a .toc section */
-	if (strcmp(fromsec, ".got2") == 0)
-		return;
-	if (strcmp(fromsec, ".toc") == 0)
-		return;
-
 	if (before && after) {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
 		     "(between '%s' and '%s')\n",
@@ -1087,6 +1079,61 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	}
 }
 
+/*
+ * Identify sections from which references to either a
+ * .init or a .exit section is OK.
+ *
+ * [OPD] Keith Ownes <kaos@sgi.com> commented:
+ * For our future {in}sanity, add a comment that this is the ppc .opd
+ * section, not the ia64 .opd section.
+ * ia64 .opd should not point to discarded sections.
+ * [.rodata] like for .init.text we ignore .rodata references -same reason
+ **/
+static int initexit_section_ref_ok(const char *name)
+{
+	const char **s;
+	/* Absolute section names */
+	const char *namelist1[] = {
+		"__bug_table",		/* used by powerpc for BUG() */
+		"__ex_table",
+		".altinstructions",
+		".cranges",		/* used by sh64 */
+		".fixup",
+		".opd",			/* See comment [OPD] */
+		".parainstructions",
+		".pdr",
+		".plt",			/* seen on ARCH=um build on x86_64. Harmless */
+		".smp_locks",
+		".stab",
+		NULL
+	};
+	/* Start of section names */
+	const char *namelist2[] = {
+		".debug",
+		".eh_frame",
+		".note",		/* ignore ELF notes - may contain anything */
+		".got",			/* powerpc - global offset table */
+		".toc",			/* powerpc - table of contents */
+		NULL
+	};
+	/* part of section name */
+	const char *namelist3 [] = {
+		".unwind",  /* Sample: IA_64.unwind.exit.text */
+		NULL
+	};
+
+	for (s = namelist1; *s; s++)
+		if (strcmp(*s, name) == 0)
+			return 1;
+	for (s = namelist2; *s; s++)
+		if (strncmp(*s, name, strlen(*s)) == 0)
+			return 1;
+	for (s = namelist3; *s; s++)
+		if (strstr(name, *s) != NULL)
+			return 1;
+	return 0;
+}
+
 /**
  * Functions used only during module init is marked __init and is stored in
  * a .init.text section. Likewise data is marked __initdata and stored in
@@ -1103,7 +1150,7 @@ static int init_section(const char *name)
 	return 0;
 }
 
-/**
+/*
  * Identify sections from which references to a .init section is OK.
  *
  * Unfortunately references to read only data that referenced .init
@@ -1117,59 +1164,41 @@ static int init_section(const char *name)
  *
  * where vgacon_startup is __init.  If you want to wade through the false
  * positives, take out the check for rodata.
- **/
+ */
 static int init_section_ref_ok(const char *name)
 {
 	const char **s;
 	/* Absolute section names */
 	const char *namelist1[] = {
-		".init",
-		".opd",   /* see comment [OPD] at exit_section_ref_ok() */
-		".toc1",  /* used by ppc64 */
-		".stab",
-		".data.rel.ro", /* used by parisc64 */
-		".parainstructions",
-		".text.lock",
-		"__bug_table", /* used by powerpc for BUG() */
-		".pci_fixup_header",
-		".pci_fixup_final",
-		".pdr",
-		"__param",
-		"__ex_table",
-		".fixup",
-		".smp_locks",
-		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
 		"__ftr_fixup",		/* powerpc cpu feature fixup */
 		"__fw_ftr_fixup",	/* powerpc firmware feature fixup */
-		".cranges",	/* used by sh64 */
+		"__param",
+		".data.rel.ro",		/* used by parisc64 */
+		".init",
+		".text.lock",
 		NULL
 	};
 	/* Start of section names */
 	const char *namelist2[] = {
 		".init.",
-		".altinstructions",
-		".eh_frame",
-		".debug",
-		".parainstructions",
+		".pci_fixup",
 		".rodata",
-		".note",		/* ignore ELF notes - may contain anything */
-		NULL
-	};
-	/* part of section name */
-	const char *namelist3 [] = {
-		".unwind",  /* sample: IA_64.unwind.init.text */
 		NULL
 	};
 
+	if (initexit_section_ref_ok(name))
+		return 1;
+
 	for (s = namelist1; *s; s++)
 		if (strcmp(*s, name) == 0)
 			return 1;
 	for (s = namelist2; *s; s++)
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
-	for (s = namelist3; *s; s++)
-		if (strstr(name, *s) != NULL)
-			return 1;
+
+	/* If section name ends with ".init" we allow references
+	 * as is the case with .initcallN.init, .early_param.init, .taglist.init etc
+	 */
 	if (strrcmp(name, ".init") == 0)
 		return 1;
 	return 0;
@@ -1194,59 +1223,26 @@ static int exit_section(const char *name)
 
 /*
  * Identify sections from which references to a .exit section is OK.
- *
- * [OPD] Keith Ownes <kaos@sgi.com> commented:
- * For our future {in}sanity, add a comment that this is the ppc .opd
- * section, not the ia64 .opd section.
- * ia64 .opd should not point to discarded sections.
- * [.rodata] like for .init.text we ignore .rodata references -same reason
- **/
+ */
 static int exit_section_ref_ok(const char *name)
 {
 	const char **s;
 	/* Absolute section names */
 	const char *namelist1[] = {
-		".exit.text",
 		".exit.data",
+		".exit.text",
+		".exitcall.exit",
 		".init.text",
 		".rodata",
-		".opd", /* See comment [OPD] */
-		".toc1",  /* used by ppc64 */
-		".altinstructions",
-		".pdr",
-		"__bug_table", /* used by powerpc for BUG() */
-		".exitcall.exit",
-		".eh_frame",
-		".parainstructions",
-		".stab",
-		"__ex_table",
-		".fixup",
-		".smp_locks",
-		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
-		".cranges",	/* used by sh64 */
-		NULL
-	};
-	/* Start of section names */
-	const char *namelist2[] = {
-		".debug",
-		".note",		/* ignore ELF notes - may contain anything */
-		NULL
-	};
-	/* part of section name */
-	const char *namelist3 [] = {
-		".unwind",  /* Sample: IA_64.unwind.exit.text */
 		NULL
 	};
 
+	if (initexit_section_ref_ok(name))
+		return 1;
+
 	for (s = namelist1; *s; s++)
 		if (strcmp(*s, name) == 0)
 			return 1;
-	for (s = namelist2; *s; s++)
-		if (strncmp(*s, name, strlen(*s)) == 0)
-			return 1;
-	for (s = namelist3; *s; s++)
-		if (strstr(name, *s) != NULL)
-			return 1;
 	return 0;
 }
 

commit b28242e7e3c08072251da6d7bc4895fbd3e58299
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue May 29 23:09:35 2007 +0200

    kbuild: ignore section mismatch warnings originating from .note section
    
    .note* sections are ELF notes, which are typically used by external
    tools to examine the kernel image.  Since this is removed from any
    runtime consideration, it's OK to reference any section from a .note*
    section.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ece09c55e09e..9c35f30d2eda 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1152,6 +1152,7 @@ static int init_section_ref_ok(const char *name)
 		".debug",
 		".parainstructions",
 		".rodata",
+		".note",		/* ignore ELF notes - may contain anything */
 		NULL
 	};
 	/* part of section name */
@@ -1228,6 +1229,7 @@ static int exit_section_ref_ok(const char *name)
 	/* Start of section names */
 	const char *namelist2[] = {
 		".debug",
+		".note",		/* ignore ELF notes - may contain anything */
 		NULL
 	};
 	/* part of section name */

commit 1de564bbf8b630ab356571cdbd15b7d5adb1c20d
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Tue May 29 13:33:01 2007 -0700

    kbuild: .paravirtprobe section is obsolete, so modpost doesn't need to handle it
    
    The .paravirtprobe section is obsolete, so modpost doesn't need to handle it.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index fa33a6b92a9d..ece09c55e09e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -637,12 +637,6 @@ static int strrcmp(const char *s, const char *sub)
  *  fromsec    = .text*
  *  refsymname = logo_
  *
- * Pattern 8:
- *  Symbols contained in .paravirtprobe may safely reference .init.text.
- *  The pattern is:
- *  tosec   = .init.text
- *  fromsec  = .paravirtprobe
- *
  * Pattern 10:
  *  ia64 has machvec table for each platform and
  *  powerpc has a machine desc table for each platform.
@@ -726,11 +720,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strncmp(refsymname, "logo_", strlen("logo_")) == 0))
 		return 1;
 
-	/* Check for pattern 8 */
-	if ((strcmp(tosec, ".init.text") == 0) &&
-	    (strcmp(fromsec, ".paravirtprobe") == 0))
-		return 1;
-
 	/* Check for pattern 10 */
 	if ((strcmp(fromsec, ".machvec") == 0) ||
 	    (strcmp(fromsec, ".machine.desc") == 0))

commit 1abe02fef95366208c264635a886785d18fd38bb
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu May 24 14:16:13 2007 +1000

    kbuild: suppress modpost warnings for references from the .toc section as used by powerpc
    
    We should do better here by effetively "dereferencing" references to
    the .toc (or the .got2) section, but that is much harder.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 256b3d272e2e..fa33a6b92a9d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -870,9 +870,12 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		return;
 
 	/* fromsec whitelist - without a valid 'before'
-	 * powerpc has a GOT table in .got2 section */
+	 * powerpc has a GOT table in .got2 section
+	 * and also a .toc section */
 	if (strcmp(fromsec, ".got2") == 0)
 		return;
+	if (strcmp(fromsec, ".toc") == 0)
+		return;
 
 	if (before && after) {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "

commit 56a974fa2d595fe6ebe433c525b8232ead539b76
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jul 16 22:39:35 2007 +0200

    kbuild: make better section mismatch reports on arm
    
    With this change we can find more symbols hereby improving
    the readability of the warnings.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b83cddb8dca9..256b3d272e2e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -929,6 +929,26 @@ static int addend_386_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 	return 0;
 }
 
+static int addend_arm_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
+{
+	unsigned int r_typ = ELF_R_TYPE(r->r_info);
+
+	switch (r_typ) {
+	case R_ARM_ABS32:
+		/* From ARM ABI: (S + A) | T */
+		r->r_addend = (int)(long)(elf->symtab_start + ELF_R_SYM(r->r_info));
+		break;
+	case R_ARM_PC24:
+		/* From ARM ABI: ((S + A) | T) - P */
+		r->r_addend = (int)(long)(elf->hdr + elf->sechdrs[rsection].sh_offset +
+		                          (r->r_offset - elf->sechdrs[rsection].sh_addr));
+		break;
+	default:
+		return 1;
+	}
+	return 0;
+}
+
 static int addend_mips_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
 {
 	unsigned int r_typ = ELF_R_TYPE(r->r_info);
@@ -1051,6 +1071,10 @@ static void check_sec_ref(struct module *mod, const char *modname,
 					if (addend_386_rel(elf, i, &r))
 						continue;
 					break;
+				case EM_ARM:
+					if(addend_arm_rel(elf, i, &r))
+						continue;
+					break;
 				case EM_MIPS:
 					if (addend_mips_rel(elf, i, &r))
 						continue;

commit ae4ac12323c0ff80528cac3269151d580e23f923
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue May 22 18:27:39 2007 +0900

    kbuild: make better section mismatch reports on i386 and mips
    
    On i386 and MIPS, warn_sec_mismatch() sometimes fails to show
    usefull symbol name.  This is because empty 'refsym' due to 0 r_addend
    value.  This patch is to adjust r_addend value, consulting with
    apply_relocate() routine in kernel code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3645e980da71..b83cddb8dca9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -374,6 +374,7 @@ static int parse_elf(struct elf_info *info, const char *filename)
 	hdr->e_shstrndx = TO_NATIVE(hdr->e_shstrndx);
 	hdr->e_shnum    = TO_NATIVE(hdr->e_shnum);
 	hdr->e_machine  = TO_NATIVE(hdr->e_machine);
+	hdr->e_type     = TO_NATIVE(hdr->e_type);
 	sechdrs = (void *)hdr + hdr->e_shoff;
 	info->sechdrs = sechdrs;
 
@@ -384,6 +385,8 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		sechdrs[i].sh_size   = TO_NATIVE(sechdrs[i].sh_size);
 		sechdrs[i].sh_link   = TO_NATIVE(sechdrs[i].sh_link);
 		sechdrs[i].sh_name   = TO_NATIVE(sechdrs[i].sh_name);
+		sechdrs[i].sh_info   = TO_NATIVE(sechdrs[i].sh_info);
+		sechdrs[i].sh_addr   = TO_NATIVE(sechdrs[i].sh_addr);
 	}
 	/* Find symbol table. */
 	for (i = 1; i < hdr->e_shnum; i++) {
@@ -753,6 +756,8 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
 		if (sym->st_shndx != relsym->st_shndx)
 			continue;
+		if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
+			continue;
 		if (sym->st_value == addr)
 			return sym;
 	}
@@ -895,6 +900,58 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	}
 }
 
+static unsigned int *reloc_location(struct elf_info *elf,
+					   int rsection, Elf_Rela *r)
+{
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	int section = sechdrs[rsection].sh_info;
+
+	return (void *)elf->hdr + sechdrs[section].sh_offset +
+		(r->r_offset - sechdrs[section].sh_addr);
+}
+
+static int addend_386_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
+{
+	unsigned int r_typ = ELF_R_TYPE(r->r_info);
+	unsigned int *location = reloc_location(elf, rsection, r);
+
+	switch (r_typ) {
+	case R_386_32:
+		r->r_addend = TO_NATIVE(*location);
+		break;
+	case R_386_PC32:
+		r->r_addend = TO_NATIVE(*location) + 4;
+		/* For CONFIG_RELOCATABLE=y */
+		if (elf->hdr->e_type == ET_EXEC)
+			r->r_addend += r->r_offset;
+		break;
+	}
+	return 0;
+}
+
+static int addend_mips_rel(struct elf_info *elf, int rsection, Elf_Rela *r)
+{
+	unsigned int r_typ = ELF_R_TYPE(r->r_info);
+	unsigned int *location = reloc_location(elf, rsection, r);
+	unsigned int inst;
+
+	if (r_typ == R_MIPS_HI16)
+		return 1;	/* skip this */
+	inst = TO_NATIVE(*location);
+	switch (r_typ) {
+	case R_MIPS_LO16:
+		r->r_addend = inst & 0xffff;
+		break;
+	case R_MIPS_26:
+		r->r_addend = (inst & 0x03ffffff) << 2;
+		break;
+	case R_MIPS_32:
+		r->r_addend = inst;
+		break;
+	}
+	return 0;
+}
+
 /**
  * A module includes a number of sections that are discarded
  * either when loaded or when used as built-in.
@@ -938,8 +995,11 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r.r_offset = TO_NATIVE(rela->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
 				if (hdr->e_machine == EM_MIPS) {
+					unsigned int r_typ;
 					r_sym = ELF64_MIPS_R_SYM(rela->r_info);
 					r_sym = TO_NATIVE(r_sym);
+					r_typ = ELF64_MIPS_R_TYPE(rela->r_info);
+					r.r_info = ELF64_R_INFO(r_sym, r_typ);
 				} else {
 					r.r_info = TO_NATIVE(rela->r_info);
 					r_sym = ELF_R_SYM(r.r_info);
@@ -972,8 +1032,11 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r.r_offset = TO_NATIVE(rel->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
 				if (hdr->e_machine == EM_MIPS) {
+					unsigned int r_typ;
 					r_sym = ELF64_MIPS_R_SYM(rel->r_info);
 					r_sym = TO_NATIVE(r_sym);
+					r_typ = ELF64_MIPS_R_TYPE(rel->r_info);
+					r.r_info = ELF64_R_INFO(r_sym, r_typ);
 				} else {
 					r.r_info = TO_NATIVE(rel->r_info);
 					r_sym = ELF_R_SYM(r.r_info);
@@ -983,6 +1046,16 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r_sym = ELF_R_SYM(r.r_info);
 #endif
 				r.r_addend = 0;
+				switch (hdr->e_machine) {
+				case EM_386:
+					if (addend_386_rel(elf, i, &r))
+						continue;
+					break;
+				case EM_MIPS:
+					if (addend_mips_rel(elf, i, &r))
+						continue;
+					break;
+				}
 				sym = elf->symtab_start + r_sym;
 				/* Skip special sections */
 				if (sym->st_shndx >= SHN_LORESERVE)

commit 2648a53acf16a837e11836203aadb219bd951a1e
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Jun 11 21:52:04 2007 +0200

    kbuild: fix sh64 section mismatch problems
    
    There's a special .cranges section that is almost always generated,
    with data being moved to the appropriate section by the linker at a later
    stage.
    
    To give a bit of background, sh64 has both a native SHmedia instruction
    set (32-bit instructions) and SHcompact (which is compatability with
    normal SH -- 16-bit, a massively reduced register set, etc.). code ranges
    are emitted when we're using the 32-bit ABI, but not the 64-bit one.
    
    It is a special staging section used solely by binutils where code with
    different flags get placed (more specifically differing flags for input
    and output sections), before being lazily merged by the linker.
    
    The closest I've been able to find to documentation is:
      http://sources.redhat.com/cgi-bin/cvsweb.cgi/src/ld/emultempl/sh64elf.em?rev=1.10&content-type=text/x-cvsweb-markup&cvsroot=src
    
    It's an array of 8-byte Elf32_CRange structure given in
      http://sources.redhat.com/cgi-bin/cvsweb.cgi/src/bfd/elf32-sh64.h?rev=1.4&content-type=text/x-cvsweb-markup&cvsroot=src
    that describes for which ISA a range is used.
    
    Silence the warnings by allowing references from .init.text to .cranges.
    
    The following warnings are fixed:
    
    WARNING: init/built-in.o(.cranges+0x0): Section mismatch: reference to .init.text:
    WARNING: init/built-in.o(.cranges+0xa): Section mismatch: reference to .init.text:
    WARNING: init/built-in.o(.cranges+0x14): Section mismatch: reference to .init.text:
    WARNING: init/built-in.o(.cranges+0x1e): Section mismatch: reference to .init.text:
    WARNING: init/built-in.o(.cranges+0x28): Section mismatch: reference to .init.text:
    WARNING: init/built-in.o(.cranges+0x32): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x50): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x5a): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x64): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0xfa): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x104): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x10e): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x14a): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x154): Section mismatch: reference to .init.text:
    WARNING: kernel/built-in.o(.cranges+0x15e): Section mismatch: reference to .init.text:
    WARNING: mm/built-in.o(.cranges+0x6e): Section mismatch: reference to .init.text:
    WARNING: mm/built-in.o(.cranges+0x78): Section mismatch: reference to .init.text:
    WARNING: mm/built-in.o(.cranges+0x82): Section mismatch: reference to .init.text:
    WARNING: mm/built-in.o(.cranges+0xaa): Section mismatch: reference to .init.text:
    WARNING: fs/built-in.o(.cranges+0x136): Section mismatch: reference to .init.text:
    WARNING: fs/built-in.o(.cranges+0x140): Section mismatch: reference to .init.text:
    WARNING: fs/built-in.o(.cranges+0x14a): Section mismatch: reference to .init.text:
    WARNING: fs/built-in.o(.cranges+0x168): Section mismatch: reference to .init.text:
    WARNING: fs/built-in.o(.cranges+0x1f4): Section mismatch: reference to .init.text:
    WARNING: fs/built-in.o(.cranges+0x1fe): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x302): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x30c): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x316): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x3a2): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x3ac): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x4ce): Section mismatch: reference to .init.text:
    WARNING: net/built-in.o(.cranges+0x4d8): Section mismatch: reference to .init.text:
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: Kaz Kojima <kkojima@rr.iij4u.or.jp>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8e5610d428c5..3645e980da71 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1052,6 +1052,7 @@ static int init_section_ref_ok(const char *name)
 		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
 		"__ftr_fixup",		/* powerpc cpu feature fixup */
 		"__fw_ftr_fixup",	/* powerpc firmware feature fixup */
+		".cranges",	/* used by sh64 */
 		NULL
 	};
 	/* Start of section names */
@@ -1132,6 +1133,7 @@ static int exit_section_ref_ok(const char *name)
 		".fixup",
 		".smp_locks",
 		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
+		".cranges",	/* used by sh64 */
 		NULL
 	};
 	/* Start of section names */

commit efa5bf1dd2cf3cdee0bfe97cfd76ff2296179ae4
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon May 21 18:41:17 2007 -0700

    Revert "kbuild: make better section mismatch reports on i386, arm and mips"
    
    This reverts commit f892b7d480eec809a5dfbd6e65742b3f3155e50e, which
    totally broke the build on x86 with CONFIG_RELOCATABLE (which, as far as
    I can tell, is the only case where it should even matter!) due to a
    SIGSEGV in modpost.
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8424d1f53bbe..8e5610d428c5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -384,7 +384,6 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		sechdrs[i].sh_size   = TO_NATIVE(sechdrs[i].sh_size);
 		sechdrs[i].sh_link   = TO_NATIVE(sechdrs[i].sh_link);
 		sechdrs[i].sh_name   = TO_NATIVE(sechdrs[i].sh_name);
-		sechdrs[i].sh_info   = TO_NATIVE(sechdrs[i].sh_info);
 	}
 	/* Find symbol table. */
 	for (i = 1; i < hdr->e_shnum; i++) {
@@ -754,8 +753,6 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
 		if (sym->st_shndx != relsym->st_shndx)
 			continue;
-		if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
-			continue;
 		if (sym->st_value == addr)
 			return sym;
 	}
@@ -898,68 +895,6 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	}
 }
 
-static void addend_386_rel(struct elf_info *elf, int section, Elf_Rela *r)
-{
-	Elf_Shdr *sechdrs = elf->sechdrs;
-	unsigned int r_typ;
-	unsigned int *location;
-
-	r_typ = ELF_R_TYPE(r->r_info);
-	location = (void *)elf->hdr +
-		sechdrs[sechdrs[section].sh_info].sh_offset + r->r_offset;
-	switch (r_typ) {
-	case R_386_32:
-		r->r_addend = TO_NATIVE(*location);
-		break;
-	case R_386_PC32:
-		r->r_addend = TO_NATIVE(*location) + 4;
-		break;
-	}
-}
-
-static void addend_arm_rel(struct elf_info *elf, int section, Elf_Rela *r)
-{
-	Elf_Shdr *sechdrs = elf->sechdrs;
-	unsigned int r_typ;
-	unsigned int *location;
-
-	r_typ = ELF_R_TYPE(r->r_info);
-	location = (void *)elf->hdr +
-		sechdrs[sechdrs[section].sh_info].sh_offset + r->r_offset;
-	switch (r_typ) {
-	case R_ARM_ABS32:
-		r->r_addend = TO_NATIVE(*location);
-		break;
-	case R_ARM_PC24:
-		r->r_addend = ((TO_NATIVE(*location) & 0x00ffffff) << 2) + 8;
-		break;
-	}
-}
-
-static int addend_mips_rel(struct elf_info *elf, int section, Elf_Rela *r)
-{
-	Elf_Shdr *sechdrs = elf->sechdrs;
-	unsigned int r_typ;
-	unsigned int *location;
-	unsigned int inst;
-
-	r_typ = ELF_R_TYPE(r->r_info);
-	if (r_typ == R_MIPS_HI16)
-		return 1;	/* skip this */
-	location = (void *)elf->hdr +
-		sechdrs[sechdrs[section].sh_info].sh_offset + r->r_offset;
-	inst = TO_NATIVE(*location);
-	switch (r_typ) {
-	case R_MIPS_LO16:
-		r->r_addend = ((inst & 0xffff) ^ 0x8000) - 0x8000;
-		break;
-	case R_MIPS_26:
-		r->r_addend = (inst & 0x03ffffff) << 2;
-		break;
-	}
-	return 0;
-}
-
 /**
  * A module includes a number of sections that are discarded
  * either when loaded or when used as built-in.
@@ -1003,11 +938,8 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r.r_offset = TO_NATIVE(rela->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
 				if (hdr->e_machine == EM_MIPS) {
-					unsigned int r_typ;
 					r_sym = ELF64_MIPS_R_SYM(rela->r_info);
 					r_sym = TO_NATIVE(r_sym);
-					r_typ = ELF64_MIPS_R_TYPE(rela->r_info);
-					r.r_info = ELF64_R_INFO(r_sym, r_typ);
 				} else {
 					r.r_info = TO_NATIVE(rela->r_info);
 					r_sym = ELF_R_SYM(r.r_info);
@@ -1040,11 +972,8 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r.r_offset = TO_NATIVE(rel->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
 				if (hdr->e_machine == EM_MIPS) {
-					unsigned int r_typ;
 					r_sym = ELF64_MIPS_R_SYM(rel->r_info);
 					r_sym = TO_NATIVE(r_sym);
-					r_typ = ELF64_MIPS_R_TYPE(rel->r_info);
-					r.r_info = ELF64_R_INFO(r_sym, r_typ);
 				} else {
 					r.r_info = TO_NATIVE(rel->r_info);
 					r_sym = ELF_R_SYM(r.r_info);
@@ -1054,14 +983,6 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r_sym = ELF_R_SYM(r.r_info);
 #endif
 				r.r_addend = 0;
-				if (hdr->e_machine == EM_386)
-					addend_386_rel(elf, i, &r);
-				else if (hdr->e_machine == EM_ARM)
-					addend_arm_rel(elf, i, &r);
-				else if (hdr->e_machine == EM_MIPS) {
-					if (addend_mips_rel(elf, i, &r))
-						continue;
-				}
 				sym = elf->symtab_start + r_sym;
 				/* Skip special sections */
 				if (sym->st_shndx >= SHN_LORESERVE)

commit 577a32f620271416d05f852477151fb51c790bc6
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu May 17 23:29:25 2007 +0200

    mm: fix section mismatch warnings
    
    modpost had two cases hardcoded for mm/
    Shift over to __init_refok and kill the
    hardcoded function names in modpost.
    
    This has the drawback that the functions
    will always be kept no matter configuration.
    With previous code the function were placed in
    init section if configuration allowed it.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 40fb7b6a00b1..8424d1f53bbe 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -641,12 +641,6 @@ static int strrcmp(const char *s, const char *sub)
  *  tosec   = .init.text
  *  fromsec  = .paravirtprobe
  *
- * Pattern 9:
- *  Some of functions are common code between boot time and hotplug
- *  time. The bootmem allocater is called only boot time in its
- *  functions. So it's ok to reference.
- *  tosec    = .init.text
- *
  * Pattern 10:
  *  ia64 has machvec table for each platform and
  *  powerpc has a machine desc table for each platform.
@@ -678,12 +672,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		NULL
 	};
 
-	const char *pat4sym[] = {
-		"sparse_index_alloc",
-		"zone_wait_table_init",
-		NULL
-	};
-
 	/* Check for pattern 0 */
 	if ((strcmp(fromsec, ".text.init.refok") == 0) ||
 	    (strcmp(fromsec, ".data.init.refok") == 0))
@@ -741,13 +729,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strcmp(fromsec, ".paravirtprobe") == 0))
 		return 1;
 
-	/* Check for pattern 9 */
-	if ((strcmp(tosec, ".init.text") == 0) &&
-	    (strcmp(fromsec, ".text") == 0))
-		for (s = pat4sym; *s; s++)
-			if (strcmp(atsym, *s) == 0)
-				return 1;
-
 	/* Check for pattern 10 */
 	if ((strcmp(fromsec, ".machvec") == 0) ||
 	    (strcmp(fromsec, ".machine.desc") == 0))

commit 92080309df1975729a9f8b45fd56528817e34db8
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu May 17 20:43:54 2007 +0200

    init/main: use __init_refok to fix section mismatch
    
    Kill a special case in modpost by introducing the
    __init_refok marker.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7c87267b6ff0..40fb7b6a00b1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -626,14 +626,6 @@ static int strrcmp(const char *s, const char *sub)
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
- * Pattern 6:
- *   During the early init phase we have references from .init.text to
- *   .text we have an intended section mismatch - do not warn about it.
- *   See kernel_init() in init/main.c
- *   tosec   = .init.text
- *   fromsec = .text
- *   atsym = kernel_init
- *
  * Pattern 7:
  *  Logos used in drivers/video/logo reside in __initdata but the
  *  funtion that references them are EXPORT_SYMBOL() so cannot be
@@ -738,12 +730,6 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		if (strcmp(refsymname, *s) == 0)
 			return 1;
 
-	/* Check for pattern 6 */
-	if ((strcmp(tosec, ".init.text") == 0) &&
-	    (strcmp(fromsec, ".text") == 0) &&
-	    (strcmp(refsymname, "kernel_init") == 0))
-		return 1;
-
 	/* Check for pattern 7 */
 	if ((strcmp(tosec, ".init.data") == 0) &&
 	    (strncmp(fromsec, ".text", strlen(".text")) == 0) &&

commit 0e0d314e6a01bb14d303e35e6f7ba24b17020044
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu May 17 20:14:48 2007 +0200

    kbuild: introduce __init_refok/__initdata_refok to supress section mismatch warnings
    
    Throughout the kernel there are a few legitimite references
    to init or exit sections. Most of these are covered by the
    patterns included in modpost but a few nees special attention.
    To avoid hardcoding a lot of function names in modpost introduce
    a marker so relevant function/data can be marked.
    When modpost see a reference to a init/exit function from
    a function/data marked no warning will be issued.
    
    Idea from: Andrew Morton <akpm@linux-foundation.org>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2909391a8035..7c87267b6ff0 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -583,6 +583,12 @@ static int strrcmp(const char *s, const char *sub)
 
 /**
  * Whitelist to allow certain references to pass with no warning.
+ *
+ * Pattern 0:
+ *   Do not warn if funtion/data are marked with __init_refok/__initdata_refok.
+ *   The pattern is identified by:
+ *   fromsec = .text.init.refok | .data.init.refok
+ *
  * Pattern 1:
  *   If a module parameter is declared __initdata and permissions=0
  *   then this is legal despite the warning generated.
@@ -686,6 +692,11 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		NULL
 	};
 
+	/* Check for pattern 0 */
+	if ((strcmp(fromsec, ".text.init.refok") == 0) ||
+	    (strcmp(fromsec, ".data.init.refok") == 0))
+		return 1;
+
 	/* Check for pattern 1 */
 	if (strcmp(tosec, ".init.data") != 0)
 		f1 = 0;

commit cd5477911fc9f5cc64678e2b95cdd606c59a11b5
Author: Li Yang <leoli@freescale.com>
Date:   Mon May 14 18:04:28 2007 +0800

    kbuild: add "Section mismatch" warning whitelist for powerpc
    
    This patch fixes the following class of "Section mismatch" warnings when
    building powerpc platforms.
    
    WARNING: arch/powerpc/kernel/built-in.o - Section mismatch: reference to .init.data:.got2 from prom_entry (offset 0x0)
    WARNING: arch/powerpc/platforms/built-in.o - Section mismatch: reference to .init.text:mpc8313_rdb_probe from .machine.desc after 'mach_mpc8313_rdb' (at offset 0x4)
    ....
    
    Signed-off-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ce7e0d17bae2..2909391a8035 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -650,9 +650,10 @@ static int strrcmp(const char *s, const char *sub)
  *  tosec    = .init.text
  *
  * Pattern 10:
- *  ia64 has machvec table for each platform. It is mixture of function
- *  pointer of .init.text and .text.
- *  fromsec  = .machvec
+ *  ia64 has machvec table for each platform and
+ *  powerpc has a machine desc table for each platform.
+ *  It is mixture of function pointers of .init.text and .text.
+ *  fromsec  = .machvec | .machine.desc
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -751,7 +752,8 @@ static int secref_whitelist(const char *modname, const char *tosec,
 				return 1;
 
 	/* Check for pattern 10 */
-	if (strcmp(fromsec, ".machvec") == 0)
+	if ((strcmp(fromsec, ".machvec") == 0) ||
+	    (strcmp(fromsec, ".machine.desc") == 0))
 		return 1;
 
 	return 0;
@@ -887,6 +889,11 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			     elf->strtab + before->st_name, refsymname))
 		return;
 
+	/* fromsec whitelist - without a valid 'before'
+	 * powerpc has a GOT table in .got2 section */
+	if (strcmp(fromsec, ".got2") == 0)
+		return;
+
 	if (before && after) {
 		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
 		     "(between '%s' and '%s')\n",

commit f892b7d480eec809a5dfbd6e65742b3f3155e50e
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu May 17 01:14:38 2007 +0900

    kbuild: make better section mismatch reports on i386, arm and mips
    
    On i386, ARM and MIPS, warn_sec_mismatch() sometimes fails to show
    usefull symbol name.  This is because empty 'refsym' due to 0 r_addend
    value.  This patch is to adjust r_addend value, consulting with
    apply_relocate() routine in kernel code.
    
    Without this patch:
      MODPOST vmlinux
    WARNING: init/built-in.o - Section mismatch: reference to .init.text: from .text between 'rest_init' (at offset 0xf4) and 'try_name'
    WARNING: mm/built-in.o - Section mismatch: reference to .init.text: from .text between 'kmem_cache_create' (at offset 0x18a39) and 'cache_reap'
    WARNING: mm/built-in.o - Section mismatch: reference to .init.text: from .text between 'kmem_cache_create' (at offset 0x18a6b) and 'cache_reap'
    
    With this patch:
      MODPOST vmlinux
    WARNING: mm/built-in.o - Section mismatch: reference to .init.text:set_up_list3s from .text between 'kmem_cache_create' (at offset 0x18a39) and 'cache_reap'
    WARNING: mm/built-in.o - Section mismatch: reference to .init.text:set_up_list3s from .text between 'kmem_cache_create' (at offset 0x18a6b) and 'cache_reap'
    
    Now modpost can detect "kernel_init" name (and whitelist it) and show
    "set_up_list3s" name.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2fcdbc7a1ee5..ce7e0d17bae2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -384,6 +384,7 @@ static int parse_elf(struct elf_info *info, const char *filename)
 		sechdrs[i].sh_size   = TO_NATIVE(sechdrs[i].sh_size);
 		sechdrs[i].sh_link   = TO_NATIVE(sechdrs[i].sh_link);
 		sechdrs[i].sh_name   = TO_NATIVE(sechdrs[i].sh_name);
+		sechdrs[i].sh_info   = TO_NATIVE(sechdrs[i].sh_info);
 	}
 	/* Find symbol table. */
 	for (i = 1; i < hdr->e_shnum; i++) {
@@ -773,6 +774,8 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
 		if (sym->st_shndx != relsym->st_shndx)
 			continue;
+		if (ELF_ST_TYPE(sym->st_info) == STT_SECTION)
+			continue;
 		if (sym->st_value == addr)
 			return sym;
 	}
@@ -910,6 +913,68 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	}
 }
 
+static void addend_386_rel(struct elf_info *elf, int section, Elf_Rela *r)
+{
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	unsigned int r_typ;
+	unsigned int *location;
+
+	r_typ = ELF_R_TYPE(r->r_info);
+	location = (void *)elf->hdr +
+		sechdrs[sechdrs[section].sh_info].sh_offset + r->r_offset;
+	switch (r_typ) {
+	case R_386_32:
+		r->r_addend = TO_NATIVE(*location);
+		break;
+	case R_386_PC32:
+		r->r_addend = TO_NATIVE(*location) + 4;
+		break;
+	}
+}
+
+static void addend_arm_rel(struct elf_info *elf, int section, Elf_Rela *r)
+{
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	unsigned int r_typ;
+	unsigned int *location;
+
+	r_typ = ELF_R_TYPE(r->r_info);
+	location = (void *)elf->hdr +
+		sechdrs[sechdrs[section].sh_info].sh_offset + r->r_offset;
+	switch (r_typ) {
+	case R_ARM_ABS32:
+		r->r_addend = TO_NATIVE(*location);
+		break;
+	case R_ARM_PC24:
+		r->r_addend = ((TO_NATIVE(*location) & 0x00ffffff) << 2) + 8;
+		break;
+	}
+}
+
+static int addend_mips_rel(struct elf_info *elf, int section, Elf_Rela *r)
+{
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	unsigned int r_typ;
+	unsigned int *location;
+	unsigned int inst;
+
+	r_typ = ELF_R_TYPE(r->r_info);
+	if (r_typ == R_MIPS_HI16)
+		return 1;	/* skip this */
+	location = (void *)elf->hdr +
+		sechdrs[sechdrs[section].sh_info].sh_offset + r->r_offset;
+	inst = TO_NATIVE(*location);
+	switch (r_typ) {
+	case R_MIPS_LO16:
+		r->r_addend = ((inst & 0xffff) ^ 0x8000) - 0x8000;
+		break;
+	case R_MIPS_26:
+		r->r_addend = (inst & 0x03ffffff) << 2;
+		break;
+	}
+	return 0;
+}
+
 /**
  * A module includes a number of sections that are discarded
  * either when loaded or when used as built-in.
@@ -953,8 +1018,11 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r.r_offset = TO_NATIVE(rela->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
 				if (hdr->e_machine == EM_MIPS) {
+					unsigned int r_typ;
 					r_sym = ELF64_MIPS_R_SYM(rela->r_info);
 					r_sym = TO_NATIVE(r_sym);
+					r_typ = ELF64_MIPS_R_TYPE(rela->r_info);
+					r.r_info = ELF64_R_INFO(r_sym, r_typ);
 				} else {
 					r.r_info = TO_NATIVE(rela->r_info);
 					r_sym = ELF_R_SYM(r.r_info);
@@ -987,8 +1055,11 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r.r_offset = TO_NATIVE(rel->r_offset);
 #if KERNEL_ELFCLASS == ELFCLASS64
 				if (hdr->e_machine == EM_MIPS) {
+					unsigned int r_typ;
 					r_sym = ELF64_MIPS_R_SYM(rel->r_info);
 					r_sym = TO_NATIVE(r_sym);
+					r_typ = ELF64_MIPS_R_TYPE(rel->r_info);
+					r.r_info = ELF64_R_INFO(r_sym, r_typ);
 				} else {
 					r.r_info = TO_NATIVE(rel->r_info);
 					r_sym = ELF_R_SYM(r.r_info);
@@ -998,6 +1069,14 @@ static void check_sec_ref(struct module *mod, const char *modname,
 				r_sym = ELF_R_SYM(r.r_info);
 #endif
 				r.r_addend = 0;
+				if (hdr->e_machine == EM_386)
+					addend_386_rel(elf, i, &r);
+				else if (hdr->e_machine == EM_ARM)
+					addend_arm_rel(elf, i, &r);
+				else if (hdr->e_machine == EM_MIPS) {
+					if (addend_mips_rel(elf, i, &r))
+						continue;
+				}
 				sym = elf->symtab_start + r_sym;
 				/* Skip special sections */
 				if (sym->st_shndx >= SHN_LORESERVE)

commit 2560120997403581dd824e5bd2389c719edcbf12
Author: Russell King <rmk+lkml@arm.linux.org.uk>
Date:   Thu May 10 23:03:25 2007 +0100

    kbuild: make modpost section warnings clearer
    
    Change modpost section mismatch warnings to be less confusing;
    model them on the binutils linker warnings which we all know how
    to interpret.
    
    Also, fix the wrong ordering of arguments for the final case -
    fromsec and refsymname were reversed.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 113dc77b9f60..2fcdbc7a1ee5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -885,29 +885,28 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		return;
 
 	if (before && after) {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
-		     "between '%s' (at offset 0x%llx) and '%s'\n",
-		     modname, secname, refsymname, fromsec,
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
+		     "(between '%s' and '%s')\n",
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname,
 		     elf->strtab + before->st_name,
-		     (long long)r.r_offset,
 		     elf->strtab + after->st_name);
 	} else if (before) {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
-		     "after '%s' (at offset 0x%llx)\n",
-		     modname, secname, refsymname, fromsec,
-		     elf->strtab + before->st_name,
-		     (long long)r.r_offset);
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
+		     "(after '%s')\n",
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname,
+		     elf->strtab + before->st_name);
 	} else if (after) {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s "
 		     "before '%s' (at offset -0x%llx)\n",
-		     modname, secname, refsymname, fromsec,
-		     elf->strtab + after->st_name,
-		     (long long)r.r_offset);
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname,
+		     elf->strtab + after->st_name);
 	} else {
-		warn("%s - Section mismatch: reference to %s:%s from %s "
-		     "(offset 0x%llx)\n",
-		     modname, secname, fromsec, refsymname,
-		     (long long)r.r_offset);
+		warn("%s(%s+0x%llx): Section mismatch: reference to %s:%s\n",
+		     modname, fromsec, (unsigned long long)r.r_offset,
+		     secname, refsymname);
 	}
 }
 

commit e61a1c1c4f240cec61300c8f27518c3e47570fd4
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Wed May 9 02:35:15 2007 -0700

    Allow arch to initialize arch field of the module structure
    
    This will later allow an arch to add module specific information via linker
    generated tables instead of poking directly in the module object structure.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 480e18b00aa6..113dc77b9f60 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1343,6 +1343,7 @@ static void add_header(struct buffer *b, struct module *mod)
 		buf_printf(b, "#ifdef CONFIG_MODULE_UNLOAD\n"
 			      " .exit = cleanup_module,\n"
 			      "#endif\n");
+	buf_printf(b, " .arch = MODULE_ARCH_INIT,\n");
 	buf_printf(b, "};\n");
 }
 

commit 72280ede316911fd5a82ef78d12a6705b1007d36
Author: Yasunori Goto <y-goto@jp.fujitsu.com>
Date:   Tue May 8 00:23:10 2007 -0700

    Add white list into modpost.c for memory hotplug code and ia64's machvec section
    
    This patch is add white list into modpost.c for some functions and
    ia64's section to fix section mismatchs.
    
      sparse_index_alloc() and zone_wait_table_init() calls bootmem allocator
      at boot time, and kmalloc/vmalloc at hotplug time. If config
      memory hotplug is on, there are references of bootmem allocater(init text)
      from them (normal text). This is cause of section mismatch.
    
      Bootmem is called by many functions and it must be
      used only at boot time. I think __init of them should keep for
      section mismatch check. So, I would like to register sparse_index_alloc()
      and zone_wait_table_init() into white list.
    
      In addition, ia64's .machvec section is function table of some platform
      dependent code. It is mixture of .init.text and normal text. These
      reference of __init functions are valid too.
    
    Signed-off-by: Yasunori Goto <y-goto@jp.fujitsu.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4ab36de45aa2..480e18b00aa6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -642,6 +642,16 @@ static int strrcmp(const char *s, const char *sub)
  *  tosec   = .init.text
  *  fromsec  = .paravirtprobe
  *
+ * Pattern 9:
+ *  Some of functions are common code between boot time and hotplug
+ *  time. The bootmem allocater is called only boot time in its
+ *  functions. So it's ok to reference.
+ *  tosec    = .init.text
+ *
+ * Pattern 10:
+ *  ia64 has machvec table for each platform. It is mixture of function
+ *  pointer of .init.text and .text.
+ *  fromsec  = .machvec
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -668,6 +678,12 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		NULL
 	};
 
+	const char *pat4sym[] = {
+		"sparse_index_alloc",
+		"zone_wait_table_init",
+		NULL
+	};
+
 	/* Check for pattern 1 */
 	if (strcmp(tosec, ".init.data") != 0)
 		f1 = 0;
@@ -726,6 +742,17 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strcmp(fromsec, ".paravirtprobe") == 0))
 		return 1;
 
+	/* Check for pattern 9 */
+	if ((strcmp(tosec, ".init.text") == 0) &&
+	    (strcmp(fromsec, ".text") == 0))
+		for (s = pat4sym; *s; s++)
+			if (strcmp(atsym, *s) == 0)
+				return 1;
+
+	/* Check for pattern 10 */
+	if (strcmp(fromsec, ".machvec") == 0)
+		return 1;
+
 	return 0;
 }
 

commit 15700770ef7c5d12e2f1659d2ddbeb3f658d9f37
Merge: 6de410c2b0cc 11de39e2fbbc
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Sun May 6 13:21:57 2007 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/sam/kbuild
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/sam/kbuild: (38 commits)
      kconfig: fix mconf segmentation fault
      kbuild: enable use of code from a different dir
      kconfig: error out if recursive dependencies are found
      kbuild: scripts/basic/fixdep segfault on pathological string-o-death
      kconfig: correct minor typo in Kconfig warning message.
      kconfig: fix path to modules.txt in Kconfig help
      usr/Kconfig: fix typo
      kernel-doc: alphabetically-sorted entries in index.html of 'htmldocs'
      kbuild: be more explicit on missing .config file
      kbuild: clarify the creation of the LOCALVERSION_AUTO string.
      kbuild: propagate errors from find in scripts/gen_initramfs_list.sh
      kconfig: refer to qt3 if we cannot find qt libraries
      kbuild: handle compressed cpio initramfs-es
      kbuild: ignore section mismatch warning for references from .paravirtprobe to .init.text
      kbuild: remove stale comment in modpost.c
      kbuild/mkuboot.sh: allow spaces in CROSS_COMPILE
      kbuild: fix make mrproper for Documentation/DocBook/man
      kbuild: remove kconfig binaries during make mrproper
      kconfig/menuconfig: do not hardcode '.config'
      kbuild: override build timestamp & version
      ...

commit b4d5171ac7d9806b1ea61903ff954cd9620135bf
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Apr 29 20:53:01 2007 +0200

    kbuild: ignore section mismatch warning for references from .paravirtprobe to .init.text
    
    Added on request from:  Rusty Russell <rusty@rustcorp.com.au>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc:  Rusty Russell <rusty@rustcorp.com.au>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b81157cf4527..628f393ecaa6 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -635,6 +635,13 @@ static int strrcmp(const char *s, const char *sub)
  *  tosec      = .init.data
  *  fromsec    = .text*
  *  refsymname = logo_
+ *
+ * Pattern 8:
+ *  Symbols contained in .paravirtprobe may safely reference .init.text.
+ *  The pattern is:
+ *  tosec   = .init.text
+ *  fromsec  = .paravirtprobe
+ *
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -712,6 +719,12 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strncmp(fromsec, ".text", strlen(".text")) == 0) &&
 	    (strncmp(refsymname, "logo_", strlen("logo_")) == 0))
 		return 1;
+
+	/* Check for pattern 8 */
+	if ((strcmp(tosec, ".init.text") == 0) &&
+	    (strcmp(fromsec, ".paravirtprobe") == 0))
+		return 1;
+
 	return 0;
 }
 

commit 66bd32e443203735b00f22bede637ec98f3070ca
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Apr 29 20:40:53 2007 +0200

    kbuild: remove stale comment in modpost.c
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b10b69b56a31..b81157cf4527 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -626,7 +626,6 @@ static int strrcmp(const char *s, const char *sub)
  *   tosec   = .init.text
  *   fromsec = .text
  *   atsym = kernel_init
- *   Some symbols belong to init section but still it is ok to reference
  *
  * Pattern 7:
  *  Logos used in drivers/video/logo reside in __initdata but the

commit 2a11665945d510e1a4df8dc44dc3668b01945ade
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sat Oct 7 05:35:32 2006 -0600

    kbuild: distinguish between errors and warnings in modpost
    
    Some of modpost's warnings are fatal, and some are not.  Adopt the
    compiler distinction between errors and warnings by calling merror()
    for fatal diagnostics and warn() for non-fatal ones.
    merror() was used as replacemtn for error() to avoid clash with glibc
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5f2ecd51bde3..b10b69b56a31 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -55,6 +55,17 @@ void warn(const char *fmt, ...)
 	va_end(arglist);
 }
 
+void merror(const char *fmt, ...)
+{
+	va_list arglist;
+
+	fprintf(stderr, "ERROR: ");
+
+	va_start(arglist, fmt);
+	vfprintf(stderr, fmt, arglist);
+	va_end(arglist);
+}
+
 static int is_vmlinux(const char *modname)
 {
 	const char *myname;
@@ -1307,9 +1318,14 @@ static int add_versions(struct buffer *b, struct module *mod)
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
 			if (have_vmlinux && !s->weak) {
-				warn("\"%s\" [%s.ko] undefined!\n",
-				     s->name, mod->name);
-				err = warn_unresolved ? 0 : 1;
+				if (warn_unresolved) {
+					warn("\"%s\" [%s.ko] undefined!\n",
+					     s->name, mod->name);
+				} else {
+					merror("\"%s\" [%s.ko] undefined!\n",
+					          s->name, mod->name);
+					err = 1;
+				}
 			}
 			continue;
 		}

commit 5a4910fbbeef14cc91daa41086449a1a4acebc96
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Feb 27 09:14:58 2007 +0100

    kbuild: whitelist logo references from .text to .init.data
    
    drivers/video/logo has references from .text to .init.data
    but function is only used during early init.
    So reference is OK and we do not want to warn about them =>
    whitelist the reference.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 281abb77e033..5f2ecd51bde3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -616,6 +616,15 @@ static int strrcmp(const char *s, const char *sub)
  *   fromsec = .text
  *   atsym = kernel_init
  *   Some symbols belong to init section but still it is ok to reference
+ *
+ * Pattern 7:
+ *  Logos used in drivers/video/logo reside in __initdata but the
+ *  funtion that references them are EXPORT_SYMBOL() so cannot be
+ *  marker __init. So we whitelist them here.
+ *  The pattern is:
+ *  tosec      = .init.data
+ *  fromsec    = .text*
+ *  refsymname = logo_
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -687,6 +696,12 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	    (strcmp(fromsec, ".text") == 0) &&
 	    (strcmp(refsymname, "kernel_init") == 0))
 		return 1;
+
+	/* Check for pattern 7 */
+	if ((strcmp(tosec, ".init.data") == 0) &&
+	    (strncmp(fromsec, ".text", strlen(".text")) == 0) &&
+	    (strncmp(refsymname, "logo_", strlen("logo_")) == 0))
+		return 1;
 	return 0;
 }
 

commit a61b2dfd1823506dbf1f9b046e0b09237ec1b985
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Feb 26 19:46:52 2007 +0100

    kbuild: fix segmentation fault in modpost
    
    If modpost was called manually with filenames without '/'
    then modpost would segfault.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e1f2b31cf34b..281abb77e033 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1345,6 +1345,7 @@ static void add_depends(struct buffer *b, struct module *mod,
 	buf_printf(b, "__attribute__((section(\".modinfo\"))) =\n");
 	buf_printf(b, "\"depends=");
 	for (s = mod->unres; s; s = s->next) {
+		const char *p;
 		if (!s->module)
 			continue;
 
@@ -1352,8 +1353,11 @@ static void add_depends(struct buffer *b, struct module *mod,
 			continue;
 
 		s->module->seen = 1;
-		buf_printf(b, "%s%s", first ? "" : ",",
-			   strrchr(s->module->name, '/') + 1);
+		if ((p = strrchr(s->module->name, '/')) != NULL)
+			p++;
+		else
+			p = s->module->name;
+		buf_printf(b, "%s%s", first ? "" : ",", p);
 		first = 0;
 	}
 	buf_printf(b, "\";\n");

commit 9bf8cb9b7908383752b1842eae78269f7e16d9fb
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Feb 26 17:49:06 2007 +0100

    kbuild: fix warnings from .pci_fixup section
    
    Now where we do not pass vmlinux to modpost we started
    to see section mismatch warnings from .pci_fixup.
    Refactored code a little to include these in the
    whitelist again.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index be0827f734c2..e1f2b31cf34b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -592,6 +592,14 @@ static int strrcmp(const char *s, const char *sub)
  *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console
  *
  * Pattern 3:
+ *   Whitelist all references from .pci_fixup* section to .init.text
+ *   This is part of the PCI init when built-in
+ *
+ * Pattern 4:
+ *   Whitelist all refereces from .text.head to .init.data
+ *   Whitelist all refereces from .text.head to .init.text
+ *
+ * Pattern 5:
  *   Some symbols belong to init section but still it is ok to reference
  *   these from non-init sections as these symbols don't have any memory
  *   allocated for them and symbol address and value are same. So even
@@ -599,7 +607,8 @@ static int strrcmp(const char *s, const char *sub)
  *   For ex. symbols marking the init section boundaries.
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
- * Pattern 4:
+ *
+ * Pattern 6:
  *   During the early init phase we have references from .init.text to
  *   .text we have an intended section mismatch - do not warn about it.
  *   See kernel_init() in init/main.c
@@ -657,26 +666,23 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	if (f1 && f2)
 		return 1;
 
-	/* Whitelist all references from .pci_fixup section if vmlinux
-	 * Whitelist all refereces from .text.head to .init.data if vmlinux
-	 * Whitelist all refereces from .text.head to .init.text if vmlinux
-	 */
-	if (is_vmlinux(modname)) {
-		if ((strcmp(fromsec, ".pci_fixup") == 0) &&
-		    (strcmp(tosec, ".init.text") == 0))
-		return 1;
-
-		if ((strcmp(fromsec, ".text.head") == 0) &&
-			((strcmp(tosec, ".init.data") == 0) ||
-			(strcmp(tosec, ".init.text") == 0)))
-		return 1;
+	/* Check for pattern 3 */
+	if ((strncmp(fromsec, ".pci_fixup", strlen(".pci_fixup")) == 0) &&
+	    (strcmp(tosec, ".init.text") == 0))
+	return 1;
 
-		/* Check for pattern 3 */
-		for (s = pat3refsym; *s; s++)
-			if (strcmp(refsymname, *s) == 0)
-				return 1;
-	}
 	/* Check for pattern 4 */
+	if ((strcmp(fromsec, ".text.head") == 0) &&
+		((strcmp(tosec, ".init.data") == 0) ||
+		(strcmp(tosec, ".init.text") == 0)))
+	return 1;
+
+	/* Check for pattern 5 */
+	for (s = pat3refsym; *s; s++)
+		if (strcmp(refsymname, *s) == 0)
+			return 1;
+
+	/* Check for pattern 6 */
 	if ((strcmp(tosec, ".init.text") == 0) &&
 	    (strcmp(fromsec, ".text") == 0) &&
 	    (strcmp(refsymname, "kernel_init") == 0))

commit aae5f662a32c35b1a962627535acb588d48ff5f9
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Feb 26 16:45:41 2007 +0100

    kbuild: whitelist section mismatch in init/main.c
    
    In init/main.c we have a reference from rest_init() to .init.text
    which is intentional.
    Rename the function 'init' to 'kernel_init' to make it a
    kernel wide unique symbol and whitelist the reference.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1912c752e422..be0827f734c2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -589,7 +589,7 @@ static int strrcmp(const char *s, const char *sub)
  *   the pattern is identified by:
  *   tosec   = .init.text | .exit.text | .init.data
  *   fromsec = .data
- *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one
+ *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one, *_console
  *
  * Pattern 3:
  *   Some symbols belong to init section but still it is ok to reference
@@ -599,6 +599,14 @@ static int strrcmp(const char *s, const char *sub)
  *   For ex. symbols marking the init section boundaries.
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
+ * Pattern 4:
+ *   During the early init phase we have references from .init.text to
+ *   .text we have an intended section mismatch - do not warn about it.
+ *   See kernel_init() in init/main.c
+ *   tosec   = .init.text
+ *   fromsec = .text
+ *   atsym = kernel_init
+ *   Some symbols belong to init section but still it is ok to reference
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
 			    const char *fromsec, const char *atsym,
@@ -668,6 +676,11 @@ static int secref_whitelist(const char *modname, const char *tosec,
 			if (strcmp(refsymname, *s) == 0)
 				return 1;
 	}
+	/* Check for pattern 4 */
+	if ((strcmp(tosec, ".init.text") == 0) &&
+	    (strcmp(fromsec, ".text") == 0) &&
+	    (strcmp(refsymname, "kernel_init") == 0))
+		return 1;
 	return 0;
 }
 

commit 85bd2fddd68e757da8e1af98f857f61a3c9ce647
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Feb 26 15:33:52 2007 +0100

    kbuild: fix section mismatch check for vmlinux
    
    vmlinux does not contain relocation entries which is
    used by the section mismatch checks.
    Reported by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    
    Use the individual objects as inputs to overcome
    this limitation.
    In modpost check the .o files and skip non-ELF files.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 65bdfdb56877..1912c752e422 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -333,10 +333,10 @@ void release_file(void *file, unsigned long size)
 	munmap(file, size);
 }
 
-static void parse_elf(struct elf_info *info, const char *filename)
+static int parse_elf(struct elf_info *info, const char *filename)
 {
 	unsigned int i;
-	Elf_Ehdr *hdr = info->hdr;
+	Elf_Ehdr *hdr;
 	Elf_Shdr *sechdrs;
 	Elf_Sym  *sym;
 
@@ -346,9 +346,18 @@ static void parse_elf(struct elf_info *info, const char *filename)
 		exit(1);
 	}
 	info->hdr = hdr;
-	if (info->size < sizeof(*hdr))
-		goto truncated;
-
+	if (info->size < sizeof(*hdr)) {
+		/* file too small, assume this is an empty .o file */
+		return 0;
+	}
+	/* Is this a valid ELF file? */
+	if ((hdr->e_ident[EI_MAG0] != ELFMAG0) ||
+	    (hdr->e_ident[EI_MAG1] != ELFMAG1) ||
+	    (hdr->e_ident[EI_MAG2] != ELFMAG2) ||
+	    (hdr->e_ident[EI_MAG3] != ELFMAG3)) {
+		/* Not an ELF file - silently ignore it */
+		return 0;
+	}
 	/* Fix endianness in ELF header */
 	hdr->e_shoff    = TO_NATIVE(hdr->e_shoff);
 	hdr->e_shstrndx = TO_NATIVE(hdr->e_shstrndx);
@@ -371,8 +380,10 @@ static void parse_elf(struct elf_info *info, const char *filename)
 			= (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
 		const char *secname;
 
-		if (sechdrs[i].sh_offset > info->size)
-			goto truncated;
+		if (sechdrs[i].sh_offset > info->size) {
+			fatal("%s is truncated. sechdrs[i].sh_offset=%u > sizeof(*hrd)=%ul\n", filename, (unsigned int)sechdrs[i].sh_offset, sizeof(*hdr));
+			return 0;
+		}
 		secname = secstrings + sechdrs[i].sh_name;
 		if (strcmp(secname, ".modinfo") == 0) {
 			info->modinfo = (void *)hdr + sechdrs[i].sh_offset;
@@ -407,10 +418,7 @@ static void parse_elf(struct elf_info *info, const char *filename)
 		sym->st_value = TO_NATIVE(sym->st_value);
 		sym->st_size  = TO_NATIVE(sym->st_size);
 	}
-	return;
-
- truncated:
-	fatal("%s is truncated.\n", filename);
+	return 1;
 }
 
 static void parse_elf_finish(struct elf_info *info)
@@ -1089,7 +1097,8 @@ static void read_symbols(char *modname)
 	struct elf_info info = { };
 	Elf_Sym *sym;
 
-	parse_elf(&info, modname);
+	if (!parse_elf(&info, modname))
+		return;
 
 	mod = new_module(modname);
 

commit 1833d6bc72893265f22addd79cf52e6987496e0f
Author: Vivek Goyal <vgoyal@in.ibm.com>
Date:   Wed May 2 19:27:08 2007 +0200

    [PATCH] i386: modpost apic related warning fixes
    
    o Modpost generates warnings for i386 if compiled with CONFIG_RELOCATABLE=y
    
    WARNING: vmlinux - Section mismatch: reference to .init.text:find_unisys_acpi_oem_table from .text between 'acpi_madt_oem_check' (at offset 0xc0101eda) and 'enable_apic_mode'
    WARNING: vmlinux - Section mismatch: reference to .init.text:acpi_get_table_header_early from .text between 'acpi_madt_oem_check' (at offset 0xc0101ef0) and 'enable_apic_mode'
    WARNING: vmlinux - Section mismatch: reference to .init.text:parse_unisys_oem from .text between 'acpi_madt_oem_check' (at offset 0xc0101f2e) and 'enable_apic_mode'
    WARNING: vmlinux - Section mismatch: reference to .init.text:setup_unisys from .text between 'acpi_madt_oem_check' (at offset 0xc0101f37) and 'enable_apic_mode'WARNING: vmlinux - Section mismatch: reference to .init.text:parse_unisys_oem from .text between 'mps_oem_check' (at offset 0xc0101ec7) and 'acpi_madt_oem_check'
    WARNING: vmlinux - Section mismatch: reference to .init.text:es7000_sw_apic from .text between 'enable_apic_mode' (at offset 0xc0101f48) and 'check_apicid_present'
    
    o Some functions which are inline (acpi_madt_oem_check) are not inlined by
      compiler as these functions are accessed using function pointer. These
      functions are put in .text section and they in-turn access __init type
      functions hence modpost generates warnings.
    
    o Do not iniline acpi_madt_oem_check, instead make it __init.
    
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 65bdfdb56877..78d659cbb36a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -606,6 +606,7 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		"_probe",
 		"_probe_one",
 		"_console",
+		"apic_es7000",
 		NULL
 	};
 

commit b0138a6cb7923a997d278b47c176778534d1095b
Merge: 6572d6d7d0f9 1055a8af093f
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Feb 26 12:48:06 2007 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/kyle/parisc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/kyle/parisc-2.6: (78 commits)
      [PARISC] Use symbolic last syscall in __NR_Linux_syscalls
      [PARISC] Add missing statfs64 and fstatfs64 syscalls
      Revert "[PARISC] Optimize TLB flush on SMP systems"
      [PARISC] Compat signal fixes for 64-bit parisc
      [PARISC] Reorder syscalls to match unistd.h
      Revert "[PATCH] make kernel/signal.c:kill_proc_info() static"
      [PARISC] fix sys_rt_sigqueueinfo
      [PARISC] fix section mismatch warnings in harmony sound driver
      [PARISC] do not export get_register/set_register
      [PARISC] add ENTRY()/ENDPROC() and simplify assembly of HP/UX emulation code
      [PARISC] convert to use CONFIG_64BIT instead of __LP64__
      [PARISC] use CONFIG_64BIT instead of __LP64__
      [PARISC] add ASM_EXCEPTIONTABLE_ENTRY() macro
      [PARISC] more ENTRY(), ENDPROC(), END() conversions
      [PARISC] fix ENTRY() and ENDPROC() for 64bit-parisc
      [PARISC] Fixes /proc/cpuinfo cache output on B160L
      [PARISC] implement standard ENTRY(), END() and ENDPROC()
      [PARISC] kill ENTRY_SYS_CPUS
      [PARISC] clean up debugging printks in smp.c
      [PARISC] factor syscall_restart code out of do_signal
      ...
    
    Fix conflict in include/linux/sched.h due to kill_proc_info() being made
    publicly available to PARISC again.

commit da68d61f89e275260cc993a0d4a39e63700098fb
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Feb 20 13:58:16 2007 -0800

    [PATCH] remove modpost false warnings on ARM
    
    This patch stops "modpost" from issuing erroneous modpost warnings on ARM
    builds, which it's been doing since since maybe last summer.  A canonical
    example would be driver method table entries:
    
      WARNING: <path> - Section mismatch: reference to .exit.text:<name>_remove
            from .data after '$d' (at offset 0x4)
    
    That "$d" symbol is generated by tools conformant with ARM ABI specs; in
    this case it's a symbol **in the middle of** a "<name>_driver" struct.
    
    The erroneous warnings appear to be issued because "modpost" whitelists
    references from "<name>_driver" data into init and exit sections ...  but
    doesn't know should also include those "$d" mapping symbols, which are not
    otherwise associated with "<name>_driver" symbols.
    
    This patch prevents the modpost symbol lookup code from ever returning
    those mapping symbols, so it will return a whitelisted symbol instead.
    Then things work as expected.
    
    Now to revert various code-bloating "fixes" that got merged because of this
    modpost bug....
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 569e68410d7a..c4b5398687b8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -686,6 +686,30 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 	return NULL;
 }
 
+static inline int is_arm_mapping_symbol(const char *str)
+{
+	return str[0] == '$' && strchr("atd", str[1])
+	       && (str[2] == '\0' || str[2] == '.');
+}
+
+/*
+ * If there's no name there, ignore it; likewise, ignore it if it's
+ * one of the magic symbols emitted used by current ARM tools.
+ *
+ * Otherwise if find_symbols_between() returns those symbols, they'll
+ * fail the whitelist tests and cause lots of false alarms ... fixable
+ * only by merging __exit and __init sections into __text, bloating
+ * the kernel (which is especially evil on embedded platforms).
+ */
+static inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)
+{
+	const char *name = elf->strtab + sym->st_name;
+
+	if (!name || !strlen(name))
+		return 0;
+	return !is_arm_mapping_symbol(name);
+}
+
 /*
  * Find symbols before or equal addr and after addr - in the section sec.
  * If we find two symbols with equal offset prefer one with a valid name.
@@ -714,16 +738,15 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 		symsec = secstrings + elf->sechdrs[sym->st_shndx].sh_name;
 		if (strcmp(symsec, sec) != 0)
 			continue;
+		if (!is_valid_name(elf, sym))
+			continue;
 		if (sym->st_value <= addr) {
 			if ((addr - sym->st_value) < beforediff) {
 				beforediff = addr - sym->st_value;
 				*before = sym;
 			}
 			else if ((addr - sym->st_value) == beforediff) {
-				/* equal offset, valid name? */
-				const char *name = elf->strtab + sym->st_name;
-				if (name && strlen(name))
-					*before = sym;
+				*before = sym;
 			}
 		}
 		else
@@ -733,10 +756,7 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 				*after = sym;
 			}
 			else if ((sym->st_value - addr) == afterdiff) {
-				/* equal offset, valid name? */
-				const char *name = elf->strtab + sym->st_name;
-				if (name && strlen(name))
-					*after = sym;
+				*after = sym;
 			}
 		}
 	}

commit e7b3ca08549caccf5d6e1cf066780bf4f0ae77a7
Merge: 62d0cfcb27cf cb6efb39163b
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Sat Feb 17 00:18:23 2007 -0500

    Merge branch 'parisc' from /home/kyle/repos/parisc-2.6.git
    
    Conflicts:
    
            arch/parisc/hpux/sys_hpux.c
            arch/parisc/mm/ioremap.c

commit f8657e1b55901e6c227094258d1fa3642fa242bd
Author: Vivek Goyal <vgoyal@in.ibm.com>
Date:   Tue Feb 13 13:26:22 2007 +0100

    [PATCH] i386: move startup_32() in text.head section
    
    o Entry startup_32 was in .text section but it was accessing some init
      data too and it prompts MODPOST to generate compilation warnings.
    
    WARNING: vmlinux - Section mismatch: reference to .init.data:boot_params from
    .text between '_text' (at offset 0xc0100029) and 'startup_32_smp'
    WARNING: vmlinux - Section mismatch: reference to .init.data:boot_params from
    .text between '_text' (at offset 0xc0100037) and 'startup_32_smp'
    WARNING: vmlinux - Section mismatch: reference to
    .init.data:init_pg_tables_end from .text between '_text' (at offset
    0xc0100099) and 'startup_32_smp'
    
    o Can't move startup_32 to .init.text as this entry point has to be at the
      start of bzImage. Hence moved startup_32 to a new section .text.head and
      instructed MODPOST to not to generate warnings if init data is being
      accessed from .text.head section. This code has been audited.
    
    o SMP boot up code (startup_32_smp) can go into .init.text if CPU hotplug
      is not supported. Otherwise it generates more warnings
    
    WARNING: vmlinux - Section mismatch: reference to .init.data:new_cpu_data from
    .text between 'checkCPUtype' (at offset 0xc0100126) and 'is486'
    WARNING: vmlinux - Section mismatch: reference to .init.data:new_cpu_data from
    .text between 'checkCPUtype' (at offset 0xc0100130) and 'is486'
    
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2aa47623f5f8..569e68410d7a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -641,12 +641,20 @@ static int secref_whitelist(const char *modname, const char *tosec,
 	if (f1 && f2)
 		return 1;
 
-	/* Whitelist all references from .pci_fixup section if vmlinux */
+	/* Whitelist all references from .pci_fixup section if vmlinux
+	 * Whitelist all refereces from .text.head to .init.data if vmlinux
+	 * Whitelist all refereces from .text.head to .init.text if vmlinux
+	 */
 	if (is_vmlinux(modname)) {
 		if ((strcmp(fromsec, ".pci_fixup") == 0) &&
 		    (strcmp(tosec, ".init.text") == 0))
 		return 1;
 
+		if ((strcmp(fromsec, ".text.head") == 0) &&
+			((strcmp(tosec, ".init.data") == 0) ||
+			(strcmp(tosec, ".init.text") == 0)))
+		return 1;
+
 		/* Check for pattern 3 */
 		for (s = pat3refsym; *s; s++)
 			if (strcmp(refsymname, *s) == 0)

commit 742433b00b1c53d447a10f215cf887e4cb3406b5
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Feb 5 16:34:00 2007 -0800

    [PATCH] PA-RISC: Fix bogus warnings from modpost
    
    parisc and parisc64 seem to name sections a little differently from other
    targets.  parisc64 gives spurious warnings like:
    
    WARNING: drivers/net/dummy.o - Section mismatch: reference to .init.text:dummy_setup from .data.rel.ro between '.LC1' (at offset 0x0) and '.LC6'
    
    and parisc gives spurious warnings like:
    
    WARNING: drivers/net/dummy.o - Section mismatch: reference to .init.text:dummy_setup from .rodata.cst4 between '.LC1' (at offset 0x0) and '.LC6'
    
    Given the other comments in modpost.c, it seems that the best solution is
    to move rodata down to the 'match at start of name' section and add
    .data.rel.ro to the 'match entire name' section.
    
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ac0a58222992..e26381e3fc00 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -910,7 +910,7 @@ static int init_section_ref_ok(const char *name)
 		".opd",   /* see comment [OPD] at exit_section_ref_ok() */
 		".toc1",  /* used by ppc64 */
 		".stab",
-		".rodata",
+		".data.rel.ro", /* used by parisc64 */
 		".parainstructions",
 		".text.lock",
 		"__bug_table", /* used by powerpc for BUG() */
@@ -933,6 +933,7 @@ static int init_section_ref_ok(const char *name)
 		".eh_frame",
 		".debug",
 		".parainstructions",
+		".rodata",
 		NULL
 	};
 	/* part of section name */

commit ee6a8545a4cbc620625c7956c95aac513842156b
Author: Vivek Goyal <vgoyal@in.ibm.com>
Date:   Thu Jan 11 01:52:44 2007 +0100

    [PATCH] x86-64: Modpost whitelist reference to more symbols (pattern 3)
    
    o MODPOST generates warning on i386 if kernel is compiled with
      CONFIG_RELOCATABLE=y.
    
    WARNING: vmlinux - Section mismatch: reference to .init.text:__init_begin from .text between 'free_initmem' (at offset 0xc0114fd3) and 'do_test_wp_bit'
    WARNING: vmlinux - Section mismatch: reference to .init.text:_sinittext from .text between 'core_kernel_text' (at offset 0xc012aeae) and 'kernel_text_address'
    WARNING: vmlinux - Section mismatch: reference to .init.text:_einittext from .text between 'core_kernel_text' (at offset 0xc012aeb7) and 'kernel_text_address'
    WARNING: vmlinux - Section mismatch: reference to .init.text:_sinittext from .text between 'get_symbol_pos' (at offset 0xc0135776) and 'reset_iter'
    WARNING: vmlinux - Section mismatch: reference to .init.text:_einittext from .text between 'get_symbol_pos' (at offset 0xc013577d) and 'reset_iter'
    
    o These symbols (__init_begin, _sinittext, _einittext) belong to init
      section and generally represent a section boundary. These are special
      symbols in the sense that their size is zero and no memory is allocated
      for them in init section. Their addr and value are same. So even if
      we free the init section, it is ok to reference them.
    
    o Whitelist access to such select symbols in MODPOST.
    
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 82e019bf2dc5..2aa47623f5f8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -582,9 +582,19 @@ static int strrcmp(const char *s, const char *sub)
  *   tosec   = .init.text | .exit.text | .init.data
  *   fromsec = .data
  *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one
+ *
+ * Pattern 3:
+ *   Some symbols belong to init section but still it is ok to reference
+ *   these from non-init sections as these symbols don't have any memory
+ *   allocated for them and symbol address and value are same. So even
+ *   if init section is freed, its ok to reference those symbols.
+ *   For ex. symbols marking the init section boundaries.
+ *   This pattern is identified by
+ *   refsymname = __init_begin, _sinittext, _einittext
  **/
 static int secref_whitelist(const char *modname, const char *tosec,
-			    const char *fromsec, const char *atsym)
+			    const char *fromsec, const char *atsym,
+			    const char *refsymname)
 {
 	int f1 = 1, f2 = 1;
 	const char **s;
@@ -599,6 +609,13 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		NULL
 	};
 
+	const char *pat3refsym[] = {
+		"__init_begin",
+		"_sinittext",
+		"_einittext",
+		NULL
+	};
+
 	/* Check for pattern 1 */
 	if (strcmp(tosec, ".init.data") != 0)
 		f1 = 0;
@@ -629,6 +646,11 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		if ((strcmp(fromsec, ".pci_fixup") == 0) &&
 		    (strcmp(tosec, ".init.text") == 0))
 		return 1;
+
+		/* Check for pattern 3 */
+		for (s = pat3refsym; *s; s++)
+			if (strcmp(refsymname, *s) == 0)
+				return 1;
 	}
 	return 0;
 }
@@ -738,7 +760,7 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	/* check whitelist - we may ignore it */
 	if (before &&
 	    secref_whitelist(modname, secname, fromsec,
-			     elf->strtab + before->st_name))
+			     elf->strtab + before->st_name, refsymname))
 		return;
 
 	if (before && after) {

commit 118c0ace1b61433311ae4e067fdd32841baa7f91
Author: Vivek Goyal <vgoyal@in.ibm.com>
Date:   Thu Jan 11 01:52:44 2007 +0100

    [PATCH] x86-64: modpost add more symbols to whitelist pattern2
    
    o MODPOST generates warning for i386 if compiled with CONFIG_RELOCATABLE=y
      and serial console support is enabled.
    
    o Serial console setup function, serial8250_console_setup(), is a non __init
      function and it calls functions which are of type __init().
      (uart_parse_options() and uart_set_options()). Assuming, setup will
      be called during init time, changing serial8250_console_setup() to __init.
    
    o Adding one more pattern to modpost whitelist. Console drivers might
      have *_console structures containing references to setup functions which
      can be of __init type. Don't generate warnings for those.
    
    WARNING: vmlinux - Section mismatch: reference to .init.text: from .data between 'serial8250_console' (at offset 0xc05a33d8) and 'serial8250_reg'
    
    Signed-off-by: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 15ab5d02e80a..82e019bf2dc5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -595,6 +595,7 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		"_ops",
 		"_probe",
 		"_probe_one",
+		"_console",
 		NULL
 	};
 

commit acd19499e9724615d720b29c74be6b218ce765c6
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Dec 13 00:33:57 2006 -0800

    [PATCH] Fix section mismatch in parainstructions
    
    Section .parainstructions should not warn about section mismatches.
    
    WARNING: drivers/net/hamradio/scc.o - Section mismatch: reference to .exit.text: from .parainstructions after '' (at offset 0x0)
    WARNING: drivers/net/hamradio/scc.o - Section mismatch: reference to .exit.text: from .parainstructions after '' (at offset 0x8)
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Andi Kleen <ak@suse.de>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ac0a58222992..15ab5d02e80a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -997,6 +997,7 @@ static int exit_section_ref_ok(const char *name)
 		"__bug_table", /* used by powerpc for BUG() */
 		".exitcall.exit",
 		".eh_frame",
+		".parainstructions",
 		".stab",
 		"__ex_table",
 		".fixup",

commit 139ec7c416248b9ea227d21839235344edfee1e0
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Dec 7 02:14:08 2006 +0100

    [PATCH] paravirt: Patch inline replacements for paravirt intercepts
    
    It turns out that the most called ops, by several orders of magnitude,
    are the interrupt manipulation ops.  These are obvious candidates for
    patching, so mark them up and create infrastructure for it.
    
    The method used is that the ops structure has a patch function, which
    is called for each place which needs to be patched: this returns a
    number of instructions (the rest are NOP-padded).
    
    Usually we can spare a register (%eax) for the binary patched code to
    use, but in a couple of critical places in entry.S we can't: we make
    the clobbers explicit at the call site, and manually clobber the
    allowed registers in debug mode as an extra check.
    
    And:
    
    Don't abuse CONFIG_DEBUG_KERNEL, add CONFIG_DEBUG_PARAVIRT.
    
    And:
    
    AK:  Fix warnings in x86-64 alternative.c build
    
    And:
    
    AK: Fix compilation with defconfig
    
    And:
    
    ^From: Andrew Morton <akpm@osdl.org>
    
    Some binutlises still like to emit references to __stop_parainstructions and
    __start_parainstructions.
    
    And:
    
    AK: Fix warnings about unused variables when PARAVIRT is disabled.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Zachary Amsden <zach@vmware.com>
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 2e1141623147..ac0a58222992 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -911,6 +911,7 @@ static int init_section_ref_ok(const char *name)
 		".toc1",  /* used by ppc64 */
 		".stab",
 		".rodata",
+		".parainstructions",
 		".text.lock",
 		"__bug_table", /* used by powerpc for BUG() */
 		".pci_fixup_header",
@@ -931,6 +932,7 @@ static int init_section_ref_ok(const char *name)
 		".altinstructions",
 		".eh_frame",
 		".debug",
+		".parainstructions",
 		NULL
 	};
 	/* part of section name */

commit 21c4ff80cba5e24932f3ef79c8482c0491630b2b
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Oct 20 11:47:19 2006 +1000

    [POWERPC] Support feature fixups in modules
    
    This patch adds support for feature fixups in modules. This involves
    adding support for R_PPC64_REL64 relocs to the 64 bits module loader.
    It also modifies modpost.c to ignore the powerpc fixup sections (or it
    would warn when used in .init.text).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 41277963f47a..2e1141623147 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -921,6 +921,8 @@ static int init_section_ref_ok(const char *name)
 		".fixup",
 		".smp_locks",
 		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
+		"__ftr_fixup",		/* powerpc cpu feature fixup */
+		"__fw_ftr_fixup",	/* powerpc firmware feature fixup */
 		NULL
 	};
 	/* Start of section names */

commit c53ddacdc08d41f812f1e637d214251d14c07a3d
Author: Kirill Korotaev <dev@openvz.org>
Date:   Thu Sep 7 13:08:54 2006 -0700

    kbuild: fail kernel compilation in case of unresolved module symbols
    
    At stage 2 modpost utility is used to check modules.  In case of unresolved
    symbols modpost only prints warning.
    
    IMHO it is a good idea to fail compilation process in case of unresolved
    symbols (at least in modules coming with kernel), since usually such errors
    are left unnoticed, but kernel modules are broken.
    
    - new option '-w' is added to modpost:
      if option is specified, modpost only warns about unresolved symbols
    
    - modpost is called with '-w' for external modules in Makefile.modpost
    
    Signed-off-by: Andrey Mirkin <amirkin@sw.ru>
    Signed-off-by: Kirill Korotaev <dev@openvz.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 16a19353c67f..41277963f47a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -23,6 +23,8 @@ int have_vmlinux = 0;
 static int all_versions = 0;
 /* If we are modposting external module set to 1 */
 static int external_module = 0;
+/* Only warn about unresolved symbols */
+static int warn_unresolved = 0;
 /* How a symbol is exported */
 enum export {
 	export_plain,      export_unused,     export_gpl,
@@ -1196,16 +1198,19 @@ static void add_header(struct buffer *b, struct module *mod)
 /**
  * Record CRCs for unresolved symbols
  **/
-static void add_versions(struct buffer *b, struct module *mod)
+static int add_versions(struct buffer *b, struct module *mod)
 {
 	struct symbol *s, *exp;
+	int err = 0;
 
 	for (s = mod->unres; s; s = s->next) {
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
-			if (have_vmlinux && !s->weak)
+			if (have_vmlinux && !s->weak) {
 				warn("\"%s\" [%s.ko] undefined!\n",
 				     s->name, mod->name);
+				err = warn_unresolved ? 0 : 1;
+			}
 			continue;
 		}
 		s->module = exp->module;
@@ -1214,7 +1219,7 @@ static void add_versions(struct buffer *b, struct module *mod)
 	}
 
 	if (!modversions)
-		return;
+		return err;
 
 	buf_printf(b, "\n");
 	buf_printf(b, "static const struct modversion_info ____versions[]\n");
@@ -1234,6 +1239,8 @@ static void add_versions(struct buffer *b, struct module *mod)
 	}
 
 	buf_printf(b, "};\n");
+
+	return err;
 }
 
 static void add_depends(struct buffer *b, struct module *mod,
@@ -1411,8 +1418,9 @@ int main(int argc, char **argv)
 	char *kernel_read = NULL, *module_read = NULL;
 	char *dump_write = NULL;
 	int opt;
+	int err;
 
-	while ((opt = getopt(argc, argv, "i:I:mo:a")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:mo:aw")) != -1) {
 		switch(opt) {
 			case 'i':
 				kernel_read = optarg;
@@ -1430,6 +1438,9 @@ int main(int argc, char **argv)
 			case 'a':
 				all_versions = 1;
 				break;
+			case 'w':
+				warn_unresolved = 1;
+				break;
 			default:
 				exit(1);
 		}
@@ -1450,6 +1461,8 @@ int main(int argc, char **argv)
 		check_exports(mod);
 	}
 
+	err = 0;
+
 	for (mod = modules; mod; mod = mod->next) {
 		if (mod->skip)
 			continue;
@@ -1457,7 +1470,7 @@ int main(int argc, char **argv)
 		buf.pos = 0;
 
 		add_header(&buf, mod);
-		add_versions(&buf, mod);
+		err |= add_versions(&buf, mod);
 		add_depends(&buf, mod, modules);
 		add_moddevtable(&buf, mod);
 		add_srcversion(&buf, mod);
@@ -1469,5 +1482,5 @@ int main(int argc, char **argv)
 	if (dump_write)
 		write_dump(dump_write);
 
-	return 0;
+	return err;
 }

commit 93659af1ce4974b1882668fee06458c0ac9315fd
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Wed Aug 9 08:23:55 2006 +0200

    kbuild: add missing return statement in modpost.c:secref_whitelist()
    
    Noticed by: Magnus Damm <magnus@valinux.co.jp>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5028d46a8f35..16a19353c67f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -627,6 +627,7 @@ static int secref_whitelist(const char *modname, const char *tosec,
 		    (strcmp(tosec, ".init.text") == 0))
 		return 1;
 	}
+	return 0;
 }
 
 /**

commit 9e157a5aa899f1ef73780e4755b57ddeb9225079
Author: Magnus Damm <magnus@valinux.co.jp>
Date:   Tue Aug 8 17:32:11 2006 +0900

    kbuild: ignore references from ".pci_fixup" to ".init.text"
    
    The modpost code is extended to ignore references
    from ".pci_fixup" to ".init.text".
    
    Signed-off-by: Magnus Damm <magnus@valinux.co.jp>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index dfde0e87a765..5028d46a8f35 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -581,8 +581,8 @@ static int strrcmp(const char *s, const char *sub)
  *   fromsec = .data
  *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one
  **/
-static int secref_whitelist(const char *tosec, const char *fromsec,
-			    const char *atsym)
+static int secref_whitelist(const char *modname, const char *tosec,
+			    const char *fromsec, const char *atsym)
 {
 	int f1 = 1, f2 = 1;
 	const char **s;
@@ -618,8 +618,15 @@ static int secref_whitelist(const char *tosec, const char *fromsec,
 	for (s = pat2sym; *s; s++)
 		if (strrcmp(atsym, *s) == 0)
 			f1 = 1;
+	if (f1 && f2)
+		return 1;
 
-	return f1 && f2;
+	/* Whitelist all references from .pci_fixup section if vmlinux */
+	if (is_vmlinux(modname)) {
+		if ((strcmp(fromsec, ".pci_fixup") == 0) &&
+		    (strcmp(tosec, ".init.text") == 0))
+		return 1;
+	}
 }
 
 /**
@@ -726,7 +733,8 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 
 	/* check whitelist - we may ignore it */
 	if (before &&
-	    secref_whitelist(secname, fromsec, elf->strtab + before->st_name))
+	    secref_whitelist(modname, secname, fromsec,
+			     elf->strtab + before->st_name))
 		return;
 
 	if (before && after) {

commit c96fca213737a5b4bc569e1d9a0ef6adeff661e9
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jul 1 11:44:23 2006 +0200

    kbuild: warn when a moduled uses a symbol marked UNUSED
    
    We now have infrastructure in place to mark an EXPORTed symbol
    as unused. So the natural next step is to warn during buildtime when
    a module uses a symbol marked UNUSED.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 65411665e13c..dfde0e87a765 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -24,7 +24,10 @@ static int all_versions = 0;
 /* If we are modposting external module set to 1 */
 static int external_module = 0;
 /* How a symbol is exported */
-enum export {export_plain, export_gpl, export_gpl_future, export_unknown};
+enum export {
+	export_plain,      export_unused,     export_gpl,
+	export_unused_gpl, export_gpl_future, export_unknown
+};
 
 void fatal(const char *fmt, ...)
 {
@@ -191,7 +194,9 @@ static struct {
 	enum export export;
 } export_list[] = {
 	{ .str = "EXPORT_SYMBOL",            .export = export_plain },
+	{ .str = "EXPORT_UNUSED_SYMBOL",     .export = export_unused },
 	{ .str = "EXPORT_SYMBOL_GPL",        .export = export_gpl },
+	{ .str = "EXPORT_UNUSED_SYMBOL_GPL", .export = export_unused_gpl },
 	{ .str = "EXPORT_SYMBOL_GPL_FUTURE", .export = export_gpl_future },
 	{ .str = "(unknown)",                .export = export_unknown },
 };
@@ -218,8 +223,12 @@ static enum export export_from_sec(struct elf_info *elf, Elf_Section sec)
 {
 	if (sec == elf->export_sec)
 		return export_plain;
+	else if (sec == elf->export_unused_sec)
+		return export_unused;
 	else if (sec == elf->export_gpl_sec)
 		return export_gpl;
+	else if (sec == elf->export_unused_gpl_sec)
+		return export_unused_gpl;
 	else if (sec == elf->export_gpl_future_sec)
 		return export_gpl_future;
 	else
@@ -368,8 +377,12 @@ static void parse_elf(struct elf_info *info, const char *filename)
 			info->modinfo_len = sechdrs[i].sh_size;
 		} else if (strcmp(secname, "__ksymtab") == 0)
 			info->export_sec = i;
+		else if (strcmp(secname, "__ksymtab_unused") == 0)
+			info->export_unused_sec = i;
 		else if (strcmp(secname, "__ksymtab_gpl") == 0)
 			info->export_gpl_sec = i;
+		else if (strcmp(secname, "__ksymtab_unused_gpl") == 0)
+			info->export_unused_gpl_sec = i;
 		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
 			info->export_gpl_future_sec = i;
 
@@ -1087,38 +1100,64 @@ void buf_write(struct buffer *buf, const char *s, int len)
 	buf->pos += len;
 }
 
-void check_license(struct module *mod)
+static void check_for_gpl_usage(enum export exp, const char *m, const char *s)
+{
+	const char *e = is_vmlinux(m) ?"":".ko";
+
+	switch (exp) {
+	case export_gpl:
+		fatal("modpost: GPL-incompatible module %s%s "
+		      "uses GPL-only symbol '%s'\n", m, e, s);
+		break;
+	case export_unused_gpl:
+		fatal("modpost: GPL-incompatible module %s%s "
+		      "uses GPL-only symbol marked UNUSED '%s'\n", m, e, s);
+		break;
+	case export_gpl_future:
+		warn("modpost: GPL-incompatible module %s%s "
+		      "uses future GPL-only symbol '%s'\n", m, e, s);
+		break;
+	case export_plain:
+	case export_unused:
+	case export_unknown:
+		/* ignore */
+		break;
+	}
+}
+
+static void check_for_unused(enum export exp, const char* m, const char* s)
+{
+	const char *e = is_vmlinux(m) ?"":".ko";
+
+	switch (exp) {
+	case export_unused:
+	case export_unused_gpl:
+		warn("modpost: module %s%s "
+		      "uses symbol '%s' marked UNUSED\n", m, e, s);
+		break;
+	default:
+		/* ignore */
+		break;
+	}
+}
+
+static void check_exports(struct module *mod)
 {
 	struct symbol *s, *exp;
 
 	for (s = mod->unres; s; s = s->next) {
 		const char *basename;
-		if (mod->gpl_compatible == 1) {
-			/* GPL-compatible modules may use all symbols */
-			continue;
-		}
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod)
 			continue;
 		basename = strrchr(mod->name, '/');
 		if (basename)
 			basename++;
-		switch (exp->export) {
-			case export_gpl:
-				fatal("modpost: GPL-incompatible module %s "
-				      "uses GPL-only symbol '%s'\n",
-				 basename ? basename : mod->name,
-				exp->name);
-				break;
-			case export_gpl_future:
-				warn("modpost: GPL-incompatible module %s "
-				      "uses future GPL-only symbol '%s'\n",
-				      basename ? basename : mod->name,
-				      exp->name);
-				break;
-			case export_plain: /* ignore */ break;
-			case export_unknown: /* ignore */ break;
-		}
+		else
+			basename = mod->name;
+		if (!mod->gpl_compatible)
+			check_for_gpl_usage(exp->export, basename, exp->name);
+		check_for_unused(exp->export, basename, exp->name);
         }
 }
 
@@ -1399,7 +1438,7 @@ int main(int argc, char **argv)
 	for (mod = modules; mod; mod = mod->next) {
 		if (mod->skip)
 			continue;
-		check_license(mod);
+		check_exports(mod);
 	}
 
 	for (mod = modules; mod; mod = mod->next) {

commit 534b89a9f6a86a28300cd71619112c4bbca7c0ae
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jul 1 10:10:19 2006 +0200

    kbuild: fix segv in modpost
    
    Parsing an old Modules.symvers file casued modpost to SEGV.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0dd16177642d..65411665e13c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -205,6 +205,8 @@ static const char *export_str(enum export ex)
 static enum export export_no(const char * s)
 {
 	int i;
+	if (!s)
+		return export_unknown;
 	for (i = 0; export_list[i].export != export_unknown; i++) {
 		if (strcmp(export_list[i].str, s) == 0)
 			return export_list[i].export;
@@ -1271,7 +1273,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
 }
 
 /* parse Module.symvers file. line format:
- * 0x12345678<tab>symbol<tab>module[<tab>export]
+ * 0x12345678<tab>symbol<tab>module[[<tab>export]<tab>something]
  **/
 static void read_dump(const char *fname, unsigned int kernel)
 {
@@ -1284,7 +1286,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		return;
 
 	while ((line = get_next_line(&pos, file, size))) {
-		char *symname, *modname, *d, *export;
+		char *symname, *modname, *d, *export, *end;
 		unsigned int crc;
 		struct module *mod;
 		struct symbol *s;
@@ -1297,7 +1299,8 @@ static void read_dump(const char *fname, unsigned int kernel)
 		*modname++ = '\0';
 		if ((export = strchr(modname, '\t')) != NULL)
 			*export++ = '\0';
-
+		if (export && ((end = strchr(export, '\t')) != NULL))
+			*end = '\0';
 		crc = strtoul(line, &d, 16);
 		if (*symname == '\0' || *modname == '\0' || *d != '\0')
 			goto fail;

commit 6803dc0ea85ad21b2cb3ec88decff5e27d7a390b
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jun 24 23:46:54 2006 +0200

    kbuild: replace abort() with exit(1)
    
    We have had no use of the coredump file for a long time.
    So just exit(1) and avoid coredumping.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7e226896579c..0dd16177642d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -330,7 +330,7 @@ static void parse_elf(struct elf_info *info, const char *filename)
 	hdr = grab_file(filename, &info->size);
 	if (!hdr) {
 		perror(filename);
-		abort();
+		exit(1);
 	}
 	info->hdr = hdr;
 	if (info->size < sizeof(*hdr))

commit 468d949401d729b28eed6ea5be25695c5731d3f1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 23 23:22:43 2006 +0100

    kbuild: kill some false positives from modpost
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d03c9fff5b2a..7e226896579c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -891,6 +891,8 @@ static int init_section_ref_ok(const char *name)
 		".pci_fixup_final",
 		".pdr",
 		"__param",
+		"__ex_table",
+		".fixup",
 		".smp_locks",
 		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
 		NULL
@@ -918,6 +920,8 @@ static int init_section_ref_ok(const char *name)
 	for (s = namelist3; *s; s++)
 		if (strstr(name, *s) != NULL)
 			return 1;
+	if (strrcmp(name, ".init") == 0)
+		return 1;
 	return 0;
 }
 
@@ -964,6 +968,8 @@ static int exit_section_ref_ok(const char *name)
 		".exitcall.exit",
 		".eh_frame",
 		".stab",
+		"__ex_table",
+		".fixup",
 		".smp_locks",
 		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
 		NULL

commit 9ac545b0f7161eaf2e180acc406c1dd6fdd77686
Author: Laurent Riffard <laurent.riffard@free.fr>
Date:   Sun Jun 11 08:02:06 2006 +0200

    kbuild: fix module.symvers parsing in modpost
    
    read_dump didn't split lines between module name and export type.
    
    Signed-off-by: Laurent Riffard <laurent.riffard@free.fr>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f27ddb841df8..d03c9fff5b2a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1289,7 +1289,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		if (!(modname = strchr(symname, '\t')))
 			goto fail;
 		*modname++ = '\0';
-		if (!(export = strchr(modname, '\t')))
+		if ((export = strchr(modname, '\t')) != NULL)
 			*export++ = '\0';
 
 		crc = strtoul(line, &d, 16);

commit 6449bd621ba51ef652ac5bda632eeabbc18dd296
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Jun 9 20:45:06 2006 -0700

    kbuild: modpost build fix
    
    scripts/mod/modpost.c: In function `check_license':
    scripts/mod/modpost.c:1094: parse error before `const'
    scripts/mod/modpost.c:1095: `basename' undeclared (first use in this function)
    scripts/mod/modpost.c:1095: (Each undeclared identifier is reported only once
    scripts/mod/modpost.c:1095: for each function it appears in.)
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index baa4d83d29a8..f27ddb841df8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1084,6 +1084,7 @@ void check_license(struct module *mod)
 	struct symbol *s, *exp;
 
 	for (s = mod->unres; s; s = s->next) {
+		const char *basename;
 		if (mod->gpl_compatible == 1) {
 			/* GPL-compatible modules may use all symbols */
 			continue;
@@ -1091,7 +1092,7 @@ void check_license(struct module *mod)
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod)
 			continue;
-		const char *basename = strrchr(mod->name, '/');
+		basename = strrchr(mod->name, '/');
 		if (basename)
 			basename++;
 		switch (exp->export) {

commit b817f6feff4a565b08f0e699a5790b4008b8f494
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Jun 9 21:53:55 2006 +0200

    kbuild: check license compatibility when building modules
    
    Modules that uses GPL symbols can no longer be build with kbuild,
    the build will fail during the modpost step.
    When a GPL-incompatible module uses a EXPORT_SYMBOL_GPL_FUTURE symbol
    then warn during modpost so author are actually notified.
    
    The actual license compatibility check is shared with the kernel
    to make sure it is in sync.
    
    Patch originally from: Andreas Gruenbacher <agruen@suse.de> and
    Ram Pai <linuxram@us.ibm.com>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index ba2e4fc2af20..baa4d83d29a8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -13,6 +13,7 @@
 
 #include <ctype.h>
 #include "modpost.h"
+#include "../../include/linux/license.h"
 
 /* Are we using CONFIG_MODVERSIONS? */
 int modversions = 0;
@@ -99,6 +100,7 @@ static struct module *new_module(char *modname)
 
 	/* add to list */
 	mod->name = p;
+	mod->gpl_compatible = -1;
 	mod->next = modules;
 	modules = mod;
 
@@ -493,13 +495,18 @@ static char *next_string(char *string, unsigned long *secsize)
 	return string;
 }
 
-static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
-			 const char *tag)
+static char *get_next_modinfo(void *modinfo, unsigned long modinfo_len,
+			      const char *tag, char *info)
 {
 	char *p;
 	unsigned int taglen = strlen(tag);
 	unsigned long size = modinfo_len;
 
+	if (info) {
+		size -= info - (char *)modinfo;
+		modinfo = next_string(info, &size);
+	}
+
 	for (p = modinfo; p; p = next_string(p, &size)) {
 		if (strncmp(p, tag, taglen) == 0 && p[taglen] == '=')
 			return p + taglen + 1;
@@ -507,6 +514,13 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
 	return NULL;
 }
 
+static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
+			 const char *tag)
+
+{
+	return get_next_modinfo(modinfo, modinfo_len, tag, NULL);
+}
+
 /**
  * Test if string s ends in string sub
  * return 0 if match
@@ -981,6 +995,7 @@ static void read_symbols(char *modname)
 {
 	const char *symname;
 	char *version;
+	char *license;
 	struct module *mod;
 	struct elf_info info = { };
 	Elf_Sym *sym;
@@ -996,6 +1011,18 @@ static void read_symbols(char *modname)
 		mod->skip = 1;
 	}
 
+	license = get_modinfo(info.modinfo, info.modinfo_len, "license");
+	while (license) {
+		if (license_is_gpl_compatible(license))
+			mod->gpl_compatible = 1;
+		else {
+			mod->gpl_compatible = 0;
+			break;
+		}
+		license = get_next_modinfo(info.modinfo, info.modinfo_len,
+					   "license", license);
+	}
+
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
 		symname = info.strtab + sym->st_name;
 
@@ -1052,6 +1079,40 @@ void buf_write(struct buffer *buf, const char *s, int len)
 	buf->pos += len;
 }
 
+void check_license(struct module *mod)
+{
+	struct symbol *s, *exp;
+
+	for (s = mod->unres; s; s = s->next) {
+		if (mod->gpl_compatible == 1) {
+			/* GPL-compatible modules may use all symbols */
+			continue;
+		}
+		exp = find_symbol(s->name);
+		if (!exp || exp->module == mod)
+			continue;
+		const char *basename = strrchr(mod->name, '/');
+		if (basename)
+			basename++;
+		switch (exp->export) {
+			case export_gpl:
+				fatal("modpost: GPL-incompatible module %s "
+				      "uses GPL-only symbol '%s'\n",
+				 basename ? basename : mod->name,
+				exp->name);
+				break;
+			case export_gpl_future:
+				warn("modpost: GPL-incompatible module %s "
+				      "uses future GPL-only symbol '%s'\n",
+				      basename ? basename : mod->name,
+				      exp->name);
+				break;
+			case export_plain: /* ignore */ break;
+			case export_unknown: /* ignore */ break;
+		}
+        }
+}
+
 /**
  * Header for the generated file
  **/
@@ -1325,6 +1386,12 @@ int main(int argc, char **argv)
 		read_symbols(argv[optind++]);
 	}
 
+	for (mod = modules; mod; mod = mod->next) {
+		if (mod->skip)
+			continue;
+		check_license(mod);
+	}
+
 	for (mod = modules; mod; mod = mod->next) {
 		if (mod->skip)
 			continue;

commit bd5cbcedf446e2f37cf2a37f533a7e1d7dff9312
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Thu Jun 8 22:12:53 2006 -0700

    kbuild: export-type enhancement to modpost.c
    
    This patch provides the ability to identify the export-type of each
    exported symbols in Module.symvers.
    
    NOTE: It updates the Module.symvers file with the additional
    information as shown below.
    
    0x0f8b92af      platform_device_add_resources   vmlinux EXPORT_SYMBOL_GPL
    0xcf7efb2a      ethtool_op_set_tx_csum          vmlinux EXPORT_SYMBOL
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Avantika Mathur <mathur@us.ibm.com>
    Signed-off-by: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a70f5ddb705c..ba2e4fc2af20 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -22,6 +22,8 @@ int have_vmlinux = 0;
 static int all_versions = 0;
 /* If we are modposting external module set to 1 */
 static int external_module = 0;
+/* How a symbol is exported */
+enum export {export_plain, export_gpl, export_gpl_future, export_unknown};
 
 void fatal(const char *fmt, ...)
 {
@@ -118,6 +120,7 @@ struct symbol {
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
 				    *  (only for external modules) **/
 	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers */
+	enum export  export;       /* Type of export */
 	char name[0];
 };
 
@@ -153,7 +156,8 @@ static struct symbol *alloc_symbol(const char *name, unsigned int weak,
 }
 
 /* For the hash of exported symbols */
-static struct symbol *new_symbol(const char *name, struct module *module)
+static struct symbol *new_symbol(const char *name, struct module *module,
+				 enum export export)
 {
 	unsigned int hash;
 	struct symbol *new;
@@ -161,6 +165,7 @@ static struct symbol *new_symbol(const char *name, struct module *module)
 	hash = tdb_hash(name) % SYMBOL_HASH_SIZE;
 	new = symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);
 	new->module = module;
+	new->export = export;
 	return new;
 }
 
@@ -179,16 +184,55 @@ static struct symbol *find_symbol(const char *name)
 	return NULL;
 }
 
+static struct {
+	const char *str;
+	enum export export;
+} export_list[] = {
+	{ .str = "EXPORT_SYMBOL",            .export = export_plain },
+	{ .str = "EXPORT_SYMBOL_GPL",        .export = export_gpl },
+	{ .str = "EXPORT_SYMBOL_GPL_FUTURE", .export = export_gpl_future },
+	{ .str = "(unknown)",                .export = export_unknown },
+};
+
+
+static const char *export_str(enum export ex)
+{
+	return export_list[ex].str;
+}
+
+static enum export export_no(const char * s)
+{
+	int i;
+	for (i = 0; export_list[i].export != export_unknown; i++) {
+		if (strcmp(export_list[i].str, s) == 0)
+			return export_list[i].export;
+	}
+	return export_unknown;
+}
+
+static enum export export_from_sec(struct elf_info *elf, Elf_Section sec)
+{
+	if (sec == elf->export_sec)
+		return export_plain;
+	else if (sec == elf->export_gpl_sec)
+		return export_gpl;
+	else if (sec == elf->export_gpl_future_sec)
+		return export_gpl_future;
+	else
+		return export_unknown;
+}
+
 /**
  * Add an exported symbol - it may have already been added without a
  * CRC, in this case just update the CRC
  **/
-static struct symbol *sym_add_exported(const char *name, struct module *mod)
+static struct symbol *sym_add_exported(const char *name, struct module *mod,
+				       enum export export)
 {
 	struct symbol *s = find_symbol(name);
 
 	if (!s) {
-		s = new_symbol(name, mod);
+		s = new_symbol(name, mod, export);
 	} else {
 		if (!s->preloaded) {
 			warn("%s: '%s' exported twice. Previous export "
@@ -200,16 +244,17 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod)
 	s->preloaded = 0;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
+	s->export    = export;
 	return s;
 }
 
 static void sym_update_crc(const char *name, struct module *mod,
-			   unsigned int crc)
+			   unsigned int crc, enum export export)
 {
 	struct symbol *s = find_symbol(name);
 
 	if (!s)
-		s = new_symbol(name, mod);
+		s = new_symbol(name, mod, export);
 	s->crc = crc;
 	s->crc_valid = 1;
 }
@@ -309,13 +354,21 @@ static void parse_elf(struct elf_info *info, const char *filename)
 	for (i = 1; i < hdr->e_shnum; i++) {
 		const char *secstrings
 			= (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
+		const char *secname;
 
 		if (sechdrs[i].sh_offset > info->size)
 			goto truncated;
-		if (strcmp(secstrings+sechdrs[i].sh_name, ".modinfo") == 0) {
+		secname = secstrings + sechdrs[i].sh_name;
+		if (strcmp(secname, ".modinfo") == 0) {
 			info->modinfo = (void *)hdr + sechdrs[i].sh_offset;
 			info->modinfo_len = sechdrs[i].sh_size;
-		}
+		} else if (strcmp(secname, "__ksymtab") == 0)
+			info->export_sec = i;
+		else if (strcmp(secname, "__ksymtab_gpl") == 0)
+			info->export_gpl_sec = i;
+		else if (strcmp(secname, "__ksymtab_gpl_future") == 0)
+			info->export_gpl_future_sec = i;
+
 		if (sechdrs[i].sh_type != SHT_SYMTAB)
 			continue;
 
@@ -353,6 +406,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			       Elf_Sym *sym, const char *symname)
 {
 	unsigned int crc;
+	enum export export = export_from_sec(info, sym->st_shndx);
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
@@ -362,7 +416,8 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		/* CRC'd symbol */
 		if (memcmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
 			crc = (unsigned int) sym->st_value;
-			sym_update_crc(symname + strlen(CRC_PFX), mod, crc);
+			sym_update_crc(symname + strlen(CRC_PFX), mod, crc,
+					export);
 		}
 		break;
 	case SHN_UNDEF:
@@ -406,7 +461,8 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	default:
 		/* All exported symbols */
 		if (memcmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
-			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod);
+			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod,
+					export);
 		}
 		if (strcmp(symname, MODULE_SYMBOL_PREFIX "init_module") == 0)
 			mod->has_init = 1;
@@ -1146,6 +1202,9 @@ static void write_if_changed(struct buffer *b, const char *fname)
 	fclose(file);
 }
 
+/* parse Module.symvers file. line format:
+ * 0x12345678<tab>symbol<tab>module[<tab>export]
+ **/
 static void read_dump(const char *fname, unsigned int kernel)
 {
 	unsigned long size, pos = 0;
@@ -1157,7 +1216,7 @@ static void read_dump(const char *fname, unsigned int kernel)
 		return;
 
 	while ((line = get_next_line(&pos, file, size))) {
-		char *symname, *modname, *d;
+		char *symname, *modname, *d, *export;
 		unsigned int crc;
 		struct module *mod;
 		struct symbol *s;
@@ -1168,8 +1227,9 @@ static void read_dump(const char *fname, unsigned int kernel)
 		if (!(modname = strchr(symname, '\t')))
 			goto fail;
 		*modname++ = '\0';
-		if (strchr(modname, '\t'))
-			goto fail;
+		if (!(export = strchr(modname, '\t')))
+			*export++ = '\0';
+
 		crc = strtoul(line, &d, 16);
 		if (*symname == '\0' || *modname == '\0' || *d != '\0')
 			goto fail;
@@ -1181,10 +1241,10 @@ static void read_dump(const char *fname, unsigned int kernel)
 			mod = new_module(NOFAIL(strdup(modname)));
 			mod->skip = 1;
 		}
-		s = sym_add_exported(symname, mod);
+		s = sym_add_exported(symname, mod, export_no(export));
 		s->kernel    = kernel;
 		s->preloaded = 1;
-		sym_update_crc(symname, mod, crc);
+		sym_update_crc(symname, mod, crc, export_no(export));
 	}
 	return;
 fail:
@@ -1214,9 +1274,10 @@ static void write_dump(const char *fname)
 		symbol = symbolhash[n];
 		while (symbol) {
 			if (dump_sym(symbol))
-				buf_printf(&buf, "0x%08x\t%s\t%s\n",
+				buf_printf(&buf, "0x%08x\t%s\t%s\t%s\n",
 					symbol->crc, symbol->name,
-					symbol->module->name);
+					symbol->module->name,
+					export_str(symbol->export));
 			symbol = symbol->next;
 		}
 	}

commit 909252d279dd5d47e44c125558e87bb44097289f
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Thu Jun 8 20:37:30 2006 +0200

    kbuild: fix false section mismatch with ARCH=um build
    
    Ignoring references to .init.text, .exit.text from the .plt section brought
    the false positives down to two warnings for a defconfig build of ARCH=um
    on x86_64.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 94047bc99961..a70f5ddb705c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -822,6 +822,7 @@ static int init_section_ref_ok(const char *name)
 		".pdr",
 		"__param",
 		".smp_locks",
+		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
 		NULL
 	};
 	/* Start of section names */
@@ -894,6 +895,7 @@ static int exit_section_ref_ok(const char *name)
 		".eh_frame",
 		".stab",
 		".smp_locks",
+		".plt",  /* seen on ARCH=um build on x86_64. Harmless */
 		NULL
 	};
 	/* Start of section names */

commit 35899c57516be6eaa42cc27151767c52d75b2979
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Jun 7 16:23:26 2006 -0700

    kbuild: ignore smp_locks section warnings from init/exit code
    
    Add ".smp_locks" section to whitelist as being safe from
    init and exit sections.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d0f86ed43f7a..94047bc99961 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -821,6 +821,7 @@ static int init_section_ref_ok(const char *name)
 		".pci_fixup_final",
 		".pdr",
 		"__param",
+		".smp_locks",
 		NULL
 	};
 	/* Start of section names */
@@ -892,6 +893,7 @@ static int exit_section_ref_ok(const char *name)
 		".exitcall.exit",
 		".eh_frame",
 		".stab",
+		".smp_locks",
 		NULL
 	};
 	/* Start of section names */

commit eae07ac607f317ee6781983d3f9d8f77ef144b45
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat May 20 15:00:28 2006 -0700

    [PATCH] kbuild: fix modpost segfault for 64bit mipsel kernel
    
    Here is an updated r_info layout fix.  Please apply "check SHT_REL
    sections" patch before this.
    
    64bit mips has different r_info layout.  This patch fixes modpost
    segfault for 64bit little endian mips kernel.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 1aa52a86c2cf..d0f86ed43f7a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -700,6 +700,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 		const char *name = secstrings + sechdrs[i].sh_name;
 		const char *secname;
 		Elf_Rela r;
+		unsigned int r_sym;
 		/* We want to process only relocation sections and not .init */
 		if (sechdrs[i].sh_type == SHT_RELA) {
 			Elf_Rela *rela;
@@ -711,9 +712,20 @@ static void check_sec_ref(struct module *mod, const char *modname,
 
 			for (rela = start; rela < stop; rela++) {
 				r.r_offset = TO_NATIVE(rela->r_offset);
-				r.r_info   = TO_NATIVE(rela->r_info);
+#if KERNEL_ELFCLASS == ELFCLASS64
+				if (hdr->e_machine == EM_MIPS) {
+					r_sym = ELF64_MIPS_R_SYM(rela->r_info);
+					r_sym = TO_NATIVE(r_sym);
+				} else {
+					r.r_info = TO_NATIVE(rela->r_info);
+					r_sym = ELF_R_SYM(r.r_info);
+				}
+#else
+				r.r_info = TO_NATIVE(rela->r_info);
+				r_sym = ELF_R_SYM(r.r_info);
+#endif
 				r.r_addend = TO_NATIVE(rela->r_addend);
-				sym = elf->symtab_start + ELF_R_SYM(r.r_info);
+				sym = elf->symtab_start + r_sym;
 				/* Skip special sections */
 				if (sym->st_shndx >= SHN_LORESERVE)
 					continue;
@@ -734,9 +746,20 @@ static void check_sec_ref(struct module *mod, const char *modname,
 
 			for (rel = start; rel < stop; rel++) {
 				r.r_offset = TO_NATIVE(rel->r_offset);
-				r.r_info   = TO_NATIVE(rel->r_info);
+#if KERNEL_ELFCLASS == ELFCLASS64
+				if (hdr->e_machine == EM_MIPS) {
+					r_sym = ELF64_MIPS_R_SYM(rel->r_info);
+					r_sym = TO_NATIVE(r_sym);
+				} else {
+					r.r_info = TO_NATIVE(rel->r_info);
+					r_sym = ELF_R_SYM(r.r_info);
+				}
+#else
+				r.r_info = TO_NATIVE(rel->r_info);
+				r_sym = ELF_R_SYM(r.r_info);
+#endif
 				r.r_addend = 0;
-				sym = elf->symtab_start + ELF_R_SYM(r.r_info);
+				sym = elf->symtab_start + r_sym;
 				/* Skip special sections */
 				if (sym->st_shndx >= SHN_LORESERVE)
 					continue;

commit 2c1a51f39d9551a514d7a089d01c23c0c3a54ab8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat May 20 15:00:26 2006 -0700

    [PATCH] kbuild: check SHT_REL sections
    
    I found that modpost can not detect section mismatch on mips and i386.  On
    mips64, the modpost (with r_info layout fix) can detect it.  The current
    modpst only checks SHT_RELA section but I suppose SHT_REL section should be
    checked also.  This patch does not contain r_info layout fix.  I'll post an
    updated r_info layout fix on next mail.
    
    Check SHT_REL sections as like as SHT_RELA sections to detect section
    mismatch.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 6d04504b2fc1..1aa52a86c2cf 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -697,29 +697,56 @@ static void check_sec_ref(struct module *mod, const char *modname,
 
 	/* Walk through all sections */
 	for (i = 0; i < hdr->e_shnum; i++) {
-		Elf_Rela *rela;
-		Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
-		Elf_Rela *stop  = (void*)start + sechdrs[i].sh_size;
-		const char *name = secstrings + sechdrs[i].sh_name +
-						strlen(".rela");
+		const char *name = secstrings + sechdrs[i].sh_name;
+		const char *secname;
+		Elf_Rela r;
 		/* We want to process only relocation sections and not .init */
-		if (section_ref_ok(name) || (sechdrs[i].sh_type != SHT_RELA))
-			continue;
+		if (sechdrs[i].sh_type == SHT_RELA) {
+			Elf_Rela *rela;
+			Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
+			Elf_Rela *stop  = (void*)start + sechdrs[i].sh_size;
+			name += strlen(".rela");
+			if (section_ref_ok(name))
+				continue;
 
-		for (rela = start; rela < stop; rela++) {
-			Elf_Rela r;
-			const char *secname;
-			r.r_offset = TO_NATIVE(rela->r_offset);
-			r.r_info   = TO_NATIVE(rela->r_info);
-			r.r_addend = TO_NATIVE(rela->r_addend);
-			sym = elf->symtab_start + ELF_R_SYM(r.r_info);
-			/* Skip special sections */
-			if (sym->st_shndx >= SHN_LORESERVE)
+			for (rela = start; rela < stop; rela++) {
+				r.r_offset = TO_NATIVE(rela->r_offset);
+				r.r_info   = TO_NATIVE(rela->r_info);
+				r.r_addend = TO_NATIVE(rela->r_addend);
+				sym = elf->symtab_start + ELF_R_SYM(r.r_info);
+				/* Skip special sections */
+				if (sym->st_shndx >= SHN_LORESERVE)
+					continue;
+
+				secname = secstrings +
+					sechdrs[sym->st_shndx].sh_name;
+				if (section(secname))
+					warn_sec_mismatch(modname, name,
+							  elf, sym, r);
+			}
+		} else if (sechdrs[i].sh_type == SHT_REL) {
+			Elf_Rel *rel;
+			Elf_Rel *start = (void *)hdr + sechdrs[i].sh_offset;
+			Elf_Rel *stop  = (void*)start + sechdrs[i].sh_size;
+			name += strlen(".rel");
+			if (section_ref_ok(name))
 				continue;
 
-			secname = secstrings + sechdrs[sym->st_shndx].sh_name;
-			if (section(secname))
-				warn_sec_mismatch(modname, name, elf, sym, r);
+			for (rel = start; rel < stop; rel++) {
+				r.r_offset = TO_NATIVE(rel->r_offset);
+				r.r_info   = TO_NATIVE(rel->r_info);
+				r.r_addend = 0;
+				sym = elf->symtab_start + ELF_R_SYM(r.r_info);
+				/* Skip special sections */
+				if (sym->st_shndx >= SHN_LORESERVE)
+					continue;
+
+				secname = secstrings +
+					sechdrs[sym->st_shndx].sh_name;
+				if (section(secname))
+					warn_sec_mismatch(modname, name,
+							  elf, sym, r);
+			}
 		}
 	}
 }

commit 601e7f024edbea8018de34c83a7398623214e636
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon May 8 13:38:42 2006 -0700

    Revert "kbuild: fix modpost segfault for 64bit mipsel kernel"
    
    This reverts commit c8d8b837ebe4b4f11e1b0c4a2bdc358c697692ed, which
    caused problems for the x86 build. Quoth Sam:
    
      "It was discussed on mips list but apparently the fix was bogus.  I
       will not have time to look into it so mips can carry this local fix
       until we get a proper fix in mainline."
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b36e884f5f96..6d04504b2fc1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -709,17 +709,10 @@ static void check_sec_ref(struct module *mod, const char *modname,
 		for (rela = start; rela < stop; rela++) {
 			Elf_Rela r;
 			const char *secname;
-			unsigned int r_sym;
 			r.r_offset = TO_NATIVE(rela->r_offset);
-			if (hdr->e_ident[EI_CLASS] == ELFCLASS64 &&
-			    hdr->e_machine == EM_MIPS) {
-				r_sym = ELF64_MIPS_R_SYM(rela->r_info);
-				r_sym = TO_NATIVE(r_sym);
-			} else {
-				r_sym = ELF_R_SYM(TO_NATIVE(rela->r_info));
-			}
+			r.r_info   = TO_NATIVE(rela->r_info);
 			r.r_addend = TO_NATIVE(rela->r_addend);
-			sym = elf->symtab_start + r_sym;
+			sym = elf->symtab_start + ELF_R_SYM(r.r_info);
 			/* Skip special sections */
 			if (sym->st_shndx >= SHN_LORESERVE)
 				continue;

commit 72ee59b5797e5d6fe32b5cf3473660a50a02db40
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Apr 15 11:17:12 2006 -0700

    kbuild modpost - relax driver data name
    
    Relax driver data name from *_driver to *driver.
    This fixes the 26 section mismatch warnings in drivers/ide/pci.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index fcd4306fa002..b36e884f5f96 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -487,14 +487,14 @@ static int strrcmp(const char *s, const char *sub)
  *   atsym   =__param*
  *
  * Pattern 2:
- *   Many drivers utilise a *_driver container with references to
+ *   Many drivers utilise a *driver container with references to
  *   add, remove, probe functions etc.
  *   These functions may often be marked __init and we do not want to
  *   warn here.
  *   the pattern is identified by:
  *   tosec   = .init.text | .exit.text | .init.data
  *   fromsec = .data
- *   atsym = *_driver, *_template, *_sht, *_ops, *_probe, *probe_one
+ *   atsym = *driver, *_template, *_sht, *_ops, *_probe, *probe_one
  **/
 static int secref_whitelist(const char *tosec, const char *fromsec,
 			    const char *atsym)
@@ -502,7 +502,7 @@ static int secref_whitelist(const char *tosec, const char *fromsec,
 	int f1 = 1, f2 = 1;
 	const char **s;
 	const char *pat2sym[] = {
-		"_driver",
+		"driver",
 		"_template", /* scsi uses *_template a lot */
 		"_sht",      /* scsi also used *_sht to some extent */
 		"_ops",

commit c8d8b837ebe4b4f11e1b0c4a2bdc358c697692ed
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Apr 25 01:53:43 2006 +0900

    kbuild: fix modpost segfault for 64bit mipsel kernel
    
    64bit mips has different r_info layout.  This patch fixes modpost
    segfault for 64bit little endian mips kernel.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index cd00e9f07589..fcd4306fa002 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -709,10 +709,17 @@ static void check_sec_ref(struct module *mod, const char *modname,
 		for (rela = start; rela < stop; rela++) {
 			Elf_Rela r;
 			const char *secname;
+			unsigned int r_sym;
 			r.r_offset = TO_NATIVE(rela->r_offset);
-			r.r_info   = TO_NATIVE(rela->r_info);
+			if (hdr->e_ident[EI_CLASS] == ELFCLASS64 &&
+			    hdr->e_machine == EM_MIPS) {
+				r_sym = ELF64_MIPS_R_SYM(rela->r_info);
+				r_sym = TO_NATIVE(r_sym);
+			} else {
+				r_sym = ELF_R_SYM(TO_NATIVE(rela->r_info));
+			}
 			r.r_addend = TO_NATIVE(rela->r_addend);
-			sym = elf->symtab_start + ELF_R_SYM(r.r_info);
+			sym = elf->symtab_start + r_sym;
 			/* Skip special sections */
 			if (sym->st_shndx >= SHN_LORESERVE)
 				continue;

commit 5ecdd0f67c624714ccd5358e1cc88324f86f0e10
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Apr 14 23:54:13 2006 +0200

    kbuild: fix false section mismatch warnings
    
    Darren Jenkins <darrenrjenkins@gmail.com> pointed out a
    number of false positives where we referenced variables
    from a _driver variable.
    Fix it by check for that pattern and ignore it.
    
    Randy.Dunlap <rdunlap@xenotime.net> pointed out a similar
    set of warnings for a number of scsi drivers.
    In scsi world they misname their variables *_template or
    *_sht so add these to list of variables that may have references
    to .init.text with no warning.
    
    Randy.Dunlap <rdunlap@xenotime.net> also pointed out a scsi driver
    with many references to .exit.text from .rodata. This is compiler
    generated references and we already ignore these for .init.text, so
    ignore them for .exit.text also.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7e8079a34adf..cd00e9f07589 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -492,17 +492,19 @@ static int strrcmp(const char *s, const char *sub)
  *   These functions may often be marked __init and we do not want to
  *   warn here.
  *   the pattern is identified by:
- *   tosec   = .init.text | .exit.text
+ *   tosec   = .init.text | .exit.text | .init.data
  *   fromsec = .data
- *   atsym = *_driver, *_ops, *_probe, *probe_one
+ *   atsym = *_driver, *_template, *_sht, *_ops, *_probe, *probe_one
  **/
 static int secref_whitelist(const char *tosec, const char *fromsec,
-			  const char *atsym)
+			    const char *atsym)
 {
 	int f1 = 1, f2 = 1;
 	const char **s;
 	const char *pat2sym[] = {
 		"_driver",
+		"_template", /* scsi uses *_template a lot */
+		"_sht",      /* scsi also used *_sht to some extent */
 		"_ops",
 		"_probe",
 		"_probe_one",
@@ -522,7 +524,8 @@ static int secref_whitelist(const char *tosec, const char *fromsec,
 
 	/* Check for pattern 2 */
 	if ((strcmp(tosec, ".init.text") != 0) &&
-	    (strcmp(tosec, ".exit.text") != 0))
+	    (strcmp(tosec, ".exit.text") != 0) &&
+	    (strcmp(tosec, ".init.data") != 0))
 		f2 = 0;
 	if (strcmp(fromsec, ".data") != 0)
 		f2 = 0;
@@ -820,6 +823,7 @@ static int exit_section(const char *name)
  * For our future {in}sanity, add a comment that this is the ppc .opd
  * section, not the ia64 .opd section.
  * ia64 .opd should not point to discarded sections.
+ * [.rodata] like for .init.text we ignore .rodata references -same reason
  **/
 static int exit_section_ref_ok(const char *name)
 {
@@ -829,6 +833,7 @@ static int exit_section_ref_ok(const char *name)
 		".exit.text",
 		".exit.data",
 		".init.text",
+		".rodata",
 		".opd", /* See comment [OPD] */
 		".toc1",  /* used by ppc64 */
 		".altinstructions",

commit eaaae38c1ac4ccbec6d2de7255b0538f38fb29d6
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Apr 11 00:54:16 2006 +0200

    kbuild: fix NULL dereference in scripts/mod/modpost.c
    
    before is NULL in this case, concluding from the surrounding code
    it seems that after is the right one to use.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 0b92ddff26fd..7e8079a34adf 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -658,7 +658,7 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		warn("%s - Section mismatch: reference to %s:%s from %s "
 		     "before '%s' (at offset -0x%llx)\n",
 		     modname, secname, refsymname, fromsec,
-		     elf->strtab + before->st_name,
+		     elf->strtab + after->st_name,
 		     (long long)r.r_offset);
 	} else {
 		warn("%s - Section mismatch: reference to %s:%s from %s "

commit 2e1ca21d46aaef95101723fa402f39d3a95aba59
Merge: 315ab19a6d12 eae0f536f640
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sat Mar 25 08:48:48 2006 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/sam/kbuild
    
    * master.kernel.org:/pub/scm/linux/kernel/git/sam/kbuild: (46 commits)
      kbuild: remove obsoleted scripts/reference_* files
      kbuild: fix make help & make *pkg
      kconfig: fix time ordering of writes to .kconfig.d and include/linux/autoconf.h
      Kconfig: remove the CONFIG_CC_ALIGN_* options
      kbuild: add -fverbose-asm to i386 Makefile
      kbuild: clean-up genksyms
      kbuild: Lindent genksyms.c
      kbuild: fix genksyms build error
      kbuild: in makefile.txt note that Makefile is preferred name for kbuild files
      kbuild: replace PHONY with FORCE
      kbuild: Fix bug in crc symbol generating of kernel and modules
      kbuild: change kbuild to not rely on incorrect GNU make behavior
      kbuild: when warning symbols exported twice now tell user this is the problem
      kbuild: fix make dir/file.xx when asm symlink is missing
      kbuild: in the section mismatch check try harder to find symbols
      kbuild: fix section mismatch check for unwind on IA64
      kbuild: kill false positives from section mismatch warnings for powerpc
      kbuild: kill trailing whitespace in modpost & friends
      kbuild: small update of allnoconfig description
      kbuild: make namespace.pl CROSS_COMPILE happy
      ...
    
    Trivial conflict in arch/ppc/boot/Makefile manually fixed up

commit 7670f023aabd976c25862e4c6fb9f6d9d2758153
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu Mar 16 23:04:08 2006 -0800

    [PATCH] kbuild: fix buffer overflow in modpost
    
    Jiri Benc <jbenc@suse.cz> reported that modpost would stop with SIGABRT if
    used with long filepaths.
    The error looked like:
    >   Building modules, stage 2.
    >   MODPOST
    > *** glibc detected *** scripts/mod/modpost: realloc(): invalid next size:
    +0x0809f588 ***
    > [...]
    
    Fix this by allocating at least the required memory + SZ bytes each time.
    Before we sometimes ended up allocating too little memory resuting in the
    glibc detected bug above.  Based on patch originally submitted by: Jiri
    Benc <jbenc@suse.cz>
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f70ff13d4818..b8b2a560b26b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -508,12 +508,7 @@ buf_printf(struct buffer *buf, const char *fmt, ...)
 	
 	va_start(ap, fmt);
 	len = vsnprintf(tmp, SZ, fmt, ap);
-	if (buf->size - buf->pos < len + 1) {
-		buf->size += 128;
-		buf->p = realloc(buf->p, buf->size);
-	}
-	strncpy(buf->p + buf->pos, tmp, len + 1);
-	buf->pos += len;
+	buf_write(buf, tmp, len);
 	va_end(ap);
 }
 
@@ -521,7 +516,7 @@ void
 buf_write(struct buffer *buf, const char *s, int len)
 {
 	if (buf->size - buf->pos < len) {
-		buf->size += len;
+		buf->size += len + SZ;
 		buf->p = realloc(buf->p, buf->size);
 	}
 	strncpy(buf->p + buf->pos, s, len);

commit f7b05e64bdb2fcc4b2dc94a4bd9426adc70c9599
Author: Luke Yang <luke.adi@gmail.com>
Date:   Thu Mar 2 18:35:31 2006 +0800

    kbuild: Fix bug in crc symbol generating of kernel and modules
    
    The scripts/genksyms/genksyms.c uses hardcoded "__crc_" prefix for
    crc symbols in kernel and modules. The prefix should be replaced by
    "MODULE_SYMBOL_PREFIX##__crc_" otherwise there will be warnings when
    MODULE_SYMBOL_PREFIX is not NULL.
    
    I am sorry my last patch for this issue is actually wrong. I revert
    it in this patch.
    
    Signed-off-by: Luke Yang <luke.adi@gmail.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e2bf4c927dd3..30f3ac8eb43c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -346,8 +346,8 @@ static void parse_elf_finish(struct elf_info *info)
 	release_file(info->hdr, info->size);
 }
 
-#define CRC_PFX     "__crc_"
-#define KSYMTAB_PFX "__ksymtab_"
+#define CRC_PFX     MODULE_SYMBOL_PREFIX "__crc_"
+#define KSYMTAB_PFX MODULE_SYMBOL_PREFIX "__ksymtab_"
 
 static void handle_modversions(struct module *mod, struct elf_info *info,
 			       Elf_Sym *sym, const char *symname)

commit 7b75b13cda8bd21e8636ea985f76e1ce5bd1a470
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 5 13:48:58 2006 +0100

    kbuild: when warning symbols exported twice now tell user this is the problem
    
    Warning now looks like this:
    WARNING: vmlinux: 'strcpy' exported twice. Previous export was in vmlinux
    
    Which gives much better hint how to fix it.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3648683a26c5..e2bf4c927dd3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -191,7 +191,7 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod)
 		s = new_symbol(name, mod);
 	} else {
 		if (!s->preloaded) {
-			warn("%s: duplicate symbol '%s' previous definition "
+			warn("%s: '%s' exported twice. Previous export "
 			     "was in %s%s\n", mod->name, name,
 			     s->module->name,
 			     is_vmlinux(s->module->name) ?"":".ko");

commit 43c74d179596ba1f8eceb8c6a5c7e11afe233662
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 5 12:02:46 2006 +0100

    kbuild: in the section mismatch check try harder to find symbols
    
    When searching for symbols the only check performed was if
    offset equals st_value. Adding an additional check to see if st_name
    points t a valid name made us sort out a few more false positives and
    let us report more correct names in warnings.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3b570b18c2e4..3648683a26c5 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -558,7 +558,10 @@ static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
 }
 
 /*
- * Find symbols before or equal addr and after addr - in the section sec
+ * Find symbols before or equal addr and after addr - in the section sec.
+ * If we find two symbols with equal offset prefer one with a valid name.
+ * The ELF format may have a better way to detect what type of symbol
+ * it is, but this works for now.
  **/
 static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 				 const char *sec,
@@ -587,6 +590,12 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 				beforediff = addr - sym->st_value;
 				*before = sym;
 			}
+			else if ((addr - sym->st_value) == beforediff) {
+				/* equal offset, valid name? */
+				const char *name = elf->strtab + sym->st_name;
+				if (name && strlen(name))
+					*before = sym;
+			}
 		}
 		else
 		{
@@ -594,6 +603,12 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 				afterdiff = sym->st_value - addr;
 				*after = sym;
 			}
+			else if ((sym->st_value - addr) == afterdiff) {
+				/* equal offset, valid name? */
+				const char *name = elf->strtab + sym->st_name;
+				if (name && strlen(name))
+					*after = sym;
+			}
 		}
 	}
 }

commit e835a39c1c1f023ef443f735b0e98b08660ae0e4
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 5 11:34:15 2006 +0100

    kbuild: fix section mismatch check for unwind on IA64
    
    Parameters to strstr() was reversed.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c4dc1d72d02e..3b570b18c2e4 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -776,7 +776,7 @@ static int init_section_ref_ok(const char *name)
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
 	for (s = namelist3; *s; s++)
-		if (strstr(*s, name) != NULL)
+		if (strstr(name, *s) != NULL)
 			return 1;
 	return 0;
 }
@@ -842,7 +842,7 @@ static int exit_section_ref_ok(const char *name)
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
 	for (s = namelist3; *s; s++)
-		if (strstr(*s, name) != NULL)
+		if (strstr(name, *s) != NULL)
 			return 1;
 	return 0;
 }

commit 9209aed0726c77ad13b8d83e73a3cf9f59a8c2b2
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Mar 5 00:16:26 2006 +0100

    kbuild: kill false positives from section mismatch warnings for powerpc
    
    Building an allmodconfig kernel for ppc64 revealed a number of false
    positives - originally reported by Andrew Morton.
    This patch removes most if not all false positives for ppc64:
    
    Section .opd
    The .opd section contains function descriptors at least for ppc64.
    So ignore it for .init.text (was ignored for .exit.text).
    See description of function descriptors here:
    http://www.linuxbase.org/spec/ELF/ppc64/PPC-elf64abi-1.7.html
    
    Section .toc1
    ppc64 places some static variables in .toc1 - ignore the.
    
    Section __bug_tabe
    BUG() and friends uses __bug_table. Ignore warnings from that section.
    
    Module parameters are placed in .data.rel for ppc64, for adjust pattern to
    match on section named .data*
    
    Tested with gcc: 3.4.0 and binutils 2.15.90.0.3
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5de3c63091e9..c4dc1d72d02e 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -483,7 +483,7 @@ static int strrcmp(const char *s, const char *sub)
  *   this pattern.
  *   The pattern is identified by:
  *   tosec   = .init.data
- *   fromsec = .data
+ *   fromsec = .data*
  *   atsym   =__param*
  *
  * Pattern 2:
@@ -512,7 +512,7 @@ static int secref_whitelist(const char *tosec, const char *fromsec,
 	/* Check for pattern 1 */
 	if (strcmp(tosec, ".init.data") != 0)
 		f1 = 0;
-	if (strcmp(fromsec, ".data") != 0)
+	if (strncmp(fromsec, ".data", strlen(".data")) != 0)
 		f1 = 0;
 	if (strncmp(atsym, "__param", strlen("__param")) != 0)
 		f1 = 0;
@@ -743,9 +743,12 @@ static int init_section_ref_ok(const char *name)
 	/* Absolute section names */
 	const char *namelist1[] = {
 		".init",
+		".opd",   /* see comment [OPD] at exit_section_ref_ok() */
+		".toc1",  /* used by ppc64 */
 		".stab",
 		".rodata",
 		".text.lock",
+		"__bug_table", /* used by powerpc for BUG() */
 		".pci_fixup_header",
 		".pci_fixup_final",
 		".pdr",
@@ -812,8 +815,10 @@ static int exit_section_ref_ok(const char *name)
 		".exit.data",
 		".init.text",
 		".opd", /* See comment [OPD] */
+		".toc1",  /* used by ppc64 */
 		".altinstructions",
 		".pdr",
+		"__bug_table", /* used by powerpc for BUG() */
 		".exitcall.exit",
 		".eh_frame",
 		".stab",

commit 62070fa42c4ac23d1d71146a4c14702302b80245
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Mar 3 16:46:04 2006 +0100

    kbuild: kill trailing whitespace in modpost & friends
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 663b1eff757b..5de3c63091e9 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -85,7 +85,7 @@ static struct module *new_module(char *modname)
 {
 	struct module *mod;
 	char *p, *s;
-	
+
 	mod = NOFAIL(malloc(sizeof(*mod)));
 	memset(mod, 0, sizeof(*mod));
 	p = NOFAIL(strdup(modname));
@@ -320,9 +320,9 @@ static void parse_elf(struct elf_info *info, const char *filename)
 			continue;
 
 		info->symtab_start = (void *)hdr + sechdrs[i].sh_offset;
-		info->symtab_stop  = (void *)hdr + sechdrs[i].sh_offset 
+		info->symtab_stop  = (void *)hdr + sechdrs[i].sh_offset
 			                         + sechdrs[i].sh_size;
-		info->strtab       = (void *)hdr + 
+		info->strtab       = (void *)hdr +
 			             sechdrs[sechdrs[i].sh_link].sh_offset;
 	}
 	if (!info->symtab_start) {
@@ -387,15 +387,15 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 			/* Ignore register directives. */
 			if (ELF_ST_TYPE(sym->st_info) == STT_SPARC_REGISTER)
 				break;
- 			if (symname[0] == '.') {
- 				char *munged = strdup(symname);
- 				munged[0] = '_';
- 				munged[1] = toupper(munged[1]);
- 				symname = munged;
- 			}
+			if (symname[0] == '.') {
+				char *munged = strdup(symname);
+				munged[0] = '_';
+				munged[1] = toupper(munged[1]);
+				symname = munged;
+			}
 		}
 #endif
-		
+
 		if (memcmp(symname, MODULE_SYMBOL_PREFIX,
 			   strlen(MODULE_SYMBOL_PREFIX)) == 0)
 			mod->unres = alloc_symbol(symname +
@@ -458,13 +458,13 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
 static int strrcmp(const char *s, const char *sub)
 {
         int slen, sublen;
-	
+
 	if (!s || !sub)
 		return 1;
-	
+
 	slen = strlen(s);
         sublen = strlen(sub);
-	
+
 	if ((slen == 0) || (sublen == 0))
 		return 1;
 
@@ -485,7 +485,7 @@ static int strrcmp(const char *s, const char *sub)
  *   tosec   = .init.data
  *   fromsec = .data
  *   atsym   =__param*
- *   
+ *
  * Pattern 2:
  *   Many drivers utilise a *_driver container with references to
  *   add, remove, probe functions etc.
@@ -508,7 +508,7 @@ static int secref_whitelist(const char *tosec, const char *fromsec,
 		"_probe_one",
 		NULL
 	};
-	
+
 	/* Check for pattern 1 */
 	if (strcmp(tosec, ".init.data") != 0)
 		f1 = 0;
@@ -521,7 +521,7 @@ static int secref_whitelist(const char *tosec, const char *fromsec,
 		return f1;
 
 	/* Check for pattern 2 */
-	if ((strcmp(tosec, ".init.text") != 0) && 
+	if ((strcmp(tosec, ".init.text") != 0) &&
 	    (strcmp(tosec, ".exit.text") != 0))
 		f2 = 0;
 	if (strcmp(fromsec, ".data") != 0)
@@ -570,7 +570,7 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 	Elf_Addr afterdiff = ~0;
 	const char *secstrings = (void *)hdr +
 				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
-	
+
 	*before = NULL;
 	*after = NULL;
 
@@ -614,7 +614,7 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	const char *secstrings = (void *)hdr +
 				 sechdrs[hdr->e_shstrndx].sh_offset;
 	const char *secname = secstrings + sechdrs[sym->st_shndx].sh_name;
-	
+
 	find_symbols_between(elf, r.r_offset, fromsec, &before, &after);
 
 	refsym = find_elf_symbol(elf, r.r_addend, sym);
@@ -622,10 +622,10 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 		refsymname = elf->strtab + refsym->st_name;
 
 	/* check whitelist - we may ignore it */
-	if (before && 
+	if (before &&
 	    secref_whitelist(secname, fromsec, elf->strtab + before->st_name))
 		return;
-	
+
 	if (before && after) {
 		warn("%s - Section mismatch: reference to %s:%s from %s "
 		     "between '%s' (at offset 0x%llx) and '%s'\n",
@@ -636,13 +636,13 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	} else if (before) {
 		warn("%s - Section mismatch: reference to %s:%s from %s "
 		     "after '%s' (at offset 0x%llx)\n",
-		     modname, secname, refsymname, fromsec, 
+		     modname, secname, refsymname, fromsec,
 		     elf->strtab + before->st_name,
 		     (long long)r.r_offset);
 	} else if (after) {
 		warn("%s - Section mismatch: reference to %s:%s from %s "
 		     "before '%s' (at offset -0x%llx)\n",
-		     modname, secname, refsymname, fromsec, 
+		     modname, secname, refsymname, fromsec,
 		     elf->strtab + before->st_name,
 		     (long long)r.r_offset);
 	} else {
@@ -676,7 +676,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 	Elf_Shdr *sechdrs = elf->sechdrs;
 	const char *secstrings = (void *)hdr +
 				 sechdrs[hdr->e_shstrndx].sh_offset;
-		
+
 	/* Walk through all sections */
 	for (i = 0; i < hdr->e_shnum; i++) {
 		Elf_Rela *rela;
@@ -724,13 +724,13 @@ static int init_section(const char *name)
 
 /**
  * Identify sections from which references to a .init section is OK.
- * 
+ *
  * Unfortunately references to read only data that referenced .init
  * sections had to be excluded. Almost all of these are false
  * positives, they are created by gcc. The downside of excluding rodata
  * is that there really are some user references from rodata to
  * init code, e.g. drivers/video/vgacon.c:
- * 
+ *
  * const struct consw vga_con = {
  *        con_startup:            vgacon_startup,
  *
@@ -769,10 +769,10 @@ static int init_section_ref_ok(const char *name)
 	for (s = namelist1; *s; s++)
 		if (strcmp(*s, name) == 0)
 			return 1;
-	for (s = namelist2; *s; s++)	
+	for (s = namelist2; *s; s++)
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
-	for (s = namelist3; *s; s++)	
+	for (s = namelist3; *s; s++)
 		if (strstr(*s, name) != NULL)
 			return 1;
 	return 0;
@@ -792,12 +792,12 @@ static int exit_section(const char *name)
 	if (strcmp(name, ".exit.data") == 0)
 		return 1;
 	return 0;
-	
+
 }
 
 /*
  * Identify sections from which references to a .exit section is OK.
- * 
+ *
  * [OPD] Keith Ownes <kaos@sgi.com> commented:
  * For our future {in}sanity, add a comment that this is the ppc .opd
  * section, not the ia64 .opd section.
@@ -829,14 +829,14 @@ static int exit_section_ref_ok(const char *name)
 		".unwind",  /* Sample: IA_64.unwind.exit.text */
 		NULL
 	};
-	
+
 	for (s = namelist1; *s; s++)
 		if (strcmp(*s, name) == 0)
 			return 1;
-	for (s = namelist2; *s; s++)	
+	for (s = namelist2; *s; s++)
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
-	for (s = namelist3; *s; s++)	
+	for (s = namelist3; *s; s++)
 		if (strstr(*s, name) != NULL)
 			return 1;
 	return 0;
@@ -900,7 +900,7 @@ void __attribute__((format(printf, 2, 3))) buf_printf(struct buffer *buf,
 	char tmp[SZ];
 	int len;
 	va_list ap;
-	
+
 	va_start(ap, fmt);
 	len = vsnprintf(tmp, SZ, fmt, ap);
 	if (buf->size - buf->pos < len + 1) {
@@ -1129,7 +1129,7 @@ static int dump_sym(struct symbol *sym)
 		return 0;
 	return 1;
 }
-		
+
 static void write_dump(const char *fname)
 {
 	struct buffer buf = { };
@@ -1141,7 +1141,7 @@ static void write_dump(const char *fname)
 		while (symbol) {
 			if (dump_sym(symbol))
 				buf_printf(&buf, "0x%08x\t%s\t%s\n",
-					symbol->crc, symbol->name, 
+					symbol->crc, symbol->name,
 					symbol->module->name);
 			symbol = symbol->next;
 		}

commit 4c8fbca5836aaafd165aa8732d92ab5d4f3a6841
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Feb 26 22:18:11 2006 +0100

    kbuild: whitelist false section mismatch warnings
    
    In several cases the section mismatch check triggered false warnings.
    Following patch introduce a whitelist to 'false positives' are not warned of.
    Two types of patterns are recognised:
    1) Typical case when a module parameter is _initdata
    2) When a function pointer is assigned to a driver structure
    
    In both patterns we rely on the actual name of the variable assigned
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index de0a9ee1de16..663b1eff757b 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -451,6 +451,89 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
 	return NULL;
 }
 
+/**
+ * Test if string s ends in string sub
+ * return 0 if match
+ **/
+static int strrcmp(const char *s, const char *sub)
+{
+        int slen, sublen;
+	
+	if (!s || !sub)
+		return 1;
+	
+	slen = strlen(s);
+        sublen = strlen(sub);
+	
+	if ((slen == 0) || (sublen == 0))
+		return 1;
+
+        if (sublen > slen)
+                return 1;
+
+        return memcmp(s + slen - sublen, sub, sublen);
+}
+
+/**
+ * Whitelist to allow certain references to pass with no warning.
+ * Pattern 1:
+ *   If a module parameter is declared __initdata and permissions=0
+ *   then this is legal despite the warning generated.
+ *   We cannot see value of permissions here, so just ignore
+ *   this pattern.
+ *   The pattern is identified by:
+ *   tosec   = .init.data
+ *   fromsec = .data
+ *   atsym   =__param*
+ *   
+ * Pattern 2:
+ *   Many drivers utilise a *_driver container with references to
+ *   add, remove, probe functions etc.
+ *   These functions may often be marked __init and we do not want to
+ *   warn here.
+ *   the pattern is identified by:
+ *   tosec   = .init.text | .exit.text
+ *   fromsec = .data
+ *   atsym = *_driver, *_ops, *_probe, *probe_one
+ **/
+static int secref_whitelist(const char *tosec, const char *fromsec,
+			  const char *atsym)
+{
+	int f1 = 1, f2 = 1;
+	const char **s;
+	const char *pat2sym[] = {
+		"_driver",
+		"_ops",
+		"_probe",
+		"_probe_one",
+		NULL
+	};
+	
+	/* Check for pattern 1 */
+	if (strcmp(tosec, ".init.data") != 0)
+		f1 = 0;
+	if (strcmp(fromsec, ".data") != 0)
+		f1 = 0;
+	if (strncmp(atsym, "__param", strlen("__param")) != 0)
+		f1 = 0;
+
+	if (f1)
+		return f1;
+
+	/* Check for pattern 2 */
+	if ((strcmp(tosec, ".init.text") != 0) && 
+	    (strcmp(tosec, ".exit.text") != 0))
+		f2 = 0;
+	if (strcmp(fromsec, ".data") != 0)
+		f2 = 0;
+
+	for (s = pat2sym; *s; s++)
+		if (strrcmp(atsym, *s) == 0)
+			f1 = 1;
+
+	return f1 && f2;
+}
+
 /**
  * Find symbol based on relocation record info.
  * In some cases the symbol supplied is a valid symbol so
@@ -518,6 +601,7 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 /**
  * Print a warning about a section mismatch.
  * Try to find symbols near it so user can find it.
+ * Check whitelist before warning - it may be a false positive.
  **/
 static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			      struct elf_info *elf, Elf_Sym *sym, Elf_Rela r)
@@ -536,6 +620,11 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	refsym = find_elf_symbol(elf, r.r_addend, sym);
 	if (refsym && strlen(elf->strtab + refsym->st_name))
 		refsymname = elf->strtab + refsym->st_name;
+
+	/* check whitelist - we may ignore it */
+	if (before && 
+	    secref_whitelist(secname, fromsec, elf->strtab + before->st_name))
+		return;
 	
 	if (before && after) {
 		warn("%s - Section mismatch: reference to %s:%s from %s "

commit 382168f4791822de7d44d9c634fbfdf8bc08c91b
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Feb 26 20:11:17 2006 +0100

    kbuild: Add copyright to modpost.c
    
    It seems popular to protect your work with copyright, so I decided to do
    so for modpost which I patch a great deal atm.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 7f25354deba2..de0a9ee1de16 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -2,7 +2,7 @@
  *
  * Copyright 2003       Kai Germaschewski
  * Copyright 2002-2004  Rusty Russell, IBM Corporation
- *
+ * Copyright 2006       Sam Ravnborg
  * Based in part on module-init-tools/depmod.c,file2alias
  *
  * This software may be used and distributed according to the terms

commit 6e10133fa4b2366e8ef18bc2ce34afe727b1c4ba
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Wed Feb 22 21:24:50 2006 +0100

    kbuild: do not warn when unwind sections references .init/.exit sections
    
    Andrew Morton reported a number of false positives for ia64 - like these:
    WARNING: drivers/acpi/button.o - Section mismatch: reference to .init.text: from .IA_64.unwind.init.text after '' (at offset 0x0)
    WARNING: drivers/acpi/button.o - Section mismatch: reference to .exit.text: from .IA_64.unwind.exit.text after '' (at offset 0x0)
    WARNING: drivers/acpi/processor.o - Section mismatch: reference to .init.text: from .IA_64.unwind after '' (at offset 0x1e8)
    
    They are all false positives - or at least the .c code looks OK.
    It is not known why sometimes a section name is appended and sometimes not.
    
    Fix is to accept references from all sections that includes "unwind." in the name.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 5b076ef51996..7f25354deba2 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -671,13 +671,21 @@ static int init_section_ref_ok(const char *name)
 		".debug",
 		NULL
 	};
-	
+	/* part of section name */
+	const char *namelist3 [] = {
+		".unwind",  /* sample: IA_64.unwind.init.text */
+		NULL
+	};
+
 	for (s = namelist1; *s; s++)
 		if (strcmp(*s, name) == 0)
 			return 1;
 	for (s = namelist2; *s; s++)	
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
+	for (s = namelist3; *s; s++)	
+		if (strstr(*s, name) != NULL)
+			return 1;
 	return 0;
 }
 
@@ -727,6 +735,11 @@ static int exit_section_ref_ok(const char *name)
 		".debug",
 		NULL
 	};
+	/* part of section name */
+	const char *namelist3 [] = {
+		".unwind",  /* Sample: IA_64.unwind.exit.text */
+		NULL
+	};
 	
 	for (s = namelist1; *s; s++)
 		if (strcmp(*s, name) == 0)
@@ -734,6 +747,9 @@ static int exit_section_ref_ok(const char *name)
 	for (s = namelist2; *s; s++)	
 		if (strncmp(*s, name, strlen(*s)) == 0)
 			return 1;
+	for (s = namelist3; *s; s++)	
+		if (strstr(*s, name) != NULL)
+			return 1;
 	return 0;
 }
 

commit fededcd2af6219de69b252b7d3ea4b4ec2f33c7a
Author: akpm@osdl.org <akpm@osdl.org>
Date:   Wed Feb 22 03:19:54 2006 -0800

    kbuild: fix modpost compile with older gcc
    
    The kernel now requires that CC be 3.1.0 or higher.  But we shouldn't place
    that requirement upon HOSTCC unless we really need to.  Fixes my ia64 problem.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 844f84b0818a..5b076ef51996 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -590,14 +590,14 @@ static void check_sec_ref(struct module *mod, const char *modname,
 		
 	/* Walk through all sections */
 	for (i = 0; i < hdr->e_shnum; i++) {
+		Elf_Rela *rela;
+		Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
+		Elf_Rela *stop  = (void*)start + sechdrs[i].sh_size;
 		const char *name = secstrings + sechdrs[i].sh_name +
 						strlen(".rela");
 		/* We want to process only relocation sections and not .init */
 		if (section_ref_ok(name) || (sechdrs[i].sh_type != SHT_RELA))
 			continue;
-		Elf_Rela *rela;
-		Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
-		Elf_Rela *stop  = (void*)start + sechdrs[i].sh_size;
 
 		for (rela = start; rela < stop; rela++) {
 			Elf_Rela r;

commit 93684d3b8062d1cebdeaed398ec6d1f354cb41a9
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Feb 19 11:53:35 2006 +0100

    kbuild: include symbol names in section mismatch warnings
    
    Try to look up the symbol that is referenced. Include the symbol
    name in the warning message.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index eeaf57476820..844f84b0818a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -451,6 +451,29 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
 	return NULL;
 }
 
+/**
+ * Find symbol based on relocation record info.
+ * In some cases the symbol supplied is a valid symbol so
+ * return refsym. If st_name != 0 we assume this is a valid symbol.
+ * In other cases the symbol needs to be looked up in the symbol table
+ * based on section and address.
+ *  **/
+static Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf_Addr addr,
+				Elf_Sym *relsym)
+{
+	Elf_Sym *sym;
+
+	if (relsym->st_name != 0)
+		return relsym;
+	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
+		if (sym->st_shndx != relsym->st_shndx)
+			continue;
+		if (sym->st_value == addr)
+			return sym;
+	}
+	return NULL;
+}
+
 /*
  * Find symbols before or equal addr and after addr - in the section sec
  **/
@@ -499,8 +522,9 @@ static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
 static void warn_sec_mismatch(const char *modname, const char *fromsec,
 			      struct elf_info *elf, Elf_Sym *sym, Elf_Rela r)
 {
-	Elf_Sym *before;
-	Elf_Sym *after;
+	const char *refsymname = "";
+	Elf_Sym *before, *after;
+	Elf_Sym *refsym;
 	Elf_Ehdr *hdr = elf->hdr;
 	Elf_Shdr *sechdrs = elf->sechdrs;
 	const char *secstrings = (void *)hdr +
@@ -509,29 +533,34 @@ static void warn_sec_mismatch(const char *modname, const char *fromsec,
 	
 	find_symbols_between(elf, r.r_offset, fromsec, &before, &after);
 
+	refsym = find_elf_symbol(elf, r.r_addend, sym);
+	if (refsym && strlen(elf->strtab + refsym->st_name))
+		refsymname = elf->strtab + refsym->st_name;
+	
 	if (before && after) {
-		warn("%s - Section mismatch: reference to %s from %s "
-		     "between '%s' (at offset 0x%lx) and '%s'\n",
-		     modname, secname, fromsec,
+		warn("%s - Section mismatch: reference to %s:%s from %s "
+		     "between '%s' (at offset 0x%llx) and '%s'\n",
+		     modname, secname, refsymname, fromsec,
 		     elf->strtab + before->st_name,
-		     (long)(r.r_offset - before->st_value),
+		     (long long)r.r_offset,
 		     elf->strtab + after->st_name);
 	} else if (before) {
-		warn("%s - Section mismatch: reference to %s from %s "
-		     "after '%s' (at offset 0x%lx)\n",
-		     modname, secname, fromsec, 
+		warn("%s - Section mismatch: reference to %s:%s from %s "
+		     "after '%s' (at offset 0x%llx)\n",
+		     modname, secname, refsymname, fromsec, 
 		     elf->strtab + before->st_name,
-		     (long)(r.r_offset - before->st_value));
+		     (long long)r.r_offset);
 	} else if (after) {
-		warn("%s - Section mismatch: reference to %s from %s "
-		     "before '%s' (at offset -0x%lx)\n",
-		     modname, secname, fromsec, 
+		warn("%s - Section mismatch: reference to %s:%s from %s "
+		     "before '%s' (at offset -0x%llx)\n",
+		     modname, secname, refsymname, fromsec, 
 		     elf->strtab + before->st_name,
-		     (long)(before->st_value - r.r_offset));
+		     (long long)r.r_offset);
 	} else {
-		warn("%s - Section mismatch: reference to %s from %s "
-		     "(offset 0x%lx)\n",
-		     modname, secname, fromsec, (long)r.r_offset);
+		warn("%s - Section mismatch: reference to %s:%s from %s "
+		     "(offset 0x%llx)\n",
+		     modname, secname, fromsec, refsymname,
+		     (long long)r.r_offset);
 	}
 }
 
@@ -575,6 +604,7 @@ static void check_sec_ref(struct module *mod, const char *modname,
 			const char *secname;
 			r.r_offset = TO_NATIVE(rela->r_offset);
 			r.r_info   = TO_NATIVE(rela->r_info);
+			r.r_addend = TO_NATIVE(rela->r_addend);
 			sym = elf->symtab_start + ELF_R_SYM(r.r_info);
 			/* Skip special sections */
 			if (sym->st_shndx >= SHN_LORESERVE)

commit 8ea80ca4f583e377c902811d42626ccfce16913f
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sun Feb 19 09:56:18 2006 +0100

    kbuild: fix segfault in modpost
    
    Do not try to look up section name until we know it is not a special
    section. Otherwise we will address outside legal space and segfault.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a7360c379cba..eeaf57476820 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -576,11 +576,11 @@ static void check_sec_ref(struct module *mod, const char *modname,
 			r.r_offset = TO_NATIVE(rela->r_offset);
 			r.r_info   = TO_NATIVE(rela->r_info);
 			sym = elf->symtab_start + ELF_R_SYM(r.r_info);
-			secname = secstrings + sechdrs[sym->st_shndx].sh_name;
 			/* Skip special sections */
 			if (sym->st_shndx >= SHN_LORESERVE)
 				continue;
 
+			secname = secstrings + sechdrs[sym->st_shndx].sh_name;
 			if (section(secname))
 				warn_sec_mismatch(modname, name, elf, sym, r);
 		}

commit b39927cf4cc5a9123d2b157ffd396884cb8156eb
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Fri Feb 17 22:42:02 2006 +0100

    kbuild: check for section mismatch during modpost stage
    
    Section mismatch is identified as references to .init*
    sections from non .init sections. And likewise references
    to .exit.* sections outside .exit sections.
    
    .init.* sections are discarded after a module is initialized
    and references to .init.* sections are oops candidates.
    .exit.* sections are discarded when a module is built-in and
    thus references to .exit are also oops candidates.
    
    The checks were possible to do using 'make buildcheck' which
    called the two perl scripts: reference_discarded.pl and
    reference_init.pl. This patch just moves the same functionality
    inside modpost and the scripts are then obsoleted.
    They will though be kept for a while so users can do double
    checks - but note that some .o files are skipped by the perl scripts
    so result is not 1:1.
    All credit for the concept goes to Keith Owens who implemented
    the original perl scrips - this patch just moves it to modpost.
    
    Compared to the perl script the implmentation in modpost will be run
    for each kernel build - thus catching the error much sooner, but
    the downside is that the individual .o file are not always identified.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index d901095ea8b7..a7360c379cba 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -451,6 +451,262 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
 	return NULL;
 }
 
+/*
+ * Find symbols before or equal addr and after addr - in the section sec
+ **/
+static void find_symbols_between(struct elf_info *elf, Elf_Addr addr,
+				 const char *sec,
+			         Elf_Sym **before, Elf_Sym **after)
+{
+	Elf_Sym *sym;
+	Elf_Ehdr *hdr = elf->hdr;
+	Elf_Addr beforediff = ~0;
+	Elf_Addr afterdiff = ~0;
+	const char *secstrings = (void *)hdr +
+				 elf->sechdrs[hdr->e_shstrndx].sh_offset;
+	
+	*before = NULL;
+	*after = NULL;
+
+	for (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {
+		const char *symsec;
+
+		if (sym->st_shndx >= SHN_LORESERVE)
+			continue;
+		symsec = secstrings + elf->sechdrs[sym->st_shndx].sh_name;
+		if (strcmp(symsec, sec) != 0)
+			continue;
+		if (sym->st_value <= addr) {
+			if ((addr - sym->st_value) < beforediff) {
+				beforediff = addr - sym->st_value;
+				*before = sym;
+			}
+		}
+		else
+		{
+			if ((sym->st_value - addr) < afterdiff) {
+				afterdiff = sym->st_value - addr;
+				*after = sym;
+			}
+		}
+	}
+}
+
+/**
+ * Print a warning about a section mismatch.
+ * Try to find symbols near it so user can find it.
+ **/
+static void warn_sec_mismatch(const char *modname, const char *fromsec,
+			      struct elf_info *elf, Elf_Sym *sym, Elf_Rela r)
+{
+	Elf_Sym *before;
+	Elf_Sym *after;
+	Elf_Ehdr *hdr = elf->hdr;
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	const char *secstrings = (void *)hdr +
+				 sechdrs[hdr->e_shstrndx].sh_offset;
+	const char *secname = secstrings + sechdrs[sym->st_shndx].sh_name;
+	
+	find_symbols_between(elf, r.r_offset, fromsec, &before, &after);
+
+	if (before && after) {
+		warn("%s - Section mismatch: reference to %s from %s "
+		     "between '%s' (at offset 0x%lx) and '%s'\n",
+		     modname, secname, fromsec,
+		     elf->strtab + before->st_name,
+		     (long)(r.r_offset - before->st_value),
+		     elf->strtab + after->st_name);
+	} else if (before) {
+		warn("%s - Section mismatch: reference to %s from %s "
+		     "after '%s' (at offset 0x%lx)\n",
+		     modname, secname, fromsec, 
+		     elf->strtab + before->st_name,
+		     (long)(r.r_offset - before->st_value));
+	} else if (after) {
+		warn("%s - Section mismatch: reference to %s from %s "
+		     "before '%s' (at offset -0x%lx)\n",
+		     modname, secname, fromsec, 
+		     elf->strtab + before->st_name,
+		     (long)(before->st_value - r.r_offset));
+	} else {
+		warn("%s - Section mismatch: reference to %s from %s "
+		     "(offset 0x%lx)\n",
+		     modname, secname, fromsec, (long)r.r_offset);
+	}
+}
+
+/**
+ * A module includes a number of sections that are discarded
+ * either when loaded or when used as built-in.
+ * For loaded modules all functions marked __init and all data
+ * marked __initdata will be discarded when the module has been intialized.
+ * Likewise for modules used built-in the sections marked __exit
+ * are discarded because __exit marked function are supposed to be called
+ * only when a moduel is unloaded which never happes for built-in modules.
+ * The check_sec_ref() function traverses all relocation records
+ * to find all references to a section that reference a section that will
+ * be discarded and warns about it.
+ **/
+static void check_sec_ref(struct module *mod, const char *modname,
+			  struct elf_info *elf,
+			  int section(const char*),
+			  int section_ref_ok(const char *))
+{
+	int i;
+	Elf_Sym  *sym;
+	Elf_Ehdr *hdr = elf->hdr;
+	Elf_Shdr *sechdrs = elf->sechdrs;
+	const char *secstrings = (void *)hdr +
+				 sechdrs[hdr->e_shstrndx].sh_offset;
+		
+	/* Walk through all sections */
+	for (i = 0; i < hdr->e_shnum; i++) {
+		const char *name = secstrings + sechdrs[i].sh_name +
+						strlen(".rela");
+		/* We want to process only relocation sections and not .init */
+		if (section_ref_ok(name) || (sechdrs[i].sh_type != SHT_RELA))
+			continue;
+		Elf_Rela *rela;
+		Elf_Rela *start = (void *)hdr + sechdrs[i].sh_offset;
+		Elf_Rela *stop  = (void*)start + sechdrs[i].sh_size;
+
+		for (rela = start; rela < stop; rela++) {
+			Elf_Rela r;
+			const char *secname;
+			r.r_offset = TO_NATIVE(rela->r_offset);
+			r.r_info   = TO_NATIVE(rela->r_info);
+			sym = elf->symtab_start + ELF_R_SYM(r.r_info);
+			secname = secstrings + sechdrs[sym->st_shndx].sh_name;
+			/* Skip special sections */
+			if (sym->st_shndx >= SHN_LORESERVE)
+				continue;
+
+			if (section(secname))
+				warn_sec_mismatch(modname, name, elf, sym, r);
+		}
+	}
+}
+
+/**
+ * Functions used only during module init is marked __init and is stored in
+ * a .init.text section. Likewise data is marked __initdata and stored in
+ * a .init.data section.
+ * If this section is one of these sections return 1
+ * See include/linux/init.h for the details
+ **/
+static int init_section(const char *name)
+{
+	if (strcmp(name, ".init") == 0)
+		return 1;
+	if (strncmp(name, ".init.", strlen(".init.")) == 0)
+		return 1;
+	return 0;
+}
+
+/**
+ * Identify sections from which references to a .init section is OK.
+ * 
+ * Unfortunately references to read only data that referenced .init
+ * sections had to be excluded. Almost all of these are false
+ * positives, they are created by gcc. The downside of excluding rodata
+ * is that there really are some user references from rodata to
+ * init code, e.g. drivers/video/vgacon.c:
+ * 
+ * const struct consw vga_con = {
+ *        con_startup:            vgacon_startup,
+ *
+ * where vgacon_startup is __init.  If you want to wade through the false
+ * positives, take out the check for rodata.
+ **/
+static int init_section_ref_ok(const char *name)
+{
+	const char **s;
+	/* Absolute section names */
+	const char *namelist1[] = {
+		".init",
+		".stab",
+		".rodata",
+		".text.lock",
+		".pci_fixup_header",
+		".pci_fixup_final",
+		".pdr",
+		"__param",
+		NULL
+	};
+	/* Start of section names */
+	const char *namelist2[] = {
+		".init.",
+		".altinstructions",
+		".eh_frame",
+		".debug",
+		NULL
+	};
+	
+	for (s = namelist1; *s; s++)
+		if (strcmp(*s, name) == 0)
+			return 1;
+	for (s = namelist2; *s; s++)	
+		if (strncmp(*s, name, strlen(*s)) == 0)
+			return 1;
+	return 0;
+}
+
+/*
+ * Functions used only during module exit is marked __exit and is stored in
+ * a .exit.text section. Likewise data is marked __exitdata and stored in
+ * a .exit.data section.
+ * If this section is one of these sections return 1
+ * See include/linux/init.h for the details
+ **/
+static int exit_section(const char *name)
+{
+	if (strcmp(name, ".exit.text") == 0)
+		return 1;
+	if (strcmp(name, ".exit.data") == 0)
+		return 1;
+	return 0;
+	
+}
+
+/*
+ * Identify sections from which references to a .exit section is OK.
+ * 
+ * [OPD] Keith Ownes <kaos@sgi.com> commented:
+ * For our future {in}sanity, add a comment that this is the ppc .opd
+ * section, not the ia64 .opd section.
+ * ia64 .opd should not point to discarded sections.
+ **/
+static int exit_section_ref_ok(const char *name)
+{
+	const char **s;
+	/* Absolute section names */
+	const char *namelist1[] = {
+		".exit.text",
+		".exit.data",
+		".init.text",
+		".opd", /* See comment [OPD] */
+		".altinstructions",
+		".pdr",
+		".exitcall.exit",
+		".eh_frame",
+		".stab",
+		NULL
+	};
+	/* Start of section names */
+	const char *namelist2[] = {
+		".debug",
+		NULL
+	};
+	
+	for (s = namelist1; *s; s++)
+		if (strcmp(*s, name) == 0)
+			return 1;
+	for (s = namelist2; *s; s++)	
+		if (strncmp(*s, name, strlen(*s)) == 0)
+			return 1;
+	return 0;
+}
+
 static void read_symbols(char *modname)
 {
 	const char *symname;
@@ -476,6 +732,8 @@ static void read_symbols(char *modname)
 		handle_modversions(mod, &info, sym, symname);
 		handle_moddevtable(mod, &info, sym, symname);
 	}
+	check_sec_ref(mod, modname, &info, init_section, init_section_ref_ok);
+	check_sec_ref(mod, modname, &info, exit_section, exit_section_ref_ok);
 
 	version = get_modinfo(info.modinfo, info.modinfo_len, "version");
 	if (version)

commit 8e70c45887a6bbe40393342ea5b426b0dd836dff
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 22:22:33 2006 +0100

    kbuild: warn about duplicate exported symbols
    
    In modpost introduce a check for symbols exported twice.
    This check caught only one victim (inet_bind_bucket_create) for
    which a patch is already sent to netdev.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 976adf152db3..d901095ea8b7 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -117,6 +117,7 @@ struct symbol {
 	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
 	unsigned int kernel:1;     /* 1 if symbol is from kernel
 				    *  (only for external modules) **/
+	unsigned int preloaded:1;  /* 1 if symbol from Module.symvers */
 	char name[0];
 };
 
@@ -186,9 +187,17 @@ static struct symbol *sym_add_exported(const char *name, struct module *mod)
 {
 	struct symbol *s = find_symbol(name);
 
-	if (!s)
+	if (!s) {
 		s = new_symbol(name, mod);
-
+	} else {
+		if (!s->preloaded) {
+			warn("%s: duplicate symbol '%s' previous definition "
+			     "was in %s%s\n", mod->name, name,
+			     s->module->name,
+			     is_vmlinux(s->module->name) ?"":".ko");
+		}
+	}
+	s->preloaded = 0;
 	s->vmlinux   = is_vmlinux(mod->name);
 	s->kernel    = 0;
 	return s;
@@ -706,7 +715,8 @@ static void read_dump(const char *fname, unsigned int kernel)
 			mod->skip = 1;
 		}
 		s = sym_add_exported(symname, mod);
-		s->kernel = kernel;
+		s->kernel    = kernel;
+		s->preloaded = 1;
 		sym_update_crc(symname, mod, crc);
 	}
 	return;

commit 040fcc819a2e7783a570f4bdcdd1f2a7f5f06837
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 22:15:55 2006 +0100

    kbuild: improved modversioning support for external modules
    
    With following patch a second option is enabled to obtain
    symbol information from a second external module when a
    external module is build.
    The recommended approach is to use a common kbuild file but
    that may be impractical in certain cases.
    With this patch one can copy over a Module.symvers from one
    external module to make symbols (and symbol versions) available
    for another external module.
    
    Updated documentation in Documentation/kbuild/modules.txt
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 4a2f2e38d27f..976adf152db3 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -20,6 +20,8 @@ int modversions = 0;
 int have_vmlinux = 0;
 /* Is CONFIG_MODULE_SRCVERSION_ALL set? */
 static int all_versions = 0;
+/* If we are modposting external module set to 1 */
+static int external_module = 0;
 
 void fatal(const char *fmt, ...)
 {
@@ -45,6 +47,18 @@ void warn(const char *fmt, ...)
 	va_end(arglist);
 }
 
+static int is_vmlinux(const char *modname)
+{
+	const char *myname;
+
+	if ((myname = strrchr(modname, '/')))
+		myname++;
+	else
+		myname = modname;
+
+	return strcmp(myname, "vmlinux") == 0;
+}
+
 void *do_nofail(void *ptr, const char *expr)
 {
 	if (!ptr) {
@@ -100,6 +114,9 @@ struct symbol {
 	unsigned int crc;
 	int crc_valid;
 	unsigned int weak:1;
+	unsigned int vmlinux:1;    /* 1 if symbol is defined in vmlinux */
+	unsigned int kernel:1;     /* 1 if symbol is from kernel
+				    *  (only for external modules) **/
 	char name[0];
 };
 
@@ -135,8 +152,7 @@ static struct symbol *alloc_symbol(const char *name, unsigned int weak,
 }
 
 /* For the hash of exported symbols */
-static void new_symbol(const char *name, struct module *module,
-		       unsigned int *crc)
+static struct symbol *new_symbol(const char *name, struct module *module)
 {
 	unsigned int hash;
 	struct symbol *new;
@@ -144,10 +160,7 @@ static void new_symbol(const char *name, struct module *module,
 	hash = tdb_hash(name) % SYMBOL_HASH_SIZE;
 	new = symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);
 	new->module = module;
-	if (crc) {
-		new->crc = *crc;
-		new->crc_valid = 1;
-	}
+	return new;
 }
 
 static struct symbol *find_symbol(const char *name)
@@ -169,19 +182,27 @@ static struct symbol *find_symbol(const char *name)
  * Add an exported symbol - it may have already been added without a
  * CRC, in this case just update the CRC
  **/
-static void add_exported_symbol(const char *name, struct module *module,
-				unsigned int *crc)
+static struct symbol *sym_add_exported(const char *name, struct module *mod)
 {
 	struct symbol *s = find_symbol(name);
 
-	if (!s) {
-		new_symbol(name, module, crc);
-		return;
-	}
-	if (crc) {
-		s->crc = *crc;
-		s->crc_valid = 1;
-	}
+	if (!s)
+		s = new_symbol(name, mod);
+
+	s->vmlinux   = is_vmlinux(mod->name);
+	s->kernel    = 0;
+	return s;
+}
+
+static void sym_update_crc(const char *name, struct module *mod,
+			   unsigned int crc)
+{
+	struct symbol *s = find_symbol(name);
+
+	if (!s)
+		s = new_symbol(name, mod);
+	s->crc = crc;
+	s->crc_valid = 1;
 }
 
 void *grab_file(const char *filename, unsigned long *size)
@@ -332,8 +353,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 		/* CRC'd symbol */
 		if (memcmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
 			crc = (unsigned int) sym->st_value;
-			add_exported_symbol(symname + strlen(CRC_PFX),
-					    mod, &crc);
+			sym_update_crc(symname + strlen(CRC_PFX), mod, crc);
 		}
 		break;
 	case SHN_UNDEF:
@@ -377,8 +397,7 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	default:
 		/* All exported symbols */
 		if (memcmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
-			add_exported_symbol(symname + strlen(KSYMTAB_PFX),
-					    mod, NULL);
+			sym_add_exported(symname + strlen(KSYMTAB_PFX), mod);
 		}
 		if (strcmp(symname, MODULE_SYMBOL_PREFIX "init_module") == 0)
 			mod->has_init = 1;
@@ -388,18 +407,6 @@ static void handle_modversions(struct module *mod, struct elf_info *info,
 	}
 }
 
-static int is_vmlinux(const char *modname)
-{
-	const char *myname;
-
-	if ((myname = strrchr(modname, '/')))
-		myname++;
-	else
-		myname = modname;
-
-	return strcmp(myname, "vmlinux") == 0;
-}
-
 /**
  * Parse tag=value strings from .modinfo section
  **/
@@ -450,9 +457,7 @@ static void read_symbols(char *modname)
 	/* When there's no vmlinux, don't print warnings about
 	 * unresolved symbols (since there'll be too many ;) */
 	if (is_vmlinux(modname)) {
-		unsigned int fake_crc = 0;
 		have_vmlinux = 1;
-		add_exported_symbol("struct_module", mod, &fake_crc);
 		mod->skip = 1;
 	}
 
@@ -665,7 +670,7 @@ static void write_if_changed(struct buffer *b, const char *fname)
 	fclose(file);
 }
 
-static void read_dump(const char *fname)
+static void read_dump(const char *fname, unsigned int kernel)
 {
 	unsigned long size, pos = 0;
 	void *file = grab_file(fname, &size);
@@ -679,6 +684,7 @@ static void read_dump(const char *fname)
 		char *symname, *modname, *d;
 		unsigned int crc;
 		struct module *mod;
+		struct symbol *s;
 
 		if (!(symname = strchr(line, '\t')))
 			goto fail;
@@ -699,13 +705,28 @@ static void read_dump(const char *fname)
 			mod = new_module(NOFAIL(strdup(modname)));
 			mod->skip = 1;
 		}
-		add_exported_symbol(symname, mod, &crc);
+		s = sym_add_exported(symname, mod);
+		s->kernel = kernel;
+		sym_update_crc(symname, mod, crc);
 	}
 	return;
 fail:
 	fatal("parse error in symbol dump file\n");
 }
 
+/* For normal builds always dump all symbols.
+ * For external modules only dump symbols
+ * that are not read from kernel Module.symvers.
+ **/
+static int dump_sym(struct symbol *sym)
+{
+	if (!external_module)
+		return 1;
+	if (sym->vmlinux || sym->kernel)
+		return 0;
+	return 1;
+}
+		
 static void write_dump(const char *fname)
 {
 	struct buffer buf = { };
@@ -715,15 +736,10 @@ static void write_dump(const char *fname)
 	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
 		symbol = symbolhash[n];
 		while (symbol) {
-			symbol = symbol->next;
-		}
-	}
-
-	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
-		symbol = symbolhash[n];
-		while (symbol) {
-			buf_printf(&buf, "0x%08x\t%s\t%s\n", symbol->crc,
-				symbol->name, symbol->module->name);
+			if (dump_sym(symbol))
+				buf_printf(&buf, "0x%08x\t%s\t%s\n",
+					symbol->crc, symbol->name, 
+					symbol->module->name);
 			symbol = symbol->next;
 		}
 	}
@@ -735,13 +751,18 @@ int main(int argc, char **argv)
 	struct module *mod;
 	struct buffer buf = { };
 	char fname[SZ];
-	char *dump_read = NULL, *dump_write = NULL;
+	char *kernel_read = NULL, *module_read = NULL;
+	char *dump_write = NULL;
 	int opt;
 
-	while ((opt = getopt(argc, argv, "i:mo:a")) != -1) {
+	while ((opt = getopt(argc, argv, "i:I:mo:a")) != -1) {
 		switch(opt) {
 			case 'i':
-				dump_read = optarg;
+				kernel_read = optarg;
+				break;
+			case 'I':
+				module_read = optarg;
+				external_module = 1;
 				break;
 			case 'm':
 				modversions = 1;
@@ -757,8 +778,10 @@ int main(int argc, char **argv)
 		}
 	}
 
-	if (dump_read)
-		read_dump(dump_read);
+	if (kernel_read)
+		read_dump(kernel_read, 1);
+	if (module_read)
+		read_dump(module_read, 0);
 
 	while (optind < argc) {
 		read_symbols(argv[optind++]);

commit 5c3ead8c72788d36d34c9f1689fb529d1339b405
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 17:19:35 2006 +0100

    kbuild: apply CodingStyle to modpost.c
    
    Just some light CodingStyle updates - no functional changes.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index a3c57ec7d54a..4a2f2e38d27f 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -21,8 +21,7 @@ int have_vmlinux = 0;
 /* Is CONFIG_MODULE_SRCVERSION_ALL set? */
 static int all_versions = 0;
 
-void
-fatal(const char *fmt, ...)
+void fatal(const char *fmt, ...)
 {
 	va_list arglist;
 
@@ -35,8 +34,7 @@ fatal(const char *fmt, ...)
 	exit(1);
 }
 
-void
-warn(const char *fmt, ...)
+void warn(const char *fmt, ...)
 {
 	va_list arglist;
 
@@ -59,8 +57,7 @@ void *do_nofail(void *ptr, const char *expr)
 
 static struct module *modules;
 
-struct module *
-find_module(char *modname)
+static struct module *find_module(char *modname)
 {
 	struct module *mod;
 
@@ -70,8 +67,7 @@ find_module(char *modname)
 	return mod;
 }
 
-struct module *
-new_module(char *modname)
+static struct module *new_module(char *modname)
 {
 	struct module *mod;
 	char *p, *s;
@@ -122,11 +118,12 @@ static inline unsigned int tdb_hash(const char *name)
 	return (1103515243 * value + 12345);
 }
 
-/* Allocate a new symbols for use in the hash of exported symbols or
- * the list of unresolved symbols per module */
-
-struct symbol *
-alloc_symbol(const char *name, unsigned int weak, struct symbol *next)
+/**
+ * Allocate a new symbols for use in the hash of exported symbols or
+ * the list of unresolved symbols per module
+ **/
+static struct symbol *alloc_symbol(const char *name, unsigned int weak,
+				   struct symbol *next)
 {
 	struct symbol *s = NOFAIL(malloc(sizeof(*s) + strlen(name) + 1));
 
@@ -138,9 +135,8 @@ alloc_symbol(const char *name, unsigned int weak, struct symbol *next)
 }
 
 /* For the hash of exported symbols */
-
-void
-new_symbol(const char *name, struct module *module, unsigned int *crc)
+static void new_symbol(const char *name, struct module *module,
+		       unsigned int *crc)
 {
 	unsigned int hash;
 	struct symbol *new;
@@ -154,8 +150,7 @@ new_symbol(const char *name, struct module *module, unsigned int *crc)
 	}
 }
 
-struct symbol *
-find_symbol(const char *name)
+static struct symbol *find_symbol(const char *name)
 {
 	struct symbol *s;
 
@@ -170,10 +165,12 @@ find_symbol(const char *name)
 	return NULL;
 }
 
-/* Add an exported symbol - it may have already been added without a
- * CRC, in this case just update the CRC */
-void
-add_exported_symbol(const char *name, struct module *module, unsigned int *crc)
+/**
+ * Add an exported symbol - it may have already been added without a
+ * CRC, in this case just update the CRC
+ **/
+static void add_exported_symbol(const char *name, struct module *module,
+				unsigned int *crc)
 {
 	struct symbol *s = find_symbol(name);
 
@@ -187,8 +184,7 @@ add_exported_symbol(const char *name, struct module *module, unsigned int *crc)
 	}
 }
 
-void *
-grab_file(const char *filename, unsigned long *size)
+void *grab_file(const char *filename, unsigned long *size)
 {
 	struct stat st;
 	void *map;
@@ -207,13 +203,12 @@ grab_file(const char *filename, unsigned long *size)
 	return map;
 }
 
-/*
-   Return a copy of the next line in a mmap'ed file.
-   spaces in the beginning of the line is trimmed away.
-   Return a pointer to a static buffer.
-*/
-char*
-get_next_line(unsigned long *pos, void *file, unsigned long size)
+/**
+  * Return a copy of the next line in a mmap'ed file.
+  * spaces in the beginning of the line is trimmed away.
+  * Return a pointer to a static buffer.
+  **/
+char* get_next_line(unsigned long *pos, void *file, unsigned long size)
 {
 	static char line[4096];
 	int skip = 1;
@@ -243,14 +238,12 @@ get_next_line(unsigned long *pos, void *file, unsigned long size)
 	return NULL;
 }
 
-void
-release_file(void *file, unsigned long size)
+void release_file(void *file, unsigned long size)
 {
 	munmap(file, size);
 }
 
-void
-parse_elf(struct elf_info *info, const char *filename)
+static void parse_elf(struct elf_info *info, const char *filename)
 {
 	unsigned int i;
 	Elf_Ehdr *hdr = info->hdr;
@@ -318,8 +311,7 @@ parse_elf(struct elf_info *info, const char *filename)
 	fatal("%s is truncated.\n", filename);
 }
 
-void
-parse_elf_finish(struct elf_info *info)
+static void parse_elf_finish(struct elf_info *info)
 {
 	release_file(info->hdr, info->size);
 }
@@ -327,9 +319,8 @@ parse_elf_finish(struct elf_info *info)
 #define CRC_PFX     "__crc_"
 #define KSYMTAB_PFX "__ksymtab_"
 
-void
-handle_modversions(struct module *mod, struct elf_info *info,
-		   Elf_Sym *sym, const char *symname)
+static void handle_modversions(struct module *mod, struct elf_info *info,
+			       Elf_Sym *sym, const char *symname)
 {
 	unsigned int crc;
 
@@ -397,8 +388,7 @@ handle_modversions(struct module *mod, struct elf_info *info,
 	}
 }
 
-int
-is_vmlinux(const char *modname)
+static int is_vmlinux(const char *modname)
 {
 	const char *myname;
 
@@ -410,7 +400,9 @@ is_vmlinux(const char *modname)
 	return strcmp(myname, "vmlinux") == 0;
 }
 
-/* Parse tag=value strings from .modinfo section */
+/**
+ * Parse tag=value strings from .modinfo section
+ **/
 static char *next_string(char *string, unsigned long *secsize)
 {
 	/* Skip non-zero chars */
@@ -443,8 +435,7 @@ static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
 	return NULL;
 }
 
-void
-read_symbols(char *modname)
+static void read_symbols(char *modname)
 {
 	const char *symname;
 	char *version;
@@ -496,8 +487,8 @@ read_symbols(char *modname)
  * following helper, then compare to the file on disk and
  * only update the later if anything changed */
 
-void __attribute__((format(printf, 2, 3)))
-buf_printf(struct buffer *buf, const char *fmt, ...)
+void __attribute__((format(printf, 2, 3))) buf_printf(struct buffer *buf,
+						      const char *fmt, ...)
 {
 	char tmp[SZ];
 	int len;
@@ -514,8 +505,7 @@ buf_printf(struct buffer *buf, const char *fmt, ...)
 	va_end(ap);
 }
 
-void
-buf_write(struct buffer *buf, const char *s, int len)
+void buf_write(struct buffer *buf, const char *s, int len)
 {
 	if (buf->size - buf->pos < len) {
 		buf->size += len;
@@ -525,10 +515,10 @@ buf_write(struct buffer *buf, const char *s, int len)
 	buf->pos += len;
 }
 
-/* Header for the generated file */
-
-void
-add_header(struct buffer *b, struct module *mod)
+/**
+ * Header for the generated file
+ **/
+static void add_header(struct buffer *b, struct module *mod)
 {
 	buf_printf(b, "#include <linux/module.h>\n");
 	buf_printf(b, "#include <linux/vermagic.h>\n");
@@ -548,10 +538,10 @@ add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "};\n");
 }
 
-/* Record CRCs for unresolved symbols */
-
-void
-add_versions(struct buffer *b, struct module *mod)
+/**
+ * Record CRCs for unresolved symbols
+ **/
+static void add_versions(struct buffer *b, struct module *mod)
 {
 	struct symbol *s, *exp;
 
@@ -591,8 +581,8 @@ add_versions(struct buffer *b, struct module *mod)
 	buf_printf(b, "};\n");
 }
 
-void
-add_depends(struct buffer *b, struct module *mod, struct module *modules)
+static void add_depends(struct buffer *b, struct module *mod,
+			struct module *modules)
 {
 	struct symbol *s;
 	struct module *m;
@@ -622,8 +612,7 @@ add_depends(struct buffer *b, struct module *mod, struct module *modules)
 	buf_printf(b, "\";\n");
 }
 
-void
-add_srcversion(struct buffer *b, struct module *mod)
+static void add_srcversion(struct buffer *b, struct module *mod)
 {
 	if (mod->srcversion[0]) {
 		buf_printf(b, "\n");
@@ -632,8 +621,7 @@ add_srcversion(struct buffer *b, struct module *mod)
 	}
 }
 
-void
-write_if_changed(struct buffer *b, const char *fname)
+static void write_if_changed(struct buffer *b, const char *fname)
 {
 	char *tmp;
 	FILE *file;
@@ -677,8 +665,7 @@ write_if_changed(struct buffer *b, const char *fname)
 	fclose(file);
 }
 
-void
-read_dump(const char *fname)
+static void read_dump(const char *fname)
 {
 	unsigned long size, pos = 0;
 	void *file = grab_file(fname, &size);
@@ -719,8 +706,7 @@ read_dump(const char *fname)
 	fatal("parse error in symbol dump file\n");
 }
 
-void
-write_dump(const char *fname)
+static void write_dump(const char *fname)
 {
 	struct buffer buf = { };
 	struct symbol *symbol;
@@ -744,8 +730,7 @@ write_dump(const char *fname)
 	write_if_changed(&buf, fname);
 }
 
-int
-main(int argc, char **argv)
+int main(int argc, char **argv)
 {
 	struct module *mod;
 	struct buffer buf = { };
@@ -800,4 +785,3 @@ main(int argc, char **argv)
 
 	return 0;
 }
-

commit cb80514d9c517cc1d101ef304529a0e9b76b4468
Author: Sam Ravnborg <sam@mars.ravnborg.org>
Date:   Sat Jan 28 16:57:26 2006 +0100

    kbuild: use warn()/fatal() consistent in modpost
    
    modpost.c provides warn() and fatal() - so use them all over the place.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index f70ff13d4818..a3c57ec7d54a 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -303,8 +303,7 @@ parse_elf(struct elf_info *info, const char *filename)
 			             sechdrs[sechdrs[i].sh_link].sh_offset;
 	}
 	if (!info->symtab_start) {
-		fprintf(stderr, "modpost: %s no symtab?\n", filename);
-		abort();
+		fatal("%s has no symtab?\n", filename);
 	}
 	/* Fix endianness in symbols */
 	for (sym = info->symtab_start; sym < info->symtab_stop; sym++) {
@@ -316,8 +315,7 @@ parse_elf(struct elf_info *info, const char *filename)
 	return;
 
  truncated:
-	fprintf(stderr, "modpost: %s is truncated.\n", filename);
-	abort();
+	fatal("%s is truncated.\n", filename);
 }
 
 void
@@ -337,8 +335,7 @@ handle_modversions(struct module *mod, struct elf_info *info,
 
 	switch (sym->st_shndx) {
 	case SHN_COMMON:
-		fprintf(stderr, "*** Warning: \"%s\" [%s] is COMMON symbol\n",
-			symname, mod->name);
+		warn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);
 		break;
 	case SHN_ABS:
 		/* CRC'd symbol */
@@ -562,8 +559,8 @@ add_versions(struct buffer *b, struct module *mod)
 		exp = find_symbol(s->name);
 		if (!exp || exp->module == mod) {
 			if (have_vmlinux && !s->weak)
-				fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
-				"undefined!\n",	s->name, mod->name);
+				warn("\"%s\" [%s.ko] undefined!\n",
+				     s->name, mod->name);
 			continue;
 		}
 		s->module = exp->module;
@@ -584,8 +581,7 @@ add_versions(struct buffer *b, struct module *mod)
 			continue;
 		}
 		if (!s->crc_valid) {
-			fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
-				"has no CRC!\n",
+			warn("\"%s\" [%s.ko] has no CRC!\n",
 				s->name, mod->name);
 			continue;
 		}

commit f83b5e323f57d6e1f35a839d663e91cebe985e54
Author: Ustyugov Roman <dr_unique@ymg.ru>
Date:   Fri Sep 23 08:42:11 2005 +0400

    kbuild: set correct KBUILD_MODNAME when using well known kernel symbols as module names
    
    This patch fixes a problem when we use well known kernel symbols as module
    names.
    
    For example, if module source name is current.c, idle_stack.c or etc.,
    we have a bad KBUILD_MODNAME value.
    For example, KBUILD_MODNAME will be "get_current()" instead of "current", or
    "(init_thread_union.stack)" instead of "idle_task".
    
    The trick is to define a stringify macro on the commandline - named
    KBUILD_STR for namespace reasons - and then to stringify the module
    name.
    
    There are a few uses of KBUILD_MODNAME throughout the tree but the usage
    is for debug and will not be harmed by this change so left untouched for now.
    
    While at it KBUILD_BASENAME was changed too. Any spinlock usage in the
    unix module would have created wrong section names without it.
    Usage in spinlock.h fixed so it no longer stringify KBUILD_BASENAME.
    
    Original patch from Ustyogov Roman - all bugs introduced by me.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 8ce5a6318684..f70ff13d4818 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -539,10 +539,9 @@ add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "\n");
 	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
 	buf_printf(b, "\n");
-	buf_printf(b, "#undef unix\n"); /* We have a module called "unix" */
 	buf_printf(b, "struct module __this_module\n");
 	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
-	buf_printf(b, " .name = __stringify(KBUILD_MODNAME),\n");
+	buf_printf(b, " .name = KBUILD_MODNAME,\n");
 	if (mod->has_init)
 		buf_printf(b, " .init = init_module,\n");
 	if (mod->has_cleanup)

commit 9572b28faf72859c6b91891c627870cfa282d19d
Author: Luke Yang <luke.adi@gmail.com>
Date:   Wed Dec 21 10:27:23 2005 +0800

    kbuild: Fix crc-error warning on modules
    
       This is the patch for the following issue:
    
     In include/linux/module.h, "__crc_" and "__ksymtab_" are hard
    coded to be the   prefix for some kinds of symbols (CRC symbol and
    ksymtab section). But in script /mod/modpost.c,
    MODULE_SYMBOL_PREFIX##"__crc_" is used as the prefix to search CRC
    symbols. So if an architecture (such as h8300 or Blackfin) defines
    MODULE_SYMBOL_PREFIX as not NULL ("_"), modpost will always warn about
    "no invalid crc".
      And it is the same with KSYMTAB_PFX.
    
    Signed-off-by: Luke Yang <luke.adi@gmail.com>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 3bed09e625c0..8ce5a6318684 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -326,8 +326,8 @@ parse_elf_finish(struct elf_info *info)
 	release_file(info->hdr, info->size);
 }
 
-#define CRC_PFX     MODULE_SYMBOL_PREFIX "__crc_"
-#define KSYMTAB_PFX MODULE_SYMBOL_PREFIX "__ksymtab_"
+#define CRC_PFX     "__crc_"
+#define KSYMTAB_PFX "__ksymtab_"
 
 void
 handle_modversions(struct module *mod, struct elf_info *info,

commit 7caaeabb17758295edff9703c18a840073c5b8f4
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Sep 11 20:14:07 2005 -0700

    [SPARC]: Fix dot-symbol exporting for good.
    
    From: Al Viro <viro@ZenIV.linux.org.uk>
    
    Instead of playing all of these hand-coded assembler aliasing games,
    just translate symbol names in the name space ".sym" to "_Sym" at
    module load time.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 09ffca54b373..3bed09e625c0 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -370,6 +370,12 @@ handle_modversions(struct module *mod, struct elf_info *info,
 			/* Ignore register directives. */
 			if (ELF_ST_TYPE(sym->st_info) == STT_SPARC_REGISTER)
 				break;
+ 			if (symname[0] == '.') {
+ 				char *munged = strdup(symname);
+ 				munged[0] = '_';
+ 				munged[1] = toupper(munged[1]);
+ 				symname = munged;
+ 			}
 		}
 #endif
 		

commit 8d5290149ee1c6a4cea5f5146d64e2a0d48f4988
Author: Ben Colline <bcollins@debian.org>
Date:   Fri Aug 19 13:44:57 2005 -0700

    [SPARC]: Deal with glibc changing macro names in modpost.c
    
    GLIBC 2.3.4 and later changed the STT_REGISTER macro to
    STT_SPARC_REGISTER, so we need to cope with that somehow.
    
    Original patch from fabbione, reposted by Ben Collins.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 9b9f94c915d2..09ffca54b373 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -359,11 +359,16 @@ handle_modversions(struct module *mod, struct elf_info *info,
 		/* ignore __this_module, it will be resolved shortly */
 		if (strcmp(symname, MODULE_SYMBOL_PREFIX "__this_module") == 0)
 			break;
-#ifdef STT_REGISTER
+/* cope with newer glibc (2.3.4 or higher) STT_ definition in elf.h */
+#if defined(STT_REGISTER) || defined(STT_SPARC_REGISTER)
+/* add compatibility with older glibc */
+#ifndef STT_SPARC_REGISTER
+#define STT_SPARC_REGISTER STT_REGISTER
+#endif
 		if (info->hdr->e_machine == EM_SPARC ||
 		    info->hdr->e_machine == EM_SPARCV9) {
 			/* Ignore register directives. */
-			if (ELF_ST_TYPE(sym->st_info) == STT_REGISTER)
+			if (ELF_ST_TYPE(sym->st_info) == STT_SPARC_REGISTER)
 				break;
 		}
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
new file mode 100644
index 000000000000..9b9f94c915d2
--- /dev/null
+++ b/scripts/mod/modpost.c
@@ -0,0 +1,797 @@
+/* Postprocess module symbol versions
+ *
+ * Copyright 2003       Kai Germaschewski
+ * Copyright 2002-2004  Rusty Russell, IBM Corporation
+ *
+ * Based in part on module-init-tools/depmod.c,file2alias
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
+ *
+ * Usage: modpost vmlinux module1.o module2.o ...
+ */
+
+#include <ctype.h>
+#include "modpost.h"
+
+/* Are we using CONFIG_MODVERSIONS? */
+int modversions = 0;
+/* Warn about undefined symbols? (do so if we have vmlinux) */
+int have_vmlinux = 0;
+/* Is CONFIG_MODULE_SRCVERSION_ALL set? */
+static int all_versions = 0;
+
+void
+fatal(const char *fmt, ...)
+{
+	va_list arglist;
+
+	fprintf(stderr, "FATAL: ");
+
+	va_start(arglist, fmt);
+	vfprintf(stderr, fmt, arglist);
+	va_end(arglist);
+
+	exit(1);
+}
+
+void
+warn(const char *fmt, ...)
+{
+	va_list arglist;
+
+	fprintf(stderr, "WARNING: ");
+
+	va_start(arglist, fmt);
+	vfprintf(stderr, fmt, arglist);
+	va_end(arglist);
+}
+
+void *do_nofail(void *ptr, const char *expr)
+{
+	if (!ptr) {
+		fatal("modpost: Memory allocation failure: %s.\n", expr);
+	}
+	return ptr;
+}
+
+/* A list of all modules we processed */
+
+static struct module *modules;
+
+struct module *
+find_module(char *modname)
+{
+	struct module *mod;
+
+	for (mod = modules; mod; mod = mod->next)
+		if (strcmp(mod->name, modname) == 0)
+			break;
+	return mod;
+}
+
+struct module *
+new_module(char *modname)
+{
+	struct module *mod;
+	char *p, *s;
+	
+	mod = NOFAIL(malloc(sizeof(*mod)));
+	memset(mod, 0, sizeof(*mod));
+	p = NOFAIL(strdup(modname));
+
+	/* strip trailing .o */
+	if ((s = strrchr(p, '.')) != NULL)
+		if (strcmp(s, ".o") == 0)
+			*s = '\0';
+
+	/* add to list */
+	mod->name = p;
+	mod->next = modules;
+	modules = mod;
+
+	return mod;
+}
+
+/* A hash of all exported symbols,
+ * struct symbol is also used for lists of unresolved symbols */
+
+#define SYMBOL_HASH_SIZE 1024
+
+struct symbol {
+	struct symbol *next;
+	struct module *module;
+	unsigned int crc;
+	int crc_valid;
+	unsigned int weak:1;
+	char name[0];
+};
+
+static struct symbol *symbolhash[SYMBOL_HASH_SIZE];
+
+/* This is based on the hash agorithm from gdbm, via tdb */
+static inline unsigned int tdb_hash(const char *name)
+{
+	unsigned value;	/* Used to compute the hash value.  */
+	unsigned   i;	/* Used to cycle through random values. */
+
+	/* Set the initial value from the key size. */
+	for (value = 0x238F13AF * strlen(name), i=0; name[i]; i++)
+		value = (value + (((unsigned char *)name)[i] << (i*5 % 24)));
+
+	return (1103515243 * value + 12345);
+}
+
+/* Allocate a new symbols for use in the hash of exported symbols or
+ * the list of unresolved symbols per module */
+
+struct symbol *
+alloc_symbol(const char *name, unsigned int weak, struct symbol *next)
+{
+	struct symbol *s = NOFAIL(malloc(sizeof(*s) + strlen(name) + 1));
+
+	memset(s, 0, sizeof(*s));
+	strcpy(s->name, name);
+	s->weak = weak;
+	s->next = next;
+	return s;
+}
+
+/* For the hash of exported symbols */
+
+void
+new_symbol(const char *name, struct module *module, unsigned int *crc)
+{
+	unsigned int hash;
+	struct symbol *new;
+
+	hash = tdb_hash(name) % SYMBOL_HASH_SIZE;
+	new = symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);
+	new->module = module;
+	if (crc) {
+		new->crc = *crc;
+		new->crc_valid = 1;
+	}
+}
+
+struct symbol *
+find_symbol(const char *name)
+{
+	struct symbol *s;
+
+	/* For our purposes, .foo matches foo.  PPC64 needs this. */
+	if (name[0] == '.')
+		name++;
+
+	for (s = symbolhash[tdb_hash(name) % SYMBOL_HASH_SIZE]; s; s=s->next) {
+		if (strcmp(s->name, name) == 0)
+			return s;
+	}
+	return NULL;
+}
+
+/* Add an exported symbol - it may have already been added without a
+ * CRC, in this case just update the CRC */
+void
+add_exported_symbol(const char *name, struct module *module, unsigned int *crc)
+{
+	struct symbol *s = find_symbol(name);
+
+	if (!s) {
+		new_symbol(name, module, crc);
+		return;
+	}
+	if (crc) {
+		s->crc = *crc;
+		s->crc_valid = 1;
+	}
+}
+
+void *
+grab_file(const char *filename, unsigned long *size)
+{
+	struct stat st;
+	void *map;
+	int fd;
+
+	fd = open(filename, O_RDONLY);
+	if (fd < 0 || fstat(fd, &st) != 0)
+		return NULL;
+
+	*size = st.st_size;
+	map = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
+	close(fd);
+
+	if (map == MAP_FAILED)
+		return NULL;
+	return map;
+}
+
+/*
+   Return a copy of the next line in a mmap'ed file.
+   spaces in the beginning of the line is trimmed away.
+   Return a pointer to a static buffer.
+*/
+char*
+get_next_line(unsigned long *pos, void *file, unsigned long size)
+{
+	static char line[4096];
+	int skip = 1;
+	size_t len = 0;
+	signed char *p = (signed char *)file + *pos;
+	char *s = line;
+
+	for (; *pos < size ; (*pos)++)
+	{
+		if (skip && isspace(*p)) {
+			p++;
+			continue;
+		}
+		skip = 0;
+		if (*p != '\n' && (*pos < size)) {
+			len++;
+			*s++ = *p++;
+			if (len > 4095)
+				break; /* Too long, stop */
+		} else {
+			/* End of string */
+			*s = '\0';
+			return line;
+		}
+	}
+	/* End of buffer */
+	return NULL;
+}
+
+void
+release_file(void *file, unsigned long size)
+{
+	munmap(file, size);
+}
+
+void
+parse_elf(struct elf_info *info, const char *filename)
+{
+	unsigned int i;
+	Elf_Ehdr *hdr = info->hdr;
+	Elf_Shdr *sechdrs;
+	Elf_Sym  *sym;
+
+	hdr = grab_file(filename, &info->size);
+	if (!hdr) {
+		perror(filename);
+		abort();
+	}
+	info->hdr = hdr;
+	if (info->size < sizeof(*hdr))
+		goto truncated;
+
+	/* Fix endianness in ELF header */
+	hdr->e_shoff    = TO_NATIVE(hdr->e_shoff);
+	hdr->e_shstrndx = TO_NATIVE(hdr->e_shstrndx);
+	hdr->e_shnum    = TO_NATIVE(hdr->e_shnum);
+	hdr->e_machine  = TO_NATIVE(hdr->e_machine);
+	sechdrs = (void *)hdr + hdr->e_shoff;
+	info->sechdrs = sechdrs;
+
+	/* Fix endianness in section headers */
+	for (i = 0; i < hdr->e_shnum; i++) {
+		sechdrs[i].sh_type   = TO_NATIVE(sechdrs[i].sh_type);
+		sechdrs[i].sh_offset = TO_NATIVE(sechdrs[i].sh_offset);
+		sechdrs[i].sh_size   = TO_NATIVE(sechdrs[i].sh_size);
+		sechdrs[i].sh_link   = TO_NATIVE(sechdrs[i].sh_link);
+		sechdrs[i].sh_name   = TO_NATIVE(sechdrs[i].sh_name);
+	}
+	/* Find symbol table. */
+	for (i = 1; i < hdr->e_shnum; i++) {
+		const char *secstrings
+			= (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
+
+		if (sechdrs[i].sh_offset > info->size)
+			goto truncated;
+		if (strcmp(secstrings+sechdrs[i].sh_name, ".modinfo") == 0) {
+			info->modinfo = (void *)hdr + sechdrs[i].sh_offset;
+			info->modinfo_len = sechdrs[i].sh_size;
+		}
+		if (sechdrs[i].sh_type != SHT_SYMTAB)
+			continue;
+
+		info->symtab_start = (void *)hdr + sechdrs[i].sh_offset;
+		info->symtab_stop  = (void *)hdr + sechdrs[i].sh_offset 
+			                         + sechdrs[i].sh_size;
+		info->strtab       = (void *)hdr + 
+			             sechdrs[sechdrs[i].sh_link].sh_offset;
+	}
+	if (!info->symtab_start) {
+		fprintf(stderr, "modpost: %s no symtab?\n", filename);
+		abort();
+	}
+	/* Fix endianness in symbols */
+	for (sym = info->symtab_start; sym < info->symtab_stop; sym++) {
+		sym->st_shndx = TO_NATIVE(sym->st_shndx);
+		sym->st_name  = TO_NATIVE(sym->st_name);
+		sym->st_value = TO_NATIVE(sym->st_value);
+		sym->st_size  = TO_NATIVE(sym->st_size);
+	}
+	return;
+
+ truncated:
+	fprintf(stderr, "modpost: %s is truncated.\n", filename);
+	abort();
+}
+
+void
+parse_elf_finish(struct elf_info *info)
+{
+	release_file(info->hdr, info->size);
+}
+
+#define CRC_PFX     MODULE_SYMBOL_PREFIX "__crc_"
+#define KSYMTAB_PFX MODULE_SYMBOL_PREFIX "__ksymtab_"
+
+void
+handle_modversions(struct module *mod, struct elf_info *info,
+		   Elf_Sym *sym, const char *symname)
+{
+	unsigned int crc;
+
+	switch (sym->st_shndx) {
+	case SHN_COMMON:
+		fprintf(stderr, "*** Warning: \"%s\" [%s] is COMMON symbol\n",
+			symname, mod->name);
+		break;
+	case SHN_ABS:
+		/* CRC'd symbol */
+		if (memcmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {
+			crc = (unsigned int) sym->st_value;
+			add_exported_symbol(symname + strlen(CRC_PFX),
+					    mod, &crc);
+		}
+		break;
+	case SHN_UNDEF:
+		/* undefined symbol */
+		if (ELF_ST_BIND(sym->st_info) != STB_GLOBAL &&
+		    ELF_ST_BIND(sym->st_info) != STB_WEAK)
+			break;
+		/* ignore global offset table */
+		if (strcmp(symname, "_GLOBAL_OFFSET_TABLE_") == 0)
+			break;
+		/* ignore __this_module, it will be resolved shortly */
+		if (strcmp(symname, MODULE_SYMBOL_PREFIX "__this_module") == 0)
+			break;
+#ifdef STT_REGISTER
+		if (info->hdr->e_machine == EM_SPARC ||
+		    info->hdr->e_machine == EM_SPARCV9) {
+			/* Ignore register directives. */
+			if (ELF_ST_TYPE(sym->st_info) == STT_REGISTER)
+				break;
+		}
+#endif
+		
+		if (memcmp(symname, MODULE_SYMBOL_PREFIX,
+			   strlen(MODULE_SYMBOL_PREFIX)) == 0)
+			mod->unres = alloc_symbol(symname +
+						  strlen(MODULE_SYMBOL_PREFIX),
+						  ELF_ST_BIND(sym->st_info) == STB_WEAK,
+						  mod->unres);
+		break;
+	default:
+		/* All exported symbols */
+		if (memcmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {
+			add_exported_symbol(symname + strlen(KSYMTAB_PFX),
+					    mod, NULL);
+		}
+		if (strcmp(symname, MODULE_SYMBOL_PREFIX "init_module") == 0)
+			mod->has_init = 1;
+		if (strcmp(symname, MODULE_SYMBOL_PREFIX "cleanup_module") == 0)
+			mod->has_cleanup = 1;
+		break;
+	}
+}
+
+int
+is_vmlinux(const char *modname)
+{
+	const char *myname;
+
+	if ((myname = strrchr(modname, '/')))
+		myname++;
+	else
+		myname = modname;
+
+	return strcmp(myname, "vmlinux") == 0;
+}
+
+/* Parse tag=value strings from .modinfo section */
+static char *next_string(char *string, unsigned long *secsize)
+{
+	/* Skip non-zero chars */
+	while (string[0]) {
+		string++;
+		if ((*secsize)-- <= 1)
+			return NULL;
+	}
+
+	/* Skip any zero padding. */
+	while (!string[0]) {
+		string++;
+		if ((*secsize)-- <= 1)
+			return NULL;
+	}
+	return string;
+}
+
+static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
+			 const char *tag)
+{
+	char *p;
+	unsigned int taglen = strlen(tag);
+	unsigned long size = modinfo_len;
+
+	for (p = modinfo; p; p = next_string(p, &size)) {
+		if (strncmp(p, tag, taglen) == 0 && p[taglen] == '=')
+			return p + taglen + 1;
+	}
+	return NULL;
+}
+
+void
+read_symbols(char *modname)
+{
+	const char *symname;
+	char *version;
+	struct module *mod;
+	struct elf_info info = { };
+	Elf_Sym *sym;
+
+	parse_elf(&info, modname);
+
+	mod = new_module(modname);
+
+	/* When there's no vmlinux, don't print warnings about
+	 * unresolved symbols (since there'll be too many ;) */
+	if (is_vmlinux(modname)) {
+		unsigned int fake_crc = 0;
+		have_vmlinux = 1;
+		add_exported_symbol("struct_module", mod, &fake_crc);
+		mod->skip = 1;
+	}
+
+	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
+		symname = info.strtab + sym->st_name;
+
+		handle_modversions(mod, &info, sym, symname);
+		handle_moddevtable(mod, &info, sym, symname);
+	}
+
+	version = get_modinfo(info.modinfo, info.modinfo_len, "version");
+	if (version)
+		maybe_frob_rcs_version(modname, version, info.modinfo,
+				       version - (char *)info.hdr);
+	if (version || (all_versions && !is_vmlinux(modname)))
+		get_src_version(modname, mod->srcversion,
+				sizeof(mod->srcversion)-1);
+
+	parse_elf_finish(&info);
+
+	/* Our trick to get versioning for struct_module - it's
+	 * never passed as an argument to an exported function, so
+	 * the automatic versioning doesn't pick it up, but it's really
+	 * important anyhow */
+	if (modversions)
+		mod->unres = alloc_symbol("struct_module", 0, mod->unres);
+}
+
+#define SZ 500
+
+/* We first write the generated file into memory using the
+ * following helper, then compare to the file on disk and
+ * only update the later if anything changed */
+
+void __attribute__((format(printf, 2, 3)))
+buf_printf(struct buffer *buf, const char *fmt, ...)
+{
+	char tmp[SZ];
+	int len;
+	va_list ap;
+	
+	va_start(ap, fmt);
+	len = vsnprintf(tmp, SZ, fmt, ap);
+	if (buf->size - buf->pos < len + 1) {
+		buf->size += 128;
+		buf->p = realloc(buf->p, buf->size);
+	}
+	strncpy(buf->p + buf->pos, tmp, len + 1);
+	buf->pos += len;
+	va_end(ap);
+}
+
+void
+buf_write(struct buffer *buf, const char *s, int len)
+{
+	if (buf->size - buf->pos < len) {
+		buf->size += len;
+		buf->p = realloc(buf->p, buf->size);
+	}
+	strncpy(buf->p + buf->pos, s, len);
+	buf->pos += len;
+}
+
+/* Header for the generated file */
+
+void
+add_header(struct buffer *b, struct module *mod)
+{
+	buf_printf(b, "#include <linux/module.h>\n");
+	buf_printf(b, "#include <linux/vermagic.h>\n");
+	buf_printf(b, "#include <linux/compiler.h>\n");
+	buf_printf(b, "\n");
+	buf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");
+	buf_printf(b, "\n");
+	buf_printf(b, "#undef unix\n"); /* We have a module called "unix" */
+	buf_printf(b, "struct module __this_module\n");
+	buf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");
+	buf_printf(b, " .name = __stringify(KBUILD_MODNAME),\n");
+	if (mod->has_init)
+		buf_printf(b, " .init = init_module,\n");
+	if (mod->has_cleanup)
+		buf_printf(b, "#ifdef CONFIG_MODULE_UNLOAD\n"
+			      " .exit = cleanup_module,\n"
+			      "#endif\n");
+	buf_printf(b, "};\n");
+}
+
+/* Record CRCs for unresolved symbols */
+
+void
+add_versions(struct buffer *b, struct module *mod)
+{
+	struct symbol *s, *exp;
+
+	for (s = mod->unres; s; s = s->next) {
+		exp = find_symbol(s->name);
+		if (!exp || exp->module == mod) {
+			if (have_vmlinux && !s->weak)
+				fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
+				"undefined!\n",	s->name, mod->name);
+			continue;
+		}
+		s->module = exp->module;
+		s->crc_valid = exp->crc_valid;
+		s->crc = exp->crc;
+	}
+
+	if (!modversions)
+		return;
+
+	buf_printf(b, "\n");
+	buf_printf(b, "static const struct modversion_info ____versions[]\n");
+	buf_printf(b, "__attribute_used__\n");
+	buf_printf(b, "__attribute__((section(\"__versions\"))) = {\n");
+
+	for (s = mod->unres; s; s = s->next) {
+		if (!s->module) {
+			continue;
+		}
+		if (!s->crc_valid) {
+			fprintf(stderr, "*** Warning: \"%s\" [%s.ko] "
+				"has no CRC!\n",
+				s->name, mod->name);
+			continue;
+		}
+		buf_printf(b, "\t{ %#8x, \"%s\" },\n", s->crc, s->name);
+	}
+
+	buf_printf(b, "};\n");
+}
+
+void
+add_depends(struct buffer *b, struct module *mod, struct module *modules)
+{
+	struct symbol *s;
+	struct module *m;
+	int first = 1;
+
+	for (m = modules; m; m = m->next) {
+		m->seen = is_vmlinux(m->name);
+	}
+
+	buf_printf(b, "\n");
+	buf_printf(b, "static const char __module_depends[]\n");
+	buf_printf(b, "__attribute_used__\n");
+	buf_printf(b, "__attribute__((section(\".modinfo\"))) =\n");
+	buf_printf(b, "\"depends=");
+	for (s = mod->unres; s; s = s->next) {
+		if (!s->module)
+			continue;
+
+		if (s->module->seen)
+			continue;
+
+		s->module->seen = 1;
+		buf_printf(b, "%s%s", first ? "" : ",",
+			   strrchr(s->module->name, '/') + 1);
+		first = 0;
+	}
+	buf_printf(b, "\";\n");
+}
+
+void
+add_srcversion(struct buffer *b, struct module *mod)
+{
+	if (mod->srcversion[0]) {
+		buf_printf(b, "\n");
+		buf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",
+			   mod->srcversion);
+	}
+}
+
+void
+write_if_changed(struct buffer *b, const char *fname)
+{
+	char *tmp;
+	FILE *file;
+	struct stat st;
+
+	file = fopen(fname, "r");
+	if (!file)
+		goto write;
+
+	if (fstat(fileno(file), &st) < 0)
+		goto close_write;
+
+	if (st.st_size != b->pos)
+		goto close_write;
+
+	tmp = NOFAIL(malloc(b->pos));
+	if (fread(tmp, 1, b->pos, file) != b->pos)
+		goto free_write;
+
+	if (memcmp(tmp, b->p, b->pos) != 0)
+		goto free_write;
+
+	free(tmp);
+	fclose(file);
+	return;
+
+ free_write:
+	free(tmp);
+ close_write:
+	fclose(file);
+ write:
+	file = fopen(fname, "w");
+	if (!file) {
+		perror(fname);
+		exit(1);
+	}
+	if (fwrite(b->p, 1, b->pos, file) != b->pos) {
+		perror(fname);
+		exit(1);
+	}
+	fclose(file);
+}
+
+void
+read_dump(const char *fname)
+{
+	unsigned long size, pos = 0;
+	void *file = grab_file(fname, &size);
+	char *line;
+
+        if (!file)
+		/* No symbol versions, silently ignore */
+		return;
+
+	while ((line = get_next_line(&pos, file, size))) {
+		char *symname, *modname, *d;
+		unsigned int crc;
+		struct module *mod;
+
+		if (!(symname = strchr(line, '\t')))
+			goto fail;
+		*symname++ = '\0';
+		if (!(modname = strchr(symname, '\t')))
+			goto fail;
+		*modname++ = '\0';
+		if (strchr(modname, '\t'))
+			goto fail;
+		crc = strtoul(line, &d, 16);
+		if (*symname == '\0' || *modname == '\0' || *d != '\0')
+			goto fail;
+
+		if (!(mod = find_module(modname))) {
+			if (is_vmlinux(modname)) {
+				have_vmlinux = 1;
+			}
+			mod = new_module(NOFAIL(strdup(modname)));
+			mod->skip = 1;
+		}
+		add_exported_symbol(symname, mod, &crc);
+	}
+	return;
+fail:
+	fatal("parse error in symbol dump file\n");
+}
+
+void
+write_dump(const char *fname)
+{
+	struct buffer buf = { };
+	struct symbol *symbol;
+	int n;
+
+	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
+		symbol = symbolhash[n];
+		while (symbol) {
+			symbol = symbol->next;
+		}
+	}
+
+	for (n = 0; n < SYMBOL_HASH_SIZE ; n++) {
+		symbol = symbolhash[n];
+		while (symbol) {
+			buf_printf(&buf, "0x%08x\t%s\t%s\n", symbol->crc,
+				symbol->name, symbol->module->name);
+			symbol = symbol->next;
+		}
+	}
+	write_if_changed(&buf, fname);
+}
+
+int
+main(int argc, char **argv)
+{
+	struct module *mod;
+	struct buffer buf = { };
+	char fname[SZ];
+	char *dump_read = NULL, *dump_write = NULL;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "i:mo:a")) != -1) {
+		switch(opt) {
+			case 'i':
+				dump_read = optarg;
+				break;
+			case 'm':
+				modversions = 1;
+				break;
+			case 'o':
+				dump_write = optarg;
+				break;
+			case 'a':
+				all_versions = 1;
+				break;
+			default:
+				exit(1);
+		}
+	}
+
+	if (dump_read)
+		read_dump(dump_read);
+
+	while (optind < argc) {
+		read_symbols(argv[optind++]);
+	}
+
+	for (mod = modules; mod; mod = mod->next) {
+		if (mod->skip)
+			continue;
+
+		buf.pos = 0;
+
+		add_header(&buf, mod);
+		add_versions(&buf, mod);
+		add_depends(&buf, mod, modules);
+		add_moddevtable(&buf, mod);
+		add_srcversion(&buf, mod);
+
+		sprintf(fname, "%s.mod.c", mod->name);
+		write_if_changed(&buf, fname);
+	}
+
+	if (dump_write)
+		write_dump(dump_write);
+
+	return 0;
+}
+
