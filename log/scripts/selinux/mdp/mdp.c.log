commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index 18fd6143888b..576d11a60417 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *
  * mdp - make dummy policy
@@ -5,20 +6,6 @@
  * When pointed at a kernel tree, builds a dummy policy for that kernel
  * with exactly one type with full rights to itself.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  * Copyright (C) IBM Corporation, 2006
  *
  * Authors: Serge E. Hallyn <serue@us.ibm.com>

commit ff1bf4c0714e7936330bb316090a75eaa35061e7
Author: Paulo Alcantara <paulo@paulo.ac>
Date:   Sun Feb 24 21:55:28 2019 -0300

    selinux: use kernel linux/socket.h for genheaders and mdp
    
    When compiling genheaders and mdp from a newer host kernel, the
    following error happens:
    
        In file included from scripts/selinux/genheaders/genheaders.c:18:
        ./security/selinux/include/classmap.h:238:2: error: #error New
        address family defined, please update secclass_map.  #error New
        address family defined, please update secclass_map.  ^~~~~
        make[3]: *** [scripts/Makefile.host:107:
        scripts/selinux/genheaders/genheaders] Error 1 make[2]: ***
        [scripts/Makefile.build:599: scripts/selinux/genheaders] Error 2
        make[1]: *** [scripts/Makefile.build:599: scripts/selinux] Error 2
        make[1]: *** Waiting for unfinished jobs....
    
    Instead of relying on the host definition, include linux/socket.h in
    classmap.h to have PF_MAX.
    
    Signed-off-by: Paulo Alcantara <paulo@paulo.ac>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    [PM: manually merge in mdp.c, subject line tweaks]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index edaba8e51651..18fd6143888b 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -32,7 +32,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
-#include <sys/socket.h>
 #include <linux/kconfig.h>
 
 static void usage(char *name)

commit e37c1877ba5b17d4251e1688449f8d43fc090802
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Thu Feb 21 16:31:47 2019 -0500

    scripts/selinux: modernize mdp
    
    Derived in part from a patch by Dominick Grift.
    
    The MDP example no longer works on modern systems.  Fix it.
    While we are at it, add MLS support and enable it.
    
    NB This still does not work on systems using dbus-daemon instead of
    dbus-broker because dbus-daemon does not yet gracefully handle unknown
    classes/permissions.  This appears to be a deficiency in libselinux's
    selinux_set_mapping() interface and underlying implementation,
    which was never fully updated to deal with unknown classes/permissions
    unlike the kernel.  The same problem also occurs with XSELinux.
    Programs that instead use selinux_check_access() like dbus-broker
    should not have this problem.
    
    Changes to mdp:
    Add support for devtmpfs, required by modern Linux distributions.
    Add MLS support, with sample sensitivities, categories, and constraints.
    Generate fs_use and genfscon rules based on kernel configuration.
    Update list of filesystem types for fs_use and genfscon rules.
    Use object_r for object contexts.
    
    Changes to install_policy.sh:
    Bail immediately on any errors.
    Provide more helpful error messages when unable to find userspace tools.
    Refuse to run if SELinux is already enabled.
    Unconditionally move aside /etc/selinux/config and create a new one.
    Build policy with -U allow so that userspace object managers do not break.
    Build policy with MLS enabled by default.
    Create seusers, failsafe_context, and default_contexts for use by
    pam_selinux / libselinux.
    Create x_contexts for the SELinux X extension.
    Create virtual_domain_context and virtual_image_context for libvirtd.
    Set to permissive mode rather than enforcing to permit initial autorelabel.
    Update the list of filesystem types to be relabeled.
    Write -F to /.autorelabel to cause a forced autorelabel on reboot.
    Drop broken attempt to relabel the /dev mountpoint directory.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Acked-by: Dominick Grift <dominick.grift@defensec.nl>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index 073fe7537f6c..edaba8e51651 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -33,6 +33,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <sys/socket.h>
+#include <linux/kconfig.h>
 
 static void usage(char *name)
 {
@@ -95,10 +96,31 @@ int main(int argc, char *argv[])
 	}
 	fprintf(fout, "\n");
 
-	/* NOW PRINT OUT MLS STUFF */
+	/* print out mls declarations and constraints */
 	if (mls) {
-		printf("MLS not yet implemented\n");
-		exit(1);
+		fprintf(fout, "sensitivity s0;\n");
+		fprintf(fout, "sensitivity s1;\n");
+		fprintf(fout, "dominance { s0 s1 }\n");
+		fprintf(fout, "category c0;\n");
+		fprintf(fout, "category c1;\n");
+		fprintf(fout, "level s0:c0.c1;\n");
+		fprintf(fout, "level s1:c0.c1;\n");
+#define SYSTEMLOW "s0"
+#define SYSTEMHIGH "s1:c0.c1"
+		for (i = 0; secclass_map[i].name; i++) {
+			struct security_class_mapping *map = &secclass_map[i];
+
+			fprintf(fout, "mlsconstrain %s {\n", map->name);
+			for (j = 0; map->perms[j]; j++)
+				fprintf(fout, "\t%s\n", map->perms[j]);
+			/*
+			 * This requires all subjects and objects to be
+			 * single-level (l2 eq h2), and that the subject
+			 * level dominate the object level (h1 dom h2)
+			 * in order to have any permissions to it.
+			 */
+			fprintf(fout, "} (l2 eq h2 and h1 dom h2);\n\n");
+		}
 	}
 
 	/* types, roles, and allows */
@@ -108,34 +130,127 @@ int main(int argc, char *argv[])
 	for (i = 0; secclass_map[i].name; i++)
 		fprintf(fout, "allow base_t base_t:%s *;\n",
 			secclass_map[i].name);
-	fprintf(fout, "user user_u roles { base_r };\n");
-	fprintf(fout, "\n");
+	fprintf(fout, "user user_u roles { base_r }");
+	if (mls)
+		fprintf(fout, " level %s range %s - %s", SYSTEMLOW,
+			SYSTEMLOW, SYSTEMHIGH);
+	fprintf(fout, ";\n");
+
+#define SUBJUSERROLETYPE "user_u:base_r:base_t"
+#define OBJUSERROLETYPE "user_u:object_r:base_t"
 
 	/* default sids */
 	for (i = 1; i < initial_sid_to_string_len; i++)
-		fprintf(fout, "sid %s user_u:base_r:base_t\n", initial_sid_to_string[i]);
+		fprintf(fout, "sid %s " SUBJUSERROLETYPE "%s\n",
+			initial_sid_to_string[i], mls ? ":" SYSTEMLOW : "");
 	fprintf(fout, "\n");
 
-	fprintf(fout, "fs_use_xattr ext2 user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr ext3 user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr ext4 user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr jfs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr xfs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr reiserfs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr jffs2 user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr gfs2 user_u:base_r:base_t;\n");
+#define FS_USE(behavior, fstype)			    \
+	fprintf(fout, "fs_use_%s %s " OBJUSERROLETYPE "%s;\n", \
+		behavior, fstype, mls ? ":" SYSTEMLOW : "")
+
+	/*
+	 * Filesystems whose inode labels can be fetched via getxattr.
+	 */
+#ifdef CONFIG_EXT2_FS_SECURITY
+	FS_USE("xattr", "ext2");
+#endif
+#ifdef CONFIG_EXT4_FS_SECURITY
+#ifdef CONFIG_EXT4_USE_FOR_EXT2
+	FS_USE("xattr", "ext2");
+#endif
+	FS_USE("xattr", "ext3");
+	FS_USE("xattr", "ext4");
+#endif
+#ifdef CONFIG_JFS_SECURITY
+	FS_USE("xattr", "jfs");
+#endif
+#ifdef CONFIG_REISERFS_FS_SECURITY
+	FS_USE("xattr", "reiserfs");
+#endif
+#ifdef CONFIG_JFFS2_FS_SECURITY
+	FS_USE("xattr", "jffs2");
+#endif
+#ifdef CONFIG_XFS_FS
+	FS_USE("xattr", "xfs");
+#endif
+#ifdef CONFIG_GFS2_FS
+	FS_USE("xattr", "gfs2");
+#endif
+#ifdef CONFIG_BTRFS_FS
+	FS_USE("xattr", "btrfs");
+#endif
+#ifdef CONFIG_F2FS_FS_SECURITY
+	FS_USE("xattr", "f2fs");
+#endif
+#ifdef CONFIG_OCFS2_FS
+	FS_USE("xattr", "ocsfs2");
+#endif
+#ifdef CONFIG_OVERLAY_FS
+	FS_USE("xattr", "overlay");
+#endif
+#ifdef CONFIG_SQUASHFS_XATTR
+	FS_USE("xattr", "squashfs");
+#endif
+
+	/*
+	 * Filesystems whose inodes are labeled from allocating task.
+	 */
+	FS_USE("task", "pipefs");
+	FS_USE("task", "sockfs");
 
-	fprintf(fout, "fs_use_task eventpollfs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_task pipefs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_task sockfs user_u:base_r:base_t;\n");
+	/*
+	 * Filesystems whose inode labels are computed from both
+	 * the allocating task and the superblock label.
+	 */
+#ifdef CONFIG_UNIX98_PTYS
+	FS_USE("trans", "devpts");
+#endif
+#ifdef CONFIG_HUGETLBFS
+	FS_USE("trans", "hugetlbfs");
+#endif
+#ifdef CONFIG_TMPFS
+	FS_USE("trans", "tmpfs");
+#endif
+#ifdef CONFIG_DEVTMPFS
+	FS_USE("trans", "devtmpfs");
+#endif
+#ifdef CONFIG_POSIX_MQUEUE
+	FS_USE("trans", "mqueue");
+#endif
 
-	fprintf(fout, "fs_use_trans mqueue user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_trans devpts user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_trans hugetlbfs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_trans tmpfs user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_trans shm user_u:base_r:base_t;\n");
+#define GENFSCON(fstype, prefix)			     \
+	fprintf(fout, "genfscon %s %s " OBJUSERROLETYPE "%s\n", \
+		fstype, prefix, mls ? ":" SYSTEMLOW : "")
 
-	fprintf(fout, "genfscon proc / user_u:base_r:base_t\n");
+	/*
+	 * Filesystems whose inodes are labeled from path prefix match
+	 * relative to the filesystem root.  Depending on the filesystem,
+	 * only a single label for all inodes may be supported.  Here
+	 * we list the filesystem types for which per-file labeling is
+	 * supported using genfscon; any other filesystem type can also
+	 * be added by only with a single entry for all of its inodes.
+	 */
+#ifdef CONFIG_PROC_FS
+	GENFSCON("proc", "/");
+#endif
+#ifdef CONFIG_SECURITY_SELINUX
+	GENFSCON("selinuxfs", "/");
+#endif
+#ifdef CONFIG_SYSFS
+	GENFSCON("sysfs", "/");
+#endif
+#ifdef CONFIG_DEBUG_FS
+	GENFSCON("debugfs", "/");
+#endif
+#ifdef CONFIG_TRACING
+	GENFSCON("tracefs", "/");
+#endif
+#ifdef CONFIG_PSTORE
+	GENFSCON("pstore", "/");
+#endif
+	GENFSCON("cgroup", "/");
+	GENFSCON("cgroup2", "/");
 
 	fclose(fout);
 
@@ -144,8 +259,8 @@ int main(int argc, char *argv[])
 		printf("Wrote policy, but cannot open %s for writing\n", ctxout);
 		usage(argv[0]);
 	}
-	fprintf(fout, "/ user_u:base_r:base_t\n");
-	fprintf(fout, "/.* user_u:base_r:base_t\n");
+	fprintf(fout, "/ " OBJUSERROLETYPE "%s\n", mls ? ":" SYSTEMLOW : "");
+	fprintf(fout, "/.* " OBJUSERROLETYPE "%s\n", mls ? ":" SYSTEMLOW : "");
 	fclose(fout);
 
 	return 0;

commit be65f9ed267fd7d8b3146b7c4be9ecdd3e0aa3ed
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jun 1 10:59:48 2018 +0200

    staging: lustre: delete the filesystem from the tree.
    
    The Lustre filesystem has been in the kernel tree for over 5 years now.
    While it has been an endless source of enjoyment for new kernel
    developers learning how to do basic codingstyle cleanups, as well as an
    semi-entertaining source of bewilderment from the vfs developers any
    time they have looked into the codebase to try to figure out how to port
    their latest api changes to this filesystem, it has not really moved
    forward into the "this is in shape to get out of staging" despite many
    half-completed attempts.
    
    And getting code out of staging is the main goal of that portion of the
    kernel tree.  Code should not stagnate and it feels like having this
    code in staging is only causing the development cycle of the filesystem
    to take longer than it should.  There is a whole separate out-of-tree
    copy of this codebase where the developers work on it, and then random
    changes are thrown over the wall at staging at some later point in time.
    This dual-tree development model has never worked, and the state of this
    codebase is proof of that.
    
    So, let's just delete the whole mess.  Now the lustre developers can go
    off and work in their out-of-tree codebase and not have to worry about
    providing valid changelog entries and breaking their patches up into
    logical pieces.  They can take the time they have spend doing those
    types of housekeeping chores and get the codebase into a much better
    shape, and it can be submitted for inclusion into the real part of the
    kernel tree when ready.
    
    Cc: Oleg Drokin <oleg.drokin@intel.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: James Simmons <jsimmons@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index ffe8179f5d41..073fe7537f6c 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -124,7 +124,6 @@ int main(int argc, char *argv[])
 	fprintf(fout, "fs_use_xattr reiserfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_xattr jffs2 user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_xattr gfs2 user_u:base_r:base_t;\n");
-	fprintf(fout, "fs_use_xattr lustre user_u:base_r:base_t;\n");
 
 	fprintf(fout, "fs_use_task eventpollfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_task pipefs user_u:base_r:base_t;\n");

commit c017c71ce09f4c7a5378fccbec6a3d7e96b0c5c2
Author: Nicolas Iooss <nicolas.iooss@m4x.org>
Date:   Sun Mar 5 15:01:52 2017 +0100

    selinux: include sys/socket.h in host programs to have PF_MAX
    
    Compiling with clang and -Wundef makes the compiler report a usage of
    undefined PF_MAX macro in security/selinux/include/classmap.h:
    
        In file included from scripts/selinux/mdp/mdp.c:48:
        security/selinux/include/classmap.h:37:31: warning: no previous
        extern declaration for non-static variable 'secclass_map'
        [-Wmissing-variable-declarations]
        struct security_class_mapping secclass_map[] = {
                                      ^
        security/selinux/include/classmap.h:235:5: error: 'PF_MAX' is not
        defined, evaluates to 0 [-Werror,-Wundef]
        #if PF_MAX > 43
            ^
        In file included from scripts/selinux/genheaders/genheaders.c:17:
        security/selinux/include/classmap.h:37:31: warning: no previous
        extern declaration for non-static variable 'secclass_map'
        [-Wmissing-variable-declarations]
        struct security_class_mapping secclass_map[] = {
                                      ^
        security/selinux/include/classmap.h:235:5: error: 'PF_MAX' is not
        defined, evaluates to 0 [-Werror,-Wundef]
        #if PF_MAX > 43
            ^
    
    PF_MAX is defined in include/linux/socket.h but not in
    include/uapi/linux/socket.h. Therefore host programs have to rely on the
    definition from libc's /usr/include/bits/socket.h, included by
    <sys/socket.h>.
    
    Fix the issue by using sys/socket.h in mdp and genheaders. When
    classmap.h is included by security/selinux/avc.c, it uses the kernel
    definition of PF_MAX, which makes the test consistent.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss@m4x.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index c29fa4a6228d..ffe8179f5d41 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -32,6 +32,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
+#include <sys/socket.h>
 
 static void usage(char *name)
 {

commit bfc5e3a6af397dcf9c99a6c1872458e7867c4680
Author: Paul Moore <paul@paul-moore.com>
Date:   Wed Dec 21 10:39:25 2016 -0500

    selinux: use the kernel headers when building scripts/selinux
    
    Commit 3322d0d64f4e ("selinux: keep SELinux in sync with new capability
    definitions") added a check on the defined capabilities without
    explicitly including the capability header file which caused problems
    when building genheaders for users of clang/llvm.  Resolve this by
    using the kernel headers when building genheaders, which is arguably
    the right thing to do regardless, and explicitly including the
    kernel's capability.h header file in classmap.h.  We also update the
    mdp build, even though it wasn't causing an error we really should
    be using the headers from the kernel we are building.
    
    Reported-by: Nicolas Iooss <nicolas.iooss@m4x.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index e10beb11b696..c29fa4a6228d 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -24,6 +24,10 @@
  * Authors: Serge E. Hallyn <serue@us.ibm.com>
  */
 
+
+/* NOTE: we really do want to use the kernel headers here */
+#define __EXPORTED_HEADERS__
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>

commit fda4d578ed0a7e1d116f56a15efea0e4ba78acad
Author: Laurent Bigonville <bigon@bigon.be>
Date:   Tue Jul 7 23:10:52 2015 +0200

    selinux: explicitly declare the role "base_r"
    
    This fixes the compilation of policy generated by mdp with the recent
    version of checkpolicy.
    
    Signed-off-by: Laurent Bigonville <bigon@bigon.be>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <pmoore@redhat.com>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index 62b34ce1f50d..e10beb11b696 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -98,6 +98,7 @@ int main(int argc, char *argv[])
 
 	/* types, roles, and allows */
 	fprintf(fout, "type base_t;\n");
+	fprintf(fout, "role base_r;\n");
 	fprintf(fout, "role base_r types { base_t };\n");
 	for (i = 0; secclass_map[i].name; i++)
 		fprintf(fout, "allow base_t base_t:%s *;\n",

commit c6d3aaa4e35c71a32a86ececacd4eea7ecfc316c
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Wed Sep 30 13:37:50 2009 -0400

    selinux: dynamic class/perm discovery
    
    Modify SELinux to dynamically discover class and permission values
    upon policy load, based on the dynamic object class/perm discovery
    logic from libselinux.  A mapping is created between kernel-private
    class and permission indices used outside the security server and the
    policy values used within the security server.
    
    The mappings are only applied upon kernel-internal computations;
    similar mappings for the private indices of userspace object managers
    is handled on a per-object manager basis by the userspace AVC.  The
    interfaces for compute_av and transition_sid are split for kernel
    vs. userspace; the userspace functions are distinguished by a _user
    suffix.
    
    The kernel-private class indices are no longer tied to the policy
    values and thus do not need to skip indices for userspace classes;
    thus the kernel class index values are compressed.  The flask.h
    definitions were regenerated by deleting the userspace classes from
    refpolicy's definitions and then regenerating the headers.  Going
    forward, we can just maintain the flask.h, av_permissions.h, and
    classmap.h definitions separately from policy as they are no longer
    tied to the policy values.  The next patch introduces a utility to
    automate generation of flask.h and av_permissions.h from the
    classmap.h definitions.
    
    The older kernel class and permission string tables are removed and
    replaced by a single security class mapping table that is walked at
    policy load to generate the mapping.  The old kernel class validation
    logic is completely replaced by the mapping logic.
    
    The handle unknown logic is reworked.  reject_unknown=1 is handled
    when the mappings are computed at policy load time, similar to the old
    handling by the class validation logic.  allow_unknown=1 is handled
    when computing and mapping decisions - if the permission was not able
    to be mapped (i.e. undefined, mapped to zero), then it is
    automatically added to the allowed vector.  If the class was not able
    to be mapped (i.e. undefined, mapped to zero), then all permissions
    are allowed for it if allow_unknown=1.
    
    avc_audit leverages the new security class mapping table to lookup the
    class and permission names from the kernel-private indices.
    
    The mdp program is updated to use the new table when generating the
    class definitions and allow rules for a minimal boot policy for the
    kernel.  It should be noted that this policy will not include any
    userspace classes, nor will its policy index values for the kernel
    classes correspond with the ones in refpolicy (they will instead match
    the kernel-private indices).
    
    Signed-off-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index b4ced8562587..62b34ce1f50d 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -29,86 +29,27 @@
 #include <unistd.h>
 #include <string.h>
 
-#include "flask.h"
-
 static void usage(char *name)
 {
 	printf("usage: %s [-m] policy_file context_file\n", name);
 	exit(1);
 }
 
-static void find_common_name(char *cname, char *dest, int len)
-{
-	char *start, *end;
-
-	start = strchr(cname, '_')+1;
-	end = strchr(start, '_');
-	if (!start || !end || start-cname > len || end-start > len) {
-		printf("Error with commons defines\n");
-		exit(1);
-	}
-	strncpy(dest, start, end-start);
-	dest[end-start] = '\0';
-}
-
-#define S_(x) x,
-static char *classlist[] = {
-#include "class_to_string.h"
-	NULL
+/* Class/perm mapping support */
+struct security_class_mapping {
+	const char *name;
+	const char *perms[sizeof(unsigned) * 8 + 1];
 };
-#undef S_
 
+#include "classmap.h"
 #include "initial_sid_to_string.h"
 
-#define TB_(x) char *x[] = {
-#define TE_(x) NULL };
-#define S_(x) x,
-#include "common_perm_to_string.h"
-#undef TB_
-#undef TE_
-#undef S_
-
-struct common {
-	char *cname;
-	char **perms;
-};
-struct common common[] = {
-#define TB_(x) { #x, x },
-#define S_(x)
-#define TE_(x)
-#include "common_perm_to_string.h"
-#undef TB_
-#undef TE_
-#undef S_
-};
-
-#define S_(x, y, z) {x, #y},
-struct av_inherit {
-	int class;
-	char *common;
-};
-struct av_inherit av_inherit[] = {
-#include "av_inherit.h"
-};
-#undef S_
-
-#include "av_permissions.h"
-#define S_(x, y, z) {x, y, z},
-struct av_perms {
-	int class;
-	int perm_i;
-	char *perm_s;
-};
-struct av_perms av_perms[] = {
-#include "av_perm_to_string.h"
-};
-#undef S_
-
 int main(int argc, char *argv[])
 {
 	int i, j, mls = 0;
+	int initial_sid_to_string_len;
 	char **arg, *polout, *ctxout;
-	int classlist_len, initial_sid_to_string_len;
+
 	FILE *fout;
 
 	if (argc < 3)
@@ -127,64 +68,25 @@ int main(int argc, char *argv[])
 		usage(argv[0]);
 	}
 
-	classlist_len = sizeof(classlist) / sizeof(char *);
 	/* print out the classes */
-	for (i=1; i < classlist_len; i++) {
-		if(classlist[i])
-			fprintf(fout, "class %s\n", classlist[i]);
-		else
-			fprintf(fout, "class user%d\n", i);
-	}
+	for (i = 0; secclass_map[i].name; i++)
+		fprintf(fout, "class %s\n", secclass_map[i].name);
 	fprintf(fout, "\n");
 
 	initial_sid_to_string_len = sizeof(initial_sid_to_string) / sizeof (char *);
 	/* print out the sids */
-	for (i=1; i < initial_sid_to_string_len; i++)
+	for (i = 1; i < initial_sid_to_string_len; i++)
 		fprintf(fout, "sid %s\n", initial_sid_to_string[i]);
 	fprintf(fout, "\n");
 
-	/* print out the commons */
-	for (i=0; i< sizeof(common)/sizeof(struct common); i++) {
-		char cname[101];
-		find_common_name(common[i].cname, cname, 100);
-		cname[100] = '\0';
-		fprintf(fout, "common %s\n{\n", cname);
-		for (j=0; common[i].perms[j]; j++)
-			fprintf(fout, "\t%s\n", common[i].perms[j]);
-		fprintf(fout, "}\n\n");
-	}
-	fprintf(fout, "\n");
-
 	/* print out the class permissions */
-	for (i=1; i < classlist_len; i++) {
-		if (classlist[i]) {
-			int firstperm = -1, numperms = 0;
-
-			fprintf(fout, "class %s\n", classlist[i]);
-			/* does it inherit from a common? */
-			for (j=0; j < sizeof(av_inherit)/sizeof(struct av_inherit); j++)
-				if (av_inherit[j].class == i)
-					fprintf(fout, "inherits %s\n", av_inherit[j].common);
-
-			for (j=0; j < sizeof(av_perms)/sizeof(struct av_perms); j++) {
-				if (av_perms[j].class == i) {
-					if (firstperm == -1)
-						firstperm = j;
-					numperms++;
-				}
-			}
-			if (!numperms) {
-				fprintf(fout, "\n");
-				continue;
-			}
-
-			fprintf(fout, "{\n");
-			/* print out the av_perms */
-			for (j=0; j < numperms; j++) {
-				fprintf(fout, "\t%s\n", av_perms[firstperm+j].perm_s);
-			}
-			fprintf(fout, "}\n\n");
-		}
+	for (i = 0; secclass_map[i].name; i++) {
+		struct security_class_mapping *map = &secclass_map[i];
+		fprintf(fout, "class %s\n", map->name);
+		fprintf(fout, "{\n");
+		for (j = 0; map->perms[j]; j++)
+			fprintf(fout, "\t%s\n", map->perms[j]);
+		fprintf(fout, "}\n\n");
 	}
 	fprintf(fout, "\n");
 
@@ -197,31 +99,34 @@ int main(int argc, char *argv[])
 	/* types, roles, and allows */
 	fprintf(fout, "type base_t;\n");
 	fprintf(fout, "role base_r types { base_t };\n");
-	for (i=1; i < classlist_len; i++) {
-		if (classlist[i])
-			fprintf(fout, "allow base_t base_t:%s *;\n", classlist[i]);
-		else
-			fprintf(fout, "allow base_t base_t:user%d *;\n", i);
-	}
+	for (i = 0; secclass_map[i].name; i++)
+		fprintf(fout, "allow base_t base_t:%s *;\n",
+			secclass_map[i].name);
 	fprintf(fout, "user user_u roles { base_r };\n");
 	fprintf(fout, "\n");
 
 	/* default sids */
-	for (i=1; i < initial_sid_to_string_len; i++)
+	for (i = 1; i < initial_sid_to_string_len; i++)
 		fprintf(fout, "sid %s user_u:base_r:base_t\n", initial_sid_to_string[i]);
 	fprintf(fout, "\n");
 
-
 	fprintf(fout, "fs_use_xattr ext2 user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_xattr ext3 user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr ext4 user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_xattr jfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_xattr xfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_xattr reiserfs user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr jffs2 user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr gfs2 user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr lustre user_u:base_r:base_t;\n");
 
+	fprintf(fout, "fs_use_task eventpollfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_task pipefs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_task sockfs user_u:base_r:base_t;\n");
 
+	fprintf(fout, "fs_use_trans mqueue user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_trans devpts user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_trans hugetlbfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_trans tmpfs user_u:base_r:base_t;\n");
 	fprintf(fout, "fs_use_trans shm user_u:base_r:base_t;\n");
 

commit 5c725138437837291db5c25f4a076ee852e806e3
Author: Trevor Keith <tsrk@tsrk.net>
Date:   Tue Sep 22 16:43:38 2009 -0700

    Fix all -Wmissing-prototypes warnings in x86 defconfig
    
    Signed-off-by: Trevor Keith <tsrk@tsrk.net>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
index ca757d486187..b4ced8562587 100644
--- a/scripts/selinux/mdp/mdp.c
+++ b/scripts/selinux/mdp/mdp.c
@@ -31,13 +31,13 @@
 
 #include "flask.h"
 
-void usage(char *name)
+static void usage(char *name)
 {
 	printf("usage: %s [-m] policy_file context_file\n", name);
 	exit(1);
 }
 
-void find_common_name(char *cname, char *dest, int len)
+static void find_common_name(char *cname, char *dest, int len)
 {
 	char *start, *end;
 

commit 93c06cbbf9fea5d5be1778febb7fa9ab1a74e5f5
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Tue Aug 26 14:47:57 2008 -0500

    selinux: add support for installing a dummy policy (v2)
    
    In August 2006 I posted a patch generating a minimal SELinux policy.  This
    week, David P. Quigley posted an updated version of that as a patch against
    the kernel.  It also had nice logic for auto-installing the policy.
    
    Following is David's original patch intro (preserved especially
    bc it has stats on the generated policies):
    
    se interested in the changes there were only two significant
    changes. The first is that the iteration through the list of classes
    used NULL as a sentinel value. The problem with this is that the
    class_to_string array actually has NULL entries in its table as place
    holders for the user space object classes.
    
    The second change was that it would seem at some point the initial sids
    table was NULL terminated. This is no longer the case so that iteration
    has to be done on array length instead of looking for NULL.
    
    Some statistics on the policy that it generates:
    
    The policy consists of 523 lines which contain no blank lines. Of those
    523 lines 453 of them are class, permission, and initial sid
    definitions. These lines are usually little to no concern to the policy
    developer since they will not be adding object classes or permissions.
    Of the remaining 70 lines there is one type, one role, and one user
    statement. The remaining lines are broken into three portions. The first
    group are TE allow rules which make up 29 of the remaining lines, the
    second is assignment of labels to the initial sids which consist of 27
    lines, and file system labeling statements which are the remaining 11.
    
    In addition to the policy.conf generated there is a single file_contexts
    file containing two lines which labels the entire system with base_t.
    
    This policy generates a policy.23 binary that is 7920 bytes.
    
    (then a few versions later...):
    
    The new policy is 587 lines (stripped of blank lines) with 476 of those
    lines being the boilerplate that I mentioned last time. The remaining
    111 lines have the 3 lines for type, user, and role, 70 lines for the
    allow rules (one for each object class including user space object
    classes), 27 lines to assign types to the initial sids, and 11 lines for
    file system labeling. The policy binary is 9194 bytes.
    
    Changelog:
    
            Aug 26: Added Documentation/SELinux.txt
            Aug 26: Incorporated a set of comments by Stephen Smalley:
                    1. auto-setup SELINUXTYPE=dummy
                    2. don't auto-install if selinux is enabled with
                            non-dummy policy
                    3. don't re-compute policy version
                    4. /sbin/setfiles not /usr/sbin/setfiles
            Aug 22: As per JMorris comments, made sure make distclean
                    cleans up the mdp directory.
                    Removed a check for file_contexts which is now
                    created in the same file as the check, making it
                    superfluous.
    
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: David Quigley <dpquigl@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/scripts/selinux/mdp/mdp.c b/scripts/selinux/mdp/mdp.c
new file mode 100644
index 000000000000..ca757d486187
--- /dev/null
+++ b/scripts/selinux/mdp/mdp.c
@@ -0,0 +1,242 @@
+/*
+ *
+ * mdp - make dummy policy
+ *
+ * When pointed at a kernel tree, builds a dummy policy for that kernel
+ * with exactly one type with full rights to itself.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2006
+ *
+ * Authors: Serge E. Hallyn <serue@us.ibm.com>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "flask.h"
+
+void usage(char *name)
+{
+	printf("usage: %s [-m] policy_file context_file\n", name);
+	exit(1);
+}
+
+void find_common_name(char *cname, char *dest, int len)
+{
+	char *start, *end;
+
+	start = strchr(cname, '_')+1;
+	end = strchr(start, '_');
+	if (!start || !end || start-cname > len || end-start > len) {
+		printf("Error with commons defines\n");
+		exit(1);
+	}
+	strncpy(dest, start, end-start);
+	dest[end-start] = '\0';
+}
+
+#define S_(x) x,
+static char *classlist[] = {
+#include "class_to_string.h"
+	NULL
+};
+#undef S_
+
+#include "initial_sid_to_string.h"
+
+#define TB_(x) char *x[] = {
+#define TE_(x) NULL };
+#define S_(x) x,
+#include "common_perm_to_string.h"
+#undef TB_
+#undef TE_
+#undef S_
+
+struct common {
+	char *cname;
+	char **perms;
+};
+struct common common[] = {
+#define TB_(x) { #x, x },
+#define S_(x)
+#define TE_(x)
+#include "common_perm_to_string.h"
+#undef TB_
+#undef TE_
+#undef S_
+};
+
+#define S_(x, y, z) {x, #y},
+struct av_inherit {
+	int class;
+	char *common;
+};
+struct av_inherit av_inherit[] = {
+#include "av_inherit.h"
+};
+#undef S_
+
+#include "av_permissions.h"
+#define S_(x, y, z) {x, y, z},
+struct av_perms {
+	int class;
+	int perm_i;
+	char *perm_s;
+};
+struct av_perms av_perms[] = {
+#include "av_perm_to_string.h"
+};
+#undef S_
+
+int main(int argc, char *argv[])
+{
+	int i, j, mls = 0;
+	char **arg, *polout, *ctxout;
+	int classlist_len, initial_sid_to_string_len;
+	FILE *fout;
+
+	if (argc < 3)
+		usage(argv[0]);
+	arg = argv+1;
+	if (argc==4 && strcmp(argv[1], "-m") == 0) {
+		mls = 1;
+		arg++;
+	}
+	polout = *arg++;
+	ctxout = *arg;
+
+	fout = fopen(polout, "w");
+	if (!fout) {
+		printf("Could not open %s for writing\n", polout);
+		usage(argv[0]);
+	}
+
+	classlist_len = sizeof(classlist) / sizeof(char *);
+	/* print out the classes */
+	for (i=1; i < classlist_len; i++) {
+		if(classlist[i])
+			fprintf(fout, "class %s\n", classlist[i]);
+		else
+			fprintf(fout, "class user%d\n", i);
+	}
+	fprintf(fout, "\n");
+
+	initial_sid_to_string_len = sizeof(initial_sid_to_string) / sizeof (char *);
+	/* print out the sids */
+	for (i=1; i < initial_sid_to_string_len; i++)
+		fprintf(fout, "sid %s\n", initial_sid_to_string[i]);
+	fprintf(fout, "\n");
+
+	/* print out the commons */
+	for (i=0; i< sizeof(common)/sizeof(struct common); i++) {
+		char cname[101];
+		find_common_name(common[i].cname, cname, 100);
+		cname[100] = '\0';
+		fprintf(fout, "common %s\n{\n", cname);
+		for (j=0; common[i].perms[j]; j++)
+			fprintf(fout, "\t%s\n", common[i].perms[j]);
+		fprintf(fout, "}\n\n");
+	}
+	fprintf(fout, "\n");
+
+	/* print out the class permissions */
+	for (i=1; i < classlist_len; i++) {
+		if (classlist[i]) {
+			int firstperm = -1, numperms = 0;
+
+			fprintf(fout, "class %s\n", classlist[i]);
+			/* does it inherit from a common? */
+			for (j=0; j < sizeof(av_inherit)/sizeof(struct av_inherit); j++)
+				if (av_inherit[j].class == i)
+					fprintf(fout, "inherits %s\n", av_inherit[j].common);
+
+			for (j=0; j < sizeof(av_perms)/sizeof(struct av_perms); j++) {
+				if (av_perms[j].class == i) {
+					if (firstperm == -1)
+						firstperm = j;
+					numperms++;
+				}
+			}
+			if (!numperms) {
+				fprintf(fout, "\n");
+				continue;
+			}
+
+			fprintf(fout, "{\n");
+			/* print out the av_perms */
+			for (j=0; j < numperms; j++) {
+				fprintf(fout, "\t%s\n", av_perms[firstperm+j].perm_s);
+			}
+			fprintf(fout, "}\n\n");
+		}
+	}
+	fprintf(fout, "\n");
+
+	/* NOW PRINT OUT MLS STUFF */
+	if (mls) {
+		printf("MLS not yet implemented\n");
+		exit(1);
+	}
+
+	/* types, roles, and allows */
+	fprintf(fout, "type base_t;\n");
+	fprintf(fout, "role base_r types { base_t };\n");
+	for (i=1; i < classlist_len; i++) {
+		if (classlist[i])
+			fprintf(fout, "allow base_t base_t:%s *;\n", classlist[i]);
+		else
+			fprintf(fout, "allow base_t base_t:user%d *;\n", i);
+	}
+	fprintf(fout, "user user_u roles { base_r };\n");
+	fprintf(fout, "\n");
+
+	/* default sids */
+	for (i=1; i < initial_sid_to_string_len; i++)
+		fprintf(fout, "sid %s user_u:base_r:base_t\n", initial_sid_to_string[i]);
+	fprintf(fout, "\n");
+
+
+	fprintf(fout, "fs_use_xattr ext2 user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr ext3 user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr jfs user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr xfs user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_xattr reiserfs user_u:base_r:base_t;\n");
+
+	fprintf(fout, "fs_use_task pipefs user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_task sockfs user_u:base_r:base_t;\n");
+
+	fprintf(fout, "fs_use_trans devpts user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_trans tmpfs user_u:base_r:base_t;\n");
+	fprintf(fout, "fs_use_trans shm user_u:base_r:base_t;\n");
+
+	fprintf(fout, "genfscon proc / user_u:base_r:base_t\n");
+
+	fclose(fout);
+
+	fout = fopen(ctxout, "w");
+	if (!fout) {
+		printf("Wrote policy, but cannot open %s for writing\n", ctxout);
+		usage(argv[0]);
+	}
+	fprintf(fout, "/ user_u:base_r:base_t\n");
+	fprintf(fout, "/.* user_u:base_r:base_t\n");
+	fclose(fout);
+
+	return 0;
+}
