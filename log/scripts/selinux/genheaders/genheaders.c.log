commit e3e0b582c321aefd72db0e7083a0adfe285e96b5
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Mon Feb 24 11:10:23 2020 -0500

    selinux: remove unused initial SIDs and improve handling
    
    Remove initial SIDs that have never been used or are no longer used by
    the kernel from its string table, which is also used to generate the
    SECINITSID_* symbols referenced in code.  Update the code to
    gracefully handle the fact that these can now be NULL. Stop treating
    it as an error if a policy defines additional initial SIDs unknown to
    the kernel.  Do not load unused initial SID contexts into the sidtab.
    Fix the incorrect usage of the name from the ocontext in error
    messages when loading initial SIDs since these are not presently
    written to the kernel policy and are therefore always NULL.
    
    After this change, it is possible to safely reclaim and reuse some of
    the unused initial SIDs without compatibility issues.  Specifically,
    unused initial SIDs that were being assigned the same context as the
    unlabeled initial SID in policies can be reclaimed and reused for
    another purpose, with existing policies still treating them as having
    the unlabeled context and future policies having the option of mapping
    them to a more specific context.  For example, this could have been
    used when the infiniband labeling support was introduced to define
    initial SIDs for the default pkey and endport SIDs similar to the
    handling of port/netif/node SIDs rather than always using
    SECINITSID_UNLABELED as the default.
    
    The set of safely reclaimable unused initial SIDs across all known
    policies is igmp_packet (13), icmp_socket (14), tcp_socket (15), kmod
    (24), policy (25), and scmp_packet (26); these initial SIDs were
    assigned the same context as unlabeled in all known policies including
    mls.  If only considering non-mls policies (i.e. assuming that mls
    users always upgrade policy with their kernels), the set of safely
    reclaimable unused initial SIDs further includes file_labels (6), init
    (7), sysctl_modprobe (16), and sysctl_fs (18) through sysctl_dev (23).
    
    Adding new initial SIDs beyond SECINITSID_NUM to policy unfortunately
    became a fatal error in commit 24ed7fdae669 ("selinux: use separate
    table for initial SID lookup") and even before that it could cause
    problems on a policy reload (collision between the new initial SID and
    one allocated at runtime) ever since commit 42596eafdd75 ("selinux:
    load the initial SIDs upon every policy load") so we cannot safely
    start adding new initial SIDs to policies beyond SECINITSID_NUM (27)
    until such a time as all such kernels do not need to be supported and
    only those that include this commit are relevant. That is not a big
    deal since we haven't added a new initial SID since 2004 (v2.6.7) and
    we have plenty of unused ones we can reclaim if we truly need one.
    
    If we want to avoid the wasted storage in initial_sid_to_string[]
    and/or sidtab->isids[] for the unused initial SIDs, we could introduce
    an indirection between the kernel initial SID values and the policy
    initial SID values and just map the policy SID values in the ocontexts
    to the kernel values during policy_load_isids(). Originally I thought
    we'd do this by preserving the initial SID names in the kernel policy
    and creating a mapping at load time like we do for the security
    classes and permissions but that would require a new kernel policy
    format version and associated changes to libsepol/checkpolicy and I'm
    not sure it is justified. Simpler approach is just to create a fixed
    mapping table in the kernel from the existing fixed policy values to
    the kernel values. Less flexible but probably sufficient.
    
    A separate selinux userspace change was applied in
    https://github.com/SELinuxProject/selinux/commit/8677ce5e8f592950ae6f14cea1b68a20ddc1ac25
    to enable removal of most of the unused initial SID contexts from
    policies, but there is no dependency between that change and this one.
    That change permits removing all of the unused initial SID contexts
    from policy except for the fs and sysctl SID contexts.  The initial
    SID declarations themselves would remain in policy to preserve the
    values of subsequent ones but the contexts can be dropped.  If/when
    the kernel decides to reuse one of them, future policies can change
    the name and start assigning a context again without breaking
    compatibility.
    
    Here is how I would envision staging changes to the initial SIDs in a
    compatible manner after this commit is applied:
    
    1. At any time after this commit is applied, the kernel could choose
    to reclaim one of the safely reclaimable unused initial SIDs listed
    above for a new purpose (i.e. replace its NULL entry in the
    initial_sid_to_string[] table with a new name and start using the
    newly generated SECINITSID_name symbol in code), and refpolicy could
    at that time rename its declaration of that initial SID to reflect its
    new purpose and start assigning it a context going
    forward. Existing/old policies would map the reclaimed initial SID to
    the unlabeled context, so that would be the initial default behavior
    until policies are updated. This doesn't depend on the selinux
    userspace change; it will work with existing policies and userspace.
    
    2. In 6 months or so we'll have another SELinux userspace release that
    will include the libsepol/checkpolicy support for omitting unused
    initial SID contexts.
    
    3. At any time after that release, refpolicy can make that release its
    minimum build requirement and drop the sid context statements (but not
    the sid declarations) for all of the unused initial SIDs except for
    fs and sysctl, which must remain for compatibility on policy
    reload with old kernels and for compatibility with kernels that were
    still using SECINITSID_SYSCTL (< 2.6.39). This doesn't depend on this
    kernel commit; it will work with previous kernels as well.
    
    4. After N years for some value of N, refpolicy decides that it no
    longer cares about policy reload compatibility for kernels that
    predate this kernel commit, and refpolicy drops the fs and sysctl
    SID contexts from policy too (but retains the declarations).
    
    5. After M years for some value of M, the kernel decides that it no
    longer cares about compatibility with refpolicies that predate step 4
    (dropping the fs and sysctl SIDs), and those two SIDs also become
    safely reclaimable.  This step is optional and need not ever occur unless
    we decide that the need to reclaim those two SIDs outweighs the
    compatibility cost.
    
    6. After O years for some value of O, refpolicy decides that it no
    longer cares about policy load (not just reload) compatibility for
    kernels that predate this kernel commit, and both kernel and refpolicy
    can then start adding and using new initial SIDs beyond 27. This does
    not depend on the previous change (step 5) and can occur independent
    of it.
    
    Fixes: https://github.com/SELinuxProject/selinux-kernel/issues/12
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 544ca126a8a8..f355b3e0e968 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -67,8 +67,12 @@ int main(int argc, char *argv[])
 	}
 
 	isids_len = sizeof(initial_sid_to_string) / sizeof (char *);
-	for (i = 1; i < isids_len; i++)
-		initial_sid_to_string[i] = stoupperx(initial_sid_to_string[i]);
+	for (i = 1; i < isids_len; i++) {
+		const char *s = initial_sid_to_string[i];
+
+		if (s)
+			initial_sid_to_string[i] = stoupperx(s);
+	}
 
 	fprintf(fout, "/* This file is automatically generated.  Do not edit. */\n");
 	fprintf(fout, "#ifndef _SELINUX_FLASK_H_\n#define _SELINUX_FLASK_H_\n\n");
@@ -82,7 +86,8 @@ int main(int argc, char *argv[])
 
 	for (i = 1; i < isids_len; i++) {
 		const char *s = initial_sid_to_string[i];
-		fprintf(fout, "#define SECINITSID_%-39s %2d\n", s, i);
+		if (s)
+			fprintf(fout, "#define SECINITSID_%-39s %2d\n", s, i);
 	}
 	fprintf(fout, "\n#define SECINITSID_NUM %d\n", i-1);
 	fprintf(fout, "\nstatic inline bool security_is_socket_class(u16 kern_tclass)\n");

commit dfbd199a7cfe3e3cd8531e1353cdbd7175bfbc5e
Author: Paulo Alcantara <paulo@paulo.ac>
Date:   Sun Feb 24 21:55:28 2019 -0300

    selinux: use kernel linux/socket.h for genheaders and mdp
    
    When compiling genheaders and mdp from a newer host kernel, the
    following error happens:
    
        In file included from scripts/selinux/genheaders/genheaders.c:18:
        ./security/selinux/include/classmap.h:238:2: error: #error New
        address family defined, please update secclass_map.  #error New
        address family defined, please update secclass_map.  ^~~~~
        make[3]: *** [scripts/Makefile.host:107:
        scripts/selinux/genheaders/genheaders] Error 1 make[2]: ***
        [scripts/Makefile.build:599: scripts/selinux/genheaders] Error 2
        make[1]: *** [scripts/Makefile.build:599: scripts/selinux] Error 2
        make[1]: *** Waiting for unfinished jobs....
    
    Instead of relying on the host definition, include linux/socket.h in
    classmap.h to have PF_MAX.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Paulo Alcantara <paulo@paulo.ac>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
    [PM: manually merge in mdp.c, subject line tweaks]
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 1ceedea847dd..544ca126a8a8 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -9,7 +9,6 @@
 #include <string.h>
 #include <errno.h>
 #include <ctype.h>
-#include <sys/socket.h>
 
 struct security_class_mapping {
 	const char *name;

commit a40612ef0ee1e524aafee58d0e5713cf5fdb3d62
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 10 03:40:11 2018 -0500

    genheaders: %-<width>s had been there since v6; %-*s - since v7
    
    Please, use at least K&R C; printf had been able to left-adjust
    a field for as long as stdio existed and use of '*' for variable
    width had been there since v7.  Yes, the first edition of K&R
    didn't cover the latter feature (it slightly predates v7), but
    you are using a much later feature of the language than that -
    in K&R C
    static char *stoupperx(const char *s)
    {
    ...
    }
    would've been spelled as
    static char *stoupperx(s)
    char *s;
    {
    ...
    }
    
    While we are at it, the use of strstr() is bogus - it finds the
    _first_ instance of substring, so it's a lousy fit for checking
    if a string ends with given suffix...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index fa48fabcb330..1ceedea847dd 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -19,8 +19,6 @@ struct security_class_mapping {
 #include "classmap.h"
 #include "initial_sid_to_string.h"
 
-#define max(x, y) (((int)(x) > (int)(y)) ? x : y)
-
 const char *progname;
 
 static void usage(void)
@@ -46,11 +44,9 @@ static char *stoupperx(const char *s)
 
 int main(int argc, char *argv[])
 {
-	int i, j, k;
+	int i, j;
 	int isids_len;
 	FILE *fout;
-	const char *needle = "SOCKET";
-	char *substr;
 
 	progname = argv[0];
 
@@ -80,20 +76,14 @@ int main(int argc, char *argv[])
 
 	for (i = 0; secclass_map[i].name; i++) {
 		struct security_class_mapping *map = &secclass_map[i];
-		fprintf(fout, "#define SECCLASS_%s", map->name);
-		for (j = 0; j < max(1, 40 - strlen(map->name)); j++)
-			fprintf(fout, " ");
-		fprintf(fout, "%2d\n", i+1);
+		fprintf(fout, "#define SECCLASS_%-39s %2d\n", map->name, i+1);
 	}
 
 	fprintf(fout, "\n");
 
 	for (i = 1; i < isids_len; i++) {
 		const char *s = initial_sid_to_string[i];
-		fprintf(fout, "#define SECINITSID_%s", s);
-		for (j = 0; j < max(1, 40 - strlen(s)); j++)
-			fprintf(fout, " ");
-		fprintf(fout, "%2d\n", i);
+		fprintf(fout, "#define SECINITSID_%-39s %2d\n", s, i);
 	}
 	fprintf(fout, "\n#define SECINITSID_NUM %d\n", i-1);
 	fprintf(fout, "\nstatic inline bool security_is_socket_class(u16 kern_tclass)\n");
@@ -101,9 +91,10 @@ int main(int argc, char *argv[])
 	fprintf(fout, "\tbool sock = false;\n\n");
 	fprintf(fout, "\tswitch (kern_tclass) {\n");
 	for (i = 0; secclass_map[i].name; i++) {
+		static char s[] = "SOCKET";
 		struct security_class_mapping *map = &secclass_map[i];
-		substr = strstr(map->name, needle);
-		if (substr && strcmp(substr, needle) == 0)
+		int len = strlen(map->name), l = sizeof(s) - 1;
+		if (len >= l && memcmp(map->name + len - l, s, l) == 0)
 			fprintf(fout, "\tcase SECCLASS_%s:\n", map->name);
 	}
 	fprintf(fout, "\t\tsock = true;\n");
@@ -129,17 +120,15 @@ int main(int argc, char *argv[])
 
 	for (i = 0; secclass_map[i].name; i++) {
 		struct security_class_mapping *map = &secclass_map[i];
+		int len = strlen(map->name);
 		for (j = 0; map->perms[j]; j++) {
 			if (j >= 32) {
 				fprintf(stderr, "Too many permissions to fit into an access vector at (%s, %s).\n",
 					map->name, map->perms[j]);
 				exit(5);
 			}
-			fprintf(fout, "#define %s__%s", map->name,
-				map->perms[j]);
-			for (k = 0; k < max(1, 40 - strlen(map->name) - strlen(map->perms[j])); k++)
-				fprintf(fout, " ");
-			fprintf(fout, "0x%08xU\n", (1<<j));
+			fprintf(fout, "#define %s__%-*s 0x%08xU\n", map->name,
+				39-len, map->perms[j], 1U<<j);
 		}
 	}
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 672b069dcfea..fa48fabcb330 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 
 /* NOTE: we really do want to use the kernel headers here */
 #define __EXPORTED_HEADERS__

commit 20a8d62eeff844a8624d6b58a0227c057b1aa43f
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Tue Jul 25 12:14:12 2017 -0400

    selinux: genheaders should fail if too many permissions are defined
    
    Ensure that genheaders fails with an error if too many permissions
    are defined in a class to fit within an access vector. This is similar
    to a check performed by checkpolicy when compiling the policy.
    
    Also, fix the suffix on the permission constants generated by this program.
    
    Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 6a24569c3578..672b069dcfea 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -129,11 +129,16 @@ int main(int argc, char *argv[])
 	for (i = 0; secclass_map[i].name; i++) {
 		struct security_class_mapping *map = &secclass_map[i];
 		for (j = 0; map->perms[j]; j++) {
+			if (j >= 32) {
+				fprintf(stderr, "Too many permissions to fit into an access vector at (%s, %s).\n",
+					map->name, map->perms[j]);
+				exit(5);
+			}
 			fprintf(fout, "#define %s__%s", map->name,
 				map->perms[j]);
 			for (k = 0; k < max(1, 40 - strlen(map->name) - strlen(map->perms[j])); k++)
 				fprintf(fout, " ");
-			fprintf(fout, "0x%08xUL\n", (1<<j));
+			fprintf(fout, "0x%08xU\n", (1<<j));
 		}
 	}
 

commit c017c71ce09f4c7a5378fccbec6a3d7e96b0c5c2
Author: Nicolas Iooss <nicolas.iooss@m4x.org>
Date:   Sun Mar 5 15:01:52 2017 +0100

    selinux: include sys/socket.h in host programs to have PF_MAX
    
    Compiling with clang and -Wundef makes the compiler report a usage of
    undefined PF_MAX macro in security/selinux/include/classmap.h:
    
        In file included from scripts/selinux/mdp/mdp.c:48:
        security/selinux/include/classmap.h:37:31: warning: no previous
        extern declaration for non-static variable 'secclass_map'
        [-Wmissing-variable-declarations]
        struct security_class_mapping secclass_map[] = {
                                      ^
        security/selinux/include/classmap.h:235:5: error: 'PF_MAX' is not
        defined, evaluates to 0 [-Werror,-Wundef]
        #if PF_MAX > 43
            ^
        In file included from scripts/selinux/genheaders/genheaders.c:17:
        security/selinux/include/classmap.h:37:31: warning: no previous
        extern declaration for non-static variable 'secclass_map'
        [-Wmissing-variable-declarations]
        struct security_class_mapping secclass_map[] = {
                                      ^
        security/selinux/include/classmap.h:235:5: error: 'PF_MAX' is not
        defined, evaluates to 0 [-Werror,-Wundef]
        #if PF_MAX > 43
            ^
    
    PF_MAX is defined in include/linux/socket.h but not in
    include/uapi/linux/socket.h. Therefore host programs have to rely on the
    definition from libc's /usr/include/bits/socket.h, included by
    <sys/socket.h>.
    
    Fix the issue by using sys/socket.h in mdp and genheaders. When
    classmap.h is included by security/selinux/avc.c, it uses the kernel
    definition of PF_MAX, which makes the test consistent.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss@m4x.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index f4dd41f900d5..6a24569c3578 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -8,6 +8,7 @@
 #include <string.h>
 #include <errno.h>
 #include <ctype.h>
+#include <sys/socket.h>
 
 struct security_class_mapping {
 	const char *name;

commit bfc5e3a6af397dcf9c99a6c1872458e7867c4680
Author: Paul Moore <paul@paul-moore.com>
Date:   Wed Dec 21 10:39:25 2016 -0500

    selinux: use the kernel headers when building scripts/selinux
    
    Commit 3322d0d64f4e ("selinux: keep SELinux in sync with new capability
    definitions") added a check on the defined capabilities without
    explicitly including the capability header file which caused problems
    when building genheaders for users of clang/llvm.  Resolve this by
    using the kernel headers when building genheaders, which is arguably
    the right thing to do regardless, and explicitly including the
    kernel's capability.h header file in classmap.h.  We also update the
    mdp build, even though it wasn't causing an error we really should
    be using the headers from the kernel we are building.
    
    Reported-by: Nicolas Iooss <nicolas.iooss@m4x.org>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 539855ff31f9..f4dd41f900d5 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -1,3 +1,7 @@
+
+/* NOTE: we really do want to use the kernel headers here */
+#define __EXPORTED_HEADERS__
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>

commit 4bc6c2d5d8386800fde23a8e78cd4f04a0ade0ad
Author: Harry Ciao <qingtao.cao@windriver.com>
Date:   Wed Mar 2 13:46:08 2011 +0800

    SELinux: Auto-generate security_is_socket_class
    
    The security_is_socket_class() is auto-generated by genheaders based
    on classmap.h to reduce maintenance effort when a new class is defined
    in SELinux kernel. The name for any socket class should be suffixed by
    "socket" and doesn't contain more than one substr of "socket".
    
    Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Stephen Smalley <sds@tycho.nsa.gov>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 58a12c278706..539855ff31f9 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -43,6 +43,8 @@ int main(int argc, char *argv[])
 	int i, j, k;
 	int isids_len;
 	FILE *fout;
+	const char *needle = "SOCKET";
+	char *substr;
 
 	progname = argv[0];
 
@@ -88,6 +90,24 @@ int main(int argc, char *argv[])
 		fprintf(fout, "%2d\n", i);
 	}
 	fprintf(fout, "\n#define SECINITSID_NUM %d\n", i-1);
+	fprintf(fout, "\nstatic inline bool security_is_socket_class(u16 kern_tclass)\n");
+	fprintf(fout, "{\n");
+	fprintf(fout, "\tbool sock = false;\n\n");
+	fprintf(fout, "\tswitch (kern_tclass) {\n");
+	for (i = 0; secclass_map[i].name; i++) {
+		struct security_class_mapping *map = &secclass_map[i];
+		substr = strstr(map->name, needle);
+		if (substr && strcmp(substr, needle) == 0)
+			fprintf(fout, "\tcase SECCLASS_%s:\n", map->name);
+	}
+	fprintf(fout, "\t\tsock = true;\n");
+	fprintf(fout, "\t\tbreak;\n");
+	fprintf(fout, "\tdefault:\n");
+	fprintf(fout, "\t\tbreak;\n");
+	fprintf(fout, "\t}\n\n");
+	fprintf(fout, "\treturn sock;\n");
+	fprintf(fout, "}\n");
+
 	fprintf(fout, "\n#endif\n");
 	fclose(fout);
 

commit 310de047eef6685274045db1e6b39c9f313df428
Author: James Morris <jmorris@namei.org>
Date:   Tue Mar 16 08:47:36 2010 +1100

    selinux: fix warning in genheaders
    
    Fix const warning in the genheaders script as a result of
    changes to the headers, as noted here:
    
    http://linux.derkeiler.com/Mailing-Lists/Kernel/2010-03/msg03977.html
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 24626968055d..58a12c278706 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -81,7 +81,7 @@ int main(int argc, char *argv[])
 	fprintf(fout, "\n");
 
 	for (i = 1; i < isids_len; i++) {
-		char *s = initial_sid_to_string[i];
+		const char *s = initial_sid_to_string[i];
 		fprintf(fout, "#define SECINITSID_%s", s);
 		for (j = 0; j < max(1, 40 - strlen(s)); j++)
 			fprintf(fout, " ");

commit 85c3b529f8ad4d65ba86b982ef050212ae7dd976
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Nov 20 11:00:12 2009 -0500

    SELinux: header generation may hit infinite loop
    
    If a permission name is long enough the selinux class definition generation
    tool will go into a infinite loop.  This is because it's macro max() is
    fooled into thinking it is dealing with unsigned numbers.  This patch makes
    sure the macro always uses signed number so 1 > -1.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 771b86f46194..24626968055d 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -13,7 +13,7 @@ struct security_class_mapping {
 #include "classmap.h"
 #include "initial_sid_to_string.h"
 
-#define max(x, y) ((x > y) ? x : y)
+#define max(x, y) (((int)(x) > (int)(y)) ? x : y)
 
 const char *progname;
 

commit 821d35a56044e522e811f6a1e8632cc230360280
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed Nov 18 14:39:51 2009 +0000

    selinux: Fix warnings
    
    scripts/selinux/genheaders/genheaders.c:20: warning: no previous prototype
    for ?usage?
    scripts/selinux/genheaders/genheaders.c:26: warning: no previous prototype
    for ?stoupperx?
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Acked-by: WANG Cong <xiyou.wangcong@gmail.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
index 3b16145dabe3..771b86f46194 100644
--- a/scripts/selinux/genheaders/genheaders.c
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -17,13 +17,13 @@ struct security_class_mapping {
 
 const char *progname;
 
-void usage(void)
+static void usage(void)
 {
 	printf("usage: %s flask.h av_permissions.h\n", progname);
 	exit(1);
 }
 
-char *stoupperx(const char *s)
+static char *stoupperx(const char *s)
 {
 	char *s2 = strdup(s);
 	char *p;

commit 8753f6bec352392b52ed9b5e290afb34379f4612
Author: Stephen Smalley <sds@tycho.nsa.gov>
Date:   Wed Sep 30 13:41:02 2009 -0400

    selinux: generate flask headers during kernel build
    
    Add a simple utility (scripts/selinux/genheaders) and invoke it to
    generate the kernel-private class and permission indices in flask.h
    and av_permissions.h automatically during the kernel build from the
    security class mapping definitions in classmap.h.  Adding new kernel
    classes and permissions can then be done just by adding them to classmap.h.
    
    Signed-off-by:  Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/scripts/selinux/genheaders/genheaders.c b/scripts/selinux/genheaders/genheaders.c
new file mode 100644
index 000000000000..3b16145dabe3
--- /dev/null
+++ b/scripts/selinux/genheaders/genheaders.c
@@ -0,0 +1,118 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+struct security_class_mapping {
+	const char *name;
+	const char *perms[sizeof(unsigned) * 8 + 1];
+};
+
+#include "classmap.h"
+#include "initial_sid_to_string.h"
+
+#define max(x, y) ((x > y) ? x : y)
+
+const char *progname;
+
+void usage(void)
+{
+	printf("usage: %s flask.h av_permissions.h\n", progname);
+	exit(1);
+}
+
+char *stoupperx(const char *s)
+{
+	char *s2 = strdup(s);
+	char *p;
+
+	if (!s2) {
+		fprintf(stderr, "%s:  out of memory\n", progname);
+		exit(3);
+	}
+
+	for (p = s2; *p; p++)
+		*p = toupper(*p);
+	return s2;
+}
+
+int main(int argc, char *argv[])
+{
+	int i, j, k;
+	int isids_len;
+	FILE *fout;
+
+	progname = argv[0];
+
+	if (argc < 3)
+		usage();
+
+	fout = fopen(argv[1], "w");
+	if (!fout) {
+		fprintf(stderr, "Could not open %s for writing:  %s\n",
+			argv[1], strerror(errno));
+		exit(2);
+	}
+
+	for (i = 0; secclass_map[i].name; i++) {
+		struct security_class_mapping *map = &secclass_map[i];
+		map->name = stoupperx(map->name);
+		for (j = 0; map->perms[j]; j++)
+			map->perms[j] = stoupperx(map->perms[j]);
+	}
+
+	isids_len = sizeof(initial_sid_to_string) / sizeof (char *);
+	for (i = 1; i < isids_len; i++)
+		initial_sid_to_string[i] = stoupperx(initial_sid_to_string[i]);
+
+	fprintf(fout, "/* This file is automatically generated.  Do not edit. */\n");
+	fprintf(fout, "#ifndef _SELINUX_FLASK_H_\n#define _SELINUX_FLASK_H_\n\n");
+
+	for (i = 0; secclass_map[i].name; i++) {
+		struct security_class_mapping *map = &secclass_map[i];
+		fprintf(fout, "#define SECCLASS_%s", map->name);
+		for (j = 0; j < max(1, 40 - strlen(map->name)); j++)
+			fprintf(fout, " ");
+		fprintf(fout, "%2d\n", i+1);
+	}
+
+	fprintf(fout, "\n");
+
+	for (i = 1; i < isids_len; i++) {
+		char *s = initial_sid_to_string[i];
+		fprintf(fout, "#define SECINITSID_%s", s);
+		for (j = 0; j < max(1, 40 - strlen(s)); j++)
+			fprintf(fout, " ");
+		fprintf(fout, "%2d\n", i);
+	}
+	fprintf(fout, "\n#define SECINITSID_NUM %d\n", i-1);
+	fprintf(fout, "\n#endif\n");
+	fclose(fout);
+
+	fout = fopen(argv[2], "w");
+	if (!fout) {
+		fprintf(stderr, "Could not open %s for writing:  %s\n",
+			argv[2], strerror(errno));
+		exit(4);
+	}
+
+	fprintf(fout, "/* This file is automatically generated.  Do not edit. */\n");
+	fprintf(fout, "#ifndef _SELINUX_AV_PERMISSIONS_H_\n#define _SELINUX_AV_PERMISSIONS_H_\n\n");
+
+	for (i = 0; secclass_map[i].name; i++) {
+		struct security_class_mapping *map = &secclass_map[i];
+		for (j = 0; map->perms[j]; j++) {
+			fprintf(fout, "#define %s__%s", map->name,
+				map->perms[j]);
+			for (k = 0; k < max(1, 40 - strlen(map->name) - strlen(map->perms[j])); k++)
+				fprintf(fout, " ");
+			fprintf(fout, "0x%08xUL\n", (1<<j));
+		}
+	}
+
+	fprintf(fout, "\n#endif\n");
+	fclose(fout);
+	exit(0);
+}
