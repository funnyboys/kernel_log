commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 41f83700ee91..f5205fb9c1ff 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -1,20 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright 2007 Jon Loeliger, Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
- *                                                                   USA
  */
 
 #define _GNU_SOURCE

commit c2e7075ca83036317cee4a564729eb82a5433169
Author: Rob Herring <robh@kernel.org>
Date:   Wed Nov 28 18:37:35 2018 -0600

    scripts/dtc: Update to upstream version v1.4.7-57-gf267e674d145
    
    This adds the following commits from upstream:
    
    f267e674d145 checks: Fix crash with multiple source annotations
    3616b9a811b6 checks: Use source position information for check failures
    2bdbd07a1223 checks: Make each message output atomic
    a1eff70c02cf util: Add xa{v}sprintf_append functions
    82a52ce4573b libfdt: Add a test for fdt_getprop_by_offset()
    607b8586b383 PEP8 / Flake8 cleanups for setup.py
    f9c0a425b648 Remove broken objdir / srcdir support
    5182b5e6f28c pylibfdt: Use common PREFIX variable
    d45bf1f5f2a6 Refine make tests_clean target
    99284c4db9cb Refine pylibfdt_clean target
    a4629cfaedfb Refine libfdt_clean target
    08380fc43aa2 tests: Use modern octal literals for Python
    8113c00b99d3 pylibfdt: Allow switch to Python 3 via environment variable PYTHON
    11738cf01f15 libfdt: Don't use memcpy to handle unaligned reads on ARM
    86a288a73670 checks: Restructure check_msg to decrease indentation
    5667e7ef9a9a annotations: add the annotation functionality
    8e20ccf52f90 annotations: add positions
    ca930e20bb54 tests: Don't lose errors from make checkm
    43366bb4eeee tests: Property count valgrind errors in wrapped tests
    5062516fb8cb srcpos: Remove srcpos_empty
    a3143fafbf83 Revert "annotations: add positions"
    403cc79f06a1 checks: Update SPI bus check for 'spi-slave'
    baa1d2cf7894 annotations: add positions
    ff2ad38f6a5a Merge remote-tracking branch 'origin/pr/18'
    aa7254d9cb17 libfdt: return correct value if #size-cells property is not present
    49903aed7783 use ptrdiff_t modifier for printing pointer differences
    da2b691ccf68 treesource: Fix dts output for phandles in middle of a sequence of ints
    8f8b77a0d62d tests: Wrap check_align() calls with base_run_test()
    522d81d572f2 Fix dts output with a REF_PATH marker
    e45198c98359 Added test cases for target references
    0fcffda15e9f Merge nodes with local target label references
    1e4a0928f3b3 pylibfdt: Don't have setup.py depend on where it's invoked from
    ca399b14956f pylibfdt: Eliminate run_setup make function
    98972f1b3e33 pylibfdt: Improved version extraction
    7ba2be6cda5f pylibfdt: Don't silence setup.py when V=1
    7691f9d39301 pylibfdt: Make SETUP make variable
    855b9963def9 pylibfdt: Simpler CFLAGS handling
    47cafbeeb977 pylibfdt: Link extension module with libfdt rather than rebuilding
    dd695d6afb19 pylibfdt: Correctly set build output directory
    59327523d0d8 pylibfdt: We don't need include files from the base directory
    e84742aa7b93 checks: fix simple-bus compatible matching
    8c59a97ce096 Fix missing labels when emitting dts format
    d448f9a5fd94 Revert dts output formatting changes of spaces around brackets
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index cb6ed0e3e5e4..41f83700ee91 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -33,6 +33,9 @@ struct search_path {
 /* This is the list of directories that we search for source files */
 static struct search_path *search_path_head, **search_path_tail;
 
+/* Detect infinite include recursion. */
+#define MAX_SRCFILE_DEPTH     (100)
+static int srcfile_depth; /* = 0 */
 
 static char *get_dirname(const char *path)
 {
@@ -51,11 +54,51 @@ static char *get_dirname(const char *path)
 
 FILE *depfile; /* = NULL */
 struct srcfile_state *current_srcfile; /* = NULL */
+static char *initial_path; /* = NULL */
+static int initial_pathlen; /* = 0 */
+static bool initial_cpp = true;
 
-/* Detect infinite include recursion. */
-#define MAX_SRCFILE_DEPTH     (100)
-static int srcfile_depth; /* = 0 */
+static void set_initial_path(char *fname)
+{
+	int i, len = strlen(fname);
 
+	xasprintf(&initial_path, "%s", fname);
+	initial_pathlen = 0;
+	for (i = 0; i != len; i++)
+		if (initial_path[i] == '/')
+			initial_pathlen++;
+}
+
+static char *shorten_to_initial_path(char *fname)
+{
+	char *p1, *p2, *prevslash1 = NULL;
+	int slashes = 0;
+
+	for (p1 = fname, p2 = initial_path; *p1 && *p2; p1++, p2++) {
+		if (*p1 != *p2)
+			break;
+		if (*p1 == '/') {
+			prevslash1 = p1;
+			slashes++;
+		}
+	}
+	p1 = prevslash1 + 1;
+	if (prevslash1) {
+		int diff = initial_pathlen - slashes, i, j;
+		int restlen = strlen(fname) - (p1 - fname);
+		char *res;
+
+		res = xmalloc((3 * diff) + restlen + 1);
+		for (i = 0, j = 0; i != diff; i++) {
+			res[j++] = '.';
+			res[j++] = '.';
+			res[j++] = '/';
+		}
+		strcpy(res + j, p1);
+		return res;
+	}
+	return NULL;
+}
 
 /**
  * Try to open a file in a given directory.
@@ -157,6 +200,9 @@ void srcfile_push(const char *fname)
 	srcfile->colno = 1;
 
 	current_srcfile = srcfile;
+
+	if (srcfile_depth == 1)
+		set_initial_path(srcfile->name);
 }
 
 bool srcfile_pop(void)
@@ -197,18 +243,6 @@ void srcfile_add_search_path(const char *dirname)
 	search_path_tail = &node->next;
 }
 
-/*
- * The empty source position.
- */
-
-struct srcpos srcpos_empty = {
-	.first_line = 0,
-	.first_column = 0,
-	.last_line = 0,
-	.last_column = 0,
-	.file = NULL,
-};
-
 void srcpos_update(struct srcpos *pos, const char *text, int len)
 {
 	int i;
@@ -234,13 +268,35 @@ struct srcpos *
 srcpos_copy(struct srcpos *pos)
 {
 	struct srcpos *pos_new;
+	struct srcfile_state *srcfile_state;
+
+	if (!pos)
+		return NULL;
 
 	pos_new = xmalloc(sizeof(struct srcpos));
+	assert(pos->next == NULL);
 	memcpy(pos_new, pos, sizeof(struct srcpos));
 
+	/* allocate without free */
+	srcfile_state = xmalloc(sizeof(struct srcfile_state));
+	memcpy(srcfile_state, pos->file, sizeof(struct srcfile_state));
+	pos_new->file = srcfile_state;
+
 	return pos_new;
 }
 
+struct srcpos *srcpos_extend(struct srcpos *pos, struct srcpos *newtail)
+{
+	struct srcpos *p;
+
+	if (!pos)
+		return newtail;
+
+	for (p = pos; p->next != NULL; p = p->next);
+	p->next = newtail;
+	return pos;
+}
+
 char *
 srcpos_string(struct srcpos *pos)
 {
@@ -266,6 +322,68 @@ srcpos_string(struct srcpos *pos)
 	return pos_str;
 }
 
+static char *
+srcpos_string_comment(struct srcpos *pos, bool first_line, int level)
+{
+	char *pos_str, *fname, *first, *rest;
+	bool fresh_fname = false;
+
+	if (!pos) {
+		if (level > 1) {
+			xasprintf(&pos_str, "<no-file>:<no-line>");
+			return pos_str;
+		} else {
+			return NULL;
+		}
+	}
+
+	if (!pos->file)
+		fname = "<no-file>";
+	else if (!pos->file->name)
+		fname = "<no-filename>";
+	else if (level > 1)
+		fname = pos->file->name;
+	else {
+		fname = shorten_to_initial_path(pos->file->name);
+		if (fname)
+			fresh_fname = true;
+		else
+			fname = pos->file->name;
+	}
+
+	if (level > 1)
+		xasprintf(&first, "%s:%d:%d-%d:%d", fname,
+			  pos->first_line, pos->first_column,
+			  pos->last_line, pos->last_column);
+	else
+		xasprintf(&first, "%s:%d", fname,
+			  first_line ? pos->first_line : pos->last_line);
+
+	if (fresh_fname)
+		free(fname);
+
+	if (pos->next != NULL) {
+		rest = srcpos_string_comment(pos->next, first_line, level);
+		xasprintf(&pos_str, "%s, %s", first, rest);
+		free(first);
+		free(rest);
+	} else {
+		pos_str = first;
+	}
+
+	return pos_str;
+}
+
+char *srcpos_string_first(struct srcpos *pos, int level)
+{
+	return srcpos_string_comment(pos, true, level);
+}
+
+char *srcpos_string_last(struct srcpos *pos, int level)
+{
+	return srcpos_string_comment(pos, false, level);
+}
+
 void srcpos_verror(struct srcpos *pos, const char *prefix,
 		   const char *fmt, va_list va)
 {
@@ -294,4 +412,9 @@ void srcpos_set_line(char *f, int l)
 {
 	current_srcfile->name = f;
 	current_srcfile->lineno = l;
+
+	if (initial_cpp) {
+		initial_cpp = false;
+		set_initial_path(f);
+	}
 }

commit 9130ba884640328bb78aaa4840e5ddf06ccafb1c
Author: Rob Herring <robh@kernel.org>
Date:   Tue Feb 27 17:40:38 2018 -0600

    scripts/dtc: Update to upstream version v1.4.6-9-gaadd0b65c987
    
    This adds the following commits from upstream:
    
    aadd0b65c987 checks: centralize printing of property names in failure messages
    88960e398907 checks: centralize printing of node path in check_msg
    f1879e1a50eb Add limited read-only support for older (V2 and V3) device tree to libfdt.
    37dea76e9700 srcpos: drop special handling of tab
    65893da4aee0 libfdt: overlay: Add missing license
    962a45ca034d Avoid installing pylibfdt when dependencies are missing
    cd6ea1b2bea6 Makefile: Split INSTALL out into INSTALL_{PROGRAM,LIB,DATA,SCRIPT}
    51b3a16338df Makefile.tests: Add LIBDL make(1) variable for portability sake
    333d533a8f4d Attempt to auto-detect stat(1) being used if not given proper invocation
    e54388015af1 dtc: Bump version to v1.4.6
    a1fe86f380cb fdtoverlay: Switch from using alloca to malloc
    c8d5472de3ff tests: Improve compatibility with other platforms
    c81d389a10cc checks: add chosen node checks
    e671852042a7 checks: add aliases node checks
    d0c44ebe3f42 checks: check for #{size,address}-cells without child nodes
    18a3d84bb802 checks: add string list check for *-names properties
    8fe94fd6f19f checks: add string list check
    6c5730819604 checks: add a string check for 'label' property
    a384191eba09 checks: fix sound-dai phandle with arg property check
    b260c4f610c0 Fix ambiguous grammar for devicetree rule
    fe667e382bac tests: Add some basic tests for the pci_bridge checks
    7975f6422260 Fix widespread incorrect use of strneq(), replace with new strprefixeq()
    fca296445eab Add strstarts() helper function
    cc392f089007 tests: Check non-matching cases for fdt_node_check_compatible()
    bba26a5291c8 livetree: avoid assertion of orphan phandles with overlays
    c8f8194d76cc implement strnlen for systems that need it
    c8b38f65fdec libfdt: Remove leading underscores from identifiers
    3b62fdaebfe5 Remove leading underscores from identifiers
    2d45d1c5c65e Replace FDT_VERSION() with stringify()
    2e6fe5a107b5 Fix some errors in comments
    b0ae9e4b0ceb tests: Correct warning in sw_tree1.c
    
    Commit c8b38f65fdec upstream ("libfdt: Remove leading underscores from
    identifiers") changed the multiple inclusion define protection, so the
    kernel's libfdt_env.h needs the corresponding update.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 9d38459902f3..cb6ed0e3e5e4 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -209,8 +209,6 @@ struct srcpos srcpos_empty = {
 	.file = NULL,
 };
 
-#define TAB_SIZE      8
-
 void srcpos_update(struct srcpos *pos, const char *text, int len)
 {
 	int i;
@@ -224,9 +222,6 @@ void srcpos_update(struct srcpos *pos, const char *text, int len)
 		if (text[i] == '\n') {
 			current_srcfile->lineno++;
 			current_srcfile->colno = 1;
-		} else if (text[i] == '\t') {
-			current_srcfile->colno =
-				ALIGN(current_srcfile->colno, TAB_SIZE);
 		} else {
 			current_srcfile->colno++;
 		}

commit 89d123106a97bf412a4c10482044c822f4b069f7
Author: Rob Herring <robh@kernel.org>
Date:   Tue Mar 21 09:01:08 2017 -0500

    scripts/dtc: Update to upstream version v1.4.4-8-g756ffc4f52f6
    
    This adds the following commits from upstream:
    
    756ffc4f52f6 Build pylibfdt as part of the normal build process
    8cb3896358e9 Adjust libfdt.h to work with swig
    b40aa8359aff Mention pylibfdt in the documentation
    12cfb740cc76 Add tests for pylibfdt
    50f250701631 Add an initial Python library for libfdt
    cdbb2b6c7a3a checks: Warn on node name unit-addresses with '0x' or leading 0s
    4c15d5da17cc checks: Add bus checks for simple-bus buses
    33c3985226d3 checks: Add bus checks for PCI buses
    558cd81bdd43 dtc: Bump version to v1.4.4
    c17a811c62eb fdtput: Remove star from value_len documentation
    194d5caaefcb fdtget: Use @return to document the return value
    d922ecdd017b tests: Make realloc_fdt() really allocate *fdt
    921cc17fec29 libfdt: overlay: Check the value of the right variable
    9ffdf60bf463 dtc: Simplify asm_emit_string() implementation
    881012e44386 libfdt: Change names of sparse helper macros
    bad5b28049e5 Fix assorted sparse warnings
    672ac09ea04d Clean up gcc attributes
    49300f2ade6a dtc: Don't abuse struct fdt_reserve_entry
    fa8bc7f928ac dtc: Bump version to v1.4.3
    34a9886a177f Add printf format attributes
    f72508e2b6ca Correct some broken printf() like format mismatches
    397d5ef0203c libfdt: Add fdt_setprop_empty()
    69a1bd6ad3f9 libfdt: Remove undefined behaviour setting empty properties
    acd1b534a592 Print output filename as part of warning messages
    120775eb1cf3 dtc: Use streq() in preference to strcmp()
    852e9ecbe197 checks: Add Warning for stricter node name character checking
    ef0e8f061534 checks: Add Warning for stricter property name character checking
    00d7bb1f4b0e dtc: pos parameter to srcpos_string() can't be NULL
    95d57726bca4 livetree.c: Fix memory leak
    3b9c97093d6e dtc: Fix NULL pointer use in dtlabel + dtref case
    43eb551426ea manual: Fix typo it -> in
    4baf15f7f13f Makefile: Add tags rule
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index aa3aad04cec4..9d38459902f3 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -252,7 +252,7 @@ srcpos_string(struct srcpos *pos)
 	const char *fname = "<no-file>";
 	char *pos_str;
 
-	if (pos)
+	if (pos->file && pos->file->name)
 		fname = pos->file->name;
 
 

commit 6f05afcbb031722ec1eff77dde188ff2edf8940e
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jan 4 10:45:20 2017 -0600

    scripts/dtc: Update to upstream version 0931cea3ba20
    
    Sync to upstream dtc commit 0931cea3ba20 ("dtc: fdtdump: check fdt if
    not in scanning mode"). In particular, this pulls in dtc overlay
    support.
    
    This adds the following commits from upstream:
    
    f88865469b65 dtc: Fix memory leak in character literal parsing
    00fbb8696b66 Rename boot_info
    1ef86ad2c24f dtc: Clean up /dts-v1/ and /plugin/ handling in grammar
    e3c769aa9c16 dtc: Don't always generate __symbols__ for plugins
    c96cb3c0169e tests: Don't use -@ on plugin de/recompile tests
    66381538ce24 tests: Remove "suppression of fixups" tests
    ba765b273f0f tests: Clarify dtc overlay tests
    6ea8cd944fcd tests: More thorough tests of libfdt overlay application without dtc
    7d8ef6e1db97 tests: Correct fdt handling of overlays without fixups and base trees without symbols
    b4dc0ed8b127 tests: Fix double expansion bugs in test code
    3ea879dc0c8f tests: Split overlay tests into those with do/don't exercise dtc plugin generation
    47b4d66a2f11 tests: Test auto-alias generation on base tree, not overlay
    72e1ad811523 tests: Make overlay/plugin tests unconditional
    e7b3c3b5951b tests: Add overlay tests
    9637e3f772a9 tests: Add check_path test
    20f29d8d41f6 dtc: Plugin and fixup support
    a2c92cac53f8 dtc: Document the dynamic plugin internals
    8f70ac39801d checks: Pass boot_info instead of root node
    ea10f953878f libfdt: add missing errors to fdt_strerror()
    daa75e8fa594 libfdt: fix fdt_stringlist_search()
    e28eff5b787a libfdt: fix fdt_stringlist_count()
    ae97c7722840 tests: overlay: Rename the device tree blobs to be more explicit
    96162d2bd9cb tests: overlay: Add test suffix to the compiled blobs
    5ce8634733b7 libfdt: Add fdt_overlay_apply to the exported symbols
    804a9db90ad2 fdt: strerr: Remove spurious BADOVERLAY
    e8c3a1a493fa tests: overlay: Move back the bad fixup tests
    7a72d89d3f81 libfdt: overlay: Fix symbols and fixups nodes condition
    cabbaa972cdd libfdt: overlay: Report a bad overlay for mismatching local fixups
    deb0a5c1aeaa libfdt: Add BADPHANDLE error string
    7b7a6be9ba15 libfdt: Don't use 'index' as a local variable name
    aea8860d831e tests: Add tests cases for the overlay code
    0cdd06c5135b libfdt: Add overlay application function
    39240cc865cf libfdt: Extend the reach of FDT_ERR_BADPHANDLE
    4aa3a6f5e6d9 libfdt: Add new errors for the overlay code
    6d1832c9e64b dtc: Remove "home page" link
    45fd440a9561 Fix some typing errors in libfdt.h and livetree.c
    a59be4939c13 Merge tag 'v1.4.2'
    a34bb721caca dtc: Fix assorted problems in the testcases for the -a option
    874f40588d3e Implement the -a option to pad dtb aligned
    ec02b34c05be dtc: Makefile improvements for release uploading
    1ed45d40a137 dtc: Bump version to 1.4.2
    36fd7331fb11 libfdt: simplify fdt_del_mem_rsv()
    d877364e4a0f libfdt: Add fdt_setprop_inplace_namelen_partial
    3e9037aaad44 libfdt: Add fdt_getprop_namelen_w
    84e0e1346c68 libfdt: Add max phandle retrieval function
    d29126c90acb libfdt: Add iterator over properties
    902d0f0953d0 libfdt: Add a subnodes iterator macro
    c539075ba8ba fdtput.c: Fix memory leak.
    f79ddb83e185 fdtget.c: Fix memory leak
    1074ee54b63f convert-dtsv0-lexer.l: fix memory leak
    e24d39a024e6 fdtdump.c: make sure size_t argument to memchr is always unsigned.
    44a59713cf05 Remove unused srcpos_dump() function
    cb9241ae3453 DTC: Fix memory leak on flatname.
    1ee0ae24ea09 Simplify check field and macro names
    9d97527a8621 Remove property check functions
    2e709d158e11 Remove tree check functions
    c4cb12e193e3 Alter grammar to allow multiple /dts-v1/ tags
    d71d25d76012 Use xasprintf() in srcpos
    9dc404958e9c util: Add xasprintf portable asprintf variant
    beef80b8b55f Correct a missing space in a fdt_header cast
    68d43cec1253 Correct line lengths in libfdt.h
    b0dbceafd49a Correct space-after-tab in libfdt.h
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index f534c22a888d..aa3aad04cec4 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -246,46 +246,27 @@ srcpos_copy(struct srcpos *pos)
 	return pos_new;
 }
 
-
-
-void
-srcpos_dump(struct srcpos *pos)
-{
-	printf("file        : \"%s\"\n",
-	       pos->file ? (char *) pos->file : "<no file>");
-	printf("first_line  : %d\n", pos->first_line);
-	printf("first_column: %d\n", pos->first_column);
-	printf("last_line   : %d\n", pos->last_line);
-	printf("last_column : %d\n", pos->last_column);
-	printf("file        : %s\n", pos->file->name);
-}
-
-
 char *
 srcpos_string(struct srcpos *pos)
 {
 	const char *fname = "<no-file>";
 	char *pos_str;
-	int rc;
 
 	if (pos)
 		fname = pos->file->name;
 
 
 	if (pos->first_line != pos->last_line)
-		rc = asprintf(&pos_str, "%s:%d.%d-%d.%d", fname,
-			      pos->first_line, pos->first_column,
-			      pos->last_line, pos->last_column);
+		xasprintf(&pos_str, "%s:%d.%d-%d.%d", fname,
+			  pos->first_line, pos->first_column,
+			  pos->last_line, pos->last_column);
 	else if (pos->first_column != pos->last_column)
-		rc = asprintf(&pos_str, "%s:%d.%d-%d", fname,
-			      pos->first_line, pos->first_column,
-			      pos->last_column);
+		xasprintf(&pos_str, "%s:%d.%d-%d", fname,
+			  pos->first_line, pos->first_column,
+			  pos->last_column);
 	else
-		rc = asprintf(&pos_str, "%s:%d.%d", fname,
-			      pos->first_line, pos->first_column);
-
-	if (rc == -1)
-		die("Couldn't allocate in srcpos string");
+		xasprintf(&pos_str, "%s:%d.%d", fname,
+			  pos->first_line, pos->first_column);
 
 	return pos_str;
 }

commit 4760597116e34bd58f670d008ae7323653268fb4
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 29 16:00:05 2015 -0500

    scripts/dtc: Update to upstream version 9d3649bd3be245c9
    
    Sync dtc with upstream as of commit 9d3649bd3be2 (Add testcases for
    fdt_path_offset_namelen()).
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: devicetree@vger.kernel.org

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index c20bc5315bc1..f534c22a888d 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -34,7 +34,7 @@ struct search_path {
 static struct search_path *search_path_head, **search_path_tail;
 
 
-static char *dirname(const char *path)
+static char *get_dirname(const char *path)
 {
 	const char *slash = strrchr(path, '/');
 
@@ -77,7 +77,7 @@ static char *try_open(const char *dirname, const char *fname, FILE **fp)
 	else
 		fullname = join_path(dirname, fname);
 
-	*fp = fopen(fullname, "r");
+	*fp = fopen(fullname, "rb");
 	if (!*fp) {
 		free(fullname);
 		fullname = NULL;
@@ -150,7 +150,7 @@ void srcfile_push(const char *fname)
 	srcfile = xmalloc(sizeof(*srcfile));
 
 	srcfile->f = srcfile_relative_open(fname, &srcfile->name);
-	srcfile->dir = dirname(srcfile->name);
+	srcfile->dir = get_dirname(srcfile->name);
 	srcfile->prev = current_srcfile;
 
 	srcfile->lineno = 1;
@@ -159,7 +159,7 @@ void srcfile_push(const char *fname)
 	current_srcfile = srcfile;
 }
 
-int srcfile_pop(void)
+bool srcfile_pop(void)
 {
 	struct srcfile_state *srcfile = current_srcfile;
 
@@ -177,7 +177,7 @@ int srcfile_pop(void)
 	 * fix this we could either allocate all the files from a
 	 * table, or use a pool allocator. */
 
-	return current_srcfile ? 1 : 0;
+	return current_srcfile ? true : false;
 }
 
 void srcfile_add_search_path(const char *dirname)
@@ -290,42 +290,27 @@ srcpos_string(struct srcpos *pos)
 	return pos_str;
 }
 
-void
-srcpos_verror(struct srcpos *pos, char const *fmt, va_list va)
+void srcpos_verror(struct srcpos *pos, const char *prefix,
+		   const char *fmt, va_list va)
 {
-       const char *srcstr;
-
-       srcstr = srcpos_string(pos);
+	char *srcstr;
 
-       fprintf(stderr, "Error: %s ", srcstr);
-       vfprintf(stderr, fmt, va);
-       fprintf(stderr, "\n");
-}
+	srcstr = srcpos_string(pos);
 
-void
-srcpos_error(struct srcpos *pos, char const *fmt, ...)
-{
-	va_list va;
+	fprintf(stderr, "%s: %s ", prefix, srcstr);
+	vfprintf(stderr, fmt, va);
+	fprintf(stderr, "\n");
 
-	va_start(va, fmt);
-	srcpos_verror(pos, fmt, va);
-	va_end(va);
+	free(srcstr);
 }
 
-
-void
-srcpos_warn(struct srcpos *pos, char const *fmt, ...)
+void srcpos_error(struct srcpos *pos, const char *prefix,
+		  const char *fmt, ...)
 {
-	const char *srcstr;
 	va_list va;
-	va_start(va, fmt);
-
-	srcstr = srcpos_string(pos);
-
-	fprintf(stderr, "Warning: %s ", srcstr);
-	vfprintf(stderr, fmt, va);
-	fprintf(stderr, "\n");
 
+	va_start(va, fmt);
+	srcpos_verror(pos, prefix, fmt, va);
 	va_end(va);
 }
 

commit 73ab39b14cdf6b83da6817166f6c8a9dcc25e392
Author: Grant Likely <grant.likely@linaro.org>
Date:   Tue Jan 21 12:54:49 2014 +0000

    scripts/dtc: Update to upstream version v1.4.0
    
    Update to the latest version of dtc with the following notable
    enhancements and bug fixes:
    
    * fdtput: expand fdt if value does not fit
    * dtc/fdt{get, put}/convert-dtsv0-lexer: convert to new usage helpers
    * libfdt: Add fdt_next_subnode() to permit easy subnode iteration
    * utilfdt_read: pass back up the length of data read
    * util_version: new helper for displaying version info
    * die: constify format string arg
    * utilfdt_read_err: use xmalloc funcs
    * Export fdt_stringlist_contains()
    * dtc: Drop the '-S is deprecated' warning
    * dtc/libfdt: sparse fixes
    * dtc/libfdt: introduce fdt types for annotation by endian checkers
    * Fix util_is_printable_string
    * dtc: srcpos_verror() should print to stderr
    * libfdt: Added missing functions to shared library
    
    Shipped bison/flex generated files were built on an Ubuntu 13.10 system.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 246ab4bc0d9d..c20bc5315bc1 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -297,9 +297,9 @@ srcpos_verror(struct srcpos *pos, char const *fmt, va_list va)
 
        srcstr = srcpos_string(pos);
 
-       fprintf(stdout, "Error: %s ", srcstr);
-       vfprintf(stdout, fmt, va);
-       fprintf(stdout, "\n");
+       fprintf(stderr, "Error: %s ", srcstr);
+       vfprintf(stderr, fmt, va);
+       fprintf(stderr, "\n");
 }
 
 void

commit cd296721a9645f9f28800a072490fa15458d1fb7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Sep 28 21:25:59 2012 +0000

    dtc: import latest upstream dtc
    
    This updates scripts/dtc to commit 317a5d9 "dtc: zero out new label
    objects" from git://git.jdl.com/software/dtc.git.
    
    This adds features such as:
    * /bits/ syntax for cell data.
    * Math expressions within cell data.
    * The ability to delete properties or nodes.
    * Support for #line directives in the input file, which allows the use of
      cpp on *.dts.
    * -i command-line option (/include/ path)
    * -W/-E command-line options for error/warning control.
    * Removal of spew to STDOUT containing the filename being compiled.
    * Many additions to the libfdt API.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Jon Loeliger <jdl@jdl.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 36a38e9f1a2c..246ab4bc0d9d 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -24,6 +24,15 @@
 #include "dtc.h"
 #include "srcpos.h"
 
+/* A node in our list of directories to search for source/include files */
+struct search_path {
+	struct search_path *next;	/* next node in list, NULL for end */
+	const char *dirname;		/* name of directory to search */
+};
+
+/* This is the list of directories that we search for source files */
+static struct search_path *search_path_head, **search_path_tail;
+
 
 static char *dirname(const char *path)
 {
@@ -47,6 +56,64 @@ struct srcfile_state *current_srcfile; /* = NULL */
 #define MAX_SRCFILE_DEPTH     (100)
 static int srcfile_depth; /* = 0 */
 
+
+/**
+ * Try to open a file in a given directory.
+ *
+ * If the filename is an absolute path, then dirname is ignored. If it is a
+ * relative path, then we look in that directory for the file.
+ *
+ * @param dirname	Directory to look in, or NULL for none
+ * @param fname		Filename to look for
+ * @param fp		Set to NULL if file did not open
+ * @return allocated filename on success (caller must free), NULL on failure
+ */
+static char *try_open(const char *dirname, const char *fname, FILE **fp)
+{
+	char *fullname;
+
+	if (!dirname || fname[0] == '/')
+		fullname = xstrdup(fname);
+	else
+		fullname = join_path(dirname, fname);
+
+	*fp = fopen(fullname, "r");
+	if (!*fp) {
+		free(fullname);
+		fullname = NULL;
+	}
+
+	return fullname;
+}
+
+/**
+ * Open a file for read access
+ *
+ * If it is a relative filename, we search the full search path for it.
+ *
+ * @param fname	Filename to open
+ * @param fp	Returns pointer to opened FILE, or NULL on failure
+ * @return pointer to allocated filename, which caller must free
+ */
+static char *fopen_any_on_path(const char *fname, FILE **fp)
+{
+	const char *cur_dir = NULL;
+	struct search_path *node;
+	char *fullname;
+
+	/* Try current directory first */
+	assert(fp);
+	if (current_srcfile)
+		cur_dir = current_srcfile->dir;
+	fullname = try_open(cur_dir, fname, fp);
+
+	/* Failing that, try each search path in turn */
+	for (node = search_path_head; !*fp && node; node = node->next)
+		fullname = try_open(node->dirname, fname, fp);
+
+	return fullname;
+}
+
 FILE *srcfile_relative_open(const char *fname, char **fullnamep)
 {
 	FILE *f;
@@ -56,13 +123,7 @@ FILE *srcfile_relative_open(const char *fname, char **fullnamep)
 		f = stdin;
 		fullname = xstrdup("<stdin>");
 	} else {
-		if (!current_srcfile || !current_srcfile->dir
-		    || (fname[0] == '/'))
-			fullname = xstrdup(fname);
-		else
-			fullname = join_path(current_srcfile->dir, fname);
-
-		f = fopen(fullname, "r");
+		fullname = fopen_any_on_path(fname, &f);
 		if (!f)
 			die("Couldn't open \"%s\": %s\n", fname,
 			    strerror(errno));
@@ -119,6 +180,23 @@ int srcfile_pop(void)
 	return current_srcfile ? 1 : 0;
 }
 
+void srcfile_add_search_path(const char *dirname)
+{
+	struct search_path *node;
+
+	/* Create the node */
+	node = xmalloc(sizeof(*node));
+	node->next = NULL;
+	node->dirname = xstrdup(dirname);
+
+	/* Add to the end of our list */
+	if (search_path_tail)
+		*search_path_tail = node;
+	else
+		search_path_head = node;
+	search_path_tail = &node->next;
+}
+
 /*
  * The empty source position.
  */
@@ -250,3 +328,9 @@ srcpos_warn(struct srcpos *pos, char const *fmt, ...)
 
 	va_end(va);
 }
+
+void srcpos_set_line(char *f, int l)
+{
+	current_srcfile->name = f;
+	current_srcfile->lineno = l;
+}

commit 136ec2049fea65aed0446d04ab7cfff2ae3070f1
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Jan 10 17:27:52 2012 -0700

    dtc: Implement -d option to write out a dependency file
    
    This will allow callers to rebuild .dtb files when any of the /include/d
    .dtsi files are modified, not just the top-level .dts file.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 2dbc874288ca..36a38e9f1a2c 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -40,6 +40,7 @@ static char *dirname(const char *path)
 	return NULL;
 }
 
+FILE *depfile; /* = NULL */
 struct srcfile_state *current_srcfile; /* = NULL */
 
 /* Detect infinite include recursion. */
@@ -67,6 +68,9 @@ FILE *srcfile_relative_open(const char *fname, char **fullnamep)
 			    strerror(errno));
 	}
 
+	if (depfile)
+		fprintf(depfile, " %s", fullname);
+
 	if (fullnamep)
 		*fullnamep = fullname;
 	else

commit 658f29a51e9830e620bb9a1ce3534b318a38bfeb
Author: John Bonesio <bones@secretlab.ca>
Date:   Wed Nov 17 15:28:20 2010 -0800

    of/flattree: Update dtc to current mainline.
    
    Pull in recent changes from the main dtc repository. These changes
    primarily allow multiple device trees to be declared which are merged
    by dtc. This feature allows us to include a basic dts file and then
    provide more information for the specific system through the merging
    functionality.
    
    Changes pulled from git://git.jdl.com/software/dtc.git
    commit id: 37c0b6a0, "dtc: Add code to make diffing trees easier"
    
    Signed-off-by: John Bonesio <bones@secretlab.ca>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
index 9641b7628b4d..2dbc874288ca 100644
--- a/scripts/dtc/srcpos.c
+++ b/scripts/dtc/srcpos.c
@@ -17,100 +17,232 @@
  *                                                                   USA
  */
 
+#define _GNU_SOURCE
+
+#include <stdio.h>
+
 #include "dtc.h"
 #include "srcpos.h"
 
-/*
- * Like yylineno, this is the current open file pos.
- */
 
-struct dtc_file *srcpos_file;
+static char *dirname(const char *path)
+{
+	const char *slash = strrchr(path, '/');
+
+	if (slash) {
+		int len = slash - path;
+		char *dir = xmalloc(len + 1);
+
+		memcpy(dir, path, len);
+		dir[len] = '\0';
+		return dir;
+	}
+	return NULL;
+}
+
+struct srcfile_state *current_srcfile; /* = NULL */
 
-static int dtc_open_one(struct dtc_file *file,
-                        const char *search,
-                        const char *fname)
+/* Detect infinite include recursion. */
+#define MAX_SRCFILE_DEPTH     (100)
+static int srcfile_depth; /* = 0 */
+
+FILE *srcfile_relative_open(const char *fname, char **fullnamep)
 {
+	FILE *f;
 	char *fullname;
 
-	if (search) {
-		fullname = xmalloc(strlen(search) + strlen(fname) + 2);
-
-		strcpy(fullname, search);
-		strcat(fullname, "/");
-		strcat(fullname, fname);
+	if (streq(fname, "-")) {
+		f = stdin;
+		fullname = xstrdup("<stdin>");
 	} else {
-		fullname = strdup(fname);
+		if (!current_srcfile || !current_srcfile->dir
+		    || (fname[0] == '/'))
+			fullname = xstrdup(fname);
+		else
+			fullname = join_path(current_srcfile->dir, fname);
+
+		f = fopen(fullname, "r");
+		if (!f)
+			die("Couldn't open \"%s\": %s\n", fname,
+			    strerror(errno));
 	}
 
-	file->file = fopen(fullname, "r");
-	if (!file->file) {
+	if (fullnamep)
+		*fullnamep = fullname;
+	else
 		free(fullname);
-		return 0;
-	}
 
-	file->name = fullname;
-	return 1;
+	return f;
 }
 
+void srcfile_push(const char *fname)
+{
+	struct srcfile_state *srcfile;
+
+	if (srcfile_depth++ >= MAX_SRCFILE_DEPTH)
+		die("Includes nested too deeply");
+
+	srcfile = xmalloc(sizeof(*srcfile));
+
+	srcfile->f = srcfile_relative_open(fname, &srcfile->name);
+	srcfile->dir = dirname(srcfile->name);
+	srcfile->prev = current_srcfile;
+
+	srcfile->lineno = 1;
+	srcfile->colno = 1;
+
+	current_srcfile = srcfile;
+}
 
-struct dtc_file *dtc_open_file(const char *fname,
-                               const struct search_path *search)
+int srcfile_pop(void)
 {
-	static const struct search_path default_search = { NULL, NULL, NULL };
+	struct srcfile_state *srcfile = current_srcfile;
 
-	struct dtc_file *file;
-	const char *slash;
+	assert(srcfile);
 
-	file = xmalloc(sizeof(struct dtc_file));
+	current_srcfile = srcfile->prev;
 
-	slash = strrchr(fname, '/');
-	if (slash) {
-		char *dir = xmalloc(slash - fname + 1);
+	if (fclose(srcfile->f))
+		die("Error closing \"%s\": %s\n", srcfile->name,
+		    strerror(errno));
 
-		memcpy(dir, fname, slash - fname);
-		dir[slash - fname] = 0;
-		file->dir = dir;
-	} else {
-		file->dir = NULL;
-	}
+	/* FIXME: We allow the srcfile_state structure to leak,
+	 * because it could still be referenced from a location
+	 * variable being carried through the parser somewhere.  To
+	 * fix this we could either allocate all the files from a
+	 * table, or use a pool allocator. */
 
-	if (streq(fname, "-")) {
-		file->name = "stdin";
-		file->file = stdin;
-		return file;
-	}
+	return current_srcfile ? 1 : 0;
+}
 
-	if (fname[0] == '/') {
-		file->file = fopen(fname, "r");
-		if (!file->file)
-			goto fail;
+/*
+ * The empty source position.
+ */
 
-		file->name = strdup(fname);
-		return file;
-	}
+struct srcpos srcpos_empty = {
+	.first_line = 0,
+	.first_column = 0,
+	.last_line = 0,
+	.last_column = 0,
+	.file = NULL,
+};
 
-	if (!search)
-		search = &default_search;
+#define TAB_SIZE      8
 
-	while (search) {
-		if (dtc_open_one(file, search->dir, fname))
-			return file;
+void srcpos_update(struct srcpos *pos, const char *text, int len)
+{
+	int i;
+
+	pos->file = current_srcfile;
+
+	pos->first_line = current_srcfile->lineno;
+	pos->first_column = current_srcfile->colno;
+
+	for (i = 0; i < len; i++)
+		if (text[i] == '\n') {
+			current_srcfile->lineno++;
+			current_srcfile->colno = 1;
+		} else if (text[i] == '\t') {
+			current_srcfile->colno =
+				ALIGN(current_srcfile->colno, TAB_SIZE);
+		} else {
+			current_srcfile->colno++;
+		}
+
+	pos->last_line = current_srcfile->lineno;
+	pos->last_column = current_srcfile->colno;
+}
 
-		if (errno != ENOENT)
-			goto fail;
+struct srcpos *
+srcpos_copy(struct srcpos *pos)
+{
+	struct srcpos *pos_new;
 
-		search = search->next;
-	}
+	pos_new = xmalloc(sizeof(struct srcpos));
+	memcpy(pos_new, pos, sizeof(struct srcpos));
+
+	return pos_new;
+}
+
+
+
+void
+srcpos_dump(struct srcpos *pos)
+{
+	printf("file        : \"%s\"\n",
+	       pos->file ? (char *) pos->file : "<no file>");
+	printf("first_line  : %d\n", pos->first_line);
+	printf("first_column: %d\n", pos->first_column);
+	printf("last_line   : %d\n", pos->last_line);
+	printf("last_column : %d\n", pos->last_column);
+	printf("file        : %s\n", pos->file->name);
+}
 
-fail:
-	die("Couldn't open \"%s\": %s\n", fname, strerror(errno));
+
+char *
+srcpos_string(struct srcpos *pos)
+{
+	const char *fname = "<no-file>";
+	char *pos_str;
+	int rc;
+
+	if (pos)
+		fname = pos->file->name;
+
+
+	if (pos->first_line != pos->last_line)
+		rc = asprintf(&pos_str, "%s:%d.%d-%d.%d", fname,
+			      pos->first_line, pos->first_column,
+			      pos->last_line, pos->last_column);
+	else if (pos->first_column != pos->last_column)
+		rc = asprintf(&pos_str, "%s:%d.%d-%d", fname,
+			      pos->first_line, pos->first_column,
+			      pos->last_column);
+	else
+		rc = asprintf(&pos_str, "%s:%d.%d", fname,
+			      pos->first_line, pos->first_column);
+
+	if (rc == -1)
+		die("Couldn't allocate in srcpos string");
+
+	return pos_str;
+}
+
+void
+srcpos_verror(struct srcpos *pos, char const *fmt, va_list va)
+{
+       const char *srcstr;
+
+       srcstr = srcpos_string(pos);
+
+       fprintf(stdout, "Error: %s ", srcstr);
+       vfprintf(stdout, fmt, va);
+       fprintf(stdout, "\n");
 }
 
-void dtc_close_file(struct dtc_file *file)
+void
+srcpos_error(struct srcpos *pos, char const *fmt, ...)
 {
-	if (fclose(file->file))
-		die("Error closing \"%s\": %s\n", file->name, strerror(errno));
+	va_list va;
+
+	va_start(va, fmt);
+	srcpos_verror(pos, fmt, va);
+	va_end(va);
+}
+
+
+void
+srcpos_warn(struct srcpos *pos, char const *fmt, ...)
+{
+	const char *srcstr;
+	va_list va;
+	va_start(va, fmt);
+
+	srcstr = srcpos_string(pos);
+
+	fprintf(stderr, "Warning: %s ", srcstr);
+	vfprintf(stderr, fmt, va);
+	fprintf(stderr, "\n");
 
-	free(file->dir);
-	free(file);
+	va_end(va);
 }

commit 9fffb55f66127b52c937ede5196ebfa0c0d50bce
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Thu Apr 30 15:25:53 2009 +1000

    Move dtc and libfdt sources from arch/powerpc/boot to scripts/dtc
    
    The powerpc kernel always requires an Open Firmware like device tree
    to supply device information.  On systems without OF, this comes from
    a flattened device tree blob.  This blob is usually generated by dtc,
    a tool which compiles a text description of the device tree into the
    flattened format used by the kernel.  Sometimes, the bootwrapper makes
    small changes to the pre-compiled device tree blob (e.g. filling in
    the size of RAM).  To do this it uses the libfdt library.
    
    Because these are only used on powerpc, the code for both these tools
    is included under arch/powerpc/boot (these were imported and are
    periodically updated from the upstream dtc tree).
    
    However, the microblaze architecture, currently being prepared for
    merging to mainline also uses dtc to produce device tree blobs.  A few
    other archs have also mentioned some interest in using dtc.
    Therefore, this patch moves dtc and libfdt from arch/powerpc into
    scripts, where it can be used by any architecture.
    
    The vast bulk of this patch is a literal move, the rest is adjusting
    the various Makefiles to use dtc and libfdt correctly from their new
    locations.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/dtc/srcpos.c b/scripts/dtc/srcpos.c
new file mode 100644
index 000000000000..9641b7628b4d
--- /dev/null
+++ b/scripts/dtc/srcpos.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2007 Jon Loeliger, Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *                                                                   USA
+ */
+
+#include "dtc.h"
+#include "srcpos.h"
+
+/*
+ * Like yylineno, this is the current open file pos.
+ */
+
+struct dtc_file *srcpos_file;
+
+static int dtc_open_one(struct dtc_file *file,
+                        const char *search,
+                        const char *fname)
+{
+	char *fullname;
+
+	if (search) {
+		fullname = xmalloc(strlen(search) + strlen(fname) + 2);
+
+		strcpy(fullname, search);
+		strcat(fullname, "/");
+		strcat(fullname, fname);
+	} else {
+		fullname = strdup(fname);
+	}
+
+	file->file = fopen(fullname, "r");
+	if (!file->file) {
+		free(fullname);
+		return 0;
+	}
+
+	file->name = fullname;
+	return 1;
+}
+
+
+struct dtc_file *dtc_open_file(const char *fname,
+                               const struct search_path *search)
+{
+	static const struct search_path default_search = { NULL, NULL, NULL };
+
+	struct dtc_file *file;
+	const char *slash;
+
+	file = xmalloc(sizeof(struct dtc_file));
+
+	slash = strrchr(fname, '/');
+	if (slash) {
+		char *dir = xmalloc(slash - fname + 1);
+
+		memcpy(dir, fname, slash - fname);
+		dir[slash - fname] = 0;
+		file->dir = dir;
+	} else {
+		file->dir = NULL;
+	}
+
+	if (streq(fname, "-")) {
+		file->name = "stdin";
+		file->file = stdin;
+		return file;
+	}
+
+	if (fname[0] == '/') {
+		file->file = fopen(fname, "r");
+		if (!file->file)
+			goto fail;
+
+		file->name = strdup(fname);
+		return file;
+	}
+
+	if (!search)
+		search = &default_search;
+
+	while (search) {
+		if (dtc_open_one(file, search->dir, fname))
+			return file;
+
+		if (errno != ENOENT)
+			goto fail;
+
+		search = search->next;
+	}
+
+fail:
+	die("Couldn't open \"%s\": %s\n", fname, strerror(errno));
+}
+
+void dtc_close_file(struct dtc_file *file)
+{
+	if (fclose(file->file))
+		die("Error closing \"%s\": %s\n", file->name, strerror(errno));
+
+	free(file->dir);
+	free(file);
+}
