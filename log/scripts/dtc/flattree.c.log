commit 3eb619b2f7d8a98a86a48de8dfa613a205c0eaab
Author: Rob Herring <robh@kernel.org>
Date:   Mon Jun 29 12:15:13 2020 -0600

    scripts/dtc: Update to upstream version v1.6.0-11-g9d7888cbf19c
    
    Sync with upstream dtc primarily to pickup the I2C bus check fixes. The
    interrupt_provider check is noisy, so turn it off for now.
    
    This adds the following commits from upstream:
    
    9d7888cbf19c dtc: Consider one-character strings as strings
    8259d59f59de checks: Improve i2c reg property checking
    fdabcf2980a4 checks: Remove warning for I2C_OWN_SLAVE_ADDRESS
    2478b1652c8d libfdt: add extern "C" for C++
    f68bfc2668b2 libfdt: trivial typo fix
    7be250b4d059 libfdt: Correct condition for reordering blocks
    81e0919a3e21 checks: Add interrupt provider test
    85e5d839847a Makefile: when building libfdt only, do not add unneeded deps
    b28464a550c5 Fix some potential unaligned accesses in dtc
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index bd6977eedcb8..07f10d2b5d79 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -156,7 +156,7 @@ static void asm_emit_data(void *e, struct data d)
 		emit_offset_label(f, m->ref, m->offset);
 
 	while ((d.len - off) >= sizeof(uint32_t)) {
-		asm_emit_cell(e, fdt32_to_cpu(*((fdt32_t *)(d.val+off))));
+		asm_emit_cell(e, dtb_ld32(d.val + off));
 		off += sizeof(uint32_t);
 	}
 

commit 12869ecd5eef299cf3745bbeb9c6ce37f3b52cb3
Author: Rob Herring <robh@kernel.org>
Date:   Fri Jun 21 08:18:32 2019 -0600

    scripts/dtc: Update to upstream version v1.5.0-30-g702c1b6c0e73
    
    Pull in SPDX tag conversion from upstream dtc. This will replace the
    conversion done in the kernel tree copy in v5.2-rc2.
    
    This adds the following commits from upstream:
    
    702c1b6c0e73 README.license: Update to reflect SPDX tag usage
    4097bbffcf1d dtc: Add GPLv2 SPDX tags to files missing license text
    94f87cd5b7c5 libfdt: Add dual GPL/BSD SPDX tags to files missing license text
    c4ffc05574b1 tests: Replace license boilerplate with SPDX tags
    a5ac29baacd2 pylibfdt: Replace dual GPLv2/BSD license boilerplate with SPDX tags
    7fb0f4db2eb7 libfdt: Replace GPL/BSD boilerplate/reference with SPDX tags
    acfe84f2c47e dtc: Replace GPLv2 boilerplate/reference with SPDX tags
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index f7f70769d73f..bd6977eedcb8 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -1,21 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
- *
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
- *                                                                   USA
  */
 
 #include "dtc.h"

commit 9bb9c6a110eaad53054e939f8800223ae6d9b66c
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jun 12 07:05:52 2019 -0600

    scripts/dtc: Update to upstream version v1.5.0-23-g87963ee20693
    
    This adds the following commits from upstream:
    
    87963ee20693 livetree: add missing type markers in generated overlay properties
    825146d13dc0 Fix typos in various documentation and source files
    25bb080c18d1 Update the GPL2 text to the latest revision
    243176c4ce84 Fix bogus error on rebuild
    ce01b21098a4 libfdt: Add FDT_CREATE_FLAG_NO_NAME_DEDUP flag that trades size for speed
    fbb62754ce45 libfdt: Introduce fdt_create_with_flags()
    228a44cce857 libfdt: Ensure fdt_add_property frees allocated name string on failure
    8f695676227b Avoid assertion in check_interrupts_property()
    5c3513f68921 Link tools and tests against libfdt shared library
    00f9febf9c16 tests: Rename tests.sh to testutils.sh
    c5d45188f923 Clean up LDLIBS handling
    6ef8fcd05b74 Rebuild libfdt shared object if versioning linker script changes
    26ee65a16c38 Use Python3 by default
    cca6546244cb libfdt: Make fdt_get_max_phandle() an inline
    730875016a6a libfdt: Add phandle generation helper
    7dfb61ba96b1 libfdt: Use fdt_find_max_phandle()
    2bc5b66d7f6c libfdt: Add new maximum phandle lookup function
    7fcf8208b8a9 libfdt: add fdt_append_addrrange()
    ae795b2db7a4 checks: Do not omit nodes with labels if symbol generation is requested
    eac2ad495b29 Update version.lds again
    f67b47135523 Revert "libfdt: Add phandle generation helper"
    54ea41c22415 libfdt: Add phandle generation helper
    4762ad051ee0 checks: Fix spelling in check_graph_endpoint
    d37f6b20107e Bump version to v1.5.0
    a4b1a307ff3a pylibfdt:tests: Extend the way how to find a Python module
    625dd8aaf20f pylibfdt: Change how passing tests are recognized
    364631626bb7 pylibfdt: Test fdt.setprop take bytes on Python 3, add error handling
    cb0f454f73cc pylibfdt: check_err accepts only integer as a first argument.
    4b68c6b3605a pylibfdt: Proper handling of bytes/unicode strings and octal literals
    78e113e81c9d Use PRIxPTR for printing uintptr_t values
    ea7a8f6dad67 libfdt: Fix FDT_ERR_NOTFOUND typos in documentation
    5aafd7ca43e0 libfdt: Fix fdt_getprop_by_offset() parameter name in documentation
    7cbc550f903b checks: Add unit address check if node is enabled
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index acf04c30669f..f7f70769d73f 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -525,7 +525,7 @@ void dt_to_asm(FILE *f, struct dt_info *dti, int version)
 	fprintf(f, "/* Memory reserve map from source file */\n");
 
 	/*
-	 * Use .long on high and low halfs of u64s to avoid .quad
+	 * Use .long on high and low halves of u64s to avoid .quad
 	 * as it appears .quad isn't available in some assemblers.
 	 */
 	for (re = dti->reservelist; re; re = re->next) {

commit c2e7075ca83036317cee4a564729eb82a5433169
Author: Rob Herring <robh@kernel.org>
Date:   Wed Nov 28 18:37:35 2018 -0600

    scripts/dtc: Update to upstream version v1.4.7-57-gf267e674d145
    
    This adds the following commits from upstream:
    
    f267e674d145 checks: Fix crash with multiple source annotations
    3616b9a811b6 checks: Use source position information for check failures
    2bdbd07a1223 checks: Make each message output atomic
    a1eff70c02cf util: Add xa{v}sprintf_append functions
    82a52ce4573b libfdt: Add a test for fdt_getprop_by_offset()
    607b8586b383 PEP8 / Flake8 cleanups for setup.py
    f9c0a425b648 Remove broken objdir / srcdir support
    5182b5e6f28c pylibfdt: Use common PREFIX variable
    d45bf1f5f2a6 Refine make tests_clean target
    99284c4db9cb Refine pylibfdt_clean target
    a4629cfaedfb Refine libfdt_clean target
    08380fc43aa2 tests: Use modern octal literals for Python
    8113c00b99d3 pylibfdt: Allow switch to Python 3 via environment variable PYTHON
    11738cf01f15 libfdt: Don't use memcpy to handle unaligned reads on ARM
    86a288a73670 checks: Restructure check_msg to decrease indentation
    5667e7ef9a9a annotations: add the annotation functionality
    8e20ccf52f90 annotations: add positions
    ca930e20bb54 tests: Don't lose errors from make checkm
    43366bb4eeee tests: Property count valgrind errors in wrapped tests
    5062516fb8cb srcpos: Remove srcpos_empty
    a3143fafbf83 Revert "annotations: add positions"
    403cc79f06a1 checks: Update SPI bus check for 'spi-slave'
    baa1d2cf7894 annotations: add positions
    ff2ad38f6a5a Merge remote-tracking branch 'origin/pr/18'
    aa7254d9cb17 libfdt: return correct value if #size-cells property is not present
    49903aed7783 use ptrdiff_t modifier for printing pointer differences
    da2b691ccf68 treesource: Fix dts output for phandles in middle of a sequence of ints
    8f8b77a0d62d tests: Wrap check_align() calls with base_run_test()
    522d81d572f2 Fix dts output with a REF_PATH marker
    e45198c98359 Added test cases for target references
    0fcffda15e9f Merge nodes with local target label references
    1e4a0928f3b3 pylibfdt: Don't have setup.py depend on where it's invoked from
    ca399b14956f pylibfdt: Eliminate run_setup make function
    98972f1b3e33 pylibfdt: Improved version extraction
    7ba2be6cda5f pylibfdt: Don't silence setup.py when V=1
    7691f9d39301 pylibfdt: Make SETUP make variable
    855b9963def9 pylibfdt: Simpler CFLAGS handling
    47cafbeeb977 pylibfdt: Link extension module with libfdt rather than rebuilding
    dd695d6afb19 pylibfdt: Correctly set build output directory
    59327523d0d8 pylibfdt: We don't need include files from the base directory
    e84742aa7b93 checks: fix simple-bus compatible matching
    8c59a97ce096 Fix missing labels when emitting dts format
    d448f9a5fd94 Revert dts output formatting changes of spaces around brackets
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index 851ea87dbc0f..acf04c30669f 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -692,7 +692,7 @@ static struct property *flat_read_property(struct inbuf *dtbuf,
 
 	val = flat_read_data(dtbuf, proplen);
 
-	return build_property(name, val);
+	return build_property(name, val, NULL);
 }
 
 
@@ -750,7 +750,7 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 	char *flatname;
 	uint32_t val;
 
-	node = build_node(NULL, NULL);
+	node = build_node(NULL, NULL, NULL);
 
 	flatname = flat_read_string(dtbuf);
 

commit f858927fd6ce394a7f431153d44ad0a09e8f49a1
Author: Rob Herring <robh@kernel.org>
Date:   Thu Sep 13 08:59:25 2018 -0500

    scripts/dtc: Update to upstream version v1.4.7-14-gc86da84d30e4
    
    Major changes are I2C and SPI bus checks, YAML output format (for
    future validation), some new libfdt functions, and more libfdt
    validation of dtbs.
    
    The YAML addition adds an optional dependency on libyaml. pkg-config is
    used to test for it and pkg-config became a kconfig dependency in 4.18.
    
    This adds the following commits from upstream:
    
    c86da84d30e4 Add support for YAML encoded output
    361b5e7d8067 Make type_marker_length helper public
    bfbfab047e45 pylibfdt: Add a means to add and delete notes
    9005f4108e7c pylibfdt: Allow delprop() to return errors
    b94c056b137e Make valgrind optional
    fd06c54d4711 tests: Better testing of dtc -I fs mode
    c3f50c9a86d9 tests: Allow dtbs_equal_unordered to ignore mem reserves
    0ac9fdee37c7 dtc: trivial '-I fs -O dts' test
    0fd1c8c783f3 pylibfdt: fdt_get_mem_rsv returns 2 uint64_t values
    04853cad18f4 pylibfdt: Don't incorrectly / unnecessarily override uint64_t typemap
    9619c8619c37 Kill bogus TYPE_BLOB marker type
    ac68ff92ae20 parser: add TYPE_STRING marker to path references
    90a190eb04d9 checks: add SPI bus checks
    53a1bd546905 checks: add I2C bus checks
    88f18909db73 dtc: Bump version to v1.4.7
    85bce8b2f06d tests: Correction to vg_prepare_blob()
    57f7f9e7bc7c tests: Don't call memcmp() with NULL arguments
    c12b2b0c20eb libfdt: fdt_address_cells() and fdt_size_cells()
    3fe0eeda0b7f livetree: Set phandle properties type to uint32
    853649acceba pylibfdt: Support the sequential-write interface
    9b0e4fe26093 tests: Improve fdt_resize() tests
    1087504bb3e8 libfdt: Add necessary header padding in fdt_create()
    c72fa777e613 libfdt: Copy the struct region in fdt_resize()
    32b9c6130762 Preserve datatype markers when emitting dts format
    6dcb8ba408ec libfdt: Add helpers for accessing unaligned words
    42607f21d43e tests: Fix incorrect check name 'prop_name_chars'
    9d78c33bf8a1 tests: fix grep for checks error messages
    b770f3d1c13f pylibfdt: Support setting the name of a node
    2f0d07e678e0 pylibfdt: Add functions to set and get properties as strings
    354d3dc55939 pylibfdt: Update the bytearray size with pack()
    3c374d46acce pylibfdt: Allow reading integer values from properties
    49d32ce40bb4 pylibfdt: Use an unsigned type for fdt32_t
    481246a0c13a pylibfdt: Avoid accessing the internal _fdt member in tests
    9aafa33d99ed pylibfdt: Add functions to update properties
    5a598671fdbf pylibfdt: Support device-tree creation/expansion
    483e170625e1 pylibfdt: Add support for reading the memory reserve map
    29bb05aa4200 pylibfdt: Add support for the rest of the header functions
    582a7159a5d0 pylibfdt: Add support for fdt_next_node()
    f0f8c9169819 pylibfdt: Reorder functions to match libfdt.h
    64a69d123935 pylibfdt: Return string instead of bytearray from getprop()
    4d09a83420df fdtput: Add documentation
    e617cbe1bd67 fdtget: Add documentation
    180a93924014 Use <inttypes.h> format specifiers in a bunch of places we should
    b9af3b396576 scripts/dtc: Fixed format mismatch in fprintf
    4b8fcc3d015c libfdt: Add fdt_check_full() function
    c14223fb2292 tests: Use valgrind client requests for better checking
    5b67d2b955a3 tests: Better handling of valgrind errors saving blobs
    e2556aaeb506 tests: Remove unused #define
    fb9c6abddaa8 Use size_t for blob lengths in utilfdt_read*
    0112fda03bf6 libfdt: Add fdt_header_size()
    6473a21d8bfe Consolidate utilfdt_read_len() variants
    d5db5382c5e5 libfdt: Safer access to memory reservations
    719d582e98ec libfdt: Propagate name errors in fdt_getprop_by_offset()
    70166d62a27f libfdt: Safer access to strings section
    eb890c0f77dc libfdt: Make fdt_check_header() more thorough
    899d6fad93f3 libfdt: Improve sequential write state checking
    04b5b4062ccd libfdt: Clean up header checking functions
    44d3efedc816 Preserve datatype information when parsing dts
    f0be81bd8de0 Make Property a subclass of bytearray
    24b1f3f064d4 pylibfdt: Add a method to access the device tree directly
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index 8d268fb785db..851ea87dbc0f 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -393,7 +393,7 @@ void dt_to_blob(FILE *f, struct dt_info *dti, int version)
 			padlen = 0;
 			if (quiet < 1)
 				fprintf(stderr,
-					"Warning: blob size %d >= minimum size %d\n",
+					"Warning: blob size %"PRIu32" >= minimum size %d\n",
 					fdt32_to_cpu(fdt.totalsize), minsize);
 		}
 	}

commit 9130ba884640328bb78aaa4840e5ddf06ccafb1c
Author: Rob Herring <robh@kernel.org>
Date:   Tue Feb 27 17:40:38 2018 -0600

    scripts/dtc: Update to upstream version v1.4.6-9-gaadd0b65c987
    
    This adds the following commits from upstream:
    
    aadd0b65c987 checks: centralize printing of property names in failure messages
    88960e398907 checks: centralize printing of node path in check_msg
    f1879e1a50eb Add limited read-only support for older (V2 and V3) device tree to libfdt.
    37dea76e9700 srcpos: drop special handling of tab
    65893da4aee0 libfdt: overlay: Add missing license
    962a45ca034d Avoid installing pylibfdt when dependencies are missing
    cd6ea1b2bea6 Makefile: Split INSTALL out into INSTALL_{PROGRAM,LIB,DATA,SCRIPT}
    51b3a16338df Makefile.tests: Add LIBDL make(1) variable for portability sake
    333d533a8f4d Attempt to auto-detect stat(1) being used if not given proper invocation
    e54388015af1 dtc: Bump version to v1.4.6
    a1fe86f380cb fdtoverlay: Switch from using alloca to malloc
    c8d5472de3ff tests: Improve compatibility with other platforms
    c81d389a10cc checks: add chosen node checks
    e671852042a7 checks: add aliases node checks
    d0c44ebe3f42 checks: check for #{size,address}-cells without child nodes
    18a3d84bb802 checks: add string list check for *-names properties
    8fe94fd6f19f checks: add string list check
    6c5730819604 checks: add a string check for 'label' property
    a384191eba09 checks: fix sound-dai phandle with arg property check
    b260c4f610c0 Fix ambiguous grammar for devicetree rule
    fe667e382bac tests: Add some basic tests for the pci_bridge checks
    7975f6422260 Fix widespread incorrect use of strneq(), replace with new strprefixeq()
    fca296445eab Add strstarts() helper function
    cc392f089007 tests: Check non-matching cases for fdt_node_check_compatible()
    bba26a5291c8 livetree: avoid assertion of orphan phandles with overlays
    c8f8194d76cc implement strnlen for systems that need it
    c8b38f65fdec libfdt: Remove leading underscores from identifiers
    3b62fdaebfe5 Remove leading underscores from identifiers
    2d45d1c5c65e Replace FDT_VERSION() with stringify()
    2e6fe5a107b5 Fix some errors in comments
    b0ae9e4b0ceb tests: Correct warning in sw_tree1.c
    
    Commit c8b38f65fdec upstream ("libfdt: Remove leading underscores from
    identifiers") changed the multiple inclusion define protection, so the
    kernel's libfdt_env.h needs the corresponding update.
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index fcf71541d8a7..8d268fb785db 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -731,7 +731,7 @@ static char *nodename_from_path(const char *ppath, const char *cpath)
 
 	plen = strlen(ppath);
 
-	if (!strneq(ppath, cpath, plen))
+	if (!strstarts(cpath, ppath))
 		die("Path \"%s\" is not valid as a child of \"%s\"\n",
 		    cpath, ppath);
 

commit 89d123106a97bf412a4c10482044c822f4b069f7
Author: Rob Herring <robh@kernel.org>
Date:   Tue Mar 21 09:01:08 2017 -0500

    scripts/dtc: Update to upstream version v1.4.4-8-g756ffc4f52f6
    
    This adds the following commits from upstream:
    
    756ffc4f52f6 Build pylibfdt as part of the normal build process
    8cb3896358e9 Adjust libfdt.h to work with swig
    b40aa8359aff Mention pylibfdt in the documentation
    12cfb740cc76 Add tests for pylibfdt
    50f250701631 Add an initial Python library for libfdt
    cdbb2b6c7a3a checks: Warn on node name unit-addresses with '0x' or leading 0s
    4c15d5da17cc checks: Add bus checks for simple-bus buses
    33c3985226d3 checks: Add bus checks for PCI buses
    558cd81bdd43 dtc: Bump version to v1.4.4
    c17a811c62eb fdtput: Remove star from value_len documentation
    194d5caaefcb fdtget: Use @return to document the return value
    d922ecdd017b tests: Make realloc_fdt() really allocate *fdt
    921cc17fec29 libfdt: overlay: Check the value of the right variable
    9ffdf60bf463 dtc: Simplify asm_emit_string() implementation
    881012e44386 libfdt: Change names of sparse helper macros
    bad5b28049e5 Fix assorted sparse warnings
    672ac09ea04d Clean up gcc attributes
    49300f2ade6a dtc: Don't abuse struct fdt_reserve_entry
    fa8bc7f928ac dtc: Bump version to v1.4.3
    34a9886a177f Add printf format attributes
    f72508e2b6ca Correct some broken printf() like format mismatches
    397d5ef0203c libfdt: Add fdt_setprop_empty()
    69a1bd6ad3f9 libfdt: Remove undefined behaviour setting empty properties
    acd1b534a592 Print output filename as part of warning messages
    120775eb1cf3 dtc: Use streq() in preference to strcmp()
    852e9ecbe197 checks: Add Warning for stricter node name character checking
    ef0e8f061534 checks: Add Warning for stricter property name character checking
    00d7bb1f4b0e dtc: pos parameter to srcpos_string() can't be NULL
    95d57726bca4 livetree.c: Fix memory leak
    3b9c97093d6e dtc: Fix NULL pointer use in dtlabel + dtref case
    43eb551426ea manual: Fix typo it -> in
    4baf15f7f13f Makefile: Add tags rule
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index ebac548b3fa8..fcf71541d8a7 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -49,7 +49,7 @@ static struct version_info {
 
 struct emitter {
 	void (*cell)(void *, cell_t);
-	void (*string)(void *, char *, int);
+	void (*string)(void *, const char *, int);
 	void (*align)(void *, int);
 	void (*data)(void *, struct data);
 	void (*beginnode)(void *, struct label *labels);
@@ -64,7 +64,7 @@ static void bin_emit_cell(void *e, cell_t val)
 	*dtbuf = data_append_cell(*dtbuf, val);
 }
 
-static void bin_emit_string(void *e, char *str, int len)
+static void bin_emit_string(void *e, const char *str, int len)
 {
 	struct data *dtbuf = e;
 
@@ -144,22 +144,14 @@ static void asm_emit_cell(void *e, cell_t val)
 		(val >> 8) & 0xff, val & 0xff);
 }
 
-static void asm_emit_string(void *e, char *str, int len)
+static void asm_emit_string(void *e, const char *str, int len)
 {
 	FILE *f = e;
-	char c = 0;
 
-	if (len != 0) {
-		/* XXX: ewww */
-		c = str[len];
-		str[len] = '\0';
-	}
-
-	fprintf(f, "\t.string\t\"%s\"\n", str);
-
-	if (len != 0) {
-		str[len] = c;
-	}
+	if (len != 0)
+		fprintf(f, "\t.string\t\"%.*s\"\n", len, str);
+	else
+		fprintf(f, "\t.string\t\"%s\"\n", str);
 }
 
 static void asm_emit_align(void *e, int a)
@@ -179,7 +171,7 @@ static void asm_emit_data(void *e, struct data d)
 		emit_offset_label(f, m->ref, m->offset);
 
 	while ((d.len - off) >= sizeof(uint32_t)) {
-		asm_emit_cell(e, fdt32_to_cpu(*((uint32_t *)(d.val+off))));
+		asm_emit_cell(e, fdt32_to_cpu(*((fdt32_t *)(d.val+off))));
 		off += sizeof(uint32_t);
 	}
 
@@ -318,17 +310,16 @@ static struct data flatten_reserve_list(struct reserve_info *reservelist,
 {
 	struct reserve_info *re;
 	struct data d = empty_data;
-	static struct fdt_reserve_entry null_re = {0,0};
 	int    j;
 
 	for (re = reservelist; re; re = re->next) {
-		d = data_append_re(d, &re->re);
+		d = data_append_re(d, re->address, re->size);
 	}
 	/*
 	 * Add additional reserved slots if the user asked for them.
 	 */
 	for (j = 0; j < reservenum; j++) {
-		d = data_append_re(d, &null_re);
+		d = data_append_re(d, 0, 0);
 	}
 
 	return d;
@@ -544,11 +535,11 @@ void dt_to_asm(FILE *f, struct dt_info *dti, int version)
 			fprintf(f, "\t.globl\t%s\n", l->label);
 			fprintf(f, "%s:\n", l->label);
 		}
-		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.address >> 32));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->address >> 32));
 		ASM_EMIT_BELONG(f, "0x%08x",
-				(unsigned int)(re->re.address & 0xffffffff));
-		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.size >> 32));
-		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.size & 0xffffffff));
+				(unsigned int)(re->address & 0xffffffff));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->size >> 32));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->size & 0xffffffff));
 	}
 	for (i = 0; i < reservenum; i++) {
 		fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
@@ -609,7 +600,7 @@ static void flat_read_chunk(struct inbuf *inb, void *p, int len)
 
 static uint32_t flat_read_word(struct inbuf *inb)
 {
-	uint32_t val;
+	fdt32_t val;
 
 	assert(((inb->ptr - inb->base) % sizeof(val)) == 0);
 
@@ -718,13 +709,15 @@ static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
 	 * First pass, count entries.
 	 */
 	while (1) {
+		uint64_t address, size;
+
 		flat_read_chunk(inb, &re, sizeof(re));
-		re.address  = fdt64_to_cpu(re.address);
-		re.size = fdt64_to_cpu(re.size);
-		if (re.size == 0)
+		address  = fdt64_to_cpu(re.address);
+		size = fdt64_to_cpu(re.size);
+		if (size == 0)
 			break;
 
-		new = build_reserve_entry(re.address, re.size);
+		new = build_reserve_entry(address, size);
 		reservelist = add_reserve_entry(reservelist, new);
 	}
 
@@ -817,6 +810,7 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 struct dt_info *dt_from_blob(const char *fname)
 {
 	FILE *f;
+	fdt32_t magic_buf, totalsize_buf;
 	uint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;
 	uint32_t off_dt, off_str, off_mem_rsvmap;
 	int rc;
@@ -833,7 +827,7 @@ struct dt_info *dt_from_blob(const char *fname)
 
 	f = srcfile_relative_open(fname, NULL);
 
-	rc = fread(&magic, sizeof(magic), 1, f);
+	rc = fread(&magic_buf, sizeof(magic_buf), 1, f);
 	if (ferror(f))
 		die("Error reading DT blob magic number: %s\n",
 		    strerror(errno));
@@ -844,11 +838,11 @@ struct dt_info *dt_from_blob(const char *fname)
 			die("Mysterious short read reading magic number\n");
 	}
 
-	magic = fdt32_to_cpu(magic);
+	magic = fdt32_to_cpu(magic_buf);
 	if (magic != FDT_MAGIC)
 		die("Blob has incorrect magic number\n");
 
-	rc = fread(&totalsize, sizeof(totalsize), 1, f);
+	rc = fread(&totalsize_buf, sizeof(totalsize_buf), 1, f);
 	if (ferror(f))
 		die("Error reading DT blob size: %s\n", strerror(errno));
 	if (rc < 1) {
@@ -858,7 +852,7 @@ struct dt_info *dt_from_blob(const char *fname)
 			die("Mysterious short read reading blob size\n");
 	}
 
-	totalsize = fdt32_to_cpu(totalsize);
+	totalsize = fdt32_to_cpu(totalsize_buf);
 	if (totalsize < FDT_V1_SIZE)
 		die("DT blob size (%d) is too small\n", totalsize);
 

commit 6f05afcbb031722ec1eff77dde188ff2edf8940e
Author: Rob Herring <robh@kernel.org>
Date:   Wed Jan 4 10:45:20 2017 -0600

    scripts/dtc: Update to upstream version 0931cea3ba20
    
    Sync to upstream dtc commit 0931cea3ba20 ("dtc: fdtdump: check fdt if
    not in scanning mode"). In particular, this pulls in dtc overlay
    support.
    
    This adds the following commits from upstream:
    
    f88865469b65 dtc: Fix memory leak in character literal parsing
    00fbb8696b66 Rename boot_info
    1ef86ad2c24f dtc: Clean up /dts-v1/ and /plugin/ handling in grammar
    e3c769aa9c16 dtc: Don't always generate __symbols__ for plugins
    c96cb3c0169e tests: Don't use -@ on plugin de/recompile tests
    66381538ce24 tests: Remove "suppression of fixups" tests
    ba765b273f0f tests: Clarify dtc overlay tests
    6ea8cd944fcd tests: More thorough tests of libfdt overlay application without dtc
    7d8ef6e1db97 tests: Correct fdt handling of overlays without fixups and base trees without symbols
    b4dc0ed8b127 tests: Fix double expansion bugs in test code
    3ea879dc0c8f tests: Split overlay tests into those with do/don't exercise dtc plugin generation
    47b4d66a2f11 tests: Test auto-alias generation on base tree, not overlay
    72e1ad811523 tests: Make overlay/plugin tests unconditional
    e7b3c3b5951b tests: Add overlay tests
    9637e3f772a9 tests: Add check_path test
    20f29d8d41f6 dtc: Plugin and fixup support
    a2c92cac53f8 dtc: Document the dynamic plugin internals
    8f70ac39801d checks: Pass boot_info instead of root node
    ea10f953878f libfdt: add missing errors to fdt_strerror()
    daa75e8fa594 libfdt: fix fdt_stringlist_search()
    e28eff5b787a libfdt: fix fdt_stringlist_count()
    ae97c7722840 tests: overlay: Rename the device tree blobs to be more explicit
    96162d2bd9cb tests: overlay: Add test suffix to the compiled blobs
    5ce8634733b7 libfdt: Add fdt_overlay_apply to the exported symbols
    804a9db90ad2 fdt: strerr: Remove spurious BADOVERLAY
    e8c3a1a493fa tests: overlay: Move back the bad fixup tests
    7a72d89d3f81 libfdt: overlay: Fix symbols and fixups nodes condition
    cabbaa972cdd libfdt: overlay: Report a bad overlay for mismatching local fixups
    deb0a5c1aeaa libfdt: Add BADPHANDLE error string
    7b7a6be9ba15 libfdt: Don't use 'index' as a local variable name
    aea8860d831e tests: Add tests cases for the overlay code
    0cdd06c5135b libfdt: Add overlay application function
    39240cc865cf libfdt: Extend the reach of FDT_ERR_BADPHANDLE
    4aa3a6f5e6d9 libfdt: Add new errors for the overlay code
    6d1832c9e64b dtc: Remove "home page" link
    45fd440a9561 Fix some typing errors in libfdt.h and livetree.c
    a59be4939c13 Merge tag 'v1.4.2'
    a34bb721caca dtc: Fix assorted problems in the testcases for the -a option
    874f40588d3e Implement the -a option to pad dtb aligned
    ec02b34c05be dtc: Makefile improvements for release uploading
    1ed45d40a137 dtc: Bump version to 1.4.2
    36fd7331fb11 libfdt: simplify fdt_del_mem_rsv()
    d877364e4a0f libfdt: Add fdt_setprop_inplace_namelen_partial
    3e9037aaad44 libfdt: Add fdt_getprop_namelen_w
    84e0e1346c68 libfdt: Add max phandle retrieval function
    d29126c90acb libfdt: Add iterator over properties
    902d0f0953d0 libfdt: Add a subnodes iterator macro
    c539075ba8ba fdtput.c: Fix memory leak.
    f79ddb83e185 fdtget.c: Fix memory leak
    1074ee54b63f convert-dtsv0-lexer.l: fix memory leak
    e24d39a024e6 fdtdump.c: make sure size_t argument to memchr is always unsigned.
    44a59713cf05 Remove unused srcpos_dump() function
    cb9241ae3453 DTC: Fix memory leak on flatname.
    1ee0ae24ea09 Simplify check field and macro names
    9d97527a8621 Remove property check functions
    2e709d158e11 Remove tree check functions
    c4cb12e193e3 Alter grammar to allow multiple /dts-v1/ tags
    d71d25d76012 Use xasprintf() in srcpos
    9dc404958e9c util: Add xasprintf portable asprintf variant
    beef80b8b55f Correct a missing space in a fdt_header cast
    68d43cec1253 Correct line lengths in libfdt.h
    b0dbceafd49a Correct space-after-tab in libfdt.h
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index ec14954f5810..ebac548b3fa8 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -366,7 +366,7 @@ static void make_fdt_header(struct fdt_header *fdt,
 		fdt->size_dt_struct = cpu_to_fdt32(dtsize);
 }
 
-void dt_to_blob(FILE *f, struct boot_info *bi, int version)
+void dt_to_blob(FILE *f, struct dt_info *dti, int version)
 {
 	struct version_info *vi = NULL;
 	int i;
@@ -384,29 +384,36 @@ void dt_to_blob(FILE *f, struct boot_info *bi, int version)
 	if (!vi)
 		die("Unknown device tree blob version %d\n", version);
 
-	flatten_tree(bi->dt, &bin_emitter, &dtbuf, &strbuf, vi);
+	flatten_tree(dti->dt, &bin_emitter, &dtbuf, &strbuf, vi);
 	bin_emit_cell(&dtbuf, FDT_END);
 
-	reservebuf = flatten_reserve_list(bi->reservelist, vi);
+	reservebuf = flatten_reserve_list(dti->reservelist, vi);
 
 	/* Make header */
 	make_fdt_header(&fdt, vi, reservebuf.len, dtbuf.len, strbuf.len,
-			bi->boot_cpuid_phys);
+			dti->boot_cpuid_phys);
 
 	/*
 	 * If the user asked for more space than is used, adjust the totalsize.
 	 */
 	if (minsize > 0) {
 		padlen = minsize - fdt32_to_cpu(fdt.totalsize);
-		if ((padlen < 0) && (quiet < 1))
-			fprintf(stderr,
-				"Warning: blob size %d >= minimum size %d\n",
-				fdt32_to_cpu(fdt.totalsize), minsize);
+		if (padlen < 0) {
+			padlen = 0;
+			if (quiet < 1)
+				fprintf(stderr,
+					"Warning: blob size %d >= minimum size %d\n",
+					fdt32_to_cpu(fdt.totalsize), minsize);
+		}
 	}
 
 	if (padsize > 0)
 		padlen = padsize;
 
+	if (alignsize > 0)
+		padlen = ALIGN(fdt32_to_cpu(fdt.totalsize) + padlen, alignsize)
+			- fdt32_to_cpu(fdt.totalsize);
+
 	if (padlen > 0) {
 		int tsize = fdt32_to_cpu(fdt.totalsize);
 		tsize += padlen;
@@ -460,7 +467,7 @@ static void dump_stringtable_asm(FILE *f, struct data strbuf)
 	}
 }
 
-void dt_to_asm(FILE *f, struct boot_info *bi, int version)
+void dt_to_asm(FILE *f, struct dt_info *dti, int version)
 {
 	struct version_info *vi = NULL;
 	int i;
@@ -500,7 +507,7 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 
 	if (vi->flags & FTF_BOOTCPUID) {
 		fprintf(f, "\t/* boot_cpuid_phys */\n");
-		asm_emit_cell(f, bi->boot_cpuid_phys);
+		asm_emit_cell(f, dti->boot_cpuid_phys);
 	}
 
 	if (vi->flags & FTF_STRTABSIZE) {
@@ -530,7 +537,7 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 	 * Use .long on high and low halfs of u64s to avoid .quad
 	 * as it appears .quad isn't available in some assemblers.
 	 */
-	for (re = bi->reservelist; re; re = re->next) {
+	for (re = dti->reservelist; re; re = re->next) {
 		struct label *l;
 
 		for_each_label(re->labels, l) {
@@ -550,7 +557,7 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 	fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
 
 	emit_label(f, symprefix, "struct_start");
-	flatten_tree(bi->dt, &asm_emitter, f, &strbuf, vi);
+	flatten_tree(dti->dt, &asm_emitter, f, &strbuf, vi);
 
 	fprintf(f, "\t/* FDT_END */\n");
 	asm_emit_cell(f, FDT_END);
@@ -572,6 +579,8 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 	if (padsize > 0) {
 		fprintf(f, "\t.space\t%d, 0\n", padsize);
 	}
+	if (alignsize > 0)
+		asm_emit_align(f, alignsize);
 	emit_label(f, symprefix, "blob_abs_end");
 
 	data_free(strbuf);
@@ -797,11 +806,15 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 		}
 	} while (val != FDT_END_NODE);
 
+	if (node->name != flatname) {
+		free(flatname);
+	}
+
 	return node;
 }
 
 
-struct boot_info *dt_from_blob(const char *fname)
+struct dt_info *dt_from_blob(const char *fname)
 {
 	FILE *f;
 	uint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;
@@ -929,5 +942,5 @@ struct boot_info *dt_from_blob(const char *fname)
 
 	fclose(f);
 
-	return build_boot_info(reservelist, tree, boot_cpuid_phys);
+	return build_dt_info(DTSF_V1, reservelist, tree, boot_cpuid_phys);
 }

commit b993734718c0106418e068f21c7be01afc12306c
Author: Rob Herring <robh@kernel.org>
Date:   Fri Mar 4 08:56:58 2016 -0600

    scripts/dtc: Update to upstream version 53bf130b1cdd
    
    Sync to upstream dtc commit 53bf130b1cdd ("libfdt: simplify
    fdt_node_check_compatible()"). This adds the following commits from
    upstream:
    
    53bf130 libfdt: simplify fdt_node_check_compatible()
    c9d9121 Warn on node name unit-address presence/absence mismatch
    2e53f9d Catch unsigned 32bit overflow when parsing flattened device tree offsets
    
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index bd99fa2d33b8..ec14954f5810 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -889,7 +889,7 @@ struct boot_info *dt_from_blob(const char *fname)
 
 	if (version >= 3) {
 		uint32_t size_str = fdt32_to_cpu(fdt->size_dt_strings);
-		if (off_str+size_str > totalsize)
+		if ((off_str+size_str < off_str) || (off_str+size_str > totalsize))
 			die("String table extends past total size\n");
 		inbuf_init(&strbuf, blob + off_str, blob + off_str + size_str);
 	} else {
@@ -898,7 +898,7 @@ struct boot_info *dt_from_blob(const char *fname)
 
 	if (version >= 17) {
 		size_dt = fdt32_to_cpu(fdt->size_dt_struct);
-		if (off_dt+size_dt > totalsize)
+		if ((off_dt+size_dt < off_dt) || (off_dt+size_dt > totalsize))
 			die("Structure block extends past total size\n");
 	}
 

commit 4760597116e34bd58f670d008ae7323653268fb4
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 29 16:00:05 2015 -0500

    scripts/dtc: Update to upstream version 9d3649bd3be245c9
    
    Sync dtc with upstream as of commit 9d3649bd3be2 (Add testcases for
    fdt_path_offset_namelen()).
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: devicetree@vger.kernel.org

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index 665dad7bb465..bd99fa2d33b8 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -261,7 +261,7 @@ static void flatten_tree(struct node *tree, struct emitter *emit,
 {
 	struct property *prop;
 	struct node *child;
-	int seen_name_prop = 0;
+	bool seen_name_prop = false;
 
 	if (tree->deleted)
 		return;
@@ -279,7 +279,7 @@ static void flatten_tree(struct node *tree, struct emitter *emit,
 		int nameoff;
 
 		if (streq(prop->name, "name"))
-			seen_name_prop = 1;
+			seen_name_prop = true;
 
 		nameoff = stringtable_insert(strbuf, prop->name);
 

commit cd296721a9645f9f28800a072490fa15458d1fb7
Author: Stephen Warren <swarren@nvidia.com>
Date:   Fri Sep 28 21:25:59 2012 +0000

    dtc: import latest upstream dtc
    
    This updates scripts/dtc to commit 317a5d9 "dtc: zero out new label
    objects" from git://git.jdl.com/software/dtc.git.
    
    This adds features such as:
    * /bits/ syntax for cell data.
    * Math expressions within cell data.
    * The ability to delete properties or nodes.
    * Support for #line directives in the input file, which allows the use of
      cpp on *.dts.
    * -i command-line option (/include/ path)
    * -W/-E command-line options for error/warning control.
    * Removal of spew to STDOUT containing the filename being compiled.
    * Many additions to the libfdt API.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Jon Loeliger <jdl@jdl.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index 28d0b2381df6..665dad7bb465 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -263,6 +263,9 @@ static void flatten_tree(struct node *tree, struct emitter *emit,
 	struct node *child;
 	int seen_name_prop = 0;
 
+	if (tree->deleted)
+		return;
+
 	emit->beginnode(etarget, tree->labels);
 
 	if (vi->flags & FTF_FULLPATH)

commit db7f4e3d2b0a68eafc16a7b78ac0b7566db1e799
Author: Felipe Balbi <balbi@ti.com>
Date:   Thu Jan 26 13:20:07 2012 +0200

    scripts: dtc: fix compile warnings
    
    Fix following compile warnings:
    
    scripts/dtc/flattree.c: In function ‘flat_read_mem_reserve’:
    scripts/dtc/flattree.c:700:14: warning: variable ‘p’ set but not used
            [-Wunused-but-set-variable]
    
    scripts/dtc/dtc.c: In function ‘main’:
    scripts/dtc/dtc.c:104:17: warning: variable ‘check’ set but not used
            [-Wunused-but-set-variable]
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index ead0332c87e1..28d0b2381df6 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -697,7 +697,6 @@ static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
 {
 	struct reserve_info *reservelist = NULL;
 	struct reserve_info *new;
-	const char *p;
 	struct fdt_reserve_entry re;
 
 	/*
@@ -706,7 +705,6 @@ static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
 	 *
 	 * First pass, count entries.
 	 */
-	p = inb->ptr;
 	while (1) {
 		flat_read_chunk(inb, &re, sizeof(re));
 		re.address  = fdt64_to_cpu(re.address);

commit 658f29a51e9830e620bb9a1ce3534b318a38bfeb
Author: John Bonesio <bones@secretlab.ca>
Date:   Wed Nov 17 15:28:20 2010 -0800

    of/flattree: Update dtc to current mainline.
    
    Pull in recent changes from the main dtc repository. These changes
    primarily allow multiple device trees to be declared which are merged
    by dtc. This feature allows us to include a basic dts file and then
    provide more information for the specific system through the merging
    functionality.
    
    Changes pulled from git://git.jdl.com/software/dtc.git
    commit id: 37c0b6a0, "dtc: Add code to make diffing trees easier"
    
    Signed-off-by: John Bonesio <bones@secretlab.ca>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
index 76acd28c068d..ead0332c87e1 100644
--- a/scripts/dtc/flattree.c
+++ b/scripts/dtc/flattree.c
@@ -52,9 +52,9 @@ struct emitter {
 	void (*string)(void *, char *, int);
 	void (*align)(void *, int);
 	void (*data)(void *, struct data);
-	void (*beginnode)(void *, const char *);
-	void (*endnode)(void *, const char *);
-	void (*property)(void *, const char *);
+	void (*beginnode)(void *, struct label *labels);
+	void (*endnode)(void *, struct label *labels);
+	void (*property)(void *, struct label *labels);
 };
 
 static void bin_emit_cell(void *e, cell_t val)
@@ -89,17 +89,17 @@ static void bin_emit_data(void *e, struct data d)
 	*dtbuf = data_append_data(*dtbuf, d.val, d.len);
 }
 
-static void bin_emit_beginnode(void *e, const char *label)
+static void bin_emit_beginnode(void *e, struct label *labels)
 {
 	bin_emit_cell(e, FDT_BEGIN_NODE);
 }
 
-static void bin_emit_endnode(void *e, const char *label)
+static void bin_emit_endnode(void *e, struct label *labels)
 {
 	bin_emit_cell(e, FDT_END_NODE);
 }
 
-static void bin_emit_property(void *e, const char *label)
+static void bin_emit_property(void *e, struct label *labels)
 {
 	bin_emit_cell(e, FDT_PROP);
 }
@@ -127,11 +127,21 @@ static void emit_offset_label(FILE *f, const char *label, int offset)
 	fprintf(f, "%s\t= . + %d\n", label, offset);
 }
 
+#define ASM_EMIT_BELONG(f, fmt, ...) \
+	{ \
+		fprintf((f), "\t.byte\t((" fmt ") >> 24) & 0xff\n", __VA_ARGS__); \
+		fprintf((f), "\t.byte\t((" fmt ") >> 16) & 0xff\n", __VA_ARGS__); \
+		fprintf((f), "\t.byte\t((" fmt ") >> 8) & 0xff\n", __VA_ARGS__); \
+		fprintf((f), "\t.byte\t(" fmt ") & 0xff\n", __VA_ARGS__); \
+	}
+
 static void asm_emit_cell(void *e, cell_t val)
 {
 	FILE *f = e;
 
-	fprintf(f, "\t.long\t0x%x\n", val);
+	fprintf(f, "\t.byte 0x%02x; .byte 0x%02x; .byte 0x%02x; .byte 0x%02x\n",
+		(val >> 24) & 0xff, (val >> 16) & 0xff,
+		(val >> 8) & 0xff, val & 0xff);
 }
 
 static void asm_emit_string(void *e, char *str, int len)
@@ -156,7 +166,7 @@ static void asm_emit_align(void *e, int a)
 {
 	FILE *f = e;
 
-	fprintf(f, "\t.balign\t%d\n", a);
+	fprintf(f, "\t.balign\t%d, 0\n", a);
 }
 
 static void asm_emit_data(void *e, struct data d)
@@ -169,8 +179,7 @@ static void asm_emit_data(void *e, struct data d)
 		emit_offset_label(f, m->ref, m->offset);
 
 	while ((d.len - off) >= sizeof(uint32_t)) {
-		fprintf(f, "\t.long\t0x%x\n",
-			fdt32_to_cpu(*((uint32_t *)(d.val+off))));
+		asm_emit_cell(e, fdt32_to_cpu(*((uint32_t *)(d.val+off))));
 		off += sizeof(uint32_t);
 	}
 
@@ -182,37 +191,43 @@ static void asm_emit_data(void *e, struct data d)
 	assert(off == d.len);
 }
 
-static void asm_emit_beginnode(void *e, const char *label)
+static void asm_emit_beginnode(void *e, struct label *labels)
 {
 	FILE *f = e;
+	struct label *l;
 
-	if (label) {
-		fprintf(f, "\t.globl\t%s\n", label);
-		fprintf(f, "%s:\n", label);
+	for_each_label(labels, l) {
+		fprintf(f, "\t.globl\t%s\n", l->label);
+		fprintf(f, "%s:\n", l->label);
 	}
-	fprintf(f, "\t.long\tFDT_BEGIN_NODE\n");
+	fprintf(f, "\t/* FDT_BEGIN_NODE */\n");
+	asm_emit_cell(e, FDT_BEGIN_NODE);
 }
 
-static void asm_emit_endnode(void *e, const char *label)
+static void asm_emit_endnode(void *e, struct label *labels)
 {
 	FILE *f = e;
+	struct label *l;
 
-	fprintf(f, "\t.long\tFDT_END_NODE\n");
-	if (label) {
-		fprintf(f, "\t.globl\t%s_end\n", label);
-		fprintf(f, "%s_end:\n", label);
+	fprintf(f, "\t/* FDT_END_NODE */\n");
+	asm_emit_cell(e, FDT_END_NODE);
+	for_each_label(labels, l) {
+		fprintf(f, "\t.globl\t%s_end\n", l->label);
+		fprintf(f, "%s_end:\n", l->label);
 	}
 }
 
-static void asm_emit_property(void *e, const char *label)
+static void asm_emit_property(void *e, struct label *labels)
 {
 	FILE *f = e;
+	struct label *l;
 
-	if (label) {
-		fprintf(f, "\t.globl\t%s\n", label);
-		fprintf(f, "%s:\n", label);
+	for_each_label(labels, l) {
+		fprintf(f, "\t.globl\t%s\n", l->label);
+		fprintf(f, "%s:\n", l->label);
 	}
-	fprintf(f, "\t.long\tFDT_PROP\n");
+	fprintf(f, "\t/* FDT_PROP */\n");
+	asm_emit_cell(e, FDT_PROP);
 }
 
 static struct emitter asm_emitter = {
@@ -248,7 +263,7 @@ static void flatten_tree(struct node *tree, struct emitter *emit,
 	struct node *child;
 	int seen_name_prop = 0;
 
-	emit->beginnode(etarget, tree->label);
+	emit->beginnode(etarget, tree->labels);
 
 	if (vi->flags & FTF_FULLPATH)
 		emit->string(etarget, tree->fullpath, 0);
@@ -265,7 +280,7 @@ static void flatten_tree(struct node *tree, struct emitter *emit,
 
 		nameoff = stringtable_insert(strbuf, prop->name);
 
-		emit->property(etarget, prop->label);
+		emit->property(etarget, prop->labels);
 		emit->cell(etarget, prop->val.len);
 		emit->cell(etarget, nameoff);
 
@@ -292,7 +307,7 @@ static void flatten_tree(struct node *tree, struct emitter *emit,
 		flatten_tree(child, emit, etarget, strbuf, vi);
 	}
 
-	emit->endnode(etarget, tree->label);
+	emit->endnode(etarget, tree->labels);
 }
 
 static struct data flatten_reserve_list(struct reserve_info *reservelist,
@@ -413,10 +428,13 @@ void dt_to_blob(FILE *f, struct boot_info *bi, int version)
 	if (padlen > 0)
 		blob = data_append_zeroes(blob, padlen);
 
-	fwrite(blob.val, blob.len, 1, f);
-
-	if (ferror(f))
-		die("Error writing device tree blob: %s\n", strerror(errno));
+	if (fwrite(blob.val, blob.len, 1, f) != 1) {
+		if (ferror(f))
+			die("Error writing device tree blob: %s\n",
+			    strerror(errno));
+		else
+			die("Short write on device tree blob\n");
+	}
 
 	/*
 	 * data_merge() frees the right-hand element so only the blob
@@ -455,39 +473,44 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 		die("Unknown device tree blob version %d\n", version);
 
 	fprintf(f, "/* autogenerated by dtc, do not edit */\n\n");
-	fprintf(f, "#define FDT_MAGIC 0x%x\n", FDT_MAGIC);
-	fprintf(f, "#define FDT_BEGIN_NODE 0x%x\n", FDT_BEGIN_NODE);
-	fprintf(f, "#define FDT_END_NODE 0x%x\n", FDT_END_NODE);
-	fprintf(f, "#define FDT_PROP 0x%x\n", FDT_PROP);
-	fprintf(f, "#define FDT_END 0x%x\n", FDT_END);
-	fprintf(f, "\n");
 
 	emit_label(f, symprefix, "blob_start");
 	emit_label(f, symprefix, "header");
-	fprintf(f, "\t.long\tFDT_MAGIC\t\t\t\t/* magic */\n");
-	fprintf(f, "\t.long\t_%s_blob_abs_end - _%s_blob_start\t/* totalsize */\n",
-		symprefix, symprefix);
-	fprintf(f, "\t.long\t_%s_struct_start - _%s_blob_start\t/* off_dt_struct */\n",
+	fprintf(f, "\t/* magic */\n");
+	asm_emit_cell(f, FDT_MAGIC);
+	fprintf(f, "\t/* totalsize */\n");
+	ASM_EMIT_BELONG(f, "_%s_blob_abs_end - _%s_blob_start",
+			symprefix, symprefix);
+	fprintf(f, "\t/* off_dt_struct */\n");
+	ASM_EMIT_BELONG(f, "_%s_struct_start - _%s_blob_start",
 		symprefix, symprefix);
-	fprintf(f, "\t.long\t_%s_strings_start - _%s_blob_start\t/* off_dt_strings */\n",
+	fprintf(f, "\t/* off_dt_strings */\n");
+	ASM_EMIT_BELONG(f, "_%s_strings_start - _%s_blob_start",
 		symprefix, symprefix);
-	fprintf(f, "\t.long\t_%s_reserve_map - _%s_blob_start\t/* off_dt_strings */\n",
+	fprintf(f, "\t/* off_mem_rsvmap */\n");
+	ASM_EMIT_BELONG(f, "_%s_reserve_map - _%s_blob_start",
 		symprefix, symprefix);
-	fprintf(f, "\t.long\t%d\t\t\t\t\t/* version */\n", vi->version);
-	fprintf(f, "\t.long\t%d\t\t\t\t\t/* last_comp_version */\n",
-		vi->last_comp_version);
-
-	if (vi->flags & FTF_BOOTCPUID)
-		fprintf(f, "\t.long\t%i\t\t\t\t\t/* boot_cpuid_phys */\n",
-			bi->boot_cpuid_phys);
+	fprintf(f, "\t/* version */\n");
+	asm_emit_cell(f, vi->version);
+	fprintf(f, "\t/* last_comp_version */\n");
+	asm_emit_cell(f, vi->last_comp_version);
+
+	if (vi->flags & FTF_BOOTCPUID) {
+		fprintf(f, "\t/* boot_cpuid_phys */\n");
+		asm_emit_cell(f, bi->boot_cpuid_phys);
+	}
 
-	if (vi->flags & FTF_STRTABSIZE)
-		fprintf(f, "\t.long\t_%s_strings_end - _%s_strings_start\t/* size_dt_strings */\n",
-			symprefix, symprefix);
+	if (vi->flags & FTF_STRTABSIZE) {
+		fprintf(f, "\t/* size_dt_strings */\n");
+		ASM_EMIT_BELONG(f, "_%s_strings_end - _%s_strings_start",
+				symprefix, symprefix);
+	}
 
-	if (vi->flags & FTF_STRUCTSIZE)
-		fprintf(f, "\t.long\t_%s_struct_end - _%s_struct_start\t/* size_dt_struct */\n",
+	if (vi->flags & FTF_STRUCTSIZE) {
+		fprintf(f, "\t/* size_dt_struct */\n");
+		ASM_EMIT_BELONG(f, "_%s_struct_end - _%s_struct_start",
 			symprefix, symprefix);
+	}
 
 	/*
 	 * Reserve map entries.
@@ -505,16 +528,17 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 	 * as it appears .quad isn't available in some assemblers.
 	 */
 	for (re = bi->reservelist; re; re = re->next) {
-		if (re->label) {
-			fprintf(f, "\t.globl\t%s\n", re->label);
-			fprintf(f, "%s:\n", re->label);
+		struct label *l;
+
+		for_each_label(re->labels, l) {
+			fprintf(f, "\t.globl\t%s\n", l->label);
+			fprintf(f, "%s:\n", l->label);
 		}
-		fprintf(f, "\t.long\t0x%08x, 0x%08x\n",
-			(unsigned int)(re->re.address >> 32),
-			(unsigned int)(re->re.address & 0xffffffff));
-		fprintf(f, "\t.long\t0x%08x, 0x%08x\n",
-			(unsigned int)(re->re.size >> 32),
-			(unsigned int)(re->re.size & 0xffffffff));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.address >> 32));
+		ASM_EMIT_BELONG(f, "0x%08x",
+				(unsigned int)(re->re.address & 0xffffffff));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.size >> 32));
+		ASM_EMIT_BELONG(f, "0x%08x", (unsigned int)(re->re.size & 0xffffffff));
 	}
 	for (i = 0; i < reservenum; i++) {
 		fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
@@ -524,7 +548,9 @@ void dt_to_asm(FILE *f, struct boot_info *bi, int version)
 
 	emit_label(f, symprefix, "struct_start");
 	flatten_tree(bi->dt, &asm_emitter, f, &strbuf, vi);
-	fprintf(f, "\t.long\tFDT_END\n");
+
+	fprintf(f, "\t/* FDT_END */\n");
+	asm_emit_cell(f, FDT_END);
 	emit_label(f, symprefix, "struct_end");
 
 	emit_label(f, symprefix, "strings_start");
@@ -601,7 +627,7 @@ static char *flat_read_string(struct inbuf *inb)
 		len++;
 	} while ((*p++) != '\0');
 
-	str = strdup(inb->ptr);
+	str = xstrdup(inb->ptr);
 
 	inb->ptr += len;
 
@@ -643,7 +669,7 @@ static char *flat_read_stringtable(struct inbuf *inb, int offset)
 		p++;
 	}
 
-	return strdup(inb->base + offset);
+	return xstrdup(inb->base + offset);
 }
 
 static struct property *flat_read_property(struct inbuf *dtbuf,
@@ -663,7 +689,7 @@ static struct property *flat_read_property(struct inbuf *dtbuf,
 
 	val = flat_read_data(dtbuf, proplen);
 
-	return build_property(name, val, NULL);
+	return build_property(name, val);
 }
 
 
@@ -688,7 +714,7 @@ static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
 		if (re.size == 0)
 			break;
 
-		new = build_reserve_entry(re.address, re.size, NULL);
+		new = build_reserve_entry(re.address, re.size);
 		reservelist = add_reserve_entry(reservelist, new);
 	}
 
@@ -710,7 +736,7 @@ static char *nodename_from_path(const char *ppath, const char *cpath)
 	if (!streq(ppath, "/"))
 		plen++;
 
-	return strdup(cpath + plen);
+	return xstrdup(cpath + plen);
 }
 
 static struct node *unflatten_tree(struct inbuf *dtbuf,
@@ -776,7 +802,7 @@ static struct node *unflatten_tree(struct inbuf *dtbuf,
 
 struct boot_info *dt_from_blob(const char *fname)
 {
-	struct dtc_file *dtcf;
+	FILE *f;
 	uint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;
 	uint32_t off_dt, off_str, off_mem_rsvmap;
 	int rc;
@@ -791,14 +817,14 @@ struct boot_info *dt_from_blob(const char *fname)
 	uint32_t val;
 	int flags = 0;
 
-	dtcf = dtc_open_file(fname, NULL);
+	f = srcfile_relative_open(fname, NULL);
 
-	rc = fread(&magic, sizeof(magic), 1, dtcf->file);
-	if (ferror(dtcf->file))
+	rc = fread(&magic, sizeof(magic), 1, f);
+	if (ferror(f))
 		die("Error reading DT blob magic number: %s\n",
 		    strerror(errno));
 	if (rc < 1) {
-		if (feof(dtcf->file))
+		if (feof(f))
 			die("EOF reading DT blob magic number\n");
 		else
 			die("Mysterious short read reading magic number\n");
@@ -808,11 +834,11 @@ struct boot_info *dt_from_blob(const char *fname)
 	if (magic != FDT_MAGIC)
 		die("Blob has incorrect magic number\n");
 
-	rc = fread(&totalsize, sizeof(totalsize), 1, dtcf->file);
-	if (ferror(dtcf->file))
+	rc = fread(&totalsize, sizeof(totalsize), 1, f);
+	if (ferror(f))
 		die("Error reading DT blob size: %s\n", strerror(errno));
 	if (rc < 1) {
-		if (feof(dtcf->file))
+		if (feof(f))
 			die("EOF reading DT blob size\n");
 		else
 			die("Mysterious short read reading blob size\n");
@@ -832,12 +858,12 @@ struct boot_info *dt_from_blob(const char *fname)
 	p = blob + sizeof(magic)  + sizeof(totalsize);
 
 	while (sizeleft) {
-		if (feof(dtcf->file))
+		if (feof(f))
 			die("EOF before reading %d bytes of DT blob\n",
 			    totalsize);
 
-		rc = fread(p, 1, sizeleft, dtcf->file);
-		if (ferror(dtcf->file))
+		rc = fread(p, 1, sizeleft, f);
+		if (ferror(f))
 			die("Error reading DT blob: %s\n",
 			    strerror(errno));
 
@@ -900,7 +926,7 @@ struct boot_info *dt_from_blob(const char *fname)
 
 	free(blob);
 
-	dtc_close_file(dtcf);
+	fclose(f);
 
 	return build_boot_info(reservelist, tree, boot_cpuid_phys);
 }

commit 9fffb55f66127b52c937ede5196ebfa0c0d50bce
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Thu Apr 30 15:25:53 2009 +1000

    Move dtc and libfdt sources from arch/powerpc/boot to scripts/dtc
    
    The powerpc kernel always requires an Open Firmware like device tree
    to supply device information.  On systems without OF, this comes from
    a flattened device tree blob.  This blob is usually generated by dtc,
    a tool which compiles a text description of the device tree into the
    flattened format used by the kernel.  Sometimes, the bootwrapper makes
    small changes to the pre-compiled device tree blob (e.g. filling in
    the size of RAM).  To do this it uses the libfdt library.
    
    Because these are only used on powerpc, the code for both these tools
    is included under arch/powerpc/boot (these were imported and are
    periodically updated from the upstream dtc tree).
    
    However, the microblaze architecture, currently being prepared for
    merging to mainline also uses dtc to produce device tree blobs.  A few
    other archs have also mentioned some interest in using dtc.
    Therefore, this patch moves dtc and libfdt from arch/powerpc into
    scripts, where it can be used by any architecture.
    
    The vast bulk of this patch is a literal move, the rest is adjusting
    the various Makefiles to use dtc and libfdt correctly from their new
    locations.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/scripts/dtc/flattree.c b/scripts/dtc/flattree.c
new file mode 100644
index 000000000000..76acd28c068d
--- /dev/null
+++ b/scripts/dtc/flattree.c
@@ -0,0 +1,906 @@
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *                                                                   USA
+ */
+
+#include "dtc.h"
+#include "srcpos.h"
+
+#define FTF_FULLPATH	0x1
+#define FTF_VARALIGN	0x2
+#define FTF_NAMEPROPS	0x4
+#define FTF_BOOTCPUID	0x8
+#define FTF_STRTABSIZE	0x10
+#define FTF_STRUCTSIZE	0x20
+#define FTF_NOPS	0x40
+
+static struct version_info {
+	int version;
+	int last_comp_version;
+	int hdr_size;
+	int flags;
+} version_table[] = {
+	{1, 1, FDT_V1_SIZE,
+	 FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS},
+	{2, 1, FDT_V2_SIZE,
+	 FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS|FTF_BOOTCPUID},
+	{3, 1, FDT_V3_SIZE,
+	 FTF_FULLPATH|FTF_VARALIGN|FTF_NAMEPROPS|FTF_BOOTCPUID|FTF_STRTABSIZE},
+	{16, 16, FDT_V3_SIZE,
+	 FTF_BOOTCPUID|FTF_STRTABSIZE|FTF_NOPS},
+	{17, 16, FDT_V17_SIZE,
+	 FTF_BOOTCPUID|FTF_STRTABSIZE|FTF_STRUCTSIZE|FTF_NOPS},
+};
+
+struct emitter {
+	void (*cell)(void *, cell_t);
+	void (*string)(void *, char *, int);
+	void (*align)(void *, int);
+	void (*data)(void *, struct data);
+	void (*beginnode)(void *, const char *);
+	void (*endnode)(void *, const char *);
+	void (*property)(void *, const char *);
+};
+
+static void bin_emit_cell(void *e, cell_t val)
+{
+	struct data *dtbuf = e;
+
+	*dtbuf = data_append_cell(*dtbuf, val);
+}
+
+static void bin_emit_string(void *e, char *str, int len)
+{
+	struct data *dtbuf = e;
+
+	if (len == 0)
+		len = strlen(str);
+
+	*dtbuf = data_append_data(*dtbuf, str, len);
+	*dtbuf = data_append_byte(*dtbuf, '\0');
+}
+
+static void bin_emit_align(void *e, int a)
+{
+	struct data *dtbuf = e;
+
+	*dtbuf = data_append_align(*dtbuf, a);
+}
+
+static void bin_emit_data(void *e, struct data d)
+{
+	struct data *dtbuf = e;
+
+	*dtbuf = data_append_data(*dtbuf, d.val, d.len);
+}
+
+static void bin_emit_beginnode(void *e, const char *label)
+{
+	bin_emit_cell(e, FDT_BEGIN_NODE);
+}
+
+static void bin_emit_endnode(void *e, const char *label)
+{
+	bin_emit_cell(e, FDT_END_NODE);
+}
+
+static void bin_emit_property(void *e, const char *label)
+{
+	bin_emit_cell(e, FDT_PROP);
+}
+
+static struct emitter bin_emitter = {
+	.cell = bin_emit_cell,
+	.string = bin_emit_string,
+	.align = bin_emit_align,
+	.data = bin_emit_data,
+	.beginnode = bin_emit_beginnode,
+	.endnode = bin_emit_endnode,
+	.property = bin_emit_property,
+};
+
+static void emit_label(FILE *f, const char *prefix, const char *label)
+{
+	fprintf(f, "\t.globl\t%s_%s\n", prefix, label);
+	fprintf(f, "%s_%s:\n", prefix, label);
+	fprintf(f, "_%s_%s:\n", prefix, label);
+}
+
+static void emit_offset_label(FILE *f, const char *label, int offset)
+{
+	fprintf(f, "\t.globl\t%s\n", label);
+	fprintf(f, "%s\t= . + %d\n", label, offset);
+}
+
+static void asm_emit_cell(void *e, cell_t val)
+{
+	FILE *f = e;
+
+	fprintf(f, "\t.long\t0x%x\n", val);
+}
+
+static void asm_emit_string(void *e, char *str, int len)
+{
+	FILE *f = e;
+	char c = 0;
+
+	if (len != 0) {
+		/* XXX: ewww */
+		c = str[len];
+		str[len] = '\0';
+	}
+
+	fprintf(f, "\t.string\t\"%s\"\n", str);
+
+	if (len != 0) {
+		str[len] = c;
+	}
+}
+
+static void asm_emit_align(void *e, int a)
+{
+	FILE *f = e;
+
+	fprintf(f, "\t.balign\t%d\n", a);
+}
+
+static void asm_emit_data(void *e, struct data d)
+{
+	FILE *f = e;
+	int off = 0;
+	struct marker *m = d.markers;
+
+	for_each_marker_of_type(m, LABEL)
+		emit_offset_label(f, m->ref, m->offset);
+
+	while ((d.len - off) >= sizeof(uint32_t)) {
+		fprintf(f, "\t.long\t0x%x\n",
+			fdt32_to_cpu(*((uint32_t *)(d.val+off))));
+		off += sizeof(uint32_t);
+	}
+
+	while ((d.len - off) >= 1) {
+		fprintf(f, "\t.byte\t0x%hhx\n", d.val[off]);
+		off += 1;
+	}
+
+	assert(off == d.len);
+}
+
+static void asm_emit_beginnode(void *e, const char *label)
+{
+	FILE *f = e;
+
+	if (label) {
+		fprintf(f, "\t.globl\t%s\n", label);
+		fprintf(f, "%s:\n", label);
+	}
+	fprintf(f, "\t.long\tFDT_BEGIN_NODE\n");
+}
+
+static void asm_emit_endnode(void *e, const char *label)
+{
+	FILE *f = e;
+
+	fprintf(f, "\t.long\tFDT_END_NODE\n");
+	if (label) {
+		fprintf(f, "\t.globl\t%s_end\n", label);
+		fprintf(f, "%s_end:\n", label);
+	}
+}
+
+static void asm_emit_property(void *e, const char *label)
+{
+	FILE *f = e;
+
+	if (label) {
+		fprintf(f, "\t.globl\t%s\n", label);
+		fprintf(f, "%s:\n", label);
+	}
+	fprintf(f, "\t.long\tFDT_PROP\n");
+}
+
+static struct emitter asm_emitter = {
+	.cell = asm_emit_cell,
+	.string = asm_emit_string,
+	.align = asm_emit_align,
+	.data = asm_emit_data,
+	.beginnode = asm_emit_beginnode,
+	.endnode = asm_emit_endnode,
+	.property = asm_emit_property,
+};
+
+static int stringtable_insert(struct data *d, const char *str)
+{
+	int i;
+
+	/* FIXME: do this more efficiently? */
+
+	for (i = 0; i < d->len; i++) {
+		if (streq(str, d->val + i))
+			return i;
+	}
+
+	*d = data_append_data(*d, str, strlen(str)+1);
+	return i;
+}
+
+static void flatten_tree(struct node *tree, struct emitter *emit,
+			 void *etarget, struct data *strbuf,
+			 struct version_info *vi)
+{
+	struct property *prop;
+	struct node *child;
+	int seen_name_prop = 0;
+
+	emit->beginnode(etarget, tree->label);
+
+	if (vi->flags & FTF_FULLPATH)
+		emit->string(etarget, tree->fullpath, 0);
+	else
+		emit->string(etarget, tree->name, 0);
+
+	emit->align(etarget, sizeof(cell_t));
+
+	for_each_property(tree, prop) {
+		int nameoff;
+
+		if (streq(prop->name, "name"))
+			seen_name_prop = 1;
+
+		nameoff = stringtable_insert(strbuf, prop->name);
+
+		emit->property(etarget, prop->label);
+		emit->cell(etarget, prop->val.len);
+		emit->cell(etarget, nameoff);
+
+		if ((vi->flags & FTF_VARALIGN) && (prop->val.len >= 8))
+			emit->align(etarget, 8);
+
+		emit->data(etarget, prop->val);
+		emit->align(etarget, sizeof(cell_t));
+	}
+
+	if ((vi->flags & FTF_NAMEPROPS) && !seen_name_prop) {
+		emit->property(etarget, NULL);
+		emit->cell(etarget, tree->basenamelen+1);
+		emit->cell(etarget, stringtable_insert(strbuf, "name"));
+
+		if ((vi->flags & FTF_VARALIGN) && ((tree->basenamelen+1) >= 8))
+			emit->align(etarget, 8);
+
+		emit->string(etarget, tree->name, tree->basenamelen);
+		emit->align(etarget, sizeof(cell_t));
+	}
+
+	for_each_child(tree, child) {
+		flatten_tree(child, emit, etarget, strbuf, vi);
+	}
+
+	emit->endnode(etarget, tree->label);
+}
+
+static struct data flatten_reserve_list(struct reserve_info *reservelist,
+				 struct version_info *vi)
+{
+	struct reserve_info *re;
+	struct data d = empty_data;
+	static struct fdt_reserve_entry null_re = {0,0};
+	int    j;
+
+	for (re = reservelist; re; re = re->next) {
+		d = data_append_re(d, &re->re);
+	}
+	/*
+	 * Add additional reserved slots if the user asked for them.
+	 */
+	for (j = 0; j < reservenum; j++) {
+		d = data_append_re(d, &null_re);
+	}
+
+	return d;
+}
+
+static void make_fdt_header(struct fdt_header *fdt,
+			    struct version_info *vi,
+			    int reservesize, int dtsize, int strsize,
+			    int boot_cpuid_phys)
+{
+	int reserve_off;
+
+	reservesize += sizeof(struct fdt_reserve_entry);
+
+	memset(fdt, 0xff, sizeof(*fdt));
+
+	fdt->magic = cpu_to_fdt32(FDT_MAGIC);
+	fdt->version = cpu_to_fdt32(vi->version);
+	fdt->last_comp_version = cpu_to_fdt32(vi->last_comp_version);
+
+	/* Reserve map should be doubleword aligned */
+	reserve_off = ALIGN(vi->hdr_size, 8);
+
+	fdt->off_mem_rsvmap = cpu_to_fdt32(reserve_off);
+	fdt->off_dt_struct = cpu_to_fdt32(reserve_off + reservesize);
+	fdt->off_dt_strings = cpu_to_fdt32(reserve_off + reservesize
+					  + dtsize);
+	fdt->totalsize = cpu_to_fdt32(reserve_off + reservesize + dtsize + strsize);
+
+	if (vi->flags & FTF_BOOTCPUID)
+		fdt->boot_cpuid_phys = cpu_to_fdt32(boot_cpuid_phys);
+	if (vi->flags & FTF_STRTABSIZE)
+		fdt->size_dt_strings = cpu_to_fdt32(strsize);
+	if (vi->flags & FTF_STRUCTSIZE)
+		fdt->size_dt_struct = cpu_to_fdt32(dtsize);
+}
+
+void dt_to_blob(FILE *f, struct boot_info *bi, int version)
+{
+	struct version_info *vi = NULL;
+	int i;
+	struct data blob       = empty_data;
+	struct data reservebuf = empty_data;
+	struct data dtbuf      = empty_data;
+	struct data strbuf     = empty_data;
+	struct fdt_header fdt;
+	int padlen = 0;
+
+	for (i = 0; i < ARRAY_SIZE(version_table); i++) {
+		if (version_table[i].version == version)
+			vi = &version_table[i];
+	}
+	if (!vi)
+		die("Unknown device tree blob version %d\n", version);
+
+	flatten_tree(bi->dt, &bin_emitter, &dtbuf, &strbuf, vi);
+	bin_emit_cell(&dtbuf, FDT_END);
+
+	reservebuf = flatten_reserve_list(bi->reservelist, vi);
+
+	/* Make header */
+	make_fdt_header(&fdt, vi, reservebuf.len, dtbuf.len, strbuf.len,
+			bi->boot_cpuid_phys);
+
+	/*
+	 * If the user asked for more space than is used, adjust the totalsize.
+	 */
+	if (minsize > 0) {
+		padlen = minsize - fdt32_to_cpu(fdt.totalsize);
+		if ((padlen < 0) && (quiet < 1))
+			fprintf(stderr,
+				"Warning: blob size %d >= minimum size %d\n",
+				fdt32_to_cpu(fdt.totalsize), minsize);
+	}
+
+	if (padsize > 0)
+		padlen = padsize;
+
+	if (padlen > 0) {
+		int tsize = fdt32_to_cpu(fdt.totalsize);
+		tsize += padlen;
+		fdt.totalsize = cpu_to_fdt32(tsize);
+	}
+
+	/*
+	 * Assemble the blob: start with the header, add with alignment
+	 * the reserve buffer, add the reserve map terminating zeroes,
+	 * the device tree itself, and finally the strings.
+	 */
+	blob = data_append_data(blob, &fdt, vi->hdr_size);
+	blob = data_append_align(blob, 8);
+	blob = data_merge(blob, reservebuf);
+	blob = data_append_zeroes(blob, sizeof(struct fdt_reserve_entry));
+	blob = data_merge(blob, dtbuf);
+	blob = data_merge(blob, strbuf);
+
+	/*
+	 * If the user asked for more space than is used, pad out the blob.
+	 */
+	if (padlen > 0)
+		blob = data_append_zeroes(blob, padlen);
+
+	fwrite(blob.val, blob.len, 1, f);
+
+	if (ferror(f))
+		die("Error writing device tree blob: %s\n", strerror(errno));
+
+	/*
+	 * data_merge() frees the right-hand element so only the blob
+	 * remains to be freed.
+	 */
+	data_free(blob);
+}
+
+static void dump_stringtable_asm(FILE *f, struct data strbuf)
+{
+	const char *p;
+	int len;
+
+	p = strbuf.val;
+
+	while (p < (strbuf.val + strbuf.len)) {
+		len = strlen(p);
+		fprintf(f, "\t.string \"%s\"\n", p);
+		p += len+1;
+	}
+}
+
+void dt_to_asm(FILE *f, struct boot_info *bi, int version)
+{
+	struct version_info *vi = NULL;
+	int i;
+	struct data strbuf = empty_data;
+	struct reserve_info *re;
+	const char *symprefix = "dt";
+
+	for (i = 0; i < ARRAY_SIZE(version_table); i++) {
+		if (version_table[i].version == version)
+			vi = &version_table[i];
+	}
+	if (!vi)
+		die("Unknown device tree blob version %d\n", version);
+
+	fprintf(f, "/* autogenerated by dtc, do not edit */\n\n");
+	fprintf(f, "#define FDT_MAGIC 0x%x\n", FDT_MAGIC);
+	fprintf(f, "#define FDT_BEGIN_NODE 0x%x\n", FDT_BEGIN_NODE);
+	fprintf(f, "#define FDT_END_NODE 0x%x\n", FDT_END_NODE);
+	fprintf(f, "#define FDT_PROP 0x%x\n", FDT_PROP);
+	fprintf(f, "#define FDT_END 0x%x\n", FDT_END);
+	fprintf(f, "\n");
+
+	emit_label(f, symprefix, "blob_start");
+	emit_label(f, symprefix, "header");
+	fprintf(f, "\t.long\tFDT_MAGIC\t\t\t\t/* magic */\n");
+	fprintf(f, "\t.long\t_%s_blob_abs_end - _%s_blob_start\t/* totalsize */\n",
+		symprefix, symprefix);
+	fprintf(f, "\t.long\t_%s_struct_start - _%s_blob_start\t/* off_dt_struct */\n",
+		symprefix, symprefix);
+	fprintf(f, "\t.long\t_%s_strings_start - _%s_blob_start\t/* off_dt_strings */\n",
+		symprefix, symprefix);
+	fprintf(f, "\t.long\t_%s_reserve_map - _%s_blob_start\t/* off_dt_strings */\n",
+		symprefix, symprefix);
+	fprintf(f, "\t.long\t%d\t\t\t\t\t/* version */\n", vi->version);
+	fprintf(f, "\t.long\t%d\t\t\t\t\t/* last_comp_version */\n",
+		vi->last_comp_version);
+
+	if (vi->flags & FTF_BOOTCPUID)
+		fprintf(f, "\t.long\t%i\t\t\t\t\t/* boot_cpuid_phys */\n",
+			bi->boot_cpuid_phys);
+
+	if (vi->flags & FTF_STRTABSIZE)
+		fprintf(f, "\t.long\t_%s_strings_end - _%s_strings_start\t/* size_dt_strings */\n",
+			symprefix, symprefix);
+
+	if (vi->flags & FTF_STRUCTSIZE)
+		fprintf(f, "\t.long\t_%s_struct_end - _%s_struct_start\t/* size_dt_struct */\n",
+			symprefix, symprefix);
+
+	/*
+	 * Reserve map entries.
+	 * Align the reserve map to a doubleword boundary.
+	 * Each entry is an (address, size) pair of u64 values.
+	 * Always supply a zero-sized temination entry.
+	 */
+	asm_emit_align(f, 8);
+	emit_label(f, symprefix, "reserve_map");
+
+	fprintf(f, "/* Memory reserve map from source file */\n");
+
+	/*
+	 * Use .long on high and low halfs of u64s to avoid .quad
+	 * as it appears .quad isn't available in some assemblers.
+	 */
+	for (re = bi->reservelist; re; re = re->next) {
+		if (re->label) {
+			fprintf(f, "\t.globl\t%s\n", re->label);
+			fprintf(f, "%s:\n", re->label);
+		}
+		fprintf(f, "\t.long\t0x%08x, 0x%08x\n",
+			(unsigned int)(re->re.address >> 32),
+			(unsigned int)(re->re.address & 0xffffffff));
+		fprintf(f, "\t.long\t0x%08x, 0x%08x\n",
+			(unsigned int)(re->re.size >> 32),
+			(unsigned int)(re->re.size & 0xffffffff));
+	}
+	for (i = 0; i < reservenum; i++) {
+		fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
+	}
+
+	fprintf(f, "\t.long\t0, 0\n\t.long\t0, 0\n");
+
+	emit_label(f, symprefix, "struct_start");
+	flatten_tree(bi->dt, &asm_emitter, f, &strbuf, vi);
+	fprintf(f, "\t.long\tFDT_END\n");
+	emit_label(f, symprefix, "struct_end");
+
+	emit_label(f, symprefix, "strings_start");
+	dump_stringtable_asm(f, strbuf);
+	emit_label(f, symprefix, "strings_end");
+
+	emit_label(f, symprefix, "blob_end");
+
+	/*
+	 * If the user asked for more space than is used, pad it out.
+	 */
+	if (minsize > 0) {
+		fprintf(f, "\t.space\t%d - (_%s_blob_end - _%s_blob_start), 0\n",
+			minsize, symprefix, symprefix);
+	}
+	if (padsize > 0) {
+		fprintf(f, "\t.space\t%d, 0\n", padsize);
+	}
+	emit_label(f, symprefix, "blob_abs_end");
+
+	data_free(strbuf);
+}
+
+struct inbuf {
+	char *base, *limit, *ptr;
+};
+
+static void inbuf_init(struct inbuf *inb, void *base, void *limit)
+{
+	inb->base = base;
+	inb->limit = limit;
+	inb->ptr = inb->base;
+}
+
+static void flat_read_chunk(struct inbuf *inb, void *p, int len)
+{
+	if ((inb->ptr + len) > inb->limit)
+		die("Premature end of data parsing flat device tree\n");
+
+	memcpy(p, inb->ptr, len);
+
+	inb->ptr += len;
+}
+
+static uint32_t flat_read_word(struct inbuf *inb)
+{
+	uint32_t val;
+
+	assert(((inb->ptr - inb->base) % sizeof(val)) == 0);
+
+	flat_read_chunk(inb, &val, sizeof(val));
+
+	return fdt32_to_cpu(val);
+}
+
+static void flat_realign(struct inbuf *inb, int align)
+{
+	int off = inb->ptr - inb->base;
+
+	inb->ptr = inb->base + ALIGN(off, align);
+	if (inb->ptr > inb->limit)
+		die("Premature end of data parsing flat device tree\n");
+}
+
+static char *flat_read_string(struct inbuf *inb)
+{
+	int len = 0;
+	const char *p = inb->ptr;
+	char *str;
+
+	do {
+		if (p >= inb->limit)
+			die("Premature end of data parsing flat device tree\n");
+		len++;
+	} while ((*p++) != '\0');
+
+	str = strdup(inb->ptr);
+
+	inb->ptr += len;
+
+	flat_realign(inb, sizeof(uint32_t));
+
+	return str;
+}
+
+static struct data flat_read_data(struct inbuf *inb, int len)
+{
+	struct data d = empty_data;
+
+	if (len == 0)
+		return empty_data;
+
+	d = data_grow_for(d, len);
+	d.len = len;
+
+	flat_read_chunk(inb, d.val, len);
+
+	flat_realign(inb, sizeof(uint32_t));
+
+	return d;
+}
+
+static char *flat_read_stringtable(struct inbuf *inb, int offset)
+{
+	const char *p;
+
+	p = inb->base + offset;
+	while (1) {
+		if (p >= inb->limit || p < inb->base)
+			die("String offset %d overruns string table\n",
+			    offset);
+
+		if (*p == '\0')
+			break;
+
+		p++;
+	}
+
+	return strdup(inb->base + offset);
+}
+
+static struct property *flat_read_property(struct inbuf *dtbuf,
+					   struct inbuf *strbuf, int flags)
+{
+	uint32_t proplen, stroff;
+	char *name;
+	struct data val;
+
+	proplen = flat_read_word(dtbuf);
+	stroff = flat_read_word(dtbuf);
+
+	name = flat_read_stringtable(strbuf, stroff);
+
+	if ((flags & FTF_VARALIGN) && (proplen >= 8))
+		flat_realign(dtbuf, 8);
+
+	val = flat_read_data(dtbuf, proplen);
+
+	return build_property(name, val, NULL);
+}
+
+
+static struct reserve_info *flat_read_mem_reserve(struct inbuf *inb)
+{
+	struct reserve_info *reservelist = NULL;
+	struct reserve_info *new;
+	const char *p;
+	struct fdt_reserve_entry re;
+
+	/*
+	 * Each entry is a pair of u64 (addr, size) values for 4 cell_t's.
+	 * List terminates at an entry with size equal to zero.
+	 *
+	 * First pass, count entries.
+	 */
+	p = inb->ptr;
+	while (1) {
+		flat_read_chunk(inb, &re, sizeof(re));
+		re.address  = fdt64_to_cpu(re.address);
+		re.size = fdt64_to_cpu(re.size);
+		if (re.size == 0)
+			break;
+
+		new = build_reserve_entry(re.address, re.size, NULL);
+		reservelist = add_reserve_entry(reservelist, new);
+	}
+
+	return reservelist;
+}
+
+
+static char *nodename_from_path(const char *ppath, const char *cpath)
+{
+	int plen;
+
+	plen = strlen(ppath);
+
+	if (!strneq(ppath, cpath, plen))
+		die("Path \"%s\" is not valid as a child of \"%s\"\n",
+		    cpath, ppath);
+
+	/* root node is a special case */
+	if (!streq(ppath, "/"))
+		plen++;
+
+	return strdup(cpath + plen);
+}
+
+static struct node *unflatten_tree(struct inbuf *dtbuf,
+				   struct inbuf *strbuf,
+				   const char *parent_flatname, int flags)
+{
+	struct node *node;
+	char *flatname;
+	uint32_t val;
+
+	node = build_node(NULL, NULL);
+
+	flatname = flat_read_string(dtbuf);
+
+	if (flags & FTF_FULLPATH)
+		node->name = nodename_from_path(parent_flatname, flatname);
+	else
+		node->name = flatname;
+
+	do {
+		struct property *prop;
+		struct node *child;
+
+		val = flat_read_word(dtbuf);
+		switch (val) {
+		case FDT_PROP:
+			if (node->children)
+				fprintf(stderr, "Warning: Flat tree input has "
+					"subnodes preceding a property.\n");
+			prop = flat_read_property(dtbuf, strbuf, flags);
+			add_property(node, prop);
+			break;
+
+		case FDT_BEGIN_NODE:
+			child = unflatten_tree(dtbuf,strbuf, flatname, flags);
+			add_child(node, child);
+			break;
+
+		case FDT_END_NODE:
+			break;
+
+		case FDT_END:
+			die("Premature FDT_END in device tree blob\n");
+			break;
+
+		case FDT_NOP:
+			if (!(flags & FTF_NOPS))
+				fprintf(stderr, "Warning: NOP tag found in flat tree"
+					" version <16\n");
+
+			/* Ignore */
+			break;
+
+		default:
+			die("Invalid opcode word %08x in device tree blob\n",
+			    val);
+		}
+	} while (val != FDT_END_NODE);
+
+	return node;
+}
+
+
+struct boot_info *dt_from_blob(const char *fname)
+{
+	struct dtc_file *dtcf;
+	uint32_t magic, totalsize, version, size_dt, boot_cpuid_phys;
+	uint32_t off_dt, off_str, off_mem_rsvmap;
+	int rc;
+	char *blob;
+	struct fdt_header *fdt;
+	char *p;
+	struct inbuf dtbuf, strbuf;
+	struct inbuf memresvbuf;
+	int sizeleft;
+	struct reserve_info *reservelist;
+	struct node *tree;
+	uint32_t val;
+	int flags = 0;
+
+	dtcf = dtc_open_file(fname, NULL);
+
+	rc = fread(&magic, sizeof(magic), 1, dtcf->file);
+	if (ferror(dtcf->file))
+		die("Error reading DT blob magic number: %s\n",
+		    strerror(errno));
+	if (rc < 1) {
+		if (feof(dtcf->file))
+			die("EOF reading DT blob magic number\n");
+		else
+			die("Mysterious short read reading magic number\n");
+	}
+
+	magic = fdt32_to_cpu(magic);
+	if (magic != FDT_MAGIC)
+		die("Blob has incorrect magic number\n");
+
+	rc = fread(&totalsize, sizeof(totalsize), 1, dtcf->file);
+	if (ferror(dtcf->file))
+		die("Error reading DT blob size: %s\n", strerror(errno));
+	if (rc < 1) {
+		if (feof(dtcf->file))
+			die("EOF reading DT blob size\n");
+		else
+			die("Mysterious short read reading blob size\n");
+	}
+
+	totalsize = fdt32_to_cpu(totalsize);
+	if (totalsize < FDT_V1_SIZE)
+		die("DT blob size (%d) is too small\n", totalsize);
+
+	blob = xmalloc(totalsize);
+
+	fdt = (struct fdt_header *)blob;
+	fdt->magic = cpu_to_fdt32(magic);
+	fdt->totalsize = cpu_to_fdt32(totalsize);
+
+	sizeleft = totalsize - sizeof(magic) - sizeof(totalsize);
+	p = blob + sizeof(magic)  + sizeof(totalsize);
+
+	while (sizeleft) {
+		if (feof(dtcf->file))
+			die("EOF before reading %d bytes of DT blob\n",
+			    totalsize);
+
+		rc = fread(p, 1, sizeleft, dtcf->file);
+		if (ferror(dtcf->file))
+			die("Error reading DT blob: %s\n",
+			    strerror(errno));
+
+		sizeleft -= rc;
+		p += rc;
+	}
+
+	off_dt = fdt32_to_cpu(fdt->off_dt_struct);
+	off_str = fdt32_to_cpu(fdt->off_dt_strings);
+	off_mem_rsvmap = fdt32_to_cpu(fdt->off_mem_rsvmap);
+	version = fdt32_to_cpu(fdt->version);
+	boot_cpuid_phys = fdt32_to_cpu(fdt->boot_cpuid_phys);
+
+	if (off_mem_rsvmap >= totalsize)
+		die("Mem Reserve structure offset exceeds total size\n");
+
+	if (off_dt >= totalsize)
+		die("DT structure offset exceeds total size\n");
+
+	if (off_str > totalsize)
+		die("String table offset exceeds total size\n");
+
+	if (version >= 3) {
+		uint32_t size_str = fdt32_to_cpu(fdt->size_dt_strings);
+		if (off_str+size_str > totalsize)
+			die("String table extends past total size\n");
+		inbuf_init(&strbuf, blob + off_str, blob + off_str + size_str);
+	} else {
+		inbuf_init(&strbuf, blob + off_str, blob + totalsize);
+	}
+
+	if (version >= 17) {
+		size_dt = fdt32_to_cpu(fdt->size_dt_struct);
+		if (off_dt+size_dt > totalsize)
+			die("Structure block extends past total size\n");
+	}
+
+	if (version < 16) {
+		flags |= FTF_FULLPATH | FTF_NAMEPROPS | FTF_VARALIGN;
+	} else {
+		flags |= FTF_NOPS;
+	}
+
+	inbuf_init(&memresvbuf,
+		   blob + off_mem_rsvmap, blob + totalsize);
+	inbuf_init(&dtbuf, blob + off_dt, blob + totalsize);
+
+	reservelist = flat_read_mem_reserve(&memresvbuf);
+
+	val = flat_read_word(&dtbuf);
+
+	if (val != FDT_BEGIN_NODE)
+		die("Device tree blob doesn't begin with FDT_BEGIN_NODE (begins with 0x%08x)\n", val);
+
+	tree = unflatten_tree(&dtbuf, &strbuf, "", flags);
+
+	val = flat_read_word(&dtbuf);
+	if (val != FDT_END)
+		die("Device tree blob doesn't end with FDT_END\n");
+
+	free(blob);
+
+	dtc_close_file(dtcf);
+
+	return build_boot_info(reservelist, tree, boot_cpuid_phys);
+}
