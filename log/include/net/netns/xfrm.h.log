commit 24969facd704a5f0dd8e08da86bf32a9ce972bee
Author: Florian Westphal <fw@strlen.de>
Date:   Wed Nov 7 23:00:35 2018 +0100

    xfrm: policy: store inexact policies in an rhashtable
    
    Switch packet-path lookups for inexact policies to rhashtable.
    
    In this initial version, we now no longer need to search policies with
    non-matching address family and type.
    
    Next patch will add the if_id as well so lookups from the xfrm interface
    driver only need to search inexact policies for that device.
    
    Future patches will augment the hlist in each rhash bucket with a tree
    and pre-sort policies according to daddr/prefix.
    
    A single rhashtable is used.  In order to avoid a full rhashtable walk on
    netns exit, the bins get placed on a pernet list, i.e. we add almost no
    cost for network namespaces that had no xfrm policies.
    
    The inexact lists are kept in place, and policies are added to both the
    per-rhash-inexact list and a pernet one.
    
    The latter is needed for the control plane to handle migrate -- these
    requests do not consider the if_id, so if we'd remove the inexact_list
    now we would have to search all hash buckets and then figure
    out which matching policy candidate is the most recent one -- this appears
    a bit harder than just keeping the 'old' inexact list for this purpose.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 9991e5ef52cc..59f45b1e9dac 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -5,6 +5,7 @@
 #include <linux/list.h>
 #include <linux/wait.h>
 #include <linux/workqueue.h>
+#include <linux/rhashtable-types.h>
 #include <linux/xfrm.h>
 #include <net/dst_ops.h>
 
@@ -53,6 +54,7 @@ struct netns_xfrm {
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 	struct work_struct	policy_hash_work;
 	struct xfrm_policy_hthresh policy_hthresh;
+	struct list_head	inexact_bins;
 
 
 	struct sock		*nlsk;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 611521646dd4..9991e5ef52cc 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __NETNS_XFRM_H
 #define __NETNS_XFRM_H
 

commit 09c7570480f7544ffbf8e6db365208b0b0c154c6
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Jul 17 13:57:26 2017 +0200

    xfrm: remove flow cache
    
    After rcu conversions performance degradation in forward tests isn't that
    noticeable anymore.
    
    See next patch for some numbers.
    
    A followup patcg could then also remove genid from the policies
    as we do not cache bundles anymore.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 27bb9633c69d..611521646dd4 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -6,7 +6,6 @@
 #include <linux/workqueue.h>
 #include <linux/xfrm.h>
 #include <net/dst_ops.h>
-#include <net/flowcache.h>
 
 struct ctl_table_header;
 
@@ -73,16 +72,6 @@ struct netns_xfrm {
 	spinlock_t xfrm_state_lock;
 	spinlock_t xfrm_policy_lock;
 	struct mutex xfrm_cfg_mutex;
-
-	/* flow cache part */
-	struct flow_cache	flow_cache_global;
-	atomic_t		flow_cache_genid;
-	struct list_head	flow_cache_gc_list;
-	atomic_t		flow_cache_gc_count;
-	spinlock_t		flow_cache_gc_lock;
-	struct work_struct	flow_cache_gc_work;
-	struct work_struct	flow_cache_flush_work;
-	struct mutex		flow_flush_sem;
 };
 
 #endif

commit 35db57bbc4b7ab810bba6e6d6954a0faf5a842cf
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Aug 23 16:00:12 2016 +0200

    xfrm: state: remove per-netns gc task
    
    After commit 5b8ef3415a21f173
    ("xfrm: Remove ancient sleeping when the SA is in acquire state")
    gc does not need any per-netns data anymore.
    
    As far as gc is concerned all state structs are the same, so we
    can use a global work struct for it.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 177ed444d7b2..27bb9633c69d 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -44,8 +44,6 @@ struct netns_xfrm {
 	unsigned int		state_hmask;
 	unsigned int		state_num;
 	struct work_struct	state_hash_work;
-	struct hlist_head	state_gc_list;
-	struct work_struct	state_gc_work;
 
 	struct list_head	policy_all;
 	struct hlist_head	*policy_byidx;

commit 9d0380df6217e8dd014118fa1c99dda9974f3613
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Aug 11 15:17:59 2016 +0200

    xfrm: policy: convert policy_lock to spinlock
    
    After earlier patches conversions all spots acquire the writer lock and
    we can now convert this to a normal spinlock.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 3ab828a97e68..177ed444d7b2 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -73,7 +73,7 @@ struct netns_xfrm {
 	struct dst_ops		xfrm6_dst_ops;
 #endif
 	spinlock_t xfrm_state_lock;
-	rwlock_t xfrm_policy_lock;
+	spinlock_t xfrm_policy_lock;
 	struct mutex xfrm_cfg_mutex;
 
 	/* flow cache part */

commit a7c44247f704e385c77579d65c6ee6d002832529
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Aug 11 15:17:56 2016 +0200

    xfrm: policy: make xfrm_policy_lookup_bytype lockless
    
    side effect: no longer disables BH (should be fine).
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 1ab51d188408..3ab828a97e68 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -11,7 +11,7 @@
 struct ctl_table_header;
 
 struct xfrm_policy_hash {
-	struct hlist_head	*table;
+	struct hlist_head	__rcu *table;
 	unsigned int		hmask;
 	u8			dbits4;
 	u8			sbits4;

commit d737a5805581c6f99dad4caa9fdf80965d617d1a
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Aug 9 12:16:09 2016 +0200

    xfrm: state: don't use lock anymore unless acquire operation is needed
    
    push the lock down, after earlier patches we can rely on rcu to
    make sure state struct won't go away.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 24cd3949a9a4..1ab51d188408 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -38,9 +38,9 @@ struct netns_xfrm {
 	 * mode. Also, it can be used by ah/esp icmp error handler to find
 	 * offending SA.
 	 */
-	struct hlist_head	*state_bydst;
-	struct hlist_head	*state_bysrc;
-	struct hlist_head	*state_byspi;
+	struct hlist_head	__rcu *state_bydst;
+	struct hlist_head	__rcu *state_bysrc;
+	struct hlist_head	__rcu *state_byspi;
 	unsigned int		state_hmask;
 	unsigned int		state_num;
 	struct work_struct	state_hash_work;

commit 6ad3122a08e3a9c2148873665752e87cf4f393cc
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Mon Feb 22 10:40:07 2016 +0100

    flowcache: Avoid OOM condition under preasure
    
    We can hit an OOM condition if we are under presure because
    we can not free the entries in gc_list fast enough. So add
    a counter for the not yet freed entries in the gc_list and
    refuse new allocations if the value is too high.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 730d82ad6ee5..24cd3949a9a4 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -80,6 +80,7 @@ struct netns_xfrm {
 	struct flow_cache	flow_cache_global;
 	atomic_t		flow_cache_genid;
 	struct list_head	flow_cache_gc_list;
+	atomic_t		flow_cache_gc_count;
 	spinlock_t		flow_cache_gc_lock;
 	struct work_struct	flow_cache_gc_work;
 	struct work_struct	flow_cache_flush_work;

commit 53c2e285f9703001e1bb48d04696c5f9d8f3aef7
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Nov 13 17:09:49 2014 +0800

    xfrm: Do not hash socket policies
    
    Back in 2003 when I added policy expiration, I half-heartedly
    did a clean-up and renamed xfrm_sk_policy_link/xfrm_sk_policy_unlink
    to __xfrm_policy_link/__xfrm_policy_unlink, because the latter
    could be reused for all policies.  I never actually got around
    to using __xfrm_policy_link for non-socket policies.
    
    Later on hashing was added to all xfrm policies, including socket
    policies.  In fact, we don't need hashing on socket policies at
    all since they're always looked up via a linked list.
    
    This patch restores xfrm_sk_policy_link/xfrm_sk_policy_unlink
    as wrappers around __xfrm_policy_link/__xfrm_policy_unlink so
    that it's obvious we're dealing with socket policies.
    
    This patch also removes hashing from __xfrm_policy_link as for
    now it's only used by socket policies which do not need to be
    hashed.  Ironically this will in fact allow us to use this helper
    for non-socket policies which I shall do later.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 9da798256f0e..730d82ad6ee5 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -50,8 +50,8 @@ struct netns_xfrm {
 	struct list_head	policy_all;
 	struct hlist_head	*policy_byidx;
 	unsigned int		policy_idx_hmask;
-	struct hlist_head	policy_inexact[XFRM_POLICY_MAX * 2];
-	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX * 2];
+	struct hlist_head	policy_inexact[XFRM_POLICY_MAX];
+	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX];
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 	struct work_struct	policy_hash_work;
 	struct xfrm_policy_hthresh policy_hthresh;

commit 880a6fab8f6ba5b5abe59ea68533202ddea1012c
Author: Christophe Gouault <christophe.gouault@6wind.com>
Date:   Fri Aug 29 16:16:05 2014 +0200

    xfrm: configure policy hash table thresholds by netlink
    
    Enable to specify local and remote prefix length thresholds for the
    policy hash table via a netlink XFRM_MSG_NEWSPDINFO message.
    
    prefix length thresholds are specified by XFRMA_SPD_IPV4_HTHRESH and
    XFRMA_SPD_IPV6_HTHRESH optional attributes (struct xfrmu_spdhthresh).
    
    example:
    
        struct xfrmu_spdhthresh thresh4 = {
            .lbits = 0;
            .rbits = 24;
        };
        struct xfrmu_spdhthresh thresh6 = {
            .lbits = 0;
            .rbits = 56;
        };
        struct nlmsghdr *hdr;
        struct nl_msg *msg;
    
        msg = nlmsg_alloc();
        hdr = nlmsg_put(msg, NL_AUTO_PORT, NL_AUTO_SEQ, XFRMA_SPD_IPV4_HTHRESH, sizeof(__u32), NLM_F_REQUEST);
        nla_put(msg, XFRMA_SPD_IPV4_HTHRESH, sizeof(thresh4), &thresh4);
        nla_put(msg, XFRMA_SPD_IPV6_HTHRESH, sizeof(thresh6), &thresh6);
        nla_send_auto(sk, msg);
    
    The numbers are the policy selector minimum prefix lengths to put a
    policy in the hash table.
    
    - lbits is the local threshold (source address for out policies,
      destination address for in and fwd policies).
    
    - rbits is the remote threshold (destination address for out
      policies, source address for in and fwd policies).
    
    The default values are:
    
    XFRMA_SPD_IPV4_HTHRESH: 32 32
    XFRMA_SPD_IPV6_HTHRESH: 128 128
    
    Dynamic re-building of the SPD is performed when the thresholds values
    are changed.
    
    The current thresholds can be read via a XFRM_MSG_GETSPDINFO request:
    the kernel replies to XFRM_MSG_GETSPDINFO requests by an
    XFRM_MSG_NEWSPDINFO message, with both attributes
    XFRMA_SPD_IPV4_HTHRESH and XFRMA_SPD_IPV6_HTHRESH.
    
    Signed-off-by: Christophe Gouault <christophe.gouault@6wind.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 41902a8103bd..9da798256f0e 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -19,6 +19,15 @@ struct xfrm_policy_hash {
 	u8			sbits6;
 };
 
+struct xfrm_policy_hthresh {
+	struct work_struct	work;
+	seqlock_t		lock;
+	u8			lbits4;
+	u8			rbits4;
+	u8			lbits6;
+	u8			rbits6;
+};
+
 struct netns_xfrm {
 	struct list_head	state_all;
 	/*
@@ -45,6 +54,7 @@ struct netns_xfrm {
 	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX * 2];
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 	struct work_struct	policy_hash_work;
+	struct xfrm_policy_hthresh policy_hthresh;
 
 
 	struct sock		*nlsk;

commit b58555f1767c9f4e330fcf168e4e753d2d9196e0
Author: Christophe Gouault <christophe.gouault@6wind.com>
Date:   Fri Aug 29 16:16:04 2014 +0200

    xfrm: hash prefixed policies based on preflen thresholds
    
    The idea is an extension of the current policy hashing.
    
    Today only non-prefixed policies are stored in a hash table. This
    patch relaxes the constraints, and hashes policies whose prefix
    lengths are greater or equal to a configurable threshold.
    
    Each hash table (one per direction) maintains its own set of IPv4 and
    IPv6 thresholds (dbits4, sbits4, dbits6, sbits6), by default (32, 32,
    128, 128).
    
    Example, if the output hash table is configured with values (16, 24,
    56, 64):
    
    ip xfrm policy add dir out src 10.22.0.0/20 dst 10.24.1.0/24 ... => hashed
    ip xfrm policy add dir out src 10.22.0.0/16 dst 10.24.1.1/32 ... => hashed
    ip xfrm policy add dir out src 10.22.0.0/16 dst 10.24.0.0/16 ... => unhashed
    
    ip xfrm policy add dir out \
        src 3ffe:304:124:2200::/60 dst 3ffe:304:124:2401::/64 ...    => hashed
    ip xfrm policy add dir out \
        src 3ffe:304:124:2200::/56 dst 3ffe:304:124:2401::2/128 ...  => hashed
    ip xfrm policy add dir out \
        src 3ffe:304:124:2200::/56 dst 3ffe:304:124:2400::/56 ...    => unhashed
    
    The high order bits of the addresses (up to the threshold) are used to
    compute the hash key.
    
    Signed-off-by: Christophe Gouault <christophe.gouault@6wind.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 3492434baf88..41902a8103bd 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -13,6 +13,10 @@ struct ctl_table_header;
 struct xfrm_policy_hash {
 	struct hlist_head	*table;
 	unsigned int		hmask;
+	u8			dbits4;
+	u8			sbits4;
+	u8			dbits6;
+	u8			sbits6;
 };
 
 struct netns_xfrm {

commit d32d9bb85c65f52bed99a0149b47e9f6578c44c5
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Mar 10 07:09:07 2014 -0700

    flowcache: restore a single flow_cache kmem_cache
    
    It is not legal to create multiple kmem_cache having the same name.
    
    flowcache can use a single kmem_cache, no need for a per netns
    one.
    
    Fixes: ca925cf1534e ("flowcache: Make flow cache name space aware")
    Reported-by: Jakub Kicinski <moorray3@wp.pl>
    Tested-by: Jakub Kicinski <moorray3@wp.pl>
    Tested-by: Fan Du <fan.du@windriver.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 51f0dce7b643..3492434baf88 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -64,7 +64,6 @@ struct netns_xfrm {
 
 	/* flow cache part */
 	struct flow_cache	flow_cache_global;
-	struct kmem_cache	*flow_cachep;
 	atomic_t		flow_cache_genid;
 	struct list_head	flow_cache_gc_list;
 	spinlock_t		flow_cache_gc_lock;

commit 1a1ccc96abb2ed9b8fbb71018e64b97324caef53
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Wed Feb 19 10:07:34 2014 +0100

    xfrm: Remove caching of xfrm_policy_sk_bundles
    
    We currently cache socket policy bundles at xfrm_policy_sk_bundles.
    These cached bundles are never used. Instead we create and cache
    a new one whenever xfrm_lookup() is called on a socket policy.
    
    Most protocols cache the used routes to the socket, so let's
    remove the unused caching of socket policy bundles in xfrm.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 52d0086d55d3..51f0dce7b643 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -59,7 +59,6 @@ struct netns_xfrm {
 	struct dst_ops		xfrm6_dst_ops;
 #endif
 	spinlock_t xfrm_state_lock;
-	spinlock_t xfrm_policy_sk_bundle_lock;
 	rwlock_t xfrm_policy_lock;
 	struct mutex xfrm_cfg_mutex;
 

commit ca925cf1534ebcec332c08719a7dee6ee1782ce4
Author: Fan Du <fan.du@windriver.com>
Date:   Sat Jan 18 09:55:27 2014 +0800

    flowcache: Make flow cache name space aware
    
    Inserting a entry into flowcache, or flushing flowcache should be based
    on per net scope. The reason to do so is flushing operation from fat
    netns crammed with flow entries will also making the slim netns with only
    a few flow cache entries go away in original implementation.
    
    Since flowcache is tightly coupled with IPsec, so it would be easier to
    put flow cache global parameters into xfrm namespace part. And one last
    thing needs to do is bumping flow cache genid, and flush flow cache should
    also be made in per net style.
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 1006a265beb3..52d0086d55d3 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -6,6 +6,7 @@
 #include <linux/workqueue.h>
 #include <linux/xfrm.h>
 #include <net/dst_ops.h>
+#include <net/flowcache.h>
 
 struct ctl_table_header;
 
@@ -61,6 +62,16 @@ struct netns_xfrm {
 	spinlock_t xfrm_policy_sk_bundle_lock;
 	rwlock_t xfrm_policy_lock;
 	struct mutex xfrm_cfg_mutex;
+
+	/* flow cache part */
+	struct flow_cache	flow_cache_global;
+	struct kmem_cache	*flow_cachep;
+	atomic_t		flow_cache_genid;
+	struct list_head	flow_cache_gc_list;
+	spinlock_t		flow_cache_gc_lock;
+	struct work_struct	flow_cache_gc_work;
+	struct work_struct	flow_cache_flush_work;
+	struct mutex		flow_flush_sem;
 };
 
 #endif

commit 5b8ef3415a21f173ab115e90ec92c071a03f22d7
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Tue Aug 27 13:43:30 2013 +0200

    xfrm: Remove ancient sleeping when the SA is in acquire state
    
    We now queue packets to the policy if the states are not yet resolved,
    this replaces the ancient sleeping code. Also the sleeping can cause
    indefinite task hangs if the needed state does not get resolved.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index ea28404e9d79..1006a265beb3 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -33,8 +33,6 @@ struct netns_xfrm {
 	struct hlist_head	state_gc_list;
 	struct work_struct	state_gc_work;
 
-	wait_queue_head_t	km_waitq;
-
 	struct list_head	policy_all;
 	struct hlist_head	*policy_byidx;
 	unsigned int		policy_idx_hmask;

commit 283bc9f35bbbcb0e9ab4e6d2427da7f9f710d52d
Author: Fan Du <fan.du@windriver.com>
Date:   Thu Nov 7 17:47:50 2013 +0800

    xfrm: Namespacify xfrm state/policy locks
    
    By semantics, xfrm layer is fully name space aware,
    so will the locks, e.g. xfrm_state/pocliy_lock.
    Ensure exclusive access into state/policy link list
    for different name space with one global lock is not
    right in terms of semantics aspect at first place,
    as they are indeed mutually independent with each
    other, but also more seriously causes scalability
    problem.
    
    One practical scenario is on a Open Network Stack,
    more than hundreds of lxc tenants acts as routers
    within one host, a global xfrm_state/policy_lock
    becomes the bottleneck. But onces those locks are
    decoupled in a per-namespace fashion, locks contend
    is just with in specific name space scope, without
    causing additional SPD/SAD access delay for other
    name space.
    
    Also this patch improve scalability while as without
    changing original xfrm behavior.
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 5299e69a32af..ea28404e9d79 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -59,6 +59,10 @@ struct netns_xfrm {
 #if IS_ENABLED(CONFIG_IPV6)
 	struct dst_ops		xfrm6_dst_ops;
 #endif
+	spinlock_t xfrm_state_lock;
+	spinlock_t xfrm_policy_sk_bundle_lock;
+	rwlock_t xfrm_policy_lock;
+	struct mutex xfrm_cfg_mutex;
 };
 
 #endif

commit dfd56b8b38fff3586f36232db58e1e9f7885a605
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sat Dec 10 09:48:31 2011 +0000

    net: use IS_ENABLED(CONFIG_IPV6)
    
    Instead of testing defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 748f91f87cd5..5299e69a32af 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -56,7 +56,7 @@ struct netns_xfrm {
 #endif
 
 	struct dst_ops		xfrm4_dst_ops;
-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#if IS_ENABLED(CONFIG_IPV6)
 	struct dst_ops		xfrm6_dst_ops;
 #endif
 };

commit 8e602ce2980fd6941dc0d3dda12e5095e8206f34
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Oct 14 05:56:18 2010 +0000

    netns: reorder fields in struct net
    
    In a network bench, I noticed an unfortunate false sharing between
    'loopback_dev' and 'count' fields in "struct net".
    
    'count' is written each time a socket is created or destroyed, while
    loopback_dev might be often read in routing code.
    
    Move loopback_dev in a read mostly section of "struct net"
    
    Note: struct netns_xfrm is cache line aligned on SMP.
    (It contains a "struct dst_ops")
    Move it at the end to avoid holes, and reduce sizeof(struct net) by 128
    bytes on ia32.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 74f119a2829a..748f91f87cd5 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -43,10 +43,6 @@ struct netns_xfrm {
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 	struct work_struct	policy_hash_work;
 
-	struct dst_ops		xfrm4_dst_ops;
-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
-	struct dst_ops		xfrm6_dst_ops;
-#endif
 
 	struct sock		*nlsk;
 	struct sock		*nlsk_stash;
@@ -58,6 +54,11 @@ struct netns_xfrm {
 #ifdef CONFIG_SYSCTL
 	struct ctl_table_header	*sysctl_hdr;
 #endif
+
+	struct dst_ops		xfrm4_dst_ops;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	struct dst_ops		xfrm6_dst_ops;
+#endif
 };
 
 #endif

commit d7c7544c3d5f59033d1bf3236bc7b289f5f26b75
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sun Jan 24 22:47:53 2010 -0800

    netns xfrm: deal with dst entries in netns
    
    GC is non-existent in netns, so after you hit GC threshold, no new
    dst entries will be created until someone triggers cleanup in init_net.
    
    Make xfrm4_dst_ops and xfrm6_dst_ops per-netns.
    This is not done in a generic way, because it woule waste
    (AF_MAX - 2) * sizeof(struct dst_ops) bytes per-netns.
    
    Reorder GC threshold initialization so it'd be done before registering
    XFRM policies.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 56f8e5585df7..74f119a2829a 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -5,6 +5,7 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 #include <linux/xfrm.h>
+#include <net/dst_ops.h>
 
 struct ctl_table_header;
 
@@ -42,6 +43,11 @@ struct netns_xfrm {
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 	struct work_struct	policy_hash_work;
 
+	struct dst_ops		xfrm4_dst_ops;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	struct dst_ops		xfrm6_dst_ops;
+#endif
+
 	struct sock		*nlsk;
 	struct sock		*nlsk_stash;
 

commit d79d792ef9f99cca463b6619a93e860d1c833a6e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Dec 3 02:29:05 2009 +0000

    net: Allow xfrm_user_net_exit to batch efficiently.
    
    xfrm.nlsk is provided by the xfrm_user module and is access via rcu from
    other parts of the xfrm code.  Add xfrm.nlsk_stash a copy of xfrm.nlsk that
    will never be set to NULL.  This allows the synchronize_net and
    netlink_kernel_release to be deferred until a whole batch of xfrm.nlsk sockets
    have been set to NULL.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 1ba912749caa..56f8e5585df7 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -43,6 +43,7 @@ struct netns_xfrm {
 	struct work_struct	policy_hash_work;
 
 	struct sock		*nlsk;
+	struct sock		*nlsk_stash;
 
 	u32			sysctl_aevent_etime;
 	u32			sysctl_aevent_rseqth;

commit b27aeadb5948d400df83db4d29590fb9862ba49d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 18:00:48 2008 -0800

    netns xfrm: per-netns sysctls
    
    Make
            net.core.xfrm_aevent_etime
            net.core.xfrm_acq_expires
            net.core.xfrm_aevent_rseqth
            net.core.xfrm_larval_drop
    
    sysctls per-netns.
    
    For that make net_core_path[] global, register it to prevent two
    /proc/net/core antries and change initcall position -- xfrm_init() is called
    from fs_initcall, so this one should be fs_initcall at least.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 09f3060e9d18..1ba912749caa 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -6,6 +6,8 @@
 #include <linux/workqueue.h>
 #include <linux/xfrm.h>
 
+struct ctl_table_header;
+
 struct xfrm_policy_hash {
 	struct hlist_head	*table;
 	unsigned int		hmask;
@@ -41,6 +43,14 @@ struct netns_xfrm {
 	struct work_struct	policy_hash_work;
 
 	struct sock		*nlsk;
+
+	u32			sysctl_aevent_etime;
+	u32			sysctl_aevent_rseqth;
+	int			sysctl_larval_drop;
+	u32			sysctl_acq_expires;
+#ifdef CONFIG_SYSCTL
+	struct ctl_table_header	*sysctl_hdr;
+#endif
 };
 
 #endif

commit a6483b790f8efcd8db190c1c0ff93f9d9efe919a
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:38:20 2008 -0800

    netns xfrm: per-netns NETLINK_XFRM socket
    
    Stub senders to init_net's one temporarily.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index c53d17357a49..09f3060e9d18 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -39,6 +39,8 @@ struct netns_xfrm {
 	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX * 2];
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 	struct work_struct	policy_hash_work;
+
+	struct sock		*nlsk;
 };
 
 #endif

commit 66caf628c3b634c57b14a1a104dcd57e4fab2e3b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:28:57 2008 -0800

    netns xfrm: per-netns policy hash resizing work
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index d5aadf06be46..c53d17357a49 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -38,6 +38,7 @@ struct netns_xfrm {
 	struct hlist_head	policy_inexact[XFRM_POLICY_MAX * 2];
 	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX * 2];
 	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
+	struct work_struct	policy_hash_work;
 };
 
 #endif

commit dc2caba7b321289e7d02e63d7216961ccecfa103
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:24:15 2008 -0800

    netns xfrm: per-netns policy counts
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 39cfa799fa90..d5aadf06be46 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -37,6 +37,7 @@ struct netns_xfrm {
 	unsigned int		policy_idx_hmask;
 	struct hlist_head	policy_inexact[XFRM_POLICY_MAX * 2];
 	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX * 2];
+	unsigned int		policy_count[XFRM_POLICY_MAX * 2];
 };
 
 #endif

commit a35f6c5de32664d82c072a7e2c7d5c5234de4158
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:23:48 2008 -0800

    netns xfrm: per-netns xfrm_policy_bydst hash
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index c7568315f16c..39cfa799fa90 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -6,6 +6,11 @@
 #include <linux/workqueue.h>
 #include <linux/xfrm.h>
 
+struct xfrm_policy_hash {
+	struct hlist_head	*table;
+	unsigned int		hmask;
+};
+
 struct netns_xfrm {
 	struct list_head	state_all;
 	/*
@@ -31,6 +36,7 @@ struct netns_xfrm {
 	struct hlist_head	*policy_byidx;
 	unsigned int		policy_idx_hmask;
 	struct hlist_head	policy_inexact[XFRM_POLICY_MAX * 2];
+	struct xfrm_policy_hash	policy_bydst[XFRM_POLICY_MAX * 2];
 };
 
 #endif

commit 8b18f8eaf9207d53ba3e69f2b98d7290f4dec227
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:23:26 2008 -0800

    netns xfrm: per-netns inexact policies
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 42dc318fe3de..c7568315f16c 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -4,6 +4,7 @@
 #include <linux/list.h>
 #include <linux/wait.h>
 #include <linux/workqueue.h>
+#include <linux/xfrm.h>
 
 struct netns_xfrm {
 	struct list_head	state_all;
@@ -29,6 +30,7 @@ struct netns_xfrm {
 	struct list_head	policy_all;
 	struct hlist_head	*policy_byidx;
 	unsigned int		policy_idx_hmask;
+	struct hlist_head	policy_inexact[XFRM_POLICY_MAX * 2];
 };
 
 #endif

commit 8100bea7d619e8496ad8e545d1b41f536e076cd5
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:22:58 2008 -0800

    netns xfrm: per-netns xfrm_policy_byidx hashmask
    
    Per-netns hashes are independently resizeable.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 5cd7d06c692b..42dc318fe3de 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -28,6 +28,7 @@ struct netns_xfrm {
 
 	struct list_head	policy_all;
 	struct hlist_head	*policy_byidx;
+	unsigned int		policy_idx_hmask;
 };
 
 #endif

commit 93b851c1c93c7d5cd8d94cd3f3a268b2d5460e9e
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:22:35 2008 -0800

    netns xfrm: per-netns xfrm_policy_byidx hash
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 66489249cd1a..5cd7d06c692b 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -27,6 +27,7 @@ struct netns_xfrm {
 	wait_queue_head_t	km_waitq;
 
 	struct list_head	policy_all;
+	struct hlist_head	*policy_byidx;
 };
 
 #endif

commit adfcf0b27e87d16a6a8c364daa724653d4d8930b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:22:11 2008 -0800

    netns xfrm: per-netns policy list
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 2a383c8ba1af..66489249cd1a 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -25,6 +25,8 @@ struct netns_xfrm {
 	struct work_struct	state_gc_work;
 
 	wait_queue_head_t	km_waitq;
+
+	struct list_head	policy_all;
 };
 
 #endif

commit 50a30657fd7ee77a94a6bf0ad86eba7c37c3032e
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:21:01 2008 -0800

    netns xfrm: per-netns km_waitq
    
    Disallow spurious wakeups in __xfrm_lookup().
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 80555351fe5e..2a383c8ba1af 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -2,6 +2,7 @@
 #define __NETNS_XFRM_H
 
 #include <linux/list.h>
+#include <linux/wait.h>
 #include <linux/workqueue.h>
 
 struct netns_xfrm {
@@ -22,6 +23,8 @@ struct netns_xfrm {
 	struct work_struct	state_hash_work;
 	struct hlist_head	state_gc_list;
 	struct work_struct	state_gc_work;
+
+	wait_queue_head_t	km_waitq;
 };
 
 #endif

commit c78371441c0d957f54c9f8a35b3ee5a378d14808
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:20:36 2008 -0800

    netns xfrm: per-netns state GC work
    
    State GC is per-netns, and this is part of it.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 8ceb76568852..80555351fe5e 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -21,6 +21,7 @@ struct netns_xfrm {
 	unsigned int		state_num;
 	struct work_struct	state_hash_work;
 	struct hlist_head	state_gc_list;
+	struct work_struct	state_gc_work;
 };
 
 #endif

commit b8a0ae20b0eecd4b86a113d2abe2fa5a582b30a6
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:20:11 2008 -0800

    netns xfrm: per-netns state GC list
    
    km_waitq is going to be made per-netns to disallow spurious wakeups
    in __xfrm_lookup().
    
    To not wakeup after every garbage-collected xfrm_state (which potentially
    can be from different netns) make state GC list per-netns.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index bd688021395a..8ceb76568852 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -20,6 +20,7 @@ struct netns_xfrm {
 	unsigned int		state_hmask;
 	unsigned int		state_num;
 	struct work_struct	state_hash_work;
+	struct hlist_head	state_gc_list;
 };
 
 #endif

commit 630827338585022b851ec0a6335df8e436c900e4
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:19:07 2008 -0800

    netns xfrm: per-netns xfrm_hash_work
    
    All of this is implicit passing which netns's hashes should be resized.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 492b471d2a7f..bd688021395a 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -2,6 +2,7 @@
 #define __NETNS_XFRM_H
 
 #include <linux/list.h>
+#include <linux/workqueue.h>
 
 struct netns_xfrm {
 	struct list_head	state_all;
@@ -18,6 +19,7 @@ struct netns_xfrm {
 	struct hlist_head	*state_byspi;
 	unsigned int		state_hmask;
 	unsigned int		state_num;
+	struct work_struct	state_hash_work;
 };
 
 #endif

commit 0bf7c5b019518d3fe9cb96b9c97bf44d251472c3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:18:39 2008 -0800

    netns xfrm: per-netns xfrm_state counts
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index dbbc0e972273..492b471d2a7f 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -17,6 +17,7 @@ struct netns_xfrm {
 	struct hlist_head	*state_bysrc;
 	struct hlist_head	*state_byspi;
 	unsigned int		state_hmask;
+	unsigned int		state_num;
 };
 
 #endif

commit 529983ecabeae3d8e61c9e27079154b1b8544dcd
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:18:12 2008 -0800

    netns xfrm: per-netns xfrm_state_hmask
    
    Since hashtables are per-netns, they can be independently resized.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index b05ca3f366aa..dbbc0e972273 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -16,6 +16,7 @@ struct netns_xfrm {
 	struct hlist_head	*state_bydst;
 	struct hlist_head	*state_bysrc;
 	struct hlist_head	*state_byspi;
+	unsigned int		state_hmask;
 };
 
 #endif

commit b754a4fd8f58d245c9b5e92914cce09c4309cb67
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:17:47 2008 -0800

    netns xfrm: per-netns xfrm_state_byspi hash
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index bfcd5a3e25b6..b05ca3f366aa 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -15,6 +15,7 @@ struct netns_xfrm {
 	 */
 	struct hlist_head	*state_bydst;
 	struct hlist_head	*state_bysrc;
+	struct hlist_head	*state_byspi;
 };
 
 #endif

commit d320bbb306f2085892bc958781e8fcaf5d491589
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:17:24 2008 -0800

    netns xfrm: per-netns xfrm_state_bysrc hash
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 02487b39ce53..bfcd5a3e25b6 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -14,6 +14,7 @@ struct netns_xfrm {
 	 * offending SA.
 	 */
 	struct hlist_head	*state_bydst;
+	struct hlist_head	*state_bysrc;
 };
 
 #endif

commit 73d189dce486cd6693fa29169b1aac0872efbcea
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:16:58 2008 -0800

    netns xfrm: per-netns xfrm_state_bydst hash
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 6ae234a16517..02487b39ce53 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -5,6 +5,15 @@
 
 struct netns_xfrm {
 	struct list_head	state_all;
+	/*
+	 * Hash table to find appropriate SA towards given target (endpoint of
+	 * tunnel or destination of transport mode) allowed by selector.
+	 *
+	 * Main use is finding SA after policy selected tunnel or transport
+	 * mode. Also, it can be used by ah/esp icmp error handler to find
+	 * offending SA.
+	 */
+	struct hlist_head	*state_bydst;
 };
 
 #endif

commit 9d4139c76905833afcb77fe8ccc17f302a0eb9ab
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:16:11 2008 -0800

    netns xfrm: per-netns xfrm_state_all list
    
    This is done to get
    a) simple "something leaked" check
    b) cover possible DoSes when other netns puts many, many xfrm_states
       onto a list.
    c) not miss "alien xfrm_state" check in some of list iterators in future.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
index 1cb0024a3b47..6ae234a16517 100644
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@ -1,7 +1,10 @@
 #ifndef __NETNS_XFRM_H
 #define __NETNS_XFRM_H
 
+#include <linux/list.h>
+
 struct netns_xfrm {
+	struct list_head	state_all;
 };
 
 #endif

commit d62ddc21b674b5ac1466091ff3fbf7baa53bc92c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Nov 25 17:14:31 2008 -0800

    netns xfrm: add netns boilerplate
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netns/xfrm.h b/include/net/netns/xfrm.h
new file mode 100644
index 000000000000..1cb0024a3b47
--- /dev/null
+++ b/include/net/netns/xfrm.h
@@ -0,0 +1,7 @@
+#ifndef __NETNS_XFRM_H
+#define __NETNS_XFRM_H
+
+struct netns_xfrm {
+};
+
+#endif
