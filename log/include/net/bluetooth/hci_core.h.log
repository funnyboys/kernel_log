commit 3ca44c16b0dcc764b641ee4ac226909f5c421aa3
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Tue May 19 13:25:19 2020 -0700

    Bluetooth: Consolidate encryption handling in hci_encrypt_cfm
    
    This makes hci_encrypt_cfm calls hci_connect_cfm in case the connection
    state is BT_CONFIG so callers don't have to check the state.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5dcf85f186c6..cdd4f1db8670 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1381,10 +1381,26 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
-								__u8 encrypt)
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct hci_cb *cb;
+	__u8 encrypt;
+
+	if (conn->state == BT_CONFIG) {
+		if (status)
+			conn->state = BT_CONNECTED;
+
+		hci_connect_cfm(conn, status);
+		hci_conn_drop(conn);
+		return;
+	}
+
+	if (!test_bit(HCI_CONN_ENCRYPT, &conn->flags))
+		encrypt = 0x00;
+	else if (test_bit(HCI_CONN_AES_CCM, &conn->flags))
+		encrypt = 0x02;
+	else
+		encrypt = 0x01;
 
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;

commit 81dafad53c67abe4f09b0b04131fe490e76e5602
Author: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date:   Tue May 12 19:19:26 2020 -0700

    Bluetooth: Add hook for driver to prevent wake from suspend
    
    Let drivers have a hook to disable configuring scanning during suspend.
    Drivers should use the device_may_wakeup function call to determine
    whether hci should be configured for wakeup.
    
    For example, an implementation for btusb may look like the following:
    
      bool btusb_prevent_wake(struct hci_dev *hdev)
      {
            struct btusb_data *data = hci_get_drvdata(hdev);
            return !device_may_wakeup(&data->udev->dev);
      }
    
    Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
    Reviewed-by: Alain Michaud <alainm@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 869ee2b30a4c..5dcf85f186c6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -503,6 +503,7 @@ struct hci_dev {
 	int (*set_diag)(struct hci_dev *hdev, bool enable);
 	int (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 	void (*cmd_timeout)(struct hci_dev *hdev);
+	bool (*prevent_wake)(struct hci_dev *hdev);
 };
 
 #define HCI_PHY_HANDLE(handle)	(handle & 0xff)

commit 0d2c9825e46d45f8a520135c9c791b5c73a165ab
Author: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date:   Tue May 12 19:19:25 2020 -0700

    Bluetooth: Rename BT_SUSPEND_COMPLETE
    
    Renamed BT_SUSPEND_COMPLETE to BT_SUSPEND_CONFIGURE_WAKE since it sets
    up the event filter and whitelist for wake-up.
    
    Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
    Reviewed-by: Alain Michaud <alainm@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0c7f3ad76665..869ee2b30a4c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -110,7 +110,7 @@ enum suspend_tasks {
 enum suspended_state {
 	BT_RUNNING = 0,
 	BT_SUSPEND_DISCONNECT,
-	BT_SUSPEND_COMPLETE,
+	BT_SUSPEND_CONFIGURE_WAKE,
 };
 
 struct hci_conn_hash {

commit d5cc6626b33780699c7a4986f3521361306862fe
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed May 6 09:57:49 2020 +0200

    Bluetooth: Introduce HCI_MGMT_HDEV_OPTIONAL option
    
    When setting HCI_MGMT_HDEV_OPTIONAL it is possible to target a specific
    conntroller or a global interface.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 239ab72f16c6..0c7f3ad76665 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1554,6 +1554,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 #define HCI_MGMT_NO_HDEV	BIT(1)
 #define HCI_MGMT_UNTRUSTED	BIT(2)
 #define HCI_MGMT_UNCONFIGURED	BIT(3)
+#define HCI_MGMT_HDEV_OPTIONAL	BIT(4)
 
 struct hci_mgmt_handler {
 	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,

commit 2eb71a3a68c387274cfc1bc43eac25138add528d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Apr 9 08:05:50 2020 +0200

    Bluetooth: Clear HCI_LL_RPA_RESOLUTION flag on reset
    
    When the controller is being reset or power cycled, then the flag
    HCI_LL_RPA_RESOLUTION which indicates if controller based address
    resolution is active needs to be also reset.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2f3275f1d1c4..239ab72f16c6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -645,6 +645,7 @@ extern struct mutex hci_cb_list_lock;
 	do {							\
 		hci_dev_clear_flag(hdev, HCI_LE_SCAN);		\
 		hci_dev_clear_flag(hdev, HCI_LE_ADV);		\
+		hci_dev_clear_flag(hdev, HCI_LL_RPA_RESOLUTION);\
 		hci_dev_clear_flag(hdev, HCI_PERIODIC_INQ);	\
 	} while (0)
 

commit a479036041d6a1bcf98f72b16a425e8d45e20ae9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Apr 3 21:44:04 2020 +0200

    Bluetooth: Add support for Read Local Simple Pairing Options
    
    With the Read Local Simple Pairing Options command it is possible to
    retrieve the support for max encryption key size supported by the
    controller and also if the controller correctly verifies the ECDH public
    key during pairing.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Alain Michaud <alainm@chromium.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3cb0f82d0c83..2f3275f1d1c4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -312,6 +312,8 @@ struct hci_dev {
 	__u16		conn_info_max_age;
 	__u16		auth_payload_timeout;
 	__u8		min_enc_key_size;
+	__u8		max_enc_key_size;
+	__u8		pairing_opts;
 	__u8		ssp_debug_mode;
 	__u8		hw_error_code;
 	__u32		clock;

commit 145373cb1b1fcdba2059e945d0aa2613af2e84d1
Author: Miao-chen Chou <mcchou@chromium.org>
Date:   Fri Apr 3 21:44:01 2020 +0200

    Bluetooth: Add framework for Microsoft vendor extension
    
    Micrsoft defined a set for HCI vendor extensions. Check the following
    link for details:
    
    https://docs.microsoft.com/en-us/windows-hardware/drivers/bluetooth/microsoft-defined-bluetooth-hci-commands-and-events
    
    This provides the basic framework to enable the extension and read its
    supported features. Drivers still have to declare support for this
    extension before it can be utilized by the host stack.
    
    Signed-off-by: Miao-chen Chou <mcchou@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d4e28773d378..3cb0f82d0c83 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -484,6 +484,11 @@ struct hci_dev {
 	struct led_trigger	*power_led;
 #endif
 
+#if IS_ENABLED(CONFIG_BT_MSFTEXT)
+	__u16			msft_opcode;
+	void			*msft_data;
+#endif
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
@@ -1116,6 +1121,14 @@ int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
 int hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);
 __printf(2, 3) void hci_set_hw_info(struct hci_dev *hdev, const char *fmt, ...);
 __printf(2, 3) void hci_set_fw_info(struct hci_dev *hdev, const char *fmt, ...);
+
+static inline void hci_set_msft_opcode(struct hci_dev *hdev, __u16 opcode)
+{
+#if IS_ENABLED(CONFIG_BT_MSFTEXT)
+	hdev->msft_opcode = opcode;
+#endif
+}
+
 int hci_dev_open(__u16 dev);
 int hci_dev_close(__u16 dev);
 int hci_dev_do_close(struct hci_dev *hdev);

commit 4867bd007d25a8dfd4ffc558534f7aec8b361789
Author: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date:   Wed Mar 11 08:54:03 2020 -0700

    Bluetooth: Pause discovery and advertising during suspend
    
    To prevent spurious wake ups, we disable any discovery or advertising
    when we enter suspend and restore it when we exit suspend. While paused,
    we disable any management requests to modify discovery or advertising.
    
    Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2d58485d0335..d4e28773d378 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -91,6 +91,12 @@ struct discovery_state {
 #define SUSPEND_NOTIFIER_TIMEOUT	msecs_to_jiffies(2000) /* 2 seconds */
 
 enum suspend_tasks {
+	SUSPEND_PAUSE_DISCOVERY,
+	SUSPEND_UNPAUSE_DISCOVERY,
+
+	SUSPEND_PAUSE_ADVERTISING,
+	SUSPEND_UNPAUSE_ADVERTISING,
+
 	SUSPEND_SCAN_DISABLE,
 	SUSPEND_SCAN_ENABLE,
 	SUSPEND_DISCONNECTING,
@@ -410,6 +416,11 @@ struct hci_dev {
 
 	struct discovery_state	discovery;
 
+	int			discovery_old_state;
+	bool			discovery_paused;
+	int			advertising_old_state;
+	bool			advertising_paused;
+
 	struct notifier_block	suspend_notifier;
 	struct work_struct	suspend_prepare;
 	enum suspended_state	suspend_state_next;

commit dd522a7429b07e4441871ae75ebbfcf53635bdd4
Author: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date:   Wed Mar 11 08:54:02 2020 -0700

    Bluetooth: Handle LE devices during suspend
    
    To handle LE devices, we must first disable passive scanning and
    disconnect all connected devices. Once that is complete, we update the
    whitelist and re-enable scanning
    
    Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1a4d732bdce6..2d58485d0335 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -607,6 +607,7 @@ struct hci_conn_params {
 
 	struct hci_conn *conn;
 	bool explicit_connect;
+	bool wakeable;
 };
 
 extern struct list_head hci_dev_list;

commit 4f40afc6c76451daff7d0dcfc8a3d113ccf65bfc
Author: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date:   Wed Mar 11 08:54:01 2020 -0700

    Bluetooth: Handle BR/EDR devices during suspend
    
    To handle BR/EDR devices, we first disable page scan and disconnect all
    connected devices. Once that is complete, we add event filters (for
    devices that can wake the system) and re-enable page scan.
    
    Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d6f694b436bf..1a4d732bdce6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -91,6 +91,10 @@ struct discovery_state {
 #define SUSPEND_NOTIFIER_TIMEOUT	msecs_to_jiffies(2000) /* 2 seconds */
 
 enum suspend_tasks {
+	SUSPEND_SCAN_DISABLE,
+	SUSPEND_SCAN_ENABLE,
+	SUSPEND_DISCONNECTING,
+
 	SUSPEND_POWERING_DOWN,
 
 	SUSPEND_PREPARE_NOTIFIER,
@@ -99,7 +103,8 @@ enum suspend_tasks {
 
 enum suspended_state {
 	BT_RUNNING = 0,
-	BT_SUSPENDED,
+	BT_SUSPEND_DISCONNECT,
+	BT_SUSPEND_COMPLETE,
 };
 
 struct hci_conn_hash {
@@ -409,6 +414,8 @@ struct hci_dev {
 	struct work_struct	suspend_prepare;
 	enum suspended_state	suspend_state_next;
 	enum suspended_state	suspend_state;
+	bool			scanning_paused;
+	bool			suspended;
 
 	wait_queue_head_t	suspend_wait_q;
 	DECLARE_BITMAP(suspend_tasks, __SUSPEND_NUM_TASKS);
@@ -418,6 +425,7 @@ struct hci_dev {
 	struct list_head	mgmt_pending;
 	struct list_head	blacklist;
 	struct list_head	whitelist;
+	struct list_head	wakeable;
 	struct list_head	uuids;
 	struct list_head	link_keys;
 	struct list_head	long_term_keys;

commit 9952d90ea2885d7cbf80cd233f694f09a9c0eaec
Author: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date:   Wed Mar 11 08:54:00 2020 -0700

    Bluetooth: Handle PM_SUSPEND_PREPARE and PM_POST_SUSPEND
    
    Register for PM_SUSPEND_PREPARE and PM_POST_SUSPEND to make sure the
    Bluetooth controller is prepared correctly for suspend/resume. Implement
    the registration, scheduling and task handling portions only in this
    patch.
    
    Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c498ac113930..d6f694b436bf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -88,6 +88,20 @@ struct discovery_state {
 	unsigned long		scan_duration;
 };
 
+#define SUSPEND_NOTIFIER_TIMEOUT	msecs_to_jiffies(2000) /* 2 seconds */
+
+enum suspend_tasks {
+	SUSPEND_POWERING_DOWN,
+
+	SUSPEND_PREPARE_NOTIFIER,
+	__SUSPEND_NUM_TASKS
+};
+
+enum suspended_state {
+	BT_RUNNING = 0,
+	BT_SUSPENDED,
+};
+
 struct hci_conn_hash {
 	struct list_head list;
 	unsigned int     acl_num;
@@ -390,6 +404,15 @@ struct hci_dev {
 	void			*smp_bredr_data;
 
 	struct discovery_state	discovery;
+
+	struct notifier_block	suspend_notifier;
+	struct work_struct	suspend_prepare;
+	enum suspended_state	suspend_state_next;
+	enum suspended_state	suspend_state;
+
+	wait_queue_head_t	suspend_wait_q;
+	DECLARE_BITMAP(suspend_tasks, __SUSPEND_NUM_TASKS);
+
 	struct hci_conn_hash	conn_hash;
 
 	struct list_head	mgmt_pending;

commit 00bce3fb0642b38fa2e5db3217526c3e0d5952ca
Author: Alain Michaud <alainm@chromium.org>
Date:   Thu Mar 5 16:14:59 2020 +0000

    Bluetooth: Enable erroneous data reporting if WBS is supported
    
    This change introduces a wide band speech setting which allows higher
    level clients to query the local controller support for wide band speech
    as well as set the setting state when the radio is powered off.
    Internally, this setting controls if erroneous data reporting is enabled
    on the controller.
    
    Signed-off-by: Alain Michaud <alainm@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dcc0dc6e2624..c498ac113930 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -260,6 +260,7 @@ struct hci_dev {
 	__u8		stored_num_keys;
 	__u8		io_capability;
 	__s8		inq_tx_power;
+	__u8		err_data_reporting;
 	__u16		page_scan_interval;
 	__u16		page_scan_window;
 	__u8		page_scan_type;

commit eab2404ba798a8efda2a970f44071c3406d94e57
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Fri Feb 14 10:08:57 2020 -0800

    Bluetooth: Add BT_PHY socket option
    
    This adds BT_PHY socket option (read-only) which can be used to read
    the PHYs in use by the underline connection.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 89ecf0a80aa1..dcc0dc6e2624 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1477,6 +1477,8 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 struct sk_buff *hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			     const void *param, u32 timeout);
 
+u32 hci_conn_get_phy(struct hci_conn *conn);
+
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_channel(unsigned short channel, struct sk_buff *skb,

commit 600a87490ff9823d065fc15e86c709e707033ecc
Author: Alain Michaud <alainm@chromium.org>
Date:   Tue Jan 7 00:43:17 2020 +0000

    Bluetooth: Implementation of MGMT_OP_SET_BLOCKED_KEYS.
    
    MGMT command is added to receive the list of blocked keys from
    user-space.
    
    The list is used to:
    1) Block keys from being distributed by the device during
       the ke distribution phase of SMP.
    2) Filter out any keys that were previously saved so
       they are no longer used.
    
    Signed-off-by: Alain Michaud <alainm@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index faebe3859931..89ecf0a80aa1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -118,6 +118,13 @@ struct bt_uuid {
 	u8 svc_hint;
 };
 
+struct blocked_key {
+	struct list_head list;
+	struct rcu_head rcu;
+	u8 type;
+	u8 val[16];
+};
+
 struct smp_csrk {
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
@@ -397,6 +404,7 @@ struct hci_dev {
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
 	struct list_head	pend_le_reports;
+	struct list_head	blocked_keys;
 
 	struct hci_dev_stats	stat;
 
@@ -1123,6 +1131,8 @@ struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 struct smp_irk *hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 addr_type, u8 val[16], bdaddr_t *rpa);
 void hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type);
+bool hci_is_blocked_key(struct hci_dev *hdev, u8 type, u8 val[16]);
+void hci_blocked_keys_clear(struct hci_dev *hdev);
 void hci_smp_irks_clear(struct hci_dev *hdev);
 
 bool hci_bdaddr_is_paired(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);

commit 1efd927d660e6ab02a9cd32fbbe3c7dc47980132
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Thu Jan 2 15:00:55 2020 -0800

    Bluetooth: Add support for LE PHY Update Complete event
    
    This handles LE PHY Update Complete event and store both tx_phy and
    rx_phy into hci_conn.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b689aceb636b..faebe3859931 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -493,6 +493,8 @@ struct hci_conn {
 	__u16		le_supv_timeout;
 	__u8		le_adv_data[HCI_MAX_AD_LENGTH];
 	__u8		le_adv_data_len;
+	__u8		le_tx_phy;
+	__u8		le_rx_phy;
 	__s8		rssi;
 	__s8		tx_power;
 	__s8		max_tx_power;

commit ad4a6795e0cfd7f2954ff004e83f00e0aa097f4c
Author: Spoorthi Ravishankar Koppad <spoorthix.k@intel.com>
Date:   Mon Jul 15 17:05:22 2019 +0530

    Bluetooth: Add support for utilizing Fast Advertising Interval
    
    Changes made to add support for fast advertising interval
    as per core 4.1 specification, section 9.3.11.2.
    
    A peripheral device entering any of the following GAP modes and
    sending either non-connectable advertising events or scannable
    undirected advertising events should use adv_fast_interval2
    (100ms - 150ms) for adv_fast_period(30s).
    
             - Non-Discoverable Mode
             - Non-Connectable Mode
             - Limited Discoverable Mode
             - General Discoverable Mode
    
    Signed-off-by: Spoorthi Ravishankar Koppad <spoorthix.k@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ffc95b382eb5..b689aceb636b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1517,6 +1517,8 @@ void hci_mgmt_chan_unregister(struct hci_mgmt_chan *c);
 #define DISCOV_INTERLEAVED_INQUIRY_LEN	0x04
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 #define DISCOV_LE_RESTART_DELAY		msecs_to_jiffies(200)	/* msec */
+#define DISCOV_LE_FAST_ADV_INT_MIN     100     /* msec */
+#define DISCOV_LE_FAST_ADV_INT_MAX     150     /* msec */
 
 void mgmt_fill_version_info(void *ver);
 int mgmt_new_settings(struct hci_dev *hdev);

commit 58a96fc35375ab87db7c5b69336f5befde1b548f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 16 20:34:41 2019 +0200

    Bluetooth: Add debug setting for changing minimum encryption key size
    
    For testing and qualification purposes it is useful to allow changing
    the minimum encryption key size value that the host stack is going to
    enforce. This adds a new debugfs setting min_encrypt_key_size to achieve
    this functionality.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ded574b32c20..ffc95b382eb5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -278,6 +278,7 @@ struct hci_dev {
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;
 	__u16		auth_payload_timeout;
+	__u8		min_enc_key_size;
 	__u8		ssp_debug_mode;
 	__u8		hw_error_code;
 	__u32		clock;

commit 302975cba1a4244d84e645773c82edbcfae1875f
Author: Spoorthi Ravishankar Koppad <spoorthix.k@intel.com>
Date:   Fri Jun 21 14:51:56 2019 +0530

    Bluetooth: Add support for LE ping feature
    
    Changes made to add HCI Write Authenticated Payload timeout
    command for LE Ping feature.
    
    As per the Core Specification 5.0 Volume 2 Part E Section 7.3.94,
    the following code changes implements
    HCI Write Authenticated Payload timeout command for LE Ping feature.
    
    Signed-off-by: Spoorthi Ravishankar Koppad <spoorthix.k@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 05b1b96f4d9e..ded574b32c20 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -199,6 +199,8 @@ struct adv_info {
 /* Default min/max age of connection information (1s/3s) */
 #define DEFAULT_CONN_INFO_MIN_AGE	1000
 #define DEFAULT_CONN_INFO_MAX_AGE	3000
+/* Default authenticated payload timeout 30s */
+#define DEFAULT_AUTH_PAYLOAD_TIMEOUT   0x0bb8
 
 struct amp_assoc {
 	__u16	len;
@@ -275,6 +277,7 @@ struct hci_dev {
 	__u16		discov_interleaved_timeout;
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;
+	__u16		auth_payload_timeout;
 	__u8		ssp_debug_mode;
 	__u8		hw_error_code;
 	__u32		clock;
@@ -481,6 +484,7 @@ struct hci_conn {
 	__u16		disc_timeout;
 	__u16		conn_timeout;
 	__u16		setting;
+	__u16		auth_payload_timeout;
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
 	__u16		le_conn_interval;

commit d5bb334a8e171b262e48f378bd2096c0ea458265
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 24 22:19:17 2019 +0200

    Bluetooth: Align minimum encryption key size for LE and BR/EDR connections
    
    The minimum encryption key size for LE connections is 56 bits and to
    align LE with BR/EDR, enforce 56 bits of minimum encryption key size for
    BR/EDR connections as well.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 094e61e07030..05b1b96f4d9e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -190,6 +190,9 @@ struct adv_info {
 
 #define HCI_MAX_SHORT_NAME_LENGTH	10
 
+/* Min encryption key size to match with SMP */
+#define HCI_MIN_ENC_KEY_SIZE		7
+
 /* Default LE RPA expiry time, 15 minutes */
 #define HCI_DEFAULT_RPA_TIMEOUT		(15 * 60)
 

commit e2bef3847e3d0d57dcf316de50c4b1a5a91816b7
Author: Rajat Jain <rajatja@google.com>
Date:   Thu Jan 24 15:28:13 2019 -0800

    Bluetooth: Allow driver specific cmd timeout handling
    
    Add a hook to allow the BT driver to do device or command specific
    handling in case of timeouts. This is to be used by Intel driver to
    reset the device after certain number of timeouts.
    
    Signed-off-by: Rajat Jain <rajatja@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e5ea633ea368..094e61e07030 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -437,6 +437,7 @@ struct hci_dev {
 	int (*post_init)(struct hci_dev *hdev);
 	int (*set_diag)(struct hci_dev *hdev, bool enable);
 	int (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);
+	void (*cmd_timeout)(struct hci_dev *hdev);
 };
 
 #define HCI_PHY_HANDLE(handle)	(handle & 0xff)

commit 30d65e0804d58a03d1a8ea4e12c6fc07ed08218b
Author: Matias Karhumaa <matias.karhumaa@gmail.com>
Date:   Fri Sep 28 21:54:30 2018 +0300

    Bluetooth: Fix debugfs NULL pointer dereference
    
    Fix crash caused by NULL pointer dereference when debugfs functions
    le_max_key_read, le_max_key_size_write, le_min_key_size_read or
    le_min_key_size_write and Bluetooth adapter was powered off.
    
    Fix is to move max_key_size and min_key_size from smp_dev to hci_dev.
    At the same time they were renamed to le_max_key_size and
    le_min_key_size.
    
    BUG: unable to handle kernel NULL pointer dereference at 00000000000002e8
    PGD 0 P4D 0
    Oops: 0000 [#24] SMP PTI
    CPU: 2 PID: 6255 Comm: cat Tainted: G      D    OE     4.18.9-200.fc28.x86_64 #1
    Hardware name: LENOVO 4286CTO/4286CTO, BIOS 8DET76WW (1.46 ) 06/21/2018
    RIP: 0010:le_max_key_size_read+0x45/0xb0 [bluetooth]
    Code: 00 00 00 48 83 ec 10 65 48 8b 04 25 28 00 00 00 48 89 44 24 08 31 c0 48 8b 87 c8 00 00 00 48 8d 7c 24 04 48 8b 80 48 0a 00 00 <48> 8b 80 e8 02 00 00 0f b6 48 52 e8 fb b6 b3 ed be 04 00 00 00 48
    RSP: 0018:ffffab23c3ff3df0 EFLAGS: 00010246
    RAX: 0000000000000000 RBX: 00007f0b4ca2e000 RCX: ffffab23c3ff3f08
    RDX: ffffffffc0ddb033 RSI: 0000000000000004 RDI: ffffab23c3ff3df4
    RBP: 0000000000020000 R08: 0000000000000000 R09: 0000000000000000
    R10: ffffab23c3ff3ed8 R11: 0000000000000000 R12: ffffab23c3ff3f08
    R13: 00007f0b4ca2e000 R14: 0000000000020000 R15: ffffab23c3ff3f08
    FS:  00007f0b4ca0f540(0000) GS:ffff91bd5e280000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00000000000002e8 CR3: 00000000629fa006 CR4: 00000000000606e0
    Call Trace:
     full_proxy_read+0x53/0x80
     __vfs_read+0x36/0x180
     vfs_read+0x8a/0x140
     ksys_read+0x4f/0xb0
     do_syscall_64+0x5b/0x160
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    Signed-off-by: Matias Karhumaa <matias.karhumaa@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9b0f821b2d3a..e5ea633ea368 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -267,6 +267,8 @@ struct hci_dev {
 	__u16		le_max_tx_time;
 	__u16		le_max_rx_len;
 	__u16		le_max_rx_time;
+	__u8		le_max_key_size;
+	__u8		le_min_key_size;
 	__u16		discov_interleaved_timeout;
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;

commit b950aa88638c52a013504f025e0b8f99bf2dc26e
Author: Ankit Navik <ankit.p.navik@intel.com>
Date:   Fri Aug 17 07:29:19 2018 +0530

    Bluetooth: Add definitions and track LE resolve list modification
    
    Add the definitions for adding entries to the LE resolve list and
    removing entries from the LE resolve list. When the LE resolve list
    gets changed via HCI commands make sure that the internal storage of
    the resolve list entries gets updated.
    
    Signed-off-by: Ankit Navik <ankit.p.navik@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0db1b9b428b7..9b0f821b2d3a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -103,6 +103,14 @@ struct bdaddr_list {
 	u8 bdaddr_type;
 };
 
+struct bdaddr_list_with_irk {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 bdaddr_type;
+	u8 peer_irk[16];
+	u8 local_irk[16];
+};
+
 struct bt_uuid {
 	struct list_head list;
 	u8 uuid[16];
@@ -1058,8 +1066,15 @@ int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *list,
 					   bdaddr_t *bdaddr, u8 type);
+struct bdaddr_list_with_irk *hci_bdaddr_list_lookup_with_irk(
+				    struct list_head *list, bdaddr_t *bdaddr,
+				    u8 type);
 int hci_bdaddr_list_add(struct list_head *list, bdaddr_t *bdaddr, u8 type);
+int hci_bdaddr_list_add_with_irk(struct list_head *list, bdaddr_t *bdaddr,
+					u8 type, u8 *peer_irk, u8 *local_irk);
 int hci_bdaddr_list_del(struct list_head *list, bdaddr_t *bdaddr, u8 type);
+int hci_bdaddr_list_del_with_irk(struct list_head *list, bdaddr_t *bdaddr,
+								u8 type);
 void hci_bdaddr_list_clear(struct list_head *list);
 
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,

commit a73c046a2869048430c332a871a5b169f192c6c3
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:45 2018 +0530

    Bluetooth: Implement Set ADV set random address
    
    This basically sets the random address for the adv instance
    Random address can be set only if the instance is created which
    is done in Set ext adv param.
    
    Random address and rpa expire timer and flags have been added
    to adv instance which will be used when the respective
    instance is scheduled.
    
    This introduces a hci_get_random_address() which returns the
    own address type and random address (rpa or nrpa) based
    on the instance flags and hdev flags. New function is required
    since own address type should be known before setting adv params
    but address can be set only after setting params.
    
    < HCI Command: LE Set Advertising Set Random Address (0x08|0x0035) plen 7
            Advertising handle: 0x00
            Advertising random address: 3C:8E:56:9B:77:84 (OUI 3C-8E-56)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Advertising Set Random Address (0x08|0x0035) ncmd 1
            Status: Success (0x00)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ad3518303a0c..0db1b9b428b7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -172,6 +172,9 @@ struct adv_info {
 	__u16	scan_rsp_len;
 	__u8	scan_rsp_data[HCI_MAX_AD_LENGTH];
 	__s8	tx_power;
+	bdaddr_t	random_addr;
+	bool 		rpa_expired;
+	struct delayed_work	rpa_expired_cb;
 };
 
 #define HCI_MAX_ADV_INSTANCES		5
@@ -1113,6 +1116,7 @@ int hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,
 			 u16 scan_rsp_len, u8 *scan_rsp_data,
 			 u16 timeout, u16 duration);
 int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
+void hci_adv_instances_set_rpa_expired(struct hci_dev *hdev, bool rpa_expired);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 

commit de181e887ac27dadda127c7d4c3e89c6da8fb6d2
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:41 2018 +0530

    Bluetooth: Impmlement extended adv enable
    
    This patch basically replaces legacy adv with extended adv
    based on the controller support. Currently there is no
    design change. ie only one adv set will be enabled at a time.
    
    This also adds tx_power in instance and store whatever returns
    from Set_ext_parameter, use the same in adv data as well.
    For instance 0 tx_power is stored in hdev only.
    
    < HCI Command: LE Set Extended Advertising Parameters (0x08|0x0036) plen 25
            Handle: 0x00
            Properties: 0x0010
              Use legacy advertising PDUs: ADV_NONCONN_IND
            Min advertising interval: 1280.000 msec (0x0800)
            Max advertising interval: 1280.000 msec (0x0800)
            Channel map: 37, 38, 39 (0x07)
            Own address type: Random (0x01)
            Peer address type: Public (0x00)
            Peer address: 00:00:00:00:00:00 (OUI 00-00-00)
            Filter policy: Allow Scan Request from Any, Allow Connect Request from Any (0x00)
            TX power: 127 dbm (0x7f)
            Primary PHY: LE 1M (0x01)
            Secondary max skip: 0x00
            Secondary PHY: LE 1M (0x01)
            SID: 0x00
            Scan request notifications: Disabled (0x00)
    > HCI Event: Command Complete (0x0e) plen 5
          LE Set Extended Advertising Parameters (0x08|0x0036) ncmd 1
            Status: Success (0x00)
            TX power (selected): 7 dbm (0x07)
    < HCI Command: LE Set Extended Advertising Enable (0x08|0x0039) plen 6
            Extended advertising: Enabled (0x01)
            Number of sets: 1 (0x01)
            Entry 0
              Handle: 0x00
              Duration: 0 ms (0x00)
              Max ext adv events: 0
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Extended Advertising Enable (0x08|0x0039) ncmd 2
            Status: Success (0x00)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2aad4a863176..ad3518303a0c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -171,6 +171,7 @@ struct adv_info {
 	__u8	adv_data[HCI_MAX_AD_LENGTH];
 	__u16	scan_rsp_len;
 	__u8	scan_rsp_data[HCI_MAX_AD_LENGTH];
+	__s8	tx_power;
 };
 
 #define HCI_MAX_ADV_INSTANCES		5

commit 6b49bcb4bce2ed0f0aefe8e304a8b9cbaeeaa3f0
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:40 2018 +0530

    Bluetooth: Read no of adv sets during init
    
    This patch reads the number of advertising sets in the controller
    during init and save it in hdev.
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 113c9bb609c7..2aad4a863176 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -222,6 +222,7 @@ struct hci_dev {
 	__u8		le_features[8];
 	__u8		le_white_list_size;
 	__u8		le_resolv_list_size;
+	__u8		le_num_of_adv_sets;
 	__u8		le_states[8];
 	__u8		commands[64];
 	__u8		hci_ver;
@@ -1180,6 +1181,9 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 /* Use ext create connection if command is supported */
 #define use_ext_conn(dev) ((dev)->commands[37] & 0x80)
 
+/* Extended advertising support */
+#define ext_adv_capable(dev) (((dev)->le_features[1] & HCI_LE_EXT_ADV))
+
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01
 

commit 45bdd86eafc7d29e0b4b6681bec9c6ab8eddc6bf
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:37 2018 +0530

    Bluetooth: Set Scan PHYs based on selected PHYs by user
    
    Use the PHYs selected in Set Phy Configuration management command
    while scanning.
    
    < HCI Command: LE Set Extended Scan Parameters (0x08|0x0041) plen 13
            Own address type: Random (0x01)
            Filter policy: Accept all advertisement (0x00)
            PHYs: 0x05
            Entry 0: LE 1M
              Type: Active (0x01)
              Interval: 11.250 msec (0x0012)
              Window: 11.250 msec (0x0012)
            Entry 1: LE Coded
              Type: Active (0x01)
              Interval: 11.250 msec (0x0012)
              Window: 11.250 msec (0x0012)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Extended Scan Parameters (0x08|0x0041) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Extended Scan Enable (0x08|0x0042) plen 6
            Extended scan: Enabled (0x01)
            Filter duplicates: Enabled (0x01)
            Duration: 0 msec (0x0000)
            Period: 0.00 sec (0x0000)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Extended Scan Enable (0x08|0x0042) ncmd 2
            Status: Success (0x00)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ab5d494a545a..113c9bb609c7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1165,6 +1165,15 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define bredr_sc_enabled(dev)  (lmp_sc_capable(dev) && \
 				hci_dev_test_flag(dev, HCI_SC_ENABLED))
 
+#define scan_1m(dev) (((dev)->le_tx_def_phys & HCI_LE_SET_PHY_1M) || \
+		      ((dev)->le_rx_def_phys & HCI_LE_SET_PHY_1M))
+
+#define scan_2m(dev) (((dev)->le_tx_def_phys & HCI_LE_SET_PHY_2M) || \
+		      ((dev)->le_rx_def_phys & HCI_LE_SET_PHY_2M))
+
+#define scan_coded(dev) (((dev)->le_tx_def_phys & HCI_LE_SET_PHY_CODED) || \
+			 ((dev)->le_rx_def_phys & HCI_LE_SET_PHY_CODED))
+
 /* Use ext scanning if set ext scan param and ext scan enable is supported */
 #define use_ext_scan(dev) (((dev)->commands[37] & 0x20) && \
 			   ((dev)->commands[37] & 0x40))

commit b7c23df85b6a1c3bcfb591cfa938d341fc3a556e
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:36 2018 +0530

    Bluetooth: Implement PHY changed event
    
    This defines and implement phy changed event and send it to user
    whenever selected PHYs changes using SET_PHY_CONFIGURATION.
    
    This will be also trigerred when BREDR pkt_type is changed using
    the legacy ioctl HCISETPTYPE.
    
    @ MGMT Command: Set PHY Configuration (0x0045) plen 4
                    Selected PHYs: 0x7fff
                      BR 1M 1SLOT
                      BR 1M 3SLOT
                      BR 1M 5SLOT
                      EDR 2M 1SLOT
                      EDR 2M 3SLOT
                      EDR 2M 5SLOT
                      EDR 3M 1SLOT
                      EDR 3M 3SLOT
                      EDR 3M 5SLOT
                      LE 1M TX
                      LE 1M RX
                      LE 2M TX
                      LE 2M RX
                      LE CODED TX
                      LE CODED RX
    < HCI Command: LE Set Default PHY (0x08|0x0031) plen 3
                    All PHYs preference: 0x00
                    TX PHYs preference: 0x07
                      LE 1M
                      LE 2M
                      LE Coded
                    RX PHYs preference: 0x07
                      LE 1M
                      LE 2M
                      LE Coded
    > HCI Event: Command Complete (0x0e) plen 4
              LE Set Default PHY (0x08|0x0031) ncmd 1
                    Status: Success (0x00)
    @ MGMT Event: Command Complete (0x0001) plen 3
              Set PHY Configuration (0x0045) plen 0
                    Status: Success (0x00)
    @ MGMT Event: PHY Configuration Changed (0x0026) plen 4
                    Selected PHYs: 0x7fff
                      BR 1M 1SLOT
                      BR 1M 3SLOT
                      BR 1M 5SLOT
                      EDR 2M 1SLOT
                      EDR 2M 3SLOT
                      EDR 2M 5SLOT
                      EDR 3M 1SLOT
                      EDR 3M 3SLOT
                      EDR 3M 5SLOT
                      LE 1M TX
                      LE 1M RX
                      LE 2M TX
                      LE 2M RX
                      LE CODED TX
                      LE CODED RX
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a64d13f91d09..ab5d494a545a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1544,6 +1544,7 @@ void mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev,
 			    u8 instance);
 void mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,
 			      u8 instance);
+int mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip);
 
 u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
 		      u16 to_multiplier);

commit 5075b972f20ddad5bb19542ea4f5794d06673375
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:33 2018 +0530

    Bluetooth: Add defines for BREDR pkt_type and LE PHYs
    
    This also add macros for checking LMP support for different
    pkt_types
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 71f79df9ee05..a64d13f91d09 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1141,6 +1141,10 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_inq_tx_pwr_capable(dev) ((dev)->features[0][7] & LMP_INQ_TX_PWR)
 #define lmp_ext_feat_capable(dev)  ((dev)->features[0][7] & LMP_EXTFEATURES)
 #define lmp_transp_capable(dev)    ((dev)->features[0][2] & LMP_TRANSPARENT)
+#define lmp_edr_2m_capable(dev)    ((dev)->features[0][3] & LMP_EDR_2M)
+#define lmp_edr_3m_capable(dev)    ((dev)->features[0][3] & LMP_EDR_3M)
+#define lmp_edr_3slot_capable(dev) ((dev)->features[0][4] & LMP_EDR_3SLOT)
+#define lmp_edr_5slot_capable(dev) ((dev)->features[0][5] & LMP_EDR_5SLOT)
 
 /* ----- Extended LMP capabilities ----- */
 #define lmp_csb_master_capable(dev) ((dev)->features[2][0] & LMP_CSB_MASTER)

commit 6decb5b45e70d6ffff6488cc8e8bad6b9ac7f99b
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:32 2018 +0530

    Bluetooth: Define PHY flags in hdev and set 1M as default
    
    1M is mandatory to be supported by LE controllers and the same
    would be set in power on. This patch defines hdev flags for
    LE PHYs and set 1M to default.
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a74453571264..71f79df9ee05 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -315,6 +315,9 @@ struct hci_dev {
 	unsigned long	sco_last_tx;
 	unsigned long	le_last_tx;
 
+	__u8		le_tx_def_phys;
+	__u8		le_rx_def_phys;
+
 	struct workqueue_struct	*workqueue;
 	struct workqueue_struct	*req_workqueue;
 

commit 4d94f95d30c8fbfe86068e9abed110974d697cf5
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Fri Jul 6 22:50:32 2018 +0200

    Bluetooth: Use extended LE Connection if supported
    
    This implements extended LE craete connection and enhanced
    LE conn complete event if the controller supports.
    
    For now it is as good as legacy LE connection and event as
    no new features in the extended connection is handled.
    
    < HCI Command: LE Extended Create Connection (0x08|0x0043) plen 26
            Filter policy: White list is not used (0x00)
            Own address type: Public (0x00)
            Peer address type: Random (0x01)
            Peer address: DB:7E:2E:1D:85:E8 (Static)
            Initiating PHYs: 0x01
            Entry 0: LE 1M
              Scan interval: 60.000 msec (0x0060)
              Scan window: 60.000 msec (0x0060)
              Min connection interval: 50.00 msec (0x0028)
              Max connection interval: 70.00 msec (0x0038)
              Connection latency: 0 (0x0000)
              Supervision timeout: 420 msec (0x002a)
              Min connection length: 0.000 msec (0x0000)
              Max connection length: 0.000 msec (0x0000)
    > HCI Event: Command Status (0x0f) plen 4
          LE Extended Create Connection (0x08|0x0043) ncmd 2
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 31
          LE Enhanced Connection Complete (0x0a)
            Status: Success (0x00)
            Handle: 3585
            Role: Master (0x00)
            Peer address type: Random (0x01)
            Peer address: DB:7E:2E:1D:85:E8 (Static)
            Local resolvable private address: 00:00:00:00:00:00 (Non-Resolvable)
            Peer resolvable private address: 00:00:00:00:00:00 (Non-Resolvable)
            Connection interval: 67.50 msec (0x0036)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Master clock accuracy: 0x00
    @ MGMT Event: Device Connected (0x000b) plen 40
            LE Address: DB:7E:2E:1D:85:E8 (Static)
            Flags: 0x00000000
            Data length: 27
            Name (complete): Designer Mouse
            Appearance: Mouse (0x03c2)
            Flags: 0x05
              LE Limited Discoverable Mode
              BR/EDR Not Supported
            16-bit Service UUIDs (complete): 1 entry
              Human Interface Device (0x1812)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cc0bde74dd45..a74453571264 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1161,6 +1161,8 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 /* Use ext scanning if set ext scan param and ext scan enable is supported */
 #define use_ext_scan(dev) (((dev)->commands[37] & 0x20) && \
 			   ((dev)->commands[37] & 0x40))
+/* Use ext create connection if command is supported */
+#define use_ext_conn(dev) ((dev)->commands[37] & 0x80)
 
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01

commit a2344b9e3a8c5c2064306b0d99b0e9a6c4813c08
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Fri Jul 6 17:05:28 2018 +0530

    Bluetooth: Use extended scanning if controller supports
    
    This implements Set extended scan param and set extended scan enable
    commands and use it for start LE scan based on controller support.
    
    The new features added in these commands are setting of new PHY for
    scanning and setting of scan duration. Both features are disabled
    for now, meaning only 1M PHY is set and scan duration is set to 0
    which means that scanning will be done untill scan disable is called.
    
    < HCI Command: LE Set Extended Scan Parameters (0x08|0x0041) plen 8
            Own address type: Random (0x01)
            Filter policy: Accept all advertisement (0x00)
            PHYs: 0x01
            Entry 0: LE 1M
              Type: Active (0x01)
              Interval: 11.250 msec (0x0012)
              Window: 11.250 msec (0x0012)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Extended Scan Parameters (0x08|0x0041) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Extended Scan Enable (0x08|0x0042) plen 6
            Extended scan: Enabled (0x01)
            Filter duplicates: Enabled (0x01)
            Duration: 0 msec (0x0000)
            Period: 0.00 sec (0x0000)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Extended Scan Enable (0x08|0x0042) ncmd 2
            Status: Success (0x00)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 409f49bd8338..cc0bde74dd45 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1158,6 +1158,10 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define bredr_sc_enabled(dev)  (lmp_sc_capable(dev) && \
 				hci_dev_test_flag(dev, HCI_SC_ENABLED))
 
+/* Use ext scanning if set ext scan param and ext scan enable is supported */
+#define use_ext_scan(dev) (((dev)->commands[37] & 0x20) && \
+			   ((dev)->commands[37] & 0x40))
+
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01
 

commit cfdb0c2d095ac5d7f09cac1317b7d0a9e8178134
Author: Ankit Navik <ankit.p.navik@intel.com>
Date:   Fri Jun 29 12:12:50 2018 +0530

    Bluetooth: Store Resolv list size
    
    When the controller supports the Read LE Resolv List size feature, the
    maximum list size are read and now stored.
    
    Before patch:
    < HCI Command: LE Read White List... (0x08|0x000f) plen 0  #55 [hci0] 17.979791
    > HCI Event: Command Complete (0x0e) plen 5                #56 [hci0] 17.980629
          LE Read White List Size (0x08|0x000f) ncmd 1
            Status: Success (0x00)
            Size: 25
    < HCI Command: LE Clear White List (0x08|0x0010) plen 0    #57 [hci0] 17.980786
    > HCI Event: Command Complete (0x0e) plen 4                #58 [hci0] 17.981627
          LE Clear White List (0x08|0x0010) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Read Maximum Dat.. (0x08|0x002f) plen 0  #59 [hci0] 17.981786
    > HCI Event: Command Complete (0x0e) plen 12               #60 [hci0] 17.982636
          LE Read Maximum Data Length (0x08|0x002f) ncmd 1
            Status: Success (0x00)
            Max TX octets: 251
            Max TX time: 17040
            Max RX octets: 251
            Max RX time: 17040
    
    After patch:
    < HCI Command: LE Read White List... (0x08|0x000f) plen 0  #55 [hci0] 13.338168
    > HCI Event: Command Complete (0x0e) plen 5                #56 [hci0] 13.338842
          LE Read White List Size (0x08|0x000f) ncmd 1
            Status: Success (0x00)
            Size: 25
    < HCI Command: LE Clear White List (0x08|0x0010) plen 0    #57 [hci0] 13.339029
    > HCI Event: Command Complete (0x0e) plen 4                #58 [hci0] 13.339939
          LE Clear White List (0x08|0x0010) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Read Resolving L.. (0x08|0x002a) plen 0  #59 [hci0] 13.340152
    > HCI Event: Command Complete (0x0e) plen 5                #60 [hci0] 13.340952
          LE Read Resolving List Size (0x08|0x002a) ncmd 1
            Status: Success (0x00)
            Size: 25
    < HCI Command: LE Read Maximum Dat.. (0x08|0x002f) plen 0  #61 [hci0] 13.341180
    > HCI Event: Command Complete (0x0e) plen 12               #62 [hci0] 13.341898
          LE Read Maximum Data Length (0x08|0x002f) ncmd 1
            Status: Success (0x00)
            Max TX octets: 251
            Max TX time: 17040
            Max RX octets: 251
            Max RX time: 17040
    
    Signed-off-by: Ankit Navik <ankit.p.navik@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 893bbbb5d2fa..409f49bd8338 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -221,6 +221,7 @@ struct hci_dev {
 	__u8		features[HCI_MAX_PAGES][8];
 	__u8		le_features[8];
 	__u8		le_white_list_size;
+	__u8		le_resolv_list_size;
 	__u8		le_states[8];
 	__u8		commands[64];
 	__u8		hci_ver;
@@ -367,6 +368,7 @@ struct hci_dev {
 	struct list_head	identity_resolving_keys;
 	struct list_head	remote_oob_data;
 	struct list_head	le_white_list;
+	struct list_head	le_resolv_list;
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
 	struct list_head	pend_le_reports;

commit d6ee6ad774a986d4faaa794a0980e7c50ed359c6
Author: Loic Poulain <loic.poulain@linaro.org>
Date:   Thu Apr 26 13:13:26 2018 +0200

    Bluetooth: Add __hci_cmd_send function
    
    This function allows to send a HCI command without expecting any
    controller event/response in return. This is allowed for vendor-
    specific commands only.
    
    Signed-off-by: Loic Poulain <loic.poulain@linaro.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b619a190ff12..893bbbb5d2fa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1393,6 +1393,8 @@ struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);
 struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,
 				  const void *param, u8 event, u32 timeout);
+int __hci_cmd_send(struct hci_dev *hdev, u16 opcode, u32 plen,
+		   const void *param);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen,
 		 const void *param);

commit 082f2300cfa1a3d9d5221c38c5eba85d4ab98bd8
Author: Szymon Janc <szymon.janc@codecoup.pl>
Date:   Tue Apr 3 13:40:06 2018 +0200

    Bluetooth: Fix connection if directed advertising and privacy is used
    
    Local random address needs to be updated before creating connection if
    RPA from LE Direct Advertising Report was resolved in host. Otherwise
    remote device might ignore connection request due to address mismatch.
    
    This was affecting following qualification test cases:
    GAP/CONN/SCEP/BV-03-C, GAP/CONN/GCEP/BV-05-C, GAP/CONN/DCEP/BV-05-C
    
    Before patch:
    < HCI Command: LE Set Random Address (0x08|0x0005) plen 6          #11350 [hci0] 84680.231216
            Address: 56:BC:E8:24:11:68 (Resolvable)
              Identity type: Random (0x01)
              Identity: F2:F1:06:3D:9C:42 (Static)
    > HCI Event: Command Complete (0x0e) plen 4                        #11351 [hci0] 84680.246022
          LE Set Random Address (0x08|0x0005) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Scan Parameters (0x08|0x000b) plen 7         #11352 [hci0] 84680.246417
            Type: Passive (0x00)
            Interval: 60.000 msec (0x0060)
            Window: 30.000 msec (0x0030)
            Own address type: Random (0x01)
            Filter policy: Accept all advertisement, inc. directed unresolved RPA (0x02)
    > HCI Event: Command Complete (0x0e) plen 4                        #11353 [hci0] 84680.248854
          LE Set Scan Parameters (0x08|0x000b) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2             #11354 [hci0] 84680.249466
            Scanning: Enabled (0x01)
            Filter duplicates: Enabled (0x01)
    > HCI Event: Command Complete (0x0e) plen 4                        #11355 [hci0] 84680.253222
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 18                          #11356 [hci0] 84680.458387
          LE Direct Advertising Report (0x0b)
            Num reports: 1
            Event type: Connectable directed - ADV_DIRECT_IND (0x01)
            Address type: Random (0x01)
            Address: 53:38:DA:46:8C:45 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Direct address type: Random (0x01)
            Direct address: 7C:D6:76:8C:DF:82 (Resolvable)
              Identity type: Random (0x01)
              Identity: F2:F1:06:3D:9C:42 (Static)
            RSSI: -74 dBm (0xb6)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2             #11357 [hci0] 84680.458737
            Scanning: Disabled (0x00)
            Filter duplicates: Disabled (0x00)
    > HCI Event: Command Complete (0x0e) plen 4                        #11358 [hci0] 84680.469982
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Create Connection (0x08|0x000d) plen 25          #11359 [hci0] 84680.470444
            Scan interval: 60.000 msec (0x0060)
            Scan window: 60.000 msec (0x0060)
            Filter policy: White list is not used (0x00)
            Peer address type: Random (0x01)
            Peer address: 53:38:DA:46:8C:45 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Own address type: Random (0x01)
            Min connection interval: 30.00 msec (0x0018)
            Max connection interval: 50.00 msec (0x0028)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Min connection length: 0.000 msec (0x0000)
            Max connection length: 0.000 msec (0x0000)
    > HCI Event: Command Status (0x0f) plen 4                          #11360 [hci0] 84680.474971
          LE Create Connection (0x08|0x000d) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Create Connection Cancel (0x08|0x000e) plen 0    #11361 [hci0] 84682.545385
    > HCI Event: Command Complete (0x0e) plen 4                        #11362 [hci0] 84682.551014
          LE Create Connection Cancel (0x08|0x000e) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 19                          #11363 [hci0] 84682.551074
          LE Connection Complete (0x01)
            Status: Unknown Connection Identifier (0x02)
            Handle: 0
            Role: Master (0x00)
            Peer address type: Public (0x00)
            Peer address: 00:00:00:00:00:00 (OUI 00-00-00)
            Connection interval: 0.00 msec (0x0000)
            Connection latency: 0 (0x0000)
            Supervision timeout: 0 msec (0x0000)
            Master clock accuracy: 0x00
    
    After patch:
    < HCI Command: LE Set Scan Parameters (0x08|0x000b) plen 7    #210 [hci0] 667.152459
            Type: Passive (0x00)
            Interval: 60.000 msec (0x0060)
            Window: 30.000 msec (0x0030)
            Own address type: Random (0x01)
            Filter policy: Accept all advertisement, inc. directed unresolved RPA (0x02)
    > HCI Event: Command Complete (0x0e) plen 4                   #211 [hci0] 667.153613
          LE Set Scan Parameters (0x08|0x000b) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2        #212 [hci0] 667.153704
            Scanning: Enabled (0x01)
            Filter duplicates: Enabled (0x01)
    > HCI Event: Command Complete (0x0e) plen 4                   #213 [hci0] 667.154584
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 18                     #214 [hci0] 667.182619
          LE Direct Advertising Report (0x0b)
            Num reports: 1
            Event type: Connectable directed - ADV_DIRECT_IND (0x01)
            Address type: Random (0x01)
            Address: 50:52:D9:A6:48:A0 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Direct address type: Random (0x01)
            Direct address: 7C:C1:57:A5:B7:A8 (Resolvable)
              Identity type: Random (0x01)
              Identity: F4:28:73:5D:38:B0 (Static)
            RSSI: -70 dBm (0xba)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2       #215 [hci0] 667.182704
            Scanning: Disabled (0x00)
            Filter duplicates: Disabled (0x00)
    > HCI Event: Command Complete (0x0e) plen 4                  #216 [hci0] 667.183599
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Random Address (0x08|0x0005) plen 6    #217 [hci0] 667.183645
            Address: 7C:C1:57:A5:B7:A8 (Resolvable)
              Identity type: Random (0x01)
              Identity: F4:28:73:5D:38:B0 (Static)
    > HCI Event: Command Complete (0x0e) plen 4                  #218 [hci0] 667.184590
          LE Set Random Address (0x08|0x0005) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Create Connection (0x08|0x000d) plen 25    #219 [hci0] 667.184613
            Scan interval: 60.000 msec (0x0060)
            Scan window: 60.000 msec (0x0060)
            Filter policy: White list is not used (0x00)
            Peer address type: Random (0x01)
            Peer address: 50:52:D9:A6:48:A0 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Own address type: Random (0x01)
            Min connection interval: 30.00 msec (0x0018)
            Max connection interval: 50.00 msec (0x0028)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Min connection length: 0.000 msec (0x0000)
            Max connection length: 0.000 msec (0x0000)
    > HCI Event: Command Status (0x0f) plen 4                    #220 [hci0] 667.186558
          LE Create Connection (0x08|0x000d) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 19                    #221 [hci0] 667.485824
          LE Connection Complete (0x01)
            Status: Success (0x00)
            Handle: 0
            Role: Master (0x00)
            Peer address type: Random (0x01)
            Peer address: 50:52:D9:A6:48:A0 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Connection interval: 50.00 msec (0x0028)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Master clock accuracy: 0x07
    @ MGMT Event: Device Connected (0x000b) plen 13          {0x0002} [hci0] 667.485996
            LE Address: 11:22:33:44:55:66 (OUI 11-22-33)
            Flags: 0x00000000
            Data length: 0
    
    Signed-off-by: Szymon Janc <szymon.janc@codecoup.pl>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 95ccc1eef558..b619a190ff12 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -895,7 +895,7 @@ struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 				     u16 conn_timeout);
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u16 conn_timeout,
-				u8 role);
+				u8 role, bdaddr_t *direct_rpa);
 struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 				 u8 sec_level, u8 auth_type);
 struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,

commit b2d091031075ac9a1598e3cc3a29c28f02e64c0d
Author: Ingo Molnar <mingo@kernel.org>
Date:   Sat Feb 4 01:27:20 2017 +0100

    sched/headers: Prepare to use <linux/rcuupdate.h> instead of <linux/rculist.h> in <linux/sched.h>
    
    We don't actually need the full rculist.h header in sched.h anymore,
    we will be able to include the smaller rcupdate.h header instead.
    
    But first update code that relied on the implicit header inclusion.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 90708f68cc02..95ccc1eef558 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -26,6 +26,8 @@
 #define __HCI_CORE_H
 
 #include <linux/leds.h>
+#include <linux/rculist.h>
+
 #include <net/bluetooth/hci.h>
 #include <net/bluetooth/hci_sock.h>
 

commit 2c935bc57221cc2edc787c72ea0e2d30cdcd3d5e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Nov 14 17:29:48 2016 +0100

    locking/atomic, kref: Add kref_read()
    
    Since we need to change the implementation, stop exposing internals.
    
    Provide kref_read() to read the current reference count; typically
    used for debug messages.
    
    Kills two anti-patterns:
    
            atomic_read(&kref->refcount)
            kref->refcount.counter
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 554671c81f4a..90708f68cc02 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -987,7 +987,7 @@ static inline void hci_conn_drop(struct hci_conn *conn)
 static inline void hci_dev_put(struct hci_dev *d)
 {
 	BT_DBG("%s orig refcnt %d", d->name,
-	       atomic_read(&d->dev.kobj.kref.refcount));
+	       kref_read(&d->dev.kobj.kref));
 
 	put_device(&d->dev);
 }
@@ -995,7 +995,7 @@ static inline void hci_dev_put(struct hci_dev *d)
 static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 {
 	BT_DBG("%s orig refcnt %d", d->name,
-	       atomic_read(&d->dev.kobj.kref.refcount));
+	       kref_read(&d->dev.kobj.kref));
 
 	get_device(&d->dev);
 	return d;

commit 39385cb5f3274735b03ed1f8e7ff517b02a0beed
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sat Nov 12 17:03:07 2016 +0200

    Bluetooth: Fix using the correct source address type
    
    The hci_get_route() API is used to look up local HCI devices, however
    so far it has been incapable of dealing with anything else than the
    public address of HCI devices. This completely breaks with LE-only HCI
    devices that do not come with a public address, but use a static
    random address instead.
    
    This patch exteds the hci_get_route() API with a src_type parameter
    that's used for comparing with the right address of each HCI device.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f00bf667ec33..554671c81f4a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1018,7 +1018,7 @@ static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
 }
 
 struct hci_dev *hci_dev_get(int index);
-struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src);
+struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, u8 src_type);
 
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);

commit c4960ecf2b09210930964ef2c05ce2590802ccf4
Author: Michał Narajowski <michal.narajowski@codecoup.pl>
Date:   Sun Sep 18 12:50:03 2016 +0200

    Bluetooth: Add support for appearance in scan rsp
    
    This patch enables prepending appearance value to scan response data.
    It also adds support for setting appearance value through mgmt command.
    If currently advertised instance has apperance flag set it is expired
    immediately.
    
    Signed-off-by: Michał Narajowski <michal.narajowski@codecoup.pl>
    Signed-off-by: Szymon Janc <szymon.janc@codecoup.pl>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a48f71d73dc8..f00bf667ec33 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -211,6 +211,7 @@ struct hci_dev {
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
 	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];
+	__u16		appearance;
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;

commit 38ceaa00d02dceb22c6bdd5268f5a44d5c00e123
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 27 20:23:41 2016 +0200

    Bluetooth: Add support for sending MGMT commands and events to monitor
    
    This adds support for tracing all management commands and events via the
    monitor interface.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9f181b583b96..a48f71d73dc8 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1406,6 +1406,9 @@ void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_channel(unsigned short channel, struct sk_buff *skb,
 			 int flag, struct sock *skip_sk);
 void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
+void hci_send_monitor_ctrl_event(struct hci_dev *hdev, u16 event,
+				 void *data, u16 data_len, ktime_t tstamp,
+				 int flag, struct sock *skip_sk);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);
 

commit 03c979c4717c7fa0c058fafe76ac4d6acdd1fb0d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 27 20:23:39 2016 +0200

    Bluetooth: Introduce helper to pack mgmt version information
    
    The mgmt version information will be also needed for the control
    changell tracing feature. This provides a helper to pack them.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cc349f633570..9f181b583b96 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1451,6 +1451,7 @@ void hci_mgmt_chan_unregister(struct hci_mgmt_chan *c);
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 #define DISCOV_LE_RESTART_DELAY		msecs_to_jiffies(200)	/* msec */
 
+void mgmt_fill_version_info(void *ver);
 int mgmt_new_settings(struct hci_dev *hdev);
 void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);

commit 1aabbbcefe8e62fbffaaa01ca8bdd4cd6ed1625b
Author: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
Date:   Fri Jul 29 13:28:25 2016 +0200

    Bluetooth: add printf format attribute to hci_set_[fh]w_info()
    
    Commit 5177a83827cd ("Bluetooth: Add debugfs fields for hardware and
    firmware info") introduced hci_set_hw_info() and hci_set_fw_info().
    These functions use kvasprintf_const() but are not marked with a
    __printf attribute.  Adding such an attribute helps detecting issues
    related to printf-formatting at build time.
    
    Signed-off-by: Nicolas Iooss <nicolas.iooss_linux@m4x.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b8d43bd9c71b..cc349f633570 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1028,8 +1028,8 @@ int hci_resume_dev(struct hci_dev *hdev);
 int hci_reset_dev(struct hci_dev *hdev);
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
 int hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);
-void hci_set_hw_info(struct hci_dev *hdev, const char *fmt, ...);
-void hci_set_fw_info(struct hci_dev *hdev, const char *fmt, ...);
+__printf(2, 3) void hci_set_hw_info(struct hci_dev *hdev, const char *fmt, ...);
+__printf(2, 3) void hci_set_fw_info(struct hci_dev *hdev, const char *fmt, ...);
 int hci_dev_open(__u16 dev);
 int hci_dev_close(__u16 dev);
 int hci_dev_do_close(struct hci_dev *hdev);

commit 53f863a66904542b03204f2b115d050b04c11ba5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 21 14:12:40 2016 +0200

    Bluetooth: Put led_trigger field behind CONFIG_BT_LEDS
    
    The led_trigger field in hci_dev should be conditional based on if
    CONFIG_BT_LEDS is set or not.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ee7fc47680a1..b8d43bd9c71b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -399,7 +399,9 @@ struct hci_dev {
 	struct delayed_work	rpa_expired;
 	bdaddr_t		rpa;
 
+#if IS_ENABLED(CONFIG_BT_LEDS)
 	struct led_trigger	*power_led;
+#endif
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);

commit 5177a83827cd0b8cf6ce0391b00dd4417352d2f1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jul 17 19:55:16 2016 +0200

    Bluetooth: Add debugfs fields for hardware and firmware info
    
    Some Bluetooth controllers allow for reading hardware and firmware
    related vendor specific infos. If they are available, then they can be
    exposed via debugfs now.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 84d0273d826a..ee7fc47680a1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -372,6 +372,8 @@ struct hci_dev {
 
 	atomic_t		promisc;
 
+	const char		*hw_info;
+	const char		*fw_info;
 	struct dentry		*debugfs;
 
 	struct device		dev;
@@ -1024,6 +1026,8 @@ int hci_resume_dev(struct hci_dev *hdev);
 int hci_reset_dev(struct hci_dev *hdev);
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
 int hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);
+void hci_set_hw_info(struct hci_dev *hdev, const char *fmt, ...);
+void hci_set_fw_info(struct hci_dev *hdev, const char *fmt, ...);
 int hci_dev_open(__u16 dev);
 int hci_dev_close(__u16 dev);
 int hci_dev_do_close(struct hci_dev *hdev);

commit f962fe32f2f85769cd835ddcecbff8c1d34cf561
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jul 17 19:55:15 2016 +0200

    Bluetooth: Move hci_recv_frame and hci_recv_diag prototypes
    
    The protoypes for hci_recv_frame and hci_recv_diag are in the wrong
    location in the header file. Move them close to all the other hci_dev
    related exported functions.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 77d7fe115a0d..84d0273d826a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1022,6 +1022,8 @@ void hci_unregister_dev(struct hci_dev *hdev);
 int hci_suspend_dev(struct hci_dev *hdev);
 int hci_resume_dev(struct hci_dev *hdev);
 int hci_reset_dev(struct hci_dev *hdev);
+int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
+int hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);
 int hci_dev_open(__u16 dev);
 int hci_dev_close(__u16 dev);
 int hci_dev_do_close(struct hci_dev *hdev);
@@ -1098,9 +1100,6 @@ int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
-int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
-int hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);
-
 void hci_init_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);

commit 160b925163c0aabc2c2fbb7d58a75e38b7cd6a17
Author: Szymon Janc <szymon.janc@codecoup.pl>
Date:   Tue Jul 12 02:12:16 2016 +0200

    Bluetooth: Add Authentication Failed reason to Disconnected Mgmt event
    
    If link is disconnected due to Authentication Failure (PIN or Key
    Missing status) userspace will be notified about this with proper error
    code. Many LE profiles define "PIN or Key Missing" status as indication
    of remote lost bond so this allows userspace to take action on this.
    
    @ Device Connected: 88:63:DF:88:0E:83 (1) flags 0x0000
            02 01 1a 05 03 0a 18 0d 18 0b 09 48 65 61 72 74  ...........Heart
            20 52 61 74 65                                    Rate
    > HCI Event: Command Status (0x0f) plen 4
          LE Read Remote Used Features (0x08|0x0016) ncmd 1
            Status: Success (0x00)
    > ACL Data RX: Handle 3585 flags 0x02 dlen 11
          ATT: Read By Group Type Request (0x10) len 6
            Handle range: 0x0001-0xffff
            Attribute group type: Primary Service (0x2800)
    > HCI Event: LE Meta Event (0x3e) plen 12
          LE Read Remote Used Features (0x04)
            Status: Success (0x00)
            Handle: 3585
            Features: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00
              LE Encryption
    < HCI Command: LE Start Encryption (0x08|0x0019) plen 28
            Handle: 3585
            Random number: 0x0000000000000000
            Encrypted diversifier: 0x0000
            Long term key: 26201cd479a0921b6f949f0b1fa8dc82
    > HCI Event: Command Status (0x0f) plen 4
          LE Start Encryption (0x08|0x0019) ncmd 1
            Status: Success (0x00)
    > HCI Event: Encryption Change (0x08) plen 4
            Status: PIN or Key Missing (0x06)
            Handle: 3585
            Encryption: Disabled (0x00)
    < HCI Command: Disconnect (0x01|0x0006) plen 3
            Handle: 3585
            Reason: Authentication Failure (0x05)
    > HCI Event: Command Status (0x0f) plen 4
          Disconnect (0x01|0x0006) ncmd 1
            Status: Success (0x00)
    > HCI Event: Disconnect Complete (0x05) plen 4
            Status: Success (0x00)
            Handle: 3585
            Reason: Connection Terminated By Local Host (0x16)
    @ Device Disconnected: 88:63:DF:88:0E:83 (1) reason 4
    
    @ Device Connected: C4:43:8F:A3:4D:83 (0) flags 0x0000
            08 09 4e 65 78 75 73 20 35                       ..Nexus 5
    > HCI Event: Command Status (0x0f) plen 4
          Authentication Requested (0x01|0x0011) ncmd 1
            Status: Success (0x00)
    > HCI Event: Link Key Request (0x17) plen 6
            Address: C4:43:8F:A3:4D:83 (LG Electronics)
    < HCI Command: Link Key Request Reply (0x01|0x000b) plen 22
            Address: C4:43:8F:A3:4D:83 (LG Electronics)
            Link key: 080812e4aa97a863d11826f71f65a933
    > HCI Event: Command Complete (0x0e) plen 10
          Link Key Request Reply (0x01|0x000b) ncmd 1
            Status: Success (0x00)
            Address: C4:43:8F:A3:4D:83 (LG Electronics)
    > HCI Event: Auth Complete (0x06) plen 3
            Status: PIN or Key Missing (0x06)
            Handle: 75
    @ Authentication Failed: C4:43:8F:A3:4D:83 (0) status 0x05
    < HCI Command: Disconnect (0x01|0x0006) plen 3
            Handle: 75
            Reason: Remote User Terminated Connection (0x13)
    > HCI Event: Command Status (0x0f) plen 4
          Disconnect (0x01|0x0006) ncmd 1
            Status: Success (0x00)
    > HCI Event: Disconnect Complete (0x05) plen 4
            Status: Success (0x00)
            Handle: 75
            Reason: Connection Terminated By Local Host (0x16)
    @ Device Disconnected: C4:43:8F:A3:4D:83 (0) reason 4
    
    Signed-off-by: Szymon Janc <szymon.janc@codecoup.pl>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dc71473462ac..77d7fe115a0d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -654,6 +654,7 @@ enum {
 	HCI_CONN_PARAM_REMOVAL_PEND,
 	HCI_CONN_NEW_LINK_KEY,
 	HCI_CONN_SCANNING,
+	HCI_CONN_AUTH_FAILURE,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit 6d5d2ee63cee7025badda3b74ae2ef7ab097acfa
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Jan 8 19:28:58 2016 +0100

    Bluetooth: add LED trigger for indicating HCI is powered up
    
    Add support for LED triggers to the Bluetooth subsystem and add kernel
    config symbol BT_LEDS for it.
    
    For now one trigger for indicating "HCI is powered up" is supported.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d4f82edb5cff..dc71473462ac 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -25,6 +25,7 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
+#include <linux/leds.h>
 #include <net/bluetooth/hci.h>
 #include <net/bluetooth/hci_sock.h>
 
@@ -396,6 +397,8 @@ struct hci_dev {
 	struct delayed_work	rpa_expired;
 	bdaddr_t		rpa;
 
+	struct led_trigger	*power_led;
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);

commit 78b781ca0d35191ebf8d8cad8beec810270f0f2e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 5 13:19:32 2016 +0200

    Bluetooth: Add support for Start Limited Discovery command
    
    This patch implements the mgmt Start Limited Discovery command. Most
    of existing Start Discovery code is reused since the only difference
    is the presence of a 'limited' flag as part of the discovery state.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 372e2a7c4ada..d4f82edb5cff 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -77,6 +77,7 @@ struct discovery_state {
 	u8			last_adv_data_len;
 	bool			report_invalid_rssi;
 	bool			result_filtering;
+	bool			limited;
 	s8			rssi;
 	u16			uuid_count;
 	u8			(*uuids)[16];

commit 0d3b7f64c84d53658daf28e2f9772e38acb9340d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 5 13:19:31 2016 +0200

    Bluetooth: Change eir_has_data_type() to more generic eir_get_data()
    
    To make the EIR parsing helper more general purpose, make it return
    the found data and its length rather than just saying whether the data
    was present or not.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c95e0326c41a..372e2a7c4ada 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1283,31 +1283,41 @@ static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
 	mutex_unlock(&hci_cb_list_lock);
 }
 
-static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
+static inline void *eir_get_data(u8 *eir, size_t eir_len, u8 type,
+				 size_t *data_len)
 {
 	size_t parsed = 0;
 
-	if (data_len < 2)
-		return false;
+	if (eir_len < 2)
+		return NULL;
 
-	while (parsed < data_len - 1) {
-		u8 field_len = data[0];
+	while (parsed < eir_len - 1) {
+		u8 field_len = eir[0];
 
 		if (field_len == 0)
 			break;
 
 		parsed += field_len + 1;
 
-		if (parsed > data_len)
+		if (parsed > eir_len)
 			break;
 
-		if (data[1] == type)
-			return true;
+		if (eir[1] != type) {
+			eir += field_len + 1;
+			continue;
+		}
+
+		/* Zero length data */
+		if (field_len == 1)
+			return NULL;
 
-		data += field_len + 1;
+		if (data_len)
+			*data_len = field_len - 1;
+
+		return &eir[2];
 	}
 
-	return false;
+	return NULL;
 }
 
 static inline bool hci_bdaddr_is_rpa(bdaddr_t *bdaddr, u8 addr_type)

commit 2ff13894cfb877cb3d02d96a8402202f0a6f3efd
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 25 16:15:44 2015 +0200

    Bluetooth: Perform HCI update for power on synchronously
    
    The request to update HCI during power on is always coming either from
    hdev->req_workqueue or through an ioctl, so it's safe to use
    hci_req_sync for it. This way we also eliminate potential races with
    incoming mgmt commands or other actions while powering on.
    
    Part of this refactoring is the splitting of mgmt_powered() into
    mgmt_power_on() and __mgmt_power_off() functions. The main reason is
    the different requirements as far as hdev locking is concerned, as
    highlighted with the __ prefix of the power off API.
    
    Since the power on in the case of clearing the AUTO_OFF flag cannot be
    done synchronously in the set_powered mgmt handler, the hci_power_on
    work callback is extended to cover this (which also simplifies the
    set_powered helper a lot).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 319bf020cea6..c95e0326c41a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1435,7 +1435,8 @@ int mgmt_new_settings(struct hci_dev *hdev);
 void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
-int mgmt_powered(struct hci_dev *hdev, u8 powered);
+void mgmt_power_on(struct hci_dev *hdev, int err);
+void __mgmt_power_off(struct hci_dev *hdev);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,

commit c366f555b8df67633b849a5088bb897d6c63aaa5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 23 15:43:06 2015 +0200

    Bluetooth: Move discoverable timeout behind hdev->req_workqueue
    
    Since the other discoverable changes are behind req_workqueue now it
    only makes sense to move the discoverable timeout there as well.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0a6966ed7ee1..319bf020cea6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1436,7 +1436,6 @@ void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
-void mgmt_discoverable_timeout(struct hci_dev *hdev);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,

commit aed1a8851db022c3bd22af41a343068b8c6e40c1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Nov 22 17:24:44 2015 +0300

    Bluetooth: Move discoverable changes to hdev->req_workqueue
    
    The discoverable mode is intrinsically linked with the connectable
    mode e.g. through sharing the same HCI command (Write Scan Enable) for
    BR/EDR. It makes therefore sense to move it to hci_request.c and run
    the changes through the same hdev->req_workqueue.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a855e41df68c..0a6966ed7ee1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -331,6 +331,7 @@ struct hci_dev {
 	struct work_struct	bg_scan_update;
 	struct work_struct	scan_update;
 	struct work_struct	connectable_update;
+	struct work_struct	discoverable_update;
 	struct delayed_work	le_scan_disable;
 	struct delayed_work	le_scan_restart;
 
@@ -1493,6 +1494,7 @@ void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 bool mgmt_get_connectable(struct hci_dev *hdev);
 void mgmt_set_connectable_complete(struct hci_dev *hdev, u8 status);
+void mgmt_set_discoverable_complete(struct hci_dev *hdev, u8 status);
 u8 mgmt_get_adv_discov_flags(struct hci_dev *hdev);
 void mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev,
 			    u8 instance);

commit 53c0ba74510c1182786dcd1e3710215467777601
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Nov 22 16:43:43 2015 +0300

    Bluetooth: Move connectable changes to hdev->req_workqueue
    
    This way the connectable changes are synchronized against each other,
    which helps avoid potential races. The connectable mode is also linked
    together with LE advertising which makes is more convenient to have it
    behind the same workqueue.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b56085b6ecce..a855e41df68c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -330,6 +330,7 @@ struct hci_dev {
 	struct work_struct	discov_update;
 	struct work_struct	bg_scan_update;
 	struct work_struct	scan_update;
+	struct work_struct	connectable_update;
 	struct delayed_work	le_scan_disable;
 	struct delayed_work	le_scan_restart;
 
@@ -1491,6 +1492,7 @@ void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			 u16 max_interval, u16 latency, u16 timeout);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 bool mgmt_get_connectable(struct hci_dev *hdev);
+void mgmt_set_connectable_complete(struct hci_dev *hdev, u8 status);
 u8 mgmt_get_adv_discov_flags(struct hci_dev *hdev);
 void mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev,
 			    u8 instance);

commit f22525700b2ae34eb97a29a91e2eee902062b484
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 18 12:49:20 2015 +0200

    Bluetooth: Move advertising instance management to hci_request.c
    
    This paves the way for eventually performing advertising changes
    through the hdev->req_workqueue. Some new APIs need to be exposed from
    mgmt.c to hci_request.c and vice-versa, but many of them will go away
    once hdev->req_workqueue gets used.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index eda809a5c3df..b56085b6ecce 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1434,9 +1434,7 @@ void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
-int mgmt_update_adv_data(struct hci_dev *hdev);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
-void mgmt_adv_timeout_expired(struct hci_dev *hdev);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,
@@ -1491,8 +1489,13 @@ void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,
 void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			 u8 bdaddr_type, u8 store_hint, u16 min_interval,
 			 u16 max_interval, u16 latency, u16 timeout);
-void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
+bool mgmt_get_connectable(struct hci_dev *hdev);
+u8 mgmt_get_adv_discov_flags(struct hci_dev *hdev);
+void mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev,
+			    u8 instance);
+void mgmt_advertising_removed(struct sock *sk, struct hci_dev *hdev,
+			      u8 instance);
 
 u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
 		      u16 to_multiplier);

commit 01b1cb87d37fb19cdaa5e7002416fdde156873d0
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 16 12:52:21 2015 +0200

    Bluetooth: Run page scan updates through hdev->req_workqueue
    
    Since Add/Remove Device perform the page scan updates independently
    from the HCI command completion we've introduced a potential race when
    multiple mgmt commands are queued. Doing the page scan updates through
    the req_workqueue ensures that the state changes are performed in a
    race-free manner.
    
    At the same time, to make the request helper more widely usable,
    extend it to also cover Inquiry Scan changes since those are behind
    the same HCI command. This is also reflected in the new name of the
    API as well as the work struct name.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 55ce209157b1..eda809a5c3df 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -329,6 +329,7 @@ struct hci_dev {
 
 	struct work_struct	discov_update;
 	struct work_struct	bg_scan_update;
+	struct work_struct	scan_update;
 	struct delayed_work	le_scan_disable;
 	struct delayed_work	le_scan_restart;
 

commit 0ad06aa6a7682319bb1adcc187a1fa8db6b2da2c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 14:44:57 2015 +0200

    Bluetooth: Fix specifying role for LE connections
    
    The hci_connect_le_scan() is (as the name implies) a master/central
    role API, so it makes no sense in passing a role parameter to it. At
    the same time this patch also fixes the direct advertising support for
    LE L2CAP sockets where we now call the more appropriate hci_le_connect()
    API if slave/peripheral role is desired.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 609f4a03899c..55ce209157b1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -877,7 +877,7 @@ struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 				     u8 dst_type, u8 sec_level,
-				     u16 conn_timeout, u8 role);
+				     u16 conn_timeout);
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u16 conn_timeout,
 				u8 role);

commit 2154d3f4fb83c812a161c4910948dd876997e111
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 08:30:45 2015 +0200

    Bluetooth: Move Stop Discovery to req_workqueue
    
    Since discovery also deals with LE scanning it makes sense to move it
    behind the same req_workqueue as other LE scanning changes. This also
    simplifies the logic since we do many of the actions in a synchronous
    manner.
    
    Part of this refactoring is moving hci_req_stop_discovery() to
    hci_request.c. At the same time the function receives support for
    properly handling the STOPPING state since that's the state we'll be
    in when stopping through the req_workqueue.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 72ea8a6d7d70..609f4a03899c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1475,6 +1475,7 @@ void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 void mgmt_start_discovery_complete(struct hci_dev *hdev, u8 status);
+void mgmt_stop_discovery_complete(struct hci_dev *hdev, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,
 		       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len);

commit e68f072b7396574df5324e1cf93e4b0c92460735
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 08:30:30 2015 +0200

    Bluetooth: Move Start Discovery to req_workqueue
    
    Since discovery also deals with LE scanning it makes sense to move it
    behind the same req_workqueue as other LE scanning changes. This also
    simplifies the logic since we do many of the actions in a synchronous
    manner.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1f75aebbd8c4..72ea8a6d7d70 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -327,6 +327,7 @@ struct hci_dev {
 	struct work_struct	cmd_work;
 	struct work_struct	tx_work;
 
+	struct work_struct	discov_update;
 	struct work_struct	bg_scan_update;
 	struct delayed_work	le_scan_disable;
 	struct delayed_work	le_scan_restart;
@@ -1473,6 +1474,7 @@ void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
+void mgmt_start_discovery_complete(struct hci_dev *hdev, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,
 		       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len);

commit 7c1fbed23981faff2840ddc8909e7c78d80ade30
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 08:11:23 2015 +0200

    Bluetooth: Move LE scan disable/restart behind req_workqueue
    
    To avoid any risks of races, place also these LE scan modification
    work callbacks behind the same work queue as the other LE scan
    changes.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c2ca6a58d1e0..1f75aebbd8c4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -328,6 +328,8 @@ struct hci_dev {
 	struct work_struct	tx_work;
 
 	struct work_struct	bg_scan_update;
+	struct delayed_work	le_scan_disable;
+	struct delayed_work	le_scan_restart;
 
 	struct sk_buff_head	rx_q;
 	struct sk_buff_head	raw_q;
@@ -372,9 +374,6 @@ struct hci_dev {
 
 	DECLARE_BITMAP(dev_flags, __HCI_NUM_FLAGS);
 
-	struct delayed_work	le_scan_disable;
-	struct delayed_work	le_scan_restart;
-
 	__s8			adv_tx_power;
 	__u8			adv_data[HCI_MAX_AD_LENGTH];
 	__u8			adv_data_len;

commit 2e93e53b8f86fb38a9a3c3bd08e539c40b3f8d89
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 08:11:17 2015 +0200

    Bluetooth: Run all background scan updates through req_workqueue
    
    Instead of firing off a simple async request queue all background scan
    updates through req_workqueue and use hci_req_sync() there to ensure
    that no two updates overlap with each other.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 15e6a2bffc2b..c2ca6a58d1e0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -327,6 +327,8 @@ struct hci_dev {
 	struct work_struct	cmd_work;
 	struct work_struct	tx_work;
 
+	struct work_struct	bg_scan_update;
+
 	struct sk_buff_head	rx_q;
 	struct sk_buff_head	raw_q;
 	struct sk_buff_head	cmd_q;

commit 030e7f8141a262e32dc064d7cf12377d769d45c2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Nov 10 09:44:53 2015 +0200

    Bluetooth: Remove unnecessary call to hci_update_background_scan
    
    The hci_conn_params_clear_all() function is only called from
    hci_unregister_dev() at which point it's completely futile to try to
    do any LE scanning updates. Simply remove this unnecessary function
    call. At the same time we can make the function static since it's only
    accessed from within the same c-file.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1878d0a96333..15e6a2bffc2b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1036,7 +1036,6 @@ struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 struct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,
 					    bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
-void hci_conn_params_clear_all(struct hci_dev *hdev);
 void hci_conn_params_clear_disabled(struct hci_dev *hdev);
 
 struct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,

commit 17bc08f0d1b17d6d5e4967c1b430af627c5f2041
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 18:03:10 2015 +0300

    Bluetooth: Remove unnecessary hci_explicit_connect_lookup function
    
    There's only one user of this helper which can be replaces with a call
    to hci_pend_le_action_lookup() and a check for params->explicit_connect.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 32bb281e6aa6..1878d0a96333 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1042,9 +1042,6 @@ void hci_conn_params_clear_disabled(struct hci_dev *hdev);
 struct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,
 						  bdaddr_t *addr,
 						  u8 addr_type);
-struct hci_conn_params *hci_explicit_connect_lookup(struct hci_dev *hdev,
-						    bdaddr_t *addr,
-						    u8 addr_type);
 
 void hci_uuids_clear(struct hci_dev *hdev);
 

commit 1b51c7b6e878a2df6fdb5bcf51f966eb46a330e0
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 18:03:00 2015 +0300

    Bluetooth: Add hci_conn_hash_lookup_le() helper function
    
    Many of the existing LE connection lookups are forced to use
    hci_conn_hash_lookup_ba() which doesn't take into account the address
    type. What's worse, most of the users don't bother checking that the
    returned address type matches what was wanted.
    
    This patch adds a new helper API to look up LE connections based on
    their address and address type, paving the way to have the
    hci_conn_hash_lookup_ba() users converted to do more precise lookups.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0015d087d8b1..32bb281e6aa6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -794,6 +794,30 @@ static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 	return NULL;
 }
 
+static inline struct hci_conn *hci_conn_hash_lookup_le(struct hci_dev *hdev,
+						       bdaddr_t *ba,
+						       __u8 ba_type)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn  *c;
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type != LE_LINK)
+		       continue;
+
+		if (ba_type == c->dst_type && !bacmp(&c->dst, ba)) {
+			rcu_read_unlock();
+			return c;
+		}
+	}
+
+	rcu_read_unlock();
+
+	return NULL;
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 							__u8 type, __u16 state)
 {

commit 8ce783dc5ea3af3a213ac9b4d9d2ccfeeb9c9058
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 15:21:31 2015 +0300

    Bluetooth: Fix missing hdev locking for LE scan cleanup
    
    The hci_conn objects don't have a dedicated lock themselves but rely
    on the caller to hold the hci_dev lock for most types of access. The
    hci_conn_timeout() function has so far sent certain HCI commands based
    on the hci_conn state which has been possible without holding the
    hci_dev lock.
    
    The recent changes to do LE scanning before connect attempts added
    even more operations to hci_conn and hci_dev from hci_conn_timeout,
    thereby exposing potential race conditions with the hci_dev and
    hci_conn states.
    
    As an example of such a race, here there's a timeout but an
    l2cap_sock_connect() call manages to race with the cleanup routine:
    
    [Oct21 08:14] l2cap_chan_timeout: chan ee4b12c0 state BT_CONNECT
    [  +0.000004] l2cap_chan_close: chan ee4b12c0 state BT_CONNECT
    [  +0.000002] l2cap_chan_del: chan ee4b12c0, conn f3141580, err 111, state BT_CONNECT
    [  +0.000002] l2cap_sock_teardown_cb: chan ee4b12c0 state BT_CONNECT
    [  +0.000005] l2cap_chan_put: chan ee4b12c0 orig refcnt 4
    [  +0.000010] hci_conn_drop: hcon f53d56e0 orig refcnt 1
    [  +0.000013] l2cap_chan_put: chan ee4b12c0 orig refcnt 3
    [  +0.000063] hci_conn_timeout: hcon f53d56e0 state BT_CONNECT
    [  +0.000049] hci_conn_params_del: addr ee:0d:30:09:53:1f (type 1)
    [  +0.000002] hci_chan_list_flush: hcon f53d56e0
    [  +0.000001] hci_chan_del: hci0 hcon f53d56e0 chan f4e7ccc0
    [  +0.004528] l2cap_sock_create: sock e708fc00
    [  +0.000023] l2cap_chan_create: chan ee4b1770
    [  +0.000001] l2cap_chan_hold: chan ee4b1770 orig refcnt 1
    [  +0.000002] l2cap_sock_init: sk ee4b3390
    [  +0.000029] l2cap_sock_bind: sk ee4b3390
    [  +0.000010] l2cap_sock_setsockopt: sk ee4b3390
    [  +0.000037] l2cap_sock_connect: sk ee4b3390
    [  +0.000002] l2cap_chan_connect: 00:02:72:d9:e5:8b -> ee:0d:30:09:53:1f (type 2) psm 0x00
    [  +0.000002] hci_get_route: 00:02:72:d9:e5:8b -> ee:0d:30:09:53:1f
    [  +0.000001] hci_dev_hold: hci0 orig refcnt 8
    [  +0.000003] hci_conn_hold: hcon f53d56e0 orig refcnt 0
    
    Above the l2cap_chan_connect() shouldn't have been able to reach the
    hci_conn f53d56e0 anymore but since hci_conn_timeout didn't do proper
    locking that's not the case. The end result is a reference to hci_conn
    that's not in the conn_hash list, resulting in list corruption when
    trying to remove it later:
    
    [Oct21 08:15] l2cap_chan_timeout: chan ee4b1770 state BT_CONNECT
    [  +0.000004] l2cap_chan_close: chan ee4b1770 state BT_CONNECT
    [  +0.000003] l2cap_chan_del: chan ee4b1770, conn f3141580, err 111, state BT_CONNECT
    [  +0.000001] l2cap_sock_teardown_cb: chan ee4b1770 state BT_CONNECT
    [  +0.000005] l2cap_chan_put: chan ee4b1770 orig refcnt 4
    [  +0.000002] hci_conn_drop: hcon f53d56e0 orig refcnt 1
    [  +0.000015] l2cap_chan_put: chan ee4b1770 orig refcnt 3
    [  +0.000038] hci_conn_timeout: hcon f53d56e0 state BT_CONNECT
    [  +0.000003] hci_chan_list_flush: hcon f53d56e0
    [  +0.000002] hci_conn_hash_del: hci0 hcon f53d56e0
    [  +0.000001] ------------[ cut here ]------------
    [  +0.000461] WARNING: CPU: 0 PID: 1782 at lib/list_debug.c:56 __list_del_entry+0x3f/0x71()
    [  +0.000839] list_del corruption, f53d56e0->prev is LIST_POISON2 (00000200)
    
    The necessary fix is unfortunately more complicated than just adding
    hci_dev_lock/unlock calls to the hci_conn_timeout() call path.
    Particularly, the hci_conn_del() API, which expects the hci_dev lock to
    be held, performs a cancel_delayed_work_sync(&hcon->disc_work) which
    would lead to a deadlock if the hci_conn_timeout() call path tries to
    acquire the same lock.
    
    This patch solves the problem by deferring the cleanup work to a
    separate work callback. To protect against the hci_dev or hci_conn
    going away meanwhile temporary references are taken with the help of
    hci_dev_hold() and hci_conn_get().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org # 4.3

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 44fb95685611..0015d087d8b1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -471,6 +471,7 @@ struct hci_conn {
 	struct delayed_work auto_accept_work;
 	struct delayed_work idle_work;
 	struct delayed_work le_conn_timeout;
+	struct work_struct  le_scan_cleanup;
 
 	struct device	dev;
 	struct dentry	*debugfs;

commit 98a63aaf245e2522b0ddd86f38fb83883344bcaf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 20 23:25:42 2015 +0200

    Bluetooth: Introduce driver specific post init callback
    
    Some drivers might have to restore certain settings after the init
    procedure has been completed. This driver callback allows them to hook
    into that stage. This callback is run just before the controller is
    declared as powered up.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 989c72aabc45..44fb95685611 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -398,6 +398,7 @@ struct hci_dev {
 	int (*send)(struct hci_dev *hdev, struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	void (*hw_error)(struct hci_dev *hdev, u8 code);
+	int (*post_init)(struct hci_dev *hdev);
 	int (*set_diag)(struct hci_dev *hdev, bool enable);
 	int (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 };

commit cad20c278085d893ebd616cd20c0747a8e9d53c7
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Oct 12 13:36:19 2015 +0200

    Bluetooth: Don't use remote address type to decide IRK persistency
    
    There are LE devices on the market that start off by announcing their
    public address and then once paired switch to using private address.
    To be interoperable with such devices we should simply trust the fact
    that we're receiving an IRK from them to indicate that they may use
    private addresses in the future. Instead, simply tie the persistency
    to the bonding/no-bonding information the same way as for LTKs and
    CSRKs.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f28470e59682..989c72aabc45 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1458,7 +1458,7 @@ void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 bool mgmt_powering_down(struct hci_dev *hdev);
 void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent);
-void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
+void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk, bool persistent);
 void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,
 		   bool persistent);
 void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit 4b4113d6dbdbdac095743c05f694af9b7cdc9a44
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 7 19:52:35 2015 +0200

    Bluetooth: Add debugfs entry for setting vendor diagnostic mode
    
    This adds a new debugfs entry for enabling and disabling the vendor
    diagnostic mode. It is only exposed for drivers that provide the
    set_diag driver callback and actually have an option for vendor
    specific diagnostic information.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d473b67a2c65..f28470e59682 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -398,6 +398,7 @@ struct hci_dev {
 	int (*send)(struct hci_dev *hdev, struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	void (*hw_error)(struct hci_dev *hdev, u8 code);
+	int (*set_diag)(struct hci_dev *hdev, bool enable);
 	int (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 };
 

commit e875ff84079b9e7d3ce24b97e3396230d41044d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 7 16:38:35 2015 +0200

    Bluetooth: Add support for vendor specific diagnostic channel
    
    Introduce hci_recv_diag function for HCI drivers to allow sending vendor
    specific diagnostic messages into the Bluetooth core stack. The messages
    are not processed, but they are forwarded to the monitor channel and can
    be retrieved by user space diagnostic tools.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 61dc786358be..d473b67a2c65 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1066,6 +1066,7 @@ int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
+int hci_recv_diag(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_init_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);

commit fbef168fec837ae26c8725737cd4b49dc8a0f917
Author: Loic Poulain <loic.poulain@intel.com>
Date:   Tue Sep 29 15:05:44 2015 +0200

    Bluetooth: Add hci_cmd_sync function
    
    Send a HCI command and wait for command complete event.
    This function serializes the requests by grabbing the req_lock.
    
    Signed-off-by: Loic Poulain <loic.poulain@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 256e6734c1fb..61dc786358be 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1349,6 +1349,9 @@ void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 
+struct sk_buff *hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
+			     const void *param, u32 timeout);
+
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_channel(unsigned short channel, struct sk_buff *skb,

commit 6b3cc1db68ac83647d37f7d16f0261621eda24aa
Author: Simon Fels <simon.fels@canonical.com>
Date:   Wed Sep 2 12:10:12 2015 +0200

    Bluetooth: close HCI device when user channel socket gets closed
    
    With 9380f9eacfbbee701daa416edd6625efcd3e29e1 the order of unsetting
    the HCI_USER_CHANNEL flag of the HCI device was reverted to ensure
    the device is first closed before making it available again.
    
    Due to hci_dev_close checking for HCI_USER_CHANNEL being set on the
    device it was never really closed and was kept opened. We're now
    calling hci_dev_do_close directly to make sure the device is correctly
    closed and we keep the correct order to unset the flag on our device
    object.
    
    Signed-off-by: Simon Fels <simon.fels@canonical.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9e1a59e01fa2..256e6734c1fb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -987,6 +987,7 @@ int hci_resume_dev(struct hci_dev *hdev);
 int hci_reset_dev(struct hci_dev *hdev);
 int hci_dev_open(__u16 dev);
 int hci_dev_close(__u16 dev);
+int hci_dev_do_close(struct hci_dev *hdev);
 int hci_dev_reset(__u16 dev);
 int hci_dev_reset_stat(__u16 dev);
 int hci_dev_cmd(unsigned int cmd, void __user *arg);

commit f75113a26008980ca13834fb6573145523596776
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:53 2015 +0200

    Bluetooth: add hci_connect_le_scan
    
    Currently, when trying to connect to already paired device that just
    rotated its RPA MAC address, old address would be used and connection
    would fail. In order to fix that, kernel must scan and receive
    advertisement with fresh RPA before connecting.
    
    This patch adds hci_connect_le_scan with dependencies, new method that
    will be used to connect to remote LE devices. Instead of just sending
    connect request, it adds a device to whitelist. Later patches will make
    use of this whitelist to send conenct request when advertisement is
    received, and properly handle timeouts.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f0a9fc1d06e0..9e1a59e01fa2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -846,6 +846,9 @@ void hci_chan_del(struct hci_chan *chan);
 void hci_chan_list_flush(struct hci_conn *conn);
 struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
+struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
+				     u8 dst_type, u8 sec_level,
+				     u16 conn_timeout, u8 role);
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u16 conn_timeout,
 				u8 role);
@@ -1011,6 +1014,9 @@ void hci_conn_params_clear_disabled(struct hci_dev *hdev);
 struct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,
 						  bdaddr_t *addr,
 						  u8 addr_type);
+struct hci_conn_params *hci_explicit_connect_lookup(struct hci_dev *hdev,
+						    bdaddr_t *addr,
+						    u8 addr_type);
 
 void hci_uuids_clear(struct hci_dev *hdev);
 

commit e7d9ab731ac7babaf2e1b7b5e2280f5f555d263f
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:52 2015 +0200

    Bluetooth: add hci_lookup_le_connect
    
    This patch adds hci_lookup_le_connect method, that will be used to check
    wether outgoing le connection attempt is in progress.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c8d2b5a89d08..f0a9fc1d06e0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -811,6 +811,26 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 	return NULL;
 }
 
+static inline struct hci_conn *hci_lookup_le_connect(struct hci_dev *hdev)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn  *c;
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == LE_LINK && c->state == BT_CONNECT &&
+		    !test_bit(HCI_CONN_SCANNING, &c->flags)) {
+			rcu_read_unlock();
+			return c;
+		}
+	}
+
+	rcu_read_unlock();
+
+	return NULL;
+}
+
 int hci_disconnect(struct hci_conn *conn, __u8 reason);
 bool hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);

commit 158e92185075184ebc5f25bab61fdd598693e28d
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:51 2015 +0200

    Bluetooth: preparation for new connect procedure
    
    Currently, when trying to connect to already paired device that just
    rotated its RPA MAC address, old address would be used and connection
    would fail. In order to fix that, kernel must scan and receive
    advertisement with fresh RPA before connecting.
    
    This patch adds some fields to hci_conn_params, in preparation to new
    connect procedure.
    
    explicit_connect will be used to override any current auto_connect action,
    and connect to device when ad is received.
    
    HCI_AUTO_CONN_EXPLICIT was added to auto_connect enum. When this value
    will be used, explicit connect is the only action, and params can be
    removed after successful connection.
    
    HCI_CONN_SCANNING is added to hci_conn flags. When it's set, connect is
    scan phase. It gets cleared when advertisement is received, and
    HCI_OP_LE_CREATE_CONN is sent.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2a6b0919e23f..c8d2b5a89d08 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -512,9 +512,11 @@ struct hci_conn_params {
 		HCI_AUTO_CONN_DIRECT,
 		HCI_AUTO_CONN_ALWAYS,
 		HCI_AUTO_CONN_LINK_LOSS,
+		HCI_AUTO_CONN_EXPLICIT,
 	} auto_connect;
 
 	struct hci_conn *conn;
+	bool explicit_connect;
 };
 
 extern struct list_head hci_dev_list;
@@ -639,6 +641,7 @@ enum {
 	HCI_CONN_DROP,
 	HCI_CONN_PARAM_REMOVAL_PEND,
 	HCI_CONN_NEW_LINK_KEY,
+	HCI_CONN_SCANNING,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit 8757825b128e71319150219b0745d3ecb87f34aa
Author: Seungyoun Ju <sy39.ju@samsung.com>
Date:   Mon Jul 13 17:28:13 2015 +0900

    Bluetooth: hci_check_conn_params() check proper range
    
    Slave latency range has been changed in Core Spec. 4.2 by Erratum 5419
    of ESR08_V1.0.0. And it should be applied to Core Spec. 4.0 and 4.1.
    
    Before:
       connSlaveLatency <= ((connSupervisionTimeout / connIntervalMax) - 1)
    
    After:
       connSlaveLatency <= ((connSupervisionTimeout / (connIntervalMax*2)) - 1)
    
    This patch makes hci_check_conn_params() check the allowable slave
    latency range using the changed way.
    
    Signed-off-by: Seungyoun Ju <sy39.ju@samsung.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3bd618d3e55d..2a6b0919e23f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1297,7 +1297,7 @@ static inline int hci_check_conn_params(u16 min, u16 max, u16 latency,
 	if (max >= to_multiplier * 8)
 		return -EINVAL;
 
-	max_latency = (to_multiplier * 8 / max) - 1;
+	max_latency = (to_multiplier * 4 / max) - 1;
 	if (latency > 499 || latency > max_latency)
 		return -EINVAL;
 

commit db25be6657a56ba2d68aae1f90d796f527f65689
Author: Florian Grandel <fgrandel@gmail.com>
Date:   Thu Jun 18 03:16:53 2015 +0200

    Bluetooth: hci_core: increase max adv inst
    
    Now that all preconditions are present for actual multi-advertising, the
    number of allowed advertising instances can be larger than one. This
    patch increases the number of allowed advertising instances to 5.
    
    Signed-off-by: Florian Grandel <fgrandel@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a6cec6d21aff..3bd618d3e55d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -169,7 +169,7 @@ struct adv_info {
 	__u8	scan_rsp_data[HCI_MAX_AD_LENGTH];
 };
 
-#define HCI_MAX_ADV_INSTANCES		1
+#define HCI_MAX_ADV_INSTANCES		5
 #define HCI_DEFAULT_ADV_DURATION	2
 
 #define HCI_MAX_SHORT_NAME_LENGTH	10

commit d4c5af8f71c8104504a83f7c71911550ebe43ac3
Author: Florian Grandel <fgrandel@gmail.com>
Date:   Thu Jun 18 03:16:52 2015 +0200

    Bluetooth: hci_core: remove obsolete adv_instance
    
    Now that the obsolete adv_instance is no longer being referenced
    anywhere in the code it can be removed without breaking the build.
    
    Signed-off-by: Florian Grandel <fgrandel@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4f58a0e6e0d3..a6cec6d21aff 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -379,7 +379,6 @@ struct hci_dev {
 	__u8			scan_rsp_data[HCI_MAX_AD_LENGTH];
 	__u8			scan_rsp_data_len;
 
-	struct adv_info		adv_instance;
 	struct list_head	adv_instances;
 	unsigned int		adv_instance_cnt;
 	__u8			cur_adv_instance;
@@ -584,11 +583,6 @@ static inline void hci_discovery_filter_clear(struct hci_dev *hdev)
 	hdev->discovery.scan_duration = 0;
 }
 
-static inline void adv_info_init(struct hci_dev *hdev)
-{
-	memset(&hdev->adv_instance, 0, sizeof(struct adv_info));
-}
-
 bool hci_discovery_active(struct hci_dev *hdev);
 
 void hci_discovery_set_state(struct hci_dev *hdev, int state);

commit fffd38bca51c9a1c00508b754ab66edb6f39cf37
Author: Florian Grandel <fgrandel@gmail.com>
Date:   Thu Jun 18 03:16:47 2015 +0200

    Bluetooth: mgmt/hci_core: multi-adv for add_advertising*()
    
    The add_advertising() and add_advertising_complete() functions reference
    the now obsolete hdev->adv_instance struct. Both methods are being
    refactored to access the dynamic advertising instance list instead.
    
    This patch also introduces all logic necessary to actually deal with
    multiple instance advertising. Notably the mgmt_adv_inst_expired() and
    schedule_adv_inst() method are being referenced to schedule instances in
    a round robin fashion.
    
    This patch also introduces a "pending" flag into the adv_info struct.
    This is necessary to identify and remove recently added advertising
    instances when the HCI commands return with an error status code.
    Otherwise new advertising instances could be leaked without properly
    informing userspace about their existence.
    
    Signed-off-by: Florian Grandel <fgrandel@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b53e1b113621..4f58a0e6e0d3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -157,6 +157,7 @@ struct oob_data {
 
 struct adv_info {
 	struct list_head list;
+	bool pending;
 	__u8	instance;
 	__u32	flags;
 	__u16	timeout;

commit 5d900e4601391576a3c0644d7fcad1ebf41a516e
Author: Florian Grandel <fgrandel@gmail.com>
Date:   Thu Jun 18 03:16:35 2015 +0200

    Bluetooth: hci_core/mgmt: move adv timeout to hdev
    
    Currently the delayed work managing advertising duration and timeout is
    part of the advertising instance structure. This is not correct as only
    a single instance can be advertised at any given time. To implement
    round robin advertising a single delayed work structure is needed.
    
    To fix this the delayed work structure is being moved to the hci_dev
    structure. The instance specific variable is renamed to "remaining_time"
    to make it clear that this is the remaining lifetime of the instance and
    not the current advertising timeout.
    
    Signed-off-by: Florian Grandel <fgrandel@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4242dbfb4cf5..b53e1b113621 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -156,11 +156,11 @@ struct oob_data {
 };
 
 struct adv_info {
-	struct delayed_work timeout_exp;
 	struct list_head list;
 	__u8	instance;
 	__u32	flags;
 	__u16	timeout;
+	__u16	remaining_time;
 	__u16	duration;
 	__u16	adv_data_len;
 	__u8	adv_data[HCI_MAX_AD_LENGTH];
@@ -382,6 +382,8 @@ struct hci_dev {
 	struct list_head	adv_instances;
 	unsigned int		adv_instance_cnt;
 	__u8			cur_adv_instance;
+	__u16			adv_instance_timeout;
+	struct delayed_work	adv_instance_expire;
 
 	__u8			irk[16];
 	__u32			rpa_timeout;
@@ -1379,6 +1381,7 @@ void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_update_adv_data(struct hci_dev *hdev);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
+void mgmt_adv_timeout_expired(struct hci_dev *hdev);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,

commit d2609b345ebf0547015a78588c4d7ad68c9ccf26
Author: Florian Grandel <fgrandel@gmail.com>
Date:   Thu Jun 18 03:16:34 2015 +0200

    Bluetooth: hci_core/mgmt: Introduce multi-adv list
    
    The current hci dev structure only supports a single advertising
    instance. To support multi-instance advertising it is necessary to
    introduce a linked list of advertising instances so that multiple
    advertising instances can be dynamically added and/or removed.
    
    In a first step, the existing adv_instance member of the hci_dev
    struct is supplemented by a linked list of advertising instances.
    This patch introduces the list and supporting list management
    infrastructure. The list is not being used yet.
    
    Signed-off-by: Florian Grandel <fgrandel@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3fbb793e634d..4242dbfb4cf5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -157,15 +157,20 @@ struct oob_data {
 
 struct adv_info {
 	struct delayed_work timeout_exp;
+	struct list_head list;
 	__u8	instance;
 	__u32	flags;
 	__u16	timeout;
+	__u16	duration;
 	__u16	adv_data_len;
 	__u8	adv_data[HCI_MAX_AD_LENGTH];
 	__u16	scan_rsp_len;
 	__u8	scan_rsp_data[HCI_MAX_AD_LENGTH];
 };
 
+#define HCI_MAX_ADV_INSTANCES		1
+#define HCI_DEFAULT_ADV_DURATION	2
+
 #define HCI_MAX_SHORT_NAME_LENGTH	10
 
 /* Default LE RPA expiry time, 15 minutes */
@@ -374,6 +379,9 @@ struct hci_dev {
 	__u8			scan_rsp_data_len;
 
 	struct adv_info		adv_instance;
+	struct list_head	adv_instances;
+	unsigned int		adv_instance_cnt;
+	__u8			cur_adv_instance;
 
 	__u8			irk[16];
 	__u32			rpa_timeout;
@@ -1019,6 +1027,15 @@ int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			       u8 bdaddr_type);
 
+void hci_adv_instances_clear(struct hci_dev *hdev);
+struct adv_info *hci_find_adv_instance(struct hci_dev *hdev, u8 instance);
+struct adv_info *hci_get_next_instance(struct hci_dev *hdev, u8 instance);
+int hci_add_adv_instance(struct hci_dev *hdev, u8 instance, u32 flags,
+			 u16 adv_data_len, u8 *adv_data,
+			 u16 scan_rsp_len, u8 *scan_rsp_data,
+			 u16 timeout, u16 duration);
+int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
+
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);

commit ff50e8afc537e66bb3daf5d1cd6628d6b76e7f06
Author: Arron Wang <arron.wang@intel.com>
Date:   Tue Jun 9 17:47:23 2015 +0800

    Bluetooth: Move SCO support under BT_BREDR config option
    
    SCO/eSCO link is supported by BR/EDR controller, it is
    suitable to move them under BT_BREDR config option
    
    Signed-off-by: Arron Wang <arron.wang@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f175a51f9740..3fbb793e634d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -532,8 +532,20 @@ int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int l2cap_disconn_ind(struct hci_conn *hcon);
 void l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
 
+#if IS_ENABLED(CONFIG_BT_BREDR)
 int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
 void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
+#else
+static inline int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				  __u8 *flags)
+{
+	return 0;
+}
+
+static inline void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)
+{
+}
+#endif
 
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */

commit 9b4c33364eb653a824c58e637c73caa6feb9879c
Author: Arron Wang <arron.wang@intel.com>
Date:   Tue Jun 9 17:47:22 2015 +0800

    Bluetooth: Make l2cap_recv_acldata() and sco_recv_scodata() return void
    
    The return value of l2cap_recv_acldata() and sco_recv_scodata()
    are not used, then change it to return void
    
    Signed-off-by: Arron Wang <arron.wang@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 24c0e4577a93..f175a51f9740 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -530,10 +530,10 @@ extern struct mutex hci_cb_list_lock;
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int l2cap_disconn_ind(struct hci_conn *hcon);
-int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
+void l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
 
 int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
-int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
+void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */

commit 8b76ce34c43a569f981623485c1b6c700594678e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jun 8 18:14:39 2015 +0300

    Bluetooth: Fix encryption key size handling for LTKs
    
    The encryption key size for LTKs is supposed to be applied only at the
    moment of encryption. When generating a Link Key (using LE SC) from
    the LTK the full non-shortened value should be used. This patch
    modifies the code to always keep the full value around and only apply
    the key size when passing the value to HCI.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a056c2bfeb81..24c0e4577a93 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1408,7 +1408,7 @@ void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
 		      u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
-							__u8 ltk[16]);
+		      __u8 ltk[16], __u8 key_size);
 
 void hci_copy_identity_address(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			       u8 *bdaddr_type);

commit 2d7cc19eebc182dbdda228aa26eb5bfff97ac072
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 21:59:27 2015 -0700

    Bluetooth: Remove hci_recv_stream_fragment function
    
    The hci_recv_stream_fragment function should have never been introduced
    in the first place. The Bluetooth core does not need to know anything
    about the HCI transport protocol.
    
    With all transport protocol specific detailed moved back into the
    drivers where they belong (mainly generic USB and UART drivers), this
    function can now be removed.
    
    This reduces the size of hci_dev structure and also removes an exported
    symbol from the Bluetooth core module.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ad957f336ead..a056c2bfeb81 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -185,7 +185,6 @@ struct amp_assoc {
 
 #define HCI_MAX_PAGES	3
 
-#define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
 	struct mutex	lock;
@@ -327,7 +326,6 @@ struct hci_dev {
 	struct sk_buff_head	cmd_q;
 
 	struct sk_buff		*sent_cmd;
-	struct sk_buff		*reassembly[NUM_REASSEMBLY];
 
 	struct mutex		req_lock;
 	wait_queue_head_t	req_wait_q;
@@ -1012,7 +1010,6 @@ int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
-int hci_recv_stream_fragment(struct hci_dev *hdev, const void *data, int count);
 
 void hci_init_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);

commit 5c7d2dd2852c7cd8f07cf91291b351c01b781044
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Apr 4 20:59:40 2015 -0700

    Bluetooth: Make data pointer of hci_recv_stream_fragment const
    
    The data pointer provided to hci_recv_stream_fragment function should
    have been marked const. The function has no business in modifying the
    original data. So fix this now.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 93fd3e756b8a..ad957f336ead 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1012,7 +1012,7 @@ int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
-int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
+int hci_recv_stream_fragment(struct hci_dev *hdev, const void *data, int count);
 
 void hci_init_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);

commit 1b9441f8ec426223f6f54f2af10ee01c8b743e5b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Apr 2 13:41:13 2015 +0300

    Bluetooth: Convert local OOB data reading to use HCI request
    
    Now that there's a HCI request API available where the callback receives
    the resulting skb, we can convert the local OOB data reading to use this
    new API. This patch does the necessary update in mgmt.c (which also
    requires moving the callback higher up since it's now a static function)
    and removes the custom calls from hci_event.c that are no-longer
    necessary.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 12686e8e9343..93fd3e756b8a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1391,9 +1391,6 @@ void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
-void mgmt_read_local_oob_data_complete(struct hci_dev *hdev, u8 *hash192,
-				       u8 *rand192, u8 *hash256, u8 *rand256,
-				       u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,
 		       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len);

commit abe66a4d036933c7376b40b0d7bb5de0458331aa
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Apr 2 13:41:11 2015 +0300

    Bluetooth: Remove unused hci_req_pending() function
    
    The hci_req_pending() function has no users anymore, so simply remove
    it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4cefee0b6330..12686e8e9343 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1284,8 +1284,6 @@ static inline int hci_check_conn_params(u16 min, u16 max, u16 latency,
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 
-bool hci_req_pending(struct hci_dev *hdev);
-
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);
 struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,

commit f7d9e97592aeb7742084814c5f37e25571b2d51d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Apr 2 13:41:10 2015 +0300

    Bluetooth: Remove unneeded recv_event variable
    
    Now that the synchronous HCI requests use the new API and a new private
    variable the recv_evt member of hci_dev is no-longer needed. This patch
    removes it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 257ac04c00e1..4cefee0b6330 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -326,7 +326,6 @@ struct hci_dev {
 	struct sk_buff_head	raw_q;
 	struct sk_buff_head	cmd_q;
 
-	struct sk_buff		*recv_evt;
 	struct sk_buff		*sent_cmd;
 	struct sk_buff		*reassembly[NUM_REASSEMBLY];
 

commit f60cb30579d3401cab1ed36b42df5c0568ae0ba7
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Apr 2 13:41:09 2015 +0300

    Bluetooth: Convert hci_req_sync family of function to new request API
    
    Now that there's an API in place that allows passing the resulting skb
    to the request callback we can conveniently convert the hci_req_sync and
    related functions to use it. Since we still need to get the skb from the
    async callback into the sleeping _sync() function the patch adds another
    req_skb variable to hci_dev where the sync request state is tracked.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 540c07feece7..257ac04c00e1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -334,6 +334,7 @@ struct hci_dev {
 	wait_queue_head_t	req_wait_q;
 	__u32			req_status;
 	__u32			req_result;
+	struct sk_buff		*req_skb;
 
 	void			*smp_data;
 	void			*smp_bredr_data;

commit 912098a6308e37208b8dcc46c57c66d0778a854b
Author: Arman Uguray <armansito@chromium.org>
Date:   Mon Mar 23 15:57:15 2015 -0700

    Bluetooth: Add support for adv instance timeout
    
    This patch implements support for the timeout parameter of the
    Add Advertising command.
    
    Signed-off-by: Arman Uguray <armansito@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3a6d4e3d68fe..540c07feece7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -156,8 +156,10 @@ struct oob_data {
 };
 
 struct adv_info {
+	struct delayed_work timeout_exp;
 	__u8	instance;
 	__u32	flags;
+	__u16	timeout;
 	__u16	adv_data_len;
 	__u8	adv_data[HCI_MAX_AD_LENGTH];
 	__u16	scan_rsp_len;

commit 203fea0178d7e165dbe834d1bdd9d243018fd5bf
Author: Arman Uguray <armansito@chromium.org>
Date:   Mon Mar 23 15:57:11 2015 -0700

    Bluetooth: Add data structure for advertising instance
    
    This patch introduces a new data structure to represent advertising
    instances that were added using the "Add Advertising" mgmt command.
    Initially an hci_dev structure will support only one of these instances
    at a time, so the current instance is simply stored as a direct member
    of hci_dev.
    
    Signed-off-by: Arman Uguray <armansito@chromium.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b65c53de6a69..3a6d4e3d68fe 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -155,6 +155,15 @@ struct oob_data {
 	u8 rand256[16];
 };
 
+struct adv_info {
+	__u8	instance;
+	__u32	flags;
+	__u16	adv_data_len;
+	__u8	adv_data[HCI_MAX_AD_LENGTH];
+	__u16	scan_rsp_len;
+	__u8	scan_rsp_data[HCI_MAX_AD_LENGTH];
+};
+
 #define HCI_MAX_SHORT_NAME_LENGTH	10
 
 /* Default LE RPA expiry time, 15 minutes */
@@ -364,6 +373,8 @@ struct hci_dev {
 	__u8			scan_rsp_data[HCI_MAX_AD_LENGTH];
 	__u8			scan_rsp_data_len;
 
+	struct adv_info		adv_instance;
+
 	__u8			irk[16];
 	__u32			rpa_timeout;
 	struct delayed_work	rpa_expired;
@@ -550,6 +561,11 @@ static inline void hci_discovery_filter_clear(struct hci_dev *hdev)
 	hdev->discovery.scan_duration = 0;
 }
 
+static inline void adv_info_init(struct hci_dev *hdev)
+{
+	memset(&hdev->adv_instance, 0, sizeof(struct adv_info));
+}
+
 bool hci_discovery_active(struct hci_dev *hdev);
 
 void hci_discovery_set_state(struct hci_dev *hdev, int state);

commit fa4335d71a1408d0112c15874538f3f4e153ba01
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 17 13:48:50 2015 +0200

    Bluetooth: Move generic mgmt command dispatcher to hci_sock.c
    
    The mgmt.c file should be reserved purely for HCI_CHANNEL_CONTROL. The
    mgmt_control() function in it is already completely generic and has a
    single user in hci_sock.c. This patch moves the function there and
    renames it a bit more appropriately to hci_mgmt_cmd() (as it's a command
    dispatcher).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 93e7b2b05a17..b65c53de6a69 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1330,9 +1330,6 @@ void hci_mgmt_chan_unregister(struct hci_mgmt_chan *c);
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 #define DISCOV_LE_RESTART_DELAY		msecs_to_jiffies(200)	/* msec */
 
-int mgmt_control(struct hci_mgmt_chan *chan, struct sock *sk,
-		 struct msghdr *msg, size_t msglen);
-
 int mgmt_new_settings(struct hci_dev *hdev);
 void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);

commit 88b94ce925cb103851f39bfa7e23e09823573d30
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 17 13:48:49 2015 +0200

    Bluetooth: Add hdev_init callback for HCI channels
    
    In order to make the mgmt command handling more generic we can't have a
    direct call to mgmt_init_hdev() from mgmt_control(). This patch adds a
    new callback to struct hci_mgmt_chan. And sets it to point to the
    mgmt_init_hdev() function for the HCI_CHANNEL_CONTROL instance.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e4dc18eed446..93e7b2b05a17 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1305,6 +1305,7 @@ struct hci_mgmt_chan {
 	unsigned short channel;
 	size_t handler_count;
 	const struct hci_mgmt_handler *handlers;
+	void (*hdev_init) (struct sock *sk, struct hci_dev *hdev);
 };
 
 int hci_mgmt_chan_register(struct hci_mgmt_chan *c);

commit aefedc1a4cfe4c874b8a7ac743f9deedc289d9e6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 15 17:08:19 2015 -0700

    Bluetooth: Remove unneeded HCI_CONN_REMOTE_OOB connection flag
    
    The HCI_CONN_REMOTE_OOB connection flag is used to indicate if the
    pairing initiator has provided out-of-band data. However since that
    value is no longer used in any decision making, just remove it.
    
    It is actually unclear what purpose the OOB data present field from
    the HCI IO Capability Response event serves in the first place. If
    either side provided out-of-band data, then that data will be used
    for pairing.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ce94bcb33600..e4dc18eed446 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -596,7 +596,6 @@ enum {
 	HCI_CONN_SC_ENABLED,
 	HCI_CONN_AES_CCM,
 	HCI_CONN_POWER_SAVE,
-	HCI_CONN_REMOTE_OOB,
 	HCI_CONN_FLUSH_KEY,
 	HCI_CONN_ENCRYPT,
 	HCI_CONN_AUTH,

commit a958452aa40c57a0407ecf84ba1bfa31ad532313
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 19:28:06 2015 -0700

    Bluetooth: Use BIT(n) macro instead of manually encoding (1 << n)
    
    The flags for the management command table used manual encoding of
    bits in the form of (1 << n). It is however preferred to use BIT(n)
    macro instead.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3546789c1616..ce94bcb33600 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1289,10 +1289,10 @@ void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
-#define HCI_MGMT_VAR_LEN	(1 << 0)
-#define HCI_MGMT_NO_HDEV	(1 << 1)
-#define HCI_MGMT_UNTRUSTED	(1 << 2)
-#define HCI_MGMT_UNCONFIGURED	(1 << 3)
+#define HCI_MGMT_VAR_LEN	BIT(0)
+#define HCI_MGMT_NO_HDEV	BIT(1)
+#define HCI_MGMT_UNTRUSTED	BIT(2)
+#define HCI_MGMT_UNCONFIGURED	BIT(3)
 
 struct hci_mgmt_handler {
 	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,

commit c91041dc4efff71f29f1dd4c9a4a5e80b841395c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 19:28:01 2015 -0700

    Bluetooth: Add support for untrusted access to management commands
    
    Some management commands are safe to be accessed from any user without
    special permissions. First step for allowing access to any of these
    commands from untrusted application is to mark them accordingly.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 859005c9a8fc..3546789c1616 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1291,7 +1291,8 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
 #define HCI_MGMT_VAR_LEN	(1 << 0)
 #define HCI_MGMT_NO_HDEV	(1 << 1)
-#define HCI_MGMT_UNCONFIGURED	(1 << 2)
+#define HCI_MGMT_UNTRUSTED	(1 << 2)
+#define HCI_MGMT_UNCONFIGURED	(1 << 3)
 
 struct hci_mgmt_handler {
 	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,

commit c08b1a1dba524c1cdef331c1f169db3a1b37bb4c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 19:27:59 2015 -0700

    Bluetooth: Consolidate socket channel sending function back into one
    
    With the introduction of trusted socket flag for control and monitor
    channels, it is now possible to use a single function for sending
    packets to these sockets. And with that consolidate the handling.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d38f6e426e84..859005c9a8fc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1284,9 +1284,7 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_channel(unsigned short channel, struct sk_buff *skb,
-			 struct sock *skip_sk);
-void hci_send_to_flagged_channel(unsigned short channel, struct sk_buff *skb,
-				 int flag);
+			 int flag, struct sock *skip_sk);
 void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);

commit 17711c62915dd62ab83a5a83a64c0d6105d13b6c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 14 19:27:54 2015 -0700

    Bluetooth: Provide hci_send_to_flagged_channel helper function
    
    The hci_send_to_flagged_channel helper function can be used to send
    packets to all channels that have a certain HCI socket flag set.
    
    This is especially useful for managment events that are limited to
    sockets that have first enabled certain functionality. This allows
    for filtering of events without confusing existing users.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6afbf5b014a1..d38f6e426e84 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1285,6 +1285,8 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_channel(unsigned short channel, struct sk_buff *skb,
 			 struct sock *skip_sk);
+void hci_send_to_flagged_channel(unsigned short channel, struct sk_buff *skb,
+				 int flag);
 void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);

commit b7cb93e52839ee44959adabc17c2a17422e6bd4b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 10:20:35 2015 -0700

    Bluetooth: Merge hdev->dbg_flags fields into hdev->dev_flags
    
    With the extension of hdev->dev_flags utilizing a bitmap now, the space
    is no longer restricted. Merge the hdev->dbg_flags into hdev->dev_flags
    to save space on 64-bit architectures. On 32-bit architectures no size
    reduction happens.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 889a489d913f..6afbf5b014a1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -353,7 +353,6 @@ struct hci_dev {
 
 	struct rfkill		*rfkill;
 
-	unsigned long		dbg_flags;
 	DECLARE_BITMAP(dev_flags, __HCI_NUM_FLAGS);
 
 	struct delayed_work	le_scan_disable;

commit eacb44dff98559d4682072c0061e1ecb63687e9c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 09:04:17 2015 -0700

    Bluetooth: Use DECLARE_BITMAP for hdev->dev_flags field
    
    The hdev->dev_flags field has outgrown itself on 32-bit systems. So
    instead of hacking around it, switch to using DECLARE_BITMAP.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6db1333a114f..889a489d913f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -354,7 +354,7 @@ struct hci_dev {
 	struct rfkill		*rfkill;
 
 	unsigned long		dbg_flags;
-	unsigned long		dev_flags;
+	DECLARE_BITMAP(dev_flags, __HCI_NUM_FLAGS);
 
 	struct delayed_work	le_scan_disable;
 	struct delayed_work	le_scan_restart;
@@ -502,14 +502,20 @@ extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern struct mutex hci_cb_list_lock;
 
-#define hci_dev_set_flag(hdev, nr)    set_bit((nr), &(hdev)->dev_flags)
-#define hci_dev_clear_flag(hdev, nr)  clear_bit((nr), &(hdev)->dev_flags)
-#define hci_dev_change_flag(hdev, nr) change_bit((nr), &(hdev)->dev_flags)
-#define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
-
-#define hci_dev_test_and_set_flag(hdev, nr)    test_and_set_bit((nr), &(hdev)->dev_flags)
-#define hci_dev_test_and_clear_flag(hdev, nr)  test_and_clear_bit((nr), &(hdev)->dev_flags)
-#define hci_dev_test_and_change_flag(hdev, nr) test_and_change_bit((nr), &(hdev)->dev_flags)
+#define hci_dev_set_flag(hdev, nr)             set_bit((nr), (hdev)->dev_flags)
+#define hci_dev_clear_flag(hdev, nr)           clear_bit((nr), (hdev)->dev_flags)
+#define hci_dev_change_flag(hdev, nr)          change_bit((nr), (hdev)->dev_flags)
+#define hci_dev_test_flag(hdev, nr)            test_bit((nr), (hdev)->dev_flags)
+#define hci_dev_test_and_set_flag(hdev, nr)    test_and_set_bit((nr), (hdev)->dev_flags)
+#define hci_dev_test_and_clear_flag(hdev, nr)  test_and_clear_bit((nr), (hdev)->dev_flags)
+#define hci_dev_test_and_change_flag(hdev, nr) test_and_change_bit((nr), (hdev)->dev_flags)
+
+#define hci_dev_clear_volatile_flags(hdev)			\
+	do {							\
+		hci_dev_clear_flag(hdev, HCI_LE_SCAN);		\
+		hci_dev_clear_flag(hdev, HCI_LE_ADV);		\
+		hci_dev_clear_flag(hdev, HCI_PERIODIC_INQ);	\
+	} while (0)
 
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit 238be788fcb75870661ec165dc90f2a2674e7fcb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:06 2015 -0700

    Bluetooth: Introduce hci_dev_test_and_set_flag helper macro
    
    Instead of manually coding test_and_set_bit on hdev->dev_flags all the
    time, use hci_dev_test_and_set_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4b7632b15051..6db1333a114f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -507,6 +507,7 @@ extern struct mutex hci_cb_list_lock;
 #define hci_dev_change_flag(hdev, nr) change_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
 
+#define hci_dev_test_and_set_flag(hdev, nr)    test_and_set_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_and_clear_flag(hdev, nr)  test_and_clear_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_and_change_flag(hdev, nr) test_and_change_bit((nr), &(hdev)->dev_flags)
 

commit a69d89272698d1c31ccb78348562af6461cf1eb7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:05 2015 -0700

    Bluetooth: Introduce hci_dev_test_and_clear_flag helper macro
    
    Instead of manually coding test_and_clear_bit on hdev->dev_flags all the
    time, use hci_dev_test_and_clear_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cd2682c64a4c..4b7632b15051 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -507,6 +507,7 @@ extern struct mutex hci_cb_list_lock;
 #define hci_dev_change_flag(hdev, nr) change_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
 
+#define hci_dev_test_and_clear_flag(hdev, nr)  test_and_clear_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_and_change_flag(hdev, nr) test_and_change_bit((nr), &(hdev)->dev_flags)
 
 /* ----- HCI interface to upper protocols ----- */

commit 516018a9c057a7c179dd6b4df917a6f5d43b3547
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:04 2015 -0700

    Bluetooth: Introduce hci_dev_test_and_change_flag helper macro
    
    Instead of manually coding test_and_change_bit on hdev->dev_flags all the
    time, use hci_dev_test_and_change_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 92b2148702e6..cd2682c64a4c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -507,6 +507,8 @@ extern struct mutex hci_cb_list_lock;
 #define hci_dev_change_flag(hdev, nr) change_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
 
+#define hci_dev_test_and_change_flag(hdev, nr) test_and_change_bit((nr), &(hdev)->dev_flags)
+
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int l2cap_disconn_ind(struct hci_conn *hcon);

commit ce05d603af7c9b5be66a1f3358443e20e2a2ae7a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:03 2015 -0700

    Bluetooth: Introduce hci_dev_change_flag helper macro
    
    Instead of manually coding change_bit on hdev->dev_flags all the time,
    use hci_dev_change_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 535b23c73c92..92b2148702e6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -504,6 +504,7 @@ extern struct mutex hci_cb_list_lock;
 
 #define hci_dev_set_flag(hdev, nr)    set_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_clear_flag(hdev, nr)  clear_bit((nr), &(hdev)->dev_flags)
+#define hci_dev_change_flag(hdev, nr) change_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
 
 /* ----- HCI interface to upper protocols ----- */

commit a358dc11d80ecaca443aa1fd2fd9d4f3425922e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:02 2015 -0700

    Bluetooth: Introduce hci_dev_clear_flag helper macro
    
    Instead of manually coding clear_bit on hdev->dev_flags all the time,
    use hci_dev_clear_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bc2a7e918da7..535b23c73c92 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -503,6 +503,7 @@ extern rwlock_t hci_dev_list_lock;
 extern struct mutex hci_cb_list_lock;
 
 #define hci_dev_set_flag(hdev, nr)    set_bit((nr), &(hdev)->dev_flags)
+#define hci_dev_clear_flag(hdev, nr)  clear_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
 
 /* ----- HCI interface to upper protocols ----- */

commit a1536da255f16f42b8f069b2769134b32558b265
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:01 2015 -0700

    Bluetooth: Introduce hci_dev_set_flag helper macro
    
    Instead of manually coding set_bit on hdev->dev_flags all the time,
    use hci_dev_set_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 05e95a75aba5..bc2a7e918da7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -502,6 +502,7 @@ extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern struct mutex hci_cb_list_lock;
 
+#define hci_dev_set_flag(hdev, nr)    set_bit((nr), &(hdev)->dev_flags)
 #define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
 
 /* ----- HCI interface to upper protocols ----- */

commit d7a5a11d7fa80beb43d5f7cb421c86f9b4d21200
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:00 2015 -0700

    Bluetooth: Introduce hci_dev_test_flag helper macro
    
    Instead of manually coding test_bit on hdev->dev_flags all the time,
    use hci_dev_test_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5cc5a192359d..05e95a75aba5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -502,6 +502,8 @@ extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern struct mutex hci_cb_list_lock;
 
+#define hci_dev_test_flag(hdev, nr)   test_bit((nr), &(hdev)->dev_flags)
+
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int l2cap_disconn_ind(struct hci_conn *hcon);
@@ -598,14 +600,14 @@ enum {
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	return test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&
+	return hci_dev_test_flag(hdev, HCI_SSP_ENABLED) &&
 	       test_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 }
 
 static inline bool hci_conn_sc_enabled(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	return test_bit(HCI_SC_ENABLED, &hdev->dev_flags) &&
+	return hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&
 	       test_bit(HCI_CONN_SC_ENABLED, &conn->flags);
 }
 
@@ -1025,10 +1027,10 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))
 #define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))
 
-#define hdev_is_powered(hdev) (test_bit(HCI_UP, &hdev->flags) && \
-				!test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
-#define bredr_sc_enabled(dev) (lmp_sc_capable(dev) && \
-			       test_bit(HCI_SC_ENABLED, &(dev)->dev_flags))
+#define hdev_is_powered(dev)   (test_bit(HCI_UP, &(dev)->flags) && \
+				!hci_dev_test_flag(dev, HCI_AUTO_OFF))
+#define bredr_sc_enabled(dev)  (lmp_sc_capable(dev) && \
+				hci_dev_test_flag(dev, HCI_SC_ENABLED))
 
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01

commit 55e76b38986a61259f3079afd0f9a865651a34fe
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 10 22:34:40 2015 +0200

    Bluetooth: Add 'Already Paired' error for Pair Device command
    
    To make the behavior predictable when attempting to pair with a device
    for which we already have a Link Key or Long Term Key, this patch adds a
    new 'Already Paired' error which gets sent in such a scenario.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index afc641c5e55c..5cc5a192359d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -967,6 +967,8 @@ struct smp_irk *hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type);
 void hci_smp_irks_clear(struct hci_dev *hdev);
 
+bool hci_bdaddr_is_paired(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+
 void hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
 					  bdaddr_t *bdaddr, u8 bdaddr_type);

commit b9a245fb12315f8c6528b29a991a004859c982d5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Mar 6 21:08:52 2015 +0200

    Bluetooth: Move all mgmt command quirks to handler table
    
    In order to completely generalize the mgmt command handling we need to
    move away command-specific information from mgmt_control() into the
    actual command table. This patch adds a new 'flags' field to the handler
    entries which can now contain the following command specific
    information:
    
     - Command takes variable length parameters
     - Command doesn't target any specific HCI device
     - Command can be sent when the HCI device is unconfigured
    
    After this the mgmt_control() function is completely generic and can
    potentially be reused by new HCI channels.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b2a183d201b7..afc641c5e55c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1273,11 +1273,15 @@ void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
+#define HCI_MGMT_VAR_LEN	(1 << 0)
+#define HCI_MGMT_NO_HDEV	(1 << 1)
+#define HCI_MGMT_UNCONFIGURED	(1 << 2)
+
 struct hci_mgmt_handler {
 	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,
 		     u16 data_len);
-	bool var_len;
 	size_t data_len;
+	unsigned long flags;
 };
 
 struct hci_mgmt_chan {

commit 6d785aa345f525e1fdf098b7c590168f0b00f3f1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Mar 6 21:08:51 2015 +0200

    Bluetooth: Convert mgmt to use HCI chan registration API
    
    This patch converts the existing mgmt code to use the newly introduced
    generic API for registering HCI channels with mgmt-like semantics.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0c84d48e5517..b2a183d201b7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1309,7 +1309,9 @@ void hci_mgmt_chan_unregister(struct hci_mgmt_chan *c);
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 #define DISCOV_LE_RESTART_DELAY		msecs_to_jiffies(200)	/* msec */
 
-int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
+int mgmt_control(struct hci_mgmt_chan *chan, struct sock *sk,
+		 struct msghdr *msg, size_t msglen);
+
 int mgmt_new_settings(struct hci_dev *hdev);
 void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);

commit 801c1e8da57499a9922223ee1882b2b59debd47c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Mar 6 21:08:50 2015 +0200

    Bluetooth: Add mgmt HCI channel registration API
    
    This patch adds an API for registering HCI channels with mgmt-like
    semantics. For now the only user will be HCI_CHANNEL_CONTROL, but e.g.
    6lowpan is intended to use this as well in the future.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 15c761c1f82a..0c84d48e5517 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1273,6 +1273,23 @@ void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
+struct hci_mgmt_handler {
+	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,
+		     u16 data_len);
+	bool var_len;
+	size_t data_len;
+};
+
+struct hci_mgmt_chan {
+	struct list_head list;
+	unsigned short channel;
+	size_t handler_count;
+	const struct hci_mgmt_handler *handlers;
+};
+
+int hci_mgmt_chan_register(struct hci_mgmt_chan *c);
+void hci_mgmt_chan_unregister(struct hci_mgmt_chan *c);
+
 /* Management interface */
 #define DISCOV_TYPE_BREDR		(BIT(BDADDR_BREDR))
 #define DISCOV_TYPE_LE			(BIT(BDADDR_LE_PUBLIC) | \

commit 82f8b651a94d5c7090563fe55cfdb286c461a16c
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Wed Mar 4 16:24:26 2015 -0800

    Bluetooth: fix service discovery behaviour for empty uuids filter
    
    This patch fixes service discovery behaviour, when provided uuid filter
    is empty and HCI_QUIRK_STRICT_DUPLICATE_FILTER is set. Before this
    patch, empty uuid filter was unable to trigger scan restart, and that
    caused inconsistent behaviour in applications.
    
    Example: two DBus clients call BlueZ, one to find all devices with
    service abcd, second to find all devices with rssi smaller than -90.
    Sum of those filters, that is passed to mgmt_service_scan is empty
    filter, with no rssi or uuids set.
    That caused kernel not to restart scan when quirk was set.
    That was inconsistent with what happen when there's only one of those
    two filters set (scan is restarted and reports devices).
    
    To fix that, new variable hdev->discovery.result_filtering was
    introduced. It can indicate that filtered scan is running, no matter
    what uuid or rssi filter is set.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index acec9140c3f9..15c761c1f82a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -76,6 +76,7 @@ struct discovery_state {
 	u8			last_adv_data[HCI_MAX_AD_LENGTH];
 	u8			last_adv_data_len;
 	bool			report_invalid_rssi;
+	bool			result_filtering;
 	s8			rssi;
 	u16			uuid_count;
 	u8			(*uuids)[16];
@@ -525,6 +526,7 @@ static inline void discovery_init(struct hci_dev *hdev)
 
 static inline void hci_discovery_filter_clear(struct hci_dev *hdev)
 {
+	hdev->discovery.result_filtering = false;
 	hdev->discovery.report_invalid_rssi = true;
 	hdev->discovery.rssi = HCI_RSSI_INVALID;
 	hdev->discovery.uuid_count = 0;

commit 4cd3928a8bee83d86fb3865bb243ab2ff1dd0eb6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 27 10:11:13 2015 +0200

    Bluetooth: Update New CSRK event to match latest specification
    
    The 'master' parameter of the New CSRK event was recently renamed to
    'type', with the old values kept for backwards compatibility as
    unauthenticated local/remote keys. This patch updates the code to take
    into account the two new (authenticated) values and ensures they get
    used based on the security level of the connection that the respective
    keys get distributed over.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a831c8ad10f1..acec9140c3f9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -108,7 +108,7 @@ struct bt_uuid {
 struct smp_csrk {
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
-	u8 master;
+	u8 type;
 	u8 val[16];
 };
 

commit 7129069e84056ba28954550beb208b2645863299
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 20 13:26:23 2015 +0200

    Bluetooth: Rename hci_send_to_control to hci_send_to_channel
    
    The hci_send_to_control() can be made more general purpose with a small
    change of passing the desired HCI channel as a parameter to it. This
    allows using it for the monitor channel as well as e.g. 6lowpan in the
    future.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a7bf77384464..a831c8ad10f1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1265,7 +1265,8 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
-void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk);
+void hci_send_to_channel(unsigned short channel, struct sk_buff *skb,
+			 struct sock *skip_sk);
 void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);

commit 3a6d576be9fe02b0c3ffa89ef6eac048e14eec84
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 18 14:53:58 2015 +0200

    Bluetooth: Convert disconn_cfm to be triggered through hci_cb
    
    This patch moves all the disconn_cfm callbacks to be based on the hci_cb
    list. This means making l2cap_disconn_cfm private to l2cap_core.c and
    sco_conn_cb private to sco.c respectively. Since the hci_conn type
    filtering isn't done any more on the wrapper level the callbacks
    themselves need to check that they were passed a relevant type of
    connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0f00f0e9f257..a7bf77384464 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -504,11 +504,9 @@ extern struct mutex hci_cb_list_lock;
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int l2cap_disconn_ind(struct hci_conn *hcon);
-void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
 int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
 
 int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
-void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
 int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 /* ----- Inquiry cache ----- */
@@ -1056,32 +1054,6 @@ static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 	return l2cap_disconn_ind(conn);
 }
 
-static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
-{
-	switch (conn->type) {
-	case ACL_LINK:
-	case LE_LINK:
-		l2cap_disconn_cfm(conn, reason);
-		break;
-
-	case SCO_LINK:
-	case ESCO_LINK:
-		sco_disconn_cfm(conn, reason);
-		break;
-
-	/* L2CAP would be handled for BREDR chan */
-	case AMP_LINK:
-		break;
-
-	default:
-		BT_ERR("unknown link type %d", conn->type);
-		break;
-	}
-
-	if (conn->disconn_cfm_cb)
-		conn->disconn_cfm_cb(conn, reason);
-}
-
 /* ----- HCI callbacks ----- */
 struct hci_cb {
 	struct list_head list;
@@ -1089,6 +1061,7 @@ struct hci_cb {
 	char *name;
 
 	void (*connect_cfm)	(struct hci_conn *conn, __u8 status);
+	void (*disconn_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
 								__u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
@@ -1110,6 +1083,21 @@ static inline void hci_connect_cfm(struct hci_conn *conn, __u8 status)
 		conn->connect_cfm_cb(conn, status);
 }
 
+static inline void hci_disconn_cfm(struct hci_conn *conn, __u8 reason)
+{
+	struct hci_cb *cb;
+
+	mutex_lock(&hci_cb_list_lock);
+	list_for_each_entry(cb, &hci_cb_list, list) {
+		if (cb->disconn_cfm)
+			cb->disconn_cfm(conn, reason);
+	}
+	mutex_unlock(&hci_cb_list_lock);
+
+	if (conn->disconn_cfm_cb)
+		conn->disconn_cfm_cb(conn, reason);
+}
+
 static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct hci_cb *cb;

commit 539c496d88f7f96d42abde4e9d901c8f8167d615
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 18 14:53:57 2015 +0200

    Bluetooth: Convert connect_cfm to be triggered through hci_cb
    
    This patch moves all the connect_cfm callbacks to be based on the hci_cb
    list. This means making l2cap_connect_cfm private to l2cap_core.c and
    sco_connect_cb private to sco.c respectively. Since the hci_conn type
    filtering isn't done any more on the wrapper level the callbacks
    themselves need to check that they were passed a relevant type of
    connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4a2db5e62699..0f00f0e9f257 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -503,13 +503,11 @@ extern struct mutex hci_cb_list_lock;
 
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
-void l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
 int l2cap_disconn_ind(struct hci_conn *hcon);
 void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
 int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
 
 int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
-void sco_connect_cfm(struct hci_conn *hcon, __u8 status);
 void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
 int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
@@ -1050,28 +1048,6 @@ static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
 	}
 }
 
-static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
-{
-	switch (conn->type) {
-	case ACL_LINK:
-	case LE_LINK:
-		l2cap_connect_cfm(conn, status);
-		break;
-
-	case SCO_LINK:
-	case ESCO_LINK:
-		sco_connect_cfm(conn, status);
-		break;
-
-	default:
-		BT_ERR("unknown link type %d", conn->type);
-		break;
-	}
-
-	if (conn->connect_cfm_cb)
-		conn->connect_cfm_cb(conn, status);
-}
-
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
 	if (conn->type != ACL_LINK && conn->type != LE_LINK)
@@ -1112,12 +1088,28 @@ struct hci_cb {
 
 	char *name;
 
+	void (*connect_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
 								__u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
 
+static inline void hci_connect_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct hci_cb *cb;
+
+	mutex_lock(&hci_cb_list_lock);
+	list_for_each_entry(cb, &hci_cb_list, list) {
+		if (cb->connect_cfm)
+			cb->connect_cfm(conn, status);
+	}
+	mutex_unlock(&hci_cb_list_lock);
+
+	if (conn->connect_cfm_cb)
+		conn->connect_cfm_cb(conn, status);
+}
+
 static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct hci_cb *cb;

commit 354fe804edb29625eee6dd7b1f3c72b43392704d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 18 14:53:56 2015 +0200

    Bluetooth: Convert L2CAP security callback to use hci_cb
    
    There's no reason to have the custom hci_proto_auth/encrypt_cfm helpers
    when the hci_cb list works equally well. This patch adds L2CAP to the
    hci_cb list and makes l2cap_security_cfm a private function of
    l2cap_core.c.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 137a18226975..4a2db5e62699 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -506,7 +506,6 @@ int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 void l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
 int l2cap_disconn_ind(struct hci_conn *hcon);
 void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
-int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
 int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
 
 int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
@@ -1107,35 +1106,6 @@ static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 		conn->disconn_cfm_cb(conn, reason);
 }
 
-static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
-{
-	__u8 encrypt;
-
-	if (conn->type != ACL_LINK && conn->type != LE_LINK)
-		return;
-
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
-		return;
-
-	encrypt = test_bit(HCI_CONN_ENCRYPT, &conn->flags) ? 0x01 : 0x00;
-	l2cap_security_cfm(conn, status, encrypt);
-
-	if (conn->security_cfm_cb)
-		conn->security_cfm_cb(conn, status);
-}
-
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
-								__u8 encrypt)
-{
-	if (conn->type != ACL_LINK && conn->type != LE_LINK)
-		return;
-
-	l2cap_security_cfm(conn, status, encrypt);
-
-	if (conn->security_cfm_cb)
-		conn->security_cfm_cb(conn, status);
-}
-
 /* ----- HCI callbacks ----- */
 struct hci_cb {
 	struct list_head list;
@@ -1153,8 +1123,6 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 	struct hci_cb *cb;
 	__u8 encrypt;
 
-	hci_proto_auth_cfm(conn, status);
-
 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
@@ -1166,6 +1134,9 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 			cb->security_cfm(conn, status, encrypt);
 	}
 	mutex_unlock(&hci_cb_list_lock);
+
+	if (conn->security_cfm_cb)
+		conn->security_cfm_cb(conn, status);
 }
 
 static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
@@ -1179,14 +1150,15 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 	if (conn->pending_sec_level > conn->sec_level)
 		conn->sec_level = conn->pending_sec_level;
 
-	hci_proto_encrypt_cfm(conn, status, encrypt);
-
 	mutex_lock(&hci_cb_list_lock);
 	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
 	mutex_unlock(&hci_cb_list_lock);
+
+	if (conn->security_cfm_cb)
+		conn->security_cfm_cb(conn, status);
 }
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)

commit fba7ecf09bc458b15f9d578e4213c8c349f9592d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 18 14:53:55 2015 +0200

    Bluetooth: Convert hci_cb_list_lock to a mutex
    
    We'll soon need to be able to sleep inside the loops that iterate the
    hci_cb list, so neither a spinlock, rwlock or rcu are usable. This patch
    changes the lock to a mutex which permits sleeping while holding the
    lock.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5f1ca3359c1a..137a18226975 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -499,7 +499,7 @@ struct hci_conn_params {
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
-extern rwlock_t hci_cb_list_lock;
+extern struct mutex hci_cb_list_lock;
 
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
@@ -1160,12 +1160,12 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 
 	encrypt = test_bit(HCI_CONN_ENCRYPT, &conn->flags) ? 0x01 : 0x00;
 
-	read_lock(&hci_cb_list_lock);
+	mutex_lock(&hci_cb_list_lock);
 	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock(&hci_cb_list_lock);
+	mutex_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
@@ -1181,24 +1181,24 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
-	read_lock(&hci_cb_list_lock);
+	mutex_lock(&hci_cb_list_lock);
 	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock(&hci_cb_list_lock);
+	mutex_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct hci_cb *cb;
 
-	read_lock(&hci_cb_list_lock);
+	mutex_lock(&hci_cb_list_lock);
 	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->key_change_cfm)
 			cb->key_change_cfm(conn, status);
 	}
-	read_unlock(&hci_cb_list_lock);
+	mutex_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
@@ -1206,12 +1206,12 @@ static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
 {
 	struct hci_cb *cb;
 
-	read_lock(&hci_cb_list_lock);
+	mutex_lock(&hci_cb_list_lock);
 	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->role_switch_cfm)
 			cb->role_switch_cfm(conn, status, role);
 	}
-	read_unlock(&hci_cb_list_lock);
+	mutex_unlock(&hci_cb_list_lock);
 }
 
 static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)

commit a44fecbd52a4d9c36f07eb2161c153047d8765d4
Author: Tedd Ho-Jeong An <tedd.an@intel.com>
Date:   Fri Feb 13 09:20:50 2015 -0800

    Bluetooth: Add shutdown callback before closing the device
    
    This callback allows a vendor to send the vendor specific commands
    before cloing the hci interface.
    
    Signed-off-by: Tedd Ho-Jeong An <tedd.an@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 52863c3e0b13..5f1ca3359c1a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -373,6 +373,7 @@ struct hci_dev {
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
 	int (*setup)(struct hci_dev *hdev);
+	int (*shutdown)(struct hci_dev *hdev);
 	int (*send)(struct hci_dev *hdev, struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	void (*hw_error)(struct hci_dev *hdev, u8 code);

commit 4b0e0ceddf085a89173805cace44cd3c4c9d9d77
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Sun Feb 1 23:07:55 2015 -0800

    Bluetooth: Add restarting to service discovery
    
    When using LE_SCAN_FILTER_DUP_ENABLE, some controllers would send
    advertising report from each LE device only once. That means that we
    don't get any updates on RSSI value, and makes Service Discovery very
    slow. This patch adds restarting scan when in Service Discovery, and
    device with filtered uuid is found, but it's not in RSSI range to send
    event yet. This way if device moves into range, we will quickly get RSSI
    update.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d3a232be9d9b..52863c3e0b13 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1334,6 +1334,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 #define DISCOV_INTERLEAVED_TIMEOUT	5120	/* msec */
 #define DISCOV_INTERLEAVED_INQUIRY_LEN	0x04
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
+#define DISCOV_LE_RESTART_DELAY		msecs_to_jiffies(200)	/* msec */
 
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_new_settings(struct hci_dev *hdev);

commit 2d28cfe7aada495f87bb439151e9bcc86998fb6d
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Sun Feb 1 23:07:54 2015 -0800

    Bluetooth: Add le_scan_restart work for LE scan restarting
    
    Currently there is no way to restart le scan, and it's needed in
    service scan method. The way it work: it disable, and then enable le
    scan on controller.
    
    During the restart, we must remember when the scan was started, and
    it's duration, to later re-schedule the le_scan_disable work, that was
    stopped during the stop scan phase.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a37e10f4e2b3..d3a232be9d9b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -79,6 +79,8 @@ struct discovery_state {
 	s8			rssi;
 	u16			uuid_count;
 	u8			(*uuids)[16];
+	unsigned long		scan_start;
+	unsigned long		scan_duration;
 };
 
 struct hci_conn_hash {
@@ -354,6 +356,7 @@ struct hci_dev {
 	unsigned long		dev_flags;
 
 	struct delayed_work	le_scan_disable;
+	struct delayed_work	le_scan_restart;
 
 	__s8			adv_tx_power;
 	__u8			adv_data[HCI_MAX_AD_LENGTH];
@@ -531,6 +534,8 @@ static inline void hci_discovery_filter_clear(struct hci_dev *hdev)
 	hdev->discovery.uuid_count = 0;
 	kfree(hdev->discovery.uuids);
 	hdev->discovery.uuids = NULL;
+	hdev->discovery.scan_start = 0;
+	hdev->discovery.scan_duration = 0;
 }
 
 bool hci_discovery_active(struct hci_dev *hdev);

commit f7697b1602d13ef80779caf23d13fa1511193144
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 30 23:20:55 2015 -0800

    Bluetooth: Store OOB data present value for each set of remote OOB data
    
    Instead of doing complex calculation every time the OOB data is used,
    just calculate the OOB data present value and store it with the OOB
    data raw values.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1780f1681ecf..a37e10f4e2b3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -145,6 +145,7 @@ struct oob_data {
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
+	u8 present;
 	u8 hash192[16];
 	u8 rand192[16];
 	u8 hash256[16];

commit c7741d16a57cbf97eebe53f27e8216b1ff20e20c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 28 11:09:55 2015 -0800

    Bluetooth: Perform a power cycle when receiving hardware error event
    
    When receiving a HCI Hardware Error event, the controller should be
    assumed to be non-functional until issuing a HCI Reset command.
    
    The Bluetooth hardware errors are vendor specific and so add a
    new hdev->hw_error callback that drivers can provide to run extra
    code to handle the hardware error.
    
    After completing the vendor specific error handling perform a full
    reset of the Bluetooth stack by closing and re-opening the transport.
    
    Based-on-patch-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0f5e59f1e3cb..1780f1681ecf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -232,6 +232,7 @@ struct hci_dev {
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;
 	__u8		ssp_debug_mode;
+	__u8		hw_error_code;
 	__u32		clock;
 
 	__u16		devid_source;
@@ -293,6 +294,7 @@ struct hci_dev {
 
 	struct work_struct	power_on;
 	struct delayed_work	power_off;
+	struct work_struct	error_reset;
 
 	__u16			discov_timeout;
 	struct delayed_work	discov_off;
@@ -369,6 +371,7 @@ struct hci_dev {
 	int (*setup)(struct hci_dev *hdev);
 	int (*send)(struct hci_dev *hdev, struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
+	void (*hw_error)(struct hci_dev *hdev, u8 code);
 	int (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 };
 

commit a1443f5a273713d4bfda360e45aa6e1d14fe7324
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jan 23 15:42:46 2015 +0200

    Bluetooth: Convert Set SC to use HCI Request
    
    This patch converts the Set Secure Connection HCI handling to use a HCI
    request instead of using a hard-coded callback in hci_event.c. This e.g.
    ensures that we don't clear the flags incorrectly if something goes
    wrong with the power up process (not related to a mgmt Set SC command).
    
    The code can also be simplified a bit since only one pending Set SC
    command is allowed, i.e. mgmt_pending_foreach usage is not needed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7777124bff55..0f5e59f1e3cb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1369,7 +1369,6 @@ int mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_auth_failed(struct hci_conn *conn, u8 status);
 void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
-void mgmt_sc_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);

commit 0026b6551b51a9520b912f41b8d447b89a825f5a
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Jan 4 16:55:14 2015 +0100

    Bluetooth: Remove unused function
    
    Remove the function hci_conn_change_link_key() that is not used anywhere.
    
    This was partially found by using a static code analysis program called
    cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1f21fe48b38e..7777124bff55 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -781,7 +781,6 @@ int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
 		      bool initiator);
-int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);

commit c2f0f979276fc4911cef5da2fc113f0daeda3ebc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jan 12 09:21:25 2015 -0800

    Bluetooth: Handle command complete event for HCI Read Stored Link Keys
    
    When the HCI Read Stored Link Keys command completes it gives useful
    information of the current stored keys and maximum keys a controller
    can actually store. So process this event and store these information
    in hci_dev structure.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 89f4e3c8a097..1f21fe48b38e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -205,6 +205,8 @@ struct hci_dev {
 	__u16		lmp_subver;
 	__u16		voice_setting;
 	__u8		num_iac;
+	__u8		stored_max_keys;
+	__u8		stored_num_keys;
 	__u8		io_capability;
 	__s8		inq_tx_power;
 	__u16		page_scan_interval;

commit 05b3c3e7905d00a1fe2e9184fdd9b5eac427c736
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Dec 31 14:43:18 2014 -0800

    Bluetooth: Remove no longer needed force_sc_support debugfs option
    
    The force_sc_support debugfs option was introduced to easily work with
    pre-production Bluetooth 4.1 silicon. This option is no longer needed
    since controllers supporting BR/EDR Secure Connections feature are now
    available.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3e7e5110f298..89f4e3c8a097 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1017,8 +1017,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 
 #define hdev_is_powered(hdev) (test_bit(HCI_UP, &hdev->flags) && \
 				!test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
-#define bredr_sc_enabled(dev) ((lmp_sc_capable(dev) || \
-				test_bit(HCI_FORCE_SC, &(dev)->dbg_flags)) && \
+#define bredr_sc_enabled(dev) (lmp_sc_capable(dev) && \
 			       test_bit(HCI_SC_ENABLED, &(dev)->dev_flags))
 
 /* ----- HCI protocols ----- */

commit 23b9ceb74f8e46bddd61a1e2afd9317221be74b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 17:13:41 2014 +0100

    Bluetooth: Create debugfs directory for each connection handle
    
    For every internal representation of a Bluetooth connection which is
    identified by hci_conn, create a debugfs directory with the handle
    number as directory name.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f20f6bd668bd..3e7e5110f298 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -440,6 +440,7 @@ struct hci_conn {
 	struct delayed_work le_conn_timeout;
 
 	struct device	dev;
+	struct dentry	*debugfs;
 
 	struct hci_dev	*hdev;
 	void		*l2cap_data;

commit a8e1bfaa55cf8ac4e419a09bdda5bb45bcd8f985
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 16:28:40 2014 +0100

    Bluetooth: Store default and maximum LE data length settings
    
    When the controller supports the LE Data Length Extension feature, the
    default and maximum data length are read and now stored.
    
    For backwards compatibility all values are initialized to the data
    length values from Bluetooth 4.1 and earlier specifications.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 79724c87ab00..f20f6bd668bd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -220,6 +220,12 @@ struct hci_dev {
 	__u16		le_conn_max_interval;
 	__u16		le_conn_latency;
 	__u16		le_supv_timeout;
+	__u16		le_def_tx_len;
+	__u16		le_def_tx_time;
+	__u16		le_max_tx_len;
+	__u16		le_max_tx_time;
+	__u16		le_max_rx_len;
+	__u16		le_max_rx_time;
 	__u16		discov_interleaved_timeout;
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;

commit 5a154e6f71dfd41c7b5cf96a13c83fca91e7df7f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Dec 19 22:26:02 2014 +0200

    Bluetooth: Fix Add Device to wait for HCI before sending cmd_complete
    
    This patch updates the Add Device mgmt command handler to use a
    hci_request to wait for HCI command completion before notifying user
    space of the mgmt command completion. To do this we need to add an extra
    hci_request parameter to the hci_conn_params_set function. Since this
    function has no other users besides mgmt.c it's moved there as a static
    function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8eccdf029500..79724c87ab00 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -920,8 +920,6 @@ struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);
 struct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,
 					    bdaddr_t *addr, u8 addr_type);
-int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
-			u8 auto_connect);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear_all(struct hci_dev *hdev);
 void hci_conn_params_clear_disabled(struct hci_dev *hdev);

commit 2cf22218b00f46f93b39a9355b830e9e8e4fd077
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Dec 19 22:26:00 2014 +0200

    Bluetooth: Add hci_request support for hci_update_background_scan
    
    Many places using hci_update_background_scan() try to synchronize
    whatever they're doing with the help of hci_request callbacks. However,
    since the hci_update_background_scan() function hasn't so far accepted a
    hci_request pointer any commands triggered by it have been left out by
    the synchronization. This patch modifies the API in a similar way as was
    done for hci_update_page_scan, i.e. there's a variant that takes a
    hci_request and another one that takes a hci_dev.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 93066f70f8ab..8eccdf029500 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -930,8 +930,6 @@ struct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,
 						  bdaddr_t *addr,
 						  u8 addr_type);
 
-void hci_update_background_scan(struct hci_dev *hdev);
-
 void hci_uuids_clear(struct hci_dev *hdev);
 
 void hci_link_keys_clear(struct hci_dev *hdev);

commit 0857dd3bed62d8f905f61a399d1ed76464b5270f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Dec 19 13:40:20 2014 +0200

    Bluetooth: Split hci_request helpers to hci_request.[ch]
    
    None of the hci_request related things in net/bluetooth/hci_core.h are
    needed anywhere outside of the core bluetooth module. This patch creates
    a new net/bluetooth/hci_request.c file with its corresponding h-file and
    moves the functionality there from hci_core.c and hci_core.h.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 664451a64d72..93066f70f8ab 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1284,31 +1284,8 @@ static inline int hci_check_conn_params(u16 min, u16 max, u16 latency,
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 
-struct hci_request {
-	struct hci_dev		*hdev;
-	struct sk_buff_head	cmd_q;
-
-	/* If something goes wrong when building the HCI request, the error
-	 * value is stored in this field.
-	 */
-	int			err;
-};
-
-void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
-int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
-void hci_req_add(struct hci_request *req, u16 opcode, u32 plen,
-		 const void *param);
-void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen,
-		    const void *param, u8 event);
-void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 bool hci_req_pending(struct hci_dev *hdev);
 
-void hci_req_add_le_scan_disable(struct hci_request *req);
-void hci_req_add_le_passive_scan(struct hci_request *req);
-
-void hci_update_page_scan(struct hci_dev *hdev);
-void __hci_update_page_scan(struct hci_request *req);
-
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);
 struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,
@@ -1418,8 +1395,6 @@ u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
 							__u8 ltk[16]);
 
-int hci_update_random_address(struct hci_request *req, bool require_privacy,
-			      u8 *own_addr_type);
 void hci_copy_identity_address(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			       u8 *bdaddr_type);
 

commit 1d2dc5b7b32393bb2d818e0de82a66b1a654d329
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Dec 19 13:40:19 2014 +0200

    Bluetooth: Split hci_update_page_scan into two functions
    
    To keep the parameter list and its semantics clear it makes sense to
    split the hci_update_page_scan function into two separate functions: one
    taking a hci_dev and another taking a hci_request. The one taking a
    hci_dev constructs its own hci_request and then calls the other
    function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3c7827005c25..664451a64d72 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1306,7 +1306,8 @@ bool hci_req_pending(struct hci_dev *hdev);
 void hci_req_add_le_scan_disable(struct hci_request *req);
 void hci_req_add_le_passive_scan(struct hci_request *req);
 
-void hci_update_page_scan(struct hci_dev *hdev, struct hci_request *req);
+void hci_update_page_scan(struct hci_dev *hdev);
+void __hci_update_page_scan(struct hci_request *req);
 
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);

commit da25cf6a9869cff52b4fd189fdcd322ad2daf023
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 13:03:35 2014 +0100

    Bluetooth: Report invalid RSSI for service discovery and background scan
    
    When using Start Service Discovery and when background scanning is used
    to report devices, the RSSI is reported or the value 127 is provided in
    case RSSI in unavailable.
    
    For Start Discovery the value 0 is reported to keep backwards
    compatibility with the existing users.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f07b1450b3c2..3c7827005c25 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -75,6 +75,7 @@ struct discovery_state {
 	u32			last_adv_flags;
 	u8			last_adv_data[HCI_MAX_AD_LENGTH];
 	u8			last_adv_data_len;
+	bool			report_invalid_rssi;
 	s8			rssi;
 	u16			uuid_count;
 	u8			(*uuids)[16];
@@ -506,11 +507,13 @@ static inline void discovery_init(struct hci_dev *hdev)
 	INIT_LIST_HEAD(&hdev->discovery.all);
 	INIT_LIST_HEAD(&hdev->discovery.unknown);
 	INIT_LIST_HEAD(&hdev->discovery.resolve);
+	hdev->discovery.report_invalid_rssi = true;
 	hdev->discovery.rssi = HCI_RSSI_INVALID;
 }
 
 static inline void hci_discovery_filter_clear(struct hci_dev *hdev)
 {
+	hdev->discovery.report_invalid_rssi = true;
 	hdev->discovery.rssi = HCI_RSSI_INVALID;
 	hdev->discovery.uuid_count = 0;
 	kfree(hdev->discovery.uuids);

commit 0256325ed666af8346c89deb9d437c2209f463cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Dec 5 11:45:21 2014 +0100

    Bluetooth: Add helper function for clearing the discovery filter
    
    The discovery filter allocates memory for its UUID list. So use
    a helper function to free it and reset it to default states.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 83ca58b9f4c1..f07b1450b3c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -509,6 +509,14 @@ static inline void discovery_init(struct hci_dev *hdev)
 	hdev->discovery.rssi = HCI_RSSI_INVALID;
 }
 
+static inline void hci_discovery_filter_clear(struct hci_dev *hdev)
+{
+	hdev->discovery.rssi = HCI_RSSI_INVALID;
+	hdev->discovery.uuid_count = 0;
+	kfree(hdev->discovery.uuids);
+	hdev->discovery.uuids = NULL;
+}
+
 bool hci_discovery_active(struct hci_dev *hdev);
 
 void hci_discovery_set_state(struct hci_dev *hdev, int state);

commit 37eab042be2196751ff108e6892951338b9a0969
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Dec 5 10:55:55 2014 +0100

    Bluetooth: Add extra discovery fields for storing filter information
    
    With the upcoming addition of support for Start Service Discovery, the
    discovery handling needs to filter on RSSI and UUID values. For that
    they need to be stored in the discovery handling. This patch adds the
    appropiate fields and also make sure they are reset when discovery
    has been stopped.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1dae7001fc31..83ca58b9f4c1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -75,6 +75,9 @@ struct discovery_state {
 	u32			last_adv_flags;
 	u8			last_adv_data[HCI_MAX_AD_LENGTH];
 	u8			last_adv_data_len;
+	s8			rssi;
+	u16			uuid_count;
+	u8			(*uuids)[16];
 };
 
 struct hci_conn_hash {
@@ -503,6 +506,7 @@ static inline void discovery_init(struct hci_dev *hdev)
 	INIT_LIST_HEAD(&hdev->discovery.all);
 	INIT_LIST_HEAD(&hdev->discovery.unknown);
 	INIT_LIST_HEAD(&hdev->discovery.resolve);
+	hdev->discovery.rssi = HCI_RSSI_INVALID;
 }
 
 bool hci_discovery_active(struct hci_dev *hdev);

commit 6928a9245f2998478047dcc3efad30734766a226
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Oct 26 20:46:09 2014 +0100

    Bluetooth: Store address type with OOB data
    
    To be able to support OOB data for LE pairing we need to store the
    address type of the remote device. This patch extends the relevant
    functions and data types with a bdaddr_type variable.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3e89ece75039..1dae7001fc31 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -140,6 +140,7 @@ struct link_key {
 struct oob_data {
 	struct list_head list;
 	bdaddr_t bdaddr;
+	u8 bdaddr_type;
 	u8 hash192[16];
 	u8 rand192[16];
 	u8 hash256[16];
@@ -942,11 +943,12 @@ void hci_smp_irks_clear(struct hci_dev *hdev);
 
 void hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
-					  bdaddr_t *bdaddr);
+					  bdaddr_t *bdaddr, u8 bdaddr_type);
 int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			    u8 *hash192, u8 *rand192,
+			    u8 bdaddr_type, u8 *hash192, u8 *rand192,
 			    u8 *hash256, u8 *rand256);
-int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			       u8 bdaddr_type);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 

commit 81328d5cca7e1cff6296a63a3c1b671d09ddb3ee
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Oct 26 20:33:47 2014 +0100

    Bluetooth: Unify remote OOB data functions
    
    There's no need to duplicate code for the 192 vs 192+256 variants of the
    OOB data functions. This is also helpful to pave the way to support LE
    SC OOB data where only 256 bit data is provided.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f39e65096b1f..3e89ece75039 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -944,10 +944,8 @@ void hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
 					  bdaddr_t *bdaddr);
 int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			    u8 *hash, u8 *rand);
-int hci_add_remote_oob_ext_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				u8 *hash192, u8 *rand192,
-				u8 *hash256, u8 *rand256);
+			    u8 *hash192, u8 *rand192,
+			    u8 *hash256, u8 *rand256);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);

commit ef8efe4bf8b5fe1a9342ae964c428aed1be7863b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Aug 13 15:12:32 2014 +0300

    Bluetooth: Add skeleton for BR/EDR SMP channel
    
    This patch adds the very basic code for creating and destroying SMP
    L2CAP channels for BR/EDR connections.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 42f9362a83c1..f39e65096b1f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -306,6 +306,7 @@ struct hci_dev {
 	__u32			req_result;
 
 	void			*smp_data;
+	void			*smp_bredr_data;
 
 	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;

commit fe8bc5ac67a36b05c4ec91643736d44373096a76
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Aug 14 12:33:17 2014 +0300

    Bluetooth: Add hci_conn flag for new link key generation
    
    For LE Secure Connections we want to trigger cross transport key
    generation only if a new link key was actually created during the BR/EDR
    connection. This patch adds a new flag to track this information.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 90929641d0f0..42f9362a83c1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -559,6 +559,7 @@ enum {
 	HCI_CONN_AUTH_INITIATOR,
 	HCI_CONN_DROP,
 	HCI_CONN_PARAM_REMOVAL_PEND,
+	HCI_CONN_NEW_LINK_KEY,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit f3a73d97b3b78584e111478d07dfd063453f112e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu May 29 15:02:59 2014 +0300

    Bluetooth: Rename hci_find_ltk_by_addr to hci_find_ltk
    
    Now that hci_find_ltk_by_addr is the only LTK lookup function there's no
    need to keep the long name anymore. This patch shortens the function
    name to simply hci_find_ltk.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b41969b561d8..90929641d0f0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -924,8 +924,8 @@ struct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 addr_type, u8 type, u8 authenticated,
 			    u8 tk[16], u8 enc_size, __le16 ediv, __le64 rand);
-struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				     u8 addr_type, u8 role);
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			     u8 addr_type, u8 role);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);
 void hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit 0ac3dbf9995281261abecfd2970406dd4e07955b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu May 29 15:00:03 2014 +0300

    Bluetooth: Remove unused hci_find_ltk function
    
    Now that LTKs are always looked up based on bdaddr (with EDiv/Rand
    checks done after a successful lookup) the hci_find_ltk function is not
    needed anymore. This patch removes the function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7f08ea36d246..b41969b561d8 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -921,8 +921,6 @@ struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 struct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,
 				  bdaddr_t *bdaddr, u8 *val, u8 type,
 				  u8 pin_len, bool *persistent);
-struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, __le64 rand,
-			     u8 role);
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 addr_type, u8 type, u8 authenticated,
 			    u8 tk[16], u8 enc_size, __le16 ediv, __le64 rand);

commit 710f11c08e9f18a8a642024880804436c0969514
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon May 26 11:21:22 2014 +0300

    Bluetooth: Use custom macro for testing BR/EDR SC enabled
    
    Since the HCI_SC_ENABLED flag will also be used for controllers without
    BR/EDR Secure Connections support whenever we need to check specifically
    for SC for BR/EDR we also need to check that the controller actually
    supports it. This patch adds a convenience macro for check all the
    necessary conditions and converts the places in the code that need it to
    use it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 396c09840fdf..7f08ea36d246 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -999,6 +999,9 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 
 #define hdev_is_powered(hdev) (test_bit(HCI_UP, &hdev->flags) && \
 				!test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+#define bredr_sc_enabled(dev) ((lmp_sc_capable(dev) || \
+				test_bit(HCI_FORCE_SC, &(dev)->dbg_flags)) && \
+			       test_bit(HCI_SC_ENABLED, &(dev)->dev_flags))
 
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01

commit 0378b59770130a994272b176a2a4346dc27361e9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 19 15:22:22 2014 +0200

    Bluetooth: Convert link keys list to use RCU
    
    This patch converts the hdev->link_keys list to be protected through
    RCU, thereby eliminating the need to hold the hdev lock while accessing
    the list.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a805b3d97c0b..396c09840fdf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -130,6 +130,7 @@ struct smp_irk {
 
 struct link_key {
 	struct list_head list;
+	struct rcu_head rcu;
 	bdaddr_t bdaddr;
 	u8 type;
 	u8 val[HCI_LINK_KEY_SIZE];

commit 38da1703060a520e69b00405f9bdf765d1396cd0
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 17 20:52:20 2014 +0200

    Bluetooth: Use shorter "rand" name for "randomizer"
    
    The common short form of "randomizer" is "rand" in many places
    (including the Bluetooth specification). The shorter version also makes
    for easier to read code with less forced line breaks. This patch renames
    all occurences of "randomizer" to "rand" in the Bluetooth subsystem
    code.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fe2d5f299e12..a805b3d97c0b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -140,9 +140,9 @@ struct oob_data {
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 hash192[16];
-	u8 randomizer192[16];
+	u8 rand192[16];
 	u8 hash256[16];
-	u8 randomizer256[16];
+	u8 rand256[16];
 };
 
 #define HCI_MAX_SHORT_NAME_LENGTH	10
@@ -943,10 +943,10 @@ void hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
 					  bdaddr_t *bdaddr);
 int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			    u8 *hash, u8 *randomizer);
+			    u8 *hash, u8 *rand);
 int hci_add_remote_oob_ext_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				u8 *hash192, u8 *randomizer192,
-				u8 *hash256, u8 *randomizer256);
+				u8 *hash192, u8 *rand192,
+				u8 *hash256, u8 *rand256);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
@@ -1374,8 +1374,8 @@ void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 void mgmt_read_local_oob_data_complete(struct hci_dev *hdev, u8 *hash192,
-				       u8 *randomizer192, u8 *hash256,
-				       u8 *randomizer256, u8 status);
+				       u8 *rand192, u8 *hash256, u8 *rand256,
+				       u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,
 		       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len);

commit adae20cb2d20e5151b866945f802b0c2312f0f82
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Nov 13 14:37:48 2014 +0200

    Bluetooth: Convert IRK list to RCU
    
    This patch set converts the hdev->identity_resolving_keys list to use
    RCU to eliminate the need to use hci_dev_lock/unlock.
    
    An additional change that must be done is to remove use of
    CRYPTO_ALG_ASYNC for the hdev-specific AES crypto context. The reason is
    that this context is used for matching RPAs and the loop that does the
    matching is under the RCU read lock, i.e. is an atomic section which
    cannot sleep.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a4adef22ad7c..fe2d5f299e12 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -121,6 +121,7 @@ struct smp_ltk {
 
 struct smp_irk {
 	struct list_head list;
+	struct rcu_head rcu;
 	bdaddr_t rpa;
 	bdaddr_t bdaddr;
 	u8 addr_type;

commit 970d0f1b280372cfd46b6de5529d96f8448de943
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Nov 13 14:37:47 2014 +0200

    Bluetooth: Convert LTK list to RCU
    
    This patch set converts the hdev->long_term_keys list to use RCU to
    eliminate the need to use hci_dev_lock/unlock.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4e39a5adfcab..a4adef22ad7c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -108,6 +108,7 @@ struct smp_csrk {
 
 struct smp_ltk {
 	struct list_head list;
+	struct rcu_head rcu;
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
 	u8 authenticated;

commit 845472e8d50c898c73b4f69f4edad5249b13d6a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 3 05:16:08 2014 +0100

    Bluetooth: Add hci_conn_lookup_type() helper function
    
    Some drivers require knowledge of what connection handle is assigned
    to what connection link type (ACL or SCO/eSCO). Instead of having each
    driver implement connection tracking, provide a simple helper function
    for lookup of the link type.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 27ddb905b351..4e39a5adfcab 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -646,6 +646,26 @@ static inline unsigned int hci_conn_count(struct hci_dev *hdev)
 	return c->acl_num + c->amp_num + c->sco_num + c->le_num;
 }
 
+static inline __u8 hci_conn_lookup_type(struct hci_dev *hdev, __u16 handle)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn *c;
+	__u8 type = INVALID_LINK;
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->handle == handle) {
+			type = c->type;
+			break;
+		}
+	}
+
+	rcu_read_unlock();
+
+	return type;
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {

commit 75e0569f7fc22272ec5e3b99bf94c6f0ad43b35f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 2 08:15:38 2014 +0100

    Bluetooth: Add hci_reset_dev() for driver triggerd stack reset
    
    Some Bluetooth drivers require to reset the upper stack. To avoid having
    all drivers send HCI Hardware Error events, provide a generic function
    to wrap the reset functionality.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b8685a77a15e..27ddb905b351 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -856,6 +856,7 @@ int hci_register_dev(struct hci_dev *hdev);
 void hci_unregister_dev(struct hci_dev *hdev);
 int hci_suspend_dev(struct hci_dev *hdev);
 int hci_resume_dev(struct hci_dev *hdev);
+int hci_reset_dev(struct hci_dev *hdev);
 int hci_dev_open(__u16 dev);
 int hci_dev_close(__u16 dev);
 int hci_dev_reset(__u16 dev);

commit 89cbb0638e9b7ba6fab02558f47a29f144df1a19
Author: Alfonso Acosta <fons@spotify.com>
Date:   Sat Oct 11 21:44:47 2014 +0000

    Bluetooth: Defer connection-parameter removal when unpairing
    
    Systematically removing the LE connection parameters and autoconnect
    action is inconvenient for rebonding without disconnecting from
    userland (i.e. unpairing followed by repairing without
    disconnecting). The parameters will be lost after unparing and
    userland needs to take care of book-keeping them and re-adding them.
    
    This patch allows userland to forget about parameter management when
    rebonding without disconnecting. It defers clearing the connection
    parameters when unparing without disconnecting, giving a chance of
    keeping the parameters if a repairing happens before the connection is
    closed.
    
    Signed-off-by: Alfonso Acosta <fons@spotify.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 07ddeed62419..b8685a77a15e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -555,6 +555,7 @@ enum {
 	HCI_CONN_STK_ENCRYPT,
 	HCI_CONN_AUTH_INITIATOR,
 	HCI_CONN_DROP,
+	HCI_CONN_PARAM_REMOVAL_PEND,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit fd45ada9105635a69cbaa2d142d502d402eef6fe
Author: Alfonso Acosta <fons@spotify.com>
Date:   Tue Oct 7 08:44:11 2014 +0000

    Bluetooth: Include ADV_IND report in Device Connected event
    
    There are scenarios when autoconnecting to a device after the
    reception of an ADV_IND report (action 0x02), in which userland
    might want to examine the report's contents.
    
    For instance, the Service Data might have changed and it would be
    useful to know ahead of time before starting any GATT procedures.
    Also, the ADV_IND may contain Manufacturer Specific data which would
    be lost if not propagated to userland. In fact, this patch results
    from the need to rebond with a device lacking persistent storage which
    notifies about losing its LTK in ADV_IND reports.
    
    This patch appends the ADV_IND report which triggered the
    autoconnection to the EIR Data in the Device Connected event.
    
    Signed-off-by: Alfonso Acosta <fons@spotify.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f1407fe0fc5b..07ddeed62419 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -398,6 +398,8 @@ struct hci_conn {
 	__u16		le_conn_interval;
 	__u16		le_conn_latency;
 	__u16		le_supv_timeout;
+	__u8		le_adv_data[HCI_MAX_AD_LENGTH];
+	__u8		le_adv_data_len;
 	__s8		rssi;
 	__s8		tx_power;
 	__s8		max_tx_power;

commit 48ec92fa4f16c0f71e95c31490c03b6c9e0e793b
Author: Alfonso Acosta <fons@spotify.com>
Date:   Tue Oct 7 08:44:10 2014 +0000

    Bluetooth: Refactor arguments of mgmt_device_connected
    
    The values of a lot of the mgmt_device_connected() parameters come
    straight from a hci_conn object. We can simplify the function by passing
    the full hci_conn pointer to it.
    
    Signed-off-by: Alfonso Acosta <fons@spotify.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 37ff1aef0845..f1407fe0fc5b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1310,9 +1310,8 @@ int mgmt_update_adv_data(struct hci_dev *hdev);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);
-void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-			   u8 addr_type, u32 flags, u8 *name, u8 name_len,
-			   u8 *dev_class);
+void mgmt_device_connected(struct hci_dev *hdev, struct hci_conn *conn,
+			   u32 flags, u8 *name, u8 name_len);
 void mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			      u8 link_type, u8 addr_type, u8 reason,
 			      bool mgmt_connected);

commit 0097db06f5ab2df1756bc4cbf4395593024d87a1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 16 21:36:09 2014 +0200

    Bluetooth: Remove exported hci_recv_fragment function
    
    The hci_recv_fragment function is no longer used by any driver and thus
    do not export it. In fact it is not even needed by the core and it can
    be removed altogether.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 206b92bfeebb..37ff1aef0845 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -926,7 +926,6 @@ int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
-int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
 void hci_init_sysfs(struct hci_dev *hdev);

commit e1e930f591bfd9604c3077f0af5c390f4f890259
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Sep 8 17:09:49 2014 -0700

    Bluetooth: Fix mgmt pairing failure when authentication fails
    
    Whether through HCI with BR/EDR or SMP with LE when authentication fails
    we should also notify any pending Pair Device mgmt command. This patch
    updates the mgmt_auth_failed function to take the actual hci_conn object
    and makes sure that any pending pairing command is notified and cleaned
    up appropriately.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 045d9133d180..206b92bfeebb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1342,8 +1342,7 @@ int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 int mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			     u8 link_type, u8 addr_type, u32 passkey,
 			     u8 entered);
-void mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		      u8 addr_type, u8 status);
+void mgmt_auth_failed(struct hci_conn *conn, u8 status);
 void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_sc_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);

commit fc75cc8684d21d3649b28c4c37d4ce3f000759e4
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Sep 5 22:19:52 2014 +0300

    Bluetooth: Fix locking of the SMP context
    
    Before the move the l2cap_chan the SMP context (smp_chan) didn't have
    any kind of proper locking. The best there existed was the
    HCI_CONN_LE_SMP_PEND flag which was used to enable mutual exclusion for
    potential multiple creators of the SMP context.
    
    Now that SMP has been converted to use the l2cap_chan infrastructure and
    since the SMP context is directly mapped to a corresponding l2cap_chan
    we get the SMP context locking essentially for free through the
    l2cap_chan lock. For all callbacks that l2cap_core.c makes for each
    channel implementation (smp.c in the case of SMP) the l2cap_chan lock is
    held through l2cap_chan_lock(chan).
    
    Since the calls from l2cap_core.c to smp.c are covered the only missing
    piece to have the locking implemented properly is to ensure that the
    lock is held for any other call path that may access the SMP context.
    This means user responses through mgmt.c, requests to elevate the
    security of a connection through hci_conn.c, as well as any deferred
    work through workqueues.
    
    This patch adds the necessary locking to all these other code paths that
    try to access the SMP context. Since mutual exclusion for the l2cap_chan
    access is now covered from all directions the patch also removes
    unnecessary HCI_CONN_LE_SMP_PEND flag (once we've acquired the chan lock
    we can simply check whether chan->smp is set to know if there's an SMP
    context).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2b6e04d37593..045d9133d180 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -539,7 +539,6 @@ enum {
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
 	HCI_CONN_SCO_SETUP_PEND,
-	HCI_CONN_LE_SMP_PEND,
 	HCI_CONN_MGMT_CONNECTED,
 	HCI_CONN_SSP_ENABLED,
 	HCI_CONN_SC_ENABLED,

commit e3b679d56caa2bc555dee646a6ac5861631e7a28
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 20:33:32 2014 +0300

    Bluetooth: Update hci_disconnect() to return an error value
    
    We'll soon use hci_disconnect() from places that are interested to know
    whether the hci_send_cmd() really succeeded or not. This patch updates
    hci_disconnect() to pass on any error returned from hci_send_cmd().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dbe73642c54c..2b6e04d37593 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -703,7 +703,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 	return NULL;
 }
 
-void hci_disconnect(struct hci_conn *conn, __u8 reason);
+int hci_disconnect(struct hci_conn *conn, __u8 reason);
 bool hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 

commit f94b665dcf15324f5ac8aa639e47be0829b6409d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 00:41:44 2014 +0300

    Bluetooth: Ignore incoming data after initiating disconnection
    
    When hci_chan_del is called the disconnection routines get scheduled
    through a workqueue. If there's any incoming ACL data before the
    routines get executed there's a chance that a new hci_chan is created
    and the disconnection never happens. This patch adds a new hci_conn flag
    to indicate that we're in the process of driving the connection down. We
    set the flag in hci_chan_del and check for it in hci_chan_create so that
    no new channels are created for the same connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 18c24f6fce6c..dbe73642c54c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -553,6 +553,7 @@ enum {
 	HCI_CONN_FIPS,
 	HCI_CONN_STK_ENCRYPT,
 	HCI_CONN_AUTH_INITIATOR,
+	HCI_CONN_DROP,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit eb78d7e53d144995b9e023b151de19fa40af72f3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 00:41:41 2014 +0300

    Bluetooth: Use zero timeout for immediate scheduling
    
    There's no point in passing a "small" timeout to queue_delayed_work() to
    try to get the callback faster scheduled. Passing 0 is perfectly valid
    and will cause a shortcut to a direct queue_work().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index aa75eee8ad7f..18c24f6fce6c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -791,7 +791,7 @@ static inline void hci_conn_drop(struct hci_conn *conn)
 				if (!conn->out)
 					timeo *= 2;
 			} else {
-				timeo = msecs_to_jiffies(10);
+				timeo = 0;
 			}
 			break;
 
@@ -800,7 +800,7 @@ static inline void hci_conn_drop(struct hci_conn *conn)
 			break;
 
 		default:
-			timeo = msecs_to_jiffies(10);
+			timeo = 0;
 			break;
 		}
 

commit 51bb8457ddfa74ede52bf8c02054dea831d59fff
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 15 21:06:57 2014 +0300

    Bluetooth: Improve *_get() functions to return the object type
    
    It's natural to have *_get() functions that increment the reference
    count of an object to return the object type itself. This way it's
    simple to make a copy of the object pointer and increase the reference
    count in a single step. This patch updates two such get() functions,
    namely hci_conn_get() and l2cap_conn_get(), and updates the users to
    take advantage of the new API.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b0ded1333865..aa75eee8ad7f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -756,9 +756,10 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status);
  * _get()/_drop() in it, but require the caller to have a valid ref (FIXME).
  */
 
-static inline void hci_conn_get(struct hci_conn *conn)
+static inline struct hci_conn *hci_conn_get(struct hci_conn *conn)
 {
 	get_device(&conn->dev);
+	return conn;
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)

commit 61a3d4f9d52c00b2016bc27fc66b10a194043f76
Merge: db906eb2101b 1bd3fa7b8c9b
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Sep 8 11:14:56 2014 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless

commit f161dd4122ffa73e4e12000309dca65bec80d416
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 15 21:06:54 2014 +0300

    Bluetooth: Fix hci_conn reference counting for auto-connections
    
    Recently the LE passive scanning and auto-connections feature was
    introduced. It uses the hci_connect_le() API which returns a hci_conn
    along with a reference count to that object. All previous users would
    tie this returned reference to some existing object, such as an L2CAP
    channel, and there'd be no leaked references this way. For
    auto-connections however the reference was returned but not stored
    anywhere, leaving established connections with one higher reference
    count than they should have.
    
    Instead of playing special tricks with hci_conn_hold/drop this patch
    associates the returned reference from hci_connect_le() with the object
    that in practice does own this reference, i.e. the hci_conn_params
    struct that caused us to initiate a connection in the first place. Once
    the connection is established or fails to establish this reference is
    removed appropriately.
    
    One extra thing needed is to call hci_pend_le_actions_clear() before
    calling hci_conn_hash_flush() so that the reference is cleared before
    the hci_conn objects are fully removed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b5d5af3aa469..6f884e6c731e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -464,6 +464,8 @@ struct hci_conn_params {
 		HCI_AUTO_CONN_ALWAYS,
 		HCI_AUTO_CONN_LINK_LOSS,
 	} auto_connect;
+
+	struct hci_conn *conn;
 };
 
 extern struct list_head hci_dev_list;

commit defce9e83666658d4420d65e45ab1ad190992f72
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 8 09:37:17 2014 +0300

    Bluetooth: Make AES crypto context private to SMP
    
    Now that we have per-adapter SMP data thanks to the root SMP L2CAP
    channel we can take advantage of it and attach the AES crypto context
    (only used for SMP) to it. This means that the smp_irk_matches() and
    smp_generate_rpa() function can be converted to internally handle the
    AES context.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2571fc1cb1c5..5f0b77b71b45 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -302,7 +302,6 @@ struct hci_dev {
 	__u32			req_status;
 	__u32			req_result;
 
-	struct crypto_blkcipher	*tfm_aes;
 	void			*smp_data;
 
 	struct discovery_state	discovery;

commit 70db83c4bcdc1447bbcb318389561c90d7056b18
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 8 09:37:16 2014 +0300

    Bluetooth: Add SMP L2CAP channel skeleton
    
    This patch creates the initial SMP L2CAP channels and a skeleton for
    their callbacks. There is one per-adapter channel created upon adapter
    registration, and then one channel per-connection created through the
    new_connection callback. The channels are registered with the reserved
    CID 0x1f for now in order to not conflict with existing SMP
    functionality. Once everything is in place the value can be changed to
    what it should be, i.e. L2CAP_CID_SMP.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cc2eb7730fbc..2571fc1cb1c5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -303,6 +303,7 @@ struct hci_dev {
 	__u32			req_result;
 
 	struct crypto_blkcipher	*tfm_aes;
+	void			*smp_data;
 
 	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;

commit 432df05eb1e57adfc46df08abbedca6c3b8862f7
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 1 11:13:31 2014 +0300

    Bluetooth: Create unified helper function for updating page scan
    
    Similar to our hci_update_background_scan() function we can simplify a
    lot of code by creating a unified helper function for doing page scan
    updates. This patch adds such a function to hci_core.c and updates all
    the relevant places to use it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8394abc4fd87..cc2eb7730fbc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -968,6 +968,9 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))
 #define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))
 
+#define hdev_is_powered(hdev) (test_bit(HCI_UP, &hdev->flags) && \
+				!test_bit(HCI_AUTO_OFF, &hdev->dev_flags))
+
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01
 
@@ -1256,6 +1259,8 @@ bool hci_req_pending(struct hci_dev *hdev);
 void hci_req_add_le_scan_disable(struct hci_request *req);
 void hci_req_add_le_passive_scan(struct hci_request *req);
 
+void hci_update_page_scan(struct hci_dev *hdev, struct hci_request *req);
+
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);
 struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,

commit 84c61d92bb6e9048eecc0738a83f1bf66f053026
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 1 11:13:30 2014 +0300

    Bluetooth: Add convenience function to check for pending power off
    
    There are several situations where we're interested in knowing whether
    we're currently in the process of powering off an adapter. This patch
    adds a convenience function for the purpose and makes it public since
    we'll soon need to access it from hci_event.c as well.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b5d5af3aa469..8394abc4fd87 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1351,6 +1351,7 @@ void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
+bool mgmt_powering_down(struct hci_dev *hdev);
 void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent);
 void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
 void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,

commit 628531c9e971f1bd023d9fbd00faff014ca22440
Author: Georg Lukas <georg@op-co.de>
Date:   Sat Jul 26 13:59:57 2014 +0200

    Bluetooth: Provide defaults for LE advertising interval
    
    Store the default values for minimum and maximum advertising interval
    with all the other controller defaults. These vaules are sent to the
    adapter whenever advertising is (re)enabled.
    
    Signed-off-by: Georg Lukas <georg@op-co.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 747a0c3d9947..b5d5af3aa469 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -203,6 +203,8 @@ struct hci_dev {
 	__u16		page_scan_window;
 	__u8		page_scan_type;
 	__u8		le_adv_channel_map;
+	__u16		le_adv_min_interval;
+	__u16		le_adv_max_interval;
 	__u8		le_scan_type;
 	__u16		le_scan_interval;
 	__u16		le_scan_window;

commit 4b9e7e7516135b1d5f047ad59188b5355bacc106
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 23 21:55:23 2014 +0200

    Bluetooth: Fix issue with ADV_IND reports and auto-connection handling
    
    When adding remote devices to the kernel using the Add Device management
    command, these devices are explicitly allowed to connect. This kind of
    incoming connections are possible even when the controller itself is
    not connectable.
    
    For BR/EDR this distinction is pretty simple since there is only one
    type of incoming connections. With LE this is not that simple anymore
    since there are ADV_IND and ADV_DIRECT_IND advertising events.
    
    The ADV_DIRECT_IND advertising events are send for incoming (slave
    initiated) connections only. And this is the only thing the kernel
    should allow when adding devices using action 0x01. This meaning
    of incoming connections is coming from BR/EDR and needs to be
    mapped to LE the same way.
    
    Supporting the auto-connection of devices using ADV_IND advertising
    events is an important feature as well. However it does not map to
    incoming connections. So introduce a new action 0x02 that allows
    the kernel to connect to devices using ADV_DIRECT_IND and in addition
    ADV_IND advertising reports.
    
    This difference is represented by the new HCI_AUTO_CONN_DIRECT value
    for only connecting to ADV_DIRECT_IND. For connection to ADV_IND and
    ADV_DIRECT_IND the old value HCI_AUTO_CONN_ALWAYS is used.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 996ed065b6c2..747a0c3d9947 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -458,6 +458,7 @@ struct hci_conn_params {
 	enum {
 		HCI_AUTO_CONN_DISABLED,
 		HCI_AUTO_CONN_REPORT,
+		HCI_AUTO_CONN_DIRECT,
 		HCI_AUTO_CONN_ALWAYS,
 		HCI_AUTO_CONN_LINK_LOSS,
 	} auto_connect;

commit 977f8fce0279e5f96dc5c5068610d60b9ae94802
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 17 15:35:39 2014 +0300

    Bluetooth: Introduce a flag to track who really initiates authentication
    
    Even though our side requests authentication, the original action that
    caused it may be remotely triggered, such as an incoming L2CAP or RFCOMM
    connect request. To track this information introduce a new hci_conn flag
    called HCI_CONN_AUTH_INITIATOR.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index eb2b9c9e3480..996ed065b6c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -547,6 +547,7 @@ enum {
 	HCI_CONN_SECURE,
 	HCI_CONN_FIPS,
 	HCI_CONN_STK_ENCRYPT,
+	HCI_CONN_AUTH_INITIATOR,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit e7cafc45258c852c5176cd421615846e79a3d307
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 17 15:35:38 2014 +0300

    Bluetooth: Pass initiator/acceptor information to hci_conn_security()
    
    We're interested in whether an authentication request is because of a
    remote or local action. So far hci_conn_security() has been used both
    for incoming and outgoing actions (e.g. RFCOMM or L2CAP connect
    requests) so without some modifications it cannot know which peer is
    responsible for requesting authentication.
    
    This patch adds a new "bool initiator" parameter to hci_conn_security()
    to indicate which side is responsible for the request and updates the
    current users to pass this information correspondingly.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 73e16ecfd6b9..eb2b9c9e3480 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -720,7 +720,8 @@ struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
 				 __u16 setting);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
-int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
+		      bool initiator);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 

commit f8218dc6605a7b2af843f9ff5d66229a4a0b1c45
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:56:08 2014 +0300

    Bluetooth: Track number of LE slave connections
    
    Most (probably all) controllers can only deal with a single slave LE
    connection at a time. This patch adds a counter for such connections so
    that the number can be quickly looked up without iterating the
    connections list.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3de000fbecdc..73e16ecfd6b9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -83,6 +83,7 @@ struct hci_conn_hash {
 	unsigned int     amp_num;
 	unsigned int     sco_num;
 	unsigned int     le_num;
+	unsigned int     le_num_slave;
 };
 
 struct bdaddr_list {
@@ -575,6 +576,8 @@ static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 		break;
 	case LE_LINK:
 		h->le_num++;
+		if (c->role == HCI_ROLE_SLAVE)
+			h->le_num_slave++;
 		break;
 	case SCO_LINK:
 	case ESCO_LINK:
@@ -599,6 +602,8 @@ static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 		break;
 	case LE_LINK:
 		h->le_num--;
+		if (c->role == HCI_ROLE_SLAVE)
+			h->le_num_slave--;
 		break;
 	case SCO_LINK:
 	case ESCO_LINK:

commit a5c4e309b9f23b9de5475029b2cb1641ec293137
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:56:07 2014 +0300

    Bluetooth: Add a role parameter to hci_conn_add()
    
    We need to be able to track slave vs master LE connections in
    hci_conn_hash, and to be able to do that we need to know the role of the
    connection by the time hci_conn_add_has() is called. This means in
    practice the hci_conn_add() call that creates the hci_conn_object.
    
    This patch adds a new role parameter to hci_conn_add() function to give
    the object its initial role value, and updates the callers to pass the
    appropriate role to it. Since the function now takes care of
    initializing both conn->role and conn->out values we can remove some
    other unnecessary assignments.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index abe5083becd3..3de000fbecdc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -695,7 +695,8 @@ void hci_disconnect(struct hci_conn *conn, __u8 reason);
 bool hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
+			      u8 role);
 int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);

commit e804d25d4a07c0ff9e5e1c58ea5ee67232aa9af8
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:42:28 2014 +0300

    Bluetooth: Use explicit role instead of a bool in function parameters
    
    To make the code more understandable it makes sense to use the new HCI
    defines for connection role instead of a "bool master" parameter. This
    makes it immediately clear when looking at the function calls what the
    last parameter is describing.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e335c5fd8824..abe5083becd3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -707,7 +707,7 @@ struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u16 conn_timeout,
-				bool master);
+				u8 role);
 struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 				 u8 sec_level, u8 auth_type);
 struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
@@ -881,12 +881,12 @@ struct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,
 				  bdaddr_t *bdaddr, u8 *val, u8 type,
 				  u8 pin_len, bool *persistent);
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, __le64 rand,
-			     bool master);
+			     u8 role);
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 addr_type, u8 type, u8 authenticated,
 			    u8 tk[16], u8 enc_size, __le16 ediv, __le64 rand);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				     u8 addr_type, bool master);
+				     u8 addr_type, u8 role);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);
 void hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit 40bef302f6323d1ee6fb3dc0e62edb0f446d0339
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:42:27 2014 +0300

    Bluetooth: Convert HCI_CONN_MASTER flag to a conn->role variable
    
    Having a dedicated u8 role variable in the hci_conn struct greatly
    simplifies tracking of the role, since this is the native way that it's
    represented on the HCI level.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b52c2ef3f56d..e335c5fd8824 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -371,6 +371,7 @@ struct hci_conn {
 	__u16		state;
 	__u8		mode;
 	__u8		type;
+	__u8		role;
 	bool		out;
 	__u8		attempt;
 	__u8		dev_class[3];
@@ -540,7 +541,6 @@ enum {
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
 	HCI_CONN_FLUSH_KEY,
-	HCI_CONN_MASTER,
 	HCI_CONN_ENCRYPT,
 	HCI_CONN_AUTH,
 	HCI_CONN_SECURE,

commit 899de765667b63bb51526f0a31693aed6ad5f828
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jul 11 05:51:58 2014 +0200

    Bluetooth: Move HCI request internals to net/bluetooth/hci_core.c
    
    The internals of the HCI request framework should not be leaking to
    its users. Move them all into net/bluetooth/hci_core.c and provide
    a simple hci_req_pending helper function for the one user outside
    the framework.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fffd0da2e0fc..b52c2ef3f56d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1240,6 +1240,7 @@ void hci_req_add(struct hci_request *req, u16 opcode, u32 plen,
 void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen,
 		    const void *param, u8 event);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
+bool hci_req_pending(struct hci_dev *hdev);
 
 void hci_req_add_le_scan_disable(struct hci_request *req);
 void hci_req_add_le_passive_scan(struct hci_request *req);
@@ -1349,14 +1350,6 @@ void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 
-/* ----- HCI requests ----- */
-#define HCI_REQ_DONE	  0
-#define HCI_REQ_PEND	  1
-#define HCI_REQ_CANCELED  2
-
-#define hci_req_lock(d)		mutex_lock(&d->req_lock)
-#define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
-
 u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
 		      u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,

commit 863def58fec2fa494c8e9ca45471819c6d731ec3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jul 11 05:41:00 2014 +0200

    Bluetooth: Move struct hci_pinfo into net/bluetooth/hci_sock.c
    
    There exists no external user of struct hci_pinfo and hci_pi and thus
    move it into the one place that is actually using it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e1930749fac7..fffd0da2e0fc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1349,17 +1349,6 @@ void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 
-/* HCI info for socket */
-#define hci_pi(sk) ((struct hci_pinfo *) sk)
-
-struct hci_pinfo {
-	struct bt_sock    bt;
-	struct hci_dev    *hdev;
-	struct hci_filter filter;
-	__u32             cmsg_mask;
-	unsigned short   channel;
-};
-
 /* ----- HCI requests ----- */
 #define HCI_REQ_DONE	  0
 #define HCI_REQ_PEND	  1

commit 3ad254f7f6fd3b66ce47a156cbb92cb02002103e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jul 11 05:36:39 2014 +0200

    Bluetooth: Move struct hci_sec_filter next to its user
    
    There is only single location using struct hci_sec_filter and with
    that there is no point in putting this declaration into a global
    header file. So move it right next to its user and make the code
    a lot more simpler.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5c52a17d6326..e1930749fac7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1360,15 +1360,6 @@ struct hci_pinfo {
 	unsigned short   channel;
 };
 
-/* HCI security filter */
-#define HCI_SFLT_MAX_OGF  5
-
-struct hci_sec_filter {
-	__u32 type_mask;
-	__u32 event_mask[2];
-	__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
-};
-
 /* ----- HCI requests ----- */
 #define HCI_REQ_DONE	  0
 #define HCI_REQ_PEND	  1

commit f49daa8190ebf25eae907048266b590a9cdccb95
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jul 11 04:58:29 2014 +0200

    Bluetooth: Move HCI socket definitions into its own header file
    
    All the HCI sockets and ioctl based definitions have been in a global
    header file that also includes all the HCI protocol structures. To
    make this a bit cleaner, move them into its own file.
    
    This also adjusts fs/compat_ioctl.c to only include this new file
    and not all the protocol structures that are not needed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7e9e95633a85..5c52a17d6326 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -26,6 +26,7 @@
 #define __HCI_CORE_H
 
 #include <net/bluetooth/hci.h>
+#include <net/bluetooth/hci_sock.h>
 
 /* HCI priority */
 #define HCI_PRIO_MAX	7

commit 13a779e42251184d0f53a8f8299ced614faa028f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 10 12:09:09 2014 +0300

    Bluetooth: Remove unneeded mgmt_write_scan_failed function
    
    The Set Connectable/Discoverable mgmt handlers use a hci_request with a
    proper callback to handle the HCI command sending. It makes therefore
    little sense to have this extra function to be called from hci_event.c
    for command failures.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b65efb22be54..7e9e95633a85 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1288,7 +1288,6 @@ void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_update_adv_data(struct hci_dev *hdev);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
-void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,

commit bc6d2d04182877b198c1a945b7c401decbbb8c02
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 10 12:09:08 2014 +0300

    Bluetooth: Remove unneeded mgmt_discoverable function
    
    Since the HCISETSCAN ioctl is the only non-mgmt user we care about for
    setting the right discoverable state we can simply do the necessary
    updates in the ioctl handler function instead. This then allows the
    removal of the mgmt_discoverable function and should simplify that state
    handling considerably.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 76675c55be15..b65efb22be54 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1286,8 +1286,8 @@ void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
+int mgmt_update_adv_data(struct hci_dev *hdev);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
-void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);

commit 031547d8688a0fc5da875b504bf11e6c2e18390e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 10 12:09:06 2014 +0300

    Bluetooth: Remove unneeded mgmt_connectable function
    
    The mgmt_connectable function has been used to ensure that the right
    actions to HCI_CONNECTABLE are taken when the HCI_Write_Scan_Enable
    command is triggered by something else than mgmt. The only other user
    that we really care about is the HCISETSCAN ioctl code, so we can
    actually more simply perform the needed changes there instead.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e69c2b08c0c6..76675c55be15 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1288,7 +1288,6 @@ void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
-void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);

commit 91a668b0565dddc9f556f9bce65da58264c74623
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 9 13:28:26 2014 +0300

    Bluetooth: Fix setting HCI_CONNECTABLE from ioctl code
    
    When the white list is in use the code would not update the
    HCI_CONNECTABLE flag if it gets changed through the ioctl code (e.g.
    hciconfig hci0 pscan). Since the flag is important for properly
    accepting incoming connections add code to fix it up if necessary and
    emit a New Settings mgmt event.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cba4837dcaa5..e69c2b08c0c6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1281,6 +1281,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
+int mgmt_new_settings(struct hci_dev *hdev);
 void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);

commit 6659358efe617bb46237e62f7303c76e10568d70
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 9 12:59:14 2014 +0300

    Bluetooth: Introduce a whitelist for BR/EDR devices
    
    This patch extends the Add/Remove device commands by letting user space
    pass BR/EDR addresses to them. The resulting entries get stored in a new
    hdev->whitelist list. The idea is that we can now selectively accept
    connections from devices in the list even though HCI_CONNECTABLE is not
    set (the actual implementation of this is coming in a subsequent patch).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3a1caf10cc8d..cba4837dcaa5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -305,6 +305,7 @@ struct hci_dev {
 
 	struct list_head	mgmt_pending;
 	struct list_head	blacklist;
+	struct list_head	whitelist;
 	struct list_head	uuids;
 	struct list_head	link_keys;
 	struct list_head	long_term_keys;

commit dcc36c16c2f1c9800146c8416ee5a4c3dc974623
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 9 12:59:13 2014 +0300

    Bluetooth: Unify helpers for bdaddr_list manipulations
    
    We already have several lists with struct bdaddr_list entries, and there
    will be more in the future. Since the operations for adding, removing,
    looking up and clearing entries in these lists are exactly the same it
    doesn't make sense to define new functions for every single list. This
    patch unifies the functions by passing the list_head to them instead of
    a hci_dev pointer.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c98de309967e..3a1caf10cc8d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -849,16 +849,11 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
-struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
-					 bdaddr_t *bdaddr, u8 type);
-int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-
-struct bdaddr_list *hci_white_list_lookup(struct hci_dev *hdev,
-					  bdaddr_t *bdaddr, u8 type);
-void hci_white_list_clear(struct hci_dev *hdev);
-int hci_white_list_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-int hci_white_list_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+struct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *list,
+					   bdaddr_t *bdaddr, u8 type);
+int hci_bdaddr_list_add(struct list_head *list, bdaddr_t *bdaddr, u8 type);
+int hci_bdaddr_list_del(struct list_head *list, bdaddr_t *bdaddr, u8 type);
+void hci_bdaddr_list_clear(struct list_head *list);
 
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);

commit c93bd15033027928709ee15bab2ce1f5582085c6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jul 8 15:07:48 2014 +0300

    Bluetooth: Remove unnecessary mgmt_advertising function
    
    Since the real advertising state is now tracked with its own flag we can
    simply set/unset the HCI_ADVERTISING flag in the
    set_advertising_complete function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5701d15779dd..c98de309967e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1292,7 +1292,6 @@ int mgmt_powered(struct hci_dev *hdev, u8 powered);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
-void mgmt_advertising(struct hci_dev *hdev, u8 advertising);
 void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);

commit cdd6275e510bd86c44d3fc85a78306f514bbac9a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jul 7 15:02:28 2014 +0300

    Bluetooth: Pass desired connection role to hci_connect_le()
    
    If we have both LE scanning and advertising simultaneously enabled we
    need a way to tell hci_connect_le() in which role to initiate a
    connection. This patch adds a new parameter to the function to give it
    the necessary information. For auto-connect and mgmt_pair_device we
    always use master role, whereas for L2CAP users (in practice sockets) we
    use slave role whenever HCI_ADVERTISING is set and master role
    otherwise.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8752ac674db1..5701d15779dd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -704,7 +704,8 @@ void hci_chan_list_flush(struct hci_conn *conn);
 struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, u8 sec_level, u16 conn_timeout);
+				u8 dst_type, u8 sec_level, u16 conn_timeout,
+				bool master);
 struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 				 u8 sec_level, u8 auth_type);
 struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,

commit d93375a82da10cb023afc945fa18471bf3c41704
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jul 7 15:02:27 2014 +0300

    Bluetooth: Remove auth_type parameter from hci_connect_le()
    
    The auth_type value which gets assigned to hci_conn->auth_type is
    something that's only used for BR/EDR connections and is of no value for
    LE connections. It makes therefore little sense to pass it to the
    hci_connect_le() function. This patch removes the parameter from the
    function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 06039aae3010..8752ac674db1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -704,8 +704,7 @@ void hci_chan_list_flush(struct hci_conn *conn);
 struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, u8 sec_level, u8 auth_type,
-				u16 conn_timeout);
+				u8 dst_type, u8 sec_level, u16 conn_timeout);
 struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 				 u8 sec_level, u8 auth_type);
 struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,

commit 09ae260ba452c2ed36ec295941a58cb75db213ed
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jul 6 13:41:15 2014 +0300

    Bluetooth: Use lower timeout for LE auto-connections
    
    When we establish connections as a consequence of receiving an
    advertising report it makes no sense to wait the normal 20 second LE
    connection timeout. This patch modifies the hci_connect_le function to
    take an extra timeout value and uses a lower 2 second timeout for the
    auto-connection case. This timeout is intentionally chosen to be just a
    bit higher than the 1.28 second timeout that High Duty Cycle Advertising
    uses.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9d838a072db4..06039aae3010 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -385,6 +385,7 @@ struct hci_conn {
 	__u32		passkey_notify;
 	__u8		passkey_entered;
 	__u16		disc_timeout;
+	__u16		conn_timeout;
 	__u16		setting;
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
@@ -703,7 +704,8 @@ void hci_chan_list_flush(struct hci_conn *conn);
 struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, u8 sec_level, u8 auth_type);
+				u8 dst_type, u8 sec_level, u8 auth_type,
+				u16 conn_timeout);
 struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 				 u8 sec_level, u8 auth_type);
 struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,

commit 19de0825cd8acb1de6fa6a135b1f059446781049
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jul 6 13:06:51 2014 +0300

    Bluetooth: Fix sending Device Removed when clearing all parameters
    
    When calling Device Remove with BDADDR_ANY we should in a similar way
    emit Device Removed events as we do when removing a single device. Since
    we have to iterate the list and call device_removed() the dedicated
    hci_conn_params_clear_enabled() is not really useful anymore. This patch
    removes the helper function and does the event emission and list item
    removal in a single loop.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index aff285698c85..9d838a072db4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -867,7 +867,6 @@ int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear_all(struct hci_dev *hdev);
 void hci_conn_params_clear_disabled(struct hci_dev *hdev);
-void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 
 struct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,
 						  bdaddr_t *addr,

commit e30d3f5fef378cd14ba8c331a5c7a2f9239c2770
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jul 5 10:48:03 2014 +0200

    Bluetooth: Store Bluetooth address from controller setup
    
    During the setup phase of a controller, the Bluetooth address will be
    read and to have that original address available for later use, store
    it as setup address.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1cae4d3a629d..aff285698c85 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -171,6 +171,7 @@ struct hci_dev {
 	__u8		bus;
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
+	bdaddr_t	setup_addr;
 	bdaddr_t	public_addr;
 	bdaddr_t	random_addr;
 	bdaddr_t	static_addr;

commit 501f882741b139da22bb3ba4bc615a6eadce5038
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 4 12:37:26 2014 +0300

    Bluetooth: Make hci_pend_le_conn_lookup more general purposed
    
    In some circumstances we need to look up entries in pend_le_conns and in
    other in pend_le_reports. This patch converts the existing lookup
    function for pend_le_conns to something that can be used for both lists.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c2bc9180cb79..1cae4d3a629d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -868,8 +868,9 @@ void hci_conn_params_clear_all(struct hci_dev *hdev);
 void hci_conn_params_clear_disabled(struct hci_dev *hdev);
 void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 
-struct hci_conn_params *hci_pend_le_conn_lookup(struct hci_dev *hdev,
-						bdaddr_t *addr, u8 addr_type);
+struct hci_conn_params *hci_pend_le_action_lookup(struct list_head *list,
+						  bdaddr_t *addr,
+						  u8 addr_type);
 
 void hci_update_background_scan(struct hci_dev *hdev);
 

commit d9b3ad7df101a6490272771f1aabbaa623a196f3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 4 12:37:25 2014 +0300

    Bluetooth: Remove unused hci_pend_le_conn_add function
    
    Since there are no more users of this function we can simply go ahead
    and remove it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9208b18cb1e9..c2bc9180cb79 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -870,7 +870,6 @@ void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 
 struct hci_conn_params *hci_pend_le_conn_lookup(struct hci_dev *hdev,
 						bdaddr_t *addr, u8 addr_type);
-void hci_pend_le_conn_add(struct hci_dev *hdev, struct hci_conn_params *params);
 
 void hci_update_background_scan(struct hci_dev *hdev);
 

commit d7347f3cc2b63be0ea35b3239faf4b32fde2fb44
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 4 12:37:23 2014 +0300

    Bluetooth: Fix clearing and restarting all LE actions on power cycle
    
    When powering off (hci_dev_do_close) we should clear both the
    pend_le_reports and pend_le_conns types of entries. When powering on
    respectively we should populate both lists. This patch converts the
    hci_pend_le_conns_clear() function into hci_pend_le_actions_clear()
    (which can now be static) and converts the restart_le_auto_conns()
    function into restart_le_actions().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 758146c513d3..9208b18cb1e9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -871,7 +871,6 @@ void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 struct hci_conn_params *hci_pend_le_conn_lookup(struct hci_dev *hdev,
 						bdaddr_t *addr, u8 addr_type);
 void hci_pend_le_conn_add(struct hci_dev *hdev, struct hci_conn_params *params);
-void hci_pend_le_conns_clear(struct hci_dev *hdev);
 
 void hci_update_background_scan(struct hci_dev *hdev);
 

commit ae44e5d19e870385d1e73ce248c19ea4761bb40c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 4 12:37:22 2014 +0300

    Bluetooth: Remove unused hci_pend_le_conn_del() function
    
    Now that there are no-longer any users of the hci_pend_le_conn_del()
    function we can simply go ahead and remove it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9670f4c66ee3..758146c513d3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -871,7 +871,6 @@ void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 struct hci_conn_params *hci_pend_le_conn_lookup(struct hci_dev *hdev,
 						bdaddr_t *addr, u8 addr_type);
 void hci_pend_le_conn_add(struct hci_dev *hdev, struct hci_conn_params *params);
-void hci_pend_le_conn_del(struct hci_dev *hdev, struct hci_conn_params *params);
 void hci_pend_le_conns_clear(struct hci_dev *hdev);
 
 void hci_update_background_scan(struct hci_dev *hdev);

commit 66f8455aeac3427110d451534567eb1b9aea6929
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 4 12:37:18 2014 +0300

    Bluetooth: Convert pend_le_reports into a list
    
    To simplify manipulation and lookup of hci_conn_params entries of the
    type HCI_AUTO_CONN_REPORT it makes sense to store them in their own
    list. The new action list_head in hci_conn_params is used for this
    purpose.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3b1143caa380..9670f4c66ee3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -312,7 +312,7 @@ struct hci_dev {
 	struct list_head	le_white_list;
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
-	unsigned int		pend_le_reports;
+	struct list_head	pend_le_reports;
 
 	struct hci_dev_stats	stat;
 

commit 93450c75448e370659ce7ca9c192298596fb055e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 4 12:37:17 2014 +0300

    Bluetooth: Convert pend_le_conn list to a generic action list
    
    In preparation to store also HCI_AUTO_CONN_REPORT entries in a list it
    makes sense to convert the existing pend_le_conn list head of
    hci_conn_params into a more generically named "action". This makes sense
    because a parameter entry will never participate in more than one action
    list.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 09f9fb85d8fd..3b1143caa380 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -439,7 +439,7 @@ struct hci_chan {
 
 struct hci_conn_params {
 	struct list_head list;
-	struct list_head pend_le_conn;
+	struct list_head action;
 
 	bdaddr_t addr;
 	u8 addr_type;

commit 912b42ef05a1e9f72a82c21d678a29c5055045d5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 3 19:33:49 2014 +0300

    Bluetooth: Use hci_conn_params in pend_le_conns
    
    Since the connection parameters are always a basis for adding entries to
    hdev->pend_le_conns (so far of type bdaddr_list) it's simpler and more
    efficient to have the parameters themselves be the entries in the
    pend_le_conns list. We do this by adding another list_head to the
    hci_conn_params struct.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b5f4405b41c2..09f9fb85d8fd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -439,6 +439,7 @@ struct hci_chan {
 
 struct hci_conn_params {
 	struct list_head list;
+	struct list_head pend_le_conn;
 
 	bdaddr_t addr;
 	u8 addr_type;
@@ -867,10 +868,10 @@ void hci_conn_params_clear_all(struct hci_dev *hdev);
 void hci_conn_params_clear_disabled(struct hci_dev *hdev);
 void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 
-struct bdaddr_list *hci_pend_le_conn_lookup(struct hci_dev *hdev,
-					    bdaddr_t *addr, u8 addr_type);
-void hci_pend_le_conn_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
-void hci_pend_le_conn_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
+struct hci_conn_params *hci_pend_le_conn_lookup(struct hci_dev *hdev,
+						bdaddr_t *addr, u8 addr_type);
+void hci_pend_le_conn_add(struct hci_dev *hdev, struct hci_conn_params *params);
+void hci_pend_le_conn_del(struct hci_dev *hdev, struct hci_conn_params *params);
 void hci_pend_le_conns_clear(struct hci_dev *hdev);
 
 void hci_update_background_scan(struct hci_dev *hdev);

commit 851efca8387e10a25ca259f7efcc47819b19bff9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 22:42:00 2014 +0300

    Bluetooth: Track number of added devices with HCI_AUTO_CONN_REPORT
    
    To be able to make the right choice of whether to start passive scanning
    or to send out a mgmt_device_found event we need to know if there are
    any devices in the le_conn_params list with the auto_connect value set
    to HCI_AUTO_CONN_REPORT. This patch adds a counter for this kind of
    devices.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 92f1bad6e22d..b5f4405b41c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -312,6 +312,7 @@ struct hci_dev {
 	struct list_head	le_white_list;
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
+	unsigned int		pend_le_reports;
 
 	struct hci_dev_stats	stat;
 

commit c46245b3efce80884acf65c01443582aec1f31ed
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:33 2014 +0300

    Bluetooth: Make is_identity_address a global function
    
    There are more places that can take advantage of is_identity_address()
    besides hci_core.c. This patch moves the function to hci_core.h and
    gives it the appropriate hci_ prefix.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d0bca13843ce..92f1bad6e22d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1179,6 +1179,18 @@ static inline bool hci_bdaddr_is_rpa(bdaddr_t *bdaddr, u8 addr_type)
 	return false;
 }
 
+static inline bool hci_is_identity_address(bdaddr_t *addr, u8 addr_type)
+{
+	if (addr_type == ADDR_LE_DEV_PUBLIC)
+		return true;
+
+	/* Check for Random Static address type */
+	if ((addr->b[5] & 0xc0) == 0xc0)
+		return true;
+
+	return false;
+}
+
 static inline struct smp_irk *hci_get_irk(struct hci_dev *hdev,
 					  bdaddr_t *bdaddr, u8 addr_type)
 {

commit f4869e2adb7ab9d09a9335b4e26a63ec413f2c6f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:32 2014 +0300

    Bluetooth: Pass store hint to mgmt_new_conn_param
    
    The calling functions of mgmt_new_conn_param have more information about
    the parameters, such as whether the kernel is tracking them or not. It
    makes therefore sense to have them pass an initial store_hint value to
    the mgmt_new_conn_param function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 32c8e51f6b26..d0bca13843ce 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1335,8 +1335,8 @@ void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
 void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,
 		   bool persistent);
 void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			 u8 bdaddr_type, u16 min_interval, u16 max_interval,
-			 u16 latency, u16 timeout);
+			 u8 bdaddr_type, u8 store_hint, u16 min_interval,
+			 u16 max_interval, u16 latency, u16 timeout);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 

commit 7d6ca6939cb2f701204317cbab15af1b98f7f501
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:31 2014 +0300

    Bluetooth: Make hci_le_conn_update return the store hint
    
    The caller of hci_le_conn_update is directly interested in knowing what
    the best value is for the store_hint parameter of the corresponding
    mgmt event. Since hci_le_conn_update knows whether there were stored
    parameters that were updated or not we can have it return an initial
    store_hint value to the caller.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f4a2f50f30b5..32c8e51f6b26 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1368,8 +1368,8 @@ struct hci_sec_filter {
 #define hci_req_lock(d)		mutex_lock(&d->req_lock)
 #define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
 
-void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
-					u16 latency, u16 to_multiplier);
+u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
+		      u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
 							__u8 ltk[16]);
 

commit a3451d279f839d987cbcf25b0f3be666aef99d0b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:27 2014 +0300

    Bluetooth: Add new auto_conn value matching mgmt action 0x00
    
    The 0x00 action value of mgmt means "scan and report" but do not
    connect. This is different from HCI_AUTO_CONN_DISABLED so we need a new
    value for it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2091e0013b8c..f4a2f50f30b5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -449,6 +449,7 @@ struct hci_conn_params {
 
 	enum {
 		HCI_AUTO_CONN_DISABLED,
+		HCI_AUTO_CONN_REPORT,
 		HCI_AUTO_CONN_ALWAYS,
 		HCI_AUTO_CONN_LINK_LOSS,
 	} auto_connect;

commit 55af49a8fe85278ea244e72d2d264cf5e0941c61
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:26 2014 +0300

    Bluetooth: Add specific connection parameter clear functions
    
    In some circumstances we'll need to either clear only the enabled
    parameters or only the disabled ones. This patch adds convenience
    functions for this purpose.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 091934bcfd84..2091e0013b8c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -862,6 +862,8 @@ int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 			u8 auto_connect);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear_all(struct hci_dev *hdev);
+void hci_conn_params_clear_disabled(struct hci_dev *hdev);
+void hci_conn_params_clear_enabled(struct hci_dev *hdev);
 
 struct bdaddr_list *hci_pend_le_conn_lookup(struct hci_dev *hdev,
 					    bdaddr_t *addr, u8 addr_type);

commit 373110c5d30b0944b47cddbe586069b7457f8845
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:25 2014 +0300

    Bluetooth: Rename hci_conn_params_clear to hci_conn_params_clear_all
    
    We'll soon have specific clear functions for clearing enabled or
    disabled entries, so rename the function that removes everything to
    clear_all().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ee480a86e558..091934bcfd84 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -861,7 +861,7 @@ struct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,
 int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 			u8 auto_connect);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
-void hci_conn_params_clear(struct hci_dev *hdev);
+void hci_conn_params_clear_all(struct hci_dev *hdev);
 
 struct bdaddr_list *hci_pend_le_conn_lookup(struct hci_dev *hdev,
 					    bdaddr_t *addr, u8 addr_type);

commit 24c457e27076beb2a85b4213642a6388eb88f240
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 2 00:53:47 2014 +0200

    Bluetooth: Add support for hdev->set_bdaddr callback handling
    
    Some embedded controllers allow the programming of a public address
    and this adds vendor support for supporting OEM confguration of such
    addresses.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 01fbbe20defb..ee480a86e558 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -171,6 +171,7 @@ struct hci_dev {
 	__u8		bus;
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
+	bdaddr_t	public_addr;
 	bdaddr_t	random_addr;
 	bdaddr_t	static_addr;
 	__u8		adv_addr_type;
@@ -344,6 +345,7 @@ struct hci_dev {
 	int (*setup)(struct hci_dev *hdev);
 	int (*send)(struct hci_dev *hdev, struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
+	int (*set_bdaddr)(struct hci_dev *hdev, const bdaddr_t *bdaddr);
 };
 
 #define HCI_PHY_HANDLE(handle)	(handle & 0xff)

commit ffb5a827d5ca5aef3f3fe5d64e42f3cf7fed4fc8
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Jul 1 18:10:11 2014 -0300

    Bluetooth: Introduce "New Connection Parameter" Event
    
    This patch introduces a new Mgmt event called "New Connection Parameter".
    This event indicates to userspace the connection parameters values the
    remote device requested.
    
    The user may store these values and load them into kernel. This way, next
    time a connection is established to that device, the kernel will use those
    parameters values instead of the default ones.
    
    This event is sent when the remote device requests new connection
    parameters through connection parameter update procedure. This event is
    not sent for slave connections.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3404f9bd2da0..01fbbe20defb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1329,6 +1329,9 @@ void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent);
 void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
 void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,
 		   bool persistent);
+void mgmt_new_conn_param(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			 u8 bdaddr_type, u16 min_interval, u16 max_interval,
+			 u16 latency, u16 timeout);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 

commit 2a8357f2393d89a34b5a77051d29951af9646406
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jul 1 22:09:47 2014 +0300

    Bluetooth: Fix redundant device (un)blocked events
    
    For the Block/Unblock Device mgmt commands we should only emit the
    Blocked/Unblocked events on any socket except for the one which received
    the command. The code was previously incorrectly trying to look up a
    non-existent pending command and thereby ending up not skipping the
    command socket for the event.
    
    We can simplify the code a lot by simply sending the event directly from
    the command handler functions. We have the reference to the command
    socket available there which makes it easy to pass to the mgmt_event
    function for skipping.
    
    The only notable side-effect of this is that the old blacklisting
    ioctl's no-longer cause mgmt events to be emitted, however as user space
    versions using these ioctl's are not mgmt-aware this is acceptable.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9078da681f16..3404f9bd2da0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1325,8 +1325,6 @@ void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
-int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent);
 void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
 void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,

commit fe59a05f941dbeb14316449be42d059761bed62c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jul 1 19:14:12 2014 +0300

    Bluetooth: Add flag to track STK encryption
    
    There are certain subtle differences in behavior when we're encrypted
    with the STK, such as allowing re-encryption even though the security
    level stays the same. Because of this, add a flag to track whether we're
    encrypted with an STK or not.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index eb0add396595..9078da681f16 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -536,6 +536,7 @@ enum {
 	HCI_CONN_AUTH,
 	HCI_CONN_SECURE,
 	HCI_CONN_FIPS,
+	HCI_CONN_STK_ENCRYPT,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit c70a7e4cc8d22cb1ce684637ef8a4bb3a80d15b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 14:11:21 2014 +0200

    Bluetooth: Add support for Not Connectable flag for Device Found events
    
    The Device Found events of the management interface should indicate if
    it is possible to connect to a remote device or if it is broadcaster
    only advertising. To allow this differentation the Not Connectable flag
    is introduced that will be set when it is known that a device can not
    be connected.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ab3d4dda071c..eb0add396595 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -71,6 +71,7 @@ struct discovery_state {
 	bdaddr_t		last_adv_addr;
 	u8			last_adv_addr_type;
 	s8			last_adv_rssi;
+	u32			last_adv_flags;
 	u8			last_adv_data[HCI_MAX_AD_LENGTH];
 	u8			last_adv_data_len;
 };

commit af58925ca6175695e502fa792f43a946f7474765
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 14:11:20 2014 +0200

    Bluetooth: Provide flags parameter direct to mgmt_device_found
    
    Providing the flags parameter directly to mgmt_device_found function
    makes the core simpler and more readable. With this it becomes a lot
    easier to add new flags in the future.
    
    This also changes hci_inquiry_cache_update to just return that flags
    needed for mgmt_device_found since that is its only use for the two
    return parameters anyway.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 61d4d265f42d..ab3d4dda071c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -510,8 +510,8 @@ struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
 						       int state);
 void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
 				      struct inquiry_entry *ie);
-bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
-			      bool name_known, bool *ssp);
+u32 hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+			     bool name_known);
 void hci_inquiry_cache_flush(struct hci_dev *hdev);
 
 /* ----- HCI Connections ----- */
@@ -1318,9 +1318,8 @@ void mgmt_read_local_oob_data_complete(struct hci_dev *hdev, u8 *hash192,
 				       u8 *randomizer192, u8 *hash256,
 				       u8 *randomizer256, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
-		       u8 ssp, u8 *eir, u16 eir_len, u8 *scan_rsp,
-		       u8 scan_rsp_len);
+		       u8 addr_type, u8 *dev_class, s8 rssi, u32 flags,
+		       u8 *eir, u16 eir_len, u8 *scan_rsp, u8 scan_rsp_len);
 void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);

commit d06b50ce14119acb04773a9808ccff5d1767b7e4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 12:11:06 2014 +0200

    Bluetooth: Remove connection interval parameters from hci_conn_params_set
    
    The connection interval parameter of hci_conn_params_set are always used
    with the controller defaults. So just let hci_conn_params_add set the
    controller default and not bother resetting them to controller defaults
    every time the hci_conn_params_set is called.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5a83621672bf..61d4d265f42d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -855,8 +855,7 @@ struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 struct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,
 					    bdaddr_t *addr, u8 addr_type);
 int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
-			u8 auto_connect, u16 conn_min_interval,
-			u16 conn_max_interval);
+			u8 auto_connect);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear(struct hci_dev *hdev);
 

commit 51d167c0972ef1496f2e6ab08aab602644d1f9bb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 1 12:11:04 2014 +0200

    Bluetooth: Change hci_conn_params_add to return the parameter struct
    
    When adding new connection parameters, it is useful to return either
    the existing struct or the newly created one.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ec830871b9b8..5a83621672bf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -852,7 +852,8 @@ int hci_white_list_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);
-int hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
+struct hci_conn_params *hci_conn_params_add(struct hci_dev *hdev,
+					    bdaddr_t *addr, u8 addr_type);
 int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 			u8 auto_connect, u16 conn_min_interval,
 			u16 conn_max_interval);

commit d4905f2453bd228d8ffc57f4e25bba0a8f52c805
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Jun 25 21:52:52 2014 -0300

    Bluetooth: Connection parameters check helper
    
    This patch renames l2cap_check_conn_param() to hci_check_conn_params()
    and moves it to hci_core.h so it can reused in others files. This helper
    will be reused in the next patch.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c0d2506e2019..ec830871b9b8 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1181,6 +1181,27 @@ static inline struct smp_irk *hci_get_irk(struct hci_dev *hdev,
 	return hci_find_irk_by_rpa(hdev, bdaddr);
 }
 
+static inline int hci_check_conn_params(u16 min, u16 max, u16 latency,
+					u16 to_multiplier)
+{
+	u16 max_latency;
+
+	if (min > max || min < 6 || max > 3200)
+		return -EINVAL;
+
+	if (to_multiplier < 10 || to_multiplier > 3200)
+		return -EINVAL;
+
+	if (max >= to_multiplier * 8)
+		return -EINVAL;
+
+	max_latency = (to_multiplier * 8 / max) - 1;
+	if (latency > 499 || latency > max_latency)
+		return -EINVAL;
+
+	return 0;
+}
+
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit bf5b3c8be07905c242bb7f751dcb890b94c22d93
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 12:34:39 2014 +0200

    Bluetooth: Provide function to create and set connection parameters
    
    In some cases it is useful to not overwrite connection parametes and
    instead just create default ones if they don't exist. This function
    does exactly that. hci_conn_params_add will allow to create new
    default connection parameters. hci_conn_params_set will set the
    values and also create new parameters if they don't exist.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ed842c7e5cf1..c0d2506e2019 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -852,7 +852,8 @@ int hci_white_list_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);
-int hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
+int hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
+int hci_conn_params_set(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 			u8 auto_connect, u16 conn_min_interval,
 			u16 conn_max_interval);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);

commit 04fb7d9066dd9173ef0d4ccea8fe3bb59bd94605
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 12:34:36 2014 +0200

    Bluetooth: Provide defaults for LE connection latency and timeout
    
    Store the connection latency and supervision timeout default values
    with all the other controller defaults. And when needed use them
    for new connections.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 182044824495..ed842c7e5cf1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -203,6 +203,8 @@ struct hci_dev {
 	__u16		le_scan_window;
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
+	__u16		le_conn_latency;
+	__u16		le_supv_timeout;
 	__u16		discov_interleaved_timeout;
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;

commit f044eb0524a02ea7f921c9234fbdba43290da1e2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 16:43:26 2014 +0200

    Bluetooth: Store latency and supervision timeout in connection params
    
    When the slave updates the connection parameters, store also the
    connection latency and supervision timeout information in the
    internal list of connection parameters for known devices.
    
    Having these values available allowes the auto-connection
    procedure to use the correct values from the beginning without
    having to request an update on every connection establishment.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0906990dedd8..182044824495 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -439,6 +439,8 @@ struct hci_conn_params {
 
 	u16 conn_min_interval;
 	u16 conn_max_interval;
+	u16 conn_latency;
+	u16 supervision_timeout;
 
 	enum {
 		HCI_AUTO_CONN_DISABLED,

commit 33f35721030185a2c5a1bb8afd4c3744709745b5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sat Jun 28 17:54:06 2014 +0300

    Bluetooth: Add tracking of local and piconet clock values
    
    This patch adds support for storing the local and piconet clock values
    from the HCI_Read_Clock command response to the hci_dev and hci_conn
    structs. This will be later used in another patch to implement support
    for the Get Clock Info mgmt command.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ca2a99807615..0906990dedd8 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -207,6 +207,7 @@ struct hci_dev {
 	__u16		conn_info_min_age;
 	__u16		conn_info_max_age;
 	__u8		ssp_debug_mode;
+	__u32		clock;
 
 	__u16		devid_source;
 	__u16		devid_vendor;
@@ -388,6 +389,9 @@ struct hci_conn {
 	__s8		max_tx_power;
 	unsigned long	flags;
 
+	__u32		clock;
+	__u16		clock_accuracy;
+
 	unsigned long	conn_info_timestamp;
 
 	__u8		remote_cap;

commit b10e8017bd9d02a3c7975c06d8fa2fc39df1731c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jun 27 14:23:07 2014 +0300

    Bluetooth: Remove unnecessary hcon->smp_conn variable
    
    The smp_conn member of struct hci_conn was simply a pointer to the
    l2cap_conn object. Since we already have hcon->l2cap_data that points to
    the same thing there's no need to have this second variable. This patch
    removes it and changes the single place that was using it to use
    hcon->l2cap_data instead.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dda7f00c07c5..ca2a99807615 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -409,7 +409,6 @@ struct hci_conn {
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
-	void		*smp_conn;
 	struct amp_mgr	*amp_mgr;
 
 	struct hci_conn	*link;

commit dbbfa2ab7a2a508fd6ad2ce08f7f34c3041f51ef
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Jun 25 16:44:45 2014 -0300

    Bluetooth: Use macro instead of hard-coded value
    
    This patch replaces the hard-coded value in hci_bdaddr_is_rpa() helper
    by the corresponding macro ADDR_LE_DEV_RANDOM.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0b0597d81827..dda7f00c07c5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1155,7 +1155,7 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 
 static inline bool hci_bdaddr_is_rpa(bdaddr_t *bdaddr, u8 addr_type)
 {
-	if (addr_type != 0x01)
+	if (addr_type != ADDR_LE_DEV_RANDOM)
 		return false;
 
 	if ((bdaddr->b[5] & 0xc0) == 0x40)

commit 4dae27983eaaee15c6867561eb2c8d7b2d28d6cc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jun 24 17:03:50 2014 +0300

    Bluetooth: Convert hci_conn->link_mode into flags
    
    Since the link_mode member of the hci_conn struct is a bit field and we
    already have a flags member as well it makes sense to merge these two
    together. This patch moves all used link_mode bits into corresponding
    flags. To keep backwards compatibility with user space we still need to
    provide a get_link_mode() helper function for the ioctl's that expect a
    link_mode style value.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4f70605e0399..0b0597d81827 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -367,7 +367,6 @@ struct hci_conn {
 	__u8		features[HCI_MAX_PAGES][8];
 	__u16		pkt_type;
 	__u16		link_policy;
-	__u32		link_mode;
 	__u8		key_type;
 	__u8		auth_type;
 	__u8		sec_level;
@@ -524,6 +523,11 @@ enum {
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
 	HCI_CONN_FLUSH_KEY,
+	HCI_CONN_MASTER,
+	HCI_CONN_ENCRYPT,
+	HCI_CONN_AUTH,
+	HCI_CONN_SECURE,
+	HCI_CONN_FIPS,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
@@ -1025,7 +1029,7 @@ static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
-	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+	encrypt = test_bit(HCI_CONN_ENCRYPT, &conn->flags) ? 0x01 : 0x00;
 	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
@@ -1066,7 +1070,7 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
-	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+	encrypt = test_bit(HCI_CONN_ENCRYPT, &conn->flags) ? 0x01 : 0x00;
 
 	read_lock(&hci_cb_list_lock);
 	list_for_each_entry(cb, &hci_cb_list, list) {

commit af6a9c321384400efab1726636e8189737bbbd09
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jun 24 13:15:53 2014 +0300

    Bluetooth: Convert hcon->flush_key to a proper flag
    
    There's no point in having boolean variables in the hci_conn struct
    since it already has a flags member. This patch converts the flush_key
    member into a proper flag.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 888911d205dc..4f70605e0399 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -394,7 +394,6 @@ struct hci_conn {
 	__u8		remote_cap;
 	__u8		remote_auth;
 	__u8		remote_id;
-	bool		flush_key;
 
 	unsigned int	sent;
 
@@ -524,6 +523,7 @@ enum {
 	HCI_CONN_AES_CCM,
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
+	HCI_CONN_FLUSH_KEY,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit 7652ff6aeaf0eeaec1f2e7e2f3ce0e588447dbd1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jun 24 13:15:49 2014 +0300

    Bluetooth: Move mgmt event sending out from hci_add_link_key()
    
    There are two callers of hci_add_link_key(). The first one is the HCI
    Link Key Notification event and the second one the mgmt code that
    receives a list of link keys from user space. Previously we've had the
    hci_add_link_key() function being responsible for also emitting a mgmt
    signal but for the latter use case this should not happen. Because of
    this a rather awkward new_key paramter has been passed to the function.
    
    This patch moves the mgmt event sending out from the hci_add_link_key()
    function, thereby making the code a bit more understandable.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7f81791a865d..888911d205dc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -860,8 +860,8 @@ void hci_uuids_clear(struct hci_dev *hdev);
 void hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 struct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,
-				  int new_key, bdaddr_t *bdaddr, u8 *val,
-				  u8 type, u8 pin_len);
+				  bdaddr_t *bdaddr, u8 *val, u8 type,
+				  u8 pin_len, bool *persistent);
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, __le64 rand,
 			     bool master);
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit 567fa2aa3dfad9848c25a226927a4ca5f94229ac
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jun 24 13:15:48 2014 +0300

    Bluetooth: Update hci_add_link_key() to return pointer to key
    
    By returning the added (or updated) key we pave the way for further
    refactoring (in subsequent patches) that allows moving the mgmt event
    sending out from this function (and thereby removal of the awkward
    new_key parameter).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cd73a82cc713..7f81791a865d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -859,8 +859,9 @@ void hci_uuids_clear(struct hci_dev *hdev);
 
 void hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
-		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+struct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,
+				  int new_key, bdaddr_t *bdaddr, u8 *val,
+				  u8 type, u8 pin_len);
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, __le64 rand,
 			     bool master);
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit e04fde60efabe27afdbe041e3e5a09ec752ec9d2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 23 11:40:04 2014 +0200

    Bluetooth: Store current LE connection parameters in hci_conn struct
    
    The LE connection parameters are needed later on to be able to decide
    if it is required to trigger connection update procedures. So when the
    connection has been established successfully, store the current used
    parameters in hci_conn struct.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c81de0d366df..cd73a82cc713 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -381,6 +381,9 @@ struct hci_conn {
 	__u16		setting;
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
+	__u16		le_conn_interval;
+	__u16		le_conn_latency;
+	__u16		le_supv_timeout;
 	__s8		rssi;
 	__s8		tx_power;
 	__s8		max_tx_power;

commit 6b8d4a6a03144c5996f98db7f8256267b0d72a3a
Author: Jukka Rissanen <jukka.rissanen@linux.intel.com>
Date:   Wed Jun 18 16:37:08 2014 +0300

    Bluetooth: 6LoWPAN: Use connected oriented channel instead of fixed one
    
    Create a CoC dynamically instead of one fixed channel for communication
    to peer devices.
    
    Signed-off-by: Jukka Rissanen <jukka.rissanen@linux.intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bf41e992a618..c81de0d366df 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -521,7 +521,6 @@ enum {
 	HCI_CONN_AES_CCM,
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
-	HCI_CONN_6LOWPAN,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit 111902f7236ff8139c30c2b9709c999fcb931399
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 21 04:53:17 2014 +0200

    Bluetooth: Use separate dbg_flags to special debugfs options
    
    All the special settings configured via debugfs are either developer
    only options or temporary solutions. To not clutter the standard flags,
    move them to their own dbg_flags entry.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index de3bb22e83f9..bf41e992a618 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -318,6 +318,7 @@ struct hci_dev {
 
 	struct rfkill		*rfkill;
 
+	unsigned long		dbg_flags;
 	unsigned long		dev_flags;
 
 	struct delayed_work	le_scan_disable;

commit 65cc2b49db63adf1455a9783234383fbec5b8314
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 16 12:30:56 2014 +0200

    Bluetooth: Use struct delayed_work for HCI command timeout
    
    Since the whole HCI command, event and data packet processing has been
    migrated to use workqueues instead of tasklets, it makes sense to use
    struct delayed_work instead of struct timer_list for the timeout
    handling. This patch converts the hdev->cmd_timer to use workqueue
    as well.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b386bf17e6c2..de3bb22e83f9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -273,7 +273,7 @@ struct hci_dev {
 
 	struct delayed_work	service_cache;
 
-	struct timer_list	cmd_timer;
+	struct delayed_work	cmd_timer;
 
 	struct work_struct	rx_work;
 	struct work_struct	cmd_work;

commit d0455ed996df84fd2670a655fe13ab72f8264765
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Wed May 14 13:43:05 2014 +0200

    Bluetooth: Store max TX power level for connection
    
    This patch adds support to store local maximum TX power level for
    connection when reply for HCI_Read_Transmit_Power_Level is received.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cbbab6327621..b386bf17e6c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -382,6 +382,7 @@ struct hci_conn {
 	__u16		le_conn_max_interval;
 	__s8		rssi;
 	__s8		tx_power;
+	__s8		max_tx_power;
 	unsigned long	flags;
 
 	unsigned long	conn_info_timestamp;

commit dd9838087b8c2b45c7976e46290749732d7af9d5
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Wed May 14 13:43:03 2014 +0200

    Bluetooth: Add support to get connection information
    
    This patch adds support for Get Connection Information mgmt command
    which can be used to query for information about connection, i.e. RSSI
    and local TX power level.
    
    In general values cached in hci_conn are returned as long as they are
    considered valid, i.e. do not exceed age limit set in hdev. This limit
    is calculated as random value between min/max values to avoid client
    trying to guess when to poll for updated information.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4623f45c8892..cbbab6327621 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -384,6 +384,8 @@ struct hci_conn {
 	__s8		tx_power;
 	unsigned long	flags;
 
+	unsigned long	conn_info_timestamp;
+
 	__u8		remote_cap;
 	__u8		remote_auth;
 	__u8		remote_id;

commit 31ad169148df2252a774c73c504aff43bfa4b656
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Wed May 14 13:43:02 2014 +0200

    Bluetooth: Add conn info lifetime parameters to debugfs
    
    This patch adds conn_info_min_age and conn_info_max_age parameters to
    debugfs which determine lifetime of connection information. Actual
    lifetime will be random value between min and max age.
    
    Default values for min and max age are 1000ms and 3000ms respectively.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 211bad6a3366..4623f45c8892 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -145,6 +145,10 @@ struct oob_data {
 /* Default LE RPA expiry time, 15 minutes */
 #define HCI_DEFAULT_RPA_TIMEOUT		(15 * 60)
 
+/* Default min/max age of connection information (1s/3s) */
+#define DEFAULT_CONN_INFO_MIN_AGE	1000
+#define DEFAULT_CONN_INFO_MAX_AGE	3000
+
 struct amp_assoc {
 	__u16	len;
 	__u16	offset;
@@ -200,6 +204,8 @@ struct hci_dev {
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
 	__u16		discov_interleaved_timeout;
+	__u16		conn_info_min_age;
+	__u16		conn_info_max_age;
 	__u8		ssp_debug_mode;
 
 	__u16		devid_source;

commit 5a134faeef82b46ff4ad244d11d8c6be41679834
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Fri May 9 21:35:28 2014 +0200

    Bluetooth: Store TX power level for connection
    
    This patch adds support to store local TX power level for connection
    when reply for HCI_Read_Transmit_Power_Level is received.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0318d5263837..211bad6a3366 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -375,6 +375,7 @@ struct hci_conn {
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
 	__s8		rssi;
+	__s8		tx_power;
 	unsigned long	flags;
 
 	__u8		remote_cap;

commit 5ae76a94150c86a6e0ee84eb74e7f7e1909b8d39
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Thu May 8 15:32:08 2014 +0200

    Bluetooth: Store RSSI for connection
    
    This patch adds support to store RSSI for connection when reply for
    HCI_Read_RSSI is received.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d73f41855ada..0318d5263837 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -374,6 +374,7 @@ struct hci_conn {
 	__u16		setting;
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
+	__s8		rssi;
 	unsigned long	flags;
 
 	__u8		remote_cap;

commit 3d5a76f08bbac55305da87f4c810279189f64297
Author: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date:   Thu Mar 27 20:55:21 2014 +0100

    Bluetooth: Keep msec in DISCOV_LE_TIMEOUT
    
    To be consistent, lets use msec for this timeout as well.
    
    Note: This define value is a minimum scan time taken from BT Core spec 4.0,
    Vol 3, Part C, chapter 9.2.6
    
    Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e0c26bc144e5..d73f41855ada 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1210,7 +1210,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
  */
 #define DISCOV_LE_SCAN_WIN		0x12
 #define DISCOV_LE_SCAN_INT		0x12
-#define DISCOV_LE_TIMEOUT		msecs_to_jiffies(10240)
+#define DISCOV_LE_TIMEOUT		10240	/* msec */
 #define DISCOV_INTERLEAVED_TIMEOUT	5120	/* msec */
 #define DISCOV_INTERLEAVED_INQUIRY_LEN	0x04
 #define DISCOV_BREDR_INQUIRY_LEN	0x08

commit b9a7a61e5c3e2f6316c2aedf4ca171bdee7a4804
Author: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date:   Thu Mar 27 20:55:20 2014 +0100

    Bluetooth: Add new debugfs parameter
    
    With this patch it is possible to control discovery interleaved
    timeout value from debugfs.
    
    It is for fine tuning of this timeout.
    
    Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 08a1d44eeab0..e0c26bc144e5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -199,6 +199,7 @@ struct hci_dev {
 	__u16		le_scan_window;
 	__u16		le_conn_min_interval;
 	__u16		le_conn_max_interval;
+	__u16		discov_interleaved_timeout;
 	__u8		ssp_debug_mode;
 
 	__u16		devid_source;

commit ae55f5982a8bc6adbafb337e0b781d30d5617782
Author: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date:   Thu Mar 27 20:55:19 2014 +0100

    Bluetooth: Keep msec in DISCOV_INTERLEAVED_TIMEOUT
    
    Keep msec instead of jiffies in this define. This is needed by following
    patch where we want this timeout to be exposed in debugfs.
    
    Note: Value of this timeout comes from recommendation in BT Core Spec.4.0,
    Vol 3, Part C, chapter 13.2.1.
    
    Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c2a419c2c5c7..08a1d44eeab0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1210,7 +1210,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 #define DISCOV_LE_SCAN_WIN		0x12
 #define DISCOV_LE_SCAN_INT		0x12
 #define DISCOV_LE_TIMEOUT		msecs_to_jiffies(10240)
-#define DISCOV_INTERLEAVED_TIMEOUT	msecs_to_jiffies(5120)
+#define DISCOV_INTERLEAVED_TIMEOUT	5120	/* msec */
 #define DISCOV_INTERLEAVED_INQUIRY_LEN	0x04
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 

commit ff5cd29f5cb8de0f0bc9016874ddde467d4b0c85
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 25 14:40:52 2014 +0200

    Bluetooth: Store also RSSI for pending advertising reports
    
    Especially in crowded environments it can become frequent that we have
    to send out whatever pending event there is stored. Since user space
    has its own filtering of small RSSI changes sending a 0 value will
    essentially force user space to wake up the higher layers (e.g. over
    D-Bus) even though the RSSI didn't actually change more than the
    threshold value.
    
    This patch adds storing also of the RSSI for pending advertising reports
    so that we report an as accurate RSSI as possible when we have to send
    out the stored information to user space.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0ba7617ceb27..c2a419c2c5c7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -70,6 +70,7 @@ struct discovery_state {
 	__u32			timestamp;
 	bdaddr_t		last_adv_addr;
 	u8			last_adv_addr_type;
+	s8			last_adv_rssi;
 	u8			last_adv_data[HCI_MAX_AD_LENGTH];
 	u8			last_adv_data_len;
 };

commit 73cf71d9865ad83c2ab7d09bc71be129088e4ded
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 25 12:06:19 2014 +0200

    Bluetooth: Fix line splitting of mgmt_device_found parameters
    
    The line was incorrectly split between the variable type and its name.
    This patch fixes the issue.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 59b112397d39..0ba7617ceb27 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1268,8 +1268,8 @@ void mgmt_read_local_oob_data_complete(struct hci_dev *hdev, u8 *hash192,
 				       u8 *randomizer192, u8 *hash256,
 				       u8 *randomizer256, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name, u8
-		       ssp, u8 *eir, u16 eir_len, u8 *scan_rsp,
+		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
+		       u8 ssp, u8 *eir, u16 eir_len, u8 *scan_rsp,
 		       u8 scan_rsp_len);
 void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);

commit b9a6328f2a7f15490de7e45eabb025f8b74a81af
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 25 10:51:52 2014 +0200

    Bluetooth: Merge ADV_IND/ADV_SCAN_IND and SCAN_RSP together
    
    To avoid too many events being sent to user space and to help parsing of
    all available remote device data it makes sense for us to wait for the
    scan response and send a single merged Device Found event to user space.
    
    This patch adds a few new variables to hci_dev to track the last
    received ADV_IND/ADV_SCAN_IND, i.e. those which will cause a SCAN_REQ to
    be send in the case of active scanning. When the SCAN_RSP is received
    the pending data is passed together with the SCAN_RSP to the
    mgmt_device_found function which takes care of merging them into a
    single Device Found event.
    
    We also need a bit of extra logic to handle situations where we don't
    receive a SCAN_RSP after caching some data. In such a scenario we simply
    have to send out the pending data as it is and then operate on the new
    report as if there was no pending data.
    
    We also need to send out any pending data when scanning stops as
    well as ensure that the storage is empty at the start of a new active
    scanning session. These both cases are covered by the update to the
    hci_cc_le_set_scan_enable function in this patch.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a1b8eab8a47d..59b112397d39 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -68,6 +68,10 @@ struct discovery_state {
 	struct list_head	unknown;	/* Name state not known */
 	struct list_head	resolve;	/* Name needs to be resolved */
 	__u32			timestamp;
+	bdaddr_t		last_adv_addr;
+	u8			last_adv_addr_type;
+	u8			last_adv_data[HCI_MAX_AD_LENGTH];
+	u8			last_adv_data_len;
 };
 
 struct hci_conn_hash {

commit 5d2e9fadf43e87e690bfbe607313bf9be47867e4
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 25 10:30:47 2014 +0200

    Bluetooth: Add scan_rsp parameter to mgmt_device_found()
    
    In preparation for being able to merge ADV_IND/ADV_SCAN_IND and SCAN_RSP
    together into a single device found event add a second parameter to the
    mgmt_device_found function. For now all callers pass NULL as this
    parameters since we don't yet have storing of the last received
    advertising report.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5f8bc05694ac..a1b8eab8a47d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1264,8 +1264,9 @@ void mgmt_read_local_oob_data_complete(struct hci_dev *hdev, u8 *hash192,
 				       u8 *randomizer192, u8 *hash256,
 				       u8 *randomizer256, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
-		       u8 ssp, u8 *eir, u16 eir_len);
+		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name, u8
+		       ssp, u8 *eir, u16 eir_len, u8 *scan_rsp,
+		       u8 scan_rsp_len);
 void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);

commit 533553f8738184bcf957d97fed9eb4d5f023e4a7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 21 12:18:10 2014 -0700

    Bluetooth: Track current configured LE scan type parameter
    
    The LE scan type paramter defines if active scanning or passive scanning
    is in use. Track the currently set value so it can be used for decision
    making from other pieces in the core.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index afbea388eda1..5f8bc05694ac 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -189,6 +189,7 @@ struct hci_dev {
 	__u16		page_scan_window;
 	__u8		page_scan_type;
 	__u8		le_adv_channel_map;
+	__u8		le_scan_type;
 	__u16		le_scan_interval;
 	__u16		le_scan_window;
 	__u16		le_conn_min_interval;

commit 39adbffe4b16285c54016d3e64471396354ae49f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Mar 20 08:18:14 2014 +0200

    Bluetooth: Fix passkey endianess in user_confirm and notify_passkey
    
    The passkey_notify and user_confirm functions in mgmt.c were expecting
    different endianess for the passkey, leading to a big endian bug and
    sparse warning in recently added SMP code. This patch converts both
    functions to expect host endianess and do the conversion to little
    endian only when assigning to the mgmt event struct.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b8cc39a4a9a5..afbea388eda1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1236,7 +1236,7 @@ void mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				      u8 status);
 int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			      u8 link_type, u8 addr_type, __le32 value,
+			      u8 link_type, u8 addr_type, u32 value,
 			      u8 confirm_hint);
 int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 link_type, u8 addr_type, u8 status);

commit 53ac6ab612456a13bf0f6bad89c1503616e4de3b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 9 23:38:42 2014 -0700

    Bluetooth: Make LTK and CSRK only persisent when bonding
    
    In case the pairable option has been disabled, the pairing procedure
    does not create keys for bonding. This means that these generated keys
    should not be stored persistently.
    
    For LTK and CSRK this is important to tell userspace to not store these
    new keys. They will be available for the lifetime of the device, but
    after the next power cycle they should not be used anymore.
    
    Inform userspace to actually store the keys persistently only if both
    sides request bonding.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e869884fbfa9..b8cc39a4a9a5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1270,9 +1270,10 @@ void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key);
+void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, bool persistent);
 void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
-void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk);
+void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk,
+		   bool persistent);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 

commit 7ee4ea3692f20b87b0e0d3884d5b2d22ec1a2df0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 9 12:19:17 2014 -0700

    Bluetooth: Add support for handling signature resolving keys
    
    The connection signature resolving key (CSRK) is used for attribute
    protocol signed write procedures. This change generates a new local
    key during pairing and requests the peer key as well.
    
    Newly generated key and received key will be provided to userspace
    using the New Signature Resolving Key management event.
    
    The Master CSRK can be used for verification of remote signed write
    PDUs and the Slave CSRK can be used for sending signed write PDUs
    to the remote device.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dbb788e4f265..e869884fbfa9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -91,6 +91,13 @@ struct bt_uuid {
 	u8 svc_hint;
 };
 
+struct smp_csrk {
+	bdaddr_t bdaddr;
+	u8 bdaddr_type;
+	u8 master;
+	u8 val[16];
+};
+
 struct smp_ltk {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -1265,6 +1272,7 @@ int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key);
 void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
+void mgmt_new_csrk(struct hci_dev *hdev, struct smp_csrk *csrk);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 

commit 9489eca4ab2fd5d9bbf3bab992168cc8107fc3e9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 17:45:46 2014 +0200

    Bluetooth: Add timeout for LE connection attempts
    
    LE connection attempts do not have a controller side timeout in the same
    way as BR/EDR has (in form of the page timeout). Since we always do
    scanning before initiating connections the attempts are always expected
    to succeed in some reasonable time.
    
    This patch adds a timer which forces a cancellation of the connection
    attempt within 20 seconds if it has not been successful by then. This
    way we e.g. ensure that mgmt_pair_device times out eventually and gives
    an error response.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index edf194679b7d..dbb788e4f265 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -375,6 +375,7 @@ struct hci_conn {
 	struct delayed_work disc_work;
 	struct delayed_work auto_accept_work;
 	struct delayed_work idle_work;
+	struct delayed_work le_conn_timeout;
 
 	struct device	dev;
 

commit cb1d68f7a337142e283ef7fc78793a57ffb4cdc3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 12:54:16 2014 +0200

    Bluetooth: Track LE initiator and responder address information
    
    For SMP we need the local and remote addresses (and their types) that
    were used to establish the connection. These may be different from the
    Identity Addresses or even the current RPA. To guarantee that we have
    this information available and it is correct track these values
    separately from the very beginning of the connection.
    
    For outgoing connections we set the values as soon as we get a
    successful command status for HCI_LE_Create_Connection (for which the
    patch adds a command status handler function) and for incoming
    connections as soon as we get a LE Connection Complete HCI event.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0c63a7e12d90..edf194679b7d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -332,6 +332,10 @@ struct hci_conn {
 	__u8		dst_type;
 	bdaddr_t	src;
 	__u8		src_type;
+	bdaddr_t	init_addr;
+	__u8		init_addr_type;
+	bdaddr_t	resp_addr;
+	__u8		resp_addr_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;

commit fe39c7b2dacf7fd4dcddc26704d01315ab92b7cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 27 16:00:28 2014 -0800

    Bluetooth: Use __le64 type for LE random numbers
    
    The random numbers in Bluetooth Low Energy are 64-bit numbers and should
    also be little endian since the HCI specification is little endian.
    
    Change the whole Low Energy pairing to use __le64 instead of a byte
    array.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 571168811ecd..0c63a7e12d90 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -99,7 +99,7 @@ struct smp_ltk {
 	u8 type;
 	u8 enc_size;
 	__le16 ediv;
-	u8 rand[8];
+	__le64 rand;
 	u8 val[16];
 };
 
@@ -828,11 +828,11 @@ void hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
-struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8],
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, __le64 rand,
 			     bool master);
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 addr_type, u8 type, u8 authenticated,
-			    u8 tk[16], u8 enc_size, __le16 ediv, u8 rand[8]);
+			    u8 tk[16], u8 enc_size, __le16 ediv, __le64 rand);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type, bool master);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);
@@ -1293,7 +1293,7 @@ struct hci_sec_filter {
 
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
-void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
+void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
 							__u8 ltk[16]);
 
 int hci_update_random_address(struct hci_request *req, bool require_privacy,

commit d2ab0ac18df8735fb1431e63446e803dcd2e7326
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 27 20:37:30 2014 -0800

    Bluetooth: Add support for storing LE white list entries
    
    The current LE white list entries require storing in the HCI controller
    structure. So provide a storage and access functions for it. In addition
    export the current list via debugfs.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9493da8f7d83..571168811ecd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -284,6 +284,7 @@ struct hci_dev {
 	struct list_head	long_term_keys;
 	struct list_head	identity_resolving_keys;
 	struct list_head	remote_oob_data;
+	struct list_head	le_white_list;
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
 
@@ -799,6 +800,12 @@ struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
 int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
+struct bdaddr_list *hci_white_list_lookup(struct hci_dev *hdev,
+					  bdaddr_t *bdaddr, u8 type);
+void hci_white_list_clear(struct hci_dev *hdev);
+int hci_white_list_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int hci_white_list_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);
 int hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,

commit c9507490ab1769a808fcb4af1a27bd738f4b0407
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 27 19:35:54 2014 -0800

    Bluetooth: Make hci_blacklist_clear function static
    
    The hci_blacklist_clear function is not used outside of hci_core.c and
    can be made static.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 093d05eeb3fa..9493da8f7d83 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -796,7 +796,6 @@ int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
 					 bdaddr_t *bdaddr, u8 type);
-void hci_blacklist_clear(struct hci_dev *hdev);
 int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 

commit a1f4c3188bb4d51a41d2026ee08a578f56c61e47
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 27 14:05:41 2014 +0200

    Bluetooth: Add hci_copy_identity_address convenience function
    
    The number of places needing the local Identity Address are starting to
    grow so it's better to have a single place for the logic of determining
    it. This patch adds a convenience function for getting the Identity
    Address and updates the two current places needing this to use it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 853376df4f99..093d05eeb3fa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1292,6 +1292,8 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 
 int hci_update_random_address(struct hci_request *req, bool require_privacy,
 			      u8 *own_addr_type);
+void hci_copy_identity_address(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			       u8 *bdaddr_type);
 
 #define SCO_AIRMODE_MASK       0x0003
 #define SCO_AIRMODE_CVSD       0x0000

commit 56ed2cb88c7370d5aa88c92a2a0b1cb92c0979b9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 27 14:05:40 2014 +0200

    Bluetooth: Add tracking of advertising address type
    
    To know the real source address for incoming connections (needed e.g.
    for SMP) we should store the own_address_type parameter that was used
    for the last HCI_LE_Write_Advertising_Parameters command. This patch
    adds a proper command complete handler for the command and stores the
    address type in a new adv_addr_type variable in the hci_dev struct.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 79a75edc62d0..853376df4f99 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -156,6 +156,7 @@ struct hci_dev {
 	bdaddr_t	bdaddr;
 	bdaddr_t	random_addr;
 	bdaddr_t	static_addr;
+	__u8		adv_addr_type;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
 	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];

commit 8ef30fd3d1f08f9ffdf2495907f50f44f2101cd3
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:55 2014 -0300

    Bluetooth: Create hci_req_add_le_passive_scan helper
    
    This patches creates the public hci_req_add_le_passive_scan helper so
    it can be re-used outside hci_core.c in the next patch.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4b192d0fa76e..79a75edc62d0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1150,6 +1150,7 @@ void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen,
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 
 void hci_req_add_le_scan_disable(struct hci_request *req);
+void hci_req_add_le_passive_scan(struct hci_request *req);
 
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);

commit a9b0a04c2aac1e6e41e254221926bdce75321f55
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:52 2014 -0300

    Bluetooth: Connection parameters and resolvable address
    
    We should only accept connection parameters from identity addresses
    (public or random static). Thus, we should check the address type
    in hci_conn_params_add().
    
    Additionally, since the IRK is removed during unpair, we should also
    remove the connection parameters from that device.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b159810f67a6..4b192d0fa76e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -801,9 +801,9 @@ int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);
-void hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
-			 u8 auto_connect, u16 conn_min_interval,
-			 u16 conn_max_interval);
+int hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
+			u8 auto_connect, u16 conn_min_interval,
+			u16 conn_max_interval);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear(struct hci_dev *hdev);
 

commit 9fcb18ef3acb51e54b6bca6d2d803676ac86813d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:48 2014 -0300

    Bluetooth: Introduce LE auto connect options
    
    This patch introduces the LE auto connection options: HCI_AUTO_CONN_
    ALWAYS and HCI_AUTO_CONN_LINK_LOSS. Their working mechanism are
    described as follows:
    
    The HCI_AUTO_CONN_ALWAYS option configures the kernel to always re-
    establish the connection, no matter the reason the connection was
    terminated. This feature is required by some LE profiles such as
    HID over GATT, Health Thermometer and Blood Pressure. These profiles
    require the host autonomously connect to the device as soon as it
    enters in connectable mode (start advertising) so the device is able
    to delivery notifications or indications.
    
    The BT_AUTO_CONN_LINK_LOSS option configures the kernel to re-
    establish the connection in case the connection was terminated due
    to a link loss. This feature is required by the majority of LE
    profiles such as Proximity, Find Me, Cycling Speed and Cadence and
    Time.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 617cf495a449..b159810f67a6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -402,6 +402,12 @@ struct hci_conn_params {
 
 	u16 conn_min_interval;
 	u16 conn_max_interval;
+
+	enum {
+		HCI_AUTO_CONN_DISABLED,
+		HCI_AUTO_CONN_ALWAYS,
+		HCI_AUTO_CONN_LINK_LOSS,
+	} auto_connect;
 };
 
 extern struct list_head hci_dev_list;
@@ -796,7 +802,8 @@ int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
 					       bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
-			 u16 conn_min_interval, u16 conn_max_interval);
+			 u8 auto_connect, u16 conn_min_interval,
+			 u16 conn_max_interval);
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear(struct hci_dev *hdev);
 

commit a4790dbd43d1617b09d57e96494fde5a4b01980a
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:47 2014 -0300

    Bluetooth: Introduce LE auto connection infrastructure
    
    This patch introduces the LE auto connection infrastructure which
    will be used to implement the LE auto connection options.
    
    In summary, the auto connection mechanism works as follows: Once the
    first pending LE connection is created, the background scanning is
    started. When the target device is found in range, the kernel
    autonomously starts the connection attempt. If connection is
    established successfully, that pending LE connection is deleted and
    the background is stopped.
    
    To achieve that, this patch introduces the hci_update_background_scan()
    which controls the background scanning state. This function starts or
    stops the background scanning based on the hdev->pend_le_conns list. If
    there is no pending LE connection, the background scanning is stopped.
    Otherwise, we start the background scanning.
    
    Then, every time a pending LE connection is added we call hci_update_
    background_scan() so the background scanning is started (in case it is
    not already running). Likewise, every time a pending LE connection is
    deleted we call hci_update_background_scan() so the background scanning
    is stopped (in case this was the last pending LE connection) or it is
    started again (in case we have more pending LE connections). Finally,
    we also call hci_update_background_scan() in hci_le_conn_failed() so
    the background scan is restarted in case the connection establishment
    fails. This way the background scanning keeps running until all pending
    LE connection are established.
    
    At this point, resolvable addresses are not support by this
    infrastructure. The proper support is added in upcoming patches.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e08405d02649..617cf495a449 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -806,6 +806,8 @@ void hci_pend_le_conn_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_pend_le_conn_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_pend_le_conns_clear(struct hci_dev *hdev);
 
+void hci_update_background_scan(struct hci_dev *hdev);
+
 void hci_uuids_clear(struct hci_dev *hdev);
 
 void hci_link_keys_clear(struct hci_dev *hdev);

commit 77a77a30ae893a63467c51e45de18d0bdfa612e4
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:46 2014 -0300

    Bluetooth: Introduce hdev->pend_le_conn list
    
    This patch introduces the hdev->pend_le_conn list which holds the
    device addresses the kernel should autonomously connect. It also
    introduces some helper functions to manipulate the list.
    
    The list and helper functions will be used by the next patch which
    implements the LE auto connection infrastructure.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 20bdb2eafeea..e08405d02649 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -284,6 +284,7 @@ struct hci_dev {
 	struct list_head	identity_resolving_keys;
 	struct list_head	remote_oob_data;
 	struct list_head	le_conn_params;
+	struct list_head	pend_le_conns;
 
 	struct hci_dev_stats	stat;
 
@@ -799,6 +800,12 @@ void hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear(struct hci_dev *hdev);
 
+struct bdaddr_list *hci_pend_le_conn_lookup(struct hci_dev *hdev,
+					    bdaddr_t *addr, u8 addr_type);
+void hci_pend_le_conn_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
+void hci_pend_le_conn_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
+void hci_pend_le_conns_clear(struct hci_dev *hdev);
+
 void hci_uuids_clear(struct hci_dev *hdev);
 
 void hci_link_keys_clear(struct hci_dev *hdev);

commit 04a6c5898e8cbb46313b7d425001b701f0fa4e3d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:44 2014 -0300

    Bluetooth: Refactor HCI connection code
    
    hci_connect() is a very simple and useless wrapper of hci_connect_acl
    and hci_connect_le functions. Addtionally, all places where hci_connect
    is called the link type value is passed explicitly. This way, we can
    safely delete hci_connect, declare hci_connect_acl and hci_connect_le
    in hci_core.h and call them directly.
    
    No functionality is changed by this patch.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4253bdfc2f81..20bdb2eafeea 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -641,8 +641,10 @@ void hci_chan_del(struct hci_chan *chan);
 void hci_chan_list_flush(struct hci_conn *conn);
 struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
-			     __u8 dst_type, __u8 sec_level, __u8 auth_type);
+struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
+				u8 dst_type, u8 sec_level, u8 auth_type);
+struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
+				 u8 sec_level, u8 auth_type);
 struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
 				 __u16 setting);
 int hci_conn_check_link_mode(struct hci_conn *conn);

commit 06c053fb54c10be49ef30fc9b6b01e42cc9a1b61
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:41 2014 -0300

    Bluetooth: Declare le_conn_failed in hci_core.h
    
    This patch adds the "hci_" prefix to le_conn_failed() helper and
    declares it in hci_core.h so it can be reused in hci_event.c.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bef65d0a14f0..4253bdfc2f81 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -653,6 +653,8 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
 
+void hci_le_conn_failed(struct hci_conn *conn, u8 status);
+
 /*
  * hci_conn_get() and hci_conn_put() are used to control the life-time of an
  * "hci_conn" object. They do not guarantee that the hci_conn object is running,

commit b1efcc2870687ec3e3c51fa72210b8e4fa465df8
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:40 2014 -0300

    Bluetooth: Create hci_req_add_le_scan_disable helper
    
    This patch moves stop LE scanning duplicate code to one single
    place and reuses it. This will avoid more duplicate code in
    upcoming patches.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 269c8201a362..bef65d0a14f0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1129,6 +1129,8 @@ void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen,
 		    const void *param, u8 event);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 
+void hci_req_add_le_scan_disable(struct hci_request *req);
+
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       const void *param, u32 timeout);
 struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,

commit 12d4a3b2ccb3ac2bd56e7c216d6e7f44730006f3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Feb 24 14:52:18 2014 +0200

    Bluetooth: Move check for MGMT_CONNECTED flag into mgmt.c
    
    Once mgmt_set_powered(off) starts doing disconnections we'll need to
    care about any disconnections in mgmt.c and not just those with the
    MGMT_CONNECTED flag set. Therefore, move the check into mgmt.c from
    hci_event.c.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6ff882e727d4..269c8201a362 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1182,7 +1182,8 @@ void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			   u8 addr_type, u32 flags, u8 *name, u8 name_len,
 			   u8 *dev_class);
 void mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			      u8 link_type, u8 addr_type, u8 reason);
+			      u8 link_type, u8 addr_type, u8 reason,
+			      bool mgmt_connected);
 void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 link_type, u8 addr_type, u8 status);
 void mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,

commit 778b235a3be0588da1909f7ef75b4bc3dbc09dfc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Feb 24 14:52:17 2014 +0200

    Bluetooth: Move HCI_ADVERTISING handling into mgmt.c
    
    We'll soon need to make decisions on toggling the HCI_ADVERTISING flag
    based on pending mgmt_set_powered commands. Therefore, move the handling
    from hci_event.c into mgmt.c.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d2d756753714..6ff882e727d4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1174,6 +1174,7 @@ int mgmt_powered(struct hci_dev *hdev, u8 powered);
 void mgmt_discoverable_timeout(struct hci_dev *hdev);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
+void mgmt_advertising(struct hci_dev *hdev, u8 advertising);
 void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		       bool persistent);

commit f4f07505005932ca5f6c8003323bd38dbd0c769c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Feb 24 14:52:16 2014 +0200

    Bluetooth: Add convenience function for getting total connection count
    
    This patch adds a convenience function to return the number of
    connections in the conn_hash list. This will be useful once we update
    the power off procedure to disconnect any open connections.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fb3b677ff8a6..d2d756753714 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -561,6 +561,13 @@ static inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)
 	}
 }
 
+static inline unsigned int hci_conn_count(struct hci_dev *hdev)
+{
+	struct hci_conn_hash *c = &hdev->conn_hash;
+
+	return c->acl_num + c->amp_num + c->sco_num + c->le_num;
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {

commit 2b5224dca5a9257a3df8cc9f93978ecb3757b9c2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Feb 23 20:39:22 2014 -0800

    Bluetooth: Store current RPA and update it if needed
    
    The RPA needs to be stored to know which is the current one. Otherwise
    it is impossible to ensure that always the correct RPA can be programmed
    into the controller when it is needed.
    
    Current code checks if the address in the controller is a RPA, but that
    can potentially lead to using a RPA that can not be resolved with the
    IRK that has been distributed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0ee9cd11b3ef..fb3b677ff8a6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -308,6 +308,7 @@ struct hci_dev {
 	__u8			irk[16];
 	__u32			rpa_timeout;
 	struct delayed_work	rpa_expired;
+	bdaddr_t		rpa;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);

commit 94b1fc92cd7cf550460ffd4bcc08c2707564aa49
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Feb 23 20:25:54 2014 -0800

    Bluetooth: Use unresolvable private address for active scanning
    
    When running active scanning during LE discovery, do not reveal the own
    identity to the peer devices. In case LE privacy has been enabled, then
    a resolvable private address is used. If the LE privacy option is off,
    then use an unresolvable private address.
    
    The public address or static random address is never used in active
    scanning anymore. This ensures that scan request are send using a
    random address.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 43b6d1131c4d..0ee9cd11b3ef 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1256,7 +1256,8 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
 
-int hci_update_random_address(struct hci_request *req, u8 *own_addr_type);
+int hci_update_random_address(struct hci_request *req, bool require_privacy,
+			      u8 *own_addr_type);
 
 #define SCO_AIRMODE_MASK       0x0003
 #define SCO_AIRMODE_CVSD       0x0000

commit 7bf32048b1af87942d311ef1620995ffc89c07d8
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 23 19:42:29 2014 +0200

    Bluetooth: Remove unneeded hdev->own_addr_type
    
    Now that the identity address type is always looked up for all
    successful connections, the hdev->own_addr_type variable has become
    completely unnecessary. Simply remove it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2506963c7a06..43b6d1131c4d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -156,7 +156,6 @@ struct hci_dev {
 	bdaddr_t	bdaddr;
 	bdaddr_t	random_addr;
 	bdaddr_t	static_addr;
-	__u8		own_addr_type;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
 	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];

commit ebd3a74765377b7528bb372aab2890638790301d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 23 19:42:21 2014 +0200

    Bluetooth: Add hci_update_random_address() convenience function
    
    This patch adds a convenience function for updating the local random
    address which is needed before advertising, scanning and initiating LE
    connections.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6415514e4f17..2506963c7a06 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1257,6 +1257,8 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
 
+int hci_update_random_address(struct hci_request *req, u8 *own_addr_type);
+
 #define SCO_AIRMODE_MASK       0x0003
 #define SCO_AIRMODE_CVSD       0x0000
 #define SCO_AIRMODE_TRANSP     0x0003

commit d6bfd59caef7e543c7786af9664309dd1a7f6396
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 23 19:42:20 2014 +0200

    Bluetooth: Add timer for regenerating local RPA
    
    This patch adds a timer for updating the local RPA periodically. The
    default timeout is set to 15 minutes.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 68bbcabdd9fd..6415514e4f17 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -130,6 +130,9 @@ struct oob_data {
 
 #define HCI_MAX_SHORT_NAME_LENGTH	10
 
+/* Default LE RPA expiry time, 15 minutes */
+#define HCI_DEFAULT_RPA_TIMEOUT		(15 * 60)
+
 struct amp_assoc {
 	__u16	len;
 	__u16	offset;
@@ -304,6 +307,8 @@ struct hci_dev {
 	__u8			scan_rsp_data_len;
 
 	__u8			irk[16];
+	__u32			rpa_timeout;
+	struct delayed_work	rpa_expired;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);

commit 863efaf224d24705c0ffdc59f2a0ec68f2d85b4f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sat Feb 22 19:06:32 2014 +0200

    Bluetooth: Add initial code for distributing local IRK
    
    This code adds a HCI_PRIVACY flag to track whether Privacy support is
    enabled (meaning we have a local IRK) and makes sure the IRK is
    distributed during SMP key distribution in case this flag is set.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c0fcc041fbb5..68bbcabdd9fd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -303,6 +303,8 @@ struct hci_dev {
 	__u8			scan_rsp_data[HCI_MAX_AD_LENGTH];
 	__u8			scan_rsp_data_len;
 
+	__u8			irk[16];
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);

commit 3f959d46a60c20eedf6f228e49d820c5922ec68f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 20 11:55:56 2014 -0800

    Bluetooth: Provide option for changing LE advertising channel map
    
    For testing purposes it is useful to provide an option to change the
    advertising channel map. So add a debugfs option to allow this.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3a8e22e9b25d..c0fcc041fbb5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -178,6 +178,7 @@ struct hci_dev {
 	__u16		page_scan_interval;
 	__u16		page_scan_window;
 	__u8		page_scan_type;
+	__u8		le_adv_channel_map;
 	__u16		le_scan_interval;
 	__u16		le_scan_window;
 	__u16		le_conn_min_interval;

commit 7a4cd51dec96b42d899ed7b2207c9ef810534451
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 19 19:52:13 2014 -0800

    Bluetooth: Track the current configured random address
    
    For Bluetooth controllers with LE support, track the value of the
    currently configured random address. It is important to know what
    the current random address is to avoid unneeded attempts to set
    a new address. This will become important when introducing the
    LE privacy support in the future.
    
    In addition expose the current configured random address via
    debugfs for debugging purposes.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3be2905010cd..3a8e22e9b25d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -151,6 +151,7 @@ struct hci_dev {
 	__u8		bus;
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
+	bdaddr_t	random_addr;
 	bdaddr_t	static_addr;
 	__u8		own_addr_type;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];

commit 95fbac8a8e459262c580ee4172e4713cdc60929b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 19 15:18:31 2014 +0200

    Bluetooth: Add support for sending New IRK event
    
    This patch adds the necessary helper function to send the New IRK mgmt
    event and makes sure that the function is called at when SMP key
    distribution has completed. The event is sent before the New LTK event
    so user space knows which remote device to associate with the keys.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 59ae04c2684f..3be2905010cd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1211,6 +1211,7 @@ void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key);
+void mgmt_new_irk(struct hci_dev *hdev, struct smp_irk *irk);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 

commit 35d702719d6464a9de2bf98d536c6e054f0a8f7e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 19 14:57:47 2014 +0200

    Bluetooth: Move SMP LTK notification after key distribution
    
    This patch moves the SMP Long Term Key notification over mgmt from the
    hci_add_ltk function to smp.c when both sides have completed their key
    distribution. This way we are also able to update the identity address
    into the mgmt_new_ltk event.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8ca95e5e3765..59ae04c2684f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -788,9 +788,8 @@ int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8],
 			     bool master);
 struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			    u8 addr_type, u8 type, int new_key,
-			    u8 authenticated, u8 tk[16], u8 enc_size,
-			    __le16 ediv, u8 rand[8]);
+			    u8 addr_type, u8 type, u8 authenticated,
+			    u8 tk[16], u8 enc_size, __le16 ediv, u8 rand[8]);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type, bool master);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);

commit ba74b666b5e581ef3d4912af73774fab48c03198
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 19 14:57:45 2014 +0200

    Bluetooth: Move New LTK store hint evaluation into mgmt_new_ltk
    
    It's simpler (one less if-statement) to just evaluate the appropriate
    value for store_hint in the mgmt_new_ltk function than to pass a boolean
    parameter to the function. Furthermore, this simplifies moving the mgmt
    event emission out from hci_add_ltk in subsequent patches.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5366dc9e25eb..8ca95e5e3765 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1211,7 +1211,7 @@ void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
+void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 

commit ca9142b8825c159897cc4a246ea27585c82add4b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 19 14:57:44 2014 +0200

    Bluetooth: Return added key when adding LTKs and IRKs
    
    The SMP code will need to postpone the mgmt event emission for the IRK
    and LTKs. To avoid extra lookups at the end of the key distribution
    simply return the added value from the add_ltk and add_irk functions.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 64c4e3f0a515..5366dc9e25eb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -787,9 +787,10 @@ int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8],
 			     bool master);
-int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
-		int new_key, u8 authenticated, u8 tk[16], u8 enc_size,
-		__le16 ediv, u8 rand[8]);
+struct smp_ltk *hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			    u8 addr_type, u8 type, int new_key,
+			    u8 authenticated, u8 tk[16], u8 enc_size,
+			    __le16 ediv, u8 rand[8]);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type, bool master);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);
@@ -799,8 +800,8 @@ int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 struct smp_irk *hci_find_irk_by_rpa(struct hci_dev *hdev, bdaddr_t *rpa);
 struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type);
-int hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type,
-		u8 val[16], bdaddr_t *rpa);
+struct smp_irk *hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			    u8 addr_type, u8 val[16], bdaddr_t *rpa);
 void hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type);
 void hci_smp_irks_clear(struct hci_dev *hdev);
 

commit f4a407bef20c0e63fcd910a9404418522abff4ab
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 21:41:34 2014 +0200

    Bluetooth: Wait for SMP key distribution completion when pairing
    
    When we initiate pairing through mgmt_pair_device the code has so far
    been waiting for a successful HCI Encrypt Change event in order to
    respond to the mgmt command. However, putting privacy into the play we
    actually want the key distribution to be complete before replying so
    that we can include the Identity Address in the mgmt response.
    
    This patch updates the various hci_conn callbacks for LE in mgmt.c to
    only respond in the case of failure, and adds a new mgmt_smp_complete
    function that the SMP code will call once key distribution has been
    completed.
    
    Since the smp_chan_destroy function that's used to indicate completion
    and clean up the SMP context can be called from various places,
    including outside of smp.c, the easiest way to track failure vs success
    is a new flag that we set once key distribution has been successfully
    completed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4461c0051228..64c4e3f0a515 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1212,6 +1212,7 @@ int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
+void mgmt_smp_complete(struct hci_conn *conn, bool complete);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 2426f3a5945ce1dfdb04aaf26748a987be49ff7c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 17:14:36 2014 +0200

    Bluetooth: Add convenience function for fetching IRKs
    
    There are many situations where we need to check if an LE address is an
    RPA and if so try to look up the IRK for it. To simplify such cases this
    patch adds a convenience function for the job.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ac468de11cb7..4461c0051228 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1083,6 +1083,15 @@ static inline bool hci_bdaddr_is_rpa(bdaddr_t *bdaddr, u8 addr_type)
 	return false;
 }
 
+static inline struct smp_irk *hci_get_irk(struct hci_dev *hdev,
+					  bdaddr_t *bdaddr, u8 addr_type)
+{
+	if (!hci_bdaddr_is_rpa(bdaddr, addr_type))
+		return NULL;
+
+	return hci_find_irk_by_rpa(hdev, bdaddr);
+}
+
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit a7ec73386ce2a8ab351ee8ab6a1e5475f72617dc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 17:14:35 2014 +0200

    Bluetooth: Fix removing any IRKs when unpairing devices
    
    When mgmt_unpair_device is called we should also remove any associated
    IRKs. This patch adds a hci_remove_irk convenience function and ensures
    that it's called when mgmt_unpair_device is called.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 964a7888ad0c..ac468de11cb7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -801,6 +801,7 @@ struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type);
 int hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type,
 		u8 val[16], bdaddr_t *rpa);
+void hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type);
 void hci_smp_irks_clear(struct hci_dev *hdev);
 
 void hci_remote_oob_data_clear(struct hci_dev *hdev);

commit 35f7498a87794ca531335f7c782e5b9495fec6d6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 17:14:32 2014 +0200

    Bluetooth: Remove return values from functions that don't need them
    
    There are many functions that never fail but still declare an integer
    return value for no reason. This patch converts these functions to use a
    void return value to avoid any confusion of whether they can fail or not.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ab94abdeb3c1..964a7888ad0c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -768,7 +768,7 @@ int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
 					 bdaddr_t *bdaddr, u8 type);
-int hci_blacklist_clear(struct hci_dev *hdev);
+void hci_blacklist_clear(struct hci_dev *hdev);
 int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
@@ -779,9 +779,9 @@ void hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
 void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
 void hci_conn_params_clear(struct hci_dev *hdev);
 
-int hci_uuids_clear(struct hci_dev *hdev);
+void hci_uuids_clear(struct hci_dev *hdev);
 
-int hci_link_keys_clear(struct hci_dev *hdev);
+void hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
@@ -793,7 +793,7 @@ int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type, bool master);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);
-int hci_smp_ltks_clear(struct hci_dev *hdev);
+void hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 struct smp_irk *hci_find_irk_by_rpa(struct hci_dev *hdev, bdaddr_t *rpa);
@@ -803,7 +803,7 @@ int hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type,
 		u8 val[16], bdaddr_t *rpa);
 void hci_smp_irks_clear(struct hci_dev *hdev);
 
-int hci_remote_oob_data_clear(struct hci_dev *hdev);
+void hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
 					  bdaddr_t *bdaddr);
 int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit e0b2b27e622da0ba8a3d253b985d3d8f174b4313
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 17:14:31 2014 +0200

    Bluetooth: Fix missing address type check for removing LTKs
    
    When removing Long Term Keys we should also be checking that the given
    address type (public vs random) matches. This patch updates the
    hci_remove_ltk function to take an extra parameter and uses it for
    address type matching.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 86ea4bab9e77..ab94abdeb3c1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -792,7 +792,7 @@ int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
 		__le16 ediv, u8 rand[8]);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type, bool master);
-int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 bdaddr_type);
 int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 

commit 301cb2d85eb89140eaff8c22066a4bfd774960a3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 10:19:34 2014 +0200

    Bluetooth: Add hci_bdaddr_is_rpa convenience function
    
    When implementing support for Resolvable Private Addresses (RPAs) we'll
    need to in several places be able to identify such addresses. This patch
    adds a simple convenience function to do the identification of the
    address type.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index eac422337582..86ea4bab9e77 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1071,6 +1071,17 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 	return false;
 }
 
+static inline bool hci_bdaddr_is_rpa(bdaddr_t *bdaddr, u8 addr_type)
+{
+	if (addr_type != 0x01)
+		return false;
+
+	if ((bdaddr->b[5] & 0xc0) == 0x40)
+	       return true;
+
+	return false;
+}
+
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit 970c4e46037ab8ece3940afc9fcf916d3ed7e003
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 10:19:33 2014 +0200

    Bluetooth: Add basic IRK management support
    
    This patch adds the initial IRK storage and management functions to the
    HCI core. This includes storing a list of IRKs per HCI device and the
    ability to add, remove and lookup entries in that list.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b344890b18f5..eac422337582 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -103,6 +103,14 @@ struct smp_ltk {
 	u8 val[16];
 };
 
+struct smp_irk {
+	struct list_head list;
+	bdaddr_t rpa;
+	bdaddr_t bdaddr;
+	u8 addr_type;
+	u8 val[16];
+};
+
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -269,6 +277,7 @@ struct hci_dev {
 	struct list_head	uuids;
 	struct list_head	link_keys;
 	struct list_head	long_term_keys;
+	struct list_head	identity_resolving_keys;
 	struct list_head	remote_oob_data;
 	struct list_head	le_conn_params;
 
@@ -787,6 +796,13 @@ int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
+struct smp_irk *hci_find_irk_by_rpa(struct hci_dev *hdev, bdaddr_t *rpa);
+struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				     u8 addr_type);
+int hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type,
+		u8 val[16], bdaddr_t *rpa);
+void hci_smp_irks_clear(struct hci_dev *hdev);
+
 int hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
 					  bdaddr_t *bdaddr);

commit 99780a7b639e73d8f8f291fa1a981db883aec47f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 10:40:07 2014 +0200

    Bluetooth: Add AES crypto context for each HCI device
    
    Previously the crypto context has only been available for LE SMP
    sessions, but now that we'll need to perform operations also during
    discovery it makes sense to have this context part of the hci_dev
    struct. Later, the context can be removed from the SMP context.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 92fa75fce29d..b344890b18f5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -259,6 +259,7 @@ struct hci_dev {
 	__u32			req_status;
 	__u32			req_result;
 
+	struct crypto_blkcipher	*tfm_aes;
 
 	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;

commit 15819a7065ac46eb804498bb7ccbba60d8f7d4d5
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Mon Feb 3 13:56:18 2014 -0300

    Bluetooth: Introduce connection parameters list
    
    This patch adds to hdev the connection parameters list (hdev->le_
    conn_params). The elements from this list (struct hci_conn_params)
    contains the connection parameters (for now, minimum and maximum
    connection interval) that should be used during the connection
    establishment.
    
    Moreover, this patch adds helper functions to manipulate hdev->le_
    conn_params list. Some of these functions are also declared in
    hci_core.h since they will be used outside hci_core.c in upcoming
    patches.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4e878780fa01..92fa75fce29d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -269,6 +269,7 @@ struct hci_dev {
 	struct list_head	link_keys;
 	struct list_head	long_term_keys;
 	struct list_head	remote_oob_data;
+	struct list_head	le_conn_params;
 
 	struct hci_dev_stats	stat;
 
@@ -373,6 +374,16 @@ struct hci_chan {
 	__u8		state;
 };
 
+struct hci_conn_params {
+	struct list_head list;
+
+	bdaddr_t addr;
+	u8 addr_type;
+
+	u16 conn_min_interval;
+	u16 conn_max_interval;
+};
+
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
@@ -751,6 +762,13 @@ int hci_blacklist_clear(struct hci_dev *hdev);
 int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
+struct hci_conn_params *hci_conn_params_lookup(struct hci_dev *hdev,
+					       bdaddr_t *addr, u8 addr_type);
+void hci_conn_params_add(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type,
+			 u16 conn_min_interval, u16 conn_max_interval);
+void hci_conn_params_del(struct hci_dev *hdev, bdaddr_t *addr, u8 addr_type);
+void hci_conn_params_clear(struct hci_dev *hdev);
+
 int hci_uuids_clear(struct hci_dev *hdev);
 
 int hci_link_keys_clear(struct hci_dev *hdev);

commit 03c515d7486b7a519728340d4b04baaad16bf806
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 31 18:42:18 2014 -0800

    Bluetooth: Remove __packed from struct smp_ltk
    
    The struct smp_ltk does not need to be packed and so remove __packed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6854384b1f25..4e878780fa01 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -101,7 +101,7 @@ struct smp_ltk {
 	__le16 ediv;
 	u8 rand[8];
 	u8 val[16];
-} __packed;
+};
 
 struct link_key {
 	struct list_head list;

commit abf76bad8fb503fb21fb0eba854fa048c75ff123
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 31 16:24:28 2014 -0800

    Bluetooth: Track the AES-CCM encryption status of LE and BR/EDR links
    
    When encryption for LE links has been enabled, it will always be use
    AES-CCM encryption. In case of BR/EDR Secure Connections, the link
    will also use AES-CCM encryption. In both cases track the AES-CCM
    status in the connection flags.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2e1d184bd8d3..6854384b1f25 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -448,6 +448,7 @@ enum {
 	HCI_CONN_MGMT_CONNECTED,
 	HCI_CONN_SSP_ENABLED,
 	HCI_CONN_SC_ENABLED,
+	HCI_CONN_AES_CCM,
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
 	HCI_CONN_6LOWPAN,

commit 5c136e90a45e3d8e050b212f8f40f2d81f096879
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jan 30 18:22:05 2014 -0300

    Bluetooth: Group list_head fields from strcut hci_dev together
    
    This patch groups the list_head fields from struct hci_dev together
    and removes empty lines between them.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b9676cc1a59d..2e1d184bd8d3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -259,18 +259,15 @@ struct hci_dev {
 	__u32			req_status;
 	__u32			req_result;
 
-	struct list_head	mgmt_pending;
 
 	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;
-	struct list_head	blacklist;
 
+	struct list_head	mgmt_pending;
+	struct list_head	blacklist;
 	struct list_head	uuids;
-
 	struct list_head	link_keys;
-
 	struct list_head	long_term_keys;
-
 	struct list_head	remote_oob_data;
 
 	struct hci_dev_stats	stat;

commit 1e406eefbe41467c00973939c2b61b37bf0e1323
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jan 30 18:22:04 2014 -0300

    Bluetooth: Save connection interval parameters in hci_conn
    
    This patch creates two new fields in struct hci_conn to save the
    minimum and maximum connection interval values used to establish
    the connection this object represents.
    
    This change is required in order to know what parameters the
    connection is currently using.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 378e2f32cfa0..b9676cc1a59d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -334,6 +334,8 @@ struct hci_conn {
 	__u8		passkey_entered;
 	__u16		disc_timeout;
 	__u16		setting;
+	__u16		le_conn_min_interval;
+	__u16		le_conn_max_interval;
 	unsigned long	flags;
 
 	__u8		remote_cap;

commit 98a0b845c63cb74e90a72d1e864ea4be968bdd83
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jan 30 19:40:00 2014 -0800

    Bluetooth: Fix differentiating stored master vs slave LTK types
    
    If LTK distribution happens in both directions we will have two LTKs for
    the same remote device: one which is used when we're connecting as
    master and another when we're connecting as slave. When looking up LTKs
    from the locally stored list we shouldn't blindly return the first match
    but also consider which type of key is in question. If we do not do this
    we may end up selecting an incorrect encryption key for a connection.
    
    This patch fixes the issue by always specifying to the LTK lookup
    functions whether we're looking for a master or a slave key.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8d225e4ea2ce..378e2f32cfa0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -757,12 +757,13 @@ int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
-struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8],
+			     bool master);
 int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
 		int new_key, u8 authenticated, u8 tk[16], u8 enc_size,
 		__le16 ediv, u8 rand[8]);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				     u8 addr_type);
+				     u8 addr_type, bool master);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit eb9a8f3fb6762a4e6ae0aa9e96532c9c544f400e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 15 22:37:38 2014 -0800

    Bluetooth: Track Secure Connections support of remote devices
    
    It is important to know if Secure Connections support has been enabled
    for a given remote device. The information is provided in the remote
    host features page. So track this information and provide a simple
    helper function to extract the status.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 66e96ebffe97..8d225e4ea2ce 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -448,6 +448,7 @@ enum {
 	HCI_CONN_LE_SMP_PEND,
 	HCI_CONN_MGMT_CONNECTED,
 	HCI_CONN_SSP_ENABLED,
+	HCI_CONN_SC_ENABLED,
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
 	HCI_CONN_6LOWPAN,
@@ -460,6 +461,13 @@ static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
 	       test_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 }
 
+static inline bool hci_conn_sc_enabled(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	return test_bit(HCI_SC_ENABLED, &hdev->dev_flags) &&
+	       test_bit(HCI_CONN_SC_ENABLED, &conn->flags);
+}
+
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;

commit 0798872ef1ad6433362faca1d16a31ad7ad72638
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:29 2014 -0800

    Bluetooth: Add internal function for storing P-192 and P-256 data
    
    Add function to allow adding P-192 and P-256 data to the internal
    storage. This also fixes a few coding style issues from the previous
    helper functions for the out-of-band credentials storage.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5948930f92e6..66e96ebffe97 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -761,9 +761,12 @@ int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);
 struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
-							bdaddr_t *bdaddr);
-int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
-								u8 *randomizer);
+					  bdaddr_t *bdaddr);
+int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			    u8 *hash, u8 *randomizer);
+int hci_add_remote_oob_ext_data(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				u8 *hash192, u8 *randomizer192,
+				u8 *hash256, u8 *randomizer256);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);

commit 519ca9d017ab7eb4a15787bd8f2d867bebe375bc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:28 2014 -0800

    Bluetooth: Provide remote OOB data for Secure Connections
    
    When Secure Connections has been enabled it is possible to provide P-192
    and/or P-256 data during the pairing process. The internal out-of-band
    credentials storage has been extended to also hold P-256 data.
    
    Initially the P-256 data will be empty and with Secure Connections enabled
    no P-256 data will be provided. This is according to the specification
    since it might be possible that the remote side did not provide either
    of the out-of-band credentials.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bd15eaa4c06e..5948930f92e6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -114,8 +114,10 @@ struct link_key {
 struct oob_data {
 	struct list_head list;
 	bdaddr_t bdaddr;
-	u8 hash[16];
-	u8 randomizer[16];
+	u8 hash192[16];
+	u8 randomizer192[16];
+	u8 hash256[16];
+	u8 randomizer256[16];
 };
 
 #define HCI_MAX_SHORT_NAME_LENGTH	10

commit 4d2d27962642e23f88745b0430d47c3ff75afdd3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:26 2014 -0800

    Bluetooth: Add support for local OOB data with Secure Connections
    
    For Secure Connections support and the usage of out-of-band pairing,
    it is needed to read the P-256 hash and randomizer or P-192 hash and
    randomizer. This change will read P-192 data when Secure Connections
    is disabled and P-192 and P-256 data when it is enabled.
    
    The difference is between using HCI Read Local OOB Data and using the
    new HCI Read Local OOB Extended Data command. The first one has been
    introduced with Bluetooth 2.1 and returns only the P-192 data.
    
    < HCI Command: Read Local OOB Data (0x03|0x0057) plen 0
    > HCI Event: Command Complete (0x0e) plen 36
          Read Local OOB Data (0x03|0x0057) ncmd 1
            Status: Success (0x00)
            Hash C from P-192: 975a59baa1c4eee391477cb410b23e6d
            Randomizer R with P-192: 9ee63b7dec411d3b467c5ae446df7f7d
    
    The second command has been introduced with Bluetooth 4.1 and will
    return P-192 and P-256 data.
    
    < HCI Command: Read Local OOB Extended Data (0x03|0x007d) plen 0
    > HCI Event: Command Complete (0x0e) plen 68
          Read Local OOB Extended Data (0x03|0x007d) ncmd 1
            Status: Success (0x00)
            Hash C from P-192: 6489731804b156fa6355efb8124a1389
            Randomizer R with P-192: 4781d5352fb215b2958222b3937b6026
            Hash C from P-256: 69ef8a928b9d07fc149e630e74ecb991
            Randomizer R with P-256: 4781d5352fb215b2958222b3937b6026
    
    The change for the management interface is transparent and no change
    is required for existing userspace. The Secure Connections feature
    needs to be manually enabled. When it is disabled, then userspace
    only gets the P-192 returned and with Secure Connections enabled,
    userspace gets P-192 and P-256 in an extended structure.
    
    It is also acceptable to just ignore the P-256 data since it is not
    required to support them. The pairing with out-of-band credentials
    will still succeed. However then of course no Secure Connection will
    b established.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1eb55ec40ac0..bd15eaa4c06e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1129,8 +1129,9 @@ void mgmt_sc_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
-void mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
-					     u8 *randomizer, u8 status);
+void mgmt_read_local_oob_data_complete(struct hci_dev *hdev, u8 *hash192,
+				       u8 *randomizer192, u8 *hash256,
+				       u8 *randomizer256, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
 		       u8 ssp, u8 *eir, u16 eir_len);

commit eac83dc632a7afba72f7084266bc310219486253
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:23 2014 -0800

    Bluetooth: Add management command for enabling Secure Connections
    
    The support for Secure Connections need to be explicitly enabled by
    userspace. This is required since only userspace that can handle the
    new link key types should enable support for Secure Connections.
    
    This command handling is similar to how Secure Simple Pairing enabling
    is done. It also tracks the case when Secure Connections support is
    enabled via raw HCI commands. This makes sure that the host features
    page is updated as well.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bb984d0626b7..1eb55ec40ac0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1125,6 +1125,7 @@ void mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, u8 status);
 void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+void mgmt_sc_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);

commit d5991585d0bc49dca4ff36d18447bb27ad1ccd73
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:16 2014 -0800

    Bluetooth: Add LMP feature definitions for Secure Connections support
    
    The support for Secure Connections introduces two new controller
    features and one new host feature.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f2f0cf5865c4..bb984d0626b7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -803,9 +803,12 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_csb_slave_capable(dev)  ((dev)->features[2][0] & LMP_CSB_SLAVE)
 #define lmp_sync_train_capable(dev) ((dev)->features[2][0] & LMP_SYNC_TRAIN)
 #define lmp_sync_scan_capable(dev)  ((dev)->features[2][0] & LMP_SYNC_SCAN)
+#define lmp_sc_capable(dev)         ((dev)->features[2][1] & LMP_SC)
+#define lmp_ping_capable(dev)       ((dev)->features[2][1] & LMP_PING)
 
 /* ----- Host capabilities ----- */
 #define lmp_host_ssp_capable(dev)  ((dev)->features[1][0] & LMP_HOST_SSP)
+#define lmp_host_sc_capable(dev)   ((dev)->features[1][0] & LMP_HOST_SC)
 #define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))
 #define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))
 

commit 18722c247023035b9e2e2a08a887adec2a9a6e49
Author: Jukka Rissanen <jukka.rissanen@linux.intel.com>
Date:   Wed Dec 11 17:05:37 2013 +0200

    Bluetooth: Enable 6LoWPAN support for BT LE devices
    
    This is initial version of
    http://tools.ietf.org/html/draft-ietf-6lo-btle-00
    
    By default the 6LoWPAN support is not activated and user
    needs to tweak /sys/kernel/debug/bluetooth/hci0/6lowpan
    file.
    
    The kernel needs IPv6 support before 6LoWPAN is usable.
    
    Signed-off-by: Jukka Rissanen <jukka.rissanen@linux.intel.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b796161fb04e..f2f0cf5865c4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -448,6 +448,7 @@ enum {
 	HCI_CONN_SSP_ENABLED,
 	HCI_CONN_POWER_SAVE,
 	HCI_CONN_REMOTE_OOB,
+	HCI_CONN_6LOWPAN,
 };
 
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)

commit 53b834d2333aec1e60fcbfadfddd4ad472329570
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 8 11:55:33 2013 -0800

    Bluetooth: Use macros for connectionless slave broadcast features
    
    Add the LMP feature constants for connectionless slave broadcast
    and use them for capability testing.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f8555ad7b104..b796161fb04e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -798,6 +798,12 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_transp_capable(dev)    ((dev)->features[0][2] & LMP_TRANSPARENT)
 
 /* ----- Extended LMP capabilities ----- */
+#define lmp_csb_master_capable(dev) ((dev)->features[2][0] & LMP_CSB_MASTER)
+#define lmp_csb_slave_capable(dev)  ((dev)->features[2][0] & LMP_CSB_SLAVE)
+#define lmp_sync_train_capable(dev) ((dev)->features[2][0] & LMP_SYNC_TRAIN)
+#define lmp_sync_scan_capable(dev)  ((dev)->features[2][0] & LMP_SYNC_SCAN)
+
+/* ----- Host capabilities ----- */
 #define lmp_host_ssp_capable(dev)  ((dev)->features[1][0] & LMP_HOST_SSP)
 #define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))
 #define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))

commit c1f3bb6bd317994beb3af7bbec4bf54ed0035509
Merge: dcd607718385 3c57e865cfb2
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Nov 8 09:03:10 2013 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next into for-davem

commit 87bc0728d462ae37841a550542829aa65a97e7c2
Merge: f421436a591d 01925efdf7e0
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Nov 4 14:51:28 2013 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next into for-davem
    
    Conflicts:
            drivers/net/wireless/brcm80211/brcmfmac/sdio_host.h

commit 4e70c7e71c5f9cf11013628ab5a0ced449b1c7b2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 19 07:09:13 2013 -0700

    Bluetooth: Expose debugfs settings for LE connection interval
    
    For testing purposes expose the default LE connection interval values
    via debugfs.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d50cc7aca4e4..8c0ab3d86f95 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -169,6 +169,8 @@ struct hci_dev {
 	__u8		page_scan_type;
 	__u16		le_scan_interval;
 	__u16		le_scan_window;
+	__u16		le_conn_min_interval;
+	__u16		le_conn_max_interval;
 	__u8		ssp_debug_mode;
 
 	__u16		devid_source;

commit 06f5b7785af6beebb7b2a452687b5a102c90ca6e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 19 07:09:11 2013 -0700

    Bluetooth: Add support for setting SSP debug mode
    
    Enabling and disabling SSP debug mode is useful for development. This
    adds a debugfs entry that allows to configure the SSP debug mode.
    
    On purpose this has been implemented as debugfs entry and not a public
    API since it is really only useful during testing and development.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c689bcf4a0f7..d50cc7aca4e4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -169,6 +169,7 @@ struct hci_dev {
 	__u8		page_scan_type;
 	__u16		le_scan_interval;
 	__u16		le_scan_window;
+	__u8		ssp_debug_mode;
 
 	__u16		devid_source;
 	__u16		devid_vendor;

commit 3497ac84bd35bc5b984a3a20625021bfb0ca3f37
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 19 05:26:57 2013 -0700

    Bluetooth: Remove interval parameter from HCI connection
    
    The conn->interval parameter of HCI connections is not used at all
    and so just remove it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0daac39c1b6e..c689bcf4a0f7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -315,7 +315,6 @@ struct hci_conn {
 	__u8		attempt;
 	__u8		dev_class[3];
 	__u8		features[HCI_MAX_PAGES][8];
-	__u16		interval;
 	__u16		pkt_type;
 	__u16		link_policy;
 	__u32		link_mode;

commit 79830f66e3cbd224bcf697b032dce9828b5a3c9e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 18 16:38:09 2013 -0700

    Bluetooth: Select the own address type during initial setup phase
    
    The own address type is based on the fact if the controller has
    a public address or not. This means that this detail can be just
    configured once during setup phase.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9b5db01bd1a2..0daac39c1b6e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -142,6 +142,7 @@ struct hci_dev {
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
 	bdaddr_t	static_addr;
+	__u8		own_addr_type;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
 	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];

commit bdc3e0f1d2019fbf89f150ed98860b1a7a762fe9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 17 17:24:19 2013 -0700

    Bluetooth: Move device_add handling into hci_register_dev
    
    The device_add handling can be done directly in hci_register_dev and
    device_remove within hci_unregister_dev.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c6becda8c466..9b5db01bd1a2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -768,8 +768,6 @@ int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
 void hci_init_sysfs(struct hci_dev *hdev);
-int hci_add_sysfs(struct hci_dev *hdev);
-void hci_del_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);

commit b9ee0a783a928631bff1f0ea355bb9dc5deeaaf8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 17 17:24:13 2013 -0700

    Bluetooth: Add address type to device blacklist table
    
    The device blacklist is not taking care of the address type. Actually
    store the address type in the list entries and also use them when
    looking up addresses in the table.
    
    This is actually a serious bug. When adding a LE public address to
    the blacklist, then it would be blocking a device on BR/EDR. And this
    is not the expected behavior.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 07c2da4854ab..c6becda8c466 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -81,6 +81,7 @@ struct hci_conn_hash {
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
+	u8 bdaddr_type;
 };
 
 struct bt_uuid {
@@ -732,7 +733,7 @@ int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
-					 bdaddr_t *bdaddr);
+					 bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_clear(struct hci_dev *hdev);
 int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);

commit a74a84f696537f38fa994c1b95a0dca9ae386865
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 16 18:11:40 2013 +0300

    Bluetooth: Convert idle timer to use delayed work
    
    There is no need to use a timer since the entire Bluetooth subsystem
    runs using workqueues these days.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2504a2553baa..07c2da4854ab 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -342,7 +342,7 @@ struct hci_conn {
 
 	struct delayed_work disc_work;
 	struct delayed_work auto_accept_work;
-	struct timer_list idle_timer;
+	struct delayed_work idle_work;
 
 	struct device	dev;
 
@@ -651,7 +651,7 @@ static inline void hci_conn_drop(struct hci_conn *conn)
 		switch (conn->type) {
 		case ACL_LINK:
 		case LE_LINK:
-			del_timer(&conn->idle_timer);
+			cancel_delayed_work(&conn->idle_work);
 			if (conn->state == BT_CONNECTED) {
 				timeo = conn->disc_timeout;
 				if (!conn->out)

commit 7bc18d9d3d7ffbc09dabb201933a063583a39027
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 16 18:11:39 2013 +0300

    Bluetooth: Convert auto accept timer to use delayed work
    
    Since the entire Bluetooth subsystem runs in workqueues these days there
    is no need to use a timer for deferring work.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d987c795ba14..2504a2553baa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -341,8 +341,8 @@ struct hci_conn {
 	struct list_head chan_list;
 
 	struct delayed_work disc_work;
+	struct delayed_work auto_accept_work;
 	struct timer_list idle_timer;
-	struct timer_list auto_accept_timer;
 
 	struct device	dev;
 

commit f8e808bd6853f1ada3614f99c95beac1bc2f2140
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 16 00:16:47 2013 -0700

    Bluetooth: Store scan response data in HCI device
    
    The scan response data needs to be stored in HCI device and so
    add a buffer for it and also ensure to clear it when resetting
    the controller.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0a3a10a76b6c..d987c795ba14 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -283,6 +283,8 @@ struct hci_dev {
 	__s8			adv_tx_power;
 	__u8			adv_data[HCI_MAX_AD_LENGTH];
 	__u8			adv_data_len;
+	__u8			scan_rsp_data[HCI_MAX_AD_LENGTH];
+	__u8			scan_rsp_data_len;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);

commit 083368f7b8c03a0b3eaa048e84eb9fa9573745d4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:29 2013 -0700

    Bluetooth: Make mgmt_new_ltk() return void
    
    The return value of mgmt_new_ltk() function is not used and
    so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5d8d322a0855..0a3a10a76b6c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1125,7 +1125,7 @@ void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
+void mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 
 /* HCI info for socket */

commit 3edaf092c271d91228c66a48b415c92925b83d0b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:28 2013 -0700

    Bluetooth: Make mgmt_read_local_oob_data_reply_complete() return void
    
    The return value of mgmt_read_local_oob_data_reply_complete() function
    is not used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d40212b94c8a..5d8d322a0855 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1115,8 +1115,8 @@ void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
 void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
-int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
-					    u8 *randomizer, u8 status);
+void mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
+					     u8 *randomizer, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
 		       u8 ssp, u8 *eir, u16 eir_len);

commit 7667da3423cdf06a818e73adaf2f675455cc8e99
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:27 2013 -0700

    Bluetooth: Make mgmt_set_local_name_complete() return void
    
    The return value of mgmt_set_local_name_complete() function is
    not used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b2b472cbb611..d40212b94c8a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1114,7 +1114,7 @@ void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				    u8 status);
-int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
+void mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 					    u8 *randomizer, u8 status);
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,

commit 4e1b0245f2394a6ee4a79bb183f56f8fe2c7af33
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:26 2013 -0700

    Bluetooth: Make mgmt_set_class_of_dev_complete() return void
    
    The return value of mgmt_set_class_of_dev_complete() function is
    not used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 734b09f28f8c..b2b472cbb611 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1112,8 +1112,8 @@ void mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, u8 status);
 void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
-int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
-				   u8 status);
+void mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
+				    u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 					    u8 *randomizer, u8 status);

commit 3e248560d951b4a99aaa1d1332030853e2ebc3fd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:25 2013 -0700

    Bluetooth: Make mgmt_ssp_enable_complete() return void
    
    The return value of mgmt_ssp_enable_complete() function is not
    used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3ee5691b247f..734b09f28f8c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1111,7 +1111,7 @@ int mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, u8 status);
 void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
-int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+void mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				   u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);

commit 464996aea48aa1ec3d7d60098dbb0f7623da6c92
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:24 2013 -0700

    Bluetooth: Make mgmt_auth_enable_complete() return void
    
    The return value of mgmt_auth_enable_complete() function is not
    used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c7427160c7c2..3ee5691b247f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1110,7 +1110,7 @@ int mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			     u8 entered);
 void mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, u8 status);
-int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
+void mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 				   u8 status);

commit e546099c3194ef6ecf46a8a50414005c29a46bc4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:23 2013 -0700

    Bluetooth: Make mgmt_auth_failed() return void
    
    The return value of mgmt_auth_failed() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index aaa897f3b50a..c7427160c7c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1108,8 +1108,8 @@ int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 int mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			     u8 link_type, u8 addr_type, u32 passkey,
 			     u8 entered);
-int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		     u8 addr_type, u8 status);
+void mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		      u8 addr_type, u8 status);
 int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,

commit 3eb385289a8b71db40b1a4a4d739817bd437db4f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:22 2013 -0700

    Bluetooth: Make mgmt_pin_code_neg_reply_complete() return void
    
    The return value of mgmt_pin_code_neg_reply_complete() function is
    not used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 95baf3561dad..aaa897f3b50a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1090,8 +1090,8 @@ void mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 void mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
 void mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				  u8 status);
-int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				     u8 status);
+void mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				      u8 status);
 int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			      u8 link_type, u8 addr_type, __le32 value,
 			      u8 confirm_hint);

commit e669cf803cb14d63d0b7c612286e5cfdec6e34f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:21 2013 -0700

    Bluetooth: Make mgmt_pin_code_reply_complete() return void
    
    The return value of mgmt_pin_code_reply_complete() function is not
    used and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a167a9dda7c7..95baf3561dad 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1088,8 +1088,8 @@ void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
 void mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			 u8 addr_type, u8 status);
 void mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
-int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				 u8 status);
+void mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+				  u8 status);
 int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 status);
 int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit ce0e4a0d7b84d4ceebc91f97de8c08da23a7bda3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 14:26:20 2013 -0700

    Bluetooth: Make mgmt_pin_code_request() return void
    
    The return value of mgmt_pin_code_request() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fc04bc846617..a167a9dda7c7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1087,7 +1087,7 @@ void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 link_type, u8 addr_type, u8 status);
 void mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			 u8 addr_type, u8 status);
-int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
+void mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				 u8 status);
 int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit d1967ff88b3854d1bb002cccd15d28ad0d9223a9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 10:57:40 2013 -0700

    Bluetooth: Update class of device on discoverable timeout
    
    When the discoverable timeout triggers and limited discoverable mode
    was used, then the class of device needs to be updated to remove
    the limited discoverable bit.
    
    To keep the class of device logic in a central place, expose a new
    function mgmt_discoverable_timeout that can be called from the
    timeout callback. In case the class of device value needs updating,
    it will add the HCI command to the transaction.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b076cd9f6683..fc04bc846617 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1072,6 +1072,7 @@ void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
+void mgmt_discoverable_timeout(struct hci_dev *hdev);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);

commit efdcf8e3d716730d2212dfd973571a0ed00c9b10
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 10:31:12 2013 -0700

    Bluetooth: Move eir_get_length() function into hci_event.c
    
    The eir_get_length() function is only used from hci_event.c and so
    instead of having a public function move it to the location where
    it is used.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 42591a41baf0..b076cd9f6683 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1009,23 +1009,6 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 	return false;
 }
 
-static inline size_t eir_get_length(u8 *eir, size_t eir_len)
-{
-	size_t parsed = 0;
-
-	while (parsed < eir_len) {
-		u8 field_len = eir[0];
-
-		if (field_len == 0)
-			return parsed;
-
-		parsed += field_len + 1;
-		eir += field_len + 1;
-	}
-
-	return eir_len;
-}
-
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit 9493399108a186492bb828417a43ff37d9ae48fa
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 10:26:39 2013 -0700

    Bluetooth: Move eir_append_data() function into mgmt.c
    
    The eir_append_data() function is only used from mgmt.c and so
    instead of having a public function move it to the location where
    it is used.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cf6be04336aa..42591a41baf0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1026,17 +1026,6 @@ static inline size_t eir_get_length(u8 *eir, size_t eir_len)
 	return eir_len;
 }
 
-static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
-				  u8 data_len)
-{
-	eir[eir_len++] = sizeof(type) + data_len;
-	eir[eir_len++] = type;
-	memcpy(&eir[eir_len], data, data_len);
-	eir_len += data_len;
-
-	return eir_len;
-}
-
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit dc4a5ee2a3282a1044b164979609b4bfab43900b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 10:15:57 2013 -0700

    Bluetooth: Make mgmt_new_link_key() return void
    
    The return value of mgmt_new_link_key() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index da21a8d2b4a1..cf6be04336aa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1103,8 +1103,8 @@ int mgmt_powered(struct hci_dev *hdev, u8 powered);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
-int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
-		      bool persistent);
+void mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
+		       bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			   u8 addr_type, u32 flags, u8 *name, u8 name_len,
 			   u8 *dev_class);

commit 4796e8af60ee7d2922386ef9fd4389d21e2c1665
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 06:33:56 2013 -0700

    Bluetooth: Make mgmt_write_scan_failed() return void
    
    The return value of mgmt_write_scan_failed() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 997d43d1996e..da21a8d2b4a1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1102,7 +1102,7 @@ void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
-int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
+void mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		      bool persistent);
 void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,

commit a330916c4f29898b93708b6bec8f59f7a7956f41
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 06:33:55 2013 -0700

    Bluetooth: Make mgmt_connectable() return void
    
    The return value of mgmt_connectable() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 783c70cf305a..997d43d1996e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1101,7 +1101,7 @@ void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
-int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
+void mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		      bool persistent);

commit 86a7564573a7de9e01aa9a2e26faa993d8f962ac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 06:33:54 2013 -0700

    Bluetooth: Make mgmt_discoverable() return void
    
    The return value of mgmt_discoverable() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4a186ec99132..783c70cf305a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1100,7 +1100,7 @@ void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
 void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
-int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
+void mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,

commit 441ad2d04123eecb06d7c14948a0e7b07bf75aa5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Oct 15 06:33:52 2013 -0700

    Bluetooth: Update advertising data based on management commands
    
    Magically updating the advertising data when some random command enables
    advertising in the controller is not really a good idea. It also caused
    a bit of complicated code with the exported hci_udpate_ad function that
    is shared from many places.
    
    This patch consolidates the advertising data update into the management
    core. It also makes sure that when powering on with LE enabled or later
    on enabling LE the controller has a good default for advertising data.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4e208420d84c..4a186ec99132 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1183,8 +1183,6 @@ struct hci_sec_filter {
 #define hci_req_lock(d)		mutex_lock(&d->req_lock)
 #define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
 
-void hci_update_ad(struct hci_request *req);
-
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],

commit b4cb9fb25e9eae749f456e9e94446650389e736b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Oct 14 13:56:16 2013 -0700

    Bluetooth: Read number of supported IAC on controller setup
    
    When initializing a controller make sure to read out the number of
    supported IAC and store its result. This value is needed to determine
    if limited discoverable for BR/EDR can be configured or not.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0326b160b89a..4e208420d84c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -159,6 +159,7 @@ struct hci_dev {
 	__u16		manufacturer;
 	__u16		lmp_subver;
 	__u16		voice_setting;
+	__u8		num_iac;
 	__u8		io_capability;
 	__s8		inq_tx_power;
 	__u16		page_scan_interval;

commit 662e8820f38dcc458e0d4769194db5ed3469224f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 13 05:23:59 2013 -0700

    Bluetooth: Store source address of HCI connections
    
    The source addressed was based on the public address of the HCI device,
    but with LE connections this not always the case. For example single
    mode LE-only controllers would use a static random address. And this
    address is configured by userspace.
    
    To not complicate the lookup of what kind of address is in use, store
    the correct source address for each HCI connection.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 714da9ea465e..0326b160b89a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -300,6 +300,7 @@ struct hci_conn {
 
 	bdaddr_t	dst;
 	__u8		dst_type;
+	bdaddr_t	src;
 	__u8		src_type;
 	__u16		handle;
 	__u16		state;

commit e7c4096e16f0e362c6cf902baab0de37ebfc1266
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 13 03:57:39 2013 -0700

    Bluetooth: Store the source address type of LE connections
    
    When establishing LE connections, it is possible to use a public
    address (if available) or a random address. The type of address
    is only known when creating connections, so make sure it is
    stored in hci_conn structure.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7889495da843..714da9ea465e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -300,6 +300,7 @@ struct hci_conn {
 
 	bdaddr_t	dst;
 	__u8		dst_type;
+	__u8		src_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;

commit 79d95a19a445f5758571b3342064f2c1e40b6c5f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 13 03:57:38 2013 -0700

    Bluetooth: Remove pointless bdaddr_to_le() helper function
    
    The bdaddr_to_le() function tries to convert the internal address
    type to one that matches the HCI address type for LE. It does not
    handle any address types not used by LE and in the end just make
    the code a lot harder to read.
    
    So instead of just hiding behind a magic function, just convert
    the internal address type where it needs to be converted. And it
    turns out that these are only two cases anyway. One when creating
    new LE connections and the other when loading the long term keys.
    In both cases this makes it more clear on what it going on.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 690045498420..7889495da843 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1187,8 +1187,6 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
 
-u8 bdaddr_to_le(u8 bdaddr_type);
-
 #define SCO_AIRMODE_MASK       0x0003
 #define SCO_AIRMODE_CVSD       0x0000
 #define SCO_AIRMODE_TRANSP     0x0003

commit bef64738e3fb87eabc6fbeededad0c44ea173384
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 11 08:23:19 2013 -0700

    Bluetooth: Make LE scan interval and window a controller option
    
    The scan interval and window for LE passive scanning and connection
    establishment should be configurable on a per controller basis. So
    introduce a setting that later on will allow modifying it.
    
    This setting does not affect LE active scanning during device
    discovery phase. As long as that phase uses interleaved discovery,
    it will continuously scan.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0e01dc257880..690045498420 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -164,6 +164,8 @@ struct hci_dev {
 	__u16		page_scan_interval;
 	__u16		page_scan_window;
 	__u8		page_scan_type;
+	__u16		le_scan_interval;
+	__u16		le_scan_window;
 
 	__u16		devid_source;
 	__u16		devid_vendor;

commit 7bd8f09f69f8a190f9b8334a07bb0a9237612314
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 11 06:19:18 2013 -0700

    Bluetooth: Add hdev parameter to hdev->send driver callback
    
    Instead of masking hdev inside the skb->dev parameter, hand it
    directly to the driver as a parameter to hdev->send. This makes
    the driver interface more clear and simpler.
    
    This patch fixes all drivers to accept and handle the new parameter
    of hdev->send callback. Special care has been taken for bpa10x
    and btusb drivers that require having skb->dev set to hdev for
    the URB transmit complete handlers.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 29b81476424c..0e01dc257880 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -285,7 +285,7 @@ struct hci_dev {
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
 	int (*setup)(struct hci_dev *hdev);
-	int (*send)(struct sk_buff *skb);
+	int (*send)(struct hci_dev *hdev, struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 };
 

commit e1a26170692dc1e5fbe0ccd98ef86cc9fcd31a64
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 10 16:52:43 2013 -0700

    Bluetooth: Provide hdev parameter to hci_recv_frame() driver callback
    
    To avoid casting skb->dev into hdev, just let the drivers provide
    the hdev directly when calling hci_recv_frame() function.
    
    This patch also fixes up all drivers to provide the hdev.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 237bf8c03fb4..29b81476424c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -755,7 +755,7 @@ int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
-int hci_recv_frame(struct sk_buff *skb);
+int hci_recv_frame(struct hci_dev *hdev, struct sk_buff *skb);
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 

commit 324d36ed26a22bc14b2dd4505f3dba3fb2676bcc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 10 10:50:06 2013 -0700

    Bluetooth: Remove hdev->ioctl driver callback
    
    Since there is no use of hdev->ioctl by any Bluetooth driver since
    ever, so just lets remove it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c06552769644..237bf8c03fb4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -287,7 +287,6 @@ struct hci_dev {
 	int (*setup)(struct hci_dev *hdev);
 	int (*send)(struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
-	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
 };
 
 #define HCI_PHY_HANDLE(handle)	(handle & 0xff)

commit 7009deab19d7be03e05f67ceac56cfdfc73aa71c
Merge: 5cde28293891 274dede8c520
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 7 15:40:44 2013 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next
    
    Conflicts:
            drivers/net/wireless/brcm80211/brcmfmac/dhd_bus.h
            drivers/net/wireless/rtlwifi/rtl8188ee/phy.h
            drivers/net/wireless/rtlwifi/rtl8192ce/phy.h
            drivers/net/wireless/rtlwifi/rtl8192de/phy.h
            drivers/net/wireless/rtlwifi/rtl8723ae/phy.h
    
    Just some minor conflicts between the wireless-next changes
    and Joe Perches's "extern" removal from function prototypes
    in header files.
    
    John W. Linville says:
    
    ====================
    Regarding the Bluetooth bits, Gustavo says:
    
    "The big work here is from Marcel and Johan. They did a lot of work
    in the L2CAP, HCI and MGMT layers. The most important ones are the
    addition of a new MGMT command to enable/disable LE advertisement
    and the introduction of the HCI user channel to allow applications
    to get directly and exclusive access to Bluetooth devices."
    
    As to the ath10k bits, Kalle says:
    
    "Bartosz dropped support for qca98xx hw1.0 hardware from ath10k, it's
    just too much to support it. Michal added support for the new firmware
    interface. Marek fixed WEP in AP and IBSS mode. Rest of the changes are
    minor fixes or cleanups."
    
    And also:
    
    "Major changes are:
    
    * throughput improvements including aligning the RX frames correctly and
      optimising HTT layer (Michal)
    
    * remove qca98xx hw1.0 support (Bartosz)
    
    * add support for firmware version 999.999.0.636 (Michal)
    
    * firmware htt statistics support (Kalle)
    
    * fix WEP in AP and IBSS mode (Marek)
    
    * fix a mutex unlock balance in debugfs file (Shafi)
    
    And of course there's a lot of smaller fixes and cleanup."
    
    For the wl12xx bits, Luca says:
    
    "Here are some patches intended for 3.13.  Eliad is upstreaming a bunch
    of patches that have been pending in the internal tree.  Mostly bugfixes
    and other small improvements."
    
    Along with that...
    
    Arend and friends bring us a batch of brcmfmac updates, Larry Finger
    offers some rtlwifi refactoring, and Sujith sends the usual batch of
    ath9k updates.  As usual, there are a number of other small updates
    from a variety of players as well.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2f1e063bc035dbbdb9174cc5f55f073a28780aa8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:53 2013 -0700

    Bluetooth: Make mgmt_discovering() return void
    
    The return value of mgmt_discovering() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 960c64b92415..c06552769644 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1145,7 +1145,7 @@ void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 ssp, u8 *eir, u16 eir_len);
 void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);
-int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
+void mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);

commit 9cf12aee8bf5eb219c79089fb4556ad1d2066585
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:52 2013 -0700

    Bluetooth: Make mgmt_remote_name() return void
    
    The return value of mgmt_remote_name() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5b738a2d1786..960c64b92415 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1143,8 +1143,8 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
 		       u8 ssp, u8 *eir, u16 eir_len);
-int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
+void mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		      u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);

commit 901801b9a420e58969e039731dd007ae104842d3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:51 2013 -0700

    Bluetooth: Make mgmt_device_found() return void
    
    The return value of mgmt_device_found() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2b0bc31ec785..5b738a2d1786 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1140,9 +1140,9 @@ int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 					    u8 *randomizer, u8 status);
-int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
-		      u8 ssp, u8 *eir, u16 eir_len);
+void mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+		       u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
+		       u8 ssp, u8 *eir, u16 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);

commit 9b80ec5e8e66ada404ad65ce61a1de70fee0fbbd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:50 2013 -0700

    Bluetooth: Make mgmt_device_disconnected() return void
    
    The return value of mgmt_device_disconnected() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 48569442ec17..2b0bc31ec785 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1104,8 +1104,8 @@ int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			   u8 addr_type, u32 flags, u8 *name, u8 name_len,
 			   u8 *dev_class);
-int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			     u8 link_type, u8 addr_type, u8 reason);
+void mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			      u8 link_type, u8 addr_type, u8 reason);
 void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 link_type, u8 addr_type, u8 status);
 void mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,

commit ecd90ae7f600270d68b471f87c66d5b41ce5a974
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:49 2013 -0700

    Bluetooth: Make mgmt_device_connected() return void
    
    The return value of mgmt_device_connected() function is not used
    and so just change it to return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d982458a96e3..48569442ec17 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1101,9 +1101,9 @@ int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 		      bool persistent);
-int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
-			  u8 *dev_class);
+void mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			   u8 addr_type, u32 flags, u8 *name, u8 name_len,
+			   u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			     u8 link_type, u8 addr_type, u8 reason);
 void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit 445608d078bf7f7fe975792a940ffac83f495fa9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:48 2013 -0700

    Bluetooth: Make mgmt_connect_failed() return void
    
    The return value of mgmt_connect_failed() function is not used
    so change it to just return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 429969fdb9f3..d982458a96e3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1108,8 +1108,8 @@ int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			     u8 link_type, u8 addr_type, u8 reason);
 void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 link_type, u8 addr_type, u8 status);
-int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-			u8 addr_type, u8 status);
+void mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			 u8 addr_type, u8 status);
 int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				 u8 status);

commit 7892924c7d5d74be8ad52316000a78fe96379044
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:47 2013 -0700

    Bluetooth: Make mgmt_disconnect_failed() return void
    
    The return value of mgmt_disconnect_failed() function is not used
    so change it to just return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 62e2fc1bc7cc..429969fdb9f3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1106,8 +1106,8 @@ int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			  u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			     u8 link_type, u8 addr_type, u8 reason);
-int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			   u8 link_type, u8 addr_type, u8 status);
+void mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			    u8 link_type, u8 addr_type, u8 status);
 int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			u8 addr_type, u8 status);
 int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);

commit 3eec705e42d19b3d3e367fcb88693c24175bdbc6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:46 2013 -0700

    Bluetooth: Make mgmt_set_powered_failed() return void
    
    The return value of mgmt_set_powered_failed() function is never used
    and so make the function just return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1e6f584d5149..62e2fc1bc7cc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1094,7 +1094,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 void mgmt_index_added(struct hci_dev *hdev);
 void mgmt_index_removed(struct hci_dev *hdev);
-int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
+void mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 int mgmt_connectable(struct hci_dev *hdev, u8 connectable);

commit bf6b56db0acbe844c96fe36ab65eb7a53c6d8654
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 23:55:45 2013 -0700

    Bluetooth: Make mgmt_index_added() and mgmt_index_removed() return void
    
    The return value from mgmt_index_added() and mgmt_index_removed()
    functions is never used. So do not pretend that returning an error
    would actually be handled and just make both functions return void.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d80d4311ccb0..1e6f584d5149 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1092,8 +1092,8 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 #define DISCOV_BREDR_INQUIRY_LEN	0x08
 
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
-int mgmt_index_added(struct hci_dev *hdev);
-int mgmt_index_removed(struct hci_dev *hdev);
+void mgmt_index_added(struct hci_dev *hdev);
+void mgmt_index_removed(struct hci_dev *hdev);
 int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);

commit 1514b8928e5d8273920b26276cd9617b6dbc7760
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 08:25:01 2013 -0700

    Bluetooth: Remove mgmt_valid_hdev() helper function
    
    The helper function mgmt_valid_hdev() is more obfuscating the code
    then it makes it easier to read. So intead of this helper, use the
    direct check for BR/EDR device type.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 30e0fbb92b0a..d80d4311ccb0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1148,7 +1148,6 @@ int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-bool mgmt_valid_hdev(struct hci_dev *hdev);
 int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 void mgmt_reenable_advertising(struct hci_dev *hdev);
 

commit a6d811ed28f7c49e869b4076a00969c4028cda0d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 04:11:12 2013 -0700

    Bluetooth: Remove no longer needed mgmt_new_settings() function
    
    The mgmt_new_settings() function was only needed to handle the
    error case when re-enabling advertising failed. Since that is
    now handled internally inside the management core, this function
    is not needed anymore. So just remove it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 869f6ad602d1..30e0fbb92b0a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1094,7 +1094,6 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(struct hci_dev *hdev);
 int mgmt_index_removed(struct hci_dev *hdev);
-int mgmt_new_settings(struct hci_dev *hdev);
 int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);

commit 5976e60811723220678ebdb2ea06fbb52fe900bd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 04:08:14 2013 -0700

    Bluetooth: Use helper function for re-enabling advertising
    
    When the all LE connections have been disconneted, then it is up to
    the host to re-enable advertising at that point. To ensure that the
    correct advertising parameters are used, force the usage of the
    common helper to enable advertising.
    
    The change just moves the manual enabling of advertising from the
    event handler into the management core so that the helper can
    be actually shared.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 82c397451261..869f6ad602d1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1151,6 +1151,7 @@ int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 bool mgmt_valid_hdev(struct hci_dev *hdev);
 int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
+void mgmt_reenable_advertising(struct hci_dev *hdev);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 80d58d0b5b18b68addad61e228ced167f8b80dd3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 5 11:47:48 2013 -0700

    Bluetooth: Move hci_amp_capable() function into L2CAP core
    
    The hci_amp_capable() function has only a single user inside the L2CAP
    core. Instead of exporting the function, place it next to its user.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4cb355b023a4..82c397451261 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -795,22 +795,6 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))
 #define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))
 
-/* returns true if at least one AMP active */
-static inline bool hci_amp_capable(void)
-{
-	struct hci_dev *hdev;
-	bool ret = false;
-
-	read_lock(&hci_dev_list_lock);
-	list_for_each_entry(hdev, &hci_dev_list, list)
-		if (hdev->amp_type != AMP_TYPE_BREDR &&
-		    test_bit(HCI_UP, &hdev->flags))
-			ret = true;
-	read_unlock(&hci_dev_list_lock);
-
-	return ret;
-}
-
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01
 

commit ece6912648da3fcf257a40774e3aad531c3e5fac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 5 11:47:43 2013 -0700

    Bluetooth: Separate AMP controller type from HCI device type
    
    There are two defined HCI device types. One is for BR/EDR controllers
    and the other is for AMP controllers. The HCI device type is not the
    same as the AMP controller type. It just happens that currently the
    defined types match, but that is not guaranteed.
    
    Split the usage of AMP controller type into its own domain so that
    it is possible to separate between BR/EDR controllers, 802.11 AMP
    controllers and any other AMP technology that might be defined in
    the future.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index db650baf8177..4cb355b023a4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -803,7 +803,7 @@ static inline bool hci_amp_capable(void)
 
 	read_lock(&hci_dev_list_lock);
 	list_for_each_entry(hdev, &hci_dev_list, list)
-		if (hdev->amp_type == HCI_AMP &&
+		if (hdev->amp_type != AMP_TYPE_BREDR &&
 		    test_bit(HCI_UP, &hdev->flags))
 			ret = true;
 	read_unlock(&hci_dev_list_lock);

commit f822c411b26ce0353c8b97877e53a12e4f895ca1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 5 11:47:41 2013 -0700

    Bluetooth: Remove useless external function to count controllers
    
    The list of controllers can be counted ahead of time and inline
    inside the AMP discover handling. There is no need to export such
    a function at all.
    
    In addition just count the AMP controller and only allocated space
    for a single mandatory BR/EDR controller. No need to allocate more
    space than needed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 079c5c55c829..db650baf8177 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -704,19 +704,6 @@ static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
 	dev_set_drvdata(&hdev->dev, data);
 }
 
-/* hci_dev_list shall be locked */
-static inline uint8_t __hci_num_ctrl(void)
-{
-	uint8_t count = 0;
-	struct list_head *p;
-
-	list_for_each(p, &hci_dev_list) {
-		count++;
-	}
-
-	return count;
-}
-
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src);
 

commit d2f5a196d7b401b79e2321b24cc0ac8636ffbc17
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sat Oct 5 12:01:05 2013 +0200

    Bluetooth: Add public mgmt function to send New Settings event
    
    A function is needed so that the HCI event processing can ask the mgmt
    code to emit a new settings event. This is necessary e.g. when the event
    processing does updates to mgmt related states without any dependency of
    actual mgmt commands.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e09c30577b3a..079c5c55c829 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1123,6 +1123,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(struct hci_dev *hdev);
 int mgmt_index_removed(struct hci_dev *hdev);
+int mgmt_new_settings(struct hci_dev *hdev);
 int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);

commit d13eafce2c892d57f1eb243e43dfe48b4626006d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Oct 2 04:41:30 2013 -0700

    Bluetooth: Add management command for setting static address
    
    On dual-mode BR/EDR/LE and LE only controllers it is possible
    to configure a random address. There are two types or random
    addresses, one is static and the other private. Since the
    random private addresses require special privacy feature to
    be supported, the configuration of these two are kept separate.
    
    This command allows for setting the static random address. It is
    only supported on controllers with LE support. The static random
    address is suppose to be valid for the lifetime of the controller
    or at least until the next power cycle. To ensure such behavior,
    setting of the address is limited to when the controller is
    powered off.
    
    The special BDADDR_ANY address (00:00:00:00:00:00) can be used to
    disable the static address. This is also the default value.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 26cc9f7858cd..e09c30577b3a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -140,6 +140,7 @@ struct hci_dev {
 	__u8		bus;
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
+	bdaddr_t	static_addr;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
 	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];

commit 416a4ae56b7a37407ca1155805c05b638f845778
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Sep 25 13:26:08 2013 +0300

    Bluetooth: Use async request for LE enable/disable
    
    This patch updates the code to use an asynchronous request for handling
    the enabling and disabling of LE support. This refactoring is necessary
    as a preparation for adding advertising support, since when LE is
    disabled we should also disable advertising, and the cleanest way to do
    this is to perform the two respective HCI commands in the same
    asynchronous request.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3ede820d328f..26cc9f7858cd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1168,7 +1168,6 @@ int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 					    u8 *randomizer, u8 status);
-int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
 		      u8 ssp, u8 *eir, u16 eir_len);

commit e74e58f8d2015ac6b4e7a65c0acde8a499d46574
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 23 11:37:36 2013 -0700

    bluetooth: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3ede820d328f..5769061e6533 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -367,18 +367,17 @@ extern rwlock_t hci_dev_list_lock;
 extern rwlock_t hci_cb_list_lock;
 
 /* ----- HCI interface to upper protocols ----- */
-extern int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
-extern void l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
-extern int l2cap_disconn_ind(struct hci_conn *hcon);
-extern void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
-extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
-extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb,
-			      u16 flags);
-
-extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
-extern void sco_connect_cfm(struct hci_conn *hcon, __u8 status);
-extern void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
-extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
+int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+void l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
+int l2cap_disconn_ind(struct hci_conn *hcon);
+void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
+int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
+int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
+
+int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
+void sco_connect_cfm(struct hci_conn *hcon, __u8 status);
+void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
+int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */

commit 2dea632f9acad076370fe871d4ccc93868621403
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:24:03 2013 +0200

    Bluetooth: Add SCO connection fallback
    
    When initiating a transparent eSCO connection, make use of T2 settings
    at first try. T2 is the recommended settings from HFP 1.6 WideBand
    Speech. Upon connection failure, try T1 settings.
    
    When CVSD is requested and eSCO is supported, try to establish eSCO
    connection using S3 settings. If it fails, fallback in sequence to S2,
    S1, D1, D0 settings.
    
    To know which setting should be used, conn->attempt is used. It
    indicates the currently ongoing SCO connection attempt and can be used
    as the index for the fallback settings table.
    
    These setting and the fallback order are described in Bluetooth HFP 1.6
    specification p. 101.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b2bfab801840..3ede820d328f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -570,7 +570,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 }
 
 void hci_disconnect(struct hci_conn *conn, __u8 reason);
-void hci_setup_sync(struct hci_conn *conn, __u16 handle);
+bool hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);

commit 07a5c61eda7f23883273f738edbf6caaebb71923
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:24:00 2013 +0200

    Bluetooth: Add constants and macro declaration for transparent data
    
    This patch defines constants and macro for transparent data LMP
    features. It refers to Bluetooth Core V4.0 specification, Part C, Chap
    3.3 which defines LMP feature mask.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 61ca2ce5b063..b2bfab801840 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -800,6 +800,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_lsto_capable(dev)      ((dev)->features[0][7] & LMP_LSTO)
 #define lmp_inq_tx_pwr_capable(dev) ((dev)->features[0][7] & LMP_INQ_TX_PWR)
 #define lmp_ext_feat_capable(dev)  ((dev)->features[0][7] & LMP_EXTFEATURES)
+#define lmp_transp_capable(dev)    ((dev)->features[0][2] & LMP_TRANSPARENT)
 
 /* ----- Extended LMP capabilities ----- */
 #define lmp_host_ssp_capable(dev)  ((dev)->features[1][0] & LMP_HOST_SSP)

commit 10c62ddc6f032c3a096401ca3ce7e5b2d5780859
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:23:59 2013 +0200

    Bluetooth: Parameters for outgoing SCO connections
    
    In order to establish a transparent SCO connection, the correct settings
    must be specified in the Setup Synchronous Connection request. For that,
    a setting field is added to ACL connection data to set up the desired
    parameters. The patch also removes usage of hdev->voice_setting in CVSD
    connection and makes use of T2 parameters for transparent data.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f403509b4d12..61ca2ce5b063 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -320,6 +320,7 @@ struct hci_conn {
 	__u32		passkey_notify;
 	__u8		passkey_entered;
 	__u16		disc_timeout;
+	__u16		setting;
 	unsigned long	flags;
 
 	__u8		remote_cap;
@@ -584,8 +585,8 @@ struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type);
-struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
-				 bdaddr_t *dst);
+struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
+				 __u16 setting);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);

commit 5d4d62f6ca04c54ed6c84df6adf5427c52feda3e
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:23:57 2013 +0200

    Bluetooth: Add constants for SCO airmode
    
    This patch defines constants for SCO airmode from SCO voice setting. It
    refers to Bluetooth Core V4.0 specification, Part E, Chap 6.12 which
    describe SCO voice setting format.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 307a19269020..f403509b4d12 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1215,4 +1215,8 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 
 u8 bdaddr_to_le(u8 bdaddr_type);
 
+#define SCO_AIRMODE_MASK       0x0003
+#define SCO_AIRMODE_CVSD       0x0000
+#define SCO_AIRMODE_TRANSP     0x0003
+
 #endif /* __HCI_CORE_H */

commit e660ed6c70370dae0887e2b5224d8b6c1e138120
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:23:54 2013 +0200

    Bluetooth: Use hci_connect_sco directly
    
    hci_connect is a super function for connecting hci protocols. But the
    voice_setting parameter (introduced in subsequent patches) is only
    needed by SCO and security requirements are not needed for SCO channels.
    Thus, it makes sense to have a separate function for SCO.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f77885ea78c2..307a19269020 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -584,6 +584,8 @@ struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type);
+struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
+				 bdaddr_t *dst);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);

commit b0434345f2a7330be5277b63606cff26a7965982
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:38 2013 -0300

    Bluetooth: Remove inquiry helpers
    
    This patch removes hci_do_inquiry and hci_cancel_inquiry helpers. We
    now use the HCI request framework in device discovery functionality
    and these helpers are no longer needed.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5de7eb95ef63..f77885ea78c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1210,8 +1210,6 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
-int hci_do_inquiry(struct hci_dev *hdev, u8 length);
-int hci_cancel_inquiry(struct hci_dev *hdev);
 
 u8 bdaddr_to_le(u8 bdaddr_type);
 

commit 917eedc56c65ba96a3bab4c346d948e73dd872f1
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:37 2013 -0300

    Bluetooth: Remove LE scan helpers
    
    This patch removes the LE scan helpers hci_le_scan and hci_cancel_
    le_scan and all code related to it. We now use the HCI request
    framework in device discovery functionality and these helpers are
    no longer needed.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1b343ef37871..5de7eb95ef63 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -117,13 +117,6 @@ struct oob_data {
 	u8 randomizer[16];
 };
 
-struct le_scan_params {
-	u8 type;
-	u16 interval;
-	u16 window;
-	int timeout;
-};
-
 #define HCI_MAX_SHORT_NAME_LENGTH	10
 
 struct amp_assoc {
@@ -283,9 +276,6 @@ struct hci_dev {
 
 	struct delayed_work	le_scan_disable;
 
-	struct work_struct	le_scan;
-	struct le_scan_params	le_scan_params;
-
 	__s8			adv_tx_power;
 	__u8			adv_data[HCI_MAX_AD_LENGTH];
 	__u8			adv_data_len;
@@ -1222,9 +1212,6 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
 int hci_do_inquiry(struct hci_dev *hdev, u8 length);
 int hci_cancel_inquiry(struct hci_dev *hdev);
-int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
-		int timeout);
-int hci_cancel_le_scan(struct hci_dev *hdev);
 
 u8 bdaddr_to_le(u8 bdaddr_type);
 

commit 1183fdcad42495073045a2d9755e0a6ac2fa874e
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:35 2013 -0300

    Bluetooth: Make mgmt_stop_discovery_failed static
    
    mgmt_stop_discovery_failed is now only used in mgmt.c so we can
    make it a local function. This patch also moves the mgmt_stop_
    discovery_failed definition up in mgmt.c to avoid forward
    declaration.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b3bdad24c2b9..1b343ef37871 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1180,7 +1180,6 @@ int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 ssp, u8 *eir, u16 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
-int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);

commit 4c87eaab01df271c81f6a68e3c28dbd44d348004
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:32 2013 -0300

    Bluetooth: Use HCI request in interleaved discovery
    
    In order to have a better HCI error handling in interleaved discovery
    functionality, we should use the HCI request framework.
    
    This patch updates le_scan_disable_work function so it uses the
    HCI request framework instead of the hci_send_cmd helper. A complete
    callback is registered (le_scan_disable_work_complete function) so we
    are able to trigger the inquiry procedure (if we are running the
    interleaved discovery) or to stop the discovery procedure (if we are
    running LE-only discovery).
    
    This patch also removes the extra logic in hci_cc_le_set_scan_enable
    to trigger the inquiry procedure and the mgmt_interleaved_discovery
    function since they become useless.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 61939a0e6cec..b3bdad24c2b9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1182,7 +1182,6 @@ int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
-int mgmt_interleaved_discovery(struct hci_dev *hdev);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 bool mgmt_valid_hdev(struct hci_dev *hdev);

commit 0d8cc935e01c0fd1312a10881f4c0f1c4b4d05ab
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:31 2013 -0300

    Bluetooth: Move discovery macros to hci_core.h
    
    Some of discovery macros will be used in hci_core so we need to
    define them in common place such as hci_core.h. Thus, this patch
    moves discovery macros to hci_core.h and also adds the DISCOV_
    prefix to them.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ff4e8a5c9ceb..61939a0e6cec 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1115,6 +1115,16 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 					 BIT(BDADDR_LE_PUBLIC) | \
 					 BIT(BDADDR_LE_RANDOM))
 
+/* These LE scan and inquiry parameters were chosen according to LE General
+ * Discovery Procedure specification.
+ */
+#define DISCOV_LE_SCAN_WIN		0x12
+#define DISCOV_LE_SCAN_INT		0x12
+#define DISCOV_LE_TIMEOUT		msecs_to_jiffies(10240)
+#define DISCOV_INTERLEAVED_TIMEOUT	msecs_to_jiffies(5120)
+#define DISCOV_INTERLEAVED_INQUIRY_LEN	0x04
+#define DISCOV_BREDR_INQUIRY_LEN	0x08
+
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(struct hci_dev *hdev);
 int mgmt_index_removed(struct hci_dev *hdev);

commit 41dc2bd6d13bfccc34d05586be2eb65876a5990a
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:30 2013 -0300

    Bluetooth: Make mgmt_start_discovery_failed static
    
    mgmt_start_discovery_failed is now only used in mgmt.c so we can
    make it a local function. This patch also moves the mgmt_start_
    discovery_failed definition up in mgmt.c to avoid forward
    declaration.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7c150e4d65b9..ff4e8a5c9ceb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1170,7 +1170,6 @@ int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		      u8 ssp, u8 *eir, u16 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
-int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_interleaved_discovery(struct hci_dev *hdev);

commit 1f9b9a5dc5bb8ee360db9d32b2090aac497ae82a
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 30 15:29:27 2013 -0300

    Bluetooth: Make inquiry_cache_flush non-static
    
    In order to use HCI request framework in start_discovery, we'll need
    to call inquiry_cache_flush in mgmt.c. Therefore, this patch adds the
    hci_ prefix to inquiry_cache_flush and makes it non-static.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7cb6d360d147..7c150e4d65b9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -432,6 +432,7 @@ void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
 				      struct inquiry_entry *ie);
 bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
 			      bool name_known, bool *ssp);
+void hci_inquiry_cache_flush(struct hci_dev *hdev);
 
 /* ----- HCI Connections ----- */
 enum {

commit 96570ffcca0b872dc8626e97569d2697f374d868
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed May 29 09:51:29 2013 +0300

    Bluetooth: Fix mgmt handling of power on failures
    
    If hci_dev_open fails we need to ensure that the corresponding
    mgmt_set_powered command gets an appropriate response. This patch fixes
    the missing response by adding a new mgmt_set_powered_failed function
    that's used to indicate a power on failure to mgmt. Since a situation
    with the device being rfkilled may require special handling in user
    space the patch uses a new dedicated mgmt status code for this.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Cc: stable@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 35a57cd1704c..7cb6d360d147 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1117,6 +1117,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(struct hci_dev *hdev);
 int mgmt_index_removed(struct hci_dev *hdev);
+int mgmt_set_powered_failed(struct hci_dev *hdev, int err);
 int mgmt_powered(struct hci_dev *hdev, u8 powered);
 int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 int mgmt_connectable(struct hci_dev *hdev, u8 connectable);

commit 07dc93dd14957dc1faba08f0aadd27b082e35ba2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Apr 19 10:14:51 2013 +0300

    Bluetooth: Fix HCI command send functions to use const specifier
    
    All HCI command send functions that take a pointer to the command
    parameters do not need to modify the content in any way (they merely
    copy the data to an skb). Therefore, the parameter type should be
    declared const. This also allows passing already const parameters to
    these APIs which previously would have generated a compiler warning.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 80d718a9b31f..35a57cd1704c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1081,17 +1081,19 @@ struct hci_request {
 
 void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
 int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
-void hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
-void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen, void *param,
-		    u8 event);
+void hci_req_add(struct hci_request *req, u16 opcode, u32 plen,
+		 const void *param);
+void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen,
+		    const void *param, u8 event);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
-			       void *param, u32 timeout);
+			       const void *param, u32 timeout);
 struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,
-				  void *param, u8 event, u32 timeout);
+				  const void *param, u8 event, u32 timeout);
 
-int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
+int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen,
+		 const void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 

commit d2c5d77fff6ac0f43fc36f4fde020f726f773c1d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Apr 17 15:00:52 2013 +0300

    Bluetooth: Add reading of all local feature pages
    
    With the introduction of CSA4 there is now also a features page number 2
    available. This patch increments the maximum supported page number to 2
    and adds code for reading all available pages (as long as we have
    support for them - indicated by HCI_MAX_PAGES).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 26822967e29c..80d718a9b31f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -134,7 +134,7 @@ struct amp_assoc {
 	__u8	data[HCI_MAX_AMP_ASSOC_SIZE];
 };
 
-#define HCI_MAX_PAGES	2
+#define HCI_MAX_PAGES	3
 
 #define NUM_REASSEMBLY 4
 struct hci_dev {
@@ -153,6 +153,7 @@ struct hci_dev {
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;
+	__u8		max_page;
 	__u8		features[HCI_MAX_PAGES][8];
 	__u8		le_features[8];
 	__u8		le_white_list_size;

commit cad718ed2f6fd204b2c5cac6b611fc3fcde7b183
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Apr 17 15:00:51 2013 +0300

    Bluetooth: Track feature pages in a single table
    
    The local and remote features are organized by page number. Page 0
    are the LMP features, page 1 the host features, and any pages beyond 1
    features that future core specification versions may define. So far
    we've only had the first two pages and two separate variables has been
    convenient enough, however with the introduction of Core Specification
    Addendum 4 there are features defined on page 2.
    
    Instead of requiring the addition of a new variable each time a new page
    number is defined, this patch refactors the code to use a single table
    for the features. The patch needs to update both the hci_dev and
    hci_conn structures since there are macros that depend on the features
    being represented in the same way in both of them.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 74f77b7ef136..26822967e29c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -134,6 +134,8 @@ struct amp_assoc {
 	__u8	data[HCI_MAX_AMP_ASSOC_SIZE];
 };
 
+#define HCI_MAX_PAGES	2
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -151,8 +153,7 @@ struct hci_dev {
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;
-	__u8		features[8];
-	__u8		host_features[8];
+	__u8		features[HCI_MAX_PAGES][8];
 	__u8		le_features[8];
 	__u8		le_white_list_size;
 	__u8		le_states[8];
@@ -313,7 +314,7 @@ struct hci_conn {
 	bool		out;
 	__u8		attempt;
 	__u8		dev_class[3];
-	__u8		features[8];
+	__u8		features[HCI_MAX_PAGES][8];
 	__u16		interval;
 	__u16		pkt_type;
 	__u16		link_policy;
@@ -786,29 +787,29 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->dev.parent = (pdev))
 
 /* ----- LMP capabilities ----- */
-#define lmp_encrypt_capable(dev)   ((dev)->features[0] & LMP_ENCRYPT)
-#define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)
-#define lmp_hold_capable(dev)      ((dev)->features[0] & LMP_HOLD)
-#define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
-#define lmp_park_capable(dev)      ((dev)->features[1] & LMP_PARK)
-#define lmp_inq_rssi_capable(dev)  ((dev)->features[3] & LMP_RSSI_INQ)
-#define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
-#define lmp_bredr_capable(dev)     (!((dev)->features[4] & LMP_NO_BREDR))
-#define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
-#define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
-#define lmp_pause_enc_capable(dev) ((dev)->features[5] & LMP_PAUSE_ENC)
-#define lmp_ext_inq_capable(dev)   ((dev)->features[6] & LMP_EXT_INQ)
-#define lmp_le_br_capable(dev)     !!((dev)->features[6] & LMP_SIMUL_LE_BR)
-#define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
-#define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
-#define lmp_lsto_capable(dev)      ((dev)->features[7] & LMP_LSTO)
-#define lmp_inq_tx_pwr_capable(dev) ((dev)->features[7] & LMP_INQ_TX_PWR)
-#define lmp_ext_feat_capable(dev)  ((dev)->features[7] & LMP_EXTFEATURES)
+#define lmp_encrypt_capable(dev)   ((dev)->features[0][0] & LMP_ENCRYPT)
+#define lmp_rswitch_capable(dev)   ((dev)->features[0][0] & LMP_RSWITCH)
+#define lmp_hold_capable(dev)      ((dev)->features[0][0] & LMP_HOLD)
+#define lmp_sniff_capable(dev)     ((dev)->features[0][0] & LMP_SNIFF)
+#define lmp_park_capable(dev)      ((dev)->features[0][1] & LMP_PARK)
+#define lmp_inq_rssi_capable(dev)  ((dev)->features[0][3] & LMP_RSSI_INQ)
+#define lmp_esco_capable(dev)      ((dev)->features[0][3] & LMP_ESCO)
+#define lmp_bredr_capable(dev)     (!((dev)->features[0][4] & LMP_NO_BREDR))
+#define lmp_le_capable(dev)        ((dev)->features[0][4] & LMP_LE)
+#define lmp_sniffsubr_capable(dev) ((dev)->features[0][5] & LMP_SNIFF_SUBR)
+#define lmp_pause_enc_capable(dev) ((dev)->features[0][5] & LMP_PAUSE_ENC)
+#define lmp_ext_inq_capable(dev)   ((dev)->features[0][6] & LMP_EXT_INQ)
+#define lmp_le_br_capable(dev)     (!!((dev)->features[0][6] & LMP_SIMUL_LE_BR))
+#define lmp_ssp_capable(dev)       ((dev)->features[0][6] & LMP_SIMPLE_PAIR)
+#define lmp_no_flush_capable(dev)  ((dev)->features[0][6] & LMP_NO_FLUSH)
+#define lmp_lsto_capable(dev)      ((dev)->features[0][7] & LMP_LSTO)
+#define lmp_inq_tx_pwr_capable(dev) ((dev)->features[0][7] & LMP_INQ_TX_PWR)
+#define lmp_ext_feat_capable(dev)  ((dev)->features[0][7] & LMP_EXTFEATURES)
 
 /* ----- Extended LMP capabilities ----- */
-#define lmp_host_ssp_capable(dev)  ((dev)->host_features[0] & LMP_HOST_SSP)
-#define lmp_host_le_capable(dev)   !!((dev)->host_features[0] & LMP_HOST_LE)
-#define lmp_host_le_br_capable(dev) !!((dev)->host_features[0] & LMP_HOST_LE_BREDR)
+#define lmp_host_ssp_capable(dev)  ((dev)->features[1][0] & LMP_HOST_SSP)
+#define lmp_host_le_capable(dev)   (!!((dev)->features[1][0] & LMP_HOST_LE))
+#define lmp_host_le_br_capable(dev) (!!((dev)->features[1][0] & LMP_HOST_LE_BREDR))
 
 /* returns true if at least one AMP active */
 static inline bool hci_amp_capable(void)

commit fa5513be2b709c8ce6ff0b11d0715760a9a70ffd
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Tue Apr 16 17:28:58 2013 +0200

    Bluetooth: Move and rename hci_conn_accept
    
    Since this function is only used by sco, move it from hci_event.c to
    sco.c and rename to sco_conn_defer_accept. Make it static.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d324b11a0c8f..74f77b7ef136 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -583,7 +583,6 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
-void hci_conn_accept(struct hci_conn *conn, int mask);
 
 struct hci_chan *hci_chan_create(struct hci_conn *conn);
 void hci_chan_del(struct hci_chan *chan);

commit 8d12356f33f819ec0d064e233f7ca8e59eaa38ef
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Sat Apr 6 20:28:39 2013 +0200

    Bluetooth: introduce hci_conn ref-counting
    
    We currently do not allow using hci_conn from outside of HCI-core.
    However, several other users could make great use of it. This includes
    HIDP, rfcomm and all other sub-protocols that rely on an active
    connection.
    
    Hence, we now introduce hci_conn ref-counting. We currently never call
    get_device(). put_device() is exclusively used in hci_conn_del_sysfs().
    Hence, we currently never have a greater device-refcnt than 1.
    Therefore, it is safe to move the put_device() call from
    hci_conn_del_sysfs() to hci_conn_del() (it's the only caller). In fact,
    this even fixes a "use-after-free" bug as we access hci_conn after calling
    hci_conn_del_sysfs() in hci_conn_del().
    
    From now on we can add references to hci_conn objects in other layers
    (like l2cap_sock, HIDP, rfcomm, ...) and grab a reference via
    hci_conn_get(). This does _not_ guarantee, that the connection is still
    alive. But, this isn't what we want. We can simply lock the hci_conn
    device and use "device_is_registered(hci_conn->dev)" to test that.
    However, this is hardly necessary as outside users should never rely on
    the HCI connection to be alive, anyway. Instead, they should solely rely
    on the device-object to be available.
    But if sub-devices want the hci_conn object as sysfs parent, they need to
    be notified when the connection drops. This will be introduced in later
    patches with l2cap_users.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5590cc4412c6..d324b11a0c8f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -600,6 +600,37 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
 
+/*
+ * hci_conn_get() and hci_conn_put() are used to control the life-time of an
+ * "hci_conn" object. They do not guarantee that the hci_conn object is running,
+ * working or anything else. They just guarantee that the object is available
+ * and can be dereferenced. So you can use its locks, local variables and any
+ * other constant data.
+ * Before accessing runtime data, you _must_ lock the object and then check that
+ * it is still running. As soon as you release the locks, the connection might
+ * get dropped, though.
+ *
+ * On the other hand, hci_conn_hold() and hci_conn_drop() are used to control
+ * how long the underlying connection is held. So every channel that runs on the
+ * hci_conn object calls this to prevent the connection from disappearing. As
+ * long as you hold a device, you must also guarantee that you have a valid
+ * reference to the device via hci_conn_get() (or the initial reference from
+ * hci_conn_add()).
+ * The hold()/drop() ref-count is known to drop below 0 sometimes, which doesn't
+ * break because nobody cares for that. But this means, we cannot use
+ * _get()/_drop() in it, but require the caller to have a valid ref (FIXME).
+ */
+
+static inline void hci_conn_get(struct hci_conn *conn)
+{
+	get_device(&conn->dev);
+}
+
+static inline void hci_conn_put(struct hci_conn *conn)
+{
+	put_device(&conn->dev);
+}
+
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	BT_DBG("hcon %p orig refcnt %d", conn, atomic_read(&conn->refcnt));

commit fc225c3f5d1b6aa6f99c5c300af4605e4923ce79
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Sat Apr 6 20:28:38 2013 +0200

    Bluetooth: remove unneeded hci_conn_hold/put_device()
    
    hci_conn_hold/put_device() is used to control when hci_conn->dev is no
    longer needed and can be deleted from the system. Lets first look how they
    are currently used throughout the code (excluding HIDP!).
    
    All code that uses hci_conn_hold_device() looks like this:
        ...
        hci_conn_hold_device();
        hci_conn_add_sysfs();
        ...
    On the other side, hci_conn_put_device() is exclusively used in
    hci_conn_del().
    
    So, considering that hci_conn_del() must not be called twice (which would
    fail horribly), we know that hci_conn_put_device() is only called _once_
    (which is in hci_conn_del()).
    On the other hand, hci_conn_add_sysfs() must not be called twice, either
    (it would call device_add twice, which breaks the device, see
    drivers/base/core.c). So we know that hci_conn_hold_device() is also
    called only once (it's only called directly before hci_conn_add_sysfs()).
    
    So hold and put are known to be called only once. That means we can safely
    remove them and directly call hci_conn_del_sysfs() in hci_conn_del().
    
    But there is one issue left: HIDP also uses hci_conn_hold/put_device().
    However, this case can be ignored and simply removed as it is totally
    broken. The issue is, the only thing HIDP delays with
    hci_conn_hold_device() is the removal of the hci_conn->dev from sysfs.
    But, the hci_conn device has no mechanism to get notified when its own
    parent (hci_dev) gets removed from sysfs. hci_dev_hold/put() does _not_
    control when it is removed but only when the device object is created
    and destroyed.
    And hci_dev calls hci_conn_flush_*() when it removes itself from sysfs,
    which itself causes hci_conn_del() to be called, but it does _not_ cause
    hci_conn_del_sysfs() to be called, which is wrong.
    
    Hence, we fix it to call hci_conn_del_sysfs() in hci_conn_del(). This
    guarantees that a hci_conn object is removed from sysfs _before_ its
    parent hci_dev is removed.
    
    The changes to HIDP look scary, wrong and broken. However, if you look at
    the HIDP session management, you will notice they're already broken in the
    exact _same_ way (ever tried "unplugging" HIDP devices? Breaks _all_ the
    time).
    So this patch only makes HIDP look _scary_ and _obviously broken_. It does
    not break HIDP itself, it already is!
    
    See later patches in this series which fix HIDP to use proper
    session-management.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 78ea9c7c202c..5590cc4412c6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -345,7 +345,6 @@ struct hci_conn {
 	struct timer_list auto_accept_timer;
 
 	struct device	dev;
-	atomic_t	devref;
 
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
@@ -601,9 +600,6 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
 
-void hci_conn_hold_device(struct hci_conn *conn);
-void hci_conn_put_device(struct hci_conn *conn);
-
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	BT_DBG("hcon %p orig refcnt %d", conn, atomic_read(&conn->refcnt));

commit 76a68ba0ae097be72dfa8f918b3139130da769a4
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Sat Apr 6 20:28:37 2013 +0200

    Bluetooth: rename hci_conn_put to hci_conn_drop
    
    We use _get() and _put() for device ref-counting in the kernel. However,
    hci_conn_put() is _not_ used for ref-counting, hence, rename it to
    hci_conn_drop() so we can later fix ref-counting and introduce
    hci_conn_put().
    
    hci_conn_hold() and hci_conn_put() are currently used to manage how long a
    connection should be held alive. When the last user drops the connection,
    we spawn a delayed work that performs the disconnect. Obviously, this has
    nothing to do with ref-counting for the _object_ but rather for the
    keep-alive of the connection.
    
    But we really _need_ proper ref-counting for the _object_ to allow
    connection-users like rfcomm-tty, HIDP or others.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d4e13bf5ae59..78ea9c7c202c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -612,7 +612,7 @@ static inline void hci_conn_hold(struct hci_conn *conn)
 	cancel_delayed_work(&conn->disc_work);
 }
 
-static inline void hci_conn_put(struct hci_conn *conn)
+static inline void hci_conn_drop(struct hci_conn *conn)
 {
 	BT_DBG("hcon %p orig refcnt %d", conn, atomic_read(&conn->refcnt));
 

commit 5afff03815e26abf34702ec10422535224cdfe38
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 12 14:02:16 2012 +0900

    Bluetooth: Remove driver init queue from core
    
    The driver init queue is no longer needed. This can be all handled
    inside the drivers now. So remove it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 395e8f6982f9..d4e13bf5ae59 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -269,8 +269,6 @@ struct hci_dev {
 
 	struct hci_dev_stats	stat;
 
-	struct sk_buff_head	driver_init;
-
 	atomic_t		promisc;
 
 	struct dentry		*debugfs;

commit f41c70c4d5e3f6c2a7f9e5dfc10af452591a2484
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Nov 12 14:02:14 2012 +0900

    Bluetooth: Add driver setup stage for early init
    
    Some drivers require a special stage for their early init. This is
    always specific to the driver or transport. So call back into driver to
    allow bringing up the device.
    
    The advantage with this stage is that the Bluetooth core is actually
    handling the HCI layer now. This means that command and event processing
    is available.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 47129b1ee20b..395e8f6982f9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -293,6 +293,7 @@ struct hci_dev {
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
+	int (*setup)(struct hci_dev *hdev);
 	int (*send)(struct sk_buff *skb);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);

commit 7b1abbbed0f2a1bc19bb8c0d48a284466043092a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Apr 3 21:54:47 2013 +0300

    Bluetooth: Add __hci_cmd_sync_ev function
    
    This patch adds a __hci_cmd_sync_ev function, analogous to
    __hci_cmd_sync except that it also takes an event parameter to indicate
    that the command completes with a special event instead of command
    complete. Internally this new function takes advantage of the
    hci_req_add_ev function introduced in the previous patch.
    
    The primary expected user of this new function are the setup routines of
    HCI drivers which may want to send custom commands and return only when
    they have completed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b85eefb230fd..47129b1ee20b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1061,6 +1061,8 @@ void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
 			       void *param, u32 timeout);
+struct sk_buff *__hci_cmd_sync_ev(struct hci_dev *hdev, u16 opcode, u32 plen,
+				  void *param, u8 event, u32 timeout);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);

commit 02350a725f5bc44490c30a10e7e04a12a5ecd406
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Apr 3 21:50:29 2013 +0300

    Bluetooth: Add support for custom event terminated commands
    
    This patch adds support for having commands within HCI requests that do
    not result in a command complete but some other event. This is at least
    needed for some vendor specific commands to be issued in the
    hdev->setup() procecure, but might also be useful for other commands.
    
    The way that the support is implemented is by extending the skb control
    buffer to have a field to indicate that the command is expected to
    terminate with a special event. After sending the command each received
    event can then be compared against this field through hdev->sent_cmd.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 755743d508aa..b85eefb230fd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1055,6 +1055,8 @@ struct hci_request {
 void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
 int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
 void hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
+void hci_req_add_ev(struct hci_request *req, u16 opcode, u32 plen, void *param,
+		    u8 event);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 
 struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,

commit 75e84b7c522c6e07964cd1f5bf28535768a1e9fa
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Apr 2 13:35:04 2013 +0300

    Bluetooth: Add __hci_cmd_sync() helper function
    
    This patch adds a helper function for sending a single HCI command
    waiting for its completion and then returning back the parameters in the
    resulting command complete event (if there was one).
    
    The implementation is very similar to that of hci_req_sync() except that
    instead of invocing a callback for sending HCI commands the function
    constructs and sends one itself and after being woken up picks the last
    received event from hdev->recv_evt (if it matches the right criteria)
    and returns it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 89eda2ef2380..755743d508aa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1057,6 +1057,9 @@ int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
 void hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 
+struct sk_buff *__hci_cmd_sync(struct hci_dev *hdev, u16 opcode, u32 plen,
+			       void *param, u32 timeout);
+
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);

commit b6ddb638235d90ed67af9af40e63880fd66a1939
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Apr 2 13:34:31 2013 +0300

    Bluetooth: Track received events in hdev
    
    This patch adds tracking of received HCI events to the hci_dev struct.
    This is necessary so that a subsequent patch can implement a function
    for sending a single command synchronously and returning the resulting
    command complete parameters in the function return value.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0e7ee892d7ab..89eda2ef2380 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -244,6 +244,7 @@ struct hci_dev {
 	struct sk_buff_head	raw_q;
 	struct sk_buff_head	cmd_q;
 
+	struct sk_buff		*recv_evt;
 	struct sk_buff		*sent_cmd;
 	struct sk_buff		*reassembly[NUM_REASSEMBLY];
 

commit d4299ce6b33c0afd22cf6a170cfaf89c63d1114d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Mar 27 20:04:57 2013 -0300

    Bluetooth: Remove unneeded hci_req_cmd_status function
    
    This patch removes the hci_req_cmd_status function since it is not
    used anymore. The HCI request framework now considers the HCI command
    has complete once the Command Status or Command Complete Event is
    received.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 358a6983d3bb..0e7ee892d7ab 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1055,7 +1055,6 @@ void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
 int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
 void hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
-void hci_req_cmd_status(struct hci_dev *hdev, u16 opcode, u8 status);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);

commit f332ec6699980e0563408c7bcf1a8a31b825fee1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Mar 15 17:07:11 2013 -0500

    Bluetooth: Add reading of page scan parameters
    
    These parameters are related to the "fast connectable" mode that can be
    changed through the mgmt interface. Not all controllers properly reset
    these values with HCI_Reset so they need to be read in order to be able
    to verify whether the values are correct or not before enabling page
    scan.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cb99193c7493..358a6983d3bb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -165,6 +165,10 @@ struct hci_dev {
 	__u16		voice_setting;
 	__u8		io_capability;
 	__s8		inq_tx_power;
+	__u16		page_scan_interval;
+	__u16		page_scan_window;
+	__u8		page_scan_type;
+
 	__u16		devid_source;
 	__u16		devid_vendor;
 	__u16		devid_product;

commit 04b4edcbc9049e100681c0149b572de439be42ab
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Mar 15 17:07:01 2013 -0500

    Bluetooth: Handle AD updating through an async request
    
    For proper control of the AD update and the related HCI commands it's
    best to run the AD update through an async request instead of a
    standalone HCI command. This patch changes the hci_update_ad() function
    to take a request pointer and updates its users appropriately. E.g. the
    function is no longer called after the init sequence but during stage 3
    of the init sequence.
    
    The TX power is read during the init sequence, so we don't need an
    explicit update whenever it is read and the AD update based on the local
    name should be done through the local name mgmt handler. The only other
    user is the update based on enabling advertising. This part is still
    kept as there is no mgmt API to enable it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d6c32561fc02..cb99193c7493 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -740,8 +740,6 @@ int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
 								u8 *randomizer);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
-int hci_update_ad(struct hci_dev *hdev);
-
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);
@@ -1167,6 +1165,8 @@ struct hci_sec_filter {
 #define hci_req_lock(d)		mutex_lock(&d->req_lock)
 #define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
 
+void hci_update_ad(struct hci_request *req);
+
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],

commit e348fe6bbab85c513816d2536ffabac4be016442
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Mar 8 11:20:17 2013 -0300

    Bluetooth: Make hci_req_add returning void
    
    Since no one checks the returning value of hci_req_add and HCI
    request errors are now handled in hci_req_run, we can make hci_
    req_add returning void.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 332ee5099a52..d6c32561fc02 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1051,7 +1051,7 @@ struct hci_request {
 
 void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
 int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
-int hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
+void hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
 void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
 void hci_req_cmd_status(struct hci_dev *hdev, u16 opcode, u8 status);
 

commit 5d73e0342fd9bf500583868906325d42c4d2bf6f
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Mar 8 11:20:16 2013 -0300

    Bluetooth: HCI request error handling
    
    When we are building a HCI request with more than one HCI command
    and one of the hci_req_add calls fail, we should have some cleanup
    routine so the HCI commands already queued on HCI request can be
    deleted. Otherwise, we will face some memory leaks issues.
    
    This patch implements the HCI request error handling which is the
    following: If a hci_req_add fails, we save the error code in hci_
    request. Once hci_req_run is called, we verify the error field. If
    it is different from zero, we delete all HCI commands already queued
    and return the error code.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3a9cbf2b55c0..332ee5099a52 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1042,6 +1042,11 @@ int hci_unregister_cb(struct hci_cb *hcb);
 struct hci_request {
 	struct hci_dev		*hdev;
 	struct sk_buff_head	cmd_q;
+
+	/* If something goes wrong when building the HCI request, the error
+	 * value is stored in this field.
+	 */
+	int			err;
 };
 
 void hci_req_init(struct hci_request *req, struct hci_dev *hdev);

commit cecbb967b2f5c52e090978ff6afe7deddbfbeda5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 5 20:37:50 2013 +0200

    Bluetooth: Remove unused hdev->init_last_cmd
    
    This variable is no longer needed (due to async HCI request support and
    the conversion of hci_req_sync to use it), so it can be safely removed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3f124f43fcb1..3a9cbf2b55c0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -248,8 +248,6 @@ struct hci_dev {
 	__u32			req_status;
 	__u32			req_result;
 
-	__u16			init_last_cmd;
-
 	struct list_head	mgmt_pending;
 
 	struct discovery_state	discovery;

commit 42c6b129cd8c2aa5012a78ec39672e7052cc677a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 5 20:37:49 2013 +0200

    Bluetooth: Use async requests internally in hci_req_sync
    
    This patch converts the hci_req_sync() procedure to internaly use the
    asynchronous HCI requests.
    
    The hci_req_sync mechanism relies on hci_req_complete() calls from
    hci_event.c into hci_core.c whenever a HCI command completes. This is
    very similar to what asynchronous requests do and makes the conversion
    fairly straight forward by converting hci_req_complete into a request
    complete callback. By this change hci_req_complete (renamed to
    hci_req_sync_complete) becomes private to hci_core.c and all calls to it
    can be removed from hci_event.c.
    
    The commands in each hci_req_sync procedure are collected into their own
    request by passing the hci_request pointer to the request callback
    (instead of the hci_dev pointer). The one slight exception is the HCI
    init request which has the special handling of HCI driver specific
    initialization commands. These commands are run in their own request
    prior to the "main" init request.
    
    One other extra change that this patch must contain is the handling of
    spontaneous HCI reset complete events that some controllers exhibit.
    These were previously handled in the hci_req_complete function but the
    right place for them now becomes the hci_req_cmd_complete function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d732d6894adc..3f124f43fcb1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1164,8 +1164,6 @@ struct hci_sec_filter {
 #define hci_req_lock(d)		mutex_lock(&d->req_lock)
 #define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
 
-void hci_req_complete(struct hci_dev *hdev, __u16 cmd, int result);
-
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],

commit 9238f36a5a5097018b90baa42c473d2f916a46f5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 5 20:37:48 2013 +0200

    Bluetooth: Add request cmd_complete and cmd_status functions
    
    This patch introduces functions to process the HCI request state when
    receiving HCI Command Status or Command Complete events. Some HCI
    commands, like Inquiry do not result in a Command complete event so
    special handling is needed for them. Inquiry is a particularly important
    one since it is the only forseeable "non-cmd_complete" command that will
    make good use of the request functionality, and its completion is either
    indicated by an Inquiry Complete event of a successful Command Complete
    for HCI_Inquiry_Cancel.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 67fe661259ba..d732d6894adc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1049,6 +1049,8 @@ struct hci_request {
 void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
 int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
 int hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
+void hci_req_cmd_complete(struct hci_dev *hdev, u16 opcode, u8 status);
+void hci_req_cmd_status(struct hci_dev *hdev, u16 opcode, u8 status);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);

commit 71c76a170e979d60e01bd093c9b79e3adeb710cc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 5 20:37:46 2013 +0200

    Bluetooth: Introduce new hci_req_add function
    
    This function is analogous to hci_send_cmd() but instead of directly
    queuing the command to hdev->cmd_q it adds it to the local queue of the
    asynchronous HCI request being build (inside struct hci_request).
    
    This is the main function used for building asynchronous requests and
    there should be one or more calls to it between calls to hci_req_init
    and hci_req_run.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7191217c6bd1..67fe661259ba 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1048,6 +1048,7 @@ struct hci_request {
 
 void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
 int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
+int hci_req_add(struct hci_request *req, u16 opcode, u32 plen, void *param);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);

commit 3119ae9599e5cdc1b9838563905c500b582ab6a5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 5 20:37:44 2013 +0200

    Bluetooth: Add initial skeleton for asynchronous HCI requests
    
    This patch adds the initial definitions and functions for asynchronous
    HCI requests. Asynchronous requests are essentially a group of HCI
    commands together with an optional completion callback. The request is
    tracked through the already existing command queue by having the
    necessary context information as part of the control buffer of each skb.
    
    The only information needed in the skb control buffer is a flag for
    indicating that the skb is the start of a request as well as the
    optional complete callback that should be used when the request is
    complete (this will be found in the last skb of the request).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 787d3b9bbd58..7191217c6bd1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1041,6 +1041,14 @@ static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 
+struct hci_request {
+	struct hci_dev		*hdev;
+	struct sk_buff_head	cmd_q;
+};
+
+void hci_req_init(struct hci_request *req, struct hci_dev *hdev);
+int hci_req_run(struct hci_request *req, hci_req_complete_t complete);
+
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);

commit bed71748346ae0807c7f7a2913965508dbd61403
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Jan 30 11:50:56 2013 -0300

    Bluetooth: Rename hci_acl_disconn
    
    As hci_acl_disconn function basically sends the HCI Disconnect Command
    and it is used to disconnect ACL, SCO and LE links, renaming it to
    hci_disconnect is more suitable.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 90cf75afcb02..787d3b9bbd58 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -574,7 +574,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 	return NULL;
 }
 
-void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
+void hci_disconnect(struct hci_conn *conn, __u8 reason);
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 

commit 83be8eca2e67faaec45280224b798828bbfa69aa
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jan 27 00:31:29 2013 +0200

    Bluetooth: Keep track of UUID type upon addition
    
    The primary purpose of the UUIDs is to enable generation of EIR and AD
    data. In these data formats the UUIDs are split into separate fields
    based on whether they're 16, 32 or 128 bit UUIDs. To make the generation
    of these data fields simpler this patch adds a type member to the
    bt_uuid struct and assigns a value to it as soon as the UUID is added to
    the kernel. This way the type doesn't need to be calculated each time
    the UUID list is later iterated.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bcf8ffe2a843..90cf75afcb02 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -86,6 +86,7 @@ struct bdaddr_list {
 struct bt_uuid {
 	struct list_head list;
 	u8 uuid[16];
+	u8 size;
 	u8 svc_hint;
 };
 

commit 9b008c0457e583e10e62d1215bed6ab26ee54906
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 22 14:02:01 2013 +0200

    Bluetooth: Add support for reading LE supported states
    
    The LE supported states indicate the states and state combinations that
    the link layer supports. This is important information for knowing what
    operations are possible when dealing with multiple connected devices.
    This patch adds reading of the supported states to the HCI init
    sequence.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d6ed4ac18d83..bcf8ffe2a843 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -154,6 +154,7 @@ struct hci_dev {
 	__u8		host_features[8];
 	__u8		le_features[8];
 	__u8		le_white_list_size;
+	__u8		le_states[8];
 	__u8		commands[64];
 	__u8		hci_ver;
 	__u16		hci_rev;

commit cf1d081f6597a45e5ff63f55c893494a8ae1cdaf
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 22 14:02:00 2013 +0200

    Bluetooth: Add support for reading LE White List Size
    
    The LE White List Size is necessary to be known before attempting to
    feed the controller with any addresses intended for the white list. This
    patch adds the necessary HCI command sending to the HCI init sequence.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3f607c94e213..d6ed4ac18d83 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -153,6 +153,7 @@ struct hci_dev {
 	__u8		features[8];
 	__u8		host_features[8];
 	__u8		le_features[8];
+	__u8		le_white_list_size;
 	__u8		commands[64];
 	__u8		hci_ver;
 	__u16		hci_rev;

commit 60e77321985ab599fac010afdc465c3e30281a06
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 22 14:01:59 2013 +0200

    Bluetooth: Add LE Local Features reading support
    
    To be able to make the appropriate decisions for some LE procedures we
    need to know the LE features that the local controller supports.
    Therefore, it's important to have the LE Read Local Supported Features
    HCI comand as part of the HCI init sequence.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 769a740c104c..3f607c94e213 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -152,6 +152,7 @@ struct hci_dev {
 	__u8		minor_class;
 	__u8		features[8];
 	__u8		host_features[8];
+	__u8		le_features[8];
 	__u8		commands[64];
 	__u8		hci_ver;
 	__u16		hci_rev;

commit 6ead1bbc381a674c20f227dbe6f3a8c6f67ce7a2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 14 22:33:50 2013 +0200

    Bluetooth: Add a new workqueue for hci_request operations
    
    The hci_request function is blocking and cannot be called through the
    usual per-HCI device workqueue (hdev->workqueue). While hci_request is
    in progress any other work from the queue, including sending HCI
    commands to the controller would be blocked and eventually cause the
    hci_request call to time out.
    
    This patch adds a second workqueue to be used by operations needing
    hci_request and thereby avoiding issues with blocking other workqueue
    users.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 014a2eaa5389..769a740c104c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -216,6 +216,7 @@ struct hci_dev {
 	unsigned long	le_last_tx;
 
 	struct workqueue_struct	*workqueue;
+	struct workqueue_struct	*req_workqueue;
 
 	struct work_struct	power_on;
 	struct delayed_work	power_off;

commit 5d05416e0907b0dd30b62b002bed3b85e6efbd61
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Nov 29 17:46:05 2012 +0200

    Bluetooth: AMP: Check that AMP is present and active
    
    Before starting quering remote AMP controllers make sure
    that there is local active AMP controller.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2f2b743f5b10..014a2eaa5389 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -779,6 +779,22 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_host_le_capable(dev)   !!((dev)->host_features[0] & LMP_HOST_LE)
 #define lmp_host_le_br_capable(dev) !!((dev)->host_features[0] & LMP_HOST_LE_BREDR)
 
+/* returns true if at least one AMP active */
+static inline bool hci_amp_capable(void)
+{
+	struct hci_dev *hdev;
+	bool ret = false;
+
+	read_lock(&hci_dev_list_lock);
+	list_for_each_entry(hdev, &hci_dev_list, list)
+		if (hdev->amp_type == HCI_AMP &&
+		    test_bit(HCI_UP, &hdev->flags))
+			ret = true;
+	read_unlock(&hci_dev_list_lock);
+
+	return ret;
+}
+
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01
 

commit ffa88e02bc67a1496fae762ad899e8f49136e7a1
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Fri Nov 23 16:50:51 2012 -0200

    Bluetooth: Move double negation to macros
    
    Some comparisons needs to double negation(!!) in order to make the value
    of the field boolean. Add it to the macro makes the code more readable.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 76891a914e75..2f2b743f5b10 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -767,7 +767,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
 #define lmp_pause_enc_capable(dev) ((dev)->features[5] & LMP_PAUSE_ENC)
 #define lmp_ext_inq_capable(dev)   ((dev)->features[6] & LMP_EXT_INQ)
-#define lmp_le_br_capable(dev)     ((dev)->features[6] & LMP_SIMUL_LE_BR)
+#define lmp_le_br_capable(dev)     !!((dev)->features[6] & LMP_SIMUL_LE_BR)
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_lsto_capable(dev)      ((dev)->features[7] & LMP_LSTO)
@@ -776,8 +776,8 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 
 /* ----- Extended LMP capabilities ----- */
 #define lmp_host_ssp_capable(dev)  ((dev)->host_features[0] & LMP_HOST_SSP)
-#define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
-#define lmp_host_le_br_capable(dev) ((dev)->host_features[0] & LMP_HOST_LE_BREDR)
+#define lmp_host_le_capable(dev)   !!((dev)->host_features[0] & LMP_HOST_LE)
+#define lmp_host_le_br_capable(dev) !!((dev)->host_features[0] & LMP_HOST_LE_BREDR)
 
 /* ----- HCI protocols ----- */
 #define HCI_PROTO_DEFER             0x01

commit 20714bfef84d3e690c9c6f8e9cd46543b5ae1eed
Author: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Wed Nov 21 10:51:12 2012 +0100

    Bluetooth: Implement deferred sco socket setup
    
    In order to authenticate and configure an incoming SCO connection, the
    BT_DEFER_SETUP option was added. This option is intended to defer reply
    to Connect Request on SCO sockets.
    When a connection is requested, the listening socket is unblocked but
    the effective connection setup happens only on first recv. Any send
    between accept and recv fails with -ENOTCONN.
    
    Signed-off-by: Frédéric Dalleau <frederic.dalleau@linux.intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ef5b85dac3f7..76891a914e75 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -376,7 +376,7 @@ extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
 extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb,
 			      u16 flags);
 
-extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);
 extern void sco_connect_cfm(struct hci_conn *hcon, __u8 status);
 extern void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
 extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
@@ -577,6 +577,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
+void hci_conn_accept(struct hci_conn *conn, int mask);
 
 struct hci_chan *hci_chan_create(struct hci_conn *conn);
 void hci_chan_del(struct hci_chan *chan);
@@ -779,8 +780,10 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_host_le_br_capable(dev) ((dev)->host_features[0] & LMP_HOST_LE_BREDR)
 
 /* ----- HCI protocols ----- */
+#define HCI_PROTO_DEFER             0x01
+
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								__u8 type)
+					__u8 type, __u8 *flags)
 {
 	switch (type) {
 	case ACL_LINK:
@@ -788,7 +791,7 @@ static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
 
 	case SCO_LINK:
 	case ESCO_LINK:
-		return sco_connect_ind(hdev, bdaddr);
+		return sco_connect_ind(hdev, bdaddr, flags);
 
 	default:
 		BT_ERR("unknown link type %d", type);

commit 3f0f524bafcd2025c12e215f13207c7be0a13bf9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Nov 8 01:23:00 2012 +0100

    Bluetooth: Add support for setting LE advertising data
    
    This patch adds support for setting basing LE advertising data. The
    three elements supported for now are the advertising flags, the TX power
    and the friendly name.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ce6dbeb6dfb6..ef5b85dac3f7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -279,6 +279,8 @@ struct hci_dev {
 	struct le_scan_params	le_scan_params;
 
 	__s8			adv_tx_power;
+	__u8			adv_data[HCI_MAX_AD_LENGTH];
+	__u8			adv_data_len;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
@@ -734,6 +736,8 @@ int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
 								u8 *randomizer);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
+int hci_update_ad(struct hci_dev *hdev);
+
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);

commit 0c0afedf55ff409be9db0b0aeeaa1c6fe0f3cd3c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Nov 1 13:27:26 2012 +0200

    Bluetooth: Fix parameter order of hci_get_route
    
    The actual parameter order of hci_get_route is (dst, src) and not (src,
    dst). All current callers use the right order but the header file shows
    the parameters in the wrong order.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b3490c634db7..ce6dbeb6dfb6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -685,7 +685,7 @@ static inline uint8_t __hci_num_ctrl(void)
 }
 
 struct hci_dev *hci_dev_get(int index);
-struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
+struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src);
 
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);

commit 6b4b73ee75bd65c4a47b1a323cb7c5180a6d2ea7
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Oct 25 00:09:52 2012 +0300

    Bluetooth: Fix sending unnecessary HCI_Write_SSP_Mode command
    
    This patch fixes sending an unnecessary HCI_Write_SSP_Mode command if
    the command has already been sent as part of the default HCI init
    sequence.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6642b3c91d33..b3490c634db7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -770,6 +770,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_ext_feat_capable(dev)  ((dev)->features[7] & LMP_EXTFEATURES)
 
 /* ----- Extended LMP capabilities ----- */
+#define lmp_host_ssp_capable(dev)  ((dev)->host_features[0] & LMP_HOST_SSP)
 #define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
 #define lmp_host_le_br_capable(dev) ((dev)->host_features[0] & LMP_HOST_LE_BREDR)
 

commit 761f09e4d6d2bfe4a517d14ca28aec041c8a7415
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 24 21:12:00 2012 +0300

    Bluetooth: Add missing feature test macros
    
    This patch adds missing feature test macros needed for various use cases
    and also sorts the macros according to the feature bit location in the
    feature mask (for easy lookup).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c885e545e651..6642b3c91d33 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -750,18 +750,28 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->dev.parent = (pdev))
 
 /* ----- LMP capabilities ----- */
-#define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)
 #define lmp_encrypt_capable(dev)   ((dev)->features[0] & LMP_ENCRYPT)
+#define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)
+#define lmp_hold_capable(dev)      ((dev)->features[0] & LMP_HOLD)
 #define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
-#define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
+#define lmp_park_capable(dev)      ((dev)->features[1] & LMP_PARK)
+#define lmp_inq_rssi_capable(dev)  ((dev)->features[3] & LMP_RSSI_INQ)
 #define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
+#define lmp_bredr_capable(dev)     (!((dev)->features[4] & LMP_NO_BREDR))
+#define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
+#define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
+#define lmp_pause_enc_capable(dev) ((dev)->features[5] & LMP_PAUSE_ENC)
+#define lmp_ext_inq_capable(dev)   ((dev)->features[6] & LMP_EXT_INQ)
+#define lmp_le_br_capable(dev)     ((dev)->features[6] & LMP_SIMUL_LE_BR)
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
-#define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
-#define lmp_bredr_capable(dev)     (!((dev)->features[4] & LMP_NO_BREDR))
+#define lmp_lsto_capable(dev)      ((dev)->features[7] & LMP_LSTO)
+#define lmp_inq_tx_pwr_capable(dev) ((dev)->features[7] & LMP_INQ_TX_PWR)
+#define lmp_ext_feat_capable(dev)  ((dev)->features[7] & LMP_EXTFEATURES)
 
 /* ----- Extended LMP capabilities ----- */
 #define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
+#define lmp_host_le_br_capable(dev) ((dev)->host_features[0] & LMP_HOST_LE_BREDR)
 
 /* ----- HCI protocols ----- */
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit 711584ea4c8ce47045c8ed4da3d6c6fdf513db92
Author: Denis Kirjanov <kirjanov@gmail.com>
Date:   Mon Oct 22 17:22:01 2012 +0400

    Bluetooth:Replace list_for_each with list_for_each_entry() helper
    
    Replace list_for_each with list_for_each_entry() helper
    
    Signed-off-by: Denis Kirjanov <kirjanov@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5ab80b7e8369..c885e545e651 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -880,7 +880,7 @@ struct hci_cb {
 
 static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 {
-	struct list_head *p;
+	struct hci_cb *cb;
 	__u8 encrypt;
 
 	hci_proto_auth_cfm(conn, status);
@@ -891,8 +891,7 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
 	read_lock(&hci_cb_list_lock);
-	list_for_each(p, &hci_cb_list) {
-		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
@@ -902,7 +901,7 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 								__u8 encrypt)
 {
-	struct list_head *p;
+	struct hci_cb *cb;
 
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;
@@ -913,8 +912,7 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
 	read_lock(&hci_cb_list_lock);
-	list_for_each(p, &hci_cb_list) {
-		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
@@ -923,11 +921,10 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 {
-	struct list_head *p;
+	struct hci_cb *cb;
 
 	read_lock(&hci_cb_list_lock);
-	list_for_each(p, &hci_cb_list) {
-		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->key_change_cfm)
 			cb->key_change_cfm(conn, status);
 	}
@@ -937,11 +934,10 @@ static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
 								__u8 role)
 {
-	struct list_head *p;
+	struct hci_cb *cb;
 
 	read_lock(&hci_cb_list_lock);
-	list_for_each(p, &hci_cb_list) {
-		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+	list_for_each_entry(cb, &hci_cb_list, list) {
 		if (cb->role_switch_cfm)
 			cb->role_switch_cfm(conn, status, role);
 	}

commit 8fa19098ebc700f14b0f8d0fb957e7748e14c44b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Oct 19 20:57:49 2012 +0300

    Bluetooth: Read adversiting channel TX power during init sequence
    
    This patch adds the reading of the LE advertising channel TX power to
    the HCI init sequence of LE-capable controllers. This data will be used
    e.g. for inclusion in the advertising data packets when advertising is
    enabled.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 00abc5246cbf..5ab80b7e8369 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -278,6 +278,8 @@ struct hci_dev {
 	struct work_struct	le_scan;
 	struct le_scan_params	le_scan_params;
 
+	__s8			adv_tx_power;
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);

commit 168df8e57e7c1afce3f86a86ae106f82ff7c18d8
Author: Mat Martineau <mathewm@codeaurora.org>
Date:   Tue Oct 23 15:24:13 2012 -0700

    Bluetooth: Add state to hci_chan
    
    On an AMP controller, hci_chan maps to a logical link.  When a channel
    is being moved, the logical link may or may not be connected already.
    The hci_chan->state is used to determine the existance of a useable
    logical link so the link can be either used or requested.
    
    Signed-off-by: Mat Martineau <mathewm@codeaurora.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Acked-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9fe8e2dec870..00abc5246cbf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -355,6 +355,7 @@ struct hci_chan {
 	struct hci_conn *conn;
 	struct sk_buff_head data_q;
 	unsigned int	sent;
+	__u8		state;
 };
 
 extern struct list_head hci_dev_list;

commit 716e4ab5c966327988e21e6137c14e457cfca690
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 10 17:38:31 2012 +0300

    Bluetooth: AMP: Hanlde AMP_LINK case in conn_put
    
    Handle AMP link when setting up disconnect timeout.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d5ed054d77cf..9fe8e2dec870 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -605,7 +605,10 @@ static inline void hci_conn_put(struct hci_conn *conn)
 
 	if (atomic_dec_and_test(&conn->refcnt)) {
 		unsigned long timeo;
-		if (conn->type == ACL_LINK || conn->type == LE_LINK) {
+
+		switch (conn->type) {
+		case ACL_LINK:
+		case LE_LINK:
 			del_timer(&conn->idle_timer);
 			if (conn->state == BT_CONNECTED) {
 				timeo = conn->disc_timeout;
@@ -614,12 +617,20 @@ static inline void hci_conn_put(struct hci_conn *conn)
 			} else {
 				timeo = msecs_to_jiffies(10);
 			}
-		} else {
+			break;
+
+		case AMP_LINK:
+			timeo = conn->disc_timeout;
+			break;
+
+		default:
 			timeo = msecs_to_jiffies(10);
+			break;
 		}
+
 		cancel_delayed_work(&conn->disc_work);
 		queue_delayed_work(conn->hdev->workqueue,
-					&conn->disc_work, timeo);
+				   &conn->disc_work, timeo);
 	}
 }
 

commit bd1eb66ba4eee21de3be24212b135f57101ad930
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 10 17:38:30 2012 +0300

    Bluetooth: AMP: Handle AMP_LINK connection
    
    AMP_LINK represents physical link between AMP controllers.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b697ef342020..d5ed054d77cf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -73,6 +73,7 @@ struct discovery_state {
 struct hci_conn_hash {
 	struct list_head list;
 	unsigned int     acl_num;
+	unsigned int     amp_num;
 	unsigned int     sco_num;
 	unsigned int     le_num;
 };
@@ -449,6 +450,9 @@ static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 	case ACL_LINK:
 		h->acl_num++;
 		break;
+	case AMP_LINK:
+		h->amp_num++;
+		break;
 	case LE_LINK:
 		h->le_num++;
 		break;
@@ -470,6 +474,9 @@ static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 	case ACL_LINK:
 		h->acl_num--;
 		break;
+	case AMP_LINK:
+		h->amp_num--;
+		break;
 	case LE_LINK:
 		h->le_num--;
 		break;
@@ -486,6 +493,8 @@ static inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)
 	switch (type) {
 	case ACL_LINK:
 		return h->acl_num;
+	case AMP_LINK:
+		return h->amp_num;
 	case LE_LINK:
 		return h->le_num;
 	case SCO_LINK:
@@ -801,6 +810,10 @@ static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 		sco_disconn_cfm(conn, reason);
 		break;
 
+	/* L2CAP would be handled for BREDR chan */
+	case AMP_LINK:
+		break;
+
 	default:
 		BT_ERR("unknown link type %d", conn->type);
 		break;

commit 42c4e53e7ac3d4069105e852d1ee24e6ee9e57b8
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 10 17:38:28 2012 +0300

    Bluetooth: AMP: Add handle to hci_chan structure
    
    hci_chan will be identified by handle used in logical link creation
    process. This handle is used in AMP ACL-U packet handle field.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dfa108c4abec..b697ef342020 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -350,7 +350,7 @@ struct hci_conn {
 
 struct hci_chan {
 	struct list_head list;
-
+	__u16 handle;
 	struct hci_conn *conn;
 	struct sk_buff_head data_q;
 	unsigned int	sent;
@@ -567,6 +567,7 @@ void hci_conn_check_pending(struct hci_dev *hdev);
 struct hci_chan *hci_chan_create(struct hci_conn *conn);
 void hci_chan_del(struct hci_chan *chan);
 void hci_chan_list_flush(struct hci_conn *conn);
+struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type);

commit 53502d69be49e3dd5bc95ab0f2deeaea260bd617
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 10 17:38:27 2012 +0300

    Bluetooth: AMP: Handle AMP_LINK timeout
    
    When AMP_LINK timeouts execute HCI_OP_DISCONN_PHY_LINK as analog to
    HCI_OP_DISCONNECT for ACL_LINK.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 90ae4f0a4fdc..dfa108c4abec 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -285,6 +285,8 @@ struct hci_dev {
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
 };
 
+#define HCI_PHY_HANDLE(handle)	(handle & 0xff)
+
 struct hci_conn {
 	struct list_head list;
 

commit dfee1ebc0e363ff1dc233c4a5246bf3e7f5c5ca6
Author: Rami Rosen <ramirose@gmail.com>
Date:   Mon Oct 1 19:37:31 2012 +0200

    Bluetooth: remove unused member of hci_dev.
    
    This patch removes core_data member from hci_dev struct as it is unused.
    
    Signed-off-by: Rami Rosen <ramirose@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ea1f9340324d..90ae4f0a4fdc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -262,8 +262,6 @@ struct hci_dev {
 
 	struct sk_buff_head	driver_init;
 
-	void			*core_data;
-
 	atomic_t		promisc;
 
 	struct dentry		*debugfs;

commit 93c284ee901f7d7bdd09087e92abefb7496c3777
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Sep 27 17:26:20 2012 +0300

    Bluetooth: AMP: Write remote AMP Assoc
    
    When receiving HCI Command Status after HCI Create Physical Link
    execute HCI Write Remote AMP Assoc command to AMP controller.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 464eae340419..ea1f9340324d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -127,6 +127,8 @@ struct le_scan_params {
 struct amp_assoc {
 	__u16	len;
 	__u16	offset;
+	__u16	rem_len;
+	__u16	len_so_far;
 	__u8	data[HCI_MAX_AMP_ASSOC_SIZE];
 };
 

commit 3161ae1c72f03b021bc67504c13025626c26d30c
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Sep 27 17:26:11 2012 +0300

    Bluetooth: AMP: Physical link struct and helpers
    
    Define physical link structures. Physical links are represented by
    hci_conn structure. For BR/EDR we use type ACL_LINK and for AMP
    we use AMP_LINK.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b1c7d0607244..464eae340419 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -318,6 +318,7 @@ struct hci_conn {
 
 	__u8		remote_cap;
 	__u8		remote_auth;
+	__u8		remote_id;
 	bool		flush_key;
 
 	unsigned int	sent;

commit 903e45411099ae8292f5ce637ad0c72f6fef61db
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Sep 27 17:26:09 2012 +0300

    Bluetooth: AMP: Use HCI cmd to Read Loc AMP Assoc
    
    When receiving A2MP Get AMP Assoc Request execute Read Local AMP Assoc
    HCI command to AMP controller. If the AMP Assoc data is larger than it
    can fit to HCI event only fragment is read. When all fragments are read
    send A2MP Get AMP Assoc Response.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e7d454609881..b1c7d0607244 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -124,6 +124,12 @@ struct le_scan_params {
 
 #define HCI_MAX_SHORT_NAME_LENGTH	10
 
+struct amp_assoc {
+	__u16	len;
+	__u16	offset;
+	__u8	data[HCI_MAX_AMP_ASSOC_SIZE];
+};
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -177,6 +183,8 @@ struct hci_dev {
 	__u32		amp_max_flush_to;
 	__u32		amp_be_flush_to;
 
+	struct amp_assoc	loc_assoc;
+
 	__u8		flow_ctl_mode;
 
 	unsigned int	auto_accept_delay;

commit 92a25256f142d55e25f9959441cea6ddeabae57e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Sep 6 18:39:26 2012 +0300

    Bluetooth: mgmt: Implement support for passkey notification
    
    This patch adds support for Secure Simple Pairing with devices that have
    KeyboardOnly as their IO capability. Such devices will cause a passkey
    notification on our side and optionally also keypress notifications.
    Without this patch some keyboards cannot be paired using the mgmt
    interface.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Cc: stable@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6a3337e9c42c..e7d454609881 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -303,6 +303,8 @@ struct hci_conn {
 	__u8		pin_length;
 	__u8		enc_key_size;
 	__u8		io_capability;
+	__u32		passkey_notify;
+	__u8		passkey_entered;
 	__u16		disc_timeout;
 	unsigned long	flags;
 
@@ -1022,6 +1024,9 @@ int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 link_type, u8 addr_type, u8 status);
 int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 					 u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_notify(struct hci_dev *hdev, bdaddr_t *bdaddr,
+			     u8 link_type, u8 addr_type, u32 passkey,
+			     u8 entered);
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 		     u8 addr_type, u8 status);
 int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);

commit 376261ae3627b03574994496f70f95d5538795d5
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Sep 6 15:05:45 2012 +0300

    Bluetooth: debug: Print refcnt for hci_dev
    
    Add debug output for HCI kref.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4704ca4b8767..6a3337e9c42c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -603,11 +603,17 @@ static inline void hci_conn_put(struct hci_conn *conn)
 /* ----- HCI Devices ----- */
 static inline void hci_dev_put(struct hci_dev *d)
 {
+	BT_DBG("%s orig refcnt %d", d->name,
+	       atomic_read(&d->dev.kobj.kref.refcount));
+
 	put_device(&d->dev);
 }
 
 static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 {
+	BT_DBG("%s orig refcnt %d", d->name,
+	       atomic_read(&d->dev.kobj.kref.refcount));
+
 	get_device(&d->dev);
 	return d;
 }

commit 9472007c62ecc8f21daa2e1e252bf73b67e535fc
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Sep 6 15:05:43 2012 +0300

    Bluetooth: trivial: Make hci_chan_del return void
    
    Return code is not needed in hci_chan_del
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fa807a3fd23b..4704ca4b8767 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -552,7 +552,7 @@ void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
 struct hci_chan *hci_chan_create(struct hci_conn *conn);
-int hci_chan_del(struct hci_chan *chan);
+void hci_chan_del(struct hci_chan *chan);
 void hci_chan_list_flush(struct hci_conn *conn);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,

commit 6b536b5e5e1da32f3ba1e3f42c7bf2f80d37dc6b
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Aug 31 16:39:28 2012 +0300

    Bluetooth: Remove unneeded zero init
    
    hdev is allocated with kzalloc so zero initialization is not needed.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1bbc1091748c..fa807a3fd23b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -428,15 +428,6 @@ static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
 	       test_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 }
 
-static inline void hci_conn_hash_init(struct hci_dev *hdev)
-{
-	struct hci_conn_hash *h = &hdev->conn_hash;
-	INIT_LIST_HEAD(&h->list);
-	h->acl_num = 0;
-	h->sco_num = 0;
-	h->le_num = 0;
-}
-
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;

commit f0d6a0ea330617454032d6e2ed48759858a44427
Author: Mikel Astiz <mikel.astiz@bmw-carit.de>
Date:   Thu Aug 9 09:52:30 2012 +0200

    Bluetooth: mgmt: Add device disconnect reason
    
    MGMT_EV_DEVICE_DISCONNECTED will now expose the disconnection reason to
    userland, distinguishing four possible values:
    
            0x00    Reason not known or unspecified
            0x01    Connection timeout
            0x02    Connection terminated by local host
            0x03    Connection terminated by remote host
    
    Note that the local/remote distinction just determines which side
    terminated the low-level connection, regardless of the disconnection of
    the higher-level profiles.
    
    This can sometimes be misleading and thus must be used with care. For
    example, some hardware combinations would report a locally initiated
    disconnection even if the user turned Bluetooth off in the remote side.
    
    Signed-off-by: Mikel Astiz <mikel.astiz@bmw-carit.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7267dafd7159..1bbc1091748c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1002,7 +1002,7 @@ int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
 			  u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
-			     u8 link_type, u8 addr_type);
+			     u8 link_type, u8 addr_type, u8 reason);
 int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			   u8 link_type, u8 addr_type, u8 status);
 int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,

commit 57f5d0d1d9f8e59819cb0ab4b707364c54b5b2d1
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:32:54 2012 -0300

    Bluetooth: Remove some functions from being exported
    
    Some connection related functions are only used inside hci_conn.c
    so no need to have them exported.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 41d943926d2c..7267dafd7159 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -551,9 +551,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 	return NULL;
 }
 
-void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
-void hci_add_sco(struct hci_conn *conn, __u16 handle);
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 void hci_sco_setup(struct hci_conn *conn, __u8 status);
 

commit 9e66463127ff7238020c3c4e7f84dfbc23e5c2b5
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Tue Jul 24 16:06:15 2012 +0300

    Bluetooth: Make connect / disconnect cfm functions return void
    
    Return values are never used because callers hci_proto_connect_cfm
    and hci_proto_disconn_cfm return void.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 03b8b6526400..41d943926d2c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -350,16 +350,16 @@ extern rwlock_t hci_cb_list_lock;
 
 /* ----- HCI interface to upper protocols ----- */
 extern int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
-extern int l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
+extern void l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
 extern int l2cap_disconn_ind(struct hci_conn *hcon);
-extern int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
+extern void l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
 extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
 extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb,
 			      u16 flags);
 
 extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
-extern int sco_connect_cfm(struct hci_conn *hcon, __u8 status);
-extern int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
+extern void sco_connect_cfm(struct hci_conn *hcon, __u8 status);
+extern void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
 extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 /* ----- Inquiry cache ----- */

commit 71becf0cea91380200ab9460e5126aeff5d7420b
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Jul 19 17:03:42 2012 +0300

    Bluetooth: debug: Fix printing refcnt for hci_conn
    
    Use the same style for refcnt printing through all Bluetooth code
    taking the reference the l2cap_chan refcnt printing.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5c7a5f819fcf..03b8b6526400 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -581,8 +581,7 @@ void hci_conn_put_device(struct hci_conn *conn);
 
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
-	BT_DBG("hcon %p refcnt %d -> %d", conn, atomic_read(&conn->refcnt),
-	       atomic_read(&conn->refcnt) + 1);
+	BT_DBG("hcon %p orig refcnt %d", conn, atomic_read(&conn->refcnt));
 
 	atomic_inc(&conn->refcnt);
 	cancel_delayed_work(&conn->disc_work);
@@ -590,8 +589,7 @@ static inline void hci_conn_hold(struct hci_conn *conn)
 
 static inline void hci_conn_put(struct hci_conn *conn)
 {
-	BT_DBG("hcon %p refcnt %d -> %d", conn, atomic_read(&conn->refcnt),
-	       atomic_read(&conn->refcnt) - 1);
+	BT_DBG("hcon %p orig refcnt %d", conn, atomic_read(&conn->refcnt));
 
 	if (atomic_dec_and_test(&conn->refcnt)) {
 		unsigned long timeo;

commit bb4b2a9ae38ef3bac69627f35e4f916752631fd1
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Jul 19 17:03:40 2012 +0300

    Bluetooth: mgmt: Managing only BR/EDR HCI controllers
    
    Add check that HCI controller is BR/EDR. AMP controller shall not be
    managed by mgmt interface and consequently user space.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 41b26648e79e..5c7a5f819fcf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1050,7 +1050,7 @@ int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_interleaved_discovery(struct hci_dev *hdev);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-
+bool mgmt_valid_hdev(struct hci_dev *hdev);
 int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 
 /* HCI info for socket */

commit 3f1732462c0e45ac9b0c09035751d7b2c1b89cc0
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jul 19 11:46:13 2012 -0300

    Bluetooth: Remove missing code
    
    This patch removes the struct adv_entry since it is not used anymore.
    This struct should have been removed in commit 479453d (Bluetooth:
    Remove advertising cache).
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 475b8c04ba52..41b26648e79e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -115,12 +115,6 @@ struct oob_data {
 	u8 randomizer[16];
 };
 
-struct adv_entry {
-	struct list_head list;
-	bdaddr_t bdaddr;
-	u8 bdaddr_type;
-};
-
 struct le_scan_params {
 	u8 type;
 	u16 interval;

commit 38b3fef1730319e2730af3fc9f73698e3a9aeb4a
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Jun 15 11:50:28 2012 +0300

    Bluetooth: Improve debugging messages for hci_conn
    
    Improve debugging of hci_conn objects by: adding print to hci_conn
    refcounting, adding object spcifier when missing, change conn to hcon
    since conn is heavily used for l2cap_conn objects and this is misleading.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 75766b7f0dc7..475b8c04ba52 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -587,12 +587,18 @@ void hci_conn_put_device(struct hci_conn *conn);
 
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
+	BT_DBG("hcon %p refcnt %d -> %d", conn, atomic_read(&conn->refcnt),
+	       atomic_read(&conn->refcnt) + 1);
+
 	atomic_inc(&conn->refcnt);
 	cancel_delayed_work(&conn->disc_work);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
 {
+	BT_DBG("hcon %p refcnt %d -> %d", conn, atomic_read(&conn->refcnt),
+	       atomic_read(&conn->refcnt) - 1);
+
 	if (atomic_dec_and_test(&conn->refcnt)) {
 		unsigned long timeo;
 		if (conn->type == ACL_LINK || conn->type == LE_LINK) {

commit 5f246e890502fed387e0f959e2224ea680c03423
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Mon Jun 11 11:13:07 2012 +0300

    Bluetooth: Update HCI timeouts constants to use msecs_to_jiffies
    
    The HCI constants are always used in form of jiffies. So just
    include the conversion from msecs in the define itself. This has the
    advantage of making the code where the timeout is used more readable
    and avoiding unnecessary conversions.
    
    The patch is similar to commit ba13ccd9 doing the same job for L2CAP
    
    Reported-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 20fd57367ddc..75766b7f0dc7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -598,7 +598,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 		if (conn->type == ACL_LINK || conn->type == LE_LINK) {
 			del_timer(&conn->idle_timer);
 			if (conn->state == BT_CONNECTED) {
-				timeo = msecs_to_jiffies(conn->disc_timeout);
+				timeo = conn->disc_timeout;
 				if (!conn->out)
 					timeo *= 2;
 			} else {

commit 8598d064cbf22b2d84c7cd8a9fcb97138baffe3f
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Tue May 29 13:59:09 2012 +0300

    Bluetooth: A2MP: Process A2MP Discover Request
    
    Adds helper functions to count HCI devs and process A2MP Discover
    Request, code makes sure that first controller in the list is
    BREDR one. Trace is shown below:
    
    ...
    > ACL data: handle 11 flags 0x02 dlen 16
        A2MP: Discover req: mtu/mps 670 mask: 0x0000
    < ACL data: handle 11 flags 0x00 dlen 22
        A2MP: Discover rsp: mtu/mps 670 mask: 0x0000
          Controller list:
            id 0 type 0 (BR-EDR) status 0x01 (Bluetooth only)
            id 1 type 1 (802.11 AMP) status 0x01 (Bluetooth only)
    ...
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6e64b76e30aa..20fd57367ddc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -641,6 +641,19 @@ static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
 	dev_set_drvdata(&hdev->dev, data);
 }
 
+/* hci_dev_list shall be locked */
+static inline uint8_t __hci_num_ctrl(void)
+{
+	uint8_t count = 0;
+	struct list_head *p;
+
+	list_for_each(p, &hci_dev_list) {
+		count++;
+	}
+
+	return count;
+}
+
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
 

commit 9740e49d17e55f3832661fd99a8e0a17e921a82e
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Tue May 29 13:59:02 2012 +0300

    Bluetooth: A2MP: AMP Manager basic functions
    
    Define AMP Manager and some basic functions.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d584a47d1c86..6e64b76e30aa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -332,6 +332,7 @@ struct hci_conn {
 	void		*l2cap_data;
 	void		*sco_data;
 	void		*smp_conn;
+	struct amp_mgr	*amp_mgr;
 
 	struct hci_conn	*link;
 

commit 8c520a59927a5600973782505dbb750d985057c4
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed May 23 04:04:22 2012 -0300

    Bluetooth: Remove unnecessary headers include
    
    Most of the include were unnecessary or already included by some other
    header.
    Replace module.h by export.h where possible.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a8ba50d7a81e..d584a47d1c86 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -25,7 +25,6 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
-#include <linux/interrupt.h>
 #include <net/bluetooth/hci.h>
 
 /* HCI priority */

commit c3c7ea65941a0b7a4f1b9655e7aaaab6ce1874d2
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed May 23 04:04:20 2012 -0300

    Bluetooth: Fix coding style in include/net/bluetooth
    
    Fix all warning and errors reported by checkpatch but license trailing
    whitespace and bdaddr_t definition.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6c658fc7ac93..a8ba50d7a81e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -65,7 +65,7 @@ struct discovery_state {
 		DISCOVERY_RESOLVING,
 		DISCOVERY_STOPPING,
 	} state;
-	struct list_head	all;		/* All devices found during inquiry */
+	struct list_head	all;	/* All devices found during inquiry */
 	struct list_head	unknown;	/* Name state not known */
 	struct list_head	resolve;	/* Name needs to be resolved */
 	__u32			timestamp;
@@ -360,7 +360,8 @@ extern int l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
 extern int l2cap_disconn_ind(struct hci_conn *hcon);
 extern int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
 extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
-extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
+extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb,
+			      u16 flags);
 
 extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 extern int sco_connect_cfm(struct hci_conn *hcon, __u8 status);
@@ -429,8 +430,8 @@ enum {
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	return (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&
-				test_bit(HCI_CONN_SSP_ENABLED, &conn->flags));
+	return test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&
+	       test_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 }
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
@@ -661,7 +662,8 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
-struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
+struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
+					 bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
 int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);

commit 9b3b44604ac8e06d299718c5d0fa0b91b675ae0b
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed May 23 11:31:20 2012 +0300

    Bluetooth: Use defined link key size
    
    Remove magic number with defined link key size.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9fc7728f94e4..6c658fc7ac93 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -105,7 +105,7 @@ struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 type;
-	u8 val[16];
+	u8 val[HCI_LINK_KEY_SIZE];
 	u8 pin_len;
 };
 

commit 9d939d948469b49912a76e789f7d4059eb1f8bc7
Author: Vishal Agarwal <vishal.agarwal@stericsson.com>
Date:   Thu Apr 26 19:19:56 2012 +0530

    Bluetooth: Fix EIR data generation for mgmt_device_found
    
    The mgmt_device_found function expects to receive only the significant
    part of the EIR data so it needs to be removed before calling the
    function. This patch adds a new eir_get_length() helper function to
    calculate the length of the significant part.
    
    Signed-off-by: Vishal Agarwal <vishal.agarwal@stericsson.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b60d2c844eba..9fc7728f94e4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -926,6 +926,23 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 	return false;
 }
 
+static inline size_t eir_get_length(u8 *eir, size_t eir_len)
+{
+	size_t parsed = 0;
+
+	while (parsed < eir_len) {
+		u8 field_len = eir[0];
+
+		if (field_len == 0)
+			return parsed;
+
+		parsed += field_len + 1;
+		eir += field_len + 1;
+	}
+
+	return eir_len;
+}
+
 static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
 				  u8 data_len)
 {

commit 2ee8ce35b1e8ba2523fa4c45fa19f9dbe321f008
Author: Syam Sidhardhan <s.syam@samsung.com>
Date:   Fri Apr 20 22:12:31 2012 +0530

    Bluetooth: Remove unused hci_le_ltk_neg_reply()
    
    No one is using hci_le_ltk_neg_reply() in bluetooth subsystem.
    
    Signed-off-by: Syam Sidhardhan <s.syam@samsung.com>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e3547ea83619..b60d2c844eba 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1055,8 +1055,6 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
-void hci_le_ltk_neg_reply(struct hci_conn *conn);
-
 int hci_do_inquiry(struct hci_dev *hdev, u8 length);
 int hci_cancel_inquiry(struct hci_dev *hdev);
 int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,

commit e10b9969f217c948c5523045f44eba4d3a758ff0
Author: Syam Sidhardhan <s.syam@samsung.com>
Date:   Thu Apr 12 20:33:17 2012 +0530

    Bluetooth: Remove unused hci_le_ltk_reply()
    
    In this API, we were using sizeof operator for an array
    given as function argument, which is invalid.
    However this API is not used anywhere.
    
    Signed-off-by: Syam Sidhardhan <s.syam@samsung.com>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d1e744f3b9be..e3547ea83619 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1055,7 +1055,6 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 							__u8 ltk[16]);
-void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
 int hci_do_inquiry(struct hci_dev *hdev, u8 length);

commit 479453d5fe3a5b911b7f56474764988100f9f650
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 24 21:02:56 2012 -0300

    Bluetooth: Remove advertising cache
    
    User-space pass the remote device address type to kernel through
    struct sockaddr_l2 what makes the advertising useless. This patch
    removes all advertising cache code.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e69a9eed082c..d1e744f3b9be 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -255,9 +255,6 @@ struct hci_dev {
 
 	struct list_head	remote_oob_data;
 
-	struct list_head	adv_entries;
-	struct delayed_work	adv_work;
-
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
@@ -692,12 +689,6 @@ int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
 								u8 *randomizer);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
-#define ADV_CLEAR_TIMEOUT (3*60*HZ) /* Three minutes */
-int hci_adv_entries_clear(struct hci_dev *hdev);
-struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_adv_entry(struct hci_dev *hdev,
-					struct hci_ev_le_advertising_info *ev);
-
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);

commit b12f62cfd9f46ac70013ce661640174b489efd39
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 24 21:02:54 2012 -0300

    Bluetooth: Add dst_type parameter to hci_connect
    
    This patch adds the dst_type parameter to hci_connect function.
    Instead of searching the address type in advertising cache, we
    use the dst_type parameter to establish LE connections.
    
    The dst_type is ignored for BR/EDR connection establishment.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7e7fe3f221fb..e69a9eed082c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -575,7 +575,7 @@ int hci_chan_del(struct hci_chan *chan);
 void hci_chan_list_flush(struct hci_conn *conn);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
-						__u8 sec_level, __u8 auth_type);
+			     __u8 dst_type, __u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);

commit 31f7956c6648fbae9c9550e91d1c348d28276309
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 24 21:02:53 2012 -0300

    Bluetooth: Move bdaddr_to_le to hci_core
    
    This patch moves the helper function bdaddr_to_le to hci_core, so it
    can be used in mgmt.c and hci_conn.c.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6777432ca61e..7e7fe3f221fb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1073,4 +1073,6 @@ int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
 		int timeout);
 int hci_cancel_le_scan(struct hci_dev *hdev);
 
+u8 bdaddr_to_le(u8 bdaddr_type);
+
 #endif /* __HCI_CORE_H */

commit 591f47f31ba4e89fc0cce2ad90da80945ce8bf94
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 24 21:02:49 2012 -0300

    Bluetooth: Move address type macros to bluetooth.h
    
    This patch moves address type macros to bluetooth.h since they will be
    used by management interface and Bluetooth socket interface. It also
    replaces the macro prefix MGMT_ADDR_ by BDADDR_.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ef6e6541aa2a..6777432ca61e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -963,16 +963,12 @@ void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_sock_dev_event(struct hci_dev *hdev, int event);
 
 /* Management interface */
-#define MGMT_ADDR_BREDR			0x00
-#define MGMT_ADDR_LE_PUBLIC		0x01
-#define MGMT_ADDR_LE_RANDOM		0x02
-
-#define DISCOV_TYPE_BREDR		(BIT(MGMT_ADDR_BREDR))
-#define DISCOV_TYPE_LE			(BIT(MGMT_ADDR_LE_PUBLIC) | \
-						BIT(MGMT_ADDR_LE_RANDOM))
-#define DISCOV_TYPE_INTERLEAVED		(BIT(MGMT_ADDR_BREDR) | \
-						BIT(MGMT_ADDR_LE_PUBLIC) | \
-						BIT(MGMT_ADDR_LE_RANDOM))
+#define DISCOV_TYPE_BREDR		(BIT(BDADDR_BREDR))
+#define DISCOV_TYPE_LE			(BIT(BDADDR_LE_PUBLIC) | \
+					 BIT(BDADDR_LE_RANDOM))
+#define DISCOV_TYPE_INTERLEAVED		(BIT(BDADDR_BREDR) | \
+					 BIT(BDADDR_LE_PUBLIC) | \
+					 BIT(BDADDR_LE_RANDOM))
 
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(struct hci_dev *hdev);

commit 270ca16bc7ff575a5900aec2475fa7f8742f7337
Author: Syam Sidhardhan <s.syam@samsung.com>
Date:   Thu Apr 12 20:33:19 2012 +0530

    Bluetooth: remove header declared but not defined
    
    hci_del_off_timer() doesn't exist anymore.
    
    Signed-off-by: Syam Sidhardhan <s.syam@samsung.com>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index afdea9530d7b..ef6e6541aa2a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -698,8 +698,6 @@ struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_adv_entry(struct hci_dev *hdev,
 					struct hci_ev_le_advertising_info *ev);
 
-void hci_del_off_timer(struct hci_dev *hdev);
-
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);

commit 0ed09148fa61e01cd27c92933ba275ea8078b34d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 3 08:46:54 2012 -0300

    Bluetooth: Remove MGMT_ADDR_INVALID macro
    
    This patch removes the MGMT_ADDR_INVALID macro. If the address type
    isn't LE, we consider it is BR/EDR type.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f7cf928ab6ff..afdea9530d7b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -968,7 +968,6 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event);
 #define MGMT_ADDR_BREDR			0x00
 #define MGMT_ADDR_LE_PUBLIC		0x01
 #define MGMT_ADDR_LE_RANDOM		0x02
-#define MGMT_ADDR_INVALID		0xff
 
 #define DISCOV_TYPE_BREDR		(BIT(MGMT_ADDR_BREDR))
 #define DISCOV_TYPE_LE			(BIT(MGMT_ADDR_LE_PUBLIC) | \

commit 7dbfac1d720d3ea68e00e187bbd2f1147257528b
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Mar 15 16:52:07 2012 -0300

    Bluetooth: Add hci_cancel_le_scan() to hci_core
    
    This patch adds to hci_core the hci_cancel_le_scan function which
    should be used to cancel an ongoing LE scan.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c8e24a9b176c..f7cf928ab6ff 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1078,5 +1078,6 @@ int hci_do_inquiry(struct hci_dev *hdev, u8 length);
 int hci_cancel_inquiry(struct hci_dev *hdev);
 int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
 		int timeout);
+int hci_cancel_le_scan(struct hci_dev *hdev);
 
 #endif /* __HCI_CORE_H */

commit 2b9be137b70bef9ec7835d83e225d8b35ba9c7ae
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 11 19:32:12 2012 -0700

    Bluetooth: Handle EIR tags for Device ID
    
    The Device ID information can be provided via Extended Inquiry Data
    as well. If a valid source is present, then include it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ce09bf1592e2..c8e24a9b176c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -159,6 +159,10 @@ struct hci_dev {
 	__u16		voice_setting;
 	__u8		io_capability;
 	__s8		inq_tx_power;
+	__u16		devid_source;
+	__u16		devid_vendor;
+	__u16		devid_product;
+	__u16		devid_version;
 
 	__u16		pkt_type;
 	__u16		esco_type;

commit 91c4e9b1ac595f83681c9a9de691e0f30eeafb44
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Mar 11 19:27:21 2012 -0700

    Bluetooth: Add TX power tag to EIR data
    
    The Inquiry Response TX power tag should be added to the Extended
    Inquiry Data (EIR) as well.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c80a9684a144..ce09bf1592e2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -158,6 +158,7 @@ struct hci_dev {
 	__u16		lmp_subver;
 	__u16		voice_setting;
 	__u8		io_capability;
+	__s8		inq_tx_power;
 
 	__u16		pkt_type;
 	__u16		esco_type;

commit 6935e0f5181644201894f0b7fbe3d8910c18af05
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Fri Mar 9 15:53:42 2012 +0100

    Bluetooth: Remove redundant hdev->parent field
    
    We initialize the "struct device" in hci_alloc_dev() for a long time now
    so we can access hdev->dev.parent directly. Hence, we can drop the
    temporary field hdev->parent which is used in no other place than
    hci_add_sysfs().
    
    SET_HCIDEV_DEV() is never called after registering a device by the
    drivers so we do not overwrite internal device-state. Furthermore,
    hdev->dev is initialized to 0 by kzalloc() inside hci_alloc_dev() so the
    default behavior with dev.parent = NULL is kept.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0eec5dbaee0f..c80a9684a144 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -263,7 +263,6 @@ struct hci_dev {
 
 	struct dentry		*debugfs;
 
-	struct device		*parent;
 	struct device		dev;
 
 	struct rfkill		*rfkill;
@@ -709,7 +708,7 @@ void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);
 
-#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
+#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->dev.parent = (pdev))
 
 /* ----- LMP capabilities ----- */
 #define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)

commit 9a0066579270584108f1f2f97d98fe989d8117df
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Mar 9 12:12:12 2012 +0200

    Bluetooth: Correct type for ediv to __le16
    
    Correct type warnings reported by sparse to show that this
    functions takes ediv argument in __le16 format.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 53e8eb2f0a2e..0eec5dbaee0f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -673,8 +673,8 @@ int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
 int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
-		int new_key, u8 authenticated, u8 tk[16], u8 enc_size, u16 ediv,
-		u8 rand[8]);
+		int new_key, u8 authenticated, u8 tk[16], u8 enc_size,
+		__le16 ediv, u8 rand[8]);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit 7d69230c4381a5abc7286a8dfc893268e14e6ead
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Mar 9 11:46:49 2012 +0200

    Bluetooth: Correct type for hdev lmp_subver
    
    Keep lmp_subver in host byte order. We have following conversion
    in hci_cc_read_local_version:
    hdev->lmp_subver = __le16_to_cpu(rp->lmp_subver);
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index db1c5df45224..53e8eb2f0a2e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -155,7 +155,7 @@ struct hci_dev {
 	__u16		hci_rev;
 	__u8		lmp_ver;
 	__u16		manufacturer;
-	__le16		lmp_subver;
+	__u16		lmp_subver;
 	__u16		voice_setting;
 	__u8		io_capability;
 

commit 6ec5bcadc21e13ceba8c144e4731eccac01d04f7
Author: Vishal Agarwal <vishal.agarwal@stericsson.com>
Date:   Mon Apr 16 14:44:44 2012 +0530

    Bluetooth: Temporary keys should be retained during connection
    
    If a key is non persistent then it should not be used in future
    connections but it should be kept for current connection. And it
    should be removed when connecion is removed.
    
    Signed-off-by: Vishal Agarwal <vishal.agarwal@stericsson.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f8577c16fcf5..db1c5df45224 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -314,6 +314,7 @@ struct hci_conn {
 
 	__u8		remote_cap;
 	__u8		remote_auth;
+	bool		flush_key;
 
 	unsigned int	sent;
 

commit 745c0ce35f904aeff8e1ea325c259a14a00ff1b7
Author: Vishal Agarwal <vishal.agarwal@stericsson.com>
Date:   Fri Apr 13 17:43:22 2012 +0530

    Bluetooth: hci_persistent_key should return bool
    
    This patch changes the return type of function hci_persistent_key
    from int to bool because it makes more sense to return information
    whether a key is persistent or not as a bool.
    
    Signed-off-by: Vishal Agarwal <vishal.agarwal@stericsson.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6822d2595aff..f8577c16fcf5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -980,7 +980,7 @@ int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
-		      u8 persistent);
+		      bool persistent);
 int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
 			  u8 *dev_class);

commit 6c0c331e4c8ff6c0f7fa6cc5fd08d853d6c579c4
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Mar 26 14:21:42 2012 +0300

    Bluetooth: Check for minimum data length in eir_has_data_type()
    
    If passed 0 as data_length the (parsed < data_length - 1) test will be
    true and cause a buffer overflow. In practice we need at least two bytes
    for the element length and type so add a test for it to the very
    beginning of the function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 220d8e0a75fb..6822d2595aff 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -909,6 +909,9 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 {
 	size_t parsed = 0;
 
+	if (data_len < 2)
+		return false;
+
 	while (parsed < data_len - 1) {
 		u8 field_len = data[0];
 

commit 84d9d0716b2d5f4a27de4801bd2dbf7aff5e1c38
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Mar 26 14:21:41 2012 +0300

    Bluetooth: Don't increment twice in eir_has_data_type()
    
    The parsed variable is already incremented inside the for-loop so there
    no need to increment it again (not to mention that the code was
    incrementing it the wrong amount).
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8e103281a09b..220d8e0a75fb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -907,11 +907,10 @@ static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
 
 static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 {
-	u8 field_len;
-	size_t parsed;
+	size_t parsed = 0;
 
-	for (parsed = 0; parsed < data_len - 1; parsed += field_len) {
-		field_len = data[0];
+	while (parsed < data_len - 1) {
+		u8 field_len = data[0];
 
 		if (field_len == 0)
 			break;

commit 3f17790c2d8524c3ddc4946bd716714becf079e1
Author: Hemant Gupta <hemant.gupta@stericsson.com>
Date:   Wed Mar 28 17:09:09 2012 +0530

    Bluetooth: Use correct flags for checking HCI_SSP_ENABLED bit
    
    This patch uses the correct flags for checking the HCI_SSP_ENABLED bit.
    Without this authentication request was not being initiated.
    
    Signed-off-by: Hemant Gupta <hemant.gupta@stericsson.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index daefaac51131..8e103281a09b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -427,7 +427,7 @@ enum {
 static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
-	return (test_bit(HCI_SSP_ENABLED, &hdev->flags) &&
+	return (test_bit(HCI_SSP_ENABLED, &hdev->dev_flags) &&
 				test_bit(HCI_CONN_SSP_ENABLED, &conn->flags));
 }
 

commit 04124681f104c1980024ff249a34a77a249fd2bc
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Thu Mar 8 01:25:00 2012 -0300

    Bluetooth: fix conding style issues all over the tree
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cbbf68a8510d..daefaac51131 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -398,16 +398,16 @@ static inline long inquiry_entry_age(struct inquiry_entry *e)
 }
 
 struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
-							bdaddr_t *bdaddr);
+					       bdaddr_t *bdaddr);
 struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
-							bdaddr_t *bdaddr);
+						       bdaddr_t *bdaddr);
 struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
-							bdaddr_t *bdaddr,
-							int state);
+						       bdaddr_t *bdaddr,
+						       int state);
 void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
-						struct inquiry_entry *ie);
+				      struct inquiry_entry *ie);
 bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
-						bool name_known, bool *ssp);
+			      bool name_known, bool *ssp);
 
 /* ----- HCI Connections ----- */
 enum {
@@ -669,13 +669,13 @@ int hci_uuids_clear(struct hci_dev *hdev);
 int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
-			bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+		     bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
 struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
 int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
-				int new_key, u8 authenticated, u8 tk[16],
-				u8 enc_size, u16 ediv, u8 rand[8]);
+		int new_key, u8 authenticated, u8 tk[16], u8 enc_size, u16 ediv,
+		u8 rand[8]);
 struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 addr_type);
+				     u8 addr_type);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
@@ -931,7 +931,7 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 }
 
 static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
-								u8 data_len)
+				  u8 data_len)
 {
 	eir[eir_len++] = sizeof(type) + data_len;
 	eir[eir_len++] = type;
@@ -978,50 +978,49 @@ int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
 int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
-								u8 persistent);
+		      u8 persistent);
 int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-					u8 addr_type, u32 flags, u8 *name,
-					u8 name_len, u8 *dev_class);
+			  u8 addr_type, u32 flags, u8 *name, u8 name_len,
+			  u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
-						u8 link_type, u8 addr_type);
+			     u8 link_type, u8 addr_type);
 int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
-					u8 link_type, u8 addr_type, u8 status);
+			   u8 link_type, u8 addr_type, u8 status);
 int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-						u8 addr_type, u8 status);
+			u8 addr_type, u8 status);
 int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status);
+				 u8 status);
 int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status);
+				     u8 status);
 int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
-				u8 link_type, u8 addr_type, __le32 value,
-				u8 confirm_hint);
+			      u8 link_type, u8 addr_type, __le32 value,
+			      u8 confirm_hint);
 int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-					u8 link_type, u8 addr_type, u8 status);
+				     u8 link_type, u8 addr_type, u8 status);
 int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-					u8 link_type, u8 addr_type, u8 status);
+					 u8 link_type, u8 addr_type, u8 status);
 int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
-						u8 link_type, u8 addr_type);
+			      u8 link_type, u8 addr_type);
 int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-					u8 link_type, u8 addr_type, u8 status);
+				     u8 link_type, u8 addr_type, u8 status);
 int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-					u8 link_type, u8 addr_type, u8 status);
+					 u8 link_type, u8 addr_type, u8 status);
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-						u8 addr_type, u8 status);
+		     u8 addr_type, u8 status);
 int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
-								u8 status);
+				   u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
-						u8 *randomizer, u8 status);
+					    u8 *randomizer, u8 status);
 int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-					u8 addr_type, u8 *dev_class, s8 rssi,
-					u8 cfm_name, u8 ssp, u8 *eir,
-					u16 eir_len);
+		      u8 addr_type, u8 *dev_class, s8 rssi, u8 cfm_name,
+		      u8 ssp, u8 *eir, u16 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-			u8 addr_type, s8 rssi, u8 *name, u8 name_len);
+		     u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
@@ -1071,6 +1070,6 @@ void hci_le_ltk_neg_reply(struct hci_conn *conn);
 int hci_do_inquiry(struct hci_dev *hdev, u8 length);
 int hci_cancel_inquiry(struct hci_dev *hdev);
 int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
-								int timeout);
+		int timeout);
 
 #endif /* __HCI_CORE_H */

commit f64b993f44c3a5fe709b276ac5652d006afe9d33
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Tue Mar 6 23:48:33 2012 -0300

    Bluetooth: Fix coding style in all .h files
    
    Proper align the struct definitions.
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 25cb0a15b579..cbbf68a8510d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -57,7 +57,7 @@ struct inquiry_entry {
 };
 
 struct discovery_state {
-	int type;
+	int			type;
 	enum {
 		DISCOVERY_STOPPED,
 		DISCOVERY_STARTING,
@@ -65,10 +65,10 @@ struct discovery_state {
 		DISCOVERY_RESOLVING,
 		DISCOVERY_STOPPING,
 	} state;
-	struct list_head all;		/* All devices found during inquiry */
-	struct list_head unknown;	/* Name state not known */
-	struct list_head resolve;	/* Name needs to be resolved */
-	__u32		timestamp;
+	struct list_head	all;		/* All devices found during inquiry */
+	struct list_head	unknown;	/* Name state not known */
+	struct list_head	resolve;	/* Name needs to be resolved */
+	__u32			timestamp;
 };
 
 struct hci_conn_hash {

commit 4f87da80a5210e66fb47b0e839f4d05016986f78
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Mar 2 19:55:56 2012 +0200

    Bluetooth: Remove HCI_PI_MGMT_INIT flag for sockets
    
    This flag is of no use right now and is in fact harmful in that it
    prevents the HCI_MGMT flag to be set for any controllers that may need
    it after the first one that bluetoothd takes into use (the flag is
    cleared for the first controller so any subsequent ones through the same
    bluetoothd mgmt socket never get the HCI_MGMT flag set).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index facd7ed32b74..25cb0a15b579 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1034,16 +1034,12 @@ int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
 
-/* HCI socket flags */
-#define HCI_PI_MGMT_INIT	0
-
 struct hci_pinfo {
 	struct bt_sock    bt;
 	struct hci_dev    *hdev;
 	struct hci_filter filter;
 	__u32             cmsg_mask;
 	unsigned short   channel;
-	unsigned long     flags;
 };
 
 /* HCI security filter */

commit 08c79b6133b70a6e3d462d11a89c80259ac66ec7
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 23 22:31:51 2012 +0200

    Bluetooth: mgmt: Add flags parameter to device_connected
    
    This patch updates the Device Connected events to match the latest API
    by adding a flags parameter to them.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 720bdc26b7e9..facd7ed32b74 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -980,8 +980,8 @@ int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 								u8 persistent);
 int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-					u8 addr_type, u8 *name, u8 name_len,
-					u8 *dev_class);
+					u8 addr_type, u32 flags, u8 *name,
+					u8 name_len, u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 						u8 link_type, u8 addr_type);
 int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit 388fc8faf200f80159353eb86cde4ab75d0a0bbd
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 23 00:38:59 2012 +0200

    Bluetooth: mgmt: Add legacy pairing info to dev_found events
    
    This patch makes sure that legacy pairing vs SSP infomation gets
    properly propageted to the device_found events in the form of the legacy
    pairing flag.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3fcc7f0d08c3..720bdc26b7e9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -407,7 +407,7 @@ struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
 void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
 						struct inquiry_entry *ie);
 bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
-							bool name_known);
+						bool name_known, bool *ssp);
 
 /* ----- HCI Connections ----- */
 enum {
@@ -1018,7 +1018,8 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 					u8 addr_type, u8 *dev_class, s8 rssi,
-					u8 cfm_name, u8 *eir, u16 eir_len);
+					u8 cfm_name, u8 ssp, u8 *eir,
+					u16 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 			u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);

commit 490c5baba7a5ad80782d5eb778638d1cfc8d70ce
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 22 19:19:09 2012 +0200

    Bluetooth: Add hdev->short_name for EIR generation
    
    It's possible to provide a short name through the mgmt interface and
    this name can be used for EIR generation when the full name doesn't fit
    there. This patch adds the preliminary tracking of the provided short
    name.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 24dd770d442b..3fcc7f0d08c3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -129,6 +129,8 @@ struct le_scan_params {
 	int timeout;
 };
 
+#define HCI_MAX_SHORT_NAME_LENGTH	10
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -141,6 +143,7 @@ struct hci_dev {
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
+	__u8		short_name[HCI_MAX_SHORT_NAME_LENGTH];
 	__u8		eir[HCI_MAX_EIR_LENGTH];
 	__u8		dev_class[3];
 	__u8		major_class;

commit 7f9a903c57bb42b9f7ad8fb7867859d3252229ab
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 22 18:38:01 2012 +0100

    Bluetooth: Send management event for class of device changes
    
    Currently there are no events to other management sockets if the class of
    device got changed. So make sure they are sent.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index abdaa7900edb..24dd770d442b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1007,6 +1007,8 @@ int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);
 int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
+int mgmt_set_class_of_dev_complete(struct hci_dev *hdev, u8 *dev_class,
+								u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);

commit 06199cf86a84206cfdc96b8dc02d5c27efa8c60f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 22 16:37:11 2012 +0200

    Bluetooth: mgmt: Implement Set LE command
    
    This patch implements support for the Set LE mgmt command. Now, in
    addition to the enable_le module parameter user space needs to send an
    explicit Enable LE command to enable LE support.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6ba3a4b1078e..abdaa7900edb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1010,6 +1010,7 @@ int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);
+int mgmt_le_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 					u8 addr_type, u8 *dev_class, s8 rssi,
 					u8 cfm_name, u8 *eir, u16 eir_len);

commit c0ecddc2507da980af307aae40d6bcdea4c195dc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 22 12:38:31 2012 +0200

    Bluetooth: mgmt: Make Set SSP command callable while powered off
    
    This patch makes it possible to enable SSP through mgmt even when
    powered off. The setting will then get automatically actiated when
    powering on.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 094b5dbdb130..6ba3a4b1078e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1006,7 +1006,7 @@ int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);
 int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
-int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 status);
+int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 enable, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);

commit cd82e61c110a36e398323e422896fcfe05879fed
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 20 20:34:38 2012 +0100

    Bluetooth: Add support for HCI monitor channel
    
    The HCI monitor channel can be used to monitor all packets and events
    from the Bluetooth subsystem. The monitor is not bound to any specific
    HCI device and allows even capturing multiple devices at the same time.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 41adae509e9c..094b5dbdb130 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -950,6 +950,7 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk);
+void hci_send_to_monitor(struct hci_dev *hdev, struct sk_buff *skb);
 
 void hci_sock_dev_event(struct hci_dev *hdev, int event);
 

commit 040030ef7d907107e6489b39da518bdf94136d68
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 20 14:50:37 2012 +0100

    Bluetooth: Remove HCI notifier handling
    
    The HCI notifier handling was never used outside of Bluetooth core layer
    and thus remove it and replace it with direct function calls. Also move
    the stack internal event generation into the HCI socket layer.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9209e4c8a211..41adae509e9c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -941,21 +941,18 @@ static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 
-int hci_register_notifier(struct notifier_block *nb);
-int hci_unregister_notifier(struct notifier_block *nb);
-
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 
-void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
-
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk);
 
+void hci_sock_dev_event(struct hci_dev *hdev, int event);
+
 /* Management interface */
 #define MGMT_ADDR_BREDR			0x00
 #define MGMT_ADDR_LE_PUBLIC		0x01

commit 470fe1b540fb50ba8ce01e0ac985602e8fbb108c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 20 14:50:30 2012 +0100

    Bluetooth: Split sending for HCI raw and control sockets
    
    The sending functions for HCI raw and control sockets have nothing in
    common except that they iterate over the socket list. Split them into
    two so they can do their job more efficient. In addition the code becomes
    more readable.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2aafeb3a8793..9209e4c8a211 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -953,8 +953,8 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
 
 /* ----- HCI Sockets ----- */
-void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
-							struct sock *skip_sk);
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+void hci_send_to_control(struct sk_buff *skb, struct sock *skip_sk);
 
 /* Management interface */
 #define MGMT_ADDR_BREDR			0x00

commit 5e0452c00a2e4b04ec1482248c897dacf106f1df
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 17 20:39:38 2012 -0300

    Bluetooth: Interleaved discovery support
    
    This patch adds interleaved discovery support to MGMT Start
    Discovery command.
    
    In case interleaved discovery is not supported (not a dual mode
    device), we perform BR/EDR or LE-only discovery according to the
    device capabilities.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 942de7764278..2aafeb3a8793 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -716,6 +716,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
+#define lmp_bredr_capable(dev)     (!((dev)->features[4] & LMP_NO_BREDR))
 
 /* ----- Extended LMP capabilities ----- */
 #define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
@@ -1019,6 +1020,7 @@ int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
+int mgmt_interleaved_discovery(struct hci_dev *hdev);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 

commit 343f935bfa44189c68527102c409286b0cfc4526
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 17 20:39:37 2012 -0300

    Bluetooth: Merge INQUIRY and LE_SCAN discovery states
    
    This patch merges DISCOVERY_INQUIRY and DISCOVERY_LE_SCAN states
    into a new state called DISCOVERY_FINDING.
    
    From the discovery perspective, we are pretty much worried about
    to know just if we are finding devices than what exactly phase of
    "finding devices" (inquiry or LE scan) we are currently running.
    Besides, to know if the controller is performing inquiry or LE scan
    we should check HCI_INQUIRY or HCI_LE_SCAN bits in hdev flags.
    
    Moreover, merging this two states will simplify the discovery state
    machine and will keep interleaved discovery implementation simpler.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d7c79b5335c2..942de7764278 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -61,8 +61,7 @@ struct discovery_state {
 	enum {
 		DISCOVERY_STOPPED,
 		DISCOVERY_STARTING,
-		DISCOVERY_INQUIRY,
-		DISCOVERY_LE_SCAN,
+		DISCOVERY_FINDING,
 		DISCOVERY_RESOLVING,
 		DISCOVERY_STOPPING,
 	} state;

commit 4aab14e5504e84c42534378f91e836e6f55d0886
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 17 20:39:36 2012 -0300

    Bluetooth: Track discovery type
    
    This patch adds to struct discovery_state the field 'type' so that
    we can track the discovery type the device is performing.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index be8da5d54abb..d7c79b5335c2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -57,6 +57,7 @@ struct inquiry_entry {
 };
 
 struct discovery_state {
+	int type;
 	enum {
 		DISCOVERY_STOPPED,
 		DISCOVERY_STARTING,

commit f39799f5047c4827b200acbf33cd0ba076afd7ed
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 17 20:39:35 2012 -0300

    Bluetooth: Prepare start_discovery
    
    This patch does some code refactoring in start_discovery function
    in order to prepare it for interleaved discovery support.
    
    MGMT_ADDR_* macros were moved to hci_core.h since they are now used
    to define discovery type macros.
    
    Discovery type macros were defined according to mgmt-api.txt
    specification:
    
    Possible values for the Type parameter are a bit-wise or of the
    following bits:
    
            1       BR/EDR
            2       LE Public
            3       LE Random
    
    By combining these e.g. the following values are possible:
    
            1       BR/EDR
            6       LE (public & random)
            7       BR/EDR/LE (interleaved discovery)
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 43e0b1eda020..be8da5d54abb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -956,6 +956,18 @@ void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
 							struct sock *skip_sk);
 
 /* Management interface */
+#define MGMT_ADDR_BREDR			0x00
+#define MGMT_ADDR_LE_PUBLIC		0x01
+#define MGMT_ADDR_LE_RANDOM		0x02
+#define MGMT_ADDR_INVALID		0xff
+
+#define DISCOV_TYPE_BREDR		(BIT(MGMT_ADDR_BREDR))
+#define DISCOV_TYPE_LE			(BIT(MGMT_ADDR_LE_PUBLIC) | \
+						BIT(MGMT_ADDR_LE_RANDOM))
+#define DISCOV_TYPE_INTERLEAVED		(BIT(MGMT_ADDR_BREDR) | \
+						BIT(MGMT_ADDR_LE_PUBLIC) | \
+						BIT(MGMT_ADDR_LE_RANDOM))
+
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(struct hci_dev *hdev);
 int mgmt_index_removed(struct hci_dev *hdev);

commit ed2c4ee360709ca838efa0ea4d6295590aff3d24
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 17 00:56:28 2012 +0200

    Bluetooth: mgmt: Add support for Set SSP command
    
    The Set SSP mgmt command can be used for enabling and disabling Secure
    Simple Pairing support for controllers that support it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 66f84adbbbef..43e0b1eda020 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -995,6 +995,7 @@ int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);
 int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
+int mgmt_ssp_enable_complete(struct hci_dev *hdev, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);

commit 33ef95ed30283eb17c686a815caf1d33e966fe4a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 16 23:56:27 2012 +0200

    Bluetooth: mgmt: Add support for Set Link Security command
    
    The Set Link Security mgmt command is used to enable or disable link
    level security, also known as Security Mode 3. This is rarely enabled in
    modern systems but the command needs to be available for completeness,
    qualification purposes and those few systems that actually want to
    enable it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b20d990436b4..66f84adbbbef 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -994,6 +994,7 @@ int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 					u8 link_type, u8 addr_type, u8 status);
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);
+int mgmt_auth_enable_complete(struct hci_dev *hdev, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);

commit 3dc07322b1ce3c8477690d54ebbf15a165f43066
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Thu Feb 9 21:58:33 2012 +0100

    Bluetooth: Introduce to_hci_conn
    
    This avoids using the dev_set/get_drvdata() functions to retrieve a
    pointer to our own structure. We can use simple pointer arithmetic here.
    The drvdata field is actually not needed by any other code-path but this
    makes the code more consistent with hci_dev.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4559189a22a1..b20d990436b4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -623,6 +623,7 @@ static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 #define hci_dev_unlock(d)	mutex_unlock(&d->lock)
 
 #define to_hci_dev(d) container_of(d, struct hci_dev, dev)
+#define to_hci_conn(c) container_of(c, struct hci_conn, dev)
 
 static inline void *hci_get_drvdata(struct hci_dev *hdev)
 {

commit 155961e8001719af6d87cbcc961111e8ce477843
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Thu Feb 9 21:58:32 2012 +0100

    Bluetooth: Remove hci_dev->driver_data
    
    The linux device model provides dev_set/get_drvdata so we can use this
    to save private driver data.
    This also removes several unnecessary casts.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 221d772ded55..4559189a22a1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -254,7 +254,6 @@ struct hci_dev {
 
 	struct sk_buff_head	driver_init;
 
-	void			*driver_data;
 	void			*core_data;
 
 	atomic_t		promisc;
@@ -625,6 +624,16 @@ static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 
 #define to_hci_dev(d) container_of(d, struct hci_dev, dev)
 
+static inline void *hci_get_drvdata(struct hci_dev *hdev)
+{
+	return dev_get_drvdata(&hdev->dev);
+}
+
+static inline void hci_set_drvdata(struct hci_dev *hdev, void *data)
+{
+	dev_set_drvdata(&hdev->dev, data);
+}
+
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
 

commit aa2b86d761a95068354511de755695ef6b53afc7
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Thu Feb 9 21:58:30 2012 +0100

    Bluetooth: Introduce to_hci_dev()
    
    We currently use dev_set_drvdata to keep a pointer to ourself. This
    doesn't make sense as we are the bus and not a driver. Therefore,
    introduce to_hci_dev() so we can get a struct hci_dev pointer from a
    struct device pointer.
    
    dev_set/get_drvdata() is reserved for drivers that provide a device and
    not for the bus using the device. The bus can use simple pointer
    arithmetic to retrieve its private data.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ccb24a4212cd..221d772ded55 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -623,6 +623,8 @@ static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 #define hci_dev_lock(d)		mutex_lock(&d->lock)
 #define hci_dev_unlock(d)	mutex_unlock(&d->lock)
 
+#define to_hci_dev(d) container_of(d, struct hci_dev, dev)
+
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
 

commit bab73cb68435232ba78a4bd1ac1a85862e3be0bb
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 9 16:07:29 2012 +0200

    Bluetooth: Add address type to mgmt_ev_auth_failed
    
    This patch updates the Authentication Failed mgmt event to match the
    latest API specification by adding an address type to it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 14a655f3929c..ccb24a4212cd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -980,7 +980,8 @@ int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 					u8 link_type, u8 addr_type, u8 status);
 int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 					u8 link_type, u8 addr_type, u8 status);
-int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
+int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+						u8 addr_type, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);

commit 88c1fe4ba55c7245ad2f3c81689f854287875121
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 9 15:56:11 2012 +0200

    Bluetooth: Add address type to mgmt blacklist messages
    
    This patch updates the implmentation for mgmt_block_device and
    mgmt_unblock_device and their corresponding events to match the latest
    API specification.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5f27694068f2..14a655f3929c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -646,8 +646,8 @@ int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
-int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 
@@ -992,8 +992,8 @@ int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
-int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
 
 int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
 

commit 272d90df2d4d065e782cafb08358bd8918bf703a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 9 15:26:12 2012 +0200

    Bluetooth: Add address type to user_confirm and user_passkey messages
    
    This patch upadate the user confirm and user passkey mgmt messages to
    match the latest API specification by adding an address type parameter
    to them.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 634a0cdcdad6..5f27694068f2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -968,16 +968,18 @@ int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 								u8 status);
 int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
-						__le32 value, u8 confirm_hint);
+				u8 link_type, u8 addr_type, __le32 value,
+				u8 confirm_hint);
 int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status);
-int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev,
-						bdaddr_t *bdaddr, u8 status);
-int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr);
+					u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+						u8 link_type, u8 addr_type);
 int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								u8 status);
-int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev,
-						bdaddr_t *bdaddr, u8 status);
+					u8 link_type, u8 addr_type, u8 status);
+int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					u8 link_type, u8 addr_type, u8 status);
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,

commit 88c3df13ca06718e5a8f509ae9cbb1228c10d537
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Feb 9 14:27:38 2012 +0200

    Bluetooth: Update mgmt_disconnect to match latest API
    
    This patch adds an address type parameter to the disconnect command and
    response in order to match the latest mgmt API specification.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7107790817a5..634a0cdcdad6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -958,7 +958,8 @@ int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 					u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 						u8 link_type, u8 addr_type);
-int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
+int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr,
+					u8 link_type, u8 addr_type, u8 status);
 int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);
 int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);

commit 28b75a89480df99a17c8facd5c33985847d06bb6
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 3 17:48:00 2012 -0300

    Bluetooth: Add hci_le_scan()
    
    We are not supposed to block in start_discovery() because
    start_discovery code is running in write() syscall context
    and this would block the write operation on the mgmt socket.
    This way, we cannot directly call hci_do_le_scan() to scan
    LE devices in start_discovery(). To overcome this issue a
    derefered work (hdev->le_scan) was created so we can properly
    call hci_do_le_scan().
    
    The helper function hci_le_scan() simply set LE scan parameters
    and queue hdev->le_scan work. The work is queued on system_long_wq
    since it can sleep for a few seconds in the worst case (timeout).
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3e70872bffea..7107790817a5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -126,6 +126,7 @@ struct le_scan_params {
 	u8 type;
 	u16 interval;
 	u16 window;
+	int timeout;
 };
 
 #define NUM_REASSEMBLY 4
@@ -269,6 +270,9 @@ struct hci_dev {
 
 	struct delayed_work	le_scan_disable;
 
+	struct work_struct	le_scan;
+	struct le_scan_params	le_scan_params;
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
@@ -1033,5 +1037,7 @@ void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
 int hci_do_inquiry(struct hci_dev *hdev, u8 length);
 int hci_cancel_inquiry(struct hci_dev *hdev);
+int hci_le_scan(struct hci_dev *hdev, u8 type, u16 interval, u16 window,
+								int timeout);
 
 #endif /* __HCI_CORE_H */

commit 7ba8b4be38e7c83b2b13333a82a0ecde921a7390
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 3 17:47:59 2012 -0300

    Bluetooth: Add hci_do_le_scan()
    
    This patch adds to hci_core the hci_do_le_scan function which
    should be used to scan LE devices.
    
    In order to enable LE scan, hci_do_le_scan() sends commands (Set
    LE Scan Parameters and Set LE Scan Enable) to the controller and
    waits for its results. If commands were executed successfully a
    delayed work is scheduled to disable the ongoing scanning after
    some amount of time. This function blocks.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bf2ef5667887..3e70872bffea 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -122,6 +122,12 @@ struct adv_entry {
 	u8 bdaddr_type;
 };
 
+struct le_scan_params {
+	u8 type;
+	u16 interval;
+	u16 window;
+};
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -261,6 +267,8 @@ struct hci_dev {
 
 	unsigned long		dev_flags;
 
+	struct delayed_work	le_scan_disable;
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);

commit c599008f8f999dab8cb4a6404be99bdc4716ba15
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Feb 3 17:47:57 2012 -0300

    Bluetooth: LE scan should send Discovering events
    
    Send MGMT Discovering events once LE scan starts/stops so the
    userspace can track when local adapters are discovering LE devices.
    
    This way, we also keep the same behavior of inquiry which sends MGMT
    Discovering events once inquiry starts/stops even if it is triggered
    by an external tool (e.g. hcitool).
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9751da78341d..bf2ef5667887 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -61,6 +61,7 @@ struct discovery_state {
 		DISCOVERY_STOPPED,
 		DISCOVERY_STARTING,
 		DISCOVERY_INQUIRY,
+		DISCOVERY_LE_SCAN,
 		DISCOVERY_RESOLVING,
 		DISCOVERY_STOPPING,
 	} state;

commit f9c5f9ddcfc404b5d4c079452755337d84c97707
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Feb 2 21:08:04 2012 -0300

    Bluetooth: Clean up structures left unused
    
    With the use of the new structures and lists for the SMP LTK's
    we may remove some code that is now unused. No need to have extra
    fields of information inside link_key now that it is only used
    for Link Keys.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7793fc644b87..9751da78341d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -100,28 +100,12 @@ struct smp_ltk {
 	u8 val[16];
 } __packed;
 
-struct key_master_id {
-	__le16 ediv;
-	u8 rand[8];
-} __packed;
-
-struct link_key_data {
-	bdaddr_t bdaddr;
-	u8 type;
-	u8 val[16];
-	u8 pin_len;
-	u8 dlen;
-	u8 data[0];
-} __packed;
-
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 type;
 	u8 val[16];
 	u8 pin_len;
-	u8 dlen;
-	u8 data[0];
 };
 
 struct oob_data {

commit 346af67b8d116f01ef696fd47959a55deb2db8b6
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Feb 2 21:08:02 2012 -0300

    Bluetooth: Add MGMT handlers for dealing with SMP LTK's
    
    This adds a method to notify that a new LTK is available and
    a handler to store keys coming from userspace into the kernel LTK
    list.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2649caf4db96..7793fc644b87 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -995,6 +995,8 @@ int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
+int mgmt_new_ltk(struct hci_dev *hdev, struct smp_ltk *key, u8 persistent);
+
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
 

commit c9839a11c0e460a2457e7cac76650d07773e6c3b
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Feb 2 21:08:01 2012 -0300

    Bluetooth: Use the updated key structures for handling LTKs
    
    This updates all the users of the older way, that was using the
    link_keys list to store the SMP keys, to use the new way.
    
    This includes defining new types for the keys, we have a type for each
    combination of STK/LTK and Master/Slave.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c998176a503d..2649caf4db96 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -658,12 +658,13 @@ int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 			bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
-struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
-struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
-					bdaddr_t *bdaddr, u8 type);
+struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
+int hci_add_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type, u8 type,
+				int new_key, u8 authenticated, u8 tk[16],
+				u8 enc_size, u16 ediv, u8 rand[8]);
+struct smp_ltk *hci_find_ltk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								u8 addr_type);
 int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
 int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 

commit b899efaf9b26cadb084752862490b4fc44bc3169
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Feb 2 21:08:00 2012 -0300

    Bluetooth: Add new structures for handling SMP Long Term Keys
    
    This includes a new list for storing the keys and a new structure used
    to represent each key.
    
    Some notes: authenticated is used to identify that the key may be used
    to setup a HIGH security link. As the same list is used to store both
    the STK's and the LTK's the type field is used so we can separate
    between those two types of keys and if the key should be used when
    in the master or slave role.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 896d9e4955fc..c998176a503d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -88,6 +88,18 @@ struct bt_uuid {
 	u8 svc_hint;
 };
 
+struct smp_ltk {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 bdaddr_type;
+	u8 authenticated;
+	u8 type;
+	u8 enc_size;
+	__le16 ediv;
+	u8 rand[8];
+	u8 val[16];
+} __packed;
+
 struct key_master_id {
 	__le16 ediv;
 	u8 rand[8];
@@ -239,6 +251,8 @@ struct hci_dev {
 
 	struct list_head	link_keys;
 
+	struct list_head	long_term_keys;
+
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
@@ -647,8 +661,10 @@ int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
 struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
 					bdaddr_t *bdaddr, u8 type);
+int hci_remove_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
 			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
+int hci_smp_ltks_clear(struct hci_dev *hdev);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);

commit 2f304d1e8bf89f2258a6c2e08c0bc2c5debd08f7
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Jan 27 19:42:02 2012 -0300

    Bluetooth: Fix potential deadlock
    
    We don't need to use the _sync variant in hci_conn_hold and
    hci_conn_put to cancel conn->disc_work delayed work. This way
    we avoid potential deadlocks like this one reported by lockdep.
    
    ======================================================
    [ INFO: possible circular locking dependency detected ]
    3.2.0+ #1 Not tainted
    -------------------------------------------------------
    kworker/u:1/17 is trying to acquire lock:
     (&hdev->lock){+.+.+.}, at: [<ffffffffa0041155>] hci_conn_timeout+0x62/0x158 [bluetooth]
    
    but task is already holding lock:
     ((&(&conn->disc_work)->work)){+.+...}, at: [<ffffffff81035751>] process_one_work+0x11a/0x2bf
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #2 ((&(&conn->disc_work)->work)){+.+...}:
           [<ffffffff81057444>] lock_acquire+0x8a/0xa7
           [<ffffffff81034ed1>] wait_on_work+0x3d/0xaa
           [<ffffffff81035b54>] __cancel_work_timer+0xac/0xef
           [<ffffffff81035ba4>] cancel_delayed_work_sync+0xd/0xf
           [<ffffffffa00554b0>] smp_chan_create+0xde/0xe6 [bluetooth]
           [<ffffffffa0056160>] smp_conn_security+0xa3/0x12d [bluetooth]
           [<ffffffffa0053640>] l2cap_connect_cfm+0x237/0x2e8 [bluetooth]
           [<ffffffffa004239c>] hci_proto_connect_cfm+0x2d/0x6f [bluetooth]
           [<ffffffffa0046ea5>] hci_event_packet+0x29d1/0x2d60 [bluetooth]
           [<ffffffffa003dde3>] hci_rx_work+0xd0/0x2e1 [bluetooth]
           [<ffffffff810357af>] process_one_work+0x178/0x2bf
           [<ffffffff81036178>] worker_thread+0xce/0x152
           [<ffffffff81039a03>] kthread+0x95/0x9d
           [<ffffffff812e7754>] kernel_thread_helper+0x4/0x10
    
    -> #1 (slock-AF_BLUETOOTH-BTPROTO_L2CAP){+.+...}:
           [<ffffffff81057444>] lock_acquire+0x8a/0xa7
           [<ffffffff812e553a>] _raw_spin_lock_bh+0x36/0x6a
           [<ffffffff81244d56>] lock_sock_nested+0x24/0x7f
           [<ffffffffa004d96f>] lock_sock+0xb/0xd [bluetooth]
           [<ffffffffa0052906>] l2cap_chan_connect+0xa9/0x26f [bluetooth]
           [<ffffffffa00545f8>] l2cap_sock_connect+0xb3/0xff [bluetooth]
           [<ffffffff81243b48>] sys_connect+0x69/0x8a
           [<ffffffff812e6579>] system_call_fastpath+0x16/0x1b
    
    -> #0 (&hdev->lock){+.+.+.}:
           [<ffffffff81056d06>] __lock_acquire+0xa80/0xd74
           [<ffffffff81057444>] lock_acquire+0x8a/0xa7
           [<ffffffff812e3870>] __mutex_lock_common+0x48/0x38e
           [<ffffffff812e3c75>] mutex_lock_nested+0x2a/0x31
           [<ffffffffa0041155>] hci_conn_timeout+0x62/0x158 [bluetooth]
           [<ffffffff810357af>] process_one_work+0x178/0x2bf
           [<ffffffff81036178>] worker_thread+0xce/0x152
           [<ffffffff81039a03>] kthread+0x95/0x9d
           [<ffffffff812e7754>] kernel_thread_helper+0x4/0x10
    
    other info that might help us debug this:
    
    Chain exists of:
      &hdev->lock --> slock-AF_BLUETOOTH-BTPROTO_L2CAP --> (&(&conn->disc_work)->work)
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock((&(&conn->disc_work)->work));
                                   lock(slock-AF_BLUETOOTH-BTPROTO_L2CAP);
                                   lock((&(&conn->disc_work)->work));
      lock(&hdev->lock);
    
     *** DEADLOCK ***
    
    2 locks held by kworker/u:1/17:
     #0:  (hdev->name){.+.+.+}, at: [<ffffffff81035751>] process_one_work+0x11a/0x2bf
     #1:  ((&(&conn->disc_work)->work)){+.+...}, at: [<ffffffff81035751>] process_one_work+0x11a/0x2bf
    
    stack backtrace:
    Pid: 17, comm: kworker/u:1 Not tainted 3.2.0+ #1
    Call Trace:
     [<ffffffff812e06c6>] print_circular_bug+0x1f8/0x209
     [<ffffffff81056d06>] __lock_acquire+0xa80/0xd74
     [<ffffffff81021ef2>] ? arch_local_irq_restore+0x6/0xd
     [<ffffffff81022bc7>] ? vprintk+0x3f9/0x41e
     [<ffffffff81057444>] lock_acquire+0x8a/0xa7
     [<ffffffffa0041155>] ? hci_conn_timeout+0x62/0x158 [bluetooth]
     [<ffffffff812e3870>] __mutex_lock_common+0x48/0x38e
     [<ffffffffa0041155>] ? hci_conn_timeout+0x62/0x158 [bluetooth]
     [<ffffffff81190fd6>] ? __dynamic_pr_debug+0x6d/0x6f
     [<ffffffffa0041155>] ? hci_conn_timeout+0x62/0x158 [bluetooth]
     [<ffffffff8105320f>] ? trace_hardirqs_off+0xd/0xf
     [<ffffffff812e3c75>] mutex_lock_nested+0x2a/0x31
     [<ffffffffa0041155>] hci_conn_timeout+0x62/0x158 [bluetooth]
     [<ffffffff810357af>] process_one_work+0x178/0x2bf
     [<ffffffff81035751>] ? process_one_work+0x11a/0x2bf
     [<ffffffff81055af3>] ? lock_acquired+0x1d0/0x1df
     [<ffffffffa00410f3>] ? hci_acl_disconn+0x65/0x65 [bluetooth]
     [<ffffffff81036178>] worker_thread+0xce/0x152
     [<ffffffff810407ed>] ? finish_task_switch+0x45/0xc5
     [<ffffffff810360aa>] ? manage_workers.isra.25+0x16a/0x16a
     [<ffffffff81039a03>] kthread+0x95/0x9d
     [<ffffffff812e7754>] kernel_thread_helper+0x4/0x10
     [<ffffffff812e5db4>] ? retint_restore_args+0x13/0x13
     [<ffffffff8103996e>] ? __init_kthread_worker+0x55/0x55
     [<ffffffff812e7750>] ? gs_change+0x13/0x13
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Reviewed-by: Ulisses Furquim <ulisses@profusion.mobi>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 25f449fcd693..896d9e4955fc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -572,7 +572,7 @@ void hci_conn_put_device(struct hci_conn *conn);
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
-	cancel_delayed_work_sync(&conn->disc_work);
+	cancel_delayed_work(&conn->disc_work);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
@@ -591,7 +591,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 		} else {
 			timeo = msecs_to_jiffies(10);
 		}
-		cancel_delayed_work_sync(&conn->disc_work);
+		cancel_delayed_work(&conn->disc_work);
 		queue_delayed_work(conn->hdev->workqueue,
 					&conn->disc_work, timeo);
 	}

commit aa64a8b500e61c33c17f1d5e7de0cc154489c59e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 18 21:33:12 2012 +0200

    Bluetooth: Add a convenience function to check for SSP enabled
    
    It's a very common test to see if both the local and the remote device
    have SSP enabled. By creating a simple function to test this we can
    shorten many if-statements in the code.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 94ba8693e9d1..25f449fcd693 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -411,6 +411,13 @@ enum {
 	HCI_CONN_REMOTE_OOB,
 };
 
+static inline bool hci_conn_ssp_enabled(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	return (test_bit(HCI_SSP_ENABLED, &hdev->flags) &&
+				test_bit(HCI_CONN_SSP_ENABLED, &conn->flags));
+}
+
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;

commit 84bde9d6c0e6830f4a8685a5d237965053118bf9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 25 14:21:06 2012 +0200

    Bluetooth: Convert hdev->ssp_mode to a flag
    
    The ssp_mode is essentially just a boolean so it's more appropriate to
    have it simply as a flag in hdev->dev_flags.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7a033111c98f..94ba8693e9d1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -144,7 +144,6 @@ struct hci_dev {
 	__u8		features[8];
 	__u8		host_features[8];
 	__u8		commands[64];
-	__u8		ssp_mode;
 	__u8		hci_ver;
 	__u16		hci_rev;
 	__u8		lmp_ver;

commit 58a681ef1455aef9caad1d41073868fb399373f6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 16 06:47:28 2012 +0200

    Bluetooth: Merge boolean members of struct hci_conn into flags
    
    Now that the flags member of struct hci_conn is supposed to accommodate
    any boolean type values we can easily merge all boolean members into it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 18af5427fd0c..7a033111c98f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -286,7 +286,6 @@ struct hci_conn {
 	__u8		attempt;
 	__u8		dev_class[3];
 	__u8		features[8];
-	__u8		ssp_mode;
 	__u16		interval;
 	__u16		pkt_type;
 	__u16		link_policy;
@@ -298,12 +297,10 @@ struct hci_conn {
 	__u8		pin_length;
 	__u8		enc_key_size;
 	__u8		io_capability;
-	__u8		power_save;
 	__u16		disc_timeout;
 	unsigned long	flags;
 
 	__u8		remote_cap;
-	__u8		remote_oob;
 	__u8		remote_auth;
 
 	unsigned int	sent;
@@ -410,6 +407,9 @@ enum {
 	HCI_CONN_SCO_SETUP_PEND,
 	HCI_CONN_LE_SMP_PEND,
 	HCI_CONN_MGMT_CONNECTED,
+	HCI_CONN_SSP_ENABLED,
+	HCI_CONN_POWER_SAVE,
+	HCI_CONN_REMOTE_OOB,
 };
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)

commit b644ba33699711630099efc58a4efc225560aceb
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 17 21:48:47 2012 +0200

    Bluetooth: Update device_connected and device_found events to latest API
    
    This patch updates mgmt_ev_device_connected and mgmt_ev_device found to
    include an EIR-encoded remote name and class whenever possible. With
    this addition the mgmt_ev_remote_name event becomes unnecessary and can
    be removed. Since the connected event doesn't map to hci_conn_complete
    anymore a HCI_CONN_MGMT_CONNECTED flag is added to track when mgmt has
    been notified about a connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 520da44940e9..18af5427fd0c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -409,6 +409,7 @@ enum {
 	HCI_CONN_MODE_CHANGE_PEND,
 	HCI_CONN_SCO_SETUP_PEND,
 	HCI_CONN_LE_SMP_PEND,
+	HCI_CONN_MGMT_CONNECTED,
 };
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
@@ -933,7 +934,8 @@ int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 								u8 persistent);
 int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-								u8 addr_type);
+					u8 addr_type, u8 *name, u8 name_len,
+					u8 *dev_class);
 int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
 						u8 link_type, u8 addr_type);
 int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
@@ -962,7 +964,8 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 					u8 addr_type, u8 *dev_class, s8 rssi,
 					u8 cfm_name, u8 *eir, u16 eir_len);
-int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
+int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+			u8 addr_type, s8 rssi, u8 *name, u8 name_len);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);

commit a0c808b373e89aecc3ecae4cbdcdeff68aa12e3e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 16 09:49:58 2012 +0200

    Bluetooth: Convert hdev->out to a bool type
    
    The hdev->out variable is essentially a boolean so the type 'bool' makes
    more sense than u8.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0938168ce602..520da44940e9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -282,7 +282,7 @@ struct hci_conn {
 	__u16		state;
 	__u8		mode;
 	__u8		type;
-	__u8		out;
+	bool		out;
 	__u8		attempt;
 	__u8		dev_class[3];
 	__u8		features[8];

commit 51a8efd7d02c13cb1c6fdd1cd66788792a3fcc7c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 16 06:10:31 2012 +0200

    Bluetooth: Rename conn->pend to conn->flags
    
    These flags can and will be used for more general purpose values than
    just pending state transitions so the more common name "flags" makes
    more sense than "pend".
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a0311018a4d0..0938168ce602 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -300,7 +300,7 @@ struct hci_conn {
 	__u8		io_capability;
 	__u8		power_save;
 	__u16		disc_timeout;
-	unsigned long	pend;
+	unsigned long	flags;
 
 	__u8		remote_cap;
 	__u8		remote_oob;
@@ -764,7 +764,7 @@ static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 	if (conn->type != ACL_LINK && conn->type != LE_LINK)
 		return;
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
@@ -805,7 +805,7 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 
 	hci_proto_auth_cfm(conn, status);
 
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return;
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;

commit 1dc06093a9f353ef19b7b5180602884d0ce065c5
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jan 15 21:01:23 2012 +0200

    Bluetooth: Merge device class into the EIR data in mgmt_ev_device_found
    
    There's no need to have a separate device class field since the same
    information can be encoded into the EIR data.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 393bb73fc999..a0311018a4d0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -893,6 +893,17 @@ static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
 	return false;
 }
 
+static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
+								u8 data_len)
+{
+	eir[eir_len++] = sizeof(type) + data_len;
+	eir[eir_len++] = type;
+	memcpy(&eir[eir_len], data, data_len);
+	eir_len += data_len;
+
+	return eir_len;
+}
+
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit 6759a67579a927f2a92f398cf67555e6cc92d0ff
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jan 15 20:51:14 2012 +0200

    Bluetooth: Move eir_has_data_field to hci_core.h
    
    This makes the function accessible from all places it's needed (e.g.
    mgmt.c and hci_event.c).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 33dff8ef2e08..393bb73fc999 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -868,6 +868,31 @@ static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
 	read_unlock(&hci_cb_list_lock);
 }
 
+static inline bool eir_has_data_type(u8 *data, size_t data_len, u8 type)
+{
+	u8 field_len;
+	size_t parsed;
+
+	for (parsed = 0; parsed < data_len - 1; parsed += field_len) {
+		field_len = data[0];
+
+		if (field_len == 0)
+			break;
+
+		parsed += field_len + 1;
+
+		if (parsed > data_len)
+			break;
+
+		if (data[1] == type)
+			return true;
+
+		data += field_len + 1;
+	}
+
+	return false;
+}
+
 int hci_register_cb(struct hci_cb *hcb);
 int hci_unregister_cb(struct hci_cb *hcb);
 

commit e319d2e74378660c5e09a1b8703663ba97f0f62a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jan 15 19:51:59 2012 +0200

    Bluetooth: Add eir_len parameter to mgmt_ev_device_found
    
    This patch add a two byte eir_len parameter mgmt_ev_device_found. Since
    it's unlikely that the data will in the short term be much bigger than
    conventional EIR lengths just use a small stack based buffer for now to
    avoid dynamic memory allocation & freeing.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f3fbfd6f6c3b..33dff8ef2e08 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -925,7 +925,7 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 					u8 addr_type, u8 *dev_class, s8 rssi,
-					u8 cfm_name, u8 *eir, u8 eir_len);
+					u8 cfm_name, u8 *eir, u16 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);

commit afc747a600ff2e3a4eef8f312fc766608a1360e2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jan 15 18:11:07 2012 +0200

    Bluetooth: Rename mgmt connected events to match user space
    
    User space uses device_(dis)connected instead of just (dis)connected so
    rename the defines and functions to match this.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 393acd071cb6..f3fbfd6f6c3b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -896,10 +896,10 @@ int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 								u8 persistent);
-int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-								u8 addr_type);
-int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+int mgmt_device_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 								u8 addr_type);
+int mgmt_device_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr,
+						u8 link_type, u8 addr_type);
 int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
 int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);

commit 7d262f86f6b73efb500be9d9242ef0673221493d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Jan 10 18:20:49 2012 -0300

    Bluetooth: Add 'eir_len' param to mgmt_device_found()
    
    This patch adds a new parameter to mgmt_device_found() to inform
    the length of 'eir' pointer.
    
    EIR data from LE advertising report event doesn't have a fixed length
    as EIR data from extended inquiry result event does. We needed to
    change mgmt_device_found() so it copies 'eir_len' bytes instead of
    HCI_MAX_EIR_LENGTH.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 59e3541e9fc7..393acd071cb6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -925,7 +925,7 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 					u8 addr_type, u8 *dev_class, s8 rssi,
-					u8 cfm_name, u8 *eir);
+					u8 cfm_name, u8 *eir, u8 eir_len);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);

commit a3d4e20a88f54571d794cca365f232bfed0669bb
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 9 00:53:02 2012 +0200

    Bluetooth: Sort to-be-resolved devices by RSSI during discovery
    
    This patch makes sure that devices with stronger signal (RSSI closer to
    0) are sorted first in the resolve list and will therefore get their
    names resolved first during device discovery. Since it's more likely
    that the device the user is trying to discover has a strong signal due
    to its proximity this ensures that the user gets the "device found"
    event for it more quickly.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f9c88251fe1a..59e3541e9fc7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -395,6 +395,8 @@ struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
 struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
 							bdaddr_t *bdaddr,
 							int state);
+void hci_inquiry_cache_update_resolve(struct hci_dev *hdev,
+						struct inquiry_entry *ie);
 bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
 							bool name_known);
 

commit dc946bd86f725c42c3ab1caf9966d29f5b364fea
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Jan 7 15:47:24 2012 +0100

    Bluetooth: Remove __hci_dev_put/hold
    
    Since we remove the owner field of hci_dev hci_dev_put and __hci_dev_put
    do the same so we can merge them into one function. Same for
    hci_dev_hold and __hci_dev_hold.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4ccf3749a9a7..f9c88251fe1a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -589,25 +589,17 @@ static inline void hci_conn_put(struct hci_conn *conn)
 }
 
 /* ----- HCI Devices ----- */
-static inline void __hci_dev_put(struct hci_dev *d)
+static inline void hci_dev_put(struct hci_dev *d)
 {
 	put_device(&d->dev);
 }
 
-/*
- * hci_dev_put and hci_dev_hold are macros to avoid dragging all the
- * overhead of all the modular infrastructure into this header.
- */
-#define hci_dev_put(d) __hci_dev_put(d)
-
-static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
+static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 {
 	get_device(&d->dev);
 	return d;
 }
 
-#define hci_dev_hold(d) __hci_dev_hold(d)
-
 #define hci_dev_lock(d)		mutex_lock(&d->lock)
 #define hci_dev_unlock(d)	mutex_unlock(&d->lock)
 

commit 4c724c7135ca2b407bd318b4267456a7b5723825
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Jan 7 15:47:23 2012 +0100

    Bluetooth: Correctly take hci_dev->dev refcount
    
    The hci_dev->dev device structure has an internal refcount. This
    refcount is used to protect the whole hci_dev object. However, we
    currently do not use it.  Therefore, if someone calls hci_free_dev() we
    currently immediately destroy the hci_dev object because we never took
    the device refcount.
    
    This even happens if the hci_dev->refcnt is not 0. In fact, the
    hci_dev->refcnt is totally useless in its current state. Therefore, we
    simply remove hci_dev->refcnt and instead use hci_dev->dev refcnt.
    
    This fixes all the symptoms and also correctly integrates the device
    structure into our bluetooth bus system.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 99984688ccdd..4ccf3749a9a7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -129,7 +129,6 @@ struct adv_entry {
 struct hci_dev {
 	struct list_head list;
 	struct mutex	lock;
-	atomic_t	refcnt;
 
 	char		name[8];
 	unsigned long	flags;
@@ -592,7 +591,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 /* ----- HCI Devices ----- */
 static inline void __hci_dev_put(struct hci_dev *d)
 {
-	atomic_dec(&d->refcnt);
+	put_device(&d->dev);
 }
 
 /*
@@ -603,7 +602,7 @@ static inline void __hci_dev_put(struct hci_dev *d)
 
 static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 {
-	atomic_inc(&d->refcnt);
+	get_device(&d->dev);
 	return d;
 }
 

commit e9b9cfa1575e37cb2dbb5534aeaaa16814228887
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Jan 7 15:47:22 2012 +0100

    Bluetooth: Remove HCI-owner field
    
    After unregistering an hci_dev object a bluetooth driver does not have
    any callbacks in the hci_dev structure left over. Therefore, there is no
    need to keep a reference to the module.
    
    Previously, we needed this to protect the hci-destruct callback.
    However, this callback is no longer available so we do not need this
    owner field, anymore.  Drivers now call hci_unregister_dev() and they
    are done with the object.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 935aca8783c4..99984688ccdd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -262,8 +262,6 @@ struct hci_dev {
 
 	struct rfkill		*rfkill;
 
-	struct module		*owner;
-
 	unsigned long		dev_flags;
 
 	int (*open)(struct hci_dev *hdev);
@@ -601,11 +599,7 @@ static inline void __hci_dev_put(struct hci_dev *d)
  * hci_dev_put and hci_dev_hold are macros to avoid dragging all the
  * overhead of all the modular infrastructure into this header.
  */
-#define hci_dev_put(d)		\
-do {				\
-	__hci_dev_put(d);	\
-	module_put(d->owner);	\
-} while (0)
+#define hci_dev_put(d) __hci_dev_put(d)
 
 static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 {
@@ -613,10 +607,7 @@ static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 	return d;
 }
 
-#define hci_dev_hold(d)						\
-({								\
-	try_module_get(d->owner) ? __hci_dev_hold(d) : NULL;	\
-})
+#define hci_dev_hold(d) __hci_dev_hold(d)
 
 #define hci_dev_lock(d)		mutex_lock(&d->lock)
 #define hci_dev_unlock(d)	mutex_unlock(&d->lock)

commit 587ae086f6e44c3f1d313e3efdfc8c2866784bc3
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Jan 7 15:47:20 2012 +0100

    Bluetooth: Remove unused hci-destruct cb
    
    The hci-destruct callback is not used by any driver so we can remove it.
    There is no reason to keep it alive, anymore. Drivers can free their
    internal data on driver-release and we do not need to provide a public
    destruct callback.
    
    Internally, we still use a destruct callback inside of hci_sysfs.c. This
    one is used to correctly free our hci_dev data structure if no more
    users have a reference to it.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 86c74cc563ff..935aca8783c4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -270,7 +270,6 @@ struct hci_dev {
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);
 	int (*send)(struct sk_buff *skb);
-	void (*destruct)(struct hci_dev *hdev);
 	void (*notify)(struct hci_dev *hdev, unsigned int evt);
 	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
 };
@@ -595,10 +594,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 /* ----- HCI Devices ----- */
 static inline void __hci_dev_put(struct hci_dev *d)
 {
-	if (atomic_dec_and_test(&d->refcnt)) {
-		if (d->destruct)
-			d->destruct(d);
-	}
+	atomic_dec(&d->refcnt);
 }
 
 /*

commit 010666a126fce7b9ecdda7209c558db21d771c56
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Jan 7 15:47:07 2012 +0100

    Bluetooth: Make hci-destruct callback optional
    
    Several drivers already provide an empty callback so we can actually
    make this optional and then remove all those empty callbacks in the
    drivers.
    
    This callback isn't needed at all by most drivers as they can remove
    their allocated structures on device disconnect and not on hci
    destruction.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 25a6c3fd7d1a..86c74cc563ff 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -595,8 +595,10 @@ static inline void hci_conn_put(struct hci_conn *conn)
 /* ----- HCI Devices ----- */
 static inline void __hci_dev_put(struct hci_dev *d)
 {
-	if (atomic_dec_and_test(&d->refcnt))
-		d->destruct(d);
+	if (atomic_dec_and_test(&d->refcnt)) {
+		if (d->destruct)
+			d->destruct(d);
+	}
 }
 
 /*

commit 1931782b67bd1b81007022e8311669c40bb7d5b1
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Wed Jan 4 11:57:17 2012 -0300

    Bluetooth: Fix using an absolute timeout on hci_conn_put()
    
    queue_delayed_work() expects a relative time for when that work
    should be scheduled.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a8680da7f400..25a6c3fd7d1a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -588,7 +588,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 		}
 		cancel_delayed_work_sync(&conn->disc_work);
 		queue_delayed_work(conn->hdev->workqueue,
-					&conn->disc_work, jiffies + timeo);
+					&conn->disc_work, timeo);
 	}
 }
 

commit 30dc78e1a2bcbe2a0fca7aa44dfded4bb0db6148
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 4 15:44:20 2012 +0200

    Bluetooth: Add name resolving support for mgmt based discovery
    
    This patch adds the necessary logic to perform name lookups after
    inquiry completes. This is done by checking for entries in the resolve
    list after each inquiry complete and remote name complete HCI event.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2f19de4770b6..a8680da7f400 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -60,7 +60,8 @@ struct discovery_state {
 	enum {
 		DISCOVERY_STOPPED,
 		DISCOVERY_STARTING,
-		DISCOVERY_ACTIVE,
+		DISCOVERY_INQUIRY,
+		DISCOVERY_RESOLVING,
 		DISCOVERY_STOPPING,
 	} state;
 	struct list_head all;		/* All devices found during inquiry */
@@ -371,6 +372,8 @@ static inline void discovery_init(struct hci_dev *hdev)
 	INIT_LIST_HEAD(&hdev->discovery.resolve);
 }
 
+bool hci_discovery_active(struct hci_dev *hdev);
+
 void hci_discovery_set_state(struct hci_dev *hdev, int state);
 
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
@@ -393,6 +396,9 @@ struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
 							bdaddr_t *bdaddr);
 struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
 							bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup_resolve(struct hci_dev *hdev,
+							bdaddr_t *bdaddr,
+							int state);
 bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
 							bool name_known);
 

commit ff9ef5787046c3fd20cf9f7ca1cd70260c1eedb9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 4 14:23:45 2012 +0200

    Bluetooth: Add discovery state tracking
    
    This patch adds proper state tracking to the device discovery process.
    This makes it possible to return appropriate errors when trying to stop
    a non-active discovery or start discovery when it is already ongoing.
    Once name resolving is implemented this also makes it possible to know
    what the right action to do is when a remote name lookup is cancelled.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5a566fd5e2a6..2f19de4770b6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -57,6 +57,12 @@ struct inquiry_entry {
 };
 
 struct discovery_state {
+	enum {
+		DISCOVERY_STOPPED,
+		DISCOVERY_STARTING,
+		DISCOVERY_ACTIVE,
+		DISCOVERY_STOPPING,
+	} state;
 	struct list_head all;		/* All devices found during inquiry */
 	struct list_head unknown;	/* Name state not known */
 	struct list_head resolve;	/* Name needs to be resolved */
@@ -359,11 +365,14 @@ extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 static inline void discovery_init(struct hci_dev *hdev)
 {
+	hdev->discovery.state = DISCOVERY_STOPPED;
 	INIT_LIST_HEAD(&hdev->discovery.all);
 	INIT_LIST_HEAD(&hdev->discovery.unknown);
 	INIT_LIST_HEAD(&hdev->discovery.resolve);
 }
 
+void hci_discovery_set_state(struct hci_dev *hdev, int state);
+
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
 	return list_empty(&hdev->discovery.all);

commit 30883512be0839349d29c7b0bc31016e0498cf8c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 4 14:16:21 2012 +0200

    Bluetooth: Rename hdev->inq_cache to hdev->discovery
    
    This struct is used for not just inquiry caching but also for general
    device discovery state tracking so it's better to rename it to something
    more appropriate.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 236f7f0e596e..5a566fd5e2a6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -56,7 +56,7 @@ struct inquiry_entry {
 	struct inquiry_data	data;
 };
 
-struct inquiry_cache {
+struct discovery_state {
 	struct list_head all;		/* All devices found during inquiry */
 	struct list_head unknown;	/* Name state not known */
 	struct list_head resolve;	/* Name needs to be resolved */
@@ -226,7 +226,7 @@ struct hci_dev {
 
 	struct list_head	mgmt_pending;
 
-	struct inquiry_cache	inq_cache;
+	struct discovery_state	discovery;
 	struct hci_conn_hash	conn_hash;
 	struct list_head	blacklist;
 
@@ -357,21 +357,21 @@ extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
 #define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
 
-static inline void inquiry_cache_init(struct hci_dev *hdev)
+static inline void discovery_init(struct hci_dev *hdev)
 {
-	INIT_LIST_HEAD(&hdev->inq_cache.all);
-	INIT_LIST_HEAD(&hdev->inq_cache.unknown);
-	INIT_LIST_HEAD(&hdev->inq_cache.resolve);
+	INIT_LIST_HEAD(&hdev->discovery.all);
+	INIT_LIST_HEAD(&hdev->discovery.unknown);
+	INIT_LIST_HEAD(&hdev->discovery.resolve);
 }
 
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
-	return list_empty(&hdev->inq_cache.all);
+	return list_empty(&hdev->discovery.all);
 }
 
 static inline long inquiry_cache_age(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
+	struct discovery_state *c = &hdev->discovery;
 	return jiffies - c->timestamp;
 }
 

commit 3175405b906a85ed2bad21e09c444266e4a05a8e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 4 13:39:52 2012 +0200

    Bluetooth: Return updated name state with hci_inquiry_cache_update
    
    If user-space has already confirmed the name for a remote device we
    shouldn't request confirmation again. The simplest way to do this is to
    return the name state from hci_inquiry_cache_update (if it is anything
    else than unknown then we do not need confirmation from user-space).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2999b6e2c3f0..236f7f0e596e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -384,7 +384,7 @@ struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
 							bdaddr_t *bdaddr);
 struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
 							bdaddr_t *bdaddr);
-void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+bool hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
 							bool name_known);
 
 /* ----- HCI Connections ----- */

commit 561aafbcb2e3f8fee11d3781f866c7b4c4f93a28
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 4 13:31:59 2012 +0200

    Bluetooth: Add initial mgmt_confirm_name support
    
    This patch adds initial support for mgmt_confirm_name. It adds the
    necessary tracking of the name state by extending the inquiry cache. The
    actual name resolving operation (to be done once inquiry is finished) is
    not yet part of this patch.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 91d1baf05077..2999b6e2c3f0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -44,14 +44,23 @@ struct inquiry_data {
 };
 
 struct inquiry_entry {
-	struct list_head	list;
+	struct list_head	all;		/* inq_cache.all */
+	struct list_head	list;		/* unknown or resolve */
+	enum {
+		NAME_NOT_KNOWN,
+		NAME_NEEDED,
+		NAME_PENDING,
+		NAME_KNOWN,
+	} name_state;
 	__u32			timestamp;
 	struct inquiry_data	data;
 };
 
 struct inquiry_cache {
-	struct list_head	list;
-	__u32			timestamp;
+	struct list_head all;		/* All devices found during inquiry */
+	struct list_head unknown;	/* Name state not known */
+	struct list_head resolve;	/* Name needs to be resolved */
+	__u32		timestamp;
 };
 
 struct hci_conn_hash {
@@ -350,12 +359,14 @@ extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 static inline void inquiry_cache_init(struct hci_dev *hdev)
 {
-	INIT_LIST_HEAD(&hdev->inq_cache.list);
+	INIT_LIST_HEAD(&hdev->inq_cache.all);
+	INIT_LIST_HEAD(&hdev->inq_cache.unknown);
+	INIT_LIST_HEAD(&hdev->inq_cache.resolve);
 }
 
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
-	return list_empty(&hdev->inq_cache.list);
+	return list_empty(&hdev->inq_cache.all);
 }
 
 static inline long inquiry_cache_age(struct hci_dev *hdev)
@@ -371,7 +382,10 @@ static inline long inquiry_entry_age(struct inquiry_entry *e)
 
 struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
 							bdaddr_t *bdaddr);
-void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
+struct inquiry_entry *hci_inquiry_cache_lookup_unknown(struct hci_dev *hdev,
+							bdaddr_t *bdaddr);
+void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data,
+							bool name_known);
 
 /* ----- HCI Connections ----- */
 enum {
@@ -913,7 +927,8 @@ int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
-				u8 addr_type, u8 *dev_class, s8 rssi, u8 *eir);
+					u8 addr_type, u8 *dev_class, s8 rssi,
+					u8 cfm_name, u8 *eir);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);

commit b57c1a5646739bfc273245dc738f2f12a2d4d3ec
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jan 3 16:03:00 2012 +0200

    Bluetooth: Convert inquiry cache to use standard list types
    
    This makes it possible to use the convenience functions provided for
    standard kernel list types and it also makes it easier to extend the use
    of the cache for the management interface where e.g. name resolving
    control will be needed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ea9231f4935f..91d1baf05077 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -44,14 +44,14 @@ struct inquiry_data {
 };
 
 struct inquiry_entry {
-	struct inquiry_entry	*next;
+	struct list_head	list;
 	__u32			timestamp;
 	struct inquiry_data	data;
 };
 
 struct inquiry_cache {
+	struct list_head	list;
 	__u32			timestamp;
-	struct inquiry_entry	*list;
 };
 
 struct hci_conn_hash {
@@ -350,14 +350,12 @@ extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 
 static inline void inquiry_cache_init(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
-	c->list = NULL;
+	INIT_LIST_HEAD(&hdev->inq_cache.list);
 }
 
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
-	struct inquiry_cache *c = &hdev->inq_cache;
-	return c->list == NULL;
+	return list_empty(&hdev->inq_cache.list);
 }
 
 static inline long inquiry_cache_age(struct hci_dev *hdev)

commit 59e294065ddee7074af91e4f5e12e6095eb1135b
Author: Andre Guedes <aguedespe@gmail.com>
Date:   Fri Dec 30 10:34:03 2011 -0300

    Bluetooth: Rename extfeatures
    
    This patch renames hdev->extfeatures to hdev->host_features since it
    holds the extended features Page 1 (aka host features).
    
    Signed-off-by: Andre Guedes <aguedespe@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5e2e98458496..ea9231f4935f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -127,7 +127,7 @@ struct hci_dev {
 	__u8		major_class;
 	__u8		minor_class;
 	__u8		features[8];
-	__u8		extfeatures[8];
+	__u8		host_features[8];
 	__u8		commands[64];
 	__u8		ssp_mode;
 	__u8		hci_ver;
@@ -676,7 +676,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
 
 /* ----- Extended LMP capabilities ----- */
-#define lmp_host_le_capable(dev)   ((dev)->extfeatures[0] & LMP_HOST_LE)
+#define lmp_host_le_capable(dev)   ((dev)->host_features[0] & LMP_HOST_LE)
 
 /* ----- HCI protocols ----- */
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,

commit f20d09d5f7093e5dc5f231c65835e2d04739bd5e
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Thu Dec 22 16:30:27 2011 -0200

    Bluetooth: remove *_bh usage from hci_dev_list and hci_cb_list
    
    They don't need to disable interrupts anymore, we only run in process
    context now.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 37d7cb8be480..5e2e98458496 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -801,13 +801,13 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
@@ -823,26 +823,26 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->security_cfm)
 			cb->security_cfm(conn, status, encrypt);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct list_head *p;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->key_change_cfm)
 			cb->key_change_cfm(conn, status);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
 static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
@@ -850,13 +850,13 @@ static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
 {
 	struct list_head *p;
 
-	read_lock_bh(&hci_cb_list_lock);
+	read_lock(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
 		if (cb->role_switch_cfm)
 			cb->role_switch_cfm(conn, status, role);
 	}
-	read_unlock_bh(&hci_cb_list_lock);
+	read_unlock(&hci_cb_list_lock);
 }
 
 int hci_register_cb(struct hci_cb *hcb);

commit 460da45d92f19adda1b79910652d5a23c65dd272
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Thu Dec 22 16:15:42 2011 -0200

    Bluetooth: Remove lock from inquiry_cache
    
    It was never used, so removing it.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4ff08d61eea5..37d7cb8be480 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -50,7 +50,6 @@ struct inquiry_entry {
 };
 
 struct inquiry_cache {
-	spinlock_t		lock;
 	__u32			timestamp;
 	struct inquiry_entry	*list;
 };
@@ -349,15 +348,9 @@ extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
 #define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
 
-#define inquiry_cache_lock(c)		spin_lock(&c->lock)
-#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
-#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
-#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
-
 static inline void inquiry_cache_init(struct hci_dev *hdev)
 {
 	struct inquiry_cache *c = &hdev->inq_cache;
-	spin_lock_init(&c->lock);
 	c->list = NULL;
 }
 

commit 2b64d153a0cc9d2b60e47be013cde8490f16e0a5
Author: Brian Gix <bgix@codeaurora.org>
Date:   Wed Dec 21 16:12:12 2011 -0800

    Bluetooth: Add MITM mechanism to LE-SMP
    
    To achive Man-In-The-Middle (MITM) level security with Low Energy,
    we have to enable User Passkey Comparison.  This commit modifies the
    hard-coded JUST-WORKS pairing mechanism to support query via the MGMT
    interface of Passkey comparison and User Confirmation.
    
    Signed-off-by: Brian Gix <bgix@codeaurora.org>
    Acked-by: Marcel Holtmann<marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5ce73dbaf604..4ff08d61eea5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -310,6 +310,7 @@ struct hci_conn {
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
+	void		*smp_conn;
 
 	struct hci_conn	*link;
 

commit 686ebf283ba19f82abd8aaec023cd124749be9ec
Author: Ulisses Furquim <ulisses@profusion.mobi>
Date:   Wed Dec 21 10:11:33 2011 -0200

    Bluetooth: Make HCI call directly into SCO and L2CAP event functions
    
    The struct hci_proto and all related register/unregister and dispatching
    code was removed. HCI core code now call directly the SCO and L2CAP
    event functions.
    
    Signed-off-by: Ulisses Furquim <ulisses@profusion.mobi>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 25c161ab6803..5ce73dbaf604 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -28,10 +28,6 @@
 #include <linux/interrupt.h>
 #include <net/bluetooth/hci.h>
 
-/* HCI upper protocols */
-#define HCI_PROTO_L2CAP	0
-#define HCI_PROTO_SCO	1
-
 /* HCI priority */
 #define HCI_PRIO_MAX	7
 
@@ -330,12 +326,24 @@ struct hci_chan {
 	unsigned int	sent;
 };
 
-extern struct hci_proto *hci_proto[];
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
 extern rwlock_t hci_dev_list_lock;
 extern rwlock_t hci_cb_list_lock;
 
+/* ----- HCI interface to upper protocols ----- */
+extern int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int l2cap_connect_cfm(struct hci_conn *hcon, u8 status);
+extern int l2cap_disconn_ind(struct hci_conn *hcon);
+extern int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason);
+extern int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt);
+extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags);
+
+extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
+extern int sco_connect_cfm(struct hci_conn *hcon, __u8 status);
+extern int sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);
+extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);
+
 /* ----- Inquiry cache ----- */
 #define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
 #define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
@@ -677,53 +685,40 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_host_le_capable(dev)   ((dev)->extfeatures[0] & LMP_HOST_LE)
 
 /* ----- HCI protocols ----- */
-struct hci_proto {
-	char		*name;
-	unsigned int	id;
-	unsigned long	flags;
-
-	void		*priv;
-
-	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr,
-								__u8 type);
-	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
-	int (*disconn_ind)	(struct hci_conn *conn);
-	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason);
-	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb,
-								__u16 flags);
-	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*security_cfm)	(struct hci_conn *conn, __u8 status,
-								__u8 encrypt);
-};
-
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
 								__u8 type)
 {
-	register struct hci_proto *hp;
-	int mask = 0;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->connect_ind)
-		mask |= hp->connect_ind(hdev, bdaddr, type);
+	switch (type) {
+	case ACL_LINK:
+		return l2cap_connect_ind(hdev, bdaddr);
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->connect_ind)
-		mask |= hp->connect_ind(hdev, bdaddr, type);
+	case SCO_LINK:
+	case ESCO_LINK:
+		return sco_connect_ind(hdev, bdaddr);
 
-	return mask;
+	default:
+		BT_ERR("unknown link type %d", type);
+		return -EINVAL;
+	}
 }
 
 static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 {
-	register struct hci_proto *hp;
+	switch (conn->type) {
+	case ACL_LINK:
+	case LE_LINK:
+		l2cap_connect_cfm(conn, status);
+		break;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->connect_cfm)
-		hp->connect_cfm(conn, status);
+	case SCO_LINK:
+	case ESCO_LINK:
+		sco_connect_cfm(conn, status);
+		break;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->connect_cfm)
-		hp->connect_cfm(conn, status);
+	default:
+		BT_ERR("unknown link type %d", conn->type);
+		break;
+	}
 
 	if (conn->connect_cfm_cb)
 		conn->connect_cfm_cb(conn, status);
@@ -731,31 +726,29 @@ static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
-	register struct hci_proto *hp;
-	int reason = HCI_ERROR_REMOTE_USER_TERM;
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return HCI_ERROR_REMOTE_USER_TERM;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->disconn_ind)
-		reason = hp->disconn_ind(conn);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->disconn_ind)
-		reason = hp->disconn_ind(conn);
-
-	return reason;
+	return l2cap_disconn_ind(conn);
 }
 
 static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 {
-	register struct hci_proto *hp;
+	switch (conn->type) {
+	case ACL_LINK:
+	case LE_LINK:
+		l2cap_disconn_cfm(conn, reason);
+		break;
 
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason);
+	case SCO_LINK:
+	case ESCO_LINK:
+		sco_disconn_cfm(conn, reason);
+		break;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->disconn_cfm)
-		hp->disconn_cfm(conn, reason);
+	default:
+		BT_ERR("unknown link type %d", conn->type);
+		break;
+	}
 
 	if (conn->disconn_cfm_cb)
 		conn->disconn_cfm_cb(conn, reason);
@@ -763,21 +756,16 @@ static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 {
-	register struct hci_proto *hp;
 	__u8 encrypt;
 
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return;
+
 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return;
 
 	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
-
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
@@ -786,23 +774,15 @@ static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
 								__u8 encrypt)
 {
-	register struct hci_proto *hp;
-
-	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	if (conn->type != ACL_LINK && conn->type != LE_LINK)
+		return;
 
-	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->security_cfm)
-		hp->security_cfm(conn, status, encrypt);
+	l2cap_security_cfm(conn, status, encrypt);
 
 	if (conn->security_cfm_cb)
 		conn->security_cfm_cb(conn, status);
 }
 
-int hci_register_proto(struct hci_proto *hproto);
-int hci_unregister_proto(struct hci_proto *hproto);
-
 /* ----- HCI callbacks ----- */
 struct hci_cb {
 	struct list_head list;

commit 9662cbc712babe3f7a792af2bdd47fa0c631f27f
Merge: 640f5950a7d9 4b0b2f088f12
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Dec 19 14:28:22 2011 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/padovan/bluetooth-next

commit 350ee4cfc0ea620bd1126ad4daa295586d6aa3a9
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Dec 7 15:56:51 2011 +0200

    Bluetooth: Add HCI Read Data Block Size function
    
    Implement block size read function. Use different variables for
    packet-based and block-based flow control.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 105eaa251034..74f8356b9ff1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -181,6 +181,11 @@ struct hci_dev {
 	unsigned int	sco_pkts;
 	unsigned int	le_pkts;
 
+	__u16		block_len;
+	__u16		block_mtu;
+	__u16		num_blocks;
+	__u16		block_cnt;
+
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
 	unsigned long	le_last_tx;

commit 7d78525dcf5c6fe5e6e73d22776ed5f960e3153e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Dec 15 00:47:39 2011 +0200

    Bluetooth: Add timer for automatically disabling the service cache
    
    We do not want the service cache to be enabled indefinitely after
    mgmt_read_info is called. To solve this a timer is added which will
    automatically disable the cache if mgmt_set_dev_class isn't called
    within 5 seconds of calling mgmt_read_info.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cc17f739dfff..105eaa251034 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -193,6 +193,8 @@ struct hci_dev {
 	__u16			discov_timeout;
 	struct delayed_work	discov_off;
 
+	struct delayed_work	service_cache;
+
 	struct timer_list	cmd_timer;
 
 	struct work_struct	rx_work;

commit 14c0b60829751135346d71e7d11649c4f72dc9af
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Dec 15 00:47:37 2011 +0200

    Bluetooth: Remove mgmt_set_service_cache
    
    Instead of having an explicit service cache command we can make the mgmt
    API simpler by implicitly enabling the cache when mgmt_read_info is
    called for the first time and disabling it when mgmt_set_dev_class is
    called.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 72f84d6d4d3a..cc17f739dfff 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -943,12 +943,16 @@ int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
 
+/* HCI socket flags */
+#define HCI_PI_MGMT_INIT	0
+
 struct hci_pinfo {
 	struct bt_sock    bt;
 	struct hci_dev    *hdev;
 	struct hci_filter filter;
 	__u32             cmsg_mask;
 	unsigned short   channel;
+	unsigned long     flags;
 };
 
 /* HCI security filter */

commit 6d438e335ce83ff0528415a58632dc6508e4fde1
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Sat Dec 17 18:53:02 2011 -0200

    Bluetooth: Remove work_add and work_del from hci_sysfs
    
    As we run in process context now we don't need worqueue to add e del from
    sysfs.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5d1bb51c43c3..72f84d6d4d3a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -301,9 +301,6 @@ struct hci_conn {
 	struct timer_list idle_timer;
 	struct timer_list auto_accept_timer;
 
-	struct work_struct work_add;
-	struct work_struct work_del;
-
 	struct device	dev;
 	atomic_t	devref;
 

commit 3eff45eaf81780dad25c167bbaafa7d25ae407da
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Thu Dec 15 00:50:02 2011 -0200

    Bluetooth: convert tx_task to workqueue
    
    This should simplify Bluetooth core processing a lot.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 051fd7fd2992..5d1bb51c43c3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -197,7 +197,7 @@ struct hci_dev {
 
 	struct work_struct	rx_work;
 	struct work_struct	cmd_work;
-	struct tasklet_struct	tx_task;
+	struct work_struct	tx_work;
 
 	struct sk_buff_head	rx_q;
 	struct sk_buff_head	raw_q;

commit c347b765fe70d718c721cd6d0b979cfbaed83125
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 23:53:47 2011 -0200

    Bluetooth: Move command task to workqueue
    
    As part of the moving on all the Bluetooth processing to Process context.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e83243318924..051fd7fd2992 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -196,7 +196,7 @@ struct hci_dev {
 	struct timer_list	cmd_timer;
 
 	struct work_struct	rx_work;
-	struct tasklet_struct	cmd_task;
+	struct work_struct	cmd_work;
 	struct tasklet_struct	tx_task;
 
 	struct sk_buff_head	rx_q;

commit bf4c63252490ba78fb833cc7acf1a5b1900c970f
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 22:54:12 2011 -0200

    Bluetooth: convert conn hash to RCU
    
    Handling hci_conn_hash with RCU make us avoid some locking and disable
    tasklets.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 14b200b08d84..e83243318924 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -392,7 +392,7 @@ static inline void hci_conn_hash_init(struct hci_dev *hdev)
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_add(&c->list, &h->list);
+	list_add_rcu(&c->list, &h->list);
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num++;
@@ -410,7 +410,10 @@ static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	list_del(&c->list);
+
+	list_del_rcu(&c->list);
+	synchronize_rcu();
+
 	switch (c->type) {
 	case ACL_LINK:
 		h->acl_num--;
@@ -445,14 +448,18 @@ static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->handle == handle)
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->handle == handle) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
+	rcu_read_unlock();
+
 	return NULL;
 }
 
@@ -460,14 +467,19 @@ static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 							__u8 type, bdaddr_t *ba)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == type && !bacmp(&c->dst, ba))
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == type && !bacmp(&c->dst, ba)) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
+
+	rcu_read_unlock();
+
 	return NULL;
 }
 
@@ -475,14 +487,19 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 							__u8 type, __u16 state)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
 	struct hci_conn  *c;
 
-	list_for_each(p, &h->list) {
-		c = list_entry(p, struct hci_conn, list);
-		if (c->type == type && c->state == state)
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(c, &h->list, list) {
+		if (c->type == type && c->state == state) {
+			rcu_read_unlock();
 			return c;
+		}
 	}
+
+	rcu_read_unlock();
+
 	return NULL;
 }
 

commit db323f2fff0ded058f033df6235e8c2be4146bfd
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Mon Jun 20 16:39:29 2011 -0300

    Bluetooth: Use delayed work for advertisiment cache timeout
    
    As HCI rx path is now done in process context it makes sense to do all the
    timer in process context as well.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d91590850429..14b200b08d84 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -226,7 +226,7 @@ struct hci_dev {
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
-	struct timer_list	adv_timer;
+	struct delayed_work	adv_work;
 
 	struct hci_dev_stats	stat;
 

commit 19c40e3bcaf2d969f5d4ee85bbe1330b54d36d9c
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Fri Jun 17 13:03:21 2011 -0300

    Bluetooth: Use delayed_work for connection timeout
    
    Bluetooth rx task runs now in a workqueue, so it a good approach run any
    timer that share locking with process context code also in a workqueue.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e7dbe597a4bb..d91590850429 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -297,7 +297,7 @@ struct hci_conn {
 	struct sk_buff_head data_q;
 	struct list_head chan_list;
 
-	struct timer_list disc_timer;
+	struct delayed_work disc_work;
 	struct timer_list idle_timer;
 	struct timer_list auto_accept_timer;
 
@@ -517,7 +517,7 @@ void hci_conn_put_device(struct hci_conn *conn);
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
-	del_timer(&conn->disc_timer);
+	cancel_delayed_work_sync(&conn->disc_work);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
@@ -536,7 +536,9 @@ static inline void hci_conn_put(struct hci_conn *conn)
 		} else {
 			timeo = msecs_to_jiffies(10);
 		}
-		mod_timer(&conn->disc_timer, jiffies + timeo);
+		cancel_delayed_work_sync(&conn->disc_work);
+		queue_delayed_work(conn->hdev->workqueue,
+					&conn->disc_work, jiffies + timeo);
 	}
 }
 

commit 09fd0de5bd8f8ef3317e5365f92f1a13dcd89aa9
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Fri Jun 17 13:03:21 2011 -0300

    Bluetooth: Replace spin_lock by mutex in hci_dev
    
    Now we run everything in HCI in process context, so it's a better idea use
    mutex instead spin_lock. The macro remains hci_dev_lock() (and I got rid
    of hci_dev_lock_bh()), of course.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1e28be45c4f2..e7dbe597a4bb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -117,7 +117,7 @@ struct adv_entry {
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
-	spinlock_t	lock;
+	struct mutex	lock;
 	atomic_t	refcnt;
 
 	char		name[8];
@@ -566,10 +566,8 @@ static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
 	return NULL;
 }
 
-#define hci_dev_lock(d)		spin_lock(&d->lock)
-#define hci_dev_unlock(d)	spin_unlock(&d->lock)
-#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
-#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
+#define hci_dev_lock(d)		mutex_lock(&d->lock)
+#define hci_dev_unlock(d)	mutex_unlock(&d->lock)
 
 struct hci_dev *hci_dev_get(int index);
 struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);

commit b78752cc71d86998d3b77d873c61d6ffdb7a2142
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Aug 8 23:06:53 2010 -0400

    Bluetooth: Process recv path in a workqueue instead of a tasklet
    
    Run recv process in workqueue helps a lot with our processing as the recv
    path will also be in the process context, i.e., now all our tx and rx are
    in process context.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6a1ac2c2489c..1e28be45c4f2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -194,8 +194,9 @@ struct hci_dev {
 	struct delayed_work	discov_off;
 
 	struct timer_list	cmd_timer;
+
+	struct work_struct	rx_work;
 	struct tasklet_struct	cmd_task;
-	struct tasklet_struct	rx_task;
 	struct tasklet_struct	tx_task;
 
 	struct sk_buff_head	rx_q;

commit 416dc94baa4a0de6904707d17522f7eae7778c8e
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 7 13:24:33 2011 -0200

    Bluetooth: make hci_conn_enter_sniff_mode static
    
    It isn't used outside hci_conn.c
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8e33c66eac73..6a1ac2c2489c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -509,7 +509,6 @@ int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
-void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
 void hci_conn_hold_device(struct hci_conn *conn);
 void hci_conn_put_device(struct hci_conn *conn);

commit dc8ed672caaab054caf62557e46dfed08848a85f
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 20:56:12 2011 -0200

    Bluetooth: Initialize LE connection count
    
    le_num needs to be set to zero.
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7f815c075711..8e33c66eac73 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -385,6 +385,7 @@ static inline void hci_conn_hash_init(struct hci_dev *hdev)
 	INIT_LIST_HEAD(&h->list);
 	h->acl_num = 0;
 	h->sco_num = 0;
+	h->le_num = 0;
 }
 
 static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)

commit 01e2821fbee26267941cdcd5b4f74d2c499f2daa
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 15:10:41 2011 -0200

    Bluetooth: remove lock from struct conn_hash
    
    It isn't used anywhere.
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fb2cce2b633f..7f815c075711 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -61,7 +61,6 @@ struct inquiry_cache {
 
 struct hci_conn_hash {
 	struct list_head list;
-	spinlock_t       lock;
 	unsigned int     acl_num;
 	unsigned int     sco_num;
 	unsigned int     le_num;

commit 2c33c06a8fd2f784ca763ad150d5d63c3c49946e
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 13:02:51 2011 -0200

    Bluetooth: remove struct hci_chan_hash
    
    Only the list member of the struct was used, so we now fold it into
    hci_conn.
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e34cd71a586e..fb2cce2b633f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -67,12 +67,6 @@ struct hci_conn_hash {
 	unsigned int     le_num;
 };
 
-struct hci_chan_hash {
-	struct list_head list;
-	spinlock_t       lock;
-	unsigned int     num;
-};
-
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -301,7 +295,7 @@ struct hci_conn {
 	unsigned int	sent;
 
 	struct sk_buff_head data_q;
-	struct hci_chan_hash chan_hash;
+	struct list_head chan_list;
 
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
@@ -390,7 +384,6 @@ static inline void hci_conn_hash_init(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	INIT_LIST_HEAD(&h->list);
-	spin_lock_init(&h->lock);
 	h->acl_num = 0;
 	h->sco_num = 0;
 }
@@ -492,28 +485,6 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 	return NULL;
 }
 
-static inline void hci_chan_hash_init(struct hci_conn *c)
-{
-	struct hci_chan_hash *h = &c->chan_hash;
-	INIT_LIST_HEAD(&h->list);
-	spin_lock_init(&h->lock);
-	h->num = 0;
-}
-
-static inline void hci_chan_hash_add(struct hci_conn *c, struct hci_chan *chan)
-{
-	struct hci_chan_hash *h = &c->chan_hash;
-	list_add(&chan->list, &h->list);
-	h->num++;
-}
-
-static inline void hci_chan_hash_del(struct hci_conn *c, struct hci_chan *chan)
-{
-	struct hci_chan_hash *h = &c->chan_hash;
-	list_del(&chan->list);
-	h->num--;
-}
-
 void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
@@ -527,7 +498,7 @@ void hci_conn_check_pending(struct hci_dev *hdev);
 
 struct hci_chan *hci_chan_create(struct hci_conn *conn);
 int hci_chan_del(struct hci_chan *chan);
-void hci_chan_hash_flush(struct hci_conn *conn);
+void hci_chan_list_flush(struct hci_conn *conn);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 						__u8 sec_level, __u8 auth_type);

commit 5f779bbd472cdb2046ff8b672ad8c5b62b61cd19
Merge: d7a4858c0fde 5a13b0953142
Author: John W. Linville <linville@tuxdriver.com>
Date:   Tue Dec 6 16:02:05 2011 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/padovan/bluetooth-next

commit d23264a896a931c4b355c102d8e9d46649195ba4
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Nov 25 20:53:38 2011 -0300

    Bluetooth: Add dev_flags to struct hci_dev
    
    This patch adds the dev_flags field to struct hci_dev. This new
    flags variable should be used to define flags related to BR/EDR
    and/or LE controller itself. It should be used to define flags
    which represents states from the controller. The dev_flags is
    cleared in case the controller sends a Reset Command Complete
    Event to the host.
    
    Also, this patch adds the HCI_LE_SCAN flag which was created to
    track if the controller is performing LE scan or not. The flag
    is set/cleared when the controller starts/stops scanning.
    
    This is an initial effort to stop using hdev->flags to define
    internal flags since it is exported to userspace by an ioctl.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 44f130f6fb5e..e34cd71a586e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -252,6 +252,8 @@ struct hci_dev {
 
 	struct module		*owner;
 
+	unsigned long		dev_flags;
+
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
 	int (*flush)(struct hci_dev *hdev);

commit 1e89cffb44a94e1937e5ec16125ae866dbba7b2e
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Nov 24 14:52:02 2011 +0200

    Bluetooth: Add HCI Read Flow Control Mode function
    
    Upstream Code Aurora function with minor trivial fixes.
    Origin: git://codeaurora.org/kernel/msm.git
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e7b2e25397d7..44f130f6fb5e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -170,6 +170,8 @@ struct hci_dev {
 	__u32		amp_max_flush_to;
 	__u32		amp_be_flush_to;
 
+	__u8		flow_ctl_mode;
+
 	unsigned int	auto_accept_delay;
 
 	unsigned long	quirks;

commit 604086b73b9b342414a53c0f34dd23aecb005ff8
Author: Brian Gix <bgix@codeaurora.org>
Date:   Wed Nov 23 08:28:33 2011 -0800

    Bluetooth: Add User Passkey Response handling
    
    For some MITM protection pairing scenarios, the user is
    required to enter or accept a 6 digit passkey.
    
    Signed-off-by: Brian Gix <bgix@codeaurora.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1795257f4063..e7b2e25397d7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -933,6 +933,11 @@ int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 								u8 status);
 int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev,
 						bdaddr_t *bdaddr, u8 status);
+int mgmt_user_passkey_request(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int mgmt_user_passkey_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								u8 status);
+int mgmt_user_passkey_neg_reply_complete(struct hci_dev *hdev,
+						bdaddr_t *bdaddr, u8 status);
 int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,

commit 515db09338704a6ad7d27b5f1e33820d3052edd2
Merge: 30be52e44fd4 cfcfc9eca2bc
Author: John W. Linville <linville@tuxdriver.com>
Date:   Tue Nov 22 14:05:46 2011 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux
    
    Conflicts:
            drivers/net/wireless/iwlegacy/iwl-debugfs.c
            drivers/net/wireless/iwlegacy/iwl-rx.c
            drivers/net/wireless/iwlegacy/iwl-scan.c
            drivers/net/wireless/iwlegacy/iwl-tx.c
            include/net/bluetooth/bluetooth.h

commit e6d465cb482935c26cb4065a6ab9ce987c067da3
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Nov 9 17:14:26 2011 -0300

    Bluetooth: mgmt_stop_discovery_failed()
    
    This patches creates mgmt_stop_discovery_failed() which removes
    pending MGMT_OP_STOP_DISCOVERY commands and sends proper command
    status events.
    
    This patch also fixes the MGMT_OP_STOP_DISCOVERY command leak in
    case cancel inquiry fails.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 827bedab6a70..1795257f4063 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -941,6 +941,7 @@ int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 				u8 addr_type, u8 *dev_class, s8 rssi, u8 *eir);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
 int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
+int mgmt_stop_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit 7a13510902c81ad865f6d02aed2f4e053a46050e
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Nov 9 17:14:25 2011 -0300

    Bluetooth: Rename mgmt_inquiry_failed()
    
    This patch renames the function mgmt_inquiry_failed() to
    mgmt_start_discovery_failed(). This function is more related
    to MGMT_OP_START_DISCOVERY command handling than to inquiry.
    Besides, this functions will be reused by LE based discovery
    procedures in case of failure.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a67ff88dcb28..827bedab6a70 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -940,7 +940,7 @@ int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 				u8 addr_type, u8 *dev_class, s8 rssi, u8 *eir);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
-int mgmt_inquiry_failed(struct hci_dev *hdev, u8 status);
+int mgmt_start_discovery_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
 int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);

commit 37d9ef76c26092098e8fbd3fd540b7ac2181e6bf
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Nov 10 15:54:39 2011 +0200

    Bluetooth: Add status parameter to mgmt_disconnect response
    
    Since disconnecting may fail the status needs to be communicated to user
    space. This also updates the implementation to match the latest mgmt API
    specification.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5f401e71584f..a67ff88dcb28 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -919,7 +919,7 @@ int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 								u8 addr_type);
 int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 								u8 addr_type);
-int mgmt_disconnect_failed(struct hci_dev *hdev);
+int mgmt_disconnect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
 int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
 						u8 addr_type, u8 status);
 int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);

commit 48264f06943e2db2c971b752949606f070d9d292
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 9 13:58:58 2011 +0200

    Bluetooth: Add public/random LE address information to mgmt messages
    
    It's necessary to know the distinction between public and random LE
    addresses so the mgmt interface also needs to distinguish between them.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0a5a05d9109c..5f401e71584f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -915,11 +915,13 @@ int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
 int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
 int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
 								u8 persistent);
-int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
-int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+								u8 addr_type);
+int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+								u8 addr_type);
 int mgmt_disconnect_failed(struct hci_dev *hdev);
-int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type,
-								u8 status);
+int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+						u8 addr_type, u8 status);
 int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 								u8 status);
@@ -935,8 +937,8 @@ int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
 int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
 						u8 *randomizer, u8 status);
-int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type,
-					u8 *dev_class, s8 rssi, u8 *eir);
+int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 link_type,
+				u8 addr_type, u8 *dev_class, s8 rssi, u8 *eir);
 int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
 int mgmt_inquiry_failed(struct hci_dev *hdev, u8 status);
 int mgmt_discovering(struct hci_dev *hdev, u8 discovering);

commit 2e58ef3e11d0775795345a20185b5a7c4bdae194
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Nov 8 20:40:15 2011 +0200

    Bluetooth: Move pending management command list into struct hci_dev
    
    This patch moves the pending management command list (previously global
    to mgmt.c) into struct hci_dev. This makes it possible to do proper
    locking when accessing it (through the existing hci_dev locks) and
    thereby avoid race conditions.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0f35a3900e16..0a5a05d9109c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -217,6 +217,8 @@ struct hci_dev {
 
 	__u16			init_last_cmd;
 
+	struct list_head	mgmt_pending;
+
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
 	struct list_head	blacklist;

commit 744cf19eadcf4de914394e0eb227f94f4318f5e4
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Nov 8 20:40:14 2011 +0200

    Bluetooth: Pass full hci_dev struct to mgmt callbacks
    
    The current global pending command list in mgmt.c is racy. Possibly the
    simplest way to fix it is to have per-hci dev lists instead of a global
    one (all commands that need a pending struct are hci_dev specific).
    This way the list can be protected using the already existing per-hci
    dev lock. To enable this refactoring the first thing that needs to be
    done is to ensure that the mgmt functions have access to the hci_dev
    struct (instead of just the dev id).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e6071d0ea20f..0f35a3900e16 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -905,36 +905,41 @@ void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
 
 /* Management interface */
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
-int mgmt_index_added(u16 index);
-int mgmt_index_removed(u16 index);
-int mgmt_powered(u16 index, u8 powered);
-int mgmt_discoverable(u16 index, u8 discoverable);
-int mgmt_connectable(u16 index, u8 connectable);
-int mgmt_write_scan_failed(u16 index, u8 scan, u8 status);
-int mgmt_new_link_key(u16 index, struct link_key *key, u8 persistent);
-int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 type);
-int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 type);
-int mgmt_disconnect_failed(u16 index);
-int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 type, u8 status);
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr, u8 secure);
-int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value,
-							u8 confirm_hint);
-int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
+int mgmt_index_added(struct hci_dev *hdev);
+int mgmt_index_removed(struct hci_dev *hdev);
+int mgmt_powered(struct hci_dev *hdev, u8 powered);
+int mgmt_discoverable(struct hci_dev *hdev, u8 discoverable);
+int mgmt_connectable(struct hci_dev *hdev, u8 connectable);
+int mgmt_write_scan_failed(struct hci_dev *hdev, u8 scan, u8 status);
+int mgmt_new_link_key(struct hci_dev *hdev, struct link_key *key,
+								u8 persistent);
+int mgmt_connected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int mgmt_disconnected(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
+int mgmt_disconnect_failed(struct hci_dev *hdev);
+int mgmt_connect_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type,
 								u8 status);
-int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
-int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
+int mgmt_pin_code_request(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 secure);
+int mgmt_pin_code_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
 								u8 status);
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 *dev_class,
-							s8 rssi, u8 *eir);
-int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
-int mgmt_inquiry_failed(u16 index, u8 status);
-int mgmt_discovering(u16 index, u8 discovering);
-int mgmt_device_blocked(u16 index, bdaddr_t *bdaddr);
-int mgmt_device_unblocked(u16 index, bdaddr_t *bdaddr);
+int mgmt_pin_code_neg_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								u8 status);
+int mgmt_user_confirm_request(struct hci_dev *hdev, bdaddr_t *bdaddr,
+						__le32 value, u8 confirm_hint);
+int mgmt_user_confirm_reply_complete(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								u8 status);
+int mgmt_user_confirm_neg_reply_complete(struct hci_dev *hdev,
+						bdaddr_t *bdaddr, u8 status);
+int mgmt_auth_failed(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 status);
+int mgmt_set_local_name_complete(struct hci_dev *hdev, u8 *name, u8 status);
+int mgmt_read_local_oob_data_reply_complete(struct hci_dev *hdev, u8 *hash,
+						u8 *randomizer, u8 status);
+int mgmt_device_found(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type,
+					u8 *dev_class, s8 rssi, u8 *eir);
+int mgmt_remote_name(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *name);
+int mgmt_inquiry_failed(struct hci_dev *hdev, u8 status);
+int mgmt_discovering(struct hci_dev *hdev, u8 discovering);
+int mgmt_device_blocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int mgmt_device_unblocked(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 4c659c3976e81f9def48993cd00988d53d7379f2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 7 23:13:39 2011 +0200

    Bluetooth: Add address type fields to mgmt messages that need them
    
    This patch adds address type info (typically BR/EDR vs LE) to management
    messages that need this. This also ensures conformance to the latest
    management API specification.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4ebc882385f9..e6071d0ea20f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -912,10 +912,10 @@ int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
 int mgmt_write_scan_failed(u16 index, u8 scan, u8 status);
 int mgmt_new_link_key(u16 index, struct link_key *key, u8 persistent);
-int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 link_type);
-int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
+int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 type);
+int mgmt_disconnected(u16 index, bdaddr_t *bdaddr, u8 type);
 int mgmt_disconnect_failed(u16 index);
-int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 type, u8 status);
 int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
@@ -928,8 +928,8 @@ int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 								u8 status);
-int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
-								u8 *eir);
+int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 type, u8 *dev_class,
+							s8 rssi, u8 *eir);
 int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
 int mgmt_inquiry_failed(u16 index, u8 status);
 int mgmt_discovering(u16 index, u8 discovering);

commit 86742e1eca319069490f6f20c2892baafc2a6922
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 7 23:13:38 2011 +0200

    Bluetooth: Update link key mgmt APIs to match latest spec.
    
    BR/EDR link keys have their own commands and events (separate from SMP)
    and the remove_keys command (previously remove_key) removes keys of any
    kind for the specified remote address.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bca53aa754e3..4ebc882385f9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -911,7 +911,7 @@ int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
 int mgmt_write_scan_failed(u16 index, u8 scan, u8 status);
-int mgmt_new_key(u16 index, struct link_key *key, u8 persistent);
+int mgmt_new_link_key(u16 index, struct link_key *key, u8 persistent);
 int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 link_type);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);

commit 3243553fdc108a0ef49b9e25bdea9c87b341413e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 7 22:16:04 2011 +0200

    Bluetooth: Convert power off mechanism to use delayed_work
    
    The power off code doesn't need to use its own custom timer since the
    delayed_work API provides the exact same functionality.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c233bceb3ccc..bca53aa754e3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -193,8 +193,7 @@ struct hci_dev {
 	struct workqueue_struct	*workqueue;
 
 	struct work_struct	power_on;
-	struct work_struct	power_off;
-	struct timer_list	off_timer;
+	struct delayed_work	power_off;
 
 	__u16			discov_timeout;
 	struct delayed_work	discov_off;

commit 2d7cee5836d6d466829b255b1290c9386d4e884f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 7 22:16:03 2011 +0200

    Bluetooth: Fix mgmt response when HCI_Write_Scan_Enable fails
    
    A proper mgmt_command_status should be returned to user-space if either
    discoverable or connectable enabling fails.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5803c1ebcefa..c233bceb3ccc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -911,6 +911,7 @@ int mgmt_index_removed(u16 index);
 int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
+int mgmt_write_scan_failed(u16 index, u8 scan, u8 status);
 int mgmt_new_key(u16 index, struct link_key *key, u8 persistent);
 int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 link_type);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);

commit 16ab91ab48287aa4fc757f3618820f728ee4412f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Nov 7 22:16:02 2011 +0200

    Bluetooth: Add timeout field to mgmt_set_discoverable
    
    Based on the revised mgmt API set_discoverable has a timeout parameter
    to specify how long the adapter will remain discoverable. A value of 0
    means "indefinitively".
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 20db034390b7..5803c1ebcefa 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -196,6 +196,9 @@ struct hci_dev {
 	struct work_struct	power_off;
 	struct timer_list	off_timer;
 
+	__u16			discov_timeout;
+	struct delayed_work	discov_off;
+
 	struct timer_list	cmd_timer;
 	struct tasklet_struct	cmd_task;
 	struct tasklet_struct	rx_task;

commit 023d50498d04c77b73eed11d849e436ef5639ed2
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Nov 4 14:16:52 2011 -0300

    Bluetooth: Create hci_cancel_inquiry()
    
    This patch adds a function to hci_core to cancel an ongoing inquiry.
    
    According to the Bluetooth spec, the inquiry cancel command should
    only be issued after the inquiry command has been issued, a command
    status event has been received for the inquiry command, and before
    the inquiry complete event occurs.
    
    As HCI_INQUIRY flag is only set just after an inquiry command status
    event occurs and it is cleared just after an inquiry complete event
    occurs, the inquiry cancel command should be issued only if HCI_INQUIRY
    flag is set.
    
    Additionally, cancel inquiry related code from stop_discovery() were
    replaced by a hci_cancel_inquiry() call.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 32f30533fd5d..20db034390b7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -971,5 +971,6 @@ void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
 int hci_do_inquiry(struct hci_dev *hdev, u8 length);
+int hci_cancel_inquiry(struct hci_dev *hdev);
 
 #endif /* __HCI_CORE_H */

commit 2519a1fc82490eb13d69610f81fe84930f3b0e3f
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Mon Nov 7 11:45:24 2011 -0300

    Bluetooth: Create hci_do_inquiry()
    
    This patch adds a function to hci_core to carry out inquiry.
    
    All inquiry code from start_discovery() were replaced by a
    hci_do_inquiry() call.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 006a7699abac..32f30533fd5d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -970,4 +970,6 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
 void hci_le_ltk_neg_reply(struct hci_conn *conn);
 
+int hci_do_inquiry(struct hci_dev *hdev, u8 length);
+
 #endif /* __HCI_CORE_H */

commit 9f5a0d7bf079e9e26771ad13ff1c2cb3adf80963
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Mon Nov 7 14:20:25 2011 +0200

    Bluetooth: Define HCI reasons instead of magic number
    
    Use HCI error reasons instead of magic numbers.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f97792c972f3..006a7699abac 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -730,7 +730,7 @@ static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
 	register struct hci_proto *hp;
-	int reason = 0x13;
+	int reason = HCI_ERROR_REMOTE_USER_TERM;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->disconn_ind)

commit 73d80deb7bdf0171f22e76dc2429c1f99eff90e2
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Wed Nov 2 15:52:01 2011 +0200

    Bluetooth: prioritizing data over HCI
    
    This implement priority based scheduler using skbuffer priority set via
    SO_PRIORITY socket option.
    
    It introduces hci_chan_hash (list of HCI Channel/hci_chan) per connection,
    each item in this list refer to a L2CAP connection and it is used to
    queue the data for transmission.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5a9db9a4b439..f97792c972f3 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -67,6 +67,12 @@ struct hci_conn_hash {
 	unsigned int     le_num;
 };
 
+struct hci_chan_hash {
+	struct list_head list;
+	spinlock_t       lock;
+	unsigned int     num;
+};
+
 struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
@@ -287,6 +293,7 @@ struct hci_conn {
 	unsigned int	sent;
 
 	struct sk_buff_head data_q;
+	struct hci_chan_hash chan_hash;
 
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
@@ -309,6 +316,14 @@ struct hci_conn {
 	void (*disconn_cfm_cb)	(struct hci_conn *conn, u8 reason);
 };
 
+struct hci_chan {
+	struct list_head list;
+
+	struct hci_conn *conn;
+	struct sk_buff_head data_q;
+	unsigned int	sent;
+};
+
 extern struct hci_proto *hci_proto[];
 extern struct list_head hci_dev_list;
 extern struct list_head hci_cb_list;
@@ -469,6 +484,28 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 	return NULL;
 }
 
+static inline void hci_chan_hash_init(struct hci_conn *c)
+{
+	struct hci_chan_hash *h = &c->chan_hash;
+	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
+	h->num = 0;
+}
+
+static inline void hci_chan_hash_add(struct hci_conn *c, struct hci_chan *chan)
+{
+	struct hci_chan_hash *h = &c->chan_hash;
+	list_add(&chan->list, &h->list);
+	h->num++;
+}
+
+static inline void hci_chan_hash_del(struct hci_conn *c, struct hci_chan *chan)
+{
+	struct hci_chan_hash *h = &c->chan_hash;
+	list_del(&chan->list);
+	h->num--;
+}
+
 void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
@@ -480,6 +517,10 @@ int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
+struct hci_chan *hci_chan_create(struct hci_conn *conn);
+int hci_chan_del(struct hci_chan *chan);
+void hci_chan_hash_flush(struct hci_conn *conn);
+
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 						__u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
@@ -849,7 +890,7 @@ int hci_register_notifier(struct notifier_block *nb);
 int hci_unregister_notifier(struct notifier_block *nb);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
-void hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+void hci_send_acl(struct hci_chan *chan, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);

commit 164a6e78990f6201dc3105ff88335ca91392a427
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Nov 1 17:06:44 2011 +0200

    Bluetooth: Fix command complete/status for discovery commands
    
    This patch adds the necessary code to send proper command status or
    command complete events to the start/stop discovery management commands.
    Before this patch these events were completely missing.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9285a650949c..5a9db9a4b439 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -887,6 +887,7 @@ int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
 								u8 *eir);
 int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
+int mgmt_inquiry_failed(u16 index, u8 status);
 int mgmt_discovering(u16 index, u8 discovering);
 int mgmt_device_blocked(u16 index, bdaddr_t *bdaddr);
 int mgmt_device_unblocked(u16 index, bdaddr_t *bdaddr);

commit 5e59b791c3561e2fbb4aee17df3505ad25c16b7a
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Tue Nov 1 10:58:57 2011 +0200

    Bluetooth: set skbuffer priority based on L2CAP socket priority
    
    This uses SO_PRIORITY to set the skbuffer priority field
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 967e18f72a38..9285a650949c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -32,6 +32,9 @@
 #define HCI_PROTO_L2CAP	0
 #define HCI_PROTO_SCO	1
 
+/* HCI priority */
+#define HCI_PRIO_MAX	7
+
 /* HCI Core structures */
 struct inquiry_data {
 	bdaddr_t	bdaddr;

commit 59735631d24e3463f139a21255e0db94bc59081e
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Wed Oct 26 10:43:19 2011 +0200

    Bluetooth: Make hci_unregister_dev return void
    
    hci_unregister_dev cannot fail and always returns 0. The drivers already ignore
    the return value so we can safely make it return void.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 119b795b2850..967e18f72a38 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -554,7 +554,7 @@ struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
 struct hci_dev *hci_alloc_dev(void);
 void hci_free_dev(struct hci_dev *hdev);
 int hci_register_dev(struct hci_dev *hdev);
-int hci_unregister_dev(struct hci_dev *hdev);
+void hci_unregister_dev(struct hci_dev *hdev);
 int hci_suspend_dev(struct hci_dev *hdev);
 int hci_resume_dev(struct hci_dev *hdev);
 int hci_dev_open(__u16 dev);

commit 1d58996da6a8045c8df2899ce5689a19c721322f
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Sep 15 17:56:39 2011 -0400

    bluetooth: macroize two small inlines to avoid module.h
    
    These two small inlines make calls to try_module_get() and
    module_put() which would force us to keep module.h present
    within yet another common include header.  We can avoid this
    by turning them into macros.  The hci_dev_hold construct
    is patterned off of raw_spin_trylock_irqsave() in spinlock.h
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5b924423cf20..3779ea362257 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -513,11 +513,15 @@ static inline void __hci_dev_put(struct hci_dev *d)
 		d->destruct(d);
 }
 
-static inline void hci_dev_put(struct hci_dev *d)
-{
-	__hci_dev_put(d);
-	module_put(d->owner);
-}
+/*
+ * hci_dev_put and hci_dev_hold are macros to avoid dragging all the
+ * overhead of all the modular infrastructure into this header.
+ */
+#define hci_dev_put(d)		\
+do {				\
+	__hci_dev_put(d);	\
+	module_put(d->owner);	\
+} while (0)
 
 static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 {
@@ -525,12 +529,10 @@ static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
 	return d;
 }
 
-static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
-{
-	if (try_module_get(d->owner))
-		return __hci_dev_hold(d);
-	return NULL;
-}
+#define hci_dev_hold(d)						\
+({								\
+	try_module_get(d->owner) ? __hci_dev_hold(d) : NULL;	\
+})
 
 #define hci_dev_lock(d)		spin_lock(&d->lock)
 #define hci_dev_unlock(d)	spin_unlock(&d->lock)

commit ce242970f0934869483221c410d09c00bc8967e7
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Oct 8 14:58:48 2011 +0200

    Bluetooth: Rename sysfs un/register to add/del
    
    As we introduced hci_init_sysfs() we should also rename
    hci_register_sysfs() and hci_unregister_sysfs() to hci_add_sysfs() and
    hci_del_sysfs() like we do with hci_conn_add/del_sysfs(). It looks more
    consistent now.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c8cc23c5c936..119b795b2850 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -609,8 +609,8 @@ int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
 void hci_init_sysfs(struct hci_dev *hdev);
-int hci_register_sysfs(struct hci_dev *hdev);
-void hci_unregister_sysfs(struct hci_dev *hdev);
+int hci_add_sysfs(struct hci_dev *hdev);
+void hci_del_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);

commit 0ac7e7002c4d0841197e9ccb8cfecc5b8c58b200
Author: David Herrmann <dh.herrmann@googlemail.com>
Date:   Sat Oct 8 14:58:47 2011 +0200

    Bluetooth: Fix hci core device initialization
    
    We must not call device_del() if we didn't use device_add(). See module.c
    for comments on that. Therefore, we need to call device_initialize() when
    allocating the hci device and later device_add() instead of
    device_register().
    
    This also fixes a bug when hci_register_dev() failed and we call
    hci_free_dev() without a valid core device. hci_free_dev() segfaults while
    calling put_device() on invalid memory.
    
    We already do this with hci_conn connections (hci_conn_init_sysfs()) so
    they do not need to be fixed.
    
    Signed-off-by: David Herrmann <dh.herrmann@googlemail.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 32cddb0f0912..c8cc23c5c936 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -608,6 +608,7 @@ int hci_recv_frame(struct sk_buff *skb);
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
+void hci_init_sysfs(struct hci_dev *hdev);
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);
 void hci_conn_init_sysfs(struct hci_conn *conn);

commit 928abaa777501ddab94b1b49aae485a2c730d303
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 12 10:53:57 2011 +0300

    Bluetooth: AMP: read local amp info HCI command
    
    Implementation of Read Local AMP Info Command
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5b924423cf20..32cddb0f0912 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -150,6 +150,17 @@ struct hci_dev {
 	__u16		sniff_min_interval;
 	__u16		sniff_max_interval;
 
+	__u8		amp_status;
+	__u32		amp_total_bw;
+	__u32		amp_max_bw;
+	__u32		amp_min_latency;
+	__u32		amp_max_pdu;
+	__u8		amp_type;
+	__u16		amp_pal_cap;
+	__u16		amp_assoc_size;
+	__u32		amp_max_flush_to;
+	__u32		amp_be_flush_to;
+
 	unsigned int	auto_accept_delay;
 
 	unsigned long	quirks;

commit 5e762444b0d3e56bbd66f5092434c4a1ba698313
Author: Antti Julku <antti.julku@nokia.com>
Date:   Thu Aug 25 16:48:02 2011 +0300

    Bluetooth: Add mgmt events for blacklisting
    
    Add management interface events for blocking/unblocking a device.
    Sender of the block device command gets cmd complete and other
    mgmt sockets get the event. Event is also sent to mgmt sockets when
    blocking is done with ioctl, e.g when blocking a device with
    hciconfig. This makes it possible for bluetoothd to track status
    of blocked devices when a third party block or unblocks a device.
    
    Event sending is handled in mgmt_device_blocked function which gets
    called from hci_blacklist_add in hci_core.c. A pending command is
    added in mgmt_block_device, so that it can found when sending the
    event - the event is not sent to the socket from which the pending
    command came. Locks were moved out from hci_core.c to hci_sock.c
    and mgmt.c, because locking is needed also for mgmt_pending_add in
    mgmt.c.
    
    Signed-off-by: Antti Julku <antti.julku@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ee1ee1bfae9e..5b924423cf20 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -873,6 +873,8 @@ int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
 								u8 *eir);
 int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
 int mgmt_discovering(u16 index, u8 discovering);
+int mgmt_device_blocked(u16 index, bdaddr_t *bdaddr);
+int mgmt_device_unblocked(u16 index, bdaddr_t *bdaddr);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 1c1def09c446aae441410b70e6439ffe44dee866
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Mon Sep 5 14:31:30 2011 -0300

    Bluetooth: Move SMP fields to a separate structure
    
    The objective is to make the core to have as little as possible
    information about SMP procedures and logic. Now, all the SMP
    specific information is hidden from the core.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4b17cd7fb164..ee1ee1bfae9e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -195,8 +195,6 @@ struct hci_dev {
 
 	__u16			init_last_cmd;
 
-	struct crypto_blkcipher	*tfm;
-
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
 	struct list_head	blacklist;

commit cfafccf730d363accacbd165542095ce6f7d2de8
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Aug 19 21:06:56 2011 -0300

    Bluetooth: Add link_type information to the mgmt Connected event
    
    One piece of information that was lost when using the mgmt interface,
    was the type of the connection. Using HCI events we used to know
    the type of the connection based on the type of the event, e.g.
    HCI_LE_Connection_Complete for LE links.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 88566f2e0a6f..4b17cd7fb164 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -855,7 +855,7 @@ int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
 int mgmt_new_key(u16 index, struct link_key *key, u8 persistent);
-int mgmt_connected(u16 index, bdaddr_t *bdaddr);
+int mgmt_connected(u16 index, bdaddr_t *bdaddr, u8 link_type);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);
 int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);

commit 454d48ff70c24930c6b0f9cb64f290fca2dfb271
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Aug 19 21:06:52 2011 -0300

    Bluetooth: Use the same timeouts for both ACL and LE links
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 605829b2c63e..88566f2e0a6f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -492,7 +492,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 {
 	if (atomic_dec_and_test(&conn->refcnt)) {
 		unsigned long timeo;
-		if (conn->type == ACL_LINK) {
+		if (conn->type == ACL_LINK || conn->type == LE_LINK) {
 			del_timer(&conn->idle_timer);
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(conn->disc_timeout);

commit d26a23454813908a1bf0e2fd8c73233b22c6dbd7
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Aug 19 21:06:51 2011 -0300

    Bluetooth: Add a flag to indicate that SMP is going on
    
    Add HCI_CONN_LE_SMP_PEND flag to indicate that SMP is pending
    for that connection. This allows to have information that an SMP
    procedure is going on for that connection.
    
    We use the HCI_CONN_ENCRYPT_PEND to indicate that encryption
    (HCI_LE_Start_Encryption) is pending for that connection.
    
    While a SMP procedure is going on we hold an reference to the
    connection, to avoid disconnections.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e2ba4d6b4190..605829b2c63e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -348,6 +348,7 @@ enum {
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
 	HCI_CONN_SCO_SETUP_PEND,
+	HCI_CONN_LE_SMP_PEND,
 };
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)

commit 52087a792c1513b85de674a4fc67fb92855474c3
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Wed Aug 17 16:23:00 2011 +0300

    Bluetooth: make use of connection number to optimize the scheduler
    
    This checks if there is any existing connection according to its type
    before start iterating in the list and immediately stop iterating when
    reaching the number of connections.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8f441b8b2963..e2ba4d6b4190 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -395,6 +395,22 @@ static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 	}
 }
 
+static inline unsigned int hci_conn_num(struct hci_dev *hdev, __u8 type)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	switch (type) {
+	case ACL_LINK:
+		return h->acl_num;
+	case LE_LINK:
+		return h->le_num;
+	case SCO_LINK:
+	case ESCO_LINK:
+		return h->sco_num;
+	default:
+		return 0;
+	}
+}
+
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 								__u16 handle)
 {

commit 95a943c162d74b20d869917bdf5df11293c35b63
Merge: ecae42d37045 95acac61ba66
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Jul 15 10:05:24 2011 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            net/bluetooth/l2cap_core.c

commit 726b4ffcaa450d9593b9b6ac8605967ce9f3e506
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 8 18:31:45 2011 -0300

    Bluetooth: Add support for storing the key size
    
    In some cases it will be useful having the key size used for
    encrypting the link. For example, some profiles may restrict
    some operations depending on the key length.
    
    The key size is stored in the key that is passed to userspace
    using the pin_length field in the key structure.
    
    For now this field is only valid for LE controllers. 3.0+HS
    controllers define the Read Encryption Key Size command, this
    field is intended for storing the value returned by that
    command.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4ff530e3892b..c41e275917c7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -261,6 +261,7 @@ struct hci_conn {
 	__u8		sec_level;
 	__u8		pending_sec_level;
 	__u8		pin_length;
+	__u8		enc_key_size;
 	__u8		io_capability;
 	__u8		power_save;
 	__u16		disc_timeout;
@@ -556,7 +557,7 @@ struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
 struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
 					bdaddr_t *bdaddr, u8 type);
 int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-					__le16 ediv, u8 rand[8], u8 ltk[16]);
+			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);

commit 0eb08e339836989557ea3aa4c427377bd32ce19c
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jul 7 18:59:42 2011 -0300

    Bluetooth: Remove unused field in hci_conn
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 306430ef164b..4ff530e3892b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -265,7 +265,6 @@ struct hci_conn {
 	__u8		power_save;
 	__u16		disc_timeout;
 	unsigned long	pend;
-	__u8		ltk[16];
 
 	__u8		remote_cap;
 	__u8		remote_oob;

commit 75d262c2ad927751bb5f096f3a6a37d81e7784f2
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jul 7 18:59:36 2011 -0300

    Bluetooth: Add functions to manipulate the link key list for SMP
    
    As the LTK (the new type of key being handled now) has more data
    associated with it, we need to store this extra data and retrieve
    the keys based on that data.
    
    Methods for searching for a key and for adding a new LTK are
    introduced here.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0e1fd2b29b0a..306430ef164b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -553,6 +553,11 @@ int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
 			bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
+struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
+struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
+					bdaddr_t *bdaddr, u8 type);
+int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
+					__le16 ediv, u8 rand[8], u8 ltk[16]);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);

commit 34918cd71b953905e5f832537ead436bcd57e8f9
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jul 7 18:59:35 2011 -0300

    Bluetooth: Add new structures for supporting SM key distribution
    
    We need these changes because SMP keys may have more information
    associated with them, for example, in the LTK case, it has an
    encrypted diversifier (ediv) and a random number (rand).
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bb57bcadf484..0e1fd2b29b0a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -74,12 +74,28 @@ struct bt_uuid {
 	u8 svc_hint;
 };
 
+struct key_master_id {
+	__le16 ediv;
+	u8 rand[8];
+} __packed;
+
+struct link_key_data {
+	bdaddr_t bdaddr;
+	u8 type;
+	u8 val[16];
+	u8 pin_len;
+	u8 dlen;
+	u8 data[0];
+} __packed;
+
 struct link_key {
 	struct list_head list;
 	bdaddr_t bdaddr;
 	u8 type;
 	u8 val[16];
 	u8 pin_len;
+	u8 dlen;
+	u8 data[0];
 };
 
 struct oob_data {

commit eead27da60df80a112d1ac3ea482226e9794c26b
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jun 30 19:20:55 2011 -0300

    Bluetooth: Add lmp_host_le_capable() macro
    
    Since we have the extended LMP features properly implemented, we
    should check the LMP_HOST_LE bit to know if the host supports LE.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index eb7fe99979e1..bb57bcadf484 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -578,6 +578,9 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 #define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
 
+/* ----- Extended LMP capabilities ----- */
+#define lmp_host_le_capable(dev)   ((dev)->extfeatures[0] & LMP_HOST_LE)
+
 /* ----- HCI protocols ----- */
 struct hci_proto {
 	char		*name;

commit 971e3a4bbcbf7378315b85150853d86be59cffe0
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jun 30 19:20:52 2011 -0300

    Bluetooth: Add extfeatures to struct hci_dev
    
    This new field holds the extended LMP features value. Some LE
    mechanism such as discovery procedure needs to read the extended
    LMP features to work properly.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 90d81f9b19a2..eb7fe99979e1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -113,6 +113,7 @@ struct hci_dev {
 	__u8		major_class;
 	__u8		minor_class;
 	__u8		features[8];
+	__u8		extfeatures[8];
 	__u8		commands[64];
 	__u8		ssp_mode;
 	__u8		hci_ver;

commit f8c1fbdb767f7487983b369a0b07ddc82b29f709
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Fri Jun 17 15:46:46 2011 -0300

    Bluetooth: Clean up unused struct hci_conn items
    
    priv and lock are never used
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 26233d4d371c..90d81f9b19a2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -223,7 +223,6 @@ struct hci_conn {
 	struct list_head list;
 
 	atomic_t	refcnt;
-	spinlock_t	lock;
 
 	bdaddr_t	dst;
 	__u8		dst_type;
@@ -272,7 +271,6 @@ struct hci_conn {
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
-	void		*priv;
 
 	struct hci_conn	*link;
 

commit 36099365c7cc64e5184b66b6eb094950a13f540c
Merge: 22c8c9343258 f70490e6078a
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Jun 24 15:25:51 2011 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            drivers/net/wireless/rtlwifi/pci.c
            include/linux/netlink.h

commit b2a66aad8620337e38d6692f03d94a03d5129840
Author: Antti Julku <antti.julku@nokia.com>
Date:   Wed Jun 15 12:01:14 2011 +0300

    Bluetooth: Move blacklisting functions to hci_core
    
    Move blacklisting functions to hci_core.c, so that they can
    be used by both management interface and hci socket interface.
    
    Signed-off-by: Antti Julku <antti.julku@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fe05946c8f0b..26233d4d371c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -529,6 +529,8 @@ int hci_inquiry(void __user *arg);
 
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
+int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 

commit 88167aed0d2e84364c8f0d9e48429c21fc7894c3
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jun 9 18:50:51 2011 -0300

    Bluetooth: Update the security level when link is encrypted
    
    If the pending security level is greater than the current security
    level and the link is now encrypted, we should update the link
    security level.
    
    This is only useful for LE links, when the only event generated
    when SMP is sucessful in the Encrypt Change event.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ab6842c6e49a..fe05946c8f0b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -745,6 +745,9 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
 	if (conn->sec_level == BT_SECURITY_SDP)
 		conn->sec_level = BT_SECURITY_LOW;
 
+	if (conn->pending_sec_level > conn->sec_level)
+		conn->sec_level = conn->pending_sec_level;
+
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
 	read_lock_bh(&hci_cb_list_lock);

commit a7a595f675f1b33dc73167147321dba5c4395acc
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jun 9 18:50:47 2011 -0300

    Bluetooth: Add support for LE Start Encryption
    
    This adds support for starting SMP Phase 2 Encryption, when the initial
    SMP negotiation is successful. This adds the LE Start Encryption and LE
    Long Term Key Request commands and related events.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7837f3260863..ab6842c6e49a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -249,6 +249,7 @@ struct hci_conn {
 	__u8		power_save;
 	__u16		disc_timeout;
 	unsigned long	pend;
+	__u8		ltk[16];
 
 	__u8		remote_cap;
 	__u8		remote_oob;
@@ -861,4 +862,9 @@ void hci_req_complete(struct hci_dev *hdev, __u16 cmd, int result);
 
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 					u16 latency, u16 to_multiplier);
+void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
+							__u8 ltk[16]);
+void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
+void hci_le_ltk_neg_reply(struct hci_conn *conn);
+
 #endif /* __HCI_CORE_H */

commit 3a0259bb80cec7595a2d085a150412d23ba28c81
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jun 9 18:50:43 2011 -0300

    Bluetooth: Add support for using the crypto subsystem
    
    This will allow using the crypto subsystem for encrypting data. As SMP
    (Security Manager Protocol) is implemented almost entirely on the host
    side and the crypto module already implements the needed methods
    (AES-128), it makes sense to use it.
    
    There's now a new module option to enable/disable SMP support.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Anderson Briglia <anderson.briglia@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 836d3e8c4bf1..7837f3260863 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -177,6 +177,8 @@ struct hci_dev {
 
 	__u16			init_last_cmd;
 
+	struct crypto_blkcipher	*tfm;
+
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
 	struct list_head	blacklist;

commit 5a9d0a3ffbc40ea1f5a0636501e7599cbb327bcc
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Tue Jun 7 11:18:06 2011 +0200

    Bluetooth: Clean up some code style issues
    
    Fix lines longer than 80 chars in length.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 818eadbc3f7f..836d3e8c4bf1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -224,7 +224,7 @@ struct hci_conn {
 	spinlock_t	lock;
 
 	bdaddr_t	dst;
-	__u8            dst_type;
+	__u8		dst_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;
@@ -317,7 +317,8 @@ static inline long inquiry_entry_age(struct inquiry_entry *e)
 	return jiffies - e->timestamp;
 }
 
-struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
+							bdaddr_t *bdaddr);
 void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
 
 /* ----- HCI Connections ----- */
@@ -431,7 +432,8 @@ int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+						__u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
@@ -460,10 +462,12 @@ static inline void hci_conn_put(struct hci_conn *conn)
 				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
 					timeo *= 2;
-			} else
+			} else {
 				timeo = msecs_to_jiffies(10);
-		} else
+			}
+		} else {
 			timeo = msecs_to_jiffies(10);
+		}
 		mod_timer(&conn->disc_timer, jiffies + timeo);
 	}
 }
@@ -578,16 +582,20 @@ struct hci_proto {
 
 	void		*priv;
 
-	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
+	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								__u8 type);
 	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
 	int (*disconn_ind)	(struct hci_conn *conn);
 	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason);
-	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb,
+								__u16 flags);
 	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	int (*security_cfm)	(struct hci_conn *conn, __u8 status,
+								__u8 encrypt);
 };
 
-static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
+static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
+								__u8 type)
 {
 	register struct hci_proto *hp;
 	int mask = 0;
@@ -673,7 +681,8 @@ static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 		conn->security_cfm_cb(conn, status);
 }
 
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
+								__u8 encrypt)
 {
 	register struct hci_proto *hp;
 
@@ -698,7 +707,8 @@ struct hci_cb {
 
 	char *name;
 
-	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
+								__u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -724,7 +734,8 @@ static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 	read_unlock_bh(&hci_cb_list_lock);
 }
 
-static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
+								__u8 encrypt)
 {
 	struct list_head *p;
 
@@ -755,7 +766,8 @@ static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
 	read_unlock_bh(&hci_cb_list_lock);
 }
 
-static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
+static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
+								__u8 role)
 {
 	struct list_head *p;
 

commit 14b12d0b98f87162b7e9e93dde66d1af97886567
Author: Jaikumar Ganesh <jaikumar@google.com>
Date:   Mon May 23 18:06:04 2011 -0700

    Bluetooth: Add BT_POWER L2CAP socket option.
    
    Add BT_POWER socket option used to control the power
    characteristics of the underlying ACL link. When the remote end
    has put the link in sniff mode and the host stack wants to send
    data we need need to explicitly exit sniff mode to work well with
    certain devices (For example, A2DP on Plantronics Voyager 855).
    However, this causes problems with HID devices.
    
    Hence, moving into active mode when sending data, irrespective
    of who set the sniff mode has been made as a socket option. By
    default, we will move into active mode. HID devices can set the
    L2CAP socket option to prevent this from happening.
    
    Currently, this has been implemented for L2CAP sockets. This has been
    tested with incoming and outgoing L2CAP sockets for HID and A2DP.
    
    Based on discussions on linux-bluetooth and patches submitted by
    Andrei Emeltchenko.
    
    Signed-off-by: Jaikumar Ganesh <jaikumar@google.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5be150229574..818eadbc3f7f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -438,7 +438,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
-void hci_conn_enter_active_mode(struct hci_conn *conn);
+void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
 void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
 void hci_conn_hold_device(struct hci_conn *conn);

commit 29b7988a23daf79c15d587ef9e98e64715aa1ea8
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue May 31 14:20:54 2011 -0300

    Bluetooth: Add 'dst_type' field to struct hci_conn
    
    This patch adds a new field (dst_type) to the struct hci_conn which
    holds the type of the destination address (bdaddr_t dst). This
    approach is needed in order to use the struct hci_conn as an
    abstraction of LE connections in HCI Layer. For non-LE this field
    is ignored.
    
    This patch also set properly the 'dst_type' field after initializing
    LE hci_conn structures.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0ac820dc35f7..5be150229574 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -224,6 +224,7 @@ struct hci_conn {
 	spinlock_t	lock;
 
 	bdaddr_t	dst;
+	__u8            dst_type;
 	__u16		handle;
 	__u16		state;
 	__u8		mode;

commit 19f8def031bfa50c579149b200bfeeb919727b27
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Tue May 31 15:49:25 2011 +0200

    Bluetooth: Fix auth_complete_evt for legacy units
    
    Legacy devices don't re-authenticate the link properly if a link key
    already exists.  Thus, don't update sec_level for this case even if
    hci_auth_complete_evt indicates success. Otherwise the sec_level will
    not reflect a real security on the link.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index af4b0ed173a8..0ac820dc35f7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -322,6 +322,7 @@ void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
 /* ----- HCI Connections ----- */
 enum {
 	HCI_CONN_AUTH_PEND,
+	HCI_CONN_REAUTH_PEND,
 	HCI_CONN_ENCRYPT_PEND,
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,

commit 3581508571b513ed2e66d71f9708d6be907460fd
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu May 26 16:23:53 2011 -0300

    Bluetooth: Advertising entries lifetime
    
    This patch adds a timer to clear 'adv_entries' after three minutes.
    
    After some amount of time, the advertising entries cached during
    the last LE scan should be considered expired and they should be
    removed from the advertising cache.
    
    It was chosen a three minutes timeout as an initial attempt. This
    value might change in future.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 10dfb85ad6a1..af4b0ed173a8 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -188,6 +188,7 @@ struct hci_dev {
 	struct list_head	remote_oob_data;
 
 	struct list_head	adv_entries;
+	struct timer_list	adv_timer;
 
 	struct hci_dev_stats	stat;
 
@@ -535,6 +536,7 @@ int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
 								u8 *randomizer);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
+#define ADV_CLEAR_TIMEOUT (3*60*HZ) /* Three minutes */
 int hci_adv_entries_clear(struct hci_dev *hdev);
 struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_add_adv_entry(struct hci_dev *hdev,

commit 76c8686f8871f1bcb2dc8b4c5311cd0e2f73d4cd
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu May 26 16:23:50 2011 -0300

    Bluetooth: LE advertising cache
    
    This patch implements the LE advertising cache. It stores sensitive
    information (bdaddr and bdaddr_type so far) gathered from LE
    advertising report events.
    
    Only advertising entries from connectables devices are added to the
    cache.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6c994c004d15..10dfb85ad6a1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -89,6 +89,12 @@ struct oob_data {
 	u8 randomizer[16];
 };
 
+struct adv_entry {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 bdaddr_type;
+};
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -181,6 +187,8 @@ struct hci_dev {
 
 	struct list_head	remote_oob_data;
 
+	struct list_head	adv_entries;
+
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
@@ -527,6 +535,11 @@ int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
 								u8 *randomizer);
 int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
+int hci_adv_entries_clear(struct hci_dev *hdev);
+struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_add_adv_entry(struct hci_dev *hdev,
+					struct hci_ev_le_advertising_info *ev);
+
 void hci_del_off_timer(struct hci_dev *hdev);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);

commit a6b7a407865aab9f849dd99a71072b7cd1175116
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jun 6 10:43:46 2011 +0000

    net: remove interrupt.h inclusion from netdevice.h
    
    * remove interrupt.g inclusion from netdevice.h -- not needed
    * fixup fallout, add interrupt.h and hardirq.h back where needed.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6c994c004d15..7851c05833e2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -25,6 +25,7 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
+#include <linux/interrupt.h>
 #include <net/bluetooth/hci.h>
 
 /* HCI upper protocols */

commit b3b1b061583ba4909b59a2f736825d86495fe956
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Fri May 6 09:42:31 2011 +0200

    Bluetooth: Double check sec req for pre 2.1 device
    
    In case of pre v2.1 devices authentication request will return
    success immediately if the link key already exists without any
    authentication process.
    
    That means, it's not possible to re-authenticate the link if you
    already have combination key and for instance want to re-authenticate
    to get the high security (use 16 digit pin).
    
    Therefore, it's necessary to check security requirements on auth
    complete event to prevent not enough secure connection.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 14cc3249c1eb..6c994c004d15 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -422,6 +422,7 @@ void hci_conn_check_pending(struct hci_dev *hdev);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
+int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);

commit 4df378a10e31698df1679f3329301d773a654b61
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Apr 28 11:29:03 2011 -0700

    Bluetooth: Add store_hint parameter to mgmt_new_key
    
    Even for keys that shouldn't be stored some use cases require the
    knowledge of a new key having been created so that the conclusion of a
    successful pairing can be made. Therefore, always send the mgmt_new_key
    event but add a store_hint parameter to it to indicate to user space
    whether the key should be stored or not.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 88c2cd92eaea..14cc3249c1eb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -775,7 +775,7 @@ int mgmt_index_removed(u16 index);
 int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
-int mgmt_new_key(u16 index, struct link_key *key);
+int mgmt_new_key(u16 index, struct link_key *key, u8 persistent);
 int mgmt_connected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);

commit 4748fed2d1a2a7a816277754498b8aa70850e051
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Apr 28 11:29:02 2011 -0700

    Bluetooth: Remove old_key_type from mgmt_ev_new_key
    
    User space shouldn't have any need for the old key type so remove it
    from the corresponding Management interface event.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3a3f7b453803..88c2cd92eaea 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -775,7 +775,7 @@ int mgmt_index_removed(u16 index);
 int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
-int mgmt_new_key(u16 index, struct link_key *key, u8 old_key_type);
+int mgmt_new_key(u16 index, struct link_key *key);
 int mgmt_connected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);

commit d25e28abe58d2bcedf6025a6ccc532c29a19046f
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Apr 28 11:28:59 2011 -0700

    Bluetooth: Fix link key persistent storage criteria
    
    Link keys should only be stored if very specific criteria of the
    authentication process are fulfilled. This patch essentially copies the
    criteria that user space has so far been using to the kernel side so
    that the management interface works properly.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 135dfac1be12..3a3f7b453803 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -515,8 +515,8 @@ int hci_uuids_clear(struct hci_dev *hdev);
 
 int hci_link_keys_clear(struct hci_dev *hdev);
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
-int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
-						u8 *key, u8 type, u8 pin_len);
+int hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn, int new_key,
+			bdaddr_t *bdaddr, u8 *val, u8 type, u8 pin_len);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
 int hci_remote_oob_data_clear(struct hci_dev *hdev);

commit 55bc1a378cc35f21a26e07af2ff2b71820808cd4
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Apr 28 11:28:56 2011 -0700

    Bluetooth: Add confirm_hint parameter to user confirmation requests
    
    When accepting a pairing request which fulfills the SSP auto-accept
    criteria we need to push the request all the way to the user for
    confirmation. This patch adds a new hint to the user_confirm_request
    management event so user space can know when to show a numeric
    comparison dialog and when to show a simple yes/no confirmation dialog.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 09b9dd61e370..135dfac1be12 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -783,7 +783,8 @@ int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value);
+int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value,
+							u8 confirm_hint);
 int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
 								u8 status);

commit 9f61656a60c9506e3e4cd41af5efbcf6a30ee3b9
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Apr 28 11:28:54 2011 -0700

    Bluetooth: Add variable SSP auto-accept delay support
    
    Some test systems require an arbitrary delay to the auto-accept test
    cases for Secure Simple Pairing in order for the tests to pass.
    Previously when this was handled in user space it was worked around by
    code modifications and recompilation, but now that it's on the kernel
    side it's more convenient if there's a debugfs interface for it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2995e2e63512..09b9dd61e370 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -126,6 +126,8 @@ struct hci_dev {
 	__u16		sniff_min_interval;
 	__u16		sniff_max_interval;
 
+	unsigned int	auto_accept_delay;
+
 	unsigned long	quirks;
 
 	atomic_t	cmd_cnt;
@@ -246,6 +248,7 @@ struct hci_conn {
 
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
+	struct timer_list auto_accept_timer;
 
 	struct work_struct work_add;
 	struct work_struct work_del;

commit a770bb5aea84ee2509d4775f9959665f96da3b9d
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Thu Apr 28 12:07:59 2011 +0200

    Bluetooth: Add secure flag for mgmt_pin_code_req
    
    Extend the mgmt_pin_code_request interface to require secure
    pin code (16 digit) for authentication.
    
    This is a kernel part of the secure pin code requirement notification
    to user space agent.
    
    Code styling fix by Johan Hedberg.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2da2eb9f53ac..2995e2e63512 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -777,7 +777,7 @@ int mgmt_connected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);
 int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
-int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
+int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr, u8 secure);
 int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value);

commit 13d39315c22b128f4796fc008b04914a7c32bb1a
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Thu Apr 28 12:07:55 2011 +0200

    Bluetooth: Map sec_level to link key requirements
    
    Keep the link key type together with connection and use it to
    map security level to link key requirements. Authenticate and/or
    encrypt connection if the link is insufficiently secure.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 69967e540c96..2da2eb9f53ac 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -226,6 +226,7 @@ struct hci_conn {
 	__u16		pkt_type;
 	__u16		link_policy;
 	__u32		link_mode;
+	__u8		key_type;
 	__u8		auth_type;
 	__u8		sec_level;
 	__u8		pending_sec_level;

commit 314b2381a79c6bfe3ddc4ba3806ecb6aec27a3db
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Apr 27 10:29:57 2011 -0400

    Bluetooth: Add discovering event to the Management interface
    
    This patch adds a new event to the Management interface to track when
    local adapters are discovering remote devices. For now this only tracks
    BR/EDR discovery procedures.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Anderson Briglia <anderson.briglia@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4093133c1283..69967e540c96 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -790,6 +790,7 @@ int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
 								u8 *eir);
 int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
+int mgmt_discovering(u16 index, u8 discovering);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit a88a9652d25a63ce10b6a5fe680d0ad8f33b9c9b
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Mar 30 13:18:12 2011 +0300

    Bluetooth: Add mgmt_remote_name event
    
    This patch adds a new remote_name event to the Management interface
    which is sent every time the name of a remote device is resolved (over
    BR/EDR).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2a88fc82429b..4093133c1283 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -789,6 +789,7 @@ int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 								u8 status);
 int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
 								u8 *eir);
+int mgmt_remote_name(u16 index, bdaddr_t *bdaddr, u8 *name);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit e17acd40f6006d0a0e0b1b3f7359ba4d543011c6
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Mar 30 23:57:16 2011 +0300

    Bluetooth: Add mgmt_device_found event
    
    This patch adds a device_found event to the Management interface. For
    now the event only maps to BR/EDR inquiry result HCI events, but in the
    future the plan is to also use it for the LE device discovery process.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3b2f09df279a..2a88fc82429b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -787,6 +787,8 @@ int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
 int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
 								u8 status);
+int mgmt_device_found(u16 index, bdaddr_t *bdaddr, u8 *dev_class, s8 rssi,
+								u8 *eir);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 80a1e1dbf62a08984d4c1bfb5a4bca38c3e1664f
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Mon Mar 28 14:07:23 2011 +0300

    Bluetooth: Add local Extended Inquiry Response (EIR) support
    
    This patch adds automated creation of the local EIR data based on what
    16-bit UUIDs are registered and what the device name is. This should
    cover the majority use cases, however things like 32/128-bit UUIDs, TX
    power and Device ID will need to be added later to be on par with what
    bluetoothd is capable of doing (without the Management interface).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 87bff518b54b..3b2f09df279a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -102,6 +102,7 @@ struct hci_dev {
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
 	__u8		dev_name[HCI_MAX_NAME_LENGTH];
+	__u8		eir[HCI_MAX_EIR_LENGTH];
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;

commit 2763eda6ccaf126633bb3180f440c8f3589f0679
Author: Szymon Janc <szymon.janc@tieto.com>
Date:   Tue Mar 22 13:12:22 2011 +0100

    Bluetooth: Add add/remove_remote_oob_data management commands
    
    This patch adds commands to add and remove remote OOB data to the managment
    interface. Remote data is stored in kernel and can be used by corresponding
    HCI commands and events when needed.
    
    Signed-off-by: Szymon Janc <szymon.janc@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index fd9b8a31e5b0..87bff518b54b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -82,6 +82,13 @@ struct link_key {
 	u8 pin_len;
 };
 
+struct oob_data {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 hash[16];
+	u8 randomizer[16];
+};
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -169,6 +176,8 @@ struct hci_dev {
 
 	struct list_head	link_keys;
 
+	struct list_head	remote_oob_data;
+
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
@@ -505,6 +514,13 @@ int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
 						u8 *key, u8 type, u8 pin_len);
 int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
 
+int hci_remote_oob_data_clear(struct hci_dev *hdev);
+struct oob_data *hci_find_remote_oob_data(struct hci_dev *hdev,
+							bdaddr_t *bdaddr);
+int hci_add_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 *hash,
+								u8 *randomizer);
+int hci_remove_remote_oob_data(struct hci_dev *hdev, bdaddr_t *bdaddr);
+
 void hci_del_off_timer(struct hci_dev *hdev);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);

commit c35938b2f56547ee77b5a038fe0db394aeac59bb
Author: Szymon Janc <szymon.janc@tieto.com>
Date:   Tue Mar 22 13:12:21 2011 +0100

    Bluetooth: Add read_local_oob_data management command
    
    This patch adds a command to read local OOB data to the managment interface.
    The command maps directly to the Read Local OOB Data HCI command.
    
    Signed-off-by: Szymon Janc <szymon.janc@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3912c7ab717c..fd9b8a31e5b0 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -768,6 +768,8 @@ int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
 								u8 status);
 int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
+int mgmt_read_local_oob_data_reply_complete(u16 index, u8 *hash, u8 *randomizer,
+								u8 status);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit b312b161ecb833b1bce5c4a97853f4a4f40c7901
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Mar 16 14:29:37 2011 +0200

    Bluetooth: mgmt: Add support for setting the local name
    
    This patch adds a new set_local_name management command as well as a
    local_name_changed management event. With these user space can both
    change the local name as well as monitor changes to it by others.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9aabb14982dd..3912c7ab717c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -767,6 +767,7 @@ int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
 								u8 status);
 int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_set_local_name_complete(u16 index, u8 *name, u8 status);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 1f6c6378c59f3ddac9ed89a68ccefe2611300c09
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Mar 16 14:29:35 2011 +0200

    Bluetooth: Add define for the maximum name length on HCI level
    
    This patch adds a clear define for the maximum device name length in HCI
    messages and thereby avoids magic numbers in the code.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 441dadbf6a89..9aabb14982dd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -94,7 +94,7 @@ struct hci_dev {
 	__u8		bus;
 	__u8		dev_type;
 	bdaddr_t	bdaddr;
-	__u8		dev_name[248];
+	__u8		dev_name[HCI_MAX_NAME_LENGTH];
 	__u8		dev_class[3];
 	__u8		major_class;
 	__u8		minor_class;

commit 2a61169209c72317d4933f8d22f749a6a61a3d36
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Sat Feb 19 12:06:00 2011 -0300

    Bluetooth: Add mgmt_auth_failed event
    
    To properly track bonding completion an event to indicate authentication
    failure is needed. This event will be sent whenever an authentication
    complete HCI event with a non-zero status comes. It will also be sent
    when we're acting in acceptor role for SSP authentication in which case
    the controller will send a Simple Pairing Complete event.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 05f4706e6c34..441dadbf6a89 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -766,6 +766,7 @@ int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value);
 int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
 								u8 status);
+int mgmt_auth_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit a5c296832b4fde7d32c01cff9cdd27d9c7c1c4f5
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Sat Feb 19 12:05:57 2011 -0300

    Bluetooth: Add management support for user confirmation request
    
    This patch adds support for the user confirmation (numeric comparison)
    Secure Simple Pairing authentication method.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 506f25089207..05f4706e6c34 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -762,6 +762,10 @@ int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
 int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_user_confirm_request(u16 index, bdaddr_t *bdaddr, __le32 value);
+int mgmt_user_confirm_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_user_confirm_neg_reply_complete(u16 index, bdaddr_t *bdaddr,
+								u8 status);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit e9a416b5ce0c0f93819f55d34cf6882196e9c3b2
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Sat Feb 19 12:05:56 2011 -0300

    Bluetooth: Add mgmt_pair_device command
    
    This patch adds a new mgmt_pair_device which can be used to initiate a
    dedicated bonding procedure. Some extra callbacks are added to the
    hci_conn struct so that the pairing code can get notified of the
    completion of the procedure.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d5d8454236bf..506f25089207 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -248,6 +248,10 @@ struct hci_conn {
 	void		*priv;
 
 	struct hci_conn	*link;
+
+	void (*connect_cfm_cb)	(struct hci_conn *conn, u8 status);
+	void (*security_cfm_cb)	(struct hci_conn *conn, u8 status);
+	void (*disconn_cfm_cb)	(struct hci_conn *conn, u8 reason);
 };
 
 extern struct hci_proto *hci_proto[];
@@ -571,6 +575,9 @@ static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->connect_cfm)
 		hp->connect_cfm(conn, status);
+
+	if (conn->connect_cfm_cb)
+		conn->connect_cfm_cb(conn, status);
 }
 
 static inline int hci_proto_disconn_ind(struct hci_conn *conn)
@@ -600,6 +607,9 @@ static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->disconn_cfm)
 		hp->disconn_cfm(conn, reason);
+
+	if (conn->disconn_cfm_cb)
+		conn->disconn_cfm_cb(conn, reason);
 }
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
@@ -619,6 +629,9 @@ static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->security_cfm)
 		hp->security_cfm(conn, status, encrypt);
+
+	if (conn->security_cfm_cb)
+		conn->security_cfm_cb(conn, status);
 }
 
 static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
@@ -632,6 +645,9 @@ static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->security_cfm)
 		hp->security_cfm(conn, status, encrypt);
+
+	if (conn->security_cfm_cb)
+		conn->security_cfm_cb(conn, status);
 }
 
 int hci_register_proto(struct hci_proto *hproto);

commit adc4266d87ba95e250e5ffa217c72b4b78c2b56a
Author: Szymon Janc <szymon.janc@tieto.com>
Date:   Thu Feb 17 16:42:00 2011 +0100

    Bluetooth: Fix some code style issues in hci_core.h
    
    Signed-off-by: Szymon Janc <szymon.janc@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7ee921d78a94..d5d8454236bf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -199,37 +199,37 @@ struct hci_dev {
 struct hci_conn {
 	struct list_head list;
 
-	atomic_t	 refcnt;
-	spinlock_t	 lock;
-
-	bdaddr_t	 dst;
-	__u16		 handle;
-	__u16		 state;
-	__u8             mode;
-	__u8		 type;
-	__u8		 out;
-	__u8		 attempt;
-	__u8		 dev_class[3];
-	__u8             features[8];
-	__u8             ssp_mode;
-	__u16            interval;
-	__u16            pkt_type;
-	__u16            link_policy;
-	__u32		 link_mode;
-	__u8             auth_type;
-	__u8             sec_level;
-	__u8		 pending_sec_level;
-	__u8		 pin_length;
-	__u8		 io_capability;
-	__u8             power_save;
-	__u16            disc_timeout;
-	unsigned long	 pend;
+	atomic_t	refcnt;
+	spinlock_t	lock;
+
+	bdaddr_t	dst;
+	__u16		handle;
+	__u16		state;
+	__u8		mode;
+	__u8		type;
+	__u8		out;
+	__u8		attempt;
+	__u8		dev_class[3];
+	__u8		features[8];
+	__u8		ssp_mode;
+	__u16		interval;
+	__u16		pkt_type;
+	__u16		link_policy;
+	__u32		link_mode;
+	__u8		auth_type;
+	__u8		sec_level;
+	__u8		pending_sec_level;
+	__u8		pin_length;
+	__u8		io_capability;
+	__u8		power_save;
+	__u16		disc_timeout;
+	unsigned long	pend;
 
 	__u8		remote_cap;
 	__u8		remote_oob;
 	__u8		remote_auth;
 
-	unsigned int	 sent;
+	unsigned int	sent;
 
 	struct sk_buff_head data_q;
 
@@ -347,7 +347,7 @@ static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 }
 
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
-					__u16 handle)
+								__u16 handle)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	struct list_head *p;
@@ -362,7 +362,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
 }
 
 static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
-					__u8 type, bdaddr_t *ba)
+							__u8 type, bdaddr_t *ba)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	struct list_head *p;
@@ -377,7 +377,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 }
 
 static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
-					__u8 type, __u16 state)
+							__u8 type, __u16 state)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	struct list_head *p;

commit 2ce603ebe1f1420c7c5b013638ec29b4fc975180
Author: Claudio Takahasi <claudio.takahasi@openbossa.org>
Date:   Wed Feb 16 20:44:53 2011 -0200

    Bluetooth: Send LE Connection Update Command
    
    If the new connection update parameter are accepted, the LE master
    host sends the LE Connection Update Command to its controller informing
    the new requested parameters.
    
    Signed-off-by: Claudio Takahasi <claudio.takahasi@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ecd2acf24420..7ee921d78a94 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -777,4 +777,6 @@ struct hci_sec_filter {
 
 void hci_req_complete(struct hci_dev *hdev, __u16 cmd, int result);
 
+void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
+					u16 latency, u16 to_multiplier);
 #endif /* __HCI_CORE_H */

commit 6bd32326cdaa9b14794416150c88e4832fb7e592
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Wed Feb 16 16:32:41 2011 +0200

    Bluetooth: Use proper timer for hci command timout
    
    Use proper timer instead of hci command flow control to timeout
    failed hci commands. Otherwise stack ends up sending commands
    when flow control is used to block new commands.
    
    2010-09-01 18:29:41.592132 < HCI Command: Remote Name Request (0x01|0x0019) plen 10
        bdaddr 00:16:CF:E1:C7:D7 mode 2 clkoffset 0x0000
    2010-09-01 18:29:41.592681 > HCI Event: Command Status (0x0f) plen 4
        Remote Name Request (0x01|0x0019) status 0x00 ncmd 0
    2010-09-01 18:29:51.022033 < HCI Command: Remote Name Request Cancel (0x01|0x001a) plen 6
        bdaddr 00:16:CF:E1:C7:D7
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d30b93c82fd4..ecd2acf24420 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -132,7 +132,6 @@ struct hci_dev {
 	unsigned int	sco_pkts;
 	unsigned int	le_pkts;
 
-	unsigned long	cmd_last_tx;
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
 	unsigned long	le_last_tx;
@@ -143,6 +142,7 @@ struct hci_dev {
 	struct work_struct	power_off;
 	struct timer_list	off_timer;
 
+	struct timer_list	cmd_timer;
 	struct tasklet_struct	cmd_task;
 	struct tasklet_struct	rx_task;
 	struct tasklet_struct	tx_task;

commit 6ed58ec520ad2b2fe3f955c8a5fd0eecafccebdf
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Thu Feb 10 22:38:48 2011 -0300

    Bluetooth: Use LE buffers for LE traffic
    
    Bluetooth chips may have separate buffers for LE traffic.
    This patch add support to use LE buffers provided by the chip.
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f434e96ce020..d30b93c82fd4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -123,15 +123,19 @@ struct hci_dev {
 	atomic_t	cmd_cnt;
 	unsigned int	acl_cnt;
 	unsigned int	sco_cnt;
+	unsigned int	le_cnt;
 
 	unsigned int	acl_mtu;
 	unsigned int	sco_mtu;
+	unsigned int	le_mtu;
 	unsigned int	acl_pkts;
 	unsigned int	sco_pkts;
+	unsigned int	le_pkts;
 
 	unsigned long	cmd_last_tx;
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
+	unsigned long	le_last_tx;
 
 	struct workqueue_struct	*workqueue;
 
@@ -521,6 +525,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 #define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
+#define lmp_le_capable(dev)        ((dev)->features[4] & LMP_LE)
 
 /* ----- HCI protocols ----- */
 struct hci_proto {

commit fcd89c09a59a054fb986861e0862aa2fff7d7c40
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Thu Feb 10 22:38:47 2011 -0300

    Bluetooth: Add LE connect support
    
    Bluetooth V4.0 adds support for Low Energy (LE) connections.
    Specification introduces new set of hci commands to control LE
    connection. This patch adds logic to create, cancel and disconnect
    LE connections.
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6163bff6fa91..f434e96ce020 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -60,6 +60,7 @@ struct hci_conn_hash {
 	spinlock_t       lock;
 	unsigned int     acl_num;
 	unsigned int     sco_num;
+	unsigned int     le_num;
 };
 
 struct bdaddr_list {
@@ -309,20 +310,36 @@ static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	list_add(&c->list, &h->list);
-	if (c->type == ACL_LINK)
+	switch (c->type) {
+	case ACL_LINK:
 		h->acl_num++;
-	else
+		break;
+	case LE_LINK:
+		h->le_num++;
+		break;
+	case SCO_LINK:
+	case ESCO_LINK:
 		h->sco_num++;
+		break;
+	}
 }
 
 static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
 	list_del(&c->list);
-	if (c->type == ACL_LINK)
+	switch (c->type) {
+	case ACL_LINK:
 		h->acl_num--;
-	else
+		break;
+	case LE_LINK:
+		h->le_num--;
+		break;
+	case SCO_LINK:
+	case ESCO_LINK:
 		h->sco_num--;
+		break;
+	}
 }
 
 static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,

commit 17fa4b9dff72fb3a1a68cc80caf98fc941d2b8b3
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue Jan 25 13:28:33 2011 +0200

    Bluetooth: Add set_io_capability management command
    
    This patch adds a new set_io_capability management command which is used
    to set the IO capability for Secure Simple Pairing (SSP) as well as the
    Security Manager Protocol (SMP). The value is per hci_dev and each
    hci_conn object inherits it upon creation.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9ac3da6e4a9a..6163bff6fa91 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -106,6 +106,7 @@ struct hci_dev {
 	__u16		manufacturer;
 	__le16		lmp_subver;
 	__u16		voice_setting;
+	__u8		io_capability;
 
 	__u16		pkt_type;
 	__u16		esco_type;
@@ -214,6 +215,7 @@ struct hci_conn {
 	__u8             sec_level;
 	__u8		 pending_sec_level;
 	__u8		 pin_length;
+	__u8		 io_capability;
 	__u8             power_save;
 	__u16            disc_timeout;
 	unsigned long	 pend;

commit 980e1a537fed7dfa53e9a4b6e586b43341f8c2d5
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Sat Jan 22 06:10:07 2011 +0200

    Bluetooth: Add support for PIN code handling in the management interface
    
    This patch adds the necessary commands and events needed to communicate
    PIN code related actions between the kernel and userspace. This includes
    a pin_code_request event as well as pin_code_reply and
    pin_code_negative_reply commands.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 45caae62cb8e..9ac3da6e4a9a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -213,6 +213,7 @@ struct hci_conn {
 	__u8             auth_type;
 	__u8             sec_level;
 	__u8		 pending_sec_level;
+	__u8		 pin_length;
 	__u8             power_save;
 	__u16            disc_timeout;
 	unsigned long	 pend;
@@ -718,6 +719,9 @@ int mgmt_connected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);
 int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_pin_code_request(u16 index, bdaddr_t *bdaddr);
+int mgmt_pin_code_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
+int mgmt_pin_code_neg_reply_complete(u16 index, bdaddr_t *bdaddr, u8 status);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 17d5c04cb597418a177c3ca18dfde679636dd51c
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Sat Jan 22 06:09:08 2011 +0200

    Bluetooth: Add support for connect failed management event
    
    This patch add a new connect failed management event to track failures
    in connecting to remote devices. It is particularly useful for security
    mode 3 scenarios when we don't have a connected state while pairing but
    still need to detect when the connect attempt failed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2197a099a2b7..45caae62cb8e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -717,6 +717,7 @@ int mgmt_new_key(u16 index, struct link_key *key, u8 old_key_type);
 int mgmt_connected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnect_failed(u16 index);
+int mgmt_connect_failed(u16 index, bdaddr_t *bdaddr, u8 status);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 8962ee74be48df16027100f657b2b12e8ef3d34d
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Jan 20 12:40:27 2011 +0200

    Bluetooth: Add disconnect managment command
    
    This patch adds a disconnect command to the managment interface. Using
    this command user space is able to force the disconnection of connected
    devices. The command maps directly to the Disconnect HCI command.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 746f8dc8aad1..2197a099a2b7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -716,6 +716,7 @@ int mgmt_connectable(u16 index, u8 connectable);
 int mgmt_new_key(u16 index, struct link_key *key, u8 old_key_type);
 int mgmt_connected(u16 index, bdaddr_t *bdaddr);
 int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
+int mgmt_disconnect_failed(u16 index);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit f7520543ab40341edbc2aeee7fef68218be19a0a
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Jan 20 12:34:39 2011 +0200

    Bluetooth: Add connected/disconnected management events
    
    This patch adds connected and disconnected managment events to track the
    connection status to remote devices. The events map directly to
    successful connection complete and disconnection complete HCI events for
    ACL links.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 009fa63a9048..746f8dc8aad1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -714,6 +714,8 @@ int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
 int mgmt_new_key(u16 index, struct link_key *key, u8 old_key_type);
+int mgmt_connected(u16 index, bdaddr_t *bdaddr);
+int mgmt_disconnected(u16 index, bdaddr_t *bdaddr);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 55ed8ca10f3530de8edbbf138acb50992bf5005b
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Mon Jan 17 14:41:05 2011 +0200

    Bluetooth: Implement link key handling for the management interface
    
    This patch adds a management commands to feed the kernel with all stored
    link keys as well as remove specific ones or all of them. Once the
    load_keys command has been called the kernel takes over link key
    replies. A new_key event is also added to inform userspace of newly
    created link keys that should be stored permanently.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e62da084e01d..009fa63a9048 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -73,6 +73,14 @@ struct bt_uuid {
 	u8 svc_hint;
 };
 
+struct link_key {
+	struct list_head list;
+	bdaddr_t bdaddr;
+	u8 type;
+	u8 val[16];
+	u8 pin_len;
+};
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -153,6 +161,8 @@ struct hci_dev {
 
 	struct list_head	uuids;
 
+	struct list_head	link_keys;
+
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
@@ -461,6 +471,12 @@ int hci_blacklist_clear(struct hci_dev *hdev);
 
 int hci_uuids_clear(struct hci_dev *hdev);
 
+int hci_link_keys_clear(struct hci_dev *hdev);
+struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_add_link_key(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
+						u8 *key, u8 type, u8 pin_len);
+int hci_remove_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr);
+
 void hci_del_off_timer(struct hci_dev *hdev);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
@@ -697,6 +713,7 @@ int mgmt_index_removed(u16 index);
 int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
 int mgmt_connectable(u16 index, u8 connectable);
+int mgmt_new_key(u16 index, struct link_key *key, u8 old_key_type);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 1aff6f09491f454d4cd9f405c783fa5e9d3168a0
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Jan 13 21:56:52 2011 +0200

    Bluetooth: Add class of device control to the management interface
    
    This patch adds the possibility for user space to fully control the
    Class of Device value of local adapters. To control the service class
    bits each UUID that's added comes with a service class "hint" which acts
    as a mask of bits that the UUID needs to have enabled. The
    set_service_cache management command is used to make sure we queue up
    all UUID changes as user space initializes its drivers and then send a
    single HCI_Write_Class_of_Device command when initialization is
    complete.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 71a3fbf1e785..e62da084e01d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -70,6 +70,7 @@ struct bdaddr_list {
 struct bt_uuid {
 	struct list_head list;
 	u8 uuid[16];
+	u8 svc_hint;
 };
 
 #define NUM_REASSEMBLY 4
@@ -86,6 +87,8 @@ struct hci_dev {
 	bdaddr_t	bdaddr;
 	__u8		dev_name[248];
 	__u8		dev_class[3];
+	__u8		major_class;
+	__u8		minor_class;
 	__u8		features[8];
 	__u8		commands[64];
 	__u8		ssp_mode;

commit d5859e22cd40b73164b3e5d8d5d796f96edcc6af
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue Jan 25 01:19:58 2011 +0200

    Bluetooth: Implement a more complete adapter initialization sequence
    
    Using the managment interface means that user space doesn't need to do
    any HCI command sending at all. This patch moves the remaining
    initialization commands from user space to the kernel side. The patch
    makes use of the new feature of __hci_request which allows the request
    to be dynamically modified while it is ongoing (something that is needed
    to react appropriately to the local features and the version of the
    adapter).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0dbdcc5f44e4..71a3fbf1e785 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -91,7 +91,9 @@ struct hci_dev {
 	__u8		ssp_mode;
 	__u8		hci_ver;
 	__u16		hci_rev;
+	__u8		lmp_ver;
 	__u16		manufacturer;
+	__le16		lmp_subver;
 	__u16		voice_setting;
 
 	__u16		pkt_type;

commit a5040efa2017f3e4f1b4d5f40fd989567f3994c1
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Mon Jan 10 13:28:59 2011 +0200

    Bluetooth: Add special handling with __hci_request and HCI_INIT
    
    To support a more dynamic HCI initialization sequence the __hci_request
    behavior requires some more changes. Particularly, the init sequence
    should be able to have conditionals in it (sending some HCI commands
    depending on the outcome of a previous command) instead of being a fixed
    list as it is right now.
    
    The reasons for these additional requirements are the moving all
    previously user space driven initialization commands to the kernel side
    as well as the support the Low Energy controllers.
    
    To fulfull these requirements the init sequence is made the only special
    case for multi-command requests and req_last_cmd is renamed to
    init_last_cmd. The hci_send_cmd function is changed to update
    init_last_cmd as long as the HCI_INIT flag is set.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index dc8084a139ed..0dbdcc5f44e4 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -139,7 +139,8 @@ struct hci_dev {
 	wait_queue_head_t	req_wait_q;
 	__u32			req_status;
 	__u32			req_result;
-	__u16			req_last_cmd;
+
+	__u16			init_last_cmd;
 
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;

commit 03b555e119de8288a16e086e1fbd223d9b429d3d
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue Jan 4 15:40:05 2011 +0200

    Bluetooth: Reject pairing requests when in non-pairable mode
    
    This patch adds the necessary logic to act accordingly when the
    HCI_PAIRABLE flag is not set. In that case PIN code replies as well as
    Secure Simple Pairing requests without a NoBonding requirement need to
    be rejected.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8ee0b8bac77c..dc8084a139ed 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -201,6 +201,10 @@ struct hci_conn {
 	__u16            disc_timeout;
 	unsigned long	 pend;
 
+	__u8		remote_cap;
+	__u8		remote_oob;
+	__u8		remote_auth;
+
 	unsigned int	 sent;
 
 	struct sk_buff_head data_q;

commit 2aeb9a1ae0e34fb46cb78b82f827a6a54ab65111
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue Jan 4 12:08:51 2011 +0200

    Bluetooth: Implement UUID handling through the management interface
    
    This patch adds methods to the management interface for userspace to
    notify the kernel of which services have been registered for specific
    adapters. This information is needed for setting the appropriate Class
    of Device value as well as the Extended Inquiry Response value. This
    patch doesn't actually implement setting of these values but just
    provides the storage of the UUIDs so the needed functionality can be
    built on top of it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ba3dbe3188ed..8ee0b8bac77c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -66,6 +66,12 @@ struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
 };
+
+struct bt_uuid {
+	struct list_head list;
+	u8 uuid[16];
+};
+
 #define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
@@ -139,6 +145,8 @@ struct hci_dev {
 	struct hci_conn_hash	conn_hash;
 	struct list_head	blacklist;
 
+	struct list_head	uuids;
+
 	struct hci_dev_stats	stat;
 
 	struct sk_buff_head	driver_init;
@@ -441,6 +449,8 @@ int hci_inquiry(void __user *arg);
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
 
+int hci_uuids_clear(struct hci_dev *hdev);
+
 void hci_del_off_timer(struct hci_dev *hdev);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);

commit 9fbcbb455dd01abfad4f314b618ac51d566114cb
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Dec 30 00:18:33 2010 +0200

    Bluetooth: Add set_connectable management command
    
    This patch adds a set_connectable command as well as a corresponding
    event to the management interface. It's mainly useful for setting an
    adapter as connectable from a non-initialized state as well as setting
    an already initialized adapter as non-connectable (mostly useful for
    qualification purposes).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ee5ec4f17a15..ba3dbe3188ed 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -676,6 +676,7 @@ int mgmt_index_added(u16 index);
 int mgmt_index_removed(u16 index);
 int mgmt_powered(u16 index, u8 powered);
 int mgmt_discoverable(u16 index, u8 discoverable);
+int mgmt_connectable(u16 index, u8 connectable);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 73f22f62388795c0f6b4f3f97bda7a64f9681aac
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Dec 29 16:00:25 2010 +0200

    Bluetooth: Add support for set_discoverable management command
    
    This patch adds a set_discoverable command to the management interface
    as well as the corresponding event. The command is used to control the
    discoverable state of adapters.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 2d046e07a586..ee5ec4f17a15 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -675,6 +675,7 @@ int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(u16 index);
 int mgmt_index_removed(u16 index);
 int mgmt_powered(u16 index, u8 powered);
+int mgmt_discoverable(u16 index, u8 discoverable);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit eec8d2bcc841ae44edcde9660ff21144a2016053
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Dec 16 10:17:38 2010 +0200

    Bluetooth: Add support for set_powered management command
    
    This patch adds a set_powered command to the management interface
    through which the powered state of local adapters can be controlled.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 32e11b37ef28..2d046e07a586 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -667,7 +667,8 @@ void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
 
 /* ----- HCI Sockets ----- */
-void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb,
+							struct sock *skip_sk);
 
 /* Management interface */
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);

commit 5add6af8fcbce269cac2457584c0ebfda055474a
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Dec 16 10:00:37 2010 +0200

    Bluetooth: Add support for management powered event
    
    This patch adds support for the powered event that's used to indicate to
    userspace when the powered state of a local adapter changes.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 75c4f201c1c6..32e11b37ef28 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -673,6 +673,7 @@ void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
 int mgmt_index_added(u16 index);
 int mgmt_index_removed(u16 index);
+int mgmt_powered(u16 index, u8 powered);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit ab81cbf99c881ca2b9a83682a8722fc84b2483d2
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Dec 15 13:53:18 2010 +0200

    Bluetooth: Implement automatic setup procedure for local adapters
    
    This patch implements automatic initialization of basic information
    about newly registered Bluetooth adapters. E.g. the address and features
    are always needed so it makes sense for the kernel to automatically
    power on adapters and read this information. A new HCI_SETUP flag is
    added to track this state.
    
    In order to not consume unnecessary amounts of power if there isn't a
    user space available that could switch the adapter back off, a timer is
    added to do this automatically as long as no Bluetooth user space seems
    to be present. A new HCI_AUTO_OFF flag is added that user space needs to
    clear to avoid the automatic power off.
    
    Additionally, the management interface index_added event is moved to the
    end of the HCI_SETUP stage so a user space supporting the managment
    inteface has all the necessary information available for fetching when
    it gets notified of a new adapter. The HCI_DEV_REG event is kept in the
    same place as before since existing HCI raw socket based user space
    versions depend on seeing the kernels initialization sequence
    (hci_init_req) to determine when the adapter is ready for use.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4e14610baece..75c4f201c1c6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -114,6 +114,10 @@ struct hci_dev {
 
 	struct workqueue_struct	*workqueue;
 
+	struct work_struct	power_on;
+	struct work_struct	power_off;
+	struct timer_list	off_timer;
+
 	struct tasklet_struct	cmd_task;
 	struct tasklet_struct	rx_task;
 	struct tasklet_struct	tx_task;
@@ -437,6 +441,8 @@ int hci_inquiry(void __user *arg);
 struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int hci_blacklist_clear(struct hci_dev *hdev);
 
+void hci_del_off_timer(struct hci_dev *hdev);
+
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);

commit e702112ff68a554bcac16bb03ddc2b8e5425bcbf
Author: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
Date:   Mon Jan 3 11:14:36 2011 +0200

    Bluetooth: Use non-flushable by default L2CAP data packets
    
    Modification of Nick Pelly <npelly@google.com> patch.
    
    With Bluetooth 2.1 ACL packets can be flushable or non-flushable. This commit
    makes ACL data packets non-flushable by default on compatible chipsets, and
    adds the BT_FLUSHABLE socket option to explicitly request flushable ACL
    data packets for a given L2CAP socket. This is useful for A2DP data which can
    be safely discarded if it can not be delivered within a short time (while
    other ACL data should not be discarded).
    
    Note that making ACL data flushable has no effect unless the automatic flush
    timeout for that ACL link is changed from its default of 0 (infinite).
    
    Default packet types (for compatible chipsets):
    Frame 34: 13 bytes on wire (104 bits), 13 bytes captured (104 bits)
    Bluetooth HCI H4
    Bluetooth HCI ACL Packet
        .... 0000 0000 0010 = Connection Handle: 0x0002
        ..00 .... .... .... = PB Flag: First Non-automatically Flushable Packet (0)
        00.. .... .... .... = BC Flag: Point-To-Point (0)
        Data Total Length: 8
    Bluetooth L2CAP Packet
    
    After setting BT_FLUSHABLE
    (sock.setsockopt(274 /*SOL_BLUETOOTH*/, 8 /* BT_FLUSHABLE */, 1 /* flush */))
    Frame 34: 13 bytes on wire (104 bits), 13 bytes captured (104 bits)
    Bluetooth HCI H4
    Bluetooth HCI ACL Packet
        .... 0000 0000 0010 = Connection Handle: 0x0002
        ..10 .... .... .... = PB Flag: First Automatically Flushable Packet (2)
        00.. .... .... .... = BC Flag: Point-To-Point (0)
        Data Total Length: 8
    Bluetooth L2CAP Packet
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d2cf88407690..4e14610baece 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -458,6 +458,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
 #define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
 #define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
+#define lmp_no_flush_capable(dev)  ((dev)->features[6] & LMP_NO_FLUSH)
 
 /* ----- HCI protocols ----- */
 struct hci_proto {

commit 765c2a964b49bd06b61a52991519281c85d82b67
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Jan 19 12:06:52 2011 +0530

    Bluetooth: Fix race condition with conn->sec_level
    
    The conn->sec_level value is supposed to represent the current level of
    security that the connection has. However, by assigning to it before
    requesting authentication it will have the wrong value during the
    authentication procedure. To fix this a pending_sec_level variable is
    added which is used to track the desired security level while making
    sure that sec_level always represents the current level of security.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index a29feb01854e..d2cf88407690 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -184,6 +184,7 @@ struct hci_conn {
 	__u32		 link_mode;
 	__u8             auth_type;
 	__u8             sec_level;
+	__u8		 pending_sec_level;
 	__u8             power_save;
 	__u16            disc_timeout;
 	unsigned long	 pend;

commit 23bb57633df97ede067ea26f3cdc8a7ba2cd8109
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue Dec 21 23:01:27 2010 +0200

    Bluetooth: Fix __hci_request synchronization for hci_open_dev
    
    The initialization function used by hci_open_dev (hci_init_req) sends
    many different HCI commands. The __hci_request function should only
    return when all of these commands have completed (or a timeout occurs).
    Several of these commands cause hci_req_complete to be called which
    causes __hci_request to return prematurely.
    
    This patch fixes the issue by adding a new hdev->req_last_cmd variable
    which is set during the initialization procedure. The hci_req_complete
    function will no longer mark the request as complete until the command
    matching hdev->req_last_cmd completes.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3786ee83604e..a29feb01854e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -129,6 +129,7 @@ struct hci_dev {
 	wait_queue_head_t	req_wait_q;
 	__u32			req_status;
 	__u32			req_result;
+	__u16			req_last_cmd;
 
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
@@ -693,6 +694,6 @@ struct hci_sec_filter {
 #define hci_req_lock(d)		mutex_lock(&d->req_lock)
 #define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
 
-void hci_req_complete(struct hci_dev *hdev, int result);
+void hci_req_complete(struct hci_dev *hdev, __u16 cmd, int result);
 
 #endif /* __HCI_CORE_H */

commit c71e97bfaadfa727669fcfcf12301744fd169091
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Mon Dec 13 21:07:07 2010 +0200

    Bluetooth: Add management events for controller addition & removal
    
    This patch adds Bluetooth Management interface events for controller
    addition and removal. The events correspond to the existing HCI_DEV_REG
    and HCI_DEV_UNREG stack internal events.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1992fac7e921..3786ee83604e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -662,6 +662,8 @@ void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 
 /* Management interface */
 int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
+int mgmt_index_added(u16 index);
+int mgmt_index_removed(u16 index);
 
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)

commit 0381101fd6a73c7d6b545044dc1472d019fc64e3
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Dec 8 00:21:06 2010 +0200

    Bluetooth: Add initial Bluetooth Management interface callbacks
    
    Add initial code for handling Bluetooth Management interface messages.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Acked-by: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 3e3435945980..1992fac7e921 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -660,6 +660,9 @@ void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
 /* ----- HCI Sockets ----- */
 void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
 
+/* Management interface */
+int mgmt_control(struct sock *sk, struct msghdr *msg, size_t len);
+
 /* HCI info for socket */
 #define hci_pi(sk) ((struct hci_pinfo *) sk)
 

commit c02178d22b3ef2d18c38c96151600ee1c7ed94f0
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Dec 8 00:21:05 2010 +0200

    Bluetooth: Add Bluetooth Management interface definitions
    
    Add initial definitions for the new Bluetooth Management interface to
    the bluetooth headers.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9c08625617a1..3e3435945980 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -668,6 +668,7 @@ struct hci_pinfo {
 	struct hci_dev    *hdev;
 	struct hci_filter filter;
 	__u32             cmsg_mask;
+	unsigned short   channel;
 };
 
 /* HCI security filter */

commit 70f23020e6d89155504b5b39f22505f4aec6fa6f
Author: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
Date:   Wed Dec 1 16:58:25 2010 +0200

    Bluetooth: clean up hci code
    
    Do not use assignment in IF condition, remove extra spaces,
    fixing typos, simplify code.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ebec8c9a929d..9c08625617a1 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -44,15 +44,15 @@ struct inquiry_data {
 };
 
 struct inquiry_entry {
-	struct inquiry_entry 	*next;
+	struct inquiry_entry	*next;
 	__u32			timestamp;
 	struct inquiry_data	data;
 };
 
 struct inquiry_cache {
-	spinlock_t 		lock;
+	spinlock_t		lock;
 	__u32			timestamp;
-	struct inquiry_entry 	*list;
+	struct inquiry_entry	*list;
 };
 
 struct hci_conn_hash {
@@ -141,7 +141,7 @@ struct hci_dev {
 	void			*driver_data;
 	void			*core_data;
 
-	atomic_t 		promisc;
+	atomic_t		promisc;
 
 	struct dentry		*debugfs;
 
@@ -150,7 +150,7 @@ struct hci_dev {
 
 	struct rfkill		*rfkill;
 
-	struct module 		*owner;
+	struct module		*owner;
 
 	int (*open)(struct hci_dev *hdev);
 	int (*close)(struct hci_dev *hdev);
@@ -215,8 +215,8 @@ extern rwlock_t hci_dev_list_lock;
 extern rwlock_t hci_cb_list_lock;
 
 /* ----- Inquiry cache ----- */
-#define INQUIRY_CACHE_AGE_MAX   (HZ*30)   // 30 seconds
-#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   // 60 seconds
+#define INQUIRY_CACHE_AGE_MAX   (HZ*30)   /* 30 seconds */
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   /* 60 seconds */
 
 #define inquiry_cache_lock(c)		spin_lock(&c->lock)
 #define inquiry_cache_unlock(c)		spin_unlock(&c->lock)

commit a02cec2155fbea457eca8881870fd2de1a4c4c76
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Sep 22 20:43:57 2010 +0000

    net: return operator cleanup
    
    Change "return (EXPR);" to "return EXPR;"
    
    return is not a function, parentheses are not required.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4568b938ca35..ebec8c9a929d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -233,7 +233,7 @@ static inline void inquiry_cache_init(struct hci_dev *hdev)
 static inline int inquiry_cache_empty(struct hci_dev *hdev)
 {
 	struct inquiry_cache *c = &hdev->inq_cache;
-	return (c->list == NULL);
+	return c->list == NULL;
 }
 
 static inline long inquiry_cache_age(struct hci_dev *hdev)

commit ea4bd8ba804dedefa65303b3bd105d6d2808e621
Author: David Miller <davem@davemloft.net>
Date:   Fri Jul 30 21:54:49 2010 -0700

    Bluetooth: Use list_head for HCI blacklist head
    
    The bdaddr in the list root is completely unused and just
    taking up space.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Tested-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8b28962e737e..4568b938ca35 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -132,7 +132,7 @@ struct hci_dev {
 
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
-	struct bdaddr_list	blacklist;
+	struct list_head	blacklist;
 
 	struct hci_dev_stats	stat;
 

commit e73439d8c0e4c522c843b8bb98c0eb5700da6b05
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 26 10:06:00 2010 -0400

    Bluetooth: Defer SCO setup if mode change is pending
    
    Certain headsets such as the Motorola H350 will reject SCO and eSCO
    connection requests while the ACL is transitioning from sniff mode
    to active mode. Add synchronization so that SCO and eSCO connection
    requests will wait until the ACL has fully transitioned to active mode.
    
    < HCI Command: Exit Sniff Mode (0x02|0x0004) plen 2
        handle 12
    > HCI Event: Command Status (0x0f) plen 4
        Exit Sniff Mode (0x02|0x0004) status 0x00 ncmd 1
    < HCI Command:  Setup Synchronous Connection (0x01|0x0028) plen 17
        handle 12 voice setting 0x0040
    > HCI Event: Command Status (0x0f) plen 4
        Setup Synchronous Connection (0x01|0x0028) status 0x00 ncmd 1
    > HCI Event: Number of Completed Packets (0x13) plen 5
        handle 12 packets 1
    > HCI Event: Mode Change (0x14) plen 6
        status 0x00 handle 12 mode 0x00 interval 0
        Mode: Active
    > HCI Event: Synchronous Connect Complete (0x2c) plen 17
        status 0x10 handle 14 bdaddr 00:1A:0E:50:28:A4 type SCO
        Error: Connection Accept Timeout Exceeded
    
    Signed-off-by: Ron Shaffer <rshaffer@codeaurora.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 350b3e6964bd..8b28962e737e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -256,6 +256,7 @@ enum {
 	HCI_CONN_ENCRYPT_PEND,
 	HCI_CONN_RSWITCH_PEND,
 	HCI_CONN_MODE_CHANGE_PEND,
+	HCI_CONN_SCO_SETUP_PEND,
 };
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
@@ -336,6 +337,7 @@ void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
 void hci_setup_sync(struct hci_conn *conn, __u16 handle);
+void hci_sco_setup(struct hci_conn *conn, __u8 status);
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);

commit 9981151086385eecc2febf4ba95a14593f834b3d
Author: Suraj Sumangala <suraj@atheros.com>
Date:   Wed Jul 14 13:02:19 2010 +0530

    Bluetooth: Implemented HCI frame reassembly for RX from stream
    
    Implemented frame reassembly implementation for reassembling fragments
    received from stream.
    
    Signed-off-by: Suraj Sumangala <suraj@atheros.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 28e5eeefdec8..350b3e6964bd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -437,6 +437,7 @@ void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
+int hci_recv_stream_fragment(struct hci_dev *hdev, void *data, int count);
 
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);

commit cd4c53919ed50b0d532f106aeb76e79077bece98
Author: Suraj Sumangala <suraj@atheros.com>
Date:   Wed Jul 14 13:02:16 2010 +0530

    Bluetooth: Add one more buffer for HCI stream reassembly
    
    Additional reassembly buffer to keep track of stream reasembly
    
    Signed-off-by: Suraj Sumangala <suraj@atheros.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 600372d44578..28e5eeefdec8 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -66,7 +66,7 @@ struct bdaddr_list {
 	struct list_head list;
 	bdaddr_t bdaddr;
 };
-
+#define NUM_REASSEMBLY 4
 struct hci_dev {
 	struct list_head list;
 	spinlock_t	lock;
@@ -123,7 +123,7 @@ struct hci_dev {
 	struct sk_buff_head	cmd_q;
 
 	struct sk_buff		*sent_cmd;
-	struct sk_buff		*reassembly[3];
+	struct sk_buff		*reassembly[NUM_REASSEMBLY];
 
 	struct mutex		req_lock;
 	wait_queue_head_t	req_wait_q;

commit 2d0a03460a8a0c611843500735096ff799aa8510
Author: Ron Shaffer <rshaffer@codeaurora.org>
Date:   Fri May 28 11:53:46 2010 -0400

    Bluetooth: Reassigned copyright to Code Aurora Forum
    
    Qualcomm, Inc. has reassigned rights to Code Aurora Forum. Accordingly,
    as files are modified by Code Aurora Forum members, the copyright
    statement will be updated.
    
    Signed-off-by: Ron Shaffer <rshaffer@codeaurora.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ab6d6186a460..600372d44578 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 

commit 04fafe4ed76f5547856f4c464bec5bf948afb498
Author: Ron Shaffer <rshaffer@codeaurora.org>
Date:   Fri May 28 11:53:45 2010 -0400

    Bluetooth: Remove extraneous white space
    
    Deleted extraneous white space from the end of several lines
    
    Signed-off-by: Ron Shaffer <rshaffer@codeaurora.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ffc637748b87..ab6d6186a460 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -1,4 +1,4 @@
-/* 
+/*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
 
@@ -12,13 +12,13 @@
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
    IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
 
@@ -386,7 +386,7 @@ static inline void __hci_dev_put(struct hci_dev *d)
 }
 
 static inline void hci_dev_put(struct hci_dev *d)
-{ 
+{
 	__hci_dev_put(d);
 	module_put(d->owner);
 }

commit f03585689fdff4ae256edd45a35bc2dd83d3684a
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue May 18 13:20:32 2010 +0200

    Bluetooth: Add blacklist support for incoming connections
    
    In some circumstances it could be desirable to reject incoming
    connections on the baseband level. This patch adds this feature through
    two new ioctl's: HCIBLOCKADDR and HCIUNBLOCKADDR. Both take a simple
    Bluetooth address as a parameter. BDADDR_ANY can be used with
    HCIUNBLOCKADDR to remove all devices from the blacklist.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index e42f6ed5421c..ffc637748b87 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -62,6 +62,11 @@ struct hci_conn_hash {
 	unsigned int     sco_num;
 };
 
+struct bdaddr_list {
+	struct list_head list;
+	bdaddr_t bdaddr;
+};
+
 struct hci_dev {
 	struct list_head list;
 	spinlock_t	lock;
@@ -127,6 +132,7 @@ struct hci_dev {
 
 	struct inquiry_cache	inq_cache;
 	struct hci_conn_hash	conn_hash;
+	struct bdaddr_list	blacklist;
 
 	struct hci_dev_stats	stat;
 
@@ -424,6 +430,9 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
 int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
+struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
+int hci_blacklist_clear(struct hci_dev *hdev);
+
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
 int hci_recv_frame(struct sk_buff *skb);

commit f48fd9c8cd746fdb055a97249a209c77dca0f710
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Mar 20 15:20:04 2010 +0100

    Bluetooth: Create per controller workqueue
    
    Instead of having a global workqueue for all controllers, it makes
    more sense to have a workqueue per controller.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4511df2a0d7f..e42f6ed5421c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -107,6 +107,8 @@ struct hci_dev {
 	unsigned long	acl_last_tx;
 	unsigned long	sco_last_tx;
 
+	struct workqueue_struct	*workqueue;
+
 	struct tasklet_struct	cmd_task;
 	struct tasklet_struct	rx_task;
 	struct tasklet_struct	tx_task;

commit 9a9c6a34416b3743c09c00f3d6708d9df3c21629
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Sat May 1 16:15:43 2010 -0300

    Bluetooth: Make hci_send_acl() void
    
    hci_send_acl can't fail, so we can make it void. This patch changes
    that and all the funcions that use hci_send_acl().
    That change exposed a bug on sending connectionless data. We were not
    reporting the lenght send back to the user space.
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>
    Reviewed-by: João Paulo Rechi Vita <jprvita@profusion.mobi>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9830a88f487e..4511df2a0d7f 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -636,7 +636,7 @@ int hci_register_notifier(struct notifier_block *nb);
 int hci_unregister_notifier(struct notifier_block *nb);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
-int hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+void hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);

commit 0d861d8b8edd139a9b291cb262d08dec8dc3922d
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Sat May 1 16:15:35 2010 -0300

    Bluetooth: Make hci_send_sco() void
    
    It also removes an unneeded check for the MTU. The check is done before
    on sco_send_frame()
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>
    Reviewed-by: João Paulo Rechi Vita <jprvita@profusion.mobi>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ce3c99e5fa25..9830a88f487e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -637,7 +637,7 @@ int hci_unregister_notifier(struct notifier_block *nb);
 
 int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 int hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
-int hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
+void hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
 void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 

commit 943da25d95c7e8fd8c39dbf09e030f5da46f5d85
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 13 02:28:41 2010 +0100

    Bluetooth: Add controller types for BR/EDR and 802.11 AMP
    
    With the Bluetooth 3.0 specification and the introduction of alternate
    MAC/PHY (AMP) support, it is required to differentiate between primary
    BR/EDR controllers and 802.11 AMP controllers. So introduce a special
    type inside HCI device for differentiation.
    
    For now all AMP controllers will be treated as raw devices until an
    AMP manager has been implemented.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4c94c1e233a2..ce3c99e5fa25 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -71,6 +71,7 @@ struct hci_dev {
 	unsigned long	flags;
 	__u16		id;
 	__u8		bus;
+	__u8		dev_type;
 	bdaddr_t	bdaddr;
 	__u8		dev_name[248];
 	__u8		dev_class[3];

commit ca325f698996c1a0770a67f41e7dc97a007d8bc2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 8 16:22:31 2010 +0100

    Bluetooth: Convert inquiry cache to use debugfs instead of sysfs
    
    The output of the inquiry cache is only useful for debugging purposes
    and so move it into debugfs.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7e65885290d5..4c94c1e233a2 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -134,6 +134,8 @@ struct hci_dev {
 
 	atomic_t 		promisc;
 
+	struct dentry		*debugfs;
+
 	struct device		*parent;
 	struct device		dev;
 

commit c13854cef4751000b968d4e8ac95796562d5b96f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 8 15:27:07 2010 +0100

    Bluetooth: Convert controller hdev->type to hdev->bus
    
    The hdev->type is misnamed and should be actually hdev->bus instead. So
    convert it now.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7b86094a894b..7e65885290d5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -70,7 +70,7 @@ struct hci_dev {
 	char		name[8];
 	unsigned long	flags;
 	__u16		id;
-	__u8		type;
+	__u8		bus;
 	bdaddr_t	bdaddr;
 	__u8		dev_name[248];
 	__u8		dev_class[3];

commit c78ae283145d3a8799b2fb01650166a66af3bff8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 18 01:02:54 2009 +0100

    Bluetooth: Unobfuscate tasklet_schedule usage
    
    The tasklet schedule function helpers are just an obfuscation. So remove
    them and call the schedule functions directly.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8460f2283089..7b86094a894b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -367,22 +367,6 @@ static inline void hci_conn_put(struct hci_conn *conn)
 	}
 }
 
-/* ----- HCI tasks ----- */
-static inline void hci_sched_cmd(struct hci_dev *hdev)
-{
-	tasklet_schedule(&hdev->cmd_task);
-}
-
-static inline void hci_sched_rx(struct hci_dev *hdev)
-{
-	tasklet_schedule(&hdev->rx_task);
-}
-
-static inline void hci_sched_tx(struct hci_dev *hdev)
-{
-	tasklet_schedule(&hdev->tx_task);
-}
-
 /* ----- HCI Devices ----- */
 static inline void __hci_dev_put(struct hci_dev *d)
 {

commit 76bca88012e1d27de794f32cc551d6314d38b6d9
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Nov 18 00:40:39 2009 +0100

    Bluetooth: Turn hci_recv_frame into an exported function
    
    For future simplification it is important that the hci_recv_frame
    function is no longer an inline function. So move it into the module
    itself and export it.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7b640aeddb64..8460f2283089 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -437,28 +437,7 @@ int hci_inquiry(void __user *arg);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
 
-/* Receive frame from HCI drivers */
-static inline int hci_recv_frame(struct sk_buff *skb)
-{
-	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
-	if (!hdev || (!test_bit(HCI_UP, &hdev->flags) 
-			&& !test_bit(HCI_INIT, &hdev->flags))) {
-		kfree_skb(skb);
-		return -ENXIO;
-	}
-
-	/* Incomming skb */
-	bt_cb(skb)->incoming = 1;
-
-	/* Time stamp */
-	__net_timestamp(skb);
-
-	/* Queue frame for rx task */
-	skb_queue_tail(&hdev->rx_q, skb);
-	hci_sched_rx(hdev);
-	return 0;
-}
-
+int hci_recv_frame(struct sk_buff *skb);
 int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 
 int hci_register_sysfs(struct hci_dev *hdev);

commit a6a67efd7088702fdbbb780c5a3f8e1a74e77b63
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jul 26 08:18:19 2009 +0000

    Bluetooth: Convert hdev->req_lock to a mutex
    
    hdev->req_lock is used as mutex so make it a mutex.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 25b8a0345a6a..7b640aeddb64 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -117,7 +117,7 @@ struct hci_dev {
 	struct sk_buff		*sent_cmd;
 	struct sk_buff		*reassembly[3];
 
-	struct semaphore	req_lock;
+	struct mutex		req_lock;
 	wait_queue_head_t	req_wait_q;
 	__u32			req_status;
 	__u32			req_result;
@@ -704,8 +704,8 @@ struct hci_sec_filter {
 #define HCI_REQ_PEND	  1
 #define HCI_REQ_CANCELED  2
 
-#define hci_req_lock(d)		down(&d->req_lock)
-#define hci_req_unlock(d)	up(&d->req_lock)
+#define hci_req_lock(d)		mutex_lock(&d->req_lock)
+#define hci_req_unlock(d)	mutex_unlock(&d->req_lock)
 
 void hci_req_complete(struct hci_dev *hdev, int result);
 

commit 9eba32b86d17ef87131fa0bce43c614904ab5781
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 22 14:19:26 2009 -0700

    Bluetooth: Add extra device reference counting for connections
    
    The device model itself has no real usable reference counting at the
    moment and this causes problems if parents are deleted before their
    children. The device model itself handles the memory details of this
    correctly, but the uevent order is not consistent. This causes various
    problems for systems like HAL or even X.
    
    So until device_put() does a proper cleanup, the device for Bluetooth
    connection will be protected with an extra reference counting to ensure
    the correct order of uevents when connections are terminated.
    
    This is not an automatic feature. Higher Bluetooth layers like HIDP or
    BNEP should grab this new reference to ensure that their uevents are
    send before the ones from the parent device.
    
    Based on a report by Brian Rogers <brian@xyzw.org>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c4ca4228b083..25b8a0345a6a 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -187,6 +187,7 @@ struct hci_conn {
 	struct work_struct work_del;
 
 	struct device	dev;
+	atomic_t	devref;
 
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
@@ -339,6 +340,9 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 void hci_conn_enter_active_mode(struct hci_conn *conn);
 void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
+void hci_conn_hold_device(struct hci_conn *conn);
+void hci_conn_put_device(struct hci_conn *conn);
+
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);

commit 611b30f74b5d8ca036a9923b3bf6e0ee10a21a53
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 8 14:41:38 2009 +0200

    Bluetooth: Add native RFKILL soft-switch support for all devices
    
    With the re-write of the RFKILL subsystem it is now possible to easily
    integrate RFKILL soft-switch support into the Bluetooth subsystem. All
    Bluetooth devices will now get automatically RFKILL support.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 73aead222b32..c4ca4228b083 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -137,6 +137,8 @@ struct hci_dev {
 	struct device		*parent;
 	struct device		dev;
 
+	struct rfkill		*rfkill;
+
 	struct module 		*owner;
 
 	int (*open)(struct hci_dev *hdev);

commit a67e899cf38ae542d1a028ccd021f9189f76fb74
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat May 2 18:24:06 2009 -0700

    Bluetooth: Fix issue with sysfs handling for connections
    
    Due to a semantic changes in flush_workqueue() the current approach of
    synchronizing the sysfs handling for connections doesn't work anymore. The
    whole approach is actually fully broken and based on assumptions that are
    no longer valid.
    
    With the introduction of Simple Pairing support, the creation of low-level
    ACL links got changed. This change invalidates the reason why in the past
    two independent work queues have been used for adding/removing sysfs
    devices. The adding of the actual sysfs device is now postponed until the
    host controller successfully assigns an unique handle to that link. So
    the real synchronization happens inside the controller and not the host.
    
    The only left-over problem is that some internals of the sysfs device
    handling are not initialized ahead of time. This leaves potential access
    to invalid data and can cause various NULL pointer dereferences. To fix
    this a new function makes sure that all sysfs details are initialized
    when an connection attempt is made. The actual sysfs device is only
    registered when the connection has been successfully established. To
    avoid a race condition with the registration, the check if a device is
    registered has been moved into the removal work.
    
    As an extra protection two flush_work() calls are left in place to
    make sure a previous add/del work has been completed first.
    
    Based on a report by Marc Pignat <marc.pignat@hevs.ch>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Tested-by: Justin P. Mattock <justinmattock@gmail.com>
    Tested-by: Roger Quadros <ext-roger.quadros@nokia.com>
    Tested-by: Marc Pignat <marc.pignat@hevs.ch>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index be5bd713d2c9..73aead222b32 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -457,6 +457,7 @@ int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
 
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_conn_init_sysfs(struct hci_conn *conn);
 void hci_conn_add_sysfs(struct hci_conn *conn);
 void hci_conn_del_sysfs(struct hci_conn *conn);
 

commit 052b30b0a8eec8db5b18ad49effdf2a9ba4c1e1a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 26 20:01:22 2009 +0200

    Bluetooth: Add different pairing timeout for Legacy Pairing
    
    The Bluetooth stack uses a reference counting for all established ACL
    links and if no user (L2CAP connection) is present, the link will be
    terminated to save power. The problem part is the dedicated pairing
    when using Legacy Pairing (Bluetooth 2.0 and before). At that point
    no user is present and pairing attempts will be disconnected within
    10 seconds or less. In previous kernel version this was not a problem
    since the disconnect timeout wasn't triggered on incoming connections
    for the first time. However this caused issues with broken host stacks
    that kept the connections around after dedicated pairing. When the
    support for Simple Pairing got added, the link establishment procedure
    needed to be changed and now causes issues when using Legacy Pairing
    
    When using Simple Pairing it is possible to do a proper reference
    counting of ACL link users. With Legacy Pairing this is not possible
    since the specification is unclear in some areas and too many broken
    Bluetooth devices have already been deployed. So instead of trying to
    deal with all the broken devices, a special pairing timeout will be
    introduced that increases the timeout to 60 seconds when pairing is
    triggered.
    
    If a broken devices now puts the stack into an unforeseen state, the
    worst that happens is the disconnect timeout triggers after 120 seconds
    instead of 4 seconds. This allows successful pairings with legacy and
    broken devices now.
    
    Based on a report by Johan Hedberg <johan.hedberg@nokia.com>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 1224bba24bdd..be5bd713d2c9 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -171,6 +171,7 @@ struct hci_conn {
 	__u8             auth_type;
 	__u8             sec_level;
 	__u8             power_save;
+	__u16            disc_timeout;
 	unsigned long	 pend;
 
 	unsigned int	 sent;
@@ -349,9 +350,9 @@ static inline void hci_conn_put(struct hci_conn *conn)
 		if (conn->type == ACL_LINK) {
 			del_timer(&conn->idle_timer);
 			if (conn->state == BT_CONNECTED) {
-				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
+				timeo = msecs_to_jiffies(conn->disc_timeout);
 				if (!conn->out)
-					timeo *= 5;
+					timeo *= 2;
 			} else
 				timeo = msecs_to_jiffies(10);
 		} else

commit f3784d834c71689336fa272df420b45345cb6b84
Author: Roger Quadros <ext-roger.quadros@nokia.com>
Date:   Thu Apr 23 14:50:54 2009 +0300

    Bluetooth: Ensure that HCI sysfs add/del is preempt safe
    
    Use a different work_struct variables for add_conn() and del_conn() and
    use single work queue instead of two for adding and deleting connections.
    
    It eliminates the following error on a preemptible kernel:
    
    [  204.358032] Unable to handle kernel NULL pointer dereference at virtual address 0000000c
    [  204.370697] pgd = c0004000
    [  204.373443] [0000000c] *pgd=00000000
    [  204.378601] Internal error: Oops: 17 [#1] PREEMPT
    [  204.383361] Modules linked in: vfat fat rfcomm sco l2cap sd_mod scsi_mod iphb pvr2d drm omaplfb ps
    [  204.438537] CPU: 0    Not tainted  (2.6.28-maemo2 #1)
    [  204.443664] PC is at klist_put+0x2c/0xb4
    [  204.447601] LR is at klist_put+0x18/0xb4
    [  204.451568] pc : [<c0270f08>]    lr : [<c0270ef4>]    psr: a0000113
    [  204.451568] sp : cf1b3f10  ip : cf1b3f10  fp : cf1b3f2c
    [  204.463104] r10: 00000000  r9 : 00000000  r8 : bf08029c
    [  204.468353] r7 : c7869200  r6 : cfbe2690  r5 : c78692c8  r4 : 00000001
    [  204.474945] r3 : 00000001  r2 : cf1b2000  r1 : 00000001  r0 : 00000000
    [  204.481506] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM Segment kernel
    [  204.488861] Control: 10c5387d  Table: 887fc018  DAC: 00000017
    [  204.494628] Process btdelconn (pid: 515, stack limit = 0xcf1b22e0)
    
    Signed-off-by: Roger Quadros <ext-roger.quadros@nokia.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 01f9316b4c23..1224bba24bdd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -180,7 +180,8 @@ struct hci_conn {
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
 
-	struct work_struct work;
+	struct work_struct work_add;
+	struct work_struct work_del;
 
 	struct device	dev;
 

commit 2950f21acb0f6b8fcd964485c2ebf1e06545ac20
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 12 14:02:50 2009 +0100

    Bluetooth: Ask upper layers for HCI disconnect reason
    
    Some of the qualification tests demand that in case of failures in L2CAP
    the HCI disconnect should indicate a reason why L2CAP fails. This is a
    bluntly layer violation since multiple L2CAP connections could be using
    the same ACL and thus forcing a disconnect reason is not a good idea.
    
    To comply with the Bluetooth test specification, the disconnect reason
    is now stored in the L2CAP connection structure and every time a new
    L2CAP channel is added it will set back to its default. So only in the
    case where the L2CAP channel with the disconnect reason is really the
    last one, it will propagated to the HCI layer.
    
    The HCI layer has been extended with a disconnect indication that allows
    it to ask upper layers for a disconnect reason. The upper layer must not
    support this callback and in that case it will nicely default to the
    existing behavior. If an upper layer like L2CAP can provide a disconnect
    reason that one will be used to disconnect the ACL or SCO link.
    
    No modification to the ACL disconnect timeout have been made. So in case
    of Linux to Linux connection the initiator will disconnect the ACL link
    before the acceptor side can signal the specific disconnect reason. That
    is perfectly fine since Linux doesn't make use of this value anyway. The
    L2CAP layer has a perfect valid error code for rejecting connection due
    to a security violation. It is unclear why the Bluetooth specification
    insists on having specific HCI disconnect reason.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 9473fce499e7..01f9316b4c23 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -478,7 +478,8 @@ struct hci_proto {
 
 	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
 	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
-	int (*disconn_ind)	(struct hci_conn *conn, __u8 reason);
+	int (*disconn_ind)	(struct hci_conn *conn);
+	int (*disconn_cfm)	(struct hci_conn *conn, __u8 reason);
 	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
 	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
@@ -513,17 +514,33 @@ static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
 		hp->connect_cfm(conn, status);
 }
 
-static inline void hci_proto_disconn_ind(struct hci_conn *conn, __u8 reason)
+static inline int hci_proto_disconn_ind(struct hci_conn *conn)
 {
 	register struct hci_proto *hp;
+	int reason = 0x13;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->disconn_ind)
-		hp->disconn_ind(conn, reason);
+		reason = hp->disconn_ind(conn);
 
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->disconn_ind)
-		hp->disconn_ind(conn, reason);
+		reason = hp->disconn_ind(conn);
+
+	return reason;
+}
+
+static inline void hci_proto_disconn_cfm(struct hci_conn *conn, __u8 reason)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_cfm)
+		hp->disconn_cfm(conn, reason);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_cfm)
+		hp->disconn_cfm(conn, reason);
 }
 
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)

commit 435fef20acfc48f46476abad55b0cd3aa47b8365
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 9 03:55:28 2009 +0100

    Bluetooth: Don't enforce authentication for L2CAP PSM 1 and 3
    
    The recommendation for the L2CAP PSM 1 (SDP) is to not use any kind
    of authentication or encryption. So don't trigger authentication
    for incoming and outgoing SDP connections.
    
    For L2CAP PSM 3 (RFCOMM) there is no clear requirement, but with
    Bluetooth 2.1 the initiator is required to enable authentication
    and encryption first and this gets enforced. So there is no need
    to trigger an additional authentication step. The RFCOMM service
    security will make sure that a secure enough link key is present.
    
    When the encryption gets enabled after the SDP connection setup,
    then switch the security level from SDP to low security.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f75028b33883..9473fce499e7 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -597,6 +597,9 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encr
 {
 	struct list_head *p;
 
+	if (conn->sec_level == BT_SECURITY_SDP)
+		conn->sec_level = BT_SECURITY_LOW;
+
 	hci_proto_encrypt_cfm(conn, status, encrypt);
 
 	read_lock_bh(&hci_cb_list_lock);

commit 0684e5f9fb9e3f7e168ab831dfca693bcb44805b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 9 02:48:38 2009 +0100

    Bluetooth: Use general bonding whenever possible
    
    When receiving incoming connection to specific services, always use
    general bonding. This ensures that the link key gets stored and can be
    used for further authentications.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 4b14972c1694..f75028b33883 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -328,7 +328,7 @@ void hci_conn_check_pending(struct hci_dev *hdev);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
-int hci_conn_security(struct hci_conn *conn, __u8 sec_level);
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 

commit 8c1b235594fbab9a13240a1dac12ea9fd99b6440
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 15 21:58:04 2009 +0100

    Bluetooth: Add enhanced security model for Simple Pairing
    
    The current security model is based around the flags AUTH, ENCRYPT and
    SECURE. Starting with support for the Bluetooth 2.1 specification this is
    no longer sufficient. The different security levels are now defined as
    SDP, LOW, MEDIUM and SECURE.
    
    Previously it was possible to set each security independently, but this
    actually doesn't make a lot of sense. For Bluetooth the encryption depends
    on a previous successful authentication. Also you can only update your
    existing link key if you successfully created at least one before. And of
    course the update of link keys without having proper encryption in place
    is a security issue.
    
    The new security levels from the Bluetooth 2.1 specification are now
    used internally. All old settings are mapped to the new values and this
    way it ensures that old applications still work. The only limitation
    is that it is no longer possible to set authentication without also
    enabling encryption. No application should have done this anyway since
    this is actually a security issue. Without encryption the integrity of
    the authentication can't be guaranteed.
    
    As default for a new L2CAP or RFCOMM connection, the LOW security level
    is used. The only exception here are the service discovery sessions on
    PSM 1 where SDP level is used. To have similar security strength as with
    a Bluetooth 2.0 and before combination key, the MEDIUM level should be
    used. This is according to the Bluetooth specification. The MEDIUM level
    will not require any kind of man-in-the-middle (MITM) protection. Only
    the HIGH security level will require this.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 46a43b721dd6..4b14972c1694 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -169,6 +169,7 @@ struct hci_conn {
 	__u16            link_policy;
 	__u32		 link_mode;
 	__u8             auth_type;
+	__u8             sec_level;
 	__u8             power_save;
 	unsigned long	 pend;
 
@@ -325,12 +326,11 @@ int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
 int hci_conn_check_link_mode(struct hci_conn *conn);
-int hci_conn_auth(struct hci_conn *conn);
-int hci_conn_encrypt(struct hci_conn *conn);
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level);
 int hci_conn_change_link_key(struct hci_conn *conn);
-int hci_conn_switch_role(struct hci_conn *conn, uint8_t role);
+int hci_conn_switch_role(struct hci_conn *conn, __u8 role);
 
 void hci_conn_enter_active_mode(struct hci_conn *conn);
 void hci_conn_enter_sniff_mode(struct hci_conn *conn);
@@ -470,26 +470,25 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 
 /* ----- HCI protocols ----- */
 struct hci_proto {
-	char 		*name;
+	char		*name;
 	unsigned int	id;
 	unsigned long	flags;
 
 	void		*priv;
 
-	int (*connect_ind) 	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
+	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
 	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
 	int (*disconn_ind)	(struct hci_conn *conn, __u8 reason);
 	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
-	int (*auth_cfm)		(struct hci_conn *conn, __u8 status);
-	int (*encrypt_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 };
 
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
 {
 	register struct hci_proto *hp;
 	int mask = 0;
-	
+
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->connect_ind)
 		mask |= hp->connect_ind(hdev, bdaddr, type);
@@ -530,14 +529,20 @@ static inline void hci_proto_disconn_ind(struct hci_conn *conn, __u8 reason)
 static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 {
 	register struct hci_proto *hp;
+	__u8 encrypt;
+
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+		return;
+
+	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->auth_cfm)
-		hp->auth_cfm(conn, status);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 
 	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->auth_cfm)
-		hp->auth_cfm(conn, status);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 }
 
 static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
@@ -545,12 +550,12 @@ static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u
 	register struct hci_proto *hp;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
-	if (hp && hp->encrypt_cfm)
-		hp->encrypt_cfm(conn, status, encrypt);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 
 	hp = hci_proto[HCI_PROTO_SCO];
-	if (hp && hp->encrypt_cfm)
-		hp->encrypt_cfm(conn, status, encrypt);
+	if (hp && hp->security_cfm)
+		hp->security_cfm(conn, status, encrypt);
 }
 
 int hci_register_proto(struct hci_proto *hproto);
@@ -562,8 +567,7 @@ struct hci_cb {
 
 	char *name;
 
-	void (*auth_cfm)	(struct hci_conn *conn, __u8 status);
-	void (*encrypt_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
 	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
 };
@@ -571,14 +575,20 @@ struct hci_cb {
 static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
 {
 	struct list_head *p;
+	__u8 encrypt;
 
 	hci_proto_auth_cfm(conn, status);
 
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+		return;
+
+	encrypt = (conn->link_mode & HCI_LM_ENCRYPT) ? 0x01 : 0x00;
+
 	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
-		if (cb->auth_cfm)
-			cb->auth_cfm(conn, status);
+		if (cb->security_cfm)
+			cb->security_cfm(conn, status, encrypt);
 	}
 	read_unlock_bh(&hci_cb_list_lock);
 }
@@ -592,8 +602,8 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encr
 	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {
 		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
-		if (cb->encrypt_cfm)
-			cb->encrypt_cfm(conn, status, encrypt);
+		if (cb->security_cfm)
+			cb->security_cfm(conn, status, encrypt);
 	}
 	read_unlock_bh(&hci_cb_list_lock);
 }

commit e7c29cb16c833441fd2160642bb13025f4e7ac70
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 9 07:19:20 2008 +0200

    [Bluetooth] Reject L2CAP connections on an insecure ACL link
    
    The Security Mode 4 of the Bluetooth 2.1 specification has strict
    authentication and encryption requirements. It is the initiators job
    to create a secure ACL link. However in case of malicious devices, the
    acceptor has to make sure that the ACL is encrypted before allowing
    any kind of L2CAP connection. The only exception here is the PSM 1 for
    the service discovery protocol, because that is allowed to run on an
    insecure ACL link.
    
    Previously it was enough to reject a L2CAP connection during the
    connection setup phase, but with Bluetooth 2.1 it is forbidden to
    do any L2CAP protocol exchange on an insecure link (except SDP).
    
    The new hci_conn_check_link_mode() function can be used to check the
    integrity of an ACL link. This functions also takes care of the cases
    where Security Mode 4 is disabled or one of the devices is based on
    an older specification.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 5e785b968e7e..46a43b721dd6 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -326,6 +326,7 @@ void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type);
+int hci_conn_check_link_mode(struct hci_conn *conn);
 int hci_conn_auth(struct hci_conn *conn);
 int hci_conn_encrypt(struct hci_conn *conn);
 int hci_conn_change_link_key(struct hci_conn *conn);

commit 09ab6f4c2376a0fc31abde1e2991513f900ea825
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 9 07:19:20 2008 +0200

    [Bluetooth] Enforce correct authentication requirements
    
    With the introduction of Security Mode 4 and Simple Pairing from the
    Bluetooth 2.1 specification it became mandatory that the initiator
    requires authentication and encryption before any L2CAP channel can
    be established. The only exception here is PSM 1 for the service
    discovery protocol (SDP). It is meant to be used without any encryption
    since it contains only public information. This is how Bluetooth 2.0
    and before handle connections on PSM 1.
    
    For Bluetooth 2.1 devices the pairing procedure differentiates between
    no bonding, general bonding and dedicated bonding. The L2CAP layer
    wrongly uses always general bonding when creating new connections, but it
    should not do this for SDP connections. In this case the authentication
    requirement should be no bonding and the just-works model should be used,
    but in case of non-SDP connection it is required to use general bonding.
    
    If the new connection requires man-in-the-middle (MITM) protection, it
    also first wrongly creates an unauthenticated link key and then later on
    requests an upgrade to an authenticated link key to provide full MITM
    protection. With Simple Pairing the link key generation is an expensive
    operation (compared to Bluetooth 2.0 and before) and doing this twice
    during a connection setup causes a noticeable delay when establishing
    a new connection. This should be avoided to not regress from the expected
    Bluetooth 2.0 connection times. The authentication requirements are known
    up-front and so enforce them.
    
    To fulfill these requirements the hci_connect() function has been extended
    with an authentication requirement parameter that will be stored inside
    the connection information and can be retrieved by userspace at any
    time. This allows the correct IO capabilities exchange and results in
    the expected behavior.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index cbf751094688..5e785b968e7e 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -325,7 +325,7 @@ int hci_conn_del(struct hci_conn *conn);
 void hci_conn_hash_flush(struct hci_dev *hdev);
 void hci_conn_check_pending(struct hci_dev *hdev);
 
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *src);
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type);
 int hci_conn_auth(struct hci_conn *conn);
 int hci_conn_encrypt(struct hci_conn *conn);
 int hci_conn_change_link_key(struct hci_conn *conn);

commit 40be492fe4fab829951681860c2bb26fa1d5fe4a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:50 2008 +0200

    [Bluetooth] Export details about authentication requirements
    
    With the Simple Pairing support, the authentication requirements are
    an explicit setting during the bonding process. Track and enforce the
    requirements and allow higher layers like L2CAP and RFCOMM to increase
    them if needed.
    
    This patch introduces a new IOCTL that allows to query the current
    authentication requirements. It is also possible to detect Simple
    Pairing support in the kernel this way.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 28fbd0caa534..cbf751094688 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -168,6 +168,7 @@ struct hci_conn {
 	__u16            pkt_type;
 	__u16            link_policy;
 	__u32		 link_mode;
+	__u8             auth_type;
 	__u8             power_save;
 	unsigned long	 pend;
 
@@ -422,6 +423,7 @@ int hci_get_dev_list(void __user *arg);
 int hci_get_dev_info(void __user *arg);
 int hci_get_conn_list(void __user *arg);
 int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
+int hci_get_auth_info(struct hci_dev *hdev, void __user *arg);
 int hci_inquiry(void __user *arg);
 
 void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);

commit 769be974d0c7b4fe1a52f9cdaad22259b60953f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:49 2008 +0200

    [Bluetooth] Use ACL config stage to retrieve remote features
    
    The Bluetooth technology introduces new features on a regular basis
    and for some of them it is important that the hardware on both sides
    support them. For features like Simple Pairing it is important that
    the host stacks on both sides have switched this feature on. To make
    valid decisions, a config stage during ACL link establishment has been
    introduced that retrieves remote features and if needed also the remote
    extended features (known as remote host features) before signalling
    this link as connected.
    
    This change introduces full reference counting of incoming and outgoing
    ACL links and the Bluetooth core will disconnect both if no owner of it
    is present. To better handle interoperability during the pairing phase
    the disconnect timeout for incoming connections has been increased to
    10 seconds. This is five times more than for outgoing connections.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f73cc2945700..28fbd0caa534 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -348,7 +348,7 @@ static inline void hci_conn_put(struct hci_conn *conn)
 			if (conn->state == BT_CONNECTED) {
 				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
 				if (!conn->out)
-					timeo *= 2;
+					timeo *= 5;
 			} else
 				timeo = msecs_to_jiffies(10);
 		} else
@@ -463,6 +463,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
 #define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
 #define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
+#define lmp_ssp_capable(dev)       ((dev)->features[6] & LMP_SIMPLE_PAIR)
 
 /* ----- HCI protocols ----- */
 struct hci_proto {

commit 41a96212b3b7b3cd59e8e8d33e6dabf0e21d9778
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:48 2008 +0200

    [Bluetooth] Track status of remote Simple Pairing mode
    
    The Simple Pairing process can only be used if both sides have the
    support enabled in the host stack. The current Bluetooth specification
    has three ways to detect this support.
    
    If an Extended Inquiry Result has been sent during inquiry then it
    is safe to assume that Simple Pairing is enabled. It is not allowed
    to enable Extended Inquiry without Simple Pairing. During the remote
    name request phase a notification with the remote host supported
    features will be sent to indicate Simple Pairing support. Also the
    second page of the remote extended features can indicate support for
    Simple Pairing.
    
    For all three cases the value of remote Simple Pairing mode is stored
    in the inquiry cache for later use.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b85754e29a78..f73cc2945700 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -40,6 +40,7 @@ struct inquiry_data {
 	__u8		dev_class[3];
 	__le16		clock_offset;
 	__s8		rssi;
+	__u8		ssp_mode;
 };
 
 struct inquiry_entry {
@@ -162,6 +163,7 @@ struct hci_conn {
 	__u8		 attempt;
 	__u8		 dev_class[3];
 	__u8             features[8];
+	__u8             ssp_mode;
 	__u16            interval;
 	__u16            pkt_type;
 	__u16            link_policy;

commit 333140b57fa7867bc92e5ee879b6ac4ef5e1d867
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:48 2008 +0200

    [Bluetooth] Track status of Simple Pairing mode
    
    The Simple Pairing feature is optional and needs to be enabled by the
    host stack first. The Linux kernel relies on the Bluetooth daemon to
    either enable or disable it, but at any time it needs to know the
    current state of the Simple Pairing mode. So track any changes made
    by external entities and store the current mode in the HCI device
    structure.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6424d63e3395..b85754e29a78 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -75,6 +75,7 @@ struct hci_dev {
 	__u8		dev_class[3];
 	__u8		features[8];
 	__u8		commands[64];
+	__u8		ssp_mode;
 	__u8		hci_ver;
 	__u16		hci_rev;
 	__u16		manufacturer;

commit a8746417e864da1ed36dd2432a399fbeb843c2a0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:46 2008 +0200

    [Bluetooth] Track connection packet type changes
    
    The connection packet type can be changed after the connection has been
    established and thus needs to be properly tracked to ensure that the
    host stack has always correct and valid information about it.
    
    On incoming connections the Bluetooth core switches the supported packet
    types to the configured list for this controller. However the usefulness
    of this feature has been questioned a lot. The general consent is that
    every Bluetooth host stack should enable as many packet types as the
    hardware actually supports and leave the decision to the link manager
    software running on the Bluetooth chip.
    
    When running on Bluetooth 2.0 or later hardware, don't change the packet
    type for incoming connections anymore. This hardware likely supports
    Enhanced Data Rate and thus leave it completely up to the link manager
    to pick the best packet type.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c8255adee8f5..6424d63e3395 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -162,6 +162,7 @@ struct hci_conn {
 	__u8		 dev_class[3];
 	__u8             features[8];
 	__u16            interval;
+	__u16            pkt_type;
 	__u16            link_policy;
 	__u32		 link_mode;
 	__u8             power_save;

commit 9719f8afce34d3d04e884873a8a5e3483e30974c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:45 2008 +0200

    [Bluetooth] Disconnect when encryption gets disabled
    
    The Bluetooth specification allows to enable or disable the encryption
    of an ACL link at any time by either the peer or the remote device. If
    a L2CAP or RFCOMM connection requested an encrypted link, they will now
    disconnect that link if the encryption gets disabled. Higher protocols
    that don't care about encryption (like SDP) are not affected.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ea13baa3851b..c8255adee8f5 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -474,7 +474,7 @@ struct hci_proto {
 	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
 	int (*auth_cfm)		(struct hci_conn *conn, __u8 status);
-	int (*encrypt_cfm)	(struct hci_conn *conn, __u8 status);
+	int (*encrypt_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
 };
 
 static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
@@ -532,17 +532,17 @@ static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
 		hp->auth_cfm(conn, status);
 }
 
-static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status)
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
 {
 	register struct hci_proto *hp;
 
 	hp = hci_proto[HCI_PROTO_L2CAP];
 	if (hp && hp->encrypt_cfm)
-		hp->encrypt_cfm(conn, status);
+		hp->encrypt_cfm(conn, status, encrypt);
 
 	hp = hci_proto[HCI_PROTO_SCO];
 	if (hp && hp->encrypt_cfm)
-		hp->encrypt_cfm(conn, status);
+		hp->encrypt_cfm(conn, status, encrypt);
 }
 
 int hci_register_proto(struct hci_proto *hproto);
@@ -579,7 +579,7 @@ static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encr
 {
 	struct list_head *p;
 
-	hci_proto_encrypt_cfm(conn, status);
+	hci_proto_encrypt_cfm(conn, status, encrypt);
 
 	read_lock_bh(&hci_cb_list_lock);
 	list_for_each(p, &hci_cb_list) {

commit b6a0dc822497e1c0b9e8c4add270cc27fce48454
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 20 14:55:10 2007 +0200

    [Bluetooth] Add support for handling simple eSCO links
    
    With the Bluetooth 1.2 specification the Extended SCO feature for
    better audio connections was introduced. So far the Bluetooth core
    wasn't able to handle any eSCO connections correctly. This patch
    adds simple eSCO support while keeping backward compatibility with
    older devices.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 0db89ed6b00c..ea13baa3851b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -313,6 +313,7 @@ static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
 void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
+void hci_setup_sync(struct hci_conn *conn, __u16 handle);
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
 int hci_conn_del(struct hci_conn *conn);

commit a9de9248064bfc8eb0a183a6a951a4e7b5ca10a4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 20 13:33:56 2007 +0200

    [Bluetooth] Switch from OGF+OCF to using only opcodes
    
    The Bluetooth HCI commands are divided into logical OGF groups for
    easier identification of their purposes. While this still makes sense
    for the written specification, its makes the code only more complex
    and harder to read. So instead of using separate OGF and OCF values
    to identify the commands, use a common 16-bit opcode that combines
    both values. As a side effect this also reduces the complexity of
    OGF and OCF calculations during command header parsing.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8f67c8a7169b..0db89ed6b00c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -71,7 +71,10 @@ struct hci_dev {
 	__u16		id;
 	__u8		type;
 	bdaddr_t	bdaddr;
+	__u8		dev_name[248];
+	__u8		dev_class[3];
 	__u8		features[8];
+	__u8		commands[64];
 	__u8		hci_ver;
 	__u16		hci_rev;
 	__u16		manufacturer;
@@ -312,8 +315,9 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
-int    hci_conn_del(struct hci_conn *conn);
-void   hci_conn_hash_flush(struct hci_dev *hdev);
+int hci_conn_del(struct hci_conn *conn);
+void hci_conn_hash_flush(struct hci_dev *hdev);
+void hci_conn_check_pending(struct hci_dev *hdev);
 
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *src);
 int hci_conn_auth(struct hci_conn *conn);
@@ -617,11 +621,11 @@ int hci_unregister_cb(struct hci_cb *hcb);
 int hci_register_notifier(struct notifier_block *nb);
 int hci_unregister_notifier(struct notifier_block *nb);
 
-int hci_send_cmd(struct hci_dev *hdev, __u16 ogf, __u16 ocf, __u32 plen, void *param);
+int hci_send_cmd(struct hci_dev *hdev, __u16 opcode, __u32 plen, void *param);
 int hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
 int hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
 
-void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 ogf, __u16 ocf);
+void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 opcode);
 
 void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
 

commit 5b7f990927fe87ad3bec762a33c0e72bcbf6841e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 11 09:51:55 2007 +0200

    [Bluetooth] Add basics to better support and handle eSCO links
    
    To better support and handle eSCO links in the future a bunch of
    constants needs to be added and some basic routines need to be
    updated. This is the initial step.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7c78744ec0fd..8f67c8a7169b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -78,6 +78,7 @@ struct hci_dev {
 	__u16		voice_setting;
 
 	__u16		pkt_type;
+	__u16		esco_type;
 	__u16		link_policy;
 	__u16		link_mode;
 
@@ -452,6 +453,7 @@ void hci_conn_del_sysfs(struct hci_conn *conn);
 #define lmp_encrypt_capable(dev)   ((dev)->features[0] & LMP_ENCRYPT)
 #define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
 #define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
+#define lmp_esco_capable(dev)      ((dev)->features[3] & LMP_ESCO)
 
 /* ----- HCI protocols ----- */
 struct hci_proto {

commit ef222013fc8c1a2fcba5c7ab169be8ffcb778ec4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 11 06:42:04 2007 +0200

    [Bluetooth] Add hci_recv_fragment() helper function
    
    Most drivers must handle fragmented HCI data packets and events. This
    patch adds a generic function for their reassembly to the Bluetooth
    core layer and thus allows to shrink the complexity of the drivers.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index c0fc39620f36..7c78744ec0fd 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -109,6 +109,7 @@ struct hci_dev {
 	struct sk_buff_head	cmd_q;
 
 	struct sk_buff		*sent_cmd;
+	struct sk_buff		*reassembly[3];
 
 	struct semaphore	req_lock;
 	wait_queue_head_t	req_wait_q;
@@ -437,6 +438,8 @@ static inline int hci_recv_frame(struct sk_buff *skb)
 	return 0;
 }
 
+int hci_recv_fragment(struct hci_dev *hdev, int type, void *data, int count);
+
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);
 void hci_conn_add_sysfs(struct hci_conn *conn);

commit 4c67bc74f016b0d360b8573e18969c0ff7926974
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 15 17:30:56 2006 +0200

    [Bluetooth] Support concurrent connect requests
    
    Most Bluetooth chips don't support concurrent connect requests, because
    this would involve a multiple baseband page with only one radio. In the
    case an upper layer like L2CAP requests a concurrent connect these chips
    return the error "Command Disallowed" for the second request. If this
    happens it the responsibility of the Bluetooth core to queue the request
    and try again after the previous connect attempt has been completed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index df22efcfcc0b..c0fc39620f36 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -153,6 +153,7 @@ struct hci_conn {
 	__u8             mode;
 	__u8		 type;
 	__u8		 out;
+	__u8		 attempt;
 	__u8		 dev_class[3];
 	__u8             features[8];
 	__u16            interval;
@@ -289,6 +290,22 @@ static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
 	return NULL;
 }
 
+static inline struct hci_conn *hci_conn_hash_lookup_state(struct hci_dev *hdev,
+					__u8 type, __u16 state)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn  *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && c->state == state)
+			return c;
+	}
+	return NULL;
+}
+
+void hci_acl_connect(struct hci_conn *conn);
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
 void hci_add_sco(struct hci_conn *conn, __u16 handle);
 

commit 6ac59344ef25d5f0ebadb5663cf700d25d2a3886
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 26 09:43:48 2006 +0200

    [Bluetooth] Support create connection cancel command
    
    In case of non-blocking connects it is possible that the last user
    of an ACL link quits before the connection has been fully established.
    This will lead to a race condition where the internal state of a
    connection is closed, but the actual link has been established and is
    active. In case of Bluetooth 1.2 and later devices it is possible to
    call create connection cancel to abort the connect. For older devices
    the disconnect timer will be used to trigger the needed disconnect.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7451a9c92d9d..df22efcfcc0b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -316,10 +316,13 @@ static inline void hci_conn_put(struct hci_conn *conn)
 	if (atomic_dec_and_test(&conn->refcnt)) {
 		unsigned long timeo;
 		if (conn->type == ACL_LINK) {
-			timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
-			if (!conn->out)
-				timeo *= 2;
 			del_timer(&conn->idle_timer);
+			if (conn->state == BT_CONNECTED) {
+				timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
+				if (!conn->out)
+					timeo *= 2;
+			} else
+				timeo = msecs_to_jiffies(10);
 		} else
 			timeo = msecs_to_jiffies(10);
 		mod_timer(&conn->disc_timer, jiffies + timeo);

commit 1143e5a6d4d69cd36d44e0184769aa2b17041a10
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Sep 23 09:57:20 2006 +0200

    [Bluetooth] Read local version information on device init
    
    The local version information are needed to identify certain feature
    sets of devices. They must be read on device init and stored for later
    use. It is also possible to access them through the device model.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 263e42b68e8d..7451a9c92d9d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -72,6 +72,9 @@ struct hci_dev {
 	__u8		type;
 	bdaddr_t	bdaddr;
 	__u8		features[8];
+	__u8		hci_ver;
+	__u16		hci_rev;
+	__u16		manufacturer;
 	__u16		voice_setting;
 
 	__u16		pkt_type;

commit b219e3ac66183fc9771b94af931fb5fd41d586ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 6 12:38:46 2006 +0200

    [Bluetooth] Integrate low-level connections into the driver model
    
    This patch integrates the low-level connections (ACL and SCO) into the
    driver model. Every connection is presented as device with the parent
    set to its host controller device.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d84855fe7336..263e42b68e8d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -165,6 +165,10 @@ struct hci_conn {
 	struct timer_list disc_timer;
 	struct timer_list idle_timer;
 
+	struct work_struct work;
+
+	struct device	dev;
+
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
@@ -412,6 +416,8 @@ static inline int hci_recv_frame(struct sk_buff *skb)
 
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);
+void hci_conn_add_sysfs(struct hci_conn *conn);
+void hci_conn_del_sysfs(struct hci_conn *conn);
 
 #define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
 

commit a91f2e396f5b32b21d842b4757bc8de5e88eac66
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 3 10:02:41 2006 +0200

    [Bluetooth] Use real devices for host controllers
    
    This patch converts the Bluetooth class devices into real devices. The
    Bluetooth class is kept and the driver core provides the appropriate
    symlinks for backward compatibility.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index ae67b36d76dc..d84855fe7336 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -124,8 +124,8 @@ struct hci_dev {
 
 	atomic_t 		promisc;
 
-	struct device		*dev;
-	struct class_device	class_dev;
+	struct device		*parent;
+	struct device		dev;
 
 	struct module 		*owner;
 
@@ -413,7 +413,7 @@ static inline int hci_recv_frame(struct sk_buff *skb)
 int hci_register_sysfs(struct hci_dev *hdev);
 void hci_unregister_sysfs(struct hci_dev *hdev);
 
-#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->class_dev.dev = (pdev))
+#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->parent = (pdev))
 
 /* ----- LMP capabilities ----- */
 #define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)

commit 27d35284258c596900e0e41c46932ec4abe6a7b1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 3 10:02:37 2006 +0200

    [Bluetooth] Add platform device for virtual and serial devices
    
    This patch adds a generic Bluetooth platform device that can be used
    as parent device by virtual and serial devices.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index f6852707bd64..ae67b36d76dc 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -124,6 +124,7 @@ struct hci_dev {
 
 	atomic_t 		promisc;
 
+	struct device		*dev;
 	struct class_device	class_dev;
 
 	struct module 		*owner;

commit 04837f6447c7f3ef114cda1ad761822dedbff8cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 3 10:02:33 2006 +0200

    [Bluetooth] Add automatic sniff mode support
    
    This patch introduces the automatic sniff mode feature. This allows
    the host to switch idle connections into sniff mode to safe power.
    
    Signed-off-by: Ulisses Furquim <ulissesf@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index bb9f81dc8723..f6852707bd64 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -31,10 +31,7 @@
 #define HCI_PROTO_L2CAP	0
 #define HCI_PROTO_SCO	1
 
-#define HCI_INIT_TIMEOUT (HZ * 10)
-
 /* HCI Core structures */
-
 struct inquiry_data {
 	bdaddr_t	bdaddr;
 	__u8		pscan_rep_mode;
@@ -81,6 +78,10 @@ struct hci_dev {
 	__u16		link_policy;
 	__u16		link_mode;
 
+	__u32		idle_timeout;
+	__u16		sniff_min_interval;
+	__u16		sniff_max_interval;
+
 	unsigned long	quirks;
 
 	atomic_t	cmd_cnt;
@@ -145,18 +146,24 @@ struct hci_conn {
 	bdaddr_t	 dst;
 	__u16		 handle;
 	__u16		 state;
+	__u8             mode;
 	__u8		 type;
 	__u8		 out;
 	__u8		 dev_class[3];
+	__u8             features[8];
+	__u16            interval;
+	__u16            link_policy;
 	__u32		 link_mode;
+	__u8             power_save;
 	unsigned long	 pend;
-	
+
 	unsigned int	 sent;
-	
+
 	struct sk_buff_head data_q;
 
-	struct timer_list timer;
-	
+	struct timer_list disc_timer;
+	struct timer_list idle_timer;
+
 	struct hci_dev	*hdev;
 	void		*l2cap_data;
 	void		*sco_data;
@@ -211,7 +218,8 @@ void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
 enum {
 	HCI_CONN_AUTH_PEND,
 	HCI_CONN_ENCRYPT_PEND,
-	HCI_CONN_RSWITCH_PEND
+	HCI_CONN_RSWITCH_PEND,
+	HCI_CONN_MODE_CHANGE_PEND,
 };
 
 static inline void hci_conn_hash_init(struct hci_dev *hdev)
@@ -286,31 +294,27 @@ int hci_conn_encrypt(struct hci_conn *conn);
 int hci_conn_change_link_key(struct hci_conn *conn);
 int hci_conn_switch_role(struct hci_conn *conn, uint8_t role);
 
-static inline void hci_conn_set_timer(struct hci_conn *conn, unsigned long timeout)
-{
-	mod_timer(&conn->timer, jiffies + timeout);
-}
-
-static inline void hci_conn_del_timer(struct hci_conn *conn)
-{
-	del_timer(&conn->timer);
-}
+void hci_conn_enter_active_mode(struct hci_conn *conn);
+void hci_conn_enter_sniff_mode(struct hci_conn *conn);
 
 static inline void hci_conn_hold(struct hci_conn *conn)
 {
 	atomic_inc(&conn->refcnt);
-	hci_conn_del_timer(conn);
+	del_timer(&conn->disc_timer);
 }
 
 static inline void hci_conn_put(struct hci_conn *conn)
 {
 	if (atomic_dec_and_test(&conn->refcnt)) {
+		unsigned long timeo;
 		if (conn->type == ACL_LINK) {
-			unsigned long timeo = (conn->out) ?
-				HCI_DISCONN_TIMEOUT : HCI_DISCONN_TIMEOUT * 2;
-			hci_conn_set_timer(conn, timeo);
+			timeo = msecs_to_jiffies(HCI_DISCONN_TIMEOUT);
+			if (!conn->out)
+				timeo *= 2;
+			del_timer(&conn->idle_timer);
 		} else
-			hci_conn_set_timer(conn, HZ / 100);
+			timeo = msecs_to_jiffies(10);
+		mod_timer(&conn->disc_timer, jiffies + timeo);
 	}
 }
 
@@ -411,8 +415,10 @@ void hci_unregister_sysfs(struct hci_dev *hdev);
 #define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->class_dev.dev = (pdev))
 
 /* ----- LMP capabilities ----- */
-#define lmp_rswitch_capable(dev) (dev->features[0] & LMP_RSWITCH)
-#define lmp_encrypt_capable(dev) (dev->features[0] & LMP_ENCRYPT)
+#define lmp_rswitch_capable(dev)   ((dev)->features[0] & LMP_RSWITCH)
+#define lmp_encrypt_capable(dev)   ((dev)->features[0] & LMP_ENCRYPT)
+#define lmp_sniff_capable(dev)     ((dev)->features[0] & LMP_SNIFF)
+#define lmp_sniffsubr_capable(dev) ((dev)->features[5] & LMP_SNIFF_SUBR)
 
 /* ----- HCI protocols ----- */
 struct hci_proto {

commit be9d122730c878baafe11e70d1436faac229f2fc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Nov 8 09:57:38 2005 -0800

    [Bluetooth]: Remove the usage of /proc completely
    
    This patch removes all relics of the /proc usage from the Bluetooth
    subsystem core and its upper layers. All the previous information are
    now available via /sys/class/bluetooth through appropriate functions.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index adb94508259b..bb9f81dc8723 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -25,7 +25,6 @@
 #ifndef __HCI_CORE_H
 #define __HCI_CORE_H
 
-#include <linux/proc_fs.h>
 #include <net/bluetooth/hci.h>
 
 /* HCI upper protocols */
@@ -34,8 +33,6 @@
 
 #define HCI_INIT_TIMEOUT (HZ * 10)
 
-extern struct proc_dir_entry *proc_bt_hci;
-
 /* HCI Core structures */
 
 struct inquiry_data {
@@ -126,10 +123,6 @@ struct hci_dev {
 
 	atomic_t 		promisc;
 
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry	*proc;
-#endif
-
 	struct class_device	class_dev;
 
 	struct module 		*owner;

commit 1ebb92521d0bc2d4ef772730d29333c06b807191
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Nov 8 09:57:21 2005 -0800

    [Bluetooth]: Add endian annotations to the core
    
    This patch adds the endian annotations to the Bluetooth core.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 7f933f302078..adb94508259b 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -44,7 +44,7 @@ struct inquiry_data {
 	__u8		pscan_period_mode;
 	__u8		pscan_mode;
 	__u8		dev_class[3];
-	__u16		clock_offset;
+	__le16		clock_offset;
 	__s8		rssi;
 };
 

commit a61bbcf28a8cb0ba56f8193d512f7222e711a294
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 14 17:24:31 2005 -0700

    [NET]: Store skb->timestamp as offset to a base timestamp
    
    Reduces skb size by 8 bytes on 64-bit.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6d63a47c731b..7f933f302078 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -404,7 +404,7 @@ static inline int hci_recv_frame(struct sk_buff *skb)
 	bt_cb(skb)->incoming = 1;
 
 	/* Time stamp */
-	do_gettimeofday(&skb->stamp);
+	__net_timestamp(skb);
 
 	/* Queue frame for rx task */
 	skb_queue_tail(&hdev->rx_q, skb);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
new file mode 100644
index 000000000000..6d63a47c731b
--- /dev/null
+++ b/include/net/bluetooth/hci_core.h
@@ -0,0 +1,626 @@
+/* 
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+#ifndef __HCI_CORE_H
+#define __HCI_CORE_H
+
+#include <linux/proc_fs.h>
+#include <net/bluetooth/hci.h>
+
+/* HCI upper protocols */
+#define HCI_PROTO_L2CAP	0
+#define HCI_PROTO_SCO	1
+
+#define HCI_INIT_TIMEOUT (HZ * 10)
+
+extern struct proc_dir_entry *proc_bt_hci;
+
+/* HCI Core structures */
+
+struct inquiry_data {
+	bdaddr_t	bdaddr;
+	__u8		pscan_rep_mode;
+	__u8		pscan_period_mode;
+	__u8		pscan_mode;
+	__u8		dev_class[3];
+	__u16		clock_offset;
+	__s8		rssi;
+};
+
+struct inquiry_entry {
+	struct inquiry_entry 	*next;
+	__u32			timestamp;
+	struct inquiry_data	data;
+};
+
+struct inquiry_cache {
+	spinlock_t 		lock;
+	__u32			timestamp;
+	struct inquiry_entry 	*list;
+};
+
+struct hci_conn_hash {
+	struct list_head list;
+	spinlock_t       lock;
+	unsigned int     acl_num;
+	unsigned int     sco_num;
+};
+
+struct hci_dev {
+	struct list_head list;
+	spinlock_t	lock;
+	atomic_t	refcnt;
+
+	char		name[8];
+	unsigned long	flags;
+	__u16		id;
+	__u8		type;
+	bdaddr_t	bdaddr;
+	__u8		features[8];
+	__u16		voice_setting;
+
+	__u16		pkt_type;
+	__u16		link_policy;
+	__u16		link_mode;
+
+	unsigned long	quirks;
+
+	atomic_t	cmd_cnt;
+	unsigned int	acl_cnt;
+	unsigned int	sco_cnt;
+
+	unsigned int	acl_mtu;
+	unsigned int	sco_mtu;
+	unsigned int	acl_pkts;
+	unsigned int	sco_pkts;
+
+	unsigned long	cmd_last_tx;
+	unsigned long	acl_last_tx;
+	unsigned long	sco_last_tx;
+
+	struct tasklet_struct	cmd_task;
+	struct tasklet_struct	rx_task;
+	struct tasklet_struct	tx_task;
+
+	struct sk_buff_head	rx_q;
+	struct sk_buff_head	raw_q;
+	struct sk_buff_head	cmd_q;
+
+	struct sk_buff		*sent_cmd;
+
+	struct semaphore	req_lock;
+	wait_queue_head_t	req_wait_q;
+	__u32			req_status;
+	__u32			req_result;
+
+	struct inquiry_cache	inq_cache;
+	struct hci_conn_hash	conn_hash;
+
+	struct hci_dev_stats	stat;
+
+	struct sk_buff_head	driver_init;
+
+	void			*driver_data;
+	void			*core_data;
+
+	atomic_t 		promisc;
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*proc;
+#endif
+
+	struct class_device	class_dev;
+
+	struct module 		*owner;
+
+	int (*open)(struct hci_dev *hdev);
+	int (*close)(struct hci_dev *hdev);
+	int (*flush)(struct hci_dev *hdev);
+	int (*send)(struct sk_buff *skb);
+	void (*destruct)(struct hci_dev *hdev);
+	void (*notify)(struct hci_dev *hdev, unsigned int evt);
+	int (*ioctl)(struct hci_dev *hdev, unsigned int cmd, unsigned long arg);
+};
+
+struct hci_conn {
+	struct list_head list;
+
+	atomic_t	 refcnt;
+	spinlock_t	 lock;
+
+	bdaddr_t	 dst;
+	__u16		 handle;
+	__u16		 state;
+	__u8		 type;
+	__u8		 out;
+	__u8		 dev_class[3];
+	__u32		 link_mode;
+	unsigned long	 pend;
+	
+	unsigned int	 sent;
+	
+	struct sk_buff_head data_q;
+
+	struct timer_list timer;
+	
+	struct hci_dev	*hdev;
+	void		*l2cap_data;
+	void		*sco_data;
+	void		*priv;
+
+	struct hci_conn	*link;
+};
+
+extern struct hci_proto *hci_proto[];
+extern struct list_head hci_dev_list;
+extern struct list_head hci_cb_list;
+extern rwlock_t hci_dev_list_lock;
+extern rwlock_t hci_cb_list_lock;
+
+/* ----- Inquiry cache ----- */
+#define INQUIRY_CACHE_AGE_MAX   (HZ*30)   // 30 seconds
+#define INQUIRY_ENTRY_AGE_MAX   (HZ*60)   // 60 seconds
+
+#define inquiry_cache_lock(c)		spin_lock(&c->lock)
+#define inquiry_cache_unlock(c)		spin_unlock(&c->lock)
+#define inquiry_cache_lock_bh(c)	spin_lock_bh(&c->lock)
+#define inquiry_cache_unlock_bh(c)	spin_unlock_bh(&c->lock)
+
+static inline void inquiry_cache_init(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	spin_lock_init(&c->lock);
+	c->list = NULL;
+}
+
+static inline int inquiry_cache_empty(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return (c->list == NULL);
+}
+
+static inline long inquiry_cache_age(struct hci_dev *hdev)
+{
+	struct inquiry_cache *c = &hdev->inq_cache;
+	return jiffies - c->timestamp;
+}
+
+static inline long inquiry_entry_age(struct inquiry_entry *e)
+{
+	return jiffies - e->timestamp;
+}
+
+struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
+void hci_inquiry_cache_update(struct hci_dev *hdev, struct inquiry_data *data);
+
+/* ----- HCI Connections ----- */
+enum {
+	HCI_CONN_AUTH_PEND,
+	HCI_CONN_ENCRYPT_PEND,
+	HCI_CONN_RSWITCH_PEND
+};
+
+static inline void hci_conn_hash_init(struct hci_dev *hdev)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	INIT_LIST_HEAD(&h->list);
+	spin_lock_init(&h->lock);
+	h->acl_num = 0;
+	h->sco_num = 0;
+}
+
+static inline void hci_conn_hash_add(struct hci_dev *hdev, struct hci_conn *c)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	list_add(&c->list, &h->list);
+	if (c->type == ACL_LINK)
+		h->acl_num++;
+	else
+		h->sco_num++;
+}
+
+static inline void hci_conn_hash_del(struct hci_dev *hdev, struct hci_conn *c)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	list_del(&c->list);
+	if (c->type == ACL_LINK)
+		h->acl_num--;
+	else
+		h->sco_num--;
+}
+
+static inline struct hci_conn *hci_conn_hash_lookup_handle(struct hci_dev *hdev,
+					__u16 handle)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn  *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->handle == handle)
+			return c;
+	}
+	return NULL;
+}
+
+static inline struct hci_conn *hci_conn_hash_lookup_ba(struct hci_dev *hdev,
+					__u8 type, bdaddr_t *ba)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+	struct hci_conn  *c;
+
+	list_for_each(p, &h->list) {
+		c = list_entry(p, struct hci_conn, list);
+		if (c->type == type && !bacmp(&c->dst, ba))
+			return c;
+	}
+	return NULL;
+}
+
+void hci_acl_disconn(struct hci_conn *conn, __u8 reason);
+void hci_add_sco(struct hci_conn *conn, __u16 handle);
+
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
+int    hci_conn_del(struct hci_conn *conn);
+void   hci_conn_hash_flush(struct hci_dev *hdev);
+
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *src);
+int hci_conn_auth(struct hci_conn *conn);
+int hci_conn_encrypt(struct hci_conn *conn);
+int hci_conn_change_link_key(struct hci_conn *conn);
+int hci_conn_switch_role(struct hci_conn *conn, uint8_t role);
+
+static inline void hci_conn_set_timer(struct hci_conn *conn, unsigned long timeout)
+{
+	mod_timer(&conn->timer, jiffies + timeout);
+}
+
+static inline void hci_conn_del_timer(struct hci_conn *conn)
+{
+	del_timer(&conn->timer);
+}
+
+static inline void hci_conn_hold(struct hci_conn *conn)
+{
+	atomic_inc(&conn->refcnt);
+	hci_conn_del_timer(conn);
+}
+
+static inline void hci_conn_put(struct hci_conn *conn)
+{
+	if (atomic_dec_and_test(&conn->refcnt)) {
+		if (conn->type == ACL_LINK) {
+			unsigned long timeo = (conn->out) ?
+				HCI_DISCONN_TIMEOUT : HCI_DISCONN_TIMEOUT * 2;
+			hci_conn_set_timer(conn, timeo);
+		} else
+			hci_conn_set_timer(conn, HZ / 100);
+	}
+}
+
+/* ----- HCI tasks ----- */
+static inline void hci_sched_cmd(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->cmd_task);
+}
+
+static inline void hci_sched_rx(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->rx_task);
+}
+
+static inline void hci_sched_tx(struct hci_dev *hdev)
+{
+	tasklet_schedule(&hdev->tx_task);
+}
+
+/* ----- HCI Devices ----- */
+static inline void __hci_dev_put(struct hci_dev *d)
+{
+	if (atomic_dec_and_test(&d->refcnt))
+		d->destruct(d);
+}
+
+static inline void hci_dev_put(struct hci_dev *d)
+{ 
+	__hci_dev_put(d);
+	module_put(d->owner);
+}
+
+static inline struct hci_dev *__hci_dev_hold(struct hci_dev *d)
+{
+	atomic_inc(&d->refcnt);
+	return d;
+}
+
+static inline struct hci_dev *hci_dev_hold(struct hci_dev *d)
+{
+	if (try_module_get(d->owner))
+		return __hci_dev_hold(d);
+	return NULL;
+}
+
+#define hci_dev_lock(d)		spin_lock(&d->lock)
+#define hci_dev_unlock(d)	spin_unlock(&d->lock)
+#define hci_dev_lock_bh(d)	spin_lock_bh(&d->lock)
+#define hci_dev_unlock_bh(d)	spin_unlock_bh(&d->lock)
+
+struct hci_dev *hci_dev_get(int index);
+struct hci_dev *hci_get_route(bdaddr_t *src, bdaddr_t *dst);
+
+struct hci_dev *hci_alloc_dev(void);
+void hci_free_dev(struct hci_dev *hdev);
+int hci_register_dev(struct hci_dev *hdev);
+int hci_unregister_dev(struct hci_dev *hdev);
+int hci_suspend_dev(struct hci_dev *hdev);
+int hci_resume_dev(struct hci_dev *hdev);
+int hci_dev_open(__u16 dev);
+int hci_dev_close(__u16 dev);
+int hci_dev_reset(__u16 dev);
+int hci_dev_reset_stat(__u16 dev);
+int hci_dev_cmd(unsigned int cmd, void __user *arg);
+int hci_get_dev_list(void __user *arg);
+int hci_get_dev_info(void __user *arg);
+int hci_get_conn_list(void __user *arg);
+int hci_get_conn_info(struct hci_dev *hdev, void __user *arg);
+int hci_inquiry(void __user *arg);
+
+void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
+
+/* Receive frame from HCI drivers */
+static inline int hci_recv_frame(struct sk_buff *skb)
+{
+	struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+	if (!hdev || (!test_bit(HCI_UP, &hdev->flags) 
+			&& !test_bit(HCI_INIT, &hdev->flags))) {
+		kfree_skb(skb);
+		return -ENXIO;
+	}
+
+	/* Incomming skb */
+	bt_cb(skb)->incoming = 1;
+
+	/* Time stamp */
+	do_gettimeofday(&skb->stamp);
+
+	/* Queue frame for rx task */
+	skb_queue_tail(&hdev->rx_q, skb);
+	hci_sched_rx(hdev);
+	return 0;
+}
+
+int hci_register_sysfs(struct hci_dev *hdev);
+void hci_unregister_sysfs(struct hci_dev *hdev);
+
+#define SET_HCIDEV_DEV(hdev, pdev) ((hdev)->class_dev.dev = (pdev))
+
+/* ----- LMP capabilities ----- */
+#define lmp_rswitch_capable(dev) (dev->features[0] & LMP_RSWITCH)
+#define lmp_encrypt_capable(dev) (dev->features[0] & LMP_ENCRYPT)
+
+/* ----- HCI protocols ----- */
+struct hci_proto {
+	char 		*name;
+	unsigned int	id;
+	unsigned long	flags;
+
+	void		*priv;
+
+	int (*connect_ind) 	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
+	int (*connect_cfm)	(struct hci_conn *conn, __u8 status);
+	int (*disconn_ind)	(struct hci_conn *conn, __u8 reason);
+	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+	int (*recv_scodata)	(struct hci_conn *conn, struct sk_buff *skb);
+	int (*auth_cfm)		(struct hci_conn *conn, __u8 status);
+	int (*encrypt_cfm)	(struct hci_conn *conn, __u8 status);
+};
+
+static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
+{
+	register struct hci_proto *hp;
+	int mask = 0;
+	
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_ind)
+		mask |= hp->connect_ind(hdev, bdaddr, type);
+
+	return mask;
+}
+
+static inline void hci_proto_connect_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->connect_cfm)
+		hp->connect_cfm(conn, status);
+}
+
+static inline void hci_proto_disconn_ind(struct hci_conn *conn, __u8 reason)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->disconn_ind)
+		hp->disconn_ind(conn, reason);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->disconn_ind)
+		hp->disconn_ind(conn, reason);
+}
+
+static inline void hci_proto_auth_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->auth_cfm)
+		hp->auth_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->auth_cfm)
+		hp->auth_cfm(conn, status);
+}
+
+static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status)
+{
+	register struct hci_proto *hp;
+
+	hp = hci_proto[HCI_PROTO_L2CAP];
+	if (hp && hp->encrypt_cfm)
+		hp->encrypt_cfm(conn, status);
+
+	hp = hci_proto[HCI_PROTO_SCO];
+	if (hp && hp->encrypt_cfm)
+		hp->encrypt_cfm(conn, status);
+}
+
+int hci_register_proto(struct hci_proto *hproto);
+int hci_unregister_proto(struct hci_proto *hproto);
+
+/* ----- HCI callbacks ----- */
+struct hci_cb {
+	struct list_head list;
+
+	char *name;
+
+	void (*auth_cfm)	(struct hci_conn *conn, __u8 status);
+	void (*encrypt_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
+	void (*key_change_cfm)	(struct hci_conn *conn, __u8 status);
+	void (*role_switch_cfm)	(struct hci_conn *conn, __u8 status, __u8 role);
+};
+
+static inline void hci_auth_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct list_head *p;
+
+	hci_proto_auth_cfm(conn, status);
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->auth_cfm)
+			cb->auth_cfm(conn, status);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
+{
+	struct list_head *p;
+
+	hci_proto_encrypt_cfm(conn, status);
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->encrypt_cfm)
+			cb->encrypt_cfm(conn, status, encrypt);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void hci_key_change_cfm(struct hci_conn *conn, __u8 status)
+{
+	struct list_head *p;
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->key_change_cfm)
+			cb->key_change_cfm(conn, status);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
+{
+	struct list_head *p;
+
+	read_lock_bh(&hci_cb_list_lock);
+	list_for_each(p, &hci_cb_list) {
+		struct hci_cb *cb = list_entry(p, struct hci_cb, list);
+		if (cb->role_switch_cfm)
+			cb->role_switch_cfm(conn, status, role);
+	}
+	read_unlock_bh(&hci_cb_list_lock);
+}
+
+int hci_register_cb(struct hci_cb *hcb);
+int hci_unregister_cb(struct hci_cb *hcb);
+
+int hci_register_notifier(struct notifier_block *nb);
+int hci_unregister_notifier(struct notifier_block *nb);
+
+int hci_send_cmd(struct hci_dev *hdev, __u16 ogf, __u16 ocf, __u32 plen, void *param);
+int hci_send_acl(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
+int hci_send_sco(struct hci_conn *conn, struct sk_buff *skb);
+
+void *hci_sent_cmd_data(struct hci_dev *hdev, __u16 ogf, __u16 ocf);
+
+void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data);
+
+/* ----- HCI Sockets ----- */
+void hci_send_to_sock(struct hci_dev *hdev, struct sk_buff *skb);
+
+/* HCI info for socket */
+#define hci_pi(sk) ((struct hci_pinfo *) sk)
+
+struct hci_pinfo {
+	struct bt_sock    bt;
+	struct hci_dev    *hdev;
+	struct hci_filter filter;
+	__u32             cmsg_mask;
+};
+
+/* HCI security filter */
+#define HCI_SFLT_MAX_OGF  5
+
+struct hci_sec_filter {
+	__u32 type_mask;
+	__u32 event_mask[2];
+	__u32 ocf_mask[HCI_SFLT_MAX_OGF + 1][4];
+};
+
+/* ----- HCI requests ----- */
+#define HCI_REQ_DONE	  0
+#define HCI_REQ_PEND	  1
+#define HCI_REQ_CANCELED  2
+
+#define hci_req_lock(d)		down(&d->req_lock)
+#define hci_req_unlock(d)	up(&d->req_lock)
+
+void hci_req_complete(struct hci_dev *hdev, int result);
+
+#endif /* __HCI_CORE_H */
