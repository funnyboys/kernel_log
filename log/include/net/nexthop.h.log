commit 50cb8769f2c1c657a470bda192b79ff679d0ecfc
Author: David Ahern <dsahern@kernel.org>
Date:   Tue Jun 9 17:27:28 2020 -0600

    vxlan: Remove access to nexthop group struct
    
    vxlan driver should be using helpers to access nexthop struct
    internals. Remove open check if whether nexthop is multipath in
    favor of the existing nexthop_is_multipath helper. Add a new
    helper, nexthop_has_v4, to cover the need to check has_v4 in
    a group.
    
    Fixes: 1274e1cc4226 ("vxlan: ecmp support for mac fdb entries")
    Cc: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David Ahern <dsahern@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 3f9e0ca2dc4d..3a4f9e3b91a5 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -151,6 +151,17 @@ static inline bool nexthop_is_fdb(const struct nexthop *nh)
 	}
 }
 
+static inline bool nexthop_has_v4(const struct nexthop *nh)
+{
+	if (nh->is_group) {
+		struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		return nh_grp->has_v4;
+	}
+	return false;
+}
+
 static inline bool nexthop_is_multipath(const struct nexthop *nh)
 {
 	if (nh->is_group) {

commit ce9ac056d9cd15630dfca352ff6d3051ba3ba8f6
Author: David Ahern <dsahern@kernel.org>
Date:   Mon Jun 8 20:54:43 2020 -0600

    nexthop: Fix fdb labeling for groups
    
    fdb nexthops are marked with a flag. For standalone nexthops, a flag was
    added to the nh_info struct. For groups that flag was added to struct
    nexthop when it should have been added to the group information. Fix
    by removing the flag from the nexthop struct and adding a flag to nh_group
    that mirrors nh_info and is really only a caching of the individual types.
    Add a helper, nexthop_is_fdb, for use by the vxlan code and fixup the
    internal code to use the flag from either nh_info or nh_group.
    
    v2
    - propagate fdb_nh in remove_nh_grp_entry
    
    Fixes: 38428d68719c ("nexthop: support for fdb ecmp nexthops")
    Cc: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David Ahern <dsahern@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index e4b55b43e907..3f9e0ca2dc4d 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -76,6 +76,7 @@ struct nh_group {
 	struct nh_group		*spare; /* spare group for removals */
 	u16			num_nh;
 	bool			mpath;
+	bool			fdb_nh;
 	bool			has_v4;
 	struct nh_grp_entry	nh_entries[];
 };
@@ -93,7 +94,6 @@ struct nexthop {
 	u8			protocol;   /* app managing this nh */
 	u8			nh_flags;
 	bool			is_group;
-	bool			is_fdb_nh;
 
 	refcount_t		refcnt;
 	struct rcu_head		rcu;
@@ -136,6 +136,21 @@ static inline bool nexthop_cmp(const struct nexthop *nh1,
 	return nh1 == nh2;
 }
 
+static inline bool nexthop_is_fdb(const struct nexthop *nh)
+{
+	if (nh->is_group) {
+		const struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		return nh_grp->fdb_nh;
+	} else {
+		const struct nh_info *nhi;
+
+		nhi = rcu_dereference_rtnl(nh->nh_info);
+		return nhi->fdb_nh;
+	}
+}
+
 static inline bool nexthop_is_multipath(const struct nexthop *nh)
 {
 	if (nh->is_group) {

commit 1806c13dc2532090d742ce03847b22367fb20ad6
Merge: 1079a34c56c5 bdc48fa11e46
Author: David S. Miller <davem@davemloft.net>
Date:   Sun May 31 17:48:46 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    xdp_umem.c had overlapping changes between the 64-bit math fix
    for the calculation of npgs and the removal of the zerocopy
    memory type which got rid of the chunk_size_nohdr member.
    
    The mlx5 Kconfig conflict is a case where we just take the
    net-next copy of the Kconfig entry dependency as it takes on
    the ESWITCH dependency by one level of indirection which is
    what the 'net' conflicting change is trying to ensure.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1fd1c768f3624a5e66766e7b4ddb9b607cd834a5
Author: David Ahern <dsahern@gmail.com>
Date:   Tue May 26 12:56:18 2020 -0600

    ipv4: nexthop version of fib_info_nh_uses_dev
    
    Similar to the last path, need to fix fib_info_nh_uses_dev for
    external nexthops to avoid referencing multiple nh_grp structs.
    Move the device check in fib_info_nh_uses_dev to a helper and
    create a nexthop version that is called if the fib_info uses an
    external nexthop.
    
    Fixes: 430a049190de ("nexthop: Add support for nexthop groups")
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 9414ae46fc1c..8c9f1a718859 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -266,6 +266,31 @@ struct fib_nh_common *nexthop_get_nhc_lookup(const struct nexthop *nh,
 	return NULL;
 }
 
+static inline bool nexthop_uses_dev(const struct nexthop *nh,
+				    const struct net_device *dev)
+{
+	struct nh_info *nhi;
+
+	if (nh->is_group) {
+		struct nh_group *nhg = rcu_dereference(nh->nh_grp);
+		int i;
+
+		for (i = 0; i < nhg->num_nh; i++) {
+			struct nexthop *nhe = nhg->nh_entries[i].nh;
+
+			nhi = rcu_dereference(nhe->nh_info);
+			if (nhc_l3mdev_matches_dev(&nhi->fib_nhc, dev))
+				return true;
+		}
+	} else {
+		nhi = rcu_dereference(nh->nh_info);
+		if (nhc_l3mdev_matches_dev(&nhi->fib_nhc, dev))
+			return true;
+	}
+
+	return false;
+}
+
 static inline unsigned int fib_info_num_path(const struct fib_info *fi)
 {
 	if (unlikely(fi->nh))

commit af7888ad9edbd8ba7f6449d1c27ce281ad4b26fd
Author: David Ahern <dsahern@gmail.com>
Date:   Tue May 26 12:56:17 2020 -0600

    ipv4: Refactor nhc evaluation in fib_table_lookup
    
    FIB lookups can return an entry that references an external nexthop.
    While walking the nexthop struct we do not want to make multiple calls
    into the nexthop code which can result in 2 different structs getting
    accessed - one returning the number of paths the rest of the loop
    seeing a different nh_grp struct. If the nexthop group shrunk, the
    result is an attempt to access a fib_nh_common that does not exist for
    the new nh_grp struct but did for the old one.
    
    To fix that move the device evaluation code to a helper that can be
    used for inline fib_nh path as well as external nexthops.
    
    Update the existing check for fi->nh in fib_table_lookup to call a
    new helper, nexthop_get_nhc_lookup, which walks the external nexthop
    with a single rcu dereference.
    
    Fixes: 430a049190de ("nexthop: Add support for nexthop groups")
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index f09e8d7d9886..9414ae46fc1c 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -233,6 +233,39 @@ struct fib_nh_common *nexthop_fib_nhc(struct nexthop *nh, int nhsel)
 	return &nhi->fib_nhc;
 }
 
+/* called from fib_table_lookup with rcu_lock */
+static inline
+struct fib_nh_common *nexthop_get_nhc_lookup(const struct nexthop *nh,
+					     int fib_flags,
+					     const struct flowi4 *flp,
+					     int *nhsel)
+{
+	struct nh_info *nhi;
+
+	if (nh->is_group) {
+		struct nh_group *nhg = rcu_dereference(nh->nh_grp);
+		int i;
+
+		for (i = 0; i < nhg->num_nh; i++) {
+			struct nexthop *nhe = nhg->nh_entries[i].nh;
+
+			nhi = rcu_dereference(nhe->nh_info);
+			if (fib_lookup_good_nhc(&nhi->fib_nhc, fib_flags, flp)) {
+				*nhsel = i;
+				return &nhi->fib_nhc;
+			}
+		}
+	} else {
+		nhi = rcu_dereference(nh->nh_info);
+		if (fib_lookup_good_nhc(&nhi->fib_nhc, fib_flags, flp)) {
+			*nhsel = 0;
+			return &nhi->fib_nhc;
+		}
+	}
+
+	return NULL;
+}
+
 static inline unsigned int fib_info_num_path(const struct fib_info *fi)
 {
 	if (unlikely(fi->nh))

commit 0b5e2e39739e861fa5fc84ab27a35dbe62a15330
Author: David Ahern <dsahern@gmail.com>
Date:   Tue May 26 12:56:16 2020 -0600

    nexthop: Expand nexthop_is_multipath in a few places
    
    I got too fancy consolidating checks on multipath type. The result
    is that path lookups can access 2 different nh_grp structs as exposed
    by Nik's torture tests. Expand nexthop_is_multipath within nexthop.h to
    avoid multiple, nh_grp dereferences and make decisions based on the
    consistent struct.
    
    Only 2 places left using nexthop_is_multipath are within IPv6, both
    only check that the nexthop is a multipath for a branching decision
    which are acceptable.
    
    Fixes: 430a049190de ("nexthop: Add support for nexthop groups")
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 8a343519ed7a..f09e8d7d9886 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -137,21 +137,20 @@ static inline unsigned int nexthop_num_path(const struct nexthop *nh)
 {
 	unsigned int rc = 1;
 
-	if (nexthop_is_multipath(nh)) {
+	if (nh->is_group) {
 		struct nh_group *nh_grp;
 
 		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
-		rc = nh_grp->num_nh;
+		if (nh_grp->mpath)
+			rc = nh_grp->num_nh;
 	}
 
 	return rc;
 }
 
 static inline
-struct nexthop *nexthop_mpath_select(const struct nexthop *nh, int nhsel)
+struct nexthop *nexthop_mpath_select(const struct nh_group *nhg, int nhsel)
 {
-	const struct nh_group *nhg = rcu_dereference_rtnl(nh->nh_grp);
-
 	/* for_nexthops macros in fib_semantics.c grabs a pointer to
 	 * the nexthop before checking nhsel
 	 */
@@ -186,12 +185,14 @@ static inline bool nexthop_is_blackhole(const struct nexthop *nh)
 {
 	const struct nh_info *nhi;
 
-	if (nexthop_is_multipath(nh)) {
-		if (nexthop_num_path(nh) > 1)
-			return false;
-		nh = nexthop_mpath_select(nh, 0);
-		if (!nh)
+	if (nh->is_group) {
+		struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		if (nh_grp->num_nh > 1)
 			return false;
+
+		nh = nh_grp->nh_entries[0].nh;
 	}
 
 	nhi = rcu_dereference_rtnl(nh->nh_info);
@@ -217,10 +218,15 @@ struct fib_nh_common *nexthop_fib_nhc(struct nexthop *nh, int nhsel)
 	BUILD_BUG_ON(offsetof(struct fib_nh, nh_common) != 0);
 	BUILD_BUG_ON(offsetof(struct fib6_nh, nh_common) != 0);
 
-	if (nexthop_is_multipath(nh)) {
-		nh = nexthop_mpath_select(nh, nhsel);
-		if (!nh)
-			return NULL;
+	if (nh->is_group) {
+		struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		if (nh_grp->mpath) {
+			nh = nexthop_mpath_select(nh_grp, nhsel);
+			if (!nh)
+				return NULL;
+		}
 	}
 
 	nhi = rcu_dereference_rtnl(nh->nh_info);
@@ -264,8 +270,11 @@ static inline struct fib6_nh *nexthop_fib6_nh(struct nexthop *nh)
 {
 	struct nh_info *nhi;
 
-	if (nexthop_is_multipath(nh)) {
-		nh = nexthop_mpath_select(nh, 0);
+	if (nh->is_group) {
+		struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		nh = nexthop_mpath_select(nh_grp, 0);
 		if (!nh)
 			return NULL;
 	}

commit 90f33bffa382598a32cc82abfeb20adc92d041b6
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue May 26 12:56:15 2020 -0600

    nexthops: don't modify published nexthop groups
    
    We must avoid modifying published nexthop groups while they might be
    in use, otherwise we might see NULL ptr dereferences. In order to do
    that we allocate 2 nexthoup group structures upon nexthop creation
    and swap between them when we have to delete an entry. The reason is
    that we can't fail nexthop group removal, so we can't handle allocation
    failure thus we move the extra allocation on creation where we can
    safely fail and return ENOMEM.
    
    Fixes: 430a049190de ("nexthop: Add support for nexthop groups")
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index c440ccc861fc..8a343519ed7a 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -70,6 +70,7 @@ struct nh_grp_entry {
 };
 
 struct nh_group {
+	struct nh_group		*spare; /* spare group for removals */
 	u16			num_nh;
 	bool			mpath;
 	bool			has_v4;

commit 8590ceedb70181ad9de5a3dc2cfe50ca33a9576a
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Thu May 21 22:26:15 2020 -0700

    nexthop: add support for notifiers
    
    This patch adds nexthop add/del notifiers. To be used by
    vxlan driver in a later patch. Could possibly be used by
    switchdev drivers in the future.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index d929c98931ad..4c951680f6f9 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -10,6 +10,7 @@
 #define __LINUX_NEXTHOP_H
 
 #include <linux/netdevice.h>
+#include <linux/notifier.h>
 #include <linux/route.h>
 #include <linux/types.h>
 #include <net/ip_fib.h>
@@ -102,6 +103,17 @@ struct nexthop {
 	};
 };
 
+enum nexthop_event_type {
+	NEXTHOP_EVENT_ADD,
+	NEXTHOP_EVENT_DEL
+};
+
+int call_nexthop_notifier(struct notifier_block *nb, struct net *net,
+			  enum nexthop_event_type event_type,
+			  struct nexthop *nh);
+int register_nexthop_notifier(struct net *net, struct notifier_block *nb);
+int unregister_nexthop_notifier(struct net *net, struct notifier_block *nb);
+
 /* caller is holding rcu or rtnl; no reference taken to nexthop */
 struct nexthop *nexthop_find_by_id(struct net *net, u32 id);
 void nexthop_free_rcu(struct rcu_head *head);

commit 38428d68719c454d269cb03b776d8a4b0ad66111
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Thu May 21 22:26:13 2020 -0700

    nexthop: support for fdb ecmp nexthops
    
    This patch introduces ecmp nexthops and nexthop groups
    for mac fdb entries. In subsequent patches this is used
    by the vxlan driver fdb entries. The use case is
    E-VPN multihoming [1,2,3] which requires bridged vxlan traffic
    to be load balanced to remote switches (vteps) belonging to
    the same multi-homed ethernet segment (This is analogous to
    a multi-homed LAG but over vxlan).
    
    Changes include new nexthop flag NHA_FDB for nexthops
    referenced by fdb entries. These nexthops only have ip.
    This patch includes appropriate checks to avoid routes
    referencing such nexthops.
    
    example:
    $ip nexthop add id 12 via 172.16.1.2 fdb
    $ip nexthop add id 13 via 172.16.1.3 fdb
    $ip nexthop add id 102 group 12/13 fdb
    
    $bridge fdb add 02:02:00:00:00:13 dev vxlan1000 nhid 101 self
    
    [1] E-VPN https://tools.ietf.org/html/rfc7432
    [2] E-VPN VxLAN: https://tools.ietf.org/html/rfc8365
    [3] LPC talk with mention of nexthop groups for L2 ecmp
    http://vger.kernel.org/lpc_net2018_talks/scaling_bridge_fdb_database_slidesV3.pdf
    
    v4 - fixed uninitialized variable reported by kernel test robot
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index c440ccc861fc..d929c98931ad 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -26,6 +26,7 @@ struct nh_config {
 	u8		nh_family;
 	u8		nh_protocol;
 	u8		nh_blackhole;
+	u8		nh_fdb;
 	u32		nh_flags;
 
 	int		nh_ifindex;
@@ -52,6 +53,7 @@ struct nh_info {
 
 	u8			family;
 	bool			reject_nh;
+	bool			fdb_nh;
 
 	union {
 		struct fib_nh_common	fib_nhc;
@@ -80,6 +82,7 @@ struct nexthop {
 	struct rb_node		rb_node;    /* entry on netns rbtree */
 	struct list_head	fi_list;    /* v4 entries using nh */
 	struct list_head	f6i_list;   /* v6 entries using nh */
+	struct list_head        fdb_list;   /* fdb entries using this nh */
 	struct list_head	grp_list;   /* nh group entries using this nh */
 	struct net		*net;
 
@@ -88,6 +91,7 @@ struct nexthop {
 	u8			protocol;   /* app managing this nh */
 	u8			nh_flags;
 	bool			is_group;
+	bool			is_fdb_nh;
 
 	refcount_t		refcnt;
 	struct rcu_head		rcu;
@@ -304,4 +308,32 @@ static inline void nexthop_path_fib6_result(struct fib6_result *res, int hash)
 int nexthop_for_each_fib6_nh(struct nexthop *nh,
 			     int (*cb)(struct fib6_nh *nh, void *arg),
 			     void *arg);
+
+static inline int nexthop_get_family(struct nexthop *nh)
+{
+	struct nh_info *nhi = rcu_dereference_rtnl(nh->nh_info);
+
+	return nhi->family;
+}
+
+static inline
+struct fib_nh_common *nexthop_fdb_nhc(struct nexthop *nh)
+{
+	struct nh_info *nhi = rcu_dereference_rtnl(nh->nh_info);
+
+	return &nhi->fib_nhc;
+}
+
+static inline struct fib_nh_common *nexthop_path_fdb_result(struct nexthop *nh,
+							    int hash)
+{
+	struct nh_info *nhi;
+	struct nexthop *nhp;
+
+	nhp = nexthop_select_path(nh, hash);
+	if (unlikely(!nhp))
+		return NULL;
+	nhi = rcu_dereference(nhp->nh_info);
+	return &nhi->fib_nhc;
+}
 #endif

commit 97a888c2ff6bbb92bdb0cb6cfff458cc412da788
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 28 18:14:11 2020 -0600

    net: nexthop: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 331ebbc94fe7..c440ccc861fc 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -73,7 +73,7 @@ struct nh_group {
 	u16			num_nh;
 	bool			mpath;
 	bool			has_v4;
-	struct nh_grp_entry	nh_entries[0];
+	struct nh_grp_entry	nh_entries[];
 };
 
 struct nexthop {

commit 7bdf4de1267780aa194b3a28c85a6c4d617b0bdb
Author: Donald Sharp <sharpd@cumulusnetworks.com>
Date:   Wed Sep 4 10:11:58 2019 -0400

    net: Properly update v4 routes with v6 nexthop
    
    When creating a v4 route that uses a v6 nexthop from a nexthop group.
    Allow the kernel to properly send the nexthop as v6 via the RTA_VIA
    attribute.
    
    Broken behavior:
    
    $ ip nexthop add via fe80::9 dev eth0
    $ ip nexthop show
    id 1 via fe80::9 dev eth0 scope link
    $ ip route add 4.5.6.7/32 nhid 1
    $ ip route show
    default via 10.0.2.2 dev eth0
    4.5.6.7 nhid 1 via 254.128.0.0 dev eth0
    10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15
    $
    
    Fixed behavior:
    
    $ ip nexthop add via fe80::9 dev eth0
    $ ip nexthop show
    id 1 via fe80::9 dev eth0 scope link
    $ ip route add 4.5.6.7/32 nhid 1
    $ ip route show
    default via 10.0.2.2 dev eth0
    4.5.6.7 nhid 1 via inet6 fe80::9 dev eth0
    10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15
    $
    
    v2, v3: Addresses code review comments from David Ahern
    
    Fixes: dcb1ecb50edf (“ipv4: Prepare for fib6_nh from a nexthop object”)
    Signed-off-by: Donald Sharp <sharpd@cumulusnetworks.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 95f766c31c90..331ebbc94fe7 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -161,7 +161,8 @@ struct nexthop *nexthop_mpath_select(const struct nexthop *nh, int nhsel)
 }
 
 static inline
-int nexthop_mpath_fill_node(struct sk_buff *skb, struct nexthop *nh)
+int nexthop_mpath_fill_node(struct sk_buff *skb, struct nexthop *nh,
+			    u8 rt_family)
 {
 	struct nh_group *nhg = rtnl_dereference(nh->nh_grp);
 	int i;
@@ -172,7 +173,7 @@ int nexthop_mpath_fill_node(struct sk_buff *skb, struct nexthop *nh)
 		struct fib_nh_common *nhc = &nhi->fib_nhc;
 		int weight = nhg->nh_entries[i].weight;
 
-		if (fib_add_nexthop(skb, nhc, weight) < 0)
+		if (fib_add_nexthop(skb, nhc, weight, rt_family) < 0)
 			return -EMSGSIZE;
 	}
 

commit 9b5f684182403f2b338f797c44eca0061c797dc8
Author: David Ahern <dsahern@gmail.com>
Date:   Sun Aug 25 07:47:30 2019 -0700

    nexthop: Fix nexthop_num_path for blackhole nexthops
    
    Donald reported this sequence:
      ip next add id 1 blackhole
      ip next add id 2 blackhole
      ip ro add 1.1.1.1/32 nhid 1
      ip ro add 1.1.1.2/32 nhid 2
    
    would cause a crash. Backtrace is:
    
    [  151.302790] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  151.304043] CPU: 1 PID: 277 Comm: ip Not tainted 5.3.0-rc5+ #37
    [  151.305078] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.11.1-1 04/01/2014
    [  151.306526] RIP: 0010:fib_add_nexthop+0x8b/0x2aa
    [  151.307343] Code: 35 f7 81 48 8d 14 01 c7 02 f1 f1 f1 f1 c7 42 04 01 f4 f4 f4 48 89 f2 48 c1 ea 03 65 48 8b 0c 25 28 00 00 00 48 89 4d d0 31 c9 <80> 3c 02 00 74 08 48 89 f7 e8 1a e8 53 ff be 08 00 00 00 4c 89 e7
    [  151.310549] RSP: 0018:ffff888116c27340 EFLAGS: 00010246
    [  151.311469] RAX: dffffc0000000000 RBX: ffff8881154ece00 RCX: 0000000000000000
    [  151.312713] RDX: 0000000000000004 RSI: 0000000000000020 RDI: ffff888115649b40
    [  151.313968] RBP: ffff888116c273d8 R08: ffffed10221e3757 R09: ffff888110f1bab8
    [  151.315212] R10: 0000000000000001 R11: ffff888110f1bab3 R12: ffff888115649b40
    [  151.316456] R13: 0000000000000020 R14: ffff888116c273b0 R15: ffff888115649b40
    [  151.317707] FS:  00007f60b4d8d800(0000) GS:ffff88811ac00000(0000) knlGS:0000000000000000
    [  151.319113] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  151.320119] CR2: 0000555671ffdc00 CR3: 00000001136ba005 CR4: 0000000000020ee0
    [  151.321367] Call Trace:
    [  151.321820]  ? fib_nexthop_info+0x635/0x635
    [  151.322572]  fib_dump_info+0xaa4/0xde0
    [  151.323247]  ? fib_create_info+0x2431/0x2431
    [  151.324008]  ? napi_alloc_frag+0x2a/0x2a
    [  151.324711]  rtmsg_fib+0x2c4/0x3be
    [  151.325339]  fib_table_insert+0xe2f/0xeee
    ...
    
    fib_dump_info incorrectly has nhs = 0 for blackhole nexthops, so it
    believes the nexthop object is a multipath group (nhs != 1) and ends
    up down the nexthop_mpath_fill_node() path which is wrong for a
    blackhole.
    
    The blackhole check in nexthop_num_path is leftover from early days
    of the blackhole implementation which did not initialize the device.
    In the end the design was simpler (fewer special case checks) to set
    the device to loopback in nh_info, so the check in nexthop_num_path
    should have been removed.
    
    Fixes: 430a049190de ("nexthop: Add support for nexthop groups")
    Reported-by: Donald Sharp <sharpd@cumulusnetworks.com>
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 25f1f9a8419b..95f766c31c90 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -141,12 +141,6 @@ static inline unsigned int nexthop_num_path(const struct nexthop *nh)
 
 		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
 		rc = nh_grp->num_nh;
-	} else {
-		const struct nh_info *nhi;
-
-		nhi = rcu_dereference_rtnl(nh->nh_info);
-		if (nhi->reject_nh)
-			rc = 0;
 	}
 
 	return rc;

commit f88c9aa12fd0cff9cbb74b490350e6f0fac68296
Author: David Ahern <dsahern@gmail.com>
Date:   Sat Jun 8 14:53:22 2019 -0700

    nexthops: Add ipv6 helper to walk all fib6_nh in a nexthop struct
    
    IPv6 has traditionally had a single fib6_nh per fib6_info. With
    nexthops we can have multiple fib6_nh associated with a fib6_info.
    Add a nexthop helper to invoke a callback for each fib6_nh in a
    'struct nexthop'. If the callback returns non-0, the loop is
    stopped and the return value passed to the caller.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index e019ed9b3dc3..25f1f9a8419b 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -305,4 +305,8 @@ static inline void nexthop_path_fib6_result(struct fib6_result *res, int hash)
 		res->nh = &nhi->fib6_nh;
 	}
 }
+
+int nexthop_for_each_fib6_nh(struct nexthop *nh,
+			     int (*cb)(struct fib6_nh *nh, void *arg),
+			     void *arg);
 #endif

commit 5270041d342de6f1e6a3b6634c1ceaa67d1f87ea
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jun 7 18:31:07 2019 +0300

    nexthop: off by one in nexthop_mpath_select()
    
    The nhg->nh_entries[] array is allocated in nexthop_grp_alloc() and it
    has nhg->num_nh elements so this check should be >= instead of >.
    
    Fixes: 430a049190de ("nexthop: Add support for nexthop groups")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index aff7b2410057..e019ed9b3dc3 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -160,7 +160,7 @@ struct nexthop *nexthop_mpath_select(const struct nexthop *nh, int nhsel)
 	/* for_nexthops macros in fib_semantics.c grabs a pointer to
 	 * the nexthop before checking nhsel
 	 */
-	if (nhsel > nhg->num_nh)
+	if (nhsel >= nhg->num_nh)
 		return NULL;
 
 	return nhg->nh_entries[nhsel].nh;

commit f88d8ea67fbdbac7a64bfa6ed9a2ba27bb822f74
Author: David Ahern <dsahern@gmail.com>
Date:   Mon Jun 3 20:19:52 2019 -0700

    ipv6: Plumb support for nexthop object in a fib6_info
    
    Add struct nexthop and nh_list list_head to fib6_info. nh_list is the
    fib6_info side of the nexthop <-> fib_info relationship. Since a fib6_info
    referencing a nexthop object can not have 'sibling' entries (the old way
    of doing multipath routes), the nh_list is a union with fib6_siblings.
    
    Add f6i_list list_head to 'struct nexthop' to track fib6_info entries
    using a nexthop instance. Update __remove_nexthop_fib to walk f6_list
    and delete fib entries using the nexthop.
    
    Add a few nexthop helpers for use when a nexthop is added to fib6_info:
    - nexthop_fib6_nh - return first fib6_nh in a nexthop object
    - fib6_info_nh_dev moved to nexthop.h and updated to use nexthop_fib6_nh
      if the fib6_info references a nexthop object
    - nexthop_path_fib6_result - similar to ipv4, select a path within a
      multipath nexthop object. If the nexthop is a blackhole, set
      fib6_result type to RTN_BLACKHOLE, and set the REJECT flag
    
    Update the fib6_info references to check for nh and take a different path
    as needed:
    - rt6_qualify_for_ecmp - if a fib entry uses a nexthop object it can NOT
      be coalesced with other fib entries into a multipath route
    - rt6_duplicate_nexthop - use nexthop_cmp if either fib6_info references
      a nexthop
    - addrconf (host routes), RA's and info entries (anything configured via
      ndisc) does not use nexthop objects
    - fib6_info_destroy_rcu - put reference to nexthop object
    - fib6_purge_rt - drop fib6_info from f6i_list
    - fib6_select_path - update to use the new nexthop_path_fib6_result when
      fib entry uses a nexthop object
    - rt6_device_match - update to catch use of nexthop object as a blackhole
      and set fib6_type and flags.
    - ip6_route_info_create - don't add space for fib6_nh if fib entry is
      going to reference a nexthop object, take a reference to nexthop object,
      disallow use of source routing
    - rt6_nlmsg_size - add space for RTA_NH_ID
    - add rt6_fill_node_nexthop to add nexthop data on a dump
    
    As with ipv4, most of the changes push existing code into the else branch
    of whether the fib entry uses a nexthop object.
    
    Update the nexthop code to walk f6i_list on a nexthop deleted to remove
    fib entries referencing it.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 2912a2d7a515..aff7b2410057 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -10,6 +10,7 @@
 #define __LINUX_NEXTHOP_H
 
 #include <linux/netdevice.h>
+#include <linux/route.h>
 #include <linux/types.h>
 #include <net/ip_fib.h>
 #include <net/ip6_fib.h>
@@ -78,6 +79,7 @@ struct nh_group {
 struct nexthop {
 	struct rb_node		rb_node;    /* entry on netns rbtree */
 	struct list_head	fi_list;    /* v4 entries using nh */
+	struct list_head	f6i_list;   /* v6 entries using nh */
 	struct list_head	grp_list;   /* nh group entries using this nh */
 	struct net		*net;
 
@@ -255,4 +257,52 @@ static inline struct fib_nh *fib_info_nh(struct fib_info *fi, int nhsel)
 
 	return &fi->fib_nh[nhsel];
 }
+
+/*
+ * IPv6 variants
+ */
+int fib6_check_nexthop(struct nexthop *nh, struct fib6_config *cfg,
+		       struct netlink_ext_ack *extack);
+
+static inline struct fib6_nh *nexthop_fib6_nh(struct nexthop *nh)
+{
+	struct nh_info *nhi;
+
+	if (nexthop_is_multipath(nh)) {
+		nh = nexthop_mpath_select(nh, 0);
+		if (!nh)
+			return NULL;
+	}
+
+	nhi = rcu_dereference_rtnl(nh->nh_info);
+	if (nhi->family == AF_INET6)
+		return &nhi->fib6_nh;
+
+	return NULL;
+}
+
+static inline struct net_device *fib6_info_nh_dev(struct fib6_info *f6i)
+{
+	struct fib6_nh *fib6_nh;
+
+	fib6_nh = f6i->nh ? nexthop_fib6_nh(f6i->nh) : f6i->fib6_nh;
+	return fib6_nh->fib_nh_dev;
+}
+
+static inline void nexthop_path_fib6_result(struct fib6_result *res, int hash)
+{
+	struct nexthop *nh = res->f6i->nh;
+	struct nh_info *nhi;
+
+	nh = nexthop_select_path(nh, hash);
+
+	nhi = rcu_dereference_rtnl(nh->nh_info);
+	if (nhi->reject_nh) {
+		res->fib6_type = RTN_BLACKHOLE;
+		res->fib6_flags |= RTF_REJECT;
+		res->nh = nexthop_fib6_nh(nh);
+	} else {
+		res->nh = &nhi->fib6_nh;
+	}
+}
 #endif

commit 4c7e8084fd467ddb2b0e6c6011f9c1064afb7e56
Author: David Ahern <dsahern@gmail.com>
Date:   Mon Jun 3 20:19:51 2019 -0700

    ipv4: Plumb support for nexthop object in a fib_info
    
    Add 'struct nexthop' and nh_list list_head to fib_info. nh_list is the
    fib_info side of the nexthop <-> fib_info relationship.
    
    Add fi_list list_head to 'struct nexthop' to track fib_info entries
    using a nexthop instance. Add __remove_nexthop_fib and add it to
    __remove_nexthop to walk the new list_head and mark those fib entries
    as dead when the nexthop is deleted.
    
    Add a few nexthop helpers for use when a nexthop is added to fib_info:
    - nexthop_cmp to determine if 2 nexthops are the same
    - nexthop_path_fib_result to select a path for a multipath
      'struct nexthop'
    - nexthop_fib_nhc to select a specific fib_nh_common within a
      multipath 'struct nexthop'
    
    Update existing fib_info_nhc to use nexthop_fib_nhc if a fib_info uses
    a 'struct nexthop', and mark fib_info_nh as only used for the non-nexthop
    case.
    
    Update the fib_info functions to check for fi->nh and take a different
    path as needed:
    - free_fib_info_rcu - put the nexthop object reference
    - fib_release_info - remove the fib_info from the nexthop's fi_list
    - nh_comp - use nexthop_cmp when either fib_info references a nexthop
      object
    - fib_info_hashfn - use the nexthop id for the hashing vs the oif of
      each fib_nh in a fib_info
    - fib_nlmsg_size - add space for the RTA_NH_ID attribute
    - fib_create_info - verify nexthop reference can be taken, verify
      nexthop spec is valid for fib entry, and add fib_info to fi_list for
      a nexthop
    - fib_select_multipath - use the new nexthop_path_fib_result to select a
      path when nexthop objects are used
    - fib_table_lookup - if the 'struct nexthop' is a blackhole nexthop, treat
      it the same as a fib entry using 'blackhole'
    
    The bulk of the changes are in fib_semantics.c and most of that is
    moving the existing change_nexthops into an else branch.
    
    Update the nexthop code to walk fi_list on a nexthop deleted to remove
    fib entries referencing it.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index e501d77b82c8..2912a2d7a515 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -77,6 +77,7 @@ struct nh_group {
 
 struct nexthop {
 	struct rb_node		rb_node;    /* entry on netns rbtree */
+	struct list_head	fi_list;    /* v4 entries using nh */
 	struct list_head	grp_list;   /* nh group entries using this nh */
 	struct net		*net;
 
@@ -110,6 +111,12 @@ static inline void nexthop_put(struct nexthop *nh)
 		call_rcu(&nh->rcu, nexthop_free_rcu);
 }
 
+static inline bool nexthop_cmp(const struct nexthop *nh1,
+			       const struct nexthop *nh2)
+{
+	return nh1 == nh2;
+}
+
 static inline bool nexthop_is_multipath(const struct nexthop *nh)
 {
 	if (nh->is_group) {
@@ -193,18 +200,59 @@ static inline bool nexthop_is_blackhole(const struct nexthop *nh)
 	return nhi->reject_nh;
 }
 
+static inline void nexthop_path_fib_result(struct fib_result *res, int hash)
+{
+	struct nh_info *nhi;
+	struct nexthop *nh;
+
+	nh = nexthop_select_path(res->fi->nh, hash);
+	nhi = rcu_dereference(nh->nh_info);
+	res->nhc = &nhi->fib_nhc;
+}
+
+/* called with rcu read lock or rtnl held */
+static inline
+struct fib_nh_common *nexthop_fib_nhc(struct nexthop *nh, int nhsel)
+{
+	struct nh_info *nhi;
+
+	BUILD_BUG_ON(offsetof(struct fib_nh, nh_common) != 0);
+	BUILD_BUG_ON(offsetof(struct fib6_nh, nh_common) != 0);
+
+	if (nexthop_is_multipath(nh)) {
+		nh = nexthop_mpath_select(nh, nhsel);
+		if (!nh)
+			return NULL;
+	}
+
+	nhi = rcu_dereference_rtnl(nh->nh_info);
+	return &nhi->fib_nhc;
+}
+
 static inline unsigned int fib_info_num_path(const struct fib_info *fi)
 {
+	if (unlikely(fi->nh))
+		return nexthop_num_path(fi->nh);
+
 	return fi->fib_nhs;
 }
 
+int fib_check_nexthop(struct nexthop *nh, u8 scope,
+		      struct netlink_ext_ack *extack);
+
 static inline struct fib_nh_common *fib_info_nhc(struct fib_info *fi, int nhsel)
 {
+	if (unlikely(fi->nh))
+		return nexthop_fib_nhc(fi->nh, nhsel);
+
 	return &fi->fib_nh[nhsel].nh_common;
 }
 
+/* only used when fib_nh is built into fib_info */
 static inline struct fib_nh *fib_info_nh(struct fib_info *fi, int nhsel)
 {
+	WARN_ON(fi->nh);
+
 	return &fi->fib_nh[nhsel];
 }
 #endif

commit 5481d73f81549e2a05cbbb49867a9a560c5292df
Author: David Ahern <dsahern@gmail.com>
Date:   Mon Jun 3 20:19:49 2019 -0700

    ipv4: Use accessors for fib_info nexthop data
    
    Use helpers to access fib_nh and fib_nhs fields of a fib_info. Drop the
    fib_dev macro which is an alias for the first nexthop. Replacements:
    
      fi->fib_dev    --> fib_info_nh(fi, 0)->fib_nh_dev
      fi->fib_nh     --> fib_info_nh(fi, 0)
      fi->fib_nh[i]  --> fib_info_nh(fi, i)
      fi->fib_nhs    --> fib_info_num_path(fi)
    
    where fib_info_nh(fi, i) returns fi->fib_nh[nhsel] and fib_info_num_path
    returns fi->fib_nhs.
    
    Move the existing fib_info_nhc to nexthop.h and define the new ones
    there. A later patch adds a check if a fib_info uses a nexthop object,
    and defining the helpers in nexthop.h avoid circular header
    dependencies.
    
    After this all remaining open coded references to fi->fib_nhs and
    fi->fib_nh are in:
    - fib_create_info and helpers used to lookup an existing fib_info
      entry, and
    - the netdev event functions fib_sync_down_dev and fib_sync_up.
    
    The latter two will not be reused for nexthops, and the fib_create_info
    will be updated to handle a nexthop in a fib_info.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 6e1b8f53624c..e501d77b82c8 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -192,4 +192,19 @@ static inline bool nexthop_is_blackhole(const struct nexthop *nh)
 	nhi = rcu_dereference_rtnl(nh->nh_info);
 	return nhi->reject_nh;
 }
+
+static inline unsigned int fib_info_num_path(const struct fib_info *fi)
+{
+	return fi->fib_nhs;
+}
+
+static inline struct fib_nh_common *fib_info_nhc(struct fib_info *fi, int nhsel)
+{
+	return &fi->fib_nh[nhsel].nh_common;
+}
+
+static inline struct fib_nh *fib_info_nh(struct fib_info *fi, int nhsel)
+{
+	return &fi->fib_nh[nhsel];
+}
 #endif

commit 430a049190de3c9e219f43084de9f1122da04570
Author: David Ahern <dsahern@gmail.com>
Date:   Fri May 24 14:43:08 2019 -0700

    nexthop: Add support for nexthop groups
    
    Allow the creation of nexthop groups which reference other nexthop
    objects to create multipath routes:
    
                          +--------------+
       +------------+   +--------------+ |
       | nh  nh_grp --->| nh_grp_entry |-+
       +------------+   +---------|----+
         ^                |       |    +------------+
         +----------------+       +--->| nh, weight |
            nh_parent                  +------------+
    
    A group entry points to a nexthop with a weight for that hop within the
    group. The nexthop has a list_head, grp_list, for tracking which groups
    it is a member of and the group entry has a reference back to the parent.
    The grp_list is used when a nexthop is deleted - to efficiently remove
    it from groups using it.
    
    If a nexthop group spec is given, no other attributes can be set. Each
    nexthop id in a group spec must already exist.
    
    Similar to single nexthops, the specification of a nexthop group can be
    updated so that data is managed with rcu locking.
    
    Add path selection function to account for multiple paths and add
    ipv{4,6}_good_nh helpers to know that if a neighbor entry exists it is
    in a good state.
    
    Update NETDEV event handling to rebalance multipath nexthop groups if
    a nexthop is deleted due to a link event (down or unregister).
    
    When a nexthop is removed any groups using it are updated. Groups using a
    nexthop a tracked via a grp_list.
    
    Nexthop dumps can be limited to groups only by adding NHA_GROUPS to the
    request.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 7cde03337e14..6e1b8f53624c 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -35,6 +35,9 @@ struct nh_config {
 		struct in6_addr	ipv6;
 	} gw;
 
+	struct nlattr	*nh_grp;
+	u16		nh_grp_type;
+
 	struct nlattr	*nh_encap;
 	u16		nh_encap_type;
 
@@ -56,20 +59,39 @@ struct nh_info {
 	};
 };
 
+struct nh_grp_entry {
+	struct nexthop	*nh;
+	u8		weight;
+	atomic_t	upper_bound;
+
+	struct list_head nh_list;
+	struct nexthop	*nh_parent;  /* nexthop of group with this entry */
+};
+
+struct nh_group {
+	u16			num_nh;
+	bool			mpath;
+	bool			has_v4;
+	struct nh_grp_entry	nh_entries[0];
+};
+
 struct nexthop {
 	struct rb_node		rb_node;    /* entry on netns rbtree */
+	struct list_head	grp_list;   /* nh group entries using this nh */
 	struct net		*net;
 
 	u32			id;
 
 	u8			protocol;   /* app managing this nh */
 	u8			nh_flags;
+	bool			is_group;
 
 	refcount_t		refcnt;
 	struct rcu_head		rcu;
 
 	union {
 		struct nh_info	__rcu *nh_info;
+		struct nh_group __rcu *nh_grp;
 	};
 };
 
@@ -88,12 +110,86 @@ static inline void nexthop_put(struct nexthop *nh)
 		call_rcu(&nh->rcu, nexthop_free_rcu);
 }
 
+static inline bool nexthop_is_multipath(const struct nexthop *nh)
+{
+	if (nh->is_group) {
+		struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		return nh_grp->mpath;
+	}
+	return false;
+}
+
+struct nexthop *nexthop_select_path(struct nexthop *nh, int hash);
+
+static inline unsigned int nexthop_num_path(const struct nexthop *nh)
+{
+	unsigned int rc = 1;
+
+	if (nexthop_is_multipath(nh)) {
+		struct nh_group *nh_grp;
+
+		nh_grp = rcu_dereference_rtnl(nh->nh_grp);
+		rc = nh_grp->num_nh;
+	} else {
+		const struct nh_info *nhi;
+
+		nhi = rcu_dereference_rtnl(nh->nh_info);
+		if (nhi->reject_nh)
+			rc = 0;
+	}
+
+	return rc;
+}
+
+static inline
+struct nexthop *nexthop_mpath_select(const struct nexthop *nh, int nhsel)
+{
+	const struct nh_group *nhg = rcu_dereference_rtnl(nh->nh_grp);
+
+	/* for_nexthops macros in fib_semantics.c grabs a pointer to
+	 * the nexthop before checking nhsel
+	 */
+	if (nhsel > nhg->num_nh)
+		return NULL;
+
+	return nhg->nh_entries[nhsel].nh;
+}
+
+static inline
+int nexthop_mpath_fill_node(struct sk_buff *skb, struct nexthop *nh)
+{
+	struct nh_group *nhg = rtnl_dereference(nh->nh_grp);
+	int i;
+
+	for (i = 0; i < nhg->num_nh; i++) {
+		struct nexthop *nhe = nhg->nh_entries[i].nh;
+		struct nh_info *nhi = rcu_dereference_rtnl(nhe->nh_info);
+		struct fib_nh_common *nhc = &nhi->fib_nhc;
+		int weight = nhg->nh_entries[i].weight;
+
+		if (fib_add_nexthop(skb, nhc, weight) < 0)
+			return -EMSGSIZE;
+	}
+
+	return 0;
+}
+
 /* called with rcu lock */
 static inline bool nexthop_is_blackhole(const struct nexthop *nh)
 {
 	const struct nh_info *nhi;
 
-	nhi = rcu_dereference(nh->nh_info);
+	if (nexthop_is_multipath(nh)) {
+		if (nexthop_num_path(nh) > 1)
+			return false;
+		nh = nexthop_mpath_select(nh, 0);
+		if (!nh)
+			return false;
+	}
+
+	nhi = rcu_dereference_rtnl(nh->nh_info);
 	return nhi->reject_nh;
 }
 #endif

commit b513bd035f4044aa2667fb01418918523a049b9c
Author: David Ahern <dsahern@gmail.com>
Date:   Fri May 24 14:43:07 2019 -0700

    nexthop: Add support for lwt encaps
    
    Add support for NHA_ENCAP and NHA_ENCAP_TYPE. Leverages the existing code
    for lwtunnel within fib_nh_common, so the only change needed is handling
    the attributes in the nexthop code.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index d188f16c0c4f..7cde03337e14 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -35,6 +35,9 @@ struct nh_config {
 		struct in6_addr	ipv6;
 	} gw;
 
+	struct nlattr	*nh_encap;
+	u16		nh_encap_type;
+
 	u32		nlflags;
 	struct nl_info	nlinfo;
 };

commit 53010f991a9f5e4ed2db705ddde6ff32709192a2
Author: David Ahern <dsahern@gmail.com>
Date:   Fri May 24 14:43:06 2019 -0700

    nexthop: Add support for IPv6 gateways
    
    Handle IPv6 gateway in a nexthop spec. If nh_family is set to AF_INET6,
    NHA_GATEWAY is expected to be an IPv6 address. Add ipv6 option to gw in
    nh_config to hold the address, add fib6_nh to nh_info to leverage the
    ipv6 initialization and cleanup code. Update nh_fill_node to dump the v6
    address.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index c0e4b0d92c39..d188f16c0c4f 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -12,6 +12,7 @@
 #include <linux/netdevice.h>
 #include <linux/types.h>
 #include <net/ip_fib.h>
+#include <net/ip6_fib.h>
 #include <net/netlink.h>
 
 #define NEXTHOP_VALID_USER_FLAGS RTNH_F_ONLINK
@@ -31,6 +32,7 @@ struct nh_config {
 
 	union {
 		__be32		ipv4;
+		struct in6_addr	ipv6;
 	} gw;
 
 	u32		nlflags;
@@ -47,6 +49,7 @@ struct nh_info {
 	union {
 		struct fib_nh_common	fib_nhc;
 		struct fib_nh		fib_nh;
+		struct fib6_nh		fib6_nh;
 	};
 };
 

commit 597cfe4fc3390a055f42546c254e48601b37009f
Author: David Ahern <dsahern@gmail.com>
Date:   Fri May 24 14:43:05 2019 -0700

    nexthop: Add support for IPv4 nexthops
    
    Add support for IPv4 nexthops. If nh_family is set to AF_INET, then
    NHA_GATEWAY is expected to be an IPv4 address.
    
    Register for netdev events to be notified of admin up/down changes as
    well as deletes. A hash table is used to track nexthop per devices to
    quickly convert device events to the affected nexthops.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 18e1f512f866..c0e4b0d92c39 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -29,6 +29,10 @@ struct nh_config {
 	int		nh_ifindex;
 	struct net_device *dev;
 
+	union {
+		__be32		ipv4;
+	} gw;
+
 	u32		nlflags;
 	struct nl_info	nlinfo;
 };
@@ -42,6 +46,7 @@ struct nh_info {
 
 	union {
 		struct fib_nh_common	fib_nhc;
+		struct fib_nh		fib_nh;
 	};
 };
 

commit ab84be7e54fc3d9b248285f1a14067558d858819
Author: David Ahern <dsahern@gmail.com>
Date:   Fri May 24 14:43:04 2019 -0700

    net: Initial nexthop code
    
    Barebones start point for nexthops. Implementation for RTM commands,
    notifications, management of rbtree for holding nexthops by id, and
    kernel side data structures for nexthops and nexthop config.
    
    Nexthops are maintained in an rbtree sorted by id. Similar to routes,
    nexthops are configured per namespace using netns_nexthop struct added
    to struct net.
    
    Nexthop notifications are sent when a nexthop is added or deleted,
    but NOT if the delete is due to a device event or network namespace
    teardown (which also involves device events). Applications are
    expected to use the device down event to flush nexthops and any
    routes used by the nexthops.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
new file mode 100644
index 000000000000..18e1f512f866
--- /dev/null
+++ b/include/net/nexthop.h
@@ -0,0 +1,88 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Generic nexthop implementation
+ *
+ * Copyright (c) 2017-19 Cumulus Networks
+ * Copyright (c) 2017-19 David Ahern <dsa@cumulusnetworks.com>
+ */
+
+#ifndef __LINUX_NEXTHOP_H
+#define __LINUX_NEXTHOP_H
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+#include <net/ip_fib.h>
+#include <net/netlink.h>
+
+#define NEXTHOP_VALID_USER_FLAGS RTNH_F_ONLINK
+
+struct nexthop;
+
+struct nh_config {
+	u32		nh_id;
+
+	u8		nh_family;
+	u8		nh_protocol;
+	u8		nh_blackhole;
+	u32		nh_flags;
+
+	int		nh_ifindex;
+	struct net_device *dev;
+
+	u32		nlflags;
+	struct nl_info	nlinfo;
+};
+
+struct nh_info {
+	struct hlist_node	dev_hash;    /* entry on netns devhash */
+	struct nexthop		*nh_parent;
+
+	u8			family;
+	bool			reject_nh;
+
+	union {
+		struct fib_nh_common	fib_nhc;
+	};
+};
+
+struct nexthop {
+	struct rb_node		rb_node;    /* entry on netns rbtree */
+	struct net		*net;
+
+	u32			id;
+
+	u8			protocol;   /* app managing this nh */
+	u8			nh_flags;
+
+	refcount_t		refcnt;
+	struct rcu_head		rcu;
+
+	union {
+		struct nh_info	__rcu *nh_info;
+	};
+};
+
+/* caller is holding rcu or rtnl; no reference taken to nexthop */
+struct nexthop *nexthop_find_by_id(struct net *net, u32 id);
+void nexthop_free_rcu(struct rcu_head *head);
+
+static inline bool nexthop_get(struct nexthop *nh)
+{
+	return refcount_inc_not_zero(&nh->refcnt);
+}
+
+static inline void nexthop_put(struct nexthop *nh)
+{
+	if (refcount_dec_and_test(&nh->refcnt))
+		call_rcu(&nh->rcu, nexthop_free_rcu);
+}
+
+/* called with rcu lock */
+static inline bool nexthop_is_blackhole(const struct nexthop *nh)
+{
+	const struct nh_info *nhi;
+
+	nhi = rcu_dereference(nh->nh_info);
+	return nhi->reject_nh;
+}
+#endif

commit 3c618c1dbb8859625c643121ac80af9a6723533f
Author: David Ahern <dsahern@gmail.com>
Date:   Sat Apr 20 09:28:20 2019 -0700

    net: Rename net/nexthop.h net/rtnh.h
    
    The header contains rtnh_ macros so rename the file accordingly.
    Allows a later patch to use the nexthop.h name for the new
    nexthop code.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
deleted file mode 100644
index 902ff382a6dc..000000000000
--- a/include/net/nexthop.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __NET_NEXTHOP_H
-#define __NET_NEXTHOP_H
-
-#include <linux/rtnetlink.h>
-#include <net/netlink.h>
-
-static inline int rtnh_ok(const struct rtnexthop *rtnh, int remaining)
-{
-	return remaining >= (int)sizeof(*rtnh) &&
-	       rtnh->rtnh_len >= sizeof(*rtnh) &&
-	       rtnh->rtnh_len <= remaining;
-}
-
-static inline struct rtnexthop *rtnh_next(const struct rtnexthop *rtnh,
-                                         int *remaining)
-{
-	int totlen = NLA_ALIGN(rtnh->rtnh_len);
-
-	*remaining -= totlen;
-	return (struct rtnexthop *) ((char *) rtnh + totlen);
-}
-
-static inline struct nlattr *rtnh_attrs(const struct rtnexthop *rtnh)
-{
-	return (struct nlattr *) ((char *) rtnh + NLA_ALIGN(sizeof(*rtnh)));
-}
-
-static inline int rtnh_attrlen(const struct rtnexthop *rtnh)
-{
-	return rtnh->rtnh_len - NLA_ALIGN(sizeof(*rtnh));
-}
-
-#endif

commit b1993a2de12c9e75c35729e2ffbc3a92d50c0d31
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat Apr 7 13:42:38 2018 -0700

    net: fix rtnh_ok()
    
    syzbot reported :
    
    BUG: KMSAN: uninit-value in rtnh_ok include/net/nexthop.h:11 [inline]
    BUG: KMSAN: uninit-value in fib_count_nexthops net/ipv4/fib_semantics.c:469 [inline]
    BUG: KMSAN: uninit-value in fib_create_info+0x554/0x8d20 net/ipv4/fib_semantics.c:1091
    
    @remaining is an integer, coming from user space.
    If it is negative we want rtnh_ok() to return false.
    
    Fixes: 4e902c57417c ("[IPv4]: FIB configuration using struct fib_config")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 36bb794f5cd6..902ff382a6dc 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -7,7 +7,7 @@
 
 static inline int rtnh_ok(const struct rtnexthop *rtnh, int remaining)
 {
-	return remaining >= sizeof(*rtnh) &&
+	return remaining >= (int)sizeof(*rtnh) &&
 	       rtnh->rtnh_len >= sizeof(*rtnh) &&
 	       rtnh->rtnh_len <= remaining;
 }

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
index 3334dbfa5aa4..36bb794f5cd6 100644
--- a/include/net/nexthop.h
+++ b/include/net/nexthop.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __NET_NEXTHOP_H
 #define __NET_NEXTHOP_H
 

commit 4e902c57417c4c285b98ba2722468d1c3ed83d1b
Author: Thomas Graf <tgraf@suug.ch>
Date:   Thu Aug 17 18:14:52 2006 -0700

    [IPv4]: FIB configuration using struct fib_config
    
    Introduces struct fib_config replacing the ugly struct kern_rta
    prone to ordering issues. Avoids creating faked netlink messages
    for auto generated routes or requests via ioctl.
    
    A new interface net/nexthop.h is added to help navigate through
    nexthop configuration arrays.
    
    A new struct nl_info will be used to carry the necessary netlink
    information to be used for notifications later on.
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/nexthop.h b/include/net/nexthop.h
new file mode 100644
index 000000000000..3334dbfa5aa4
--- /dev/null
+++ b/include/net/nexthop.h
@@ -0,0 +1,33 @@
+#ifndef __NET_NEXTHOP_H
+#define __NET_NEXTHOP_H
+
+#include <linux/rtnetlink.h>
+#include <net/netlink.h>
+
+static inline int rtnh_ok(const struct rtnexthop *rtnh, int remaining)
+{
+	return remaining >= sizeof(*rtnh) &&
+	       rtnh->rtnh_len >= sizeof(*rtnh) &&
+	       rtnh->rtnh_len <= remaining;
+}
+
+static inline struct rtnexthop *rtnh_next(const struct rtnexthop *rtnh,
+                                         int *remaining)
+{
+	int totlen = NLA_ALIGN(rtnh->rtnh_len);
+
+	*remaining -= totlen;
+	return (struct rtnexthop *) ((char *) rtnh + totlen);
+}
+
+static inline struct nlattr *rtnh_attrs(const struct rtnexthop *rtnh)
+{
+	return (struct nlattr *) ((char *) rtnh + NLA_ALIGN(sizeof(*rtnh)));
+}
+
+static inline int rtnh_attrlen(const struct rtnexthop *rtnh)
+{
+	return rtnh->rtnh_len - NLA_ALIGN(sizeof(*rtnh));
+}
+
+#endif
