commit 762f926d6f19b9ab4dee0f98d55fc67e276cd094
Author: Alaa Hleihel <alaa@mellanox.com>
Date:   Sun Jun 14 14:12:48 2020 +0300

    net/sched: act_ct: Make tcf_ct_flow_table_restore_skb inline
    
    Currently, tcf_ct_flow_table_restore_skb is exported by act_ct
    module, therefore modules using it will have hard-dependency
    on act_ct and will require loading it all the time.
    
    This can lead to an unnecessary overhead on systems that do not
    use hardware connection tracking action (ct_metadata action) in
    the first place.
    
    To relax the hard-dependency between the modules, we unexport this
    function and make it a static inline one.
    
    Fixes: 30b0cf90c6dd ("net/sched: act_ct: Support restoring conntrack info on skbs")
    Signed-off-by: Alaa Hleihel <alaa@mellanox.com>
    Reviewed-by: Roi Dayan <roid@mellanox.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_ct.h b/include/net/tc_act/tc_ct.h
index 79654bcb9a29..8250d6f0a462 100644
--- a/include/net/tc_act/tc_ct.h
+++ b/include/net/tc_act/tc_ct.h
@@ -66,7 +66,16 @@ static inline struct nf_flowtable *tcf_ct_ft(const struct tc_action *a)
 #endif /* CONFIG_NF_CONNTRACK */
 
 #if IS_ENABLED(CONFIG_NET_ACT_CT)
-void tcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie);
+static inline void
+tcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie)
+{
+	enum ip_conntrack_info ctinfo = cookie & NFCT_INFOMASK;
+	struct nf_conn *ct;
+
+	ct = (struct nf_conn *)(cookie & NFCT_PTRMASK);
+	nf_conntrack_get(&ct->ct_general);
+	nf_ct_set(skb, ct, ctinfo);
+}
 #else
 static inline void
 tcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie) { }

commit edd5861e597b7ec2fae2fa3bc8180164045b5075
Author: Paul Blakey <paulb@mellanox.com>
Date:   Thu Mar 12 12:23:09 2020 +0200

    net/sched: act_ct: Enable hardware offload of flow table entires
    
    Pass the zone's flow table instance on the flow action to the drivers.
    Thus, allowing drivers to register FT add/del/stats callbacks.
    
    Finally, enable hardware offload on the flow table instance.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_ct.h b/include/net/tc_act/tc_ct.h
index 735da5912974..79654bcb9a29 100644
--- a/include/net/tc_act/tc_ct.h
+++ b/include/net/tc_act/tc_ct.h
@@ -27,6 +27,7 @@ struct tcf_ct_params {
 	struct rcu_head rcu;
 
 	struct tcf_ct_flow_table *ct_ft;
+	struct nf_flowtable *nf_ft;
 };
 
 struct tcf_ct {
@@ -50,9 +51,18 @@ static inline int tcf_ct_action(const struct tc_action *a)
 	return to_ct_params(a)->ct_action;
 }
 
+static inline struct nf_flowtable *tcf_ct_ft(const struct tc_action *a)
+{
+	return to_ct_params(a)->nf_ft;
+}
+
 #else
 static inline uint16_t tcf_ct_zone(const struct tc_action *a) { return 0; }
 static inline int tcf_ct_action(const struct tc_action *a) { return 0; }
+static inline struct nf_flowtable *tcf_ct_ft(const struct tc_action *a)
+{
+	return NULL;
+}
 #endif /* CONFIG_NF_CONNTRACK */
 
 #if IS_ENABLED(CONFIG_NET_ACT_CT)

commit 30b0cf90c6dd82e7ebb3fcb5ba8447f1baeb80be
Author: Paul Blakey <paulb@mellanox.com>
Date:   Thu Mar 12 12:23:07 2020 +0200

    net/sched: act_ct: Support restoring conntrack info on skbs
    
    Provide an API to restore the ct state pointer.
    
    This may be used by drivers to restore the ct state if they
    miss in tc chain after they already did the hardware connection
    tracking action (ct_metadata action).
    
    For example, consider the following rule on chain 0 that is in_hw,
    however chain 1 is not_in_hw:
    
    $ tc filter add dev ... chain 0 ... \
      flower ... action ct pipe action goto chain 1
    
    Packets of a flow offloaded (via nf flow table offload) by the driver
    hit this rule in hardware, will be marked with the ct metadata action
    (mark, label, zone) that does the equivalent of the software ct action,
    and when the packet jumps to hardware chain 1, there would be a miss.
    
    CT was already processed in hardware. Therefore, the driver's miss
    handling should restore the ct state on the skb, using the provided API,
    and continue the packet processing in chain 1.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_ct.h b/include/net/tc_act/tc_ct.h
index cf3492e2a6a4..735da5912974 100644
--- a/include/net/tc_act/tc_ct.h
+++ b/include/net/tc_act/tc_ct.h
@@ -55,6 +55,13 @@ static inline uint16_t tcf_ct_zone(const struct tc_action *a) { return 0; }
 static inline int tcf_ct_action(const struct tc_action *a) { return 0; }
 #endif /* CONFIG_NF_CONNTRACK */
 
+#if IS_ENABLED(CONFIG_NET_ACT_CT)
+void tcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie);
+#else
+static inline void
+tcf_ct_flow_table_restore_skb(struct sk_buff *skb, unsigned long cookie) { }
+#endif
+
 static inline bool is_tcf_ct(const struct tc_action *a)
 {
 #if defined(CONFIG_NET_CLS_ACT) && IS_ENABLED(CONFIG_NF_CONNTRACK)

commit c34b961a249211bdb08d03bdecfb31ff22eb002f
Author: Paul Blakey <paulb@mellanox.com>
Date:   Tue Mar 3 15:07:49 2020 +0200

    net/sched: act_ct: Create nf flow table per zone
    
    Use the NF flow tables infrastructure for CT offload.
    
    Create a nf flow table per zone.
    
    Next patches will add FT entries to this table, and do
    the software offload.
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_ct.h b/include/net/tc_act/tc_ct.h
index a8b156402873..cf3492e2a6a4 100644
--- a/include/net/tc_act/tc_ct.h
+++ b/include/net/tc_act/tc_ct.h
@@ -25,6 +25,8 @@ struct tcf_ct_params {
 	u16 ct_action;
 
 	struct rcu_head rcu;
+
+	struct tcf_ct_flow_table *ct_ft;
 };
 
 struct tcf_ct {

commit 107f2d50916500985b9fffd7c77d8c14809f9802
Author: Vlad Buslov <vladbu@mellanox.com>
Date:   Mon Feb 17 12:12:11 2020 +0200

    net: sched: refactor ct action helpers to require tcf_lock
    
    In order to remove rtnl lock dependency from flow_action representation
    translator, change rtnl_dereference() to rcu_dereference_protected() in ct
    action helpers that provide external access to zone and action values. This
    is safe to do because the functions are not called from anywhere else
    outside flow_action infrastructure which was modified to obtain tcf_lock
    when accessing action data in one of previous patches in the series.
    
    Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_ct.h b/include/net/tc_act/tc_ct.h
index bdc20ab3b88d..a8b156402873 100644
--- a/include/net/tc_act/tc_ct.h
+++ b/include/net/tc_act/tc_ct.h
@@ -33,8 +33,10 @@ struct tcf_ct {
 };
 
 #define to_ct(a) ((struct tcf_ct *)a)
-#define to_ct_params(a) ((struct tcf_ct_params *) \
-			 rtnl_dereference((to_ct(a)->params)))
+#define to_ct_params(a)							\
+	((struct tcf_ct_params *)					\
+	 rcu_dereference_protected(to_ct(a)->params,			\
+				   lockdep_is_held(&a->tcfa_lock)))
 
 static inline uint16_t tcf_ct_zone(const struct tc_action *a)
 {

commit b57dc7c13ea90e09ae15f821d2583fa0231b4935
Author: Paul Blakey <paulb@mellanox.com>
Date:   Tue Jul 9 10:30:48 2019 +0300

    net/sched: Introduce action ct
    
    Allow sending a packet to conntrack module for connection tracking.
    
    The packet will be marked with conntrack connection's state, and
    any metadata such as conntrack mark and label. This state metadata
    can later be matched against with tc classifers, for example with the
    flower classifier as below.
    
    In addition to committing new connections the user can optionally
    specific a zone to track within, set a mark/label and configure nat
    with an address range and port range.
    
    Usage is as follows:
    $ tc qdisc add dev ens1f0_0 ingress
    $ tc qdisc add dev ens1f0_1 ingress
    
    $ tc filter add dev ens1f0_0 ingress \
      prio 1 chain 0 proto ip \
      flower ip_proto tcp ct_state -trk \
      action ct zone 2 pipe \
      action goto chain 2
    $ tc filter add dev ens1f0_0 ingress \
      prio 1 chain 2 proto ip \
      flower ct_state +trk+new \
      action ct zone 2 commit mark 0xbb nat src addr 5.5.5.7 pipe \
      action mirred egress redirect dev ens1f0_1
    $ tc filter add dev ens1f0_0 ingress \
      prio 1 chain 2 proto ip \
      flower ct_zone 2 ct_mark 0xbb ct_state +trk+est \
      action ct nat pipe \
      action mirred egress redirect dev ens1f0_1
    
    $ tc filter add dev ens1f0_1 ingress \
      prio 1 chain 0 proto ip \
      flower ip_proto tcp ct_state -trk \
      action ct zone 2 pipe \
      action goto chain 1
    $ tc filter add dev ens1f0_1 ingress \
      prio 1 chain 1 proto ip \
      flower ct_zone 2 ct_mark 0xbb ct_state +trk+est \
      action ct nat pipe \
      action mirred egress redirect dev ens1f0_0
    
    Signed-off-by: Paul Blakey <paulb@mellanox.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Yossi Kuperman <yossiku@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    
    Changelog:
    V5->V6:
            Added CONFIG_NF_DEFRAG_IPV6 in handle fragments ipv6 case
    V4->V5:
            Reordered nf_conntrack_put() in tcf_ct_skb_nfct_cached()
    V3->V4:
            Added strict_start_type for act_ct policy
    V2->V3:
            Fixed david's comments: Removed extra newline after rcu in tcf_ct_params , and indent of break in act_ct.c
    V1->V2:
            Fixed parsing of ranges TCA_CT_NAT_IPV6_MAX as 'else' case overwritten ipv4 max
            Refactored NAT_PORT_MIN_MAX range handling as well
            Added ipv4/ipv6 defragmentation
            Removed extra skb pull push of nw offset in exectute nat
            Refactored tcf_ct_skb_network_trim after pull
            Removed TCA_ACT_CT define
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_ct.h b/include/net/tc_act/tc_ct.h
new file mode 100644
index 000000000000..bdc20ab3b88d
--- /dev/null
+++ b/include/net/tc_act/tc_ct.h
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __NET_TC_CT_H
+#define __NET_TC_CT_H
+
+#include <net/act_api.h>
+#include <uapi/linux/tc_act/tc_ct.h>
+
+#if IS_ENABLED(CONFIG_NF_CONNTRACK)
+#include <net/netfilter/nf_nat.h>
+#include <net/netfilter/nf_conntrack_labels.h>
+
+struct tcf_ct_params {
+	struct nf_conn *tmpl;
+	u16 zone;
+
+	u32 mark;
+	u32 mark_mask;
+
+	u32 labels[NF_CT_LABELS_MAX_SIZE / sizeof(u32)];
+	u32 labels_mask[NF_CT_LABELS_MAX_SIZE / sizeof(u32)];
+
+	struct nf_nat_range2 range;
+	bool ipv4_range;
+
+	u16 ct_action;
+
+	struct rcu_head rcu;
+};
+
+struct tcf_ct {
+	struct tc_action common;
+	struct tcf_ct_params __rcu *params;
+};
+
+#define to_ct(a) ((struct tcf_ct *)a)
+#define to_ct_params(a) ((struct tcf_ct_params *) \
+			 rtnl_dereference((to_ct(a)->params)))
+
+static inline uint16_t tcf_ct_zone(const struct tc_action *a)
+{
+	return to_ct_params(a)->zone;
+}
+
+static inline int tcf_ct_action(const struct tc_action *a)
+{
+	return to_ct_params(a)->ct_action;
+}
+
+#else
+static inline uint16_t tcf_ct_zone(const struct tc_action *a) { return 0; }
+static inline int tcf_ct_action(const struct tc_action *a) { return 0; }
+#endif /* CONFIG_NF_CONNTRACK */
+
+static inline bool is_tcf_ct(const struct tc_action *a)
+{
+#if defined(CONFIG_NET_CLS_ACT) && IS_ENABLED(CONFIG_NF_CONNTRACK)
+	if (a->ops && a->ops->id == TCA_ID_CT)
+		return true;
+#endif
+	return false;
+}
+
+#endif /* __NET_TC_CT_H */
