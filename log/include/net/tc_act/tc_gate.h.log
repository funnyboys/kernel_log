commit d29bdd69ecdd70e8e3c2268fc8e188d6ab55e54a
Author: Po Liu <Po.Liu@nxp.com>
Date:   Fri May 1 08:53:16 2020 +0800

    net: schedule: add action gate offloading
    
    Add the gate action to the flow action entry. Add the gate parameters to
    the tc_setup_flow_action() queueing to the entries of flow_action_entry
    array provide to the driver.
    
    Signed-off-by: Po Liu <Po.Liu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_gate.h b/include/net/tc_act/tc_gate.h
index 330ad8b02495..8bc6be81a7ad 100644
--- a/include/net/tc_act/tc_gate.h
+++ b/include/net/tc_act/tc_gate.h
@@ -7,6 +7,13 @@
 #include <net/act_api.h>
 #include <linux/tc_act/tc_gate.h>
 
+struct action_gate_entry {
+	u8			gate_state;
+	u32			interval;
+	s32			ipv;
+	s32			maxoctets;
+};
+
 struct tcfg_gate_entry {
 	int			index;
 	u8			gate_state;
@@ -44,4 +51,96 @@ struct tcf_gate {
 
 #define to_gate(a) ((struct tcf_gate *)a)
 
+static inline bool is_tcf_gate(const struct tc_action *a)
+{
+#ifdef CONFIG_NET_CLS_ACT
+	if (a->ops && a->ops->id == TCA_ID_GATE)
+		return true;
+#endif
+	return false;
+}
+
+static inline u32 tcf_gate_index(const struct tc_action *a)
+{
+	return a->tcfa_index;
+}
+
+static inline s32 tcf_gate_prio(const struct tc_action *a)
+{
+	s32 tcfg_prio;
+
+	tcfg_prio = to_gate(a)->param.tcfg_priority;
+
+	return tcfg_prio;
+}
+
+static inline u64 tcf_gate_basetime(const struct tc_action *a)
+{
+	u64 tcfg_basetime;
+
+	tcfg_basetime = to_gate(a)->param.tcfg_basetime;
+
+	return tcfg_basetime;
+}
+
+static inline u64 tcf_gate_cycletime(const struct tc_action *a)
+{
+	u64 tcfg_cycletime;
+
+	tcfg_cycletime = to_gate(a)->param.tcfg_cycletime;
+
+	return tcfg_cycletime;
+}
+
+static inline u64 tcf_gate_cycletimeext(const struct tc_action *a)
+{
+	u64 tcfg_cycletimeext;
+
+	tcfg_cycletimeext = to_gate(a)->param.tcfg_cycletime_ext;
+
+	return tcfg_cycletimeext;
+}
+
+static inline u32 tcf_gate_num_entries(const struct tc_action *a)
+{
+	u32 num_entries;
+
+	num_entries = to_gate(a)->param.num_entries;
+
+	return num_entries;
+}
+
+static inline struct action_gate_entry
+			*tcf_gate_get_list(const struct tc_action *a)
+{
+	struct action_gate_entry *oe;
+	struct tcf_gate_params *p;
+	struct tcfg_gate_entry *entry;
+	u32 num_entries;
+	int i = 0;
+
+	p = &to_gate(a)->param;
+	num_entries = p->num_entries;
+
+	list_for_each_entry(entry, &p->entries, list)
+		i++;
+
+	if (i != num_entries)
+		return NULL;
+
+	oe = kcalloc(num_entries, sizeof(*oe), GFP_ATOMIC);
+	if (!oe)
+		return NULL;
+
+	i = 0;
+	list_for_each_entry(entry, &p->entries, list) {
+		oe[i].gate_state = entry->gate_state;
+		oe[i].interval = entry->interval;
+		oe[i].ipv = entry->ipv;
+		oe[i].maxoctets = entry->maxoctets;
+		i++;
+	}
+
+	return oe;
+}
 #endif

commit a51c328df3106663879645680609eb49b3ff6444
Author: Po Liu <Po.Liu@nxp.com>
Date:   Fri May 1 08:53:15 2020 +0800

    net: qos: introduce a gate control flow action
    
    Introduce a ingress frame gate control flow action.
    Tc gate action does the work like this:
    Assume there is a gate allow specified ingress frames can be passed at
    specific time slot, and be dropped at specific time slot. Tc filter
    chooses the ingress frames, and tc gate action would specify what slot
    does these frames can be passed to device and what time slot would be
    dropped.
    Tc gate action would provide an entry list to tell how much time gate
    keep open and how much time gate keep state close. Gate action also
    assign a start time to tell when the entry list start. Then driver would
    repeat the gate entry list cyclically.
    For the software simulation, gate action requires the user assign a time
    clock type.
    
    Below is the setting example in user space. Tc filter a stream source ip
    address is 192.168.0.20 and gate action own two time slots. One is last
    200ms gate open let frame pass another is last 100ms gate close let
    frames dropped. When the ingress frames have reach total frames over
    8000000 bytes, the excessive frames will be dropped in that 200000000ns
    time slot.
    
    > tc qdisc add dev eth0 ingress
    
    > tc filter add dev eth0 parent ffff: protocol ip \
               flower src_ip 192.168.0.20 \
               action gate index 2 clockid CLOCK_TAI \
               sched-entry open 200000000 -1 8000000 \
               sched-entry close 100000000 -1 -1
    
    > tc chain del dev eth0 ingress chain 0
    
    "sched-entry" follow the name taprio style. Gate state is
    "open"/"close". Follow with period nanosecond. Then next item is internal
    priority value means which ingress queue should put. "-1" means
    wildcard. The last value optional specifies the maximum number of
    MSDU octets that are permitted to pass the gate during the specified
    time interval.
    Base-time is not set will be 0 as default, as result start time would
    be ((N + 1) * cycletime) which is the minimal of future time.
    
    Below example shows filtering a stream with destination mac address is
    10:00:80:00:00:00 and ip type is ICMP, follow the action gate. The gate
    action would run with one close time slot which means always keep close.
    The time cycle is total 200000000ns. The base-time would calculate by:
    
     1357000000000 + (N + 1) * cycletime
    
    When the total value is the future time, it will be the start time.
    The cycletime here would be 200000000ns for this case.
    
    > tc filter add dev eth0 parent ffff:  protocol ip \
               flower skip_hw ip_proto icmp dst_mac 10:00:80:00:00:00 \
               action gate index 12 base-time 1357000000000 \
               sched-entry close 200000000 -1 -1 \
               clockid CLOCK_TAI
    
    Signed-off-by: Po Liu <Po.Liu@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/tc_act/tc_gate.h b/include/net/tc_act/tc_gate.h
new file mode 100644
index 000000000000..330ad8b02495
--- /dev/null
+++ b/include/net/tc_act/tc_gate.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright 2020 NXP */
+
+#ifndef __NET_TC_GATE_H
+#define __NET_TC_GATE_H
+
+#include <net/act_api.h>
+#include <linux/tc_act/tc_gate.h>
+
+struct tcfg_gate_entry {
+	int			index;
+	u8			gate_state;
+	u32			interval;
+	s32			ipv;
+	s32			maxoctets;
+	struct list_head	list;
+};
+
+struct tcf_gate_params {
+	s32			tcfg_priority;
+	u64			tcfg_basetime;
+	u64			tcfg_cycletime;
+	u64			tcfg_cycletime_ext;
+	u32			tcfg_flags;
+	s32			tcfg_clockid;
+	size_t			num_entries;
+	struct list_head	entries;
+};
+
+#define GATE_ACT_GATE_OPEN	BIT(0)
+#define GATE_ACT_PENDING	BIT(1)
+
+struct tcf_gate {
+	struct tc_action	common;
+	struct tcf_gate_params	param;
+	u8			current_gate_status;
+	ktime_t			current_close_time;
+	u32			current_entry_octets;
+	s32			current_max_octets;
+	struct tcfg_gate_entry	*next_entry;
+	struct hrtimer		hitimer;
+	enum tk_offsets		tk_offset;
+};
+
+#define to_gate(a) ((struct tcf_gate *)a)
+
+#endif
