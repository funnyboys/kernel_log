commit af13b3c338bea6a766b1a0ee4f9c939e8bf38256
Author: David Laight <David.Laight@ACULAB.COM>
Date:   Mon Mar 23 14:31:19 2020 +0000

    Remove DST_HOST
    
    Previous changes to the IP routing code have removed all the
    tests for the DS_HOST route flag.
    Remove the flags and all the code that sets it.
    
    Signed-off-by: David Laight <david.laight@aculab.com>
    Acked-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 81750ae50833..ff021cab657e 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -231,7 +231,7 @@ int ip_rt_ioctl(struct net *, unsigned int cmd, struct rtentry *rt);
 void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
 struct rtable *rt_dst_alloc(struct net_device *dev,
 			     unsigned int flags, u16 type,
-			     bool nopolicy, bool noxfrm, bool will_cache);
+			     bool nopolicy, bool noxfrm);
 struct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);
 
 struct in_ifaddr;

commit 571912c69f0ed731bd1e071ade9dc7ca4aa52065
Author: Martin Varghese <martin.varghese@nokia.com>
Date:   Mon Feb 24 10:57:50 2020 +0530

    net: UDP tunnel encapsulation module for tunnelling different protocols like MPLS, IP, NSH etc.
    
    The Bareudp tunnel module provides a generic L3 encapsulation
    tunnelling module for tunnelling different protocols like MPLS,
    IP,NSH etc inside a UDP tunnel.
    
    Signed-off-by: Martin Varghese <martin.varghese@nokia.com>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index a9c60fc68e36..81750ae50833 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -128,6 +128,12 @@ static inline struct rtable *__ip_route_output_key(struct net *net,
 
 struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
 				    const struct sock *sk);
+struct rtable *ip_route_output_tunnel(struct sk_buff *skb,
+				      struct net_device *dev,
+				      struct net *net, __be32 *saddr,
+				      const struct ip_tunnel_info *info,
+				      u8 protocol, bool use_cache);
+
 struct dst_entry *ipv4_blackhole_route(struct net *net,
 				       struct dst_entry *dst_orig);
 

commit 02b24941619fcce3d280311ac73b1e461552e9c8
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Wed Nov 20 13:47:37 2019 +0100

    ipv4: use dst hint for ipv4 list receive
    
    This is alike the previous change, with some additional ipv4 specific
    quirk. Even when using the route hint we still have to do perform
    additional per packet checks about source address validity: a new
    helper is added to wrap them.
    
    Hints are explicitly disabled if the destination is a local broadcast,
    that keeps the code simple and local broadcast are a slower path anyway.
    
    UDP flood performances vs recvmmsg() receiver:
    
    vanilla         patched         delta
    Kpps            Kpps            %
    1683            1871            +11
    
    In the worst case scenario - each packet has a different
    destination address - the performance delta is within noise
    range.
    
    v3 -> v4:
     - re-enable hints for forward
    
    v2 -> v3:
     - really fix build (sic) and hint usage check
     - use fib4_has_custom_rules() helpers (David A.)
     - add ip_extract_route_hint() helper (Edward C.)
     - use prev skb as hint instead of copying data (Willem)
    
    v1 -> v2:
     - fix build issue with !CONFIG_IP_MULTIPLE_TABLES
    
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6c516840380d..a9c60fc68e36 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -185,6 +185,10 @@ int ip_route_input_rcu(struct sk_buff *skb, __be32 dst, __be32 src,
 		       u8 tos, struct net_device *devin,
 		       struct fib_result *res);
 
+int ip_route_use_hint(struct sk_buff *skb, __be32 dst, __be32 src,
+		      u8 tos, struct net_device *devin,
+		      const struct sk_buff *hint);
+
 static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin)
 {

commit 77d5bc7e6a6cf8bbeca31aab7f0c5449a5eee762
Author: David Ahern <dsahern@gmail.com>
Date:   Tue Sep 17 10:39:49 2019 -0700

    ipv4: Revert removal of rt_uses_gateway
    
    Julian noted that rt_uses_gateway has a more subtle use than 'is gateway
    set':
        https://lore.kernel.org/netdev/alpine.LFD.2.21.1909151104060.2546@ja.home.ssi.bg/
    
    Revert that part of the commit referenced in the Fixes tag.
    
    Currently, there are no u8 holes in 'struct rtable'. There is a 4-byte hole
    in the second cacheline which contains the gateway declaration. So move
    rt_gw_family down to the gateway declarations since they are always used
    together, and then re-use that u8 for rt_uses_gateway. End result is that
    rtable size is unchanged.
    
    Fixes: 1550c171935d ("ipv4: Prepare rtable for IPv6 gateway")
    Reported-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Reviewed-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/include/net/route.h b/include/net/route.h
index dfce19c9fa96..6c516840380d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -53,10 +53,11 @@ struct rtable {
 	unsigned int		rt_flags;
 	__u16			rt_type;
 	__u8			rt_is_input;
-	u8			rt_gw_family;
+	__u8			rt_uses_gateway;
 
 	int			rt_iif;
 
+	u8			rt_gw_family;
 	/* Info on neighbour */
 	union {
 		__be32		rt_gw4;

commit e93fb3e9521abffadb8f965c591a290cdd92b56c
Author: John Fastabend <john.fastabend@gmail.com>
Date:   Fri Aug 23 17:11:38 2019 -0700

    net: route dump netlink NLM_F_MULTI flag missing
    
    An excerpt from netlink(7) man page,
    
      In multipart messages (multiple nlmsghdr headers with associated payload
      in one byte stream) the first and all following headers have the
      NLM_F_MULTI flag set, except for the last  header  which  has the type
      NLMSG_DONE.
    
    but, after (ee28906) there is a missing NLM_F_MULTI flag in the middle of a
    FIB dump. The result is user space applications following above man page
    excerpt may get confused and may stop parsing msg believing something went
    wrong.
    
    In the golang netlink lib [0] the library logic stops parsing believing the
    message is not a multipart message. Found this running Cilium[1] against
    net-next while adding a feature to auto-detect routes. I noticed with
    multiple route tables we no longer could detect the default routes on net
    tree kernels because the library logic was not returning them.
    
    Fix this by handling the fib_dump_info_fnhe() case the same way the
    fib_dump_info() handles it by passing the flags argument through the
    call chain and adding a flags argument to rt_fill_info().
    
    Tested with Cilium stack and auto-detection of routes works again. Also
    annotated libs to dump netlink msgs and inspected NLM_F_MULTI and
    NLMSG_DONE flags look correct after this.
    
    Note: In inet_rtm_getroute() pass rt_fill_info() '0' for flags the same
    as is done for fib_dump_info() so this looks correct to me.
    
    [0] https://github.com/vishvananda/netlink/
    [1] https://github.com/cilium/
    
    Fixes: ee28906fd7a14 ("ipv4: Dump route exceptions if requested")
    Signed-off-by: John Fastabend <john.fastabend@gmail.com>
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 630a0493f1f3..dfce19c9fa96 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -233,7 +233,7 @@ void rt_del_uncached_list(struct rtable *rt);
 
 int fib_dump_info_fnhe(struct sk_buff *skb, struct netlink_callback *cb,
 		       u32 table_id, struct fib_info *fi,
-		       int *fa_index, int fa_start);
+		       int *fa_index, int fa_start, unsigned int flags);
 
 static inline void ip_rt_put(struct rtable *rt)
 {

commit d96ff269a04be286989ead13bf8b4be55bdee8ee
Merge: 3a49584477ff 556e2f6020bf
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 27 21:06:39 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    The new route handling in ip_mc_finish_output() from 'net' overlapped
    with the new support for returning congestion notifications from BPF
    programs.
    
    In order to handle this I had to take the dev_loopback_xmit() calls
    out of the switch statement.
    
    The aquantia driver conflicts were simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5b18f1289808fee5d04a7e6ecf200189f41a4db6
Author: Stephen Suryaputra <ssuryaextr@gmail.com>
Date:   Wed Jun 26 02:21:16 2019 -0400

    ipv4: reset rt_iif for recirculated mcast/bcast out pkts
    
    Multicast or broadcast egress packets have rt_iif set to the oif. These
    packets might be recirculated back as input and lookup to the raw
    sockets may fail because they are bound to the incoming interface
    (skb_iif). If rt_iif is not zero, during the lookup, inet_iif() function
    returns rt_iif instead of skb_iif. Hence, the lookup fails.
    
    v2: Make it non vrf specific (David Ahern). Reword the changelog to
        reflect it.
    Signed-off-by: Stephen Suryaputra <ssuryaextr@gmail.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 065b47754f05..55ff71ffb796 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -221,6 +221,7 @@ void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
 struct rtable *rt_dst_alloc(struct net_device *dev,
 			     unsigned int flags, u16 type,
 			     bool nopolicy, bool noxfrm, bool will_cache);
+struct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);
 
 struct in_ifaddr;
 void fib_add_ifaddr(struct in_ifaddr *);

commit ee28906fd7a1437ca77a60a99b6b9c6d676220f8
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Fri Jun 21 17:45:23 2019 +0200

    ipv4: Dump route exceptions if requested
    
    Since commit 4895c771c7f0 ("ipv4: Add FIB nexthop exceptions."), cached
    exception routes are stored as a separate entity, so they are not dumped
    on a FIB dump, even if the RTM_F_CLONED flag is passed.
    
    This implies that the command 'ip route list cache' doesn't return any
    result anymore.
    
    If the RTM_F_CLONED is passed, and strict checking requested, retrieve
    nexthop exception routes and dump them. If no strict checking is
    requested, filtering can't be performed consistently: dump everything in
    that case.
    
    With this, we need to add an argument to the netlink callback in order to
    track how many entries were already dumped for the last leaf included in
    a partial netlink dump.
    
    A single additional argument is sufficient, even if we traverse logically
    nested structures (nexthop objects, hash table buckets, bucket chains): it
    doesn't matter if we stop in the middle of any of those, because they are
    always traversed the same way. As an example, s_i values in [], s_fa
    values in ():
    
      node (fa) #1 [1]
        nexthop #1
        bucket #1 -> #0 in chain (1)
        bucket #2 -> #0 in chain (2) -> #1 in chain (3) -> #2 in chain (4)
        bucket #3 -> #0 in chain (5) -> #1 in chain (6)
    
        nexthop #2
        bucket #1 -> #0 in chain (7) -> #1 in chain (8)
        bucket #2 -> #0 in chain (9)
      --
      node (fa) #2 [2]
        nexthop #1
        bucket #1 -> #0 in chain (1) -> #1 in chain (2)
        bucket #2 -> #0 in chain (3)
    
    it doesn't matter if we stop at (3), (4), (7) for "node #1", or at (2)
    for "node #2": walking flattens all that.
    
    It would even be possible to drop the distinction between the in-tree
    (s_i) and in-node (s_fa) counter, but a further improvement might
    advise against this. This is only as accurate as the existing tracking
    mechanism for leaves: if a partial dump is restarted after exceptions
    are removed or expired, we might skip some non-dumped entries.
    
    To improve this, we could attach a 'sernum' attribute (similar to the
    one used for IPv6) to nexthop entities, and bump this counter whenever
    exceptions change: having a distinction between the two counters would
    make this more convenient.
    
    Listing of exception routes (modified routes pre-3.5) was tested against
    these versions of kernel and iproute2:
    
                        iproute2
    kernel         4.14.0   4.15.0   4.19.0   5.0.0   5.1.0
     3.5-rc4         +        +        +        +       +
     4.4
     4.9
     4.14
     4.15
     4.19
     5.0
     5.1
     fixed           +        +        +        +       +
    
    v7:
       - Move loop over nexthop objects to route.c, and pass struct fib_info
         and table ID to it, not a struct fib_alias (suggested by David Ahern)
       - While at it, note that the NULL check on fa->fa_info is redundant,
         and the check on RTNH_F_DEAD is also not consistent with what's done
         with regular route listing: just keep it for nhc_flags
       - Rename entry point function for dumping exceptions to
         fib_dump_info_fnhe(), and rearrange arguments for consistency with
         fib_dump_info()
       - Rename fnhe_dump_buckets() to fnhe_dump_bucket() and make it handle
         one bucket at a time
       - Expand commit message to describe why we can have a single "skip"
         counter for all exceptions stored in bucket chains in nexthop objects
         (suggested by David Ahern)
    
    v6:
       - Rebased onto net-next
       - Loop over nexthop paths too. Move loop over fnhe buckets to route.c,
         avoids need to export rt_fill_info() and to touch exceptions from
         fib_trie.c. Pass NULL as flow to rt_fill_info(), it now allows that
         (suggested by David Ahern)
    
    Fixes: 4895c771c7f0 ("ipv4: Add FIB nexthop exceptions.")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 065b47754f05..cfcd0f5980f9 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -230,6 +230,10 @@ void fib_modify_prefix_metric(struct in_ifaddr *ifa, u32 new_metric);
 void rt_add_uncached_list(struct rtable *rt);
 void rt_del_uncached_list(struct rtable *rt);
 
+int fib_dump_info_fnhe(struct sk_buff *skb, struct netlink_callback *cb,
+		       u32 table_id, struct fib_info *fi,
+		       int *fa_index, int fa_start);
+
 static inline void ip_rt_put(struct rtable *rt)
 {
 	/* dst_release() accepts a NULL parameter.

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/route.h b/include/net/route.h
index 96f6c9ae33c2..065b47754f05 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * INET		An implementation of the TCP/IP protocol suite for the LINUX
  *		operating system.  INET  is implemented using the  BSD Socket
@@ -15,11 +16,6 @@
  *		Alexey Kuznetsov:	Major changes for new routing code.
  *		Mike McLagan    :	Routing by source
  *		Robert Olsson   :	Added rt_cache statistics
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
  */
 #ifndef _ROUTE_H
 #define _ROUTE_H

commit 5c9f7c1dfc2e0776551ef1ceb335187c6698d1ff
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Apr 5 16:30:34 2019 -0700

    ipv4: Add helpers for neigh lookup for nexthop
    
    A common theme in the output path is looking up a neigh entry for a
    nexthop, either the gateway in an rtable or a fallback to the daddr
    in the skb:
    
            nexthop = (__force u32)rt_nexthop(rt, ip_hdr(skb)->daddr);
            neigh = __ipv4_neigh_lookup_noref(dev, nexthop);
            if (unlikely(!neigh))
                    neigh = __neigh_create(&arp_tbl, &nexthop, dev, false);
    
    To allow the nexthop to be an IPv6 address we need to consider the
    family of the nexthop and then call __ipv{4,6}_neigh_lookup_noref based
    on it.
    
    To make this simpler, add a ip_neigh_gw4 helper similar to ip_neigh_gw6
    added in an earlier patch which handles:
    
            neigh = __ipv4_neigh_lookup_noref(dev, nexthop);
            if (unlikely(!neigh))
                    neigh = __neigh_create(&arp_tbl, &nexthop, dev, false);
    
    And then add a second one, ip_neigh_for_gw, that calls either
    ip_neigh_gw4 or ip_neigh_gw6 based on the address family of the gateway.
    
    Update the output paths in the VRF driver and core v4 code to use
    ip_neigh_for_gw simplifying the family based lookup and making both
    ready for a v6 nexthop.
    
    ipv4_neigh_lookup has a different need - the potential to resolve a
    passed in address in addition to any gateway in the rtable or skb. Since
    this is a one-off, add ip_neigh_gw4 and ip_neigh_gw6 diectly. The
    difference between __neigh_create used by the helpers and neigh_create
    called by ipv4_neigh_lookup is taking a refcount, so add rcu_read_lock_bh
    and bump the refcnt on the neigh entry.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5d28a2509b58..96f6c9ae33c2 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -29,6 +29,8 @@
 #include <net/flow.h>
 #include <net/inet_sock.h>
 #include <net/ip_fib.h>
+#include <net/arp.h>
+#include <net/ndisc.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/rcupdate.h>
@@ -350,4 +352,34 @@ static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
 	return hoplimit;
 }
 
+static inline struct neighbour *ip_neigh_gw4(struct net_device *dev,
+					     __be32 daddr)
+{
+	struct neighbour *neigh;
+
+	neigh = __ipv4_neigh_lookup_noref(dev, daddr);
+	if (unlikely(!neigh))
+		neigh = __neigh_create(&arp_tbl, &daddr, dev, false);
+
+	return neigh;
+}
+
+static inline struct neighbour *ip_neigh_for_gw(struct rtable *rt,
+						struct sk_buff *skb,
+						bool *is_v6gw)
+{
+	struct net_device *dev = rt->dst.dev;
+	struct neighbour *neigh;
+
+	if (likely(rt->rt_gw_family == AF_INET)) {
+		neigh = ip_neigh_gw4(dev, rt->rt_gw4);
+	} else if (rt->rt_gw_family == AF_INET6) {
+		neigh = ip_neigh_gw6(dev, &rt->rt_gw6);
+		*is_v6gw = true;
+	} else {
+		neigh = ip_neigh_gw4(dev, ip_hdr(skb)->daddr);
+	}
+	return neigh;
+}
+
 #endif	/* _ROUTE_H */

commit 0f5f7d7bf6e6bda4dffe7b42812a16ada6ea9816
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Apr 5 16:30:29 2019 -0700

    ipv4: Add support to rtable for ipv6 gateway
    
    Add support for an IPv6 gateway to rtable. Since a gateway is either
    IPv4 or IPv6, make it a union with rt_gw4 where rt_gw_family decides
    which address is in use.
    
    When dumping the route data, encode an ipv6 nexthop using RTA_VIA.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 96912b099c08..5d28a2509b58 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -60,7 +60,10 @@ struct rtable {
 	int			rt_iif;
 
 	/* Info on neighbour */
-	__be32			rt_gw4;
+	union {
+		__be32		rt_gw4;
+		struct in6_addr	rt_gw6;
+	};
 
 	/* Miscellaneous cached information */
 	u32			rt_mtu_locked:1,

commit 1550c171935d264f522581fd037db5e64a716bb6
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Apr 5 16:30:27 2019 -0700

    ipv4: Prepare rtable for IPv6 gateway
    
    To allow the gateway to be either an IPv4 or IPv6 address, remove
    rt_uses_gateway from rtable and replace with rt_gw_family. If
    rt_gw_family is set it implies rt_uses_gateway. Rename rt_gateway
    to rt_gw4 to represent the IPv4 version.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9883dc82f723..96912b099c08 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -55,12 +55,12 @@ struct rtable {
 	unsigned int		rt_flags;
 	__u16			rt_type;
 	__u8			rt_is_input;
-	__u8			rt_uses_gateway;
+	u8			rt_gw_family;
 
 	int			rt_iif;
 
 	/* Info on neighbour */
-	__be32			rt_gateway;
+	__be32			rt_gw4;
 
 	/* Miscellaneous cached information */
 	u32			rt_mtu_locked:1,
@@ -82,8 +82,8 @@ static inline bool rt_is_output_route(const struct rtable *rt)
 
 static inline __be32 rt_nexthop(const struct rtable *rt, __be32 daddr)
 {
-	if (rt->rt_gateway)
-		return rt->rt_gateway;
+	if (rt->rt_gw_family == AF_INET)
+		return rt->rt_gw4;
 	return daddr;
 }
 

commit 1042caa79e9351b81ed19dc8d2d7fd6ff51a4422
Author: Maciej Żenczykowski <maze@google.com>
Date:   Tue Sep 25 20:56:27 2018 -0700

    net-ipv4: remove 2 always zero parameters from ipv4_redirect()
    
    (the parameters in question are mark and flow_flags)
    
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 73c605bdd6d8..9883dc82f723 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -203,8 +203,7 @@ static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu, int oif,
 		      u8 protocol);
 void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
-void ipv4_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark,
-		   u8 protocol, int flow_flags);
+void ipv4_redirect(struct sk_buff *skb, struct net *net, int oif, u8 protocol);
 void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
 void ip_rt_send_redirect(struct sk_buff *skb);
 

commit d888f39666774c7debfa34e4e20ba33cf61a6d71
Author: Maciej Żenczykowski <maze@google.com>
Date:   Tue Sep 25 20:56:26 2018 -0700

    net-ipv4: remove 2 always zero parameters from ipv4_update_pmtu()
    
    (the parameters in question are mark and flow_flags)
    
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index bb53cdba38dc..73c605bdd6d8 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -201,7 +201,7 @@ static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 }
 
 void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu, int oif,
-		      u32 mark, u8 protocol, int flow_flags);
+		      u8 protocol);
 void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
 void ipv4_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark,
 		   u8 protocol, int flow_flags);

commit af4d768ad28cbf6542ba70dba10b49127b31b762
Author: David Ahern <dsahern@gmail.com>
Date:   Sun May 27 08:09:57 2018 -0700

    net/ipv4: Add support for specifying metric of connected routes
    
    Add support for IFA_RT_PRIORITY to ipv4 addresses.
    
    If the metric is changed on an existing address then the new route
    is inserted before removing the old one. Since the metric is one
    of the route keys, the prefix route can not be replaced.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index dbb032d5921b..bb53cdba38dc 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -225,6 +225,7 @@ struct rtable *rt_dst_alloc(struct net_device *dev,
 struct in_ifaddr;
 void fib_add_ifaddr(struct in_ifaddr *);
 void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
+void fib_modify_prefix_metric(struct in_ifaddr *ifa, u32 new_metric);
 
 void rt_add_uncached_list(struct rtable *rt);
 void rt_del_uncached_list(struct rtable *rt);

commit 03fe2debbb2771fb90881e4ce8109b09cf772a5c
Merge: 6686c459e144 f36b7534b833
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 23 11:24:57 2018 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Fun set of conflict resolutions here...
    
    For the mac80211 stuff, these were fortunately just parallel
    adds.  Trivially resolved.
    
    In drivers/net/phy/phy.c we had a bug fix in 'net' that moved the
    function phy_disable_interrupts() earlier in the file, whilst in
    'net-next' the phy_error() call from this function was removed.
    
    In net/ipv4/xfrm4_policy.c, David Ahern's changes to remove the
    'rt_table_id' member of rtable collided with a bug fix in 'net' that
    added a new struct member "rt_mtu_locked" which needs to be copied
    over here.
    
    The mlxsw driver conflict consisted of net-next separating
    the span code and definitions into separate files, whilst
    a 'net' bug fix made some changes to that moved code.
    
    The mlx5 infiniband conflict resolution was quite non-trivial,
    the RDMA tree's merge commit was used as a guide here, and
    here are their notes:
    
    ====================
    
        Due to bug fixes found by the syzkaller bot and taken into the for-rc
        branch after development for the 4.17 merge window had already started
        being taken into the for-next branch, there were fairly non-trivial
        merge issues that would need to be resolved between the for-rc branch
        and the for-next branch.  This merge resolves those conflicts and
        provides a unified base upon which ongoing development for 4.17 can
        be based.
    
        Conflicts:
                drivers/infiniband/hw/mlx5/main.c - Commit 42cea83f9524
                (IB/mlx5: Fix cleanup order on unload) added to for-rc and
                commit b5ca15ad7e61 (IB/mlx5: Add proper representors support)
                add as part of the devel cycle both needed to modify the
                init/de-init functions used by mlx5.  To support the new
                representors, the new functions added by the cleanup patch
                needed to be made non-static, and the init/de-init list
                added by the representors patch needed to be modified to
                match the init/de-init list changes made by the cleanup
                patch.
        Updates:
                drivers/infiniband/hw/mlx5/mlx5_ib.h - Update function
                prototypes added by representors patch to reflect new function
                names as changed by cleanup patch
                drivers/infiniband/hw/mlx5/ib_rep.c - Update init/de-init
                stage list to match new order from cleanup patch
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit d52e5a7e7ca49457dd31fc8b42fb7c0d58a31221
Author: Sabrina Dubroca <sd@queasysnail.net>
Date:   Wed Mar 14 10:21:14 2018 +0100

    ipv4: lock mtu in fnhe when received PMTU < net.ipv4.route.min_pmtu
    
    Prior to the rework of PMTU information storage in commit
    2c8cec5c10bc ("ipv4: Cache learned PMTU information in inetpeer."),
    when a PMTU event advertising a PMTU smaller than
    net.ipv4.route.min_pmtu was received, we would disable setting the DF
    flag on packets by locking the MTU metric, and set the PMTU to
    net.ipv4.route.min_pmtu.
    
    Since then, we don't disable DF, and set PMTU to
    net.ipv4.route.min_pmtu, so the intermediate router that has this link
    with a small MTU will have to drop the packets.
    
    This patch reestablishes pre-2.6.39 behavior by splitting
    rtable->rt_pmtu into a bitfield with rt_mtu_locked and rt_pmtu.
    rt_mtu_locked indicates that we shouldn't set the DF bit on that path,
    and is checked in ip_dont_fragment().
    
    One possible workaround is to set net.ipv4.route.min_pmtu to a value low
    enough to accommodate the lowest MTU encountered.
    
    Fixes: 2c8cec5c10bc ("ipv4: Cache learned PMTU information in inetpeer.")
    Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 40b870d58f38..20a92ca9e115 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -63,7 +63,8 @@ struct rtable {
 	__be32			rt_gateway;
 
 	/* Miscellaneous cached information */
-	u32			rt_pmtu;
+	u32			rt_mtu_locked:1,
+				rt_pmtu:31;
 
 	u32			rt_table_id;
 

commit 510c321b557121861601f9d259aadd65aa274f35
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Feb 14 19:06:02 2018 +0800

    xfrm: reuse uncached_list to track xdsts
    
    In early time, when freeing a xdst, it would be inserted into
    dst_garbage.list first. Then if it's refcnt was still held
    somewhere, later it would be put into dst_busy_list in
    dst_gc_task().
    
    When one dev was being unregistered, the dev of these dsts in
    dst_busy_list would be set with loopback_dev and put this dev.
    So that this dev's removal wouldn't get blocked, and avoid the
    kmsg warning:
    
      kernel:unregister_netdevice: waiting for veth0 to become \
      free. Usage count = 2
    
    However after Commit 52df157f17e5 ("xfrm: take refcnt of dst
    when creating struct xfrm_dst bundle"), the xdst will not be
    freed with dst gc, and this warning happens.
    
    To fix it, we need to find these xdsts that are still held by
    others when removing the dev, and free xdst's dev and set it
    with loopback_dev.
    
    But unfortunately after flow_cache for xfrm was deleted, no
    list tracks them anymore. So we need to save these xdsts
    somewhere to release the xdst's dev later.
    
    To make this easier, this patch is to reuse uncached_list to
    track xdsts, so that the dev refcnt can be released in the
    event NETDEV_UNREGISTER process of fib_netdev_notifier.
    
    Thanks to Florian, we could move forward this fix quickly.
    
    Fixes: 52df157f17e5 ("xfrm: take refcnt of dst when creating struct xfrm_dst bundle")
    Reported-by: Jianlin Shi <jishi@redhat.com>
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Tested-by: Eyal Birger <eyal.birger@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/route.h b/include/net/route.h
index 1eb9ce470e25..40b870d58f38 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -227,6 +227,9 @@ struct in_ifaddr;
 void fib_add_ifaddr(struct in_ifaddr *);
 void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
 
+void rt_add_uncached_list(struct rtable *rt);
+void rt_del_uncached_list(struct rtable *rt);
+
 static inline void ip_rt_put(struct rtable *rt)
 {
 	/* dst_release() accepts a NULL parameter.

commit 68e813aa43071377b698c662bc0214f2a833bcbb
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Feb 14 14:24:28 2018 -0800

    net/ipv4: Remove fib table id from rtable
    
    Remove rt_table_id from rtable. It was added for getroute to return the
    table id that was hit in the lookup. With the changes for fibmatch the
    table id can be extracted from the fib_info returned in the fib_result
    so it no longer needs to be in rtable directly.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 1eb9ce470e25..158833ea7988 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -65,8 +65,6 @@ struct rtable {
 	/* Miscellaneous cached information */
 	u32			rt_pmtu;
 
-	u32			rt_table_id;
-
 	struct list_head	rt_uncached;
 	struct uncached_list	*rt_uncached_list;
 };

commit ca25c30040f93c127ff1651aa636c0174f1e0cdb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 1 08:03:10 2017 -0400

    ip_rt_ioctl(): take copyin to caller
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/net/route.h b/include/net/route.h
index d538e6db1afe..1eb9ce470e25 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -217,7 +217,7 @@ unsigned int inet_addr_type_dev_table(struct net *net,
 				      const struct net_device *dev,
 				      __be32 addr);
 void ip_rt_multicast_event(struct in_device *);
-int ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
+int ip_rt_ioctl(struct net *, unsigned int cmd, struct rtentry *rt);
 void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
 struct rtable *rt_dst_alloc(struct net_device *dev,
 			     unsigned int flags, u16 type,

commit bc044e8db7962e727a75b591b9851ff2ac5cf846
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Thu Sep 28 15:51:37 2017 +0200

    udp: perform source validation for mcast early demux
    
    The UDP early demux can leverate the rx dst cache even for
    multicast unconnected sockets.
    
    In such scenario the ipv4 source address is validated only on
    the first packet in the given flow. After that, when we fetch
    the dst entry  from the socket rx cache, we stop enforcing
    the rp_filter and we even start accepting any kind of martian
    addresses.
    
    Disabling the dst cache for unconnected multicast socket will
    cause large performace regression, nearly reducing by half the
    max ingress tput.
    
    Instead we factor out a route helper to completely validate an
    skb source address for multicast packets and we call it from
    the UDP early demux for mcast packets landing on unconnected
    sockets, after successful fetching the related cached dst entry.
    
    This still gives a measurable, but limited performance
    regression:
    
                    rp_filter = 0           rp_filter = 1
    edmux disabled: 1182 Kpps               1127 Kpps
    edmux before:   2238 Kpps               2238 Kpps
    edmux after:    2037 Kpps               2019 Kpps
    
    The above figures are on top of current net tree.
    Applying the net-next commit 6e617de84e87 ("net: avoid a full
    fib lookup when rp_filter is disabled.") the delta with
    rp_filter == 0 will decrease even more.
    
    Fixes: 421b3885bf6d ("udp: ipv4: Add udp early demux")
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 57dfc6850d37..d538e6db1afe 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -175,7 +175,9 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 	fl4->fl4_gre_key = gre_key;
 	return ip_route_output_key(net, fl4);
 }
-
+int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+			  u8 tos, struct net_device *dev,
+			  struct in_device *in_dev, u32 *itag);
 int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
 			 u8 tos, struct net_device *devin);
 int ip_route_input_rcu(struct sk_buff *skb, __be32 dst, __be32 src,

commit 222d7dbd258dad4cd5241c43ef818141fad5a87a
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Sep 21 09:15:46 2017 -0700

    net: prevent dst uses after free
    
    In linux-4.13, Wei worked hard to convert dst to a traditional
    refcounted model, removing GC.
    
    We now want to make sure a dst refcount can not transition from 0 back
    to 1.
    
    The problem here is that input path attached a not refcounted dst to an
    skb. Then later, because packet is forwarded and hits skb_dst_force()
    before exiting RCU section, we might try to take a refcount on one dst
    that is about to be freed, if another cpu saw 1 -> 0 transition in
    dst_release() and queued the dst for freeing after one RCU grace period.
    
    Lets unify skb_dst_force() and skb_dst_force_safe(), since we should
    always perform the complete check against dst refcount, and not assume
    it is not zero.
    
    Bugzilla : https://bugzilla.kernel.org/show_bug.cgi?id=197005
    
    [  989.919496]  skb_dst_force+0x32/0x34
    [  989.919498]  __dev_queue_xmit+0x1ad/0x482
    [  989.919501]  ? eth_header+0x28/0xc6
    [  989.919502]  dev_queue_xmit+0xb/0xd
    [  989.919504]  neigh_connected_output+0x9b/0xb4
    [  989.919507]  ip_finish_output2+0x234/0x294
    [  989.919509]  ? ipt_do_table+0x369/0x388
    [  989.919510]  ip_finish_output+0x12c/0x13f
    [  989.919512]  ip_output+0x53/0x87
    [  989.919513]  ip_forward_finish+0x53/0x5a
    [  989.919515]  ip_forward+0x2cb/0x3e6
    [  989.919516]  ? pskb_trim_rcsum.part.9+0x4b/0x4b
    [  989.919518]  ip_rcv_finish+0x2e2/0x321
    [  989.919519]  ip_rcv+0x26f/0x2eb
    [  989.919522]  ? vlan_do_receive+0x4f/0x289
    [  989.919523]  __netif_receive_skb_core+0x467/0x50b
    [  989.919526]  ? tcp_gro_receive+0x239/0x239
    [  989.919529]  ? inet_gro_receive+0x226/0x238
    [  989.919530]  __netif_receive_skb+0x4d/0x5f
    [  989.919532]  netif_receive_skb_internal+0x5c/0xaf
    [  989.919533]  napi_gro_receive+0x45/0x81
    [  989.919536]  ixgbe_poll+0xc8a/0xf09
    [  989.919539]  ? kmem_cache_free_bulk+0x1b6/0x1f7
    [  989.919540]  net_rx_action+0xf4/0x266
    [  989.919543]  __do_softirq+0xa8/0x19d
    [  989.919545]  irq_exit+0x5d/0x6b
    [  989.919546]  do_IRQ+0x9c/0xb5
    [  989.919548]  common_interrupt+0x93/0x93
    [  989.919548]  </IRQ>
    
    Similarly dst_clone() can use dst_hold() helper to have additional
    debugging, as a follow up to commit 44ebe79149ff ("net: add debug
    atomic_inc_not_zero() in dst_hold()")
    
    In net-next we will convert dst atomic_t to refcount_t for peace of
    mind.
    
    Fixes: a4c2fd7f7891 ("net: remove DST_NOCACHE flag")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Wei Wang <weiwan@google.com>
    Reported-by: Paweł Staszewski <pstaszewski@itcare.pl>
    Bisected-by: Paweł Staszewski <pstaszewski@itcare.pl>
    Acked-by: Wei Wang <weiwan@google.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 1b09a9368c68..57dfc6850d37 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -190,7 +190,7 @@ static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 	rcu_read_lock();
 	err = ip_route_input_noref(skb, dst, src, tos, devin);
 	if (!err) {
-		skb_dst_force_safe(skb);
+		skb_dst_force(skb);
 		if (!skb_dst(skb))
 			err = -EINVAL;
 	}

commit 64327fc811268d4a24de03dac242ea29de6be75f
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Thu Aug 31 18:11:41 2017 +0200

    ipv4: Don't override return code from ip_route_input_noref()
    
    After ip_route_input() calls ip_route_input_noref(), another
    check on skb_dst() is done, but if this fails, we shouldn't
    override the return code from ip_route_input_noref(), as it
    could have been more specific (i.e. -EHOSTUNREACH).
    
    This also saves one call to skb_dst_force_safe() and one to
    skb_dst() in case the ip_route_input_noref() check fails.
    
    Reported-by: Sabrina Dubroca <sdubroca@redhat.com>
    Fixes: 9df16efadd2a ("ipv4: call dst_hold_safe() properly")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Acked-by: Wei Wang <weiwan@google.com>
    Acked-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index cb0a76d9dde1..1b09a9368c68 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -189,10 +189,11 @@ static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 
 	rcu_read_lock();
 	err = ip_route_input_noref(skb, dst, src, tos, devin);
-	if (!err)
+	if (!err) {
 		skb_dst_force_safe(skb);
-	if (!skb_dst(skb))
-		err = -EINVAL;
+		if (!skb_dst(skb))
+			err = -EINVAL;
+	}
 	rcu_read_unlock();
 
 	return err;

commit 9df16efadd2a8a82731dc76ff656c771e261827f
Author: Wei Wang <weiwan@google.com>
Date:   Sat Jun 17 10:42:31 2017 -0700

    ipv4: call dst_hold_safe() properly
    
    This patch checks all the calls to
    dst_hold()/skb_dst_force()/dst_clone()/dst_use() to see if
    dst_hold_safe() is needed to avoid double free issue if dst
    gc is removed and dst_release() directly destroys dst when
    dst->__refcnt drops to 0.
    
    In tx path, TCP hold sk->sk_rx_dst ref count and also hold sock_lock().
    UDP and other similar protocols always hold refcount for
    skb->_skb_refdst. So both paths seem to be safe.
    
    In rx path, as it is lockless and skb_dst_set_noref() is likely to be
    used, dst_hold_safe() should always be used when trying to hold dst.
    
    In the routing code, if dst is held during an rcu protected session, it
    is necessary to call dst_hold_safe() as the current dst might be in its
    rcu grace period.
    
    Signed-off-by: Wei Wang <weiwan@google.com>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 08e689f23365..cb0a76d9dde1 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -190,7 +190,9 @@ static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 	rcu_read_lock();
 	err = ip_route_input_noref(skb, dst, src, tos, devin);
 	if (!err)
-		skb_dst_force(skb);
+		skb_dst_force_safe(skb);
+	if (!skb_dst(skb))
+		err = -EINVAL;
 	rcu_read_unlock();
 
 	return err;

commit 5510cdf7be042a1943222e19912f13a396c0b914
Author: David Ahern <dsahern@gmail.com>
Date:   Thu May 25 10:42:34 2017 -0700

    net: ipv4: refactor ip_route_input_noref
    
    A later patch wants access to the fib result on an input route lookup
    with the rcu lock held. Refactor ip_route_input_noref pushing the logic
    between rcu_read_lock ... rcu_read_unlock into a new helper that takes
    the fib_result as an input arg.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 89e4028cd063..08e689f23365 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -178,6 +178,9 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 
 int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
 			 u8 tos, struct net_device *devin);
+int ip_route_input_rcu(struct sk_buff *skb, __be32 dst, __be32 src,
+		       u8 tos, struct net_device *devin,
+		       struct fib_result *res);
 
 static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin)

commit 3abd1ade6765e8edcccad6a9e1039cc709e65dde
Author: David Ahern <dsahern@gmail.com>
Date:   Thu May 25 10:42:33 2017 -0700

    net: ipv4: refactor __ip_route_output_key_hash
    
    A later patch wants access to the fib result on an output route lookup
    with the rcu lock held. Refactor __ip_route_output_key_hash, pushing
    the logic between rcu_read_lock ... rcu_read_unlock into a new helper
    with the fib_result as an input arg.
    
    To keep the name length under control remove the leading underscores
    from the name and add _rcu to the name of the new helper indicating it
    is called with the rcu read lock held.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 2cc0e14c6359..89e4028cd063 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -113,13 +113,16 @@ struct in_device;
 int ip_rt_init(void);
 void rt_cache_flush(struct net *net);
 void rt_flush_dev(struct net_device *dev);
-struct rtable *__ip_route_output_key_hash(struct net *net, struct flowi4 *flp,
-					  const struct sk_buff *skb);
+struct rtable *ip_route_output_key_hash(struct net *net, struct flowi4 *flp,
+					const struct sk_buff *skb);
+struct rtable *ip_route_output_key_hash_rcu(struct net *net, struct flowi4 *flp,
+					    struct fib_result *res,
+					    const struct sk_buff *skb);
 
 static inline struct rtable *__ip_route_output_key(struct net *net,
 						   struct flowi4 *flp)
 {
-	return __ip_route_output_key_hash(net, flp, NULL);
+	return ip_route_output_key_hash(net, flp, NULL);
 }
 
 struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,

commit bf4e0a3db97eb882368fd82980b3b1fa0b5b9778
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Mar 16 15:28:00 2017 +0200

    net: ipv4: add support for ECMP hash policy choice
    
    This patch adds support for ECMP hash policy choice via a new sysctl
    called fib_multipath_hash_policy and also adds support for L4 hashes.
    The current values for fib_multipath_hash_policy are:
     0 - layer 3 (default)
     1 - layer 4
    If there's an skb hash already set and it matches the chosen policy then it
    will be used instead of being calculated (currently only for L4).
    In L3 mode we always calculate the hash due to the ICMP error special
    case, the flow dissector's field consistentification should handle the
    address order thus we can remove the address reversals.
    If the skb is provided we always use it for the hash calculation,
    otherwise we fallback to fl4, that is if skb is NULL fl4 has to be set.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index c0874c87c173..2cc0e14c6359 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -113,13 +113,13 @@ struct in_device;
 int ip_rt_init(void);
 void rt_cache_flush(struct net *net);
 void rt_flush_dev(struct net_device *dev);
-struct rtable *__ip_route_output_key_hash(struct net *, struct flowi4 *flp,
-					  int mp_hash);
+struct rtable *__ip_route_output_key_hash(struct net *net, struct flowi4 *flp,
+					  const struct sk_buff *skb);
 
 static inline struct rtable *__ip_route_output_key(struct net *net,
 						   struct flowi4 *flp)
 {
-	return __ip_route_output_key_hash(net, flp, -1);
+	return __ip_route_output_key_hash(net, flp, NULL);
 }
 
 struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,

commit e2d118a1cb5e60d077131a09db1d81b90a5295fe
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Fri Nov 4 02:23:43 2016 +0900

    net: inet: Support UID-based routing in IP protocols.
    
    - Use the UID in routing lookups made by protocol connect() and
      sendmsg() functions.
    - Make sure that routing lookups triggered by incoming packets
      (e.g., Path MTU discovery) take the UID of the socket into
      account.
    - For packets not associated with a userspace socket, (e.g., ping
      replies) use UID 0 inside the user namespace corresponding to
      the network namespace the socket belongs to. This allows
      all namespaces to apply routing and iptables rules to
      kernel-originated traffic in that namespaces by matching UID 0.
      This is better than using the UID of the kernel socket that is
      sending the traffic, because the UID of kernel sockets created
      at namespace creation time (e.g., the per-processor ICMP and
      TCP sockets) is the UID of the user that created the socket,
      which might not be mapped in the namespace.
    
    Tested: compiles allnoconfig, allyesconfig, allmodconfig
    Tested: https://android-review.googlesource.com/253302
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 0429d47cad25..c0874c87c173 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -153,7 +153,7 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct flowi
 	flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, tos,
 			   RT_SCOPE_UNIVERSE, proto,
 			   sk ? inet_sk_flowi_flags(sk) : 0,
-			   daddr, saddr, dport, sport);
+			   daddr, saddr, dport, sport, sock_net_uid(net, sk));
 	if (sk)
 		security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
 	return ip_route_output_flow(net, fl4, sk);
@@ -269,7 +269,8 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
-			   protocol, flow_flags, dst, src, dport, sport);
+			   protocol, flow_flags, dst, src, dport, sport,
+			   sk->sk_uid);
 }
 
 static inline struct rtable *ip_route_connect(struct flowi4 *fl4,

commit d66f6c0a8f3c0bcc4ee7a9b1da4b0ebe7ee555a3
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Sat Sep 10 12:09:58 2016 -0700

    net: ipv4: Remove l3mdev_get_saddr
    
    No longer needed
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index ad777d79af94..0429d47cad25 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -29,7 +29,6 @@
 #include <net/flow.h>
 #include <net/inet_sock.h>
 #include <net/ip_fib.h>
-#include <net/l3mdev.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/rcupdate.h>
@@ -285,15 +284,6 @@ static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
 	ip_route_connect_init(fl4, dst, src, tos, oif, protocol,
 			      sport, dport, sk);
 
-	if (!src && oif) {
-		int rc;
-
-		rc = l3mdev_get_saddr(net, oif, fl4);
-		if (rc < 0)
-			return ERR_PTR(rc);
-
-		src = fl4->saddr;
-	}
 	if (!dst || !src) {
 		rt = __ip_route_output_key(net, fl4);
 		if (IS_ERR(rt))

commit 1602f49b58abcb0d34a5f0a29d68e7c1769547aa
Merge: 22d37b6b0058 5f44abd041c5
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Apr 23 18:26:24 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts were two cases of simple overlapping changes,
    nothing serious.
    
    In the UDP case, we need to add a hlist_add_tail_rcu()
    to linux/rculist.h, because we've moved UDP socket handling
    away from using nulls lists.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9ab179d83b4e31ea277a123492e419067c2f129a
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Thu Apr 7 11:10:06 2016 -0700

    net: vrf: Fix dst reference counting
    
    Vivek reported a kernel exception deleting a VRF with an active
    connection through it. The root cause is that the socket has a cached
    reference to a dst that is destroyed. Converting the dst_destroy to
    dst_release and letting proper reference counting kick in does not
    work as the dst has a reference to the device which needs to be released
    as well.
    
    I talked to Hannes about this at netdev and he pointed out the ipv4 and
    ipv6 dst handling has dst_ifdown for just this scenario. Rather than
    continuing with the reinvented dst wheel in VRF just remove it and
    leverage the ipv4 and ipv6 versions.
    
    Fixes: 193125dbd8eb2 ("net: Introduce VRF device driver")
    Fixes: 35402e3136634 ("net: Add IPv6 support to VRF device")
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9b0a523bb428..6de665bf1750 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -209,6 +209,9 @@ unsigned int inet_addr_type_dev_table(struct net *net,
 void ip_rt_multicast_event(struct in_device *);
 int ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
 void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
+struct rtable *rt_dst_alloc(struct net_device *dev,
+			     unsigned int flags, u16 type,
+			     bool nopolicy, bool noxfrm, bool will_cache);
 
 struct in_ifaddr;
 void fib_add_ifaddr(struct in_ifaddr *);

commit 0340d0b9e0e2dc340acb664f19d6550940b22cde
Author: Tom Herbert <tom@herbertland.com>
Date:   Tue Apr 5 08:22:49 2016 -0700

    net: Checks skb_dst to be NULL in inet_iif
    
    In inet_iif check if skb_rtable is NULL for the skb and return
    skb->skb_iif if it is.
    
    This change allows inet_iif to be called before the dst
    information has been set in the skb (e.g. when doing socket based
    UDP GRO).
    
    Signed-off-by: Tom Herbert <tom@herbertland.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9b0a523bb428..f4b11eee1754 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -322,10 +322,11 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 
 static inline int inet_iif(const struct sk_buff *skb)
 {
-	int iif = skb_rtable(skb)->rt_iif;
+	struct rtable *rt = skb_rtable(skb);
+
+	if (rt && rt->rt_iif)
+		return rt->rt_iif;
 
-	if (iif)
-		return iif;
 	return skb->skb_iif;
 }
 

commit fa50d974d104113630d68b7d03233a6686230d0c
Author: Nikolay Borisov <kernel@kyup.com>
Date:   Mon Feb 15 12:11:27 2016 +0200

    ipv4: Namespaceify ip_default_ttl sysctl knob
    
    Signed-off-by: Nikolay Borisov <kernel@kyup.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index a3b9ef74a389..9b0a523bb428 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -329,14 +329,13 @@ static inline int inet_iif(const struct sk_buff *skb)
 	return skb->skb_iif;
 }
 
-extern int sysctl_ip_default_ttl;
-
 static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
 {
 	int hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);
+	struct net *net = dev_net(dst->dev);
 
 	if (hoplimit == 0)
-		hoplimit = sysctl_ip_default_ttl;
+		hoplimit = net->ipv4.sysctl_ip_default_ttl;
 	return hoplimit;
 }
 

commit b5bdacf3bb027ba0af4d61b38ec289bfc8b64372
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Mon Jan 4 09:09:27 2016 -0800

    net: Propagate lookup failure in l3mdev_get_saddr to caller
    
    Commands run in a vrf context are not failing as expected on a route lookup:
        root@kenny:~# ip ro ls table vrf-red
        unreachable default
    
        root@kenny:~# ping -I vrf-red -c1 -w1 10.100.1.254
        ping: Warning: source address might be selected on device other than vrf-red.
        PING 10.100.1.254 (10.100.1.254) from 0.0.0.0 vrf-red: 56(84) bytes of data.
    
        --- 10.100.1.254 ping statistics ---
        2 packets transmitted, 0 received, 100% packet loss, time 999ms
    
    Since the vrf table does not have a route for 10.100.1.254 the ping
    should have failed. The saddr lookup causes a full VRF table lookup.
    Propogating a lookup failure to the user allows the command to fail as
    expected:
    
        root@kenny:~# ping -I vrf-red -c1 -w1 10.100.1.254
        connect: No route to host
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index ee81307863d5..a3b9ef74a389 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -283,7 +283,12 @@ static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
 			      sport, dport, sk);
 
 	if (!src && oif) {
-		l3mdev_get_saddr(net, oif, fl4);
+		int rc;
+
+		rc = l3mdev_get_saddr(net, oif, fl4);
+		if (rc < 0)
+			return ERR_PTR(rc);
+
 		src = fl4->saddr;
 	}
 	if (!dst || !src) {

commit 8cbb512c923d5f695ff6265b2b741b1718e3b444
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Mon Oct 5 08:51:26 2015 -0700

    net: Add source address lookup op for VRF
    
    Add operation to l3mdev to lookup source address for a given flow.
    Add support for the operation to VRF driver and convert existing
    IPv4 hooks to use the new lookup.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 3e18d90b3f4e..ee81307863d5 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -266,9 +266,6 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
-	if (netif_index_is_l3_master(sock_net(sk), oif))
-		flow_flags |= FLOWI_FLAG_L3MDEV_SRC | FLOWI_FLAG_SKIP_NH_OIF;
-
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);
 }
@@ -285,6 +282,10 @@ static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
 	ip_route_connect_init(fl4, dst, src, tos, oif, protocol,
 			      sport, dport, sk);
 
+	if (!src && oif) {
+		l3mdev_get_saddr(net, oif, fl4);
+		src = fl4->saddr;
+	}
 	if (!dst || !src) {
 		rt = __ip_route_output_key(net, fl4);
 		if (IS_ERR(rt))

commit 6e2895a8e3824eb5611c97a015a3b6d678b4503e
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Mon Oct 5 08:51:23 2015 -0700

    net: Rename FLOWI_FLAG_VRFSRC to FLOWI_FLAG_L3MDEV_SRC
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index d32cb76f5302..3e18d90b3f4e 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -267,7 +267,7 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
 	if (netif_index_is_l3_master(sock_net(sk), oif))
-		flow_flags |= FLOWI_FLAG_VRFSRC | FLOWI_FLAG_SKIP_NH_OIF;
+		flow_flags |= FLOWI_FLAG_L3MDEV_SRC | FLOWI_FLAG_SKIP_NH_OIF;
 
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);

commit 79a131592dbb81a2dba208622a2ffbfc53f28bc0
Author: Peter Nørlund <pch@ordbogen.com>
Date:   Wed Sep 30 10:12:22 2015 +0200

    ipv4: ICMP packet inspection for multipath
    
    ICMP packets are inspected to let them route together with the flow they
    belong to, minimizing the chance that a problematic path will affect flows
    on other paths, and so that anycast environments can work with ECMP.
    
    Signed-off-by: Peter Nørlund <pch@ordbogen.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index e211dc167db1..d32cb76f5302 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -28,6 +28,7 @@
 #include <net/inetpeer.h>
 #include <net/flow.h>
 #include <net/inet_sock.h>
+#include <net/ip_fib.h>
 #include <net/l3mdev.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
@@ -113,7 +114,15 @@ struct in_device;
 int ip_rt_init(void);
 void rt_cache_flush(struct net *net);
 void rt_flush_dev(struct net_device *dev);
-struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
+struct rtable *__ip_route_output_key_hash(struct net *, struct flowi4 *flp,
+					  int mp_hash);
+
+static inline struct rtable *__ip_route_output_key(struct net *net,
+						   struct flowi4 *flp)
+{
+	return __ip_route_output_key_hash(net, flp, -1);
+}
+
 struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
 				    const struct sock *sk);
 struct dst_entry *ipv4_blackhole_route(struct net *net,

commit 9478d12d33ad12d29c5343ae7346b51bc1f4c5a9
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Sep 29 20:07:18 2015 -0700

    net: Move netif_index_is_l3_master to l3mdev.h
    
    Change CONFIG dependency to CONFIG_NET_L3_MASTER_DEV as well.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index a565d0dad12c..e211dc167db1 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -28,6 +28,7 @@
 #include <net/inetpeer.h>
 #include <net/flow.h>
 #include <net/inet_sock.h>
+#include <net/l3mdev.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/rcupdate.h>

commit 007979eaf94d1c888d8c7cf8a5250c2c6c9bd98e
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Sep 29 20:07:10 2015 -0700

    net: Rename IFF_VRF_MASTER to IFF_L3MDEV_MASTER
    
    Rename IFF_VRF_MASTER to IFF_L3MDEV_MASTER and update the name of the
    netif_is_vrf and netif_index_is_vrf macros.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index d1bd90bb3187..a565d0dad12c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -256,7 +256,7 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
-	if (netif_index_is_vrf(sock_net(sk), oif))
+	if (netif_index_is_l3_master(sock_net(sk), oif))
 		flow_flags |= FLOWI_FLAG_VRFSRC | FLOWI_FLAG_SKIP_NH_OIF;
 
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,

commit 4963ed48f2c20196d51a447ee87dc2815584fee4
Merge: 4d54d86546f6 518a7cb6980c
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Sep 26 16:08:27 2015 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            net/ipv4/arp.c
    
    The net/ipv4/arp.c conflict was one commit adding a new
    local variable while another commit was deleting one.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6f9c961546699ff8bc5e1c1c52200616867ec68a
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 07:39:10 2015 -0700

    inet: constify ip_route_output_flow() socket argument
    
    Very soon, TCP stack might call inet_csk_route_req(), which
    calls inet_csk_route_req() with an unlocked listener socket,
    so we need to make sure ip_route_output_flow() is not trying to
    change any field from its socket argument.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 10a7d21a211c..414beadc619f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -114,7 +114,7 @@ void rt_cache_flush(struct net *net);
 void rt_flush_dev(struct net_device *dev);
 struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
 struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
-				    struct sock *sk);
+				    const struct sock *sk);
 struct dst_entry *ipv4_blackhole_route(struct net *net,
 				       struct dst_entry *dst_orig);
 

commit 58189ca7b27411c3dc9a5cb9eeee0906da684c59
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Sep 15 15:10:50 2015 -0700

    net: Fix vti use case with oif in dst lookups
    
    Steffen reported that the recent change to add oif to dst lookups breaks
    the VTI use case. The problem is that with the oif set in the flow struct
    the comparison to the nh_oif is triggered. Fix by splitting the
    FLOWI_FLAG_VRFSRC into 2 flags -- one that triggers the vrf device cache
    bypass (FLOWI_FLAG_VRFSRC) and another telling the lookup to not compare
    nh oif (FLOWI_FLAG_SKIP_NH_OIF).
    
    Fixes: 42a7b32b73d6 ("xfrm: Add oif to dst lookups")
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Acked-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index cc61cb95f059..f46af256880c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -255,7 +255,7 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
 	if (netif_index_is_vrf(sock_net(sk), oif))
-		flow_flags |= FLOWI_FLAG_VRFSRC;
+		flow_flags |= FLOWI_FLAG_VRFSRC | FLOWI_FLAG_SKIP_NH_OIF;
 
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);

commit b7503e0cdb5dbec5d201aa69d8888c14679b5ae8
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Wed Sep 2 13:58:35 2015 -0700

    net: Add FIB table id to rtable
    
    Add the FIB table id to rtable to make the information available for
    IPv4 as it is for IPv6.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index cc61cb95f059..10a7d21a211c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -64,6 +64,8 @@ struct rtable {
 	/* Miscellaneous cached information */
 	u32			rt_pmtu;
 
+	u32			rt_table_id;
+
 	struct list_head	rt_uncached;
 	struct uncached_list	*rt_uncached_list;
 };

commit 9b8ff51822893e743eee09350c1928daa3ef503f
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Sep 1 14:26:35 2015 -0600

    net: Make table id type u32
    
    A number of VRF patches used 'int' for table id. It should be u32 to be
    consistent with the rest of the stack.
    
    Fixes:
    4e3c89920cd3a ("net: Introduce VRF related flags and helpers")
    15be405eb2ea9 ("net: Add inet_addr lookup by table")
    30bbaa1950055 ("net: Fix up inet_addr_type checks")
    021dd3b8a142d ("net: Add routes to the table associated with the device")
    dc028da54ed35 ("inet: Move VRF table lookup to inlined function")
    f6d3c19274c74 ("net: FIB tracepoints")
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 395d79bb556c..cc61cb95f059 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -188,7 +188,7 @@ void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
 void ip_rt_send_redirect(struct sk_buff *skb);
 
 unsigned int inet_addr_type(struct net *net, __be32 addr);
-unsigned int inet_addr_type_table(struct net *net, __be32 addr, int tb_id);
+unsigned int inet_addr_type_table(struct net *net, __be32 addr, u32 tb_id);
 unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
 				__be32 addr);
 unsigned int inet_addr_type_dev_table(struct net *net,

commit 61adedf3e3f1d3f032c5a6a299978d91eff6d555
Author: Jiri Benc <jbenc@redhat.com>
Date:   Thu Aug 20 13:56:25 2015 +0200

    route: move lwtunnel state to dst_entry
    
    Currently, the lwtunnel state resides in per-protocol data. This is
    a problem if we encapsulate ipv6 traffic in an ipv4 tunnel (or vice versa).
    The xmit function of the tunnel does not know whether the packet has been
    routed to it by ipv4 or ipv6, yet it needs the lwtstate data. Moving the
    lwtstate data to dst_entry makes such inter-protocol tunneling possible.
    
    As a bonus, this brings a nice diffstat.
    
    Signed-off-by: Jiri Benc <jbenc@redhat.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6dda2c1bf8c6..395d79bb556c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -66,7 +66,6 @@ struct rtable {
 
 	struct list_head	rt_uncached;
 	struct uncached_list	*rt_uncached_list;
-	struct lwtunnel_state   *rt_lwtstate;
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)

commit 30bbaa19500559d7625c65632195413f639b3b97
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Thu Aug 13 14:59:05 2015 -0600

    net: Fix up inet_addr_type checks
    
    Currently inet_addr_type and inet_dev_addr_type expect local addresses
    to be in the local table. With the VRF device local routes for devices
    associated with a VRF will be in the table associated with the VRF.
    Provide an alternate inet_addr lookup to use a specific table rather
    than defaulting to the local table.
    
    inet_addr_type_dev_table keeps the same semantics as inet_addr_type but
    if the passed in device is enslaved to a VRF then the table for that VRF
    is used for the lookup.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6ba681f0b98d..6dda2c1bf8c6 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -192,6 +192,9 @@ unsigned int inet_addr_type(struct net *net, __be32 addr);
 unsigned int inet_addr_type_table(struct net *net, __be32 addr, int tb_id);
 unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
 				__be32 addr);
+unsigned int inet_addr_type_dev_table(struct net *net,
+				      const struct net_device *dev,
+				      __be32 addr);
 void ip_rt_multicast_event(struct in_device *);
 int ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
 void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);

commit 15be405eb2ea943ac5fa2aab7d0ba282e9ef1301
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Thu Aug 13 14:59:04 2015 -0600

    net: Add inet_addr lookup by table
    
    Currently inet_addr_type and inet_dev_addr_type expect local addresses
    to be in the local table. With the VRF device local routes for devices
    associated with a VRF will be in the table associated with the VRF.
    Provide an alternate inet_addr lookup to use a specific table rather
    than defaulting to the local table.
    
    Signed-off-by: Shrijeet Mukherjee <shm@cumulusnetworks.com>
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 94189d4bd899..6ba681f0b98d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -189,6 +189,7 @@ void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
 void ip_rt_send_redirect(struct sk_buff *skb);
 
 unsigned int inet_addr_type(struct net *net, __be32 addr);
+unsigned int inet_addr_type_table(struct net *net, __be32 addr, int tb_id);
 unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
 				__be32 addr);
 void ip_rt_multicast_event(struct in_device *);

commit 613d09b30f8b589d5a9b49775054c8865db95d1c
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Thu Aug 13 14:59:02 2015 -0600

    net: Use VRF device index for lookups on TX
    
    As with ingress use the index of VRF master device for route lookups on
    egress. However, the oif should only be used to direct the lookups to a
    specific table. Routes in the table are not based on the VRF device but
    rather interfaces that are part of the VRF so do not consider the oif for
    lookups within the table. The FLOWI_FLAG_VRFSRC is used to control this
    latter part.
    
    Signed-off-by: Shrijeet Mukherjee <shm@cumulusnetworks.com>
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 2d45f419477f..94189d4bd899 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -251,6 +251,9 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
+	if (netif_index_is_vrf(sock_net(sk), oif))
+		flow_flags |= FLOWI_FLAG_VRFSRC;
+
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);
 }

commit 571e722676fe386bb66f72a75b64a6ebf535c077
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Tue Jul 21 10:43:47 2015 +0200

    ipv4: support for fib route lwtunnel encap attributes
    
    This patch adds support in ipv4 fib functions to parse user
    provided encap attributes and attach encap state data to fib_nh
    and rtable.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index fe22d03afb6a..2d45f419477f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -66,6 +66,7 @@ struct rtable {
 
 	struct list_head	rt_uncached;
 	struct uncached_list	*rt_uncached_list;
+	struct lwtunnel_state   *rt_lwtstate;
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)

commit 5055c371bfd53fd369b895051b541318c2bad495
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Jan 14 15:17:06 2015 -0800

    ipv4: per cpu uncached list
    
    RAW sockets with hdrinc suffer from contention on rt_uncached_lock
    spinlock.
    
    One solution is to use percpu lists, since most routes are destroyed
    by the cpu that created them.
    
    It is unclear why we even have to put these routes in uncached_list,
    as all outgoing packets should be freed when a device is dismantled.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Fixes: caacf05e5ad1 ("ipv4: Properly purge netdev references on uncached routes.")
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b17cf28f996e..fe22d03afb6a 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -46,6 +46,7 @@
 
 struct fib_nh;
 struct fib_info;
+struct uncached_list;
 struct rtable {
 	struct dst_entry	dst;
 
@@ -64,6 +65,7 @@ struct rtable {
 	u32			rt_pmtu;
 
 	struct list_head	rt_uncached;
+	struct uncached_list	*rt_uncached_list;
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)

commit 0b8c7f6f2a26ed2dee24881299fc69f554596dbb
Author: Li RongQing <roy.qing.li@gmail.com>
Date:   Fri Mar 21 11:33:10 2014 +0800

    ipv4: remove ip_rt_dump from route.c
    
    ip_rt_dump do nothing after IPv4 route caches removal, so we can remove it.
    
    Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9d1f423d5944..b17cf28f996e 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -191,7 +191,6 @@ unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
 void ip_rt_multicast_event(struct in_device *);
 int ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
 void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
-int ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
 struct in_ifaddr;
 void fib_add_ifaddr(struct in_ifaddr *);

commit f87c10a8aa1e82498c42d0335524d6ae7cf5a52b
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Jan 9 10:01:15 2014 +0100

    ipv4: introduce ip_dst_mtu_maybe_forward and protect forwarding path against pmtu spoofing
    
    While forwarding we should not use the protocol path mtu to calculate
    the mtu for a forwarded packet but instead use the interface mtu.
    
    We mark forwarded skbs in ip_forward with IPSKB_FORWARDED, which was
    introduced for multicast forwarding. But as it does not conflict with
    our usage in unicast code path it is perfect for reuse.
    
    I moved the functions ip_sk_accept_pmtu, ip_sk_use_pmtu and ip_skb_dst_mtu
    along with the new ip_dst_mtu_maybe_forward to net/ip.h to fix circular
    dependencies because of IPSKB_FORWARDED.
    
    Because someone might have written a software which does probe
    destinations manually and expects the kernel to honour those path mtus
    I introduced a new per-namespace "ip_forward_use_pmtu" knob so someone
    can disable this new behaviour. We also still use mtus which are locked on a
    route for forwarding.
    
    The reason for this change is, that path mtus information can be injected
    into the kernel via e.g. icmp_err protocol handler without verification
    of local sockets. As such, this could cause the IPv4 forwarding path to
    wrongfully emit fragmentation needed notifications or start to fragment
    packets along a path.
    
    Tunnel and ipsec output paths clear IPCB again, thus IPSKB_FORWARDED
    won't be set and further fragmentation logic will use the path mtu to
    determine the fragmentation size. They also recheck packet size with
    help of path mtu discovery and report appropriate errors.
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: David Miller <davem@davemloft.net>
    Cc: John Heffner <johnwheffner@gmail.com>
    Cc: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 638e3ebf76f3..9d1f423d5944 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -36,6 +36,9 @@
 #include <linux/cache.h>
 #include <linux/security.h>
 
+/* IPv4 datagram length is stored into 16bit field (tot_len) */
+#define IP_MAX_MTU	0xFFFFU
+
 #define RTO_ONLINK	0x01
 
 #define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
@@ -311,20 +314,4 @@ static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
 	return hoplimit;
 }
 
-static inline bool ip_sk_accept_pmtu(const struct sock *sk)
-{
-	return inet_sk(sk)->pmtudisc != IP_PMTUDISC_INTERFACE;
-}
-
-static inline bool ip_sk_use_pmtu(const struct sock *sk)
-{
-	return inet_sk(sk)->pmtudisc < IP_PMTUDISC_PROBE;
-}
-
-static inline int ip_skb_dst_mtu(const struct sk_buff *skb)
-{
-	return (!skb->sk || ip_sk_use_pmtu(skb->sk)) ?
-	       dst_mtu(skb_dst(skb)) : skb_dst(skb)->dev->mtu;
-}
-
 #endif	/* _ROUTE_H */

commit 0e0d44ab4275549998567cd4700b43f7496eb62b
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Wed Aug 28 08:04:14 2013 +0200

    net: Remove FLOWI_FLAG_CAN_SLEEP
    
    FLOWI_FLAG_CAN_SLEEP was used to notify xfrm about the posibility
    to sleep until the needed states are resolved. This code is gone,
    so FLOWI_FLAG_CAN_SLEEP is not needed anymore.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/route.h b/include/net/route.h
index f68c167280a7..638e3ebf76f3 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -239,14 +239,12 @@ static inline char rt_tos2priority(u8 tos)
 static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32 src,
 					 u32 tos, int oif, u8 protocol,
 					 __be16 sport, __be16 dport,
-					 struct sock *sk, bool can_sleep)
+					 struct sock *sk)
 {
 	__u8 flow_flags = 0;
 
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
-	if (can_sleep)
-		flow_flags |= FLOWI_FLAG_CAN_SLEEP;
 
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);
@@ -256,13 +254,13 @@ static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
 					      __be32 dst, __be32 src, u32 tos,
 					      int oif, u8 protocol,
 					      __be16 sport, __be16 dport,
-					      struct sock *sk, bool can_sleep)
+					      struct sock *sk)
 {
 	struct net *net = sock_net(sk);
 	struct rtable *rt;
 
 	ip_route_connect_init(fl4, dst, src, tos, oif, protocol,
-			      sport, dport, sk, can_sleep);
+			      sport, dport, sk);
 
 	if (!dst || !src) {
 		rt = __ip_route_output_key(net, fl4);

commit 482fc6094afad572a4ea1fd722e7b11ca72022a0
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Tue Nov 5 02:24:17 2013 +0100

    ipv4: introduce new IP_MTU_DISCOVER mode IP_PMTUDISC_INTERFACE
    
    Sockets marked with IP_PMTUDISC_INTERFACE won't do path mtu discovery,
    their sockets won't accept and install new path mtu information and they
    will always use the interface mtu for outgoing packets. It is guaranteed
    that the packet is not fragmented locally. But we won't set the DF-Flag
    on the outgoing frames.
    
    Florian Weimer had the idea to use this flag to ensure DNS servers are
    never generating outgoing fragments. They may well be fragmented on the
    path, but the server never stores or usees path mtu values, which could
    well be forged in an attack.
    
    (The root of the problem with path MTU discovery is that there is
    no reliable way to authenticate ICMP Fragmentation Needed But DF Set
    messages because they are sent from intermediate routers with their
    source addresses, and the IMCP payload will not always contain sufficient
    information to identify a flow.)
    
    Recent research in the DNS community showed that it is possible to
    implement an attack where DNS cache poisoning is feasible by spoofing
    fragments. This work was done by Amir Herzberg and Haya Shulman:
    <https://sites.google.com/site/hayashulman/files/fragmentation-poisoning.pdf>
    
    This issue was previously discussed among the DNS community, e.g.
    <http://www.ietf.org/mail-archive/web/dnsext/current/msg01204.html>,
    without leading to fixes.
    
    This patch depends on the patch "ipv4: fix DO and PROBE pmtu mode
    regarding local fragmentation with UFO/CORK" for the enforcement of the
    non-fragmentable checks. If other users than ip_append_page/data should
    use this semantic too, we have to add a new flag to IPCB(skb)->flags to
    suppress local fragmentation and check for this in ip_finish_output.
    
    Many thanks to Florian Weimer for the idea and feedback while implementing
    this patch.
    
    Cc: David S. Miller <davem@davemloft.net>
    Suggested-by: Florian Weimer <fweimer@redhat.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index dd4ae0029fd8..f68c167280a7 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -313,12 +313,20 @@ static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
 	return hoplimit;
 }
 
-static inline int ip_skb_dst_mtu(struct sk_buff *skb)
+static inline bool ip_sk_accept_pmtu(const struct sock *sk)
 {
-	struct inet_sock *inet = skb->sk ? inet_sk(skb->sk) : NULL;
+	return inet_sk(sk)->pmtudisc != IP_PMTUDISC_INTERFACE;
+}
 
-	return (inet && inet->pmtudisc == IP_PMTUDISC_PROBE) ?
-	       skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
+static inline bool ip_sk_use_pmtu(const struct sock *sk)
+{
+	return inet_sk(sk)->pmtudisc < IP_PMTUDISC_PROBE;
+}
+
+static inline int ip_skb_dst_mtu(const struct sk_buff *skb)
+{
+	return (!skb->sk || ip_sk_use_pmtu(skb->sk)) ?
+	       dst_mtu(skb_dst(skb)) : skb_dst(skb)->dev->mtu;
 }
 
 #endif	/* _ROUTE_H */

commit 0baf2b35fc70ab16c385963d2502da26a55d2cb7
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Oct 16 02:49:04 2013 -0700

    ipv4: shrink rt_cache_stat
    
    Half of the rt_cache_stat fields are no longer used after IP
    route cache removal, lets shrink this per cpu area.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 0ad8e0102386..dd4ae0029fd8 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -88,22 +88,14 @@ struct ip_rt_acct {
 };
 
 struct rt_cache_stat {
-        unsigned int in_hit;
         unsigned int in_slow_tot;
         unsigned int in_slow_mc;
         unsigned int in_no_route;
         unsigned int in_brd;
         unsigned int in_martian_dst;
         unsigned int in_martian_src;
-        unsigned int out_hit;
         unsigned int out_slow_tot;
         unsigned int out_slow_mc;
-        unsigned int gc_total;
-        unsigned int gc_ignored;
-        unsigned int gc_goal_miss;
-        unsigned int gc_dst_overflow;
-        unsigned int in_hlist_search;
-        unsigned int out_hlist_search;
 };
 
 extern struct ip_rt_acct __percpu *ip_rt_acct;

commit aa6615814533c634190019ee3a5b10490026d545
Author: Francesco Fusco <ffusco@redhat.com>
Date:   Tue Sep 24 15:43:09 2013 +0200

    ipv4: processing ancillary IP_TOS or IP_TTL
    
    If IP_TOS or IP_TTL are specified as ancillary data, then sendmsg() sends out
    packets with the specified TTL or TOS overriding the socket values specified
    with the traditional setsockopt().
    
    The struct inet_cork stores the values of TOS, TTL and priority that are
    passed through the struct ipcm_cookie. If there are user-specified TOS
    (tos != -1) or TTL (ttl != 0) in the struct ipcm_cookie, these values are
    used to override the per-socket values. In case of TOS also the priority
    is changed accordingly.
    
    Two helper functions get_rttos and get_rtconn_flags are defined to take
    into account the presence of a user specified TOS value when computing
    RT_TOS and RT_CONN_FLAGS.
    
    Signed-off-by: Francesco Fusco <ffusco@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6f572ca66d25..0ad8e0102386 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -39,6 +39,7 @@
 #define RTO_ONLINK	0x01
 
 #define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
+#define RT_CONN_FLAGS_TOS(sk,tos)   (RT_TOS(tos) | sock_flag(sk, SOCK_LOCALROUTE))
 
 struct fib_nh;
 struct fib_info;

commit 2702c4bb89b2a9bfe49f3db77a1bac88d5c6404c
Author: Joe Perches <joe@perches.com>
Date:   Sun Sep 22 10:32:22 2013 -0700

    route.h: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index afdeeb5bec25..6f572ca66d25 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -108,13 +108,15 @@ struct rt_cache_stat {
 extern struct ip_rt_acct __percpu *ip_rt_acct;
 
 struct in_device;
-extern int		ip_rt_init(void);
-extern void		rt_cache_flush(struct net *net);
-extern void		rt_flush_dev(struct net_device *dev);
-extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
-extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
-					   struct sock *sk);
-extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);
+
+int ip_rt_init(void);
+void rt_cache_flush(struct net *net);
+void rt_flush_dev(struct net_device *dev);
+struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
+struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
+				    struct sock *sk);
+struct dst_entry *ipv4_blackhole_route(struct net *net,
+				       struct dst_entry *dst_orig);
 
 static inline struct rtable *ip_route_output_key(struct net *net, struct flowi4 *flp)
 {
@@ -162,8 +164,8 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 	return ip_route_output_key(net, fl4);
 }
 
-extern int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
-				u8 tos, struct net_device *devin);
+int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
+			 u8 tos, struct net_device *devin);
 
 static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin)
@@ -179,24 +181,25 @@ static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 	return err;
 }
 
-extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,
-			     int oif, u32 mark, u8 protocol, int flow_flags);
-extern void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
-extern void ipv4_redirect(struct sk_buff *skb, struct net *net,
-			  int oif, u32 mark, u8 protocol, int flow_flags);
-extern void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
-extern void ip_rt_send_redirect(struct sk_buff *skb);
-
-extern unsigned int		inet_addr_type(struct net *net, __be32 addr);
-extern unsigned int		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);
-extern void		ip_rt_multicast_event(struct in_device *);
-extern int		ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
-extern void		ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
-extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
+void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu, int oif,
+		      u32 mark, u8 protocol, int flow_flags);
+void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
+void ipv4_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark,
+		   u8 protocol, int flow_flags);
+void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
+void ip_rt_send_redirect(struct sk_buff *skb);
+
+unsigned int inet_addr_type(struct net *net, __be32 addr);
+unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
+				__be32 addr);
+void ip_rt_multicast_event(struct in_device *);
+int ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
+void ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
+int ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
 struct in_ifaddr;
-extern void fib_add_ifaddr(struct in_ifaddr *);
-extern void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
+void fib_add_ifaddr(struct in_ifaddr *);
+void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
 
 static inline void ip_rt_put(struct rtable *rt)
 {

commit 0ea9d5e3e0e03a63b11392f5613378977dae7eca
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Tue Aug 13 04:35:58 2013 +0200

    xfrm: introduce helper for safe determination of mtu
    
    skb->sk socket can be of AF_INET or AF_INET6 address family. Thus we
    always have to make sure we a referring to the correct interpretation
    of skb->sk.
    
    We only depend on header defines to query the mtu, so we don't introduce
    a new dependency to ipv6 by this change.
    
    Cc: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/include/net/route.h b/include/net/route.h
index 2ea40c1b5e00..afdeeb5bec25 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -317,4 +317,12 @@ static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
 	return hoplimit;
 }
 
+static inline int ip_skb_dst_mtu(struct sk_buff *skb)
+{
+	struct inet_sock *inet = skb->sk ? inet_sk(skb->sk) : NULL;
+
+	return (inet && inet->pmtudisc == IP_PMTUDISC_PROBE) ?
+	       skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
+}
+
 #endif	/* _ROUTE_H */

commit 6da025fa23bb10c82f80de319c837ed2b02306e4
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Oct 28 22:33:23 2012 +0000

    ipv4: avoid a test in ip_rt_put()
    
    We can save a test in ip_rt_put(), considering dst_release() accepts
    a NULL parameter, and dst is first element in rtable.
    
    Add a BUILD_BUG_ON() to catch any change that could break this
    assertion.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Cong Wang <amwang@redhat.com>
    Acked-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index bc40b633a5c4..2ea40c1b5e00 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -198,10 +198,13 @@ struct in_ifaddr;
 extern void fib_add_ifaddr(struct in_ifaddr *);
 extern void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
 
-static inline void ip_rt_put(struct rtable * rt)
+static inline void ip_rt_put(struct rtable *rt)
 {
-	if (rt)
-		dst_release(&rt->dst);
+	/* dst_release() accepts a NULL parameter.
+	 * We rely on dst being first structure in struct rtable
+	 */
+	BUILD_BUG_ON(offsetof(struct rtable, dst) != 0);
+	dst_release(&rt->dst);
 }
 
 #define IPTOS_RT_MASK	(IPTOS_TOS_MASK & ~3)

commit 155e8336c373d14d87a7f91e356d85ef4b93b8f9
Author: Julian Anastasov <ja@ssi.bg>
Date:   Mon Oct 8 11:41:18 2012 +0000

    ipv4: introduce rt_uses_gateway
    
    Add new flag to remember when route is via gateway.
    We will use it to allow rt_gateway to contain address of
    directly connected host for the cases when DST_NOCACHE is
    used or when the NH exception caches per-destination route
    without DST_NOCACHE flag, i.e. when routes are not used for
    other destinations. By this way we force the neighbour
    resolving to work with the routed destination but we
    can use different address in the packet, feature needed
    for IPVS-DR where original packet for virtual IP is routed
    via route to real IP.
    
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index da22243d2760..bc40b633a5c4 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -48,7 +48,8 @@ struct rtable {
 	int			rt_genid;
 	unsigned int		rt_flags;
 	__u16			rt_type;
-	__u16			rt_is_input;
+	__u8			rt_is_input;
+	__u8			rt_uses_gateway;
 
 	int			rt_iif;
 

commit bafa6d9d89072c1a18853afe9ee5de05c491c13a
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Fri Sep 7 00:45:29 2012 +0000

    ipv4/route: arg delay is useless in rt_cache_flush()
    
    Since route cache deletion (89aef8921bfbac22f), delay is no
    more used. Remove it.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 776a27f1ab78..da22243d2760 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -108,7 +108,7 @@ extern struct ip_rt_acct __percpu *ip_rt_acct;
 
 struct in_device;
 extern int		ip_rt_init(void);
-extern void		rt_cache_flush(struct net *net, int how);
+extern void		rt_cache_flush(struct net *net);
 extern void		rt_flush_dev(struct net_device *dev);
 extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
 extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,

commit caacf05e5ad1abf0a2864863da4e33024bc68ec6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 31 15:06:50 2012 -0700

    ipv4: Properly purge netdev references on uncached routes.
    
    When a device is unregistered, we have to purge all of the
    references to it that may exist in the entire system.
    
    If a route is uncached, we currently have no way of accomplishing
    this.
    
    So create a global list that is scanned when a network device goes
    down.  This mirrors the logic in net/core/dst.c's dst_ifdown().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 8c52bc6f1c90..776a27f1ab78 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -57,6 +57,8 @@ struct rtable {
 
 	/* Miscellaneous cached information */
 	u32			rt_pmtu;
+
+	struct list_head	rt_uncached;
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)
@@ -107,6 +109,7 @@ extern struct ip_rt_acct __percpu *ip_rt_acct;
 struct in_device;
 extern int		ip_rt_init(void);
 extern void		rt_cache_flush(struct net *net, int how);
+extern void		rt_flush_dev(struct net_device *dev);
 extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
 extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
 					   struct sock *sk);

commit c6cffba4ffa26a8ffacd0bb9f3144e34f20da7de
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jul 26 11:14:38 2012 +0000

    ipv4: Fix input route performance regression.
    
    With the routing cache removal we lost the "noref" code paths on
    input, and this can kill some routing workloads.
    
    Reinstate the noref path when we hit a cached route in the FIB
    nexthops.
    
    With help from Eric Dumazet.
    
    Reported-by: Alexander Duyck <alexander.duyck@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index c29ef2733f2d..8c52bc6f1c90 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -30,6 +30,7 @@
 #include <net/inet_sock.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
+#include <linux/rcupdate.h>
 #include <linux/route.h>
 #include <linux/ip.h>
 #include <linux/cache.h>
@@ -157,8 +158,22 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 	return ip_route_output_key(net, fl4);
 }
 
-extern int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
-			  u8 tos, struct net_device *devin);
+extern int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
+				u8 tos, struct net_device *devin);
+
+static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
+				 u8 tos, struct net_device *devin)
+{
+	int err;
+
+	rcu_read_lock();
+	err = ip_route_input_noref(skb, dst, src, tos, devin);
+	if (!err)
+		skb_dst_force(skb);
+	rcu_read_unlock();
+
+	return err;
+}
 
 extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,
 			     int oif, u32 mark, u8 protocol, int flow_flags);

commit 13378cad02afc2adc6c0e07fca03903c7ada0b37
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jul 23 13:57:45 2012 -0700

    ipv4: Change rt->rt_iif encoding.
    
    On input packet processing, rt->rt_iif will be zero if we should
    use skb->dev->ifindex.
    
    Since we access rt->rt_iif consistently via inet_iif(), that is
    the only spot whose interpretation have to adjust.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 60d611dc5cee..c29ef2733f2d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -277,7 +277,11 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 
 static inline int inet_iif(const struct sk_buff *skb)
 {
-	return skb_rtable(skb)->rt_iif;
+	int iif = skb_rtable(skb)->rt_iif;
+
+	if (iif)
+		return iif;
+	return skb->skb_iif;
 }
 
 extern int sysctl_ip_default_ttl;

commit 2860583fe840d972573363dfa190b2149a604534
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 17 14:55:59 2012 -0700

    ipv4: Kill rt->fi
    
    It's not really needed.
    
    We only grabbed a reference to the fib_info for the sake of fib_info
    local metrics.
    
    However, fib_info objects are freed using RCU, as are therefore their
    private metrics (if any).
    
    We would have triggered a route cache flush if we eliminated a
    reference to a fib_info object in the routing tables.
    
    Therefore, any existing cached routes will first check and see that
    they have been invalidated before an errant reference to these
    metric values would occur.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 4bafe0bfe829..60d611dc5cee 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -56,7 +56,6 @@ struct rtable {
 
 	/* Miscellaneous cached information */
 	u32			rt_pmtu;
-	struct fib_info		*fi; /* for client ref to shared metrics */
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)

commit 9917e1e8762745191eba5a3bf2040278cbddbee1
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 17 14:44:26 2012 -0700

    ipv4: Turn rt->rt_route_iif into rt->rt_is_input.
    
    That is this value's only use, as a boolean to indicate whether
    a route is an input route or not.
    
    So implement it that way, using a u16 gap present in the struct
    already.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index e789a92fd602..4bafe0bfe829 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -47,8 +47,8 @@ struct rtable {
 	int			rt_genid;
 	unsigned int		rt_flags;
 	__u16			rt_type;
+	__u16			rt_is_input;
 
-	int			rt_route_iif;
 	int			rt_iif;
 
 	/* Info on neighbour */
@@ -61,12 +61,12 @@ struct rtable {
 
 static inline bool rt_is_input_route(const struct rtable *rt)
 {
-	return rt->rt_route_iif != 0;
+	return rt->rt_is_input != 0;
 }
 
 static inline bool rt_is_output_route(const struct rtable *rt)
 {
-	return rt->rt_route_iif == 0;
+	return rt->rt_is_input == 0;
 }
 
 static inline __be32 rt_nexthop(const struct rtable *rt, __be32 daddr)

commit 4fd551d7bed93af60af61c5a324b8f5dff37953a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 17 14:39:44 2012 -0700

    ipv4: Kill rt->rt_oif
    
    Never actually used.
    
    It was being set on output routes to the original OIF specified in the
    flow key used for the lookup.
    
    Adjust the only user, ipmr_rt_fib_lookup(), for greater correctness of
    the flowi4_oif and flowi4_iif values, thanks to feedback from Julian
    Anastasov.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 3c1eeab9749b..e789a92fd602 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -50,7 +50,6 @@ struct rtable {
 
 	int			rt_route_iif;
 	int			rt_iif;
-	int			rt_oif;
 
 	/* Info on neighbour */
 	__be32			rt_gateway;

commit f8126f1d5136be1ca1a3536d43ad7a710b5620f8
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 13 05:03:45 2012 -0700

    ipv4: Adjust semantics of rt->rt_gateway.
    
    In order to allow prefixed routes, we have to adjust how rt_gateway
    is set and interpreted.
    
    The new interpretation is:
    
    1) rt_gateway == 0, destination is on-link, nexthop is iph->daddr
    
    2) rt_gateway != 0, destination requires a nexthop gateway
    
    Abstract the fetching of the proper nexthop value using a new
    inline helper, rt_nexthop(), as suggested by Joe Perches.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Tested-by: Vijay Subramanian <subramanian.vijay@gmail.com>

diff --git a/include/net/route.h b/include/net/route.h
index 6d111bceb160..3c1eeab9749b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -70,6 +70,13 @@ static inline bool rt_is_output_route(const struct rtable *rt)
 	return rt->rt_route_iif == 0;
 }
 
+static inline __be32 rt_nexthop(const struct rtable *rt, __be32 daddr)
+{
+	if (rt->rt_gateway)
+		return rt->rt_gateway;
+	return daddr;
+}
+
 struct ip_rt_acct {
 	__u32 	o_bytes;
 	__u32 	o_packets;

commit f1ce3062c53809d862d8a04e7a0566c3cc4e0bda
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jul 12 10:10:17 2012 -0700

    ipv4: Remove 'rt_dst' from 'struct rtable'
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 757fe40b6cea..6d111bceb160 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -48,7 +48,6 @@ struct rtable {
 	unsigned int		rt_flags;
 	__u16			rt_type;
 
-	__be32			rt_dst;	/* Path destination	*/
 	int			rt_route_iif;
 	int			rt_iif;
 	int			rt_oif;

commit b48698895de86e07b685f8e4b8db0f1cd5a97e9a
Author: David Miller <davem@davemloft.net>
Date:   Sun Jul 1 02:03:01 2012 +0000

    ipv4: Remove 'rt_mark' from 'struct rtable'
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 85d1093e42de..757fe40b6cea 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -52,7 +52,6 @@ struct rtable {
 	int			rt_route_iif;
 	int			rt_iif;
 	int			rt_oif;
-	__u32			rt_mark;
 
 	/* Info on neighbour */
 	__be32			rt_gateway;

commit d6c0a4f609847d6e65658913f9ccbcb1c137cff3
Author: David Miller <davem@davemloft.net>
Date:   Sun Jul 1 02:02:59 2012 +0000

    ipv4: Kill 'rt_src' from 'struct rtable'
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 935fa59630b0..85d1093e42de 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -49,7 +49,6 @@ struct rtable {
 	__u16			rt_type;
 
 	__be32			rt_dst;	/* Path destination	*/
-	__be32			rt_src;	/* Path source		*/
 	int			rt_route_iif;
 	int			rt_iif;
 	int			rt_oif;

commit 1a00fee4ffb22312a0ac40045ecd6f222b55eb3d
Author: David Miller <davem@davemloft.net>
Date:   Sun Jul 1 02:02:56 2012 +0000

    ipv4: Remove rt_key_{src,dst,tos} from struct rtable.
    
    They are always used in contexts where they can be reconstituted,
    or where the finally resolved rt->rt_{src,dst} is semantically
    equivalent.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5c86c4773b2b..935fa59630b0 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -44,14 +44,9 @@ struct fib_info;
 struct rtable {
 	struct dst_entry	dst;
 
-	/* Lookup key. */
-	__be32			rt_key_dst;
-	__be32			rt_key_src;
-
 	int			rt_genid;
 	unsigned int		rt_flags;
 	__u16			rt_type;
-	__u8			rt_key_tos;
 
 	__be32			rt_dst;	/* Path destination	*/
 	__be32			rt_src;	/* Path source		*/

commit 38a424e4657462fe9f8b76f01a0e879abde99ab4
Author: David Miller <davem@davemloft.net>
Date:   Sun Jul 1 02:02:53 2012 +0000

    ipv4: Kill ip_route_input_noref().
    
    The "noref" argument to ip_route_input_common() is now always ignored
    because we do not cache routes, and in that case we must always grab
    a reference to the resulting 'dst'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5dcfeb621e06..5c86c4773b2b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -160,20 +160,8 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 	return ip_route_output_key(net, fl4);
 }
 
-extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
-				 u8 tos, struct net_device *devin, bool noref);
-
-static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
-				 u8 tos, struct net_device *devin)
-{
-	return ip_route_input_common(skb, dst, src, tos, devin, false);
-}
-
-static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
-				       u8 tos, struct net_device *devin)
-{
-	return ip_route_input_common(skb, dst, src, tos, devin, true);
-}
+extern int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
+			  u8 tos, struct net_device *devin);
 
 extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,
 			     int oif, u32 mark, u8 protocol, int flow_flags);

commit 89aef8921bfbac22f00e04f8450f6e447db13e42
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 17 11:00:09 2012 -0700

    ipv4: Delete routing cache.
    
    The ipv4 routing cache is non-deterministic, performance wise, and is
    subject to reasonably easy to launch denial of service attacks.
    
    The routing cache works great for well behaved traffic, and the world
    was a much friendlier place when the tradeoffs that led to the routing
    cache's design were considered.
    
    What it boils down to is that the performance of the routing cache is
    a product of the traffic patterns seen by a system rather than being a
    product of the contents of the routing tables.  The former of which is
    controllable by external entitites.
    
    Even for "well behaved" legitimate traffic, high volume sites can see
    hit rates in the routing cache of only ~%10.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index ace3cb442519..5dcfeb621e06 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -109,7 +109,6 @@ extern struct ip_rt_acct __percpu *ip_rt_acct;
 struct in_device;
 extern int		ip_rt_init(void);
 extern void		rt_cache_flush(struct net *net, int how);
-extern void		rt_cache_flush_batch(struct net *net);
 extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
 extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
 					   struct sock *sk);

commit 1f42539d257af671d56d4bdbcf13aef31abff6ef
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jul 11 21:30:08 2012 -0700

    ipv4: Kill ip_rt_redirect().
    
    No longer needed, as the protocol handlers now all properly
    propagate the redirect back into the routing code.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6ab93eeb8660..ace3cb442519 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -108,7 +108,6 @@ extern struct ip_rt_acct __percpu *ip_rt_acct;
 
 struct in_device;
 extern int		ip_rt_init(void);
-extern void		ip_rt_redirect(struct sk_buff *skb, __be32 new_gw);
 extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
 extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);

commit b42597e2f36e2043756aa7462faddf630962f061
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jul 11 21:25:45 2012 -0700

    ipv4: Add ipv4_redirect() and ipv4_sk_redirect() helper functions.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b1402787aecb..6ab93eeb8660 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -180,6 +180,9 @@ static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 s
 extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,
 			     int oif, u32 mark, u8 protocol, int flow_flags);
 extern void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
+extern void ipv4_redirect(struct sk_buff *skb, struct net *net,
+			  int oif, u32 mark, u8 protocol, int flow_flags);
+extern void ipv4_sk_redirect(struct sk_buff *skb, struct sock *sk);
 extern void ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned int		inet_addr_type(struct net *net, __be32 addr);

commit 94206125c4aac32e43c25bfe1b827e7ab993b7dc
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jul 11 20:38:08 2012 -0700

    ipv4: Rearrange arguments to ip_rt_redirect()
    
    Pass in the SKB rather than just the IP addresses, so that policy
    and other aspects can reside in ip_rt_redirect() rather then
    icmp_redirect().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 52362368af09..b1402787aecb 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -108,8 +108,7 @@ extern struct ip_rt_acct __percpu *ip_rt_acct;
 
 struct in_device;
 extern int		ip_rt_init(void);
-extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
-				       __be32 src, struct net_device *dev);
+extern void		ip_rt_redirect(struct sk_buff *skb, __be32 new_gw);
 extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
 extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);

commit f185071ddf799e194ba015d040d3d49cdbfa7e48
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 10 07:26:01 2012 -0700

    ipv4: Remove inetpeer from routes.
    
    No longer used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index c27449466d18..52362368af09 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -40,7 +40,6 @@
 #define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
 
 struct fib_nh;
-struct inet_peer;
 struct fib_info;
 struct rtable {
 	struct dst_entry	dst;
@@ -66,44 +65,9 @@ struct rtable {
 
 	/* Miscellaneous cached information */
 	u32			rt_pmtu;
-	unsigned long		_peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */
 };
 
-static inline struct inet_peer *rt_peer_ptr(struct rtable *rt)
-{
-	return inetpeer_ptr(rt->_peer);
-}
-
-static inline bool rt_has_peer(struct rtable *rt)
-{
-	return inetpeer_ptr_is_peer(rt->_peer);
-}
-
-static inline void __rt_set_peer(struct rtable *rt, struct inet_peer *peer)
-{
-	__inetpeer_ptr_set_peer(&rt->_peer, peer);
-}
-
-static inline bool rt_set_peer(struct rtable *rt, struct inet_peer *peer)
-{
-	return inetpeer_ptr_set_peer(&rt->_peer, peer);
-}
-
-static inline void rt_init_peer(struct rtable *rt, struct inet_peer_base *base)
-{
-	inetpeer_init_ptr(&rt->_peer, base);
-}
-
-static inline void rt_transfer_peer(struct rtable *rt, struct rtable *ort)
-{
-	rt->_peer = ort->_peer;
-	if (rt_has_peer(ort)) {
-		struct inet_peer *peer = rt_peer_ptr(ort);
-		atomic_inc(&peer->refcnt);
-	}
-}
-
 static inline bool rt_is_input_route(const struct rtable *rt)
 {
 	return rt->rt_route_iif != 0;
@@ -326,27 +290,6 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 	return rt;
 }
 
-extern void rt_bind_peer(struct rtable *rt, __be32 daddr, int create);
-
-static inline struct inet_peer *__rt_get_peer(struct rtable *rt, __be32 daddr, int create)
-{
-	if (rt_has_peer(rt))
-		return rt_peer_ptr(rt);
-
-	rt_bind_peer(rt, daddr, create);
-	return (rt_has_peer(rt) ? rt_peer_ptr(rt) : NULL);
-}
-
-static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)
-{
-	return __rt_get_peer(rt, daddr, 0);
-}
-
-static inline struct inet_peer *rt_get_peer_create(struct rtable *rt, __be32 daddr)
-{
-	return __rt_get_peer(rt, daddr, 1);
-}
-
 static inline int inet_iif(const struct sk_buff *skb)
 {
 	return skb_rtable(skb)->rt_iif;

commit 5943634fc5592037db0693b261f7f4bea6bb9457
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 10 06:58:42 2012 -0700

    ipv4: Maintain redirect and PMTU info in struct rtable again.
    
    Maintaining this in the inetpeer entries was not the right way to do
    this at all.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 635d7a99d199..c27449466d18 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -65,7 +65,7 @@ struct rtable {
 	__be32			rt_gateway;
 
 	/* Miscellaneous cached information */
-	u32			rt_peer_genid;
+	u32			rt_pmtu;
 	unsigned long		_peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */
 };

commit 3e12939a2a67fbb4cbd962c3b9bc398c73319766
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 10 04:01:57 2012 -0700

    inet: Kill FLOWI_FLAG_PRECOW_METRICS.
    
    No longer needed.  TCP writes metrics, but now in it's own special
    cache that does not dirty the route metrics.  Therefore there is no
    longer any reason to pre-cow metrics in this way.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 211e2665139b..635d7a99d199 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -278,8 +278,6 @@ static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32
 
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
-	if (protocol == IPPROTO_TCP)
-		flow_flags |= FLOWI_FLAG_PRECOW_METRICS;
 	if (can_sleep)
 		flow_flags |= FLOWI_FLAG_CAN_SLEEP;
 

commit 41347dcdd81988b8e60853257b2875285cc17a4e
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 28 04:05:27 2012 -0700

    ipv4: Kill rt->rt_spec_dst, no longer used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 47eb25ac1f7f..211e2665139b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -65,7 +65,6 @@ struct rtable {
 	__be32			rt_gateway;
 
 	/* Miscellaneous cached information */
-	__be32			rt_spec_dst; /* RFC1122 specific destination */
 	u32			rt_peer_genid;
 	unsigned long		_peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */

commit c10237e077cef50e925f052e49f3b4fead9d71f9
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jun 27 17:05:06 2012 -0700

    Revert "ipv4: tcp: dont cache unconfirmed intput dst"
    
    This reverts commit c074da2810c118b3812f32d6754bd9ead2f169e7.
    
    This change has several unwanted side effects:
    
    1) Sockets will cache the DST_NOCACHE route in sk->sk_rx_dst and we'll
       thus never create a real cached route.
    
    2) All TCP traffic will use DST_NOCACHE and never use the routing
       cache at all.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6361f9335774..47eb25ac1f7f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -201,18 +201,18 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 }
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
-				 u8 tos, struct net_device *devin, bool noref, bool nocache);
+				 u8 tos, struct net_device *devin, bool noref);
 
 static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin)
 {
-	return ip_route_input_common(skb, dst, src, tos, devin, false, false);
+	return ip_route_input_common(skb, dst, src, tos, devin, false);
 }
 
 static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
-				       u8 tos, struct net_device *devin, bool nocache)
+				       u8 tos, struct net_device *devin)
 {
-	return ip_route_input_common(skb, dst, src, tos, devin, true, nocache);
+	return ip_route_input_common(skb, dst, src, tos, devin, true);
 }
 
 extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,

commit c074da2810c118b3812f32d6754bd9ead2f169e7
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Jun 26 23:14:15 2012 +0000

    ipv4: tcp: dont cache unconfirmed intput dst
    
    DDOS synflood attacks hit badly IP route cache.
    
    On typical machines, this cache is allowed to hold up to 8 Millions dst
    entries, 256 bytes for each, for a total of 2GB of memory.
    
    rt_garbage_collect() triggers and tries to cleanup things.
    
    Eventually route cache is disabled but machine is under fire and might
    OOM and crash.
    
    This patch exploits the new TCP early demux, to set a nocache
    boolean in case incoming TCP frame is for a not yet ESTABLISHED or
    TIMEWAIT socket.
    
    This 'nocache' boolean is then used in case dst entry is not found in
    route cache, to create an unhashed dst entry (DST_NOCACHE)
    
    SYN-cookie-ACK sent use a similar mechanism (ipv4: tcp: dont cache
    output dst for syncookies), so after this patch, a machine is able to
    absorb a DDOS synflood attack without polluting its IP route cache.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Hans Schillstrom <hans.schillstrom@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 47eb25ac1f7f..6361f9335774 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -201,18 +201,18 @@ static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4
 }
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
-				 u8 tos, struct net_device *devin, bool noref);
+				 u8 tos, struct net_device *devin, bool noref, bool nocache);
 
 static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin)
 {
-	return ip_route_input_common(skb, dst, src, tos, devin, false);
+	return ip_route_input_common(skb, dst, src, tos, devin, false, false);
 }
 
 static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
-				       u8 tos, struct net_device *devin)
+				       u8 tos, struct net_device *devin, bool nocache)
 {
-	return ip_route_input_common(skb, dst, src, tos, devin, true);
+	return ip_route_input_common(skb, dst, src, tos, devin, true, nocache);
 }
 
 extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,

commit 36393395536064e483b73d173f6afc103eadfbc4
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 14 22:21:46 2012 -0700

    ipv4: Handle PMTU in all ICMP error handlers.
    
    With ip_rt_frag_needed() removed, we have to explicitly update PMTU
    information in every ICMP error handler.
    
    Create two helper functions to facilitate this.
    
    1) ipv4_sk_update_pmtu()
    
       This updates the PMTU when we have a socket context to
       work with.
    
    2) ipv4_update_pmtu()
    
       Raw version, used when no socket context is available.  For this
       interface, we essentially just pass in explicit arguments for
       the flow identity information we would have extracted from the
       socket.
    
       And you'll notice that ipv4_sk_update_pmtu() is simply implemented
       in terms of ipv4_update_pmtu()
    
    Note that __ip_route_output_key() is used, rather than something like
    ip_route_output_flow() or ip_route_output_key().  This is because we
    absolutely do not want to end up with a route that does IPSEC
    encapsulation and the like.  Instead, we only want the route that
    would get us to the node described by the outermost IP header.
    
    Reported-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index a36ae429ed5d..47eb25ac1f7f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -215,7 +215,10 @@ static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 s
 	return ip_route_input_common(skb, dst, src, tos, devin, true);
 }
 
-extern void		ip_rt_send_redirect(struct sk_buff *skb);
+extern void ipv4_update_pmtu(struct sk_buff *skb, struct net *net, u32 mtu,
+			     int oif, u32 mark, u8 protocol, int flow_flags);
+extern void ipv4_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, u32 mtu);
+extern void ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned int		inet_addr_type(struct net *net, __be32 addr);
 extern unsigned int		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);

commit 43b03f1f6d6832d744918947d185a7aee89d1e0f
Merge: 2da45db2bdd4 5ee31c6898ea
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 12 21:59:18 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            MAINTAINERS
            drivers/net/wireless/iwlwifi/pcie/trans.c
    
    The iwlwifi conflict was resolved by keeping the code added
    in 'net' that turns off the buggy chip feature.
    
    The MAINTAINERS conflict was merely overlapping changes, one
    change updated all the wireless web site URLs and the other
    changed some GIT trees to be Johannes's instead of John's.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 55afabaa0df0dd139c8796a71beb43d1216fbe43
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jun 11 15:52:29 2012 -0700

    inet: Fix BUG triggered by __rt{,6}_get_peer().
    
    If no peer actually gets attached (either because create is zero or
    the peer allocation fails) we'll trigger a BUG because we
    unconditionally do an rt{,6}_peer_ptr() afterwards.
    
    Fix this by guarding it with the proper check.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index cc693a5bb20d..2bfbc9329ea9 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -334,7 +334,7 @@ static inline struct inet_peer *__rt_get_peer(struct rtable *rt, __be32 daddr, i
 		return rt_peer_ptr(rt);
 
 	rt_bind_peer(rt, daddr, create);
-	return rt_peer_ptr(rt);
+	return (rt_has_peer(rt) ? rt_peer_ptr(rt) : NULL);
 }
 
 static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)

commit 46517008e1168dc926cf2c47d529efc07eca85c0
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jun 10 00:04:12 2012 -0700

    ipv4: Kill ip_rt_frag_needed().
    
    There is zero point to this function.
    
    It's only real substance is to perform an extremely outdated BSD4.2
    ICMP check, which we can safely remove.  If you really have a MTU
    limited link being routed by a BSD4.2 derived system, here's a nickel
    go buy yourself a real router.
    
    The other actions of ip_rt_frag_needed(), checking and conditionally
    updating the peer, are done by the per-protocol handlers of the ICMP
    event.
    
    TCP, UDP, et al. have a handler which will receive this event and
    transmit it back into the associated route via dst_ops->update_pmtu().
    
    This simplification is important, because it eliminates the one place
    where we do not have a proper route context in which to make an
    inetpeer lookup.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6340c37677fc..cc693a5bb20d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -215,8 +215,6 @@ static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 s
 	return ip_route_input_common(skb, dst, src, tos, devin, true);
 }
 
-extern unsigned short	ip_rt_frag_needed(struct net *net, const struct iphdr *iph,
-					  unsigned short new_mtu, struct net_device *dev);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned int		inet_addr_type(struct net *net, __be32 addr);

commit 97bab73f987e2781129cd6f4b6379bf44d808cc6
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Jun 9 22:36:36 2012 -0700

    inet: Hide route peer accesses behind helpers.
    
    We encode the pointer(s) into an unsigned long with one state bit.
    
    The state bit is used so we can store the inetpeer tree root to use
    when resolving the peer later.
    
    Later the peer roots will be per-FIB table, and this change works to
    facilitate that.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 433fc6c1d404..6340c37677fc 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -67,10 +67,44 @@ struct rtable {
 	/* Miscellaneous cached information */
 	__be32			rt_spec_dst; /* RFC1122 specific destination */
 	u32			rt_peer_genid;
-	struct inet_peer	*peer; /* long-living peer info */
+	unsigned long		_peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */
 };
 
+static inline struct inet_peer *rt_peer_ptr(struct rtable *rt)
+{
+	return inetpeer_ptr(rt->_peer);
+}
+
+static inline bool rt_has_peer(struct rtable *rt)
+{
+	return inetpeer_ptr_is_peer(rt->_peer);
+}
+
+static inline void __rt_set_peer(struct rtable *rt, struct inet_peer *peer)
+{
+	__inetpeer_ptr_set_peer(&rt->_peer, peer);
+}
+
+static inline bool rt_set_peer(struct rtable *rt, struct inet_peer *peer)
+{
+	return inetpeer_ptr_set_peer(&rt->_peer, peer);
+}
+
+static inline void rt_init_peer(struct rtable *rt, struct inet_peer_base *base)
+{
+	inetpeer_init_ptr(&rt->_peer, base);
+}
+
+static inline void rt_transfer_peer(struct rtable *rt, struct rtable *ort)
+{
+	rt->_peer = ort->_peer;
+	if (rt_has_peer(ort)) {
+		struct inet_peer *peer = rt_peer_ptr(ort);
+		atomic_inc(&peer->refcnt);
+	}
+}
+
 static inline bool rt_is_input_route(const struct rtable *rt)
 {
 	return rt->rt_route_iif != 0;
@@ -298,11 +332,11 @@ extern void rt_bind_peer(struct rtable *rt, __be32 daddr, int create);
 
 static inline struct inet_peer *__rt_get_peer(struct rtable *rt, __be32 daddr, int create)
 {
-	if (rt->peer)
-		return rt->peer;
+	if (rt_has_peer(rt))
+		return rt_peer_ptr(rt);
 
 	rt_bind_peer(rt, daddr, create);
-	return rt->peer;
+	return rt_peer_ptr(rt);
 }
 
 static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)

commit c5d21c4b2a7765ab0600c8426374b50eb9f4a36f
Author: Roland Dreier <roland@purestorage.com>
Date:   Sun Jun 10 20:05:24 2012 +0000

    net: Reorder initialization in ip_route_output to fix gcc warning
    
    If I build with W=1, for every file that includes <net/route.h>, I get the warning
    
        include/net/route.h: In function 'ip_route_output':
        include/net/route.h:135:3: warning: initialized field overwritten [-Woverride-init]
        include/net/route.h:135:3: warning: (near initialization for 'fl4') [-Woverride-init]
    
    (This is with "gcc (Debian 4.6.3-1) 4.6.3")
    
    A fix seems pretty trivial: move the initialization of .flowi4_tos
    earlier.  As far as I can tell, this has no effect on code generation.
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index ed2b78e2375d..98705468ac03 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -130,9 +130,9 @@ static inline struct rtable *ip_route_output(struct net *net, __be32 daddr,
 {
 	struct flowi4 fl4 = {
 		.flowi4_oif = oif,
+		.flowi4_tos = tos,
 		.daddr = daddr,
 		.saddr = saddr,
-		.flowi4_tos = tos,
 	};
 	return ip_route_output_key(net, &fl4);
 }

commit fbfe95a42e90b3dd079cc9019ba7d7700feee0f6
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jun 8 23:24:18 2012 -0700

    inet: Create and use rt{,6}_get_peer_create().
    
    There's a lot of places that open-code rt{,6}_get_peer() only because
    they want to set 'create' to one.  So add an rt{,6}_get_peer_create()
    for their sake.
    
    There were also a few spots open-coding plain rt{,6}_get_peer() and
    those are transformed here as well.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index ed2b78e2375d..433fc6c1d404 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -296,15 +296,25 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 
 extern void rt_bind_peer(struct rtable *rt, __be32 daddr, int create);
 
-static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)
+static inline struct inet_peer *__rt_get_peer(struct rtable *rt, __be32 daddr, int create)
 {
 	if (rt->peer)
 		return rt->peer;
 
-	rt_bind_peer(rt, daddr, 0);
+	rt_bind_peer(rt, daddr, create);
 	return rt->peer;
 }
 
+static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)
+{
+	return __rt_get_peer(rt, daddr, 0);
+}
+
+static inline struct inet_peer *rt_get_peer_create(struct rtable *rt, __be32 daddr)
+{
+	return __rt_get_peer(rt, daddr, 1);
+}
+
 static inline int inet_iif(const struct sk_buff *skb)
 {
 	return skb_rtable(skb)->rt_iif;

commit 95c961747284a6b83a5e2d81240e214b0fa3464d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sun Apr 15 05:58:06 2012 +0000

    net: cleanup unsigned to unsigned int
    
    Use of "unsigned int" is preferred to bare "unsigned" in net tree.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b1c0d5b564c2..ed2b78e2375d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -50,7 +50,7 @@ struct rtable {
 	__be32			rt_key_src;
 
 	int			rt_genid;
-	unsigned		rt_flags;
+	unsigned int		rt_flags;
 	__u16			rt_type;
 	__u8			rt_key_tos;
 
@@ -185,8 +185,8 @@ extern unsigned short	ip_rt_frag_needed(struct net *net, const struct iphdr *iph
 					  unsigned short new_mtu, struct net_device *dev);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
-extern unsigned		inet_addr_type(struct net *net, __be32 addr);
-extern unsigned		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);
+extern unsigned int		inet_addr_type(struct net *net, __be32 addr);
+extern unsigned int		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
 extern int		ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);

commit e6b45241c57a83197e5de9166b3b0d32ac562609
Author: Julian Anastasov <ja@ssi.bg>
Date:   Sat Feb 4 13:04:46 2012 +0000

    ipv4: reset flowi parameters on route connect
    
    Eric Dumazet found that commit 813b3b5db83
    (ipv4: Use caller's on-stack flowi as-is in output
    route lookups.) that comes in 3.0 added a regression.
    The problem appears to be that resulting flowi4_oif is
    used incorrectly as input parameter to some routing lookups.
    The result is that when connecting to local port without
    listener if the IP address that is used is not on a loopback
    interface we incorrectly assign RTN_UNICAST to the output
    route because no route is matched by oif=lo. The RST packet
    can not be sent immediately by tcp_v4_send_reset because
    it expects RTN_LOCAL.
    
            So, change ip_route_connect and ip_route_newports to
    update the flowi4 fields that are input parameters because
    we do not want unnecessary binding to oif.
    
            To make it clear what are the input parameters that
    can be modified during lookup and to show which fields of
    floiw4 are reused add a new function to update the flowi4
    structure: flowi4_update_output.
    
    Thanks to Yurij M. Plotnikov for providing a bug report including a
    program to reproduce the problem.
    
    Thanks to Eric Dumazet for tracking the problem down to
    tcp_v4_send_reset and providing initial fix.
    
    Reported-by: Yurij M. Plotnikov <Yurij.Plotnikov@oktetlabs.ru>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 91855d185b53..b1c0d5b564c2 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -270,6 +270,7 @@ static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
 		if (IS_ERR(rt))
 			return rt;
 		ip_rt_put(rt);
+		flowi4_update_output(fl4, oif, tos, fl4->daddr, fl4->saddr);
 	}
 	security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
 	return ip_route_output_flow(net, fl4, sk);
@@ -284,6 +285,9 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 		fl4->fl4_dport = dport;
 		fl4->fl4_sport = sport;
 		ip_rt_put(rt);
+		flowi4_update_output(fl4, sk->sk_bound_dev_if,
+				     RT_CONN_FLAGS(sk), fl4->daddr,
+				     fl4->saddr);
 		security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
 		return ip_route_output_flow(sock_net(sk), fl4, sk);
 	}

commit b8400f3718a11c9b0ca400705cddf94f3132c1c3
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Wed Nov 23 02:14:15 2011 +0000

    route: struct rtable can be const in rt_is_input_route and rt_is_output_route
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index db7b3432f07c..91855d185b53 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -71,12 +71,12 @@ struct rtable {
 	struct fib_info		*fi; /* for client ref to shared metrics */
 };
 
-static inline bool rt_is_input_route(struct rtable *rt)
+static inline bool rt_is_input_route(const struct rtable *rt)
 {
 	return rt->rt_route_iif != 0;
 }
 
-static inline bool rt_is_output_route(struct rtable *rt)
+static inline bool rt_is_output_route(const struct rtable *rt)
 {
 	return rt->rt_route_iif == 0;
 }

commit a48eff128865aa20520fa6e0e0c5fbd2ac50d712
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 18 18:42:43 2011 -0400

    ipv4: Pass explicit destination address to rt_bind_peer().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 600d0f2ef8d6..db7b3432f07c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -290,14 +290,14 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 	return rt;
 }
 
-extern void rt_bind_peer(struct rtable *rt, int create);
+extern void rt_bind_peer(struct rtable *rt, __be32 daddr, int create);
 
 static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)
 {
 	if (rt->peer)
 		return rt->peer;
 
-	rt_bind_peer(rt, 0);
+	rt_bind_peer(rt, daddr, 0);
 	return rt->peer;
 }
 

commit ed2361e66eec60645f8e4715fe39a42235ef43ae
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 18 18:38:54 2011 -0400

    ipv4: Pass explicit destination address to rt_get_peer().
    
    This will next trickle down to rt_bind_peer().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index ba0e0840370c..600d0f2ef8d6 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -292,7 +292,7 @@ static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable
 
 extern void rt_bind_peer(struct rtable *rt, int create);
 
-static inline struct inet_peer *rt_get_peer(struct rtable *rt)
+static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)
 {
 	if (rt->peer)
 		return rt->peer;

commit 8e36360ae876995e92d3a7538dda70548e64e685
Author: David S. Miller <davem@davemloft.net>
Date:   Fri May 13 17:29:41 2011 -0400

    ipv4: Remove route key identity dependencies in ip_rt_get_source().
    
    Pass in the sk_buff so that we can fetch the necessary keys from
    the packet header when working with input routes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9f8070b251fb..ba0e0840370c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -189,7 +189,7 @@ extern unsigned		inet_addr_type(struct net *net, __be32 addr);
 extern unsigned		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
 extern int		ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
-extern void		ip_rt_get_source(u8 *src, struct rtable *rt);
+extern void		ip_rt_get_source(u8 *src, struct sk_buff *skb, struct rtable *rt);
 extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
 struct in_ifaddr;

commit cbb1e85f9cfd2bd9b7edfd21d167e89a4279faf0
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 4 12:33:34 2011 -0700

    ipv4: Kill rt->rt_{src, dst} usage in IP GRE tunnels.
    
    First, make callers pass on-stack flowi4 to ip_route_output_gre()
    so they can get at the fully resolved flow key.
    
    Next, use that in ipgre_tunnel_xmit() to avoid the need to use
    rt->rt_{dst,src}.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 8c02c871a8ce..9f8070b251fb 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -152,19 +152,18 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct flowi
 	return ip_route_output_flow(net, fl4, sk);
 }
 
-static inline struct rtable *ip_route_output_gre(struct net *net,
+static inline struct rtable *ip_route_output_gre(struct net *net, struct flowi4 *fl4,
 						 __be32 daddr, __be32 saddr,
 						 __be32 gre_key, __u8 tos, int oif)
 {
-	struct flowi4 fl4 = {
-		.flowi4_oif = oif,
-		.daddr = daddr,
-		.saddr = saddr,
-		.flowi4_tos = tos,
-		.flowi4_proto = IPPROTO_GRE,
-		.fl4_gre_key = gre_key,
-	};
-	return ip_route_output_key(net, &fl4);
+	memset(fl4, 0, sizeof(*fl4));
+	fl4->flowi4_oif = oif;
+	fl4->daddr = daddr;
+	fl4->saddr = saddr;
+	fl4->flowi4_tos = tos;
+	fl4->flowi4_proto = IPPROTO_GRE;
+	fl4->fl4_gre_key = gre_key;
+	return ip_route_output_key(net, fl4);
 }
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,

commit 31e4543db29fb85496a122b965d6482c8d1a2bfe
Author: David S. Miller <davem@davemloft.net>
Date:   Tue May 3 20:25:42 2011 -0700

    ipv4: Make caller provide on-stack flow key to ip_route_output_ports().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index f07609e83141..8c02c871a8ce 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -137,20 +137,19 @@ static inline struct rtable *ip_route_output(struct net *net, __be32 daddr,
 	return ip_route_output_key(net, &fl4);
 }
 
-static inline struct rtable *ip_route_output_ports(struct net *net, struct sock *sk,
+static inline struct rtable *ip_route_output_ports(struct net *net, struct flowi4 *fl4,
+						   struct sock *sk,
 						   __be32 daddr, __be32 saddr,
 						   __be16 dport, __be16 sport,
 						   __u8 proto, __u8 tos, int oif)
 {
-	struct flowi4 fl4;
-
-	flowi4_init_output(&fl4, oif, sk ? sk->sk_mark : 0, tos,
+	flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, tos,
 			   RT_SCOPE_UNIVERSE, proto,
 			   sk ? inet_sk_flowi_flags(sk) : 0,
 			   daddr, saddr, dport, sport);
 	if (sk)
-		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
-	return ip_route_output_flow(net, &fl4, sk);
+		security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
+	return ip_route_output_flow(net, fl4, sk);
 }
 
 static inline struct rtable *ip_route_output_gre(struct net *net,

commit 475949d8e86bbde5ea3ffa4d95e022ca69233b14
Author: David S. Miller <davem@davemloft.net>
Date:   Tue May 3 19:45:15 2011 -0700

    ipv4: Renamt struct rtable's rt_tos to rt_key_tos.
    
    To more accurately reflect that it is purely a routing
    cache lookup key and is used in no other context.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 16eb59cd7080..f07609e83141 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -52,7 +52,7 @@ struct rtable {
 	int			rt_genid;
 	unsigned		rt_flags;
 	__u16			rt_type;
-	__u8			rt_tos;
+	__u8			rt_key_tos;
 
 	__be32			rt_dst;	/* Path destination	*/
 	__be32			rt_src;	/* Path source		*/

commit 6706b6ebab85dfca4e2886e35ec9c3c4ee13e27e
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Apr 28 23:13:17 2011 -0700

    ipv4: Remove now superfluous code in ip_route_connect().
    
    Now that output route lookups update the flow with
    source address et al. selections, the fl4->{saddr,daddr}
    assignments here are no longer necessary.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 81b6cf276549..16eb59cd7080 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -271,8 +271,6 @@ static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
 		rt = __ip_route_output_key(net, fl4);
 		if (IS_ERR(rt))
 			return rt;
-		fl4->daddr = rt->rt_dst;
-		fl4->saddr = rt->rt_src;
 		ip_rt_put(rt);
 	}
 	security_sk_classify_flow(sk, flowi4_to_flowi(fl4));

commit 813b3b5db831ddbd92b5ce0fdeb74e3368f1323c
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Apr 28 14:48:42 2011 -0700

    ipv4: Use caller's on-stack flowi as-is in output route lookups.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index fdbdb9271d7f..81b6cf276549 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -115,7 +115,7 @@ extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
-extern struct rtable *__ip_route_output_key(struct net *, const struct flowi4 *flp);
+extern struct rtable *__ip_route_output_key(struct net *, struct flowi4 *flp);
 extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
 					   struct sock *sk);
 extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);

commit b678027cb77b079bc8e5b94172995d173bdb494b
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Apr 26 14:58:35 2011 -0700

    ipv4: Kill RTO_CONN.
    
    It's not used by anything in the kernel, and defined in net/route.h so
    never exported to userspace.
    
    Therefore we can safely remove it.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 79530da31b34..fdbdb9271d7f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -37,10 +37,6 @@
 
 #define RTO_ONLINK	0x01
 
-#define RTO_CONN	0
-/* RTO_CONN is not used (being alias for 0), but preserved not to break
- * some modules referring to it. */
-
 #define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
 
 struct fib_nh;

commit 2d7192d6cbab20e153c47fa1559ffd41ceef0e79
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Apr 26 13:28:44 2011 -0700

    ipv4: Sanitize and simplify ip_route_{connect,newports}()
    
    These functions are used together as a unit for route resolution
    during connect().  They address the chicken-and-egg problem that
    exists when ports need to be allocated during connect() processing,
    yet such port allocations require addressing information from the
    routing code.
    
    It's currently more heavy handed than it needs to be, and in
    particular we allocate and initialize a flow object twice.
    
    Let the callers provide the on-stack flow object.  That way we only
    need to initialize it once in the ip_route_connect() call.
    
    Later, if ip_route_newports() needs to do anything, it re-uses that
    flow object as-is except for the ports which it updates before the
    route re-lookup.
    
    Also, describe why this set of facilities are needed and how it works
    in a big comment.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>

diff --git a/include/net/route.h b/include/net/route.h
index 3684c3edbae4..79530da31b34 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -217,17 +217,37 @@ static inline char rt_tos2priority(u8 tos)
 	return ip_tos2prio[IPTOS_TOS(tos)>>1];
 }
 
-static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
-					      int oif, u8 protocol,
-					      __be16 sport, __be16 dport,
-					      struct sock *sk, bool can_sleep)
+/* ip_route_connect() and ip_route_newports() work in tandem whilst
+ * binding a socket for a new outgoing connection.
+ *
+ * In order to use IPSEC properly, we must, in the end, have a
+ * route that was looked up using all available keys including source
+ * and destination ports.
+ *
+ * However, if a source port needs to be allocated (the user specified
+ * a wildcard source port) we need to obtain addressing information
+ * in order to perform that allocation.
+ *
+ * So ip_route_connect() looks up a route using wildcarded source and
+ * destination ports in the key, simply so that we can get a pair of
+ * addresses to use for port allocation.
+ *
+ * Later, once the ports are allocated, ip_route_newports() will make
+ * another route lookup if needed to make sure we catch any IPSEC
+ * rules keyed on the port information.
+ *
+ * The callers allocate the flow key on their stack, and must pass in
+ * the same flowi4 object to both the ip_route_connect() and the
+ * ip_route_newports() calls.
+ */
+
+static inline void ip_route_connect_init(struct flowi4 *fl4, __be32 dst, __be32 src,
+					 u32 tos, int oif, u8 protocol,
+					 __be16 sport, __be16 dport,
+					 struct sock *sk, bool can_sleep)
 {
-	struct net *net = sock_net(sk);
-	struct rtable *rt;
-	struct flowi4 fl4;
-	__u8 flow_flags;
+	__u8 flow_flags = 0;
 
-	flow_flags = 0;
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 	if (protocol == IPPROTO_TCP)
@@ -235,41 +255,45 @@ static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
 	if (can_sleep)
 		flow_flags |= FLOWI_FLAG_CAN_SLEEP;
 
-	flowi4_init_output(&fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
+	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);
+}
+
+static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
+					      __be32 dst, __be32 src, u32 tos,
+					      int oif, u8 protocol,
+					      __be16 sport, __be16 dport,
+					      struct sock *sk, bool can_sleep)
+{
+	struct net *net = sock_net(sk);
+	struct rtable *rt;
+
+	ip_route_connect_init(fl4, dst, src, tos, oif, protocol,
+			      sport, dport, sk, can_sleep);
 
 	if (!dst || !src) {
-		rt = __ip_route_output_key(net, &fl4);
+		rt = __ip_route_output_key(net, fl4);
 		if (IS_ERR(rt))
 			return rt;
-		fl4.daddr = rt->rt_dst;
-		fl4.saddr = rt->rt_src;
+		fl4->daddr = rt->rt_dst;
+		fl4->saddr = rt->rt_src;
 		ip_rt_put(rt);
 	}
-	security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
-	return ip_route_output_flow(net, &fl4, sk);
+	security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
+	return ip_route_output_flow(net, fl4, sk);
 }
 
-static inline struct rtable *ip_route_newports(struct rtable *rt,
-					       u8 protocol, __be16 orig_sport,
-					       __be16 orig_dport, __be16 sport,
-					       __be16 dport, struct sock *sk)
+static inline struct rtable *ip_route_newports(struct flowi4 *fl4, struct rtable *rt,
+					       __be16 orig_sport, __be16 orig_dport,
+					       __be16 sport, __be16 dport,
+					       struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi4 fl4;
-		__u8 flow_flags;
-
-		flow_flags = 0;
-		if (inet_sk(sk)->transparent)
-			flow_flags |= FLOWI_FLAG_ANYSRC;
-		if (protocol == IPPROTO_TCP)
-			flow_flags |= FLOWI_FLAG_PRECOW_METRICS;
-		flowi4_init_output(&fl4, rt->rt_oif, rt->rt_mark, rt->rt_tos,
-				   RT_SCOPE_UNIVERSE, protocol, flow_flags,
-				   rt->rt_dst, rt->rt_src, dport, sport);
+		fl4->fl4_dport = dport;
+		fl4->fl4_sport = sport;
 		ip_rt_put(rt);
-		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
-		return ip_route_output_flow(sock_net(sk), &fl4, sk);
+		security_sk_classify_flow(sk, flowi4_to_flowi(fl4));
+		return ip_route_output_flow(sock_net(sk), fl4, sk);
 	}
 	return rt;
 }

commit 2a9e9507011440a57d6356ded630ba0c0f5d4b77
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Apr 24 10:54:56 2011 -0700

    net: Remove __KERNEL__ cpp checks from include/net
    
    These header files are never installed to user consumption, so any
    __KERNEL__ cpp checks are superfluous.
    
    Projects should also not copy these files into their userland utility
    sources and try to use them there.  If they insist on doing so, the
    onus is on them to sanitize the headers as needed.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b3962e249e14..3684c3edbae4 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -35,10 +35,6 @@
 #include <linux/cache.h>
 #include <linux/security.h>
 
-#ifndef __KERNEL__
-#warning This file is not supposed to be used outside of kernel.
-#endif
-
 #define RTO_ONLINK	0x01
 
 #define RTO_CONN	0

commit b71d1d426d263b0b6cb5760322efebbfc89d4463
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Fri Apr 22 04:53:02 2011 +0000

    inet: constify ip headers and in6_addr
    
    Add const qualifiers to structs iphdr, ipv6hdr and in6_addr pointers
    where possible, to make code intention more obvious.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 3782cddd1383..b3962e249e14 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -191,7 +191,8 @@ static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 s
 	return ip_route_input_common(skb, dst, src, tos, devin, true);
 }
 
-extern unsigned short	ip_rt_frag_needed(struct net *net, struct iphdr *iph, unsigned short new_mtu, struct net_device *dev);
+extern unsigned short	ip_rt_frag_needed(struct net *net, const struct iphdr *iph,
+					  unsigned short new_mtu, struct net_device *dev);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned		inet_addr_type(struct net *net, __be32 addr);

commit c1e48efc701b79ee4367c9a1a4e8bbc7c3586e02
Merge: 912d398d28b4 1b86a58f9d7c
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Apr 7 14:05:23 2011 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/benet/be_main.c

commit 1b86a58f9d7ce4fe2377687f378fbfb53bdc9b6c
Author: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
Date:   Thu Apr 7 14:04:08 2011 -0700

    ipv4: Fix "Set rt->rt_iif more sanely on output routes."
    
    Commit 1018b5c01636c7c6bda31a719bda34fc631db29a ("Set rt->rt_iif more
    sanely on output routes.")  breaks rt_is_{output,input}_route.
    
    This became the cause to return "IP_PKTINFO's ->ipi_ifindex == 0".
    
    To fix it, this does:
    
    1) Add "int rt_route_iif;" to struct rtable
    
    2) For input routes, always set rt_route_iif to same value as rt_iif
    
    3) For output routes, always set rt_route_iif to zero.  Set rt_iif
       as it is done currently.
    
    4) Change rt_is_{output,input}_route() to test rt_route_iif
    
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index f88429cad52a..8fce0621cad1 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -64,6 +64,7 @@ struct rtable {
 
 	__be32			rt_dst;	/* Path destination	*/
 	__be32			rt_src;	/* Path source		*/
+	int			rt_route_iif;
 	int			rt_iif;
 	int			rt_oif;
 	__u32			rt_mark;
@@ -80,12 +81,12 @@ struct rtable {
 
 static inline bool rt_is_input_route(struct rtable *rt)
 {
-	return rt->rt_iif != 0;
+	return rt->rt_route_iif != 0;
 }
 
 static inline bool rt_is_output_route(struct rtable *rt)
 {
-	return rt->rt_iif == 0;
+	return rt->rt_route_iif == 0;
 }
 
 struct ip_rt_acct {

commit 94b92b88344641dbeadd2ef371549b7663a48fb1
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Mar 31 04:52:59 2011 -0700

    ipv4: Use flowi4_init_output() in net/route.h
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index f88429cad52a..b24288595e58 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -149,17 +149,12 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct sock
 						   __be16 dport, __be16 sport,
 						   __u8 proto, __u8 tos, int oif)
 {
-	struct flowi4 fl4 = {
-		.flowi4_oif = oif,
-		.flowi4_flags = sk ? inet_sk_flowi_flags(sk) : 0,
-		.flowi4_mark = sk ? sk->sk_mark : 0,
-		.daddr = daddr,
-		.saddr = saddr,
-		.flowi4_tos = tos,
-		.flowi4_proto = proto,
-		.fl4_dport = dport,
-		.fl4_sport = sport,
-	};
+	struct flowi4 fl4;
+
+	flowi4_init_output(&fl4, oif, sk ? sk->sk_mark : 0, tos,
+			   RT_SCOPE_UNIVERSE, proto,
+			   sk ? inet_sk_flowi_flags(sk) : 0,
+			   daddr, saddr, dport, sport);
 	if (sk)
 		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
 	return ip_route_output_flow(net, &fl4, sk);
@@ -229,25 +224,21 @@ static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
 					      __be16 sport, __be16 dport,
 					      struct sock *sk, bool can_sleep)
 {
-	struct flowi4 fl4 = {
-		.flowi4_oif = oif,
-		.flowi4_mark = sk->sk_mark,
-		.daddr = dst,
-		.saddr = src,
-		.flowi4_tos = tos,
-		.flowi4_proto = protocol,
-		.fl4_sport = sport,
-		.fl4_dport = dport,
-	};
 	struct net *net = sock_net(sk);
 	struct rtable *rt;
+	struct flowi4 fl4;
+	__u8 flow_flags;
 
+	flow_flags = 0;
 	if (inet_sk(sk)->transparent)
-		fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;
+		flow_flags |= FLOWI_FLAG_ANYSRC;
 	if (protocol == IPPROTO_TCP)
-		fl4.flowi4_flags |= FLOWI_FLAG_PRECOW_METRICS;
+		flow_flags |= FLOWI_FLAG_PRECOW_METRICS;
 	if (can_sleep)
-		fl4.flowi4_flags |= FLOWI_FLAG_CAN_SLEEP;
+		flow_flags |= FLOWI_FLAG_CAN_SLEEP;
+
+	flowi4_init_output(&fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
+			   protocol, flow_flags, dst, src, dport, sport);
 
 	if (!dst || !src) {
 		rt = __ip_route_output_key(net, &fl4);
@@ -267,20 +258,17 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 					       __be16 dport, struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi4 fl4 = {
-			.flowi4_oif = rt->rt_oif,
-			.flowi4_mark = rt->rt_mark,
-			.daddr = rt->rt_dst,
-			.saddr = rt->rt_src,
-			.flowi4_tos = rt->rt_tos,
-			.flowi4_proto = protocol,
-			.fl4_sport = sport,
-			.fl4_dport = dport
-		};
+		struct flowi4 fl4;
+		__u8 flow_flags;
+
+		flow_flags = 0;
 		if (inet_sk(sk)->transparent)
-			fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;
+			flow_flags |= FLOWI_FLAG_ANYSRC;
 		if (protocol == IPPROTO_TCP)
-			fl4.flowi4_flags |= FLOWI_FLAG_PRECOW_METRICS;
+			flow_flags |= FLOWI_FLAG_PRECOW_METRICS;
+		flowi4_init_output(&fl4, rt->rt_oif, rt->rt_mark, rt->rt_tos,
+				   RT_SCOPE_UNIVERSE, protocol, flow_flags,
+				   rt->rt_dst, rt->rt_src, dport, sport);
 		ip_rt_put(rt);
 		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
 		return ip_route_output_flow(sock_net(sk), &fl4, sk);

commit 6df59a84eccd4cad7fcefda3e0c5e55239a3b2dd
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Fri Mar 25 01:28:45 2011 -0700

    route: Take the right src and dst addresses in ip_route_newports
    
    When we set up the flow informations in ip_route_newports(), we take
    the address informations from the the rt_key_src and rt_key_dst fields
    of the rtable. They appear to be empty. So take the address
    informations from rt_src and rt_dst instead. This issue was introduced
    by commit 5e2b61f78411be25f0b84f97d5b5d312f184dfd1 ("ipv4: Remove
    flowi from struct rtable.")
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index dc102445ec47..f88429cad52a 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -270,8 +270,8 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 		struct flowi4 fl4 = {
 			.flowi4_oif = rt->rt_oif,
 			.flowi4_mark = rt->rt_mark,
-			.daddr = rt->rt_key_dst,
-			.saddr = rt->rt_key_src,
+			.daddr = rt->rt_dst,
+			.saddr = rt->rt_src,
 			.flowi4_tos = rt->rt_tos,
 			.flowi4_proto = protocol,
 			.fl4_sport = sport,

commit e6abbaa2725a43cf5d26c4c2a5dc6c0f6029ea19
Author: Julian Anastasov <ja@ssi.bg>
Date:   Sat Mar 19 12:13:49 2011 +0000

    ipv4: fix route deletion for IPs on many subnets
    
    Alex Sidorenko reported for problems with local
    routes left after IP addresses are deleted. It happens
    when same IPs are used in more than one subnet for the
    device.
    
            Fix fib_del_ifaddr to restrict the checks for duplicate
    local and broadcast addresses only to the IFAs that use
    our primary IFA or another primary IFA with same address.
    And we expect the prefsrc to be matched when the routes
    are deleted because it is possible they to differ only by
    prefsrc. This patch prevents local and broadcast routes
    to be leaked until their primary IP is deleted finally
    from the box.
    
            As the secondary address promotion needs to delete
    the routes for all secondaries that used the old primary IFA,
    add option to ignore these secondaries from the checks and
    to assume they are already deleted, so that we can safely
    delete the route while these IFAs are still on the device list.
    
    Reported-by: Alex Sidorenko <alexandre.sidorenko@hp.com>
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 30d6cae3841a..dc102445ec47 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -207,6 +207,7 @@ extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
 struct in_ifaddr;
 extern void fib_add_ifaddr(struct in_ifaddr *);
+extern void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
 
 static inline void ip_rt_put(struct rtable * rt)
 {

commit 9cce96df5b76691712dba22e83ff5efe900361e1
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 03:00:33 2011 -0500

    net: Put fl4_* macros to struct flowi4 and use them again.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 80b0353f4f41..30d6cae3841a 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -157,8 +157,8 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct sock
 		.saddr = saddr,
 		.flowi4_tos = tos,
 		.flowi4_proto = proto,
-		.uli.ports.dport = dport,
-		.uli.ports.sport = sport,
+		.fl4_dport = dport,
+		.fl4_sport = sport,
 	};
 	if (sk)
 		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
@@ -175,7 +175,7 @@ static inline struct rtable *ip_route_output_gre(struct net *net,
 		.saddr = saddr,
 		.flowi4_tos = tos,
 		.flowi4_proto = IPPROTO_GRE,
-		.uli.gre_key = gre_key,
+		.fl4_gre_key = gre_key,
 	};
 	return ip_route_output_key(net, &fl4);
 }
@@ -235,8 +235,8 @@ static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
 		.saddr = src,
 		.flowi4_tos = tos,
 		.flowi4_proto = protocol,
-		.uli.ports.sport = sport,
-		.uli.ports.dport = dport,
+		.fl4_sport = sport,
+		.fl4_dport = dport,
 	};
 	struct net *net = sock_net(sk);
 	struct rtable *rt;
@@ -273,8 +273,8 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 			.saddr = rt->rt_key_src,
 			.flowi4_tos = rt->rt_tos,
 			.flowi4_proto = protocol,
-			.uli.ports.sport = sport,
-			.uli.ports.dport = dport
+			.fl4_sport = sport,
+			.fl4_dport = dport
 		};
 		if (inet_sk(sk)->transparent)
 			fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;

commit 9d6ec938019c6b16cb9ec96598ebe8f20de435fe
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 01:12:47 2011 -0500

    ipv4: Use flowi4 in public route lookup interfaces.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 4c207f9fe0cb..80b0353f4f41 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -122,12 +122,12 @@ extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
-extern struct rtable *__ip_route_output_key(struct net *, const struct flowi *flp);
-extern struct rtable *ip_route_output_flow(struct net *, struct flowi *flp,
+extern struct rtable *__ip_route_output_key(struct net *, const struct flowi4 *flp);
+extern struct rtable *ip_route_output_flow(struct net *, struct flowi4 *flp,
 					   struct sock *sk);
 extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);
 
-static inline struct rtable *ip_route_output_key(struct net *net, struct flowi *flp)
+static inline struct rtable *ip_route_output_key(struct net *net, struct flowi4 *flp)
 {
 	return ip_route_output_flow(net, flp, NULL);
 }
@@ -135,13 +135,13 @@ static inline struct rtable *ip_route_output_key(struct net *net, struct flowi *
 static inline struct rtable *ip_route_output(struct net *net, __be32 daddr,
 					     __be32 saddr, u8 tos, int oif)
 {
-	struct flowi fl = {
-		.flowi_oif = oif,
-		.fl4_dst = daddr,
-		.fl4_src = saddr,
-		.fl4_tos = tos,
+	struct flowi4 fl4 = {
+		.flowi4_oif = oif,
+		.daddr = daddr,
+		.saddr = saddr,
+		.flowi4_tos = tos,
 	};
-	return ip_route_output_key(net, &fl);
+	return ip_route_output_key(net, &fl4);
 }
 
 static inline struct rtable *ip_route_output_ports(struct net *net, struct sock *sk,
@@ -149,35 +149,35 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct sock
 						   __be16 dport, __be16 sport,
 						   __u8 proto, __u8 tos, int oif)
 {
-	struct flowi fl = {
-		.flowi_oif = oif,
-		.flowi_flags = sk ? inet_sk_flowi_flags(sk) : 0,
-		.flowi_mark = sk ? sk->sk_mark : 0,
-		.fl4_dst = daddr,
-		.fl4_src = saddr,
-		.fl4_tos = tos,
-		.flowi_proto = proto,
-		.fl4_dport = dport,
-		.fl4_sport = sport,
+	struct flowi4 fl4 = {
+		.flowi4_oif = oif,
+		.flowi4_flags = sk ? inet_sk_flowi_flags(sk) : 0,
+		.flowi4_mark = sk ? sk->sk_mark : 0,
+		.daddr = daddr,
+		.saddr = saddr,
+		.flowi4_tos = tos,
+		.flowi4_proto = proto,
+		.uli.ports.dport = dport,
+		.uli.ports.sport = sport,
 	};
 	if (sk)
-		security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(net, &fl, sk);
+		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
+	return ip_route_output_flow(net, &fl4, sk);
 }
 
 static inline struct rtable *ip_route_output_gre(struct net *net,
 						 __be32 daddr, __be32 saddr,
 						 __be32 gre_key, __u8 tos, int oif)
 {
-	struct flowi fl = {
-		.flowi_oif = oif,
-		.fl4_dst = daddr,
-		.fl4_src = saddr,
-		.fl4_tos = tos,
-		.flowi_proto = IPPROTO_GRE,
-		.fl4_gre_key = gre_key,
+	struct flowi4 fl4 = {
+		.flowi4_oif = oif,
+		.daddr = daddr,
+		.saddr = saddr,
+		.flowi4_tos = tos,
+		.flowi4_proto = IPPROTO_GRE,
+		.uli.gre_key = gre_key,
 	};
-	return ip_route_output_key(net, &fl);
+	return ip_route_output_key(net, &fl4);
 }
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
@@ -228,36 +228,36 @@ static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
 					      __be16 sport, __be16 dport,
 					      struct sock *sk, bool can_sleep)
 {
-	struct flowi fl = {
-		.flowi_oif = oif,
-		.flowi_mark = sk->sk_mark,
-		.fl4_dst = dst,
-		.fl4_src = src,
-		.fl4_tos = tos,
-		.flowi_proto = protocol,
-		.fl4_sport = sport,
-		.fl4_dport = dport,
+	struct flowi4 fl4 = {
+		.flowi4_oif = oif,
+		.flowi4_mark = sk->sk_mark,
+		.daddr = dst,
+		.saddr = src,
+		.flowi4_tos = tos,
+		.flowi4_proto = protocol,
+		.uli.ports.sport = sport,
+		.uli.ports.dport = dport,
 	};
 	struct net *net = sock_net(sk);
 	struct rtable *rt;
 
 	if (inet_sk(sk)->transparent)
-		fl.flowi_flags |= FLOWI_FLAG_ANYSRC;
+		fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;
 	if (protocol == IPPROTO_TCP)
-		fl.flowi_flags |= FLOWI_FLAG_PRECOW_METRICS;
+		fl4.flowi4_flags |= FLOWI_FLAG_PRECOW_METRICS;
 	if (can_sleep)
-		fl.flowi_flags |= FLOWI_FLAG_CAN_SLEEP;
+		fl4.flowi4_flags |= FLOWI_FLAG_CAN_SLEEP;
 
 	if (!dst || !src) {
-		rt = __ip_route_output_key(net, &fl);
+		rt = __ip_route_output_key(net, &fl4);
 		if (IS_ERR(rt))
 			return rt;
-		fl.fl4_dst = rt->rt_dst;
-		fl.fl4_src = rt->rt_src;
+		fl4.daddr = rt->rt_dst;
+		fl4.saddr = rt->rt_src;
 		ip_rt_put(rt);
 	}
-	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(net, &fl, sk);
+	security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
+	return ip_route_output_flow(net, &fl4, sk);
 }
 
 static inline struct rtable *ip_route_newports(struct rtable *rt,
@@ -266,23 +266,23 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 					       __be16 dport, struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi fl = {
-			.flowi_oif = rt->rt_oif,
-			.flowi_mark = rt->rt_mark,
-			.fl4_dst = rt->rt_key_dst,
-			.fl4_src = rt->rt_key_src,
-			.fl4_tos = rt->rt_tos,
-			.flowi_proto = protocol,
-			.fl4_sport = sport,
-			.fl4_dport = dport
+		struct flowi4 fl4 = {
+			.flowi4_oif = rt->rt_oif,
+			.flowi4_mark = rt->rt_mark,
+			.daddr = rt->rt_key_dst,
+			.saddr = rt->rt_key_src,
+			.flowi4_tos = rt->rt_tos,
+			.flowi4_proto = protocol,
+			.uli.ports.sport = sport,
+			.uli.ports.dport = dport
 		};
 		if (inet_sk(sk)->transparent)
-			fl.flowi_flags |= FLOWI_FLAG_ANYSRC;
+			fl4.flowi4_flags |= FLOWI_FLAG_ANYSRC;
 		if (protocol == IPPROTO_TCP)
-			fl.flowi_flags |= FLOWI_FLAG_PRECOW_METRICS;
+			fl4.flowi4_flags |= FLOWI_FLAG_PRECOW_METRICS;
 		ip_rt_put(rt);
-		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(sock_net(sk), &fl, sk);
+		security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
+		return ip_route_output_flow(sock_net(sk), &fl4, sk);
 	}
 	return rt;
 }

commit 6281dcc94a96bd73017b2baa8fa83925405109ef
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 00:43:55 2011 -0500

    net: Make flowi ports AF dependent.
    
    Create two sets of port member accessors, one set prefixed by fl4_*
    and the other prefixed by fl6_*
    
    This will let us to create AF optimal flow instances.
    
    It will work because every context in which we access the ports,
    we have to be fully aware of which AF the flowi is anyways.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 3d814f84abd0..4c207f9fe0cb 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -157,8 +157,8 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct sock
 		.fl4_src = saddr,
 		.fl4_tos = tos,
 		.flowi_proto = proto,
-		.fl_ip_dport = dport,
-		.fl_ip_sport = sport,
+		.fl4_dport = dport,
+		.fl4_sport = sport,
 	};
 	if (sk)
 		security_sk_classify_flow(sk, &fl);
@@ -175,7 +175,7 @@ static inline struct rtable *ip_route_output_gre(struct net *net,
 		.fl4_src = saddr,
 		.fl4_tos = tos,
 		.flowi_proto = IPPROTO_GRE,
-		.fl_gre_key = gre_key,
+		.fl4_gre_key = gre_key,
 	};
 	return ip_route_output_key(net, &fl);
 }
@@ -228,14 +228,16 @@ static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
 					      __be16 sport, __be16 dport,
 					      struct sock *sk, bool can_sleep)
 {
-	struct flowi fl = { .flowi_oif = oif,
-			    .flowi_mark = sk->sk_mark,
-			    .fl4_dst = dst,
-			    .fl4_src = src,
-			    .fl4_tos = tos,
-			    .flowi_proto = protocol,
-			    .fl_ip_sport = sport,
-			    .fl_ip_dport = dport };
+	struct flowi fl = {
+		.flowi_oif = oif,
+		.flowi_mark = sk->sk_mark,
+		.fl4_dst = dst,
+		.fl4_src = src,
+		.fl4_tos = tos,
+		.flowi_proto = protocol,
+		.fl4_sport = sport,
+		.fl4_dport = dport,
+	};
 	struct net *net = sock_net(sk);
 	struct rtable *rt;
 
@@ -264,15 +266,16 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 					       __be16 dport, struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi fl = { .flowi_oif = rt->rt_oif,
-				    .flowi_mark = rt->rt_mark,
-				    .fl4_dst = rt->rt_key_dst,
-				    .fl4_src = rt->rt_key_src,
-				    .fl4_tos = rt->rt_tos,
-				    .flowi_proto = protocol,
-				    .fl_ip_sport = sport,
-				    .fl_ip_dport = dport };
-
+		struct flowi fl = {
+			.flowi_oif = rt->rt_oif,
+			.flowi_mark = rt->rt_mark,
+			.fl4_dst = rt->rt_key_dst,
+			.fl4_src = rt->rt_key_src,
+			.fl4_tos = rt->rt_tos,
+			.flowi_proto = protocol,
+			.fl4_sport = sport,
+			.fl4_dport = dport
+		};
 		if (inet_sk(sk)->transparent)
 			fl.flowi_flags |= FLOWI_FLAG_ANYSRC;
 		if (protocol == IPPROTO_TCP)

commit 1d28f42c1bd4bb2363d88df74d0128b4da135b4a
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 00:29:39 2011 -0500

    net: Put flowi_* prefix on AF independent members of struct flowi
    
    I intend to turn struct flowi into a union of AF specific flowi
    structs.  There will be a common structure that each variant includes
    first, much like struct sock_common.
    
    This is the first step to move in that direction.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index f140f4130fea..3d814f84abd0 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -136,7 +136,7 @@ static inline struct rtable *ip_route_output(struct net *net, __be32 daddr,
 					     __be32 saddr, u8 tos, int oif)
 {
 	struct flowi fl = {
-		.oif = oif,
+		.flowi_oif = oif,
 		.fl4_dst = daddr,
 		.fl4_src = saddr,
 		.fl4_tos = tos,
@@ -150,13 +150,13 @@ static inline struct rtable *ip_route_output_ports(struct net *net, struct sock
 						   __u8 proto, __u8 tos, int oif)
 {
 	struct flowi fl = {
-		.oif = oif,
-		.flags = sk ? inet_sk_flowi_flags(sk) : 0,
-		.mark = sk ? sk->sk_mark : 0,
+		.flowi_oif = oif,
+		.flowi_flags = sk ? inet_sk_flowi_flags(sk) : 0,
+		.flowi_mark = sk ? sk->sk_mark : 0,
 		.fl4_dst = daddr,
 		.fl4_src = saddr,
 		.fl4_tos = tos,
-		.proto = proto,
+		.flowi_proto = proto,
 		.fl_ip_dport = dport,
 		.fl_ip_sport = sport,
 	};
@@ -170,11 +170,11 @@ static inline struct rtable *ip_route_output_gre(struct net *net,
 						 __be32 gre_key, __u8 tos, int oif)
 {
 	struct flowi fl = {
-		.oif = oif,
+		.flowi_oif = oif,
 		.fl4_dst = daddr,
 		.fl4_src = saddr,
 		.fl4_tos = tos,
-		.proto = IPPROTO_GRE,
+		.flowi_proto = IPPROTO_GRE,
 		.fl_gre_key = gre_key,
 	};
 	return ip_route_output_key(net, &fl);
@@ -228,23 +228,23 @@ static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
 					      __be16 sport, __be16 dport,
 					      struct sock *sk, bool can_sleep)
 {
-	struct flowi fl = { .oif = oif,
-			    .mark = sk->sk_mark,
+	struct flowi fl = { .flowi_oif = oif,
+			    .flowi_mark = sk->sk_mark,
 			    .fl4_dst = dst,
 			    .fl4_src = src,
 			    .fl4_tos = tos,
-			    .proto = protocol,
+			    .flowi_proto = protocol,
 			    .fl_ip_sport = sport,
 			    .fl_ip_dport = dport };
 	struct net *net = sock_net(sk);
 	struct rtable *rt;
 
 	if (inet_sk(sk)->transparent)
-		fl.flags |= FLOWI_FLAG_ANYSRC;
+		fl.flowi_flags |= FLOWI_FLAG_ANYSRC;
 	if (protocol == IPPROTO_TCP)
-		fl.flags |= FLOWI_FLAG_PRECOW_METRICS;
+		fl.flowi_flags |= FLOWI_FLAG_PRECOW_METRICS;
 	if (can_sleep)
-		fl.flags |= FLOWI_FLAG_CAN_SLEEP;
+		fl.flowi_flags |= FLOWI_FLAG_CAN_SLEEP;
 
 	if (!dst || !src) {
 		rt = __ip_route_output_key(net, &fl);
@@ -264,19 +264,19 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 					       __be16 dport, struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi fl = { .oif = rt->rt_oif,
-				    .mark = rt->rt_mark,
+		struct flowi fl = { .flowi_oif = rt->rt_oif,
+				    .flowi_mark = rt->rt_mark,
 				    .fl4_dst = rt->rt_key_dst,
 				    .fl4_src = rt->rt_key_src,
 				    .fl4_tos = rt->rt_tos,
-				    .proto = protocol,
+				    .flowi_proto = protocol,
 				    .fl_ip_sport = sport,
 				    .fl_ip_dport = dport };
 
 		if (inet_sk(sk)->transparent)
-			fl.flags |= FLOWI_FLAG_ANYSRC;
+			fl.flowi_flags |= FLOWI_FLAG_ANYSRC;
 		if (protocol == IPPROTO_TCP)
-			fl.flags |= FLOWI_FLAG_PRECOW_METRICS;
+			fl.flowi_flags |= FLOWI_FLAG_PRECOW_METRICS;
 		ip_rt_put(rt);
 		security_sk_classify_flow(sk, &fl);
 		return ip_route_output_flow(sock_net(sk), &fl, sk);

commit 78fbfd8a653ca972afe479517a40661bfff6d8c3
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 00:00:52 2011 -0500

    ipv4: Create and use route lookup helpers.
    
    The idea here is this minimizes the number of places one has to edit
    in order to make changes to how flows are defined and used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9257f5f17337..f140f4130fea 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -132,6 +132,54 @@ static inline struct rtable *ip_route_output_key(struct net *net, struct flowi *
 	return ip_route_output_flow(net, flp, NULL);
 }
 
+static inline struct rtable *ip_route_output(struct net *net, __be32 daddr,
+					     __be32 saddr, u8 tos, int oif)
+{
+	struct flowi fl = {
+		.oif = oif,
+		.fl4_dst = daddr,
+		.fl4_src = saddr,
+		.fl4_tos = tos,
+	};
+	return ip_route_output_key(net, &fl);
+}
+
+static inline struct rtable *ip_route_output_ports(struct net *net, struct sock *sk,
+						   __be32 daddr, __be32 saddr,
+						   __be16 dport, __be16 sport,
+						   __u8 proto, __u8 tos, int oif)
+{
+	struct flowi fl = {
+		.oif = oif,
+		.flags = sk ? inet_sk_flowi_flags(sk) : 0,
+		.mark = sk ? sk->sk_mark : 0,
+		.fl4_dst = daddr,
+		.fl4_src = saddr,
+		.fl4_tos = tos,
+		.proto = proto,
+		.fl_ip_dport = dport,
+		.fl_ip_sport = sport,
+	};
+	if (sk)
+		security_sk_classify_flow(sk, &fl);
+	return ip_route_output_flow(net, &fl, sk);
+}
+
+static inline struct rtable *ip_route_output_gre(struct net *net,
+						 __be32 daddr, __be32 saddr,
+						 __be32 gre_key, __u8 tos, int oif)
+{
+	struct flowi fl = {
+		.oif = oif,
+		.fl4_dst = daddr,
+		.fl4_src = saddr,
+		.fl4_tos = tos,
+		.proto = IPPROTO_GRE,
+		.fl_gre_key = gre_key,
+	};
+	return ip_route_output_key(net, &fl);
+}
+
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin, bool noref);
 

commit 5e2b61f78411be25f0b84f97d5b5d312f184dfd1
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 4 21:47:09 2011 -0800

    ipv4: Remove flowi from struct rtable.
    
    The only necessary parts are the src/dst addresses, the
    interface indexes, the TOS, and the mark.
    
    The rest is unnecessary bloat, which amounts to nearly
    50 bytes on 64-bit.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 8905d90e0044..9257f5f17337 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -53,16 +53,20 @@ struct fib_info;
 struct rtable {
 	struct dst_entry	dst;
 
-	/* Cache lookup keys */
-	struct flowi		fl;
+	/* Lookup key. */
+	__be32			rt_key_dst;
+	__be32			rt_key_src;
 
 	int			rt_genid;
 	unsigned		rt_flags;
 	__u16			rt_type;
+	__u8			rt_tos;
 
 	__be32			rt_dst;	/* Path destination	*/
 	__be32			rt_src;	/* Path source		*/
 	int			rt_iif;
+	int			rt_oif;
+	__u32			rt_mark;
 
 	/* Info on neighbour */
 	__be32			rt_gateway;
@@ -76,12 +80,12 @@ struct rtable {
 
 static inline bool rt_is_input_route(struct rtable *rt)
 {
-	return rt->fl.iif != 0;
+	return rt->rt_iif != 0;
 }
 
 static inline bool rt_is_output_route(struct rtable *rt)
 {
-	return rt->fl.iif == 0;
+	return rt->rt_iif == 0;
 }
 
 struct ip_rt_acct {
@@ -212,11 +216,11 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 					       __be16 dport, struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi fl = { .oif = rt->fl.oif,
-				    .mark = rt->fl.mark,
-				    .fl4_dst = rt->fl.fl4_dst,
-				    .fl4_src = rt->fl.fl4_src,
-				    .fl4_tos = rt->fl.fl4_tos,
+		struct flowi fl = { .oif = rt->rt_oif,
+				    .mark = rt->rt_mark,
+				    .fl4_dst = rt->rt_key_dst,
+				    .fl4_src = rt->rt_key_src,
+				    .fl4_tos = rt->rt_tos,
 				    .proto = protocol,
 				    .fl_ip_sport = sport,
 				    .fl_ip_dport = dport };

commit 4157434c23f8f5126a2ffd3cc7b2c3bd928be075
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Mar 4 21:31:48 2011 -0800

    ipv4: Use passed-in protocol in ip_route_newports().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 60daf745216a..8905d90e0044 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -217,7 +217,7 @@ static inline struct rtable *ip_route_newports(struct rtable *rt,
 				    .fl4_dst = rt->fl.fl4_dst,
 				    .fl4_src = rt->fl.fl4_src,
 				    .fl4_tos = rt->fl.fl4_tos,
-				    .proto = rt->fl.proto,
+				    .proto = protocol,
 				    .fl_ip_sport = sport,
 				    .fl_ip_dport = dport };
 

commit 5bfa787fb2c29cce0722500f90df29e049ff07fc
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Mar 2 14:56:30 2011 -0800

    ipv4: ip_route_output_key() is better as an inline.
    
    This avoid a stack frame at zero cost.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 088a1867348f..60daf745216a 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -119,11 +119,15 @@ extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
 extern struct rtable *__ip_route_output_key(struct net *, const struct flowi *flp);
-extern struct rtable *ip_route_output_key(struct net *, struct flowi *flp);
 extern struct rtable *ip_route_output_flow(struct net *, struct flowi *flp,
 					   struct sock *sk);
 extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);
 
+static inline struct rtable *ip_route_output_key(struct net *net, struct flowi *flp)
+{
+	return ip_route_output_flow(net, flp, NULL);
+}
+
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin, bool noref);
 

commit b23dd4fe42b455af5c6e20966b7d6959fa8352ea
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Mar 2 14:31:35 2011 -0800

    ipv4: Make output route lookup return rtable directly.
    
    Instead of on the stack.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 707cfc8eccdc..088a1867348f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -118,9 +118,10 @@ extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
-extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
-extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
-extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk);
+extern struct rtable *__ip_route_output_key(struct net *, const struct flowi *flp);
+extern struct rtable *ip_route_output_key(struct net *, struct flowi *flp);
+extern struct rtable *ip_route_output_flow(struct net *, struct flowi *flp,
+					   struct sock *sk);
 extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
@@ -166,10 +167,10 @@ static inline char rt_tos2priority(u8 tos)
 	return ip_tos2prio[IPTOS_TOS(tos)>>1];
 }
 
-static inline int ip_route_connect(struct rtable **rp, __be32 dst,
-				   __be32 src, u32 tos, int oif, u8 protocol,
-				   __be16 sport, __be16 dport, struct sock *sk,
-				   bool can_sleep)
+static inline struct rtable *ip_route_connect(__be32 dst, __be32 src, u32 tos,
+					      int oif, u8 protocol,
+					      __be16 sport, __be16 dport,
+					      struct sock *sk, bool can_sleep)
 {
 	struct flowi fl = { .oif = oif,
 			    .mark = sk->sk_mark,
@@ -179,8 +180,8 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 			    .proto = protocol,
 			    .fl_ip_sport = sport,
 			    .fl_ip_dport = dport };
-	int err;
 	struct net *net = sock_net(sk);
+	struct rtable *rt;
 
 	if (inet_sk(sk)->transparent)
 		fl.flags |= FLOWI_FLAG_ANYSRC;
@@ -190,29 +191,29 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		fl.flags |= FLOWI_FLAG_CAN_SLEEP;
 
 	if (!dst || !src) {
-		err = __ip_route_output_key(net, rp, &fl);
-		if (err)
-			return err;
-		fl.fl4_dst = (*rp)->rt_dst;
-		fl.fl4_src = (*rp)->rt_src;
-		ip_rt_put(*rp);
-		*rp = NULL;
+		rt = __ip_route_output_key(net, &fl);
+		if (IS_ERR(rt))
+			return rt;
+		fl.fl4_dst = rt->rt_dst;
+		fl.fl4_src = rt->rt_src;
+		ip_rt_put(rt);
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(net, rp, &fl, sk);
+	return ip_route_output_flow(net, &fl, sk);
 }
 
-static inline int ip_route_newports(struct rtable **rp, u8 protocol,
-				    __be16 orig_sport, __be16 orig_dport,
-				    __be16 sport, __be16 dport, struct sock *sk)
+static inline struct rtable *ip_route_newports(struct rtable *rt,
+					       u8 protocol, __be16 orig_sport,
+					       __be16 orig_dport, __be16 sport,
+					       __be16 dport, struct sock *sk)
 {
 	if (sport != orig_sport || dport != orig_dport) {
-		struct flowi fl = { .oif = (*rp)->fl.oif,
-				    .mark = (*rp)->fl.mark,
-				    .fl4_dst = (*rp)->fl.fl4_dst,
-				    .fl4_src = (*rp)->fl.fl4_src,
-				    .fl4_tos = (*rp)->fl.fl4_tos,
-				    .proto = (*rp)->fl.proto,
+		struct flowi fl = { .oif = rt->fl.oif,
+				    .mark = rt->fl.mark,
+				    .fl4_dst = rt->fl.fl4_dst,
+				    .fl4_src = rt->fl.fl4_src,
+				    .fl4_tos = rt->fl.fl4_tos,
+				    .proto = rt->fl.proto,
 				    .fl_ip_sport = sport,
 				    .fl_ip_dport = dport };
 
@@ -220,12 +221,11 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 			fl.flags |= FLOWI_FLAG_ANYSRC;
 		if (protocol == IPPROTO_TCP)
 			fl.flags |= FLOWI_FLAG_PRECOW_METRICS;
-		ip_rt_put(*rp);
-		*rp = NULL;
+		ip_rt_put(rt);
 		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(sock_net(sk), rp, &fl, sk);
+		return ip_route_output_flow(sock_net(sk), &fl, sk);
 	}
-	return 0;
+	return rt;
 }
 
 extern void rt_bind_peer(struct rtable *rt, int create);

commit 2774c131b1d19920b4587db1cfbd6f0750ad1f15
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 1 14:59:04 2011 -0800

    xfrm: Handle blackhole route creation via afinfo.
    
    That way we don't have to potentially do this in every xfrm_lookup()
    caller.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 923e670586d4..707cfc8eccdc 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -121,6 +121,7 @@ extern void		rt_cache_flush_batch(struct net *net);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk);
+extern struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig);
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin, bool noref);

commit 273447b352e69c327efdecfd6e1d6fe3edbdcd14
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 1 14:27:04 2011 -0800

    ipv4: Kill can_sleep arg to ip_route_output_flow()
    
    This boolean state is now available in the flow flags.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 1be5c05a0905..923e670586d4 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -120,7 +120,7 @@ extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
-extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, bool can_sleep);
+extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk);
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin, bool noref);
@@ -198,7 +198,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		*rp = NULL;
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(net, rp, &fl, sk, can_sleep);
+	return ip_route_output_flow(net, rp, &fl, sk);
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,
@@ -222,7 +222,7 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(sock_net(sk), rp, &fl, sk, false);
+		return ip_route_output_flow(sock_net(sk), rp, &fl, sk);
 	}
 	return 0;
 }

commit 5df65e5567a497a28067019b8ff08f98fb026629
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 1 14:22:19 2011 -0800

    net: Add FLOWI_FLAG_CAN_SLEEP.
    
    And set is in contexts where the route resolution can sleep.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6de4333d6002..1be5c05a0905 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -185,6 +185,8 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		fl.flags |= FLOWI_FLAG_ANYSRC;
 	if (protocol == IPPROTO_TCP)
 		fl.flags |= FLOWI_FLAG_PRECOW_METRICS;
+	if (can_sleep)
+		fl.flags |= FLOWI_FLAG_CAN_SLEEP;
 
 	if (!dst || !src) {
 		err = __ip_route_output_key(net, rp, &fl);

commit 420d44daa7aa1cc847e9e527f0a27a9ce61768ca
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 1 14:19:23 2011 -0800

    ipv4: Make final arg to ip_route_output_flow to be boolean "can_sleep"
    
    Since that is what the current vague "flags" argument means.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5e0826d1c0e0..6de4333d6002 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -120,7 +120,7 @@ extern void		rt_cache_flush(struct net *net, int how);
 extern void		rt_cache_flush_batch(struct net *net);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
-extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
+extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, bool can_sleep);
 
 extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
 				 u8 tos, struct net_device *devin, bool noref);
@@ -196,7 +196,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		*rp = NULL;
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(net, rp, &fl, sk, can_sleep ? 1 : 0);
+	return ip_route_output_flow(net, rp, &fl, sk, can_sleep);
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,
@@ -220,7 +220,7 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(sock_net(sk), rp, &fl, sk, 0);
+		return ip_route_output_flow(sock_net(sk), rp, &fl, sk, false);
 	}
 	return 0;
 }

commit abdf7e7239da270e68262728f125ea94b9b7d42d
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 1 14:15:24 2011 -0800

    ipv4: Can final ip_route_connect() arg to boolean "can_sleep".
    
    Since that's what the current vague "flags" thing means.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b3f89ad04e0b..5e0826d1c0e0 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -168,7 +168,7 @@ static inline char rt_tos2priority(u8 tos)
 static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 				   __be32 src, u32 tos, int oif, u8 protocol,
 				   __be16 sport, __be16 dport, struct sock *sk,
-				   int flags)
+				   bool can_sleep)
 {
 	struct flowi fl = { .oif = oif,
 			    .mark = sk->sk_mark,
@@ -196,7 +196,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		*rp = NULL;
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(net, rp, &fl, sk, flags);
+	return ip_route_output_flow(net, rp, &fl, sk, can_sleep ? 1 : 0);
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,

commit dca8b089c95d94afa1d715df257de0286350e99d
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Feb 24 13:38:12 2011 -0800

    ipv4: Rearrange how ip_route_newports() gets port keys.
    
    ip_route_newports() is the only place in the entire kernel that
    cares about the port members in the routing cache entry's lookup
    flow key.
    
    Therefore the only reason we store an entire flow inside of the
    struct rtentry is for this one special case.
    
    Rewrite ip_route_newports() such that:
    
    1) The caller passes in the original port values, so we don't need
       to use the rth->fl.fl_ip_{s,d}port values to remember them.
    
    2) The lookup flow is constructed by hand instead of being copied
       from the routing cache entry's flow.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index bf790c1c6ac8..b3f89ad04e0b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -200,16 +200,19 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,
+				    __be16 orig_sport, __be16 orig_dport,
 				    __be16 sport, __be16 dport, struct sock *sk)
 {
-	if (sport != (*rp)->fl.fl_ip_sport ||
-	    dport != (*rp)->fl.fl_ip_dport) {
-		struct flowi fl;
-
-		memcpy(&fl, &(*rp)->fl, sizeof(fl));
-		fl.fl_ip_sport = sport;
-		fl.fl_ip_dport = dport;
-		fl.proto = protocol;
+	if (sport != orig_sport || dport != orig_dport) {
+		struct flowi fl = { .oif = (*rp)->fl.oif,
+				    .mark = (*rp)->fl.mark,
+				    .fl4_dst = (*rp)->fl.fl4_dst,
+				    .fl4_src = (*rp)->fl.fl4_src,
+				    .fl4_tos = (*rp)->fl.fl4_tos,
+				    .proto = (*rp)->fl.proto,
+				    .fl_ip_sport = sport,
+				    .fl_ip_dport = dport };
+
 		if (inet_sk(sk)->transparent)
 			fl.flags |= FLOWI_FLAG_ANYSRC;
 		if (protocol == IPPROTO_TCP)

commit 6431cbc25fa21635ee04eb0516ba6c51389fbfac
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Feb 7 20:38:06 2011 -0800

    inet: Create a mechanism for upward inetpeer propagation into routes.
    
    If we didn't have a routing cache, we would not be able to properly
    propagate certain kinds of dynamic path attributes, for example
    PMTU information and redirects.
    
    The reason is that if we didn't have a routing cache, then there would
    be no way to lookup all of the active cached routes hanging off of
    sockets, tunnels, IPSEC bundles, etc.
    
    Consider the case where we created a cached route, but no inetpeer
    entry existed and also we were not asked to pre-COW the route metrics
    and therefore did not force the creation a new inetpeer entry.
    
    If we later get a PMTU message, or a redirect, and store this
    information in a new inetpeer entry, there is no way to teach that
    cached route about the newly existing inetpeer entry.
    
    The facilities implemented here handle this problem.
    
    First we create a generation ID.  When we create a cached route of any
    kind, we remember the generation ID at the time of attachment.  Any
    time we force-create an inetpeer entry in response to new path
    information, we bump that generation ID.
    
    The dst_ops->check() callback is where the knowledge of this event
    is propagated.  If the global generation ID does not equal the one
    stored in the cached route, and the cached route has not attached
    to an inetpeer yet, we look it up and attach if one is found.  Now
    that we've updated the cached route's information, we update the
    route's generation ID too.
    
    This clears the way for implementing PMTU and redirects directly in
    the inetpeer cache.  There is absolutely no need to consult cached
    route information in order to maintain this information.
    
    At this point nothing bumps the inetpeer genids, that comes in the
    later changes which handle PMTUs and redirects using inetpeers.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index e5864658dc76..bf790c1c6ac8 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -69,6 +69,7 @@ struct rtable {
 
 	/* Miscellaneous cached information */
 	__be32			rt_spec_dst; /* RFC1122 specific destination */
+	u32			rt_peer_genid;
 	struct inet_peer	*peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */
 };

commit a4daad6b0923030fbd3b00a01f570e4c3eef446b
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jan 27 22:01:53 2011 -0800

    net: Pre-COW metrics for TCP.
    
    TCP is going to record metrics for the connection,
    so pre-COW the route metrics at route cache entry
    creation time.
    
    This avoids several atomic operations that have to
    occur if we COW the metrics after the entry reaches
    global visibility.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5677cbf0c6e6..e5864658dc76 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -182,6 +182,8 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 
 	if (inet_sk(sk)->transparent)
 		fl.flags |= FLOWI_FLAG_ANYSRC;
+	if (protocol == IPPROTO_TCP)
+		fl.flags |= FLOWI_FLAG_PRECOW_METRICS;
 
 	if (!dst || !src) {
 		err = __ip_route_output_key(net, rp, &fl);
@@ -209,6 +211,8 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		fl.proto = protocol;
 		if (inet_sk(sk)->transparent)
 			fl.flags |= FLOWI_FLAG_ANYSRC;
+		if (protocol == IPPROTO_TCP)
+			fl.flags |= FLOWI_FLAG_PRECOW_METRICS;
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);

commit 62fa8a846d7de4b299232e330c74b7783539df76
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jan 26 20:51:05 2011 -0800

    net: Implement read-only protection and COW'ing of metrics.
    
    Routing metrics are now copy-on-write.
    
    Initially a route entry points it's metrics at a read-only location.
    If a routing table entry exists, it will point there.  Else it will
    point at the all zero metric place-holder called 'dst_default_metrics'.
    
    The writeability state of the metrics is stored in the low bits of the
    metrics pointer, we have two bits left to spare if we want to store
    more states.
    
    For the initial implementation, COW is implemented simply via kmalloc.
    However future enhancements will change this to place the writable
    metrics somewhere else, in order to increase sharing.  Very likely
    this "somewhere else" will be the inetpeer cache.
    
    Note also that this means that metrics updates may transiently fail
    if we cannot COW the metrics successfully.
    
    But even by itself, this patch should decrease memory usage and
    increase cache locality especially for routing workloads.  In those
    cases the read-only metric copies stay in place and never get written
    to.
    
    TCP workloads where metrics get updated, and those rare cases where
    PMTU triggers occur, will take a very slight performance hit.  But
    that hit will be alleviated when the long-term writable metrics
    move to a more sharable location.
    
    Since the metrics storage went from a u32 array of RTAX_MAX entries to
    what is essentially a pointer, some retooling of the dst_entry layout
    was necessary.
    
    Most importantly, we need to preserve the alignment of the reference
    count so that it doesn't share cache lines with the read-mostly state,
    as per Eric Dumazet's alignment assertion checks.
    
    The only non-trivial bit here is the move of the 'flags' member into
    the writeable cacheline.  This is OK since we are always accessing the
    flags around the same moment when we made a modification to the
    reference count.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 93e10c453f6b..5677cbf0c6e6 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -49,6 +49,7 @@
 
 struct fib_nh;
 struct inet_peer;
+struct fib_info;
 struct rtable {
 	struct dst_entry	dst;
 
@@ -69,6 +70,7 @@ struct rtable {
 	/* Miscellaneous cached information */
 	__be32			rt_spec_dst; /* RFC1122 specific destination */
 	struct inet_peer	*peer; /* long-living peer info */
+	struct fib_info		*fi; /* for client ref to shared metrics */
 };
 
 static inline bool rt_is_input_route(struct rtable *rt)

commit 6561a3b12d62ed5317e6ac32182d87a03f62c8dc
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Dec 19 21:11:20 2010 -0800

    ipv4: Flush per-ns routing cache more sanely.
    
    Flush the routing cache only of entries that match the
    network namespace in which the purge event occurred.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>

diff --git a/include/net/route.h b/include/net/route.h
index 27002362944a..93e10c453f6b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -114,7 +114,7 @@ extern int		ip_rt_init(void);
 extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(struct net *net, int how);
-extern void		rt_cache_flush_batch(void);
+extern void		rt_cache_flush_batch(struct net *net);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);

commit 323e126f0c5995f779d7df7fd035f6e8fed8764d
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Dec 12 21:55:08 2010 -0800

    ipv4: Don't pre-seed hoplimit metric.
    
    Always go through a new ip4_dst_hoplimit() helper, just like ipv6.
    
    This allowed several simplifications:
    
    1) The interim dst_metric_hoplimit() can go as it's no longer
       userd.
    
    2) The sysctl_ip_default_ttl entry no longer needs to use
       ipv4_doint_and_flush, since the sysctl is not cached in
       routing cache metrics any longer.
    
    3) ipv4_doint_and_flush no longer needs to be exported and
       therefore can be marked static.
    
    When ipv4_doint_and_flush_strategy was removed some time ago,
    the external declaration in ip.h was mistakenly left around
    so kill that off too.
    
    We have to move the sysctl_ip_default_ttl declaration into
    ipv4's route cache definition header net/route.h, because
    currently net/ip.h (where the declaration lives now) has
    a back dependency on net/route.h
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b8c1f7703fc6..27002362944a 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -231,4 +231,15 @@ static inline int inet_iif(const struct sk_buff *skb)
 	return skb_rtable(skb)->rt_iif;
 }
 
+extern int sysctl_ip_default_ttl;
+
+static inline int ip4_dst_hoplimit(const struct dst_entry *dst)
+{
+	int hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);
+
+	if (hoplimit == 0)
+		hoplimit = sysctl_ip_default_ttl;
+	return hoplimit;
+}
+
 #endif	/* _ROUTE_H */

commit 5811662b15db018c740c57d037523683fd3e6123
Author: Changli Gao <xiaosuo@gmail.com>
Date:   Fri Nov 12 18:43:55 2010 +0000

    net: use the macros defined for the members of flowi
    
    Use the macros defined for the members of flowi to clean the code up.
    
    Signed-off-by: Changli Gao <xiaosuo@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5cd46d1c0e14..b8c1f7703fc6 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -169,14 +169,12 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 {
 	struct flowi fl = { .oif = oif,
 			    .mark = sk->sk_mark,
-			    .nl_u = { .ip4_u = { .daddr = dst,
-						 .saddr = src,
-						 .tos   = tos } },
+			    .fl4_dst = dst,
+			    .fl4_src = src,
+			    .fl4_tos = tos,
 			    .proto = protocol,
-			    .uli_u = { .ports =
-				       { .sport = sport,
-					 .dport = dport } } };
-
+			    .fl_ip_sport = sport,
+			    .fl_ip_dport = dport };
 	int err;
 	struct net *net = sock_net(sk);
 

commit c753796769e4fb0cd813b6e5801b3c01f4681d4f
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Nov 11 17:07:48 2010 -0800

    ipv4: Make rt->fl.iif tests lest obscure.
    
    When we test rt->fl.iif against zero, we're seeing if it's
    an output or an input route.
    
    Make that explicit with some helper functions.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index cea533eaa853..5cd46d1c0e14 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -71,6 +71,16 @@ struct rtable {
 	struct inet_peer	*peer; /* long-living peer info */
 };
 
+static inline bool rt_is_input_route(struct rtable *rt)
+{
+	return rt->fl.iif != 0;
+}
+
+static inline bool rt_is_output_route(struct rtable *rt)
+{
+	return rt->fl.iif == 0;
+}
+
 struct ip_rt_acct {
 	__u32 	o_bytes;
 	__u32 	o_packets;

commit 72cdd1d971c0deb1619c5c339270570c43647a78
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Nov 11 07:14:07 2010 +0000

    net: get rid of rtable->idev
    
    It seems idev field in struct rtable has no special purpose, but adding
    extra atomic ops.
    
    We hold refcounts on the device itself (using percpu data, so pretty
    cheap in current kernel).
    
    infiniband case is solved using dst.dev instead of idev->dev
    
    Removal of this field means routing without route cache is now using
    shared data, percpu data, and only potential contention is a pair of
    atomic ops on struct neighbour per forwarded packet.
    
    About 5% speedup on routing test.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 7e5e73bfa4de..cea533eaa853 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -55,8 +55,6 @@ struct rtable {
 	/* Cache lookup keys */
 	struct flowi		fl;
 
-	struct in_device	*idev;
-	
 	int			rt_genid;
 	unsigned		rt_flags;
 	__u16			rt_type;

commit fb0c5f0bc8b69b40549449ee7fc65f3706f12062
Author: Ulrich Weber <uweber@astaro.com>
Date:   Mon Sep 27 03:31:00 2010 +0000

    tproxy: check for transparent flag in ip_route_newports
    
    as done in ip_route_connect()
    
    Signed-off-by: Ulrich Weber <uweber@astaro.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index bd732d62e1c3..7e5e73bfa4de 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -199,6 +199,8 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		fl.fl_ip_sport = sport;
 		fl.fl_ip_dport = dport;
 		fl.proto = protocol;
+		if (inet_sk(sk)->transparent)
+			fl.flags |= FLOWI_FLAG_ANYSRC;
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);

commit d8d1f30b95a635dbd610dcc5eb641aca8f4768cf
Author: Changli Gao <xiaosuo@gmail.com>
Date:   Thu Jun 10 23:31:35 2010 -0700

    net-next: remove useless union keyword
    
    remove useless union keyword in rtable, rt6_info and dn_route.
    
    Since there is only one member in a union, the union keyword isn't useful.
    
    Signed-off-by: Changli Gao <xiaosuo@gmail.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index af6cf4b4c9dc..bd732d62e1c3 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -50,9 +50,7 @@
 struct fib_nh;
 struct inet_peer;
 struct rtable {
-	union {
-		struct dst_entry	dst;
-	} u;
+	struct dst_entry	dst;
 
 	/* Cache lookup keys */
 	struct flowi		fl;
@@ -144,7 +142,7 @@ extern void fib_add_ifaddr(struct in_ifaddr *);
 static inline void ip_rt_put(struct rtable * rt)
 {
 	if (rt)
-		dst_release(&rt->u.dst);
+		dst_release(&rt->dst);
 }
 
 #define IPTOS_RT_MASK	(IPTOS_TOS_MASK & ~3)

commit 407eadd996dc62a827db85f1d0c286a98fd5d336
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon May 10 11:32:55 2010 +0000

    net: implements ip_route_input_noref()
    
    ip_route_input() is the version returning a refcounted dst, while
    ip_route_input_noref() returns a non refcounted one.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 2c9fba7f7731..af6cf4b4c9dc 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -112,7 +112,22 @@ extern void		rt_cache_flush_batch(void);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
-extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
+
+extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src,
+				 u8 tos, struct net_device *devin, bool noref);
+
+static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src,
+				 u8 tos, struct net_device *devin)
+{
+	return ip_route_input_common(skb, dst, src, tos, devin, false);
+}
+
+static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src,
+				       u8 tos, struct net_device *devin)
+{
+	return ip_route_input_common(skb, dst, src, tos, devin, true);
+}
+
 extern unsigned short	ip_rt_frag_needed(struct net *net, struct iphdr *iph, unsigned short new_mtu, struct net_device *dev);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 

commit 7d720c3e4f0c4fc152a6bf17e24244a3c85412d2
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Feb 16 15:20:26 2010 +0000

    percpu: add __percpu sparse annotations to net
    
    Add __percpu sparse annotations to net.
    
    These annotations are to make sparse consider percpu variables to be
    in a different address space and warn if accessed without going
    through percpu accessors.  This patch doesn't affect normal builds.
    
    The macro and type tricks around snmp stats make things a bit
    interesting.  DEFINE/DECLARE_SNMP_STAT() macros mark the target field
    as __percpu and SNMP_UPD_PO_STATS() macro is updated accordingly.  All
    snmp_mib_*() users which used to cast the argument to (void **) are
    updated to cast it to (void __percpu **).
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: Vlad Yasevich <vladislav.yasevich@hp.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index bce6dd68d27b..2c9fba7f7731 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -101,7 +101,7 @@ struct rt_cache_stat {
         unsigned int out_hlist_search;
 };
 
-extern struct ip_rt_acct *ip_rt_acct;
+extern struct ip_rt_acct __percpu *ip_rt_acct;
 
 struct in_device;
 extern int		ip_rt_init(void);

commit a5ee155136b4a8f4ab0e4c9c064b661da475e298
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Nov 29 15:45:58 2009 +0000

    net: NETDEV_UNREGISTER_PERNET -> NETDEV_UNREGISTER_BATCH
    
    The motivation for an additional notifier in batched netdevice
    notification (rt_do_flush) only needs to be called once per batch not
    once per namespace.
    
    For further batching improvements I need a guarantee that the
    netdevices are unregistered in order allowing me to unregister an all
    of the network devices in a network namespace at the same time with
    the guarantee that the loopback device is really and truly
    unregistered last.
    
    Additionally it appears that we moved the route cache flush after
    the final synchronize_net, which seems wrong and there was no
    explanation.  So I have restored the original location of the final
    synchronize_net.
    
    Cc: Octavian Purdila <opurdila@ixiacom.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index cfb4c071a136..bce6dd68d27b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -108,6 +108,7 @@ extern int		ip_rt_init(void);
 extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(struct net *net, int how);
+extern void		rt_cache_flush_batch(void);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);

commit fd2c3ef761fbc5e6c27fa7d40b30cda06bfcd7d8
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Nov 3 03:26:03 2009 +0000

    net: cleanup include/net
    
    This cleanup patch puts struct/union/enum opening braces,
    in first line to ease grep games.
    
    struct something
    {
    
    becomes :
    
    struct something {
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 40f6346ef496..cfb4c071a136 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -49,10 +49,8 @@
 
 struct fib_nh;
 struct inet_peer;
-struct rtable
-{
-	union
-	{
+struct rtable {
+	union {
 		struct dst_entry	dst;
 	} u;
 
@@ -77,16 +75,14 @@ struct rtable
 	struct inet_peer	*peer; /* long-living peer info */
 };
 
-struct ip_rt_acct
-{
+struct ip_rt_acct {
 	__u32 	o_bytes;
 	__u32 	o_packets;
 	__u32 	i_bytes;
 	__u32 	i_packets;
 };
 
-struct rt_cache_stat 
-{
+struct rt_cache_stat {
         unsigned int in_hit;
         unsigned int in_slow_tot;
         unsigned int in_slow_mc;

commit 511c3f92ad5b6d9f8f6464be1b4f85f0422be91a
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Jun 2 05:14:27 2009 +0000

    net: skb->rtable accessor
    
    Define skb_rtable(const struct sk_buff *skb) accessor to get rtable from skb
    
    Delete skb->rtable field
    
    Setting rtable is not allowed, just set dst instead as rtable is an alias.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 4e8cae0e5841..40f6346ef496 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -210,7 +210,7 @@ static inline struct inet_peer *rt_get_peer(struct rtable *rt)
 
 static inline int inet_iif(const struct sk_buff *skb)
 {
-	return skb->rtable->rt_iif;
+	return skb_rtable(skb)->rt_iif;
 }
 
 #endif	/* _ROUTE_H */

commit 79876874ce20d37ecdc7f481ebf142466999152f
Author: KOVACS Krisztian <hidden@sch.bme.hu>
Date:   Wed Oct 1 07:35:39 2008 -0700

    ipv4: Conditionally enable transparent flow flag when connecting
    
    Set FLOWI_FLAG_ANYSRC in flowi->flags if the socket has the
    transparent socket option set. This way we selectively enable certain
    connections with non-local source addresses to be routed.
    
    Signed-off-by: KOVACS Krisztian <hidden@sch.bme.hu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 31d1485b624d..4e8cae0e5841 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -27,7 +27,7 @@
 #include <net/dst.h>
 #include <net/inetpeer.h>
 #include <net/flow.h>
-#include <net/sock.h>
+#include <net/inet_sock.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/route.h>
@@ -161,6 +161,10 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 
 	int err;
 	struct net *net = sock_net(sk);
+
+	if (inet_sk(sk)->transparent)
+		fl.flags |= FLOWI_FLAG_ANYSRC;
+
 	if (!dst || !src) {
 		err = __ip_route_output_key(net, rp, &fl);
 		if (err)

commit 1668e010cbe1a7567c81d4c02d31dde9859e9da1
Author: KOVACS Krisztian <hidden@sch.bme.hu>
Date:   Wed Oct 1 07:33:10 2008 -0700

    ipv4: Make inet_sock.h independent of route.h
    
    inet_iif() in inet_sock.h requires route.h. Since users of inet_iif()
    usually require other route.h functionality anyway this patch moves
    inet_iif() to route.h.
    
    Signed-off-by: KOVACS Krisztian <hidden@sch.bme.hu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 4f0d8c14736c..31d1485b624d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -204,4 +204,9 @@ static inline struct inet_peer *rt_get_peer(struct rtable *rt)
 	return rt->peer;
 }
 
+static inline int inet_iif(const struct sk_buff *skb)
+{
+	return skb->rtable->rt_iif;
+}
+
 #endif	/* _ROUTE_H */

commit eeb61f719c00c626115852bbc91189dc3011a844
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Jul 27 08:59:33 2008 +0100

    missing bits of net-namespace / sysctl
    
    Piss-poor sysctl registration API strikes again, film at 11...
    
    What we really need is _pathname_ required to be present in already
    registered table, so that kernel could warn about bad order.  That's the
    next target for sysctl stuff (and generally saner and more explicit
    order of initialization of ipv[46] internals wouldn't hurt either).
    
    For the time being, here are full fixups required by ..._rotable()
    stuff; we make per-net sysctl sets descendents of "ro" one and make sure
    that sufficient skeleton is there before we start registering per-net
    sysctls.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/net/route.h b/include/net/route.h
index 3140cc500854..4f0d8c14736c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -204,6 +204,4 @@ static inline struct inet_peer *rt_get_peer(struct rtable *rt)
 	return rt->peer;
 }
 
-extern ctl_table ipv4_route_table[];
-
 #endif	/* _ROUTE_H */

commit 76e6ebfb40a2455c18234dcb0f9df37533215461
Author: Denis V. Lunev <den@openvz.org>
Date:   Sat Jul 5 19:00:44 2008 -0700

    netns: add namespace parameter to rt_cache_flush
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index fc836ff824cc..3140cc500854 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -111,7 +111,7 @@ struct in_device;
 extern int		ip_rt_init(void);
 extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
-extern void		rt_cache_flush(int how);
+extern void		rt_cache_flush(struct net *net, int how);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);

commit 0010e46577a27c1d915034637f6c2fa57a9a091c
Author: Timo Teras <timo.teras@iki.fi>
Date:   Tue Apr 29 03:32:25 2008 -0700

    ipv4: Update MTU to all related cache entries in ip_rt_frag_needed()
    
    Add struct net_device parameter to ip_rt_frag_needed() and update MTU to
    cache entries where ifindex is specified. This is similar to what is
    already done in ip_rt_redirect().
    
    Signed-off-by: Timo Teras <timo.teras@iki.fi>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index c6338802e8f1..fc836ff824cc 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -116,7 +116,7 @@ extern int		__ip_route_output_key(struct net *, struct rtable **, const struct f
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
 extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
-extern unsigned short	ip_rt_frag_needed(struct net *net, struct iphdr *iph, unsigned short new_mtu);
+extern unsigned short	ip_rt_frag_needed(struct net *net, struct iphdr *iph, unsigned short new_mtu, struct net_device *dev);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned		inet_addr_type(struct net *net, __be32 addr);

commit 3b1e0a655f8eba44ab1ee2a1068d169ccfb853b9
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Wed Mar 26 02:26:21 2008 +0900

    [NET] NETNS: Omit sock->sk_net without CONFIG_NET_NS.
    
    Introduce per-sock inlines: sock_net(), sock_net_set()
    and per-inet_timewait_sock inlines: twsk_net(), twsk_net_set().
    Without CONFIG_NET_NS, no namespace other than &init_net exists.
    Let's explicitly define them to help compiler optimizations.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/route.h b/include/net/route.h
index 28dba925663c..c6338802e8f1 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -160,7 +160,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 					 .dport = dport } } };
 
 	int err;
-	struct net *net = sk->sk_net;
+	struct net *net = sock_net(sk);
 	if (!dst || !src) {
 		err = __ip_route_output_key(net, rp, &fl);
 		if (err)
@@ -188,7 +188,7 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(sk->sk_net, rp, &fl, sk, 0);
+		return ip_route_output_flow(sock_net(sk), rp, &fl, sk, 0);
 	}
 	return 0;
 }

commit 7d164be8aa4392fe55474f4608547f2097e07c41
Author: Joe Perches <joe@perches.com>
Date:   Sun Mar 23 22:03:56 2008 -0700

    [NET]: include/net/route.h - remove duplicate include
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index eadad5901429..28dba925663c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -34,7 +34,6 @@
 #include <linux/ip.h>
 #include <linux/cache.h>
 #include <linux/security.h>
-#include <net/sock.h>
 
 #ifndef __KERNEL__
 #warning This file is not supposed to be used outside of kernel.

commit 29e75252da20f3ab9e132c68c9aed156b87beae6
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Thu Jan 31 17:05:09 2008 -0800

    [IPV4] route cache: Introduce rt_genid for smooth cache invalidation
    
    Current ip route cache implementation is not suited to large caches.
    
    We can consume a lot of CPU when cache must be invalidated, since we
    currently need to evict all cache entries, and this eviction is
    sometimes asynchronous. min_delay & max_delay can somewhat control this
    asynchronism behavior, but whole thing is a kludge, regularly triggering
    infamous soft lockup messages. When entries are still in use, this also
    consumes a lot of ram, filling dst_garbage.list.
    
    A better scheme is to use a generation identifier on each entry,
    so that cache invalidation can be performed by changing the table
    identifier, without having to scan all entries.
    No more delayed flushing, no more stalling when secret_interval expires.
    
    Invalidated entries will then be freed at GC time (controled by
    ip_rt_gc_timeout or stress), or when an invalidated entry is found
    in a chain when an insert is done.
    Thus we keep a normal equilibrium.
    
    This patch :
    - renames rt_hash_rnd to rt_genid (and makes it an atomic_t)
    - Adds a new rt_genid field to 'struct rtable' (filling a hole on 64bit)
    - Checks entry->rt_genid at appropriate places :

diff --git a/include/net/route.h b/include/net/route.h
index fcc6d5b35863..eadad5901429 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -62,6 +62,7 @@ struct rtable
 
 	struct in_device	*idev;
 	
+	int			rt_genid;
 	unsigned		rt_flags;
 	__u16			rt_type;
 

commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
Author: Laszlo Attila Toth <panther@balabit.hu>
Date:   Wed Jan 30 19:08:16 2008 -0800

    [NET]: Introducing socket mark socket option.
    
    A userspace program may wish to set the mark for each packets its send
    without using the netfilter MARK target. Changing the mark can be used
    for mark based routing without netfilter or for packet filtering.
    
    It requires CAP_NET_ADMIN capability.
    
    Signed-off-by: Laszlo Attila Toth <panther@balabit.hu>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 4eabf008413b..fcc6d5b35863 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -27,6 +27,7 @@
 #include <net/dst.h>
 #include <net/inetpeer.h>
 #include <net/flow.h>
+#include <net/sock.h>
 #include <linux/in_route.h>
 #include <linux/rtnetlink.h>
 #include <linux/route.h>
@@ -149,6 +150,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 				   int flags)
 {
 	struct flowi fl = { .oif = oif,
+			    .mark = sk->sk_mark,
 			    .nl_u = { .ip4_u = { .daddr = dst,
 						 .saddr = src,
 						 .tos   = tos } },

commit b5921910a1de4ba82add59154976c3dc7352c8c2
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Jan 22 23:50:25 2008 -0800

    [NETNS]: Routing cache virtualization.
    
    Basically, this piece looks relatively easy. Namespace is already
    available on the dst entry via device and the device is safe to
    dereferrence. Compare it with one of a searcher and skip entry if
    appropriate.
    
    The only exception is ip_rt_frag_needed. So, add namespace parameter to it.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 1985d820edea..4eabf008413b 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -115,7 +115,7 @@ extern int		__ip_route_output_key(struct net *, struct rtable **, const struct f
 extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
 extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
-extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
+extern unsigned short	ip_rt_frag_needed(struct net *net, struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned		inet_addr_type(struct net *net, __be32 addr);

commit eee80592c3c1f7381c04913d9d3eb6e3c3c87628
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Jan 22 23:49:35 2008 -0800

    [NETNS]: Correct namespace for connect-time routing.
    
    ip_route_connect and ip_route_newports are a part of routing API
    presented to the socket layer. The namespace is available inside them
    through a socket.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index d9b876adbf42..1985d820edea 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -33,6 +33,7 @@
 #include <linux/ip.h>
 #include <linux/cache.h>
 #include <linux/security.h>
+#include <net/sock.h>
 
 #ifndef __KERNEL__
 #warning This file is not supposed to be used outside of kernel.
@@ -157,8 +158,9 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 					 .dport = dport } } };
 
 	int err;
+	struct net *net = sk->sk_net;
 	if (!dst || !src) {
-		err = __ip_route_output_key(&init_net, rp, &fl);
+		err = __ip_route_output_key(net, rp, &fl);
 		if (err)
 			return err;
 		fl.fl4_dst = (*rp)->rt_dst;
@@ -167,7 +169,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		*rp = NULL;
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(&init_net, rp, &fl, sk, flags);
+	return ip_route_output_flow(net, rp, &fl, sk, flags);
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,
@@ -184,7 +186,7 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(&init_net, rp, &fl, sk, 0);
+		return ip_route_output_flow(sk->sk_net, rp, &fl, sk, 0);
 	}
 	return 0;
 }

commit f206351a50ea86250fabea96b9af8d8f8fc02603
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Jan 22 22:07:34 2008 -0800

    [NETNS]: Add namespace parameter to ip_route_output_key.
    
    Needed to propagate it down to the ip_route_output_flow.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 6b970d7d07e0..d9b876adbf42 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -111,7 +111,7 @@ extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(int how);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
-extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
+extern int		ip_route_output_key(struct net *, struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
 extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);

commit f1b050bf7a88910f9f00c9c8989c1bf5a67dd140
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Jan 22 22:07:10 2008 -0800

    [NETNS]: Add namespace parameter to ip_route_output_flow.
    
    Needed to propagate it down to the __ip_route_output_key.
    
    Signed_off_by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 3e3b14e060f9..6b970d7d07e0 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -112,7 +112,7 @@ extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 extern void		rt_cache_flush(int how);
 extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
-extern int		ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
+extern int		ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
 extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
@@ -167,7 +167,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		*rp = NULL;
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(rp, &fl, sk, flags);
+	return ip_route_output_flow(&init_net, rp, &fl, sk, flags);
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,
@@ -184,7 +184,7 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		ip_rt_put(*rp);
 		*rp = NULL;
 		security_sk_classify_flow(sk, &fl);
-		return ip_route_output_flow(rp, &fl, sk, 0);
+		return ip_route_output_flow(&init_net, rp, &fl, sk, 0);
 	}
 	return 0;
 }

commit 611c183ebcb5af384df3a4ddb391034a1b6ac255
Author: Denis V. Lunev <den@openvz.org>
Date:   Tue Jan 22 22:06:48 2008 -0800

    [NETNS]: Add namespace parameter to __ip_route_output_key.
    
    This is only required to propagate it down to the
    ip_route_output_slow.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5847e6fabe8e..3e3b14e060f9 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -110,7 +110,7 @@ extern int		ip_rt_init(void);
 extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
 extern void		rt_cache_flush(int how);
-extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);
+extern int		__ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
 extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
@@ -158,7 +158,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 
 	int err;
 	if (!dst || !src) {
-		err = __ip_route_output_key(rp, &fl);
+		err = __ip_route_output_key(&init_net, rp, &fl);
 		if (err)
 			return err;
 		fl.fl4_dst = (*rp)->rt_dst;

commit 1bad118a330d494b23663fce94d4e9d9d5065fa7
Author: Denis V. Lunev <den@openvz.org>
Date:   Thu Jan 10 03:29:53 2008 -0800

    [NETNS]: Pass namespace through ip_rt_ioctl.
    
    ... up to rtentry_to_fib_config
    
    Acked-by: Benjamin Thery <benjamin.thery@bull.net>
    Acked-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index b77700059252..5847e6fabe8e 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -120,7 +120,7 @@ extern void		ip_rt_send_redirect(struct sk_buff *skb);
 extern unsigned		inet_addr_type(struct net *net, __be32 addr);
 extern unsigned		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
-extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
+extern int		ip_rt_ioctl(struct net *, unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct rtable *rt);
 extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 

commit 6b175b26c1048d331508940ad3516ead1998084f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jan 10 03:25:28 2008 -0800

    [NETNS]: Add netns parameter to inet_(dev_)add_type.
    
    The patch extends the inet_addr_type and inet_dev_addr_type with the
    network namespace pointer. That allows to access the different tables
    relatively to the network namespace.
    
    The modification of the signature function is reported in all the
    callers of the inet_addr_type using the pointer to the well known
    init_net.
    
    Acked-by: Benjamin Thery <benjamin.thery@bull.net>
    Acked-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 76b08c1affc0..b77700059252 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -117,8 +117,8 @@ extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, stru
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
-extern unsigned		inet_addr_type(__be32 addr);
-extern unsigned		inet_dev_addr_type(const struct net_device *dev, __be32 addr);
+extern unsigned		inet_addr_type(struct net *net, __be32 addr);
+extern unsigned		inet_dev_addr_type(struct net *net, const struct net_device *dev, __be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
 extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct rtable *rt);

commit 0553811612a6178365f3b062c30234913b218a96
Author: Laszlo Attila Toth <panther@balabit.hu>
Date:   Tue Dec 4 23:28:46 2007 -0800

    [IPV4]: Add inet_dev_addr_type()
    
    Address type search can be limited to an interface by
    inet_dev_addr_type function.
    
    Signed-off-by: Laszlo Attila Toth <panther@balabit.hu>
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 59b0b19205a2..76b08c1affc0 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -118,6 +118,7 @@ extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mt
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
 extern unsigned		inet_addr_type(__be32 addr);
+extern unsigned		inet_dev_addr_type(const struct net_device *dev, __be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
 extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct rtable *rt);

commit 56c99d0415e8b778c200f115b198c126243ec351
Author: Denis V. Lunev <den@openvz.org>
Date:   Thu Dec 6 02:19:07 2007 -0800

    [IPV4]: Remove prototype of ip_rt_advice
    
    ip_rt_advice has been gone, so no need to keep prototype and debug message.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index f7ce6259f86f..59b0b19205a2 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -109,7 +109,6 @@ struct in_device;
 extern int		ip_rt_init(void);
 extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
 				       __be32 src, struct net_device *dev);
-extern void		ip_rt_advice(struct rtable **rp, int advice);
 extern void		rt_cache_flush(int how);
 extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct rtable **, struct flowi *flp);

commit 4839c52b01ca91be1c62761e08fb3deb3881e857
Author: Philippe De Muyter <phdm@macqel.be>
Date:   Mon Jul 9 15:32:57 2007 -0700

    [IPV4]: Make ip_tos2prio const.
    
    Signed-off-by: Philippe De Muyter <phdm@macqel.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 188b8936bb27..f7ce6259f86f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -135,7 +135,7 @@ static inline void ip_rt_put(struct rtable * rt)
 
 #define IPTOS_RT_MASK	(IPTOS_TOS_MASK & ~3)
 
-extern __u8 ip_tos2prio[16];
+extern const __u8 ip_tos2prio[16];
 
 static inline char rt_tos2priority(u8 tos)
 {

commit e06e7c615877026544ad7f8b309d1a3706410383
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Sun Jun 10 17:22:39 2007 -0700

    [IPV4]: The scheduled removal of multipath cached routing support.
    
    With help from Chris Wedgwood.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 749e4dfe5ff3..188b8936bb27 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -62,7 +62,6 @@ struct rtable
 	
 	unsigned		rt_flags;
 	__u16			rt_type;
-	__u16			rt_multipath_alg;
 
 	__be32			rt_dst;	/* Path destination	*/
 	__be32			rt_src;	/* Path source		*/

commit 093c2ca4167cf66f69020329d14138da0da8599b
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Fri Feb 9 16:19:26 2007 -0800

    [IPV4]: Convert ipv4 route to use the new dst_entry 'next' pointer
    
    This patch removes the rt_next pointer from 'struct rtable.u' union,
    and renames u.rt_next to u.dst_rt_next.
    
    It also moves 'struct flowi' right after 'struct dst_entry' to prepare
    the gain on lookups.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 1440bdb5a27d..749e4dfe5ff3 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -53,9 +53,11 @@ struct rtable
 	union
 	{
 		struct dst_entry	dst;
-		struct rtable		*rt_next;
 	} u;
 
+	/* Cache lookup keys */
+	struct flowi		fl;
+
 	struct in_device	*idev;
 	
 	unsigned		rt_flags;
@@ -69,9 +71,6 @@ struct rtable
 	/* Info on neighbour */
 	__be32			rt_gateway;
 
-	/* Cache lookup keys */
-	struct flowi		fl;
-
 	/* Miscellaneous cached information */
 	__be32			rt_spec_dst; /* RFC1122 specific destination */
 	struct inet_peer	*peer; /* long-living peer info */

commit 8eb9086f21c73b38b5ca27558db4c91d62d0e70b
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Thu Feb 8 02:09:21 2007 -0800

    [IPV4/IPV6]: Always wait for IPSEC SA resolution in socket contexts.
    
    Do this even for non-blocking sockets.  This avoids the silly -EAGAIN
    that applications can see now, even for non-blocking sockets in some
    cases (f.e. connect()).
    
    With help from Venkat Tekkirala.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 486e37aff06c..1440bdb5a27d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -146,7 +146,8 @@ static inline char rt_tos2priority(u8 tos)
 
 static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 				   __be32 src, u32 tos, int oif, u8 protocol,
-				   __be16 sport, __be16 dport, struct sock *sk)
+				   __be16 sport, __be16 dport, struct sock *sk,
+				   int flags)
 {
 	struct flowi fl = { .oif = oif,
 			    .nl_u = { .ip4_u = { .daddr = dst,
@@ -168,7 +169,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 		*rp = NULL;
 	}
 	security_sk_classify_flow(sk, &fl);
-	return ip_route_output_flow(rp, &fl, sk, 0);
+	return ip_route_output_flow(rp, &fl, sk, flags);
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,

commit 39dccd9d922b595301e5d43ca7a30823d81393b6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Sep 27 18:34:41 2006 -0700

    [IPV4]: route.h annotations
    
    ip_route_connect(), ip_route_newports() get port numbers net-endian
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 58752722c968..486e37aff06c 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -146,7 +146,7 @@ static inline char rt_tos2priority(u8 tos)
 
 static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 				   __be32 src, u32 tos, int oif, u8 protocol,
-				   u16 sport, u16 dport, struct sock *sk)
+				   __be16 sport, __be16 dport, struct sock *sk)
 {
 	struct flowi fl = { .oif = oif,
 			    .nl_u = { .ip4_u = { .daddr = dst,
@@ -172,7 +172,7 @@ static inline int ip_route_connect(struct rtable **rp, __be32 dst,
 }
 
 static inline int ip_route_newports(struct rtable **rp, u8 protocol,
-				    u16 sport, u16 dport, struct sock *sk)
+				    __be16 sport, __be16 dport, struct sock *sk)
 {
 	if (sport != (*rp)->fl.fl_ip_sport ||
 	    dport != (*rp)->fl.fl_ip_dport) {

commit fd6832220974809141b3981e380b78690bba8911
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 26 22:17:51 2006 -0700

    [IPV4]: inet_addr_type() annotations
    
    argument and inferred net-endian variables in callers annotated.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 63524843f6d9..58752722c968 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -120,7 +120,7 @@ extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, stru
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 
-extern unsigned		inet_addr_type(u32 addr);
+extern unsigned		inet_addr_type(__be32 addr);
 extern void		ip_rt_multicast_event(struct in_device *);
 extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct rtable *rt);

commit bada8adc4e6622764205921e6ba3f717aa03c882
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 26 21:27:15 2006 -0700

    [IPV4]: ip_route_connect() ipv4 address arguments annotated
    
    annotated address arguments (port number left alone for now); ditto
    for inferred net-endian variables in callers.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 5bb2b15b4391..63524843f6d9 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -144,8 +144,8 @@ static inline char rt_tos2priority(u8 tos)
 	return ip_tos2prio[IPTOS_TOS(tos)>>1];
 }
 
-static inline int ip_route_connect(struct rtable **rp, u32 dst,
-				   u32 src, u32 tos, int oif, u8 protocol,
+static inline int ip_route_connect(struct rtable **rp, __be32 dst,
+				   __be32 src, u32 tos, int oif, u8 protocol,
 				   u16 sport, u16 dport, struct sock *sk)
 {
 	struct flowi fl = { .oif = oif,

commit f2c3fe24119ee4f8faca08699f0488f500014a27
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 26 21:26:42 2006 -0700

    [IPV4]: annotate ipv4 addresses in struct rtable and struct flowi
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 64a18811526d..5bb2b15b4391 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -62,18 +62,18 @@ struct rtable
 	__u16			rt_type;
 	__u16			rt_multipath_alg;
 
-	__u32			rt_dst;	/* Path destination	*/
-	__u32			rt_src;	/* Path source		*/
+	__be32			rt_dst;	/* Path destination	*/
+	__be32			rt_src;	/* Path source		*/
 	int			rt_iif;
 
 	/* Info on neighbour */
-	__u32			rt_gateway;
+	__be32			rt_gateway;
 
 	/* Cache lookup keys */
 	struct flowi		fl;
 
 	/* Miscellaneous cached information */
-	__u32			rt_spec_dst; /* RFC1122 specific destination */
+	__be32			rt_spec_dst; /* RFC1122 specific destination */
 	struct inet_peer	*peer; /* long-living peer info */
 };
 

commit f7655229c06d041323b40bd6eb9f95ca0ce95506
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 26 21:25:43 2006 -0700

    [IPV4]: ip_rt_redirect() annotations
    
    The first 4 arguments of ip_rt_redirect() are net-endian.  Annotated.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9cfa67089f7f..64a18811526d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -109,8 +109,8 @@ extern struct ip_rt_acct *ip_rt_acct;
 
 struct in_device;
 extern int		ip_rt_init(void);
-extern void		ip_rt_redirect(u32 old_gw, u32 dst, u32 new_gw,
-				       u32 src, struct net_device *dev);
+extern void		ip_rt_redirect(__be32 old_gw, __be32 dst, __be32 new_gw,
+				       __be32 src, struct net_device *dev);
 extern void		ip_rt_advice(struct rtable **rp, int advice);
 extern void		rt_cache_flush(int how);
 extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);

commit 9e12bb22e32389b41222c9d9fb55724fed83a038
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 26 21:25:20 2006 -0700

    [IPV4]: ip_route_input() annotations
    
    ip_route_input() takes net-endian source and destination address.
    * Annotated as such.
    * arguments of its invocations annotated where needed.
    * local helpers getting the same values passed to by it (ip_route_input_mc(),
    ip_route_input_slow(), ip_handle_martian_source(), ip_mkroute_input(),
    ip_mkroute_input_def(), __mkroute_input()) annotated
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 7f93ac0e0899..9cfa67089f7f 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -116,7 +116,7 @@ extern void		rt_cache_flush(int how);
 extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);
 extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
 extern int		ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
-extern int		ip_route_input(struct sk_buff*, u32 dst, u32 src, u8 tos, struct net_device *devin);
+extern int		ip_route_input(struct sk_buff*, __be32 dst, __be32 src, u8 tos, struct net_device *devin);
 extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
 extern void		ip_rt_send_redirect(struct sk_buff *skb);
 

commit beb8d13bed80f8388f1a9a107d07ddd342e627e8
Author: Venkat Yekkirala <vyekkirala@TrustedCS.com>
Date:   Fri Aug 4 23:12:42 2006 -0700

    [MLSXFRM]: Add flow labeling
    
    This labels the flows that could utilize IPSec xfrms at the points the
    flows are defined so that IPSec policy and SAs at the right label can
    be used.
    
    The following protos are currently not handled, but they should
    continue to be able to use single-labeled IPSec like they currently
    do.
    
    ipmr
    ip_gre
    ipip
    igmp
    sit
    sctp
    ip6_tunnel (IPv6 over IPv6 tunnel device)
    decnet
    
    Signed-off-by: Venkat Yekkirala <vyekkirala@TrustedCS.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index c4a068692dcc..7f93ac0e0899 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -32,6 +32,7 @@
 #include <linux/route.h>
 #include <linux/ip.h>
 #include <linux/cache.h>
+#include <linux/security.h>
 
 #ifndef __KERNEL__
 #warning This file is not supposed to be used outside of kernel.
@@ -166,6 +167,7 @@ static inline int ip_route_connect(struct rtable **rp, u32 dst,
 		ip_rt_put(*rp);
 		*rp = NULL;
 	}
+	security_sk_classify_flow(sk, &fl);
 	return ip_route_output_flow(rp, &fl, sk, 0);
 }
 
@@ -182,6 +184,7 @@ static inline int ip_route_newports(struct rtable **rp, u8 protocol,
 		fl.proto = protocol;
 		ip_rt_put(*rp);
 		*rp = NULL;
+		security_sk_classify_flow(sk, &fl);
 		return ip_route_output_flow(rp, &fl, sk, 0);
 	}
 	return 0;

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/net/route.h b/include/net/route.h
index 98c915abdec8..c4a068692dcc 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -24,7 +24,6 @@
 #ifndef _ROUTE_H
 #define _ROUTE_H
 
-#include <linux/config.h>
 #include <net/dst.h>
 #include <net/inetpeer.h>
 #include <net/flow.h>

commit cef2685e0053945ea0f3c02297386b040f486ea7
Author: Ilia Sotnikov <hostcc@gmail.com>
Date:   Sat Mar 25 01:38:55 2006 -0800

    [IPV4]: Aggregate route entries with different TOS values
    
    When we get an ICMP need-to-frag message, the original TOS value in the
    ICMP payload cannot be used as a key to look up the routes to update.
    This is because the TOS field may have been modified by routers on the
    way.  Similarly, ip_rt_redirect should also ignore the TOS as the router
    that gave us the message may have modified the TOS value.
    
    The patch achieves this objective by aggregating entries with different
    TOS values (but are otherwise identical) into the same bucket.  This
    makes it easy to update them at the same time when an ICMP message is
    received.
    
    In future we should use a twin-hashing scheme where teh aggregation
    occurs at the entry level.  That is, the TOS goes back into the hash
    for normal lookups while ICMP lookups will end up with a node that
    gives us a list that contains all other route entries that differ
    only by TOS.
    
    Signed-off-by: Ilia Sotnikov <hostcc@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 9c04f15090d2..98c915abdec8 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -110,7 +110,7 @@ extern struct ip_rt_acct *ip_rt_acct;
 struct in_device;
 extern int		ip_rt_init(void);
 extern void		ip_rt_redirect(u32 old_gw, u32 dst, u32 new_gw,
-				       u32 src, u8 tos, struct net_device *dev);
+				       u32 src, struct net_device *dev);
 extern void		ip_rt_advice(struct rtable **rp, int advice);
 extern void		rt_cache_flush(int how);
 extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);

commit 5d39a795bfa217b5f7637028c83ab5cb291f37bf
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jan 31 17:35:35 2006 -0800

    [IPV4]: Always set fl.proto in ip_route_newports
    
    ip_route_newports uses the struct flowi from the struct rtable returned
    by ip_route_connect for the new route lookup and just replaces the port
    numbers if they have changed. If an IPsec policy exists which doesn't match
    port 0 the struct flowi won't have the proto field set and no xfrm lookup
    is done for the changed ports.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index e3e5436f8017..9c04f15090d2 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -170,8 +170,8 @@ static inline int ip_route_connect(struct rtable **rp, u32 dst,
 	return ip_route_output_flow(rp, &fl, sk, 0);
 }
 
-static inline int ip_route_newports(struct rtable **rp, u16 sport, u16 dport,
-				    struct sock *sk)
+static inline int ip_route_newports(struct rtable **rp, u8 protocol,
+				    u16 sport, u16 dport, struct sock *sk)
 {
 	if (sport != (*rp)->fl.fl_ip_sport ||
 	    dport != (*rp)->fl.fl_ip_dport) {
@@ -180,6 +180,7 @@ static inline int ip_route_newports(struct rtable **rp, u16 sport, u16 dport,
 		memcpy(&fl, &(*rp)->fl, sizeof(fl));
 		fl.fl_ip_sport = sport;
 		fl.fl_ip_dport = dport;
+		fl.proto = protocol;
 		ip_rt_put(*rp);
 		*rp = NULL;
 		return ip_route_output_flow(rp, &fl, sk, 0);

commit 0ff60a45678e67b2547256a636fd00c1667ce4fa
Author: Jamal Hadi Salim <hadi@cyberus.ca>
Date:   Tue Nov 22 14:47:37 2005 -0800

    [IPV4]: Fix secondary IP addresses after promotion
    
    This patch fixes the problem with promoting aliases when:
    a) a single primary and > 1 secondary addresses
    b) multiple primary addresses each with at least one secondary address
    
    Based on earlier efforts from Brian Pomerantz <bapper@piratehaven.org>,
    Patrick McHardy <kaber@trash.net> and Thomas Graf <tgraf@suug.ch>
    
    Signed-off-by: Jamal Hadi Salim <hadi@cyberus.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index dbe79ca67d31..e3e5436f8017 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -126,6 +126,9 @@ extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
 extern void		ip_rt_get_source(u8 *src, struct rtable *rt);
 extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
 
+struct in_ifaddr;
+extern void fib_add_ifaddr(struct in_ifaddr *);
+
 static inline void ip_rt_put(struct rtable * rt)
 {
 	if (rt)

commit 20380731bc2897f2952ae055420972ded4cd786e
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 16 02:18:02 2005 -0300

    [NET]: Fix sparse warnings
    
    Of this type, mostly:
    
    CHECK   net/ipv6/netfilter.c
    net/ipv6/netfilter.c:96:12: warning: symbol 'ipv6_netfilter_init' was not declared. Should it be static?
    net/ipv6/netfilter.c:101:6: warning: symbol 'ipv6_netfilter_fini' was not declared. Should it be static?
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index 63c94558236d..dbe79ca67d31 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -195,4 +195,6 @@ static inline struct inet_peer *rt_get_peer(struct rtable *rt)
 	return rt->peer;
 }
 
+extern ctl_table ipv4_route_table[];
+
 #endif	/* _ROUTE_H */

commit 0742fd53a3774781255bd1e471e7aa2e4a82d5f7
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Aug 9 19:35:47 2005 -0700

    [IPV4]: possible cleanups
    
    This patch contains the following possible cleanups:
    - make needlessly global code static
    - #if 0 the following unused global function:
      - xfrm4_state.c: xfrm4_state_fini
    - remove the following unneeded EXPORT_SYMBOL's:
      - ip_output.c: ip_finish_output
      - ip_output.c: sysctl_ip_default_ttl
      - fib_frontend.c: ip_dev_find
      - inetpeer.c: inet_peer_idlock
      - ip_options.c: ip_options_compile
      - ip_options.c: ip_options_undo
      - net/core/request_sock.c: sysctl_max_syn_backlog
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index c3cd069a9aca..63c94558236d 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -105,10 +105,6 @@ struct rt_cache_stat
         unsigned int out_hlist_search;
 };
 
-extern struct rt_cache_stat *rt_cache_stat;
-#define RT_CACHE_STAT_INC(field)					  \
-		(per_cpu_ptr(rt_cache_stat, raw_smp_processor_id())->field++)
-
 extern struct ip_rt_acct *ip_rt_acct;
 
 struct in_device;

commit 39c715b71740c4a78ba4769fb54826929bac03cb
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jun 21 17:14:34 2005 -0700

    [PATCH] smp_processor_id() cleanup
    
    This patch implements a number of smp_processor_id() cleanup ideas that
    Arjan van de Ven and I came up with.
    
    The previous __smp_processor_id/_smp_processor_id/smp_processor_id API
    spaghetti was hard to follow both on the implementational and on the
    usage side.
    
    Some of the complexity arose from picking wrong names, some of the
    complexity comes from the fact that not all architectures defined
    __smp_processor_id.
    
    In the new code, there are two externally visible symbols:
    
     - smp_processor_id(): debug variant.
    
     - raw_smp_processor_id(): nondebug variant. Replaces all existing
       uses of _smp_processor_id() and __smp_processor_id(). Defined
       by every SMP architecture in include/asm-*/smp.h.
    
    There is one new internal symbol, dependent on DEBUG_PREEMPT:
    
     - debug_smp_processor_id(): internal debug variant, mapped to
                                 smp_processor_id().
    
    Also, i moved debug_smp_processor_id() from lib/kernel_lock.c into a new
    lib/smp_processor_id.c file.  All related comments got updated and/or
    clarified.
    
    I have build/boot tested the following 8 .config combinations on x86:
    
     {SMP,UP} x {PREEMPT,!PREEMPT} x {DEBUG_PREEMPT,!DEBUG_PREEMPT}
    
    I have also build/boot tested x64 on UP/PREEMPT/DEBUG_PREEMPT.  (Other
    architectures are untested, but should work just fine.)
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/net/route.h b/include/net/route.h
index d34ca8fc6756..c3cd069a9aca 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -107,7 +107,7 @@ struct rt_cache_stat
 
 extern struct rt_cache_stat *rt_cache_stat;
 #define RT_CACHE_STAT_INC(field)					  \
-		(per_cpu_ptr(rt_cache_stat, _smp_processor_id())->field++)
+		(per_cpu_ptr(rt_cache_stat, raw_smp_processor_id())->field++)
 
 extern struct ip_rt_acct *ip_rt_acct;
 

commit 37e20a66db02eff9adbeee043af990cca85d0034
Author: Pravin B. Shelar <pravins@calsoftinc.com>
Date:   Sun May 29 20:26:44 2005 -0700

    [IPV4]: Kill MULTIPATHHOLDROUTE flag.
    
    It cannot work properly, so just ignore it in drr
    and rr multipath algorithms just like the random
    multipath algorithm does.
    
    Suggested by Herbert Xu.
    
    Signed-off by: Pravin B. Shelar <pravins@calsoftinc.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/route.h b/include/net/route.h
index efe92b239ef1..d34ca8fc6756 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -181,9 +181,6 @@ static inline int ip_route_newports(struct rtable **rp, u16 sport, u16 dport,
 		memcpy(&fl, &(*rp)->fl, sizeof(fl));
 		fl.fl_ip_sport = sport;
 		fl.fl_ip_dport = dport;
-#if defined(CONFIG_IP_ROUTE_MULTIPATH_CACHED)
-		fl.flags |= FLOWI_FLAG_MULTIPATHOLDROUTE;
-#endif
 		ip_rt_put(*rp);
 		*rp = NULL;
 		return ip_route_output_flow(rp, &fl, sk, 0);

commit 02c30a84e6298b6b20a56f0896ac80b47839e134
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Thu May 5 16:16:16 2005 -0700

    [PATCH] update Ross Biro bouncing email address
    
    Ross moved.  Remove the bad email address so people will find the correct
    one in ./CREDITS.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/net/route.h b/include/net/route.h
index 22da7579d5de..efe92b239ef1 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -7,7 +7,7 @@
  *
  * Version:	@(#)route.h	1.0.4	05/27/93
  *
- * Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+ * Authors:	Ross Biro
  *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
  * Fixes:
  *		Alan Cox	:	Reformatted. Added ip_rt_local()

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/route.h b/include/net/route.h
new file mode 100644
index 000000000000..22da7579d5de
--- /dev/null
+++ b/include/net/route.h
@@ -0,0 +1,205 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET  is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Definitions for the IP router.
+ *
+ * Version:	@(#)route.h	1.0.4	05/27/93
+ *
+ * Authors:	Ross Biro, <bir7@leland.Stanford.Edu>
+ *		Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ * Fixes:
+ *		Alan Cox	:	Reformatted. Added ip_rt_local()
+ *		Alan Cox	:	Support for TCP parameters.
+ *		Alexey Kuznetsov:	Major changes for new routing code.
+ *		Mike McLagan    :	Routing by source
+ *		Robert Olsson   :	Added rt_cache statistics
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+#ifndef _ROUTE_H
+#define _ROUTE_H
+
+#include <linux/config.h>
+#include <net/dst.h>
+#include <net/inetpeer.h>
+#include <net/flow.h>
+#include <linux/in_route.h>
+#include <linux/rtnetlink.h>
+#include <linux/route.h>
+#include <linux/ip.h>
+#include <linux/cache.h>
+
+#ifndef __KERNEL__
+#warning This file is not supposed to be used outside of kernel.
+#endif
+
+#define RTO_ONLINK	0x01
+
+#define RTO_CONN	0
+/* RTO_CONN is not used (being alias for 0), but preserved not to break
+ * some modules referring to it. */
+
+#define RT_CONN_FLAGS(sk)   (RT_TOS(inet_sk(sk)->tos) | sock_flag(sk, SOCK_LOCALROUTE))
+
+struct fib_nh;
+struct inet_peer;
+struct rtable
+{
+	union
+	{
+		struct dst_entry	dst;
+		struct rtable		*rt_next;
+	} u;
+
+	struct in_device	*idev;
+	
+	unsigned		rt_flags;
+	__u16			rt_type;
+	__u16			rt_multipath_alg;
+
+	__u32			rt_dst;	/* Path destination	*/
+	__u32			rt_src;	/* Path source		*/
+	int			rt_iif;
+
+	/* Info on neighbour */
+	__u32			rt_gateway;
+
+	/* Cache lookup keys */
+	struct flowi		fl;
+
+	/* Miscellaneous cached information */
+	__u32			rt_spec_dst; /* RFC1122 specific destination */
+	struct inet_peer	*peer; /* long-living peer info */
+};
+
+struct ip_rt_acct
+{
+	__u32 	o_bytes;
+	__u32 	o_packets;
+	__u32 	i_bytes;
+	__u32 	i_packets;
+};
+
+struct rt_cache_stat 
+{
+        unsigned int in_hit;
+        unsigned int in_slow_tot;
+        unsigned int in_slow_mc;
+        unsigned int in_no_route;
+        unsigned int in_brd;
+        unsigned int in_martian_dst;
+        unsigned int in_martian_src;
+        unsigned int out_hit;
+        unsigned int out_slow_tot;
+        unsigned int out_slow_mc;
+        unsigned int gc_total;
+        unsigned int gc_ignored;
+        unsigned int gc_goal_miss;
+        unsigned int gc_dst_overflow;
+        unsigned int in_hlist_search;
+        unsigned int out_hlist_search;
+};
+
+extern struct rt_cache_stat *rt_cache_stat;
+#define RT_CACHE_STAT_INC(field)					  \
+		(per_cpu_ptr(rt_cache_stat, _smp_processor_id())->field++)
+
+extern struct ip_rt_acct *ip_rt_acct;
+
+struct in_device;
+extern int		ip_rt_init(void);
+extern void		ip_rt_redirect(u32 old_gw, u32 dst, u32 new_gw,
+				       u32 src, u8 tos, struct net_device *dev);
+extern void		ip_rt_advice(struct rtable **rp, int advice);
+extern void		rt_cache_flush(int how);
+extern int		__ip_route_output_key(struct rtable **, const struct flowi *flp);
+extern int		ip_route_output_key(struct rtable **, struct flowi *flp);
+extern int		ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
+extern int		ip_route_input(struct sk_buff*, u32 dst, u32 src, u8 tos, struct net_device *devin);
+extern unsigned short	ip_rt_frag_needed(struct iphdr *iph, unsigned short new_mtu);
+extern void		ip_rt_send_redirect(struct sk_buff *skb);
+
+extern unsigned		inet_addr_type(u32 addr);
+extern void		ip_rt_multicast_event(struct in_device *);
+extern int		ip_rt_ioctl(unsigned int cmd, void __user *arg);
+extern void		ip_rt_get_source(u8 *src, struct rtable *rt);
+extern int		ip_rt_dump(struct sk_buff *skb,  struct netlink_callback *cb);
+
+static inline void ip_rt_put(struct rtable * rt)
+{
+	if (rt)
+		dst_release(&rt->u.dst);
+}
+
+#define IPTOS_RT_MASK	(IPTOS_TOS_MASK & ~3)
+
+extern __u8 ip_tos2prio[16];
+
+static inline char rt_tos2priority(u8 tos)
+{
+	return ip_tos2prio[IPTOS_TOS(tos)>>1];
+}
+
+static inline int ip_route_connect(struct rtable **rp, u32 dst,
+				   u32 src, u32 tos, int oif, u8 protocol,
+				   u16 sport, u16 dport, struct sock *sk)
+{
+	struct flowi fl = { .oif = oif,
+			    .nl_u = { .ip4_u = { .daddr = dst,
+						 .saddr = src,
+						 .tos   = tos } },
+			    .proto = protocol,
+			    .uli_u = { .ports =
+				       { .sport = sport,
+					 .dport = dport } } };
+
+	int err;
+	if (!dst || !src) {
+		err = __ip_route_output_key(rp, &fl);
+		if (err)
+			return err;
+		fl.fl4_dst = (*rp)->rt_dst;
+		fl.fl4_src = (*rp)->rt_src;
+		ip_rt_put(*rp);
+		*rp = NULL;
+	}
+	return ip_route_output_flow(rp, &fl, sk, 0);
+}
+
+static inline int ip_route_newports(struct rtable **rp, u16 sport, u16 dport,
+				    struct sock *sk)
+{
+	if (sport != (*rp)->fl.fl_ip_sport ||
+	    dport != (*rp)->fl.fl_ip_dport) {
+		struct flowi fl;
+
+		memcpy(&fl, &(*rp)->fl, sizeof(fl));
+		fl.fl_ip_sport = sport;
+		fl.fl_ip_dport = dport;
+#if defined(CONFIG_IP_ROUTE_MULTIPATH_CACHED)
+		fl.flags |= FLOWI_FLAG_MULTIPATHOLDROUTE;
+#endif
+		ip_rt_put(*rp);
+		*rp = NULL;
+		return ip_route_output_flow(rp, &fl, sk, 0);
+	}
+	return 0;
+}
+
+extern void rt_bind_peer(struct rtable *rt, int create);
+
+static inline struct inet_peer *rt_get_peer(struct rtable *rt)
+{
+	if (rt->peer)
+		return rt->peer;
+
+	rt_bind_peer(rt, 0);
+	return rt->peer;
+}
+
+#endif	/* _ROUTE_H */
