commit fddda2b7b521185f3aa018f9559eb33b0aee53a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 19:44:18 2018 +0200

    proc: introduce proc_create_seq{,_data}
    
    Variants of proc_create{,_data} that directly take a struct seq_operations
    argument and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/net/rose.h b/include/net/rose.h
index 04b72681f2ab..cf517d306a28 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -200,9 +200,9 @@ void rose_enquiry_response(struct sock *);
 
 /* rose_route.c */
 extern struct rose_neigh *rose_loopback_neigh;
-extern const struct file_operations rose_neigh_fops;
-extern const struct file_operations rose_nodes_fops;
-extern const struct file_operations rose_routes_fops;
+extern const struct seq_operations rose_neigh_seqops;
+extern const struct seq_operations rose_node_seqops;
+extern struct seq_operations rose_route_seqops;
 
 void rose_add_loopback_neigh(void);
 int __must_check rose_add_loopback_node(rose_address *);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/rose.h b/include/net/rose.h
index 50811fe2c585..04b72681f2ab 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  *	Declarations of Rose type objects.
  *

commit 54df3b961db19e3eb6ccbac0ca469c56b1b58689
Author: Joe Perches <joe@perches.com>
Date:   Sun Sep 22 10:32:21 2013 -0700

    rose.h: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index 555dd198aab7..50811fe2c585 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -160,38 +160,42 @@ extern int  sysctl_rose_routing_control;
 extern int  sysctl_rose_link_fail_timeout;
 extern int  sysctl_rose_maximum_vcs;
 extern int  sysctl_rose_window_size;
-extern int  rosecmp(rose_address *, rose_address *);
-extern int  rosecmpm(rose_address *, rose_address *, unsigned short);
-extern char *rose2asc(char *buf, const rose_address *);
-extern struct sock *rose_find_socket(unsigned int, struct rose_neigh *);
-extern void rose_kill_by_neigh(struct rose_neigh *);
-extern unsigned int rose_new_lci(struct rose_neigh *);
-extern int  rose_rx_call_request(struct sk_buff *, struct net_device *, struct rose_neigh *, unsigned int);
-extern void rose_destroy_socket(struct sock *);
+
+int rosecmp(rose_address *, rose_address *);
+int rosecmpm(rose_address *, rose_address *, unsigned short);
+char *rose2asc(char *buf, const rose_address *);
+struct sock *rose_find_socket(unsigned int, struct rose_neigh *);
+void rose_kill_by_neigh(struct rose_neigh *);
+unsigned int rose_new_lci(struct rose_neigh *);
+int rose_rx_call_request(struct sk_buff *, struct net_device *,
+			 struct rose_neigh *, unsigned int);
+void rose_destroy_socket(struct sock *);
 
 /* rose_dev.c */
-extern void  rose_setup(struct net_device *);
+void rose_setup(struct net_device *);
 
 /* rose_in.c */
-extern int  rose_process_rx_frame(struct sock *, struct sk_buff *);
+int rose_process_rx_frame(struct sock *, struct sk_buff *);
 
 /* rose_link.c */
-extern void rose_start_ftimer(struct rose_neigh *);
-extern void rose_stop_ftimer(struct rose_neigh *);
-extern void rose_stop_t0timer(struct rose_neigh *);
-extern int  rose_ftimer_running(struct rose_neigh *);
-extern void rose_link_rx_restart(struct sk_buff *, struct rose_neigh *, unsigned short);
-extern void rose_transmit_clear_request(struct rose_neigh *, unsigned int, unsigned char, unsigned char);
-extern void rose_transmit_link(struct sk_buff *, struct rose_neigh *);
+void rose_start_ftimer(struct rose_neigh *);
+void rose_stop_ftimer(struct rose_neigh *);
+void rose_stop_t0timer(struct rose_neigh *);
+int rose_ftimer_running(struct rose_neigh *);
+void rose_link_rx_restart(struct sk_buff *, struct rose_neigh *,
+			  unsigned short);
+void rose_transmit_clear_request(struct rose_neigh *, unsigned int,
+				 unsigned char, unsigned char);
+void rose_transmit_link(struct sk_buff *, struct rose_neigh *);
 
 /* rose_loopback.c */
-extern void rose_loopback_init(void);
-extern void rose_loopback_clear(void);
-extern int  rose_loopback_queue(struct sk_buff *, struct rose_neigh *);
+void rose_loopback_init(void);
+void rose_loopback_clear(void);
+int rose_loopback_queue(struct sk_buff *, struct rose_neigh *);
 
 /* rose_out.c */
-extern void rose_kick(struct sock *);
-extern void rose_enquiry_response(struct sock *);
+void rose_kick(struct sock *);
+void rose_enquiry_response(struct sock *);
 
 /* rose_route.c */
 extern struct rose_neigh *rose_loopback_neigh;
@@ -199,43 +203,45 @@ extern const struct file_operations rose_neigh_fops;
 extern const struct file_operations rose_nodes_fops;
 extern const struct file_operations rose_routes_fops;
 
-extern void rose_add_loopback_neigh(void);
-extern int __must_check rose_add_loopback_node(rose_address *);
-extern void rose_del_loopback_node(rose_address *);
-extern void rose_rt_device_down(struct net_device *);
-extern void rose_link_device_down(struct net_device *);
-extern struct net_device *rose_dev_first(void);
-extern struct net_device *rose_dev_get(rose_address *);
-extern struct rose_route *rose_route_free_lci(unsigned int, struct rose_neigh *);
-extern struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *, unsigned char *, int);
-extern int  rose_rt_ioctl(unsigned int, void __user *);
-extern void rose_link_failed(ax25_cb *, int);
-extern int  rose_route_frame(struct sk_buff *, ax25_cb *);
-extern void rose_rt_free(void);
+void rose_add_loopback_neigh(void);
+int __must_check rose_add_loopback_node(rose_address *);
+void rose_del_loopback_node(rose_address *);
+void rose_rt_device_down(struct net_device *);
+void rose_link_device_down(struct net_device *);
+struct net_device *rose_dev_first(void);
+struct net_device *rose_dev_get(rose_address *);
+struct rose_route *rose_route_free_lci(unsigned int, struct rose_neigh *);
+struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *,
+				  unsigned char *, int);
+int rose_rt_ioctl(unsigned int, void __user *);
+void rose_link_failed(ax25_cb *, int);
+int rose_route_frame(struct sk_buff *, ax25_cb *);
+void rose_rt_free(void);
 
 /* rose_subr.c */
-extern void rose_clear_queues(struct sock *);
-extern void rose_frames_acked(struct sock *, unsigned short);
-extern void rose_requeue_frames(struct sock *);
-extern int  rose_validate_nr(struct sock *, unsigned short);
-extern void rose_write_internal(struct sock *, int);
-extern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);
-extern int  rose_parse_facilities(unsigned char *, unsigned int, struct rose_facilities_struct *);
-extern void rose_disconnect(struct sock *, int, int, int);
+void rose_clear_queues(struct sock *);
+void rose_frames_acked(struct sock *, unsigned short);
+void rose_requeue_frames(struct sock *);
+int rose_validate_nr(struct sock *, unsigned short);
+void rose_write_internal(struct sock *, int);
+int rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);
+int rose_parse_facilities(unsigned char *, unsigned int,
+			  struct rose_facilities_struct *);
+void rose_disconnect(struct sock *, int, int, int);
 
 /* rose_timer.c */
-extern void rose_start_heartbeat(struct sock *);
-extern void rose_start_t1timer(struct sock *);
-extern void rose_start_t2timer(struct sock *);
-extern void rose_start_t3timer(struct sock *);
-extern void rose_start_hbtimer(struct sock *);
-extern void rose_start_idletimer(struct sock *);
-extern void rose_stop_heartbeat(struct sock *);
-extern void rose_stop_timer(struct sock *);
-extern void rose_stop_idletimer(struct sock *);
+void rose_start_heartbeat(struct sock *);
+void rose_start_t1timer(struct sock *);
+void rose_start_t2timer(struct sock *);
+void rose_start_t3timer(struct sock *);
+void rose_start_hbtimer(struct sock *);
+void rose_start_idletimer(struct sock *);
+void rose_stop_heartbeat(struct sock *);
+void rose_stop_timer(struct sock *);
+void rose_stop_idletimer(struct sock *);
 
 /* sysctl_net_rose.c */
-extern void rose_register_sysctl(void);
-extern void rose_unregister_sysctl(void);
+void rose_register_sysctl(void);
+void rose_unregister_sysctl(void);
 
 #endif

commit e0bccd315db0c2f919e7fcf9cb60db21d9986f52
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sun Mar 20 06:48:05 2011 +0000

    rose: Add length checks to CALL_REQUEST parsing
    
    Define some constant offsets for CALL_REQUEST based on the description
    at <http://www.techfest.com/networking/wan/x25plp.htm> and the
    definition of ROSE as using 10-digit (5-byte) addresses.  Use them
    consistently.  Validate all implicit and explicit facilities lengths.
    Validate the address length byte rather than either trusting or
    assuming its value.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index 5ba9f02731eb..555dd198aab7 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -14,6 +14,12 @@
 
 #define	ROSE_MIN_LEN			3
 
+#define	ROSE_CALL_REQ_ADDR_LEN_OFF	3
+#define	ROSE_CALL_REQ_ADDR_LEN_VAL	0xAA	/* each address is 10 digits */
+#define	ROSE_CALL_REQ_DEST_ADDR_OFF	4
+#define	ROSE_CALL_REQ_SRC_ADDR_OFF	9
+#define	ROSE_CALL_REQ_FACILITIES_OFF	14
+
 #define	ROSE_GFI			0x10
 #define	ROSE_Q_BIT			0x80
 #define	ROSE_D_BIT			0x40
@@ -214,7 +220,7 @@ extern void rose_requeue_frames(struct sock *);
 extern int  rose_validate_nr(struct sock *, unsigned short);
 extern void rose_write_internal(struct sock *, int);
 extern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);
-extern int  rose_parse_facilities(unsigned char *, struct rose_facilities_struct *);
+extern int  rose_parse_facilities(unsigned char *, unsigned int, struct rose_facilities_struct *);
 extern void rose_disconnect(struct sock *, int, int, int);
 
 /* rose_timer.c */

commit dcf777f6ed9799c5ac90ac17a5c369e6b73ca92e
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Jul 26 19:11:14 2009 -0700

    NET: ROSE: Don't use static buffer.
    
    The use of a static buffer in rose2asc() to return its result is not
    threadproof and can result in corruption if multiple threads are trying
    to use one of the procfs files based on rose2asc().
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index cbd5364b2c8a..5ba9f02731eb 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -156,7 +156,7 @@ extern int  sysctl_rose_maximum_vcs;
 extern int  sysctl_rose_window_size;
 extern int  rosecmp(rose_address *, rose_address *);
 extern int  rosecmpm(rose_address *, rose_address *, unsigned short);
-extern const char *rose2asc(const rose_address *);
+extern char *rose2asc(char *buf, const rose_address *);
 extern struct sock *rose_find_socket(unsigned int, struct rose_neigh *);
 extern void rose_kill_by_neigh(struct rose_neigh *);
 extern unsigned int rose_new_lci(struct rose_neigh *);

commit fe2c802ab62aa63d276deafa905875f3455f2621
Author: Bernard Pidoux <f6bvp@amsat.org>
Date:   Tue Jun 17 17:08:32 2008 -0700

    rose: improving AX25 routing frames via ROSE network
    
    ROSE network is organized through nodes connected via hamradio or Internet.
    AX25 packet radio frames sent to a remote ROSE address destination are routed
    through these nodes.
    
    Without the present patch, automatic routing mechanism did not work optimally
    due to an improper parameter checking.
    
    rose_get_neigh() function is called either by rose_connect() or by
    rose_route_frame().
    
    In the case of a call from rose_connect(), f0 timer is checked to find if a connection
    is already pending. In that case it returns the address of the neighbour, or returns a NULL otherwise.
    
    When called by rose_route_frame() the purpose was to route a packet AX25 frame
    through an adjacent node given a destination rose address.
    However, in that case, t0 timer checked does not indicate if the adjacent node
    is actually connected even if the timer is not null. Thus, for each frame sent, the
    function often tried to start a new connexion even if the adjacent node was already connected.
    
    The patch adds a "new" parameter that is true when the function is called by
    rose route_frame().
    This instructs rose_get_neigh() to check node parameter "restarted".
    If restarted is true it means that the route to the destination address is opened via a neighbour
    node already connected.
    If "restarted" is false the function returns a NULL.
    In that case the calling function will initiate a new connection as before.
    
    This results in a fast routing of frames, from nodes to nodes, until
    destination is reached, as originaly specified by ROSE protocole.
    
    Signed-off-by: Bernard Pidoux <f6bvp@amsat.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index e5bb084d8754..cbd5364b2c8a 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -201,7 +201,7 @@ extern void rose_link_device_down(struct net_device *);
 extern struct net_device *rose_dev_first(void);
 extern struct net_device *rose_dev_get(rose_address *);
 extern struct rose_route *rose_route_free_lci(unsigned int, struct rose_neigh *);
-extern struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *, unsigned char *);
+extern struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *, unsigned char *, int);
 extern int  rose_rt_ioctl(unsigned int, void __user *);
 extern void rose_link_failed(ax25_cb *, int);
 extern int  rose_route_frame(struct sk_buff *, ax25_cb *);

commit 891e6a931255238dddd08a7b306871240961a27f
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sun Oct 7 23:44:17 2007 -0700

    [ROSE]: Fix rose.ko oops on unload
    
    Commit a3d384029aa304f8f3f5355d35f0ae274454f7cd aka
    "[AX.25]: Fix unchecked rose_add_loopback_neigh uses"
    transformed rose_loopback_neigh var into statically allocated one.
    However, on unload it will be kfree's which can't work.
    
    Steps to reproduce:
    
            modprobe rose
            rmmod rose
    
    BUG: unable to handle kernel NULL pointer dereference at virtual address 00000008
     printing eip:
    c014c664
    *pde = 00000000
    Oops: 0000 [#1]
    PREEMPT DEBUG_PAGEALLOC
    Modules linked in: rose ax25 fan ufs loop usbhid rtc snd_intel8x0 snd_ac97_codec ehci_hcd ac97_bus uhci_hcd thermal usbcore button processor evdev sr_mod cdrom
    CPU:    0
    EIP:    0060:[<c014c664>]    Not tainted VLI
    EFLAGS: 00210086   (2.6.23-rc9 #3)
    EIP is at kfree+0x48/0xa1
    eax: 00000556   ebx: c1734aa0   ecx: f6a5e000   edx: f7082000
    esi: 00000000   edi: f9a55d20   ebp: 00200287   esp: f6a5ef28
    ds: 007b   es: 007b   fs: 0000  gs: 0033  ss: 0068
    Process rmmod (pid: 1823, ti=f6a5e000 task=f7082000 task.ti=f6a5e000)
    Stack: f9a55d20 f9a5200c 00000000 00000000 00000000 f6a5e000 f9a5200c f9a55a00
           00000000 bf818cf0 f9a51f3f f9a55a00 00000000 c0132c60 65736f72 00000000
           f69f9630 f69f9528 c014244a f6a4e900 00200246 f7082000 c01025e6 00000000
    Call Trace:
     [<f9a5200c>] rose_rt_free+0x1d/0x49 [rose]
     [<f9a5200c>] rose_rt_free+0x1d/0x49 [rose]
     [<f9a51f3f>] rose_exit+0x4c/0xd5 [rose]
     [<c0132c60>] sys_delete_module+0x15e/0x186
     [<c014244a>] remove_vma+0x40/0x45
     [<c01025e6>] sysenter_past_esp+0x8f/0x99
     [<c012bacf>] trace_hardirqs_on+0x118/0x13b
     [<c01025b6>] sysenter_past_esp+0x5f/0x99
     =======================
    Code: 05 03 1d 80 db 5b c0 8b 03 25 00 40 02 00 3d 00 40 02 00 75 03 8b 5b 0c 8b 73 10 8b 44 24 18 89 44 24 04 9c 5d fa e8 77 df fd ff <8b> 56 08 89 f8 e8 84 f4 fd ff e8 bd 32 06 00 3b 5c 86 60 75 0f
    EIP: [<c014c664>] kfree+0x48/0xa1 SS:ESP 0068:f6a5ef28
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index a4047d3cf5dd..e5bb084d8754 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -188,7 +188,7 @@ extern void rose_kick(struct sock *);
 extern void rose_enquiry_response(struct sock *);
 
 /* rose_route.c */
-extern struct rose_neigh rose_loopback_neigh;
+extern struct rose_neigh *rose_loopback_neigh;
 extern const struct file_operations rose_neigh_fops;
 extern const struct file_operations rose_nodes_fops;
 extern const struct file_operations rose_routes_fops;

commit 540473208f8ac71c25a87e1a2670c3c18dd4d6db
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:28 2007 -0800

    [PATCH] mark struct file_operations const 1
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/net/rose.h b/include/net/rose.h
index 4c05a88b921b..a4047d3cf5dd 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -189,9 +189,9 @@ extern void rose_enquiry_response(struct sock *);
 
 /* rose_route.c */
 extern struct rose_neigh rose_loopback_neigh;
-extern struct file_operations rose_neigh_fops;
-extern struct file_operations rose_nodes_fops;
-extern struct file_operations rose_routes_fops;
+extern const struct file_operations rose_neigh_fops;
+extern const struct file_operations rose_nodes_fops;
+extern const struct file_operations rose_routes_fops;
 
 extern void rose_add_loopback_neigh(void);
 extern int __must_check rose_add_loopback_node(rose_address *);

commit a3d384029aa304f8f3f5355d35f0ae274454f7cd
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Dec 14 15:52:13 2006 -0800

    [AX.25]: Fix unchecked rose_add_loopback_neigh uses
    
    rose_add_loopback_neigh uses kmalloc and the callers were ignoring the
    error value.  Rewrite to let the caller deal with the allocation.  This
    allows the use of static allocation of kmalloc use entirely.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index 0143796a3e37..4c05a88b921b 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -188,12 +188,12 @@ extern void rose_kick(struct sock *);
 extern void rose_enquiry_response(struct sock *);
 
 /* rose_route.c */
-extern struct rose_neigh *rose_loopback_neigh;
+extern struct rose_neigh rose_loopback_neigh;
 extern struct file_operations rose_neigh_fops;
 extern struct file_operations rose_nodes_fops;
 extern struct file_operations rose_routes_fops;
 
-extern int __must_check rose_add_loopback_neigh(void);
+extern void rose_add_loopback_neigh(void);
 extern int __must_check rose_add_loopback_node(rose_address *);
 extern void rose_del_loopback_node(rose_address *);
 extern void rose_rt_device_down(struct net_device *);

commit c9266b99e2def0a456766220df09713f8e765891
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Dec 14 15:49:28 2006 -0800

    [AX.25]: Mark all kmalloc users __must_check
    
    The recent fix 0506d4068bad834aab1141b5dc5e748eb175c6b3 made obvious that
    error values were not being propagated through the AX.25 stack.  To help
    with that this patch marks all kmalloc users in the AX.25, NETROM and
    ROSE stacks as __must_check.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index 012b09ed2401..0143796a3e37 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -193,8 +193,8 @@ extern struct file_operations rose_neigh_fops;
 extern struct file_operations rose_nodes_fops;
 extern struct file_operations rose_routes_fops;
 
-extern int  rose_add_loopback_neigh(void);
-extern int  rose_add_loopback_node(rose_address *);
+extern int __must_check rose_add_loopback_neigh(void);
+extern int __must_check rose_add_loopback_node(rose_address *);
 extern void rose_del_loopback_node(rose_address *);
 extern void rose_rt_device_down(struct net_device *);
 extern void rose_link_device_down(struct net_device *);

commit 82e84249f0ee098e004c8bd6d90a1640bd56cfbb
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed May 3 23:28:20 2006 -0700

    [ROSE]: Eleminate HZ from ROSE kernel interfaces
    
    Convert all ROSE sysctl time values from jiffies to ms as units.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/rose.h b/include/net/rose.h
index 3249b979605a..012b09ed2401 100644
--- a/include/net/rose.h
+++ b/include/net/rose.h
@@ -49,14 +49,14 @@ enum {
 	ROSE_STATE_5			/* Deferred Call Acceptance */
 };
 
-#define ROSE_DEFAULT_T0			(180 * HZ)	/* Default T10 T20 value */
-#define ROSE_DEFAULT_T1			(200 * HZ)	/* Default T11 T21 value */
-#define ROSE_DEFAULT_T2			(180 * HZ)	/* Default T12 T22 value */
-#define	ROSE_DEFAULT_T3			(180 * HZ)	/* Default T13 T23 value */
-#define	ROSE_DEFAULT_HB			(5 * HZ)	/* Default Holdback value */
-#define	ROSE_DEFAULT_IDLE		(0 * 60 * HZ)	/* No Activity Timeout - none */
+#define ROSE_DEFAULT_T0			180000		/* Default T10 T20 value */
+#define ROSE_DEFAULT_T1			200000		/* Default T11 T21 value */
+#define ROSE_DEFAULT_T2			180000		/* Default T12 T22 value */
+#define	ROSE_DEFAULT_T3			180000		/* Default T13 T23 value */
+#define	ROSE_DEFAULT_HB			5000		/* Default Holdback value */
+#define	ROSE_DEFAULT_IDLE		0		/* No Activity Timeout - none */
 #define	ROSE_DEFAULT_ROUTING		1		/* Default routing flag */
-#define	ROSE_DEFAULT_FAIL_TIMEOUT	(120 * HZ)	/* Time until link considered usable */
+#define	ROSE_DEFAULT_FAIL_TIMEOUT	120000		/* Time until link considered usable */
 #define	ROSE_DEFAULT_MAXVC		50		/* Maximum number of VCs per neighbour */
 #define	ROSE_DEFAULT_WINDOW_SIZE	7		/* Default window size */
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/rose.h b/include/net/rose.h
new file mode 100644
index 000000000000..3249b979605a
--- /dev/null
+++ b/include/net/rose.h
@@ -0,0 +1,235 @@
+/*
+ *	Declarations of Rose type objects.
+ *
+ *	Jonathan Naylor G4KLX	25/8/96
+ */
+
+#ifndef _ROSE_H
+#define _ROSE_H 
+
+#include <linux/rose.h>
+#include <net/sock.h>
+
+#define	ROSE_ADDR_LEN			5
+
+#define	ROSE_MIN_LEN			3
+
+#define	ROSE_GFI			0x10
+#define	ROSE_Q_BIT			0x80
+#define	ROSE_D_BIT			0x40
+#define	ROSE_M_BIT			0x10
+
+#define	ROSE_CALL_REQUEST		0x0B
+#define	ROSE_CALL_ACCEPTED		0x0F
+#define	ROSE_CLEAR_REQUEST		0x13
+#define	ROSE_CLEAR_CONFIRMATION		0x17
+#define	ROSE_DATA			0x00
+#define	ROSE_INTERRUPT			0x23
+#define	ROSE_INTERRUPT_CONFIRMATION	0x27
+#define	ROSE_RR				0x01
+#define	ROSE_RNR			0x05
+#define	ROSE_REJ			0x09
+#define	ROSE_RESET_REQUEST		0x1B
+#define	ROSE_RESET_CONFIRMATION		0x1F
+#define	ROSE_REGISTRATION_REQUEST	0xF3
+#define	ROSE_REGISTRATION_CONFIRMATION	0xF7
+#define	ROSE_RESTART_REQUEST		0xFB
+#define	ROSE_RESTART_CONFIRMATION	0xFF
+#define	ROSE_DIAGNOSTIC			0xF1
+#define	ROSE_ILLEGAL			0xFD
+
+/* Define Link State constants. */
+
+enum {
+	ROSE_STATE_0,			/* Ready */
+	ROSE_STATE_1,			/* Awaiting Call Accepted */
+	ROSE_STATE_2,			/* Awaiting Clear Confirmation */
+	ROSE_STATE_3,			/* Data Transfer */
+	ROSE_STATE_4,			/* Awaiting Reset Confirmation */
+	ROSE_STATE_5			/* Deferred Call Acceptance */
+};
+
+#define ROSE_DEFAULT_T0			(180 * HZ)	/* Default T10 T20 value */
+#define ROSE_DEFAULT_T1			(200 * HZ)	/* Default T11 T21 value */
+#define ROSE_DEFAULT_T2			(180 * HZ)	/* Default T12 T22 value */
+#define	ROSE_DEFAULT_T3			(180 * HZ)	/* Default T13 T23 value */
+#define	ROSE_DEFAULT_HB			(5 * HZ)	/* Default Holdback value */
+#define	ROSE_DEFAULT_IDLE		(0 * 60 * HZ)	/* No Activity Timeout - none */
+#define	ROSE_DEFAULT_ROUTING		1		/* Default routing flag */
+#define	ROSE_DEFAULT_FAIL_TIMEOUT	(120 * HZ)	/* Time until link considered usable */
+#define	ROSE_DEFAULT_MAXVC		50		/* Maximum number of VCs per neighbour */
+#define	ROSE_DEFAULT_WINDOW_SIZE	7		/* Default window size */
+
+#define ROSE_MODULUS 			8
+#define	ROSE_MAX_PACKET_SIZE		251		/* Maximum packet size */
+
+#define	ROSE_COND_ACK_PENDING		0x01
+#define	ROSE_COND_PEER_RX_BUSY		0x02
+#define	ROSE_COND_OWN_RX_BUSY		0x04
+
+#define	FAC_NATIONAL			0x00
+#define	FAC_CCITT			0x0F
+
+#define	FAC_NATIONAL_RAND		0x7F
+#define	FAC_NATIONAL_FLAGS		0x3F
+#define	FAC_NATIONAL_DEST_DIGI		0xE9
+#define	FAC_NATIONAL_SRC_DIGI		0xEB
+#define	FAC_NATIONAL_FAIL_CALL		0xED
+#define	FAC_NATIONAL_FAIL_ADD		0xEE
+#define	FAC_NATIONAL_DIGIS			0xEF
+
+#define	FAC_CCITT_DEST_NSAP		0xC9
+#define	FAC_CCITT_SRC_NSAP		0xCB
+
+struct rose_neigh {
+	struct rose_neigh	*next;
+	ax25_address		callsign;
+	ax25_digi		*digipeat;
+	ax25_cb			*ax25;
+	struct net_device		*dev;
+	unsigned short		count;
+	unsigned short		use;
+	unsigned int		number;
+	char			restarted;
+	char			dce_mode;
+	char			loopback;
+	struct sk_buff_head	queue;
+	struct timer_list	t0timer;
+	struct timer_list	ftimer;
+};
+
+struct rose_node {
+	struct rose_node	*next;
+	rose_address		address;
+	unsigned short		mask;
+	unsigned char		count;
+	char			loopback;
+	struct rose_neigh	*neighbour[3];
+};
+
+struct rose_route {
+	struct rose_route	*next;
+	unsigned int		lci1, lci2;
+	rose_address		src_addr, dest_addr;
+	ax25_address		src_call, dest_call;
+	struct rose_neigh 	*neigh1, *neigh2;
+	unsigned int		rand;
+};
+
+struct rose_sock {
+	struct sock		sock;
+	rose_address		source_addr,   dest_addr;
+	ax25_address		source_call,   dest_call;
+	unsigned char		source_ndigis, dest_ndigis;
+	ax25_address		source_digis[ROSE_MAX_DIGIS];
+	ax25_address		dest_digis[ROSE_MAX_DIGIS];
+	struct rose_neigh	*neighbour;
+	struct net_device		*device;
+	unsigned int		lci, rand;
+	unsigned char		state, condition, qbitincl, defer;
+	unsigned char		cause, diagnostic;
+	unsigned short		vs, vr, va, vl;
+	unsigned long		t1, t2, t3, hb, idle;
+#ifdef M_BIT
+	unsigned short		fraglen;
+	struct sk_buff_head	frag_queue;
+#endif
+	struct sk_buff_head	ack_queue;
+	struct rose_facilities_struct facilities;
+	struct timer_list	timer;
+	struct timer_list	idletimer;
+};
+
+#define rose_sk(sk) ((struct rose_sock *)(sk))
+
+/* af_rose.c */
+extern ax25_address rose_callsign;
+extern int  sysctl_rose_restart_request_timeout;
+extern int  sysctl_rose_call_request_timeout;
+extern int  sysctl_rose_reset_request_timeout;
+extern int  sysctl_rose_clear_request_timeout;
+extern int  sysctl_rose_no_activity_timeout;
+extern int  sysctl_rose_ack_hold_back_timeout;
+extern int  sysctl_rose_routing_control;
+extern int  sysctl_rose_link_fail_timeout;
+extern int  sysctl_rose_maximum_vcs;
+extern int  sysctl_rose_window_size;
+extern int  rosecmp(rose_address *, rose_address *);
+extern int  rosecmpm(rose_address *, rose_address *, unsigned short);
+extern const char *rose2asc(const rose_address *);
+extern struct sock *rose_find_socket(unsigned int, struct rose_neigh *);
+extern void rose_kill_by_neigh(struct rose_neigh *);
+extern unsigned int rose_new_lci(struct rose_neigh *);
+extern int  rose_rx_call_request(struct sk_buff *, struct net_device *, struct rose_neigh *, unsigned int);
+extern void rose_destroy_socket(struct sock *);
+
+/* rose_dev.c */
+extern void  rose_setup(struct net_device *);
+
+/* rose_in.c */
+extern int  rose_process_rx_frame(struct sock *, struct sk_buff *);
+
+/* rose_link.c */
+extern void rose_start_ftimer(struct rose_neigh *);
+extern void rose_stop_ftimer(struct rose_neigh *);
+extern void rose_stop_t0timer(struct rose_neigh *);
+extern int  rose_ftimer_running(struct rose_neigh *);
+extern void rose_link_rx_restart(struct sk_buff *, struct rose_neigh *, unsigned short);
+extern void rose_transmit_clear_request(struct rose_neigh *, unsigned int, unsigned char, unsigned char);
+extern void rose_transmit_link(struct sk_buff *, struct rose_neigh *);
+
+/* rose_loopback.c */
+extern void rose_loopback_init(void);
+extern void rose_loopback_clear(void);
+extern int  rose_loopback_queue(struct sk_buff *, struct rose_neigh *);
+
+/* rose_out.c */
+extern void rose_kick(struct sock *);
+extern void rose_enquiry_response(struct sock *);
+
+/* rose_route.c */
+extern struct rose_neigh *rose_loopback_neigh;
+extern struct file_operations rose_neigh_fops;
+extern struct file_operations rose_nodes_fops;
+extern struct file_operations rose_routes_fops;
+
+extern int  rose_add_loopback_neigh(void);
+extern int  rose_add_loopback_node(rose_address *);
+extern void rose_del_loopback_node(rose_address *);
+extern void rose_rt_device_down(struct net_device *);
+extern void rose_link_device_down(struct net_device *);
+extern struct net_device *rose_dev_first(void);
+extern struct net_device *rose_dev_get(rose_address *);
+extern struct rose_route *rose_route_free_lci(unsigned int, struct rose_neigh *);
+extern struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *, unsigned char *);
+extern int  rose_rt_ioctl(unsigned int, void __user *);
+extern void rose_link_failed(ax25_cb *, int);
+extern int  rose_route_frame(struct sk_buff *, ax25_cb *);
+extern void rose_rt_free(void);
+
+/* rose_subr.c */
+extern void rose_clear_queues(struct sock *);
+extern void rose_frames_acked(struct sock *, unsigned short);
+extern void rose_requeue_frames(struct sock *);
+extern int  rose_validate_nr(struct sock *, unsigned short);
+extern void rose_write_internal(struct sock *, int);
+extern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);
+extern int  rose_parse_facilities(unsigned char *, struct rose_facilities_struct *);
+extern void rose_disconnect(struct sock *, int, int, int);
+
+/* rose_timer.c */
+extern void rose_start_heartbeat(struct sock *);
+extern void rose_start_t1timer(struct sock *);
+extern void rose_start_t2timer(struct sock *);
+extern void rose_start_t3timer(struct sock *);
+extern void rose_start_hbtimer(struct sock *);
+extern void rose_start_idletimer(struct sock *);
+extern void rose_stop_heartbeat(struct sock *);
+extern void rose_stop_timer(struct sock *);
+extern void rose_stop_idletimer(struct sock *);
+
+/* sysctl_net_rose.c */
+extern void rose_register_sysctl(void);
+extern void rose_unregister_sysctl(void);
+
+#endif
