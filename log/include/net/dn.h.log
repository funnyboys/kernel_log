commit 2a171788ba7bb61995e98e8163204fc7880f63b2
Merge: bf5345882bd1 d4c2e9fca5b7
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Nov 4 09:26:51 2017 +0900

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Files removed in 'net-next' had their license header updated
    in 'net'.  We take the remove from 'net-next'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/dn.h b/include/net/dn.h
index 913b73d239f5..fc0036228d20 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _NET_DN_H
 #define _NET_DN_H
 

commit eb4ddaf474285a4c6986f4a1c3205bdb0bed2da9
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:28:45 2017 -0700

    net/decnet: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Johannes Berg <johannes.berg@intel.com>
    Cc: David Ahern <dsa@cumulusnetworks.com>
    Cc: linux-decnet-user@lists.sourceforge.net
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 913b73d239f5..4394f7d5cfe8 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -122,13 +122,6 @@ struct dn_scp                                   /* Session Control Port */
 	unsigned long keepalive;
 	void (*keepalive_fxn)(struct sock *sk);
 
-	/*
-	 * This stuff is for the fast timer for delayed acks
-	 */
-	struct timer_list delack_timer;
-	int delack_pending;
-	void (*delack_fxn)(struct sock *sk);
-
 };
 
 static inline struct dn_scp *DN_SK(struct sock *sk)

commit ab3301bd96c024ec9c2e1c35c90327dc5c8012a4
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Sun Feb 9 22:22:53 2014 +0530

    net: Move prototype declaration to header file include/net/dn.h from net/decnet/af_decnet.c
    
    Move prototype declaration of functions to header file include/net/dn.h
    from net/decnet/af_decnet.c because they are used by more than one file.
    
    This eliminates the following warning in net/decnet/af_decnet.c:
    net/decnet/sysctl_net_decnet.c:354:6: warning: no previous prototype for ‘dn_register_sysctl’ [-Wmissing-prototypes]
    net/decnet/sysctl_net_decnet.c:359:6: warning: no previous prototype for ‘dn_unregister_sysctl’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index ccc15588d108..913b73d239f5 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -200,6 +200,8 @@ static inline void dn_sk_ports_copy(struct flowidn *fld, struct dn_scp *scp)
 }
 
 unsigned int dn_mss_from_pmtu(struct net_device *dev, int mtu);
+void dn_register_sysctl(void);
+void dn_unregister_sysctl(void);
 
 #define DN_MENUVER_ACC 0x01
 #define DN_MENUVER_USR 0x02

commit 59ddd965c2388720681eb4dc386bfb074e80788e
Author: Joe Perches <joe@perches.com>
Date:   Fri Sep 20 11:23:20 2013 -0700

    decnet (dn*.h): Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index c88bf4ebd330..ccc15588d108 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -199,24 +199,26 @@ static inline void dn_sk_ports_copy(struct flowidn *fld, struct dn_scp *scp)
 	fld->fld_dport = scp->addrrem;
 }
 
-extern unsigned int dn_mss_from_pmtu(struct net_device *dev, int mtu);
+unsigned int dn_mss_from_pmtu(struct net_device *dev, int mtu);
 
 #define DN_MENUVER_ACC 0x01
 #define DN_MENUVER_USR 0x02
 #define DN_MENUVER_PRX 0x04
 #define DN_MENUVER_UIC 0x08
 
-extern struct sock *dn_sklist_find_listener(struct sockaddr_dn *addr);
-extern struct sock *dn_find_by_skb(struct sk_buff *skb);
+struct sock *dn_sklist_find_listener(struct sockaddr_dn *addr);
+struct sock *dn_find_by_skb(struct sk_buff *skb);
 #define DN_ASCBUF_LEN 9
-extern char *dn_addr2asc(__u16, char *);
-extern int dn_destroy_timer(struct sock *sk);
+char *dn_addr2asc(__u16, char *);
+int dn_destroy_timer(struct sock *sk);
 
-extern int dn_sockaddr2username(struct sockaddr_dn *addr, unsigned char *buf, unsigned char type);
-extern int dn_username2sockaddr(unsigned char *data, int len, struct sockaddr_dn *addr, unsigned char *type);
+int dn_sockaddr2username(struct sockaddr_dn *addr, unsigned char *buf,
+			 unsigned char type);
+int dn_username2sockaddr(unsigned char *data, int len, struct sockaddr_dn *addr,
+			 unsigned char *type);
 
-extern void dn_start_slow_timer(struct sock *sk);
-extern void dn_stop_slow_timer(struct sock *sk);
+void dn_start_slow_timer(struct sock *sk);
+void dn_stop_slow_timer(struct sock *sk);
 
 extern __le16 decnet_address;
 extern int decnet_debug_level;

commit 95c961747284a6b83a5e2d81240e214b0fa3464d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sun Apr 15 05:58:06 2012 +0000

    net: cleanup unsigned to unsigned int
    
    Use of "unsigned int" is preferred to bare "unsigned" in net tree.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 814af0b9387d..c88bf4ebd330 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -199,7 +199,7 @@ static inline void dn_sk_ports_copy(struct flowidn *fld, struct dn_scp *scp)
 	fld->fld_dport = scp->addrrem;
 }
 
-extern unsigned dn_mss_from_pmtu(struct net_device *dev, int mtu);
+extern unsigned int dn_mss_from_pmtu(struct net_device *dev, int mtu);
 
 #define DN_MENUVER_ACC 0x01
 #define DN_MENUVER_USR 0x02

commit 4c5e40366a8879a3fda6a22a4b65c02ef20a08c4
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Feb 15 16:37:44 2012 -0500

    decnet: net/dn.h needs net/flow.h
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 298521e0d8a2..814af0b9387d 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -3,6 +3,7 @@
 
 #include <linux/dn.h>
 #include <net/sock.h>
+#include <net/flow.h>
 #include <asm/byteorder.h>
 #include <asm/unaligned.h>
 

commit bef55aebd560c5a6f8883c421abccee39978c58c
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 17:17:10 2011 -0500

    decnet: Convert to use flowidn where applicable.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 558dc7f93fb3..298521e0d8a2 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -192,10 +192,10 @@ static inline void dn_dn2eth(unsigned char *ethaddr, __le16 addr)
 	ethaddr[5] = (__u8)(a >> 8);
 }
 
-static inline void dn_sk_ports_copy(struct flowi *fl, struct dn_scp *scp)
+static inline void dn_sk_ports_copy(struct flowidn *fld, struct dn_scp *scp)
 {
-	fl->u.dn.uli.ports.sport = scp->addrloc;
-	fl->u.dn.uli.ports.dport = scp->addrrem;
+	fld->fld_sport = scp->addrloc;
+	fld->fld_dport = scp->addrrem;
 }
 
 extern unsigned dn_mss_from_pmtu(struct net_device *dev, int mtu);

commit 56bb8059e1a8bf291054c26367564dc302f6fd8f
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 12 00:44:35 2011 -0500

    net: Break struct flowi out into AF specific instances.
    
    Now we have struct flowi4, flowi6, and flowidn for each address
    family.  And struct flowi is just a union of them all.
    
    It might have been troublesome to convert flow_cache_uli_match() but
    as it turns out this function is completely unused and therefore can
    be simply removed.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index a514a3cf4573..558dc7f93fb3 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -194,8 +194,8 @@ static inline void dn_dn2eth(unsigned char *ethaddr, __le16 addr)
 
 static inline void dn_sk_ports_copy(struct flowi *fl, struct dn_scp *scp)
 {
-	fl->uli_u.dnports.sport = scp->addrloc;
-	fl->uli_u.dnports.dport = scp->addrrem;
+	fl->u.dn.uli.ports.sport = scp->addrloc;
+	fl->u.dn.uli.ports.dport = scp->addrrem;
 }
 
 extern unsigned dn_mss_from_pmtu(struct net_device *dev, int mtu);

commit 8d987e5c75107ca7515fa19e857cfa24aab6ec8f
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Nov 9 23:24:26 2010 +0000

    net: avoid limits overflow
    
    Robin Holt tried to boot a 16TB machine and found some limits were
    reached : sysctl_tcp_mem[2], sysctl_udp_mem[2]
    
    We can switch infrastructure to use long "instead" of "int", now
    atomic_long_t primitives are available for free.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reported-by: Robin Holt <holt@sgi.com>
    Reviewed-by: Robin Holt <holt@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index e5469f7b67a3..a514a3cf4573 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -225,7 +225,7 @@ extern int decnet_di_count;
 extern int decnet_dr_count;
 extern int decnet_no_fc_max_cwnd;
 
-extern int sysctl_decnet_mem[3];
+extern long sysctl_decnet_mem[3];
 extern int sysctl_decnet_wmem[3];
 extern int sysctl_decnet_rmem[3];
 

commit 475ad8e2172d7f8b73af5532a8dad265b51339c2
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Nov 27 23:04:13 2008 -0800

    decnet: compile fix for removal of byteorder wrapper
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 7cd6bb83f7ab..e5469f7b67a3 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -4,7 +4,7 @@
 #include <linux/dn.h>
 #include <net/sock.h>
 #include <asm/byteorder.h>
-#include <asm/unalignedh>
+#include <asm/unaligned.h>
 
 struct dn_scp                                   /* Session Control Port */
 {

commit c4106aa88a440430d387e022f2ad6dc1e0d52e98
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Nov 27 00:12:47 2008 -0800

    decnet: remove private wrappers of endian helpers
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 627778384c84..7cd6bb83f7ab 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -4,9 +4,7 @@
 #include <linux/dn.h>
 #include <net/sock.h>
 #include <asm/byteorder.h>
-
-#define dn_ntohs(x) le16_to_cpu(x)
-#define dn_htons(x) cpu_to_le16(x)
+#include <asm/unalignedh>
 
 struct dn_scp                                   /* Session Control Port */
 {
@@ -175,7 +173,7 @@ struct dn_skb_cb {
 
 static inline __le16 dn_eth2dn(unsigned char *ethaddr)
 {
-	return dn_htons(ethaddr[4] | (ethaddr[5] << 8));
+	return get_unaligned((__le16 *)(ethaddr + 4));
 }
 
 static inline __le16 dn_saddr2dn(struct sockaddr_dn *saddr)
@@ -185,7 +183,7 @@ static inline __le16 dn_saddr2dn(struct sockaddr_dn *saddr)
 
 static inline void dn_dn2eth(unsigned char *ethaddr, __le16 addr)
 {
-	__u16 a = dn_ntohs(addr);
+	__u16 a = le16_to_cpu(addr);
 	ethaddr[0] = 0xAA;
 	ethaddr[1] = 0x00;
 	ethaddr[2] = 0x04;

commit ed8b548ce3cb988f59a0fd9af6ccdc4f8198cd19
Author: Ilpo Järvinen <ilpo.jarvinen@helsinki.fi>
Date:   Tue Jul 10 23:02:12 2007 -0700

    [DECNET]: Another unnecessary net/tcp.h inclusion in net/dn.h
    
    No longer needed.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@helsinki.fi>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index ac4ce9091747..627778384c84 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -3,7 +3,6 @@
 
 #include <linux/dn.h>
 #include <net/sock.h>
-#include <net/tcp.h>
 #include <asm/byteorder.h>
 
 #define dn_ntohs(x) le16_to_cpu(x)

commit 185b1aa122f87052d9154bb74990bc785372a750
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Sat Oct 21 20:24:01 2006 -0700

    [NET]: Reduce sizeof(struct flowi) by 20 bytes.
    
    As suggested by David, just kill off some unused fields in dnports to
    reduce sizef(struct flowi). If they come back, they should be moved to
    nl_u.dn_u in order not to enlarge again struct flowi
    
    [ Modified to really delete this stuff instead of using #if 0. -DaveM ]
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 465b78302782..ac4ce9091747 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -199,11 +199,6 @@ static inline void dn_sk_ports_copy(struct flowi *fl, struct dn_scp *scp)
 {
 	fl->uli_u.dnports.sport = scp->addrloc;
 	fl->uli_u.dnports.dport = scp->addrrem;
-	fl->uli_u.dnports.objnum = scp->addr.sdn_objnum;
-	if (fl->uli_u.dnports.objnum == 0) {
-		fl->uli_u.dnports.objnamel = (__u8)dn_ntohs(scp->addr.sdn_objnamel);
-		memcpy(fl->uli_u.dnports.objname, scp->addr.sdn_objname, 16);
-	}
 }
 
 extern unsigned dn_mss_from_pmtu(struct net_device *dev, int mtu);

commit c4ea94ab3710eb2434abe2eab1a479c2dc01f8ac
Author: Steven Whitehouse <steve@chygwyn.com>
Date:   Mon Mar 20 22:42:39 2006 -0800

    [DECnet]: Endian annotation and fixes for DECnet.
    
    The typedef for dn_address has been removed in favour of using __le16
    or __u16 directly as appropriate. All the DECnet header files are
    updated accordingly.
    
    The byte ordering of dn_eth2dn() and dn_dn2eth() are both changed
    since just about all their callers wanted network order rather than
    host order, so the conversion is now done in the functions themselves.
    
    Several missed endianess conversions have been picked up during the
    conversion process. The nh_gw field in struct dn_fib_info has been
    changed from a 32 bit field to 16 bits as it ought to be.
    
    One or two cases of using htons rather than dn_htons in the routing
    code have been found and fixed.
    
    There are still a few warnings to fix, but this patch deals with the
    important cases.
    
    Signed-off-by: Steven Whitehouse <steve@chygwyn.com>
    Signed-off-by: Patrick Caulfield <patrick@tykepenguin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index a4b6168e1e25..465b78302782 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -6,10 +6,8 @@
 #include <net/tcp.h>
 #include <asm/byteorder.h>
 
-typedef unsigned short dn_address;
-
-#define dn_ntohs(x) le16_to_cpu((unsigned short)(x))
-#define dn_htons(x) cpu_to_le16((unsigned short)(x))
+#define dn_ntohs(x) le16_to_cpu(x)
+#define dn_htons(x) cpu_to_le16(x)
 
 struct dn_scp                                   /* Session Control Port */
 {
@@ -31,36 +29,36 @@ struct dn_scp                                   /* Session Control Port */
 #define DN_CL    15                     /* Closed               */
 #define DN_CN    16                     /* Closed Notification  */
 
-        unsigned short          addrloc;
-        unsigned short          addrrem;
-        unsigned short          numdat;
-        unsigned short          numoth;
-        unsigned short          numoth_rcv;
-        unsigned short          numdat_rcv;
-        unsigned short          ackxmt_dat;
-        unsigned short          ackxmt_oth;
-        unsigned short          ackrcv_dat;
-        unsigned short          ackrcv_oth;
-        unsigned char           flowrem_sw;
-	unsigned char		flowloc_sw;
+        __le16          addrloc;
+        __le16          addrrem;
+        __u16          numdat;
+        __u16          numoth;
+        __u16          numoth_rcv;
+        __u16          numdat_rcv;
+        __u16          ackxmt_dat;
+        __u16          ackxmt_oth;
+        __u16          ackrcv_dat;
+        __u16          ackrcv_oth;
+        __u8           flowrem_sw;
+	__u8           flowloc_sw;
 #define DN_SEND         2
 #define DN_DONTSEND     1
 #define DN_NOCHANGE     0
-	unsigned short		flowrem_dat;
-	unsigned short		flowrem_oth;
-	unsigned short		flowloc_dat;
-	unsigned short		flowloc_oth;
-	unsigned char		services_rem;
-	unsigned char		services_loc;
-	unsigned char		info_rem;
-	unsigned char		info_loc;
-
-	unsigned short		segsize_rem;
-	unsigned short		segsize_loc;
-
-	unsigned char		nonagle;
-	unsigned char		multi_ireq;
-	unsigned char		accept_mode;
+	__u16		flowrem_dat;
+	__u16		flowrem_oth;
+	__u16		flowloc_dat;
+	__u16		flowloc_oth;
+	__u8		services_rem;
+	__u8		services_loc;
+	__u8		info_rem;
+	__u8		info_loc;
+
+	__u16		segsize_rem;
+	__u16		segsize_loc;
+
+	__u8		nonagle;
+	__u8		multi_ireq;
+	__u8		accept_mode;
 	unsigned long		seg_total; /* Running total of current segment */
 
 	struct optdata_dn     conndata_in;
@@ -160,40 +158,41 @@ static inline struct dn_scp *DN_SK(struct sock *sk)
  */
 #define DN_SKB_CB(skb) ((struct dn_skb_cb *)(skb)->cb)
 struct dn_skb_cb {
-	unsigned short dst;
-	unsigned short src;
-	unsigned short hops;
-	unsigned short dst_port;
-	unsigned short src_port;
-	unsigned char services;
-	unsigned char info;
-	unsigned char rt_flags;
-	unsigned char nsp_flags;
-	unsigned short segsize;
-	unsigned short segnum;
-	unsigned short xmit_count;
+	__le16 dst;
+	__le16 src;
+	__u16 hops;
+	__le16 dst_port;
+	__le16 src_port;
+	__u8 services;
+	__u8 info;
+	__u8 rt_flags;
+	__u8 nsp_flags;
+	__u16 segsize;
+	__u16 segnum;
+	__u16 xmit_count;
 	unsigned long stamp;
 	int iif;
 };
 
-static inline dn_address dn_eth2dn(unsigned char *ethaddr)
+static inline __le16 dn_eth2dn(unsigned char *ethaddr)
 {
-	return ethaddr[4] | (ethaddr[5] << 8);
+	return dn_htons(ethaddr[4] | (ethaddr[5] << 8));
 }
 
-static inline dn_address dn_saddr2dn(struct sockaddr_dn *saddr)
+static inline __le16 dn_saddr2dn(struct sockaddr_dn *saddr)
 {
-	return *(dn_address *)saddr->sdn_nodeaddr;
+	return *(__le16 *)saddr->sdn_nodeaddr;
 }
 
-static inline void dn_dn2eth(unsigned char *ethaddr, dn_address addr)
+static inline void dn_dn2eth(unsigned char *ethaddr, __le16 addr)
 {
+	__u16 a = dn_ntohs(addr);
 	ethaddr[0] = 0xAA;
 	ethaddr[1] = 0x00;
 	ethaddr[2] = 0x04;
 	ethaddr[3] = 0x00;
-	ethaddr[4] = (unsigned char)(addr & 0xff);
-	ethaddr[5] = (unsigned char)(addr >> 8);
+	ethaddr[4] = (__u8)(a & 0xff);
+	ethaddr[5] = (__u8)(a >> 8);
 }
 
 static inline void dn_sk_ports_copy(struct flowi *fl, struct dn_scp *scp)
@@ -202,7 +201,7 @@ static inline void dn_sk_ports_copy(struct flowi *fl, struct dn_scp *scp)
 	fl->uli_u.dnports.dport = scp->addrrem;
 	fl->uli_u.dnports.objnum = scp->addr.sdn_objnum;
 	if (fl->uli_u.dnports.objnum == 0) {
-		fl->uli_u.dnports.objnamel = scp->addr.sdn_objnamel;
+		fl->uli_u.dnports.objnamel = (__u8)dn_ntohs(scp->addr.sdn_objnamel);
 		memcpy(fl->uli_u.dnports.objname, scp->addr.sdn_objname, 16);
 	}
 }
@@ -217,7 +216,7 @@ extern unsigned dn_mss_from_pmtu(struct net_device *dev, int mtu);
 extern struct sock *dn_sklist_find_listener(struct sockaddr_dn *addr);
 extern struct sock *dn_find_by_skb(struct sk_buff *skb);
 #define DN_ASCBUF_LEN 9
-extern char *dn_addr2asc(dn_address, char *);
+extern char *dn_addr2asc(__u16, char *);
 extern int dn_destroy_timer(struct sock *sk);
 
 extern int dn_sockaddr2username(struct sockaddr_dn *addr, unsigned char *buf, unsigned char type);
@@ -226,7 +225,7 @@ extern int dn_username2sockaddr(unsigned char *data, int len, struct sockaddr_dn
 extern void dn_start_slow_timer(struct sock *sk);
 extern void dn_stop_slow_timer(struct sock *sk);
 
-extern dn_address decnet_address;
+extern __le16 decnet_address;
 extern int decnet_debug_level;
 extern int decnet_time_wait;
 extern int decnet_dn_count;

commit 1f12bcc9d1840fd26bf577065214f1ebeb2609ba
Author: Steven Whitehouse <steve@chygwyn.com>
Date:   Mon Dec 5 13:42:06 2005 -0800

    [DECNET]: add memory buffer settings
    
    The patch (originally from Steve) simply adds memory buffer settings to
    DECnet similar to those in TCP.
    
    Signed-off-by: Patrick Caulfield <patrick@tykepenguin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index c1dbbd222793..a4b6168e1e25 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -234,4 +234,8 @@ extern int decnet_di_count;
 extern int decnet_dr_count;
 extern int decnet_no_fc_max_cwnd;
 
+extern int sysctl_decnet_mem[3];
+extern int sysctl_decnet_wmem[3];
+extern int sysctl_decnet_rmem[3];
+
 #endif /* _NET_DN_H */

commit c752f0739f09b803aed191c4765a3b6650a08653
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Tue Aug 9 20:08:28 2005 -0700

    [TCP]: Move the tcp sock states to net/tcp_states.h
    
    Lots of places just needs the states, not even linux/tcp.h, where this
    enum was, needs it.
    
    This speeds up development of the refactorings as less sources are
    rebuilt when things get moved from net/tcp.h.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/dn.h b/include/net/dn.h
index 5551c46db397..c1dbbd222793 100644
--- a/include/net/dn.h
+++ b/include/net/dn.h
@@ -3,6 +3,7 @@
 
 #include <linux/dn.h>
 #include <net/sock.h>
+#include <net/tcp.h>
 #include <asm/byteorder.h>
 
 typedef unsigned short dn_address;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/dn.h b/include/net/dn.h
new file mode 100644
index 000000000000..5551c46db397
--- /dev/null
+++ b/include/net/dn.h
@@ -0,0 +1,236 @@
+#ifndef _NET_DN_H
+#define _NET_DN_H
+
+#include <linux/dn.h>
+#include <net/sock.h>
+#include <asm/byteorder.h>
+
+typedef unsigned short dn_address;
+
+#define dn_ntohs(x) le16_to_cpu((unsigned short)(x))
+#define dn_htons(x) cpu_to_le16((unsigned short)(x))
+
+struct dn_scp                                   /* Session Control Port */
+{
+        unsigned char           state;
+#define DN_O     1                      /* Open                 */
+#define DN_CR    2                      /* Connect Receive      */
+#define DN_DR    3                      /* Disconnect Reject    */
+#define DN_DRC   4                      /* Discon. Rej. Complete*/
+#define DN_CC    5                      /* Connect Confirm      */
+#define DN_CI    6                      /* Connect Initiate     */
+#define DN_NR    7                      /* No resources         */
+#define DN_NC    8                      /* No communication     */
+#define DN_CD    9                      /* Connect Delivery     */
+#define DN_RJ    10                     /* Rejected             */
+#define DN_RUN   11                     /* Running              */
+#define DN_DI    12                     /* Disconnect Initiate  */
+#define DN_DIC   13                     /* Disconnect Complete  */
+#define DN_DN    14                     /* Disconnect Notificat */
+#define DN_CL    15                     /* Closed               */
+#define DN_CN    16                     /* Closed Notification  */
+
+        unsigned short          addrloc;
+        unsigned short          addrrem;
+        unsigned short          numdat;
+        unsigned short          numoth;
+        unsigned short          numoth_rcv;
+        unsigned short          numdat_rcv;
+        unsigned short          ackxmt_dat;
+        unsigned short          ackxmt_oth;
+        unsigned short          ackrcv_dat;
+        unsigned short          ackrcv_oth;
+        unsigned char           flowrem_sw;
+	unsigned char		flowloc_sw;
+#define DN_SEND         2
+#define DN_DONTSEND     1
+#define DN_NOCHANGE     0
+	unsigned short		flowrem_dat;
+	unsigned short		flowrem_oth;
+	unsigned short		flowloc_dat;
+	unsigned short		flowloc_oth;
+	unsigned char		services_rem;
+	unsigned char		services_loc;
+	unsigned char		info_rem;
+	unsigned char		info_loc;
+
+	unsigned short		segsize_rem;
+	unsigned short		segsize_loc;
+
+	unsigned char		nonagle;
+	unsigned char		multi_ireq;
+	unsigned char		accept_mode;
+	unsigned long		seg_total; /* Running total of current segment */
+
+	struct optdata_dn     conndata_in;
+	struct optdata_dn     conndata_out;
+	struct optdata_dn     discdata_in;
+	struct optdata_dn     discdata_out;
+        struct accessdata_dn  accessdata;
+
+        struct sockaddr_dn addr; /* Local address  */
+	struct sockaddr_dn peer; /* Remote address */
+
+	/*
+	 * In this case the RTT estimation is not specified in the
+	 * docs, nor is any back off algorithm. Here we follow well
+	 * known tcp algorithms with a few small variations.
+	 *
+	 * snd_window: Max number of packets we send before we wait for
+	 *             an ack to come back. This will become part of a
+	 *             more complicated scheme when we support flow
+	 *             control.
+	 *
+	 * nsp_srtt:   Round-Trip-Time (x8) in jiffies. This is a rolling
+	 *             average.
+	 * nsp_rttvar: Round-Trip-Time-Varience (x4) in jiffies. This is the
+	 *             varience of the smoothed average (but calculated in
+	 *             a simpler way than for normal statistical varience
+	 *             calculations).
+	 *
+	 * nsp_rxtshift: Backoff counter. Value is zero normally, each time
+	 *               a packet is lost is increases by one until an ack
+	 *               is received. Its used to index an array of backoff
+	 *               multipliers.
+	 */
+#define NSP_MIN_WINDOW 1
+#define NSP_MAX_WINDOW (0x07fe)
+	unsigned long max_window;
+	unsigned long snd_window;
+#define NSP_INITIAL_SRTT (HZ)
+	unsigned long nsp_srtt;
+#define NSP_INITIAL_RTTVAR (HZ*3)
+	unsigned long nsp_rttvar;
+#define NSP_MAXRXTSHIFT 12
+	unsigned long nsp_rxtshift;
+
+	/*
+	 * Output queues, one for data, one for otherdata/linkservice
+	 */
+	struct sk_buff_head data_xmit_queue;
+	struct sk_buff_head other_xmit_queue;
+
+	/*
+	 * Input queue for other data
+	 */
+	struct sk_buff_head other_receive_queue;
+	int other_report;
+
+	/*
+	 * Stuff to do with the slow timer
+	 */
+	unsigned long stamp;          /* time of last transmit */
+	unsigned long persist;
+	int (*persist_fxn)(struct sock *sk);
+	unsigned long keepalive;
+	void (*keepalive_fxn)(struct sock *sk);
+
+	/*
+	 * This stuff is for the fast timer for delayed acks
+	 */
+	struct timer_list delack_timer;
+	int delack_pending;
+	void (*delack_fxn)(struct sock *sk);
+
+};
+
+static inline struct dn_scp *DN_SK(struct sock *sk)
+{
+	return (struct dn_scp *)(sk + 1);
+}
+
+/*
+ * src,dst : Source and Destination DECnet addresses
+ * hops : Number of hops through the network
+ * dst_port, src_port : NSP port numbers
+ * services, info : Useful data extracted from conninit messages
+ * rt_flags : Routing flags byte
+ * nsp_flags : NSP layer flags byte
+ * segsize : Size of segment
+ * segnum : Number, for data, otherdata and linkservice
+ * xmit_count : Number of times we've transmitted this skb
+ * stamp : Time stamp of most recent transmission, used in RTT calculations
+ * iif: Input interface number
+ *
+ * As a general policy, this structure keeps all addresses in network
+ * byte order, and all else in host byte order. Thus dst, src, dst_port
+ * and src_port are in network order. All else is in host order.
+ * 
+ */
+#define DN_SKB_CB(skb) ((struct dn_skb_cb *)(skb)->cb)
+struct dn_skb_cb {
+	unsigned short dst;
+	unsigned short src;
+	unsigned short hops;
+	unsigned short dst_port;
+	unsigned short src_port;
+	unsigned char services;
+	unsigned char info;
+	unsigned char rt_flags;
+	unsigned char nsp_flags;
+	unsigned short segsize;
+	unsigned short segnum;
+	unsigned short xmit_count;
+	unsigned long stamp;
+	int iif;
+};
+
+static inline dn_address dn_eth2dn(unsigned char *ethaddr)
+{
+	return ethaddr[4] | (ethaddr[5] << 8);
+}
+
+static inline dn_address dn_saddr2dn(struct sockaddr_dn *saddr)
+{
+	return *(dn_address *)saddr->sdn_nodeaddr;
+}
+
+static inline void dn_dn2eth(unsigned char *ethaddr, dn_address addr)
+{
+	ethaddr[0] = 0xAA;
+	ethaddr[1] = 0x00;
+	ethaddr[2] = 0x04;
+	ethaddr[3] = 0x00;
+	ethaddr[4] = (unsigned char)(addr & 0xff);
+	ethaddr[5] = (unsigned char)(addr >> 8);
+}
+
+static inline void dn_sk_ports_copy(struct flowi *fl, struct dn_scp *scp)
+{
+	fl->uli_u.dnports.sport = scp->addrloc;
+	fl->uli_u.dnports.dport = scp->addrrem;
+	fl->uli_u.dnports.objnum = scp->addr.sdn_objnum;
+	if (fl->uli_u.dnports.objnum == 0) {
+		fl->uli_u.dnports.objnamel = scp->addr.sdn_objnamel;
+		memcpy(fl->uli_u.dnports.objname, scp->addr.sdn_objname, 16);
+	}
+}
+
+extern unsigned dn_mss_from_pmtu(struct net_device *dev, int mtu);
+
+#define DN_MENUVER_ACC 0x01
+#define DN_MENUVER_USR 0x02
+#define DN_MENUVER_PRX 0x04
+#define DN_MENUVER_UIC 0x08
+
+extern struct sock *dn_sklist_find_listener(struct sockaddr_dn *addr);
+extern struct sock *dn_find_by_skb(struct sk_buff *skb);
+#define DN_ASCBUF_LEN 9
+extern char *dn_addr2asc(dn_address, char *);
+extern int dn_destroy_timer(struct sock *sk);
+
+extern int dn_sockaddr2username(struct sockaddr_dn *addr, unsigned char *buf, unsigned char type);
+extern int dn_username2sockaddr(unsigned char *data, int len, struct sockaddr_dn *addr, unsigned char *type);
+
+extern void dn_start_slow_timer(struct sock *sk);
+extern void dn_stop_slow_timer(struct sock *sk);
+
+extern dn_address decnet_address;
+extern int decnet_debug_level;
+extern int decnet_time_wait;
+extern int decnet_dn_count;
+extern int decnet_di_count;
+extern int decnet_dr_count;
+extern int decnet_no_fc_max_cwnd;
+
+#endif /* _NET_DN_H */
