commit 76cd622fe2c2b10c1f0a7311ca797feccacc329d
Merge: 5eb2bcf247de c6bc6041b10f
Author: Saeed Mahameed <saeedm@mellanox.com>
Date:   Sat May 9 00:06:35 2020 -0700

    Merge branch 'mlx5-next' of git://git.kernel.org/pub/scm/linux/kernel/git/mellanox/linux
    
    This merge includes updates to bonding driver needed for the rdma stack,
    to avoid conflicts with the RDMA branch.
    
    Maor Gottlieb Says:
    
    ====================
    Bonding: Add support to get xmit slave
    
    The following series adds support to get the LAG master xmit slave by
    introducing new .ndo - ndo_get_xmit_slave. Every LAG module can
    implement it and it first implemented in the bond driver.
    This is follow-up to the RFC discussion [1].
    
    The main motivation for doing this is for drivers that offload part
    of the LAG functionality. For example, Mellanox Connect-X hardware
    implements RoCE LAG which selects the TX affinity when the resources
    are created and port is remapped when it goes down.
    
    The first part of this patchset introduces the new .ndo and add the
    support to the bonding module.
    
    The second part adds support to get the RoCE LAG xmit slave by building
    skb of the RoCE packet based on the AH attributes and call to the new
    .ndo.
    
    The third part change the mlx5 driver driver to set the QP's affinity
    port according to the slave which found by the .ndo.
    ====================
    
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

commit ae46f184bc1fb15bf2de47114c29236e61ca4bbc
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu May 7 09:32:22 2020 -0700

    bonding: propagate transmit status
    
    Currently, bonding always returns NETDEV_TX_OK to its caller.
    
    It is worth trying to be more accurate : TCP for instance
    can have different recovery strategies if it can have more
    precise status, if packet was dropped by slave qdisc.
    
    This is especially important when host is under stress.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Jay Vosburgh <j.vosburgh@gmail.com>
    Cc: Veaceslav Falico <vfalico@gmail.com>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index f211983cd52a..9b1e76515a9c 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -504,15 +504,17 @@ static inline unsigned long slave_last_rx(struct bonding *bond,
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
-static inline void bond_netpoll_send_skb(const struct slave *slave,
+static inline netdev_tx_t bond_netpoll_send_skb(const struct slave *slave,
 					 struct sk_buff *skb)
 {
-	netpoll_send_skb(slave->np, skb);
+	return netpoll_send_skb(slave->np, skb);
 }
 #else
-static inline void bond_netpoll_send_skb(const struct slave *slave,
+static inline netdev_tx_t bond_netpoll_send_skb(const struct slave *slave,
 					 struct sk_buff *skb)
 {
+	BUG();
+	return NETDEV_TX_OK;
 }
 #endif
 
@@ -606,7 +608,7 @@ struct bond_net {
 };
 
 int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond, struct slave *slave);
-void bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
+netdev_tx_t bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
 int bond_create(struct net *net, const char *name);
 int bond_create_sysfs(struct bond_net *net);
 void bond_destroy_sysfs(struct bond_net *net);
@@ -739,10 +741,11 @@ extern struct bond_parm_tbl ad_select_tbl[];
 /* exported from bond_netlink.c */
 extern struct rtnl_link_ops bond_link_ops;
 
-static inline void bond_tx_drop(struct net_device *dev, struct sk_buff *skb)
+static inline netdev_tx_t bond_tx_drop(struct net_device *dev, struct sk_buff *skb)
 {
 	atomic_long_inc(&dev->tx_dropped);
 	dev_kfree_skb_any(skb);
+	return NET_XMIT_DROP;
 }
 
 #endif /* _NET_BONDING_H */

commit f78ed2204db9fc35b545d693865bddbe0149aa1f
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu May 7 09:32:21 2020 -0700

    netpoll: accept NULL np argument in netpoll_send_skb()
    
    netpoll_send_skb() callers seem to leak skb if
    the np pointer is NULL. While this should not happen, we
    can make the code more robust.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 0b696da5c115..f211983cd52a 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -507,10 +507,7 @@ static inline unsigned long slave_last_rx(struct bonding *bond,
 static inline void bond_netpoll_send_skb(const struct slave *slave,
 					 struct sk_buff *skb)
 {
-	struct netpoll *np = slave->np;
-
-	if (np)
-		netpoll_send_skb(np, skb);
+	netpoll_send_skb(slave->np, skb);
 }
 #else
 static inline void bond_netpoll_send_skb(const struct slave *slave,

commit e7511f560f5499c664c1ba9181c76044e2af578d
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Sat May 2 22:22:20 2020 -0700

    bonding: remove useless stats_lock_key
    
    After commit b3e80d44f5b1
    ("bonding: fix lockdep warning in bond_get_stats()") the dynamic
    key is no longer necessary, as we compute nest level at run-time.
    So, we can just remove it to save some lockdep key entries.
    
    Test commands:
     ip link add bond0 type bond
     ip link add bond1 type bond
     ip link set bond0 master bond1
     ip link set bond0 nomaster
     ip link set bond1 master bond0
    
    Reported-and-tested-by: syzbot+aaa6fa4949cc5d9b7b25@syzkaller.appspotmail.com
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Acked-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index dc2ce31a1f52..0b696da5c115 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -237,7 +237,6 @@ struct bonding {
 	struct	 dentry *debug_dir;
 #endif /* CONFIG_DEBUG_FS */
 	struct rtnl_link_stats64 bond_stats;
-	struct lock_class_key stats_lock_key;
 };
 
 #define bond_slave_get_rcu(dev) \

commit 6b447e76ed44cc354cd0a346b86efe393e603e0d
Author: Maor Gottlieb <maorg@mellanox.com>
Date:   Thu Apr 30 22:21:38 2020 +0300

    bonding: Add array of all slaves
    
    Keep all slaves in array so it could be used to get the xmit slave
    assume all the slaves are active.
    The logic to add slave to the array is like the usable slaves, except
    that we also add slaves that currently can't transmit - not up or active.
    
    Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 33bdb6d5182d..b5e49bedbc9f 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -200,7 +200,8 @@ struct bonding {
 	struct   slave __rcu *curr_active_slave;
 	struct   slave __rcu *current_arp_slave;
 	struct   slave __rcu *primary_slave;
-	struct   bond_up_slave __rcu *usable_slaves; /* Array of usable slaves */
+	struct   bond_up_slave __rcu *usable_slaves;
+	struct   bond_up_slave __rcu *all_slaves;
 	bool     force_primary;
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	int     (*recv_probe)(const struct sk_buff *, struct bonding *,

commit ed7d4f023b1a9b0578f20d66557c66452ab845ec
Author: Maor Gottlieb <maorg@mellanox.com>
Date:   Thu Apr 30 22:21:33 2020 +0300

    bonding: Rename slave_arr to usable_slaves
    
    Rename slave_arr to usable_slaves, since we will have two arrays,
    one for the usable slaves and the other to all slaves.
    
    Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index dc2ce31a1f52..33bdb6d5182d 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -200,7 +200,7 @@ struct bonding {
 	struct   slave __rcu *curr_active_slave;
 	struct   slave __rcu *current_arp_slave;
 	struct   slave __rcu *primary_slave;
-	struct   bond_up_slave __rcu *slave_arr; /* Array of usable slaves */
+	struct   bond_up_slave __rcu *usable_slaves; /* Array of usable slaves */
 	bool     force_primary;
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	int     (*recv_probe)(const struct sk_buff *, struct bonding *,

commit 749db093040788ff474937d2452d4cf0176b5a1f
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 28 07:56:29 2020 -0600

    bonding: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 3d56b026bb9e..dc2ce31a1f52 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -183,7 +183,7 @@ struct slave {
 struct bond_up_slave {
 	unsigned int	count;
 	struct rcu_head rcu;
-	struct slave	*arr[0];
+	struct slave	*arr[];
 };
 
 /*

commit 1899bb325149e481de31a4f32b59ea6f24e176ea
Author: Jay Vosburgh <jay.vosburgh@canonical.com>
Date:   Fri Nov 1 21:56:42 2019 -0700

    bonding: fix state transition issue in link monitoring
    
    Since de77ecd4ef02 ("bonding: improve link-status update in
    mii-monitoring"), the bonding driver has utilized two separate variables
    to indicate the next link state a particular slave should transition to.
    Each is used to communicate to a different portion of the link state
    change commit logic; one to the bond_miimon_commit function itself, and
    another to the state transition logic.
    
            Unfortunately, the two variables can become unsynchronized,
    resulting in incorrect link state transitions within bonding.  This can
    cause slaves to become stuck in an incorrect link state until a
    subsequent carrier state transition.
    
            The issue occurs when a special case in bond_slave_netdev_event
    sets slave->link directly to BOND_LINK_FAIL.  On the next pass through
    bond_miimon_inspect after the slave goes carrier up, the BOND_LINK_FAIL
    case will set the proposed next state (link_new_state) to BOND_LINK_UP,
    but the new_link to BOND_LINK_DOWN.  The setting of the final link state
    from new_link comes after that from link_new_state, and so the slave
    will end up incorrectly in _DOWN state.
    
            Resolve this by combining the two variables into one.
    
    Reported-by: Aleksei Zakharov <zakharov.a.g@yandex.ru>
    Reported-by: Sha Zhang <zhangsha.zhang@huawei.com>
    Cc: Mahesh Bandewar <maheshb@google.com>
    Fixes: de77ecd4ef02 ("bonding: improve link-status update in mii-monitoring")
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 1afc125014da..3d56b026bb9e 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -159,7 +159,6 @@ struct slave {
 	unsigned long target_last_arp_rx[BOND_MAX_ARP_TARGETS];
 	s8     link;		/* one of BOND_LINK_XXXX */
 	s8     link_new_state;	/* one of BOND_LINK_XXXX */
-	s8     new_link;
 	u8     backup:1,   /* indicates backup slave. Value corresponds with
 			      BOND_STATE_ACTIVE and BOND_STATE_BACKUP */
 	       inactive:1, /* indicates inactive slave */
@@ -549,7 +548,7 @@ static inline void bond_propose_link_state(struct slave *slave, int state)
 
 static inline void bond_commit_link_state(struct slave *slave, bool notify)
 {
-	if (slave->link == slave->link_new_state)
+	if (slave->link_new_state == BOND_LINK_NOCHANGE)
 		return;
 
 	slave->link = slave->link_new_state;

commit f3b0a18bb6cb07a9abb75e21b1f08eeaefa78e81
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Mon Oct 21 18:47:58 2019 +0000

    net: remove unnecessary variables and callback
    
    This patch removes variables and callback these are related to the nested
    device structure.
    devices that can be nested have their own nest_level variable that
    represents the depth of nested devices.
    In the previous patch, new {lower/upper}_level variables are added and
    they replace old private nest_level variable.
    So, this patch removes all 'nest_level' variables.
    
    In order to avoid lockdep warning, ->ndo_get_lock_subclass() was added
    to get lockdep subclass value, which is actually lower nested depth value.
    But now, they use the dynamic lockdep key to avoid lockdep warning instead
    of the subclass.
    So, this patch removes ->ndo_get_lock_subclass() callback.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 334909feb2bb..1afc125014da 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -203,7 +203,6 @@ struct bonding {
 	struct   slave __rcu *primary_slave;
 	struct   bond_up_slave __rcu *slave_arr; /* Array of usable slaves */
 	bool     force_primary;
-	u32      nest_level;
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
 			      struct slave *);

commit 089bca2caed0d0dea7da235ce1fe245808f5ec02
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Mon Oct 21 18:47:53 2019 +0000

    bonding: use dynamic lockdep key instead of subclass
    
    All bonding device has same lockdep key and subclass is initialized with
    nest_level.
    But actual nest_level value can be changed when a lower device is attached.
    And at this moment, the subclass should be updated but it seems to be
    unsafe.
    So this patch makes bonding use dynamic lockdep key instead of the
    subclass.
    
    Test commands:
        ip link add bond0 type bond
    
        for i in {1..5}
        do
                let A=$i-1
                ip link add bond$i type bond
                ip link set bond$i master bond$A
        done
        ip link set bond5 master bond0
    
    Splat looks like:
    [  307.992912] WARNING: possible recursive locking detected
    [  307.993656] 5.4.0-rc3+ #96 Tainted: G        W
    [  307.994367] --------------------------------------------
    [  307.995092] ip/761 is trying to acquire lock:
    [  307.995710] ffff8880513aac60 (&(&bond->stats_lock)->rlock#2/2){+.+.}, at: bond_get_stats+0xb8/0x500 [bonding]
    [  307.997045]
                   but task is already holding lock:
    [  307.997923] ffff88805fcbac60 (&(&bond->stats_lock)->rlock#2/2){+.+.}, at: bond_get_stats+0xb8/0x500 [bonding]
    [  307.999215]
                   other info that might help us debug this:
    [  308.000251]  Possible unsafe locking scenario:
    
    [  308.001137]        CPU0
    [  308.001533]        ----
    [  308.001915]   lock(&(&bond->stats_lock)->rlock#2/2);
    [  308.002609]   lock(&(&bond->stats_lock)->rlock#2/2);
    [  308.003302]
                    *** DEADLOCK ***
    
    [  308.004310]  May be due to missing lock nesting notation
    
    [  308.005319] 3 locks held by ip/761:
    [  308.005830]  #0: ffffffff9fcc42b0 (rtnl_mutex){+.+.}, at: rtnetlink_rcv_msg+0x466/0x8a0
    [  308.006894]  #1: ffff88805fcbac60 (&(&bond->stats_lock)->rlock#2/2){+.+.}, at: bond_get_stats+0xb8/0x500 [bonding]
    [  308.008243]  #2: ffffffff9f9219c0 (rcu_read_lock){....}, at: bond_get_stats+0x9f/0x500 [bonding]
    [  308.009422]
                   stack backtrace:
    [  308.010124] CPU: 0 PID: 761 Comm: ip Tainted: G        W         5.4.0-rc3+ #96
    [  308.011097] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  308.012179] Call Trace:
    [  308.012601]  dump_stack+0x7c/0xbb
    [  308.013089]  __lock_acquire+0x269d/0x3de0
    [  308.013669]  ? register_lock_class+0x14d0/0x14d0
    [  308.014318]  lock_acquire+0x164/0x3b0
    [  308.014858]  ? bond_get_stats+0xb8/0x500 [bonding]
    [  308.015520]  _raw_spin_lock_nested+0x2e/0x60
    [  308.016129]  ? bond_get_stats+0xb8/0x500 [bonding]
    [  308.017215]  bond_get_stats+0xb8/0x500 [bonding]
    [  308.018454]  ? bond_arp_rcv+0xf10/0xf10 [bonding]
    [  308.019710]  ? rcu_read_lock_held+0x90/0xa0
    [  308.020605]  ? rcu_read_lock_sched_held+0xc0/0xc0
    [  308.021286]  ? bond_get_stats+0x9f/0x500 [bonding]
    [  308.021953]  dev_get_stats+0x1ec/0x270
    [  308.022508]  bond_get_stats+0x1d1/0x500 [bonding]
    
    Fixes: d3fff6c443fe ("net: add netdev_lockdep_set_classes() helper")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index f7fe45689142..334909feb2bb 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -239,6 +239,7 @@ struct bonding {
 	struct	 dentry *debug_dir;
 #endif /* CONFIG_DEBUG_FS */
 	struct rtnl_link_stats64 bond_stats;
+	struct lock_class_key stats_lock_key;
 };
 
 #define bond_slave_get_rcu(dev) \

commit 07a4ddec3ce9b0a533b5f90f582f1057390d5e63
Author: Vincent Bernat <vincent@bernat.ch>
Date:   Tue Jul 2 19:43:54 2019 +0200

    bonding: add an option to specify a delay between peer notifications
    
    Currently, gratuitous ARP/ND packets are sent every `miimon'
    milliseconds. This commit allows a user to specify a custom delay
    through a new option, `peer_notif_delay'.
    
    Like for `updelay' and `downdelay', this delay should be a multiple of
    `miimon' to avoid managing an additional work queue. The configuration
    logic is copied from `updelay' and `downdelay'. However, the default
    value cannot be set using a module parameter: Netlink or sysfs should
    be used to configure this feature.
    
    When setting `miimon' to 100 and `peer_notif_delay' to 500, we can
    observe the 500 ms delay is respected:
    
        20:30:19.354693 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
        20:30:19.874892 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
        20:30:20.394919 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
        20:30:20.914963 ARP, Request who-has 203.0.113.10 tell 203.0.113.10, length 28
    
    In bond_mii_monitor(), I have tried to keep the lock logic readable.
    The change is due to the fact we cannot rely on a notification to
    lower the value of `bond->send_peer_notif' as `NETDEV_NOTIFY_PEERS' is
    only triggered once every N times, while we need to decrement the
    counter each time.
    
    iproute2 also needs to be updated to be able to specify this new
    attribute through `ip link'.
    
    Signed-off-by: Vincent Bernat <vincent@bernat.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 676e7fae05a3..f7fe45689142 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -123,6 +123,7 @@ struct bond_params {
 	int fail_over_mac;
 	int updelay;
 	int downdelay;
+	int peer_notif_delay;
 	int lacp_fast;
 	unsigned int min_links;
 	int ad_select;

commit 5237ff79b23901a5326f8e986667976861370445
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Jun 7 10:59:28 2019 -0400

    bonding: add slave_foo printk macros
    
    Where possible, we generally want both the bond master and the relevant slave
    information in message output. Standardize the format using new slave_*
    printk macros.
    
    Suggested-by: Joe Perches <joe@perches.com>
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index b46d68acf701..676e7fae05a3 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -38,6 +38,15 @@
 #define __long_aligned __attribute__((aligned((sizeof(long)))))
 #endif
 
+#define slave_info(bond_dev, slave_dev, fmt, ...) \
+	netdev_info(bond_dev, "(slave %s): " fmt, (slave_dev)->name, ##__VA_ARGS__)
+#define slave_warn(bond_dev, slave_dev, fmt, ...) \
+	netdev_warn(bond_dev, "(slave %s): " fmt, (slave_dev)->name, ##__VA_ARGS__)
+#define slave_dbg(bond_dev, slave_dev, fmt, ...) \
+	netdev_dbg(bond_dev, "(slave %s): " fmt, (slave_dev)->name, ##__VA_ARGS__)
+#define slave_err(bond_dev, slave_dev, fmt, ...) \
+	netdev_err(bond_dev, "(slave %s): " fmt, (slave_dev)->name, ##__VA_ARGS__)
+
 #define BOND_MODE(bond) ((bond)->params.mode)
 
 /* slave list primitives */

commit d4859d749aa7090ffb743d15648adb962a1baeae
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Mon Sep 24 14:40:11 2018 -0700

    bonding: avoid possible dead-lock
    
    Syzkaller reported this on a slightly older kernel but it's still
    applicable to the current kernel -
    
    ======================================================
    WARNING: possible circular locking dependency detected
    4.18.0-next-20180823+ #46 Not tainted
    ------------------------------------------------------
    syz-executor4/26841 is trying to acquire lock:
    00000000dd41ef48 ((wq_completion)bond_dev->name){+.+.}, at: flush_workqueue+0x2db/0x1e10 kernel/workqueue.c:2652
    
    but task is already holding lock:
    00000000768ab431 (rtnl_mutex){+.+.}, at: rtnl_lock net/core/rtnetlink.c:77 [inline]
    00000000768ab431 (rtnl_mutex){+.+.}, at: rtnetlink_rcv_msg+0x412/0xc30 net/core/rtnetlink.c:4708
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -> #2 (rtnl_mutex){+.+.}:
           __mutex_lock_common kernel/locking/mutex.c:925 [inline]
           __mutex_lock+0x171/0x1700 kernel/locking/mutex.c:1073
           mutex_lock_nested+0x16/0x20 kernel/locking/mutex.c:1088
           rtnl_lock+0x17/0x20 net/core/rtnetlink.c:77
           bond_netdev_notify drivers/net/bonding/bond_main.c:1310 [inline]
           bond_netdev_notify_work+0x44/0xd0 drivers/net/bonding/bond_main.c:1320
           process_one_work+0xc73/0x1aa0 kernel/workqueue.c:2153
           worker_thread+0x189/0x13c0 kernel/workqueue.c:2296
           kthread+0x35a/0x420 kernel/kthread.c:246
           ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:415
    
    -> #1 ((work_completion)(&(&nnw->work)->work)){+.+.}:
           process_one_work+0xc0b/0x1aa0 kernel/workqueue.c:2129
           worker_thread+0x189/0x13c0 kernel/workqueue.c:2296
           kthread+0x35a/0x420 kernel/kthread.c:246
           ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:415
    
    -> #0 ((wq_completion)bond_dev->name){+.+.}:
           lock_acquire+0x1e4/0x4f0 kernel/locking/lockdep.c:3901
           flush_workqueue+0x30a/0x1e10 kernel/workqueue.c:2655
           drain_workqueue+0x2a9/0x640 kernel/workqueue.c:2820
           destroy_workqueue+0xc6/0x9d0 kernel/workqueue.c:4155
           __alloc_workqueue_key+0xef9/0x1190 kernel/workqueue.c:4138
           bond_init+0x269/0x940 drivers/net/bonding/bond_main.c:4734
           register_netdevice+0x337/0x1100 net/core/dev.c:8410
           bond_newlink+0x49/0xa0 drivers/net/bonding/bond_netlink.c:453
           rtnl_newlink+0xef4/0x1d50 net/core/rtnetlink.c:3099
           rtnetlink_rcv_msg+0x46e/0xc30 net/core/rtnetlink.c:4711
           netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c:2454
           rtnetlink_rcv+0x1c/0x20 net/core/rtnetlink.c:4729
           netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]
           netlink_unicast+0x5a0/0x760 net/netlink/af_netlink.c:1343
           netlink_sendmsg+0xa18/0xfc0 net/netlink/af_netlink.c:1908
           sock_sendmsg_nosec net/socket.c:622 [inline]
           sock_sendmsg+0xd5/0x120 net/socket.c:632
           ___sys_sendmsg+0x7fd/0x930 net/socket.c:2115
           __sys_sendmsg+0x11d/0x290 net/socket.c:2153
           __do_sys_sendmsg net/socket.c:2162 [inline]
           __se_sys_sendmsg net/socket.c:2160 [inline]
           __x64_sys_sendmsg+0x78/0xb0 net/socket.c:2160
           do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290
           entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    other info that might help us debug this:
    
    Chain exists of:
      (wq_completion)bond_dev->name --> (work_completion)(&(&nnw->work)->work) --> rtnl_mutex
    
     Possible unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(rtnl_mutex);
                                   lock((work_completion)(&(&nnw->work)->work));
                                   lock(rtnl_mutex);
      lock((wq_completion)bond_dev->name);
    
     *** DEADLOCK ***
    
    1 lock held by syz-executor4/26841:
    
    stack backtrace:
    CPU: 1 PID: 26841 Comm: syz-executor4 Not tainted 4.18.0-next-20180823+ #46
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x1c9/0x2b4 lib/dump_stack.c:113
     print_circular_bug.isra.34.cold.55+0x1bd/0x27d kernel/locking/lockdep.c:1222
     check_prev_add kernel/locking/lockdep.c:1862 [inline]
     check_prevs_add kernel/locking/lockdep.c:1975 [inline]
     validate_chain kernel/locking/lockdep.c:2416 [inline]
     __lock_acquire+0x3449/0x5020 kernel/locking/lockdep.c:3412
     lock_acquire+0x1e4/0x4f0 kernel/locking/lockdep.c:3901
     flush_workqueue+0x30a/0x1e10 kernel/workqueue.c:2655
     drain_workqueue+0x2a9/0x640 kernel/workqueue.c:2820
     destroy_workqueue+0xc6/0x9d0 kernel/workqueue.c:4155
     __alloc_workqueue_key+0xef9/0x1190 kernel/workqueue.c:4138
     bond_init+0x269/0x940 drivers/net/bonding/bond_main.c:4734
     register_netdevice+0x337/0x1100 net/core/dev.c:8410
     bond_newlink+0x49/0xa0 drivers/net/bonding/bond_netlink.c:453
     rtnl_newlink+0xef4/0x1d50 net/core/rtnetlink.c:3099
     rtnetlink_rcv_msg+0x46e/0xc30 net/core/rtnetlink.c:4711
     netlink_rcv_skb+0x172/0x440 net/netlink/af_netlink.c:2454
     rtnetlink_rcv+0x1c/0x20 net/core/rtnetlink.c:4729
     netlink_unicast_kernel net/netlink/af_netlink.c:1317 [inline]
     netlink_unicast+0x5a0/0x760 net/netlink/af_netlink.c:1343
     netlink_sendmsg+0xa18/0xfc0 net/netlink/af_netlink.c:1908
     sock_sendmsg_nosec net/socket.c:622 [inline]
     sock_sendmsg+0xd5/0x120 net/socket.c:632
     ___sys_sendmsg+0x7fd/0x930 net/socket.c:2115
     __sys_sendmsg+0x11d/0x290 net/socket.c:2153
     __do_sys_sendmsg net/socket.c:2162 [inline]
     __se_sys_sendmsg net/socket.c:2160 [inline]
     __x64_sys_sendmsg+0x78/0xb0 net/socket.c:2160
     do_syscall_64+0x1b9/0x820 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x457089
    Code: fd b4 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 cb b4 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f2df20a5c78 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
    RAX: ffffffffffffffda RBX: 00007f2df20a66d4 RCX: 0000000000457089
    RDX: 0000000000000000 RSI: 0000000020000180 RDI: 0000000000000003
    RBP: 0000000000930140 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00000000ffffffff
    R13: 00000000004d40b8 R14: 00000000004c8ad8 R15: 0000000000000001
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index a2d058170ea3..b46d68acf701 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -139,12 +139,6 @@ struct bond_parm_tbl {
 	int mode;
 };
 
-struct netdev_notify_work {
-	struct delayed_work	work;
-	struct net_device	*dev;
-	struct netdev_bonding_info bonding_info;
-};
-
 struct slave {
 	struct net_device *dev; /* first - useful for panic debug */
 	struct bonding *bond; /* our master */
@@ -172,6 +166,7 @@ struct slave {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll *np;
 #endif
+	struct delayed_work notify_work;
 	struct kobject kobj;
 	struct rtnl_link_stats64 slave_stats;
 };

commit eeed992b776c54af6108187c87ac60d028e69d37
Author: Petr Machata <petrm@mellanox.com>
Date:   Tue Jul 10 10:02:58 2018 +0300

    net: Add lag.h, net_lag_port_dev_txable()
    
    LAG devices (team or bond) recognize for each one of their slave devices
    whether LAG traffic is going to be sent through that device. Bond calls
    such devices "active", team calls them "txable". When this state
    changes, a NETDEV_CHANGELOWERSTATE notification is distributed, together
    with a netdev_notifier_changelowerstate_info structure that for LAG
    devices includes a tx_enabled flag that refers to the new state. The
    notification thus makes it possible to react to the changes in txability
    in drivers.
    
    However there's no way to query txability from the outside on demand.
    That is problematic namely for mlxsw, which when resolving ERSPAN packet
    path, may encounter a LAG device, and needs to determine which of the
    slaves it should choose.
    
    To that end, introduce a new function, net_lag_port_dev_txable(), which
    determines whether a given slave device is "active" or
    "txable" (depending on the flavor of the LAG device). That function then
    dispatches to per-LAG-flavor helpers, bond_is_active_slave_dev() resp.
    team_port_dev_txable().
    
    Because there currently is no good place where net_lag_port_dev_txable()
    should be added, introduce a new header file, lag.h, which should from
    now on hold any logic common to both team and bond. (But keep
    netif_is_lag_master() together with the rest of netif_is_*_master()
    functions).
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 808f1d167349..a2d058170ea3 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -411,6 +411,19 @@ static inline bool bond_slave_can_tx(struct slave *slave)
 	       bond_is_active_slave(slave);
 }
 
+static inline bool bond_is_active_slave_dev(const struct net_device *slave_dev)
+{
+	struct slave *slave;
+	bool active;
+
+	rcu_read_lock();
+	slave = bond_slave_get_rcu(slave_dev);
+	active = bond_is_active_slave(slave);
+	rcu_read_unlock();
+
+	return active;
+}
+
 static inline void bond_hw_addr_copy(u8 *dst, const u8 *src, unsigned int len)
 {
 	if (len == ETH_ALEN) {

commit e79c1055749e3183a2beee04a24da378623329c5
Author: Debabrata Banerjee <dbanerje@akamai.com>
Date:   Mon May 14 14:48:09 2018 -0400

    bonding: allow use of tx hashing in balance-alb
    
    The rx load balancing provided by balance-alb is not mutually
    exclusive with using hashing for tx selection, and should provide a decent
    speed increase because this eliminates spinlocks and cache contention.
    
    Signed-off-by: Debabrata Banerjee <dbanerje@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index b52235158836..808f1d167349 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -285,8 +285,15 @@ static inline bool bond_needs_speed_duplex(const struct bonding *bond)
 
 static inline bool bond_is_nondyn_tlb(const struct bonding *bond)
 {
-	return (BOND_MODE(bond) == BOND_MODE_TLB)  &&
-	       (bond->params.tlb_dynamic_lb == 0);
+	return (bond_is_lb(bond) && bond->params.tlb_dynamic_lb == 0);
+}
+
+static inline bool bond_mode_can_use_xmit_hash(const struct bonding *bond)
+{
+	return (BOND_MODE(bond) == BOND_MODE_8023AD ||
+		BOND_MODE(bond) == BOND_MODE_XOR ||
+		BOND_MODE(bond) == BOND_MODE_TLB ||
+		BOND_MODE(bond) == BOND_MODE_ALB);
 }
 
 static inline bool bond_mode_uses_xmit_hash(const struct bonding *bond)

commit 21706ee8a47d3ede7fdae0be6d7c0a0e31a83229
Author: Debabrata Banerjee <dbanerje@akamai.com>
Date:   Wed May 9 19:32:11 2018 -0400

    bonding: send learning packets for vlans on slave
    
    There was a regression at some point from the intended functionality of
    commit f60c3704e87d ("bonding: Fix alb mode to only use first level
    vlans.")
    
    Given the return value vlan_get_encap_level() we need to store the nest
    level of the bond device, and then compare the vlan's encap level to
    this. Without this, this check always fails and learning packets are
    never sent.
    
    In addition, this same commit caused a regression in the behavior of
    balance_alb, which requires learning packets be sent for all interfaces
    using the slave's mac in order to load balance properly. For vlan's
    that have not set a user mac, we can send after checking one bit.
    Otherwise we need send the set mac, albeit defeating rx load balancing
    for that vlan.
    
    Signed-off-by: Debabrata Banerjee <dbanerje@akamai.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index f801fc940b29..b52235158836 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -198,6 +198,7 @@ struct bonding {
 	struct   slave __rcu *primary_slave;
 	struct   bond_up_slave __rcu *slave_arr; /* Array of usable slaves */
 	bool     force_primary;
+	u32      nest_level;
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
 			      struct slave *);

commit ef5201c83d1400570a3b6f004ad7a23d71934411
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Oct 24 13:54:20 2017 +0800

    bonding: remove rtmsg_ifinfo called after bond_lower_state_changed
    
    After the patch 'rtnetlink: bring NETDEV_CHANGELOWERSTATE event
    process back to rtnetlink_event', bond_lower_state_changed would
    generate NETDEV_CHANGEUPPER event which would send a notification
    to userspace in rtnetlink_event.
    
    There's no need to call rtmsg_ifinfo to send the notification
    any more. So this patch is to remove it from these places after
    bond_lower_state_changed.
    
    Besides, after this, rtmsg_ifinfo is not needed to be exported.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 2860cc66c2bb..f801fc940b29 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -330,7 +330,6 @@ static inline void bond_set_active_slave(struct slave *slave)
 		slave->backup = 0;
 		bond_queue_slave_event(slave);
 		bond_lower_state_changed(slave);
-		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 	}
 }
 
@@ -340,7 +339,6 @@ static inline void bond_set_backup_slave(struct slave *slave)
 		slave->backup = 1;
 		bond_queue_slave_event(slave);
 		bond_lower_state_changed(slave);
-		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 	}
 }
 
@@ -353,7 +351,6 @@ static inline void bond_set_slave_state(struct slave *slave,
 	slave->backup = slave_state;
 	if (notify) {
 		bond_lower_state_changed(slave);
-		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 		bond_queue_slave_event(slave);
 		slave->should_notify = 0;
 	} else {
@@ -385,7 +382,6 @@ static inline void bond_slave_state_notify(struct bonding *bond)
 	bond_for_each_slave(bond, tmp, iter) {
 		if (tmp->should_notify) {
 			bond_lower_state_changed(tmp);
-			rtmsg_ifinfo(RTM_NEWLINK, tmp->dev, 0, GFP_ATOMIC);
 			tmp->should_notify = 0;
 		}
 	}

commit 33eaf2a6eb48ebf00374aaaf4b1b43f9950dcbe4
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 4 17:48:46 2017 -0700

    net: Add extack to ndo_add_slave
    
    Pass extack to do_set_master and down to ndo_add_slave
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index b2e68657a216..2860cc66c2bb 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -596,7 +596,8 @@ void bond_destroy_sysfs(struct bond_net *net);
 void bond_prepare_sysfs_group(struct bonding *bond);
 int bond_sysfs_slave_add(struct slave *slave);
 void bond_sysfs_slave_del(struct slave *slave);
-int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev);
+int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev,
+		 struct netlink_ext_ack *extack);
 int bond_release(struct net_device *bond_dev, struct net_device *slave_dev);
 u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb);
 int bond_set_carrier(struct bonding *bond);

commit ad729bc9acfb7c47112964b4877ef5404578ed13
Author: Andreas Born <futur.andy@googlemail.com>
Date:   Thu Aug 10 06:41:44 2017 +0200

    bonding: require speed/duplex only for 802.3ad, alb and tlb
    
    The patch c4adfc822bf5 ("bonding: make speed, duplex setting consistent
    with link state") puts the link state to down if
    bond_update_speed_duplex() cannot retrieve speed and duplex settings.
    Assumably the patch was written with 802.3ad mode in mind which relies
    on link speed/duplex settings. For other modes like active-backup these
    settings are not required. Thus, only for these other modes, this patch
    reintroduces support for slaves that do not support reporting speed or
    duplex such as wireless devices. This fixes the regression reported in
    bug 196547 (https://bugzilla.kernel.org/show_bug.cgi?id=196547).
    
    Fixes: c4adfc822bf5 ("bonding: make speed, duplex setting consistent
    with link state")
    Signed-off-by: Andreas Born <futur.andy@googlemail.com>
    Acked-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index b00508d22e0a..b2e68657a216 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -277,6 +277,11 @@ static inline bool bond_is_lb(const struct bonding *bond)
 	       BOND_MODE(bond) == BOND_MODE_ALB;
 }
 
+static inline bool bond_needs_speed_duplex(const struct bonding *bond)
+{
+	return BOND_MODE(bond) == BOND_MODE_8023AD || bond_is_lb(bond);
+}
+
 static inline bool bond_is_nondyn_tlb(const struct bonding *bond)
 {
 	return (BOND_MODE(bond) == BOND_MODE_TLB)  &&

commit ea8ffc0818d8a47ffda423f61f1d8ad1caca8986
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Thu Apr 20 12:49:24 2017 -0700

    bonding: fix wq initialization for links created via netlink
    
    Earlier patch 4493b81bea ("bonding: initialize work-queues during
    creation of bond") moved the work-queue initialization from bond_open()
    to bond_create(). However this caused the link those are created using
    netlink 'create bond option' (ip link add bondX type bond); create the
    new trunk without initializing work-queues. Prior to the above mentioned
    change, ndo_open was in both paths and things worked correctly. The
    consequence is visible in the report shared by Joe Stringer -
    
    I've noticed that this patch breaks bonding within namespaces if
    you're not careful to perform device cleanup correctly.
    
    Here's my repro script, you can run on any net-next with this patch
    and you'll start seeing some weird behaviour:
    
    ip netns add foo
    ip li add veth0 type veth peer name veth0+ netns foo
    ip li add veth1 type veth peer name veth1+ netns foo
    ip netns exec foo ip li add bond0 type bond
    ip netns exec foo ip li set dev veth0+ master bond0
    ip netns exec foo ip li set dev veth1+ master bond0
    ip netns exec foo ip addr add dev bond0 192.168.0.1/24
    ip netns exec foo ip li set dev bond0 up
    ip li del dev veth0
    ip li del dev veth1
    
    The second to last command segfaults, last command hangs. rtnl is now
    permanently locked. It's not a problem if you take bond0 down before
    deleting veths, or delete bond0 before deleting veths. If you delete
    either end of the veth pair as per above, either inside or outside the
    namespace, it hits this problem.
    
    Here's some kernel logs:
    [ 1221.801610] bond0: Enslaving veth0+ as an active interface with an up link
    [ 1224.449581] bond0: Enslaving veth1+ as an active interface with an up link
    [ 1281.193863] bond0: Releasing backup interface veth0+
    [ 1281.193866] bond0: the permanent HWaddr of veth0+ -
    16:bf:fb:e0:b8:43 - is still in use by bond0 - set the HWaddr of
    veth0+ to a different address to avoid conflicts
    [ 1281.193867] ------------[ cut here ]------------
    [ 1281.193873] WARNING: CPU: 0 PID: 2024 at kernel/workqueue.c:1511
    __queue_delayed_work+0x13f/0x150
    [ 1281.193873] Modules linked in: bonding veth openvswitch nf_nat_ipv6
    nf_nat_ipv4 nf_nat autofs4 nfsd auth_rpcgss nfs_acl binfmt_misc nfs
    lockd grace sunrpc fscache ppdev vmw_balloon coretemp psmouse
    serio_raw vmwgfx ttm drm_kms_helper vmw_vmci netconsole parport_pc
    configfs drm i2c_piix4 fb_sys_fops syscopyarea sysfillrect sysimgblt
    shpchp mac_hid nf_conntrack_ipv6 nf_defrag_ipv6 nf_conntrack_ipv4
    nf_defrag_ipv4 nf_conntrack libcrc32c lp parport hid_generic usbhid
    hid mptspi mptscsih e1000 mptbase ahci libahci
    [ 1281.193905] CPU: 0 PID: 2024 Comm: ip Tainted: G        W
    4.10.0-bisect-bond-v0.14 #37
    [ 1281.193906] Hardware name: VMware, Inc. VMware Virtual
    Platform/440BX Desktop Reference Platform, BIOS 6.00 09/30/2014
    [ 1281.193906] Call Trace:
    [ 1281.193912]  dump_stack+0x63/0x89
    [ 1281.193915]  __warn+0xd1/0xf0
    [ 1281.193917]  warn_slowpath_null+0x1d/0x20
    [ 1281.193918]  __queue_delayed_work+0x13f/0x150
    [ 1281.193920]  queue_delayed_work_on+0x27/0x40
    [ 1281.193929]  bond_change_active_slave+0x25b/0x670 [bonding]
    [ 1281.193932]  ? synchronize_rcu_expedited+0x27/0x30
    [ 1281.193935]  __bond_release_one+0x489/0x510 [bonding]
    [ 1281.193939]  ? addrconf_notify+0x1b7/0xab0
    [ 1281.193942]  bond_netdev_event+0x2c5/0x2e0 [bonding]
    [ 1281.193944]  ? netconsole_netdev_event+0x124/0x190 [netconsole]
    [ 1281.193947]  notifier_call_chain+0x49/0x70
    [ 1281.193948]  raw_notifier_call_chain+0x16/0x20
    [ 1281.193950]  call_netdevice_notifiers_info+0x35/0x60
    [ 1281.193951]  rollback_registered_many+0x23b/0x3e0
    [ 1281.193953]  unregister_netdevice_many+0x24/0xd0
    [ 1281.193955]  rtnl_delete_link+0x3c/0x50
    [ 1281.193956]  rtnl_dellink+0x8d/0x1b0
    [ 1281.193960]  rtnetlink_rcv_msg+0x95/0x220
    [ 1281.193962]  ? __kmalloc_node_track_caller+0x35/0x280
    [ 1281.193964]  ? __netlink_lookup+0xf1/0x110
    [ 1281.193966]  ? rtnl_newlink+0x830/0x830
    [ 1281.193967]  netlink_rcv_skb+0xa7/0xc0
    [ 1281.193969]  rtnetlink_rcv+0x28/0x30
    [ 1281.193970]  netlink_unicast+0x15b/0x210
    [ 1281.193971]  netlink_sendmsg+0x319/0x390
    [ 1281.193974]  sock_sendmsg+0x38/0x50
    [ 1281.193975]  ___sys_sendmsg+0x25c/0x270
    [ 1281.193978]  ? mem_cgroup_commit_charge+0x76/0xf0
    [ 1281.193981]  ? page_add_new_anon_rmap+0x89/0xc0
    [ 1281.193984]  ? lru_cache_add_active_or_unevictable+0x35/0xb0
    [ 1281.193985]  ? __handle_mm_fault+0x4e9/0x1170
    [ 1281.193987]  __sys_sendmsg+0x45/0x80
    [ 1281.193989]  SyS_sendmsg+0x12/0x20
    [ 1281.193991]  do_syscall_64+0x6e/0x180
    [ 1281.193993]  entry_SYSCALL64_slow_path+0x25/0x25
    [ 1281.193995] RIP: 0033:0x7f6ec122f5a0
    [ 1281.193995] RSP: 002b:00007ffe69e89c48 EFLAGS: 00000246 ORIG_RAX:
    000000000000002e
    [ 1281.193997] RAX: ffffffffffffffda RBX: 00007ffe69e8dd60 RCX: 00007f6ec122f5a0
    [ 1281.193997] RDX: 0000000000000000 RSI: 00007ffe69e89c90 RDI: 0000000000000003
    [ 1281.193998] RBP: 00007ffe69e89c90 R08: 0000000000000000 R09: 0000000000000003
    [ 1281.193999] R10: 00007ffe69e89a10 R11: 0000000000000246 R12: 0000000058f14b9f
    [ 1281.193999] R13: 0000000000000000 R14: 00000000006473a0 R15: 00007ffe69e8e450
    [ 1281.194001] ---[ end trace 713a77486cbfbfa3 ]---
    
    Fixes: 4493b81bea ("bonding: initialize work-queues during creation of bond")
    Reported-by: Joe Stringer <joe@ovn.org>
    Tested-by: Joe Stringer <joe@ovn.org>
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Acked-by: Andy Gospodarek <andy@greyhouse.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 04a21e8048be..b00508d22e0a 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -614,6 +614,7 @@ struct bond_vlan_tag *bond_verify_device_path(struct net_device *start_dev,
 					      int level);
 int bond_update_slave_arr(struct bonding *bond, struct slave *skipslave);
 void bond_slave_arr_work_rearm(struct bonding *bond, unsigned long delay);
+void bond_work_init_all(struct bonding *bond);
 
 #ifdef CONFIG_PROC_FS
 void bond_create_proc_entry(struct bonding *bond);

commit faeeb317a5615076dff1ff44b51e862e6064dbd0
Author: Jarod Wilson <jarod@redhat.com>
Date:   Tue Apr 4 17:32:42 2017 -0400

    bonding: attempt to better support longer hw addresses
    
    People are using bonding over Infiniband IPoIB connections, and who knows
    what else. Infiniband has a hardware address length of 20 octets
    (INFINIBAND_ALEN), and the network core defines a MAX_ADDR_LEN of 32.
    Various places in the bonding code are currently hard-wired to 6 octets
    (ETH_ALEN), such as the 3ad code, which I've left untouched here. Besides,
    only alb is currently possible on Infiniband links right now anyway, due
    to commit 1533e7731522, so the alb code is where most of the changes are.
    
    One major component of this change is the addition of a bond_hw_addr_copy
    function that takes a length argument, instead of using ether_addr_copy
    everywhere that hardware addresses need to be copied about. The other
    major component of this change is converting the bonding code from using
    struct sockaddr for address storage to struct sockaddr_storage, as the
    former has an address storage space of only 14, while the latter is 128
    minus a few, which is necessary to support bonding over device with up to
    MAX_ADDR_LEN octet hardware addresses. Additionally, this probably fixes
    up some memory corruption issues with the current code, where it's
    possible to write an infiniband hardware address into a sockaddr declared
    on the stack.
    
    Lightly tested on a dual mlx4 IPoIB setup, which properly shows a 20-octet
    hardware address now:
    
    $ cat /proc/net/bonding/bond0
    Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)
    
    Bonding Mode: fault-tolerance (active-backup) (fail_over_mac active)
    Primary Slave: mlx4_ib0 (primary_reselect always)
    Currently Active Slave: mlx4_ib0
    MII Status: up
    MII Polling Interval (ms): 100
    Up Delay (ms): 100
    Down Delay (ms): 100
    
    Slave Interface: mlx4_ib0
    MII Status: up
    Speed: Unknown
    Duplex: Unknown
    Link Failure Count: 0
    Permanent HW addr:
    80:00:02:08:fe:80:00:00:00:00:00:00:e4:1d:2d:03:00:1d:67:01
    Slave queue ID: 0
    
    Slave Interface: mlx4_ib1
    MII Status: up
    Speed: Unknown
    Duplex: Unknown
    Link Failure Count: 0
    Permanent HW addr:
    80:00:02:09:fe:80:00:00:00:00:00:01:e4:1d:2d:03:00:1d:67:02
    Slave queue ID: 0
    
    Also tested with a standard 1Gbps NIC bonding setup (with a mix of
    e1000 and e1000e cards), running LNST's bonding tests.
    
    CC: Jay Vosburgh <j.vosburgh@gmail.com>
    CC: Veaceslav Falico <vfalico@gmail.com>
    CC: Andy Gospodarek <andy@greyhouse.net>
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index fb2dd97857c4..04a21e8048be 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -166,7 +166,7 @@ struct slave {
 	u32    link_failure_count;
 	u32    speed;
 	u16    queue_id;
-	u8     perm_hwaddr[ETH_ALEN];
+	u8     perm_hwaddr[MAX_ADDR_LEN];
 	struct ad_slave_info *ad_info;
 	struct tlb_slave_info tlb_info;
 #ifdef CONFIG_NET_POLL_CONTROLLER
@@ -402,6 +402,16 @@ static inline bool bond_slave_can_tx(struct slave *slave)
 	       bond_is_active_slave(slave);
 }
 
+static inline void bond_hw_addr_copy(u8 *dst, const u8 *src, unsigned int len)
+{
+	if (len == ETH_ALEN) {
+		ether_addr_copy(dst, src);
+		return;
+	}
+
+	memcpy(dst, src, len);
+}
+
 #define BOND_PRI_RESELECT_ALWAYS	0
 #define BOND_PRI_RESELECT_BETTER	1
 #define BOND_PRI_RESELECT_FAILURE	2

commit f307668bfcb7e83b6f62bda6a703e09613a00bd0
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Mon Mar 27 11:37:30 2017 -0700

    bonding: split bond_set_slave_link_state into two parts
    
    Split the function into two (a) propose (b) commit phase without
    changing the semantics for the original API.
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 3c857778a6ca..fb2dd97857c4 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -153,7 +153,8 @@ struct slave {
 	unsigned long last_link_up;
 	unsigned long last_rx;
 	unsigned long target_last_arp_rx[BOND_MAX_ARP_TARGETS];
-	s8     link;    /* one of BOND_LINK_XXXX */
+	s8     link;		/* one of BOND_LINK_XXXX */
+	s8     link_new_state;	/* one of BOND_LINK_XXXX */
 	s8     new_link;
 	u8     backup:1,   /* indicates backup slave. Value corresponds with
 			      BOND_STATE_ACTIVE and BOND_STATE_BACKUP */
@@ -504,13 +505,17 @@ static inline bool bond_is_slave_inactive(struct slave *slave)
 	return slave->inactive;
 }
 
-static inline void bond_set_slave_link_state(struct slave *slave, int state,
-					     bool notify)
+static inline void bond_propose_link_state(struct slave *slave, int state)
+{
+	slave->link_new_state = state;
+}
+
+static inline void bond_commit_link_state(struct slave *slave, bool notify)
 {
-	if (slave->link == state)
+	if (slave->link == slave->link_new_state)
 		return;
 
-	slave->link = state;
+	slave->link = slave->link_new_state;
 	if (notify) {
 		bond_queue_slave_event(slave);
 		bond_lower_state_changed(slave);
@@ -523,6 +528,13 @@ static inline void bond_set_slave_link_state(struct slave *slave, int state,
 	}
 }
 
+static inline void bond_set_slave_link_state(struct slave *slave, int state,
+					     bool notify)
+{
+	bond_propose_link_state(slave, state);
+	bond_commit_link_state(slave, notify);
+}
+
 static inline void bond_slave_link_notify(struct bonding *bond)
 {
 	struct list_head *iter;

commit c7d03a00b56fc23c3a01a8353789ad257363e281
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Nov 17 04:58:21 2016 +0300

    netns: make struct pernet_operations::id unsigned int
    
    Make struct pernet_operations::id unsigned.
    
    There are 2 reasons to do so:
    
    1)
    This field is really an index into an zero based array and
    thus is unsigned entity. Using negative value is out-of-bound
    access by definition.
    
    2)
    On x86_64 unsigned 32-bit data which are mixed with pointers
    via array indexing or offsets added or subtracted to pointers
    are preffered to signed 32-bit data.
    
    "int" being used as an array index needs to be sign-extended
    to 64-bit before being used.
    
            void f(long *p, int i)
            {
                    g(p[i]);
            }
    
      roughly translates to
    
            movsx   rsi, esi
            mov     rdi, [rsi+...]
            call    g
    
    MOVSX is 3 byte instruction which isn't necessary if the variable is
    unsigned because x86_64 is zero extending by default.
    
    Now, there is net_generic() function which, you guessed it right, uses
    "int" as an array index:
    
            static inline void *net_generic(const struct net *net, int id)
            {
                    ...
                    ptr = ng->ptr[id - 1];
                    ...
            }
    
    And this function is used a lot, so those sign extensions add up.
    
    Patch snipes ~1730 bytes on allyesconfig kernel (without all junk
    messing with code generation):
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
    
    Unfortunately some functions actually grow bigger.
    This is a semmingly random artefact of code generation with register
    allocator being used differently. gcc decides that some variable
    needs to live in new r8+ registers and every access now requires REX
    prefix. Or it is shifted into r12, so [r12+0] addressing mode has to be
    used which is longer than [r8]
    
    However, overall balance is in negative direction:
    
            add/remove: 0/0 grow/shrink: 70/598 up/down: 396/-2126 (-1730)
            function                                     old     new   delta
            nfsd4_lock                                  3886    3959     +73
            tipc_link_build_proto_msg                   1096    1140     +44
            mac80211_hwsim_new_radio                    2776    2808     +32
            tipc_mon_rcv                                1032    1058     +26
            svcauth_gss_legacy_init                     1413    1429     +16
            tipc_bcbase_select_primary                   379     392     +13
            nfsd4_exchange_id                           1247    1260     +13
            nfsd4_setclientid_confirm                    782     793     +11
                    ...
            put_client_renew_locked                      494     480     -14
            ip_set_sockfn_get                            730     716     -14
            geneve_sock_add                              829     813     -16
            nfsd4_sequence_done                          721     703     -18
            nlmclnt_lookup_host                          708     686     -22
            nfsd4_lockt                                 1085    1063     -22
            nfs_get_client                              1077    1050     -27
            tcf_bpf_init                                1106    1076     -30
            nfsd4_encode_fattr                          5997    5930     -67
            Total: Before=154856051, After=154854321, chg -0.00%
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index f32f7ef8a23a..3c857778a6ca 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -681,7 +681,7 @@ static inline int bond_get_targets_ip(__be32 *targets, __be32 ip)
 }
 
 /* exported from bond_main.c */
-extern int bond_net_id;
+extern unsigned int bond_net_id;
 extern const struct bond_parm_tbl bond_lacp_tbl[];
 extern const struct bond_parm_tbl xmit_hashtype_tbl[];
 extern const struct bond_parm_tbl arp_validate_tbl[];

commit 4ad41c1e2616a64c9e789d7069b1cb3402d2af3a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Sep 3 19:37:25 2016 -0400

    bonding: quit messing with IOCTL
    
    The only remaining users are issuing SIOCGMIIPHY and SIOCGMIIREG,
    neither of which deals with userland pointers.  Simply calling
    ->ndo_do_ioctl() is fine; no messing with set_fs() is needed.
    It used to mess with SIOCETHTOOL, which would've needed set_fs(),
    but that has been killed in "[NET] ethtool ops are the only way"
    9 years ago...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 6360c259da6d..f32f7ef8a23a 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -37,18 +37,6 @@
 #ifndef __long_aligned
 #define __long_aligned __attribute__((aligned((sizeof(long)))))
 #endif
-/*
- * Less bad way to call ioctl from within the kernel; this needs to be
- * done some other way to get the call out of interrupt context.
- * Needs "ioctl" variable to be supplied by calling context.
- */
-#define IOCTL(dev, arg, cmd) ({		\
-	int res = 0;			\
-	mm_segment_t fs = get_fs();	\
-	set_fs(get_ds());		\
-	res = ioctl(dev, arg, cmd);	\
-	set_fs(fs);			\
-	res; })
 
 #define BOND_MODE(bond) ((bond)->params.mode)
 

commit f87fda00b6ed232a817c655b8d179b48bde8fdbe
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Jun 30 16:13:41 2016 +0200

    bonding: prevent out of bound accesses
    
    ether_addr_equal_64bits() requires some care about its arguments,
    namely that 8 bytes might be read, even if last 2 byte values are not
    used.
    
    KASan detected a violation with null_mac_addr and lacpdu_mcast_addr
    in bond_3ad.c
    
    Same problem with mac_bcast[] and mac_v6_allmcast[] in bond_alb.c :
    Although the 8-byte alignment was there, KASan would detect out
    of bound accesses.
    
    Fixes: 815117adaf5b ("bonding: use ether_addr_equal_unaligned for bond addr compare")
    Fixes: bb54e58929f3 ("bonding: Verify RX LACPDU has proper dest mac-addr")
    Fixes: 885a136c52a8 ("bonding: use compare_ether_addr_64bits() in ALB")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Acked-by: Dmitry Vyukov <dvyukov@google.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 791800ddd6d9..6360c259da6d 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -34,6 +34,9 @@
 
 #define BOND_DEFAULT_MIIMON	100
 
+#ifndef __long_aligned
+#define __long_aligned __attribute__((aligned((sizeof(long)))))
+#endif
 /*
  * Less bad way to call ioctl from within the kernel; this needs to be
  * done some other way to get the call out of interrupt context.
@@ -138,7 +141,9 @@ struct bond_params {
 	struct reciprocal_value reciprocal_packets_per_slave;
 	u16 ad_actor_sys_prio;
 	u16 ad_user_port_key;
-	u8 ad_actor_system[ETH_ALEN];
+
+	/* 2 bytes of padding : see ether_addr_equal_64bits() */
+	u8 ad_actor_system[ETH_ALEN + 2];
 };
 
 struct bond_parm_tbl {

commit fe30937b65354c7fec244caebbdaae68e28ca797
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Mar 17 17:23:36 2016 -0700

    bonding: fix bond_get_stats()
    
    bond_get_stats() can be called from rtnetlink (with RTNL held)
    or from /proc/net/dev seq handler (with RCU held)
    
    The logic added in commit 5f0c5f73e5ef ("bonding: make global bonding
    stats more reliable") kind of assumed only one cpu could run there.
    
    If multiple threads are reading /proc/net/dev, stats can be really
    messed up after a while.
    
    A second problem is that some fields are 32bit, so we need to properly
    handle the wrap around problem.
    
    Given that RTNL is not always held, we need to use
    bond_for_each_slave_rcu().
    
    Fixes: 5f0c5f73e5ef ("bonding: make global bonding stats more reliable")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Andy Gospodarek <gospo@cumulusnetworks.com>
    Cc: Jay Vosburgh <j.vosburgh@gmail.com>
    Cc: Veaceslav Falico <vfalico@gmail.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index ee6c52053aa3..791800ddd6d9 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -215,6 +215,7 @@ struct bonding {
 	 * ALB mode (6) - to sync the use and modifications of its hash table
 	 */
 	spinlock_t mode_lock;
+	spinlock_t stats_lock;
 	u8	 send_peer_notif;
 	u8       igmp_retrans;
 #ifdef CONFIG_PROC_FS

commit f7c7eb7f7af7f87e0fc150994785fd139576e43a
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Dec 3 12:12:20 2015 +0100

    bonding: implement lower state change propagation
    
    Let netdev notifier listeners know about link and slave state change.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 1df437715e2f..ee6c52053aa3 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -247,6 +247,7 @@ struct bonding {
 	((struct slave *) rtnl_dereference(dev->rx_handler_data))
 
 void bond_queue_slave_event(struct slave *slave);
+void bond_lower_state_changed(struct slave *slave);
 
 struct bond_vlan_tag {
 	__be16		vlan_proto;
@@ -328,6 +329,7 @@ static inline void bond_set_active_slave(struct slave *slave)
 	if (slave->backup) {
 		slave->backup = 0;
 		bond_queue_slave_event(slave);
+		bond_lower_state_changed(slave);
 		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 	}
 }
@@ -337,6 +339,7 @@ static inline void bond_set_backup_slave(struct slave *slave)
 	if (!slave->backup) {
 		slave->backup = 1;
 		bond_queue_slave_event(slave);
+		bond_lower_state_changed(slave);
 		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 	}
 }
@@ -349,6 +352,7 @@ static inline void bond_set_slave_state(struct slave *slave,
 
 	slave->backup = slave_state;
 	if (notify) {
+		bond_lower_state_changed(slave);
 		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 		bond_queue_slave_event(slave);
 		slave->should_notify = 0;
@@ -380,6 +384,7 @@ static inline void bond_slave_state_notify(struct bonding *bond)
 
 	bond_for_each_slave(bond, tmp, iter) {
 		if (tmp->should_notify) {
+			bond_lower_state_changed(tmp);
 			rtmsg_ifinfo(RTM_NEWLINK, tmp->dev, 0, GFP_ATOMIC);
 			tmp->should_notify = 0;
 		}
@@ -514,6 +519,7 @@ static inline void bond_set_slave_link_state(struct slave *slave, int state,
 	slave->link = state;
 	if (notify) {
 		bond_queue_slave_event(slave);
+		bond_lower_state_changed(slave);
 		slave->should_notify_link = 0;
 	} else {
 		if (slave->should_notify_link)
@@ -531,6 +537,7 @@ static inline void bond_slave_link_notify(struct bonding *bond)
 	bond_for_each_slave(bond, tmp, iter) {
 		if (tmp->should_notify_link) {
 			bond_queue_slave_event(tmp);
+			bond_lower_state_changed(tmp);
 			tmp->should_notify_link = 0;
 		}
 	}

commit 5d397061ca2081d8a99e4bee5792122faa6aaf86
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Thu Dec 3 12:12:19 2015 +0100

    bonding: allow notifications for bond_set_slave_link_state
    
    Similar to state notifications.
    
    We allow caller to indicate if the notification should happen now or later,
    depending on if he holds rtnl mutex or not. Introduce bond_slave_link_notify
    function (similar to bond_slave_state_notify) which is later on called
    with rtnl mutex and goes over slaves and executes delayed notification.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index c1740a2794a3..1df437715e2f 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -165,7 +165,8 @@ struct slave {
 	u8     backup:1,   /* indicates backup slave. Value corresponds with
 			      BOND_STATE_ACTIVE and BOND_STATE_BACKUP */
 	       inactive:1, /* indicates inactive slave */
-	       should_notify:1; /* indicateds whether the state changed */
+	       should_notify:1, /* indicates whether the state changed */
+	       should_notify_link:1; /* indicates whether the link changed */
 	u8     duplex;
 	u32    original_mtu;
 	u32    link_failure_count;
@@ -504,10 +505,35 @@ static inline bool bond_is_slave_inactive(struct slave *slave)
 	return slave->inactive;
 }
 
-static inline void bond_set_slave_link_state(struct slave *slave, int state)
+static inline void bond_set_slave_link_state(struct slave *slave, int state,
+					     bool notify)
 {
+	if (slave->link == state)
+		return;
+
 	slave->link = state;
-	bond_queue_slave_event(slave);
+	if (notify) {
+		bond_queue_slave_event(slave);
+		slave->should_notify_link = 0;
+	} else {
+		if (slave->should_notify_link)
+			slave->should_notify_link = 0;
+		else
+			slave->should_notify_link = 1;
+	}
+}
+
+static inline void bond_slave_link_notify(struct bonding *bond)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave(bond, tmp, iter) {
+		if (tmp->should_notify_link) {
+			bond_queue_slave_event(tmp);
+			tmp->should_notify_link = 0;
+		}
+	}
 }
 
 static inline __be32 bond_confirm_addr(struct net_device *dev, __be32 dst, __be32 local)

commit e999869548b9ab97b7dffa053ba2fee81c31d069
Author: Matan Barak <matanb@mellanox.com>
Date:   Thu Jul 30 18:33:24 2015 +0300

    net/bonding: Export bond_option_active_slave_get_rcu
    
    Some consumers of the netdev events API would like to know who is the
    active slave when a NETDEV_CHANGEUPPER or NETDEV_BONDING_FAILOVER
    events occur. For example, when managing RoCE GIDs, GIDs based on the
    bond's ips should only be set on the port which corresponds to active
    slave netdevice.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 20defc0353d1..c1740a2794a3 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -310,6 +310,13 @@ static inline bool bond_uses_primary(struct bonding *bond)
 	return bond_mode_uses_primary(BOND_MODE(bond));
 }
 
+static inline struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond)
+{
+	struct slave *slave = rcu_dereference(bond->curr_active_slave);
+
+	return bond_uses_primary(bond) && slave ? slave->dev : NULL;
+}
+
 static inline bool bond_slave_is_up(struct slave *slave)
 {
 	return netif_running(slave->dev) && netif_carrier_ok(slave->dev);

commit d22a5fc0c32edcf5c3bb973ee8c9a2606ba500a8
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat May 9 00:01:57 2015 -0700

    bonding: Implement user key part of port_key in an AD system.
    
    The port key has three components - user-key, speed-part, and duplex-part.
    The LSBit is for the duplex-part, next 5 bits are for the speed while the
    remaining 10 bits are the user defined key bits. Get these 10 bits
    from the user-space (through the SysFs interface) and use it to form the
    admin port-key. Allowed range for the user-key is 0 - 1023 (10 bits). If
    it is not provided then use zero for the user-key-bits (default).
    
    It can set using following example code -
    
       # modprobe bonding mode=4
       # usr_port_key=$(( RANDOM & 0x3FF ))
       # echo $usr_port_key > /sys/class/net/bond0/bonding/ad_user_port_key
       # echo +eth1 > /sys/class/net/bond0/bonding/slaves
       ...
       # ip link set bond0 up
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    [jt: * fixed up style issues reported by checkpatch
         * fixed up context from change in ad_actor_sys_prio patch]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 650f38693956..20defc0353d1 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -137,6 +137,7 @@ struct bond_params {
 	int tlb_dynamic_lb;
 	struct reciprocal_value reciprocal_packets_per_slave;
 	u16 ad_actor_sys_prio;
+	u16 ad_user_port_key;
 	u8 ad_actor_system[ETH_ALEN];
 };
 

commit 74514957552edd4661a4608618121f3c71d4e891
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat May 9 00:01:56 2015 -0700

    bonding: Allow userspace to set actors' macaddr in an AD-system.
    
    In an AD system, the communication between actor and partner is the
    business between these two entities. In the current setup anyone on the
    same L2 can "guess" the LACPDU contents and then possibly send the
    spoofed LACPDUs and trick the partner causing connectivity issues for
    the AD system. This patch allows to use a random mac-address obscuring
    it's identity making it harder for someone in the L2 is do the same thing.
    
    This patch allows user-space to choose the mac-address for the AD-system.
    This mac-address can not be NULL or a Multicast. If the mac-address is set
    from user-space; kernel will honor it and will not overwrite it. In the
    absence (value from user space); the logic will default to using the
    masters' mac as the mac-address for the AD-system.
    
    It can be set using example code below -
    
       # modprobe bonding mode=4
       # sys_mac_addr=$(printf '%02x:%02x:%02x:%02x:%02x:%02x' \
                        $(( (RANDOM & 0xFE) | 0x02 )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )) \
                        $(( RANDOM & 0xFF )))
       # echo $sys_mac_addr > /sys/class/net/bond0/bonding/ad_actor_system
       # echo +eth1 > /sys/class/net/bond0/bonding/slaves
       ...
       # ip link set bond0 up
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    [jt: fixed up style issues reported by checkpatch]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 405cf87a450a..650f38693956 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -137,6 +137,7 @@ struct bond_params {
 	int tlb_dynamic_lb;
 	struct reciprocal_value reciprocal_packets_per_slave;
 	u16 ad_actor_sys_prio;
+	u8 ad_actor_system[ETH_ALEN];
 };
 
 struct bond_parm_tbl {

commit 6791e4661c4bd3e9f193a84247f2c389578a4336
Author: Mahesh Bandewar <maheshb@google.com>
Date:   Sat May 9 00:01:55 2015 -0700

    bonding: Allow userspace to set actors' system_priority in AD system
    
    This patch allows user to randomize the system-priority in an ad-system.
    The allowed range is 1 - 0xFFFF while default value is 0xFFFF. If user
    does not specify this value, the system defaults to 0xFFFF, which is
    what it was before this patch.
    
    Following example code could set the value -
        # modprobe bonding mode=4
        # sys_prio=$(( 1 + RANDOM + RANDOM ))
        # echo $sys_prio > /sys/class/net/bond0/bonding/ad_actor_sys_prio
        # echo +eth1 > /sys/class/net/bond0/bonding/slaves
        ...
        # ip link set bond0 up
    
    Signed-off-by: Mahesh Bandewar <maheshb@google.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@redhat.com>
    [jt: * fixed up style issues reported by checkpatch
         * changed how the default value is set in bond_check_params(), this
           makes the default consistent between what gets set for a new bond
           and what the default is claimed to be in the bonding options.]
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 78ed135e9dea..405cf87a450a 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -136,6 +136,7 @@ struct bond_params {
 	int packets_per_slave;
 	int tlb_dynamic_lb;
 	struct reciprocal_value reciprocal_packets_per_slave;
+	u16 ad_actor_sys_prio;
 };
 
 struct bond_parm_tbl {

commit 73b5a6f2a7a1cb78ccdec3900afc8657e11bc6bf
Author: Matan Barak <matanb@mellanox.com>
Date:   Sun Apr 26 15:55:57 2015 +0300

    net/bonding: Make DRV macros private
    
    The bonding modules currently defines four macros with
    general names that pollute the global namespace:
    DRV_VERSION
    DRV_RELDATE
    DRV_NAME
    DRV_DESCRIPTION
    
    Fixing that by defining a private bonding_priv.h
    header files which includes those defines.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index fda6feeb6c1f..78ed135e9dea 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -30,13 +30,6 @@
 #include <net/bond_alb.h>
 #include <net/bond_options.h>
 
-#define DRV_VERSION	"3.7.1"
-#define DRV_RELDATE	"April 27, 2011"
-#define DRV_NAME	"bonding"
-#define DRV_DESCRIPTION	"Ethernet Channel Bonding Driver"
-
-#define bond_version DRV_DESCRIPTION ": v" DRV_VERSION " (" DRV_RELDATE ")\n"
-
 #define BOND_MAX_ARP_TARGETS	16
 
 #define BOND_DEFAULT_MIIMON	100

commit 92e584fe443995bbb84069a4d13ea8ebedb5c5c8
Author: Moni Shoua <monis@mellanox.com>
Date:   Sun Feb 8 11:49:32 2015 +0200

    net/bonding: Fix potential bad memory access during bonding events
    
    When queuing work to send the NETDEV_BONDING_INFO netdev event, it's
    possible that when the work is executed, the pointer to the slave
    becomes invalid. This can happen if between queuing the event and the
    execution of the work, the net-device was un-ensvaled and re-enslaved.
    
    Fix that by queuing a work with the data of the slave instead of the
    slave structure.
    
    Fixes: 69e6113343cf ('net/bonding: Notify state change on slaves')
    Reported-by: Nikolay Aleksandrov <nikolay@redhat.com>
    Signed-off-by: Moni Shoua <monis@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 4e17095ad46a..fda6feeb6c1f 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -152,8 +152,8 @@ struct bond_parm_tbl {
 
 struct netdev_notify_work {
 	struct delayed_work	work;
-	struct slave		*slave;
 	struct net_device	*dev;
+	struct netdev_bonding_info bonding_info;
 };
 
 struct slave {

commit 69e6113343cfe983511904ffca0d7a1466460b67
Author: Moni Shoua <monis@mellanox.com>
Date:   Tue Feb 3 16:48:31 2015 +0200

    net/bonding: Notify state change on slaves
    
    Use notifier chain to dispatch an event upon a change in slave state.
    Event is dispatched with slave specific info.
    
    Signed-off-by: Moni Shoua <monis@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index d1367ec74933..4e17095ad46a 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -150,6 +150,12 @@ struct bond_parm_tbl {
 	int mode;
 };
 
+struct netdev_notify_work {
+	struct delayed_work	work;
+	struct slave		*slave;
+	struct net_device	*dev;
+};
+
 struct slave {
 	struct net_device *dev; /* first - useful for panic debug */
 	struct bonding *bond; /* our master */
@@ -243,6 +249,8 @@ struct bonding {
 #define bond_slave_get_rtnl(dev) \
 	((struct slave *) rtnl_dereference(dev->rx_handler_data))
 
+void bond_queue_slave_event(struct slave *slave);
+
 struct bond_vlan_tag {
 	__be16		vlan_proto;
 	unsigned short	vlan_id;
@@ -315,6 +323,7 @@ static inline void bond_set_active_slave(struct slave *slave)
 {
 	if (slave->backup) {
 		slave->backup = 0;
+		bond_queue_slave_event(slave);
 		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 	}
 }
@@ -323,6 +332,7 @@ static inline void bond_set_backup_slave(struct slave *slave)
 {
 	if (!slave->backup) {
 		slave->backup = 1;
+		bond_queue_slave_event(slave);
 		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
 	}
 }
@@ -336,6 +346,7 @@ static inline void bond_set_slave_state(struct slave *slave,
 	slave->backup = slave_state;
 	if (notify) {
 		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
+		bond_queue_slave_event(slave);
 		slave->should_notify = 0;
 	} else {
 		if (slave->should_notify)
@@ -493,6 +504,7 @@ static inline bool bond_is_slave_inactive(struct slave *slave)
 static inline void bond_set_slave_link_state(struct slave *slave, int state)
 {
 	slave->link = state;
+	bond_queue_slave_event(slave);
 }
 
 static inline __be32 bond_confirm_addr(struct net_device *dev, __be32 dst, __be32 local)

commit 69a2338e05995b10225b2a131f7540d1305980e4
Author: Moni Shoua <monis@mellanox.com>
Date:   Tue Feb 3 16:48:30 2015 +0200

    net/bonding: Move slave state changes to a helper function
    
    Move slave state changes to a helper function, this is a pre-step for adding
    functionality of dispatching an event when this helper is called.
    
    This commit doesn't add new functionality.
    
    Signed-off-by: Moni Shoua <monis@mellanox.com>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 29f53eacac0a..d1367ec74933 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -490,6 +490,11 @@ static inline bool bond_is_slave_inactive(struct slave *slave)
 	return slave->inactive;
 }
 
+static inline void bond_set_slave_link_state(struct slave *slave, int state)
+{
+	slave->link = state;
+}
+
 static inline __be32 bond_confirm_addr(struct net_device *dev, __be32 dst, __be32 local)
 {
 	struct in_device *in_dev;

commit 2477bc9a3db53540c64687c79efae9a7f1f60cef
Author: Jonathan Toppins <jtoppins@cumulusnetworks.com>
Date:   Mon Jan 26 01:16:57 2015 -0500

    bonding: update bond carrier state when min_links option changes
    
    Cc: Andy Gospodarek <gospo@cumulusnetworks.com>
    Signed-off-by: Jonathan Toppins <jtoppins@cumulusnetworks.com>
    Signed-off-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
index 983a94b86b95..29f53eacac0a 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -525,6 +525,7 @@ void bond_sysfs_slave_del(struct slave *slave);
 int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev);
 int bond_release(struct net_device *bond_dev, struct net_device *slave_dev);
 u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb);
+int bond_set_carrier(struct bonding *bond);
 void bond_select_active_slave(struct bonding *bond);
 void bond_change_active_slave(struct bonding *bond, struct slave *new_active);
 void bond_create_debugfs(void);

commit 1ef8019be8799c39f316a772ffdd705c46029752
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 10 13:27:49 2014 -0500

    net: Move bonding headers under include/net
    
    This ways drivers like cxgb4 don't need to do ugly relative includes.
    
    Reported-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/bonding.h b/include/net/bonding.h
new file mode 100644
index 000000000000..983a94b86b95
--- /dev/null
+++ b/include/net/bonding.h
@@ -0,0 +1,654 @@
+/*
+ * Bond several ethernet interfaces into a Cisco, running 'Etherchannel'.
+ *
+ * Portions are (c) Copyright 1995 Simon "Guru Aleph-Null" Janes
+ * NCM: Network and Communications Management, Inc.
+ *
+ * BUT, I'm the one who modified it for ethernet, so:
+ * (c) Copyright 1999, Thomas Davis, tadavis@lbl.gov
+ *
+ *	This software may be used and distributed according to the terms
+ *	of the GNU Public License, incorporated herein by reference.
+ *
+ */
+
+#ifndef _NET_BONDING_H
+#define _NET_BONDING_H
+
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/if_bonding.h>
+#include <linux/cpumask.h>
+#include <linux/in6.h>
+#include <linux/netpoll.h>
+#include <linux/inetdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/reciprocal_div.h>
+#include <linux/if_link.h>
+
+#include <net/bond_3ad.h>
+#include <net/bond_alb.h>
+#include <net/bond_options.h>
+
+#define DRV_VERSION	"3.7.1"
+#define DRV_RELDATE	"April 27, 2011"
+#define DRV_NAME	"bonding"
+#define DRV_DESCRIPTION	"Ethernet Channel Bonding Driver"
+
+#define bond_version DRV_DESCRIPTION ": v" DRV_VERSION " (" DRV_RELDATE ")\n"
+
+#define BOND_MAX_ARP_TARGETS	16
+
+#define BOND_DEFAULT_MIIMON	100
+
+/*
+ * Less bad way to call ioctl from within the kernel; this needs to be
+ * done some other way to get the call out of interrupt context.
+ * Needs "ioctl" variable to be supplied by calling context.
+ */
+#define IOCTL(dev, arg, cmd) ({		\
+	int res = 0;			\
+	mm_segment_t fs = get_fs();	\
+	set_fs(get_ds());		\
+	res = ioctl(dev, arg, cmd);	\
+	set_fs(fs);			\
+	res; })
+
+#define BOND_MODE(bond) ((bond)->params.mode)
+
+/* slave list primitives */
+#define bond_slave_list(bond) (&(bond)->dev->adj_list.lower)
+
+#define bond_has_slaves(bond) !list_empty(bond_slave_list(bond))
+
+/* IMPORTANT: bond_first/last_slave can return NULL in case of an empty list */
+#define bond_first_slave(bond) \
+	(bond_has_slaves(bond) ? \
+		netdev_adjacent_get_private(bond_slave_list(bond)->next) : \
+		NULL)
+#define bond_last_slave(bond) \
+	(bond_has_slaves(bond) ? \
+		netdev_adjacent_get_private(bond_slave_list(bond)->prev) : \
+		NULL)
+
+/* Caller must have rcu_read_lock */
+#define bond_first_slave_rcu(bond) \
+	netdev_lower_get_first_private_rcu(bond->dev)
+
+#define bond_is_first_slave(bond, pos) (pos == bond_first_slave(bond))
+#define bond_is_last_slave(bond, pos) (pos == bond_last_slave(bond))
+
+/**
+ * bond_for_each_slave - iterate over all slaves
+ * @bond:	the bond holding this list
+ * @pos:	current slave
+ * @iter:	list_head * iterator
+ *
+ * Caller must hold RTNL
+ */
+#define bond_for_each_slave(bond, pos, iter) \
+	netdev_for_each_lower_private((bond)->dev, pos, iter)
+
+/* Caller must have rcu_read_lock */
+#define bond_for_each_slave_rcu(bond, pos, iter) \
+	netdev_for_each_lower_private_rcu((bond)->dev, pos, iter)
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+extern atomic_t netpoll_block_tx;
+
+static inline void block_netpoll_tx(void)
+{
+	atomic_inc(&netpoll_block_tx);
+}
+
+static inline void unblock_netpoll_tx(void)
+{
+	atomic_dec(&netpoll_block_tx);
+}
+
+static inline int is_netpoll_tx_blocked(struct net_device *dev)
+{
+	if (unlikely(netpoll_tx_running(dev)))
+		return atomic_read(&netpoll_block_tx);
+	return 0;
+}
+#else
+#define block_netpoll_tx()
+#define unblock_netpoll_tx()
+#define is_netpoll_tx_blocked(dev) (0)
+#endif
+
+struct bond_params {
+	int mode;
+	int xmit_policy;
+	int miimon;
+	u8 num_peer_notif;
+	int arp_interval;
+	int arp_validate;
+	int arp_all_targets;
+	int use_carrier;
+	int fail_over_mac;
+	int updelay;
+	int downdelay;
+	int lacp_fast;
+	unsigned int min_links;
+	int ad_select;
+	char primary[IFNAMSIZ];
+	int primary_reselect;
+	__be32 arp_targets[BOND_MAX_ARP_TARGETS];
+	int tx_queues;
+	int all_slaves_active;
+	int resend_igmp;
+	int lp_interval;
+	int packets_per_slave;
+	int tlb_dynamic_lb;
+	struct reciprocal_value reciprocal_packets_per_slave;
+};
+
+struct bond_parm_tbl {
+	char *modename;
+	int mode;
+};
+
+struct slave {
+	struct net_device *dev; /* first - useful for panic debug */
+	struct bonding *bond; /* our master */
+	int    delay;
+	/* all three in jiffies */
+	unsigned long last_link_up;
+	unsigned long last_rx;
+	unsigned long target_last_arp_rx[BOND_MAX_ARP_TARGETS];
+	s8     link;    /* one of BOND_LINK_XXXX */
+	s8     new_link;
+	u8     backup:1,   /* indicates backup slave. Value corresponds with
+			      BOND_STATE_ACTIVE and BOND_STATE_BACKUP */
+	       inactive:1, /* indicates inactive slave */
+	       should_notify:1; /* indicateds whether the state changed */
+	u8     duplex;
+	u32    original_mtu;
+	u32    link_failure_count;
+	u32    speed;
+	u16    queue_id;
+	u8     perm_hwaddr[ETH_ALEN];
+	struct ad_slave_info *ad_info;
+	struct tlb_slave_info tlb_info;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	struct netpoll *np;
+#endif
+	struct kobject kobj;
+	struct rtnl_link_stats64 slave_stats;
+};
+
+struct bond_up_slave {
+	unsigned int	count;
+	struct rcu_head rcu;
+	struct slave	*arr[0];
+};
+
+/*
+ * Link pseudo-state only used internally by monitors
+ */
+#define BOND_LINK_NOCHANGE -1
+
+/*
+ * Here are the locking policies for the two bonding locks:
+ * Get rcu_read_lock when reading or RTNL when writing slave list.
+ */
+struct bonding {
+	struct   net_device *dev; /* first - useful for panic debug */
+	struct   slave __rcu *curr_active_slave;
+	struct   slave __rcu *current_arp_slave;
+	struct   slave __rcu *primary_slave;
+	struct   bond_up_slave __rcu *slave_arr; /* Array of usable slaves */
+	bool     force_primary;
+	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
+	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
+			      struct slave *);
+	/* mode_lock is used for mode-specific locking needs, currently used by:
+	 * 3ad mode (4) - protect against running bond_3ad_unbind_slave() and
+	 *                bond_3ad_state_machine_handler() concurrently and also
+	 *                the access to the state machine shared variables.
+	 * TLB mode (5) - to sync the use and modifications of its hash table
+	 * ALB mode (6) - to sync the use and modifications of its hash table
+	 */
+	spinlock_t mode_lock;
+	u8	 send_peer_notif;
+	u8       igmp_retrans;
+#ifdef CONFIG_PROC_FS
+	struct   proc_dir_entry *proc_entry;
+	char     proc_file_name[IFNAMSIZ];
+#endif /* CONFIG_PROC_FS */
+	struct   list_head bond_list;
+	u32      rr_tx_counter;
+	struct   ad_bond_info ad_info;
+	struct   alb_bond_info alb_info;
+	struct   bond_params params;
+	struct   workqueue_struct *wq;
+	struct   delayed_work mii_work;
+	struct   delayed_work arp_work;
+	struct   delayed_work alb_work;
+	struct   delayed_work ad_work;
+	struct   delayed_work mcast_work;
+	struct   delayed_work slave_arr_work;
+#ifdef CONFIG_DEBUG_FS
+	/* debugging support via debugfs */
+	struct	 dentry *debug_dir;
+#endif /* CONFIG_DEBUG_FS */
+	struct rtnl_link_stats64 bond_stats;
+};
+
+#define bond_slave_get_rcu(dev) \
+	((struct slave *) rcu_dereference(dev->rx_handler_data))
+
+#define bond_slave_get_rtnl(dev) \
+	((struct slave *) rtnl_dereference(dev->rx_handler_data))
+
+struct bond_vlan_tag {
+	__be16		vlan_proto;
+	unsigned short	vlan_id;
+};
+
+/**
+ * Returns NULL if the net_device does not belong to any of the bond's slaves
+ *
+ * Caller must hold bond lock for read
+ */
+static inline struct slave *bond_get_slave_by_dev(struct bonding *bond,
+						  struct net_device *slave_dev)
+{
+	return netdev_lower_dev_get_private(bond->dev, slave_dev);
+}
+
+static inline struct bonding *bond_get_bond_by_slave(struct slave *slave)
+{
+	return slave->bond;
+}
+
+static inline bool bond_should_override_tx_queue(struct bonding *bond)
+{
+	return BOND_MODE(bond) == BOND_MODE_ACTIVEBACKUP ||
+	       BOND_MODE(bond) == BOND_MODE_ROUNDROBIN;
+}
+
+static inline bool bond_is_lb(const struct bonding *bond)
+{
+	return BOND_MODE(bond) == BOND_MODE_TLB ||
+	       BOND_MODE(bond) == BOND_MODE_ALB;
+}
+
+static inline bool bond_is_nondyn_tlb(const struct bonding *bond)
+{
+	return (BOND_MODE(bond) == BOND_MODE_TLB)  &&
+	       (bond->params.tlb_dynamic_lb == 0);
+}
+
+static inline bool bond_mode_uses_xmit_hash(const struct bonding *bond)
+{
+	return (BOND_MODE(bond) == BOND_MODE_8023AD ||
+		BOND_MODE(bond) == BOND_MODE_XOR ||
+		bond_is_nondyn_tlb(bond));
+}
+
+static inline bool bond_mode_uses_arp(int mode)
+{
+	return mode != BOND_MODE_8023AD && mode != BOND_MODE_TLB &&
+	       mode != BOND_MODE_ALB;
+}
+
+static inline bool bond_mode_uses_primary(int mode)
+{
+	return mode == BOND_MODE_ACTIVEBACKUP || mode == BOND_MODE_TLB ||
+	       mode == BOND_MODE_ALB;
+}
+
+static inline bool bond_uses_primary(struct bonding *bond)
+{
+	return bond_mode_uses_primary(BOND_MODE(bond));
+}
+
+static inline bool bond_slave_is_up(struct slave *slave)
+{
+	return netif_running(slave->dev) && netif_carrier_ok(slave->dev);
+}
+
+static inline void bond_set_active_slave(struct slave *slave)
+{
+	if (slave->backup) {
+		slave->backup = 0;
+		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
+	}
+}
+
+static inline void bond_set_backup_slave(struct slave *slave)
+{
+	if (!slave->backup) {
+		slave->backup = 1;
+		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
+	}
+}
+
+static inline void bond_set_slave_state(struct slave *slave,
+					int slave_state, bool notify)
+{
+	if (slave->backup == slave_state)
+		return;
+
+	slave->backup = slave_state;
+	if (notify) {
+		rtmsg_ifinfo(RTM_NEWLINK, slave->dev, 0, GFP_ATOMIC);
+		slave->should_notify = 0;
+	} else {
+		if (slave->should_notify)
+			slave->should_notify = 0;
+		else
+			slave->should_notify = 1;
+	}
+}
+
+static inline void bond_slave_state_change(struct bonding *bond)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave(bond, tmp, iter) {
+		if (tmp->link == BOND_LINK_UP)
+			bond_set_active_slave(tmp);
+		else if (tmp->link == BOND_LINK_DOWN)
+			bond_set_backup_slave(tmp);
+	}
+}
+
+static inline void bond_slave_state_notify(struct bonding *bond)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave(bond, tmp, iter) {
+		if (tmp->should_notify) {
+			rtmsg_ifinfo(RTM_NEWLINK, tmp->dev, 0, GFP_ATOMIC);
+			tmp->should_notify = 0;
+		}
+	}
+}
+
+static inline int bond_slave_state(struct slave *slave)
+{
+	return slave->backup;
+}
+
+static inline bool bond_is_active_slave(struct slave *slave)
+{
+	return !bond_slave_state(slave);
+}
+
+static inline bool bond_slave_can_tx(struct slave *slave)
+{
+	return bond_slave_is_up(slave) && slave->link == BOND_LINK_UP &&
+	       bond_is_active_slave(slave);
+}
+
+#define BOND_PRI_RESELECT_ALWAYS	0
+#define BOND_PRI_RESELECT_BETTER	1
+#define BOND_PRI_RESELECT_FAILURE	2
+
+#define BOND_FOM_NONE			0
+#define BOND_FOM_ACTIVE			1
+#define BOND_FOM_FOLLOW			2
+
+#define BOND_ARP_TARGETS_ANY		0
+#define BOND_ARP_TARGETS_ALL		1
+
+#define BOND_ARP_VALIDATE_NONE		0
+#define BOND_ARP_VALIDATE_ACTIVE	(1 << BOND_STATE_ACTIVE)
+#define BOND_ARP_VALIDATE_BACKUP	(1 << BOND_STATE_BACKUP)
+#define BOND_ARP_VALIDATE_ALL		(BOND_ARP_VALIDATE_ACTIVE | \
+					 BOND_ARP_VALIDATE_BACKUP)
+#define BOND_ARP_FILTER			(BOND_ARP_VALIDATE_ALL + 1)
+#define BOND_ARP_FILTER_ACTIVE		(BOND_ARP_VALIDATE_ACTIVE | \
+					 BOND_ARP_FILTER)
+#define BOND_ARP_FILTER_BACKUP		(BOND_ARP_VALIDATE_BACKUP | \
+					 BOND_ARP_FILTER)
+
+#define BOND_SLAVE_NOTIFY_NOW		true
+#define BOND_SLAVE_NOTIFY_LATER		false
+
+static inline int slave_do_arp_validate(struct bonding *bond,
+					struct slave *slave)
+{
+	return bond->params.arp_validate & (1 << bond_slave_state(slave));
+}
+
+static inline int slave_do_arp_validate_only(struct bonding *bond)
+{
+	return bond->params.arp_validate & BOND_ARP_FILTER;
+}
+
+static inline int bond_is_ip_target_ok(__be32 addr)
+{
+	return !ipv4_is_lbcast(addr) && !ipv4_is_zeronet(addr);
+}
+
+/* Get the oldest arp which we've received on this slave for bond's
+ * arp_targets.
+ */
+static inline unsigned long slave_oldest_target_arp_rx(struct bonding *bond,
+						       struct slave *slave)
+{
+	int i = 1;
+	unsigned long ret = slave->target_last_arp_rx[0];
+
+	for (; (i < BOND_MAX_ARP_TARGETS) && bond->params.arp_targets[i]; i++)
+		if (time_before(slave->target_last_arp_rx[i], ret))
+			ret = slave->target_last_arp_rx[i];
+
+	return ret;
+}
+
+static inline unsigned long slave_last_rx(struct bonding *bond,
+					struct slave *slave)
+{
+	if (bond->params.arp_all_targets == BOND_ARP_TARGETS_ALL)
+		return slave_oldest_target_arp_rx(bond, slave);
+
+	return slave->last_rx;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static inline void bond_netpoll_send_skb(const struct slave *slave,
+					 struct sk_buff *skb)
+{
+	struct netpoll *np = slave->np;
+
+	if (np)
+		netpoll_send_skb(np, skb);
+}
+#else
+static inline void bond_netpoll_send_skb(const struct slave *slave,
+					 struct sk_buff *skb)
+{
+}
+#endif
+
+static inline void bond_set_slave_inactive_flags(struct slave *slave,
+						 bool notify)
+{
+	if (!bond_is_lb(slave->bond))
+		bond_set_slave_state(slave, BOND_STATE_BACKUP, notify);
+	if (!slave->bond->params.all_slaves_active)
+		slave->inactive = 1;
+}
+
+static inline void bond_set_slave_active_flags(struct slave *slave,
+					       bool notify)
+{
+	bond_set_slave_state(slave, BOND_STATE_ACTIVE, notify);
+	slave->inactive = 0;
+}
+
+static inline bool bond_is_slave_inactive(struct slave *slave)
+{
+	return slave->inactive;
+}
+
+static inline __be32 bond_confirm_addr(struct net_device *dev, __be32 dst, __be32 local)
+{
+	struct in_device *in_dev;
+	__be32 addr = 0;
+
+	rcu_read_lock();
+	in_dev = __in_dev_get_rcu(dev);
+
+	if (in_dev)
+		addr = inet_confirm_addr(dev_net(dev), in_dev, dst, local,
+					 RT_SCOPE_HOST);
+	rcu_read_unlock();
+	return addr;
+}
+
+struct bond_net {
+	struct net		*net;	/* Associated network namespace */
+	struct list_head	dev_list;
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*proc_dir;
+#endif
+	struct class_attribute	class_attr_bonding_masters;
+};
+
+int bond_arp_rcv(const struct sk_buff *skb, struct bonding *bond, struct slave *slave);
+void bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb, struct net_device *slave_dev);
+int bond_create(struct net *net, const char *name);
+int bond_create_sysfs(struct bond_net *net);
+void bond_destroy_sysfs(struct bond_net *net);
+void bond_prepare_sysfs_group(struct bonding *bond);
+int bond_sysfs_slave_add(struct slave *slave);
+void bond_sysfs_slave_del(struct slave *slave);
+int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev);
+int bond_release(struct net_device *bond_dev, struct net_device *slave_dev);
+u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb);
+void bond_select_active_slave(struct bonding *bond);
+void bond_change_active_slave(struct bonding *bond, struct slave *new_active);
+void bond_create_debugfs(void);
+void bond_destroy_debugfs(void);
+void bond_debug_register(struct bonding *bond);
+void bond_debug_unregister(struct bonding *bond);
+void bond_debug_reregister(struct bonding *bond);
+const char *bond_mode_name(int mode);
+void bond_setup(struct net_device *bond_dev);
+unsigned int bond_get_num_tx_queues(void);
+int bond_netlink_init(void);
+void bond_netlink_fini(void);
+struct net_device *bond_option_active_slave_get_rcu(struct bonding *bond);
+const char *bond_slave_link_status(s8 link);
+struct bond_vlan_tag *bond_verify_device_path(struct net_device *start_dev,
+					      struct net_device *end_dev,
+					      int level);
+int bond_update_slave_arr(struct bonding *bond, struct slave *skipslave);
+void bond_slave_arr_work_rearm(struct bonding *bond, unsigned long delay);
+
+#ifdef CONFIG_PROC_FS
+void bond_create_proc_entry(struct bonding *bond);
+void bond_remove_proc_entry(struct bonding *bond);
+void bond_create_proc_dir(struct bond_net *bn);
+void bond_destroy_proc_dir(struct bond_net *bn);
+#else
+static inline void bond_create_proc_entry(struct bonding *bond)
+{
+}
+
+static inline void bond_remove_proc_entry(struct bonding *bond)
+{
+}
+
+static inline void bond_create_proc_dir(struct bond_net *bn)
+{
+}
+
+static inline void bond_destroy_proc_dir(struct bond_net *bn)
+{
+}
+#endif
+
+static inline struct slave *bond_slave_has_mac(struct bonding *bond,
+					       const u8 *mac)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave(bond, tmp, iter)
+		if (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))
+			return tmp;
+
+	return NULL;
+}
+
+/* Caller must hold rcu_read_lock() for read */
+static inline struct slave *bond_slave_has_mac_rcu(struct bonding *bond,
+					       const u8 *mac)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave_rcu(bond, tmp, iter)
+		if (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))
+			return tmp;
+
+	return NULL;
+}
+
+/* Caller must hold rcu_read_lock() for read */
+static inline bool bond_slave_has_mac_rx(struct bonding *bond, const u8 *mac)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+	struct netdev_hw_addr *ha;
+
+	bond_for_each_slave_rcu(bond, tmp, iter)
+		if (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))
+			return true;
+
+	if (netdev_uc_empty(bond->dev))
+		return false;
+
+	netdev_for_each_uc_addr(ha, bond->dev)
+		if (ether_addr_equal_64bits(mac, ha->addr))
+			return true;
+
+	return false;
+}
+
+/* Check if the ip is present in arp ip list, or first free slot if ip == 0
+ * Returns -1 if not found, index if found
+ */
+static inline int bond_get_targets_ip(__be32 *targets, __be32 ip)
+{
+	int i;
+
+	for (i = 0; i < BOND_MAX_ARP_TARGETS; i++)
+		if (targets[i] == ip)
+			return i;
+		else if (targets[i] == 0)
+			break;
+
+	return -1;
+}
+
+/* exported from bond_main.c */
+extern int bond_net_id;
+extern const struct bond_parm_tbl bond_lacp_tbl[];
+extern const struct bond_parm_tbl xmit_hashtype_tbl[];
+extern const struct bond_parm_tbl arp_validate_tbl[];
+extern const struct bond_parm_tbl arp_all_targets_tbl[];
+extern const struct bond_parm_tbl fail_over_mac_tbl[];
+extern const struct bond_parm_tbl pri_reselect_tbl[];
+extern struct bond_parm_tbl ad_select_tbl[];
+
+/* exported from bond_netlink.c */
+extern struct rtnl_link_ops bond_link_ops;
+
+static inline void bond_tx_drop(struct net_device *dev, struct sk_buff *skb)
+{
+	atomic_long_inc(&dev->tx_dropped);
+	dev_kfree_skb_any(skb);
+}
+
+#endif /* _NET_BONDING_H */
