commit 7400b063969bdca4a06cd97f1294d765c8eecbe1
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Sat Mar 7 17:52:36 2020 +0100

    nft_set_pipapo: Introduce AVX2-based lookup implementation
    
    If the AVX2 set is available, we can exploit the repetitive
    characteristic of this algorithm to provide a fast, vectorised
    version by using 256-bit wide AVX2 operations for bucket loads and
    bitwise intersections.
    
    In most cases, this implementation consistently outperforms rbtree
    set instances despite the fact they are configured to use a given,
    single, ranged data type out of the ones used for performance
    measurements by the nft_concat_range.sh kselftest.
    
    That script, injecting packets directly on the ingoing device path
    with pktgen, reports, averaged over five runs on a single AMD Epyc
    7402 thread (3.35GHz, 768 KiB L1D$, 12 MiB L2$), the figures below.
    CONFIG_RETPOLINE was not set here.
    
    Note that this is not a fair comparison over hash and rbtree set
    types: non-ranged entries (used to have a reference for hash types)
    would be matched faster than this, and matching on a single field
    only (which is the case for rbtree) is also significantly faster.
    
    However, it's not possible at the moment to choose this set type
    for non-ranged entries, and the current implementation also needs
    a few minor adjustments in order to match on less than two fields.
    
     ---------------.-----------------------------------.------------.
     AMD Epyc 7402  |          baselines, Mpps          | this patch |
      1 thread      |___________________________________|____________|
      3.35GHz       |        |        |        |        |            |
      768KiB L1D$   | netdev |  hash  | rbtree |        |            |
     ---------------|  hook  |   no   | single |        |   pipapo   |
     type   entries |  drop  | ranges | field  | pipapo |    AVX2    |
     ---------------|--------|--------|--------|--------|------------|
     net,port       |        |        |        |        |            |
              1000  |   19.0 |   10.4 |    3.8 |    4.0 | 7.5   +87% |
     ---------------|--------|--------|--------|--------|------------|
     port,net       |        |        |        |        |            |
               100  |   18.8 |   10.3 |    5.8 |    6.3 | 8.1   +29% |
     ---------------|--------|--------|--------|--------|------------|
     net6,port      |        |        |        |        |            |
              1000  |   16.4 |    7.6 |    1.8 |    2.1 | 4.8  +128% |
     ---------------|--------|--------|--------|--------|------------|
     port,proto     |        |        |        |        |            |
             30000  |   19.6 |   11.6 |    3.9 |    0.5 | 2.6  +420% |
     ---------------|--------|--------|--------|--------|------------|
     net6,port,mac  |        |        |        |        |            |
                10  |   16.5 |    5.4 |    4.3 |    3.4 | 4.7   +38% |
     ---------------|--------|--------|--------|--------|------------|
     net6,port,mac, |        |        |        |        |            |
     proto    1000  |   16.5 |    5.7 |    1.9 |    1.4 | 3.6   +26% |
     ---------------|--------|--------|--------|--------|------------|
     net,mac        |        |        |        |        |            |
              1000  |   19.0 |    8.4 |    3.9 |    2.5 | 6.4  +156% |
     ---------------'--------'--------'--------'--------'------------'
    
    A similar strategy could be easily reused to implement specialised
    versions for other SIMD sets, and I plan to post at least a NEON
    version at a later time.
    
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 3e30cc5d195b..78516de14d31 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -75,6 +75,7 @@ extern const struct nft_set_type nft_set_hash_fast_type;
 extern const struct nft_set_type nft_set_rbtree_type;
 extern const struct nft_set_type nft_set_bitmap_type;
 extern const struct nft_set_type nft_set_pipapo_type;
+extern const struct nft_set_type nft_set_pipapo_avx2_type;
 
 struct nft_expr;
 struct nft_regs;

commit 24d19826fcbd97144908ae32019ee67d358c5879
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Feb 18 11:59:27 2020 +0100

    netfilter: nf_tables: make all set structs const
    
    They do not need to be writeable anymore.
    
    v2: remove left-over __read_mostly annotation in set_pipapo.c (Stefano)
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 29e7e1021267..3e30cc5d195b 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -69,12 +69,12 @@ extern const struct nft_expr_ops nft_payload_fast_ops;
 extern struct static_key_false nft_counters_enabled;
 extern struct static_key_false nft_trace_enabled;
 
-extern struct nft_set_type nft_set_rhash_type;
-extern struct nft_set_type nft_set_hash_type;
-extern struct nft_set_type nft_set_hash_fast_type;
-extern struct nft_set_type nft_set_rbtree_type;
-extern struct nft_set_type nft_set_bitmap_type;
-extern struct nft_set_type nft_set_pipapo_type;
+extern const struct nft_set_type nft_set_rhash_type;
+extern const struct nft_set_type nft_set_hash_type;
+extern const struct nft_set_type nft_set_hash_fast_type;
+extern const struct nft_set_type nft_set_rbtree_type;
+extern const struct nft_set_type nft_set_bitmap_type;
+extern const struct nft_set_type nft_set_pipapo_type;
 
 struct nft_expr;
 struct nft_regs;

commit 3c4287f62044a90e73a561aa05fc46e62da173da
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Wed Jan 22 00:17:55 2020 +0100

    nf_tables: Add set type for arbitrary concatenation of ranges
    
    This new set type allows for intervals in concatenated fields,
    which are expressed in the usual way, that is, simple byte
    concatenation with padding to 32 bits for single fields, and
    given as ranges by specifying start and end elements containing,
    each, the full concatenation of start and end values for the
    single fields.
    
    Ranges are expanded to composing netmasks, for each field: these
    are inserted as rules in per-field lookup tables. Bits to be
    classified are divided in 4-bit groups, and for each group, the
    lookup table contains 4^2 buckets, representing all the possible
    values of a bit group. This approach was inspired by the Grouper
    algorithm:
            http://www.cse.usf.edu/~ligatti/projects/grouper/
    
    Matching is performed by a sequence of AND operations between
    bucket values, with buckets selected according to the value of
    packet bits, for each group. The result of this sequence tells
    us which rules matched for a given field.
    
    In order to concatenate several ranged fields, per-field rules
    are mapped using mapping arrays, one per field, that specify
    which rules should be considered while matching the next field.
    The mapping array for the last field contains a reference to
    the element originally inserted.
    
    The notes in nft_set_pipapo.c cover the algorithm in deeper
    detail.
    
    A pure hash-based approach is of no use here, as ranges need
    to be classified. An implementation based on "proxying" the
    existing red-black tree set type, creating a tree for each
    field, was considered, but deemed impractical due to the fact
    that elements would need to be shared between trees, at least
    as long as we want to keep UAPI changes to a minimum.
    
    A stand-alone implementation of this algorithm is available at:
            https://pipapo.lameexcu.se
    together with notes about possible future optimisations
    (in pipapo.c).
    
    This algorithm was designed with data locality in mind, and can
    be highly optimised for SIMD instruction sets, as the bulk of
    the matching work is done with repetitive, simple bitwise
    operations.
    
    At this point, without further optimisations, nft_concat_range.sh
    reports, for one AMD Epyc 7351 thread (2.9GHz, 512 KiB L1D$, 8 MiB
    L2$):
    
    TEST: performance
      net,port                                                      [ OK ]
        baseline (drop from netdev hook):              10190076pps
        baseline hash (non-ranged entries):             6179564pps
        baseline rbtree (match on first field only):    2950341pps
        set with  1000 full, ranged entries:            2304165pps
      port,net                                                      [ OK ]
        baseline (drop from netdev hook):              10143615pps
        baseline hash (non-ranged entries):             6135776pps
        baseline rbtree (match on first field only):    4311934pps
        set with   100 full, ranged entries:            4131471pps
      net6,port                                                     [ OK ]
        baseline (drop from netdev hook):               9730404pps
        baseline hash (non-ranged entries):             4809557pps
        baseline rbtree (match on first field only):    1501699pps
        set with  1000 full, ranged entries:            1092557pps
      port,proto                                                    [ OK ]
        baseline (drop from netdev hook):              10812426pps
        baseline hash (non-ranged entries):             6929353pps
        baseline rbtree (match on first field only):    3027105pps
        set with 30000 full, ranged entries:             284147pps
      net6,port,mac                                                 [ OK ]
        baseline (drop from netdev hook):               9660114pps
        baseline hash (non-ranged entries):             3778877pps
        baseline rbtree (match on first field only):    3179379pps
        set with    10 full, ranged entries:            2082880pps
      net6,port,mac,proto                                           [ OK ]
        baseline (drop from netdev hook):               9718324pps
        baseline hash (non-ranged entries):             3799021pps
        baseline rbtree (match on first field only):    1506689pps
        set with  1000 full, ranged entries:             783810pps
      net,mac                                                       [ OK ]
        baseline (drop from netdev hook):              10190029pps
        baseline hash (non-ranged entries):             5172218pps
        baseline rbtree (match on first field only):    2946863pps
        set with  1000 full, ranged entries:            1279122pps
    
    v4:
     - fix build for 32-bit architectures: 64-bit division needs
       div_u64() (kbuild test robot <lkp@intel.com>)
    v3:
     - rework interface for field length specification,
       NFT_SET_SUBKEY disappears and information is stored in
       description
     - remove scratch area to store closing element of ranges,
       as elements now come with an actual attribute to specify
       the upper range limit (Pablo Neira Ayuso)
     - also remove pointer to 'start' element from mapping table,
       closing key is now accessible via extension data
     - use bytes right away instead of bits for field lengths,
       this way we can also double the inner loop of the lookup
       function to take care of upper and lower bits in a single
       iteration (minor performance improvement)
     - make it clearer that set operations are actually atomic
       API-wise, but we can't e.g. implement flush() as one-shot
       action
     - fix type for 'dup' in nft_pipapo_insert(), check for
       duplicates only in the next generation, and in general take
       care of differentiating generation mask cases depending on
       the operation (Pablo Neira Ayuso)
     - report C implementation matching rate in commit message, so
       that AVX2 implementation can be compared (Pablo Neira Ayuso)
    v2:
     - protect access to scratch maps in nft_pipapo_lookup() with
       local_bh_disable/enable() (Florian Westphal)
     - drop rcu_read_lock/unlock() from nft_pipapo_lookup(), it's
       already implied (Florian Westphal)
     - explain why partial allocation failures don't need handling
       in pipapo_realloc_scratch(), rename 'm' to clone and update
       related kerneldoc to make it clear we're not operating on
       the live copy (Florian Westphal)
     - add expicit check for priv->start_elem in
       nft_pipapo_insert() to avoid ending up in nft_pipapo_walk()
       with a NULL start element, and also zero it out in every
       operation that might make it invalid, so that insertion
       doesn't proceed with an invalid element (Florian Westphal)
    
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 2656155b4069..29e7e1021267 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -74,6 +74,7 @@ extern struct nft_set_type nft_set_hash_type;
 extern struct nft_set_type nft_set_hash_fast_type;
 extern struct nft_set_type nft_set_rbtree_type;
 extern struct nft_set_type nft_set_bitmap_type;
+extern struct nft_set_type nft_set_pipapo_type;
 
 struct nft_expr;
 struct nft_regs;

commit c593642c8be046915ca3a4a300243a68077cd207
Author: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
Date:   Mon Dec 9 10:31:43 2019 -0800

    treewide: Use sizeof_field() macro
    
    Replace all the occurrences of FIELD_SIZEOF() with sizeof_field() except
    at places where these are defined. Later patches will remove the unused
    definition of FIELD_SIZEOF().
    
    This patch is generated using following script:
    
    EXCLUDE_FILES="include/linux/stddef.h|include/linux/kernel.h"
    
    git grep -l -e "\bFIELD_SIZEOF\b" | while read file;
    do
    
            if [[ "$file" =~ $EXCLUDE_FILES ]]; then
                    continue
            fi
            sed -i  -e 's/\bFIELD_SIZEOF\b/sizeof_field/g' $file;
    done
    
    Signed-off-by: Pankaj Bharadiya <pankaj.laxminarayan.bharadiya@intel.com>
    Link: https://lore.kernel.org/r/20190924105839.110713-3-pankaj.laxminarayan.bharadiya@intel.com
    Co-developed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: David Miller <davem@davemloft.net> # for net

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 7281895fa6d9..2656155b4069 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -41,7 +41,7 @@ struct nft_immediate_expr {
  */
 static inline u32 nft_cmp_fast_mask(unsigned int len)
 {
-	return cpu_to_le32(~0U >> (FIELD_SIZEOF(struct nft_cmp_fast_expr,
+	return cpu_to_le32(~0U >> (sizeof_field(struct nft_cmp_fast_expr,
 						data) * BITS_PER_BYTE - len));
 }
 

commit 10870dd89e956d911d1a39474c0bf4a18c72cffc
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Jan 8 17:35:34 2019 +0100

    netfilter: nf_tables: add direct calls for all builtin expressions
    
    With CONFIG_RETPOLINE its faster to add an if (ptr == &foo_func)
    check and and use direct calls for all the built-in expressions.
    
    ~15% improvement in pathological cases.
    
    checkpatch doesn't like the X macro due to the embedded return statement,
    but the macro has a very limited scope so I don't think its a problem.
    
    I would like to avoid bugs of the form
      If (e->ops->eval == (unsigned long)nft_foo_eval)
             nft_bar_eval();
    
    and open-coded if ()/else if()/else cascade, thus the macro.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 2046d104f323..7281895fa6d9 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -80,6 +80,22 @@ struct nft_regs;
 struct nft_pktinfo;
 void nft_meta_get_eval(const struct nft_expr *expr,
 		       struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_cmp_eval(const struct nft_expr *expr,
+		  struct nft_regs *regs, const struct nft_pktinfo *pkt);
 void nft_lookup_eval(const struct nft_expr *expr,
 		     struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_payload_eval(const struct nft_expr *expr,
+		      struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_immediate_eval(const struct nft_expr *expr,
+			struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_bitwise_eval(const struct nft_expr *expr,
+		      struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_range_eval(const struct nft_expr *expr,
+		    struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_byteorder_eval(const struct nft_expr *expr,
+			struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_dynset_eval(const struct nft_expr *expr,
+		     struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_rt_get_eval(const struct nft_expr *expr,
+		     struct nft_regs *regs, const struct nft_pktinfo *pkt);
 #endif /* _NET_NF_TABLES_CORE_H */

commit fb961945457f5177072c968aa38fee910ab893b9
Author: Christian Göttsche <cgzones@googlemail.com>
Date:   Sun Sep 23 20:26:15 2018 +0200

    netfilter: nf_tables: add SECMARK support
    
    Add the ability to set the security context of packets within the nf_tables framework.
    Add a nft_object for holding security contexts in the kernel and manipulating packets on the wire.
    
    Convert the security context strings at rule addition time to security identifiers.
    This is the same behavior like in xt_SECMARK and offers better performance than computing it per packet.
    
    Set the maximum security context length to 256.
    
    Signed-off-by: Christian Göttsche <cgzones@googlemail.com>
    Acked-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 8da837d2aaf9..2046d104f323 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -16,6 +16,10 @@ extern struct nft_expr_type nft_meta_type;
 extern struct nft_expr_type nft_rt_type;
 extern struct nft_expr_type nft_exthdr_type;
 
+#ifdef CONFIG_NETWORK_SECMARK
+extern struct nft_object_type nft_secmark_obj_type;
+#endif
+
 int nf_tables_core_module_init(void);
 void nf_tables_core_module_exit(void);
 

commit 222440b4e832059c0ddf18d1e409f0552ab53a7d
Author: Florian Westphal <fw@strlen.de>
Date:   Wed Jul 4 12:48:04 2018 +0200

    netfilter: nf_tables: handle meta/lookup with direct call
    
    Currently nft uses inlined variants for common operations
    such as 'ip saddr 1.2.3.4' instead of an indirect call.
    
    Also handle meta get operations and lookups without indirect call,
    both are builtin.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index a05134507e7b..8da837d2aaf9 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -71,4 +71,11 @@ extern struct nft_set_type nft_set_hash_fast_type;
 extern struct nft_set_type nft_set_rbtree_type;
 extern struct nft_set_type nft_set_bitmap_type;
 
+struct nft_expr;
+struct nft_regs;
+struct nft_pktinfo;
+void nft_meta_get_eval(const struct nft_expr *expr,
+		       struct nft_regs *regs, const struct nft_pktinfo *pkt);
+void nft_lookup_eval(const struct nft_expr *expr,
+		     struct nft_regs *regs, const struct nft_pktinfo *pkt);
 #endif /* _NET_NF_TABLES_CORE_H */

commit e240cd0df48185a28c153f83a39ba3940e3e9b86
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Jul 6 19:06:43 2018 +0200

    netfilter: nf_tables: place all set backends in one single module
    
    This patch disallows rbtree with single elements, which is causing
    problems with the recent timeout support. Before this patch, you
    could opt out individual set representations per module, which is
    just adding extra complexity.
    
    Fixes: 8d8540c4f5e0("netfilter: nft_set_rbtree: add timeout support")
    Reported-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index e0c0c2558ec4..a05134507e7b 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -65,4 +65,10 @@ extern const struct nft_expr_ops nft_payload_fast_ops;
 extern struct static_key_false nft_counters_enabled;
 extern struct static_key_false nft_trace_enabled;
 
+extern struct nft_set_type nft_set_rhash_type;
+extern struct nft_set_type nft_set_hash_type;
+extern struct nft_set_type nft_set_hash_fast_type;
+extern struct nft_set_type nft_set_rbtree_type;
+extern struct nft_set_type nft_set_bitmap_type;
+
 #endif /* _NET_NF_TABLES_CORE_H */

commit a654de8fdc1815676ab750e70cab231fc814c29f
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed May 30 20:18:57 2018 +0200

    netfilter: nf_tables: fix chain dependency validation
    
    The following ruleset:
    
     add table ip filter
     add chain ip filter input { type filter hook input priority 4; }
     add chain ip filter ap
     add rule ip filter input jump ap
     add rule ip filter ap masquerade
    
    results in a panic, because the masquerade extension should be rejected
    from the filter chain. The existing validation is missing a chain
    dependency check when the rule is added to the non-base chain.
    
    This patch fixes the problem by walking down the rules from the
    basechains, searching for either immediate or lookup expressions, then
    jumping to non-base chains and again walking down the rules to perform
    the expression validation, so we make sure the full ruleset graph is
    validated. This is done only once from the commit phase, in case of
    problem, we abort the transaction and perform fine grain validation for
    error reporting. This patch requires 003087911af2 ("netfilter:
    nfnetlink: allow commit to fail") to achieve this behaviour.
    
    This patch also adds a cleanup callback to nfnl batch interface to reset
    the validate state from the exit path.
    
    As a result of this patch, nf_tables_check_loops() doesn't use
    ->validate to check for loops, instead it just checks for immediate
    expressions.
    
    Reported-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index cd6915b6c054..e0c0c2558ec4 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -2,6 +2,8 @@
 #ifndef _NET_NF_TABLES_CORE_H
 #define _NET_NF_TABLES_CORE_H
 
+#include <net/netfilter/nf_tables.h>
+
 extern struct nft_expr_type nft_imm_type;
 extern struct nft_expr_type nft_cmp_type;
 extern struct nft_expr_type nft_lookup_type;
@@ -23,6 +25,12 @@ struct nft_cmp_fast_expr {
 	u8			len;
 };
 
+struct nft_immediate_expr {
+	struct nft_data		data;
+	enum nft_registers	dreg:8;
+	u8			dlen;
+};
+
 /* Calculate the mask for the nft_cmp_fast expression. On big endian the
  * mask needs to include the *upper* bytes when interpreting that data as
  * something smaller than the full u32, therefore a cpu_to_le32 is done.

commit d0103158cf7c9190860dabd12b85ccad3c6e3455
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Apr 16 19:15:56 2018 +0200

    netfilter: nf_tables: merge exthdr expression into nft core
    
    before:
       text    data     bss     dec     hex filename
       5056     844       0    5900    170c net/netfilter/nft_exthdr.ko
     102456    2316     401  105173   19ad5 net/netfilter/nf_tables.ko
    
    after:
     106410    2392     401  109203   1aa93 net/netfilter/nf_tables.ko
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index d6a358ae3749..cd6915b6c054 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -12,6 +12,7 @@ extern struct nft_expr_type nft_dynset_type;
 extern struct nft_expr_type nft_range_type;
 extern struct nft_expr_type nft_meta_type;
 extern struct nft_expr_type nft_rt_type;
+extern struct nft_expr_type nft_exthdr_type;
 
 int nf_tables_core_module_init(void);
 void nf_tables_core_module_exit(void);

commit ae1bc6a9f398d5e0310387eb077a0d9ce1fb21f5
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Apr 16 19:15:55 2018 +0200

    netfilter: nf_tables: merge rt expression into nft core
    
    before:
       text    data     bss     dec     hex filename
       2657     844       0    3501     dad net/netfilter/nft_rt.ko
     100826    2240     401  103467   1942b net/netfilter/nf_tables.ko
    after:
       2657     844       0    3501     dad net/netfilter/nft_rt.ko
     102456    2316     401  105173   19ad5 net/netfilter/nf_tables.ko
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 3339cce8f585..d6a358ae3749 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -11,6 +11,7 @@ extern struct nft_expr_type nft_payload_type;
 extern struct nft_expr_type nft_dynset_type;
 extern struct nft_expr_type nft_range_type;
 extern struct nft_expr_type nft_meta_type;
+extern struct nft_expr_type nft_rt_type;
 
 int nf_tables_core_module_init(void);
 void nf_tables_core_module_exit(void);

commit 8a22543c8e7093104d7c22190746b9492bfbd897
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Apr 16 19:15:54 2018 +0200

    netfilter: nf_tables: make meta expression builtin
    
    size net/netfilter/nft_meta.ko
       text    data     bss     dec     hex filename
       5826     936       1    6763    1a6b net/netfilter/nft_meta.ko
      96407    2064     400   98871   18237 net/netfilter/nf_tables.ko
    
    after:
     100826    2240     401  103467   1942b net/netfilter/nf_tables.ko
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index ea5aab568be8..3339cce8f585 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -10,6 +10,7 @@ extern struct nft_expr_type nft_byteorder_type;
 extern struct nft_expr_type nft_payload_type;
 extern struct nft_expr_type nft_dynset_type;
 extern struct nft_expr_type nft_range_type;
+extern struct nft_expr_type nft_meta_type;
 
 int nf_tables_core_module_init(void);
 void nf_tables_core_module_exit(void);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 424684c33771..ea5aab568be8 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _NET_NF_TABLES_CORE_H
 #define _NET_NF_TABLES_CORE_H
 

commit 9f08ea848117ab521efcfd3e004d8e1a0edc640c
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue Jul 18 20:18:09 2017 +0200

    netfilter: nf_tables: keep chain counters away from hot path
    
    These chain counters are only used by the iptables-compat tool, that
    allow users to use the x_tables extensions from the existing nf_tables
    framework. This patch makes nf_tables by ~5% for the general usecase,
    ie. native nft users, where no chain counters are used at all.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 8f690effec37..424684c33771 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -49,6 +49,8 @@ struct nft_payload_set {
 };
 
 extern const struct nft_expr_ops nft_payload_fast_ops;
+
+extern struct static_key_false nft_counters_enabled;
 extern struct static_key_false nft_trace_enabled;
 
 #endif /* _NET_NF_TABLES_CORE_H */

commit 1814096980bbe546c4384b7b064126cbe7d40d30
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Thu Nov 24 12:04:55 2016 +0100

    netfilter: nft_payload: layer 4 checksum adjustment for pseudoheader fields
    
    This patch adds a new flag that signals the kernel to update layer 4
    checksum if the packet field belongs to the layer 4 pseudoheader. This
    implicitly provides stateless NAT 1:1 that is useful under very specific
    usecases.
    
    Since rules mangling layer 3 fields that are part of the pseudoheader
    may potentially convey any layer 4 packet, we have to deal with the
    layer 4 checksum adjustment using protocol specific code.
    
    This patch adds support for TCP, UDP and ICMPv6, since they include the
    pseudoheader in the layer 4 checksum calculation. ICMP doesn't, so we
    can skip it.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 862373d4ea9d..8f690effec37 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -45,6 +45,7 @@ struct nft_payload_set {
 	enum nft_registers	sreg:8;
 	u8			csum_type;
 	u8			csum_offset;
+	u8			csum_flags;
 };
 
 extern const struct nft_expr_ops nft_payload_fast_ops;

commit 4e24877e61e8507c0843e4bddbc6ecccbfd2e87d
Author: Liping Zhang <zlpnobody@gmail.com>
Date:   Sun Nov 6 21:15:51 2016 +0800

    netfilter: nf_tables: simplify the basic expressions' init routine
    
    Some basic expressions are built into nf_tables.ko, such as nft_cmp,
    nft_lookup, nft_range and so on. But these basic expressions' init
    routine is a little ugly, too many goto errX labels, and we forget
    to call nft_range_module_exit in the exit routine, although it is
    harmless.
    
    Acctually, the init and exit routines of these basic expressions
    are same, i.e. do nft_register_expr in the init routine and do
    nft_unregister_expr in the exit routine.
    
    So it's better to arrange them into an array and deal with them
    together.
    
    Signed-off-by: Liping Zhang <zlpnobody@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 00f4f6b1b1ba..862373d4ea9d 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -1,12 +1,18 @@
 #ifndef _NET_NF_TABLES_CORE_H
 #define _NET_NF_TABLES_CORE_H
 
+extern struct nft_expr_type nft_imm_type;
+extern struct nft_expr_type nft_cmp_type;
+extern struct nft_expr_type nft_lookup_type;
+extern struct nft_expr_type nft_bitwise_type;
+extern struct nft_expr_type nft_byteorder_type;
+extern struct nft_expr_type nft_payload_type;
+extern struct nft_expr_type nft_dynset_type;
+extern struct nft_expr_type nft_range_type;
+
 int nf_tables_core_module_init(void);
 void nf_tables_core_module_exit(void);
 
-int nft_immediate_module_init(void);
-void nft_immediate_module_exit(void);
-
 struct nft_cmp_fast_expr {
 	u32			data;
 	enum nft_registers	sreg:8;
@@ -25,24 +31,6 @@ static inline u32 nft_cmp_fast_mask(unsigned int len)
 
 extern const struct nft_expr_ops nft_cmp_fast_ops;
 
-int nft_cmp_module_init(void);
-void nft_cmp_module_exit(void);
-
-int nft_range_module_init(void);
-void nft_range_module_exit(void);
-
-int nft_lookup_module_init(void);
-void nft_lookup_module_exit(void);
-
-int nft_dynset_module_init(void);
-void nft_dynset_module_exit(void);
-
-int nft_bitwise_module_init(void);
-void nft_bitwise_module_exit(void);
-
-int nft_byteorder_module_init(void);
-void nft_byteorder_module_exit(void);
-
 struct nft_payload {
 	enum nft_payload_bases	base:8;
 	u8			offset;
@@ -62,7 +50,4 @@ struct nft_payload_set {
 extern const struct nft_expr_ops nft_payload_fast_ops;
 extern struct static_key_false nft_trace_enabled;
 
-int nft_payload_module_init(void);
-void nft_payload_module_exit(void);
-
 #endif /* _NET_NF_TABLES_CORE_H */

commit 0f3cd9b3697708c86a825ae3cedabf7be6fd3e72
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Sep 23 15:23:33 2016 +0200

    netfilter: nf_tables: add range expression
    
    Inverse ranges != [a,b] are not currently possible because rules are
    composites of && operations, and we need to express this:
    
            data < a || data > b
    
    This patch adds a new range expression. Positive ranges can be already
    through two cmp expressions:
    
            cmp(sreg, data, >=)
            cmp(sreg, data, <=)
    
    This new range expression provides an alternative way to express this.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index a9060dd99db7..00f4f6b1b1ba 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -28,6 +28,9 @@ extern const struct nft_expr_ops nft_cmp_fast_ops;
 int nft_cmp_module_init(void);
 void nft_cmp_module_exit(void);
 
+int nft_range_module_init(void);
+void nft_range_module_exit(void);
+
 int nft_lookup_module_init(void);
 void nft_lookup_module_exit(void);
 

commit e639f7ab079b5256660018511d87aa34b54f1a9d
Author: Florian Westphal <fw@strlen.de>
Date:   Sat Nov 28 21:53:05 2015 +0100

    netfilter: nf_tables: wrap tracing with a static key
    
    Only needed when meta nftrace rule(s) were added.
    The assumption is that no such rules are active, so the call to
    nft_trace_init is "never" needed.
    
    When nftrace rules are active, we always call the nft_trace_* functions,
    but will only send netlink messages when all of the following are true:
    
     - traceinfo structure was initialised
     - skb->nf_trace == 1
     - at least one subscriber to trace group.
    
    Adding an extra conditional
    (static_branch ... && skb->nf_trace)
            nft_trace_init( ..)
    
    Is possible but results in a larger nft_do_chain footprint.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 4ff5424909aa..a9060dd99db7 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -57,6 +57,7 @@ struct nft_payload_set {
 };
 
 extern const struct nft_expr_ops nft_payload_fast_ops;
+extern struct static_key_false nft_trace_enabled;
 
 int nft_payload_module_init(void);
 void nft_payload_module_exit(void);

commit 7ec3f7b47b8d9ad7ba425726f2c58f9ddce040df
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Nov 24 10:00:22 2015 +0000

    netfilter: nft_payload: add packet mangling support
    
    Add support for mangling packet payload. Checksum for the specified base
    header is updated automatically if requested, however no updates for any
    kind of pseudo headers are supported, meaning no stateless NAT is supported.
    
    For checksum updates different checksumming methods can be specified. The
    currently supported methods are NONE for no checksum updates, and INET for
    internet type checksums.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index c6f400cfaac8..4ff5424909aa 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -47,6 +47,15 @@ struct nft_payload {
 	enum nft_registers	dreg:8;
 };
 
+struct nft_payload_set {
+	enum nft_payload_bases	base:8;
+	u8			offset;
+	u8			len;
+	enum nft_registers	sreg:8;
+	u8			csum_type;
+	u8			csum_offset;
+};
+
 extern const struct nft_expr_ops nft_payload_fast_ops;
 
 int nft_payload_module_init(void);

commit 22fe54d5fefcfa98c58cc2f4607dd26d9648b3f5
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Apr 5 14:41:08 2015 +0200

    netfilter: nf_tables: add support for dynamic set updates
    
    Add a new "dynset" expression for dynamic set updates.
    
    A new set op ->update() is added which, for non existant elements,
    invokes an initialization callback and inserts the new element.
    For both new or existing elements the extenstion pointer is returned
    to the caller to optionally perform timer updates or other actions.
    
    Element removal is not supported so far, however that seems to be a
    rather exotic need and can be added later on.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index a75fc8e27cd6..c6f400cfaac8 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -31,6 +31,9 @@ void nft_cmp_module_exit(void);
 int nft_lookup_module_init(void);
 void nft_lookup_module_exit(void);
 
+int nft_dynset_module_init(void);
+void nft_dynset_module_exit(void);
+
 int nft_bitwise_module_init(void);
 void nft_bitwise_module_exit(void);
 

commit b855d416dc17061ebb271ea7ef1201d100531770
Author: Patrick McHardy <kaber@trash.net>
Date:   Sat Apr 12 13:17:57 2014 +0200

    netfilter: nf_tables: fix nft_cmp_fast failure on big endian for size < 4
    
    nft_cmp_fast is used for equality comparisions of size <= 4. For
    comparisions of size < 4 byte a mask is calculated that is applied to
    both the data from userspace (during initialization) and the register
    value (during runtime). Both values are stored using (in effect) memcpy
    to a memory area that is then interpreted as u32 by nft_cmp_fast.
    
    This works fine on little endian since smaller types have the same base
    address, however on big endian this is not true and the smaller types
    are interpreted as a big number with trailing zero bytes.
    
    The mask therefore must not include the lower bytes, but the higher bytes
    on big endian. Add a helper function that does a cpu_to_le32 to switch
    the bytes on big endian. Since we're dealing with a mask of just consequitive
    bits, this works out fine.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index cf2b7ae2b9d8..a75fc8e27cd6 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -13,6 +13,16 @@ struct nft_cmp_fast_expr {
 	u8			len;
 };
 
+/* Calculate the mask for the nft_cmp_fast expression. On big endian the
+ * mask needs to include the *upper* bytes when interpreting that data as
+ * something smaller than the full u32, therefore a cpu_to_le32 is done.
+ */
+static inline u32 nft_cmp_fast_mask(unsigned int len)
+{
+	return cpu_to_le32(~0U >> (FIELD_SIZEOF(struct nft_cmp_fast_expr,
+						data) * BITS_PER_BYTE - len));
+}
+
 extern const struct nft_expr_ops nft_cmp_fast_ops;
 
 int nft_cmp_module_init(void);

commit 5eccdfaabcf44f71702ba033d9c24821111749e1
Author: Joe Perches <joe@perches.com>
Date:   Sat Oct 19 22:05:31 2013 -0700

    nf_tables*.h: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index fe7b16206a4e..cf2b7ae2b9d8 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -1,11 +1,11 @@
 #ifndef _NET_NF_TABLES_CORE_H
 #define _NET_NF_TABLES_CORE_H
 
-extern int nf_tables_core_module_init(void);
-extern void nf_tables_core_module_exit(void);
+int nf_tables_core_module_init(void);
+void nf_tables_core_module_exit(void);
 
-extern int nft_immediate_module_init(void);
-extern void nft_immediate_module_exit(void);
+int nft_immediate_module_init(void);
+void nft_immediate_module_exit(void);
 
 struct nft_cmp_fast_expr {
 	u32			data;
@@ -15,17 +15,17 @@ struct nft_cmp_fast_expr {
 
 extern const struct nft_expr_ops nft_cmp_fast_ops;
 
-extern int nft_cmp_module_init(void);
-extern void nft_cmp_module_exit(void);
+int nft_cmp_module_init(void);
+void nft_cmp_module_exit(void);
 
-extern int nft_lookup_module_init(void);
-extern void nft_lookup_module_exit(void);
+int nft_lookup_module_init(void);
+void nft_lookup_module_exit(void);
 
-extern int nft_bitwise_module_init(void);
-extern void nft_bitwise_module_exit(void);
+int nft_bitwise_module_init(void);
+void nft_bitwise_module_exit(void);
 
-extern int nft_byteorder_module_init(void);
-extern void nft_byteorder_module_exit(void);
+int nft_byteorder_module_init(void);
+void nft_byteorder_module_exit(void);
 
 struct nft_payload {
 	enum nft_payload_bases	base:8;
@@ -36,7 +36,7 @@ struct nft_payload {
 
 extern const struct nft_expr_ops nft_payload_fast_ops;
 
-extern int nft_payload_module_init(void);
-extern void nft_payload_module_exit(void);
+int nft_payload_module_init(void);
+void nft_payload_module_exit(void);
 
 #endif /* _NET_NF_TABLES_CORE_H */

commit c29b72e02573b8fe5e6cae5d192a6a4772e7bbd6
Author: Patrick McHardy <kaber@trash.net>
Date:   Thu Oct 10 11:06:41 2013 +0200

    netfilter: nft_payload: add optimized payload implementation for small loads
    
    Add an optimized payload expression implementation for small (up to 4 bytes)
    aligned data loads from the linear packet area.
    
    This patch also includes original Patrick McHardy's entitled (nf_tables:
    inline nft_payload_fast_eval() into main evaluation loop).
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 3df6a9be3bdd..fe7b16206a4e 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -27,6 +27,15 @@ extern void nft_bitwise_module_exit(void);
 extern int nft_byteorder_module_init(void);
 extern void nft_byteorder_module_exit(void);
 
+struct nft_payload {
+	enum nft_payload_bases	base:8;
+	u8			offset;
+	u8			len;
+	enum nft_registers	dreg:8;
+};
+
+extern const struct nft_expr_ops nft_payload_fast_ops;
+
 extern int nft_payload_module_init(void);
 extern void nft_payload_module_exit(void);
 

commit cb7dbfd0390c9e244339f3270fe8649568241812
Author: Patrick McHardy <kaber@trash.net>
Date:   Thu Oct 10 23:35:40 2013 +0200

    netfilter: nf_tables: add optimized data comparison for small values
    
    Add an optimized version of nft_data_cmp() that only handles values of to
    4 bytes length.
    
    This patch includes original Patrick McHardy's patch entitled (nf_tables:
    inline nft_cmp_fast_eval() into main evaluation loop).
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
index 283396c916e0..3df6a9be3bdd 100644
--- a/include/net/netfilter/nf_tables_core.h
+++ b/include/net/netfilter/nf_tables_core.h
@@ -7,6 +7,14 @@ extern void nf_tables_core_module_exit(void);
 extern int nft_immediate_module_init(void);
 extern void nft_immediate_module_exit(void);
 
+struct nft_cmp_fast_expr {
+	u32			data;
+	enum nft_registers	sreg:8;
+	u8			len;
+};
+
+extern const struct nft_expr_ops nft_cmp_fast_ops;
+
 extern int nft_cmp_module_init(void);
 extern void nft_cmp_module_exit(void);
 

commit 96518518cc417bb0a8c80b9fb736202e28acdf96
Author: Patrick McHardy <kaber@trash.net>
Date:   Mon Oct 14 11:00:02 2013 +0200

    netfilter: add nftables
    
    This patch adds nftables which is the intended successor of iptables.
    This packet filtering framework reuses the existing netfilter hooks,
    the connection tracking system, the NAT subsystem, the transparent
    proxying engine, the logging infrastructure and the userspace packet
    queueing facilities.
    
    In a nutshell, nftables provides a pseudo-state machine with 4 general
    purpose registers of 128 bits and 1 specific purpose register to store
    verdicts. This pseudo-machine comes with an extensible instruction set,
    a.k.a. "expressions" in the nftables jargon. The expressions included
    in this patch provide the basic functionality, they are:
    
    * bitwise: to perform bitwise operations.
    * byteorder: to change from host/network endianess.
    * cmp: to compare data with the content of the registers.
    * counter: to enable counters on rules.
    * ct: to store conntrack keys into register.
    * exthdr: to match IPv6 extension headers.
    * immediate: to load data into registers.
    * limit: to limit matching based on packet rate.
    * log: to log packets.
    * meta: to match metainformation that usually comes with the skbuff.
    * nat: to perform Network Address Translation.
    * payload: to fetch data from the packet payload and store it into
      registers.
    * reject (IPv4 only): to explicitly close connection, eg. TCP RST.
    
    Using this instruction-set, the userspace utility 'nft' can transform
    the rules expressed in human-readable text representation (using a
    new syntax, inspired by tcpdump) to nftables bytecode.
    
    nftables also inherits the table, chain and rule objects from
    iptables, but in a more configurable way, and it also includes the
    original datatype-agnostic set infrastructure with mapping support.
    This set infrastructure is enhanced in the follow up patch (netfilter:
    nf_tables: add netlink set API).
    
    This patch includes the following components:
    
    * the netlink API: net/netfilter/nf_tables_api.c and
      include/uapi/netfilter/nf_tables.h
    * the packet filter core: net/netfilter/nf_tables_core.c
    * the expressions (described above): net/netfilter/nft_*.c
    * the filter tables: arp, IPv4, IPv6 and bridge:
      net/ipv4/netfilter/nf_tables_ipv4.c
      net/ipv6/netfilter/nf_tables_ipv6.c
      net/ipv4/netfilter/nf_tables_arp.c
      net/bridge/netfilter/nf_tables_bridge.c
    * the NAT table (IPv4 only):
      net/ipv4/netfilter/nf_table_nat_ipv4.c
    * the route table (similar to mangle):
      net/ipv4/netfilter/nf_table_route_ipv4.c
      net/ipv6/netfilter/nf_table_route_ipv6.c
    * internal definitions under:
      include/net/netfilter/nf_tables.h
      include/net/netfilter/nf_tables_core.h
    * It also includes an skeleton expression:
      net/netfilter/nft_expr_template.c
      and the preliminary implementation of the meta target
      net/netfilter/nft_meta_target.c
    
    It also includes a change in struct nf_hook_ops to add a new
    pointer to store private data to the hook, that is used to store
    the rule list per chain.
    
    This patch is based on the patch from Patrick McHardy, plus merged
    accumulated cleanups, fixes and small enhancements to the nftables
    code that has been done since 2009, which are:
    
    From Patrick McHardy:
    * nf_tables: adjust netlink handler function signatures
    * nf_tables: only retry table lookup after successful table module load
    * nf_tables: fix event notification echo and avoid unnecessary messages
    * nft_ct: add l3proto support
    * nf_tables: pass expression context to nft_validate_data_load()
    * nf_tables: remove redundant definition
    * nft_ct: fix maxattr initialization
    * nf_tables: fix invalid event type in nf_tables_getrule()
    * nf_tables: simplify nft_data_init() usage
    * nf_tables: build in more core modules
    * nf_tables: fix double lookup expression unregistation
    * nf_tables: move expression initialization to nf_tables_core.c
    * nf_tables: build in payload module
    * nf_tables: use NFPROTO constants
    * nf_tables: rename pid variables to portid
    * nf_tables: save 48 bits per rule
    * nf_tables: introduce chain rename
    * nf_tables: check for duplicate names on chain rename
    * nf_tables: remove ability to specify handles for new rules
    * nf_tables: return error for rule change request
    * nf_tables: return error for NLM_F_REPLACE without rule handle
    * nf_tables: include NLM_F_APPEND/NLM_F_REPLACE flags in rule notification
    * nf_tables: fix NLM_F_MULTI usage in netlink notifications
    * nf_tables: include NLM_F_APPEND in rule dumps
    
    From Pablo Neira Ayuso:
    * nf_tables: fix stack overflow in nf_tables_newrule
    * nf_tables: nft_ct: fix compilation warning
    * nf_tables: nft_ct: fix crash with invalid packets
    * nft_log: group and qthreshold are 2^16
    * nf_tables: nft_meta: fix socket uid,gid handling
    * nft_counter: allow to restore counters
    * nf_tables: fix module autoload
    * nf_tables: allow to remove all rules placed in one chain
    * nf_tables: use 64-bits rule handle instead of 16-bits
    * nf_tables: fix chain after rule deletion
    * nf_tables: improve deletion performance
    * nf_tables: add missing code in route chain type
    * nf_tables: rise maximum number of expressions from 12 to 128
    * nf_tables: don't delete table if in use
    * nf_tables: fix basechain release
    
    From Tomasz Bursztyka:
    * nf_tables: Add support for changing users chain's name
    * nf_tables: Change chain's name to be fixed sized
    * nf_tables: Add support for replacing a rule by another one
    * nf_tables: Update uapi nftables netlink header documentation
    
    From Florian Westphal:
    * nft_log: group is u16, snaplen u32
    
    From Phil Oester:
    * nf_tables: operational limit match
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tables_core.h b/include/net/netfilter/nf_tables_core.h
new file mode 100644
index 000000000000..283396c916e0
--- /dev/null
+++ b/include/net/netfilter/nf_tables_core.h
@@ -0,0 +1,25 @@
+#ifndef _NET_NF_TABLES_CORE_H
+#define _NET_NF_TABLES_CORE_H
+
+extern int nf_tables_core_module_init(void);
+extern void nf_tables_core_module_exit(void);
+
+extern int nft_immediate_module_init(void);
+extern void nft_immediate_module_exit(void);
+
+extern int nft_cmp_module_init(void);
+extern void nft_cmp_module_exit(void);
+
+extern int nft_lookup_module_init(void);
+extern void nft_lookup_module_exit(void);
+
+extern int nft_bitwise_module_init(void);
+extern void nft_bitwise_module_exit(void);
+
+extern int nft_byteorder_module_init(void);
+extern void nft_byteorder_module_exit(void);
+
+extern int nft_payload_module_init(void);
+extern void nft_payload_module_exit(void);
+
+#endif /* _NET_NF_TABLES_CORE_H */
