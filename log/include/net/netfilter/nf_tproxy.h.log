commit 99d20a461c43556242a4e1b65e309f1c1fadea4f
Merge: c4c5551df136 24c458c485c8
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 20 22:28:28 2018 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/pablo/nf-next
    
    Pablo Neira Ayuso says:
    
    ====================
    Netfilter/IPVS updates for net-next
    
    The following patchset contains Netfilter/IPVS updates for your net-next
    tree:
    
    1) No need to set ttl from reject action for the bridge family, from
       Taehee Yoo.
    
    2) Use a fixed timeout for flow that are passed up from the flowtable
       to conntrack, from Florian Westphal.
    
    3) More preparation patches for tproxy support for nf_tables, from Mate
       Eckl.
    
    4) Remove unnecessary indirection in core IPv6 checksum function, from
       Florian Westphal.
    
    5) Use nf_ct_get_tuplepr() from openvswitch, instead of opencoding it.
       From Florian Westphal.
    
    6) socket match now selects socket infrastructure, instead of depending
       on it. From Mate Eckl.
    
    7) Patch series to simplify conntrack tuple building/parsing from packet
       path and ctnetlink, from Florian Westphal.
    
    8) Fetch timeout policy from protocol helpers, instead of doing it from
       core, from Florian Westphal.
    
    9) Merge IPv4 and IPv6 protocol trackers into conntrack core, from
       Florian Westphal.
    
    10) Depend on CONFIG_NF_TABLES_IPV6 and CONFIG_IP6_NF_IPTABLES
        respectively, instead of IPV6. Patch from Mate Eckl.
    
    11) Add specific function for garbage collection in conncount,
        from Yi-Hung Wei.
    
    12) Catch number of elements in the connlimit list, from Yi-Hung Wei.
    
    13) Move locking to nf_conncount, from Yi-Hung Wei.
    
    14) Series of patches to add lockless tree traversal in nf_conncount,
        from Yi-Hung Wei.
    
    15) Resolve clash in matching conntracks when race happens, from
        Martynas Pumputis.
    
    16) If connection entry times out, remove template entry from the
        ip_vs_conn_tab table to improve behaviour under flood, from
        Julian Anastasov.
    
    17) Remove useless parameter from nf_ct_helper_ext_add(), from Gao feng.
    
    18) Call abort from 2-phase commit protocol before requesting modules,
        make sure this is done under the mutex, from Florian Westphal.
    
    19) Grab module reference when starting transaction, also from Florian.
    
    20) Dynamically allocate expression info array for pre-parsing, from
        Florian.
    
    21) Add per netns mutex for nf_tables, from Florian Westphal.
    
    22) A couple of patches to simplify and refactor nf_osf code to prepare
        for nft_osf support.
    
    23) Break evaluation on missing socket, from Mate Eckl.
    
    24) Allow to match socket mark from nft_socket, from Mate Eckl.
    
    25) Remove dependency on nf_defrag_ipv6, now that IPv6 tracker is
        built-in into nf_conntrack. From Florian Westphal.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f286586df68e7733a8e651098401f139dc2e17f4
Author: Máté Eckl <ecklm94@gmail.com>
Date:   Mon Jun 18 15:12:52 2018 +0200

    netfilter: nft_tproxy: Move nf_tproxy_assign_sock() to nf_tproxy.h
    
    This function is also necessary to implement nft tproxy support
    
    Fixes: 45ca4e0cf273 ("netfilter: Libify xt_TPROXY")
    Signed-off-by: Máté Eckl <ecklm94@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tproxy.h b/include/net/netfilter/nf_tproxy.h
index 9754a50ecde9..d5a80888cbe4 100644
--- a/include/net/netfilter/nf_tproxy.h
+++ b/include/net/netfilter/nf_tproxy.h
@@ -17,6 +17,14 @@ static inline bool nf_tproxy_sk_is_transparent(struct sock *sk)
 	return false;
 }
 
+/* assign a socket to the skb -- consumes sk */
+static inline void nf_tproxy_assign_sock(struct sk_buff *skb, struct sock *sk)
+{
+	skb_orphan(skb);
+	skb->sk = sk;
+	skb->destructor = sock_edemux;
+}
+
 __be32 nf_tproxy_laddr4(struct sk_buff *skb, __be32 user_laddr, __be32 daddr);
 
 /**

commit 5711b4e89319c2912f20b2a4f371c1525fc9551d
Author: Máté Eckl <ecklm94@gmail.com>
Date:   Thu Jul 5 12:01:53 2018 +0200

    netfilter: nf_tproxy: fix possible non-linear access to transport header
    
    This patch fixes a silent out-of-bound read possibility that was present
    because of the misuse of this function.
    
    Mostly it was called with a struct udphdr *hp which had only the udphdr
    part linearized by the skb_header_pointer, however
    nf_tproxy_get_sock_v{4,6} uses it as a tcphdr pointer, so some reads for
    tcp specific attributes may be invalid.
    
    Fixes: a583636a83ea ("inet: refactor inet[6]_lookup functions to take skb")
    Signed-off-by: Máté Eckl <ecklm94@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tproxy.h b/include/net/netfilter/nf_tproxy.h
index 9754a50ecde9..4cc64c8446eb 100644
--- a/include/net/netfilter/nf_tproxy.h
+++ b/include/net/netfilter/nf_tproxy.h
@@ -64,7 +64,7 @@ nf_tproxy_handle_time_wait4(struct net *net, struct sk_buff *skb,
  * belonging to established connections going through that one.
  */
 struct sock *
-nf_tproxy_get_sock_v4(struct net *net, struct sk_buff *skb, void *hp,
+nf_tproxy_get_sock_v4(struct net *net, struct sk_buff *skb,
 		      const u8 protocol,
 		      const __be32 saddr, const __be32 daddr,
 		      const __be16 sport, const __be16 dport,
@@ -103,7 +103,7 @@ nf_tproxy_handle_time_wait6(struct sk_buff *skb, int tproto, int thoff,
 			    struct sock *sk);
 
 struct sock *
-nf_tproxy_get_sock_v6(struct net *net, struct sk_buff *skb, int thoff, void *hp,
+nf_tproxy_get_sock_v6(struct net *net, struct sk_buff *skb, int thoff,
 		      const u8 protocol,
 		      const struct in6_addr *saddr, const struct in6_addr *daddr,
 		      const __be16 sport, const __be16 dport,

commit 45ca4e0cf2734f8cc14b43e47c23618215abf1b8
Author: Máté Eckl <ecklm94@gmail.com>
Date:   Fri Jun 1 20:44:56 2018 +0200

    netfilter: Libify xt_TPROXY
    
    The extracted functions will likely be usefull to implement tproxy
    support in nf_tables.
    
    Extrancted functions:
            - nf_tproxy_sk_is_transparent
            - nf_tproxy_laddr4
            - nf_tproxy_handle_time_wait4
            - nf_tproxy_get_sock_v4
            - nf_tproxy_laddr6
            - nf_tproxy_handle_time_wait6
            - nf_tproxy_get_sock_v6
    
    (nf_)tproxy_handle_time_wait6 also needed some refactor as its current
    implementation was xtables-specific.
    
    Signed-off-by: Máté Eckl <ecklm94@gmail.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/netfilter/nf_tproxy.h b/include/net/netfilter/nf_tproxy.h
new file mode 100644
index 000000000000..9754a50ecde9
--- /dev/null
+++ b/include/net/netfilter/nf_tproxy.h
@@ -0,0 +1,113 @@
+#ifndef _NF_TPROXY_H_
+#define _NF_TPROXY_H_
+
+#include <net/tcp.h>
+
+enum nf_tproxy_lookup_t {
+	 NF_TPROXY_LOOKUP_LISTENER,
+	 NF_TPROXY_LOOKUP_ESTABLISHED,
+};
+
+static inline bool nf_tproxy_sk_is_transparent(struct sock *sk)
+{
+	if (inet_sk_transparent(sk))
+		return true;
+
+	sock_gen_put(sk);
+	return false;
+}
+
+__be32 nf_tproxy_laddr4(struct sk_buff *skb, __be32 user_laddr, __be32 daddr);
+
+/**
+ * nf_tproxy_handle_time_wait4 - handle IPv4 TCP TIME_WAIT reopen redirections
+ * @skb:	The skb being processed.
+ * @laddr:	IPv4 address to redirect to or zero.
+ * @lport:	TCP port to redirect to or zero.
+ * @sk:		The TIME_WAIT TCP socket found by the lookup.
+ *
+ * We have to handle SYN packets arriving to TIME_WAIT sockets
+ * differently: instead of reopening the connection we should rather
+ * redirect the new connection to the proxy if there's a listener
+ * socket present.
+ *
+ * nf_tproxy_handle_time_wait4() consumes the socket reference passed in.
+ *
+ * Returns the listener socket if there's one, the TIME_WAIT socket if
+ * no such listener is found, or NULL if the TCP header is incomplete.
+ */
+struct sock *
+nf_tproxy_handle_time_wait4(struct net *net, struct sk_buff *skb,
+			    __be32 laddr, __be16 lport, struct sock *sk);
+
+/*
+ * This is used when the user wants to intercept a connection matching
+ * an explicit iptables rule. In this case the sockets are assumed
+ * matching in preference order:
+ *
+ *   - match: if there's a fully established connection matching the
+ *     _packet_ tuple, it is returned, assuming the redirection
+ *     already took place and we process a packet belonging to an
+ *     established connection
+ *
+ *   - match: if there's a listening socket matching the redirection
+ *     (e.g. on-port & on-ip of the connection), it is returned,
+ *     regardless if it was bound to 0.0.0.0 or an explicit
+ *     address. The reasoning is that if there's an explicit rule, it
+ *     does not really matter if the listener is bound to an interface
+ *     or to 0. The user already stated that he wants redirection
+ *     (since he added the rule).
+ *
+ * Please note that there's an overlap between what a TPROXY target
+ * and a socket match will match. Normally if you have both rules the
+ * "socket" match will be the first one, effectively all packets
+ * belonging to established connections going through that one.
+ */
+struct sock *
+nf_tproxy_get_sock_v4(struct net *net, struct sk_buff *skb, void *hp,
+		      const u8 protocol,
+		      const __be32 saddr, const __be32 daddr,
+		      const __be16 sport, const __be16 dport,
+		      const struct net_device *in,
+		      const enum nf_tproxy_lookup_t lookup_type);
+
+const struct in6_addr *
+nf_tproxy_laddr6(struct sk_buff *skb, const struct in6_addr *user_laddr,
+		 const struct in6_addr *daddr);
+
+/**
+ * nf_tproxy_handle_time_wait6 - handle IPv6 TCP TIME_WAIT reopen redirections
+ * @skb:	The skb being processed.
+ * @tproto:	Transport protocol.
+ * @thoff:	Transport protocol header offset.
+ * @net:	Network namespace.
+ * @laddr:	IPv6 address to redirect to.
+ * @lport:	TCP port to redirect to or zero.
+ * @sk:		The TIME_WAIT TCP socket found by the lookup.
+ *
+ * We have to handle SYN packets arriving to TIME_WAIT sockets
+ * differently: instead of reopening the connection we should rather
+ * redirect the new connection to the proxy if there's a listener
+ * socket present.
+ *
+ * nf_tproxy_handle_time_wait6() consumes the socket reference passed in.
+ *
+ * Returns the listener socket if there's one, the TIME_WAIT socket if
+ * no such listener is found, or NULL if the TCP header is incomplete.
+ */
+struct sock *
+nf_tproxy_handle_time_wait6(struct sk_buff *skb, int tproto, int thoff,
+			    struct net *net,
+			    const struct in6_addr *laddr,
+			    const __be16 lport,
+			    struct sock *sk);
+
+struct sock *
+nf_tproxy_get_sock_v6(struct net *net, struct sk_buff *skb, int thoff, void *hp,
+		      const u8 protocol,
+		      const struct in6_addr *saddr, const struct in6_addr *daddr,
+		      const __be16 sport, const __be16 dport,
+		      const struct net_device *in,
+		      const enum nf_tproxy_lookup_t lookup_type);
+
+#endif /* _NF_TPROXY_H_ */
