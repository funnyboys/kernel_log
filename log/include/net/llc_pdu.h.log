commit 7e0309631ecf0cd16edba72ff74747fa1b96ead3
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Jan 1 23:04:25 2014 +0100

    net: llc: fix order of evaluation in llc_conn_ac_inc_vr_by_1
    
    Function llc_conn_ac_inc_vr_by_1() evaluates via macro
    PDU_GET_NEXT_Vr() into ...
    
      llc_sk(sk)->vR = ++llc_sk(sk)->vR & 0xffffffffffffff7f
    
    ... but the order in which the side effects take place is
    undefined because there is no intervening sequence point.
    
    As llc_sk(sk)->vR is written in llc_sk(sk)->vR (assignment
    left-hand side) and written in ++llc_sk(sk)->vR & 0xffffffffffffff7f
    this might possibly yield undefined behavior.
    
    The final value of llc_sk(sk)->vR is ambiguous, because,
    depending on the order of expression evaluation, the
    increment may occur before, after, or interleaved with
    the assignment. In C, evaluating such an expression yields
    undefined behavior.
    
    Since we're doing the increment via PDU_GET_NEXT_Vr() macro
    and the only place it is being used is from
    llc_conn_ac_inc_vr_by_1(), in order to increment vR by 1
    with a follow-up optimized modulo, rewrite the expression
    into ((vR + 1) & CONST) in order to fix this.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 31e2de7d57c5..c0f0a13ed818 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -142,7 +142,7 @@
 #define LLC_S_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_S_PF_BIT_MASK) ? 1 : 0)
 
 #define PDU_SUPV_GET_Nr(pdu)   ((pdu->ctrl_2 & 0xFE) >> 1)
-#define PDU_GET_NEXT_Vr(sn)    (++sn & ~LLC_2_SEQ_NBR_MODULO)
+#define PDU_GET_NEXT_Vr(sn)    (((sn) + 1) & ~LLC_2_SEQ_NBR_MODULO)
 
 /* FRMR information field macros */
 

commit bf3c710f71a6144bd4d3bb9efb91099863debfb8
Author: Joe Perches <joe@perches.com>
Date:   Sat Sep 21 10:22:45 2013 -0700

    llc*.h: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 5a93d13ac95c..31e2de7d57c5 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -410,21 +410,20 @@ struct llc_frmr_info {
 	u8  ind_bits;		/* indicator bits set with macro */
 } __packed;
 
-extern void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 type);
-extern void llc_pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value);
-extern void llc_pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit);
-extern void llc_pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit);
-extern void llc_pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr);
-extern void llc_pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
-extern void llc_pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
-extern void llc_pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
-extern void llc_pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit);
-extern void llc_pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit);
-extern void llc_pdu_init_as_frmr_rsp(struct sk_buff *skb,
-				     struct llc_pdu_sn *prev_pdu,
-				     u8 f_bit, u8 vs, u8 vr, u8 vzyxw);
-extern void llc_pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
-extern void llc_pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
-extern void llc_pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
-extern void llc_pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit);
+void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 type);
+void llc_pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value);
+void llc_pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit);
+void llc_pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit);
+void llc_pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr);
+void llc_pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+void llc_pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+void llc_pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+void llc_pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit);
+void llc_pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit);
+void llc_pdu_init_as_frmr_rsp(struct sk_buff *skb, struct llc_pdu_sn *prev_pdu,
+			      u8 f_bit, u8 vs, u8 vr, u8 vzyxw);
+void llc_pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+void llc_pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+void llc_pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+void llc_pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit);
 #endif /* LLC_PDU_H */

commit 211ed865108e24697b44bee5daac502ee6bdd4a4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu May 10 17:14:35 2012 -0400

    net: delete all instances of special processing for token ring
    
    We are going to delete the Token ring support.  This removes any
    special processing in the core networking for token ring, (aside
    from net/tr.c itself), leaving the drivers and remaining tokenring
    support present but inert.
    
    The mass removal of the drivers and net/tr.c will be in a separate
    commit, so that the history of these files that we still care
    about won't have the giant deletion tied into their history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index f57e7d46a453..5a93d13ac95c 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -13,7 +13,6 @@
  */
 
 #include <linux/if_ether.h>
-#include <linux/if_tr.h>
 
 /* Lengths of frame formats */
 #define LLC_PDU_LEN_I	4       /* header and 2 control bytes */
@@ -253,10 +252,6 @@ static inline void llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa)
 {
 	if (skb->protocol == htons(ETH_P_802_2))
 		memcpy(sa, eth_hdr(skb)->h_source, ETH_ALEN);
-	else if (skb->protocol == htons(ETH_P_TR_802_2)) {
-		memcpy(sa, tr_hdr(skb)->saddr, ETH_ALEN);
-		*sa &= 0x7F;
-	}
 }
 
 /**
@@ -270,8 +265,6 @@ static inline void llc_pdu_decode_da(struct sk_buff *skb, u8 *da)
 {
 	if (skb->protocol == htons(ETH_P_802_2))
 		memcpy(da, eth_hdr(skb)->h_dest, ETH_ALEN);
-	else if (skb->protocol == htons(ETH_P_TR_802_2))
-		memcpy(da, tr_hdr(skb)->daddr, ETH_ALEN);
 }
 
 /**

commit a10e14667635dde504ed9e7ee851494c2cf2ae8e
Author: Vitalii Demianets <vitas@nppfactor.kiev.ua>
Date:   Thu May 12 23:04:29 2011 +0000

    bonding,llc: Fix structure sizeof incompatibility for some PDUs
    
    With some combinations of arch/compiler (e.g. arm-linux-gcc) the sizeof
    operator on structure returns value greater than expected. In cases when the
    structure is used for mapping PDU fields it may lead to unexpected results
    (such as holes and alignment problems in skb data). __packed prevents this
    undesired behavior.
    
    Signed-off-by: Vitalii Demianets <vitas@nppfactor.kiev.ua>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 75b8e2968c9b..f57e7d46a453 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -199,7 +199,7 @@ struct llc_pdu_sn {
 	u8 ssap;
 	u8 ctrl_1;
 	u8 ctrl_2;
-};
+} __packed;
 
 static inline struct llc_pdu_sn *llc_pdu_sn_hdr(struct sk_buff *skb)
 {
@@ -211,7 +211,7 @@ struct llc_pdu_un {
 	u8 dsap;
 	u8 ssap;
 	u8 ctrl_1;
-};
+} __packed;
 
 static inline struct llc_pdu_un *llc_pdu_un_hdr(struct sk_buff *skb)
 {
@@ -359,7 +359,7 @@ struct llc_xid_info {
 	u8 fmt_id;	/* always 0x81 for LLC */
 	u8 type;	/* different if NULL/non-NULL LSAP */
 	u8 rw;		/* sender receive window */
-};
+} __packed;
 
 /**
  *	llc_pdu_init_as_xid_cmd - sets bytes 3, 4 & 5 of LLC header as XID
@@ -415,7 +415,7 @@ struct llc_frmr_info {
 	u8  curr_ssv;		/* current send state variable val */
 	u8  curr_rsv;		/* current receive state variable */
 	u8  ind_bits;		/* indicator bits set with macro */
-};
+} __packed;
 
 extern void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 type);
 extern void llc_pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value);

commit f83f1768f833cb45bc93429fdc552252a4f55ac3
Author: Joonwoo Park <joonwpark81@gmail.com>
Date:   Mon Mar 31 21:02:47 2008 -0700

    [LLC]: skb allocation size for responses
    
    Allocate the skb for llc responses with the received packet size by
    using the size adjustable llc_frame_alloc.
    Don't allocate useless extra payload.
    Cleanup magic numbers.
    
    So, this fixes oops.
    Reported by Jim Westfall:
    kernel: skb_over_panic: text:c0541fc7 len:1000 put:997 head:c166ac00 data:c166ac2f tail:0xc166b017 end:0xc166ac80 dev:eth0
    kernel: ------------[ cut here ]------------
    kernel: kernel BUG at net/core/skbuff.c:95!
    
    Signed-off-by: Joonwoo Park <joonwpark81@gmail.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 4a8f58b17e43..75b8e2968c9b 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -381,7 +381,7 @@ static inline void llc_pdu_init_as_xid_cmd(struct sk_buff *skb,
 	xid_info->fmt_id = LLC_XID_FMT_ID;	/* 0x81 */
 	xid_info->type	 = svcs_supported;
 	xid_info->rw	 = rx_window << 1;	/* size of receive window */
-	skb_put(skb, 3);
+	skb_put(skb, sizeof(struct llc_xid_info));
 }
 
 /**
@@ -406,7 +406,7 @@ static inline void llc_pdu_init_as_xid_rsp(struct sk_buff *skb,
 	xid_info->fmt_id = LLC_XID_FMT_ID;
 	xid_info->type	 = svcs_supported;
 	xid_info->rw	 = rx_window << 1;
-	skb_put(skb, 3);
+	skb_put(skb, sizeof(struct llc_xid_info));
 }
 
 /* LLC Type 2 FRMR response information field format */

commit d56f90a7c96da5187f0cdf07ee7434fe6aa78bbc
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 10 20:50:43 2007 -0700

    [SK_BUFF]: Introduce skb_network_header()
    
    For the places where we need a pointer to the network header, it is still legal
    to touch skb->nh.raw directly if just adding to, subtracting from or setting it
    to another layer header.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 778f75a40b4d..4a8f58b17e43 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -203,7 +203,7 @@ struct llc_pdu_sn {
 
 static inline struct llc_pdu_sn *llc_pdu_sn_hdr(struct sk_buff *skb)
 {
-	return (struct llc_pdu_sn *)skb->nh.raw;
+	return (struct llc_pdu_sn *)skb_network_header(skb);
 }
 
 /* Un-numbered PDU format (3 bytes in length) */
@@ -215,7 +215,7 @@ struct llc_pdu_un {
 
 static inline struct llc_pdu_un *llc_pdu_un_hdr(struct sk_buff *skb)
 {
-	return (struct llc_pdu_un *)skb->nh.raw;
+	return (struct llc_pdu_un *)skb_network_header(skb);
 }
 
 /**

commit c1d2bbe1cd6c7bbdc6d532cefebb66c7efb789ce
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Apr 10 20:45:18 2007 -0700

    [SK_BUFF]: Introduce skb_reset_network_header(skb)
    
    For the common, open coded 'skb->nh.raw = skb->data' operation, so that we can
    later turn skb->nh.raw into a offset, reducing the size of struct sk_buff in
    64bit land while possibly keeping it as a pointer on 32bit.
    
    This one touches just the most simple case, next will handle the slightly more
    "complex" cases.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 4e620992c806..778f75a40b4d 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -235,7 +235,7 @@ static inline void llc_pdu_header_init(struct sk_buff *skb, u8 type,
 	struct llc_pdu_un *pdu;
 
 	skb_push(skb, hlen);
-	skb->nh.raw = skb->data;
+	skb_reset_network_header(skb);
 	pdu = llc_pdu_un_hdr(skb);
 	pdu->dsap = dsap;
 	pdu->ssap = ssap;

commit 37e6636669b0b996681586facee8034f7f674f6a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sat Mar 10 15:34:36 2007 -0300

    [LLC]: Kill llc_set_pdu_hdr
    
    We'll have skb_reset_network_header soon.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index aa33a477c3fb..4e620992c806 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -218,11 +218,6 @@ static inline struct llc_pdu_un *llc_pdu_un_hdr(struct sk_buff *skb)
 	return (struct llc_pdu_un *)skb->nh.raw;
 }
 
-static inline void *llc_set_pdu_hdr(struct sk_buff *skb, void *ptr)
-{
-	return skb->nh.raw = ptr;
-}
-
 /**
  *	llc_pdu_header_init - initializes pdu header
  *	@skb: input skb that header must be set into it.
@@ -237,7 +232,11 @@ static inline void llc_pdu_header_init(struct sk_buff *skb, u8 type,
 				       u8 ssap, u8 dsap, u8 cr)
 {
 	const int hlen = type == LLC_PDU_TYPE_U ? 3 : 4;
-	struct llc_pdu_un *pdu = llc_set_pdu_hdr(skb, skb_push(skb, hlen));
+	struct llc_pdu_un *pdu;
+
+	skb_push(skb, hlen);
+	skb->nh.raw = skb->data;
+	pdu = llc_pdu_un_hdr(skb);
 	pdu->dsap = dsap;
 	pdu->ssap = ssap;
 	pdu->ssap |= cr;

commit 3fbd418acc264e7069483d04165633ed3bfad80c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 8 00:26:05 2006 -0800

    [LLC]: anotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index 8f6306581fa7..aa33a477c3fb 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -252,9 +252,9 @@ static inline void llc_pdu_header_init(struct sk_buff *skb, u8 type,
  */
 static inline void llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa)
 {
-	if (skb->protocol == ntohs(ETH_P_802_2))
+	if (skb->protocol == htons(ETH_P_802_2))
 		memcpy(sa, eth_hdr(skb)->h_source, ETH_ALEN);
-	else if (skb->protocol == ntohs(ETH_P_TR_802_2)) {
+	else if (skb->protocol == htons(ETH_P_TR_802_2)) {
 		memcpy(sa, tr_hdr(skb)->saddr, ETH_ALEN);
 		*sa &= 0x7F;
 	}
@@ -269,9 +269,9 @@ static inline void llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa)
  */
 static inline void llc_pdu_decode_da(struct sk_buff *skb, u8 *da)
 {
-	if (skb->protocol == ntohs(ETH_P_802_2))
+	if (skb->protocol == htons(ETH_P_802_2))
 		memcpy(da, eth_hdr(skb)->h_dest, ETH_ALEN);
-	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+	else if (skb->protocol == htons(ETH_P_TR_802_2))
 		memcpy(da, tr_hdr(skb)->daddr, ETH_ALEN);
 }
 
@@ -345,7 +345,7 @@ static inline void llc_pdu_init_as_test_rsp(struct sk_buff *skb,
 	pdu->ctrl_1  = LLC_PDU_TYPE_U;
 	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
 	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
-	if (ev_skb->protocol == ntohs(ETH_P_802_2)) {
+	if (ev_skb->protocol == htons(ETH_P_802_2)) {
 		struct llc_pdu_un *ev_pdu = llc_pdu_un_hdr(ev_skb);
 		int dsize;
 

commit cf225356578326308b16a0fd03ff3fa72fe3da07
Author: Jochen Friedrich <jochen@scram.de>
Date:   Mon Nov 14 21:58:18 2005 -0800

    [LLC]: Fix typo
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Acked-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index c7a959428b4f..8f6306581fa7 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -357,7 +357,7 @@ static inline void llc_pdu_init_as_test_rsp(struct sk_buff *skb,
 
 /* LLC Type 1 XID command/response information fields format */
 struct llc_xid_info {
-	u8 fmt_id;	/* always 0x18 for LLC */
+	u8 fmt_id;	/* always 0x81 for LLC */
 	u8 type;	/* different if NULL/non-NULL LSAP */
 	u8 rw;		/* sender receive window */
 };

commit 5ed688a7162ff8d28d7cf98b34a1f825e4c2c2ac
Author: Jochen Friedrich <jochen@scram.de>
Date:   Sun Oct 23 10:33:52 2005 +0200

    [LLC]: Strip RIF flag from source MAC address
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
index f45c37d89cf7..c7a959428b4f 100644
--- a/include/net/llc_pdu.h
+++ b/include/net/llc_pdu.h
@@ -254,8 +254,10 @@ static inline void llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa)
 {
 	if (skb->protocol == ntohs(ETH_P_802_2))
 		memcpy(sa, eth_hdr(skb)->h_source, ETH_ALEN);
-	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+	else if (skb->protocol == ntohs(ETH_P_TR_802_2)) {
 		memcpy(sa, tr_hdr(skb)->saddr, ETH_ALEN);
+		*sa &= 0x7F;
+	}
 }
 
 /**

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/llc_pdu.h b/include/net/llc_pdu.h
new file mode 100644
index 000000000000..f45c37d89cf7
--- /dev/null
+++ b/include/net/llc_pdu.h
@@ -0,0 +1,436 @@
+#ifndef LLC_PDU_H
+#define LLC_PDU_H
+/*
+ * Copyright (c) 1997 by Procom Technology,Inc.
+ * 		 2001-2003 by Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ * This program can be redistributed or modified under the terms of the
+ * GNU General Public License as published by the Free Software Foundation.
+ * This program is distributed without any warranty or implied warranty
+ * of merchantability or fitness for a particular purpose.
+ *
+ * See the GNU General Public License for more details.
+ */
+
+#include <linux/if_ether.h>
+#include <linux/if_tr.h>
+
+/* Lengths of frame formats */
+#define LLC_PDU_LEN_I	4       /* header and 2 control bytes */
+#define LLC_PDU_LEN_S	4
+#define LLC_PDU_LEN_U	3       /* header and 1 control byte */
+/* Known SAP addresses */
+#define LLC_GLOBAL_SAP	0xFF
+#define LLC_NULL_SAP	0x00	/* not network-layer visible */
+#define LLC_MGMT_INDIV	0x02	/* station LLC mgmt indiv addr */
+#define LLC_MGMT_GRP	0x03	/* station LLC mgmt group addr */
+#define LLC_RDE_SAP	0xA6	/* route ... */
+
+/* SAP field bit masks */
+#define LLC_ISO_RESERVED_SAP	0x02
+#define LLC_SAP_GROUP_DSAP	0x01
+#define LLC_SAP_RESP_SSAP	0x01
+
+/* Group/individual DSAP indicator is DSAP field */
+#define LLC_PDU_GROUP_DSAP_MASK    0x01
+#define LLC_PDU_IS_GROUP_DSAP(pdu)      \
+	((pdu->dsap & LLC_PDU_GROUP_DSAP_MASK) ? 0 : 1)
+#define LLC_PDU_IS_INDIV_DSAP(pdu)      \
+	(!(pdu->dsap & LLC_PDU_GROUP_DSAP_MASK) ? 0 : 1)
+
+/* Command/response PDU indicator in SSAP field */
+#define LLC_PDU_CMD_RSP_MASK	0x01
+#define LLC_PDU_CMD		0
+#define LLC_PDU_RSP		1
+#define LLC_PDU_IS_CMD(pdu)    ((pdu->ssap & LLC_PDU_RSP) ? 0 : 1)
+#define LLC_PDU_IS_RSP(pdu)    ((pdu->ssap & LLC_PDU_RSP) ? 1 : 0)
+
+/* Get PDU type from 2 lowest-order bits of control field first byte */
+#define LLC_PDU_TYPE_I_MASK    0x01	/* 16-bit control field */
+#define LLC_PDU_TYPE_S_MASK    0x03
+#define LLC_PDU_TYPE_U_MASK    0x03	/* 8-bit control field */
+#define LLC_PDU_TYPE_MASK      0x03
+
+#define LLC_PDU_TYPE_I	0	/* first bit */
+#define LLC_PDU_TYPE_S	1	/* first two bits */
+#define LLC_PDU_TYPE_U	3	/* first two bits */
+
+#define LLC_PDU_TYPE_IS_I(pdu) \
+	((!(pdu->ctrl_1 & LLC_PDU_TYPE_I_MASK)) ? 1 : 0)
+
+#define LLC_PDU_TYPE_IS_U(pdu) \
+	(((pdu->ctrl_1 & LLC_PDU_TYPE_U_MASK) == LLC_PDU_TYPE_U) ? 1 : 0)
+
+#define LLC_PDU_TYPE_IS_S(pdu) \
+	(((pdu->ctrl_1 & LLC_PDU_TYPE_S_MASK) == LLC_PDU_TYPE_S) ? 1 : 0)
+
+/* U-format PDU control field masks */
+#define LLC_U_PF_BIT_MASK      0x10	/* P/F bit mask */
+#define LLC_U_PF_IS_1(pdu)     ((pdu->ctrl_1 & LLC_U_PF_BIT_MASK) ? 1 : 0)
+#define LLC_U_PF_IS_0(pdu)     ((!(pdu->ctrl_1 & LLC_U_PF_BIT_MASK)) ? 1 : 0)
+
+#define LLC_U_PDU_CMD_MASK     0xEC	/* cmd/rsp mask */
+#define LLC_U_PDU_CMD(pdu)     (pdu->ctrl_1 & LLC_U_PDU_CMD_MASK)
+#define LLC_U_PDU_RSP(pdu)     (pdu->ctrl_1 & LLC_U_PDU_CMD_MASK)
+
+#define LLC_1_PDU_CMD_UI       0x00	/* Type 1 cmds/rsps */
+#define LLC_1_PDU_CMD_XID      0xAC
+#define LLC_1_PDU_CMD_TEST     0xE0
+
+#define LLC_2_PDU_CMD_SABME    0x6C	/* Type 2 cmds/rsps */
+#define LLC_2_PDU_CMD_DISC     0x40
+#define LLC_2_PDU_RSP_UA       0x60
+#define LLC_2_PDU_RSP_DM       0x0C
+#define LLC_2_PDU_RSP_FRMR     0x84
+
+/* Type 1 operations */
+
+/* XID information field bit masks */
+
+/* LLC format identifier (byte 1) */
+#define LLC_XID_FMT_ID		0x81	/* first byte must be this */
+
+/* LLC types/classes identifier (byte 2) */
+#define LLC_XID_CLASS_ZEROS_MASK	0xE0	/* these must be zeros */
+#define LLC_XID_CLASS_MASK		0x1F	/* AND with byte to get below */
+
+#define LLC_XID_NULL_CLASS_1	0x01	/* if NULL LSAP...use these */
+#define LLC_XID_NULL_CLASS_2	0x03
+#define LLC_XID_NULL_CLASS_3	0x05
+#define LLC_XID_NULL_CLASS_4	0x07
+
+#define LLC_XID_NNULL_TYPE_1	0x01	/* if non-NULL LSAP...use these */
+#define LLC_XID_NNULL_TYPE_2	0x02
+#define LLC_XID_NNULL_TYPE_3	0x04
+#define LLC_XID_NNULL_TYPE_1_2	0x03
+#define LLC_XID_NNULL_TYPE_1_3	0x05
+#define LLC_XID_NNULL_TYPE_2_3	0x06
+#define LLC_XID_NNULL_ALL		0x07
+
+/* Sender Receive Window (byte 3) */
+#define LLC_XID_RW_MASK	0xFE	/* AND with value to get below */
+
+#define LLC_XID_MIN_RW	0x02	/* lowest-order bit always zero */
+
+/* Type 2 operations */
+
+#define LLC_2_SEQ_NBR_MODULO   ((u8) 128)
+
+/* I-PDU masks ('ctrl' is I-PDU control word) */
+#define LLC_I_GET_NS(pdu)     (u8)((pdu->ctrl_1 & 0xFE) >> 1)
+#define LLC_I_GET_NR(pdu)     (u8)((pdu->ctrl_2 & 0xFE) >> 1)
+
+#define LLC_I_PF_BIT_MASK      0x01
+
+#define LLC_I_PF_IS_0(pdu)     ((!(pdu->ctrl_2 & LLC_I_PF_BIT_MASK)) ? 1 : 0)
+#define LLC_I_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_I_PF_BIT_MASK) ? 1 : 0)
+
+/* S-PDU supervisory commands and responses */
+
+#define LLC_S_PDU_CMD_MASK     0x0C
+#define LLC_S_PDU_CMD(pdu)     (pdu->ctrl_1 & LLC_S_PDU_CMD_MASK)
+#define LLC_S_PDU_RSP(pdu)     (pdu->ctrl_1 & LLC_S_PDU_CMD_MASK)
+
+#define LLC_2_PDU_CMD_RR       0x00	/* rx ready cmd */
+#define LLC_2_PDU_RSP_RR       0x00	/* rx ready rsp */
+#define LLC_2_PDU_CMD_REJ      0x08	/* reject PDU cmd */
+#define LLC_2_PDU_RSP_REJ      0x08	/* reject PDU rsp */
+#define LLC_2_PDU_CMD_RNR      0x04	/* rx not ready cmd */
+#define LLC_2_PDU_RSP_RNR      0x04	/* rx not ready rsp */
+
+#define LLC_S_PF_BIT_MASK      0x01
+#define LLC_S_PF_IS_0(pdu)     ((!(pdu->ctrl_2 & LLC_S_PF_BIT_MASK)) ? 1 : 0)
+#define LLC_S_PF_IS_1(pdu)     ((pdu->ctrl_2 & LLC_S_PF_BIT_MASK) ? 1 : 0)
+
+#define PDU_SUPV_GET_Nr(pdu)   ((pdu->ctrl_2 & 0xFE) >> 1)
+#define PDU_GET_NEXT_Vr(sn)    (++sn & ~LLC_2_SEQ_NBR_MODULO)
+
+/* FRMR information field macros */
+
+#define FRMR_INFO_LENGTH       5	/* 5 bytes of information */
+
+/*
+ * info is pointer to FRMR info field structure; 'rej_ctrl' is byte pointer
+ * (if U-PDU) or word pointer to rejected PDU control field
+ */
+#define FRMR_INFO_SET_REJ_CNTRL(info,rej_ctrl) \
+	info->rej_pdu_ctrl = ((*((u8 *) rej_ctrl) & \
+				LLC_PDU_TYPE_U) != LLC_PDU_TYPE_U ? \
+				(u16)*((u16 *) rej_ctrl) : \
+				(((u16) *((u8 *) rej_ctrl)) & 0x00FF))
+
+/*
+ * Info is pointer to FRMR info field structure; 'vs' is a byte containing
+ * send state variable value in low-order 7 bits (insure the lowest-order
+ * bit remains zero (0))
+ */
+#define FRMR_INFO_SET_Vs(info,vs) (info->curr_ssv = (((u8) vs) << 1))
+#define FRMR_INFO_SET_Vr(info,vr) (info->curr_rsv = (((u8) vr) << 1))
+
+/*
+ * Info is pointer to FRMR info field structure; 'cr' is a byte containing
+ * the C/R bit value in the low-order bit
+ */
+#define FRMR_INFO_SET_C_R_BIT(info, cr)  (info->curr_rsv |= (((u8) cr) & 0x01))
+
+/*
+ * In the remaining five macros, 'info' is pointer to FRMR info field
+ * structure; 'ind' is a byte containing the bit value to set in the
+ * lowest-order bit)
+ */
+#define FRMR_INFO_SET_INVALID_PDU_CTRL_IND(info, ind) \
+       (info->ind_bits = ((info->ind_bits & 0xFE) | (((u8) ind) & 0x01)))
+
+#define FRMR_INFO_SET_INVALID_PDU_INFO_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xFD) | (((u8) ind) & 0x02)))
+
+#define FRMR_INFO_SET_PDU_INFO_2LONG_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xFB) | (((u8) ind) & 0x04)))
+
+#define FRMR_INFO_SET_PDU_INVALID_Nr_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xF7) | (((u8) ind) & 0x08)))
+
+#define FRMR_INFO_SET_PDU_INVALID_Ns_IND(info, ind) \
+       (info->ind_bits = ( (info->ind_bits & 0xEF) | (((u8) ind) & 0x10)))
+
+/* Sequence-numbered PDU format (4 bytes in length) */
+struct llc_pdu_sn {
+	u8 dsap;
+	u8 ssap;
+	u8 ctrl_1;
+	u8 ctrl_2;
+};
+
+static inline struct llc_pdu_sn *llc_pdu_sn_hdr(struct sk_buff *skb)
+{
+	return (struct llc_pdu_sn *)skb->nh.raw;
+}
+
+/* Un-numbered PDU format (3 bytes in length) */
+struct llc_pdu_un {
+	u8 dsap;
+	u8 ssap;
+	u8 ctrl_1;
+};
+
+static inline struct llc_pdu_un *llc_pdu_un_hdr(struct sk_buff *skb)
+{
+	return (struct llc_pdu_un *)skb->nh.raw;
+}
+
+static inline void *llc_set_pdu_hdr(struct sk_buff *skb, void *ptr)
+{
+	return skb->nh.raw = ptr;
+}
+
+/**
+ *	llc_pdu_header_init - initializes pdu header
+ *	@skb: input skb that header must be set into it.
+ *	@type: type of PDU (U, I or S).
+ *	@ssap: source sap.
+ *	@dsap: destination sap.
+ *	@cr: command/response bit (0 or 1).
+ *
+ *	This function sets DSAP, SSAP and command/Response bit in LLC header.
+ */
+static inline void llc_pdu_header_init(struct sk_buff *skb, u8 type,
+				       u8 ssap, u8 dsap, u8 cr)
+{
+	const int hlen = type == LLC_PDU_TYPE_U ? 3 : 4;
+	struct llc_pdu_un *pdu = llc_set_pdu_hdr(skb, skb_push(skb, hlen));
+	pdu->dsap = dsap;
+	pdu->ssap = ssap;
+	pdu->ssap |= cr;
+}
+
+/**
+ *	llc_pdu_decode_sa - extracs source address (MAC) of input frame
+ *	@skb: input skb that source address must be extracted from it.
+ *	@sa: pointer to source address (6 byte array).
+ *
+ *	This function extracts source address(MAC) of input frame.
+ */
+static inline void llc_pdu_decode_sa(struct sk_buff *skb, u8 *sa)
+{
+	if (skb->protocol == ntohs(ETH_P_802_2))
+		memcpy(sa, eth_hdr(skb)->h_source, ETH_ALEN);
+	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+		memcpy(sa, tr_hdr(skb)->saddr, ETH_ALEN);
+}
+
+/**
+ *	llc_pdu_decode_da - extracts dest address of input frame
+ *	@skb: input skb that destination address must be extracted from it
+ *	@sa: pointer to destination address (6 byte array).
+ *
+ *	This function extracts destination address(MAC) of input frame.
+ */
+static inline void llc_pdu_decode_da(struct sk_buff *skb, u8 *da)
+{
+	if (skb->protocol == ntohs(ETH_P_802_2))
+		memcpy(da, eth_hdr(skb)->h_dest, ETH_ALEN);
+	else if (skb->protocol == ntohs(ETH_P_TR_802_2))
+		memcpy(da, tr_hdr(skb)->daddr, ETH_ALEN);
+}
+
+/**
+ *	llc_pdu_decode_ssap - extracts source SAP of input frame
+ *	@skb: input skb that source SAP must be extracted from it.
+ *	@ssap: source SAP (output argument).
+ *
+ *	This function extracts source SAP of input frame. Right bit of SSAP is
+ *	command/response bit.
+ */
+static inline void llc_pdu_decode_ssap(struct sk_buff *skb, u8 *ssap)
+{
+	*ssap = llc_pdu_un_hdr(skb)->ssap & 0xFE;
+}
+
+/**
+ *	llc_pdu_decode_dsap - extracts dest SAP of input frame
+ *	@skb: input skb that destination SAP must be extracted from it.
+ *	@dsap: destination SAP (output argument).
+ *
+ *	This function extracts destination SAP of input frame. right bit of
+ *	DSAP designates individual/group SAP.
+ */
+static inline void llc_pdu_decode_dsap(struct sk_buff *skb, u8 *dsap)
+{
+	*dsap = llc_pdu_un_hdr(skb)->dsap & 0xFE;
+}
+
+/**
+ *	llc_pdu_init_as_ui_cmd - sets LLC header as UI PDU
+ *	@skb: input skb that header must be set into it.
+ *
+ *	This function sets third byte of LLC header as a UI PDU.
+ */
+static inline void llc_pdu_init_as_ui_cmd(struct sk_buff *skb)
+{
+	struct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);
+
+	pdu->ctrl_1  = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_UI;
+}
+
+/**
+ *	llc_pdu_init_as_test_cmd - sets PDU as TEST
+ *	@skb - Address of the skb to build
+ *
+ * 	Sets a PDU as TEST
+ */
+static inline void llc_pdu_init_as_test_cmd(struct sk_buff *skb)
+{
+	struct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);
+
+	pdu->ctrl_1  = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
+	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+}
+
+/**
+ *	llc_pdu_init_as_test_rsp - build TEST response PDU
+ *	@skb: Address of the skb to build
+ *	@ev_skb: The received TEST command PDU frame
+ *
+ *	Builds a pdu frame as a TEST response.
+ */
+static inline void llc_pdu_init_as_test_rsp(struct sk_buff *skb,
+					    struct sk_buff *ev_skb)
+{
+	struct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);
+
+	pdu->ctrl_1  = LLC_PDU_TYPE_U;
+	pdu->ctrl_1 |= LLC_1_PDU_CMD_TEST;
+	pdu->ctrl_1 |= LLC_U_PF_BIT_MASK;
+	if (ev_skb->protocol == ntohs(ETH_P_802_2)) {
+		struct llc_pdu_un *ev_pdu = llc_pdu_un_hdr(ev_skb);
+		int dsize;
+
+		dsize = ntohs(eth_hdr(ev_skb)->h_proto) - 3;
+		memcpy(((u8 *)pdu) + 3, ((u8 *)ev_pdu) + 3, dsize);
+		skb_put(skb, dsize);
+	}
+}
+
+/* LLC Type 1 XID command/response information fields format */
+struct llc_xid_info {
+	u8 fmt_id;	/* always 0x18 for LLC */
+	u8 type;	/* different if NULL/non-NULL LSAP */
+	u8 rw;		/* sender receive window */
+};
+
+/**
+ *	llc_pdu_init_as_xid_cmd - sets bytes 3, 4 & 5 of LLC header as XID
+ *	@skb: input skb that header must be set into it.
+ *
+ *	This function sets third,fourth,fifth and sixth bytes of LLC header as
+ *	a XID PDU.
+ */
+static inline void llc_pdu_init_as_xid_cmd(struct sk_buff *skb,
+					   u8 svcs_supported, u8 rx_window)
+{
+	struct llc_xid_info *xid_info;
+	struct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);
+
+	pdu->ctrl_1	 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1	|= LLC_1_PDU_CMD_XID;
+	pdu->ctrl_1	|= LLC_U_PF_BIT_MASK;
+	xid_info	 = (struct llc_xid_info *)(((u8 *)&pdu->ctrl_1) + 1);
+	xid_info->fmt_id = LLC_XID_FMT_ID;	/* 0x81 */
+	xid_info->type	 = svcs_supported;
+	xid_info->rw	 = rx_window << 1;	/* size of receive window */
+	skb_put(skb, 3);
+}
+
+/**
+ *	llc_pdu_init_as_xid_rsp - builds XID response PDU
+ *	@skb: Address of the skb to build
+ *	@svcs_supported: The class of the LLC (I or II)
+ *	@rx_window: The size of the receive window of the LLC
+ *
+ *	Builds a pdu frame as an XID response.
+ */
+static inline void llc_pdu_init_as_xid_rsp(struct sk_buff *skb,
+					   u8 svcs_supported, u8 rx_window)
+{
+	struct llc_xid_info *xid_info;
+	struct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);
+
+	pdu->ctrl_1	 = LLC_PDU_TYPE_U;
+	pdu->ctrl_1	|= LLC_1_PDU_CMD_XID;
+	pdu->ctrl_1	|= LLC_U_PF_BIT_MASK;
+
+	xid_info	 = (struct llc_xid_info *)(((u8 *)&pdu->ctrl_1) + 1);
+	xid_info->fmt_id = LLC_XID_FMT_ID;
+	xid_info->type	 = svcs_supported;
+	xid_info->rw	 = rx_window << 1;
+	skb_put(skb, 3);
+}
+
+/* LLC Type 2 FRMR response information field format */
+struct llc_frmr_info {
+	u16 rej_pdu_ctrl;	/* bits 1-8 if U-PDU */
+	u8  curr_ssv;		/* current send state variable val */
+	u8  curr_rsv;		/* current receive state variable */
+	u8  ind_bits;		/* indicator bits set with macro */
+};
+
+extern void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 type);
+extern void llc_pdu_set_pf_bit(struct sk_buff *skb, u8 bit_value);
+extern void llc_pdu_decode_pf_bit(struct sk_buff *skb, u8 *pf_bit);
+extern void llc_pdu_init_as_disc_cmd(struct sk_buff *skb, u8 p_bit);
+extern void llc_pdu_init_as_i_cmd(struct sk_buff *skb, u8 p_bit, u8 ns, u8 nr);
+extern void llc_pdu_init_as_rej_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+extern void llc_pdu_init_as_rnr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+extern void llc_pdu_init_as_rr_cmd(struct sk_buff *skb, u8 p_bit, u8 nr);
+extern void llc_pdu_init_as_sabme_cmd(struct sk_buff *skb, u8 p_bit);
+extern void llc_pdu_init_as_dm_rsp(struct sk_buff *skb, u8 f_bit);
+extern void llc_pdu_init_as_frmr_rsp(struct sk_buff *skb,
+				     struct llc_pdu_sn *prev_pdu,
+				     u8 f_bit, u8 vs, u8 vr, u8 vzyxw);
+extern void llc_pdu_init_as_rr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+extern void llc_pdu_init_as_rej_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+extern void llc_pdu_init_as_rnr_rsp(struct sk_buff *skb, u8 f_bit, u8 nr);
+extern void llc_pdu_init_as_ua_rsp(struct sk_buff *skb, u8 f_bit);
+#endif /* LLC_PDU_H */
