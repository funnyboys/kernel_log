commit 2025cf9e193de05b0654570dd639acb49ebd3adf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:02 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 288
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 263 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.208660670@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 74fa7eb94e72..963db96bcbbb 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -1,16 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * NFC Digital Protocol stack
  * Copyright (c) 2013, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
  */
 
 #ifndef __NFC_DIGITAL_H

commit 1a09c56f545c8ff8d338a38c7c40d79f4165a94c
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Fri Jul 8 15:52:45 2016 +0200

    NFC: digital: Add support for NFC DEP Response Waiting Time
    
    When sending an ATR_REQ, the initiator must wait for the ATR_RES at
    least 'RWT(nfcdep,activation) + dRWT(nfcdep)' and no more than
    'RWT(nfcdep,activation) + dRWT(nfcdep) + dT(nfcdep,initiator)'. This
    gives a timeout value between 1237 ms and 1337 ms. This patch defines
    DIGITAL_ATR_RES_RWT to 1337 used for the timeout value of ATR_REQ
    command.
    
    For other DEP PDUs, the initiator must wait between 'RWT + dRWT(nfcdep)'
    and 'RWT + dRWT(nfcdep) + dT(nfcdep,initiator)' where RWT is given by
    the following formula: '(256 * 16 / f(c)) * 2^wt' where wt is the value
    of the TO field in the ATR_RES response and is in the range between 0
    and 14. This patch declares a mapping table for wt values and gives RWT
    max values between 100 ms and 5049 ms.
    
    This patch also defines DIGITAL_ATR_RES_TO_WT, the maximum wt value in
    target mode, to 8.
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index f9a4e4771861..74fa7eb94e72 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -226,6 +226,7 @@ struct nfc_digital_dev {
 	u8 curr_rf_tech;
 	u8 curr_nfc_dep_pni;
 	u8 did;
+	u16 dep_rwt;
 
 	u8 local_payload_max;
 	u8 remote_payload_max;

commit 1d984c2e03c1fb21539a9f50627e312788512013
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Fri Jul 8 15:52:39 2016 +0200

    NFC: digital: Fix handling of saved PDU sk_buff pointers
    
    This patch fixes the way an I-PDU is saved in case it needs to be sent
    again. It is now copied using pskb_copy() and not simply referenced
    using skb_get() since it could be modified by the driver.
    
    digital_in_send_saved_skb() and digital_tg_send_saved_skb() still get a
    reference on the saved skb which is re-sent but release it if the send
    operation fails. That way the caller doesn't have to take care about skb
    ref in case of error.
    
    RTOX supervisor PDU must not be saved as this can override a previously
    saved I-PDU that should be re-sent later on.
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 506e3f6eabef..f9a4e4771861 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -237,7 +237,6 @@ struct nfc_digital_dev {
 	int nack_count;
 
 	struct sk_buff *saved_skb;
-	unsigned int saved_skb_len;
 
 	u16 target_fsc;
 

commit 7854a44526de84142e367f08288c9f3a33c4c8ee
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Tue Jun 7 16:21:52 2016 +0200

    NFC: digital: Add a delay between poll cycles
    
    This replaces the polling work struct with a delayed work struct and add
    a 10 ms delay between 2 poll cycles. This avoids to flood the device
    with 'switch off'/'switch on' commands.
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 0ae101eef0f4..506e3f6eabef 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -220,7 +220,7 @@ struct nfc_digital_dev {
 	struct list_head cmd_queue;
 	struct mutex cmd_lock;
 
-	struct work_struct poll_work;
+	struct delayed_work poll_work;
 
 	u8 curr_protocol;
 	u8 curr_rf_tech;

commit 384ab1d174a11292af63674a26eaa99864db9b48
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 23 16:38:13 2014 -0700

    NFC: digital: Add NFC-DEP Initiator-side ATN Support
    
    When an NFC-DEP Initiator times out when waiting for
    a DEP_RES from the Target, its supposed to send an
    ATN to the Target.  The Target should respond to the
    ATN with a similar ATN PDU and the Initiator can then
    resend the last non-ATN PDU that it sent.  No more
    than 'N(retry,atn)' are to be send where
    2 <= 'N(retry,atn)' <= 5.  If the Initiator had just
    sent a NACK PDU when the timeout occurred, it is to
    continue sending NACKs until 'N(retry,nack)' NACKs
    have been send.  This is described in section
    14.12.5.6 of the NFC-DEP Digital Protocol Spec.
    
    The digital layer's NFC-DEP code doesn't implement
    this so add that support.
    
    The value chosen for 'N(retry,atn)' is 2.
    
    Reviewed-by: Thierry Escande <thierry.escande@linux.intel.com>
    Tested-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 7400a8126cd1..0ae101eef0f4 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -233,6 +233,7 @@ struct nfc_digital_dev {
 	struct sk_buff *chaining_skb;
 	struct digital_data_exch *data_exch;
 
+	int atn_count;
 	int nack_count;
 
 	struct sk_buff *saved_skb;

commit 49dbb14e30c3249f98fe243c3e21b91d10c5c59b
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 23 16:38:12 2014 -0700

    NFC: digital: Add NFC-DEP Target-side NACK Support
    
    When an NFC-DEP Target receives a NACK PDU with
    a PNI equal to 1 less than the current PNI, it
    is supposed to re-send the last PDU.  This is
    implied in section 14.12.5.4 of the NFC Digital
    Protocol Spec.
    
    The digital layer's NFC-DEP code doesn't implement
    Target-side NACK handing so add it.  The last PDU
    that was sent is saved in the 'nfc_digital_dev'
    structure's 'saved_skb' member.  The skb will have
    an additional reference taken to ensure that the skb
    isn't freed when the driver performs a kfree_skb()
    on the skb.  The length of the skb/PDU is also saved
    so the length can be restored when re-sending the PDU
    in the skb (the driver will perform an skb_pull() so
    an skb_push() needs to be done to restore the skb's
    data pointer/length).
    
    Reviewed-by: Thierry Escande <thierry.escande@linux.intel.com>
    Tested-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 2fd498cdb818..7400a8126cd1 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -235,6 +235,9 @@ struct nfc_digital_dev {
 
 	int nack_count;
 
+	struct sk_buff *saved_skb;
+	unsigned int saved_skb_len;
+
 	u16 target_fsc;
 
 	int (*skb_check_crc)(struct sk_buff *skb);

commit a80509c76bf2b10dae76f3caea343ac4b85c72b4
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 23 16:38:11 2014 -0700

    NFC: digital: Add NFC-DEP Initiator-side NACK Support
    
    When an NFC-DEP Initiator receives a frame with
    an incorrect CRC or with a parity error, and the
    frame is at least 4 bytes long, its supposed to
    send a NACK to the Target.  The Initiator can
    send up to 'N(retry,nack)' consecutive NACKs
    where 2 <= 'N(retry,nack)' <= 5.  When the limit
    is exceeded, a PROTOCOL EXCEPTION is raised.
    Any other type of transmission error is to be
    ignored and the Initiator should continue
    waiting for a new frame.  This is described
    in section 14.12.5.4 of the NFC Digital Protocol
    Spec.
    
    The digital layer's NFC-DEP code doesn't implement
    any of this so add it.  This support diverges from
    the spec in two significant ways:
    
    a) NACKs will be sent for ANY error reported by the
       driver except a timeout.  This is done because
       there is currently no way for the digital layer
       to distinguish a CRC or parity error from any
       other type of error reported by the driver.
    
    b) All other errors will cause a PROTOCOL EXCEPTION
       even frames with CRC errors that are less than 4
       bytes.
    
    The value chosen for 'N(retry,nack)' is 2.
    
    Targets do not send NACK PDUs.
    
    Reviewed-by: Thierry Escande <thierry.escande@linux.intel.com>
    Tested-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 2fdff00e06cd..2fd498cdb818 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -233,6 +233,8 @@ struct nfc_digital_dev {
 	struct sk_buff *chaining_skb;
 	struct digital_data_exch *data_exch;
 
+	int nack_count;
+
 	u16 target_fsc;
 
 	int (*skb_check_crc)(struct sk_buff *skb);

commit 3bd2a5bcc6cd7b8d588aa9ffa947177721eba18e
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 23 16:38:09 2014 -0700

    NFC: digital: Add NFC-DEP Send Chaining Support
    
    When the NFC-DEP code is given a packet to send
    that is larger than the peer's maximum payload,
    its supposed to set the 'MI' bit in the 'I' PDU's
    Protocol Frame Byte (PFB).  Setting this bit
    indicates that NFC-DEP chaining is to occur.
    
    When NFC-DEP chaining is progress, sender 'I' PDUs
    are acknowledged with 'ACK' PDUs until the last 'I'
    PDU in the chain (which has the 'MI' bit cleared)
    is responded to with a normal 'I' PDU.  This can
    occur while in Initiator mode or in Target mode.
    
    Sender NFC-DEP chaining is currently not implemented
    in the digital layer so add that support.  Unfortunately,
    since sending a frame may require writing the CRC to the
    end of the data, the relevant data part of the original
    skb must be copied for each intermediate frame.
    
    Reviewed-by: Thierry Escande <thierry.escande@linux.intel.com>
    Tested-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 42dbc6e6ee21..2fdff00e06cd 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -230,6 +230,9 @@ struct nfc_digital_dev {
 	u8 local_payload_max;
 	u8 remote_payload_max;
 
+	struct sk_buff *chaining_skb;
+	struct digital_data_exch *data_exch;
+
 	u16 target_fsc;
 
 	int (*skb_check_crc)(struct sk_buff *skb);

commit b08147cbc4d1b63d65f6c7c522fed9ef3212bc52
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 23 16:38:08 2014 -0700

    NFC: digital: Implement NFC-DEP max payload lengths
    
    The maximum payload for NFC-DEP exchanges (i.e., the
    number of bytes between SoD and EoD) is negotiated
    using the ATR_REQ, ATR_RES, and PSL_REQ commands.
    The valid maximum lengths are 64, 128, 192, and 254
    bytes.
    
    Currently, NFC-DEP code assumes that both sides are
    always using 254 byte maximums and ignores attempts
    by the peer to change it.  Instead, implement the
    negotiation code, enforce the local maximum when
    receiving data from the peer, and don't send payloads
    that exceed the remote's maximum.  The default local
    maximum is 254 bytes.
    
    Reviewed-by: Thierry Escande <thierry.escande@linux.intel.com>
    Tested-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 80c6183989f3..42dbc6e6ee21 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -227,6 +227,9 @@ struct nfc_digital_dev {
 	u8 curr_nfc_dep_pni;
 	u8 did;
 
+	u8 local_payload_max;
+	u8 remote_payload_max;
+
 	u16 target_fsc;
 
 	int (*skb_check_crc)(struct sk_buff *skb);

commit 05afedcb89189df5cea30a13b2a5b4aa70572749
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 23 16:38:05 2014 -0700

    NFC: digital: Add Target-mode NFC-DEP DID Support
    
    When in Target mode, the Initiator specifies whether
    subsequent DEP_REQ and DEP_RES frames will include
    a DID byte by the value passed in the ATR_REQ.  If
    the DID value in the ATR_REQ is '0' then no DID
    byte will be included.  If the DID value is between
    '1' and '14' then a DID byte containing the same
    value must be included in subsequent DEP_REQ and
    DEP_RES frames.  Any other DID value is invalid.
    This is specified in sections 14.8.1.2 and 14.8.2.2
    of the NFC Digital Protocol Spec.
    
    Checking the DID value (if it should be there at all),
    is not currently supported by the digital layer's
    NFC-DEP code.  Add this support by remembering the
    DID value in the ATR_REQ, checking the DID value of
    received DEP_REQ frames (if it should be there at all),
    and including the remembered DID value in DEP_RES
    frames when appropriate.
    
    Reviewed-by: Thierry Escande <thierry.escande@linux.intel.com>
    Tested-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index d9a5cf7ac1c4..80c6183989f3 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -225,6 +225,7 @@ struct nfc_digital_dev {
 	u8 curr_protocol;
 	u8 curr_rf_tech;
 	u8 curr_nfc_dep_pni;
+	u8 did;
 
 	u16 target_fsc;
 

commit bf30a67c947ed57c1cf7c68a47dc24331458037e
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Jul 21 21:24:39 2014 -0700

    NFC: digital: Add 'tg_listen_md' and 'tg_get_rf_tech' driver hooks
    
    The digital layer of the NFC subsystem currently
    supports a 'tg_listen_mdaa' driver hook that supports
    devices that can do mode detection and automatic
    anticollision.  However, there are some devices that
    can do mode detection but not automatic anitcollision
    so add the 'tg_listen_md' hook to support those devices.
    
    In order for the digital layer to get the RF technology
    detected by the device from the driver, add the
    'tg_get_rf_tech' hook.  It is only valid to call this
    hook immediately after a successful call to 'tg_listen_md'.
    
    CC: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 575d668b7852..d9a5cf7ac1c4 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -127,6 +127,15 @@ typedef void (*nfc_digital_cmd_complete_t)(struct nfc_digital_dev *ddev,
  *	the NFC-DEP ATR_REQ command through cb. The digital stack deducts the RF
  *	tech by analyzing the SoD of the frame containing the ATR_REQ command.
  *	This is an asynchronous function.
+ * @tg_listen_md: If supported, put the device in automatic listen mode with
+ *	mode detection but without automatic anti-collision. In this mode, the
+ *	device automatically detects the RF technology.  What the actual
+ *	RF technology is can be retrieved by calling @tg_get_rf_tech.
+ *	The digital stack will then perform the appropriate anti-collision
+ *	sequence.  This is an asynchronous function.
+ * @tg_get_rf_tech: Required when @tg_listen_md is supported, unused otherwise.
+ *	Return the RF Technology that was detected by the @tg_listen_md call.
+ *	This is a synchronous function.
  *
  * @switch_rf: Turns device radio on or off. The stack does not call explicitly
  *	switch_rf to turn the radio on. A call to in|tg_configure_hw must turn
@@ -161,6 +170,9 @@ struct nfc_digital_ops {
 			      struct digital_tg_mdaa_params *mdaa_params,
 			      u16 timeout, nfc_digital_cmd_complete_t cb,
 			      void *arg);
+	int (*tg_listen_md)(struct nfc_digital_dev *ddev, u16 timeout,
+			    nfc_digital_cmd_complete_t cb, void *arg);
+	int (*tg_get_rf_tech)(struct nfc_digital_dev *ddev, u8 *rf_tech);
 
 	int (*switch_rf)(struct nfc_digital_dev *ddev, bool on);
 	void (*abort_cmd)(struct nfc_digital_dev *ddev);

commit f63bac94bfe2b7f98d28e5c7d3432a5060841f51
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Jul 21 21:22:29 2014 -0700

    NFC: digital: Remove extra blank line
    
    Remove extra blank line that was inadvertently
    added by a recent commit.
    
    CC: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 2bc31d10f9eb..575d668b7852 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -67,7 +67,6 @@ enum {
 	NFC_DIGITAL_FRAMING_NFCB,
 	NFC_DIGITAL_FRAMING_NFCB_T4T,
 
-
 	NFC_DIGITAL_FRAMING_LAST,
 };
 

commit 55537c7e7d76417303c32f84a8dd1a12e02c4409
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Wed Jul 2 10:16:15 2014 -0700

    NFC: digital: Add digital framing calls when in target mode
    
    Add new "NFC_DIGITAL_FRAMING_*" calls to the digital
    layer so the driver can make the necessary adjustments
    when performing anticollision while in target mode.
    
    The driver must ensure that the effect of these calls
    happens after the following response has been sent but
    before reception of the next request begins.
    
    Acked-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index bdf55c3b7a19..2bc31d10f9eb 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -49,6 +49,7 @@ enum {
 	NFC_DIGITAL_FRAMING_NFCA_SHORT = 0,
 	NFC_DIGITAL_FRAMING_NFCA_STANDARD,
 	NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A,
+	NFC_DIGITAL_FRAMING_NFCA_ANTICOL_COMPLETE,
 
 	NFC_DIGITAL_FRAMING_NFCA_T1T,
 	NFC_DIGITAL_FRAMING_NFCA_T2T,
@@ -66,6 +67,7 @@ enum {
 	NFC_DIGITAL_FRAMING_NFCB,
 	NFC_DIGITAL_FRAMING_NFCB_T4T,
 
+
 	NFC_DIGITAL_FRAMING_LAST,
 };
 

commit 51d98fa47c9c3f5d34cd4097ce08e8e8669a89b4
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Mar 31 17:36:37 2014 -0700

    NFC: digital: Add macros for the ISO/IEC 14443-B Protocol
    
    Add RF tech and framing macros for the ISO/IEC 14443-B Protocol.
    
    Cc: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 7655cfe27c34..bdf55c3b7a19 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -36,6 +36,7 @@ enum {
 	NFC_DIGITAL_RF_TECH_212F,
 	NFC_DIGITAL_RF_TECH_424F,
 	NFC_DIGITAL_RF_TECH_ISO15693,
+	NFC_DIGITAL_RF_TECH_106B,
 
 	NFC_DIGITAL_RF_TECH_LAST,
 };
@@ -62,6 +63,9 @@ enum {
 	NFC_DIGITAL_FRAMING_ISO15693_INVENTORY,
 	NFC_DIGITAL_FRAMING_ISO15693_T5T,
 
+	NFC_DIGITAL_FRAMING_NFCB,
+	NFC_DIGITAL_FRAMING_NFCB_T4T,
+
 	NFC_DIGITAL_FRAMING_LAST,
 };
 

commit ceeee42d85b4c91b16b6019e69c584589b72be04
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Thu Mar 6 07:39:19 2014 -0700

    NFC: digital: Rename Type V tags to Type 5 tags
    
    According to the latest draft specification from
    the NFC-V committee, ISO/IEC 15693 tags will be
    referred to as "Type 5" tags and not "Type V"
    tags anymore.  Make the code reflect the new
    terminology.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index b9699d7dd039..7655cfe27c34 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -60,7 +60,7 @@ enum {
 	NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED,
 
 	NFC_DIGITAL_FRAMING_ISO15693_INVENTORY,
-	NFC_DIGITAL_FRAMING_ISO15693_TVT,	/* Type V Tag (ISO/IEC 15693) */
+	NFC_DIGITAL_FRAMING_ISO15693_T5T,
 
 	NFC_DIGITAL_FRAMING_LAST,
 };

commit 12e3d241e42956da168fd499347855af799f62fb
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Mon Jan 27 00:31:31 2014 +0100

    NFC: digital: Add poll support for type 4A tag platform
    
    This adds support for ATS request and response handling for type 4A tag
    activation.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 1f0528d33500..b9699d7dd039 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -51,6 +51,7 @@ enum {
 
 	NFC_DIGITAL_FRAMING_NFCA_T1T,
 	NFC_DIGITAL_FRAMING_NFCA_T2T,
+	NFC_DIGITAL_FRAMING_NFCA_T4T,
 	NFC_DIGITAL_FRAMING_NFCA_NFC_DEP,
 
 	NFC_DIGITAL_FRAMING_NFCF,
@@ -208,6 +209,8 @@ struct nfc_digital_dev {
 	u8 curr_rf_tech;
 	u8 curr_nfc_dep_pni;
 
+	u16 target_fsc;
+
 	int (*skb_check_crc)(struct sk_buff *skb);
 	void (*skb_add_crc)(struct sk_buff *skb);
 };

commit e487e4dc2eb227c52fc71eae683181fa917163b8
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Jan 14 17:52:09 2014 -0700

    NFC: Add ISO/IEC 15693 header definitions
    
    Add the header definitions required by upcoming
    patches that add support for ISO/IEC 15693.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 81af21e9bcd4..1f0528d33500 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -35,6 +35,7 @@ enum {
 	NFC_DIGITAL_RF_TECH_106A = 0,
 	NFC_DIGITAL_RF_TECH_212F,
 	NFC_DIGITAL_RF_TECH_424F,
+	NFC_DIGITAL_RF_TECH_ISO15693,
 
 	NFC_DIGITAL_RF_TECH_LAST,
 };
@@ -57,6 +58,9 @@ enum {
 	NFC_DIGITAL_FRAMING_NFCF_NFC_DEP,
 	NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED,
 
+	NFC_DIGITAL_FRAMING_ISO15693_INVENTORY,
+	NFC_DIGITAL_FRAMING_ISO15693_TVT,	/* Type V Tag (ISO/IEC 15693) */
+
 	NFC_DIGITAL_FRAMING_LAST,
 };
 

commit 444fb98eed98f7292a83f9bf123d1c78f171327e
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Jan 2 11:58:12 2014 +0100

    NFC: digital: Add a note about asynchronous functions
    
    This explains how and why the timeout parameter must be handled by the
    driver implementation.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 36acecd5f06c..81af21e9bcd4 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -122,6 +122,16 @@ typedef void (*nfc_digital_cmd_complete_t)(struct nfc_digital_dev *ddev,
  *	switch_rf to turn the radio on. A call to in|tg_configure_hw must turn
  *	the device radio on.
  * @abort_cmd: Discard the last sent command.
+ *
+ * Notes: Asynchronous functions have a timeout parameter. It is the driver
+ *	responsibility to call the digital stack back through the
+ *	nfc_digital_cmd_complete_t callback when no RF respsonse has been
+ *	received within the specified time (in milliseconds). In that case the
+ *	driver must set the resp sk_buff to ERR_PTR(-ETIMEDOUT).
+ *	Since the digital stack serializes commands to be sent, it's mandatory
+ *	for the driver to handle the timeout correctly. Otherwise the stack
+ *	would not be able to send new commands, waiting for the reply of the
+ *	current one.
  */
 struct nfc_digital_ops {
 	int (*in_configure_hw)(struct nfc_digital_dev *ddev, int type,

commit 2c66daecc4092e6049673c281b2e6f0d5e59a94c
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:27 2013 +0200

    NFC Digital: Add NFC-A technology support
    
    This adds support for NFC-A technology at 106 kbits/s. The stack can
    detect tags of type 1 and 2. There is no support for collision
    detection. Tags can be read and written by using a user space
    application or a daemon like neard.
    
    The flow of polling operations for NFC-A detection is as follow:
    
    1 - The digital stack sends the SENS_REQ command to the NFC device.
    2 - The NFC device receives a SENS_RES response from a peer device and
        passes it to the digital stack.
    3   - If the SENS_RES response identifies a type 1 tag, detection ends.
          NFC core is notified through nfc_targets_found().
    4   - Otherwise, the digital stack sets the cascade level of NFCID1 to
          CL1 and sends the SDD_REQ command.
    5 - The digital stack selects SEL_CMD and SEL_PAR according to the
        cascade level and sends the SDD_REQ command.
    4 - The digital stack receives a SDD_RES response for the cascade level
        passed in the SDD_REQ command.
    5 - The digital stack analyses (part of) NFCID1 and verify BCC.
    6 - The digital stack sends the SEL_REQ command with the NFCID1
        received in the SDD_RES.
    6 - The peer device replies with a SEL_RES response
    7   - Detection ends if NFCID1 is complete. NFC core notified of new
          target by nfc_targets_found().
    8   - If NFCID1 is not complete, the cascade level is incremented (up
          to and including CL3) and the execution continues at step 5 to
          get the remaining bytes of NFCID1.
    
    Once target detection is done, type 1 and 2 tag commands must be
    handled by a user space application (i.e neard) through the NFC core.
    Responses for type 1 tag are returned directly to user space via NFC
    core.
    Responses of type 2 commands are handled differently. The digital stack
    doesn't analyse the type of commands sent through im_transceive() and
    must differentiate valid responses from error ones.
    The response process flow is as follow:
    
    1 - If the response length is 16 bytes, it is a valid response of a
        READ command. the packet is returned to the NFC core through the
        callback passed to im_transceive(). Processing stops.
    2 - If the response is 1 byte long and is a ACK byte (0x0A), it is a
        valid response of a WRITE command for example. First packet byte
        is set to 0 for no-error and passed back to the NFC core.
        Processing stops.
    3 - Any other response is treated as an error and -EIO error code is
        returned to the NFC core through the response callback.
    
    Moreover, since the driver can't differentiate success response from a
    NACK response, the digital stack has to handle CRC calculation.
    
    Thus, this patch also adds support for CRC calculation. If the driver
    doesn't handle it, the digital stack will calculate CRC and will add it
    to sent frames. CRC will also be checked and removed from received
    frames. Pointers to the correct CRC calculation functions are stored in
    the digital stack device structure when a target is detected. This
    avoids the need to check the current target type for every call to
    im_transceive() and for every response received from a peer device.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index aabd89400d23..36acecd5f06c 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -193,6 +193,9 @@ struct nfc_digital_dev {
 	u8 curr_protocol;
 	u8 curr_rf_tech;
 	u8 curr_nfc_dep_pni;
+
+	int (*skb_check_crc)(struct sk_buff *skb);
+	void (*skb_add_crc)(struct sk_buff *skb);
 };
 
 struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,

commit 59ee2361c9248f07846f7a6e585768dcce18fb16
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:26 2013 +0200

    NFC Digital: Implement driver commands mechanism
    
    This implements the mechanism used to send commands to the driver in
    initiator mode through in_send_cmd().
    
    Commands are serialized and sent to the driver by using a work item
    on the system workqueue. Responses are handled asynchronously by
    another work item. Once the digital stack receives the response through
    the command_complete callback, the next command is sent to the driver.
    
    This also implements the polling mechanism. It's handled by a work item
    cycling on all supported protocols. The start poll command for a given
    protocol is sent to the driver using the mechanism described above.
    The process continues until a peer is discovered or stop_poll is
    called. This patch implements the poll function for NFC-A that sends a
    SENS_REQ command and waits for the SENS_RES response.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
index 8e16b6e0265a..aabd89400d23 100644
--- a/include/net/nfc/digital.h
+++ b/include/net/nfc/digital.h
@@ -146,6 +146,15 @@ struct nfc_digital_ops {
 	void (*abort_cmd)(struct nfc_digital_dev *ddev);
 };
 
+#define NFC_DIGITAL_POLL_MODE_COUNT_MAX	6 /* 106A, 212F, and 424F in & tg */
+
+typedef int (*digital_poll_t)(struct nfc_digital_dev *ddev, u8 rf_tech);
+
+struct digital_poll_tech {
+	u8 rf_tech;
+	digital_poll_t poll_func;
+};
+
 /**
  * Driver capabilities - bit mask made of the following values
  *
@@ -168,6 +177,22 @@ struct nfc_digital_dev {
 
 	u32 driver_capabilities;
 	void *driver_data;
+
+	struct digital_poll_tech poll_techs[NFC_DIGITAL_POLL_MODE_COUNT_MAX];
+	u8 poll_tech_count;
+	u8 poll_tech_index;
+	struct mutex poll_lock;
+
+	struct work_struct cmd_work;
+	struct work_struct cmd_complete_work;
+	struct list_head cmd_queue;
+	struct mutex cmd_lock;
+
+	struct work_struct poll_work;
+
+	u8 curr_protocol;
+	u8 curr_rf_tech;
+	u8 curr_nfc_dep_pni;
 };
 
 struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,

commit 4b10884eb428c243ae2070a539612e645f3d9b93
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:25 2013 +0200

    NFC: Digital Protocol stack implementation
    
    This is the initial commit of the NFC Digital Protocol stack
    implementation.
    
    It offers an interface for devices that don't have an embedded NFC
    Digital protocol stack. The driver instantiates the digital stack by
    calling nfc_digital_allocate_device(). Within the nfc_digital_ops
    structure, the driver specifies a set of function pointers for driver
    operations. These functions must be implemented by the driver and are:
    
    in_configure_hw:
    Hardware configuration for RF technology and communication framing in
    initiator mode. This is a synchronous function.
    
    in_send_cmd:
    Initiator mode data exchange using RF technology and framing previously
    set with in_configure_hw. The peer response is returned through
    callback cb. If an io error occurs or the peer didn't reply within the
    specified timeout (ms), the error code is passed back through the resp
    pointer. This is an asynchronous function.
    
    tg_configure_hw:
    Hardware configuration for RF technology and communication framing in
    target mode. This is a synchronous function.
    
    tg_send_cmd:
    Target mode data exchange using RF technology and framing previously
    set with tg_configure_hw. The peer next command is returned through
    callback cb. If an io error occurs or the peer didn't reply within the
    specified timeout (ms), the error code is passed back through the resp
    pointer. This is an asynchronous function.
    
    tg_listen:
    Put the device in listen mode waiting for data from the peer device.
    This is an asynchronous function.
    
    tg_listen_mdaa:
    If supported, put the device in automatic listen mode with mode
    detection and automatic anti-collision. In this mode, the device
    automatically detects the RF technology and executes the
    anti-collision detection using the command responses specified in
    mdaa_params. The mdaa_params structure contains SENS_RES, NFCID1, and
    SEL_RES for 106A RF tech. NFCID2 and system code (sc) for 212F and
    424F. The driver returns the NFC-DEP ATR_REQ command through cb. The
    digital stack deducts the RF tech by analyzing the SoD of the frame
    containing the ATR_REQ command. This is an asynchronous function.
    
    switch_rf:
    Turns device radio on or off. The stack does not call explicitly
    switch_rf to turn the radio on. A call to in|tg_configure_hw must turn
    the device radio on.
    
    abort_cmd:
    Discard the last sent command.
    
    Then the driver registers itself against the digital stack by using
    nfc_digital_register_device() which in turn registers the digital stack
    against the NFC core layer. The digital stack implements common NFC
    operations like dev_up(), dev_down(), start_poll(), stop_poll(), etc.
    
    This patch is only a skeleton and NFC operations are just stubs.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/include/net/nfc/digital.h b/include/net/nfc/digital.h
new file mode 100644
index 000000000000..8e16b6e0265a
--- /dev/null
+++ b/include/net/nfc/digital.h
@@ -0,0 +1,199 @@
+/*
+ * NFC Digital Protocol stack
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __NFC_DIGITAL_H
+#define __NFC_DIGITAL_H
+
+#include <linux/skbuff.h>
+#include <net/nfc/nfc.h>
+
+/**
+ * Configuration types for in_configure_hw and tg_configure_hw.
+ */
+enum {
+	NFC_DIGITAL_CONFIG_RF_TECH = 0,
+	NFC_DIGITAL_CONFIG_FRAMING,
+};
+
+/**
+ * RF technology values passed as param argument to in_configure_hw and
+ * tg_configure_hw for NFC_DIGITAL_CONFIG_RF_TECH configuration type.
+ */
+enum {
+	NFC_DIGITAL_RF_TECH_106A = 0,
+	NFC_DIGITAL_RF_TECH_212F,
+	NFC_DIGITAL_RF_TECH_424F,
+
+	NFC_DIGITAL_RF_TECH_LAST,
+};
+
+/**
+ * Framing configuration passed as param argument to in_configure_hw and
+ * tg_configure_hw for NFC_DIGITAL_CONFIG_FRAMING configuration type.
+ */
+enum {
+	NFC_DIGITAL_FRAMING_NFCA_SHORT = 0,
+	NFC_DIGITAL_FRAMING_NFCA_STANDARD,
+	NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A,
+
+	NFC_DIGITAL_FRAMING_NFCA_T1T,
+	NFC_DIGITAL_FRAMING_NFCA_T2T,
+	NFC_DIGITAL_FRAMING_NFCA_NFC_DEP,
+
+	NFC_DIGITAL_FRAMING_NFCF,
+	NFC_DIGITAL_FRAMING_NFCF_T3T,
+	NFC_DIGITAL_FRAMING_NFCF_NFC_DEP,
+	NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED,
+
+	NFC_DIGITAL_FRAMING_LAST,
+};
+
+#define DIGITAL_MDAA_NFCID1_SIZE 3
+
+struct digital_tg_mdaa_params {
+	u16 sens_res;
+	u8 nfcid1[DIGITAL_MDAA_NFCID1_SIZE];
+	u8 sel_res;
+
+	u8 nfcid2[NFC_NFCID2_MAXSIZE];
+	u16 sc;
+};
+
+struct nfc_digital_dev;
+
+/**
+ * nfc_digital_cmd_complete_t - Definition of command result callback
+ *
+ * @ddev: nfc_digital_device ref
+ * @arg: user data
+ * @resp: response data
+ *
+ * resp pointer can be an error code and will be checked with IS_ERR() macro.
+ * The callback is responsible for freeing resp sk_buff.
+ */
+typedef void (*nfc_digital_cmd_complete_t)(struct nfc_digital_dev *ddev,
+					   void *arg, struct sk_buff *resp);
+
+/**
+ * Device side NFC Digital operations
+ *
+ * Initiator mode:
+ * @in_configure_hw: Hardware configuration for RF technology and communication
+ *	framing in initiator mode. This is a synchronous function.
+ * @in_send_cmd: Initiator mode data exchange using RF technology and framing
+ *	previously set with in_configure_hw. The peer response is returned
+ *	through callback cb. If an io error occurs or the peer didn't reply
+ *	within the specified timeout (ms), the error code is passed back through
+ *	the resp pointer. This is an asynchronous function.
+ *
+ * Target mode: Only NFC-DEP protocol is supported in target mode.
+ * @tg_configure_hw: Hardware configuration for RF technology and communication
+ *	framing in target mode. This is a synchronous function.
+ * @tg_send_cmd: Target mode data exchange using RF technology and framing
+ *	previously set with tg_configure_hw. The peer next command is returned
+ *	through callback cb. If an io error occurs or the peer didn't reply
+ *	within the specified timeout (ms), the error code is passed back through
+ *	the resp pointer. This is an asynchronous function.
+ * @tg_listen: Put the device in listen mode waiting for data from the peer
+ *	device. This is an asynchronous function.
+ * @tg_listen_mdaa: If supported, put the device in automatic listen mode with
+ *	mode detection and automatic anti-collision. In this mode, the device
+ *	automatically detects the RF technology and executes the anti-collision
+ *	detection using the command responses specified in mdaa_params. The
+ *	mdaa_params structure contains SENS_RES, NFCID1, and SEL_RES for 106A RF
+ *	tech. NFCID2 and system code (sc) for 212F and 424F. The driver returns
+ *	the NFC-DEP ATR_REQ command through cb. The digital stack deducts the RF
+ *	tech by analyzing the SoD of the frame containing the ATR_REQ command.
+ *	This is an asynchronous function.
+ *
+ * @switch_rf: Turns device radio on or off. The stack does not call explicitly
+ *	switch_rf to turn the radio on. A call to in|tg_configure_hw must turn
+ *	the device radio on.
+ * @abort_cmd: Discard the last sent command.
+ */
+struct nfc_digital_ops {
+	int (*in_configure_hw)(struct nfc_digital_dev *ddev, int type,
+			       int param);
+	int (*in_send_cmd)(struct nfc_digital_dev *ddev, struct sk_buff *skb,
+			   u16 timeout, nfc_digital_cmd_complete_t cb,
+			   void *arg);
+
+	int (*tg_configure_hw)(struct nfc_digital_dev *ddev, int type,
+			       int param);
+	int (*tg_send_cmd)(struct nfc_digital_dev *ddev, struct sk_buff *skb,
+			   u16 timeout, nfc_digital_cmd_complete_t cb,
+			   void *arg);
+	int (*tg_listen)(struct nfc_digital_dev *ddev, u16 timeout,
+			 nfc_digital_cmd_complete_t cb, void *arg);
+	int (*tg_listen_mdaa)(struct nfc_digital_dev *ddev,
+			      struct digital_tg_mdaa_params *mdaa_params,
+			      u16 timeout, nfc_digital_cmd_complete_t cb,
+			      void *arg);
+
+	int (*switch_rf)(struct nfc_digital_dev *ddev, bool on);
+	void (*abort_cmd)(struct nfc_digital_dev *ddev);
+};
+
+/**
+ * Driver capabilities - bit mask made of the following values
+ *
+ * @NFC_DIGITAL_DRV_CAPS_IN_CRC: The driver handles CRC calculation in initiator
+ *	mode.
+ * @NFC_DIGITAL_DRV_CAPS_TG_CRC: The driver handles CRC calculation in target
+ *	mode.
+ */
+#define NFC_DIGITAL_DRV_CAPS_IN_CRC	0x0001
+#define NFC_DIGITAL_DRV_CAPS_TG_CRC	0x0002
+
+struct nfc_digital_dev {
+	struct nfc_dev *nfc_dev;
+	struct nfc_digital_ops *ops;
+
+	u32 protocols;
+
+	int tx_headroom;
+	int tx_tailroom;
+
+	u32 driver_capabilities;
+	void *driver_data;
+};
+
+struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
+						    __u32 supported_protocols,
+						    __u32 driver_capabilities,
+						    int tx_headroom,
+						    int tx_tailroom);
+void nfc_digital_free_device(struct nfc_digital_dev *ndev);
+int nfc_digital_register_device(struct nfc_digital_dev *ndev);
+void nfc_digital_unregister_device(struct nfc_digital_dev *ndev);
+
+static inline void nfc_digital_set_parent_dev(struct nfc_digital_dev *ndev,
+					      struct device *dev)
+{
+	nfc_set_parent_dev(ndev->nfc_dev, dev);
+}
+
+static inline void nfc_digital_set_drvdata(struct nfc_digital_dev *dev,
+					   void *data)
+{
+	dev->driver_data = data;
+}
+
+static inline void *nfc_digital_get_drvdata(struct nfc_digital_dev *dev)
+{
+	return dev->driver_data;
+}
+
+#endif /* __NFC_DIGITAL_H */
