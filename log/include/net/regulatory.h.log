commit b572510100165ba037ba43dbbb0f05e8da12c741
Author: Thomas Pedersen <thomas@adapt-ip.com>
Date:   Wed Apr 1 18:18:02 2020 -0700

    ieee80211: share 802.11 unit conversion helpers
    
    MHZ_TO_KHZ, and KHZ_TO_MHZ are useful to drivers and
    elsewhere so export these in the common ieee80211 header.
    Move the power helpers also because we might as well.
    
    Signed-off-by: Thomas Pedersen <thomas@adapt-ip.com>
    Link: https://lore.kernel.org/r/20200402011810.22947-2-thomas@adapt-ip.com
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 3469750df0f4..09a3099886e5 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -231,13 +231,6 @@ struct ieee80211_regdomain {
 	struct ieee80211_reg_rule reg_rules[];
 };
 
-#define MHZ_TO_KHZ(freq) ((freq) * 1000)
-#define KHZ_TO_MHZ(freq) ((freq) / 1000)
-#define DBI_TO_MBI(gain) ((gain) * 100)
-#define MBI_TO_DBI(gain) ((gain) / 100)
-#define DBM_TO_MBM(gain) ((gain) * 100)
-#define MBM_TO_DBM(gain) ((gain) / 100)
-
 #define REG_RULE_EXT(start, end, bw, gain, eirp, dfs_cac, reg_flags)	\
 {									\
 	.freq_range.start_freq_khz = MHZ_TO_KHZ(start),			\

commit 38cb87ee47fb825f6c9d645c019f75b3905c0ab2
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Wed Aug 22 13:52:21 2018 +0200

    cfg80211: make wmm_rule part of the reg_rule structure
    
    Make wmm_rule be part of the reg_rule structure. This simplifies the
    code a lot at the cost of having bigger memory usage. However in most
    cases we have only few reg_rule's and when we do have many like in
    iwlwifi we do not save memory as it allocates a separate wmm_rule for
    each channel anyway.
    
    This also fixes a bug reported in various places where somewhere the
    pointers were corrupted and we ended up doing a null-dereference.
    
    Fixes: 230ebaa189af ("cfg80211: read wmm rules from regulatory database")
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    [rephrase commit message slightly]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 60f8cc86a447..3469750df0f4 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -217,15 +217,15 @@ struct ieee80211_wmm_rule {
 struct ieee80211_reg_rule {
 	struct ieee80211_freq_range freq_range;
 	struct ieee80211_power_rule power_rule;
-	struct ieee80211_wmm_rule *wmm_rule;
+	struct ieee80211_wmm_rule wmm_rule;
 	u32 flags;
 	u32 dfs_cac_ms;
+	bool has_wmm;
 };
 
 struct ieee80211_regdomain {
 	struct rcu_head rcu_head;
 	u32 n_reg_rules;
-	u32 n_wmm_rules;
 	char alpha2[3];
 	enum nl80211_dfs_regions dfs_region;
 	struct ieee80211_reg_rule reg_rules[];

commit 230ebaa189af44d50dccb4a1846e39ca594e347b
Author: Haim Dreyfuss <haim.dreyfuss@intel.com>
Date:   Wed Mar 28 13:24:09 2018 +0300

    cfg80211: read wmm rules from regulatory database
    
    ETSI EN 301 893 v2.1.1 (2017-05) standard defines a new channel access
    mechanism that all devices (WLAN and LAA) need to comply with.
    The regulatory database can now be loaded into the kernel and also
    has the option to load optional data.
    In order to be able to comply with ETSI standard, we add wmm_rule into
    regulatory rule and add the option to read its value from the regulatory
    database.
    
    Signed-off-by: Haim Dreyfuss <haim.dreyfuss@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    [johannes: fix memory leak in error path]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index f83cacce3308..60f8cc86a447 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -4,6 +4,7 @@
  * regulatory support structures
  *
  * Copyright 2008-2009	Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
+ * Copyright (C) 2018 Intel Corporation
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -188,9 +189,35 @@ struct ieee80211_power_rule {
 	u32 max_eirp;
 };
 
+/**
+ * struct ieee80211_wmm_ac - used to store per ac wmm regulatory limitation
+ *
+ * The information provided in this structure is required for QoS
+ * transmit queue configuration. Cf. IEEE 802.11 7.3.2.29.
+ *
+ * @cw_min: minimum contention window [a value of the form
+ *      2^n-1 in the range 1..32767]
+ * @cw_max: maximum contention window [like @cw_min]
+ * @cot: maximum burst time in units of 32 usecs, 0 meaning disabled
+ * @aifsn: arbitration interframe space [0..255]
+ *
+ */
+struct ieee80211_wmm_ac {
+	u16 cw_min;
+	u16 cw_max;
+	u16 cot;
+	u8 aifsn;
+};
+
+struct ieee80211_wmm_rule {
+	struct ieee80211_wmm_ac client[IEEE80211_NUM_ACS];
+	struct ieee80211_wmm_ac ap[IEEE80211_NUM_ACS];
+};
+
 struct ieee80211_reg_rule {
 	struct ieee80211_freq_range freq_range;
 	struct ieee80211_power_rule power_rule;
+	struct ieee80211_wmm_rule *wmm_rule;
 	u32 flags;
 	u32 dfs_cac_ms;
 };
@@ -198,6 +225,7 @@ struct ieee80211_reg_rule {
 struct ieee80211_regdomain {
 	struct rcu_head rcu_head;
 	u32 n_reg_rules;
+	u32 n_wmm_rules;
 	char alpha2[3];
 	enum nl80211_dfs_regions dfs_region;
 	struct ieee80211_reg_rule reg_rules[];

commit 657308f73e674e86b60509a430a46e569bf02846
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Feb 22 20:55:28 2018 +0100

    regulatory: add NUL to request alpha2
    
    Similar to the ancient commit a5fe8e7695dc ("regulatory: add NUL
    to alpha2"), add another byte to alpha2 in the request struct so
    that when we use nla_put_string(), we don't overrun anything.
    
    Fixes: 73d54c9e74c4 ("cfg80211: add regulatory netlink multicast group")
    Reported-by: Kees Cook <keescook@google.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index ebc5a2ed8631..f83cacce3308 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -78,7 +78,7 @@ struct regulatory_request {
 	int wiphy_idx;
 	enum nl80211_reg_initiator initiator;
 	enum nl80211_user_reg_hint_type user_reg_hint_type;
-	char alpha2[2];
+	char alpha2[3];
 	enum nl80211_dfs_regions dfs_region;
 	bool intersect;
 	bool processed;

commit b0d7aa59592b4270531de5ce65dcf18338a2d98c
Author: Jonathan Doron <jond@wizery.com>
Date:   Mon Dec 15 19:26:00 2014 +0200

    cfg80211: allow wiphy specific regdomain management
    
    Add a new regulatory flag that allows a driver to manage regdomain
    changes/updates for its own wiphy.
    A self-managed wiphys only employs regulatory information obtained from
    the FW and driver and does not use other cfg80211 sources like
    beacon-hints, country-code IEs and hints from other devices on the same
    system. Conversely, a self-managed wiphy does not share its regulatory
    hints with other devices in the system. If a system contains several
    devices, one or more of which are self-managed, there might be
    contradictory regulatory settings between them. Usage of flag is
    generally discouraged. Only use it if the FW/driver is incompatible
    with non-locally originated hints.
    
    A new API lets the driver send a complete regdomain, to be applied on
    its wiphy only.
    
    After a wiphy-specific regdomain change takes place, usermode will get
    a new type of change notification. The regulatory core also takes care
    enforce regulatory restrictions, in case some interfaces are on
    forbidden channels.
    
    Signed-off-by: Jonathan Doron <jonathanx.doron@intel.com>
    Signed-off-by: Arik Nemtsov <arikx.nemtsov@intel.com>
    Reviewed-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index b776d72d84be..ebc5a2ed8631 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -147,6 +147,24 @@ struct regulatory_request {
  *	NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_P2P_GO,
  *	NL80211_IFTYPE_P2P_DEVICE. The flag will be set by default if a device
  *	includes any modes unsupported for enforcement checking.
+ * @REGULATORY_WIPHY_SELF_MANAGED: for devices that employ wiphy-specific
+ *	regdom management. These devices will ignore all regdom changes not
+ *	originating from their own wiphy.
+ *	A self-managed wiphys only employs regulatory information obtained from
+ *	the FW and driver and does not use other cfg80211 sources like
+ *	beacon-hints, country-code IEs and hints from other devices on the same
+ *	system. Conversely, a self-managed wiphy does not share its regulatory
+ *	hints with other devices in the system. If a system contains several
+ *	devices, one or more of which are self-managed, there might be
+ *	contradictory regulatory settings between them. Usage of flag is
+ *	generally discouraged. Only use it if the FW/driver is incompatible
+ *	with non-locally originated hints.
+ *	This flag is incompatible with the flags: %REGULATORY_CUSTOM_REG,
+ *	%REGULATORY_STRICT_REG, %REGULATORY_COUNTRY_IE_FOLLOW_POWER,
+ *	%REGULATORY_COUNTRY_IE_IGNORE and %REGULATORY_DISABLE_BEACON_HINTS.
+ *	Mixing any of the above flags with this flag will result in a failure
+ *	to register the wiphy. This flag implies
+ *	%REGULATORY_DISABLE_BEACON_HINTS and %REGULATORY_COUNTRY_IE_IGNORE.
  */
 enum ieee80211_regulatory_flags {
 	REGULATORY_CUSTOM_REG			= BIT(0),
@@ -156,6 +174,7 @@ enum ieee80211_regulatory_flags {
 	REGULATORY_COUNTRY_IE_IGNORE		= BIT(4),
 	REGULATORY_ENABLE_RELAX_NO_IR           = BIT(5),
 	REGULATORY_IGNORE_STALE_KICKOFF         = BIT(6),
+	REGULATORY_WIPHY_SELF_MANAGED		= BIT(7),
 };
 
 struct ieee80211_freq_range {

commit ad932f046fbe9839479350e7b88082a7d1dea498
Author: Arik Nemtsov <arik@wizery.com>
Date:   Thu Nov 27 09:44:55 2014 +0200

    cfg80211: leave invalid channels on regdomain change
    
    When the regulatory settings change, some channels might become invalid.
    Disconnect interfaces acting on these channels, after giving userspace
    code a grace period to leave them.
    
    This mode is currently opt-in, and not all interface operating modes are
    supported for regulatory-enforcement checks. A wiphy that wishes to use
    the new enforcement code must specify an appropriate regulatory flag,
    and all its supported interface modes must be supported by the checking
    code.
    
    Signed-off-by: Arik Nemtsov <arikx.nemtsov@intel.com>
    Reviewed-by: Luis R. Rodriguez <mcgrof@suse.com>
    [fix some indentation, typos]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index dad7ab20a8cb..b776d72d84be 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -136,6 +136,17 @@ struct regulatory_request {
  *      otherwise initiating radiation is not allowed. This will enable the
  *      relaxations enabled under the CFG80211_REG_RELAX_NO_IR configuration
  *      option
+ * @REGULATORY_IGNORE_STALE_KICKOFF: the regulatory core will _not_ make sure
+ *	all interfaces on this wiphy reside on allowed channels. If this flag
+ *	is not set, upon a regdomain change, the interfaces are given a grace
+ *	period (currently 60 seconds) to disconnect or move to an allowed
+ *	channel. Interfaces on forbidden channels are forcibly disconnected.
+ *	Currently these types of interfaces are supported for enforcement:
+ *	NL80211_IFTYPE_ADHOC, NL80211_IFTYPE_STATION, NL80211_IFTYPE_AP,
+ *	NL80211_IFTYPE_AP_VLAN, NL80211_IFTYPE_MONITOR,
+ *	NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_P2P_GO,
+ *	NL80211_IFTYPE_P2P_DEVICE. The flag will be set by default if a device
+ *	includes any modes unsupported for enforcement checking.
  */
 enum ieee80211_regulatory_flags {
 	REGULATORY_CUSTOM_REG			= BIT(0),
@@ -144,6 +155,7 @@ enum ieee80211_regulatory_flags {
 	REGULATORY_COUNTRY_IE_FOLLOW_POWER	= BIT(3),
 	REGULATORY_COUNTRY_IE_IGNORE		= BIT(4),
 	REGULATORY_ENABLE_RELAX_NO_IR           = BIT(5),
+	REGULATORY_IGNORE_STALE_KICKOFF         = BIT(6),
 };
 
 struct ieee80211_freq_range {

commit a5fe8e7695dc3f547e955ad2b662e3e72969e506
Author: Eliad Peller <eliad@wizery.com>
Date:   Wed Jun 11 10:23:35 2014 +0300

    regulatory: add NUL to alpha2
    
    alpha2 is defined as 2-chars array, but is used in multiple
    places as string (e.g. with nla_put_string calls), which
    might leak kernel data.
    
    Solve it by simply adding an extra char for the NULL
    terminator, making such operations safe.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Eliad Peller <eliadx.peller@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 259992444e80..dad7ab20a8cb 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -167,7 +167,7 @@ struct ieee80211_reg_rule {
 struct ieee80211_regdomain {
 	struct rcu_head rcu_head;
 	u32 n_reg_rules;
-	char alpha2[2];
+	char alpha2[3];
 	enum nl80211_dfs_regions dfs_region;
 	struct ieee80211_reg_rule reg_rules[];
 };

commit 174e0cd28af0fe3c6c634c3e4d9e042c683bd7f7
Author: Ilan Peer <ilan.peer@intel.com>
Date:   Sun Feb 23 09:13:01 2014 +0200

    cfg80211: Enable GO operation on additional channels
    
    Allow GO operation on a channel marked with IEEE80211_CHAN_GO_CONCURRENT
    iff there is an active station interface that is associated to
    an AP operating on the same channel in the 2 GHz band or the same UNII band
    (in the 5 GHz band). This relaxation is not allowed if the channel is
    marked with IEEE80211_CHAN_RADAR.
    
    Note that this is a permissive approach to the FCC definitions,
    that require a clear assessment that the device operating the AP is
    an authorized master, i.e., with radar detection and DFS capabilities.
    
    It is assumed that such restrictions are enforced by user space.
    Furthermore, it is assumed, that if the conditions that allowed for
    the operation of the GO on such a channel change, i.e., the station
    interface disconnected from the AP, it is the responsibility of user
    space to evacuate the GO from the channel.
    
    Signed-off-by: Ilan Peer <ilan.peer@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 75fc1f5a948d..259992444e80 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -131,6 +131,11 @@ struct regulatory_request {
  * 	all country IE information processed by the regulatory core. This will
  * 	override %REGULATORY_COUNTRY_IE_FOLLOW_POWER as all country IEs will
  * 	be ignored.
+ * @REGULATORY_ENABLE_RELAX_NO_IR: for devices that wish to allow the
+ *      NO_IR relaxation, which enables transmissions on channels on which
+ *      otherwise initiating radiation is not allowed. This will enable the
+ *      relaxations enabled under the CFG80211_REG_RELAX_NO_IR configuration
+ *      option
  */
 enum ieee80211_regulatory_flags {
 	REGULATORY_CUSTOM_REG			= BIT(0),
@@ -138,6 +143,7 @@ enum ieee80211_regulatory_flags {
 	REGULATORY_DISABLE_BEACON_HINTS		= BIT(2),
 	REGULATORY_COUNTRY_IE_FOLLOW_POWER	= BIT(3),
 	REGULATORY_COUNTRY_IE_IGNORE		= BIT(4),
+	REGULATORY_ENABLE_RELAX_NO_IR           = BIT(5),
 };
 
 struct ieee80211_freq_range {

commit 089027e57cfa79337feffdd7252c8ba0be352afa
Author: Janusz Dziedzic <janusz.dziedzic@tieto.com>
Date:   Fri Feb 21 19:46:12 2014 +0100

    cfg80211: regulatory: allow getting DFS CAC time from userspace
    
    Introduce DFS CAC time as a regd param, configured per REG_RULE and
    set per channel in cfg80211. DFS CAC time is close connected with
    regulatory database configuration. Instead of using hardcoded values,
    get DFS CAC time form regulatory database. Pass DFS CAC time to user
    mode (mainly for iw reg get, iw list, iw info). Allow setting DFS CAC
    time via CRDA. Add support for internal regulatory database.
    
    Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
    [rewrap commit log]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index b07cdc9fa454..75fc1f5a948d 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -155,6 +155,7 @@ struct ieee80211_reg_rule {
 	struct ieee80211_freq_range freq_range;
 	struct ieee80211_power_rule power_rule;
 	u32 flags;
+	u32 dfs_cac_ms;
 };
 
 struct ieee80211_regdomain {
@@ -172,14 +173,18 @@ struct ieee80211_regdomain {
 #define DBM_TO_MBM(gain) ((gain) * 100)
 #define MBM_TO_DBM(gain) ((gain) / 100)
 
-#define REG_RULE(start, end, bw, gain, eirp, reg_flags) \
-{							\
-	.freq_range.start_freq_khz = MHZ_TO_KHZ(start),	\
-	.freq_range.end_freq_khz = MHZ_TO_KHZ(end),	\
-	.freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw),	\
-	.power_rule.max_antenna_gain = DBI_TO_MBI(gain),\
-	.power_rule.max_eirp = DBM_TO_MBM(eirp),	\
-	.flags = reg_flags,				\
+#define REG_RULE_EXT(start, end, bw, gain, eirp, dfs_cac, reg_flags)	\
+{									\
+	.freq_range.start_freq_khz = MHZ_TO_KHZ(start),			\
+	.freq_range.end_freq_khz = MHZ_TO_KHZ(end),			\
+	.freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw),			\
+	.power_rule.max_antenna_gain = DBI_TO_MBI(gain),		\
+	.power_rule.max_eirp = DBM_TO_MBM(eirp),			\
+	.flags = reg_flags,						\
+	.dfs_cac_ms = dfs_cac,						\
 }
 
+#define REG_RULE(start, end, bw, gain, eirp, reg_flags) \
+	REG_RULE_EXT(start, end, bw, gain, eirp, 0, reg_flags)
+
 #endif

commit 4f7b91404cd5da3657a82b00394f4f5dfbff13d6
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Sat Dec 14 20:09:06 2013 +0100

    cfg80211: make regulatory_hint() remove REGULATORY_CUSTOM_REG
    
    The REGULATORY_CUSTOM_REG can be used during early init with
    the goal of overriding the wiphy's default regulatory settings
    in case the alpha2 of the device is not known. In the case that
    the alpha2 becomes known lets avoid having drivers having to
    clear the REGULATORY_CUSTOM_REG flag by doing it for them
    when regulatory_hint() is used.
    
    Cc: Sujith Manoharan <c_manoha@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index c96a0b86f342..b07cdc9fa454 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -96,6 +96,10 @@ struct regulatory_request {
  *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
  *	wiphy_apply_custom_regulatory() should have this flag set
  *	or the regulatory core will set it for the wiphy.
+ *	If you use regulatory_hint() *after* using
+ *	wiphy_apply_custom_regulatory() the wireless core will
+ *	clear the REGULATORY_CUSTOM_REG for your wiphy as it would be
+ *	implied that the device somehow gained knowledge of its region.
  * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
  *	has regulatory domain that it wishes to be considered as the
  *	superset for regulatory rules. After this device gets its regulatory

commit 4c7d3982a6e37831382b9ef90aa0dbadc0bf3a22
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Wed Nov 13 18:54:02 2013 +0100

    cfg80211: use enum nl80211_dfs_regions for dfs_region everywhere
    
    u8 was used in some other places, just stick to the enum,
    this forces us to express the values that are expected.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 92ab80f69efe..c96a0b86f342 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -79,7 +79,7 @@ struct regulatory_request {
 	enum nl80211_reg_initiator initiator;
 	enum nl80211_user_reg_hint_type user_reg_hint_type;
 	char alpha2[2];
-	u8 dfs_region;
+	enum nl80211_dfs_regions dfs_region;
 	bool intersect;
 	bool processed;
 	enum environment_cap country_ie_env;
@@ -157,7 +157,7 @@ struct ieee80211_regdomain {
 	struct rcu_head rcu_head;
 	u32 n_reg_rules;
 	char alpha2[2];
-	u8 dfs_region;
+	enum nl80211_dfs_regions dfs_region;
 	struct ieee80211_reg_rule reg_rules[];
 };
 

commit 2a901468c221e778af52603e006a53d286e81f90
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Nov 11 22:15:31 2013 +0100

    cfg80211: add an option to disable processing country IEs
    
    Certain vendors may want to disable the processing of
    country IEs so that they can continue using the regulatory
    domain the driver or user has set.  Currently there is no
    way to stop the core from processing country IEs, so add
    support to the core to ignore country IE hints.
    
    Cc: Mihir Shete <smihir@qti.qualcomm.com>
    Cc: Henri Bahini <hbahini@qca.qualcomm.com>
    Cc: Tushnim Bhattacharyya <tushnimb@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index b03ddee3341d..92ab80f69efe 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -123,12 +123,17 @@ struct regulatory_request {
  *	derived from the regulatory domain. The regulatory domain used will be
  *	based on the ISO3166-alpha2 from country IE provided through
  *	regulatory_hint_country_ie()
+ * @REGULATORY_COUNTRY_IE_IGNORE: for devices that have a preference to ignore
+ * 	all country IE information processed by the regulatory core. This will
+ * 	override %REGULATORY_COUNTRY_IE_FOLLOW_POWER as all country IEs will
+ * 	be ignored.
  */
 enum ieee80211_regulatory_flags {
 	REGULATORY_CUSTOM_REG			= BIT(0),
 	REGULATORY_STRICT_REG			= BIT(1),
 	REGULATORY_DISABLE_BEACON_HINTS		= BIT(2),
 	REGULATORY_COUNTRY_IE_FOLLOW_POWER	= BIT(3),
+	REGULATORY_COUNTRY_IE_IGNORE		= BIT(4),
 };
 
 struct ieee80211_freq_range {

commit a09a85a013523a8b572dc5732b5c30e0785195f3
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Nov 11 22:15:30 2013 +0100

    cfg80211: add flags to define country IE processing rules
    
    802.11 cards may have different country IE parsing behavioural
    preferences and vendors may want to support these. These preferences
    were managed by the REGULATORY_CUSTOM_REG and the REGULATORY_STRICT_REG
    flags and their combination. Instead of using this existing notation,
    split out the country IE behavioural preferences as a new flag. This
    will allow us to add more customizations easily and make the code more
    maintainable.
    
    Cc: Mihir Shete <smihir@qti.qualcomm.com>
    Cc: Henri Bahini <hbahini@qca.qualcomm.com>
    Cc: Tushnim Bhattacharyya <tushnimb@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [fix up conflicts]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index a6a20e2a54c4..b03ddee3341d 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -96,27 +96,39 @@ struct regulatory_request {
  *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
  *	wiphy_apply_custom_regulatory() should have this flag set
  *	or the regulatory core will set it for the wiphy.
- * @REGULATORY_STRICT_REG: tells us the driver for this device will
- *	ignore regulatory domain settings until it gets its own regulatory
- *	domain via its regulatory_hint() unless the regulatory hint is
- *	from a country IE. After its gets its own regulatory domain it will
- *	only allow further regulatory domain settings to further enhance
- *	compliance. For example if channel 13 and 14 are disabled by this
- *	regulatory domain no user regulatory domain can enable these channels
- *	at a later time. This can be used for devices which do not have
- *	calibration information guaranteed for frequencies or settings
- *	outside of its regulatory domain. If used in combination with
- *	REGULATORY_FLAG_CUSTOM_REG the inspected country IE power settings
- *	will be followed.
+ * @REGULATORY_STRICT_REG: tells us that the wiphy for this device
+ *	has regulatory domain that it wishes to be considered as the
+ *	superset for regulatory rules. After this device gets its regulatory
+ *	domain programmed further regulatory hints shall only be considered
+ *	for this device to enhance regulatory compliance, forcing the
+ *	device to only possibly use subsets of the original regulatory
+ *	rules. For example if channel 13 and 14 are disabled by this
+ *	device's regulatory domain no user specified regulatory hint which
+ *	has these channels enabled would enable them for this wiphy,
+ *	the device's original regulatory domain will be trusted as the
+ *	base. You can program the superset of regulatory rules for this
+ *	wiphy with regulatory_hint() for cards programmed with an
+ *	ISO3166-alpha2 country code. wiphys that use regulatory_hint()
+ *	will have their wiphy->regd programmed once the regulatory
+ *	domain is set, and all other regulatory hints will be ignored
+ *	until their own regulatory domain gets programmed.
  * @REGULATORY_DISABLE_BEACON_HINTS: enable this if your driver needs to
  *	ensure that passive scan flags and beaconing flags may not be lifted by
  *	cfg80211 due to regulatory beacon hints. For more information on beacon
  *	hints read the documenation for regulatory_hint_found_beacon()
+ * @REGULATORY_COUNTRY_IE_FOLLOW_POWER:  for devices that have a preference
+ *	that even though they may have programmed their own custom power
+ *	setting prior to wiphy registration, they want to ensure their channel
+ *	power settings are updated for this connection with the power settings
+ *	derived from the regulatory domain. The regulatory domain used will be
+ *	based on the ISO3166-alpha2 from country IE provided through
+ *	regulatory_hint_country_ie()
  */
 enum ieee80211_regulatory_flags {
 	REGULATORY_CUSTOM_REG			= BIT(0),
 	REGULATORY_STRICT_REG			= BIT(1),
 	REGULATORY_DISABLE_BEACON_HINTS		= BIT(2),
+	REGULATORY_COUNTRY_IE_FOLLOW_POWER	= BIT(3),
 };
 
 struct ieee80211_freq_range {

commit a2f73b6c5db3c272d87eaebb5bed355d75a0f25f
Author: Luis R. Rodriguez <mcgrof@do-not-panic.com>
Date:   Mon Nov 11 22:15:29 2013 +0100

    cfg80211: move regulatory flags to their own variable
    
    We'll expand this later, this will make it easier to
    classify and review what things are related to regulatory
    or not.
    
    Coccinelle only missed 4 hits, which I had to do manually,
    supplying the SmPL in case of merge conflicts.
    
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY
    +wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG
    @@
    expression e;
    @@
    -e->flags |= WIPHY_FLAG_CUSTOM_REGULATORY
    +e->regulatory_flags |= REGULATORY_CUSTOM_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags &= ~WIPHY_FLAG_CUSTOM_REGULATORY
    +wiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags & WIPHY_FLAG_CUSTOM_REGULATORY
    +wiphy->regulatory_flags & REGULATORY_CUSTOM_REG
    
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY
    +wiphy->regulatory_flags |= REGULATORY_STRICT_REG
    @@
    expression e;
    @@
    -e->flags |= WIPHY_FLAG_STRICT_REGULATORY
    +e->regulatory_flags |= REGULATORY_STRICT_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY
    +wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags & WIPHY_FLAG_STRICT_REGULATORY
    +wiphy->regulatory_flags & REGULATORY_STRICT_REG
    
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS
    +wiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS
    @@
    expression e;
    @@
    -e->flags |= WIPHY_FLAG_DISABLE_BEACON_HINTS
    +e->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS
    +wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS
    @@
    struct wiphy *wiphy;
    @@
    -wiphy->flags & WIPHY_FLAG_DISABLE_BEACON_HINTS
    +wiphy->regulatory_flags & REGULATORY_DISABLE_BEACON_HINTS
    
    Generated-by: Coccinelle SmPL
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Cc: Peter Senna Tschudin <peter.senna@gmail.com>
    Cc: Mihir Shete <smihir@qti.qualcomm.com>
    Cc: Henri Bahini <hbahini@qca.qualcomm.com>
    Cc: Tushnim Bhattacharyya <tushnimb@qca.qualcomm.com>
    Signed-off-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    [fix up whitespace damage, overly long lines]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index f17ed590d64a..a6a20e2a54c4 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -38,17 +38,17 @@ enum environment_cap {
  *
  * @rcu_head: RCU head struct used to free the request
  * @wiphy_idx: this is set if this request's initiator is
- * 	%REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
- * 	can be used by the wireless core to deal with conflicts
- * 	and potentially inform users of which devices specifically
- * 	cased the conflicts.
+ *	%REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
+ *	can be used by the wireless core to deal with conflicts
+ *	and potentially inform users of which devices specifically
+ *	cased the conflicts.
  * @initiator: indicates who sent this request, could be any of
- * 	of those set in nl80211_reg_initiator (%NL80211_REGDOM_SET_BY_*)
+ *	of those set in nl80211_reg_initiator (%NL80211_REGDOM_SET_BY_*)
  * @alpha2: the ISO / IEC 3166 alpha2 country code of the requested
- * 	regulatory domain. We have a few special codes:
- * 	00 - World regulatory domain
- * 	99 - built by driver but a specific alpha2 cannot be determined
- * 	98 - result of an intersection between two regulatory domains
+ *	regulatory domain. We have a few special codes:
+ *	00 - World regulatory domain
+ *	99 - built by driver but a specific alpha2 cannot be determined
+ *	98 - result of an intersection between two regulatory domains
  *	97 - regulatory domain has not yet been configured
  * @dfs_region: If CRDA responded with a regulatory domain that requires
  *	DFS master operation on a known DFS region (NL80211_DFS_*),
@@ -59,8 +59,8 @@ enum environment_cap {
  *	of hint passed. This could be any of the %NL80211_USER_REG_HINT_*
  *	types.
  * @intersect: indicates whether the wireless core should intersect
- * 	the requested regulatory domain with the presently set regulatory
- * 	domain.
+ *	the requested regulatory domain with the presently set regulatory
+ *	domain.
  * @processed: indicates whether or not this requests has already been
  *	processed. When the last request is processed it means that the
  *	currently regulatory domain set on cfg80211 is updated from
@@ -68,9 +68,9 @@ enum environment_cap {
  *	the last request is not yet processed we must yield until it
  *	is processed before processing any new requests.
  * @country_ie_checksum: checksum of the last processed and accepted
- * 	country IE
+ *	country IE
  * @country_ie_env: lets us know if the AP is telling us we are outdoor,
- * 	indoor, or if it doesn't matter
+ *	indoor, or if it doesn't matter
  * @list: used to insert into the reg_requests_list linked list
  */
 struct regulatory_request {
@@ -86,6 +86,39 @@ struct regulatory_request {
 	struct list_head list;
 };
 
+/**
+ * enum ieee80211_regulatory_flags - device regulatory flags
+ *
+ * @REGULATORY_CUSTOM_REG: tells us the driver for this device
+ *	has its own custom regulatory domain and cannot identify the
+ *	ISO / IEC 3166 alpha2 it belongs to. When this is enabled
+ *	we will disregard the first regulatory hint (when the
+ *	initiator is %REGDOM_SET_BY_CORE). Drivers that use
+ *	wiphy_apply_custom_regulatory() should have this flag set
+ *	or the regulatory core will set it for the wiphy.
+ * @REGULATORY_STRICT_REG: tells us the driver for this device will
+ *	ignore regulatory domain settings until it gets its own regulatory
+ *	domain via its regulatory_hint() unless the regulatory hint is
+ *	from a country IE. After its gets its own regulatory domain it will
+ *	only allow further regulatory domain settings to further enhance
+ *	compliance. For example if channel 13 and 14 are disabled by this
+ *	regulatory domain no user regulatory domain can enable these channels
+ *	at a later time. This can be used for devices which do not have
+ *	calibration information guaranteed for frequencies or settings
+ *	outside of its regulatory domain. If used in combination with
+ *	REGULATORY_FLAG_CUSTOM_REG the inspected country IE power settings
+ *	will be followed.
+ * @REGULATORY_DISABLE_BEACON_HINTS: enable this if your driver needs to
+ *	ensure that passive scan flags and beaconing flags may not be lifted by
+ *	cfg80211 due to regulatory beacon hints. For more information on beacon
+ *	hints read the documenation for regulatory_hint_found_beacon()
+ */
+enum ieee80211_regulatory_flags {
+	REGULATORY_CUSTOM_REG			= BIT(0),
+	REGULATORY_STRICT_REG			= BIT(1),
+	REGULATORY_DISABLE_BEACON_HINTS		= BIT(2),
+};
+
 struct ieee80211_freq_range {
 	u32 start_freq_khz;
 	u32 end_freq_khz;

commit c492db370c17c428a0a58d3673294d4e99634b7d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 6 16:29:25 2012 +0100

    regulatory: use RCU to protect last_request
    
    This will allow making freq_reg_info() lock-free.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 96b0f07cb85b..f17ed590d64a 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -36,6 +36,7 @@ enum environment_cap {
 /**
  * struct regulatory_request - used to keep track of regulatory requests
  *
+ * @rcu_head: RCU head struct used to free the request
  * @wiphy_idx: this is set if this request's initiator is
  * 	%REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
  * 	can be used by the wireless core to deal with conflicts
@@ -73,6 +74,7 @@ enum environment_cap {
  * @list: used to insert into the reg_requests_list linked list
  */
 struct regulatory_request {
+	struct rcu_head rcu_head;
 	int wiphy_idx;
 	enum nl80211_reg_initiator initiator;
 	enum nl80211_user_reg_hint_type user_reg_hint_type;

commit 458f4f9e960b9a3b674c4b87d996eef186b1fe83
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 6 15:47:38 2012 +0100

    regulatory: use RCU to protect global and wiphy regdomains
    
    To simplify the locking and not require cfg80211_mutex
    (which nl80211 uses to access the global regdomain) and
    also to make it possible for drivers to access their
    wiphy->regd safely, use RCU to protect these pointers.
    
    Acked-by: Luis R. Rodriguez <mcgrof@do-not-panic.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 7dcaa2794fde..96b0f07cb85b 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -18,6 +18,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <linux/rcupdate.h>
 
 /**
  * enum environment_cap - Environment parsed from country IE
@@ -101,6 +102,7 @@ struct ieee80211_reg_rule {
 };
 
 struct ieee80211_regdomain {
+	struct rcu_head rcu_head;
 	u32 n_reg_rules;
 	char alpha2[2];
 	u8 dfs_region;

commit 57b5ce072e7361218a8e2ea1d62960cbb71d9cff
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Thu Jul 12 11:49:18 2012 -0700

    cfg80211: add cellular base station regulatory hint support
    
    Cellular base stations can provide hints to cfg80211 about
    where they think we are. This can be done for example on
    a cell phone. To enable these hints we simply allow them
    through as user regulatory hints but we allow userspace
    to clasify the hint as either coming directly from the
    user or coming from a cellular base station. This option
    is only available when you enable
    CONFIG_CFG80211_CERTIFICATION_ONUS.
    
    The base station hints themselves will not be processed
    by the core unless at least one device on the system
    supports this feature.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index a5f79933e211..7dcaa2794fde 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -52,6 +52,10 @@ enum environment_cap {
  *	DFS master operation on a known DFS region (NL80211_DFS_*),
  *	dfs_region represents that region. Drivers can use this and the
  *	@alpha2 to adjust their device's DFS parameters as required.
+ * @user_reg_hint_type: if the @initiator was of type
+ *	%NL80211_REGDOM_SET_BY_USER, this classifies the type
+ *	of hint passed. This could be any of the %NL80211_USER_REG_HINT_*
+ *	types.
  * @intersect: indicates whether the wireless core should intersect
  * 	the requested regulatory domain with the presently set regulatory
  * 	domain.
@@ -70,6 +74,7 @@ enum environment_cap {
 struct regulatory_request {
 	int wiphy_idx;
 	enum nl80211_reg_initiator initiator;
+	enum nl80211_user_reg_hint_type user_reg_hint_type;
 	char alpha2[2];
 	u8 dfs_region;
 	bool intersect;

commit b68e6b3b33b208c5690355fd9804ea65cc53d3a5
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Tue Oct 11 10:59:03 2011 -0700

    cfg80211: pass DFS region to drivers through reg_notifier()
    
    This grants drivers access to the DFS region that a
    regulatory domain belongs to.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 7399c93cb4bc..a5f79933e211 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -48,6 +48,10 @@ enum environment_cap {
  * 	99 - built by driver but a specific alpha2 cannot be determined
  * 	98 - result of an intersection between two regulatory domains
  *	97 - regulatory domain has not yet been configured
+ * @dfs_region: If CRDA responded with a regulatory domain that requires
+ *	DFS master operation on a known DFS region (NL80211_DFS_*),
+ *	dfs_region represents that region. Drivers can use this and the
+ *	@alpha2 to adjust their device's DFS parameters as required.
  * @intersect: indicates whether the wireless core should intersect
  * 	the requested regulatory domain with the presently set regulatory
  * 	domain.
@@ -67,6 +71,7 @@ struct regulatory_request {
 	int wiphy_idx;
 	enum nl80211_reg_initiator initiator;
 	char alpha2[2];
+	u8 dfs_region;
 	bool intersect;
 	bool processed;
 	enum environment_cap country_ie_env;

commit 8b60b07805d557542160d852874fa6a1b969184e
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Tue Oct 11 10:59:02 2011 -0700

    cfg80211: process regulatory DFS region for countries
    
    The wireless-regdb now has support for mapping a country to
    one DFS region. CRDA sends this to us now so process it
    so we can provide that hint to drivers. This will later be
    used by code for processing DFS in a way that meets the
    criteria for the DFS region the country belongs to.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index eb7d3c2d4274..7399c93cb4bc 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -93,6 +93,7 @@ struct ieee80211_reg_rule {
 struct ieee80211_regdomain {
 	u32 n_reg_rules;
 	char alpha2[2];
+	u8 dfs_region;
 	struct ieee80211_reg_rule reg_rules[];
 };
 

commit dde88b736f228be8bb2a831a4c373910d0b950fa
Author: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
Date:   Tue Aug 23 15:03:34 2011 -0700

    wireless: relicense regulatory header to ISC
    
    I will suck out stuff to userspace to start the regulatory
    revampamp, this work will be permissively licensed.
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 356d6e3dc20a..eb7d3c2d4274 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -3,11 +3,19 @@
 /*
  * regulatory support structures
  *
- * Copyright 2008-2009	Luis R. Rodriguez <lrodriguez@atheros.com>
+ * Copyright 2008-2009	Luis R. Rodriguez <mcgrof@qca.qualcomm.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
 

commit b2e253cf300c5e33f49b7dd8b593bfc722177401
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Wed Nov 17 21:46:09 2010 -0800

    cfg80211: Fix regulatory bug with multiple cards and delays
    
    When two cards are connected with the same regulatory domain
    if CRDA had a delayed response then cfg80211's own set regulatory
    domain would still be the world regulatory domain. There was a bug
    on cfg80211's logic such that it assumed that once you pegged a
    request as the last request it was already the currently set
    regulatory domain. This would mean we would race setting a stale
    regulatory domain to secondary cards which had the same regulatory
    domain since the alpha2 would match.
    
    We fix this by processing each regulatory request atomically,
    and only move on to the next one once we get it fully processed.
    In the case CRDA is not present we will simply world roam.
    
    This issue is only present when you have a slow system and the
    CRDA processing is delayed. Because of this it is not a known
    regression.
    
    Without this fix when a delay is present with CRDA the second card
    would end up with an intersected regulatory domain and not allow it
    to use the channels it really is designed for. When two cards with
    two different regulatory domains were inserted you'd end up
    rejecting the second card's regulatory domain request.
    This fails with mac80211_hswim's regtest=2 (two requests, same alpha2)
    and regtest=3 (two requests, different alpha2) module parameter
    options.
    
    This was reproduced and tested against mac80211_hwsim using this
    CRDA delayer:
    
           #!/bin/bash
           echo $COUNTRY >> /tmp/log
           sleep 2
           /sbin/crda.orig
    
    And these regulatory tests:
    
           modprobe mac80211_hwsim regtest=2
           modprobe mac80211_hwsim regtest=3
    
    Reported-by: Mark Mentovai <mark@moxienet.com>
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Tested-by: Mark Mentovai <mark@moxienet.com>
    Tested-by: Bruno Randolf <br1@einfach.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 9e103a4e91ee..356d6e3dc20a 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -43,6 +43,12 @@ enum environment_cap {
  * @intersect: indicates whether the wireless core should intersect
  * 	the requested regulatory domain with the presently set regulatory
  * 	domain.
+ * @processed: indicates whether or not this requests has already been
+ *	processed. When the last request is processed it means that the
+ *	currently regulatory domain set on cfg80211 is updated from
+ *	CRDA and can be used by other regulatory requests. When a
+ *	the last request is not yet processed we must yield until it
+ *	is processed before processing any new requests.
  * @country_ie_checksum: checksum of the last processed and accepted
  * 	country IE
  * @country_ie_env: lets us know if the AP is telling us we are outdoor,
@@ -54,6 +60,7 @@ struct regulatory_request {
 	enum nl80211_reg_initiator initiator;
 	char alpha2[2];
 	bool intersect;
+	bool processed;
 	enum environment_cap country_ie_env;
 	struct list_head list;
 };

commit 4f366c5dabcb936dd5754a35188bd699181fe1ce
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu Jul 15 14:57:33 2010 -0400

    wireless: only use alpha2 regulatory information from country IE
    
    The meaning and/or usage of the country IE is somewhat poorly defined.
    In practice, this means that regulatory rulesets in a country IE are
    often incomplete and might be untrustworthy.  This removes the code
    associated with interpreting those rulesets while preserving respect
    for country "alpha2" codes also contained in the country IE.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index f873ee37f7e4..9e103a4e91ee 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -54,7 +54,6 @@ struct regulatory_request {
 	enum nl80211_reg_initiator initiator;
 	char alpha2[2];
 	bool intersect;
-	u32 country_ie_checksum;
 	enum environment_cap country_ie_env;
 	struct list_head list;
 };

commit 09d989d179d0c679043556dda77c51b41a2dae7e
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Fri Jan 29 19:58:57 2010 -0500

    cfg80211: add regulatory hint disconnect support
    
    This adds a new regulatory hint to be used when we know all
    devices have been disconnected and idle. This can happen
    when we suspend, for instance. When we disconnect we can
    no longer assume the same regulatory rules learned from
    a country IE or beacon hints are applicable so restore
    regulatory settings to an initial state.
    
    Since driver hints are cached on the wiphy that called
    the hint, those hints are not reproduced onto cfg80211
    as the wiphy will respect its own wiphy->regd regardless.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
index 47995b81c5d7..f873ee37f7e4 100644
--- a/include/net/regulatory.h
+++ b/include/net/regulatory.h
@@ -39,6 +39,7 @@ enum environment_cap {
  * 	00 - World regulatory domain
  * 	99 - built by driver but a specific alpha2 cannot be determined
  * 	98 - result of an intersection between two regulatory domains
+ *	97 - regulatory domain has not yet been configured
  * @intersect: indicates whether the wireless core should intersect
  * 	the requested regulatory domain with the presently set regulatory
  * 	domain.

commit d323655372590c533c275b1d798f9d1221efb5c6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 20 14:31:42 2009 +0200

    cfg80211: clean up includes
    
    Trying to separate header files into net/wireless.h and
    net/cfg80211.h has been a source of confusion. Remove
    net/wireless.h (because there also is the linux/wireless.h)
    and subsume everything into net/cfg80211.h -- except the
    definitions for regulatory structures which get moved to
    a new header net/regulatory.h.
    
    The "new" net/cfg80211.h is now divided into sections.
    
    There are no real changes in this patch but code shuffling
    and some very minor documentation fixes.
    
    I have also, to make things reflect reality, put in a
    copyright line for Luis to net/regulatory.h since that
    is probably exclusively written by him but was formerly
    in a file that only had my copyright line.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/net/regulatory.h b/include/net/regulatory.h
new file mode 100644
index 000000000000..47995b81c5d7
--- /dev/null
+++ b/include/net/regulatory.h
@@ -0,0 +1,101 @@
+#ifndef __NET_REGULATORY_H
+#define __NET_REGULATORY_H
+/*
+ * regulatory support structures
+ *
+ * Copyright 2008-2009	Luis R. Rodriguez <lrodriguez@atheros.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+/**
+ * enum environment_cap - Environment parsed from country IE
+ * @ENVIRON_ANY: indicates country IE applies to both indoor and
+ *	outdoor operation.
+ * @ENVIRON_INDOOR: indicates country IE applies only to indoor operation
+ * @ENVIRON_OUTDOOR: indicates country IE applies only to outdoor operation
+ */
+enum environment_cap {
+	ENVIRON_ANY,
+	ENVIRON_INDOOR,
+	ENVIRON_OUTDOOR,
+};
+
+/**
+ * struct regulatory_request - used to keep track of regulatory requests
+ *
+ * @wiphy_idx: this is set if this request's initiator is
+ * 	%REGDOM_SET_BY_COUNTRY_IE or %REGDOM_SET_BY_DRIVER. This
+ * 	can be used by the wireless core to deal with conflicts
+ * 	and potentially inform users of which devices specifically
+ * 	cased the conflicts.
+ * @initiator: indicates who sent this request, could be any of
+ * 	of those set in nl80211_reg_initiator (%NL80211_REGDOM_SET_BY_*)
+ * @alpha2: the ISO / IEC 3166 alpha2 country code of the requested
+ * 	regulatory domain. We have a few special codes:
+ * 	00 - World regulatory domain
+ * 	99 - built by driver but a specific alpha2 cannot be determined
+ * 	98 - result of an intersection between two regulatory domains
+ * @intersect: indicates whether the wireless core should intersect
+ * 	the requested regulatory domain with the presently set regulatory
+ * 	domain.
+ * @country_ie_checksum: checksum of the last processed and accepted
+ * 	country IE
+ * @country_ie_env: lets us know if the AP is telling us we are outdoor,
+ * 	indoor, or if it doesn't matter
+ * @list: used to insert into the reg_requests_list linked list
+ */
+struct regulatory_request {
+	int wiphy_idx;
+	enum nl80211_reg_initiator initiator;
+	char alpha2[2];
+	bool intersect;
+	u32 country_ie_checksum;
+	enum environment_cap country_ie_env;
+	struct list_head list;
+};
+
+struct ieee80211_freq_range {
+	u32 start_freq_khz;
+	u32 end_freq_khz;
+	u32 max_bandwidth_khz;
+};
+
+struct ieee80211_power_rule {
+	u32 max_antenna_gain;
+	u32 max_eirp;
+};
+
+struct ieee80211_reg_rule {
+	struct ieee80211_freq_range freq_range;
+	struct ieee80211_power_rule power_rule;
+	u32 flags;
+};
+
+struct ieee80211_regdomain {
+	u32 n_reg_rules;
+	char alpha2[2];
+	struct ieee80211_reg_rule reg_rules[];
+};
+
+#define MHZ_TO_KHZ(freq) ((freq) * 1000)
+#define KHZ_TO_MHZ(freq) ((freq) / 1000)
+#define DBI_TO_MBI(gain) ((gain) * 100)
+#define MBI_TO_DBI(gain) ((gain) / 100)
+#define DBM_TO_MBM(gain) ((gain) * 100)
+#define MBM_TO_DBM(gain) ((gain) / 100)
+
+#define REG_RULE(start, end, bw, gain, eirp, reg_flags) \
+{							\
+	.freq_range.start_freq_khz = MHZ_TO_KHZ(start),	\
+	.freq_range.end_freq_khz = MHZ_TO_KHZ(end),	\
+	.freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw),	\
+	.power_rule.max_antenna_gain = DBI_TO_MBI(gain),\
+	.power_rule.max_eirp = DBM_TO_MBM(eirp),	\
+	.flags = reg_flags,				\
+}
+
+#endif
