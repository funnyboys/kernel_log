commit b75326c201242de9495ff98e5d5cff41d7fc0d9d
Author: Fernando Gont <fgont@si6networks.com>
Date:   Sun Apr 19 09:24:57 2020 -0300

    ipv6: Honor all IPv6 PIO Valid Lifetime values
    
    RFC4862 5.5.3 e) prevents received Router Advertisements from reducing
    the Valid Lifetime of configured addresses to less than two hours, thus
    preventing hosts from reacting to the information provided by a router
    that has positive knowledge that a prefix has become invalid.
    
    This patch makes hosts honor all Valid Lifetime values, as per
    draft-gont-6man-slaac-renum-06, Section 4.2. This is meant to help
    mitigate the problem discussed in draft-ietf-v6ops-slaac-renum.
    
    Note: Attacks aiming at disabling an advertised prefix via a Valid
    Lifetime of 0 are not really more harmful than other attacks
    that can be performed via forged RA messages, such as those
    aiming at completely disabling a next-hop router via an RA that
    advertises a Router Lifetime of 0, or performing a Denial of
    Service (DoS) attack by advertising illegitimate prefixes via
    forged PIOs.  In scenarios where RA-based attacks are of concern,
    proper mitigations such as RA-Guard [RFC6105] [RFC7113] should
    be implemented.
    
    Signed-off-by: Fernando Gont <fgont@si6networks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index e0eabe58aa8b..fdb07105384c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -6,8 +6,6 @@
 #define RTR_SOLICITATION_INTERVAL	(4*HZ)
 #define RTR_SOLICITATION_MAX_INTERVAL	(3600*HZ)	/* 1 hour */
 
-#define MIN_VALID_LIFETIME		(2*3600)	/* 2 hours */
-
 #define TEMP_VALID_LIFETIME		(7*86400)
 #define TEMP_PREFERRED_LIFETIME		(86400)
 #define REGEN_MAX_RETRY			(3)

commit f37c6059363403d528acf8d530bb6e8a5666a875
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Mar 27 18:00:19 2020 -0400

    addrconf: add functionality to check on rpl requirements
    
    This patch adds a functionality to addrconf to check on a specific RPL
    address configuration. According to RFC 6554:
    
    To detect loops in the SRH, a router MUST determine if the SRH
    includes multiple addresses assigned to any interface on that
    router. If such addresses appear more than once and are separated by
    at least one address not assigned to that router.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index a088349dd94f..e0eabe58aa8b 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -90,6 +90,9 @@ int ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,
 int ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr);
 #endif
 
+int ipv6_chk_rpl_srh_loop(struct net *net, const struct in6_addr *segs,
+			  unsigned char nsegs);
+
 bool ipv6_chk_custom_prefix(const struct in6_addr *addr,
 				   const unsigned int prefix_len,
 				   struct net_device *dev);

commit 54e1f08bddbe63a3c0ae44f65df2c8b895003ef4
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Dec 13 21:24:28 2019 +0100

    ipv6: Annotate ipv6_addr_is_* bitwise pointer casts
    
    The sparse commit 6002ded74587 ("add a flag to warn on casts to/from
    bitwise pointers") introduced a check for non-direct casts from/to
    restricted datatypes (when -Wbitwise-pointer is enabled).
    
    This triggered a warning in the 64 bit optimized ipv6_addr_is_*() functions
    because sparse doesn't know that the buffer already points to some data in
    the correct bitwise integer format. But these were correct and can
    therefore be marked with __force to signalize sparse an intended cast to a
    specific bitwise type.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 1bab88184d3c..a088349dd94f 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -437,7 +437,7 @@ static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
 static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__be64 *p = (__be64 *)addr;
+	__be64 *p = (__force __be64 *)addr;
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(1))) == 0UL;
 #else
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
@@ -449,7 +449,7 @@ static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 static inline bool ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__be64 *p = (__be64 *)addr;
+	__be64 *p = (__force __be64 *)addr;
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(2))) == 0UL;
 #else
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
@@ -466,7 +466,7 @@ static inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)
 static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__be64 *p = (__be64 *)addr;
+	__be64 *p = (__force __be64 *)addr;
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |
 		((p[1] ^ cpu_to_be64(0x00000001ff000000UL)) &
 		 cpu_to_be64(0xffffffffff000000UL))) == 0UL;
@@ -481,7 +481,7 @@ static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
 static inline bool ipv6_addr_is_all_snoopers(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__be64 *p = (__be64 *)addr;
+	__be64 *p = (__force __be64 *)addr;
 
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |
 		(p[1] ^ cpu_to_be64(0x6a))) == 0UL;

commit 328908621081c3c7455c39549c5334e74b7c525a
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 7 09:37:27 2019 -0400

    ipv6: Make ipv6_mc_may_pull() return bool.
    
    Consistent with how pskb_may_pull() also now does so.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 3f62b347b04a..1bab88184d3c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -202,11 +202,11 @@ u32 ipv6_addr_label(struct net *net, const struct in6_addr *addr,
 /*
  *	multicast prototypes (mcast.c)
  */
-static inline int ipv6_mc_may_pull(struct sk_buff *skb,
-				   unsigned int len)
+static inline bool ipv6_mc_may_pull(struct sk_buff *skb,
+				    unsigned int len)
 {
 	if (skb_transport_offset(skb) + ipv6_transport_len(skb) < len)
-		return 0;
+		return false;
 
 	return pskb_may_pull(skb, len);
 }

commit 3a7ef457e85173a5b9ec7a03016db5a57b717b33
Author: Stefano Brivio <sbrivio@redhat.com>
Date:   Tue Aug 13 00:46:01 2019 +0200

    ipv6: Fix return value of ipv6_mc_may_pull() for malformed packets
    
    Commit ba5ea614622d ("bridge: simplify ip_mc_check_igmp() and
    ipv6_mc_check_mld() calls") replaces direct calls to pskb_may_pull()
    in br_ipv6_multicast_mld2_report() with calls to ipv6_mc_may_pull(),
    that returns -EINVAL on buffers too short to be valid IPv6 packets,
    while maintaining the previous handling of the return code.
    
    This leads to the direct opposite of the intended effect: if the
    packet is malformed, -EINVAL evaluates as true, and we'll happily
    proceed with the processing.
    
    Return 0 if the packet is too short, in the same way as this was
    fixed for IPv4 by commit 083b78a9ed64 ("ip: fix ip_mc_may_pull()
    return value").
    
    I don't have a reproducer for this, unlike the one referred to by
    the IPv4 commit, but this is clearly broken.
    
    Fixes: ba5ea614622d ("bridge: simplify ip_mc_check_igmp() and ipv6_mc_check_mld() calls")
    Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
    Acked-by: Guillaume Nault <gnault@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index becdad576859..3f62b347b04a 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -206,7 +206,7 @@ static inline int ipv6_mc_may_pull(struct sk_buff *skb,
 				   unsigned int len)
 {
 	if (skb_transport_offset(skb) + ipv6_transport_len(skb) < len)
-		return -EINVAL;
+		return 0;
 
 	return pskb_may_pull(skb, len);
 }

commit e1ae5c2ea4783b1fd87be250f9fcc9d9e1a6ba3f
Author: Stephen Suryaputra <ssuryaextr@gmail.com>
Date:   Mon Jun 10 10:32:50 2019 -0400

    vrf: Increment Icmp6InMsgs on the original netdev
    
    Get the ingress interface and increment ICMP counters based on that
    instead of skb->dev when the the dev is a VRF device.
    
    This is a follow up on the following message:
    https://www.spinics.net/lists/netdev/msg560268.html
    
    v2: Avoid changing skb->dev since it has unintended effect for local
        delivery (David Ahern).
    Signed-off-by: Stephen Suryaputra <ssuryaextr@gmail.com>
    Reviewed-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 2f67ae854ff0..becdad576859 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -309,6 +309,22 @@ static inline struct inet6_dev *__in6_dev_get(const struct net_device *dev)
 	return rcu_dereference_rtnl(dev->ip6_ptr);
 }
 
+/**
+ * __in6_dev_stats_get - get inet6_dev pointer for stats
+ * @dev: network device
+ * @skb: skb for original incoming interface if neeeded
+ *
+ * Caller must hold rcu_read_lock or RTNL, because this function
+ * does not take a reference on the inet6_dev.
+ */
+static inline struct inet6_dev *__in6_dev_stats_get(const struct net_device *dev,
+						    const struct sk_buff *skb)
+{
+	if (netif_is_l3_master(dev))
+		dev = dev_get_by_index_rcu(dev_net(dev), inet6_iif(skb));
+	return __in6_dev_get(dev);
+}
+
 /**
  * __in6_dev_get_safely - get inet6_dev pointer from netdevice
  * @dev: network device

commit 3616d08bcbb564c7765187cd45ad392e49bad73a
Author: David Ahern <dsahern@gmail.com>
Date:   Fri Mar 22 06:06:09 2019 -0700

    ipv6: Move ipv6 stubs to a separate header file
    
    The number of stubs is growing and has nothing to do with addrconf.
    Move the definition of the stubs to a separate header file and update
    users. In the move, drop the vxlan specific comment before ipv6_stub.
    
    Code move only; no functional change intended.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index ec8e6784a6f7..2f67ae854ff0 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -238,53 +238,6 @@ bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
 
 void ipv6_mc_dad_complete(struct inet6_dev *idev);
 
-/* A stub used by vxlan module. This is ugly, ideally these
- * symbols should be built into the core kernel.
- */
-struct ipv6_stub {
-	int (*ipv6_sock_mc_join)(struct sock *sk, int ifindex,
-				 const struct in6_addr *addr);
-	int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
-				 const struct in6_addr *addr);
-	int (*ipv6_dst_lookup)(struct net *net, struct sock *sk,
-			       struct dst_entry **dst, struct flowi6 *fl6);
-	int (*ipv6_route_input)(struct sk_buff *skb);
-
-	struct fib6_table *(*fib6_get_table)(struct net *net, u32 id);
-	struct fib6_info *(*fib6_lookup)(struct net *net, int oif,
-					 struct flowi6 *fl6, int flags);
-	struct fib6_info *(*fib6_table_lookup)(struct net *net,
-					      struct fib6_table *table,
-					      int oif, struct flowi6 *fl6,
-					      int flags);
-	struct fib6_info *(*fib6_multipath_select)(const struct net *net,
-						   struct fib6_info *f6i,
-						   struct flowi6 *fl6, int oif,
-						   const struct sk_buff *skb,
-						   int strict);
-	u32 (*ip6_mtu_from_fib6)(struct fib6_info *f6i, struct in6_addr *daddr,
-				 struct in6_addr *saddr);
-
-	void (*udpv6_encap_enable)(void);
-	void (*ndisc_send_na)(struct net_device *dev, const struct in6_addr *daddr,
-			      const struct in6_addr *solicited_addr,
-			      bool router, bool solicited, bool override, bool inc_opt);
-	struct neigh_table *nd_tbl;
-};
-extern const struct ipv6_stub *ipv6_stub __read_mostly;
-
-/* A stub used by bpf helpers. Similarly ugly as ipv6_stub */
-struct ipv6_bpf_stub {
-	int (*inet6_bind)(struct sock *sk, struct sockaddr *uaddr, int addr_len,
-			  bool force_bind_address_no_port, bool with_lock);
-	struct sock *(*udp6_lib_lookup)(struct net *net,
-					const struct in6_addr *saddr, __be16 sport,
-					const struct in6_addr *daddr, __be16 dport,
-					int dif, int sdif, struct udp_table *tbl,
-					struct sk_buff *skb);
-};
-extern const struct ipv6_bpf_stub *ipv6_bpf_stub __read_mostly;
-
 /*
  * identify MLD packets for MLD filter exceptions
  */

commit 6d3d07b45c86f984424ccbad110ca500397fd18c
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Mar 27 20:53:53 2019 -0700

    ipv6: Refactor fib6_ignore_linkdown
    
    fib6_ignore_linkdown takes a fib6_info but only looks at the net_device
    and its IPv6 config. Change it to take a net_device over a fib6_info as
    its input argument.
    
    In addition, move it to a header file to make the check inline and usable
    later with IPv4 code without going through the ipv6 stub, and rename to
    ip6_ignore_linkdown since it is only checking the setting based on the
    ipv6 struct on a device.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 269ec27385e9..ec8e6784a6f7 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -425,6 +425,14 @@ static inline void in6_dev_hold(struct inet6_dev *idev)
 	refcount_inc(&idev->refcnt);
 }
 
+/* called with rcu_read_lock held */
+static inline bool ip6_ignore_linkdown(const struct net_device *dev)
+{
+	const struct inet6_dev *idev = __in6_dev_get(dev);
+
+	return !!idev->cnf.ignore_routes_with_linkdown;
+}
+
 void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);
 
 static inline void in6_ifa_put(struct inet6_ifaddr *ifp)

commit 9b0a6a9dbab0ae092d033e67dc2701e8a7b09cdb
Author: Peter Oskolkov <posk@google.com>
Date:   Wed Feb 13 11:53:38 2019 -0800

    ipv6_stub: add ipv6_route_input stub/proxy.
    
    Proxy ip6_route_input via ipv6_stub, for later use by lwt bpf ip encap
    (see the next patch in the patchset).
    
    Signed-off-by: Peter Oskolkov <posk@google.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 20d523ee2fec..269ec27385e9 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -248,6 +248,7 @@ struct ipv6_stub {
 				 const struct in6_addr *addr);
 	int (*ipv6_dst_lookup)(struct net *net, struct sock *sk,
 			       struct dst_entry **dst, struct flowi6 *fl6);
+	int (*ipv6_route_input)(struct sk_buff *skb);
 
 	struct fib6_table *(*fib6_get_table)(struct net *net, u32 id);
 	struct fib6_info *(*fib6_lookup)(struct net *net, int oif,

commit 4b3087c7e37f9e499127201849e33960dc81da11
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Mon Jan 21 07:26:28 2019 +0100

    bridge: Snoop Multicast Router Advertisements
    
    When multiple multicast routers are present in a broadcast domain then
    only one of them will be detectable via IGMP/MLD query snooping. The
    multicast router with the lowest IP address will become the selected and
    active querier while all other multicast routers will then refrain from
    sending queries.
    
    To detect such rather silent multicast routers, too, RFC4286
    ("Multicast Router Discovery") provides a standardized protocol to
    detect multicast routers for multicast snooping switches.
    
    This patch implements the necessary MRD Advertisement message parsing
    and after successful processing adds such routers to the internal
    multicast router list.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index daf11dcb0f70..20d523ee2fec 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -229,6 +229,7 @@ void ipv6_mc_unmap(struct inet6_dev *idev);
 void ipv6_mc_remap(struct inet6_dev *idev);
 void ipv6_mc_init_dev(struct inet6_dev *idev);
 void ipv6_mc_destroy_dev(struct inet6_dev *idev);
+int ipv6_mc_check_icmpv6(struct sk_buff *skb);
 int ipv6_mc_check_mld(struct sk_buff *skb);
 void addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp);
 
@@ -499,6 +500,20 @@ static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
 #endif
 }
 
+static inline bool ipv6_addr_is_all_snoopers(const struct in6_addr *addr)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
+	__be64 *p = (__be64 *)addr;
+
+	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |
+		(p[1] ^ cpu_to_be64(0x6a))) == 0UL;
+#else
+	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
+		addr->s6_addr32[1] | addr->s6_addr32[2] |
+		(addr->s6_addr32[3] ^ htonl(0x0000006a))) == 0;
+#endif
+}
+
 #ifdef CONFIG_PROC_FS
 int if6_proc_init(void);
 void if6_proc_exit(void);

commit ba5ea614622dca6d675b4cc8a97270569ae13a23
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Mon Jan 21 07:26:25 2019 +0100

    bridge: simplify ip_mc_check_igmp() and ipv6_mc_check_mld() calls
    
    This patch refactors ip_mc_check_igmp(), ipv6_mc_check_mld() and
    their callers (more precisely, the Linux bridge) to not rely on
    the skb_trimmed parameter anymore.
    
    An skb with its tail trimmed to the IP packet length was initially
    introduced for the following three reasons:
    
    1) To be able to verify the ICMPv6 checksum.
    2) To be able to distinguish the version of an IGMP or MLD query.
       They are distinguishable only by their size.
    3) To avoid parsing data for an IGMPv3 or MLDv2 report that is
       beyond the IP packet but still within the skb.
    
    The first case still uses a cloned and potentially trimmed skb to
    verfiy. However, there is no need to propagate it to the caller.
    For the second and third case explicit IP packet length checks were
    added.
    
    This hopefully makes ip_mc_check_igmp() and ipv6_mc_check_mld() easier
    to read and verfiy, as well as easier to use.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 1656c5978498..daf11dcb0f70 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -49,6 +49,7 @@ struct prefix_info {
 	struct in6_addr		prefix;
 };
 
+#include <linux/ipv6.h>
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
 #include <net/ipv6.h>
@@ -201,6 +202,15 @@ u32 ipv6_addr_label(struct net *net, const struct in6_addr *addr,
 /*
  *	multicast prototypes (mcast.c)
  */
+static inline int ipv6_mc_may_pull(struct sk_buff *skb,
+				   unsigned int len)
+{
+	if (skb_transport_offset(skb) + ipv6_transport_len(skb) < len)
+		return -EINVAL;
+
+	return pskb_may_pull(skb, len);
+}
+
 int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 		      const struct in6_addr *addr);
 int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
@@ -219,7 +229,7 @@ void ipv6_mc_unmap(struct inet6_dev *idev);
 void ipv6_mc_remap(struct inet6_dev *idev);
 void ipv6_mc_init_dev(struct inet6_dev *idev);
 void ipv6_mc_destroy_dev(struct inet6_dev *idev);
-int ipv6_mc_check_mld(struct sk_buff *skb, struct sk_buff **skb_trimmed);
+int ipv6_mc_check_mld(struct sk_buff *skb);
 void addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp);
 
 bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,

commit 2384d02520ff2a916169b2fd85ea50e923ed56c2
Author: Jeff Barnhill <0xeffeff@gmail.com>
Date:   Fri Nov 2 20:23:57 2018 +0000

    net/ipv6: Add anycast addresses to a global hashtable
    
    icmp6_send() function is expensive on systems with a large number of
    interfaces. Every time it’s called, it has to verify that the source
    address does not correspond to an existing anycast address by looping
    through every device and every anycast address on the device.  This can
    result in significant delays for a CPU when there are a large number of
    neighbors and ND timers are frequently timing out and calling
    neigh_invalidate().
    
    Add anycast addresses to a global hashtable to allow quick searching for
    matching anycast addresses.  This is based on inet6_addr_lst in addrconf.c.
    
    Signed-off-by: Jeff Barnhill <0xeffeff@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 14b789a123e7..1656c5978498 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -317,6 +317,8 @@ bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 			 const struct in6_addr *addr);
 bool ipv6_chk_acast_addr_src(struct net *net, struct net_device *dev,
 			     const struct in6_addr *addr);
+int ipv6_anycast_init(void);
+void ipv6_anycast_cleanup(void);
 
 /* Device notifier */
 int register_inet6addr_notifier(struct notifier_block *nb);

commit 8a615c6b0352a9ec56151b6c95d68e0a2eef5cf0
Author: Joe Stringer <joe@wand.net.nz>
Date:   Mon Oct 15 10:27:45 2018 -0700

    bpf: Allow sk_lookup with IPv6 module
    
    This is a more complete fix than d71019b54bff ("net: core: Fix build
    with CONFIG_IPV6=m"), so that IPv6 sockets may be looked up if the IPv6
    module is loaded (not just if it's compiled in).
    
    Signed-off-by: Joe Stringer <joe@wand.net.nz>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 6def0351bcc3..14b789a123e7 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -265,6 +265,11 @@ extern const struct ipv6_stub *ipv6_stub __read_mostly;
 struct ipv6_bpf_stub {
 	int (*inet6_bind)(struct sock *sk, struct sockaddr *uaddr, int addr_len,
 			  bool force_bind_address_no_port, bool with_lock);
+	struct sock *(*udp6_lib_lookup)(struct net *net,
+					const struct in6_addr *saddr, __be16 sport,
+					const struct in6_addr *daddr, __be16 dport,
+					int dif, int sdif, struct udp_table *tbl,
+					struct sk_buff *skb);
 };
 extern const struct ipv6_bpf_stub *ipv6_bpf_stub __read_mostly;
 

commit 2dbb9b9e6df67d444fbe425c7f6014858d337adf
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Wed Aug 8 01:01:25 2018 -0700

    bpf: Introduce BPF_PROG_TYPE_SK_REUSEPORT
    
    This patch adds a BPF_PROG_TYPE_SK_REUSEPORT which can select
    a SO_REUSEPORT sk from a BPF_MAP_TYPE_REUSEPORT_ARRAY.  Like other
    non SK_FILTER/CGROUP_SKB program, it requires CAP_SYS_ADMIN.
    
    BPF_PROG_TYPE_SK_REUSEPORT introduces "struct sk_reuseport_kern"
    to store the bpf context instead of using the skb->cb[48].
    
    At the SO_REUSEPORT sk lookup time, it is in the middle of transiting
    from a lower layer (ipv4/ipv6) to a upper layer (udp/tcp).  At this
    point,  it is not always clear where the bpf context can be appended
    in the skb->cb[48] to avoid saving-and-restoring cb[].  Even putting
    aside the difference between ipv4-vs-ipv6 and udp-vs-tcp.  It is not
    clear if the lower layer is only ipv4 and ipv6 in the future and
    will it not touch the cb[] again before transiting to the upper
    layer.
    
    For example, in udp_gro_receive(), it uses the 48 byte NAPI_GRO_CB
    instead of IP[6]CB and it may still modify the cb[] after calling
    the udp[46]_lib_lookup_skb().  Because of the above reason, if
    sk->cb is used for the bpf ctx, saving-and-restoring is needed
    and likely the whole 48 bytes cb[] has to be saved and restored.
    
    Instead of saving, setting and restoring the cb[], this patch opts
    to create a new "struct sk_reuseport_kern" and setting the needed
    values in there.
    
    The new BPF_PROG_TYPE_SK_REUSEPORT and "struct sk_reuseport_(kern|md)"
    will serve all ipv4/ipv6 + udp/tcp combinations.  There is no protocol
    specific usage at this point and it is also inline with the current
    sock_reuseport.c implementation (i.e. no protocol specific requirement).
    
    In "struct sk_reuseport_md", this patch exposes data/data_end/len
    with semantic similar to other existing usages.  Together
    with "bpf_skb_load_bytes()" and "bpf_skb_load_bytes_relative()",
    the bpf prog can peek anywhere in the skb.  The "bind_inany" tells
    the bpf prog that the reuseport group is bind-ed to a local
    INANY address which cannot be learned from skb.
    
    The new "bind_inany" is added to "struct sock_reuseport" which will be
    used when running the new "BPF_PROG_TYPE_SK_REUSEPORT" bpf prog in order
    to avoid repeating the "bind INANY" test on
    "sk_v6_rcv_saddr/sk->sk_rcv_saddr" every time a bpf prog is run.  It can
    only be properly initialized when a "sk->sk_reuseport" enabled sk is
    adding to a hashtable (i.e. during "reuseport_alloc()" and
    "reuseport_add_sock()").
    
    The new "sk_select_reuseport()" is the main helper that the
    bpf prog will use to select a SO_REUSEPORT sk.  It is the only function
    that can use the new BPF_MAP_TYPE_REUSEPORT_ARRAY.  As mentioned in
    the earlier patch, the validity of a selected sk is checked in
    run time in "sk_select_reuseport()".  Doing the check in
    verification time is difficult and inflexible (consider the map-in-map
    use case).  The runtime check is to compare the selected sk's reuseport_id
    with the reuseport_id that we want.  This helper will return -EXXX if the
    selected sk cannot serve the incoming request (e.g. reuseport_id
    not match).  The bpf prog can decide if it wants to do SK_DROP as its
    discretion.
    
    When the bpf prog returns SK_PASS, the kernel will check if a
    valid sk has been selected (i.e. "reuse_kern->selected_sk != NULL").
    If it does , it will use the selected sk.  If not, the kernel
    will select one from "reuse->socks[]" (as before this patch).
    
    The SK_DROP and SK_PASS handling logic will be in the next patch.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 5f43f7a70fe6..6def0351bcc3 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -108,6 +108,7 @@ int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    u32 banned_flags);
 bool inet_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
 			  bool match_wildcard);
+bool inet_rcv_saddr_any(const struct sock *sk);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 

commit 8308f3ff1753d001f7a73f9bb0f02292b5400557
Author: David Ahern <dsahern@gmail.com>
Date:   Sun May 27 08:09:58 2018 -0700

    net/ipv6: Add support for specifying metric of connected routes
    
    Add support for IFA_RT_PRIORITY to ipv6 addresses.
    
    If the metric is changed on an existing address then the new route
    is inserted before removing the old one. Since the metric is one
    of the route keys, the prefix route can not be atomically replaced.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f766af2cd1a4..5f43f7a70fe6 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -65,6 +65,7 @@ struct ifa6_config {
 
 	const struct in6_addr	*peer_pfx;
 
+	u32			rt_priority;
 	u32			ifa_flags;
 	u32			preferred_lft;
 	u32			valid_lft;

commit e6464b8c6361962f5ff99dc95d010b64432c27b5
Author: David Ahern <dsahern@gmail.com>
Date:   Sun May 27 08:09:53 2018 -0700

    net/ipv6: Convert ipv6_add_addr to struct ifa6_config
    
    Move config parameters for adding an ipv6 address to a struct. struct
    names stem from inet6_rtm_newaddr which is the modern handler for
    adding an address.
    
    Start the conversion to ifa6_config with ipv6_add_addr. This is an argument
    move only; no functional change intended. Mapping of variable changes:
    
        addr      -->  cfg->pfx
        peer_addr -->  cfg->peer_pfx
        pfxlen    -->  cfg->plen
        flags     -->  cfg->ifa_flags
    
    scope, valid_lft, prefered_lft have the same names within cfg
    (with corrected spelling).
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c07d4dd09361..f766af2cd1a4 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -59,6 +59,18 @@ struct in6_validator_info {
 	struct netlink_ext_ack	*extack;
 };
 
+struct ifa6_config {
+	const struct in6_addr	*pfx;
+	unsigned int		plen;
+
+	const struct in6_addr	*peer_pfx;
+
+	u32			ifa_flags;
+	u32			preferred_lft;
+	u32			valid_lft;
+	u16			scope;
+};
+
 int addrconf_init(void);
 void addrconf_cleanup(void);
 

commit 901731b882d77dc53897aec45015ced42d56fe4c
Author: David Ahern <dsahern@gmail.com>
Date:   Mon May 21 09:08:14 2018 -0700

    net/ipv6: Add helper to return path MTU based on fib result
    
    Determine path MTU from a FIB lookup result. Logic is based on
    ip6_dst_mtu_forward plus lookup of nexthop exception.
    
    Add ip6_dst_mtu_forward to ipv6_stubs to handle access by core
    bpf code.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index ff766ab207e0..c07d4dd09361 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -236,6 +236,8 @@ struct ipv6_stub {
 						   struct flowi6 *fl6, int oif,
 						   const struct sk_buff *skb,
 						   int strict);
+	u32 (*ip6_mtu_from_fib6)(struct fib6_info *f6i, struct in6_addr *daddr,
+				 struct in6_addr *saddr);
 
 	void (*udpv6_encap_enable)(void);
 	void (*ndisc_send_na)(struct net_device *dev, const struct in6_addr *daddr,

commit 65a2022e89a4760f9702837e2d9d15a39a9c68a3
Author: David Ahern <dsahern@gmail.com>
Date:   Wed May 9 20:34:25 2018 -0700

    net/ipv6: Add fib lookup stubs for use in bpf helper
    
    Add stubs to retrieve a handle to an IPv6 FIB table, fib6_get_table,
    a stub to do a lookup in a specific table, fib6_table_lookup, and
    a stub for a full route lookup.
    
    The stubs are needed for core bpf code to handle the case when the
    IPv6 module is not builtin.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 8312cc25a3af..ff766ab207e0 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -223,6 +223,20 @@ struct ipv6_stub {
 				 const struct in6_addr *addr);
 	int (*ipv6_dst_lookup)(struct net *net, struct sock *sk,
 			       struct dst_entry **dst, struct flowi6 *fl6);
+
+	struct fib6_table *(*fib6_get_table)(struct net *net, u32 id);
+	struct fib6_info *(*fib6_lookup)(struct net *net, int oif,
+					 struct flowi6 *fl6, int flags);
+	struct fib6_info *(*fib6_table_lookup)(struct net *net,
+					      struct fib6_table *table,
+					      int oif, struct flowi6 *fl6,
+					      int flags);
+	struct fib6_info *(*fib6_multipath_select)(const struct net *net,
+						   struct fib6_info *f6i,
+						   struct flowi6 *fl6, int oif,
+						   const struct sk_buff *skb,
+						   int strict);
+
 	void (*udpv6_encap_enable)(void);
 	void (*ndisc_send_na)(struct net_device *dev, const struct in6_addr *daddr,
 			      const struct in6_addr *solicited_addr,

commit bdb7cc643fc9db8d6ed9a2b9e524e27ac5882029
Author: Stephen Suryaputra <ssuryaextr@gmail.com>
Date:   Mon Apr 16 13:42:16 2018 -0400

    ipv6: Count interface receive statistics on the ingress netdev
    
    The statistics such as InHdrErrors should be counted on the ingress
    netdev rather than on the dev from the dst, which is the egress.
    
    Signed-off-by: Stephen Suryaputra <ssuryaextr@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 378d601258be..8312cc25a3af 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -307,6 +307,20 @@ static inline struct inet6_dev *__in6_dev_get(const struct net_device *dev)
 	return rcu_dereference_rtnl(dev->ip6_ptr);
 }
 
+/**
+ * __in6_dev_get_safely - get inet6_dev pointer from netdevice
+ * @dev: network device
+ *
+ * This is a safer version of __in6_dev_get
+ */
+static inline struct inet6_dev *__in6_dev_get_safely(const struct net_device *dev)
+{
+	if (likely(dev))
+		return rcu_dereference_rtnl(dev->ip6_ptr);
+	else
+		return NULL;
+}
+
 /**
  * in6_dev_get - get inet6_dev pointer from netdevice
  * @dev: network device

commit d74bad4e74ee373787a9ae24197c17b7cdc428d5
Author: Andrey Ignatov <rdna@fb.com>
Date:   Fri Mar 30 15:08:05 2018 -0700

    bpf: Hooks for sys_connect
    
    == The problem ==
    
    See description of the problem in the initial patch of this patch set.
    
    == The solution ==
    
    The patch provides much more reliable in-kernel solution for the 2nd
    part of the problem: making outgoing connecttion from desired IP.
    
    It adds new attach types `BPF_CGROUP_INET4_CONNECT` and
    `BPF_CGROUP_INET6_CONNECT` for program type
    `BPF_PROG_TYPE_CGROUP_SOCK_ADDR` that can be used to override both
    source and destination of a connection at connect(2) time.
    
    Local end of connection can be bound to desired IP using newly
    introduced BPF-helper `bpf_bind()`. It allows to bind to only IP though,
    and doesn't support binding to port, i.e. leverages
    `IP_BIND_ADDRESS_NO_PORT` socket option. There are two reasons for this:
    * looking for a free port is expensive and can affect performance
      significantly;
    * there is no use-case for port.
    
    As for remote end (`struct sockaddr *` passed by user), both parts of it
    can be overridden, remote IP and remote port. It's useful if an
    application inside cgroup wants to connect to another application inside
    same cgroup or to itself, but knows nothing about IP assigned to the
    cgroup.
    
    Support is added for IPv4 and IPv6, for TCP and UDP.
    
    IPv4 and IPv6 have separate attach types for same reason as sys_bind
    hooks, i.e. to prevent reading from / writing to e.g. user_ip6 fields
    when user passes sockaddr_in since it'd be out-of-bound.
    
    == Implementation notes ==
    
    The patch introduces new field in `struct proto`: `pre_connect` that is
    a pointer to a function with same signature as `connect` but is called
    before it. The reason is in some cases BPF hooks should be called way
    before control is passed to `sk->sk_prot->connect`. Specifically
    `inet_dgram_connect` autobinds socket before calling
    `sk->sk_prot->connect` and there is no way to call `bpf_bind()` from
    hooks from e.g. `ip4_datagram_connect` or `ip6_datagram_connect` since
    it'd cause double-bind. On the other hand `proto.pre_connect` provides a
    flexible way to add BPF hooks for connect only for necessary `proto` and
    call them at desired time before `connect`. Since `bpf_bind()` is
    allowed to bind only to IP and autobind in `inet_dgram_connect` binds
    only port there is no chance of double-bind.
    
    bpf_bind() sets `force_bind_address_no_port` to bind to only IP despite
    of value of `bind_address_no_port` socket field.
    
    bpf_bind() sets `with_lock` to `false` when calling to __inet_bind()
    and __inet6_bind() since all call-sites, where bpf_bind() is called,
    already hold socket lock.
    
    Signed-off-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 132e5b95167a..378d601258be 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -231,6 +231,13 @@ struct ipv6_stub {
 };
 extern const struct ipv6_stub *ipv6_stub __read_mostly;
 
+/* A stub used by bpf helpers. Similarly ugly as ipv6_stub */
+struct ipv6_bpf_stub {
+	int (*inet6_bind)(struct sock *sk, struct sockaddr *uaddr, int addr_len,
+			  bool force_bind_address_no_port, bool with_lock);
+};
+extern const struct ipv6_bpf_stub *ipv6_bpf_stub __read_mostly;
+
 /*
  * identify MLD packets for MLD filter exceptions
  */

commit 232378e8db4780bc7145d7a0ee47f5f80a41ad6b
Author: David Ahern <dsahern@gmail.com>
Date:   Tue Mar 13 08:29:37 2018 -0700

    net/ipv6: Change address check to always take a device argument
    
    ipv6_chk_addr_and_flags determines if an address is a local address and
    optionally if it is an address on a specific device. For example, it is
    called by ip6_route_info_create to determine if a given gateway address
    is a local address. The address check currently does not consider L3
    domains and as a result does not allow a route to be added in one VRF
    if the nexthop points to an address in a second VRF. e.g.,
    
        $ ip route add 2001:db8:1::/64 vrf r2 via 2001:db8:102::23
        Error: Invalid gateway address.
    
    where 2001:db8:102::23 is an address on an interface in vrf r1.
    
    ipv6_chk_addr_and_flags needs to allow callers to always pass in a device
    with a separate argument to not limit the address to the specific device.
    The device is used used to determine the L3 domain of interest.
    
    To that end add an argument to skip the device check and update callers
    to always pass a device where possible and use the new argument to mean
    any address in the domain.
    
    Update a handful of users of ipv6_chk_addr with a NULL dev argument. This
    patch handles the change to these callers without adding the domain check.
    
    ip6_validate_gw needs to handle 2 cases - one where the device is given
    as part of the nexthop spec and the other where the device is resolved.
    There is at least 1 VRF case where deferring the check to only after
    the route lookup has resolved the device fails with an unintuitive error
    "RTNETLINK answers: No route to host" as opposed to the preferred
    "Error: Gateway can not be a local address." The 'no route to host'
    error is because of the fallback to a full lookup. The check is done
    twice to avoid this error.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c4185a7b0e90..132e5b95167a 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -69,8 +69,8 @@ int addrconf_set_dstaddr(struct net *net, void __user *arg);
 int ipv6_chk_addr(struct net *net, const struct in6_addr *addr,
 		  const struct net_device *dev, int strict);
 int ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,
-			    const struct net_device *dev, int strict,
-			    u32 banned_flags);
+			    const struct net_device *dev, bool skip_dev_check,
+			    int strict, u32 banned_flags);
 
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 int ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr);

commit a3fde2addd5f0218b64102005a237ef727b0dc30
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Dec 4 19:19:18 2017 +0100

    rtnetlink: ipv6: convert remaining users to rtnl_register_module
    
    convert remaining users of rtnl_register to rtnl_register_module
    and un-export rtnl_register.
    
    Requested-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index b623b65a79d1..c4185a7b0e90 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -180,7 +180,7 @@ static inline int addrconf_finite_timeout(unsigned long timeout)
  */
 int ipv6_addr_label_init(void);
 void ipv6_addr_label_cleanup(void);
-void ipv6_addr_label_rtnl_register(void);
+int ipv6_addr_label_rtnl_register(void);
 u32 ipv6_addr_label(struct net *net, const struct in6_addr *addr,
 		    int type, int ifindex);
 

commit 27c565ae9d554fa1c00c799754cff43476c8d3b5
Author: Eric Dumazet <edumazet@google.com>
Date:   Sat Nov 4 08:53:27 2017 -0700

    ipv6: remove IN6_ADDR_HSIZE from addrconf.h
    
    IN6_ADDR_HSIZE is private to addrconf.c, move it here to avoid
    confusion.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Acked-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 3357332ea375..b623b65a79d1 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -59,9 +59,6 @@ struct in6_validator_info {
 	struct netlink_ext_ack	*extack;
 };
 
-#define IN6_ADDR_HSIZE_SHIFT	8
-#define IN6_ADDR_HSIZE		(1 << IN6_ADDR_HSIZE_SHIFT)
-
 int addrconf_init(void);
 void addrconf_cleanup(void);
 

commit 2a171788ba7bb61995e98e8163204fc7880f63b2
Merge: bf5345882bd1 d4c2e9fca5b7
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Nov 4 09:26:51 2017 +0900

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Files removed in 'net-next' had their license header updated
    in 'net'.  We take the remove from 'net-next'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f44ff2476758..35f5aabd432f 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _ADDRCONF_H
 #define _ADDRCONF_H
 

commit da13c59b9936dfedcf9f2203bd29fbf83ad672bf
Author: Vishwanath Pai <vpai@akamai.com>
Date:   Mon Oct 30 19:38:52 2017 -0400

    net: display hw address of source machine during ipv6 DAD failure
    
    This patch updates the error messages displayed in kernel log to include
    hwaddress of the source machine that caused ipv6 duplicate address
    detection failures.
    
    Examples:
    
    a) When we receive a NA packet from another machine advertising our
    address:
    
    ICMPv6: NA: 34:ab:cd:56:11:e8 advertised our address 2001:db8:: on eth0!
    
    b) When we detect DAD failure during address assignment to an interface:
    
    IPv6: eth0: IPv6 duplicate address 2001:db8:: used by 34:ab:cd:56:11:e8
    detected!
    
    v2:
        Changed %pI6 to %pI6c in ndisc_recv_na()
        Chaged the v6 address in the commit message to 2001:db8::
    
    Suggested-by: Igor Lubashev <ilubashe@akamai.com>
    Signed-off-by: Vishwanath Pai <vpai@akamai.com>
    Acked-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 15b5ffd7253d..2a616ea53956 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -208,7 +208,7 @@ void ipv6_mc_remap(struct inet6_dev *idev);
 void ipv6_mc_init_dev(struct inet6_dev *idev);
 void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 int ipv6_mc_check_mld(struct sk_buff *skb, struct sk_buff **skb_trimmed);
-void addrconf_dad_failure(struct inet6_ifaddr *ifp);
+void addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp);
 
 bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
 			 const struct in6_addr *src_addr);

commit 3f27fb23219e75343b094366f2358bff34300493
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Oct 23 16:17:47 2017 -0700

    ipv6: addrconf: add per netns perturbation in inet6_addr_hash()
    
    Bring IPv6 in par with IPv4 :
    
    - Use net_hash_mix() to spread addresses a bit more.
    - Use 256 slots hash table instead of 16
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index b8b16437c6d5..15b5ffd7253d 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -58,7 +58,7 @@ struct in6_validator_info {
 	struct netlink_ext_ack	*extack;
 };
 
-#define IN6_ADDR_HSIZE_SHIFT	4
+#define IN6_ADDR_HSIZE_SHIFT	8
 #define IN6_ADDR_HSIZE		(1 << IN6_ADDR_HSIZE_SHIFT)
 
 int addrconf_init(void);

commit de95e04791a03de5cb681980a3880db6919e3b4a
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 18 09:56:54 2017 -0700

    net: Add extack to validator_info structs used for address notifier
    
    Add extack to in_validator_info and in6_validator_info. Update the one
    user of each, ipvlan, to return an error message for failures.
    
    Only manual configuration of an address is plumbed in the IPv6 code path.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 87981cd63180..b8b16437c6d5 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -55,6 +55,7 @@ struct prefix_info {
 struct in6_validator_info {
 	struct in6_addr		i6vi_addr;
 	struct inet6_dev	*i6vi_dev;
+	struct netlink_ext_ack	*extack;
 };
 
 #define IN6_ADDR_HSIZE_SHIFT	4

commit 7016e0627171878810798a842a416dddee4e3329
Author: Joe Perches <joe@perches.com>
Date:   Wed Sep 13 13:58:15 2017 -0700

    net: Convert int functions to bool
    
    Global function ipv6_rcv_saddr_equal and static functions
    ipv6_rcv_saddr_equal and ipv4_rcv_saddr_equal currently return int.
    
    bool is slightly more descriptive for these functions so change
    their return type from int to bool.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f44ff2476758..87981cd63180 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -94,8 +94,8 @@ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 		      u32 banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    u32 banned_flags);
-int inet_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
-			 bool match_wildcard);
+bool inet_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
+			  bool match_wildcard);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 

commit 12d94a804946af291e24b80fc53ec86264765781
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Aug 15 04:09:51 2017 -0700

    ipv6: fix NULL dereference in ip6_route_dev_notify()
    
    Based on a syzkaller report [1], I found that a per cpu allocation
    failure in snmp6_alloc_dev() would then lead to NULL dereference in
    ip6_route_dev_notify().
    
    It seems this is a very old bug, thus no Fixes tag in this submission.
    
    Let's add in6_dev_put_clear() helper, as we will probably use
    it elsewhere (once available/present in net-next)
    
    [1]
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] SMP KASAN
    Dumping ftrace buffer:
       (ftrace buffer empty)
    Modules linked in:
    CPU: 1 PID: 17294 Comm: syz-executor6 Not tainted 4.13.0-rc2+ #10
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    task: ffff88019f456680 task.stack: ffff8801c6e58000
    RIP: 0010:__read_once_size include/linux/compiler.h:250 [inline]
    RIP: 0010:atomic_read arch/x86/include/asm/atomic.h:26 [inline]
    RIP: 0010:refcount_sub_and_test+0x7d/0x1b0 lib/refcount.c:178
    RSP: 0018:ffff8801c6e5f1b0 EFLAGS: 00010202
    RAX: 0000000000000037 RBX: dffffc0000000000 RCX: ffffc90005d25000
    RDX: ffff8801c6e5f218 RSI: ffffffff82342bbf RDI: 0000000000000001
    RBP: ffff8801c6e5f240 R08: 0000000000000001 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: 1ffff10038dcbe37
    R13: 0000000000000006 R14: 0000000000000001 R15: 00000000000001b8
    FS:  00007f21e0429700(0000) GS:ffff8801dc100000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000001ddbc22000 CR3: 00000001d632b000 CR4: 00000000001426e0
    DR0: 0000000020000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000600
    Call Trace:
     refcount_dec_and_test+0x1a/0x20 lib/refcount.c:211
     in6_dev_put include/net/addrconf.h:335 [inline]
     ip6_route_dev_notify+0x1c9/0x4a0 net/ipv6/route.c:3732
     notifier_call_chain+0x136/0x2c0 kernel/notifier.c:93
     __raw_notifier_call_chain kernel/notifier.c:394 [inline]
     raw_notifier_call_chain+0x2d/0x40 kernel/notifier.c:401
     call_netdevice_notifiers_info+0x51/0x90 net/core/dev.c:1678
     call_netdevice_notifiers net/core/dev.c:1694 [inline]
     rollback_registered_many+0x91c/0xe80 net/core/dev.c:7107
     rollback_registered+0x1be/0x3c0 net/core/dev.c:7149
     register_netdevice+0xbcd/0xee0 net/core/dev.c:7587
     register_netdev+0x1a/0x30 net/core/dev.c:7669
     loopback_net_init+0x76/0x160 drivers/net/loopback.c:214
     ops_init+0x10a/0x570 net/core/net_namespace.c:118
     setup_net+0x313/0x710 net/core/net_namespace.c:294
     copy_net_ns+0x27c/0x580 net/core/net_namespace.c:418
     create_new_namespaces+0x425/0x880 kernel/nsproxy.c:107
     unshare_nsproxy_namespaces+0xae/0x1e0 kernel/nsproxy.c:206
     SYSC_unshare kernel/fork.c:2347 [inline]
     SyS_unshare+0x653/0xfa0 kernel/fork.c:2297
     entry_SYSCALL_64_fastpath+0x1f/0xbe
    RIP: 0033:0x4512c9
    RSP: 002b:00007f21e0428c08 EFLAGS: 00000216 ORIG_RAX: 0000000000000110
    RAX: ffffffffffffffda RBX: 0000000000718150 RCX: 00000000004512c9
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000062020200
    RBP: 0000000000000086 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000216 R12: 00000000004b973d
    R13: 00000000ffffffff R14: 000000002001d000 R15: 00000000000002dd
    Code: 50 2b 34 82 c7 00 f1 f1 f1 f1 c7 40 04 04 f2 f2 f2 c7 40 08 f3 f3
    f3 f3 e8 a1 43 39 ff 4c 89 f8 48 8b 95 70 ff ff ff 48 c1 e8 03 <0f> b6
    0c 18 4c 89 f8 83 e0 07 83 c0 03 38 c8 7c 08 84 c9 0f 85
    RIP: __read_once_size include/linux/compiler.h:250 [inline] RSP:
    ffff8801c6e5f1b0
    RIP: atomic_read arch/x86/include/asm/atomic.h:26 [inline] RSP:
    ffff8801c6e5f1b0
    RIP: refcount_sub_and_test+0x7d/0x1b0 lib/refcount.c:178 RSP:
    ffff8801c6e5f1b0
    ---[ end trace e441d046c6410d31 ]---
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 6df79e96a780..f44ff2476758 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -336,6 +336,16 @@ static inline void in6_dev_put(struct inet6_dev *idev)
 		in6_dev_finish_destroy(idev);
 }
 
+static inline void in6_dev_put_clear(struct inet6_dev **pidev)
+{
+	struct inet6_dev *idev = *pidev;
+
+	if (idev) {
+		in6_dev_put(idev);
+		*pidev = NULL;
+	}
+}
+
 static inline void __in6_dev_put(struct inet6_dev *idev)
 {
 	refcount_dec(&idev->refcnt);

commit 271201c09c86cd75e0fd6206bde689176e85aa21
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 09:34:56 2017 +0300

    net, ipv6: convert inet6_ifaddr.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 620bd9a83ba9..6df79e96a780 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -350,18 +350,18 @@ void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);
 
 static inline void in6_ifa_put(struct inet6_ifaddr *ifp)
 {
-	if (atomic_dec_and_test(&ifp->refcnt))
+	if (refcount_dec_and_test(&ifp->refcnt))
 		inet6_ifa_finish_destroy(ifp);
 }
 
 static inline void __in6_ifa_put(struct inet6_ifaddr *ifp)
 {
-	atomic_dec(&ifp->refcnt);
+	refcount_dec(&ifp->refcnt);
 }
 
 static inline void in6_ifa_hold(struct inet6_ifaddr *ifp)
 {
-	atomic_inc(&ifp->refcnt);
+	refcount_inc(&ifp->refcnt);
 }
 
 

commit 1be9246077f6bb1583f9347c599480621d63c66a
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 09:34:55 2017 +0300

    net, ipv6: convert inet6_dev.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index d0889cb50172..620bd9a83ba9 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -316,7 +316,7 @@ static inline struct inet6_dev *in6_dev_get(const struct net_device *dev)
 	rcu_read_lock();
 	idev = rcu_dereference(dev->ip6_ptr);
 	if (idev)
-		atomic_inc(&idev->refcnt);
+		refcount_inc(&idev->refcnt);
 	rcu_read_unlock();
 	return idev;
 }
@@ -332,18 +332,18 @@ void in6_dev_finish_destroy(struct inet6_dev *idev);
 
 static inline void in6_dev_put(struct inet6_dev *idev)
 {
-	if (atomic_dec_and_test(&idev->refcnt))
+	if (refcount_dec_and_test(&idev->refcnt))
 		in6_dev_finish_destroy(idev);
 }
 
 static inline void __in6_dev_put(struct inet6_dev *idev)
 {
-	atomic_dec(&idev->refcnt);
+	refcount_dec(&idev->refcnt);
 }
 
 static inline void in6_dev_hold(struct inet6_dev *idev)
 {
-	atomic_inc(&idev->refcnt);
+	refcount_inc(&idev->refcnt);
 }
 
 void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);

commit 3ad7d2468f79fc13215eb941f766a692d34b1381
Author: Krister Johansen <kjlx@templeofstupid.com>
Date:   Thu Jun 8 13:12:14 2017 -0700

    Ipvlan should return an error when an address is already in use.
    
    The ipvlan code already knows how to detect when a duplicate address is
    about to be assigned to an ipvlan device.  However, that failure is not
    propogated outward and leads to a silent failure.
    
    Introduce a validation step at ip address creation time and allow device
    drivers to register to validate the incoming ip addresses.  The ipvlan
    code is the first consumer.  If it detects an address in use, we can
    return an error to the user before beginning to commit the new ifa in
    the networking code.
    
    This can be especially useful if it is necessary to provision many
    ipvlans in containers.  The provisioning software (or operator) can use
    this to detect situations where an ip address is unexpectedly in use.
    
    Signed-off-by: Krister Johansen <kjlx@templeofstupid.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index b43a4eec3cec..d0889cb50172 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -48,11 +48,15 @@ struct prefix_info {
 	struct in6_addr		prefix;
 };
 
-
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
 #include <net/ipv6.h>
 
+struct in6_validator_info {
+	struct in6_addr		i6vi_addr;
+	struct inet6_dev	*i6vi_dev;
+};
+
 #define IN6_ADDR_HSIZE_SHIFT	4
 #define IN6_ADDR_HSIZE		(1 << IN6_ADDR_HSIZE_SHIFT)
 
@@ -278,6 +282,10 @@ int register_inet6addr_notifier(struct notifier_block *nb);
 int unregister_inet6addr_notifier(struct notifier_block *nb);
 int inet6addr_notifier_call_chain(unsigned long val, void *v);
 
+int register_inet6addr_validator_notifier(struct notifier_block *nb);
+int unregister_inet6addr_validator_notifier(struct notifier_block *nb);
+int inet6addr_validator_notifier_call_chain(unsigned long val, void *v);
+
 void inet6_netconf_notify_devconf(struct net *net, int event, int type,
 				  int ifindex, struct ipv6_devconf *devconf);
 

commit 242d3a49a2a1a71d8eb9f953db1bcaa9d698ce00
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Mon May 8 10:12:13 2017 -0700

    ipv6: reorder ip6_route_dev_notifier after ipv6_dev_notf
    
    For each netns (except init_net), we initialize its null entry
    in 3 places:
    
    1) The template itself, as we use kmemdup()
    2) Code around dst_init_metrics() in ip6_route_net_init()
    3) ip6_route_dev_notify(), which is supposed to initialize it after
       loopback registers
    
    Unfortunately the last one still happens in a wrong order because
    we expect to initialize net->ipv6.ip6_null_entry->rt6i_idev to
    net->loopback_dev's idev, thus we have to do that after we add
    idev to loopback. However, this notifier has priority == 0 same as
    ipv6_dev_notf, and ipv6_dev_notf is registered after
    ip6_route_dev_notifier so it is called actually after
    ip6_route_dev_notifier. This is similar to commit 2f460933f58e
    ("ipv6: initialize route null entry in addrconf_init()") which
    fixes init_net.
    
    Fix it by picking a smaller priority for ip6_route_dev_notifier.
    Also, we have to release the refcnt accordingly when unregistering
    loopback_dev because device exit functions are called before subsys
    exit functions.
    
    Acked-by: David Ahern <dsahern@gmail.com>
    Tested-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 2452e6449532..b43a4eec3cec 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -20,6 +20,8 @@
 #define ADDRCONF_TIMER_FUZZ		(HZ / 4)
 #define ADDRCONF_TIMER_FUZZ_MAX		(HZ)
 
+#define ADDRCONF_NOTIFY_PRIORITY	0
+
 #include <linux/in.h>
 #include <linux/in6.h>
 

commit 4d6f28591fe415fc5233e9148c66a1b81ad17425
Author: Yuval Shaia <yuval.shaia@oracle.com>
Date:   Tue Mar 14 16:01:57 2017 +0200

    {net,IB}/{rxe,usnic}: Utilize generic mac to eui32 function
    
    This logic seems to be duplicated in (at least) three separate files.
    Move it to one place so code can be re-use.
    
    Signed-off-by: Yuval Shaia <yuval.shaia@oracle.com>
    Reviewed-by: Leon Romanovsky <leonro@mellanox.com>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 1aeb25dd42a7..2452e6449532 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -103,12 +103,24 @@ int addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,
 				 u32 addr_flags, bool sllao, bool tokenized,
 				 __u32 valid_lft, u32 prefered_lft);
 
+static inline void addrconf_addr_eui48_base(u8 *eui, const char *const addr)
+{
+	memcpy(eui, addr, 3);
+	eui[3] = 0xFF;
+	eui[4] = 0xFE;
+	memcpy(eui + 5, addr + 3, 3);
+}
+
+static inline void addrconf_addr_eui48(u8 *eui, const char *const addr)
+{
+	addrconf_addr_eui48_base(eui, addr);
+	eui[0] ^= 2;
+}
+
 static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
 {
 	if (dev->addr_len != ETH_ALEN)
 		return -1;
-	memcpy(eui, dev->dev_addr, 3);
-	memcpy(eui + 5, dev->dev_addr + 3, 3);
 
 	/*
 	 * The zSeries OSA network cards can be shared among various
@@ -123,14 +135,16 @@ static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
 	 * case.  Hence the resulting interface identifier has local
 	 * scope according to RFC2373.
 	 */
+
+	addrconf_addr_eui48_base(eui, dev->dev_addr);
+
 	if (dev->dev_id) {
 		eui[3] = (dev->dev_id >> 8) & 0xFF;
 		eui[4] = dev->dev_id & 0xFF;
 	} else {
-		eui[3] = 0xFF;
-		eui[4] = 0xFE;
 		eui[0] ^= 2;
 	}
+
 	return 0;
 }
 

commit 85b3daada4cab8cc36888f5d025058bbc8737497
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Tue Mar 28 14:28:04 2017 -0700

    net: ipv6: Refactor inet6_netconf_notify_devconf to take event
    
    Refactor inet6_netconf_notify_devconf to take the event as an input arg.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 17c6fd84e287..1aeb25dd42a7 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -262,8 +262,8 @@ int register_inet6addr_notifier(struct notifier_block *nb);
 int unregister_inet6addr_notifier(struct notifier_block *nb);
 int inet6addr_notifier_call_chain(unsigned long val, void *v);
 
-void inet6_netconf_notify_devconf(struct net *net, int type, int ifindex,
-				  struct ipv6_devconf *devconf);
+void inet6_netconf_notify_devconf(struct net *net, int event, int type,
+				  int ifindex, struct ipv6_devconf *devconf);
 
 /**
  * __in6_dev_get - get inet6_dev pointer from netdevice

commit fe38d2a1c8bee0b3a0be40de5b621a28200612e5
Author: Josef Bacik <jbacik@fb.com>
Date:   Tue Jan 17 07:51:01 2017 -0800

    inet: collapse ipv4/v6 rcv_saddr_equal functions into one
    
    We pass these per-protocol equal functions around in various places, but
    we can just have one function that checks the sk->sk_family and then do
    the right comparison function.  I've also changed the ipv4 version to
    not cast to inet_sock since it is unneeded.
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 8f998afc1384..17c6fd84e287 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -88,9 +88,7 @@ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 		      u32 banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    u32 banned_flags);
-int ipv4_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
-			 bool match_wildcard);
-int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
+int inet_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
 			 bool match_wildcard);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);

commit 8651be8f14a12d24f203f283601d9b0418c389ff
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Wed Oct 19 23:35:12 2016 -0700

    ipv6: fix a potential deadlock in do_ipv6_setsockopt()
    
    Baozeng reported this deadlock case:
    
           CPU0                    CPU1
           ----                    ----
      lock([  165.136033] sk_lock-AF_INET6);
                                   lock([  165.136033] rtnl_mutex);
                                   lock([  165.136033] sk_lock-AF_INET6);
      lock([  165.136033] rtnl_mutex);
    
    Similar to commit 87e9f0315952
    ("ipv4: fix a potential deadlock in mcast getsockopt() path")
    this is due to we still have a case, ipv6_sock_mc_close(),
    where we acquire sk_lock before rtnl_lock. Close this deadlock
    with the similar solution, that is always acquire rtnl lock first.
    
    Fixes: baf606d9c9b1 ("ipv4,ipv6: grab rtnl before locking the socket")
    Reported-by: Baozeng Ding <sploving1@gmail.com>
    Tested-by: Baozeng Ding <sploving1@gmail.com>
    Cc: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f2d072787947..8f998afc1384 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -174,6 +174,7 @@ int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 		      const struct in6_addr *addr);
 int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 		      const struct in6_addr *addr);
+void __ipv6_sock_mc_close(struct sock *sk);
 void ipv6_sock_mc_close(struct sock *sk);
 bool inet6_mc_check(struct sock *sk, const struct in6_addr *mc_addr,
 		    const struct in6_addr *src_addr);

commit bd11f0741fa5a2c296629898ad07759dd12b35bb
Author: Maciej Żenczykowski <maze@google.com>
Date:   Tue Sep 27 23:57:58 2016 -0700

    ipv6 addrconf: implement RFC7559 router solicitation backoff
    
    This implements:
      https://tools.ietf.org/html/rfc7559
    
    Backoff is performed according to RFC3315 section 14:
      https://tools.ietf.org/html/rfc3315#section-14
    
    We allow setting /proc/sys/net/ipv6/conf/*/router_solicitations
    to a negative value meaning an unlimited number of retransmits,
    and we make this the new default (inline with the RFC).
    
    We also add a new setting:
      /proc/sys/net/ipv6/conf/*/router_solicitation_max_interval
    defaulting to 1 hour (per RFC recommendation).
    
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Acked-by: Erik Kline <ek@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 9826d3a9464c..f2d072787947 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -1,8 +1,9 @@
 #ifndef _ADDRCONF_H
 #define _ADDRCONF_H
 
-#define MAX_RTR_SOLICITATIONS		3
+#define MAX_RTR_SOLICITATIONS		-1		/* unlimited */
 #define RTR_SOLICITATION_INTERVAL	(4*HZ)
+#define RTR_SOLICITATION_MAX_INTERVAL	(3600*HZ)	/* 1 hour */
 
 #define MIN_VALID_LIFETIME		(2*3600)	/* 2 hours */
 

commit cc84b3c6b48ae81748c5e25d3558872385196162
Author: Alexander Aring <aar@pengutronix.de>
Date:   Wed Jun 15 21:20:24 2016 +0200

    ipv6: export several functions
    
    This patch exports some neighbour discovery functions which can be used
    by 6lowpan neighbour discovery ops functionality then.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: James Morris <jmorris@namei.org>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Acked-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index b1774eb03f37..9826d3a9464c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -97,6 +97,13 @@ void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 void addrconf_add_linklocal(struct inet6_dev *idev,
 			    const struct in6_addr *addr, u32 flags);
 
+int addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,
+				 const struct prefix_info *pinfo,
+				 struct inet6_dev *in6_dev,
+				 const struct in6_addr *addr, int addr_type,
+				 u32 addr_flags, bool sllao, bool tokenized,
+				 __u32 valid_lft, u32 prefered_lft);
+
 static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
 {
 	if (dev->addr_len != ETH_ALEN)

commit 2ad3ed59198c5404c34515cfcfd9a2b3c54d964f
Author: Alexander Aring <aar@pengutronix.de>
Date:   Wed Jun 15 21:20:17 2016 +0200

    6lowpan: add 802.15.4 short addr slaac
    
    This patch adds the autoconfiguration if a valid 802.15.4 short address
    is available for 802.15.4 6LoWPAN interfaces.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: James Morris <jmorris@namei.org>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 730d856683e5..b1774eb03f37 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -94,6 +94,9 @@ int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 
+void addrconf_add_linklocal(struct inet6_dev *idev,
+			    const struct in6_addr *addr, u32 flags);
+
 static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
 {
 	if (dev->addr_len != ETH_ALEN)

commit a583636a83ea383fd07517e5a7a2eedbc5d90fb1
Author: Craig Gallek <kraig@google.com>
Date:   Wed Feb 10 11:50:38 2016 -0500

    inet: refactor inet[6]_lookup functions to take skb
    
    This is a preliminary step to allow fast socket lookup of SO_REUSEPORT
    groups.  Doing so with a BPF filter will require access to the
    skb in question.  This change plumbs the skb (and offset to payload
    data) through the call stack to the listening socket lookup
    implementations where it will be used in a following patch.
    
    Signed-off-by: Craig Gallek <kraig@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 47f52d3cd8df..730d856683e5 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -87,6 +87,8 @@ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 		      u32 banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    u32 banned_flags);
+int ipv4_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
+			 bool match_wildcard);
 int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
 			 bool match_wildcard);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);

commit e32ea7e747271a0abcd37e265005e97cc81d9df5
Author: Craig Gallek <kraig@google.com>
Date:   Mon Jan 4 17:41:46 2016 -0500

    soreuseport: fast reuseport UDP socket selection
    
    Include a struct sock_reuseport instance when a UDP socket binds to
    a specific address for the first time with the reuseport flag set.
    When selecting a socket for an incoming UDP packet, use the information
    available in sock_reuseport if present.
    
    This required adding an additional field to the UDP source address
    equality function to differentiate between exact and wildcard matches.
    The original use case allowed wildcard matches when checking for
    existing port uses during bind.  The new use case of adding a socket
    to a reuseport group requires exact address matching.
    
    Performance test (using a machine with 2 CPU sockets and a total of
    48 cores):  Create reuseport groups of varying size.  Use one socket
    from this group per user thread (pinning each thread to a different
    core) calling recvmmsg in a tight loop.  Record number of messages
    received per second while saturating a 10G link.
      10 sockets: 18% increase (~2.8M -> 3.3M pkts/s)
      20 sockets: 14% increase (~2.9M -> 3.3M pkts/s)
      40 sockets: 13% increase (~3.0M -> 3.4M pkts/s)
    
    This work is based off a similar implementation written by
    Ying Cai <ycai@google.com> for implementing policy-based reuseport
    selection.
    
    Signed-off-by: Craig Gallek <kraig@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 78003dfb8539..47f52d3cd8df 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -87,7 +87,8 @@ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 		      u32 banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    u32 banned_flags);
-int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
+int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2,
+			 bool match_wildcard);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 

commit 38cf595b195552276e1cf1826434e05782de4be8
Author: Jiri Benc <jbenc@redhat.com>
Date:   Tue Sep 22 18:57:13 2015 +0200

    ipv6: remove unused neigh parameter from ndisc functions
    
    Since commit 12fd84f4383b1 ("ipv6: Remove unused neigh argument for
    icmp6_dst_alloc() and its callers."), the neigh parameter of ndisc_send_na
    and ndisc_send_ns is unused.
    
    CC: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Jiri Benc <jbenc@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index b5474b1fcd83..78003dfb8539 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -192,8 +192,7 @@ struct ipv6_stub {
 	int (*ipv6_dst_lookup)(struct net *net, struct sock *sk,
 			       struct dst_entry **dst, struct flowi6 *fl6);
 	void (*udpv6_encap_enable)(void);
-	void (*ndisc_send_na)(struct net_device *dev, struct neighbour *neigh,
-			      const struct in6_addr *daddr,
+	void (*ndisc_send_na)(struct net_device *dev, const struct in6_addr *daddr,
 			      const struct in6_addr *solicited_addr,
 			      bool router, bool solicited, bool override, bool inc_opt);
 	struct neigh_table *nd_tbl;

commit 26d2177e977c912863ac04f6c1a967e793ca3a56
Merge: a794b4f32921 d1178cbcdcf9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 9 08:33:31 2015 -0700

    Merge tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dledford/rdma
    
    Pull inifiniband/rdma updates from Doug Ledford:
     "This is a fairly sizeable set of changes.  I've put them through a
      decent amount of testing prior to sending the pull request due to
      that.
    
      There are still a few fixups that I know are coming, but I wanted to
      go ahead and get the big, sizable chunk into your hands sooner rather
      than waiting for those last few fixups.
    
      Of note is the fact that this creates what is intended to be a
      temporary area in the drivers/staging tree specifically for some
      cleanups and additions that are coming for the RDMA stack.  We
      deprecated two drivers (ipath and amso1100) and are waiting to hear
      back if we can deprecate another one (ehca).  We also put Intel's new
      hfi1 driver into this area because it needs to be refactored and a
      transfer library created out of the factored out code, and then it and
      the qib driver and the soft-roce driver should all be modified to use
      that library.
    
      I expect drivers/staging/rdma to be around for three or four kernel
      releases and then to go away as all of the work is completed and final
      deletions of deprecated drivers are done.
    
      Summary of changes for 4.3:
    
       - Create drivers/staging/rdma
       - Move amso1100 driver to staging/rdma and schedule for deletion
       - Move ipath driver to staging/rdma and schedule for deletion
       - Add hfi1 driver to staging/rdma and set TODO for move to regular
         tree
       - Initial support for namespaces to be used on RDMA devices
       - Add RoCE GID table handling to the RDMA core caching code
       - Infrastructure to support handling of devices with differing read
         and write scatter gather capabilities
       - Various iSER updates
       - Kill off unsafe usage of global mr registrations
       - Update SRP driver
       - Misc  mlx4 driver updates
       - Support for the mr_alloc verb
       - Support for a netlink interface between kernel and user space cache
         daemon to speed path record queries and route resolution
       - Ininitial support for safe hot removal of verbs devices"
    
    * tag 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dledford/rdma: (136 commits)
      IB/ipoib: Suppress warning for send only join failures
      IB/ipoib: Clean up send-only multicast joins
      IB/srp: Fix possible protection fault
      IB/core: Move SM class defines from ib_mad.h to ib_smi.h
      IB/core: Remove unnecessary defines from ib_mad.h
      IB/hfi1: Add PSM2 user space header to header_install
      IB/hfi1: Add CSRs for CONFIG_SDMA_VERBOSITY
      mlx5: Fix incorrect wc pkey_index assignment for GSI messages
      IB/mlx5: avoid destroying a NULL mr in reg_user_mr error flow
      IB/uverbs: reject invalid or unknown opcodes
      IB/cxgb4: Fix if statement in pick_local_ip6adddrs
      IB/sa: Fix rdma netlink message flags
      IB/ucma: HW Device hot-removal support
      IB/mlx4_ib: Disassociate support
      IB/uverbs: Enable device removal when there are active user space applications
      IB/uverbs: Explicitly pass ib_dev to uverbs commands
      IB/uverbs: Fix race between ib_uverbs_open and remove_one
      IB/uverbs: Fix reference counting usage of event files
      IB/core: Make ib_dealloc_pd return void
      IB/srp: Create an insecure all physical rkey only if needed
      ...

commit 399e6f95811bd36fb64b3d30cf8529d633884b4c
Author: Matan Barak <matanb@mellanox.com>
Date:   Thu Jul 30 18:33:22 2015 +0300

    net/ipv6: Export addrconf_ifid_eui48
    
    For loopback purposes, RoCE devices should have a default GID in the
    port GID table, even when the interface is down. In order to do so,
    we use the IPv6 link local address which would have been genenrated
    for the related Ethernet netdevice when it goes up as a default GID.
    
    addrconf_ifid_eui48 is used to gernerate this address, export it.
    
    Signed-off-by: Matan Barak <matanb@mellanox.com>
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index def59d3a34d5..431fdfa3f56d 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -91,6 +91,37 @@ int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 
+static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
+{
+	if (dev->addr_len != ETH_ALEN)
+		return -1;
+	memcpy(eui, dev->dev_addr, 3);
+	memcpy(eui + 5, dev->dev_addr + 3, 3);
+
+	/*
+	 * The zSeries OSA network cards can be shared among various
+	 * OS instances, but the OSA cards have only one MAC address.
+	 * This leads to duplicate address conflicts in conjunction
+	 * with IPv6 if more than one instance uses the same card.
+	 *
+	 * The driver for these cards can deliver a unique 16-bit
+	 * identifier for each instance sharing the same card.  It is
+	 * placed instead of 0xFFFE in the interface identifier.  The
+	 * "u" bit of the interface identifier is not inverted in this
+	 * case.  Hence the resulting interface identifier has local
+	 * scope according to RFC2373.
+	 */
+	if (dev->dev_id) {
+		eui[3] = (dev->dev_id >> 8) & 0xFF;
+		eui[4] = dev->dev_id & 0xFF;
+	} else {
+		eui[3] = 0xFF;
+		eui[4] = 0xFE;
+		eui[0] ^= 2;
+	}
+	return 0;
+}
+
 static inline unsigned long addrconf_timeout_fixup(u32 timeout,
 						   unsigned int unit)
 {

commit 343d60aada5a358ca186d6e9e353230379c426d8
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Thu Jul 30 13:34:53 2015 -0700

    ipv6: change ipv6_stub_impl.ipv6_dst_lookup to take net argument
    
    This patch adds net argument to ipv6_stub_impl.ipv6_dst_lookup
    for use cases where sk is not available (like mpls).
    sk appears to be needed to get the namespace 'net' and is optional
    otherwise. This patch series changes ipv6_stub_impl.ipv6_dst_lookup
    to take net argument. sk remains optional.
    
    All callers of ipv6_stub_impl.ipv6_dst_lookup have been modified
    to pass net. I have modified them to use already available
    'net' in the scope of the call. I can change them to
    sock_net(sk) to avoid any unintended change in behaviour if sock
    namespace is different. They dont seem to be from code inspection.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index def59d3a34d5..0c3ac5acb85f 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -158,8 +158,8 @@ struct ipv6_stub {
 				 const struct in6_addr *addr);
 	int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
 				 const struct in6_addr *addr);
-	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
-				struct flowi6 *fl6);
+	int (*ipv6_dst_lookup)(struct net *net, struct sock *sk,
+			       struct dst_entry **dst, struct flowi6 *fl6);
 	void (*udpv6_encap_enable)(void);
 	void (*ndisc_send_na)(struct net_device *dev, struct neighbour *neigh,
 			      const struct in6_addr *daddr,

commit 9afd85c9e4552b276e2f4cfefd622bdeeffbbf26
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Sat May 2 14:01:07 2015 +0200

    net: Export IGMP/MLD message validation code
    
    With this patch, the IGMP and MLD message validation functions are moved
    from the bridge code to IPv4/IPv6 multicast files. Some small
    refactoring was done to enhance readibility and to iron out some
    differences in behaviour between the IGMP and MLD parsing code (e.g. the
    skb-cloning of MLD messages is now only done if necessary, just like the
    IGMP part always did).
    
    Finally, these IGMP and MLD message validation functions are exported so
    that not only the bridge can use it but batman-adv later, too.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 80456f72d70a..def59d3a34d5 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -142,6 +142,7 @@ void ipv6_mc_unmap(struct inet6_dev *idev);
 void ipv6_mc_remap(struct inet6_dev *idev);
 void ipv6_mc_init_dev(struct inet6_dev *idev);
 void ipv6_mc_destroy_dev(struct inet6_dev *idev);
+int ipv6_mc_check_mld(struct sk_buff *skb, struct sk_buff **skb_trimmed);
 void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 
 bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,

commit c58da4c659803ac12eca5275c8a7064222adb4c7
Author: Erik Kline <ek@google.com>
Date:   Wed Feb 4 20:01:23 2015 +0900

    net: ipv6: allow explicitly choosing optimistic addresses
    
    RFC 4429 ("Optimistic DAD") states that optimistic addresses
    should be treated as deprecated addresses.  From section 2.1:
    
       Unless noted otherwise, components of the IPv6 protocol stack
       should treat addresses in the Optimistic state equivalently to
       those in the Deprecated state, indicating that the address is
       available for use but should not be used if another suitable
       address is available.
    
    Optimistic addresses are indeed avoided when other addresses are
    available (i.e. at source address selection time), but they have
    not heretofore been available for things like explicit bind() and
    sendmsg() with struct in6_pktinfo, etc.
    
    This change makes optimistic addresses treated more like
    deprecated addresses than tentative ones.
    
    Signed-off-by: Erik Kline <ek@google.com>
    Acked-by: Lorenzo Colitti <lorenzo@google.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index d13573bb879e..80456f72d70a 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -62,6 +62,9 @@ int addrconf_set_dstaddr(struct net *net, void __user *arg);
 
 int ipv6_chk_addr(struct net *net, const struct in6_addr *addr,
 		  const struct net_device *dev, int strict);
+int ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,
+			    const struct net_device *dev, int strict,
+			    u32 banned_flags);
 
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 int ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr);

commit 1f6d80358dc9bbbeb56cb43384fa11fd645d9289
Merge: a2aeb02a8e6a 98f75b8291a8
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 23 12:09:27 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            arch/mips/net/bpf_jit.c
            drivers/net/can/flexcan.c
    
    Both the flexcan and MIPS bpf_jit conflicts were cases of simple
    overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 013b4d90387a5dca54281263e0d4650db97bd67c
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Thu Sep 11 15:35:11 2014 -0700

    ipv6: clean up ipv6_dev_ac_inc()
    
    Make it accept inet6_dev, and rename it to __ipv6_dev_ac_inc()
    to reflect this change.
    
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f679877bb601..9b1d42e66cca 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -202,7 +202,7 @@ int ipv6_sock_ac_drop(struct sock *sk, int ifindex,
 		      const struct in6_addr *addr);
 void ipv6_sock_ac_close(struct sock *sk);
 
-int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
+int __ipv6_dev_ac_inc(struct inet6_dev *idev, const struct in6_addr *addr);
 int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 			 const struct in6_addr *addr);

commit 381f4dca48d23e155b936b86ccd3ff12f073cf0f
Author: Sabrina Dubroca <sd@queasysnail.net>
Date:   Wed Sep 10 23:23:02 2014 +0200

    ipv6: clean up anycast when an interface is destroyed
    
    If we try to rmmod the driver for an interface while sockets with
    setsockopt(JOIN_ANYCAST) are alive, some refcounts aren't cleaned up
    and we get stuck on:
    
      unregister_netdevice: waiting for ens3 to become free. Usage count = 1
    
    If we LEAVE_ANYCAST/close everything before rmmod'ing, there is no
    problem.
    
    We need to perform a cleanup similar to the one for multicast in
    addrconf_ifdown(how == 1).
    
    Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f679877bb601..ec51e673b4b6 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -204,6 +204,7 @@ void ipv6_sock_ac_close(struct sock *sk);
 
 int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
 int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
+void ipv6_ac_destroy_dev(struct inet6_dev *idev);
 bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 			 const struct in6_addr *addr);
 bool ipv6_chk_acast_addr_src(struct net *net, struct net_device *dev,

commit 5c98631cca574ac6255885cf372f6bcf9dcfd483
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Tue Apr 29 11:57:34 2014 +0900

    net: ipv6: Introduce ip6_sk_dst_hoplimit.
    
    This replaces 6 identical code snippets with a call to a new
    static inline function.
    
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 933a9f22a05f..f679877bb601 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -306,11 +306,6 @@ static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
 		      htonl(0xFF000000) | addr->s6_addr32[3]);
 }
 
-static inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)
-{
-	return (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);
-}
-
 static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64

commit bc861959103cb5ca43157db6ddb83d1e17e9c38a
Author: Bjørn Mork <bjorn@mork.no>
Date:   Thu Feb 27 14:20:29 2014 +0100

    ipv6: addrconf: silence sparse endianness warnings
    
    Avoid the following sparse __CHECK_ENDIAN__ warnings:
    
     include/net/addrconf.h:318:25: warning: restricted __be64 degrades to integer
     include/net/addrconf.h:318:70: warning: restricted __be64 degrades to integer
     include/net/addrconf.h:330:25: warning: restricted __be64 degrades to integer
     include/net/addrconf.h:330:70: warning: restricted __be64 degrades to integer
     include/net/addrconf.h:347:25: warning: restricted __be64 degrades to integer
     include/net/addrconf.h:348:26: warning: restricted __be64 degrades to integer
     include/net/addrconf.h:349:18: warning: restricted __be64 degrades to integer
    
    The warnings are false but they make it harder to spot real
    bugs.
    
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 50e39a8822b4..933a9f22a05f 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -314,7 +314,7 @@ static inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)
 static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__u64 *p = (__u64 *)addr;
+	__be64 *p = (__be64 *)addr;
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(1))) == 0UL;
 #else
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
@@ -326,7 +326,7 @@ static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 static inline bool ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__u64 *p = (__u64 *)addr;
+	__be64 *p = (__be64 *)addr;
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(2))) == 0UL;
 #else
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
@@ -343,7 +343,7 @@ static inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)
 static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
 {
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
-	__u64 *p = (__u64 *)addr;
+	__be64 *p = (__be64 *)addr;
 	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |
 		((p[1] ^ cpu_to_be64(0x00000001ff000000UL)) &
 		 cpu_to_be64(0xffffffffff000000UL))) == 0UL;

commit 7c90cc2d40cab15adc78545edba8b5996bd4cade
Author: FX Le Bail <fx.lebail@yahoo.com>
Date:   Wed Jan 22 07:42:37 2014 +0100

    ipv6: enable anycast addresses as source addresses for datagrams
    
    This change allows to consider an anycast address valid as source address
    when given via an IPV6_PKTINFO or IPV6_2292PKTINFO ancillary data item.
    So, when sending a datagram with ancillary data, the unicast and anycast
    addresses are handled in the same way.
    
    - Adds ipv6_chk_acast_addr_src() to check if an anycast address is link-local
      on given interface or is global.
    - Uses it in ip6_datagram_send_ctl().
    
    Signed-off-by: Francois-Xavier Le Bail <fx.lebail@yahoo.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 66c4a44d8f5c..50e39a8822b4 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -205,8 +205,9 @@ void ipv6_sock_ac_close(struct sock *sk);
 int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
 int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
-				const struct in6_addr *addr);
-
+			 const struct in6_addr *addr);
+bool ipv6_chk_acast_addr_src(struct net *net, struct net_device *dev,
+			     const struct in6_addr *addr);
 
 /* Device notifier */
 int register_inet6addr_notifier(struct notifier_block *nb);

commit bba24896f022d4d239494bebf18e713cd8aec7a5
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Sat Dec 7 19:26:57 2013 +0100

    neigh: ipv6: respect default values set before an address is assigned to device
    
    Make the behaviour similar to ipv4. This will allow user to set sysctl
    default neigh param values and these values will be respected even by
    devices registered before (that ones what do not have address set yet).
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index e70278eef12a..66c4a44d8f5c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -248,6 +248,13 @@ static inline struct inet6_dev *in6_dev_get(const struct net_device *dev)
 	return idev;
 }
 
+static inline struct neigh_parms *__in6_dev_nd_parms_get_rcu(const struct net_device *dev)
+{
+	struct inet6_dev *idev = __in6_dev_get(dev);
+
+	return idev ? idev->nd_parms : NULL;
+}
+
 void in6_dev_finish_destroy(struct inet6_dev *idev);
 
 static inline void in6_dev_put(struct inet6_dev *idev)

commit 479840ffdbe4242e8a25349218c8e0859223aa35
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Dec 6 09:45:21 2013 +0100

    ipv6 addrconf: extend ifa_flags to u32
    
    There is no more space in u8 ifa_flags. So do what davem suffested and
    add another netlink attr called IFA_FLAGS for carry more flags.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: Thomas Haller <thaller@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 86505bfa5d2c..e70278eef12a 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -81,9 +81,9 @@ int ipv6_dev_get_saddr(struct net *net, const struct net_device *dev,
 		       const struct in6_addr *daddr, unsigned int srcprefs,
 		       struct in6_addr *saddr);
 int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
-		      unsigned char banned_flags);
+		      u32 banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
-		    unsigned char banned_flags);
+		    u32 banned_flags);
 int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);

commit 7df37ff33dc122f7bd0614d707939fe84322d264
Author: Catalin\(ux\) M. BOIE <catab@embedromix.ro>
Date:   Mon Sep 23 23:04:19 2013 +0300

    IPv6 NAT: Do not drop DNATed 6to4/6rd packets
    
    When a router is doing DNAT for 6to4/6rd packets the latest
    anti-spoofing commit 218774dc ("ipv6: add anti-spoofing checks for
    6to4 and 6rd") will drop them because the IPv6 address embedded does
    not match the IPv4 destination. This patch will allow them to pass by
    testing if we have an address that matches on 6to4/6rd interface.  I
    have been hit by this problem using Fedora and IPV6TO4_IPV4ADDR.
    Also, log the dropped packets (with rate limit).
    
    Signed-off-by: Catalin(ux) M. BOIE <catab@embedromix.ro>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index fb314de2b61b..86505bfa5d2c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -67,6 +67,10 @@ int ipv6_chk_addr(struct net *net, const struct in6_addr *addr,
 int ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr);
 #endif
 
+bool ipv6_chk_custom_prefix(const struct in6_addr *addr,
+				   const unsigned int prefix_len,
+				   struct net_device *dev);
+
 int ipv6_chk_prefix(const struct in6_addr *addr, struct net_device *dev);
 
 struct inet6_ifaddr *ipv6_get_ifaddr(struct net *net,

commit f564f45c451809aa3b74f577754528520d315ac1
Author: Cong Wang <amwang@redhat.com>
Date:   Sat Aug 31 13:44:36 2013 +0800

    vxlan: add ipv6 proxy support
    
    This patch adds the IPv6 version of "arp_reduce", ndisc_send_na()
    will be needed.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index bcf957341b62..fb314de2b61b 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -153,6 +153,10 @@ struct ipv6_stub {
 	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
 				struct flowi6 *fl6);
 	void (*udpv6_encap_enable)(void);
+	void (*ndisc_send_na)(struct net_device *dev, struct neighbour *neigh,
+			      const struct in6_addr *daddr,
+			      const struct in6_addr *solicited_addr,
+			      bool router, bool solicited, bool override, bool inc_opt);
 	struct neigh_table *nd_tbl;
 };
 extern const struct ipv6_stub *ipv6_stub __read_mostly;

commit e15a00aafa4b7953ad717d3cb1ad7acf4ff76945
Author: Cong Wang <amwang@redhat.com>
Date:   Sat Aug 31 13:44:34 2013 +0800

    vxlan: add ipv6 route short circuit support
    
    route short circuit only has IPv4 part, this patch adds
    the IPv6 part. nd_tbl will be needed.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 5339cab356bb..bcf957341b62 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -153,6 +153,7 @@ struct ipv6_stub {
 	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
 				struct flowi6 *fl6);
 	void (*udpv6_encap_enable)(void);
+	struct neigh_table *nd_tbl;
 };
 extern const struct ipv6_stub *ipv6_stub __read_mostly;
 

commit 5f81bd2e5d804ca93f3ec8873451b22d2f454721
Author: Cong Wang <amwang@redhat.com>
Date:   Sat Aug 31 13:44:30 2013 +0800

    ipv6: export a stub for IPv6 symbols used by vxlan
    
    In case IPv6 is compiled as a module, introduce a stub
    for ipv6_sock_mc_join and ipv6_sock_mc_drop etc.. It will be used
    by vxlan module. Suggested by Ben.
    
    This is an ugly but easy solution for now.
    
    Cc: Ben Hutchings <bhutchings@solarflare.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 43fa31a610b8..5339cab356bb 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -141,6 +141,21 @@ bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
 			 const struct in6_addr *src_addr);
 
 void ipv6_mc_dad_complete(struct inet6_dev *idev);
+
+/* A stub used by vxlan module. This is ugly, ideally these
+ * symbols should be built into the core kernel.
+ */
+struct ipv6_stub {
+	int (*ipv6_sock_mc_join)(struct sock *sk, int ifindex,
+				 const struct in6_addr *addr);
+	int (*ipv6_sock_mc_drop)(struct sock *sk, int ifindex,
+				 const struct in6_addr *addr);
+	int (*ipv6_dst_lookup)(struct sock *sk, struct dst_entry **dst,
+				struct flowi6 *fl6);
+	void (*udpv6_encap_enable)(void);
+};
+extern const struct ipv6_stub *ipv6_stub __read_mostly;
+
 /*
  * identify MLD packets for MLD filter exceptions
  */

commit e8e54d3c13b35479294f3dceb6bd6ed7a7dc5bf8
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 31 17:31:32 2013 -0700

    addrconf.h: Remove extern function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Reflow modified prototypes to 80 columns.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c7b181cb47a6..43fa31a610b8 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -53,51 +53,36 @@ struct prefix_info {
 #define IN6_ADDR_HSIZE_SHIFT	4
 #define IN6_ADDR_HSIZE		(1 << IN6_ADDR_HSIZE_SHIFT)
 
-extern int			addrconf_init(void);
-extern void			addrconf_cleanup(void);
+int addrconf_init(void);
+void addrconf_cleanup(void);
 
-extern int			addrconf_add_ifaddr(struct net *net,
-						    void __user *arg);
-extern int			addrconf_del_ifaddr(struct net *net,
-						    void __user *arg);
-extern int			addrconf_set_dstaddr(struct net *net,
-						     void __user *arg);
+int addrconf_add_ifaddr(struct net *net, void __user *arg);
+int addrconf_del_ifaddr(struct net *net, void __user *arg);
+int addrconf_set_dstaddr(struct net *net, void __user *arg);
 
-extern int			ipv6_chk_addr(struct net *net,
-					      const struct in6_addr *addr,
-					      const struct net_device *dev,
-					      int strict);
+int ipv6_chk_addr(struct net *net, const struct in6_addr *addr,
+		  const struct net_device *dev, int strict);
 
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
-extern int			ipv6_chk_home_addr(struct net *net,
-						   const struct in6_addr *addr);
+int ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr);
 #endif
 
-extern int			ipv6_chk_prefix(const struct in6_addr *addr,
-						struct net_device *dev);
-
-extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
-						 const struct in6_addr *addr,
-						 struct net_device *dev,
-						 int strict);
-
-extern int			ipv6_dev_get_saddr(struct net *net,
-					       const struct net_device *dev,
-					       const struct in6_addr *daddr,
-					       unsigned int srcprefs,
-					       struct in6_addr *saddr);
-extern int			__ipv6_get_lladdr(struct inet6_dev *idev,
-						  struct in6_addr *addr,
-						  unsigned char banned_flags);
-extern int			ipv6_get_lladdr(struct net_device *dev,
-						struct in6_addr *addr,
-						unsigned char banned_flags);
-extern int 			ipv6_rcv_saddr_equal(const struct sock *sk,
-						    const struct sock *sk2);
-extern void			addrconf_join_solict(struct net_device *dev,
-					const struct in6_addr *addr);
-extern void			addrconf_leave_solict(struct inet6_dev *idev,
-					const struct in6_addr *addr);
+int ipv6_chk_prefix(const struct in6_addr *addr, struct net_device *dev);
+
+struct inet6_ifaddr *ipv6_get_ifaddr(struct net *net,
+				     const struct in6_addr *addr,
+				     struct net_device *dev, int strict);
+
+int ipv6_dev_get_saddr(struct net *net, const struct net_device *dev,
+		       const struct in6_addr *daddr, unsigned int srcprefs,
+		       struct in6_addr *saddr);
+int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
+		      unsigned char banned_flags);
+int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
+		    unsigned char banned_flags);
+int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
+void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
+void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 
 static inline unsigned long addrconf_timeout_fixup(u32 timeout,
 						   unsigned int unit)
@@ -124,41 +109,38 @@ static inline int addrconf_finite_timeout(unsigned long timeout)
 /*
  *	IPv6 Address Label subsystem (addrlabel.c)
  */
-extern int			ipv6_addr_label_init(void);
-extern void			ipv6_addr_label_cleanup(void);
-extern void			ipv6_addr_label_rtnl_register(void);
-extern u32			ipv6_addr_label(struct net *net,
-						const struct in6_addr *addr,
-						int type, int ifindex);
+int ipv6_addr_label_init(void);
+void ipv6_addr_label_cleanup(void);
+void ipv6_addr_label_rtnl_register(void);
+u32 ipv6_addr_label(struct net *net, const struct in6_addr *addr,
+		    int type, int ifindex);
 
 /*
  *	multicast prototypes (mcast.c)
  */
-extern int ipv6_sock_mc_join(struct sock *sk, int ifindex,
-			     const struct in6_addr *addr);
-extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
-			     const struct in6_addr *addr);
-extern void ipv6_sock_mc_close(struct sock *sk);
-extern bool inet6_mc_check(struct sock *sk,
-			   const struct in6_addr *mc_addr,
-			   const struct in6_addr *src_addr);
-
-extern int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
-extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
-extern int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
-extern void ipv6_mc_up(struct inet6_dev *idev);
-extern void ipv6_mc_down(struct inet6_dev *idev);
-extern void ipv6_mc_unmap(struct inet6_dev *idev);
-extern void ipv6_mc_remap(struct inet6_dev *idev);
-extern void ipv6_mc_init_dev(struct inet6_dev *idev);
-extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
-extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
-
-extern bool ipv6_chk_mcast_addr(struct net_device *dev,
-				const struct in6_addr *group,
-				const struct in6_addr *src_addr);
-
-extern void ipv6_mc_dad_complete(struct inet6_dev *idev);
+int ipv6_sock_mc_join(struct sock *sk, int ifindex,
+		      const struct in6_addr *addr);
+int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
+		      const struct in6_addr *addr);
+void ipv6_sock_mc_close(struct sock *sk);
+bool inet6_mc_check(struct sock *sk, const struct in6_addr *mc_addr,
+		    const struct in6_addr *src_addr);
+
+int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
+int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
+int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
+void ipv6_mc_up(struct inet6_dev *idev);
+void ipv6_mc_down(struct inet6_dev *idev);
+void ipv6_mc_unmap(struct inet6_dev *idev);
+void ipv6_mc_remap(struct inet6_dev *idev);
+void ipv6_mc_init_dev(struct inet6_dev *idev);
+void ipv6_mc_destroy_dev(struct inet6_dev *idev);
+void addrconf_dad_failure(struct inet6_ifaddr *ifp);
+
+bool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,
+			 const struct in6_addr *src_addr);
+
+void ipv6_mc_dad_complete(struct inet6_dev *idev);
 /*
  * identify MLD packets for MLD filter exceptions
  */
@@ -184,29 +166,31 @@ static inline bool ipv6_is_mld(struct sk_buff *skb, int nexthdr, int offset)
 	return false;
 }
 
-extern void addrconf_prefix_rcv(struct net_device *dev,
-				u8 *opt, int len, bool sllao);
+void addrconf_prefix_rcv(struct net_device *dev,
+			 u8 *opt, int len, bool sllao);
 
 /*
  *	anycast prototypes (anycast.c)
  */
-extern int ipv6_sock_ac_join(struct sock *sk,int ifindex, const struct in6_addr *addr);
-extern int ipv6_sock_ac_drop(struct sock *sk,int ifindex, const struct in6_addr *addr);
-extern void ipv6_sock_ac_close(struct sock *sk);
-
-extern int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
-extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
-extern bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
+int ipv6_sock_ac_join(struct sock *sk, int ifindex,
+		      const struct in6_addr *addr);
+int ipv6_sock_ac_drop(struct sock *sk, int ifindex,
+		      const struct in6_addr *addr);
+void ipv6_sock_ac_close(struct sock *sk);
+
+int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
+int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
+bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 				const struct in6_addr *addr);
 
 
 /* Device notifier */
-extern int register_inet6addr_notifier(struct notifier_block *nb);
-extern int unregister_inet6addr_notifier(struct notifier_block *nb);
-extern int inet6addr_notifier_call_chain(unsigned long val, void *v);
+int register_inet6addr_notifier(struct notifier_block *nb);
+int unregister_inet6addr_notifier(struct notifier_block *nb);
+int inet6addr_notifier_call_chain(unsigned long val, void *v);
 
-extern void inet6_netconf_notify_devconf(struct net *net, int type, int ifindex,
-					 struct ipv6_devconf *devconf);
+void inet6_netconf_notify_devconf(struct net *net, int type, int ifindex,
+				  struct ipv6_devconf *devconf);
 
 /**
  * __in6_dev_get - get inet6_dev pointer from netdevice
@@ -240,7 +224,7 @@ static inline struct inet6_dev *in6_dev_get(const struct net_device *dev)
 	return idev;
 }
 
-extern void in6_dev_finish_destroy(struct inet6_dev *idev);
+void in6_dev_finish_destroy(struct inet6_dev *idev);
 
 static inline void in6_dev_put(struct inet6_dev *idev)
 {
@@ -258,7 +242,7 @@ static inline void in6_dev_hold(struct inet6_dev *idev)
 	atomic_inc(&idev->refcnt);
 }
 
-extern void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);
+void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);
 
 static inline void in6_ifa_put(struct inet6_ifaddr *ifp)
 {
@@ -340,8 +324,8 @@ static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
 }
 
 #ifdef CONFIG_PROC_FS
-extern int if6_proc_init(void);
-extern void if6_proc_exit(void);
+int if6_proc_init(void);
+void if6_proc_exit(void);
 #endif
 
 #endif

commit 8965779d2c0e6ab246c82a405236b1fb2adae6b2
Author: Amerigo Wang <amwang@redhat.com>
Date:   Sat Jun 29 21:30:49 2013 +0800

    ipv6,mcast: always hold idev->lock before mca_lock
    
    dingtianhong reported the following deadlock detected by lockdep:
    
     ======================================================
     [ INFO: possible circular locking dependency detected ]
     3.4.24.05-0.1-default #1 Not tainted
     -------------------------------------------------------
     ksoftirqd/0/3 is trying to acquire lock:
      (&ndev->lock){+.+...}, at: [<ffffffff8147f804>] ipv6_get_lladdr+0x74/0x120
    
     but task is already holding lock:
      (&mc->mca_lock){+.+...}, at: [<ffffffff8149d130>] mld_send_report+0x40/0x150
    
     which lock already depends on the new lock.
    
     the existing dependency chain (in reverse order) is:
    
     -> #1 (&mc->mca_lock){+.+...}:
            [<ffffffff810a8027>] validate_chain+0x637/0x730
            [<ffffffff810a8417>] __lock_acquire+0x2f7/0x500
            [<ffffffff810a8734>] lock_acquire+0x114/0x150
            [<ffffffff814f691a>] rt_spin_lock+0x4a/0x60
            [<ffffffff8149e4bb>] igmp6_group_added+0x3b/0x120
            [<ffffffff8149e5d8>] ipv6_mc_up+0x38/0x60
            [<ffffffff81480a4d>] ipv6_find_idev+0x3d/0x80
            [<ffffffff81483175>] addrconf_notify+0x3d5/0x4b0
            [<ffffffff814fae3f>] notifier_call_chain+0x3f/0x80
            [<ffffffff81073471>] raw_notifier_call_chain+0x11/0x20
            [<ffffffff813d8722>] call_netdevice_notifiers+0x32/0x60
            [<ffffffff813d92d4>] __dev_notify_flags+0x34/0x80
            [<ffffffff813d9360>] dev_change_flags+0x40/0x70
            [<ffffffff813ea627>] do_setlink+0x237/0x8a0
            [<ffffffff813ebb6c>] rtnl_newlink+0x3ec/0x600
            [<ffffffff813eb4d0>] rtnetlink_rcv_msg+0x160/0x310
            [<ffffffff814040b9>] netlink_rcv_skb+0x89/0xb0
            [<ffffffff813eb357>] rtnetlink_rcv+0x27/0x40
            [<ffffffff81403e20>] netlink_unicast+0x140/0x180
            [<ffffffff81404a9e>] netlink_sendmsg+0x33e/0x380
            [<ffffffff813c4252>] sock_sendmsg+0x112/0x130
            [<ffffffff813c537e>] __sys_sendmsg+0x44e/0x460
            [<ffffffff813c5544>] sys_sendmsg+0x44/0x70
            [<ffffffff814feab9>] system_call_fastpath+0x16/0x1b
    
     -> #0 (&ndev->lock){+.+...}:
            [<ffffffff810a798e>] check_prev_add+0x3de/0x440
            [<ffffffff810a8027>] validate_chain+0x637/0x730
            [<ffffffff810a8417>] __lock_acquire+0x2f7/0x500
            [<ffffffff810a8734>] lock_acquire+0x114/0x150
            [<ffffffff814f6c82>] rt_read_lock+0x42/0x60
            [<ffffffff8147f804>] ipv6_get_lladdr+0x74/0x120
            [<ffffffff8149b036>] mld_newpack+0xb6/0x160
            [<ffffffff8149b18b>] add_grhead+0xab/0xc0
            [<ffffffff8149d03b>] add_grec+0x3ab/0x460
            [<ffffffff8149d14a>] mld_send_report+0x5a/0x150
            [<ffffffff8149f99e>] igmp6_timer_handler+0x4e/0xb0
            [<ffffffff8105705a>] call_timer_fn+0xca/0x1d0
            [<ffffffff81057b9f>] run_timer_softirq+0x1df/0x2e0
            [<ffffffff8104e8c7>] handle_pending_softirqs+0xf7/0x1f0
            [<ffffffff8104ea3b>] __do_softirq_common+0x7b/0xf0
            [<ffffffff8104f07f>] __thread_do_softirq+0x1af/0x210
            [<ffffffff8104f1c1>] run_ksoftirqd+0xe1/0x1f0
            [<ffffffff8106c7de>] kthread+0xae/0xc0
            [<ffffffff814fff74>] kernel_thread_helper+0x4/0x10
    
    actually we can just hold idev->lock before taking pmc->mca_lock,
    and avoid taking idev->lock again when iterating idev->addr_list,
    since the upper callers of mld_newpack() already take
    read_lock_bh(&idev->lock).
    
    Reported-by: dingtianhong <dingtianhong@huawei.com>
    Cc: dingtianhong <dingtianhong@huawei.com>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Tested-by: Ding Tianhong <dingtianhong@huawei.com>
    Tested-by: Chen Weilong <chenweilong@huawei.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f68eaf574d7e..c7b181cb47a6 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -86,6 +86,9 @@ extern int			ipv6_dev_get_saddr(struct net *net,
 					       const struct in6_addr *daddr,
 					       unsigned int srcprefs,
 					       struct in6_addr *saddr);
+extern int			__ipv6_get_lladdr(struct inet6_dev *idev,
+						  struct in6_addr *addr,
+						  unsigned char banned_flags);
 extern int			ipv6_get_lladdr(struct net_device *dev,
 						struct in6_addr *addr,
 						unsigned char banned_flags);

commit b173ee488dcc545e77ed482158a2f0d06d7a5860
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Jun 27 00:07:01 2013 +0200

    ipv6: resend MLD report if a link-local address completes DAD
    
    RFC3590/RFC3810 specifies we should resend MLD reports as soon as a
    valid link-local address is available.
    
    We now use the valid_ll_addr_cnt to check if it is necessary to resend
    a new report.
    
    Changes since Flavio Leitner's version:
    a) adapt for valid_ll_addr_cnt
    b) resend first reports directly in the path and just arm the timer for
       mc_qrv-1 resends.
    
    Reported-by: Flavio Leitner <fleitner@redhat.com>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Flavio Leitner <fbl@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 21f702704f24..f68eaf574d7e 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -155,6 +155,7 @@ extern bool ipv6_chk_mcast_addr(struct net_device *dev,
 				const struct in6_addr *group,
 				const struct in6_addr *src_addr);
 
+extern void ipv6_mc_dad_complete(struct inet6_dev *idev);
 /*
  * identify MLD packets for MLD filter exceptions
  */

commit 2a7851bffb008ff4882eee673da74718997b4265
Author: Florian Westphal <fw@strlen.de>
Date:   Fri May 17 03:56:10 2013 +0000

    netfilter: add nf_ipv6_ops hook to fix xt_addrtype with IPv6
    
    Quoting https://bugzilla.netfilter.org/show_bug.cgi?id=812:
    
    [ ip6tables -m addrtype ]
    When I tried to use in the nat/PREROUTING it messes up the
    routing cache even if the rule didn't matched at all.
    [..]
    If I remove the --limit-iface-in from the non-working scenario, so just
    use the -m addrtype --dst-type LOCAL it works!
    
    This happens when LOCAL type matching is requested with --limit-iface-in,
    and the default ipv6 route is via the interface the packet we test
    arrived on.
    
    Because xt_addrtype uses ip6_route_output, the ipv6 routing implementation
    creates an unwanted cached entry, and the packet won't make it to the
    real/expected destination.
    
    Silently ignoring --limit-iface-in makes the routing work but it breaks
    rule matching (--dst-type LOCAL with limit-iface-in is supposed to only
    match if the dst address is configured on the incoming interface;
    without --limit-iface-in it will match if the address is reachable
    via lo).
    
    The test should call ipv6_chk_addr() instead.  However, this would add
    a link-time dependency on ipv6.
    
    There are two possible solutions:
    
    1) Revert the commit that moved ipt_addrtype to xt_addrtype,
       and put ipv6 specific code into ip6t_addrtype.
    2) add new "nf_ipv6_ops" struct to register pointers to ipv6 functions.
    
    While the former might seem preferable, Pablo pointed out that there
    are more xt modules with link-time dependeny issues regarding ipv6,
    so lets go for 2).
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 84a6440f1f19..21f702704f24 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -65,7 +65,7 @@ extern int			addrconf_set_dstaddr(struct net *net,
 
 extern int			ipv6_chk_addr(struct net *net,
 					      const struct in6_addr *addr,
-					      struct net_device *dev,
+					      const struct net_device *dev,
 					      int strict);
 
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)

commit f88c91ddba958e9a5dd4a5ee8c52a0faa790f586
Author: Cong Wang <amwang@redhat.com>
Date:   Sun Apr 14 23:18:43 2013 +0800

    ipv6: statically link register_inet6addr_notifier()
    
    Tomas reported the following build error:
    
    net/built-in.o: In function `ieee80211_unregister_hw':
    (.text+0x10f0e1): undefined reference to `unregister_inet6addr_notifier'
    net/built-in.o: In function `ieee80211_register_hw':
    (.text+0x10f610): undefined reference to `register_inet6addr_notifier'
    make: *** [vmlinux] Error 1
    
    when built IPv6 as a module.
    
    So we have to statically link these symbols.
    
    Reported-by: Tomas Melin <tomas.melin@iki.fi>
    Cc: Tomas Melin <tomas.melin@iki.fi>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: YOSHIFUJI Hidaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 40be2a0d8ae1..84a6440f1f19 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -199,6 +199,7 @@ extern bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 /* Device notifier */
 extern int register_inet6addr_notifier(struct notifier_block *nb);
 extern int unregister_inet6addr_notifier(struct notifier_block *nb);
+extern int inet6addr_notifier_call_chain(unsigned long val, void *v);
 
 extern void inet6_netconf_notify_devconf(struct net *net, int type, int ifindex,
 					 struct ipv6_devconf *devconf);

commit 5c766d642bcaffd0c2a5b354db2068515b3846cf
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Thu Jan 24 09:41:41 2013 +0000

    ipv4: introduce address lifetime
    
    There are some usecase when lifetime of ipv4 addresses might be helpful.
    For example:
    1) initramfs networkmanager uses a DHCP daemon to learn network
    configuration parameters
    2) initramfs networkmanager addresses, routes and DNS configuration
    3) initramfs networkmanager is requested to stop
    4) initramfs networkmanager stops all daemons including dhclient
    5) there are addresses and routes configured but no daemon running. If
    the system doesn't start networkmanager for some reason, addresses and
    routes will be used forever, which violates RFC 2131.
    
    This patch is essentially a backport of ivp6 address lifetime mechanism
    for ipv4 addresses.
    
    Current "ip" tool supports this without any patch (since it does not
    distinguish between ipv4 and ipv6 addresses in this perspective.
    
    Also, this should be back-compatible with all current netlink users.
    
    Reported-by: Pavel Šimerda <psimerda@redhat.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 6c58d507123f..40be2a0d8ae1 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -15,6 +15,10 @@
 
 #define IPV6_MAX_ADDRESSES		16
 
+#define ADDRCONF_TIMER_FUZZ_MINUS	(HZ > 50 ? HZ / 50 : 1)
+#define ADDRCONF_TIMER_FUZZ		(HZ / 4)
+#define ADDRCONF_TIMER_FUZZ_MAX		(HZ)
+
 #include <linux/in.h>
 #include <linux/in6.h>
 

commit d1641565f6926c2e9f5859d81bc6f72fc0e1ad76
Author: YOSHIFUJI Hideaki / 吉藤英明 <yoshfuji@linux-ipv6.org>
Date:   Sun Jan 20 07:38:52 2013 +0000

    ipv6: Optimize ipv6_addr_is_ll_all_{nodes,routers}().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 9dc5efc3b0d6..6c58d507123f 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -288,16 +288,26 @@ static inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)
 
 static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
+	__u64 *p = (__u64 *)addr;
+	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(1))) == 0UL;
+#else
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
 		addr->s6_addr32[1] | addr->s6_addr32[2] |
 		(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0;
+#endif
 }
 
 static inline bool ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
+	__u64 *p = (__u64 *)addr;
+	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) | (p[1] ^ cpu_to_be64(2))) == 0UL;
+#else
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
 		addr->s6_addr32[1] | addr->s6_addr32[2] |
 		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0;
+#endif
 }
 
 static inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)

commit 9d1007740041613bae8492be092932a3f0eb1ebf
Author: YOSHIFUJI Hideaki / 吉藤英明 <yoshfuji@linux-ipv6.org>
Date:   Sun Jan 20 07:39:07 2013 +0000

    ipv6: Optimize ipv6_addr_is_solict_mult().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 3a3eeb407f4b..9dc5efc3b0d6 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -307,10 +307,17 @@ static inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)
 
 static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
 {
-	return (addr->s6_addr32[0] == htonl(0xff020000) &&
-		addr->s6_addr32[1] == htonl(0x00000000) &&
-		addr->s6_addr32[2] == htonl(0x00000001) &&
-		addr->s6_addr[12] == 0xff);
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && BITS_PER_LONG == 64
+	__u64 *p = (__u64 *)addr;
+	return ((p[0] ^ cpu_to_be64(0xff02000000000000UL)) |
+		((p[1] ^ cpu_to_be64(0x00000001ff000000UL)) &
+		 cpu_to_be64(0xffffffffff000000UL))) == 0UL;
+#else
+	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
+		addr->s6_addr32[1] |
+		(addr->s6_addr32[2] ^ htonl(0x00000001)) |
+		(addr->s6_addr[12] ^ 0xff)) == 0;
+#endif
 }
 
 #ifdef CONFIG_PROC_FS

commit ca97a644d752b46e5e08526e36705c3b0dd03f5f
Author: YOSHIFUJI Hideaki / 吉藤英明 <yoshfuji@linux-ipv6.org>
Date:   Sun Jan 20 07:39:00 2013 +0000

    ipv6: Introduce ipv6_addr_is_solict_mult() to check Solicited Node Multicast Addresses.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c6a44213fc74..3a3eeb407f4b 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -305,6 +305,14 @@ static inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)
 	return (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);
 }
 
+static inline bool ipv6_addr_is_solict_mult(const struct in6_addr *addr)
+{
+	return (addr->s6_addr32[0] == htonl(0xff020000) &&
+		addr->s6_addr32[1] == htonl(0x00000000) &&
+		addr->s6_addr32[2] == htonl(0x00000001) &&
+		addr->s6_addr[12] == 0xff);
+}
+
 #ifdef CONFIG_PROC_FS
 extern int if6_proc_init(void);
 extern void if6_proc_exit(void);

commit b27b28cb445975dc02d2e7d9437d23af76a51571
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Mon Jan 21 02:38:38 2013 +0900

    ipv6: Make ipv6_addr_is_XXX() return boolean.
    
    ipv6_addr_is_{multicast,ll_all_nodes,ll_all_routers,isatap}()
    return boolean.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 7cd14c007fc5..c6a44213fc74 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -281,26 +281,26 @@ static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
 		      htonl(0xFF000000) | addr->s6_addr32[3]);
 }
 
-static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
+static inline bool ipv6_addr_is_multicast(const struct in6_addr *addr)
 {
 	return (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);
 }
 
-static inline int ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
+static inline bool ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
 		addr->s6_addr32[1] | addr->s6_addr32[2] |
 		(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0;
 }
 
-static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
+static inline bool ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
 	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
 		addr->s6_addr32[1] | addr->s6_addr32[2] |
 		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0;
 }
 
-static inline int ipv6_addr_is_isatap(const struct in6_addr *addr)
+static inline bool ipv6_addr_is_isatap(const struct in6_addr *addr)
 {
 	return (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);
 }

commit daad151263cf334d57fcc0270e2483d4b4639650
Author: YOSHIFUJI Hideaki / 吉藤英明 <yoshfuji@linux-ipv6.org>
Date:   Sun Jan 13 05:02:18 2013 +0000

    ipv6: Make ipv6_is_mld() inline and use it from ip6_mc_input().
    
    Move generalized version of ipv6_is_mld() to header,
    and use it from ip6_mc_input().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index df4ef9453384..7cd14c007fc5 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -150,7 +150,31 @@ extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 extern bool ipv6_chk_mcast_addr(struct net_device *dev,
 				const struct in6_addr *group,
 				const struct in6_addr *src_addr);
-extern bool ipv6_is_mld(struct sk_buff *skb, int nexthdr);
+
+/*
+ * identify MLD packets for MLD filter exceptions
+ */
+static inline bool ipv6_is_mld(struct sk_buff *skb, int nexthdr, int offset)
+{
+	struct icmp6hdr *hdr;
+
+	if (nexthdr != IPPROTO_ICMPV6 ||
+	    !pskb_network_may_pull(skb, offset + sizeof(struct icmp6hdr)))
+		return false;
+
+	hdr = (struct icmp6hdr *)(skb_network_header(skb) + offset);
+
+	switch (hdr->icmp6_type) {
+	case ICMPV6_MGM_QUERY:
+	case ICMPV6_MGM_REPORT:
+	case ICMPV6_MGM_REDUCTION:
+	case ICMPV6_MLD2_REPORT:
+		return true;
+	default:
+		break;
+	}
+	return false;
+}
 
 extern void addrconf_prefix_rcv(struct net_device *dev,
 				u8 *opt, int len, bool sllao);

commit d67b8c616b48df30e2836d797795f2420d109bc9
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Tue Dec 4 01:13:35 2012 +0000

    netconf: advertise mc_forwarding status
    
    This patch advertise the MC_FORWARDING status for IPv4 and IPv6.
    This field is readonly, only multicast engine in the kernel updates it.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 9e63e76b20e7..df4ef9453384 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -172,6 +172,9 @@ extern bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 extern int register_inet6addr_notifier(struct notifier_block *nb);
 extern int unregister_inet6addr_notifier(struct notifier_block *nb);
 
+extern void inet6_netconf_notify_devconf(struct net *net, int type, int ifindex,
+					 struct ipv6_devconf *devconf);
+
 /**
  * __in6_dev_get - get inet6_dev pointer from netdevice
  * @dev: network device

commit b3f644fc8232ca761da0b5c5ccb6f30b423c4302
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 26 19:14:14 2012 +0200

    netfilter: ip6tables: add MASQUERADE target
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 089a09d001d1..9e63e76b20e7 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -78,7 +78,7 @@ extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
 						 int strict);
 
 extern int			ipv6_dev_get_saddr(struct net *net,
-					       struct net_device *dev,
+					       const struct net_device *dev,
 					       const struct in6_addr *daddr,
 					       unsigned int srcprefs,
 					       struct in6_addr *saddr);

commit ddbe503203855939946430e39bae58de11b70b69
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Jul 18 08:11:12 2012 +0000

    ipv6: add ipv6_addr_hash() helper
    
    Introduce ipv6_addr_hash() helper doing a XOR on all bits
    of an IPv6 address, with an optimized x86_64 version.
    
    Use it in flow dissector, as suggested by Andrew McGregor,
    to reduce hash collision probabilities in fq_codel (and other
    users of flow dissector)
    
    Use it in ip6_tunnel.c and use more bit shuffling, as suggested
    by David Laight, as existing hash was ignoring most of them.
    
    Use it in sunrpc and use more bit shuffling, using hash_32().
    
    Use it in net/ipv6/addrconf.c, using hash_32() as well.
    
    As a cleanup, use it in net/ipv4/tcp_metrics.c
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Andrew McGregor <andrewmcgr@gmail.com>
    Cc: Dave Taht <dave.taht@gmail.com>
    Cc: Tom Herbert <therbert@google.com>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f2b801c4b555..089a09d001d1 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -46,7 +46,8 @@ struct prefix_info {
 #include <net/if_inet6.h>
 #include <net/ipv6.h>
 
-#define IN6_ADDR_HSIZE		16
+#define IN6_ADDR_HSIZE_SHIFT	4
+#define IN6_ADDR_HSIZE		(1 << IN6_ADDR_HSIZE_SHIFT)
 
 extern int			addrconf_init(void);
 extern void			addrconf_cleanup(void);

commit a50feda546ac03415707a9bbcac8d6b20714db21
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri May 18 18:57:34 2012 +0000

    ipv6: bool/const conversions phase2
    
    Mostly bool conversions, some inline removals and const additions.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 27f450ba9514..f2b801c4b555 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -131,9 +131,9 @@ extern int ipv6_sock_mc_join(struct sock *sk, int ifindex,
 extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
 			     const struct in6_addr *addr);
 extern void ipv6_sock_mc_close(struct sock *sk);
-extern int inet6_mc_check(struct sock *sk,
-			  const struct in6_addr *mc_addr,
-			  const struct in6_addr *src_addr);
+extern bool inet6_mc_check(struct sock *sk,
+			   const struct in6_addr *mc_addr,
+			   const struct in6_addr *src_addr);
 
 extern int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
 extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
@@ -146,10 +146,10 @@ extern void ipv6_mc_init_dev(struct inet6_dev *idev);
 extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 
-extern int ipv6_chk_mcast_addr(struct net_device *dev,
-			       const struct in6_addr *group,
-			       const struct in6_addr *src_addr);
-extern int ipv6_is_mld(struct sk_buff *skb, int nexthdr);
+extern bool ipv6_chk_mcast_addr(struct net_device *dev,
+				const struct in6_addr *group,
+				const struct in6_addr *src_addr);
+extern bool ipv6_is_mld(struct sk_buff *skb, int nexthdr);
 
 extern void addrconf_prefix_rcv(struct net_device *dev,
 				u8 *opt, int len, bool sllao);
@@ -163,8 +163,8 @@ extern void ipv6_sock_ac_close(struct sock *sk);
 
 extern int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
 extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
-extern int ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
-			       const struct in6_addr *addr);
+extern bool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
+				const struct in6_addr *addr);
 
 
 /* Device notifier */

commit 95c961747284a6b83a5e2d81240e214b0fa3464d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sun Apr 15 05:58:06 2012 +0000

    net: cleanup unsigned to unsigned int
    
    Use of "unsigned int" is preferred to bare "unsigned" in net tree.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 757a17638b1b..27f450ba9514 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -92,7 +92,7 @@ extern void			addrconf_leave_solict(struct inet6_dev *idev,
 					const struct in6_addr *addr);
 
 static inline unsigned long addrconf_timeout_fixup(u32 timeout,
-						    unsigned unit)
+						   unsigned int unit)
 {
 	if (timeout == 0xffffffff)
 		return ~0UL;

commit f79d52c254e4e2cef3da64dc02ade3bc8f10c539
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Feb 1 16:14:17 2012 -0500

    ipv6: Remove never used function inet6_ac_check().
    
    It went from unused, to commented out, and never changing after
    that.
    
    Just get rid of it, if someone wants it they can unearth it from
    the history.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f68dce2d8d88..757a17638b1b 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -160,7 +160,6 @@ extern void addrconf_prefix_rcv(struct net_device *dev,
 extern int ipv6_sock_ac_join(struct sock *sk,int ifindex, const struct in6_addr *addr);
 extern int ipv6_sock_ac_drop(struct sock *sk,int ifindex, const struct in6_addr *addr);
 extern void ipv6_sock_ac_close(struct sock *sk);
-extern int inet6_ac_check(struct sock *sk, const struct in6_addr *addr, int ifindex);
 
 extern int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
 extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);

commit e6bff995f8fe78f74cbe8f14bf6a31f3560b9ce4
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jan 4 10:49:15 2012 +0000

    ipv6: Check RA for sllao when configuring optimistic ipv6 address (v2)
    
    Recently Dave noticed that a test we did in ipv6_add_addr to see if we next hop
    route for the interface we're adding an addres to was wrong (see commit
    7ffbcecbeed91e5874e9a1cfc4c0cbb07dac3069).  for one, it never triggers, and two,
    it was completely wrong to begin with.  This test was meant to cover this
    section of RFC 4429:
    
    3.3 Modifications to RFC 2462 Stateless Address Autoconfiguration
    
       * (modifies section 5.5) A host MAY choose to configure a new address
            as an Optimistic Address.  A host that does not know the SLLAO
            of its router SHOULD NOT configure a new address as Optimistic.
            A router SHOULD NOT configure an Optimistic Address.
    
    This patch should bring us into proper compliance with the above clause.  Since
    we only add a SLAAC address after we've received a RA which may or may not
    contain a source link layer address option, we can pass a pointer to that option
    to addrconf_prefix_rcv (which may be null if the option is not present), and
    only set the optimistic flag if the option was found in the RA.
    
    Change notes:
    (v2) modified the new parameter to addrconf_prefix_rcv to be a bool rather than
    a pointer to make its use more clear as per request from davem.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index cbc6bb0a6838..f68dce2d8d88 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -151,7 +151,8 @@ extern int ipv6_chk_mcast_addr(struct net_device *dev,
 			       const struct in6_addr *src_addr);
 extern int ipv6_is_mld(struct sk_buff *skb, int nexthdr);
 
-extern void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len);
+extern void addrconf_prefix_rcv(struct net_device *dev,
+				u8 *opt, int len, bool sllao);
 
 /*
  *	anycast prototypes (anycast.c)

commit 76f793e3a47139d340185cbc1a314740c09b13d3
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Tue Jul 26 13:50:49 2011 +0000

    ipv6: updates to privacy addresses per RFC 4941.
    
    Update the code to handle some of the differences between
    RFC 3041 and RFC 4941, which obsoletes it. Also a couple
    of janitorial fixes.
    
    - Allow router advertisements to increase the lifetime of
      temporary addresses. This was not allowed by RFC 3041,
      but is specified by RFC 4941. It is useful when RA
      lifetimes are lower than TEMP_{VALID,PREFERRED}_LIFETIME:
      in this case, the previous code would delete or deprecate
      addresses prematurely.
    
    - Change the default of MAX_RETRY to 3 per RFC 4941.
    
    - Add a comment to clarify that the preferred and valid
      lifetimes in inet6_ifaddr are relative to the timestamp.
    
    - Shorten lines to 80 characters in a couple of places.
    
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 582e4ae70753..cbc6bb0a6838 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -8,7 +8,7 @@
 
 #define TEMP_VALID_LIFETIME		(7*86400)
 #define TEMP_PREFERRED_LIFETIME		(86400)
-#define REGEN_MAX_RETRY			(5)
+#define REGEN_MAX_RETRY			(3)
 #define MAX_DESYNC_FACTOR		(600)
 
 #define ADDR_CHECK_FREQUENCY		(120*HZ)

commit 2a9e9507011440a57d6356ded630ba0c0f5d4b77
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Apr 24 10:54:56 2011 -0700

    net: Remove __KERNEL__ cpp checks from include/net
    
    These header files are never installed to user consumption, so any
    __KERNEL__ cpp checks are superfluous.
    
    Projects should also not copy these files into their userland utility
    sources and try to use them there.  If they insist on doing so, the
    onus is on them to sanitize the headers as needed.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 7c4d92c0dd1d..582e4ae70753 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -42,8 +42,6 @@ struct prefix_info {
 };
 
 
-#ifdef __KERNEL__
-
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
 #include <net/ipv6.h>
@@ -285,4 +283,3 @@ extern void if6_proc_exit(void);
 #endif
 
 #endif
-#endif

commit b71d1d426d263b0b6cb5760322efebbfc89d4463
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Fri Apr 22 04:53:02 2011 +0000

    inet: constify ip headers and in6_addr
    
    Add const qualifiers to structs iphdr, ipv6hdr and in6_addr pointers
    where possible, to make code intention more obvious.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 23710aa6a181..7c4d92c0dd1d 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -61,16 +61,16 @@ extern int			addrconf_set_dstaddr(struct net *net,
 						     void __user *arg);
 
 extern int			ipv6_chk_addr(struct net *net,
-					      struct in6_addr *addr,
+					      const struct in6_addr *addr,
 					      struct net_device *dev,
 					      int strict);
 
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 extern int			ipv6_chk_home_addr(struct net *net,
-						   struct in6_addr *addr);
+						   const struct in6_addr *addr);
 #endif
 
-extern int			ipv6_chk_prefix(struct in6_addr *addr,
+extern int			ipv6_chk_prefix(const struct in6_addr *addr,
 						struct net_device *dev);
 
 extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
@@ -89,9 +89,9 @@ extern int			ipv6_get_lladdr(struct net_device *dev,
 extern int 			ipv6_rcv_saddr_equal(const struct sock *sk,
 						    const struct sock *sk2);
 extern void			addrconf_join_solict(struct net_device *dev,
-					struct in6_addr *addr);
+					const struct in6_addr *addr);
 extern void			addrconf_leave_solict(struct inet6_dev *idev,
-					struct in6_addr *addr);
+					const struct in6_addr *addr);
 
 static inline unsigned long addrconf_timeout_fixup(u32 timeout,
 						    unsigned unit)
@@ -158,15 +158,15 @@ extern void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len);
 /*
  *	anycast prototypes (anycast.c)
  */
-extern int ipv6_sock_ac_join(struct sock *sk,int ifindex,struct in6_addr *addr);
-extern int ipv6_sock_ac_drop(struct sock *sk,int ifindex,struct in6_addr *addr);
+extern int ipv6_sock_ac_join(struct sock *sk,int ifindex, const struct in6_addr *addr);
+extern int ipv6_sock_ac_drop(struct sock *sk,int ifindex, const struct in6_addr *addr);
 extern void ipv6_sock_ac_close(struct sock *sk);
-extern int inet6_ac_check(struct sock *sk, struct in6_addr *addr, int ifindex);
+extern int inet6_ac_check(struct sock *sk, const struct in6_addr *addr, int ifindex);
 
-extern int ipv6_dev_ac_inc(struct net_device *dev, struct in6_addr *addr);
-extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, struct in6_addr *addr);
+extern int ipv6_dev_ac_inc(struct net_device *dev, const struct in6_addr *addr);
+extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr);
 extern int ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
-			       struct in6_addr *addr);
+			       const struct in6_addr *addr);
 
 
 /* Device notifier */

commit dca9b2404a6d6579828da2425c051462701efd3f
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Wed Dec 1 18:05:17 2010 +0000

    net: kill unused macros from head file
    
    These macros have been defined for several years since v2.6.12-rc2（tracing by git）,
    but never be used. So remove them.
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index a9441249306c..23710aa6a181 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -1,8 +1,6 @@
 #ifndef _ADDRCONF_H
 #define _ADDRCONF_H
 
-#define RETRANS_TIMER	HZ
-
 #define MAX_RTR_SOLICITATIONS		3
 #define RTR_SOLICITATION_INTERVAL	(4*HZ)
 

commit c61393ea83573ff422af505b6fd49ef9ec9b91ca
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Oct 4 20:17:53 2010 +0000

    ipv6: make __ipv6_isatap_ifid static
    
    Another exported symbol only used in one file
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 958d2749b7a9..a9441249306c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -276,8 +276,6 @@ static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0;
 }
 
-extern int __ipv6_isatap_ifid(u8 *eui, __be32 addr);
-
 static inline int ipv6_addr_is_isatap(const struct in6_addr *addr)
 {
 	return (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);

commit e40051d134f7ee95c8c1f7a3471e84eafc9ab326
Merge: 42099d7a3941 2cc6d2bf3d61
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Sep 27 01:03:03 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/qlcnic/qlcnic_init.c
            net/ipv4/ip_output.c

commit 2cc6d2bf3d6195fabcf0febc192c01f99519a8f3
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Fri Sep 24 09:55:52 2010 +0000

    ipv6: add a missing unregister_pernet_subsys call
    
    Clean up a missing exit path in the ipv6 module init routines.  In
    addrconf_init we call ipv6_addr_label_init which calls register_pernet_subsys
    for the ipv6_addr_label_ops structure.  But if module loading fails, or if the
    ipv6 module is removed, there is no corresponding unregister_pernet_subsys call,
    which leaves a now-bogus address on the pernet_list, leading to oopses in
    subsequent registrations.  This patch cleans up both the failed load path and
    the unload path.  Tested by myself with good results.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    
     include/net/addrconf.h |    1 +
     net/ipv6/addrconf.c    |   11 ++++++++---
     net/ipv6/addrlabel.c   |    5 +++++
     3 files changed, 14 insertions(+), 3 deletions(-)
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 45375b41a2a0..4d40c4d0230b 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -121,6 +121,7 @@ static inline int addrconf_finite_timeout(unsigned long timeout)
  *	IPv6 Address Label subsystem (addrlabel.c)
  */
 extern int			ipv6_addr_label_init(void);
+extern void			ipv6_addr_label_cleanup(void);
 extern void			ipv6_addr_label_rtnl_register(void);
 extern u32			ipv6_addr_label(struct net *net,
 						const struct in6_addr *addr,

commit 48daa3bb84d547828871534caa51427a3fe90748
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Sep 21 06:57:39 2010 +0000

    ipv6: addrconf.h cleanups
    
    - Use rcu_dereference_rtnl() in __in6_dev_get
    - kerneldoc for __in6_dev_get() and in6_dev_get()
    - Use inline functions instead of macros
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 45375b41a2a0..7d178a758acf 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -174,20 +174,32 @@ extern int ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
 extern int register_inet6addr_notifier(struct notifier_block *nb);
 extern int unregister_inet6addr_notifier(struct notifier_block *nb);
 
-static inline struct inet6_dev *
-__in6_dev_get(struct net_device *dev)
+/**
+ * __in6_dev_get - get inet6_dev pointer from netdevice
+ * @dev: network device
+ *
+ * Caller must hold rcu_read_lock or RTNL, because this function
+ * does not take a reference on the inet6_dev.
+ */
+static inline struct inet6_dev *__in6_dev_get(const struct net_device *dev)
 {
-	return rcu_dereference_check(dev->ip6_ptr,
-				     rcu_read_lock_held() ||
-				     lockdep_rtnl_is_held());
+	return rcu_dereference_rtnl(dev->ip6_ptr);
 }
 
-static inline struct inet6_dev *
-in6_dev_get(struct net_device *dev)
+/**
+ * in6_dev_get - get inet6_dev pointer from netdevice
+ * @dev: network device
+ *
+ * This version can be used in any context, and takes a reference
+ * on the inet6_dev. Callers must use in6_dev_put() later to
+ * release this reference.
+ */
+static inline struct inet6_dev *in6_dev_get(const struct net_device *dev)
 {
-	struct inet6_dev *idev = NULL;
+	struct inet6_dev *idev;
+
 	rcu_read_lock();
-	idev = __in6_dev_get(dev);
+	idev = rcu_dereference(dev->ip6_ptr);
 	if (idev)
 		atomic_inc(&idev->refcnt);
 	rcu_read_unlock();
@@ -196,16 +208,21 @@ in6_dev_get(struct net_device *dev)
 
 extern void in6_dev_finish_destroy(struct inet6_dev *idev);
 
-static inline void
-in6_dev_put(struct inet6_dev *idev)
+static inline void in6_dev_put(struct inet6_dev *idev)
 {
 	if (atomic_dec_and_test(&idev->refcnt))
 		in6_dev_finish_destroy(idev);
 }
 
-#define __in6_dev_put(idev)  atomic_dec(&(idev)->refcnt)
-#define in6_dev_hold(idev)   atomic_inc(&(idev)->refcnt)
+static inline void __in6_dev_put(struct inet6_dev *idev)
+{
+	atomic_dec(&idev->refcnt);
+}
 
+static inline void in6_dev_hold(struct inet6_dev *idev)
+{
+	atomic_inc(&idev->refcnt);
+}
 
 extern void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);
 
@@ -215,9 +232,15 @@ static inline void in6_ifa_put(struct inet6_ifaddr *ifp)
 		inet6_ifa_finish_destroy(ifp);
 }
 
-#define __in6_ifa_put(ifp)	atomic_dec(&(ifp)->refcnt)
-#define in6_ifa_hold(ifp)	atomic_inc(&(ifp)->refcnt)
+static inline void __in6_ifa_put(struct inet6_ifaddr *ifp)
+{
+	atomic_dec(&ifp->refcnt);
+}
 
+static inline void in6_ifa_hold(struct inet6_ifaddr *ifp)
+{
+	atomic_inc(&ifp->refcnt);
+}
 
 
 /*
@@ -240,23 +263,23 @@ static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
 
 static inline int ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
-	return (((addr->s6_addr32[0] ^ htonl(0xff020000)) |
+	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
 		addr->s6_addr32[1] | addr->s6_addr32[2] |
-		(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0);
+		(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0;
 }
 
 static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
-	return (((addr->s6_addr32[0] ^ htonl(0xff020000)) |
+	return ((addr->s6_addr32[0] ^ htonl(0xff020000)) |
 		addr->s6_addr32[1] | addr->s6_addr32[2] |
-		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0);
+		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0;
 }
 
 extern int __ipv6_isatap_ifid(u8 *eui, __be32 addr);
 
 static inline int ipv6_addr_is_isatap(const struct in6_addr *addr)
 {
-	return ((addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE));
+	return (addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE);
 }
 
 #ifdef CONFIG_PROC_FS

commit a898def29e4119bc01ebe7ca97423181f4c0ea2d
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Mon Feb 22 17:04:49 2010 -0800

    net: Add checking to rcu_dereference() primitives
    
    Update rcu_dereference() primitives to use new lockdep-based
    checking. The rcu_dereference() in __in6_dev_get() may be
    protected either by rcu_read_lock() or RTNL, per Eric Dumazet.
    The rcu_dereference() in __sk_free() is protected by the fact
    that it is never reached if an update could change it.  Check
    for this by using rcu_dereference_check() to verify that the
    struct sock's ->sk_wmem_alloc counter is zero.
    
    Acked-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: laijs@cn.fujitsu.com
    Cc: dipankar@in.ibm.com
    Cc: mathieu.desnoyers@polymtl.ca
    Cc: josh@joshtriplett.org
    Cc: dvhltc@us.ibm.com
    Cc: niv@us.ibm.com
    Cc: peterz@infradead.org
    Cc: rostedt@goodmis.org
    Cc: Valdis.Kletnieks@vt.edu
    Cc: dhowells@redhat.com
    LKML-Reference: <1266887105-1528-5-git-send-email-paulmck@linux.vnet.ibm.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 0f7c37825fc1..45375b41a2a0 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -177,7 +177,9 @@ extern int unregister_inet6addr_notifier(struct notifier_block *nb);
 static inline struct inet6_dev *
 __in6_dev_get(struct net_device *dev)
 {
-	return rcu_dereference(dev->ip6_ptr);
+	return rcu_dereference_check(dev->ip6_ptr,
+				     rcu_read_lock_held() ||
+				     lockdep_rtnl_is_held());
 }
 
 static inline struct inet6_dev *

commit 75c78500ddad74b229cd0691496b8549490496a2
Author: Moni Shoua <monis@voltaire.com>
Date:   Tue Sep 15 02:37:40 2009 -0700

    bonding: remap muticast addresses without using dev_close() and dev_open()
    
    This patch fixes commit e36b9d16c6a6d0f59803b3ef04ff3c22c3844c10. The approach
    there is to call dev_close()/dev_open() whenever the device type is changed in
    order to remap the device IP multicast addresses to HW multicast addresses.
    This approach suffers from 2 drawbacks:
    
    *. It assumes tha the device is UP when calling dev_close(), or otherwise
       dev_close() has no affect. It is worth to mention that initscripts (Redhat)
       and sysconfig (Suse) doesn't act the same in this matter.
    *. dev_close() has other side affects, like deleting entries from the routing
       table, which might be unnecessary.
    
    The fix here is to directly remap the IP multicast addresses to HW multicast
    addresses for a bonding device that changes its type, and nothing else.
    
    Reported-by:   Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: Moni Shoua <monis@voltaire.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 7b55ab215a64..0f7c37825fc1 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -143,6 +143,8 @@ extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr
 extern int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 extern void ipv6_mc_up(struct inet6_dev *idev);
 extern void ipv6_mc_down(struct inet6_dev *idev);
+extern void ipv6_mc_unmap(struct inet6_dev *idev);
+extern void ipv6_mc_remap(struct inet6_dev *idev);
 extern void ipv6_mc_init_dev(struct inet6_dev *idev);
 extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);

commit b2f5e7cd3dee2ed721bf0675e1a1ddebb849aee6
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Mar 24 16:24:51 2009 +0000

    ipv6: Fix conflict resolutions during ipv6 binding
    
    The ipv6 version of bind_conflict code calls ipv6_rcv_saddr_equal()
    which at times wrongly identified intersections between addresses.
    It particularly broke down under a few instances and caused erroneous
    bind conflicts.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c216de528b08..7b55ab215a64 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -88,8 +88,8 @@ extern int			ipv6_dev_get_saddr(struct net *net,
 extern int			ipv6_get_lladdr(struct net_device *dev,
 						struct in6_addr *addr,
 						unsigned char banned_flags);
-extern int			ipv6_rcv_saddr_equal(const struct sock *sk, 
-						      const struct sock *sk2);
+extern int 			ipv6_rcv_saddr_equal(const struct sock *sk,
+						    const struct sock *sk2);
 extern void			addrconf_join_solict(struct net_device *dev,
 					struct in6_addr *addr);
 extern void			addrconf_leave_solict(struct inet6_dev *idev,

commit 191cd582500f49b32a63040fedeebb0168c720af
Author: Brian Haley <brian.haley@hp.com>
Date:   Thu Aug 14 15:33:21 2008 -0700

    netns: Add network namespace argument to rt6_fill_node() and ipv6_dev_get_saddr()
    
    ipv6_dev_get_saddr() blindly de-references dst_dev to get the network
    namespace, but some callers might pass NULL.  Change callers to pass a
    namespace pointer instead.
    
    Signed-off-by: Brian Haley <brian.haley@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 06b28142b3ab..c216de528b08 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -80,7 +80,8 @@ extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
 						 struct net_device *dev,
 						 int strict);
 
-extern int			ipv6_dev_get_saddr(struct net_device *dev, 
+extern int			ipv6_dev_get_saddr(struct net *net,
+					       struct net_device *dev,
 					       const struct in6_addr *daddr,
 					       unsigned int srcprefs,
 					       struct in6_addr *saddr);

commit 3de232554a91adc74e80dc15c304be806bd7e1f9
Author: Benjamin Thery <benjamin.thery@bull.net>
Date:   Wed May 28 14:51:24 2008 +0200

    ipv6 netns: Address labels per namespace
    
    This pacth makes IPv6 address labels per network namespace.
    It keeps the global label tables, ip6addrlbl_table, but
    adds a 'net' member to each ip6addrlbl_entry.
    This new member is taken into account when matching labels.
    
    Changelog
    =========
    * v1: Initial version
    * v2:
      * Minize the penalty when network namespaces are not configured:
          *  the 'net' member is added only if CONFIG_NET_NS is
             defined. This saves space when network namespaces are not
             configured.
          * 'net' value is retrieved with the inlined function
             ip6addrlbl_net() that always return &init_net when
             CONFIG_NET_NS is not defined.
      * 'net' member in ip6addrlbl_entry renamed to the less generic
        'lbl_net' name (helps code search).
    
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index bbd3d583c6e6..06b28142b3ab 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -121,7 +121,8 @@ static inline int addrconf_finite_timeout(unsigned long timeout)
  */
 extern int			ipv6_addr_label_init(void);
 extern void			ipv6_addr_label_rtnl_register(void);
-extern u32			ipv6_addr_label(const struct in6_addr *addr,
+extern u32			ipv6_addr_label(struct net *net,
+						const struct in6_addr *addr,
 						int type, int ifindex);
 
 /*

commit 4bed72e4f5502ea3322f0a00794815fa58951abe
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Tue May 27 17:37:49 2008 +0900

    [IPV6] ADDRCONF: Allow longer lifetime on 64bit archs.
    
    - Allow longer lifetimes (>= 0x7fffffff/HZ) on 64bit archs
      by using unsigned long.
    - Shadow this arithmetic overflow workaround by introducing
      helper functions: addrconf_timeout_fixup() and
      addrconf_finite_timeout().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 0a2f0372df31..bbd3d583c6e6 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -94,6 +94,28 @@ extern void			addrconf_join_solict(struct net_device *dev,
 extern void			addrconf_leave_solict(struct inet6_dev *idev,
 					struct in6_addr *addr);
 
+static inline unsigned long addrconf_timeout_fixup(u32 timeout,
+						    unsigned unit)
+{
+	if (timeout == 0xffffffff)
+		return ~0UL;
+
+	/*
+	 * Avoid arithmetic overflow.
+	 * Assuming unit is constant and non-zero, this "if" statement
+	 * will go away on 64bit archs.
+	 */
+	if (0xfffffffe > LONG_MAX / unit && timeout > LONG_MAX / unit)
+		return LONG_MAX / unit;
+
+	return timeout;
+}
+
+static inline int addrconf_finite_timeout(unsigned long timeout)
+{
+	return ~timeout;
+}
+
 /*
  *	IPv6 Address Label subsystem (addrlabel.c)
  */

commit f3ee4010e84452aa133e5163e6cfabc52b194e94
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Apr 10 15:42:11 2008 +0900

    [IPV6]: Define constants for link-local multicast addresses.
    
    - Define link-local all-node / all-router multicast addresses.
    - Remove ipv6_addr_all_nodes() and ipv6_addr_all_routers().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 92af23d66eb9..0a2f0372df31 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -205,17 +205,6 @@ static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
 		      htonl(0xFF000000) | addr->s6_addr32[3]);
 }
 
-
-static inline void ipv6_addr_all_nodes(struct in6_addr *addr)
-{
-	ipv6_addr_set(addr, htonl(0xFF020000), 0, 0, htonl(0x1));
-}
-
-static inline void ipv6_addr_all_routers(struct in6_addr *addr)
-{
-	ipv6_addr_set(addr, htonl(0xFF020000), 0, 0, htonl(0x2));
-}
-
 static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
 {
 	return (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);

commit 9acd9f3ae92d0dc0ca7504fb48c1040e8bbc39fe
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Apr 10 15:42:10 2008 +0900

    [IPV6]: Make address arguments const.
    
    - net/ipv6/addrconf.c:
            ipv6_get_ifaddr(), ipv6_dev_get_saddr()
    - net/ipv6/mcast.c:
            ipv6_sock_mc_join(), ipv6_sock_mc_drop(),
            inet6_mc_check(),
            ipv6_dev_mc_inc(), __ipv6_dev_mc_dec(), ipv6_dev_mc_dec(),
            ipv6_chk_mcast_addr()
    - net/ipv6/route.c:
            rt6_lookup(), icmp6_dst_alloc()
    - net/ipv6/ip6_output.c:
            ip6_nd_hdr()
    - net/ipv6/ndisc.c:
            ndisc_send_ns(), ndisc_send_rs(), ndisc_send_redirect(),
            ndisc_get_neigh(), __ndisc_send()
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 8317c1bcd86c..92af23d66eb9 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -76,12 +76,12 @@ extern int			ipv6_chk_prefix(struct in6_addr *addr,
 						struct net_device *dev);
 
 extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
-						 struct in6_addr *addr,
+						 const struct in6_addr *addr,
 						 struct net_device *dev,
 						 int strict);
 
 extern int			ipv6_dev_get_saddr(struct net_device *dev, 
-					       struct in6_addr *daddr,
+					       const struct in6_addr *daddr,
 					       unsigned int srcprefs,
 					       struct in6_addr *saddr);
 extern int			ipv6_get_lladdr(struct net_device *dev,
@@ -105,25 +105,27 @@ extern u32			ipv6_addr_label(const struct in6_addr *addr,
 /*
  *	multicast prototypes (mcast.c)
  */
-extern int ipv6_sock_mc_join(struct sock *sk, int ifindex, 
-		  struct in6_addr *addr);
-extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex, 
-		  struct in6_addr *addr);
+extern int ipv6_sock_mc_join(struct sock *sk, int ifindex,
+			     const struct in6_addr *addr);
+extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex,
+			     const struct in6_addr *addr);
 extern void ipv6_sock_mc_close(struct sock *sk);
-extern int inet6_mc_check(struct sock *sk, struct in6_addr *mc_addr,
-		struct in6_addr *src_addr);
+extern int inet6_mc_check(struct sock *sk,
+			  const struct in6_addr *mc_addr,
+			  const struct in6_addr *src_addr);
 
-extern int ipv6_dev_mc_inc(struct net_device *dev, struct in6_addr *addr);
-extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, struct in6_addr *addr);
-extern int ipv6_dev_mc_dec(struct net_device *dev, struct in6_addr *addr);
+extern int ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr);
+extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr);
+extern int ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr);
 extern void ipv6_mc_up(struct inet6_dev *idev);
 extern void ipv6_mc_down(struct inet6_dev *idev);
 extern void ipv6_mc_init_dev(struct inet6_dev *idev);
 extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
 extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
 
-extern int ipv6_chk_mcast_addr(struct net_device *dev, struct in6_addr *group,
-		struct in6_addr *src_addr);
+extern int ipv6_chk_mcast_addr(struct net_device *dev,
+			       const struct in6_addr *group,
+			       const struct in6_addr *src_addr);
 extern int ipv6_is_mld(struct sk_buff *skb, int nexthdr);
 
 extern void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len);

commit dfd982baff01c18e3e1717c97fdac79c28f105ce
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Apr 10 15:42:09 2008 +0900

    [IPV6] ADDRCONF: Uninline ipv6_isatap_eui64().
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 1ba4e5bf5801..8317c1bcd86c 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -233,20 +233,7 @@ static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0);
 }
 
-static inline int ipv6_isatap_eui64(u8 *eui, __be32 addr)
-{
-	eui[0] = (ipv4_is_zeronet(addr) || ipv4_is_private_10(addr) ||
-		  ipv4_is_loopback(addr) || ipv4_is_linklocal_169(addr) ||
-		  ipv4_is_private_172(addr) || ipv4_is_test_192(addr) ||
-		  ipv4_is_anycast_6to4(addr) || ipv4_is_private_192(addr) ||
-		  ipv4_is_test_198(addr) || ipv4_is_multicast(addr) ||
-		  ipv4_is_lbcast(addr)) ? 0x00 : 0x02;
-	eui[1] = 0;
-	eui[2] = 0x5E;
-	eui[3] = 0xFE;
-	memcpy (eui+4, &addr, 4);
-	return 0;
-}
+extern int __ipv6_isatap_ifid(u8 *eui, __be32 addr);
 
 static inline int ipv6_addr_is_isatap(const struct in6_addr *addr)
 {

commit 3eb84f49290461e2b83d6e8ee1f3f0e504340c8b
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Apr 10 15:42:08 2008 +0900

    [IPV6] ADDRCONF: Uninline ipv6_addr_hash().
    
    The function is only used in net/ipv6/addrconf.c.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 1dc9d03372d9..1ba4e5bf5801 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -189,25 +189,6 @@ static inline void in6_ifa_put(struct inet6_ifaddr *ifp)
 #define in6_ifa_hold(ifp)	atomic_inc(&(ifp)->refcnt)
 
 
-/*
- *	Hash function taken from net_alias.c
- */
-
-static __inline__ u8 ipv6_addr_hash(const struct in6_addr *addr)
-{	
-	__u32 word;
-
-	/* 
-	 * We perform the hash function over the last 64 bits of the address
-	 * This will include the IEEE address token on links that support it.
-	 */
-
-	word = (__force u32)(addr->s6_addr32[2] ^ addr->s6_addr32[3]);
-	word ^= (word >> 16);
-	word ^= (word >> 8);
-
-	return ((word ^ (word >> 4)) & 0x0f);
-}
 
 /*
  *	compute link-local solicited-node multicast address

commit fed85383ac34d82e96f227ce49ce68117cec23a0
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Apr 11 20:17:55 2008 +0900

    [IPV6]: Use XOR and OR rather than mutiple ands for ipv6 address comparisons.
    
    ipv6_addr_equal(), ipv6_addr_v4mapped(),
    ipv6_addr_is_ll_all_{nodes,routers}(),
    ipv6_masked_addr_cmp()
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index bdcc863a60a4..1dc9d03372d9 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -240,18 +240,16 @@ static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
 
 static inline int ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
 {
-	return (addr->s6_addr32[0] == htonl(0xff020000) &&
-		addr->s6_addr32[1] == 0 &&
-		addr->s6_addr32[2] == 0 &&
-		addr->s6_addr32[3] == htonl(0x00000001));
+	return (((addr->s6_addr32[0] ^ htonl(0xff020000)) |
+		addr->s6_addr32[1] | addr->s6_addr32[2] |
+		(addr->s6_addr32[3] ^ htonl(0x00000001))) == 0);
 }
 
 static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 {
-	return (addr->s6_addr32[0] == htonl(0xff020000) &&
-		addr->s6_addr32[1] == 0 &&
-		addr->s6_addr32[2] == 0 &&
-		addr->s6_addr32[3] == htonl(0x00000002));
+	return (((addr->s6_addr32[0] ^ htonl(0xff020000)) |
+		addr->s6_addr32[1] | addr->s6_addr32[2] |
+		(addr->s6_addr32[3] ^ htonl(0x00000002))) == 0);
 }
 
 static inline int ipv6_isatap_eui64(u8 *eui, __be32 addr)

commit 52eeeb8481d705e61e2e9aae974e7799a93783e9
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Sat Mar 15 22:54:23 2008 -0400

    [IPV6]: Unify ip6_onlink() and ipip6_onlink().
    
    Both are identical, let's create ipv6_chk_prefix() and use it
    in both places.

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index d89b0bc7ab75..bdcc863a60a4 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -71,6 +71,10 @@ extern int			ipv6_chk_addr(struct net *net,
 extern int			ipv6_chk_home_addr(struct net *net,
 						   struct in6_addr *addr);
 #endif
+
+extern int			ipv6_chk_prefix(struct in6_addr *addr,
+						struct net_device *dev);
+
 extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
 						 struct in6_addr *addr,
 						 struct net_device *dev,

commit be2ce06b4962658d807410e58f7c6b739dc6a0c3
Author: Rami Rosen <ramirose@gmail.com>
Date:   Fri Mar 28 16:26:45 2008 -0700

    [IPV6]: Remove unused method declaration in include/net/addrconf.h.
    
    This patches removes unused declaration of addrconf_forwarding_on() method
    in include/net/addrconf.h.
    
    Signed-off-by: Rami Rosen <ramirose@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index d0c47c306046..d89b0bc7ab75 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -185,7 +185,6 @@ static inline void in6_ifa_put(struct inet6_ifaddr *ifp)
 #define in6_ifa_hold(ifp)	atomic_inc(&(ifp)->refcnt)
 
 
-extern void			addrconf_forwarding_on(void);
 /*
  *	Hash function taken from net_alias.c
  */

commit 6ab57e7e7fa316552d0f94eaebf1def1d49f18da
Author: Daniel Lezcano <dlezcano@fr.ibm.com>
Date:   Wed Mar 26 16:52:32 2008 -0700

    [NETNS][IPV6] anycast - handle several network namespace
    
    Make use of the network namespace information to have this protocol to
    handle several network namespace.
    
    Signed-off-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c9276c72764d..d0c47c306046 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -134,7 +134,8 @@ extern int inet6_ac_check(struct sock *sk, struct in6_addr *addr, int ifindex);
 
 extern int ipv6_dev_ac_inc(struct net_device *dev, struct in6_addr *addr);
 extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, struct in6_addr *addr);
-extern int ipv6_chk_acast_addr(struct net_device *dev, struct in6_addr *addr);
+extern int ipv6_chk_acast_addr(struct net *net, struct net_device *dev,
+			       struct in6_addr *addr);
 
 
 /* Device notifier */

commit 7cbca67c073263c179f605bdbbdc565ab29d801d
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Tue Mar 25 09:37:42 2008 +0900

    [IPV6]: Support Source Address Selection API (RFC5014).
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index edcb4bbaab7d..c9276c72764d 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -78,6 +78,7 @@ extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
 
 extern int			ipv6_dev_get_saddr(struct net_device *dev, 
 					       struct in6_addr *daddr,
+					       unsigned int srcprefs,
 					       struct in6_addr *saddr);
 extern int			ipv6_get_lladdr(struct net_device *dev,
 						struct in6_addr *addr,

commit 6b75d0908185bf853b188afa6f269426f6554c5b
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 10 06:00:30 2008 -0400

    [IPV6]: Optimize hop-limit determination.
    
    Last part of hop-limit determination is always:
        hoplimit = dst_metric(dst, RTAX_HOPLIMIT);
        if (hoplimit < 0)
            hoplimit = ipv6_get_hoplimit(dst->dev).
    
    Let's consolidate it as ip6_dst_hoplimit(dst).
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 232da20e7171..edcb4bbaab7d 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -123,8 +123,6 @@ extern int ipv6_is_mld(struct sk_buff *skb, int nexthdr);
 
 extern void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len);
 
-extern int ipv6_get_hoplimit(struct net_device *dev);
-
 /*
  *	anycast prototypes (anycast.c)
  */

commit af2849377e7b70afa1274e475be50286cd0ef6eb
Author: Daniel Lezcano <dlezcano@fr.ibm.com>
Date:   Wed Mar 5 10:46:57 2008 -0800

    [NETNS][IPV6] addrconf - Pass the proper network namespace parameters to addrconf
    
    This patch propagates the network namespace pointer to the address
    configuration routines which need it, which means adding a new
    parameter to these functions, and make them use it instead of using
    the initial network namespace.
    
    Signed-off-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 89e3c53c8886..232da20e7171 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -55,9 +55,12 @@ struct prefix_info {
 extern int			addrconf_init(void);
 extern void			addrconf_cleanup(void);
 
-extern int			addrconf_add_ifaddr(void __user *arg);
-extern int			addrconf_del_ifaddr(void __user *arg);
-extern int			addrconf_set_dstaddr(void __user *arg);
+extern int			addrconf_add_ifaddr(struct net *net,
+						    void __user *arg);
+extern int			addrconf_del_ifaddr(struct net *net,
+						    void __user *arg);
+extern int			addrconf_set_dstaddr(struct net *net,
+						     void __user *arg);
 
 extern int			ipv6_chk_addr(struct net *net,
 					      struct in6_addr *addr,

commit 5e5f3f0f801321078c897a5de0b4b4304f234da0
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 3 21:44:34 2008 +0900

    [IPV6] ADDRCONF: Convert ipv6_get_saddr() to ipv6_dev_get_saddr().
    
    Since most users of ipv6_get_saddr() pass non-NULL as
    dst argument, use ipv6_dev_get_saddr() directly.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index a9ff97c120c7..89e3c53c8886 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -73,9 +73,6 @@ extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
 						 struct net_device *dev,
 						 int strict);
 
-extern int			ipv6_get_saddr(struct dst_entry *dst, 
-					       struct in6_addr *daddr,
-					       struct in6_addr *saddr);
 extern int			ipv6_dev_get_saddr(struct net_device *dev, 
 					       struct in6_addr *daddr,
 					       struct in6_addr *saddr);

commit 0e7b8dcd16eb91b9cd8ecc07c4094512f20d7e3c
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu Feb 28 17:03:12 2008 +0900

    [IPV6]: Use htonl() instead of __constant_htonl() where appricable.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 496503c03846..a9ff97c120c7 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -214,29 +214,25 @@ static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
 					     struct in6_addr *solicited)
 {
 	ipv6_addr_set(solicited,
-		      __constant_htonl(0xFF020000), 0,
-		      __constant_htonl(0x1),
-		      __constant_htonl(0xFF000000) | addr->s6_addr32[3]);
+		      htonl(0xFF020000), 0,
+		      htonl(0x1),
+		      htonl(0xFF000000) | addr->s6_addr32[3]);
 }
 
 
 static inline void ipv6_addr_all_nodes(struct in6_addr *addr)
 {
-	ipv6_addr_set(addr,
-		      __constant_htonl(0xFF020000), 0, 0,
-		      __constant_htonl(0x1));
+	ipv6_addr_set(addr, htonl(0xFF020000), 0, 0, htonl(0x1));
 }
 
 static inline void ipv6_addr_all_routers(struct in6_addr *addr)
 {
-	ipv6_addr_set(addr,
-		      __constant_htonl(0xFF020000), 0, 0,
-		      __constant_htonl(0x2));
+	ipv6_addr_set(addr, htonl(0xFF020000), 0, 0, htonl(0x2));
 }
 
 static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
 {
-	return (addr->s6_addr32[0] & __constant_htonl(0xFF000000)) == __constant_htonl(0xFF000000);
+	return (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);
 }
 
 static inline int ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)

commit 1e637c74b0f84eaca02b914c0b8c6f67276e9697
Author: Jan Engelhardt <jengelh@computergmbh.de>
Date:   Mon Jan 21 03:18:08 2008 -0800

    [IPV4]: Enable use of 240/4 address space.
    
    This short patch modifies the IPv4 networking to enable use of the
    240.0.0.0/4 (aka "class-E") address space as propsed in the internet
    draft draft-fuller-240space-00.txt.
    
    Signed-off-by: Jan Engelhardt <jengelh@computergmbh.de>
    Acked-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 8b1509bfc695..496503c03846 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -262,7 +262,7 @@ static inline int ipv6_isatap_eui64(u8 *eui, __be32 addr)
 		  ipv4_is_private_172(addr) || ipv4_is_test_192(addr) ||
 		  ipv4_is_anycast_6to4(addr) || ipv4_is_private_192(addr) ||
 		  ipv4_is_test_198(addr) || ipv4_is_multicast(addr) ||
-		  ipv4_is_badclass(addr)) ? 0x00 : 0x02;
+		  ipv4_is_lbcast(addr)) ? 0x00 : 0x02;
 	eui[1] = 0;
 	eui[2] = 0x5E;
 	eui[3] = 0xFE;

commit 389f661224cdbdf178553fb09a52dc6c8bf86890
Author: Daniel Lezcano <dlezcano@fr.ibm.com>
Date:   Thu Jan 10 22:44:40 2008 -0800

    [NETNS][IPV6]: inet6_addr - make ipv6_chk_home_addr namespace aware
    
    Looks if the address is belonging to the network namespace, otherwise
    discard the address for the check.
    
    Signed-off-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 77f630f12806..8b1509bfc695 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -65,7 +65,8 @@ extern int			ipv6_chk_addr(struct net *net,
 					      int strict);
 
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
-extern int			ipv6_chk_home_addr(struct in6_addr *addr);
+extern int			ipv6_chk_home_addr(struct net *net,
+						   struct in6_addr *addr);
 #endif
 extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
 						 struct in6_addr *addr,

commit 1cab3da6be6c7659f62d0d297b389cc0e48b2178
Author: Daniel Lezcano <dlezcano@fr.ibm.com>
Date:   Thu Jan 10 22:44:09 2008 -0800

    [NETNS][IPV6]: inet6_addr - ipv6_get_ifaddr namespace aware
    
    The inet6_addr_lst is browsed taking into account the network
    namespace specified as parameter. If an address does not belong
    to the specified namespace, it is ignored.
    
    Signed-off-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index d1697b587a1a..77f630f12806 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -67,9 +67,11 @@ extern int			ipv6_chk_addr(struct net *net,
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 extern int			ipv6_chk_home_addr(struct in6_addr *addr);
 #endif
-extern struct inet6_ifaddr *	ipv6_get_ifaddr(struct in6_addr *addr,
-						struct net_device *dev,
-						int strict);
+extern struct inet6_ifaddr      *ipv6_get_ifaddr(struct net *net,
+						 struct in6_addr *addr,
+						 struct net_device *dev,
+						 int strict);
+
 extern int			ipv6_get_saddr(struct dst_entry *dst, 
 					       struct in6_addr *daddr,
 					       struct in6_addr *saddr);

commit bfeade087005278fc8cafe230b7658a4f40c5acb
Author: Daniel Lezcano <dlezcano@fr.ibm.com>
Date:   Thu Jan 10 22:43:18 2008 -0800

    [NETNS][IPV6]: inet6_addr - check ipv6 address per namespace
    
    When a new address is added, we must check if the new address does not
    already exists.  This patch makes this check to be aware of a network
    namespace, so the check will look if the address already exists for
    the specified network namespace. While the addresses are browsed, the
    addresses which do not belong to the namespace are discarded.
    
    Signed-off-by: Daniel Lezcano <dlezcano@fr.ibm.com>
    Signed-off-by: Benjamin Thery <benjamin.thery@bull.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 1c3a5602990e..d1697b587a1a 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -59,9 +59,11 @@ extern int			addrconf_add_ifaddr(void __user *arg);
 extern int			addrconf_del_ifaddr(void __user *arg);
 extern int			addrconf_set_dstaddr(void __user *arg);
 
-extern int			ipv6_chk_addr(struct in6_addr *addr,
+extern int			ipv6_chk_addr(struct net *net,
+					      struct in6_addr *addr,
 					      struct net_device *dev,
 					      int strict);
+
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 extern int			ipv6_chk_home_addr(struct in6_addr *addr);
 #endif

commit 3db8cda362dced00caf19865ffda3fa1028c59bc
Author: Joe Perches <joe@perches.com>
Date:   Sun Dec 16 13:43:24 2007 -0800

    [IPV4] include/net: Use ipv4_is_<type>
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index c56827da0dee..1c3a5602990e 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -252,10 +252,12 @@ static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 
 static inline int ipv6_isatap_eui64(u8 *eui, __be32 addr)
 {
-	eui[0] = (ZERONET(addr) || PRIVATE_10(addr) || LOOPBACK(addr) ||
-		  LINKLOCAL_169(addr) || PRIVATE_172(addr) || TEST_192(addr) ||
-		  ANYCAST_6TO4(addr) || PRIVATE_192(addr) || TEST_198(addr) ||
-		  MULTICAST(addr) || BADCLASS(addr)) ? 0x00 : 0x02;
+	eui[0] = (ipv4_is_zeronet(addr) || ipv4_is_private_10(addr) ||
+		  ipv4_is_loopback(addr) || ipv4_is_linklocal_169(addr) ||
+		  ipv4_is_private_172(addr) || ipv4_is_test_192(addr) ||
+		  ipv4_is_anycast_6to4(addr) || ipv4_is_private_192(addr) ||
+		  ipv4_is_test_198(addr) || ipv4_is_multicast(addr) ||
+		  ipv4_is_badclass(addr)) ? 0x00 : 0x02;
 	eui[1] = 0;
 	eui[2] = 0x5E;
 	eui[3] = 0xFE;

commit c7dc89c0ac8e7c3796bff91becf58ccdbcaf9f18
Author: Fred L. Templin <fred.l.templin@boeing.com>
Date:   Thu Nov 29 22:11:40 2007 +1100

    [IPV6]: Add RFC4214 support
    
    This patch includes support for the Intra-Site Automatic Tunnel
    Addressing Protocol (ISATAP) per RFC4214. It uses the SIT
    module, and is configured using extensions to the "iproute2"
    utility. The diffs are specific to the Linux 2.6.24-rc2 kernel
    distribution.
    
    This version includes the diff for ./include/linux/if.h which was
    missing in the v2.4 submission and is needed to make the
    patch compile. The patch has been installed, compiled and
    tested in a clean 2.6.24-rc2 kernel build area.
    
    Signed-off-by: Fred L. Templin <fred.l.templin@boeing.com>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index bccc2feb99da..c56827da0dee 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -17,6 +17,7 @@
 
 #define IPV6_MAX_ADDRESSES		16
 
+#include <linux/in.h>
 #include <linux/in6.h>
 
 struct prefix_info {
@@ -249,6 +250,24 @@ static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 		addr->s6_addr32[3] == htonl(0x00000002));
 }
 
+static inline int ipv6_isatap_eui64(u8 *eui, __be32 addr)
+{
+	eui[0] = (ZERONET(addr) || PRIVATE_10(addr) || LOOPBACK(addr) ||
+		  LINKLOCAL_169(addr) || PRIVATE_172(addr) || TEST_192(addr) ||
+		  ANYCAST_6TO4(addr) || PRIVATE_192(addr) || TEST_198(addr) ||
+		  MULTICAST(addr) || BADCLASS(addr)) ? 0x00 : 0x02;
+	eui[1] = 0;
+	eui[2] = 0x5E;
+	eui[3] = 0xFE;
+	memcpy (eui+4, &addr, 4);
+	return 0;
+}
+
+static inline int ipv6_addr_is_isatap(const struct in6_addr *addr)
+{
+	return ((addr->s6_addr32[2] | htonl(0x02000000)) == htonl(0x02005EFE));
+}
+
 #ifdef CONFIG_PROC_FS
 extern int if6_proc_init(void);
 extern void if6_proc_exit(void);

commit 2a8cc6c89039e0530a3335954253b76ed0f9339a
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Wed Nov 14 15:56:23 2007 +0900

    [IPV6] ADDRCONF: Support RFC3484 configurable address selection policy table.
    
    Policy table is implemented as an RCU linear list since we do not expect
    large list nor frequent updates.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 33b593e17441..bccc2feb99da 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -83,6 +83,14 @@ extern void			addrconf_join_solict(struct net_device *dev,
 extern void			addrconf_leave_solict(struct inet6_dev *idev,
 					struct in6_addr *addr);
 
+/*
+ *	IPv6 Address Label subsystem (addrlabel.c)
+ */
+extern int			ipv6_addr_label_init(void);
+extern void			ipv6_addr_label_rtnl_register(void);
+extern u32			ipv6_addr_label(const struct in6_addr *addr,
+						int type, int ifindex);
+
 /*
  *	multicast prototypes (mcast.c)
  */

commit 59fbb3a61e02deaeaa4fb50792217921f3002d64
Author: Masahide NAKAMURA <nakam@linux-ipv6.org>
Date:   Tue Jun 26 23:56:32 2007 -0700

    [IPV6] MIP6: Loadable module support for MIPv6.
    
    This patch makes MIPv6 loadable module named "mip6".
    
    Here is a modprobe.conf(5) example to load it automatically
    when user application uses XFRM state for MIPv6:
    
    alias xfrm-type-10-43 mip6
    alias xfrm-type-10-60 mip6
    
    Some MIPv6 feature is not included by this modular, however,
    it should not be affected to other features like either IPsec
    or IPv6 with and without the patch.
    We may discuss XFRM, MH (RAW socket) and ancillary data/sockopt
    separately for future work.
    
    Loadable features:
    * MH receiving check (to send ICMP error back)
    * RO header parsing and building (i.e. RH2 and HAO in DSTOPTS)
    * XFRM policy/state database handling for RO
    
    These are NOT covered as loadable:
    * Home Address flags and its rule on source address selection
    * XFRM sub policy (depends on its own kernel option)
    * XFRM functions to receive RO as IPv6 extension header
    * MH sending/receiving through raw socket if user application
      opens it (since raw socket allows to do so)
    * RH2 sending as ancillary data
    * RH2 operation with setsockopt(2)
    
    Signed-off-by: Masahide NAKAMURA <nakam@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f3531d0bcd05..33b593e17441 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -61,7 +61,7 @@ extern int			addrconf_set_dstaddr(void __user *arg);
 extern int			ipv6_chk_addr(struct in6_addr *addr,
 					      struct net_device *dev,
 					      int strict);
-#ifdef CONFIG_IPV6_MIP6
+#if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 extern int			ipv6_chk_home_addr(struct in6_addr *addr);
 #endif
 extern struct inet6_ifaddr *	ipv6_get_ifaddr(struct in6_addr *addr,

commit 95c385b4d5a71b8ad552aecaa968ea46d7da2f6a
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Apr 25 17:08:10 2007 -0700

    [IPV6] ADDRCONF: Optimistic Duplicate Address Detection (RFC 4429) Support.
    
    Nominally an autoconfigured IPv6 address is added to an interface in the
    Tentative state (as per RFC 2462).  Addresses in this state remain in this
    state while the Duplicate Address Detection process operates on them to
    determine their uniqueness on the network.  During this period, these
    tentative addresses may not be used for communication, increasing the time
    before a node may be able to communicate on a network.  Using Optimistic
    Duplicate Address Detection, autoconfigured addresses may be used
    immediately for communication on the network, as long as certain rules are
    followed to avoid conflicts with other nodes during the Duplicate Address
    Detection process.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 88df8fc814e4..f3531d0bcd05 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -73,7 +73,9 @@ extern int			ipv6_get_saddr(struct dst_entry *dst,
 extern int			ipv6_dev_get_saddr(struct net_device *dev, 
 					       struct in6_addr *daddr,
 					       struct in6_addr *saddr);
-extern int			ipv6_get_lladdr(struct net_device *dev, struct in6_addr *);
+extern int			ipv6_get_lladdr(struct net_device *dev,
+						struct in6_addr *addr,
+						unsigned char banned_flags);
 extern int			ipv6_rcv_saddr_equal(const struct sock *sk, 
 						      const struct sock *sk2);
 extern void			addrconf_join_solict(struct net_device *dev,

commit e69a4adc669fe210817ec50ae3f9a7a5ad62d4e8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 14 20:56:00 2006 -0800

    [IPV6]: Misc endianness annotations.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 44f1b673f916..88df8fc814e4 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -35,9 +35,9 @@ struct prefix_info {
 #else
 #error "Please fix <asm/byteorder.h>"
 #endif
-	__u32			valid;
-	__u32			prefered;
-	__u32			reserved2;
+	__be32			valid;
+	__be32			prefered;
+	__be32			reserved2;
 
 	struct in6_addr		prefix;
 };
@@ -183,7 +183,7 @@ static __inline__ u8 ipv6_addr_hash(const struct in6_addr *addr)
 	 * This will include the IEEE address token on links that support it.
 	 */
 
-	word = addr->s6_addr32[2] ^ addr->s6_addr32[3];
+	word = (__force u32)(addr->s6_addr32[2] ^ addr->s6_addr32[3]);
 	word ^= (word >> 16);
 	word ^= (word >> 8);
 

commit 3b9f9a1c3903b64c38505f9fed3bb11e48dbc931
Author: Noriaki TAKAMIYA <takamiya@po.ntts.co.jp>
Date:   Fri Sep 22 14:45:56 2006 -0700

    [IPV6] ADDRCONF: Mobile IPv6 Home Address support.
    
    IFA_F_HOMEADDRESS is introduced for Mobile IPv6 Home Addresses on
    Mobile Node.
    
    The IFA_F_HOMEADDRESS flag should be set for Mobile IPv6 Home
    Addresses for 2 purposes. 1) We need to check this on receipt of
    Type 2 Routing Header (RFC3775 Secion 6.4), 2) We prefer Home
    Address(es) in source address selection (RFC3484 Section 5 Rule 4).
    
    Signed-off-by: Noriaki TAKAMIYA <takamiya@po.ntts.co.jp>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index aa2ed8f0a9dd..44f1b673f916 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -61,12 +61,8 @@ extern int			addrconf_set_dstaddr(void __user *arg);
 extern int			ipv6_chk_addr(struct in6_addr *addr,
 					      struct net_device *dev,
 					      int strict);
-/* XXX: this is a placeholder till addrconf supports */
 #ifdef CONFIG_IPV6_MIP6
-static inline int ipv6_chk_home_addr(struct in6_addr *addr)
-{
-	return 0;
-}
+extern int			ipv6_chk_home_addr(struct in6_addr *addr);
 #endif
 extern struct inet6_ifaddr *	ipv6_get_ifaddr(struct in6_addr *addr,
 						struct net_device *dev,

commit 8814c4b533817df825485ff32ce6ac406c3a54d1
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Sep 22 14:44:24 2006 -0700

    [IPV6] ADDRCONF: Convert addrconf_lock to RCU.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 5fc8627435eb..aa2ed8f0a9dd 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -133,20 +133,18 @@ extern int unregister_inet6addr_notifier(struct notifier_block *nb);
 static inline struct inet6_dev *
 __in6_dev_get(struct net_device *dev)
 {
-	return (struct inet6_dev *)dev->ip6_ptr;
+	return rcu_dereference(dev->ip6_ptr);
 }
 
-extern rwlock_t addrconf_lock;
-
 static inline struct inet6_dev *
 in6_dev_get(struct net_device *dev)
 {
 	struct inet6_dev *idev = NULL;
-	read_lock(&addrconf_lock);
-	idev = dev->ip6_ptr;
+	rcu_read_lock();
+	idev = __in6_dev_get(dev);
 	if (idev)
 		atomic_inc(&idev->refcnt);
-	read_unlock(&addrconf_lock);
+	rcu_read_unlock();
 	return idev;
 }
 

commit 65d4ed92219b28875efb52de5700da8c3dfa83e1
Author: Masahide NAKAMURA <nakam@linux-ipv6.org>
Date:   Wed Aug 23 19:16:22 2006 -0700

    [IPV6] MIP6: Add inbound interface of routing header type 2.
    
    Add inbound interface of routing header type 2 for Mobile IPv6.
    Based on MIPL2 kernel patch.
    
    This patch was also written by: Ville Nuorvala <vnuorval@tcs.hut.fi>
    
    Signed-off-by: Masahide NAKAMURA <nakam@linux-ipv6.org>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 3d71251b3eca..5fc8627435eb 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -61,6 +61,13 @@ extern int			addrconf_set_dstaddr(void __user *arg);
 extern int			ipv6_chk_addr(struct in6_addr *addr,
 					      struct net_device *dev,
 					      int strict);
+/* XXX: this is a placeholder till addrconf supports */
+#ifdef CONFIG_IPV6_MIP6
+static inline int ipv6_chk_home_addr(struct in6_addr *addr)
+{
+	return 0;
+}
+#endif
 extern struct inet6_ifaddr *	ipv6_get_ifaddr(struct in6_addr *addr,
 						struct net_device *dev,
 						int strict);

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 750e2508dd90..3d71251b3eca 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -45,7 +45,6 @@ struct prefix_info {
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
 #include <net/ipv6.h>

commit 20380731bc2897f2952ae055420972ded4cd786e
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 16 02:18:02 2005 -0300

    [NET]: Fix sparse warnings
    
    Of this type, mostly:
    
    CHECK   net/ipv6/netfilter.c
    net/ipv6/netfilter.c:96:12: warning: symbol 'ipv6_netfilter_init' was not declared. Should it be static?
    net/ipv6/netfilter.c:101:6: warning: symbol 'ipv6_netfilter_fini' was not declared. Should it be static?
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index a0ed93672176..750e2508dd90 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -45,6 +45,7 @@ struct prefix_info {
 
 #ifdef __KERNEL__
 
+#include <linux/config.h>
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
 #include <net/ipv6.h>
@@ -238,5 +239,10 @@ static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
 		addr->s6_addr32[3] == htonl(0x00000002));
 }
 
+#ifdef CONFIG_PROC_FS
+extern int if6_proc_init(void);
+extern void if6_proc_exit(void);
+#endif
+
 #endif
 #endif

commit 6a800d456a81a9046634bcd26d868fd537f0c9ae
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue May 3 22:17:18 2005 -0700

    [IPV6]: net/addrconf.h needs to include linux/in6.h earlier
    
    Else the in6_addr layout is not known for struct
    prefix_info.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index f1e5af4be98e..a0ed93672176 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -17,6 +17,8 @@
 
 #define IPV6_MAX_ADDRESSES		16
 
+#include <linux/in6.h>
+
 struct prefix_info {
 	__u8			type;
 	__u8			length;
@@ -43,7 +45,6 @@ struct prefix_info {
 
 #ifdef __KERNEL__
 
-#include <linux/in6.h>
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
 #include <net/ipv6.h>

commit e4553eddae592b948c9695c9a0002169b0cab6fc
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue May 3 14:25:13 2005 -0700

    [IPV6]: Include ipv6.h for ipv6_addr_set
    
    This patch includes net/ipv6.h from addrconf.h since it needs
    ipv6_addr_set.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 7af9a13cb9be..f1e5af4be98e 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -46,6 +46,7 @@ struct prefix_info {
 #include <linux/in6.h>
 #include <linux/netdevice.h>
 #include <net/if_inet6.h>
+#include <net/ipv6.h>
 
 #define IN6_ADDR_HSIZE		16
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/addrconf.h b/include/net/addrconf.h
new file mode 100644
index 000000000000..7af9a13cb9be
--- /dev/null
+++ b/include/net/addrconf.h
@@ -0,0 +1,240 @@
+#ifndef _ADDRCONF_H
+#define _ADDRCONF_H
+
+#define RETRANS_TIMER	HZ
+
+#define MAX_RTR_SOLICITATIONS		3
+#define RTR_SOLICITATION_INTERVAL	(4*HZ)
+
+#define MIN_VALID_LIFETIME		(2*3600)	/* 2 hours */
+
+#define TEMP_VALID_LIFETIME		(7*86400)
+#define TEMP_PREFERRED_LIFETIME		(86400)
+#define REGEN_MAX_RETRY			(5)
+#define MAX_DESYNC_FACTOR		(600)
+
+#define ADDR_CHECK_FREQUENCY		(120*HZ)
+
+#define IPV6_MAX_ADDRESSES		16
+
+struct prefix_info {
+	__u8			type;
+	__u8			length;
+	__u8			prefix_len;
+
+#if defined(__BIG_ENDIAN_BITFIELD)
+	__u8			onlink : 1,
+			 	autoconf : 1,
+				reserved : 6;
+#elif defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8			reserved : 6,
+				autoconf : 1,
+				onlink : 1;
+#else
+#error "Please fix <asm/byteorder.h>"
+#endif
+	__u32			valid;
+	__u32			prefered;
+	__u32			reserved2;
+
+	struct in6_addr		prefix;
+};
+
+
+#ifdef __KERNEL__
+
+#include <linux/in6.h>
+#include <linux/netdevice.h>
+#include <net/if_inet6.h>
+
+#define IN6_ADDR_HSIZE		16
+
+extern int			addrconf_init(void);
+extern void			addrconf_cleanup(void);
+
+extern int			addrconf_add_ifaddr(void __user *arg);
+extern int			addrconf_del_ifaddr(void __user *arg);
+extern int			addrconf_set_dstaddr(void __user *arg);
+
+extern int			ipv6_chk_addr(struct in6_addr *addr,
+					      struct net_device *dev,
+					      int strict);
+extern struct inet6_ifaddr *	ipv6_get_ifaddr(struct in6_addr *addr,
+						struct net_device *dev,
+						int strict);
+extern int			ipv6_get_saddr(struct dst_entry *dst, 
+					       struct in6_addr *daddr,
+					       struct in6_addr *saddr);
+extern int			ipv6_dev_get_saddr(struct net_device *dev, 
+					       struct in6_addr *daddr,
+					       struct in6_addr *saddr);
+extern int			ipv6_get_lladdr(struct net_device *dev, struct in6_addr *);
+extern int			ipv6_rcv_saddr_equal(const struct sock *sk, 
+						      const struct sock *sk2);
+extern void			addrconf_join_solict(struct net_device *dev,
+					struct in6_addr *addr);
+extern void			addrconf_leave_solict(struct inet6_dev *idev,
+					struct in6_addr *addr);
+
+/*
+ *	multicast prototypes (mcast.c)
+ */
+extern int ipv6_sock_mc_join(struct sock *sk, int ifindex, 
+		  struct in6_addr *addr);
+extern int ipv6_sock_mc_drop(struct sock *sk, int ifindex, 
+		  struct in6_addr *addr);
+extern void ipv6_sock_mc_close(struct sock *sk);
+extern int inet6_mc_check(struct sock *sk, struct in6_addr *mc_addr,
+		struct in6_addr *src_addr);
+
+extern int ipv6_dev_mc_inc(struct net_device *dev, struct in6_addr *addr);
+extern int __ipv6_dev_mc_dec(struct inet6_dev *idev, struct in6_addr *addr);
+extern int ipv6_dev_mc_dec(struct net_device *dev, struct in6_addr *addr);
+extern void ipv6_mc_up(struct inet6_dev *idev);
+extern void ipv6_mc_down(struct inet6_dev *idev);
+extern void ipv6_mc_init_dev(struct inet6_dev *idev);
+extern void ipv6_mc_destroy_dev(struct inet6_dev *idev);
+extern void addrconf_dad_failure(struct inet6_ifaddr *ifp);
+
+extern int ipv6_chk_mcast_addr(struct net_device *dev, struct in6_addr *group,
+		struct in6_addr *src_addr);
+extern int ipv6_is_mld(struct sk_buff *skb, int nexthdr);
+
+extern void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len);
+
+extern int ipv6_get_hoplimit(struct net_device *dev);
+
+/*
+ *	anycast prototypes (anycast.c)
+ */
+extern int ipv6_sock_ac_join(struct sock *sk,int ifindex,struct in6_addr *addr);
+extern int ipv6_sock_ac_drop(struct sock *sk,int ifindex,struct in6_addr *addr);
+extern void ipv6_sock_ac_close(struct sock *sk);
+extern int inet6_ac_check(struct sock *sk, struct in6_addr *addr, int ifindex);
+
+extern int ipv6_dev_ac_inc(struct net_device *dev, struct in6_addr *addr);
+extern int __ipv6_dev_ac_dec(struct inet6_dev *idev, struct in6_addr *addr);
+extern int ipv6_chk_acast_addr(struct net_device *dev, struct in6_addr *addr);
+
+
+/* Device notifier */
+extern int register_inet6addr_notifier(struct notifier_block *nb);
+extern int unregister_inet6addr_notifier(struct notifier_block *nb);
+
+static inline struct inet6_dev *
+__in6_dev_get(struct net_device *dev)
+{
+	return (struct inet6_dev *)dev->ip6_ptr;
+}
+
+extern rwlock_t addrconf_lock;
+
+static inline struct inet6_dev *
+in6_dev_get(struct net_device *dev)
+{
+	struct inet6_dev *idev = NULL;
+	read_lock(&addrconf_lock);
+	idev = dev->ip6_ptr;
+	if (idev)
+		atomic_inc(&idev->refcnt);
+	read_unlock(&addrconf_lock);
+	return idev;
+}
+
+extern void in6_dev_finish_destroy(struct inet6_dev *idev);
+
+static inline void
+in6_dev_put(struct inet6_dev *idev)
+{
+	if (atomic_dec_and_test(&idev->refcnt))
+		in6_dev_finish_destroy(idev);
+}
+
+#define __in6_dev_put(idev)  atomic_dec(&(idev)->refcnt)
+#define in6_dev_hold(idev)   atomic_inc(&(idev)->refcnt)
+
+
+extern void inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp);
+
+static inline void in6_ifa_put(struct inet6_ifaddr *ifp)
+{
+	if (atomic_dec_and_test(&ifp->refcnt))
+		inet6_ifa_finish_destroy(ifp);
+}
+
+#define __in6_ifa_put(ifp)	atomic_dec(&(ifp)->refcnt)
+#define in6_ifa_hold(ifp)	atomic_inc(&(ifp)->refcnt)
+
+
+extern void			addrconf_forwarding_on(void);
+/*
+ *	Hash function taken from net_alias.c
+ */
+
+static __inline__ u8 ipv6_addr_hash(const struct in6_addr *addr)
+{	
+	__u32 word;
+
+	/* 
+	 * We perform the hash function over the last 64 bits of the address
+	 * This will include the IEEE address token on links that support it.
+	 */
+
+	word = addr->s6_addr32[2] ^ addr->s6_addr32[3];
+	word ^= (word >> 16);
+	word ^= (word >> 8);
+
+	return ((word ^ (word >> 4)) & 0x0f);
+}
+
+/*
+ *	compute link-local solicited-node multicast address
+ */
+
+static inline void addrconf_addr_solict_mult(const struct in6_addr *addr,
+					     struct in6_addr *solicited)
+{
+	ipv6_addr_set(solicited,
+		      __constant_htonl(0xFF020000), 0,
+		      __constant_htonl(0x1),
+		      __constant_htonl(0xFF000000) | addr->s6_addr32[3]);
+}
+
+
+static inline void ipv6_addr_all_nodes(struct in6_addr *addr)
+{
+	ipv6_addr_set(addr,
+		      __constant_htonl(0xFF020000), 0, 0,
+		      __constant_htonl(0x1));
+}
+
+static inline void ipv6_addr_all_routers(struct in6_addr *addr)
+{
+	ipv6_addr_set(addr,
+		      __constant_htonl(0xFF020000), 0, 0,
+		      __constant_htonl(0x2));
+}
+
+static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
+{
+	return (addr->s6_addr32[0] & __constant_htonl(0xFF000000)) == __constant_htonl(0xFF000000);
+}
+
+static inline int ipv6_addr_is_ll_all_nodes(const struct in6_addr *addr)
+{
+	return (addr->s6_addr32[0] == htonl(0xff020000) &&
+		addr->s6_addr32[1] == 0 &&
+		addr->s6_addr32[2] == 0 &&
+		addr->s6_addr32[3] == htonl(0x00000001));
+}
+
+static inline int ipv6_addr_is_ll_all_routers(const struct in6_addr *addr)
+{
+	return (addr->s6_addr32[0] == htonl(0xff020000) &&
+		addr->s6_addr32[1] == 0 &&
+		addr->s6_addr32[2] == 0 &&
+		addr->s6_addr32[3] == htonl(0x00000002));
+}
+
+#endif
+#endif
