commit 47505b8bcfcffffe878ea1fee412922f3bfd7262
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:41 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 104
    
    Based on 1 normalized pattern(s):
    
      this sctp implementation is free software you can redistribute it
      and or modify it under the terms of the gnu general public license
      as published by the free software foundation either version 2 or at
      your option any later version this sctp implementation is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with gnu cc see the file copying if not see
      http www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 42 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.683323110@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 6d5beac29bc1..e8df72e1627a 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* SCTP kernel Implementation
  * (C) Copyright IBM Corp. 2001, 2004
  * Copyright (C) 1999-2001 Cisco, Motorola
@@ -6,22 +7,6 @@
  *
  * These are the definitions needed for the command object.
  *
- * This SCTP implementation  is free software;
- * you can redistribute it and/or modify it under the terms of
- * the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This SCTP implementation  is distributed in the hope that it
- * will be useful, but WITHOUT ANY WARRANTY; without even the implied
- *                 ************************
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with GNU CC; see the file COPYING.  If not, see
- * <http://www.gnu.org/licenses/>.
- *
  * Please send any bug reports or fixes you make to the
  * email address(es):
  *    lksctp developers <linux-sctp@vger.kernel.org>

commit fbd019737d71e405f86549fd738f81e2ff3dd073
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Apr 29 14:16:19 2019 +0800

    sctp: avoid running the sctp state machine recursively
    
    Ying triggered a call trace when doing an asconf testing:
    
      BUG: scheduling while atomic: swapper/12/0/0x10000100
      Call Trace:
       <IRQ>  [<ffffffffa4375904>] dump_stack+0x19/0x1b
       [<ffffffffa436fcaf>] __schedule_bug+0x64/0x72
       [<ffffffffa437b93a>] __schedule+0x9ba/0xa00
       [<ffffffffa3cd5326>] __cond_resched+0x26/0x30
       [<ffffffffa437bc4a>] _cond_resched+0x3a/0x50
       [<ffffffffa3e22be8>] kmem_cache_alloc_node+0x38/0x200
       [<ffffffffa423512d>] __alloc_skb+0x5d/0x2d0
       [<ffffffffc0995320>] sctp_packet_transmit+0x610/0xa20 [sctp]
       [<ffffffffc098510e>] sctp_outq_flush+0x2ce/0xc00 [sctp]
       [<ffffffffc098646c>] sctp_outq_uncork+0x1c/0x20 [sctp]
       [<ffffffffc0977338>] sctp_cmd_interpreter.isra.22+0xc8/0x1460 [sctp]
       [<ffffffffc0976ad1>] sctp_do_sm+0xe1/0x350 [sctp]
       [<ffffffffc099443d>] sctp_primitive_ASCONF+0x3d/0x50 [sctp]
       [<ffffffffc0977384>] sctp_cmd_interpreter.isra.22+0x114/0x1460 [sctp]
       [<ffffffffc0976ad1>] sctp_do_sm+0xe1/0x350 [sctp]
       [<ffffffffc097b3a4>] sctp_assoc_bh_rcv+0xf4/0x1b0 [sctp]
       [<ffffffffc09840f1>] sctp_inq_push+0x51/0x70 [sctp]
       [<ffffffffc099732b>] sctp_rcv+0xa8b/0xbd0 [sctp]
    
    As it shows, the first sctp_do_sm() running under atomic context (NET_RX
    softirq) invoked sctp_primitive_ASCONF() that uses GFP_KERNEL flag later,
    and this flag is supposed to be used in non-atomic context only. Besides,
    sctp_do_sm() was called recursively, which is not expected.
    
    Vlad tried to fix this recursive call in Commit c0786693404c ("sctp: Fix
    oops when sending queued ASCONF chunks") by introducing a new command
    SCTP_CMD_SEND_NEXT_ASCONF. But it didn't work as this command is still
    used in the first sctp_do_sm() call, and sctp_primitive_ASCONF() will
    be called in this command again.
    
    To avoid calling sctp_do_sm() recursively, we send the next queued ASCONF
    not by sctp_primitive_ASCONF(), but by sctp_sf_do_prm_asconf() in the 1st
    sctp_do_sm() directly.
    
    Reported-by: Ying Xu <yinxu@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 6640f84fe536..6d5beac29bc1 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -105,7 +105,6 @@ enum sctp_verb {
 	SCTP_CMD_T1_RETRAN,	 /* Mark for retransmission after T1 timeout  */
 	SCTP_CMD_UPDATE_INITTAG, /* Update peer inittag */
 	SCTP_CMD_SEND_MSG,	 /* Send the whole use message */
-	SCTP_CMD_SEND_NEXT_ASCONF, /* Send the next ASCONF after ACK */
 	SCTP_CMD_PURGE_ASCONF_QUEUE, /* Purge all asconf queues.*/
 	SCTP_CMD_SET_ASOC,	 /* Restore association context */
 	SCTP_CMD_LAST

commit 30f6ebf65bc46161c5aaff1db2e6e7c76aa4a06b
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Mar 14 19:05:34 2018 +0800

    sctp: add SCTP_AUTH_NO_AUTH type for AUTHENTICATION_EVENT
    
    This patch is to add SCTP_AUTH_NO_AUTH type for AUTHENTICATION_EVENT,
    as described in section 6.1.8 of RFC6458.
    
          SCTP_AUTH_NO_AUTH:  This report indicates that the peer does not
             support SCTP authentication as defined in [RFC4895].
    
    Note that the implementation is quite similar as that of
    SCTP_ADAPTATION_INDICATION.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index b55c6a48a206..6640f84fe536 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -100,6 +100,7 @@ enum sctp_verb {
 	SCTP_CMD_SET_SK_ERR,	 /* Set sk_err */
 	SCTP_CMD_ASSOC_CHANGE,	 /* generate and send assoc_change event */
 	SCTP_CMD_ADAPTATION_IND, /* generate and send adaptation event */
+	SCTP_CMD_PEER_NO_AUTH,   /* generate and send authentication event */
 	SCTP_CMD_ASSOC_SHKEY,    /* generate the association shared keys */
 	SCTP_CMD_T1_RETRAN,	 /* Mark for retransmission after T1 timeout  */
 	SCTP_CMD_UPDATE_INITTAG, /* Update peer inittag */

commit e08af95df1130883762b388a19bb150ae5d16c09
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:54 2017 +0800

    sctp: remove the typedef sctp_verb_t
    
    This patch is to remove the typedef sctp_verb_t, and
    replace with enum sctp_verb in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index f5fc425b5a4f..b55c6a48a206 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -40,7 +40,7 @@
 #include <net/sctp/structs.h>
 
 
-typedef enum {
+enum sctp_verb {
 	SCTP_CMD_NOP = 0,	/* Do nothing. */
 	SCTP_CMD_NEW_ASOC,	/* Register a new association.  */
 	SCTP_CMD_DELETE_TCB,	/* Delete the current association. */
@@ -108,7 +108,7 @@ typedef enum {
 	SCTP_CMD_PURGE_ASCONF_QUEUE, /* Purge all asconf queues.*/
 	SCTP_CMD_SET_ASOC,	 /* Restore association context */
 	SCTP_CMD_LAST
-} sctp_verb_t;
+};
 
 /* How many commands can you put in an struct sctp_cmd_seq?
  * This is a rather arbitrary number, ideally derived from a careful
@@ -198,7 +198,7 @@ static inline union sctp_arg SCTP_NULL(void)
 
 struct sctp_cmd {
 	union sctp_arg obj;
-	sctp_verb_t verb;
+	enum sctp_verb verb;
 };
 
 struct sctp_cmd_seq {
@@ -225,8 +225,8 @@ static inline int sctp_init_cmd_seq(struct sctp_cmd_seq *seq)
  * Use the SCTP_* constructors defined by SCTP_ARG_CONSTRUCTOR() above
  * to wrap data which goes in the obj argument.
  */
-static inline void sctp_add_cmd_sf(struct sctp_cmd_seq *seq, sctp_verb_t verb,
-				   union sctp_arg obj)
+static inline void sctp_add_cmd_sf(struct sctp_cmd_seq *seq,
+				   enum sctp_verb verb, union sctp_arg obj)
 {
 	struct sctp_cmd *cmd = seq->last_used_slot - 1;
 

commit c488b7704ed0eed18e11f9b685931558735f2a68
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:53 2017 +0800

    sctp: remove the typedef sctp_arg_t
    
    This patch is to remove the typedef sctp_arg_t, and
    replace with union sctp_arg in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index cbf6798866ef..f5fc425b5a4f 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -117,7 +117,7 @@ typedef enum {
  */
 #define SCTP_MAX_NUM_COMMANDS 20
 
-typedef union {
+union sctp_arg {
 	void *zero_all;	/* Set to NULL to clear the entire union */
 	__s32 i32;
 	__u32 u32;
@@ -137,24 +137,24 @@ typedef union {
 	struct sctp_packet *packet;
 	struct sctp_sackhdr *sackh;
 	struct sctp_datamsg *msg;
-} sctp_arg_t;
+};
 
 /* We are simulating ML type constructors here.
  *
  * SCTP_ARG_CONSTRUCTOR(NAME, TYPE, ELT) builds a function called
  * SCTP_NAME() which takes an argument of type TYPE and returns an
- * sctp_arg_t.  It does this by inserting the sole argument into the
- * ELT union element of a local sctp_arg_t.
+ * union sctp_arg.  It does this by inserting the sole argument into
+ * the ELT union element of a local union sctp_arg.
  *
  * E.g., SCTP_ARG_CONSTRUCTOR(I32, __s32, i32) builds SCTP_I32(arg),
- * which takes an __s32 and returns a sctp_arg_t containing the
+ * which takes an __s32 and returns a union sctp_arg containing the
  * __s32.  So, after foo = SCTP_I32(arg), foo.i32 == arg.
  */
 
 #define SCTP_ARG_CONSTRUCTOR(name, type, elt) \
-static inline sctp_arg_t	\
+static inline union sctp_arg	\
 SCTP_## name (type arg)		\
-{ sctp_arg_t retval;\
+{ union sctp_arg retval;\
   retval.zero_all = NULL;\
   retval.elt = arg;\
   return retval;\
@@ -179,25 +179,25 @@ SCTP_ARG_CONSTRUCTOR(PACKET,	struct sctp_packet *, packet)
 SCTP_ARG_CONSTRUCTOR(SACKH,	struct sctp_sackhdr *, sackh)
 SCTP_ARG_CONSTRUCTOR(DATAMSG,	struct sctp_datamsg *, msg)
 
-static inline sctp_arg_t SCTP_FORCE(void)
+static inline union sctp_arg SCTP_FORCE(void)
 {
 	return SCTP_I32(1);
 }
 
-static inline sctp_arg_t SCTP_NOFORCE(void)
+static inline union sctp_arg SCTP_NOFORCE(void)
 {
 	return SCTP_I32(0);
 }
 
-static inline sctp_arg_t SCTP_NULL(void)
+static inline union sctp_arg SCTP_NULL(void)
 {
-	sctp_arg_t retval;
+	union sctp_arg retval;
 	retval.zero_all = NULL;
 	return retval;
 }
 
 struct sctp_cmd {
-	sctp_arg_t obj;
+	union sctp_arg obj;
 	sctp_verb_t verb;
 };
 
@@ -226,7 +226,7 @@ static inline int sctp_init_cmd_seq(struct sctp_cmd_seq *seq)
  * to wrap data which goes in the obj argument.
  */
 static inline void sctp_add_cmd_sf(struct sctp_cmd_seq *seq, sctp_verb_t verb,
-				   sctp_arg_t obj)
+				   union sctp_arg obj)
 {
 	struct sctp_cmd *cmd = seq->last_used_slot - 1;
 

commit a85bbeb221d860097859f110ba1321f2b0653f07
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:52 2017 +0800

    sctp: remove the typedef sctp_cmd_seq_t
    
    This patch is to remove the typedef sctp_cmd_seq_t, and
    replace with struct sctp_cmd_seq in the places where it's
    using this typedef.
    
    Note that it doesn't fix many indents although it should,
    as sctp_disposition_t's removal would mess them up again.
    So better to fix them when removing sctp_disposition_t in
    the later patch.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 4e9e589b8f18..cbf6798866ef 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -110,7 +110,7 @@ typedef enum {
 	SCTP_CMD_LAST
 } sctp_verb_t;
 
-/* How many commands can you put in an sctp_cmd_seq_t?
+/* How many commands can you put in an struct sctp_cmd_seq?
  * This is a rather arbitrary number, ideally derived from a careful
  * analysis of the state functions, but in reality just taken from
  * thin air in the hopes othat we don't trigger a kernel panic.
@@ -201,17 +201,17 @@ struct sctp_cmd {
 	sctp_verb_t verb;
 };
 
-typedef struct {
+struct sctp_cmd_seq {
 	struct sctp_cmd cmds[SCTP_MAX_NUM_COMMANDS];
 	struct sctp_cmd *last_used_slot;
 	struct sctp_cmd *next_cmd;
-} sctp_cmd_seq_t;
+};
 
 
 /* Initialize a block of memory as a command sequence.
  * Return 0 if the initialization fails.
  */
-static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
+static inline int sctp_init_cmd_seq(struct sctp_cmd_seq *seq)
 {
 	/* cmds[] is filled backwards to simplify the overflow BUG() check */
 	seq->last_used_slot = seq->cmds + SCTP_MAX_NUM_COMMANDS;
@@ -220,12 +220,12 @@ static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
 }
 
 
-/* Add a command to an sctp_cmd_seq_t.
+/* Add a command to an struct sctp_cmd_seq.
  *
  * Use the SCTP_* constructors defined by SCTP_ARG_CONSTRUCTOR() above
  * to wrap data which goes in the obj argument.
  */
-static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
+static inline void sctp_add_cmd_sf(struct sctp_cmd_seq *seq, sctp_verb_t verb,
 				   sctp_arg_t obj)
 {
 	struct sctp_cmd *cmd = seq->last_used_slot - 1;
@@ -240,7 +240,7 @@ static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
 /* Return the next command structure in an sctp_cmd_seq.
  * Return NULL at the end of the sequence.
  */
-static inline struct sctp_cmd *sctp_next_cmd(sctp_cmd_seq_t *seq)
+static inline struct sctp_cmd *sctp_next_cmd(struct sctp_cmd_seq *seq)
 {
 	if (seq->next_cmd <= seq->last_used_slot)
 		return NULL;

commit e2c3108ab25b4dbab3821e8b6084bfb73afb655c
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:51 2017 +0800

    sctp: remove the typedef sctp_cmd_t
    
    This patch is to remove the typedef sctp_cmd_t, and
    replace with enum sctp_cmd in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 376cb78b6247..4e9e589b8f18 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -196,15 +196,15 @@ static inline sctp_arg_t SCTP_NULL(void)
 	return retval;
 }
 
-typedef struct {
+struct sctp_cmd {
 	sctp_arg_t obj;
 	sctp_verb_t verb;
-} sctp_cmd_t;
+};
 
 typedef struct {
-	sctp_cmd_t cmds[SCTP_MAX_NUM_COMMANDS];
-	sctp_cmd_t *last_used_slot;
-	sctp_cmd_t *next_cmd;
+	struct sctp_cmd cmds[SCTP_MAX_NUM_COMMANDS];
+	struct sctp_cmd *last_used_slot;
+	struct sctp_cmd *next_cmd;
 } sctp_cmd_seq_t;
 
 
@@ -228,7 +228,7 @@ static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
 static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
 				   sctp_arg_t obj)
 {
-	sctp_cmd_t *cmd = seq->last_used_slot - 1;
+	struct sctp_cmd *cmd = seq->last_used_slot - 1;
 
 	BUG_ON(cmd < seq->cmds);
 
@@ -240,7 +240,7 @@ static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
 /* Return the next command structure in an sctp_cmd_seq.
  * Return NULL at the end of the sequence.
  */
-static inline sctp_cmd_t *sctp_next_cmd(sctp_cmd_seq_t *seq)
+static inline struct sctp_cmd *sctp_next_cmd(sctp_cmd_seq_t *seq)
 {
 	if (seq->next_cmd <= seq->last_used_slot)
 		return NULL;

commit 19cd1592a24754e16d48398812d5f69b63f674dd
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 20:00:02 2017 +0800

    sctp: remove the typedef sctp_event_timeout_t
    
    This patch is to remove the typedef sctp_event_timeout_t, and
    replace with enum sctp_event_timeout in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index be12ec946628..376cb78b6247 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -127,7 +127,7 @@ typedef union {
 	int error;
 	__be16 err;
 	enum sctp_state state;
-	sctp_event_timeout_t to;
+	enum sctp_event_timeout to;
 	struct sctp_chunk *chunk;
 	struct sctp_association *asoc;
 	struct sctp_transport *transport;
@@ -168,7 +168,7 @@ SCTP_ARG_CONSTRUCTOR(U8,	__u8, u8)
 SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)
 SCTP_ARG_CONSTRUCTOR(PERR,      __be16, err)	/* protocol error */
 SCTP_ARG_CONSTRUCTOR(STATE,	enum sctp_state, state)
-SCTP_ARG_CONSTRUCTOR(TO,	sctp_event_timeout_t, to)
+SCTP_ARG_CONSTRUCTOR(TO,	enum sctp_event_timeout, to)
 SCTP_ARG_CONSTRUCTOR(CHUNK,	struct sctp_chunk *, chunk)
 SCTP_ARG_CONSTRUCTOR(ASOC,	struct sctp_association *, asoc)
 SCTP_ARG_CONSTRUCTOR(TRANSPORT,	struct sctp_transport *, transport)

commit 5210601945f5aedaf2d7f13a88436e27a39c6a8a
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:59 2017 +0800

    sctp: remove the typedef sctp_state_t
    
    This patch is to remove the typedef sctp_state_t, and
    replace with enum sctp_state in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 1d5f6ff3f440..be12ec946628 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -126,7 +126,7 @@ typedef union {
 	__u8 u8;
 	int error;
 	__be16 err;
-	sctp_state_t state;
+	enum sctp_state state;
 	sctp_event_timeout_t to;
 	struct sctp_chunk *chunk;
 	struct sctp_association *asoc;
@@ -167,7 +167,7 @@ SCTP_ARG_CONSTRUCTOR(U16,	__u16, u16)
 SCTP_ARG_CONSTRUCTOR(U8,	__u8, u8)
 SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)
 SCTP_ARG_CONSTRUCTOR(PERR,      __be16, err)	/* protocol error */
-SCTP_ARG_CONSTRUCTOR(STATE,	sctp_state_t, state)
+SCTP_ARG_CONSTRUCTOR(STATE,	enum sctp_state, state)
 SCTP_ARG_CONSTRUCTOR(TO,	sctp_event_timeout_t, to)
 SCTP_ARG_CONSTRUCTOR(CHUNK,	struct sctp_chunk *, chunk)
 SCTP_ARG_CONSTRUCTOR(ASOC,	struct sctp_association *, asoc)

commit 787310859d8d1a72545db2343fb3ac8f765b0f35
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sun Jul 23 09:34:32 2017 +0800

    sctp: remove the typedef sctp_sackhdr_t
    
    This patch is to remove the typedef sctp_sackhdr_t, and replace
    with struct sctp_sackhdr in the places where it's using this
    typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index d4679e7a5ed5..1d5f6ff3f440 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -135,7 +135,7 @@ typedef union {
 	struct sctp_init_chunk *init;
 	struct sctp_ulpevent *ulpevent;
 	struct sctp_packet *packet;
-	sctp_sackhdr_t *sackh;
+	struct sctp_sackhdr *sackh;
 	struct sctp_datamsg *msg;
 } sctp_arg_t;
 
@@ -176,7 +176,7 @@ SCTP_ARG_CONSTRUCTOR(BA,	struct sctp_bind_addr *, bp)
 SCTP_ARG_CONSTRUCTOR(PEER_INIT,	struct sctp_init_chunk *, init)
 SCTP_ARG_CONSTRUCTOR(ULPEVENT,  struct sctp_ulpevent *, ulpevent)
 SCTP_ARG_CONSTRUCTOR(PACKET,	struct sctp_packet *, packet)
-SCTP_ARG_CONSTRUCTOR(SACKH,	sctp_sackhdr_t *, sackh)
+SCTP_ARG_CONSTRUCTOR(SACKH,	struct sctp_sackhdr *, sackh)
 SCTP_ARG_CONSTRUCTOR(DATAMSG,	struct sctp_datamsg *, msg)
 
 static inline sctp_arg_t SCTP_FORCE(void)

commit 01a992bea523d9568cf56a02003c15c9dc40eb20
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jun 30 11:52:22 2017 +0800

    sctp: remove the typedef sctp_init_chunk_t
    
    This patch is to remove the typedef sctp_init_chunk_t, and replace
    with struct sctp_init_chunk in the places where it's using this
    typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index d4a20d00461c..d4679e7a5ed5 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -132,7 +132,7 @@ typedef union {
 	struct sctp_association *asoc;
 	struct sctp_transport *transport;
 	struct sctp_bind_addr *bp;
-	sctp_init_chunk_t *init;
+	struct sctp_init_chunk *init;
 	struct sctp_ulpevent *ulpevent;
 	struct sctp_packet *packet;
 	sctp_sackhdr_t *sackh;
@@ -173,7 +173,7 @@ SCTP_ARG_CONSTRUCTOR(CHUNK,	struct sctp_chunk *, chunk)
 SCTP_ARG_CONSTRUCTOR(ASOC,	struct sctp_association *, asoc)
 SCTP_ARG_CONSTRUCTOR(TRANSPORT,	struct sctp_transport *, transport)
 SCTP_ARG_CONSTRUCTOR(BA,	struct sctp_bind_addr *, bp)
-SCTP_ARG_CONSTRUCTOR(PEER_INIT,	sctp_init_chunk_t *, init)
+SCTP_ARG_CONSTRUCTOR(PEER_INIT,	struct sctp_init_chunk *, init)
 SCTP_ARG_CONSTRUCTOR(ULPEVENT,  struct sctp_ulpevent *, ulpevent)
 SCTP_ARG_CONSTRUCTOR(PACKET,	struct sctp_packet *, packet)
 SCTP_ARG_CONSTRUCTOR(SACKH,	sctp_sackhdr_t *, sackh)

commit bdf6fa52f01b941d4a80372d56de465bdbbd1d23
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Fri Oct 3 18:16:20 2014 -0400

    sctp: handle association restarts when the socket is closed.
    
    Currently association restarts do not take into consideration the
    state of the socket.  When a restart happens, the current assocation
    simply transitions into established state.  This creates a condition
    where a remote system, through a the restart procedure, may create a
    local association that is no way reachable by user.  The conditions
    to trigger this are as follows:
      1) Remote does not acknoledge some data causing data to remain
         outstanding.
      2) Local application calls close() on the socket.  Since data
         is still outstanding, the association is placed in SHUTDOWN_PENDING
         state.  However, the socket is closed.
      3) The remote tries to create a new association, triggering a restart
         on the local system.  The association moves from SHUTDOWN_PENDING
         to ESTABLISHED.  At this point, it is no longer reachable by
         any socket on the local system.
    
    This patch addresses the above situation by moving the newly ESTABLISHED
    association into SHUTDOWN-SENT state and bundling a SHUTDOWN after
    the COOKIE-ACK chunk.  This way, the restarted associate immidiately
    enters the shutdown procedure and forces the termination of the
    unreachable association.
    
    Reported-by: David Laight <David.Laight@aculab.com>
    Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index f22538e68245..d4a20d00461c 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -115,7 +115,7 @@ typedef enum {
  * analysis of the state functions, but in reality just taken from
  * thin air in the hopes othat we don't trigger a kernel panic.
  */
-#define SCTP_MAX_NUM_COMMANDS 14
+#define SCTP_MAX_NUM_COMMANDS 20
 
 typedef union {
 	void *zero_all;	/* Set to NULL to clear the entire union */

commit d1a3fe26e97c0f17579c39f8a446c50f7cc3154a
Author: David Laight <David.Laight@ACULAB.COM>
Date:   Fri Jul 4 14:35:57 2014 +0000

    net: sctp: Use pointers (not array indexes) to access sctp_cmd_seq_t.cmds[].
    
    Using pointers into sctp_cmd_seq_t.cmds[] lets the compiler generate much
    better code.
    Use the last entry first to optimise the overflow check.
    
    Signed-off-by: David Laight <david.laight@aculab.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 589a1918ad55..f22538e68245 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -203,8 +203,8 @@ typedef struct {
 
 typedef struct {
 	sctp_cmd_t cmds[SCTP_MAX_NUM_COMMANDS];
-	__u8 next_free_slot;
-	__u8 next_cmd;
+	sctp_cmd_t *last_used_slot;
+	sctp_cmd_t *next_cmd;
 } sctp_cmd_seq_t;
 
 
@@ -213,8 +213,9 @@ typedef struct {
  */
 static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
 {
-	seq->next_free_slot = 0;
-	seq->next_cmd = 0;
+	/* cmds[] is filled backwards to simplify the overflow BUG() check */
+	seq->last_used_slot = seq->cmds + SCTP_MAX_NUM_COMMANDS;
+	seq->next_cmd = seq->last_used_slot;
 	return 1;		/* We always succeed.  */
 }
 
@@ -227,10 +228,13 @@ static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
 static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
 				   sctp_arg_t obj)
 {
-	BUG_ON(seq->next_free_slot >= SCTP_MAX_NUM_COMMANDS);
+	sctp_cmd_t *cmd = seq->last_used_slot - 1;
 
-	seq->cmds[seq->next_free_slot].verb = verb;
-	seq->cmds[seq->next_free_slot++].obj = obj;
+	BUG_ON(cmd < seq->cmds);
+
+	cmd->verb = verb;
+	cmd->obj = obj;
+	seq->last_used_slot = cmd;
 }
 
 /* Return the next command structure in an sctp_cmd_seq.
@@ -238,12 +242,10 @@ static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
  */
 static inline sctp_cmd_t *sctp_next_cmd(sctp_cmd_seq_t *seq)
 {
-	sctp_cmd_t *retval = NULL;
-
-	if (seq->next_cmd < seq->next_free_slot)
-		retval = &seq->cmds[seq->next_cmd++];
+	if (seq->next_cmd <= seq->last_used_slot)
+		return NULL;
 
-	return retval;
+	return --seq->next_cmd;
 }
 
 #endif /* __net_sctp_command_h__ */

commit b9420e1c87838bcb354ae3495852430413dd9e4b
Author: David Laight <David.Laight@ACULAB.COM>
Date:   Fri Jul 4 14:35:51 2014 +0000

    net: sctp: Optimise the way 'sctp_arg_t' values are initialised.
    
    Even if memset() is inlined (as on x86) using it to zero the union
    generates a memory word write of zero, followed by a write of the
    smaller field, and then a read of the word.
    As well as being a lot of instructions the sequence is unlikely to
    be optimised by the store-load forward hardware so will be slow.
    
    Instead allocate a field of the union that is the same size as the
    entire union and write a zero value to it. The compiler will then
    generate the required value in a register.
    
    Zeroing the union shouldn't be necessary, but this patch series isn't
    intended to have a behavioural change.
    
    Signed-off-by: David Laight <david.laight@aculab.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 0e91a42065db..589a1918ad55 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -118,6 +118,7 @@ typedef enum {
 #define SCTP_MAX_NUM_COMMANDS 14
 
 typedef union {
+	void *zero_all;	/* Set to NULL to clear the entire union */
 	__s32 i32;
 	__u32 u32;
 	__be32 be32;
@@ -154,7 +155,7 @@ typedef union {
 static inline sctp_arg_t	\
 SCTP_## name (type arg)		\
 { sctp_arg_t retval;\
-  memset(&retval, 0, sizeof(sctp_arg_t));\
+  retval.zero_all = NULL;\
   retval.elt = arg;\
   return retval;\
 }
@@ -191,7 +192,7 @@ static inline sctp_arg_t SCTP_NOFORCE(void)
 static inline sctp_arg_t SCTP_NULL(void)
 {
 	sctp_arg_t retval;
-	memset(&retval, 0, sizeof(sctp_arg_t));
+	retval.zero_all = NULL;
 	return retval;
 }
 
@@ -212,7 +213,8 @@ typedef struct {
  */
 static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
 {
-	memset(seq, 0, sizeof(sctp_cmd_seq_t));
+	seq->next_free_slot = 0;
+	seq->next_cmd = 0;
 	return 1;		/* We always succeed.  */
 }
 

commit be1f4f48cef17c6ea9350db04c774dc8eb252158
Author: David Laight <David.Laight@ACULAB.COM>
Date:   Fri Jul 4 14:35:51 2014 +0000

    net: sctp: Inline the functions from command.c
    
    sctp_init_cmd_seq() and sctp_next_cmd() are only called from one place.
    The call sequence for sctp_add_cmd_sf() is likely to be longer than
    the inlined code.
    With sctp_add_cmd_sf() inlined the compiler can optimise repeated calls.
    
    Signed-off-by: David Laight <david.laight@aculab.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 4b7cd695e431..0e91a42065db 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -210,19 +210,38 @@ typedef struct {
 /* Initialize a block of memory as a command sequence.
  * Return 0 if the initialization fails.
  */
-int sctp_init_cmd_seq(sctp_cmd_seq_t *seq);
+static inline int sctp_init_cmd_seq(sctp_cmd_seq_t *seq)
+{
+	memset(seq, 0, sizeof(sctp_cmd_seq_t));
+	return 1;		/* We always succeed.  */
+}
+
 
 /* Add a command to an sctp_cmd_seq_t.
  *
  * Use the SCTP_* constructors defined by SCTP_ARG_CONSTRUCTOR() above
  * to wrap data which goes in the obj argument.
  */
-void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb, sctp_arg_t obj);
+static inline void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb,
+				   sctp_arg_t obj)
+{
+	BUG_ON(seq->next_free_slot >= SCTP_MAX_NUM_COMMANDS);
+
+	seq->cmds[seq->next_free_slot].verb = verb;
+	seq->cmds[seq->next_free_slot++].obj = obj;
+}
 
 /* Return the next command structure in an sctp_cmd_seq.
  * Return NULL at the end of the sequence.
  */
-sctp_cmd_t *sctp_next_cmd(sctp_cmd_seq_t *seq);
+static inline sctp_cmd_t *sctp_next_cmd(sctp_cmd_seq_t *seq)
+{
+	sctp_cmd_t *retval = NULL;
 
-#endif /* __net_sctp_command_h__ */
+	if (seq->next_cmd < seq->next_free_slot)
+		retval = &seq->cmds[seq->next_cmd++];
+
+	return retval;
+}
 
+#endif /* __net_sctp_command_h__ */

commit a6227e26d946bc56df47ca5fe418660a07ef8288
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri Dec 6 09:13:40 2013 -0800

    include/net/: Fix FSF address in file headers
    
    Several files refer to an old address for the Free Software Foundation
    in the file header comment.  Resolve by replacing the address with
    the URL <http://www.gnu.org/licenses/> so that we do not have to keep
    updating the header comments anytime the address changes.
    
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 832f2191489c..4b7cd695e431 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -19,9 +19,8 @@
  * See the GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with GNU CC; see the file COPYING.  If not, write to
- * the Free Software Foundation, 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
+ * along with GNU CC; see the file COPYING.  If not, see
+ * <http://www.gnu.org/licenses/>.
  *
  * Please send any bug reports or fixes you make to the
  * email address(es):

commit 477143e3fece3dc12629bb1ebd7b47e8e6e72b2b
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Aug 6 21:18:13 2013 +0200

    net: sctp: trivial: update bug report in header comment
    
    With the restructuring of the lksctp.org site, we only allow bug
    reports through the SCTP mailing list linux-sctp@vger.kernel.org,
    not via SF, as SF is only used for web hosting and nothing more.
    While at it, also remove the obvious statement that bugs will be
    fixed and incooperated into the kernel.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 35247271e557..832f2191489c 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -23,19 +23,17 @@
  * the Free Software Foundation, 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  *
- * Please send any bug reports or fixes you make to one of the
- * following email addresses:
+ * Please send any bug reports or fixes you make to the
+ * email address(es):
+ *    lksctp developers <linux-sctp@vger.kernel.org>
  *
- * La Monte H.P. Yarroll <piggy@acm.org>
- * Karl Knutson <karl@athena.chicago.il.us>
- * Ardelle Fan <ardelle.fan@intel.com>
- * Sridhar Samudrala <sri@us.ibm.com>
- *
- * Any bugs reported given to us we will try to fix... any fixes shared will
- * be incorporated into the next SCTP release.
+ * Written or modified by:
+ *   La Monte H.P. Yarroll <piggy@acm.org>
+ *   Karl Knutson <karl@athena.chicago.il.us>
+ *   Ardelle Fan <ardelle.fan@intel.com>
+ *   Sridhar Samudrala <sri@us.ibm.com>
  */
 
-
 #ifndef __net_sctp_command_h__
 #define __net_sctp_command_h__
 

commit b26ddd813031666293c95e84c997eb8b1f97bd38
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Mon Oct 29 08:32:13 2012 +0000

    sctp: Clean up type-punning in sctp_cmd_t union
    
    Lots of points in the sctp_cmd_interpreter function treat the sctp_cmd_t arg as
    a void pointer, even though they are written as various other types.  Theres no
    need for this as doing so just leads to possible type-punning issues that could
    cause crashes, and if we remain type-consistent we can actually just remove the
    void * member of the union entirely.
    
    Change Notes:
    
    v2)
            * Dropped chunk that modified SCTP_NULL to create a marker pattern
             should anyone try to use a SCTP_NULL() assigned sctp_arg_t, Assigning
             to .zero provides the same effect and should be faster, per Vlad Y.
    
    v3)
            * Reverted part of V2, opting to use memset instead of .zero, so that
             the entire union is initalized thus avoiding the i164 speculative load
             problems previously encountered, per Dave M..  Also rewrote
             SCTP_[NO]FORCE so as to use common infrastructure a little more
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: linux-sctp@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 712b3bebeda7..35247271e557 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -130,8 +130,6 @@ typedef union {
 	__be16 err;
 	sctp_state_t state;
 	sctp_event_timeout_t to;
-	unsigned long zero;
-	void *ptr;
 	struct sctp_chunk *chunk;
 	struct sctp_association *asoc;
 	struct sctp_transport *transport;
@@ -154,23 +152,15 @@ typedef union {
  * which takes an __s32 and returns a sctp_arg_t containing the
  * __s32.  So, after foo = SCTP_I32(arg), foo.i32 == arg.
  */
-static inline sctp_arg_t SCTP_NULL(void)
-{
-	sctp_arg_t retval; retval.ptr = NULL; return retval;
-}
-static inline sctp_arg_t SCTP_NOFORCE(void)
-{
-	sctp_arg_t retval = {.zero = 0UL}; retval.i32 = 0; return retval;
-}
-static inline sctp_arg_t SCTP_FORCE(void)
-{
-	sctp_arg_t retval = {.zero = 0UL}; retval.i32 = 1; return retval;
-}
 
 #define SCTP_ARG_CONSTRUCTOR(name, type, elt) \
 static inline sctp_arg_t	\
 SCTP_## name (type arg)		\
-{ sctp_arg_t retval = {.zero = 0UL}; retval.elt = arg; return retval; }
+{ sctp_arg_t retval;\
+  memset(&retval, 0, sizeof(sctp_arg_t));\
+  retval.elt = arg;\
+  return retval;\
+}
 
 SCTP_ARG_CONSTRUCTOR(I32,	__s32, i32)
 SCTP_ARG_CONSTRUCTOR(U32,	__u32, u32)
@@ -181,7 +171,6 @@ SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)
 SCTP_ARG_CONSTRUCTOR(PERR,      __be16, err)	/* protocol error */
 SCTP_ARG_CONSTRUCTOR(STATE,	sctp_state_t, state)
 SCTP_ARG_CONSTRUCTOR(TO,	sctp_event_timeout_t, to)
-SCTP_ARG_CONSTRUCTOR(PTR,	void *, ptr)
 SCTP_ARG_CONSTRUCTOR(CHUNK,	struct sctp_chunk *, chunk)
 SCTP_ARG_CONSTRUCTOR(ASOC,	struct sctp_association *, asoc)
 SCTP_ARG_CONSTRUCTOR(TRANSPORT,	struct sctp_transport *, transport)
@@ -192,6 +181,23 @@ SCTP_ARG_CONSTRUCTOR(PACKET,	struct sctp_packet *, packet)
 SCTP_ARG_CONSTRUCTOR(SACKH,	sctp_sackhdr_t *, sackh)
 SCTP_ARG_CONSTRUCTOR(DATAMSG,	struct sctp_datamsg *, msg)
 
+static inline sctp_arg_t SCTP_FORCE(void)
+{
+	return SCTP_I32(1);
+}
+
+static inline sctp_arg_t SCTP_NOFORCE(void)
+{
+	return SCTP_I32(0);
+}
+
+static inline sctp_arg_t SCTP_NULL(void)
+{
+	sctp_arg_t retval;
+	memset(&retval, 0, sizeof(sctp_arg_t));
+	return retval;
+}
+
 typedef struct {
 	sctp_arg_t obj;
 	sctp_verb_t verb;

commit d5ccd496601b8776a516d167a6485754575dc38f
Author: Max Matveev <makc@redhat.com>
Date:   Mon Aug 29 21:02:24 2011 +0000

    sctp: deal with multiple COOKIE_ECHO chunks
    
    Attempt to reduce the number of IP packets emitted in response to single
    SCTP packet (2e3216cd) introduced a complication - if a packet contains
    two COOKIE_ECHO chunks and nothing else then SCTP state machine corks the
    socket while processing first COOKIE_ECHO and then loses the association
    and forgets to uncork the socket. To deal with the issue add new SCTP
    command which can be used to set association explictly. Use this new
    command when processing second COOKIE_ECHO chunk to restore the context
    for SCTP state machine.
    
    Signed-off-by: Max Matveev <makc@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 6506458ccd33..712b3bebeda7 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -109,6 +109,7 @@ typedef enum {
 	SCTP_CMD_SEND_MSG,	 /* Send the whole use message */
 	SCTP_CMD_SEND_NEXT_ASCONF, /* Send the next ASCONF after ACK */
 	SCTP_CMD_PURGE_ASCONF_QUEUE, /* Purge all asconf queues.*/
+	SCTP_CMD_SET_ASOC,	 /* Restore association context */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit f8d9605243280f1870dd2c6c37a735b925c15f3c
Author: Thomas Graf <tgraf@infradead.org>
Date:   Thu Jul 7 00:28:35 2011 +0000

    sctp: Enforce retransmission limit during shutdown
    
    When initiating a graceful shutdown while having data chunks
    on the retransmission queue with a peer which is in zero
    window mode the shutdown is never completed because the
    retransmission error count is reset periodically by the
    following two rules:
    
     - Do not timeout association while doing zero window probe.
     - Reset overall error count when a heartbeat request has
       been acknowledged.
    
    The graceful shutdown will wait for all outstanding TSN to
    be acknowledged before sending the SHUTDOWN request. This
    never happens due to the peer's zero window not acknowledging
    the continuously retransmitted data chunks. Although the
    error counter is incremented for each failed retransmission,
    the receiving of the SACK announcing the zero window clears
    the error count again immediately. Also heartbeat requests
    continue to be sent periodically. The peer acknowledges these
    requests causing the error counter to be reset as well.
    
    This patch changes behaviour to only reset the overall error
    counter for the above rules while not in shutdown. After
    reaching the maximum number of retransmission attempts, the
    T5 shutdown guard timer is scheduled to give the receiver
    some additional time to recover. The timer is stopped as soon
    as the receiver acknowledges any data.
    
    The issue can be easily reproduced by establishing a sctp
    association over the loopback device, constantly queueing
    data at the sender while not reading any at the receiver.
    Wait for the window to reach zero, then initiate a shutdown
    by killing both processes simultaneously. The association
    will never be freed and the chunks on the retransmission
    queue will be retransmitted indefinitely.
    
    Signed-off-by: Thomas Graf <tgraf@infradead.org>
    Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index dd6847e5d6e4..6506458ccd33 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -63,6 +63,7 @@ typedef enum {
 	SCTP_CMD_ECN_ECNE,	/* Do delayed ECNE processing. */
 	SCTP_CMD_ECN_CWR,	/* Do delayed CWR processing.  */
 	SCTP_CMD_TIMER_START,	/* Start a timer.  */
+	SCTP_CMD_TIMER_START_ONCE, /* Start a timer once */
 	SCTP_CMD_TIMER_RESTART,	/* Restart a timer. */
 	SCTP_CMD_TIMER_STOP,	/* Stop a timer. */
 	SCTP_CMD_INIT_CHOOSE_TRANSPORT, /* Choose transport for an INIT. */

commit a000c01e60e40e15304ffe48fff051d17a7bea91
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Sun May 29 23:23:36 2011 +0000

    sctp: stop pending timers and purge queues when peer restart asoc
    
    If the peer restart the asoc, we should not only fail any unsent/unacked
    data, but also stop the T3-rtx, SACK, T4-rto timers, and teardown ASCONF
    queues.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 2b447646ce4b..dd6847e5d6e4 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -107,6 +107,7 @@ typedef enum {
 	SCTP_CMD_UPDATE_INITTAG, /* Update peer inittag */
 	SCTP_CMD_SEND_MSG,	 /* Send the whole use message */
 	SCTP_CMD_SEND_NEXT_ASCONF, /* Send the next ASCONF after ACK */
+	SCTP_CMD_PURGE_ASCONF_QUEUE, /* Purge all asconf queues.*/
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit 66009927f1e7374afdc6f9fdd25c493ee4eadf7c
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Mon Apr 18 19:12:40 2011 +0000

    sctp: kill abandoned SCTP_CMD_TRANSMIT command
    
    Remove SCTP_CMD_TRANSMIT command as it never be used.
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index c01dc99def07..2b447646ce4b 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -73,7 +73,6 @@ typedef enum {
 	SCTP_CMD_INIT_FAILED,   /* High level, do init failure work. */
 	SCTP_CMD_REPORT_DUP,	/* Report a duplicate TSN.  */
 	SCTP_CMD_STRIKE,	/* Mark a strike against a transport.  */
-	SCTP_CMD_TRANSMIT,      /* Transmit the outqueue. */
 	SCTP_CMD_HB_TIMERS_START,    /* Start the heartbeat timers. */
 	SCTP_CMD_HB_TIMER_UPDATE,    /* Update a heartbeat timers.  */
 	SCTP_CMD_HB_TIMERS_STOP,     /* Stop the heartbeat timers.  */

commit 49b4a6546fac02f58784f0744e0f99a6562ccc03
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Mon Nov 29 00:14:58 2010 +0000

    sctp: kill unused macros in head file
    
    1. SCTP_CMD_NUM_VERBS,SCTP_CMD_MAX
    These two macros have never been used for several years since v2.6.12-rc2.
    
    2.sctp_port_rover,sctp_port_alloc_lock
    The commit 063930 abandoned global variables of port_rover and port_alloc_lock,
    but still keep two macros to refer to them.
    So, remove them now.
    
    commit 06393009000779b00a558fd2f280882cc7dc2008
    Author: Stephen Hemminger <shemminger@linux-foundation.org>
    Date:   Wed Oct 10 17:30:18 2007 -0700
    
        [SCTP]: port randomization
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 2c55a7ea20af..c01dc99def07 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -111,9 +111,6 @@ typedef enum {
 	SCTP_CMD_LAST
 } sctp_verb_t;
 
-#define SCTP_CMD_MAX		(SCTP_CMD_LAST - 1)
-#define SCTP_CMD_NUM_VERBS	(SCTP_CMD_MAX + 1)
-
 /* How many commands can you put in an sctp_cmd_seq_t?
  * This is a rather arbitrary number, ideally derived from a careful
  * analysis of the state functions, but in reality just taken from

commit c0786693404cffd80ca3cb6e75ee7b35186b2825
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Apr 28 08:47:22 2010 +0000

    sctp: Fix oops when sending queued ASCONF chunks
    
    When we finish processing ASCONF_ACK chunk, we try to send
    the next queued ASCONF.  This action runs the sctp state
    machine recursively and it's not prepared to do so.
    
    kernel BUG at kernel/timer.c:790!
    invalid opcode: 0000 [#1] SMP
    last sysfs file: /sys/module/ipv6/initstate
    Modules linked in: sha256_generic sctp libcrc32c ipv6 dm_multipath
    uinput 8139too i2c_piix4 8139cp mii i2c_core pcspkr virtio_net joydev
    floppy virtio_blk virtio_pci [last unloaded: scsi_wait_scan]
    
    Pid: 0, comm: swapper Not tainted 2.6.34-rc4 #15 /Bochs
    EIP: 0060:[<c044a2ef>] EFLAGS: 00010286 CPU: 0
    EIP is at add_timer+0xd/0x1b
    EAX: cecbab14 EBX: 000000f0 ECX: c0957b1c EDX: 03595cf4
    ESI: cecba800 EDI: cf276f00 EBP: c0957aa0 ESP: c0957aa0
     DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
    Process swapper (pid: 0, ti=c0956000 task=c0988ba0 task.ti=c0956000)
    Stack:
     c0957ae0 d1851214 c0ab62e4 c0ab5f26 0500ffff 00000004 00000005 00000004
    <0> 00000000 d18694fd 00000004 1666b892 cecba800 cecba800 c0957b14
    00000004
    <0> c0957b94 d1851b11 ceda8b00 cecba800 cf276f00 00000001 c0957b14
    000000d0
    Call Trace:
     [<d1851214>] ? sctp_side_effects+0x607/0xdfc [sctp]
     [<d1851b11>] ? sctp_do_sm+0x108/0x159 [sctp]
     [<d1863386>] ? sctp_pname+0x0/0x1d [sctp]
     [<d1861a56>] ? sctp_primitive_ASCONF+0x36/0x3b [sctp]
     [<d185657c>] ? sctp_process_asconf_ack+0x2a4/0x2d3 [sctp]
     [<d184e35c>] ? sctp_sf_do_asconf_ack+0x1dd/0x2b4 [sctp]
     [<d1851ac1>] ? sctp_do_sm+0xb8/0x159 [sctp]
     [<d1863334>] ? sctp_cname+0x0/0x52 [sctp]
     [<d1854377>] ? sctp_assoc_bh_rcv+0xac/0xe1 [sctp]
     [<d1858f0f>] ? sctp_inq_push+0x2d/0x30 [sctp]
     [<d186329d>] ? sctp_rcv+0x797/0x82e [sctp]
    
    Tested-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Yuansong Qiao <ysqiao@research.ait.ie>
    Signed-off-by: Shuaijun Zhang <szhang@research.ait.ie>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 8be5135ff7aa..2c55a7ea20af 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -107,6 +107,7 @@ typedef enum {
 	SCTP_CMD_T1_RETRAN,	 /* Mark for retransmission after T1 timeout  */
 	SCTP_CMD_UPDATE_INITTAG, /* Update peer inittag */
 	SCTP_CMD_SEND_MSG,	 /* Send the whole use message */
+	SCTP_CMD_SEND_NEXT_ASCONF, /* Send the next ASCONF after ACK */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit 9c5c62be2f794c7cee533d856f9f34c3cf21ff1b
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Aug 10 13:51:03 2009 -0400

    sctp: Send user messages to the lower layer as one
    
    Currenlty, sctp breaks up user messages into fragments and
    sends each fragment to the lower layer by itself.  This means
    that for each fragment we go all the way down the stack
    and back up.  This also discourages bundling of multiple
    fragments when they can fit into a sigle packet (ex: due
    to user setting a low fragmentation threashold).
    
    We introduce a new command SCTP_CMD_SND_MSG and hand the
    whole message down state machine.  The state machine and
    the side-effect parser will cork the queue, add all chunks
    from the message to the queue, and then un-cork the queue
    thus causing the chunks to get transmitted.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 3b966802e05d..8be5135ff7aa 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -106,6 +106,7 @@ typedef enum {
 	SCTP_CMD_ASSOC_SHKEY,    /* generate the association shared keys */
 	SCTP_CMD_T1_RETRAN,	 /* Mark for retransmission after T1 timeout  */
 	SCTP_CMD_UPDATE_INITTAG, /* Update peer inittag */
+	SCTP_CMD_SEND_MSG,	 /* Send the whole use message */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 
@@ -139,6 +140,7 @@ typedef union {
 	struct sctp_ulpevent *ulpevent;
 	struct sctp_packet *packet;
 	sctp_sackhdr_t *sackh;
+	struct sctp_datamsg *msg;
 } sctp_arg_t;
 
 /* We are simulating ML type constructors here.
@@ -188,6 +190,7 @@ SCTP_ARG_CONSTRUCTOR(PEER_INIT,	sctp_init_chunk_t *, init)
 SCTP_ARG_CONSTRUCTOR(ULPEVENT,  struct sctp_ulpevent *, ulpevent)
 SCTP_ARG_CONSTRUCTOR(PACKET,	struct sctp_packet *, packet)
 SCTP_ARG_CONSTRUCTOR(SACKH,	sctp_sackhdr_t *, sackh)
+SCTP_ARG_CONSTRUCTOR(DATAMSG,	struct sctp_datamsg *, msg)
 
 typedef struct {
 	sctp_arg_t obj;

commit 7e99013a5043cacd375375c3efad35b57c3afdba
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Mar 2 09:46:14 2009 +0000

    sctp: Fix broken RTO-doubling for data retransmits
    
    Commit faee47cdbfe8d74a1573c2f81ea6dbb08d735be6
    (sctp: Fix the RTO-doubling on idle-link heartbeats)
    broke the RTO doubling for data retransmits.  If the
    heartbeat was sent before the data T3-rtx time, the
    the RTO will not double upon the T3-rtx expiration.
    Distingish between the operations by passing an argument
    to the function.
    
    Additionally, Wei Youngjun pointed out that our treatment
    of requested HEARTBEATS and timer HEARTBEATS is the same
    wrt resetting congestion window.  That needs to be separated,
    since user requested HEARTBEATS should not treat the link
    as idle.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 88988ab03d75..3b966802e05d 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -77,7 +77,8 @@ typedef enum {
 	SCTP_CMD_HB_TIMERS_START,    /* Start the heartbeat timers. */
 	SCTP_CMD_HB_TIMER_UPDATE,    /* Update a heartbeat timers.  */
 	SCTP_CMD_HB_TIMERS_STOP,     /* Stop the heartbeat timers.  */
-	SCTP_CMD_TRANSPORT_RESET,    /* Reset the status of a transport. */
+	SCTP_CMD_TRANSPORT_HB_SENT,  /* Reset the status of a transport. */
+	SCTP_CMD_TRANSPORT_IDLE,     /* Do manipulations on idle transport */
 	SCTP_CMD_TRANSPORT_ON,       /* Mark the transport as active. */
 	SCTP_CMD_REPORT_ERROR,   /* Pass this error back out of the sm. */
 	SCTP_CMD_REPORT_BAD_TAG, /* Verification tags didn't match. */

commit df39e8ba56a788733d369068c7319e04b1da3cd5
Merge: f5572855ec49 159d83363b62
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Apr 14 02:30:23 2008 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
    
            drivers/net/ehea/ehea_main.c
            drivers/net/wireless/iwlwifi/Kconfig
            drivers/net/wireless/rt2x00/rt61pci.c
            net/ipv4/inet_timewait_sock.c
            net/ipv6/raw.c
            net/mac80211/ieee80211_sta.c

commit f4ad85ca3ef8a1ede76c5020a28a8f4057b4d24f
Author: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
Date:   Sat Apr 12 18:39:34 2008 -0700

    [SCTP]: Fix protocol violation when receiving an error lenght INIT-ACK
    
    When receiving an error length INIT-ACK during COOKIE-WAIT,
    a 0-vtag ABORT will be responsed. This action violates the
    protocol apparently. This patch achieves the following things.
    1 If the INIT-ACK contains all the fixed parameters, use init-tag
      recorded from INIT-ACK as vtag.
    2 If the INIT-ACK doesn't contain all the fixed parameters,
      just reflect its vtag.
    
    Signed-off-by: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 10ae2da6f93b..35b1e83fb96a 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -104,6 +104,7 @@ typedef enum {
 	SCTP_CMD_ADAPTATION_IND, /* generate and send adaptation event */
 	SCTP_CMD_ASSOC_SHKEY,    /* generate the association shared keys */
 	SCTP_CMD_T1_RETRAN,	 /* Mark for retransmission after T1 timeout  */
+	SCTP_CMD_UPDATE_INITTAG, /* Update peer inittag */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit bc09dff198e67a98a82c42000006b39f6d502031
Author: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
Date:   Thu Mar 27 17:54:29 2008 -0700

    [SCTP]: Remove sctp_add_cmd_sf wrapper bloat
    
    With a was number of callsites sctp_add_cmd_sf wrapper bloats
    kernel by some amount. Due to unlikely tracking allyesconfig,
    with the initial result were around ~7kB (thus caught my
    attention) while a non-debug config produced only ~2.3kB effect.
    
    I (ij) proposed first a patch to uninline it but Vlad responded
    with a patch that removed the only sctp_add_cmd call which is
    wrapped by sctp_add_cmd_sf (I wasn't sure if I could do that).
    I did minor cleanup to Vlad's patch.
    
    Signed-off-by: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 10ae2da6f93b..4263af857794 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -205,12 +205,11 @@ typedef struct {
 int sctp_init_cmd_seq(sctp_cmd_seq_t *seq);
 
 /* Add a command to an sctp_cmd_seq_t.
- * Return 0 if the command sequence is full.
  *
  * Use the SCTP_* constructors defined by SCTP_ARG_CONSTRUCTOR() above
  * to wrap data which goes in the obj argument.
  */
-int sctp_add_cmd(sctp_cmd_seq_t *seq, sctp_verb_t verb, sctp_arg_t obj);
+void sctp_add_cmd_sf(sctp_cmd_seq_t *seq, sctp_verb_t verb, sctp_arg_t obj);
 
 /* Return the next command structure in an sctp_cmd_seq.
  * Return NULL at the end of the sequence.

commit 60c778b25972e095df8981dd41e99d161e8738f9
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Jan 11 09:57:09 2008 -0500

    [SCTP]: Stop claiming that this is a "reference implementation"
    
    I was notified by Randy Stewart that lksctp claims to be
    "the reference implementation".  First of all, "the
    refrence implementation" was the original implementation
    of SCTP in usersapce written ty Randy and a few others.
    Second, after looking at the definiton of 'reference implementation',
    we don't really meet the requirements.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index c1f797673571..10ae2da6f93b 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -1,18 +1,18 @@
-/* SCTP kernel reference Implementation
+/* SCTP kernel Implementation
  * (C) Copyright IBM Corp. 2001, 2004
  * Copyright (C) 1999-2001 Cisco, Motorola
  *
- * This file is part of the SCTP kernel reference Implementation
+ * This file is part of the SCTP kernel implementation
  *
  * These are the definitions needed for the command object.
  *
- * The SCTP reference implementation  is free software;
+ * This SCTP implementation  is free software;
  * you can redistribute it and/or modify it under the terms of
  * the GNU General Public License as published by
  * the Free Software Foundation; either version 2, or (at your option)
  * any later version.
  *
- * the SCTP reference implementation  is distributed in the hope that it
+ * This SCTP implementation  is distributed in the hope that it
  * will be useful, but WITHOUT ANY WARRANTY; without even the implied
  *                 ************************
  * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

commit b6157d8e03e1e780660a328f7183bcbfa4a93a19
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 24 15:59:16 2007 -0400

    SCTP: Fix difference cases of retransmit.
    
    Commit d0ce92910bc04e107b2f3f2048f07e94f570035d broke several retransmit
    cases including fast retransmit.  The reason is that we should
    only delay by rto while doing retranmists as a result of a timeout.
    Retransmit as a result of path mtu discover, fast retransmit, or
    other evernts that should trigger immidiate retransmissions got broken.
    
    Also, since rto is doubled prior to marking of packets elegable for
    retransmission, we never marked correct chunks anyway.
    
    The fix is provide a reason for a given retransmission so that we
    can mark chunks appropriately and to save the old rto value to do
    comparisons against.
    
    All regressions tests passed with this code.
    
    Spotted by Wei Yongjun <yjwei@cn.fujitsu.com>
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index b8733364557f..c1f797673571 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -103,6 +103,7 @@ typedef enum {
 	SCTP_CMD_ASSOC_CHANGE,	 /* generate and send assoc_change event */
 	SCTP_CMD_ADAPTATION_IND, /* generate and send adaptation event */
 	SCTP_CMD_ASSOC_SHKEY,    /* generate the association shared keys */
+	SCTP_CMD_T1_RETRAN,	 /* Mark for retransmission after T1 timeout  */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit 730fc3d05cd4ba4c9ce2de91f3d43349e95dbbf5
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sun Sep 16 19:32:11 2007 -0700

    [SCTP]: Implete SCTP-AUTH parameter processing
    
    Implement processing for the CHUNKS, RANDOM, and HMAC parameters and
    deal with how this parameters are effected by association restarts.
    In particular, during unexpeted INIT processing, we need to reply with
    parameters from the original INIT chunk.  Also, after restart, we need
    to update the old association with new peer parameters and change the
    association shared keys.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index f56c8d695a82..b8733364557f 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -102,6 +102,7 @@ typedef enum {
 	SCTP_CMD_SET_SK_ERR,	 /* Set sk_err */
 	SCTP_CMD_ASSOC_CHANGE,	 /* generate and send assoc_change event */
 	SCTP_CMD_ADAPTATION_IND, /* generate and send adaptation event */
+	SCTP_CMD_ASSOC_SHKEY,    /* generate the association shared keys */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit 07d939677166cc4f000c767196872a9becc2697b
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri May 4 13:55:27 2007 -0700

    [SCTP]: Set assoc_id correctly during INIT collision.
    
    During the INIT/COOKIE-ACK collision cases, it's possible to get
    into a situation where the association id is not yet set at the time
    of the user event generation.  As a result, user events have an
    association id set to 0 which will confuse applications.
    
    This happens if we hit case B of duplicate cookie processing.
    In the particular example found and provided by Oscar Isaula
    <Oscar.Isaula@motorola.com>, flow looks like this:
    A                               B
    ---- INIT------->  (lost)
                <---------INIT------
    ---- INIT-ACK--->
                <------ Cookie ECHO
    
    When the Cookie Echo is received, we end up trying to update the
    association that was created on A as a result of the (lost) INIT,
    but that association doesn't have the ID set yet.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 6114c4f54b0a..f56c8d695a82 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -100,6 +100,8 @@ typedef enum {
 	SCTP_CMD_T3_RTX_TIMERS_STOP, /* Stops T3-rtx pending timers */
 	SCTP_CMD_FORCE_PRIM_RETRAN,  /* Forces retrans. over primary path. */
 	SCTP_CMD_SET_SK_ERR,	 /* Set sk_err */
+	SCTP_CMD_ASSOC_CHANGE,	 /* generate and send assoc_change event */
+	SCTP_CMD_ADAPTATION_IND, /* generate and send adaptation event */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit 2178eda82616566b7397791afa6e5487990bac8e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:26:53 2006 -0800

    [SCTP]: SCTP_CMD_PROCESS_CTSN annotations.
    
    argument passed as __be32
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index dfe5d44b61ab..6114c4f54b0a 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -116,6 +116,7 @@ typedef enum {
 typedef union {
 	__s32 i32;
 	__u32 u32;
+	__be32 be32;
 	__u16 u16;
 	__u8 u8;
 	int error;
@@ -165,6 +166,7 @@ SCTP_## name (type arg)		\
 
 SCTP_ARG_CONSTRUCTOR(I32,	__s32, i32)
 SCTP_ARG_CONSTRUCTOR(U32,	__u32, u32)
+SCTP_ARG_CONSTRUCTOR(BE32,	__be32, be32)
 SCTP_ARG_CONSTRUCTOR(U16,	__u16, u16)
 SCTP_ARG_CONSTRUCTOR(U8,	__u8, u8)
 SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)

commit dc251b2b1c4bfea51903cb9fbc141a5b33f6aca7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:00:44 2006 -0800

    [SCTP]: SCTP_CMD_INIT_FAILED annotations.
    
    argument stored for SCTP_CMD_INIT_FAILED is always __be16
    (protocol error).  Introduced new field and accessor for
    it (SCTP_PERR()); switched to their use (from SCTP_U32() and
    .u32)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 807d6f1ef4b5..dfe5d44b61ab 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -119,6 +119,7 @@ typedef union {
 	__u16 u16;
 	__u8 u8;
 	int error;
+	__be16 err;
 	sctp_state_t state;
 	sctp_event_timeout_t to;
 	unsigned long zero;
@@ -167,6 +168,7 @@ SCTP_ARG_CONSTRUCTOR(U32,	__u32, u32)
 SCTP_ARG_CONSTRUCTOR(U16,	__u16, u16)
 SCTP_ARG_CONSTRUCTOR(U8,	__u8, u8)
 SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)
+SCTP_ARG_CONSTRUCTOR(PERR,      __be16, err)	/* protocol error */
 SCTP_ARG_CONSTRUCTOR(STATE,	sctp_state_t, state)
 SCTP_ARG_CONSTRUCTOR(TO,	sctp_event_timeout_t, to)
 SCTP_ARG_CONSTRUCTOR(PTR,	void *, ptr)

commit 8de8c8738086501bbe3057ed6f4b70dded657488
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Fri May 19 10:58:12 2006 -0700

    [SCTP]: Set sk_err so that poll wakes up after a non-blocking connect failure.
    
    Also fix some other cases where sk_err is not set for 1-1 style sockets.
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index 34a1a09e5aef..807d6f1ef4b5 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -99,6 +99,7 @@ typedef enum {
 	SCTP_CMD_DEL_NON_PRIMARY, /* Removes non-primary peer transports. */
 	SCTP_CMD_T3_RTX_TIMERS_STOP, /* Stops T3-rtx pending timers */
 	SCTP_CMD_FORCE_PRIM_RETRAN,  /* Forces retrans. over primary path. */
+	SCTP_CMD_SET_SK_ERR,	 /* Set sk_err */
 	SCTP_CMD_LAST
 } sctp_verb_t;
 

commit 19c7e9eef503dc1ae926f3d26c56f88bee568d7b
Author: Vladislav Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Nov 11 16:07:40 2005 -0800

    [SCTP]: Fix ia64 NaT consumption fault with sctp_sideffect commands.
    
    On ia64, it is possible to get NaT Consumption Fault and a kernel panic
    when initializing sctp sideeffect commands arguments.  The union
    sctp_arg_t contains different sized elements and when loading a smaller
    sized element (32 or 16 bits), it is possible for a speculative load to
    fail and result in a NaT bit set which causes a kernel crash.  The easy
    way to get around it is to load the largerst member of the union.
    
    Signed-off-by: Vladislav Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index dc107ffad483..34a1a09e5aef 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -120,6 +120,7 @@ typedef union {
 	int error;
 	sctp_state_t state;
 	sctp_event_timeout_t to;
+	unsigned long zero;
 	void *ptr;
 	struct sctp_chunk *chunk;
 	struct sctp_association *asoc;
@@ -148,17 +149,17 @@ static inline sctp_arg_t SCTP_NULL(void)
 }
 static inline sctp_arg_t SCTP_NOFORCE(void)
 {
-	sctp_arg_t retval; retval.i32 = 0; return retval;
+	sctp_arg_t retval = {.zero = 0UL}; retval.i32 = 0; return retval;
 }
 static inline sctp_arg_t SCTP_FORCE(void)
 {
-	sctp_arg_t retval; retval.i32 = 1; return retval;
+	sctp_arg_t retval = {.zero = 0UL}; retval.i32 = 1; return retval;
 }
 
 #define SCTP_ARG_CONSTRUCTOR(name, type, elt) \
 static inline sctp_arg_t	\
 SCTP_## name (type arg)		\
-{ sctp_arg_t retval; retval.elt = arg; return retval; }
+{ sctp_arg_t retval = {.zero = 0UL}; retval.elt = arg; return retval; }
 
 SCTP_ARG_CONSTRUCTOR(I32,	__s32, i32)
 SCTP_ARG_CONSTRUCTOR(U32,	__u32, u32)

commit 3f7a87d2fa9b42f7aade43914f060df68cc89cc7
Author: Frank Filz <ffilzlnx@us.ibm.com>
Date:   Mon Jun 20 13:14:57 2005 -0700

    [SCTP] sctp_connectx() API support
    
    Implements sctp_connectx() as defined in the SCTP sockets API draft by
    tunneling the request through a setsockopt().
    
    Signed-off-by: Frank Filz <ffilzlnx@us.ibm.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
index ebc5282e6d58..dc107ffad483 100644
--- a/include/net/sctp/command.h
+++ b/include/net/sctp/command.h
@@ -65,9 +65,11 @@ typedef enum {
 	SCTP_CMD_TIMER_START,	/* Start a timer.  */
 	SCTP_CMD_TIMER_RESTART,	/* Restart a timer. */
 	SCTP_CMD_TIMER_STOP,	/* Stop a timer. */
-	SCTP_CMD_COUNTER_RESET, /* Reset a counter. */
-	SCTP_CMD_COUNTER_INC,   /* Increment a counter. */
+	SCTP_CMD_INIT_CHOOSE_TRANSPORT, /* Choose transport for an INIT. */
+	SCTP_CMD_INIT_COUNTER_RESET, /* Reset init counter. */
+	SCTP_CMD_INIT_COUNTER_INC,   /* Increment init counter. */
 	SCTP_CMD_INIT_RESTART,  /* High level, do init timer work. */
+	SCTP_CMD_COOKIEECHO_RESTART,  /* High level, do cookie-echo timer work. */
 	SCTP_CMD_INIT_FAILED,   /* High level, do init failure work. */
 	SCTP_CMD_REPORT_DUP,	/* Report a duplicate TSN.  */
 	SCTP_CMD_STRIKE,	/* Mark a strike against a transport.  */
@@ -118,7 +120,6 @@ typedef union {
 	int error;
 	sctp_state_t state;
 	sctp_event_timeout_t to;
-	sctp_counter_t counter;
 	void *ptr;
 	struct sctp_chunk *chunk;
 	struct sctp_association *asoc;
@@ -165,7 +166,6 @@ SCTP_ARG_CONSTRUCTOR(U16,	__u16, u16)
 SCTP_ARG_CONSTRUCTOR(U8,	__u8, u8)
 SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)
 SCTP_ARG_CONSTRUCTOR(STATE,	sctp_state_t, state)
-SCTP_ARG_CONSTRUCTOR(COUNTER,	sctp_counter_t, counter)
 SCTP_ARG_CONSTRUCTOR(TO,	sctp_event_timeout_t, to)
 SCTP_ARG_CONSTRUCTOR(PTR,	void *, ptr)
 SCTP_ARG_CONSTRUCTOR(CHUNK,	struct sctp_chunk *, chunk)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/sctp/command.h b/include/net/sctp/command.h
new file mode 100644
index 000000000000..ebc5282e6d58
--- /dev/null
+++ b/include/net/sctp/command.h
@@ -0,0 +1,211 @@
+/* SCTP kernel reference Implementation
+ * (C) Copyright IBM Corp. 2001, 2004
+ * Copyright (C) 1999-2001 Cisco, Motorola
+ *
+ * This file is part of the SCTP kernel reference Implementation
+ *
+ * These are the definitions needed for the command object.
+ *
+ * The SCTP reference implementation  is free software;
+ * you can redistribute it and/or modify it under the terms of
+ * the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * the SCTP reference implementation  is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ *                 ************************
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU CC; see the file COPYING.  If not, write to
+ * the Free Software Foundation, 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Please send any bug reports or fixes you make to one of the
+ * following email addresses:
+ *
+ * La Monte H.P. Yarroll <piggy@acm.org>
+ * Karl Knutson <karl@athena.chicago.il.us>
+ * Ardelle Fan <ardelle.fan@intel.com>
+ * Sridhar Samudrala <sri@us.ibm.com>
+ *
+ * Any bugs reported given to us we will try to fix... any fixes shared will
+ * be incorporated into the next SCTP release.
+ */
+
+
+#ifndef __net_sctp_command_h__
+#define __net_sctp_command_h__
+
+#include <net/sctp/constants.h>
+#include <net/sctp/structs.h>
+
+
+typedef enum {
+	SCTP_CMD_NOP = 0,	/* Do nothing. */
+	SCTP_CMD_NEW_ASOC,	/* Register a new association.  */
+	SCTP_CMD_DELETE_TCB,	/* Delete the current association. */
+	SCTP_CMD_NEW_STATE,	/* Enter a new state.  */
+	SCTP_CMD_REPORT_TSN,	/* Record the arrival of a TSN.  */
+	SCTP_CMD_GEN_SACK,	/* Send a Selective ACK (maybe).  */
+	SCTP_CMD_PROCESS_SACK,	/* Process an inbound SACK.  */
+	SCTP_CMD_GEN_INIT_ACK,	/* Generate an INIT ACK chunk.  */
+	SCTP_CMD_PEER_INIT,	/* Process a INIT from the peer.  */
+	SCTP_CMD_GEN_COOKIE_ECHO, /* Generate a COOKIE ECHO chunk. */
+	SCTP_CMD_CHUNK_ULP,	/* Send a chunk to the sockets layer.  */
+	SCTP_CMD_EVENT_ULP,	/* Send a notification to the sockets layer. */
+	SCTP_CMD_REPLY,		/* Send a chunk to our peer.  */
+	SCTP_CMD_SEND_PKT,	/* Send a full packet to our peer.  */
+	SCTP_CMD_RETRAN,	/* Mark a transport for retransmission.  */
+	SCTP_CMD_ECN_CE,        /* Do delayed CE processing.   */
+	SCTP_CMD_ECN_ECNE,	/* Do delayed ECNE processing. */
+	SCTP_CMD_ECN_CWR,	/* Do delayed CWR processing.  */
+	SCTP_CMD_TIMER_START,	/* Start a timer.  */
+	SCTP_CMD_TIMER_RESTART,	/* Restart a timer. */
+	SCTP_CMD_TIMER_STOP,	/* Stop a timer. */
+	SCTP_CMD_COUNTER_RESET, /* Reset a counter. */
+	SCTP_CMD_COUNTER_INC,   /* Increment a counter. */
+	SCTP_CMD_INIT_RESTART,  /* High level, do init timer work. */
+	SCTP_CMD_INIT_FAILED,   /* High level, do init failure work. */
+	SCTP_CMD_REPORT_DUP,	/* Report a duplicate TSN.  */
+	SCTP_CMD_STRIKE,	/* Mark a strike against a transport.  */
+	SCTP_CMD_TRANSMIT,      /* Transmit the outqueue. */
+	SCTP_CMD_HB_TIMERS_START,    /* Start the heartbeat timers. */
+	SCTP_CMD_HB_TIMER_UPDATE,    /* Update a heartbeat timers.  */
+	SCTP_CMD_HB_TIMERS_STOP,     /* Stop the heartbeat timers.  */
+	SCTP_CMD_TRANSPORT_RESET,    /* Reset the status of a transport. */
+	SCTP_CMD_TRANSPORT_ON,       /* Mark the transport as active. */
+	SCTP_CMD_REPORT_ERROR,   /* Pass this error back out of the sm. */
+	SCTP_CMD_REPORT_BAD_TAG, /* Verification tags didn't match. */
+	SCTP_CMD_PROCESS_CTSN,   /* Sideeffect from shutdown. */
+	SCTP_CMD_ASSOC_FAILED,	 /* Handle association failure. */
+	SCTP_CMD_DISCARD_PACKET, /* Discard the whole packet. */
+	SCTP_CMD_GEN_SHUTDOWN,   /* Generate a SHUTDOWN chunk. */
+	SCTP_CMD_UPDATE_ASSOC,   /* Update association information. */
+	SCTP_CMD_PURGE_OUTQUEUE, /* Purge all data waiting to be sent. */
+	SCTP_CMD_SETUP_T2,       /* Hi-level, setup T2-shutdown parms.  */
+	SCTP_CMD_RTO_PENDING,	 /* Set transport's rto_pending. */
+	SCTP_CMD_PART_DELIVER,	 /* Partial data delivery considerations. */
+	SCTP_CMD_RENEGE,         /* Renege data on an association. */
+	SCTP_CMD_SETUP_T4,	 /* ADDIP, setup T4 RTO timer parms. */
+	SCTP_CMD_PROCESS_OPERR,  /* Process an ERROR chunk. */
+	SCTP_CMD_REPORT_FWDTSN,	 /* Report new cumulative TSN Ack. */
+	SCTP_CMD_PROCESS_FWDTSN, /* Skips were reported, so process further. */
+	SCTP_CMD_CLEAR_INIT_TAG, /* Clears association peer's inittag. */
+	SCTP_CMD_DEL_NON_PRIMARY, /* Removes non-primary peer transports. */
+	SCTP_CMD_T3_RTX_TIMERS_STOP, /* Stops T3-rtx pending timers */
+	SCTP_CMD_FORCE_PRIM_RETRAN,  /* Forces retrans. over primary path. */
+	SCTP_CMD_LAST
+} sctp_verb_t;
+
+#define SCTP_CMD_MAX		(SCTP_CMD_LAST - 1)
+#define SCTP_CMD_NUM_VERBS	(SCTP_CMD_MAX + 1)
+
+/* How many commands can you put in an sctp_cmd_seq_t?
+ * This is a rather arbitrary number, ideally derived from a careful
+ * analysis of the state functions, but in reality just taken from
+ * thin air in the hopes othat we don't trigger a kernel panic.
+ */
+#define SCTP_MAX_NUM_COMMANDS 14
+
+typedef union {
+	__s32 i32;
+	__u32 u32;
+	__u16 u16;
+	__u8 u8;
+	int error;
+	sctp_state_t state;
+	sctp_event_timeout_t to;
+	sctp_counter_t counter;
+	void *ptr;
+	struct sctp_chunk *chunk;
+	struct sctp_association *asoc;
+	struct sctp_transport *transport;
+	struct sctp_bind_addr *bp;
+	sctp_init_chunk_t *init;
+	struct sctp_ulpevent *ulpevent;
+	struct sctp_packet *packet;
+	sctp_sackhdr_t *sackh;
+} sctp_arg_t;
+
+/* We are simulating ML type constructors here.
+ *
+ * SCTP_ARG_CONSTRUCTOR(NAME, TYPE, ELT) builds a function called
+ * SCTP_NAME() which takes an argument of type TYPE and returns an
+ * sctp_arg_t.  It does this by inserting the sole argument into the
+ * ELT union element of a local sctp_arg_t.
+ *
+ * E.g., SCTP_ARG_CONSTRUCTOR(I32, __s32, i32) builds SCTP_I32(arg),
+ * which takes an __s32 and returns a sctp_arg_t containing the
+ * __s32.  So, after foo = SCTP_I32(arg), foo.i32 == arg.
+ */
+static inline sctp_arg_t SCTP_NULL(void)
+{
+	sctp_arg_t retval; retval.ptr = NULL; return retval;
+}
+static inline sctp_arg_t SCTP_NOFORCE(void)
+{
+	sctp_arg_t retval; retval.i32 = 0; return retval;
+}
+static inline sctp_arg_t SCTP_FORCE(void)
+{
+	sctp_arg_t retval; retval.i32 = 1; return retval;
+}
+
+#define SCTP_ARG_CONSTRUCTOR(name, type, elt) \
+static inline sctp_arg_t	\
+SCTP_## name (type arg)		\
+{ sctp_arg_t retval; retval.elt = arg; return retval; }
+
+SCTP_ARG_CONSTRUCTOR(I32,	__s32, i32)
+SCTP_ARG_CONSTRUCTOR(U32,	__u32, u32)
+SCTP_ARG_CONSTRUCTOR(U16,	__u16, u16)
+SCTP_ARG_CONSTRUCTOR(U8,	__u8, u8)
+SCTP_ARG_CONSTRUCTOR(ERROR,     int, error)
+SCTP_ARG_CONSTRUCTOR(STATE,	sctp_state_t, state)
+SCTP_ARG_CONSTRUCTOR(COUNTER,	sctp_counter_t, counter)
+SCTP_ARG_CONSTRUCTOR(TO,	sctp_event_timeout_t, to)
+SCTP_ARG_CONSTRUCTOR(PTR,	void *, ptr)
+SCTP_ARG_CONSTRUCTOR(CHUNK,	struct sctp_chunk *, chunk)
+SCTP_ARG_CONSTRUCTOR(ASOC,	struct sctp_association *, asoc)
+SCTP_ARG_CONSTRUCTOR(TRANSPORT,	struct sctp_transport *, transport)
+SCTP_ARG_CONSTRUCTOR(BA,	struct sctp_bind_addr *, bp)
+SCTP_ARG_CONSTRUCTOR(PEER_INIT,	sctp_init_chunk_t *, init)
+SCTP_ARG_CONSTRUCTOR(ULPEVENT,  struct sctp_ulpevent *, ulpevent)
+SCTP_ARG_CONSTRUCTOR(PACKET,	struct sctp_packet *, packet)
+SCTP_ARG_CONSTRUCTOR(SACKH,	sctp_sackhdr_t *, sackh)
+
+typedef struct {
+	sctp_arg_t obj;
+	sctp_verb_t verb;
+} sctp_cmd_t;
+
+typedef struct {
+	sctp_cmd_t cmds[SCTP_MAX_NUM_COMMANDS];
+	__u8 next_free_slot;
+	__u8 next_cmd;
+} sctp_cmd_seq_t;
+
+
+/* Initialize a block of memory as a command sequence.
+ * Return 0 if the initialization fails.
+ */
+int sctp_init_cmd_seq(sctp_cmd_seq_t *seq);
+
+/* Add a command to an sctp_cmd_seq_t.
+ * Return 0 if the command sequence is full.
+ *
+ * Use the SCTP_* constructors defined by SCTP_ARG_CONSTRUCTOR() above
+ * to wrap data which goes in the obj argument.
+ */
+int sctp_add_cmd(sctp_cmd_seq_t *seq, sctp_verb_t verb, sctp_arg_t obj);
+
+/* Return the next command structure in an sctp_cmd_seq.
+ * Return NULL at the end of the sequence.
+ */
+sctp_cmd_t *sctp_next_cmd(sctp_cmd_seq_t *seq);
+
+#endif /* __net_sctp_command_h__ */
+
