commit 2e7aaaa19cf226944c19fbefbbbbd76f9720b310
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 28 18:13:05 2020 -0600

    net: sctp: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 314a2fa21d6b..fb42c90348d3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -326,7 +326,7 @@ struct sctp_cookie {
 	 * the association TCB is re-constructed from the cookie.
 	 */
 	__u32 raw_addr_list_len;
-	struct sctp_init_chunk peer_init[0];
+	struct sctp_init_chunk peer_init[];
 };
 
 

commit adf6f8cb3f4c2a15d5f35e6cf9ffeb6856d35312
Merge: c431047c4efe e58c19124189
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 25 14:57:26 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Merge in networking bug fixes for merge window.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 312434617cb16be5166316cf9d08ba760b1042a1
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Nov 23 11:56:49 2019 +0800

    sctp: cache netns in sctp_ep_common
    
    This patch is to fix a data-race reported by syzbot:
    
      BUG: KCSAN: data-race in sctp_assoc_migrate / sctp_hash_obj
    
      write to 0xffff8880b67c0020 of 8 bytes by task 18908 on cpu 1:
        sctp_assoc_migrate+0x1a6/0x290 net/sctp/associola.c:1091
        sctp_sock_migrate+0x8aa/0x9b0 net/sctp/socket.c:9465
        sctp_accept+0x3c8/0x470 net/sctp/socket.c:4916
        inet_accept+0x7f/0x360 net/ipv4/af_inet.c:734
        __sys_accept4+0x224/0x430 net/socket.c:1754
        __do_sys_accept net/socket.c:1795 [inline]
        __se_sys_accept net/socket.c:1792 [inline]
        __x64_sys_accept+0x4e/0x60 net/socket.c:1792
        do_syscall_64+0xcc/0x370 arch/x86/entry/common.c:290
        entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
      read to 0xffff8880b67c0020 of 8 bytes by task 12003 on cpu 0:
        sctp_hash_obj+0x4f/0x2d0 net/sctp/input.c:894
        rht_key_get_hash include/linux/rhashtable.h:133 [inline]
        rht_key_hashfn include/linux/rhashtable.h:159 [inline]
        rht_head_hashfn include/linux/rhashtable.h:174 [inline]
        head_hashfn lib/rhashtable.c:41 [inline]
        rhashtable_rehash_one lib/rhashtable.c:245 [inline]
        rhashtable_rehash_chain lib/rhashtable.c:276 [inline]
        rhashtable_rehash_table lib/rhashtable.c:316 [inline]
        rht_deferred_worker+0x468/0xab0 lib/rhashtable.c:420
        process_one_work+0x3d4/0x890 kernel/workqueue.c:2269
        worker_thread+0xa0/0x800 kernel/workqueue.c:2415
        kthread+0x1d4/0x200 drivers/block/aoe/aoecmd.c:1253
        ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:352
    
    It was caused by rhashtable access asoc->base.sk when sctp_assoc_migrate
    is changing its value. However, what rhashtable wants is netns from asoc
    base.sk, and for an asoc, its netns won't change once set. So we can
    simply fix it by caching netns since created.
    
    Fixes: d6c0256a60e6 ("sctp: add the rhashtable apis for sctp global transport hashtable")
    Reported-by: syzbot+e3b35fe7918ff0ee474e@syzkaller.appspotmail.com
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 503fbc3cd819..2b6f3f13d5bc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1239,6 +1239,9 @@ struct sctp_ep_common {
 	/* What socket does this endpoint belong to?  */
 	struct sock *sk;
 
+	/* Cache netns and it won't change once set */
+	struct net *net;
+
 	/* This is where we receive inbound chunks.  */
 	struct sctp_inq	  inqueue;
 

commit 34515e94c92c3f593cd696abca8609246cbd75e6
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Nov 8 13:20:35 2019 +0800

    sctp: add support for Primary Path Switchover
    
    This is a new feature defined in section 5 of rfc7829: "Primary Path
    Switchover". By introducing a new tunable parameter:
    
      Primary.Switchover.Max.Retrans (PSMR)
    
    The primary path will be changed to another active path when the path
    error counter on the old primary path exceeds PSMR, so that "the SCTP
    sender is allowed to continue data transmission on a new working path
    even when the old primary destination address becomes active again".
    
    This patch is to add this tunable parameter, 'ps_retrans' per netns,
    sock, asoc and transport. It also allows a user to change ps_retrans
    per netns by sysctl, and ps_retrans per sock/asoc/transport will be
    initialized with it.
    
    The check will be done in sctp_do_8_2_transport_strike() when this
    feature is enabled.
    
    Note this feature is disabled by initializing 'ps_retrans' per netns
    as 0xffff by default, and its value can't be less than 'pf_retrans'
    when changing by sysctl.
    
    v3->v4:
      - add define SCTP_PS_RETRANS_MAX 0xffff, and use it on extra2 of
        sysctl 'ps_retrans'.
      - add a new entry for ps_retrans on ip-sysctl.txt.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9a43738774d7..3cc913f328cd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -184,7 +184,8 @@ struct sctp_sock {
 	__u32 flowlabel;
 	__u8  dscp;
 
-	int pf_retrans;
+	__u16 pf_retrans;
+	__u16 ps_retrans;
 
 	/* The initial Path MTU to use for new associations. */
 	__u32 pathmtu;
@@ -897,7 +898,9 @@ struct sctp_transport {
 	 * and will be initialized from the assocs value.  This can be changed
 	 * using the SCTP_PEER_ADDR_THLDS socket option
 	 */
-	int pf_retrans;
+	__u16 pf_retrans;
+	/* Used for primary path switchover. */
+	__u16 ps_retrans;
 	/* PMTU	      : The current known path MTU.  */
 	__u32 pathmtu;
 
@@ -1773,7 +1776,9 @@ struct sctp_association {
 	 * and will be initialized from the assocs value.  This can be
 	 * changed using the SCTP_PEER_ADDR_THLDS socket option
 	 */
-	int pf_retrans;
+	__u16 pf_retrans;
+	/* Used for primary path switchover. */
+	__u16 ps_retrans;
 
 	/* Maximum number of times the endpoint will retransmit INIT  */
 	__u16 max_init_attempts;

commit aef587be42925f92418083f08852d0011b2766ca
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Nov 8 13:20:32 2019 +0800

    sctp: add pf_expose per netns and sock and asoc
    
    As said in rfc7829, section 3, point 12:
    
      The SCTP stack SHOULD expose the PF state of its destination
      addresses to the ULP as well as provide the means to notify the
      ULP of state transitions of its destination addresses from
      active to PF, and vice versa.  However, it is recommended that
      an SCTP stack implementing SCTP-PF also allows for the ULP to be
      kept ignorant of the PF state of its destinations and the
      associated state transitions, thus allowing for retention of the
      simpler state transition model of [RFC4960] in the ULP.
    
    Not only does it allow to expose the PF state to ULP, but also
    allow to ignore sctp-pf to ULP.
    
    So this patch is to add pf_expose per netns, sock and asoc. And in
    sctp_assoc_control_transport(), ulp_notify will be set to false if
    asoc->expose is not 'enabled' in next patch.
    
    It also allows a user to change pf_expose per netns by sysctl, and
    pf_expose per sock and asoc will be initialized with it.
    
    Note that pf_expose also works for SCTP_GET_PEER_ADDR_INFO sockopt,
    to not allow a user to query the state of a sctp-pf peer address
    when pf_expose is 'disabled', as said in section 7.3.
    
    v1->v2:
      - Fix a build warning noticed by Nathan Chancellor.
    v2->v3:
      - set pf_expose to UNUSED by default to keep compatible with old
        applications.
    v3->v4:
      - add a new entry for pf_expose on ip-sysctl.txt, as Marcelo suggested.
      - change this patch to 1/5, and move sctp_assoc_control_transport
        change into 2/5, as Marcelo suggested.
      - use SCTP_PF_EXPOSE_UNSET instead of SCTP_PF_EXPOSE_UNUSED, and
        set SCTP_PF_EXPOSE_UNSET to 0 in enum, as Marcelo suggested.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 503fbc3cd819..9a43738774d7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -215,6 +215,7 @@ struct sctp_sock {
 	__u32 adaptation_ind;
 	__u32 pd_point;
 	__u16	nodelay:1,
+		pf_expose:2,
 		reuse:1,
 		disable_fragments:1,
 		v4mapped:1,
@@ -2053,6 +2054,7 @@ struct sctp_association {
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1,		/* Is it a temporary association? */
+	     pf_expose:2,       /* Expose pf state? */
 	     force_delay:1;
 
 	__u8 strreset_enable;

commit 1b0b8114b9549dee6490e728cd787f808b586158
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Aug 26 16:30:02 2019 +0800

    sctp: make ecn flag per netns and endpoint
    
    This patch is to add ecn flag for both netns_sctp and sctp_endpoint,
    net->sctp.ecn_enable is set 1 by default, and ep->ecn_enable will
    be initialized with net->sctp.ecn_enable.
    
    asoc->peer.ecn_capable will be set during negotiation only when
    ep->ecn_enable is set on both sides.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index daac1eff18c9..503fbc3cd819 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1322,7 +1322,8 @@ struct sctp_endpoint {
 	/* SCTP-AUTH: endpoint shared keys */
 	struct list_head endpoint_shared_keys;
 	__u16 active_key_id;
-	__u8  auth_enable:1,
+	__u8  ecn_enable:1,
+	      auth_enable:1,
 	      intl_enable:1,
 	      prsctp_enable:1,
 	      asconf_enable:1,

commit 4e27428fb5626f966aa961b1aad8751f2ebeef72
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Aug 19 22:02:43 2019 +0800

    sctp: add asconf_enable in struct sctp_endpoint
    
    This patch is to make addip/asconf flag per endpoint,
    and its value is initialized by the per netns flag,
    net->sctp.addip_enable.
    
    It also replaces the checks of net->sctp.addip_enable
    with ep->asconf_enable in some places.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ba5c4f6eede5..daac1eff18c9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1325,6 +1325,7 @@ struct sctp_endpoint {
 	__u8  auth_enable:1,
 	      intl_enable:1,
 	      prsctp_enable:1,
+	      asconf_enable:1,
 	      reconf_enable:1;
 
 	__u8  strreset_enable;

commit e55f4b8bf4622103badac8694cdabceec06f9b38
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jul 9 00:57:07 2019 +0800

    sctp: rename sp strm_interleave to ep intl_enable
    
    Like other endpoint features, strm_interleave should be moved to
    sctp_endpoint and renamed to intl_enable.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c41b57ba04bb..ba5c4f6eede5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -219,7 +219,6 @@ struct sctp_sock {
 		disable_fragments:1,
 		v4mapped:1,
 		frag_interleave:1,
-		strm_interleave:1,
 		recvrcvinfo:1,
 		recvnxtinfo:1,
 		data_ready_signalled:1;
@@ -1324,6 +1323,7 @@ struct sctp_endpoint {
 	struct list_head endpoint_shared_keys;
 	__u16 active_key_id;
 	__u8  auth_enable:1,
+	      intl_enable:1,
 	      prsctp_enable:1,
 	      reconf_enable:1;
 

commit da1f6d4de7b743c86cb49015ea05b184fea1388c
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jul 9 00:57:06 2019 +0800

    sctp: rename asoc intl_enable to asoc peer.intl_capable
    
    To keep consistent with other asoc features, we move intl_enable
    to peer.intl_capable in asoc.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7f35b8ee9f65..c41b57ba04bb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1679,28 +1679,30 @@ struct sctp_association {
 		__be16 addip_disabled_mask;
 
 		/* These are capabilities which our peer advertised.  */
-		__u8	ecn_capable:1,      /* Can peer do ECN? */
+		__u16	ecn_capable:1,      /* Can peer do ECN? */
 			ipv4_address:1,     /* Peer understands IPv4 addresses? */
 			ipv6_address:1,     /* Peer understands IPv6 addresses? */
 			hostname_address:1, /* Peer understands DNS addresses? */
 			asconf_capable:1,   /* Does peer support ADDIP? */
 			prsctp_capable:1,   /* Can peer do PR-SCTP? */
 			reconf_capable:1,   /* Can peer do RE-CONFIG? */
-			auth_capable:1;     /* Is peer doing SCTP-AUTH? */
-
-		/* sack_needed : This flag indicates if the next received
-		 *             : packet is to be responded to with a
-		 *             : SACK. This is initialized to 0.  When a packet
-		 *             : is received sack_cnt is incremented. If this value
-		 *             : reaches 2 or more, a SACK is sent and the
-		 *             : value is reset to 0. Note: This is used only
-		 *             : when no DATA chunks are received out of
-		 *             : order.  When DATA chunks are out of order,
-		 *             : SACK's are not delayed (see Section 6).
-		 */
-		__u8    sack_needed:1,     /* Do we need to sack the peer? */
+			intl_capable:1,     /* Can peer do INTERLEAVE */
+			auth_capable:1,     /* Is peer doing SCTP-AUTH? */
+			/* sack_needed:
+			 *   This flag indicates if the next received
+			 *   packet is to be responded to with a
+			 *   SACK. This is initialized to 0.  When a packet
+			 *   is received sack_cnt is incremented. If this value
+			 *   reaches 2 or more, a SACK is sent and the
+			 *   value is reset to 0. Note: This is used only
+			 *   when no DATA chunks are received out of
+			 *   order.  When DATA chunks are out of order,
+			 *   SACK's are not delayed (see Section 6).
+			 */
+			sack_needed:1,     /* Do we need to sack the peer? */
 			sack_generation:1,
 			zero_window_announced:1;
+
 		__u32	sack_cnt;
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
@@ -2049,8 +2051,7 @@ struct sctp_association {
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1,		/* Is it a temporary association? */
-	     force_delay:1,
-	     intl_enable:1;
+	     force_delay:1;
 
 	__u8 strreset_enable;
 	__u8 strreset_outstanding; /* request param count on the fly */

commit 1c13475368b697d4fc9c0630b5d4ee51d5ca0790
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jul 9 00:57:05 2019 +0800

    sctp: remove prsctp_enable from asoc
    
    Like reconf_enable, prsctp_enable should also be removed from asoc,
    as asoc->peer.prsctp_capable has taken its job.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d9e0e1a53f99..7f35b8ee9f65 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2050,8 +2050,7 @@ struct sctp_association {
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1,		/* Is it a temporary association? */
 	     force_delay:1,
-	     intl_enable:1,
-	     prsctp_enable:1;
+	     intl_enable:1;
 
 	__u8 strreset_enable;
 	__u8 strreset_outstanding; /* request param count on the fly */

commit a96701fb3534c45bd6fe5e6f6d3a91e3acc19b59
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jul 9 00:57:04 2019 +0800

    sctp: remove reconf_enable from asoc
    
    asoc's reconf support is actually decided by the 4-shakehand negotiation,
    not something that users can set by sockopt. asoc->peer.reconf_capable is
    working for this. So remove it from asoc.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0767701ef362..d9e0e1a53f99 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2051,8 +2051,7 @@ struct sctp_association {
 	     temp:1,		/* Is it a temporary association? */
 	     force_delay:1,
 	     intl_enable:1,
-	     prsctp_enable:1,
-	     reconf_enable:1;
+	     prsctp_enable:1;
 
 	__u8 strreset_enable;
 	__u8 strreset_outstanding; /* request param count on the fly */

commit 47505b8bcfcffffe878ea1fee412922f3bfd7262
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:41 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 104
    
    Based on 1 normalized pattern(s):
    
      this sctp implementation is free software you can redistribute it
      and or modify it under the terms of the gnu general public license
      as published by the free software foundation either version 2 or at
      your option any later version this sctp implementation is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with gnu cc see the file copying if not see
      http www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 42 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.683323110@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 140fd836a396..0767701ef362 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* SCTP kernel implementation
  * (C) Copyright IBM Corp. 2001, 2004
  * Copyright (c) 1999-2000 Cisco, Inc.
@@ -6,22 +7,6 @@
  *
  * This file is part of the SCTP kernel implementation
  *
- * This SCTP implementation is free software;
- * you can redistribute it and/or modify it under the terms of
- * the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This SCTP implementation is distributed in the hope that it
- * will be useful, but WITHOUT ANY WARRANTY; without even the implied
- *		   ************************
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with GNU CC; see the file COPYING.  If not, see
- * <http://www.gnu.org/licenses/>.
- *
  * Please send any bug reports or fixes you make to the
  * email addresses:
  *    lksctp developers <linux-sctp@vger.kernel.org>

commit 2075e50caf5ea28be3cba0d01b3058bb5c3b0168
Author: Kent Overstreet <kent.overstreet@gmail.com>
Date:   Mon Mar 11 23:31:22 2019 -0700

    sctp: convert to genradix
    
    This also makes sctp_stream_alloc_(out|in) saner, in that they no longer
    allocate new flex_arrays/genradixes, they just preallocate more
    elements.
    
    This code does however have a suspicious lack of locking.
    
    Link: http://lkml.kernel.org/r/20181217131929.11727-7-kent.overstreet@gmail.com
    Signed-off-by: Kent Overstreet <kent.overstreet@gmail.com>
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Eric Paris <eparis@parisplace.org>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Pravin B Shelar <pshelar@ovn.org>
    Cc: Shaohua Li <shli@kernel.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 58e4b23cecf4..140fd836a396 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -48,6 +48,7 @@
 #define __sctp_structs_h__
 
 #include <linux/ktime.h>
+#include <linux/generic-radix-tree.h>
 #include <linux/rhashtable-types.h>
 #include <linux/socket.h>	/* linux/in.h needs this!!    */
 #include <linux/in.h>		/* We get struct sockaddr_in. */
@@ -57,7 +58,6 @@
 #include <linux/atomic.h>		/* This gets us atomic counters.  */
 #include <linux/skbuff.h>	/* We need sk_buff_head. */
 #include <linux/workqueue.h>	/* We need tq_struct.	 */
-#include <linux/flex_array.h>	/* We need flex_array.   */
 #include <linux/sctp.h>		/* We need sctp* header structs.  */
 #include <net/sctp/auth.h>	/* We need auth specific structs */
 #include <net/ip.h>		/* For inet_skb_parm */
@@ -1449,8 +1449,9 @@ struct sctp_stream_in {
 };
 
 struct sctp_stream {
-	struct flex_array *out;
-	struct flex_array *in;
+	GENRADIX(struct sctp_stream_out) out;
+	GENRADIX(struct sctp_stream_in)	in;
+
 	__u16 outcnt;
 	__u16 incnt;
 	/* Current stream being sent, if any */
@@ -1473,17 +1474,17 @@ struct sctp_stream {
 };
 
 static inline struct sctp_stream_out *sctp_stream_out(
-	const struct sctp_stream *stream,
+	struct sctp_stream *stream,
 	__u16 sid)
 {
-	return flex_array_get(stream->out, sid);
+	return genradix_ptr(&stream->out, sid);
 }
 
 static inline struct sctp_stream_in *sctp_stream_in(
-	const struct sctp_stream *stream,
+	struct sctp_stream *stream,
 	__u16 sid)
 {
-	return flex_array_get(stream->in, sid);
+	return genradix_ptr(&stream->in, sid);
 }
 
 #define SCTP_SO(s, i) sctp_stream_out((s), (i))

commit 7efba10d6bd22030fb5931e50bf97496f932f00e
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jan 28 15:08:46 2019 +0800

    sctp: add SCTP_FUTURE_ASOC and SCTP_CURRENT_ASSOC for SCTP_STREAM_SCHEDULER sockopt
    
    Check with SCTP_ALL_ASSOC instead in sctp_setsockopt_scheduler and
    check with SCTP_FUTURE_ASSOC instead in sctp_getsockopt_scheduler,
    it's compatible with 0.
    
    SCTP_CURRENT_ASSOC is supported for SCTP_STREAM_SCHEDULER in this
    patch. It also adds default_ss in sctp_sock to support
    SCTP_FUTURE_ASSOC.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a5a46b1c9261..58e4b23cecf4 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -211,6 +211,8 @@ struct sctp_sock {
 	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
+	__u32 default_ss;
+
 	struct sctp_rtoinfo rtoinfo;
 	struct sctp_paddrparams paddrparam;
 	struct sctp_assocparams assocparams;

commit 8add543e369d67ccd42f7e67d68866b4d606f632
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jan 28 15:08:29 2019 +0800

    sctp: add SCTP_FUTURE_ASSOC for SCTP_PEER_ADDR_THLDS sockopt
    
    Check with SCTP_FUTURE_ASSOC instead in
    sctp_set/getsockopt_paddr_thresholds, it's compatible with 0.
    
    It also adds pf_retrans in sctp_sock to support SCTP_FUTURE_ASSOC.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 003020eb6e66..a5a46b1c9261 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -199,6 +199,8 @@ struct sctp_sock {
 	__u32 flowlabel;
 	__u8  dscp;
 
+	int pf_retrans;
+
 	/* The initial Path MTU to use for new associations. */
 	__u32 pathmtu;
 

commit 4cc1feeb6ffc2799f8badb4dea77c637d340cb0d
Merge: a60956ed72f7 40e020c129cf
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Dec 9 21:27:48 2018 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Several conflicts, seemingly all over the place.
    
    I used Stephen Rothwell's sample resolutions for many of these, if not
    just to double check my own work, so definitely the credit largely
    goes to him.
    
    The NFP conflict consisted of a bug fix (moving operations
    past the rhashtable operation) while chaning the initial
    argument in the function call in the moved code.
    
    The net/dsa/master.c conflict had to do with a bug fix intermixing of
    making dsa_master_set_mtu() static with the fixing of the tagging
    attribute location.
    
    cls_flower had a conflict because the dup reject fix from Or
    overlapped with the addition of port range classifiction.
    
    __set_phy_supported()'s conflict was relatively easy to resolve
    because Andrew fixed it in both trees, so it was just a matter
    of taking the net-next copy.  Or at least I think it was :-)
    
    Joe Stringer's fix to the handling of netns id 0 in bpf_sk_lookup()
    intermixed with changes on how the sdif and caller_net are calculated
    in these code paths in net-next.
    
    The remaining BPF conflicts were largely about the addition of the
    __bpf_md_ptr stuff in 'net' overlapping with adjustments and additions
    to the relevant data structure where the MD pointer macros are used.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit fb6df5a6234c38a9c551559506a49a677ac6f07a
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Dec 1 01:36:59 2018 +0800

    sctp: kfree_rcu asoc
    
    In sctp_hash_transport/sctp_epaddr_lookup_transport, it dereferences
    a transport's asoc under rcu_read_lock while asoc is freed not after
    a grace period, which leads to a use-after-free panic.
    
    This patch fixes it by calling kfree_rcu to make asoc be freed after
    a grace period.
    
    Note that only the asoc's memory is delayed to free in the patch, it
    won't cause sk to linger longer.
    
    Thanks Neil and Marcelo to make this clear.
    
    Fixes: 7fda702f9315 ("sctp: use new rhlist interface on sctp transport rhashtable")
    Fixes: cd2b70875058 ("sctp: check duplicate node before inserting a new transport")
    Reported-by: syzbot+0b05d8aa7cb185107483@syzkaller.appspotmail.com
    Reported-by: syzbot+aad231d51b1923158444@syzkaller.appspotmail.com
    Suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a11f93790476..feada358d872 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2075,6 +2075,8 @@ struct sctp_association {
 
 	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
 	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
+
+	struct rcu_head rcu;
 };
 
 

commit a1e3a0590f9bd232f3a03fd87226a4a99bd5ec92
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sun Nov 18 16:08:52 2018 +0800

    sctp: add subscribe per asoc
    
    The member subscribe should be per asoc, so that sockopt SCTP_EVENT
    in the next patch can subscribe a event from one asoc only.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index bc7808aa2760..7eaa294d938d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2077,6 +2077,8 @@ struct sctp_association {
 
 	int sent_cnt_removable;
 
+	__u16 subscribe;
+
 	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
 	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
 };

commit 2cc0eeb67636e0339ad7b6cdfa305f63983642af
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sun Nov 18 16:08:51 2018 +0800

    sctp: define subscribe in sctp_sock as __u16
    
    The member subscribe in sctp_sock is used to indicate to which of
    the events it is subscribed, more like a group of flags. So it's
    better to be defined as __u16 (2 bytpes), instead of struct
    sctp_event_subscribe (13 bytes).
    
    Note that sctp_event_subscribe is an UAPI struct, used on sockopt
    calls, and thus it will not be removed. This patch only changes
    the internal storage of the flags.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index af9d494120ba..bc7808aa2760 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -217,7 +217,7 @@ struct sctp_sock {
 	 * These two structures must be grouped together for the usercopy
 	 * whitelist region.
 	 */
-	struct sctp_event_subscribe subscribe;
+	__u16 subscribe;
 	struct sctp_initmsg initmsg;
 
 	int user_frag;

commit 6ba84574026792ce33a40c7da721dea36d0f3973
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Nov 12 18:27:17 2018 +0800

    sctp: process sk_reuseport in sctp_get_port_local
    
    When socks' sk_reuseport is set, the same port and address are allowed
    to be bound into these socks who have the same uid.
    
    Note that the difference from sk_reuse is that it allows multiple socks
    to listen on the same port and address.
    
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 15d017f33a46..af9d494120ba 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -96,7 +96,9 @@ struct sctp_stream;
 
 struct sctp_bind_bucket {
 	unsigned short	port;
-	unsigned short	fastreuse;
+	signed char	fastreuse;
+	signed char	fastreuseport;
+	kuid_t		fastuid;
 	struct hlist_node	node;
 	struct hlist_head	owner;
 	struct net	*net;

commit 76c6d988aeb3c15d57ea0c245a3b5f27802c1fbe
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Nov 12 18:27:16 2018 +0800

    sctp: add sock_reuseport for the sock in __sctp_hash_endpoint
    
    This is a part of sk_reuseport support for sctp. It defines a helper
    sctp_bind_addrs_check() to check if the bind_addrs in two socks are
    matched. It will add sock_reuseport if they are completely matched,
    and return err if they are partly matched, and alloc sock_reuseport
    if all socks are not matched at all.
    
    It will work until sk_reuseport support is added in
    sctp_get_port_local() in the next patch.
    
    v1->v2:
      - use 'laddr->valid && laddr2->valid' check instead as Marcelo
        pointed in sctp_bind_addrs_check().
    
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a11f93790476..15d017f33a46 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1190,6 +1190,8 @@ int sctp_bind_addr_conflict(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *, struct sctp_sock *);
 int sctp_bind_addr_state(const struct sctp_bind_addr *bp,
 			 const union sctp_addr *addr);
+int sctp_bind_addrs_check(struct sctp_sock *sp,
+			  struct sctp_sock *sp2, int cnt2);
 union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,
 					const union sctp_addr	*addrs,
 					int			addrcnt,

commit d805397c3822d57ca3884d4bea37b2291fc40992
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Oct 15 19:58:29 2018 +0800

    sctp: use the pmtu from the icmp packet to update transport pathmtu
    
    Other than asoc pmtu sync from all transports, sctp_assoc_sync_pmtu
    is also processing transport pmtu_pending by icmp packets. But it's
    meaningless to use sctp_dst_mtu(t->dst) as new pmtu for a transport.
    
    The right pmtu value should come from the icmp packet, and it would
    be saved into transport->mtu_info in this patch and used later when
    the pmtu sync happens in sctp_sendmsg_to_asoc or sctp_packet_config.
    
    Besides, without this patch, as pmtu can only be updated correctly
    when receiving a icmp packet and no place is holding sock lock, it
    will take long time if the sock is busy with sending packets.
    
    Note that it doesn't process transport->mtu_info in .release_cb(),
    as there is no enough information for pmtu update, like for which
    asoc or transport. It is not worth traversing all asocs to check
    pmtu_pending. So unlike tcp, sctp does this in tx path, for which
    mtu_info needs to be atomic_t.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 28a7c8e44636..a11f93790476 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -876,6 +876,8 @@ struct sctp_transport {
 	unsigned long sackdelay;
 	__u32 sackfreq;
 
+	atomic_t mtu_info;
+
 	/* When was the last time that we heard from this transport? We use
 	 * this to pick new active and retran paths.
 	 */

commit 0d493b4d0be352b5e361e4fa0bc3efe952d8b10e
Author: Konstantin Khorenko <khorenko@virtuozzo.com>
Date:   Fri Aug 10 20:11:43 2018 +0300

    net/sctp: Replace in/out stream arrays with flex_array
    
    This path replaces physically contiguous memory arrays
    allocated using kmalloc_array() with flexible arrays.
    This enables to avoid memory allocation failures on the
    systems under a memory stress.
    
    Signed-off-by: Oleg Babin <obabin@virtuozzo.com>
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6b2b8df8a1d2..28a7c8e44636 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -57,6 +57,7 @@
 #include <linux/atomic.h>		/* This gets us atomic counters.  */
 #include <linux/skbuff.h>	/* We need sk_buff_head. */
 #include <linux/workqueue.h>	/* We need tq_struct.	 */
+#include <linux/flex_array.h>	/* We need flex_array.   */
 #include <linux/sctp.h>		/* We need sctp* header structs.  */
 #include <net/sctp/auth.h>	/* We need auth specific structs */
 #include <net/ip.h>		/* For inet_skb_parm */
@@ -1438,8 +1439,8 @@ struct sctp_stream_in {
 };
 
 struct sctp_stream {
-	struct sctp_stream_out *out;
-	struct sctp_stream_in *in;
+	struct flex_array *out;
+	struct flex_array *in;
 	__u16 outcnt;
 	__u16 incnt;
 	/* Current stream being sent, if any */
@@ -1465,14 +1466,14 @@ static inline struct sctp_stream_out *sctp_stream_out(
 	const struct sctp_stream *stream,
 	__u16 sid)
 {
-	return ((struct sctp_stream_out *)(stream->out)) + sid;
+	return flex_array_get(stream->out, sid);
 }
 
 static inline struct sctp_stream_in *sctp_stream_in(
 	const struct sctp_stream *stream,
 	__u16 sid)
 {
-	return ((struct sctp_stream_in *)(stream->in)) + sid;
+	return flex_array_get(stream->in, sid);
 }
 
 #define SCTP_SO(s, i) sctp_stream_out((s), (i))

commit 05364ca03cfd419caecb292fede20eb39667eaae
Author: Konstantin Khorenko <khorenko@virtuozzo.com>
Date:   Fri Aug 10 20:11:42 2018 +0300

    net/sctp: Make wrappers for accessing in/out streams
    
    This patch introduces wrappers for accessing in/out streams indirectly.
    This will enable to replace physically contiguous memory arrays
    of streams with flexible arrays (or maybe any other appropriate
    mechanism) which do memory allocation on a per-page basis.
    
    Signed-off-by: Oleg Babin <obabin@virtuozzo.com>
    Signed-off-by: Konstantin Khorenko <khorenko@virtuozzo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ab869e0d8326..6b2b8df8a1d2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -398,37 +398,35 @@ void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);
 
 /* What is the current SSN number for this stream? */
 #define sctp_ssn_peek(stream, type, sid) \
-	((stream)->type[sid].ssn)
+	(sctp_stream_##type((stream), (sid))->ssn)
 
 /* Return the next SSN number for this stream.	*/
 #define sctp_ssn_next(stream, type, sid) \
-	((stream)->type[sid].ssn++)
+	(sctp_stream_##type((stream), (sid))->ssn++)
 
 /* Skip over this ssn and all below. */
 #define sctp_ssn_skip(stream, type, sid, ssn) \
-	((stream)->type[sid].ssn = ssn + 1)
+	(sctp_stream_##type((stream), (sid))->ssn = ssn + 1)
 
 /* What is the current MID number for this stream? */
 #define sctp_mid_peek(stream, type, sid) \
-	((stream)->type[sid].mid)
+	(sctp_stream_##type((stream), (sid))->mid)
 
 /* Return the next MID number for this stream.  */
 #define sctp_mid_next(stream, type, sid) \
-	((stream)->type[sid].mid++)
+	(sctp_stream_##type((stream), (sid))->mid++)
 
 /* Skip over this mid and all below. */
 #define sctp_mid_skip(stream, type, sid, mid) \
-	((stream)->type[sid].mid = mid + 1)
-
-#define sctp_stream_in(asoc, sid) (&(asoc)->stream.in[sid])
+	(sctp_stream_##type((stream), (sid))->mid = mid + 1)
 
 /* What is the current MID_uo number for this stream? */
 #define sctp_mid_uo_peek(stream, type, sid) \
-	((stream)->type[sid].mid_uo)
+	(sctp_stream_##type((stream), (sid))->mid_uo)
 
 /* Return the next MID_uo number for this stream.  */
 #define sctp_mid_uo_next(stream, type, sid) \
-	((stream)->type[sid].mid_uo++)
+	(sctp_stream_##type((stream), (sid))->mid_uo++)
 
 /*
  * Pointers to address related SCTP functions.
@@ -1463,6 +1461,23 @@ struct sctp_stream {
 	struct sctp_stream_interleave *si;
 };
 
+static inline struct sctp_stream_out *sctp_stream_out(
+	const struct sctp_stream *stream,
+	__u16 sid)
+{
+	return ((struct sctp_stream_out *)(stream->out)) + sid;
+}
+
+static inline struct sctp_stream_in *sctp_stream_in(
+	const struct sctp_stream *stream,
+	__u16 sid)
+{
+	return ((struct sctp_stream_in *)(stream->in)) + sid;
+}
+
+#define SCTP_SO(s, i) sctp_stream_out((s), (i))
+#define SCTP_SI(s, i) sctp_stream_in((s), (i))
+
 #define SCTP_STREAM_CLOSED		0x00
 #define SCTP_STREAM_OPEN		0x01
 

commit 8a9c58d28d0f66569737a3295116710ed24573cd
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 2 18:21:12 2018 +0800

    sctp: add support for dscp and flowlabel per transport
    
    Like some other per transport params, flowlabel and dscp are added
    in transport, asoc and sctp_sock. By default, transport sets its
    value from asoc's, and asoc does it from sctp_sock. flowlabel
    only works for ipv6 transport.
    
    Other than that they need to be passed down in sctp_xmit, flow4/6
    also needs to set them before looking up route in get_dst.
    
    Note that it uses '& 0x100000' to check if flowlabel is set and
    '& 0x1' (tos 1st bit is unused) to check if dscp is set by users,
    so that they could be set to 0 by sockopt in next patch.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 701a51736fa5..ab869e0d8326 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -193,6 +193,9 @@ struct sctp_sock {
 	/* This is the max_retrans value for new associations. */
 	__u16 pathmaxrxt;
 
+	__u32 flowlabel;
+	__u8  dscp;
+
 	/* The initial Path MTU to use for new associations. */
 	__u32 pathmtu;
 
@@ -895,6 +898,9 @@ struct sctp_transport {
 	 */
 	__u16 pathmaxrxt;
 
+	__u32 flowlabel;
+	__u8  dscp;
+
 	/* This is the partially failed retrans value for the transport
 	 * and will be initialized from the assocs value.  This can be changed
 	 * using the SCTP_PEER_ADDR_THLDS socket option
@@ -1772,6 +1778,9 @@ struct sctp_association {
 	 */
 	__u16 pathmaxrxt;
 
+	__u32 flowlabel;
+	__u8  dscp;
+
 	/* Flag that path mtu update is pending */
 	__u8   pmtu_pending;
 

commit b0e9a2fe3ff971950833bc0ffc383babd9443bc4
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Jun 28 15:31:00 2018 +0800

    sctp: add support for SCTP_REUSE_PORT sockopt
    
    This feature is actually already supported by sk->sk_reuse which can be
    set by socket level opt SO_REUSEADDR. But it's not working exactly as
    RFC6458 demands in section 8.1.27, like:
    
      - This option only supports one-to-one style SCTP sockets
      - This socket option must not be used after calling bind()
        or sctp_bindx().
    
    Besides, SCTP_REUSE_PORT sockopt should be provided for user's programs.
    Otherwise, the programs with SCTP_REUSE_PORT from other systems will not
    work in linux.
    
    To separate it from the socket level version, this patch adds 'reuse' in
    sctp_sock and it works pretty much as sk->sk_reuse, but with some extra
    setup limitations that are needed when it is being enabled.
    
    "It should be noted that the behavior of the socket-level socket option
    to reuse ports and/or addresses for SCTP sockets is unspecified", so it
    leaves SO_REUSEADDR as is for the compatibility.
    
    Note that the name SCTP_REUSE_PORT is somewhat confusing, as its
    functionality is nearly identical to SO_REUSEADDR, but with some
    extra restrictions. Here it uses 'reuse' in sctp_sock instead of
    'reuseport'. As for sk->sk_reuseport support for SCTP, it will be
    added in another patch.
    
    Thanks to Neil to make this clear.
    
    v1->v2:
      - add sctp_sk->reuse to separate it from the socket level version.
    v2->v3:
      - improve changelog according to Marcelo's suggestion.
    
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e0f962d27386..701a51736fa5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -220,6 +220,7 @@ struct sctp_sock {
 	__u32 adaptation_ind;
 	__u32 pd_point;
 	__u16	nodelay:1,
+		reuse:1,
 		disable_fragments:1,
 		v4mapped:1,
 		frag_interleave:1,

commit 0eb71a9da5796851fa87ddc1a534066c0fe54055
Author: NeilBrown <neilb@suse.com>
Date:   Mon Jun 18 12:52:50 2018 +1000

    rhashtable: split rhashtable.h
    
    Due to the use of rhashtables in net namespaces,
    rhashtable.h is included in lots of the kernel,
    so a small changes can required a large recompilation.
    This makes development painful.
    
    This patch splits out rhashtable-types.h which just includes
    the major type declarations, and does not include (non-trivial)
    inline code.  rhashtable.h is no longer included by anything
    in the include/ directory.
    Common include files only include rhashtable-types.h so a large
    recompilation is only triggered when that changes.
    
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index dbe1b911a24d..e0f962d27386 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -48,7 +48,7 @@
 #define __sctp_structs_h__
 
 #include <linux/ktime.h>
-#include <linux/rhashtable.h>
+#include <linux/rhashtable-types.h>
 #include <linux/socket.h>	/* linux/in.h needs this!!    */
 #include <linux/in.h>		/* We get struct sockaddr_in. */
 #include <linux/in6.h>		/* We get struct in6_addr     */

commit 995191220056300c51ed870a5d5321f91f3eef89
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Jun 14 07:37:02 2018 +0800

    sctp: define sctp_packet_gso_append to build GSO frames
    
    Now sctp GSO uses skb_gro_receive() to append the data into head
    skb frag_list. However it actually only needs very few code from
    skb_gro_receive(). Besides, NAPI_GRO_CB has to be set while most
    of its members are not needed here.
    
    This patch is to add sctp_packet_gso_append() to build GSO frames
    instead of skb_gro_receive(), and it would avoid many unnecessary
    checks and make the code clearer.
    
    Note that sctp will use page frags instead of frag_list to build
    GSO frames in another patch. But it may take time, as sctp's GSO
    frames may have different size. skb_segment() can only split it
    into the frags with the same size, which would break the border
    of sctp chunks.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ebf809eed33a..dbe1b911a24d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1133,6 +1133,11 @@ struct sctp_input_cb {
 };
 #define SCTP_INPUT_CB(__skb)	((struct sctp_input_cb *)&((__skb)->cb[0]))
 
+struct sctp_output_cb {
+	struct sk_buff *last;
+};
+#define SCTP_OUTPUT_CB(__skb)	((struct sctp_output_cb *)&((__skb)->cb[0]))
+
 static inline const struct sk_buff *sctp_gso_headskb(const struct sk_buff *skb)
 {
 	const struct sctp_chunk *chunk = SCTP_INPUT_CB(skb)->chunk;

commit 2f5e3c9df6938b823664869ec87af3da8df272f6
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Thu Apr 26 16:58:55 2018 -0300

    sctp: introduce sctp_assoc_update_frag_point
    
    and avoid the open-coded versions of it.
    
    Now sctp_datamsg_from_user can just re-use asoc->frag_point as it will
    always be updated.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c5e244be8f1e..ebf809eed33a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2097,6 +2097,7 @@ int sctp_assoc_update(struct sctp_association *old,
 
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
+void sctp_assoc_update_frag_point(struct sctp_association *asoc);
 void sctp_assoc_set_pmtu(struct sctp_association *asoc, __u32 pmtu);
 void sctp_assoc_sync_pmtu(struct sctp_association *asoc);
 void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);

commit c4b2893dae6427ce1e528033383c94cbf81e80d8
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Thu Apr 26 16:58:53 2018 -0300

    sctp: introduce sctp_assoc_set_pmtu
    
    All changes to asoc PMTU should now go through this wrapper, making it
    easier to track them and to do other actions upon it.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 05594b248e52..c5e244be8f1e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2097,6 +2097,7 @@ int sctp_assoc_update(struct sctp_association *old,
 
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
+void sctp_assoc_set_pmtu(struct sctp_association *asoc, __u32 pmtu);
 void sctp_assoc_sync_pmtu(struct sctp_association *asoc);
 void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);
 void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);

commit 22e15b6f9c010ffded63e6c9720a656eb3d73835
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Apr 25 17:46:47 2018 +0800

    sctp: remove the unused sctp_assoc_is_match function
    
    After Commit 4f0087812648 ("sctp: apply rhashtable api to send/recv
    path"), there's no place using sctp_assoc_is_match, so remove it.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a0ec462bc1a9..05594b248e52 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2091,10 +2091,6 @@ void sctp_assoc_control_transport(struct sctp_association *asoc,
 				  enum sctp_transport_cmd command,
 				  sctp_sn_error_t error);
 struct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *, __u32);
-struct sctp_transport *sctp_assoc_is_match(struct sctp_association *,
-					   struct net *,
-					   const union sctp_addr *,
-					   const union sctp_addr *);
 void sctp_assoc_migrate(struct sctp_association *, struct sock *);
 int sctp_assoc_update(struct sctp_association *old,
 		      struct sctp_association *new);

commit 9eda2d2dca830f0f8923b1f377d0fb70f576af1d
Merge: 6ad11bdd57ad 6b6bc6205d98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 15:39:26 2018 -0700

    Merge tag 'selinux-pr-20180403' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux
    
    Pull SELinux updates from Paul Moore:
     "A bigger than usual pull request for SELinux, 13 patches (lucky!)
      along with a scary looking diffstat.
    
      Although if you look a bit closer, excluding the usual minor
      tweaks/fixes, there are really only two significant changes in this
      pull request: the addition of proper SELinux access controls for SCTP
      and the encapsulation of a lot of internal SELinux state.
    
      The SCTP changes are the result of a multi-month effort (maybe even a
      year or longer?) between the SELinux folks and the SCTP folks to add
      proper SELinux controls. A special thanks go to Richard for seeing
      this through and keeping the effort moving forward.
    
      The state encapsulation work is a bit of janitorial work that came out
      of some early work on SELinux namespacing. The question of namespacing
      is still an open one, but I believe there is some real value in the
      encapsulation work so we've split that out and are now sending that up
      to you"
    
    * tag 'selinux-pr-20180403' of git://git.kernel.org/pub/scm/linux/kernel/git/pcmoore/selinux:
      selinux: wrap AVC state
      selinux: wrap selinuxfs state
      selinux: fix handling of uninitialized selinux state in get_bools/classes
      selinux: Update SELinux SCTP documentation
      selinux: Fix ltp test connect-syscall failure
      selinux: rename the {is,set}_enforcing() functions
      selinux: wrap global selinux state
      selinux: fix typo in selinux_netlbl_sctp_sk_clone declaration
      selinux: Add SCTP support
      sctp: Add LSM hooks
      sctp: Add ip option support
      security: Add support for SCTP security hooks
      netlabel: If PF_INET6, check sk_buff ip header version

commit 5306653850b444452937834adc5a5ac63bae275e
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Mar 26 16:55:00 2018 +0800

    sctp: remove unnecessary asoc in sctp_has_association
    
    After Commit dae399d7fdee ("sctp: hold transport instead of assoc
    when lookup assoc in rx path"), it put transport instead of asoc
    in sctp_has_association. Variable 'asoc' is not used any more.
    
    So this patch is to remove it, while at it,  it also changes the
    return type of sctp_has_association to bool, and does the same
    for it's caller sctp_endpoint_is_peeled_off.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 012fb3e2f4cf..c63249ea34c3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1341,12 +1341,12 @@ struct sctp_association *sctp_endpoint_lookup_assoc(
 	const struct sctp_endpoint *ep,
 	const union sctp_addr *paddr,
 	struct sctp_transport **);
-int sctp_endpoint_is_peeled_off(struct sctp_endpoint *,
-				const union sctp_addr *);
+bool sctp_endpoint_is_peeled_off(struct sctp_endpoint *ep,
+				 const union sctp_addr *paddr);
 struct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *,
 					struct net *, const union sctp_addr *);
-int sctp_has_association(struct net *net, const union sctp_addr *laddr,
-			 const union sctp_addr *paddr);
+bool sctp_has_association(struct net *net, const union sctp_addr *laddr,
+			  const union sctp_addr *paddr);
 
 int sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,
 		     const struct sctp_association *asoc,

commit 3ff547c06a7d75d72d37dae2c064fcf0672e56c0
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Mar 14 19:05:31 2018 +0800

    sctp: add support for SCTP AUTH Information for sendmsg
    
    This patch is to add support for SCTP AUTH Information for sendmsg,
    as described in section 5.3.8 of RFC6458.
    
    With this option, you can provide shared key identifier used for
    sending the user message.
    
    It's also a necessary send info for sctp_sendv.
    
    Note that it reuses sinfo->sinfo_tsn to indicate if this option is
    set and sinfo->sinfo_ssn to save the shkey ID which can be 0.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 49ad67bbdbb5..012fb3e2f4cf 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2118,6 +2118,7 @@ struct sctp_cmsgs {
 	struct sctp_sndrcvinfo *srinfo;
 	struct sctp_sndinfo *sinfo;
 	struct sctp_prinfo *prinfo;
+	struct sctp_authinfo *authinfo;
 	struct msghdr *addrs_msg;
 };
 

commit 1b1e0bc9947427ae58bbe7de0ce9cfd591b589b9
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Mar 14 19:05:30 2018 +0800

    sctp: add refcnt support for sh_key
    
    With refcnt support for sh_key, chunks auth sh_keys can be decided
    before enqueuing it. Changing the active key later will not affect
    the chunks already enqueued.
    
    Furthermore, this is necessary when adding the support for authinfo
    for sendmsg in next patch.
    
    Note that struct sctp_chunk can't be grown due to that performance
    drop issue on slow cpu, so it just reuses head_skb memory for shkey
    in sctp_chunk.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ec6e46b7e119..49ad67bbdbb5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -577,8 +577,12 @@ struct sctp_chunk {
 	/* This points to the sk_buff containing the actual data.  */
 	struct sk_buff *skb;
 
-	/* In case of GSO packets, this will store the head one */
-	struct sk_buff *head_skb;
+	union {
+		/* In case of GSO packets, this will store the head one */
+		struct sk_buff *head_skb;
+		/* In case of auth enabled, this will point to the shkey */
+		struct sctp_shared_key *shkey;
+	};
 
 	/* These are the SCTP headers by reverse order in a packet.
 	 * Note that some of these may happen more than once.  In that
@@ -1995,6 +1999,7 @@ struct sctp_association {
 	 * The current generated assocaition shared key (secret)
 	 */
 	struct sctp_auth_bytes *asoc_shared_key;
+	struct sctp_shared_key *shkey;
 
 	/* SCTP AUTH: hmac id of the first peer requested algorithm
 	 * that we support.

commit 2c0dbaa0c43d04d8d6daf52adb724c5789676b15
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Mar 5 20:44:19 2018 +0800

    sctp: add support for SCTP_DSTADDRV4/6 Information for sendmsg
    
    This patch is to add support for Destination IPv4/6 Address options
    for sendmsg, as described in section 5.3.9/10 of RFC6458.
    
    With this option, you can provide more than one destination addrs
    to sendmsg when creating asoc, like sctp_connectx.
    
    It's also a necessary send info for sctp_sendv.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d40a2a329888..ec6e46b7e119 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2113,6 +2113,7 @@ struct sctp_cmsgs {
 	struct sctp_sndrcvinfo *srinfo;
 	struct sctp_sndinfo *sinfo;
 	struct sctp_prinfo *prinfo;
+	struct msghdr *addrs_msg;
 };
 
 /* Structure for tracking memory objects */

commit ed63afb8a318f6b3558d76afba7809daee4f28e5
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Mar 5 20:44:18 2018 +0800

    sctp: add support for PR-SCTP Information for sendmsg
    
    This patch is to add support for PR-SCTP Information for sendmsg,
    as described in section 5.3.7 of RFC6458.
    
    With this option, you can specify pr_policy and pr_value for user
    data in sendmsg.
    
    It's also a necessary send info for sctp_sendv.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 03e92dda1813..d40a2a329888 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -2112,6 +2112,7 @@ struct sctp_cmsgs {
 	struct sctp_initmsg *init;
 	struct sctp_sndrcvinfo *srinfo;
 	struct sctp_sndinfo *sinfo;
+	struct sctp_prinfo *prinfo;
 };
 
 /* Structure for tracking memory objects */

commit 2277c7cd75e39783eeb7512a6c35f8b4abbe1039
Author: Richard Haines <richard_c_haines@btinternet.com>
Date:   Tue Feb 13 20:56:24 2018 +0000

    sctp: Add LSM hooks
    
    Add security hooks allowing security modules to exercise access control
    over SCTP.
    
    Signed-off-by: Richard Haines <richard_c_haines@btinternet.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ead5fcedc283..7a23896cddc4 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1318,6 +1318,16 @@ struct sctp_endpoint {
 	      reconf_enable:1;
 
 	__u8  strreset_enable;
+
+	/* Security identifiers from incoming (INIT). These are set by
+	 * security_sctp_assoc_request(). These will only be used by
+	 * SCTP TCP type sockets and peeled off connections as they
+	 * cause a new socket to be generated. security_sctp_sk_clone()
+	 * will then plug these into the new socket.
+	 */
+
+	u32 secid;
+	u32 peer_secid;
 };
 
 /* Recover the outter endpoint structure. */

commit b7e10c25b839c0c7579b2b402afc9883c107e09f
Author: Richard Haines <richard_c_haines@btinternet.com>
Date:   Sat Feb 24 16:18:51 2018 +0000

    sctp: Add ip option support
    
    Add ip option support to allow LSM security modules to utilise CIPSO/IPv4
    and CALIPSO/IPv6 services.
    
    Signed-off-by: Richard Haines <richard_c_haines@btinternet.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: Paul Moore <paul@paul-moore.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 03e92dda1813..ead5fcedc283 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -491,6 +491,7 @@ struct sctp_af {
 	void		(*ecn_capable)(struct sock *sk);
 	__u16		net_header_len;
 	int		sockaddr_len;
+	int		(*ip_options_len)(struct sock *sk);
 	sa_family_t	sa_family;
 	struct list_head list;
 };
@@ -515,6 +516,7 @@ struct sctp_pf {
 	int (*addr_to_user)(struct sctp_sock *sk, union sctp_addr *addr);
 	void (*to_sk_saddr)(union sctp_addr *, struct sock *sk);
 	void (*to_sk_daddr)(union sctp_addr *, struct sock *sk);
+	void (*copy_ip_options)(struct sock *sk, struct sock *newsk);
 	struct sctp_af *af;
 };
 

commit 617aebe6a97efa539cc4b8a52adccd89596e6be0
Merge: 0771ad44a20b e47e311843de
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 3 16:25:42 2018 -0800

    Merge tag 'usercopy-v4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull hardened usercopy whitelisting from Kees Cook:
     "Currently, hardened usercopy performs dynamic bounds checking on slab
      cache objects. This is good, but still leaves a lot of kernel memory
      available to be copied to/from userspace in the face of bugs.
    
      To further restrict what memory is available for copying, this creates
      a way to whitelist specific areas of a given slab cache object for
      copying to/from userspace, allowing much finer granularity of access
      control.
    
      Slab caches that are never exposed to userspace can declare no
      whitelist for their objects, thereby keeping them unavailable to
      userspace via dynamic copy operations. (Note, an implicit form of
      whitelisting is the use of constant sizes in usercopy operations and
      get_user()/put_user(); these bypass all hardened usercopy checks since
      these sizes cannot change at runtime.)
    
      This new check is WARN-by-default, so any mistakes can be found over
      the next several releases without breaking anyone's system.
    
      The series has roughly the following sections:
       - remove %p and improve reporting with offset
       - prepare infrastructure and whitelist kmalloc
       - update VFS subsystem with whitelists
       - update SCSI subsystem with whitelists
       - update network subsystem with whitelists
       - update process memory with whitelists
       - update per-architecture thread_struct with whitelists
       - update KVM with whitelists and fix ioctl bug
       - mark all other allocations as not whitelisted
       - update lkdtm for more sensible test overage"
    
    * tag 'usercopy-v4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux: (38 commits)
      lkdtm: Update usercopy tests for whitelisting
      usercopy: Restrict non-usercopy caches to size 0
      kvm: x86: fix KVM_XEN_HVM_CONFIG ioctl
      kvm: whitelist struct kvm_vcpu_arch
      arm: Implement thread_struct whitelist for hardened usercopy
      arm64: Implement thread_struct whitelist for hardened usercopy
      x86: Implement thread_struct whitelist for hardened usercopy
      fork: Provide usercopy whitelisting for task_struct
      fork: Define usercopy region in thread_stack slab caches
      fork: Define usercopy region in mm_struct slab caches
      net: Restrict unwhitelisted proto caches to size 0
      sctp: Copy struct sctp_sock.autoclose to userspace using put_user()
      sctp: Define usercopy region in SCTP proto slab cache
      caif: Define usercopy region in caif proto slab cache
      ip: Define usercopy region in IP proto slab cache
      net: Define usercopy region in struct proto slab cache
      scsi: Define usercopy region in scsi_sense_cache slab cache
      cifs: Define usercopy region in cifs_request slab cache
      vxfs: Define usercopy region in vxfs_inode slab cache
      ufs: Define usercopy region in ufs_inode_cache slab cache
      ...

commit ab9ee8e38b292f9a6698a4fedbb6ff8d08ce2012
Author: David Windsor <dave@nullcore.net>
Date:   Thu Aug 24 16:57:57 2017 -0700

    sctp: Define usercopy region in SCTP proto slab cache
    
    The SCTP socket event notification subscription information need to be
    copied to/from userspace. In support of usercopy hardening, this patch
    defines a region in the struct proto slab cache in which userspace copy
    operations are allowed. Additionally moves the usercopy fields to be
    adjacent for the region to cover both.
    
    example usage trace:
    
        net/sctp/socket.c:
            sctp_getsockopt_events(...):
                ...
                copy_to_user(..., &sctp_sk(sk)->subscribe, len)
    
            sctp_setsockopt_events(...):
                ...
                copy_from_user(&sctp_sk(sk)->subscribe, ..., optlen)
    
            sctp_getsockopt_initmsg(...):
                ...
                copy_to_user(..., &sctp_sk(sk)->initmsg, len)
    
    This region is known as the slab cache's usercopy region. Slab caches
    can now check that each dynamically sized copy operation involving
    cache-managed memory falls entirely within the slab's usercopy region.
    
    This patch is modified from Brad Spengler/PaX Team's PAX_USERCOPY
    whitelisting code in the last public patch of grsecurity/PaX based on my
    understanding of the code. Changes or omissions from the original code are
    mine and don't reflect the original grsecurity/PaX code.
    
    Signed-off-by: David Windsor <dave@nullcore.net>
    [kees: split from network patch, move struct members adjacent]
    [kees: add SCTPv6 struct whitelist, provide usage trace]
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-sctp@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 16f949eef52f..6168e3449131 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -202,12 +202,17 @@ struct sctp_sock {
 	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
-	struct sctp_initmsg initmsg;
 	struct sctp_rtoinfo rtoinfo;
 	struct sctp_paddrparams paddrparam;
-	struct sctp_event_subscribe subscribe;
 	struct sctp_assocparams assocparams;
 
+	/*
+	 * These two structures must be grouped together for the usercopy
+	 * whitelist region.
+	 */
+	struct sctp_event_subscribe subscribe;
+	struct sctp_initmsg initmsg;
+
 	int user_frag;
 
 	__u32 autoclose;

commit a0ce093180f2bbb832b3f5583adc640ad67ea568
Merge: f4803f1b73f8 ef7f8cec80a0
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jan 9 10:37:00 2018 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit b6c5734db07079c9410147b32407f2366d584e6c
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Fri Jan 5 11:17:18 2018 -0200

    sctp: fix the handling of ICMP Frag Needed for too small MTUs
    
    syzbot reported a hang involving SCTP, on which it kept flooding dmesg
    with the message:
    [  246.742374] sctp: sctp_transport_update_pmtu: Reported pmtu 508 too
    low, using default minimum of 512
    
    That happened because whenever SCTP hits an ICMP Frag Needed, it tries
    to adjust to the new MTU and triggers an immediate retransmission. But
    it didn't consider the fact that MTUs smaller than the SCTP minimum MTU
    allowed (512) would not cause the PMTU to change, and issued the
    retransmission anyway (thus leading to another ICMP Frag Needed, and so
    on).
    
    As IPv4 (ip_rt_min_pmtu=556) and IPv6 (IPV6_MIN_MTU=1280) minimum MTU
    are higher than that, sctp_transport_update_pmtu() is changed to
    re-fetch the PMTU that got set after our request, and with that, detect
    if there was an actual change or not.
    
    The fix, thus, skips the immediate retransmission if the received ICMP
    resulted in no change, in the hope that SCTP will select another path.
    
    Note: The value being used for the minimum MTU (512,
    SCTP_DEFAULT_MINSEGMENT) is not right and instead it should be (576,
    SCTP_MIN_PMTU), but such change belongs to another patch.
    
    Changes from v1:
    - do not disable PMTU discovery, in the light of commit
    06ad391919b2 ("[SCTP] Don't disable PMTU discovery when mtu is small")
    and as suggested by Xin Long.
    - changed the way to break the rtx loop by detecting if the icmp
      resulted in a change or not
    Changes from v2:
    none
    
    See-also: https://lkml.org/lkml/2017/12/22/811
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2f8f93da5dc2..9a5ccf03a59b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -966,7 +966,7 @@ void sctp_transport_burst_limited(struct sctp_transport *);
 void sctp_transport_burst_reset(struct sctp_transport *);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
 void sctp_transport_reset(struct sctp_transport *t);
-void sctp_transport_update_pmtu(struct sctp_transport *t, u32 pmtu);
+bool sctp_transport_update_pmtu(struct sctp_transport *t, u32 pmtu);
 void sctp_transport_immediate_rtx(struct sctp_transport *);
 void sctp_transport_dst_release(struct sctp_transport *t);
 void sctp_transport_dst_confirm(struct sctp_transport *t);

commit 0fc2ea922c8ad5520c80f03facbf396c81dce802
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 15 00:41:27 2017 +0800

    sctp: implement validate_ftsn for sctp_stream_interleave
    
    validate_ftsn is added as a member of sctp_stream_interleave, used to
    validate ssn/chunk type for fwdtsn or mid (message id)/chunk type for
    ifwdtsn, called in sctp_sf_eat_fwd_tsn, just as validate_data.
    
    If this check fails, an abort packet will be sent, as said in section
    2.3.1 of RFC8260.
    
    As ifwdtsn and fwdtsn chunks have different length, it also defines
    ftsn_chunk_len for sctp_stream_interleave to describe the chunk size.
    Then it replaces all sizeof(struct sctp_fwdtsn_chunk) with
    sctp_ftsnchk_len.
    
    It also adds the process for ifwdtsn in rx path. As Marcelo pointed
    out, there's no need to add event table for ifwdtsn, but just share
    prsctp_chunk_event_table with fwdtsn's. It would drop fwdtsn chunk
    for ifwdtsn and drop ifwdtsn chunk for fwdtsn by calling validate_ftsn
    in sctp_sf_eat_fwd_tsn.
    
    After this patch, the ifwdtsn can be accepted.
    
    Note that this patch also removes the sctp.intl_enable check for
    idata chunks in sctp_chunk_event_lookup, as it will do this check
    in validate_data later.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo R. Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b7720d65a975..8ac4d5cdbfed 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1443,6 +1443,16 @@ static inline __u16 sctp_datahdr_len(const struct sctp_stream *stream)
 	return stream->si->data_chunk_len - sizeof(struct sctp_chunkhdr);
 }
 
+static inline __u16 sctp_ftsnchk_len(const struct sctp_stream *stream)
+{
+	return stream->si->ftsn_chunk_len;
+}
+
+static inline __u16 sctp_ftsnhdr_len(const struct sctp_stream *stream)
+{
+	return stream->si->ftsn_chunk_len - sizeof(struct sctp_chunkhdr);
+}
+
 /* SCTP_GET_ASSOC_STATS counters */
 struct sctp_priv_assoc_stats {
 	/* Maximum observed rto in the association during subsequent

commit 8e0c3b73cec1b943affde91b3c412ad8266b4694
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 15 00:41:26 2017 +0800

    sctp: implement generate_ftsn for sctp_stream_interleave
    
    generate_ftsn is added as a member of sctp_stream_interleave, used to
    create fwdtsn or ifwdtsn chunk according to abandoned chunks, called
    in sctp_retransmit and sctp_outq_sack.
    
    sctp_generate_iftsn works for ifwdtsn, and sctp_generate_fwdtsn is
    still used for making fwdtsn.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo R. Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a5c3cf41e693..b7720d65a975 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1100,6 +1100,7 @@ void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
 void sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
 void sctp_prsctp_prune(struct sctp_association *asoc,
 		       struct sctp_sndrcvinfo *sinfo, int msg_len);
+void sctp_generate_fwdtsn(struct sctp_outq *q, __u32 sack_ctsn);
 /* Uncork and flush an outqueue.  */
 static inline void sctp_outq_cork(struct sctp_outq *q)
 {

commit 2d07a49aded490a0a4a2748e64030a0f59b6b8be
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 15 00:41:25 2017 +0800

    sctp: add basic structures and make chunk function for ifwdtsn
    
    sctp_ifwdtsn_skip, sctp_ifwdtsn_hdr and sctp_ifwdtsn_chunk are used to
    define and parse I-FWD TSN chunk format, and sctp_make_ifwdtsn is a
    function to build the chunk.
    
    The I-FORWARD-TSN Chunk Format is defined in section 2.3.1 of RFC8260.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo R. Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8ef638d966f1..a5c3cf41e693 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -599,6 +599,7 @@ struct sctp_chunk {
 		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
 		struct sctp_authhdr *auth_hdr;
 		struct sctp_idatahdr *idata_hdr;
+		struct sctp_ifwdtsn_hdr *ifwdtsn_hdr;
 	} subh;
 
 	__u8 *chunk_end;

commit 132282386f5d0eff7a84a119599216b5f9e9bfc6
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:04:09 2017 +0800

    sctp: add support for the process of unordered idata
    
    Unordered idata process is more complicated than unordered data:
    
     - It has to add mid into sctp_stream_out to save the next mid value,
       which is separated from ordered idata's.
    
     - To support pd for unordered idata, another mid and pd_mode need to
       be added to save the message id and pd state in sctp_stream_in.
    
     - To make  unordered idata reasm easier, it adds a new event queue
       to save frags for idata.
    
    The patch mostly adds the samilar reasm functions for unordered idata
    as ordered idata's, and also adjusts some other codes on assign_mid,
    abort_pd and ulpevent_data for idata.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 73b315de2fef..8ef638d966f1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -413,6 +413,14 @@ void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);
 
 #define sctp_stream_in(asoc, sid) (&(asoc)->stream.in[sid])
 
+/* What is the current MID_uo number for this stream? */
+#define sctp_mid_uo_peek(stream, type, sid) \
+	((stream)->type[sid].mid_uo)
+
+/* Return the next MID_uo number for this stream.  */
+#define sctp_mid_uo_next(stream, type, sid) \
+	((stream)->type[sid].mid_uo++)
+
 /*
  * Pointers to address related SCTP functions.
  * (i.e. things that depend on the address family.)
@@ -1379,8 +1387,9 @@ struct sctp_stream_out {
 		__u32 mid;
 		__u16 ssn;
 	};
-	__u8	state;
+	__u32 mid_uo;
 	struct sctp_stream_out_ext *ext;
+	__u8 state;
 };
 
 struct sctp_stream_in {
@@ -1388,8 +1397,11 @@ struct sctp_stream_in {
 		__u32 mid;
 		__u16 ssn;
 	};
+	__u32 mid_uo;
 	__u32 fsn;
+	__u32 fsn_uo;
 	char pd_mode;
+	char pd_mode_uo;
 };
 
 struct sctp_stream {

commit bd4d627dbd5adb8130d5c54a4135d89f45e41905
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:04:04 2017 +0800

    sctp: implement ulpevent_data for sctp_stream_interleave
    
    ulpevent_data is added as a member of sctp_stream_interleave, used to
    do the most process in ulpq, including to convert data or idata chunk
    to event, reasm them in reasm queue and put them in lobby queue in
    right order, and deliver them up to user sk rx queue.
    
    This procedure is described in section 2.2.3 of RFC8260.
    
    It adds most functions for idata here to do the similar process as
    the old functions for data. But since the details are very different
    between them, the old functions can not be reused for idata.
    
    event->ssn and event->ppid settings are moved to ulpevent_data from
    sctp_ulpevent_make_rcvmsg, so that sctp_ulpevent_make_rcvmsg could
    work for both data and idata.
    
    Note that mid is added in sctp_ulpevent for idata, __packed has to
    be used for defining sctp_ulpevent, or it would exceeds the skb cb
    that saves a sctp_ulpevent variable for ulp layer process.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index be4cc73f3106..73b315de2fef 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -411,6 +411,8 @@ void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);
 #define sctp_mid_skip(stream, type, sid, mid) \
 	((stream)->type[sid].mid = mid + 1)
 
+#define sctp_stream_in(asoc, sid) (&(asoc)->stream.in[sid])
+
 /*
  * Pointers to address related SCTP functions.
  * (i.e. things that depend on the address family.)
@@ -1387,6 +1389,7 @@ struct sctp_stream_in {
 		__u16 ssn;
 	};
 	__u32 fsn;
+	char pd_mode;
 };
 
 struct sctp_stream {

commit 9d4ceaf154a947e69648041bcb11a24a7a40c380
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:04:03 2017 +0800

    sctp: implement validate_data for sctp_stream_interleave
    
    validate_data is added as a member of sctp_stream_interleave, used
    to validate ssn/chunk type for data or mid (message id)/chunk type
    for idata, called in sctp_eat_data.
    
    If this check fails, an abort packet will be sent, as said in
    section 2.2.3 of RFC8260.
    
    It also adds the process for idata in rx path. As Marcelo pointed
    out, there's no need to add event table for idata, but just share
    chunk_event_table with data's. It would drop data chunk for idata
    and drop idata chunk for data by calling validate_data in
    sctp_eat_data.
    
    As last patch did, it also replaces sizeof(struct sctp_data_chunk)
    with sctp_datachk_len for rx path.
    
    After this patch, the idata can be accepted and delivered to ulp
    layer.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fd93973bb667..be4cc73f3106 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1382,7 +1382,11 @@ struct sctp_stream_out {
 };
 
 struct sctp_stream_in {
-	__u16	ssn;
+	union {
+		__u32 mid;
+		__u16 ssn;
+	};
+	__u32 fsn;
 };
 
 struct sctp_stream {

commit 668c9beb9020d5834ee9e43c208190a07d2b1928
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:04:02 2017 +0800

    sctp: implement assign_number for sctp_stream_interleave
    
    assign_number is added as a member of sctp_stream_interleave, used
    to assign ssn for data or mid (message id) for idata, called in
    sctp_packet_append_data. sctp_chunk_assign_ssn is left as it is,
    and sctp_chunk_assign_mid is added for sctp_stream_interleave_1.
    
    This procedure is described in section 2.2.2 of RFC8260.
    
    All sizeof(struct sctp_data_chunk) in tx path is replaced with
    sctp_datachk_len, to make it right for idata as well. And also
    adjust sctp_chunk_is_data for SCTP_CID_I_DATA.
    
    After this patch, idata can be built and sent in tx path.
    
    Note that if sp strm_interleave is set, it has to wait_connect in
    sctp_sendmsg, as asoc intl_enable need to be known after 4 shake-
    hands, to decide if it should use data or idata later. data and
    idata can't be mixed to send in one asoc.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 96cc898787f1..fd93973bb667 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -399,6 +399,18 @@ void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);
 #define sctp_ssn_skip(stream, type, sid, ssn) \
 	((stream)->type[sid].ssn = ssn + 1)
 
+/* What is the current MID number for this stream? */
+#define sctp_mid_peek(stream, type, sid) \
+	((stream)->type[sid].mid)
+
+/* Return the next MID number for this stream.  */
+#define sctp_mid_next(stream, type, sid) \
+	((stream)->type[sid].mid++)
+
+/* Skip over this mid and all below. */
+#define sctp_mid_skip(stream, type, sid, mid) \
+	((stream)->type[sid].mid = mid + 1)
+
 /*
  * Pointers to address related SCTP functions.
  * (i.e. things that depend on the address family.)
@@ -623,6 +635,7 @@ struct sctp_chunk {
 	__u16	rtt_in_progress:1,	/* This chunk used for RTT calc? */
 		has_tsn:1,		/* Does this chunk have a TSN yet? */
 		has_ssn:1,		/* Does this chunk have a SSN yet? */
+#define has_mid has_ssn
 		singleton:1,		/* Only chunk in the packet? */
 		end_of_packet:1,	/* Last chunk in the packet? */
 		ecn_ce_done:1,		/* Have we processed the ECN CE bit? */
@@ -1360,7 +1373,10 @@ struct sctp_stream_out_ext {
 };
 
 struct sctp_stream_out {
-	__u16	ssn;
+	union {
+		__u32 mid;
+		__u16 ssn;
+	};
 	__u8	state;
 	struct sctp_stream_out_ext *ext;
 };

commit 0c3f6f655487d12c7a0c16914c98c599043e88d3
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:04:01 2017 +0800

    sctp: implement make_datafrag for sctp_stream_interleave
    
    To avoid hundreds of checks for the different process on I-DATA chunk,
    struct sctp_stream_interleave is defined as a group of functions used
    to replace the codes in some place where it needs to do different job
    according to if the asoc intl_enabled is set.
    
    With these ops, it only needs to initialize asoc->stream.si with
    sctp_stream_interleave_0 for normal data if asoc intl_enable is 0,
    or sctp_stream_interleave_1 for idata if asoc intl_enable is set in
    sctp_stream_init.
    
    After that, the members in asoc->stream.si can be used directly in
    some special places without checking asoc intl_enable.
    
    make_datafrag is the first member for sctp_stream_interleave, it's
    used to make data or idata frags, called in sctp_datamsg_from_user.
    The old function sctp_make_datafrag_empty needs to be adjust some
    to fit in this ops.
    
    Note that as idata and data chunks have different length, it also
    defines data_chunk_len for sctp_stream_interleave to describe the
    chunk size.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7026a8039367..96cc898787f1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -89,6 +89,7 @@ struct sctp_stream;
 #include <net/sctp/tsnmap.h>
 #include <net/sctp/ulpevent.h>
 #include <net/sctp/ulpqueue.h>
+#include <net/sctp/stream_interleave.h>
 
 /* Structures useful for managing bind/connect. */
 
@@ -1389,11 +1390,22 @@ struct sctp_stream {
 			struct sctp_stream_out_ext *rr_next;
 		};
 	};
+	struct sctp_stream_interleave *si;
 };
 
 #define SCTP_STREAM_CLOSED		0x00
 #define SCTP_STREAM_OPEN		0x01
 
+static inline __u16 sctp_datachk_len(const struct sctp_stream *stream)
+{
+	return stream->si->data_chunk_len;
+}
+
+static inline __u16 sctp_datahdr_len(const struct sctp_stream *stream)
+{
+	return stream->si->data_chunk_len - sizeof(struct sctp_chunkhdr);
+}
+
 /* SCTP_GET_ASSOC_STATS counters */
 struct sctp_priv_assoc_stats {
 	/* Maximum observed rto in the association during subsequent

commit ad05a7a05ede28ba6dd935d9e932264a22518b1f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:04:00 2017 +0800

    sctp: add basic structures and make chunk function for idata
    
    sctp_idatahdr and sctp_idata_chunk are used to define and parse
    I-DATA chunk format, and sctp_make_idata is a function to build
    the chunk.
    
    The I-DATA Chunk Format is defined in section 2.1 of RFC8260.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7030cbe11f45..7026a8039367 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -575,6 +575,7 @@ struct sctp_chunk {
 		struct sctp_addiphdr *addip_hdr;
 		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
 		struct sctp_authhdr *auth_hdr;
+		struct sctp_idatahdr *idata_hdr;
 	} subh;
 
 	__u8 *chunk_end;

commit 772a58693fc3116d05b7969223a80a6376e639eb
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Dec 8 21:03:58 2017 +0800

    sctp: add stream interleave enable members and sockopt
    
    This patch adds intl_enable in asoc and netns, and strm_interleave in
    sctp_sock to indicate if stream interleave is enabled and supported.
    
    netns intl_enable would be set via procfs, but that is not added yet
    until all stream interleave codes are completely implemented; asoc
    intl_enable will be set when doing 4-shakehands.
    
    sp strm_interleave can be set by sockopt SCTP_INTERLEAVING_SUPPORTED
    which is also added in this patch. This socket option is defined in
    section 4.3.1 of RFC8260.
    
    Note that strm_interleave can only be set by sockopt when both netns
    intl_enable and sp frag_interleave are set.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2f8f93da5dc2..7030cbe11f45 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -217,6 +217,7 @@ struct sctp_sock {
 		disable_fragments:1,
 		v4mapped:1,
 		frag_interleave:1,
+		strm_interleave:1,
 		recvrcvinfo:1,
 		recvnxtinfo:1,
 		data_ready_signalled:1;
@@ -1940,6 +1941,7 @@ struct sctp_association {
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1,		/* Is it a temporary association? */
 	     force_delay:1,
+	     intl_enable:1,
 	     prsctp_enable:1,
 	     reconf_enable:1;
 

commit e5f612969c6f965e3bd1158598e0a3b1c4f389b9
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Nov 25 21:18:35 2017 +0800

    sctp: abandon the whole msg if one part of a fragmented message is abandoned
    
    As rfc3758#section-3.1 demands:
    
       A3) When a TSN is "abandoned", if it is part of a fragmented message,
           all other TSN's within that fragmented message MUST be abandoned
           at the same time.
    
    Besides, if it couldn't handle this, the rest frags would never get
    assembled in peer side.
    
    This patch supports it by adding abandoned flag in sctp_datamsg, when
    one chunk is being abandoned, set chunk->msg->abandoned as well. Next
    time when checking for abandoned, go checking chunk->msg->abandoned
    first.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 16f949eef52f..2f8f93da5dc2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -503,7 +503,8 @@ struct sctp_datamsg {
 	/* Did the messenge fail to send? */
 	int send_error;
 	u8 send_failed:1,
-	   can_delay;	    /* should this message be Nagle delayed */
+	   can_delay:1,	/* should this message be Nagle delayed */
+	   abandoned:1;	/* should this message be abandoned */
 };
 
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,

commit ac1ed8b82cd60ba8e7d84103ac1414b8c577c485
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 3 19:20:17 2017 -0300

    sctp: introduce round robin stream scheduler
    
    This patch introduces RFC Draft ndata section 3.2 Priority Based
    Scheduler (SCTP_SS_RR).
    
    Works by maintaining a list of enqueued streams and tracking the last
    one used to send data. When the datamsg is done, it switches to the next
    stream.
    
    See-also: https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13
    Tested-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 40eb8d66a37c..16f949eef52f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1348,6 +1348,10 @@ struct sctp_stream_out_ext {
 			struct list_head prio_list;
 			struct sctp_stream_priorities *prio_head;
 		};
+		/* Fields used by RR scheduler */
+		struct {
+			struct list_head rr_list;
+		};
 	};
 };
 
@@ -1374,6 +1378,13 @@ struct sctp_stream {
 			/* List of priorities scheduled */
 			struct list_head prio_list;
 		};
+		/* Fields used by RR scheduler */
+		struct {
+			/* List of streams scheduled */
+			struct list_head rr_list;
+			/* The next stream stream in line */
+			struct sctp_stream_out_ext *rr_next;
+		};
 	};
 };
 

commit 637784ade221a3c8a7ecd0f583eddd95d6276b9a
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 3 19:20:16 2017 -0300

    sctp: introduce priority based stream scheduler
    
    This patch introduces RFC Draft ndata section 3.4 Priority Based
    Scheduler (SCTP_SS_PRIO).
    
    It works by having a struct sctp_stream_priority for each priority
    configured. This struct is then enlisted on a queue ordered per priority
    if, and only if, there is a stream with data queued, so that dequeueing
    is very straightforward: either finish current datamsg or simply dequeue
    from the highest priority queued, which is the next stream pointed, and
    that's it.
    
    If there are multiple streams assigned with the same priority and with
    data queued, it will do round robin amongst them while respecting
    datamsgs boundaries (when not using idata chunks), to be reasonably
    fair.
    
    We intentionally don't maintain a list of priorities nor a list of all
    streams with the same priority to save memory. The first would mean at
    least 2 other pointers per priority (which, for 1000 priorities, that
    can mean 16kB) and the second would also mean 2 other pointers but per
    stream. As SCTP supports up to 65535 streams on a given asoc, that's
    1MB. This impacts when giving a priority to some stream, as we have to
    find out if the new priority is already being used and if we can free
    the old one, and also when tearing down.
    
    The new fields in struct sctp_stream_out_ext and sctp_stream are added
    under a union because that memory is to be shared with other schedulers.
    
    See-also: https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13
    Tested-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 3c22a30fd71b..40eb8d66a37c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1328,10 +1328,27 @@ struct sctp_inithdr_host {
 	__u32 initial_tsn;
 };
 
+struct sctp_stream_priorities {
+	/* List of priorities scheduled */
+	struct list_head prio_sched;
+	/* List of streams scheduled */
+	struct list_head active;
+	/* The next stream stream in line */
+	struct sctp_stream_out_ext *next;
+	__u16 prio;
+};
+
 struct sctp_stream_out_ext {
 	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
 	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
 	struct list_head outq; /* chunks enqueued by this stream */
+	union {
+		struct {
+			/* Scheduled streams list */
+			struct list_head prio_list;
+			struct sctp_stream_priorities *prio_head;
+		};
+	};
 };
 
 struct sctp_stream_out {
@@ -1351,6 +1368,13 @@ struct sctp_stream {
 	__u16 incnt;
 	/* Current stream being sent, if any */
 	struct sctp_stream_out *out_curr;
+	union {
+		/* Fields used by priority scheduler */
+		struct {
+			/* List of priorities scheduled */
+			struct list_head prio_list;
+		};
+	};
 };
 
 #define SCTP_STREAM_CLOSED		0x00

commit 5bbbbe32a43199c2b9ea5ea66fab6241c64beb51
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 3 19:20:13 2017 -0300

    sctp: introduce stream scheduler foundations
    
    This patch introduces the hooks necessary to do stream scheduling, as
    per RFC Draft ndata.  It also introduces the first scheduler, which is
    what we do today but now factored out: first come first served (FCFS).
    
    With stream scheduling now we have to track which chunk was enqueued on
    which stream and be able to select another other than the in front of
    the main outqueue. So we introduce a list on sctp_stream_out_ext
    structure for this purpose.
    
    We reuse sctp_chunk->transmitted_list space for the list above, as the
    chunk cannot belong to the two lists at the same time. By using the
    union in there, we can have distinct names for these moments.
    
    sctp_sched_ops are the operations expected to be implemented by each
    scheduler. The dequeueing is a bit particular to this implementation but
    it is to match how we dequeue packets today. We first dequeue and then
    check if it fits the packet and if not, we requeue it at head. Thus why
    we don't have a peek operation but have dequeue_done instead, which is
    called once the chunk can be safely considered as transmitted.
    
    The check removed from sctp_outq_flush is now performed by
    sctp_stream_outq_migrate, which is only called during assoc setup.
    (sctp_sendmsg() also checks for it)
    
    The only operation that is foreseen but not yet added here is a way to
    signalize that a new packet is starting or that the packet is done, for
    round robin scheduler per packet, but is intentionally left to the
    patch that actually implements it.
    
    Support for I-DATA chunks, also described in this RFC, with user message
    interleaving is straightforward as it just requires the schedulers to
    probe for the feature and ignore datamsg boundaries when dequeueing.
    
    See-also: https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-ndata-13
    Tested-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c48f7999fe9b..3c22a30fd71b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -84,7 +84,6 @@ struct sctp_ulpq;
 struct sctp_ep_common;
 struct crypto_shash;
 struct sctp_stream;
-struct sctp_stream_out;
 
 
 #include <net/sctp/tsnmap.h>
@@ -531,8 +530,12 @@ struct sctp_chunk {
 	/* How many times this chunk have been sent, for prsctp RTX policy */
 	int sent_count;
 
-	/* This is our link to the per-transport transmitted list.  */
-	struct list_head transmitted_list;
+	union {
+		/* This is our link to the per-transport transmitted list.  */
+		struct list_head transmitted_list;
+		/* List in specific stream outq */
+		struct list_head stream_list;
+	};
 
 	/* This field is used by chunks that hold fragmented data.
 	 * For the first fragment this is the list that holds the rest of
@@ -1019,6 +1022,9 @@ struct sctp_outq {
 	/* Data pending that has never been transmitted.  */
 	struct list_head out_chunk_list;
 
+	/* Stream scheduler being used */
+	struct sctp_sched_ops *sched;
+
 	unsigned int out_qlen;	/* Total length of queued data chunks. */
 
 	/* Error of send failed, may used in SCTP_SEND_FAILED event. */
@@ -1325,6 +1331,7 @@ struct sctp_inithdr_host {
 struct sctp_stream_out_ext {
 	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
 	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
+	struct list_head outq; /* chunks enqueued by this stream */
 };
 
 struct sctp_stream_out {
@@ -1342,6 +1349,8 @@ struct sctp_stream {
 	struct sctp_stream_in *in;
 	__u16 outcnt;
 	__u16 incnt;
+	/* Current stream being sent, if any */
+	struct sctp_stream_out *out_curr;
 };
 
 #define SCTP_STREAM_CLOSED		0x00

commit 2fc019f790312e703efa1a44204c586112a430dc
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 3 19:20:12 2017 -0300

    sctp: introduce sctp_chunk_stream_no
    
    Add a helper to fetch the stream number from a given chunk.
    
    Tested-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9b2b30b3ba4d..c48f7999fe9b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -642,6 +642,11 @@ void sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,
 		     union sctp_addr *);
 const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 
+static inline __u16 sctp_chunk_stream_no(struct sctp_chunk *ch)
+{
+	return ntohs(ch->subh.data_hdr->stream);
+}
+
 enum {
 	SCTP_ADDR_NEW,		/* new address added to assoc/ep */
 	SCTP_ADDR_SRC,		/* address can be used as source */

commit f952be79cebd49d04154781d99408867a069d375
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Oct 3 19:20:11 2017 -0300

    sctp: introduce struct sctp_stream_out_ext
    
    With the stream schedulers, sctp_stream_out will become too big to be
    allocated by kmalloc and as we need to allocate with BH disabled, we
    cannot use __vmalloc in sctp_stream_init().
    
    This patch moves out the stats from sctp_stream_out to
    sctp_stream_out_ext, which will be allocated only when the application
    tries to sendmsg something on it.
    
    Just the introduction of sctp_stream_out_ext would already fix the issue
    described above by splitting the allocation in two. Moving the stats
    to it also reduces the pressure on the allocator as we will ask for less
    memory atomically when creating the socket and we will use GFP_KERNEL
    later.
    
    Then, for stream schedulers, we will just use sctp_stream_out_ext.
    
    Tested-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0477945de1a3..9b2b30b3ba4d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -84,6 +84,7 @@ struct sctp_ulpq;
 struct sctp_ep_common;
 struct crypto_shash;
 struct sctp_stream;
+struct sctp_stream_out;
 
 
 #include <net/sctp/tsnmap.h>
@@ -380,6 +381,7 @@ struct sctp_sender_hb_info {
 
 int sctp_stream_init(struct sctp_stream *stream, __u16 outcnt, __u16 incnt,
 		     gfp_t gfp);
+int sctp_stream_init_ext(struct sctp_stream *stream, __u16 sid);
 void sctp_stream_free(struct sctp_stream *stream);
 void sctp_stream_clear(struct sctp_stream *stream);
 void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);
@@ -1315,11 +1317,15 @@ struct sctp_inithdr_host {
 	__u32 initial_tsn;
 };
 
+struct sctp_stream_out_ext {
+	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
+	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
+};
+
 struct sctp_stream_out {
 	__u16	ssn;
 	__u8	state;
-	__u64	abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
-	__u64	abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
+	struct sctp_stream_out_ext *ext;
 };
 
 struct sctp_stream_in {

commit b7ef2618a0bf75c1e480b05739b0c5f2a42081cd
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:50 2017 +0800

    sctp: remove the typedef sctp_socket_type_t
    
    This patch is to remove the typedef sctp_socket_type_t, and
    replace with enum sctp_socket_type in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b6d75b37f84d..0477945de1a3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -150,18 +150,18 @@ extern struct sctp_globals {
 #define sctp_checksum_disable		(sctp_globals.checksum_disable)
 
 /* SCTP Socket type: UDP or TCP style. */
-typedef enum {
+enum sctp_socket_type {
 	SCTP_SOCKET_UDP = 0,
 	SCTP_SOCKET_UDP_HIGH_BANDWIDTH,
 	SCTP_SOCKET_TCP
-} sctp_socket_type_t;
+};
 
 /* Per socket SCTP information. */
 struct sctp_sock {
 	/* inet_sock has to be the first member of sctp_sock */
 	struct inet_sock inet;
 	/* What kind of a socket is this? */
-	sctp_socket_type_t type;
+	enum sctp_socket_type type;
 
 	/* PF_ family specific functions.  */
 	struct sctp_pf *pf;

commit d38ef5ae35b0960f3219f1cf0203e19819e757c7
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:49 2017 +0800

    sctp: remove the typedef sctp_dbg_objcnt_entry_t
    
    This patch is to remove the typedef sctp_dbg_objcnt_entry_t, and
    replace with struct sctp_dbg_objcnt_entry in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e171d3a3d2b4..b6d75b37f84d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1992,9 +1992,9 @@ struct sctp_cmsgs {
 };
 
 /* Structure for tracking memory objects */
-typedef struct {
+struct sctp_dbg_objcnt_entry {
 	char *label;
 	atomic_t *counter;
-} sctp_dbg_objcnt_entry_t;
+};
 
 #endif /* __sctp_structs_h__ */

commit a05437ac5deb100f94e290ad4c5eef3e78f4b6bb
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:48 2017 +0800

    sctp: remove the typedef sctp_cmsgs_t
    
    This patch is to remove the typedef sctp_cmsgs_t, and
    replace with struct sctp_cmsgs in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 937187f3bffc..e171d3a3d2b4 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1985,11 +1985,11 @@ int sctp_cmp_addr_exact(const union sctp_addr *ss1,
 struct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc);
 
 /* A convenience structure to parse out SCTP specific CMSGs. */
-typedef struct sctp_cmsgs {
+struct sctp_cmsgs {
 	struct sctp_initmsg *init;
 	struct sctp_sndrcvinfo *srinfo;
 	struct sctp_sndinfo *sinfo;
-} sctp_cmsgs_t;
+};
 
 /* Structure for tracking memory objects */
 typedef struct {

commit 74439f344b1becd57ec822bc0e2c1a4cbf240a53
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:47 2017 +0800

    sctp: remove the typedef sctp_endpoint_type_t
    
    This patch is to remove the typedef sctp_endpoint_type_t, and
    replace with enum sctp_endpoint_type in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 60033a263193..937187f3bffc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1142,10 +1142,10 @@ int sctp_is_ep_boundall(struct sock *sk);
 
 
 /* What type of endpoint?  */
-typedef enum {
+enum sctp_endpoint_type {
 	SCTP_EP_TYPE_SOCKET,
 	SCTP_EP_TYPE_ASSOCIATION,
-} sctp_endpoint_type_t;
+};
 
 /*
  * A common base class to bridge the implmentation view of a
@@ -1169,7 +1169,7 @@ struct sctp_ep_common {
 	int hashent;
 
 	/* Runtime type information.  What kind of endpoint is this? */
-	sctp_endpoint_type_t type;
+	enum sctp_endpoint_type type;
 
 	/* Some fields to help us manage this object.
 	 *   refcnt   - Reference count access to this object.

commit edf903f83ebca988e04a39f515ab6eacb92055df
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:46 2017 +0800

    sctp: remove the typedef sctp_sender_hb_info_t
    
    This patch is to remove the typedef sctp_sender_hb_info_t, and
    replace with struct sctp_sender_hb_info in the places where it's
    using this typedef.
    
    It is also to use sizeof(variable) instead of sizeof(type).
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 73e9509c057e..60033a263193 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -371,12 +371,12 @@ union sctp_params {
  *    chunk is sent and the destination transport address to which this
  *    HEARTBEAT is sent (see Section 8.3).
  */
-typedef struct sctp_sender_hb_info {
+struct sctp_sender_hb_info {
 	struct sctp_paramhdr param_hdr;
 	union sctp_addr daddr;
 	unsigned long sent_at;
 	__u64 hb_nonce;
-} sctp_sender_hb_info_t;
+};
 
 int sctp_stream_init(struct sctp_stream *stream, __u16 outcnt, __u16 incnt,
 		     gfp_t gfp);

commit afa6c45429f6e5ddd1eb6b77a36358f9c4b789da
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Aug 11 10:23:45 2017 +0800

    sctp: remove the unused typedef sctp_packet_phandler_t
    
    Remove this function typedef, there is even no places
    using it.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fbe6e81b889b..73e9509c057e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -657,8 +657,6 @@ struct sctp_sockaddr_entry {
 
 #define SCTP_ADDRESS_TICK_DELAY	500
 
-typedef struct sctp_chunk *(sctp_packet_phandler_t)(struct sctp_association *);
-
 /* This structure holds lists of chunks as we are assembling for
  * transmission.
  */

commit 5210601945f5aedaf2d7f13a88436e27a39c6a8a
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:59 2017 +0800

    sctp: remove the typedef sctp_state_t
    
    This patch is to remove the typedef sctp_state_t, and
    replace with enum sctp_state in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6fab67e7f1e5..fbe6e81b889b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1577,7 +1577,7 @@ struct sctp_association {
 	 *
 	 *		State takes values from SCTP_STATE_*.
 	 */
-	sctp_state_t state;
+	enum sctp_state state;
 
 	/* Overall     : The overall association error count.
 	 * Error Count : [Clear this any time I get something.]

commit 86b36f2a9b9ea58dd2100b0e6f1f45a1f67ee95e
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:57 2017 +0800

    sctp: remove the typedef sctp_xmit_t
    
    This patch is to remove the typedef sctp_xmit_t, and
    replace with enum sctp_xmit in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d098d1c4ed74..6fab67e7f1e5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -697,10 +697,11 @@ struct sctp_packet {
 void sctp_packet_init(struct sctp_packet *, struct sctp_transport *,
 		      __u16 sport, __u16 dport);
 void sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
-sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *,
-				       struct sctp_chunk *, int, gfp_t);
-sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *,
-                                     struct sctp_chunk *);
+enum sctp_xmit sctp_packet_transmit_chunk(struct sctp_packet *packet,
+					  struct sctp_chunk *chunk,
+					  int one_packet, gfp_t gfp);
+enum sctp_xmit sctp_packet_append_chunk(struct sctp_packet *packet,
+					struct sctp_chunk *chunk);
 int sctp_packet_transmit(struct sctp_packet *, gfp_t);
 void sctp_packet_free(struct sctp_packet *);
 

commit 0ceaeebe28d46e49c865f88a3e3ca75f6cf13e1f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:55 2017 +0800

    sctp: remove the typedef sctp_transport_cmd_t
    
    This patch is to remove the typedef sctp_transport_cmd_t, and
    replace with enum sctp_transport_cmd in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d771d418481f..d098d1c4ed74 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1947,9 +1947,10 @@ void sctp_assoc_del_peer(struct sctp_association *asoc,
 			 const union sctp_addr *addr);
 void sctp_assoc_rm_peer(struct sctp_association *asoc,
 			 struct sctp_transport *peer);
-void sctp_assoc_control_transport(struct sctp_association *,
-				  struct sctp_transport *,
-				  sctp_transport_cmd_t, sctp_sn_error_t);
+void sctp_assoc_control_transport(struct sctp_association *asoc,
+				  struct sctp_transport *transport,
+				  enum sctp_transport_cmd command,
+				  sctp_sn_error_t error);
 struct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *, __u32);
 struct sctp_transport *sctp_assoc_is_match(struct sctp_association *,
 					   struct net *,

commit 1c662018d2d41ecc5550cbd74d29d2d32c164ed3
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:54 2017 +0800

    sctp: remove the typedef sctp_scope_t
    
    This patch is to remove the typedef sctp_scope_t, and
    replace with enum sctp_scope in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5e872acee6e3..d771d418481f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -449,7 +449,7 @@ struct sctp_af {
 	int		(*addr_valid)	(union sctp_addr *,
 					 struct sctp_sock *,
 					 const struct sk_buff *);
-	sctp_scope_t	(*scope) (union sctp_addr *);
+	enum sctp_scope	(*scope)(union sctp_addr *);
 	void		(*inaddr_any)	(union sctp_addr *, __be16);
 	int		(*is_any)	(const union sctp_addr *);
 	int		(*available)	(union sctp_addr *,
@@ -1111,7 +1111,7 @@ void sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);
 void sctp_bind_addr_free(struct sctp_bind_addr *);
 int sctp_bind_addr_copy(struct net *net, struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
-			sctp_scope_t scope, gfp_t gfp,
+			enum sctp_scope scope, gfp_t gfp,
 			int flags);
 int sctp_bind_addr_dup(struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
@@ -1135,8 +1135,9 @@ union sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,
 int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
 			   __u16 port, gfp_t gfp);
 
-sctp_scope_t sctp_scope(const union sctp_addr *);
-int sctp_in_scope(struct net *net, const union sctp_addr *addr, const sctp_scope_t scope);
+enum sctp_scope sctp_scope(const union sctp_addr *addr);
+int sctp_in_scope(struct net *net, const union sctp_addr *addr,
+		  const enum sctp_scope scope);
 int sctp_is_any(struct sock *sk, const union sctp_addr *addr);
 int sctp_is_ep_boundall(struct sock *sk);
 
@@ -1925,8 +1926,8 @@ static inline struct sctp_association *sctp_assoc(struct sctp_ep_common *base)
 
 
 struct sctp_association *
-sctp_association_new(const struct sctp_endpoint *, const struct sock *,
-		     sctp_scope_t scope, gfp_t gfp);
+sctp_association_new(const struct sctp_endpoint *ep, const struct sock *sk,
+		     enum sctp_scope scope, gfp_t gfp);
 void sctp_association_free(struct sctp_association *);
 void sctp_association_put(struct sctp_association *);
 void sctp_association_hold(struct sctp_association *);
@@ -1967,8 +1968,8 @@ void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
 void sctp_assoc_del_nonprimary_peers(struct sctp_association *,
 				    struct sctp_transport *);
-int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *,
-				     sctp_scope_t, gfp_t);
+int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
+				     enum sctp_scope scope, gfp_t gfp);
 int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
 					 struct sctp_cookie*,
 					 gfp_t gfp);

commit 125c29820252bfa5bf8081e75618e4ee7e9487da
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:52 2017 +0800

    sctp: remove the typedef sctp_retransmit_reason_t
    
    This patch is to remove the typedef sctp_retransmit_reason_t, and
    replace with enum sctp_retransmit_reason in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 53802d8872d7..5e872acee6e3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1054,8 +1054,8 @@ int sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);
 
-void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
-		     sctp_retransmit_reason_t);
+void sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,
+		     enum sctp_retransmit_reason reason);
 void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
 void sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
 void sctp_prsctp_prune(struct sctp_association *asoc,

commit 233e7936c84b7d7dd90c10e2ba27abb5ab42956f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Aug 5 19:59:51 2017 +0800

    sctp: remove the typedef sctp_lower_cwnd_t
    
    This patch is to remove the typedef sctp_lower_cwnd_t, and
    replace with enum sctp_lower_cwnd in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 66cd7639b912..53802d8872d7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -950,7 +950,8 @@ int sctp_transport_hold(struct sctp_transport *);
 void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);
 void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);
-void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
+void sctp_transport_lower_cwnd(struct sctp_transport *t,
+			       enum sctp_lower_cwnd reason);
 void sctp_transport_burst_limited(struct sctp_transport *);
 void sctp_transport_burst_reset(struct sctp_transport *);
 unsigned long sctp_transport_timeout(struct sctp_transport *);

commit 1474774a7f0daf9878fd9537a24714f419e744ed
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 17 11:29:59 2017 +0800

    sctp: remove the typedef sctp_hmac_algo_param_t
    
    This patch is to remove the typedef sctp_hmac_algo_param_t, and
    replace with struct sctp_hmac_algo_param in the places where it's
    using this typedef.
    
    It is also to use sizeof(variable) instead of sizeof(type).
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8042e6380b0e..66cd7639b912 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1558,7 +1558,7 @@ struct sctp_association {
 		 */
 		struct sctp_random_param *peer_random;
 		struct sctp_chunks_param *peer_chunks;
-		sctp_hmac_algo_param_t *peer_hmacs;
+		struct sctp_hmac_algo_param *peer_hmacs;
 	} peer;
 
 	/* State       : A state variable indicating what state the

commit a762a9d94d44980e3690f9de87b918376daa6428
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 17 11:29:58 2017 +0800

    sctp: remove the typedef sctp_chunks_param_t
    
    This patch is to remove the typedef sctp_chunks_param_t, and
    replace with struct sctp_chunks_param in the places where it's
    using this typedef.
    
    It is also to use sizeof(variable) instead of sizeof(type).
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f22c079fd1f1..8042e6380b0e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1557,7 +1557,7 @@ struct sctp_association {
 		 * cookie and these are just pointers to those locations
 		 */
 		struct sctp_random_param *peer_random;
-		sctp_chunks_param_t *peer_chunks;
+		struct sctp_chunks_param *peer_chunks;
 		sctp_hmac_algo_param_t *peer_hmacs;
 	} peer;
 

commit b02db702face3791889a4fcf06691c086648ee89
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Jul 17 11:29:57 2017 +0800

    sctp: remove the typedef sctp_random_param_t
    
    This patch is to remove the typedef sctp_random_param_t, and
    replace with struct sctp_random_param in the places where it's
    using this typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5ab29af8ca8a..f22c079fd1f1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1556,7 +1556,7 @@ struct sctp_association {
 		 * and authenticated chunk list.  All that is part of the
 		 * cookie and these are just pointers to those locations
 		 */
-		sctp_random_param_t *peer_random;
+		struct sctp_random_param *peer_random;
 		sctp_chunks_param_t *peer_chunks;
 		sctp_hmac_algo_param_t *peer_hmacs;
 	} peer;

commit c638457a7c6b8931cd4586d6a13a33887185342d
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 15:53:28 2017 +0300

    net, sctp: convert sctp_ep_common.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6a0d37258506..5ab29af8ca8a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1174,7 +1174,7 @@ struct sctp_ep_common {
 	 *   refcnt   - Reference count access to this object.
 	 *   dead     - Do not attempt to use this object.
 	 */
-	atomic_t    refcnt;
+	refcount_t    refcnt;
 	bool	    dead;
 
 	/* What socket does this endpoint belong to?  */

commit a4b2b58efd44db68358e1a6b71cf205c795d7ada
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 15:53:27 2017 +0300

    net, sctp: convert sctp_transport.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0dfc5c14b696..6a0d37258506 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -735,7 +735,7 @@ struct sctp_transport {
 	struct rhlist_head node;
 
 	/* Reference counting. */
-	atomic_t refcnt;
+	refcount_t refcnt;
 		/* RTO-Pending : A flag used to track if one of the DATA
 		 *		chunks sent to this address is currently being
 		 *		used to compute a RTT. If this flag is 0,

commit e7f027961759f334bcc939980ec35480faa7ef17
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 15:53:26 2017 +0300

    net, sctp: convert sctp_chunk.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4d7c855d8443..0dfc5c14b696 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -524,7 +524,7 @@ int sctp_chunk_abandoned(struct sctp_chunk *);
 struct sctp_chunk {
 	struct list_head list;
 
-	atomic_t refcnt;
+	refcount_t refcnt;
 
 	/* How many times this chunk have been sent, for prsctp RTX policy */
 	int sent_count;

commit c0acdfb409c82047853df1e5f3dbdbe4005c78ae
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 15:53:25 2017 +0300

    net, sctp: convert sctp_datamsg.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 07c11fefa8c4..4d7c855d8443 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -496,7 +496,7 @@ struct sctp_datamsg {
 	/* Chunks waiting to be submitted to lower layer. */
 	struct list_head chunks;
 	/* Reference counting. */
-	atomic_t refcnt;
+	refcount_t refcnt;
 	/* When is this message no longer interesting to the peer? */
 	unsigned long expires_at;
 	/* Did the messenge fail to send? */

commit 01a992bea523d9568cf56a02003c15c9dc40eb20
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jun 30 11:52:22 2017 +0800

    sctp: remove the typedef sctp_init_chunk_t
    
    This patch is to remove the typedef sctp_init_chunk_t, and replace
    with struct sctp_init_chunk in the places where it's using this
    typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2393d2ee95c1..07c11fefa8c4 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1298,11 +1298,11 @@ int sctp_has_association(struct net *net, const union sctp_addr *laddr,
 
 int sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,
 		     const struct sctp_association *asoc,
-		     enum sctp_cid cid, sctp_init_chunk_t *peer_init,
+		     enum sctp_cid cid, struct sctp_init_chunk *peer_init,
 		     struct sctp_chunk *chunk, struct sctp_chunk **err_chunk);
 int sctp_process_init(struct sctp_association *, struct sctp_chunk *chunk,
 		      const union sctp_addr *peer,
-		      sctp_init_chunk_t *init, gfp_t gfp);
+		      struct sctp_init_chunk *init, gfp_t gfp);
 __u32 sctp_generate_tag(const struct sctp_endpoint *);
 __u32 sctp_generate_tsn(const struct sctp_endpoint *);
 

commit 3c9187049214127d3401926b033d05eb75d69c39
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jun 30 11:52:16 2017 +0800

    sctp: remove the typedef sctp_paramhdr_t
    
    This patch is to remove the typedef sctp_paramhdr_t, and replace
    with struct sctp_paramhdr in the places where it's using this
    typedef.
    
    It is also to fix some indents and  use sizeof(variable) instead
    of sizeof(type).
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9e9605ecb5c9..2393d2ee95c1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -310,9 +310,10 @@ struct sctp_cookie {
 
 	__u32 adaptation_ind;
 
-	__u8 auth_random[sizeof(sctp_paramhdr_t) + SCTP_AUTH_RANDOM_LENGTH];
+	__u8 auth_random[sizeof(struct sctp_paramhdr) +
+			 SCTP_AUTH_RANDOM_LENGTH];
 	__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS * sizeof(__u16) + 2];
-	__u8 auth_chunks[sizeof(sctp_paramhdr_t) + SCTP_AUTH_MAX_CHUNKS];
+	__u8 auth_chunks[sizeof(struct sctp_paramhdr) + SCTP_AUTH_MAX_CHUNKS];
 
 	/* This is a shim for my peer's INIT packet, followed by
 	 * a copy of the raw address list of the association.

commit 6d85e68f4cde48f8c2fac6d9c00ca6988cf6e327
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jun 30 11:52:14 2017 +0800

    sctp: remove the typedef sctp_cid_t
    
    This patch is to remove the typedef sctp_cid_t, and replace
    with struct sctp_cid in the places where it's using this
    typedef.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e26763bfabd6..9e9605ecb5c9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1297,7 +1297,7 @@ int sctp_has_association(struct net *net, const union sctp_addr *laddr,
 
 int sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,
 		     const struct sctp_association *asoc,
-		     sctp_cid_t, sctp_init_chunk_t *peer_init,
+		     enum sctp_cid cid, sctp_init_chunk_t *peer_init,
 		     struct sctp_chunk *chunk, struct sctp_chunk **err_chunk);
 int sctp_process_init(struct sctp_association *, struct sctp_chunk *chunk,
 		      const union sctp_addr *peer,

commit 5ee8aa689780f2c19702fe3768a3103b9c07d72e
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Jun 20 16:05:11 2017 +0800

    sctp: handle errors when updating asoc
    
    It's a bad thing not to handle errors when updating asoc. The memory
    allocation failure in any of the functions called in sctp_assoc_update()
    would cause sctp to work unexpectedly.
    
    This patch is to fix it by aborting the asoc and reporting the error when
    any of these functions fails.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5051317162df..e26763bfabd6 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1953,8 +1953,8 @@ struct sctp_transport *sctp_assoc_is_match(struct sctp_association *,
 					   const union sctp_addr *,
 					   const union sctp_addr *);
 void sctp_assoc_migrate(struct sctp_association *, struct sock *);
-void sctp_assoc_update(struct sctp_association *old,
-		       struct sctp_association *new);
+int sctp_assoc_update(struct sctp_association *old,
+		      struct sctp_association *new);
 
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 

commit ff356414dc006170153c79434eb81d130c03beec
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed May 31 16:36:32 2017 +0800

    sctp: merge sctp_stream_new and sctp_stream_init
    
    Since last patch, sctp doesn't need to alloc memory for asoc->stream any
    more. sctp_stream_new and sctp_stream_init both are used to alloc memory
    for stream.in or stream.out, and their names are also confusing.
    
    This patch is to merge them into sctp_stream_init, and only pass stream
    and streamcnt parameters into it, instead of the whole asoc.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c8dbf410c4f5..5051317162df 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -377,8 +377,8 @@ typedef struct sctp_sender_hb_info {
 	__u64 hb_nonce;
 } sctp_sender_hb_info_t;
 
-int sctp_stream_new(struct sctp_association *asoc, gfp_t gfp);
-int sctp_stream_init(struct sctp_association *asoc, gfp_t gfp);
+int sctp_stream_init(struct sctp_stream *stream, __u16 outcnt, __u16 incnt,
+		     gfp_t gfp);
 void sctp_stream_free(struct sctp_stream *stream);
 void sctp_stream_clear(struct sctp_stream *stream);
 void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);

commit cee360ab4dd66fc1de33a5fa1cb418fa21c27ce3
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed May 31 16:36:31 2017 +0800

    sctp: define the member stream as an object instead of pointer in asoc
    
    As Marcelo's suggestion, stream is a fixed size member of asoc and would
    not grow with more streams. To avoid an allocation for it, this patch is
    to define it as an object instead of pointer and update the places using
    it, also create sctp_stream_update() called in sctp_assoc_update() to
    migrate the stream info from one stream to another.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a8b38e123f97..c8dbf410c4f5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -381,6 +381,7 @@ int sctp_stream_new(struct sctp_association *asoc, gfp_t gfp);
 int sctp_stream_init(struct sctp_association *asoc, gfp_t gfp);
 void sctp_stream_free(struct sctp_stream *stream);
 void sctp_stream_clear(struct sctp_stream *stream);
+void sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new);
 
 /* What is the current SSN number for this stream? */
 #define sctp_ssn_peek(stream, type, sid) \
@@ -1750,7 +1751,7 @@ struct sctp_association {
 	__u32 default_rcv_context;
 
 	/* Stream arrays */
-	struct sctp_stream *stream;
+	struct sctp_stream stream;
 
 	/* All outbound chunks go through this structure.  */
 	struct sctp_outq outqueue;

commit e4dc99c7c21ba456fd72a70ada5d8d5f3850bcf5
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Apr 15 22:00:27 2017 +0800

    sctp: process duplicated strreset out and addstrm out requests correctly
    
    Now sctp stream reconf will process a request again even if it's seqno is
    less than asoc->strreset_inseq.
    
    If one request has been done successfully and some data chunks have been
    accepted and then a duplicated strreset out request comes, the streamin's
    ssn will be cleared. It will cause that stream will never receive chunks
    any more because of unsynchronized ssn. It allows a replay attack.
    
    A similar issue also exists when processing addstrm out requests. It will
    cause more extra streams being added.
    
    This patch is to fix it by saving the last 2 results into asoc. When a
    duplicated strreset out or addstrm out request is received, reply it with
    bad seqno if it's seqno < asoc->strreset_inseq - 2, and reply it with the
    result saved in asoc if it's seqno >= asoc->strreset_inseq - 2.
    
    Note that it saves last 2 results instead of only last 1 result, because
    two requests can be sent together in one chunk.
    
    And note that when receiving a duplicated request, the receiver side will
    still reply it even if the peer has received the response. It's safe, As
    the response will be dropped by the peer.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b751399aa6b7..a8b38e123f97 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1889,6 +1889,7 @@ struct sctp_association {
 
 	__u32 strreset_outseq; /* Update after receiving response */
 	__u32 strreset_inseq; /* Update after receiving request */
+	__u32 strreset_result[2]; /* save the results of last 2 responses */
 
 	struct sctp_chunk *strreset_chunk; /* save request chunk */
 

commit 6f14f443d3e773439fb9cc6f2685ba90d5d026c5
Merge: faeeb317a561 ea6b1720ce25
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Apr 6 07:25:07 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Mostly simple cases of overlapping changes (adding code nearby,
    a function whose name changes, for example).
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3ebfdf082184d04f6e73b30cd9446613dc7f8c02
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Apr 4 13:39:55 2017 +0800

    sctp: get sock from transport in sctp_transport_update_pmtu
    
    This patch is almost to revert commit 02f3d4ce9e81 ("sctp: Adjust PMTU
    updates to accomodate route invalidation."). As t->asoc can't be NULL
    in sctp_transport_update_pmtu, it could get sk from asoc, and no need
    to pass sk into that function.
    
    It is also to remove some duplicated codes from that function.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a127b7c2c3c9..138f8615acf0 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -952,8 +952,8 @@ void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
 void sctp_transport_burst_limited(struct sctp_transport *);
 void sctp_transport_burst_reset(struct sctp_transport *);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
-void sctp_transport_reset(struct sctp_transport *);
-void sctp_transport_update_pmtu(struct sock *, struct sctp_transport *, u32);
+void sctp_transport_reset(struct sctp_transport *t);
+void sctp_transport_update_pmtu(struct sctp_transport *t, u32 pmtu);
 void sctp_transport_immediate_rtx(struct sctp_transport *);
 void sctp_transport_dst_release(struct sctp_transport *t);
 void sctp_transport_dst_confirm(struct sctp_transport *t);
@@ -1954,7 +1954,7 @@ void sctp_assoc_update(struct sctp_association *old,
 
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
-void sctp_assoc_sync_pmtu(struct sock *, struct sctp_association *);
+void sctp_assoc_sync_pmtu(struct sctp_association *asoc);
 void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);
 void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);
 void sctp_assoc_set_primary(struct sctp_association *,

commit d229d48d183fbc1391908decc7d2bcf09ca2f38f
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Apr 1 17:07:46 2017 +0800

    sctp: add SCTP_PR_STREAM_STATUS sockopt for prsctp
    
    Before when implementing sctp prsctp, SCTP_PR_STREAM_STATUS wasn't
    added, as it needs to save abandoned_(un)sent for every stream.
    
    After sctp stream reconf is added in sctp, assoc has structure
    sctp_stream_out to save per stream info.
    
    This patch is to add SCTP_PR_STREAM_STATUS by putting the prsctp
    per stream statistics into sctp_stream_out.
    
    v1->v2:
      fix an indent issue.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 592decebac75..3e61a54424a1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1315,6 +1315,8 @@ struct sctp_inithdr_host {
 struct sctp_stream_out {
 	__u16	ssn;
 	__u8	state;
+	__u64	abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
+	__u64	abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
 };
 
 struct sctp_stream_in {

commit 3dbcc105d5561e18ccd0842c7baab1c835562a37
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Mar 30 01:00:53 2017 +0800

    sctp: alloc stream info when initializing asoc
    
    When sending a msg without asoc established, sctp will send INIT packet
    first and then enqueue chunks.
    
    Before receiving INIT_ACK, stream info is not yet alloced. But enqueuing
    chunks needs to access stream info, like out stream state and out stream
    cnt.
    
    This patch is to fix it by allocing out stream info when initializing an
    asoc, allocing in stream and re-allocing out stream when processing init.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8caa5ee9e290..a127b7c2c3c9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -377,7 +377,8 @@ typedef struct sctp_sender_hb_info {
 	__u64 hb_nonce;
 } sctp_sender_hb_info_t;
 
-struct sctp_stream *sctp_stream_new(__u16 incnt, __u16 outcnt, gfp_t gfp);
+int sctp_stream_new(struct sctp_association *asoc, gfp_t gfp);
+int sctp_stream_init(struct sctp_association *asoc, gfp_t gfp);
 void sctp_stream_free(struct sctp_stream *stream);
 void sctp_stream_clear(struct sctp_stream *stream);
 

commit f9ba3501d50317697811ff3c48f623f08d616fc8
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Mar 27 00:21:15 2017 +0800

    sctp: change to save MSG_MORE flag into assoc
    
    David Laight noticed the support for MSG_MORE with datamsg->force_delay
    didn't really work as we expected, as the first msg with MSG_MORE set
    would always block the following chunks' dequeuing.
    
    This Patch is to rewrite it by saving the MSG_MORE flag into assoc as
    David Laight suggested.
    
    asoc->force_delay is used to save MSG_MORE flag before a msg is sent.
    All chunks in queue would not be sent out if asoc->force_delay is set
    by the msg with MSG_MORE flag, until a new msg without MSG_MORE flag
    clears asoc->force_delay.
    
    Note that this change would not affect the flush is generated by other
    triggers, like asoc->state != ESTABLISHED, queue size > pmtu etc.
    
    v1->v2:
      Not clear asoc->force_delay after sending the msg with MSG_MORE flag.
    
    Fixes: 4ea0c32f5f42 ("sctp: add support for MSG_MORE")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: David Laight <david.laight@aculab.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 592decebac75..8caa5ee9e290 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -499,7 +499,6 @@ struct sctp_datamsg {
 	/* Did the messenge fail to send? */
 	int send_error;
 	u8 send_failed:1,
-	   force_delay:1,
 	   can_delay;	    /* should this message be Nagle delayed */
 };
 
@@ -1878,6 +1877,7 @@ struct sctp_association {
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1,		/* Is it a temporary association? */
+	     force_delay:1,
 	     prsctp_enable:1,
 	     reconf_enable:1;
 

commit 1511949c61ec63e4b646c34d602ac6990b38ce30
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Mar 20 17:46:27 2017 +0800

    sctp: declare struct sctp_stream before using it
    
    sctp_stream_free uses struct sctp_stream as a param, but struct sctp_stream
    is defined after it's declaration.
    
    This patch is to declare struct sctp_stream before sctp_stream_free.
    
    Fixes: a83863174a61 ("sctp: prepare asoc stream for stream reconf")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4f645198e9bd..592decebac75 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -83,6 +83,7 @@ struct sctp_bind_addr;
 struct sctp_ulpq;
 struct sctp_ep_common;
 struct crypto_shash;
+struct sctp_stream;
 
 
 #include <net/sctp/tsnmap.h>

commit 1f904495b79003cd3d881de8731377d48fcbc7e3
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Mar 18 19:27:23 2017 +0800

    sctp: define dst_pending_confirm as a bit in sctp_transport
    
    As tp->dst_pending_confirm's value can only be set 0 or 1, this
    patch is to change to define it as a bit instead of __u32.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 07a0b128625a..4f645198e9bd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -753,6 +753,8 @@ struct sctp_transport {
 		/* Is the Path MTU update pending on this tranport */
 		pmtu_pending:1,
 
+		dst_pending_confirm:1,	/* need to confirm neighbour */
+
 		/* Has this transport moved the ctsn since we last sacked */
 		sack_generation:1;
 	u32 dst_cookie;
@@ -806,8 +808,6 @@ struct sctp_transport {
 
 	__u32 burst_limited;	/* Holds old cwnd when max.burst is applied */
 
-	__u32 dst_pending_confirm;	/* need to confirm neighbour */
-
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */

commit cdfbabfb2f0ce983fdaa42f20e5f7842178fc01e
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 9 08:09:05 2017 +0000

    net: Work around lockdep limitation in sockets that use sockets
    
    Lockdep issues a circular dependency warning when AFS issues an operation
    through AF_RXRPC from a context in which the VFS/VM holds the mmap_sem.
    
    The theory lockdep comes up with is as follows:
    
     (1) If the pagefault handler decides it needs to read pages from AFS, it
         calls AFS with mmap_sem held and AFS begins an AF_RXRPC call, but
         creating a call requires the socket lock:
    
            mmap_sem must be taken before sk_lock-AF_RXRPC
    
     (2) afs_open_socket() opens an AF_RXRPC socket and binds it.  rxrpc_bind()
         binds the underlying UDP socket whilst holding its socket lock.
         inet_bind() takes its own socket lock:
    
            sk_lock-AF_RXRPC must be taken before sk_lock-AF_INET
    
     (3) Reading from a TCP socket into a userspace buffer might cause a fault
         and thus cause the kernel to take the mmap_sem, but the TCP socket is
         locked whilst doing this:
    
            sk_lock-AF_INET must be taken before mmap_sem
    
    However, lockdep's theory is wrong in this instance because it deals only
    with lock classes and not individual locks.  The AF_INET lock in (2) isn't
    really equivalent to the AF_INET lock in (3) as the former deals with a
    socket entirely internal to the kernel that never sees userspace.  This is
    a limitation in the design of lockdep.
    
    Fix the general case by:
    
     (1) Double up all the locking keys used in sockets so that one set are
         used if the socket is created by userspace and the other set is used
         if the socket is created by the kernel.
    
     (2) Store the kern parameter passed to sk_alloc() in a variable in the
         sock struct (sk_kern_sock).  This informs sock_lock_init(),
         sock_init_data() and sk_clone_lock() as to the lock keys to be used.
    
         Note that the child created by sk_clone_lock() inherits the parent's
         kern setting.
    
     (3) Add a 'kern' parameter to ->accept() that is analogous to the one
         passed in to ->create() that distinguishes whether kernel_accept() or
         sys_accept4() was the caller and can be passed to sk_alloc().
    
         Note that a lot of accept functions merely dequeue an already
         allocated socket.  I haven't touched these as the new socket already
         exists before we get the parameter.
    
         Note also that there are a couple of places where I've made the accepted
         socket unconditionally kernel-based:
    
            irda_accept()
            rds_rcp_accept_one()
            tcp_accept_from_sock()
    
         because they follow a sock_create_kern() and accept off of that.
    
    Whilst creating this, I noticed that lustre and ocfs don't create sockets
    through sock_create_kern() and thus they aren't marked as for-kernel,
    though they appear to be internal.  I wonder if these should do that so
    that they use the new set of lock keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a244db5e5ff7..07a0b128625a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -476,7 +476,8 @@ struct sctp_pf {
 	int  (*send_verify) (struct sctp_sock *, union sctp_addr *);
 	int  (*supported_addrs)(const struct sctp_sock *, __be16 *);
 	struct sock *(*create_accept_sk) (struct sock *sk,
-					  struct sctp_association *asoc);
+					  struct sctp_association *asoc,
+					  bool kern);
 	int (*addr_to_user)(struct sctp_sock *sk, union sctp_addr *addr);
 	void (*to_sk_saddr)(union sctp_addr *, struct sock *sk);
 	void (*to_sk_daddr)(union sctp_addr *, struct sock *sk);

commit 4ea0c32f5f42f7ef33a7ecfb9b61ff0cad9b3c08
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sun Feb 19 01:52:46 2017 +0800

    sctp: add support for MSG_MORE
    
    This patch is to add support for MSG_MORE on sctp.
    
    It adds force_delay in sctp_datamsg to save MSG_MORE, and sets it after
    creating datamsg according to the send flag. sctp_packet_can_append_data
    then uses it to decide if the chunks of this msg will be sent at once or
    delay it.
    
    Note that unlike [1], this patch saves MSG_MORE in datamsg, instead of
    in assoc. As sctp enqueues the chunks first, then dequeue them one by
    one. If it's saved in assoc,the current msg's send flag (MSG_MORE) may
    affect other chunks' bundling.
    
    Since last patch, sctp flush out queue once assoc state falls into
    SHUTDOWN_PENDING, the close block problem mentioned in [1] has been
    solved as well.
    
    [1] https://patchwork.ozlabs.org/patch/372404/
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 387c802bf248..a244db5e5ff7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -497,6 +497,7 @@ struct sctp_datamsg {
 	/* Did the messenge fail to send? */
 	int send_error;
 	u8 send_failed:1,
+	   force_delay:1,
 	   can_delay;	    /* should this message be Nagle delayed */
 };
 

commit 85c727b5948344c8d559e2fda8925e9ddd41c29a
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Feb 7 11:37:56 2017 -0200

    sctp: drop __packed from almost all SCTP structures
    
    __packed is considered harmful as it potentially generates code that
    doesn't perform well and its usage should be avoided as much as
    possible.
    
    This patch drops __packed from all SCTP structures except one, which is
    sctp_signed_cookie. In there it's required, as per changelog on
    commit 9834a2bb4970 ("[SCTP]: Fix sctp_cookie alignment in the packet.").
    
    After this patch, no alignment changes neither in x86 or x86_64 and
    no exceptions were noticed during testing on both archs.
    
    Code size for SCTP module also didn't change with this patch.
    
    Cc: David Miller <davem@davemloft.net>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6a685049f67f..387c802bf248 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -374,7 +374,7 @@ typedef struct sctp_sender_hb_info {
 	union sctp_addr daddr;
 	unsigned long sent_at;
 	__u64 hb_nonce;
-} __packed sctp_sender_hb_info_t;
+} sctp_sender_hb_info_t;
 
 struct sctp_stream *sctp_stream_new(__u16 incnt, __u16 outcnt, gfp_t gfp);
 void sctp_stream_free(struct sctp_stream *stream);

commit c86a773c78025f5b825bacd7b846f4fa60dc0317
Author: Julian Anastasov <ja@ssi.bg>
Date:   Mon Feb 6 23:14:13 2017 +0200

    sctp: add dst_pending_confirm flag
    
    Add new transport flag to allow sockets to confirm neighbour.
    When same struct dst_entry can be used for many different
    neighbours we can not use it for pending confirmations.
    The flag is propagated from transport to every packet.
    It is reset when cached dst is reset.
    
    Reported-by: YueHaibing <yuehaibing@huawei.com>
    Fixes: 5110effee8fd ("net: Do delayed neigh confirmation.")
    Fixes: f2bb4bedf35d ("ipv4: Cache output routes in fib_info nexthops.")
    Signed-off-by: Julian Anastasov <ja@ssi.bg>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 231fa9ac50bd..6a685049f67f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -804,6 +804,8 @@ struct sctp_transport {
 
 	__u32 burst_limited;	/* Holds old cwnd when max.burst is applied */
 
+	__u32 dst_pending_confirm;	/* need to confirm neighbour */
+
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */
@@ -950,6 +952,8 @@ unsigned long sctp_transport_timeout(struct sctp_transport *);
 void sctp_transport_reset(struct sctp_transport *);
 void sctp_transport_update_pmtu(struct sock *, struct sctp_transport *, u32);
 void sctp_transport_immediate_rtx(struct sctp_transport *);
+void sctp_transport_dst_release(struct sctp_transport *t);
+void sctp_transport_dst_confirm(struct sctp_transport *t);
 
 
 /* This is the structure we use to queue packets as they come into

commit 7f9d68ac944e24ee5f9ac8d059ca00b1c1d34137
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Jan 18 00:44:47 2017 +0800

    sctp: implement sender-side procedures for SSN Reset Request Parameter
    
    This patch is to implement sender-side procedures for the Outgoing
    and Incoming SSN Reset Request Parameter described in rfc6525 section
    5.1.2 and 5.1.3.
    
    It is also add sockopt SCTP_RESET_STREAMS in rfc6525 section 6.3.2
    for users.
    
    Note that the new asoc member strreset_outstanding is to make sure
    only one reconf request chunk on the fly as rfc6525 section 5.1.1
    demands.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d99b76e33b2e..231fa9ac50bd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1875,6 +1875,7 @@ struct sctp_association {
 	     reconf_enable:1;
 
 	__u8 strreset_enable;
+	__u8 strreset_outstanding; /* request param count on the fly */
 
 	__u32 strreset_outseq; /* Update after receiving response */
 	__u32 strreset_inseq; /* Update after receiving request */

commit 9fb657aec0e20b4ed4401c44a4140f8d7b7a9ca0
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Jan 18 00:44:46 2017 +0800

    sctp: add sockopt SCTP_ENABLE_STREAM_RESET
    
    This patch is to add sockopt SCTP_ENABLE_STREAM_RESET to get/set
    strreset_enable to indicate which reconf request type it supports,
    which is described in rfc6525 section 6.3.1.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ee037ef15d65..d99b76e33b2e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1257,6 +1257,8 @@ struct sctp_endpoint {
 	__u8  auth_enable:1,
 	      prsctp_enable:1,
 	      reconf_enable:1;
+
+	__u8  strreset_enable;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1872,6 +1874,8 @@ struct sctp_association {
 	     prsctp_enable:1,
 	     reconf_enable:1;
 
+	__u8 strreset_enable;
+
 	__u32 strreset_outseq; /* Update after receiving response */
 	__u32 strreset_inseq; /* Update after receiving request */
 

commit c28445c3cb07ba1da2c1dc7b5f3066c686a6acc6
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Jan 18 00:44:45 2017 +0800

    sctp: add reconf_enable in asoc ep and netns
    
    This patch is to add reconf_enable field in all of asoc ep and netns
    to indicate if they support stream reset.
    
    When initializing, asoc reconf_enable get the default value from ep
    reconf_enable which is from netns netns reconf_enable by default.
    
    It is also to add reconf_capable in asoc peer part to know if peer
    supports reconf_enable, the value is set if ext params have reconf
    chunk support when processing init chunk, just as rfc6525 section
    5.1.1 demands.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 463b4d642d68..ee037ef15d65 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1255,7 +1255,8 @@ struct sctp_endpoint {
 	struct list_head endpoint_shared_keys;
 	__u16 active_key_id;
 	__u8  auth_enable:1,
-	      prsctp_enable:1;
+	      prsctp_enable:1,
+	      reconf_enable:1;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1508,6 +1509,7 @@ struct sctp_association {
 			hostname_address:1, /* Peer understands DNS addresses? */
 			asconf_capable:1,   /* Does peer support ADDIP? */
 			prsctp_capable:1,   /* Can peer do PR-SCTP? */
+			reconf_capable:1,   /* Can peer do RE-CONFIG? */
 			auth_capable:1;     /* Is peer doing SCTP-AUTH? */
 
 		/* sack_needed : This flag indicates if the next received
@@ -1867,7 +1869,8 @@ struct sctp_association {
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1,		/* Is it a temporary association? */
-	     prsctp_enable:1;
+	     prsctp_enable:1,
+	     reconf_enable:1;
 
 	__u32 strreset_outseq; /* Update after receiving response */
 	__u32 strreset_inseq; /* Update after receiving request */

commit 7b9438de0cd4b46a6914416bfede6cf839cd9e68
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Jan 18 00:44:43 2017 +0800

    sctp: add stream reconf timer
    
    This patch is to add a per transport timer based on sctp timer frame
    for stream reconf chunk retransmission. It would start after sending
    a reconf request chunk, and stop after receiving the response chunk.
    
    If the timer expires, besides retransmitting the reconf request chunk,
    it would also do the same thing with data RTO timer. like to increase
    the appropriate error counts, and perform threshold management, possibly
    destroying the asoc if sctp retransmission thresholds are exceeded, just
    as section 5.1.1 describes.
    
    This patch is also to add asoc strreset_chunk, it is used to save the
    reconf request chunk, so that it can be retransmitted, and to check if
    the response is really for this request by comparing the information
    inside with the response chunk as well.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 3dc983e97564..463b4d642d68 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -877,6 +877,9 @@ struct sctp_transport {
 	/* Timer to handle ICMP proto unreachable envets */
 	struct timer_list proto_unreach_timer;
 
+	/* Timer to handler reconf chunk rtx */
+	struct timer_list reconf_timer;
+
 	/* Since we're using per-destination retransmission timers
 	 * (see above), we're also using per-destination "transmitted"
 	 * queues.  This probably ought to be a private struct
@@ -935,6 +938,7 @@ void sctp_transport_pmtu(struct sctp_transport *, struct sock *sk);
 void sctp_transport_free(struct sctp_transport *);
 void sctp_transport_reset_t3_rtx(struct sctp_transport *);
 void sctp_transport_reset_hb_timer(struct sctp_transport *);
+void sctp_transport_reset_reconf_timer(struct sctp_transport *transport);
 int sctp_transport_hold(struct sctp_transport *);
 void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);
@@ -1868,6 +1872,8 @@ struct sctp_association {
 	__u32 strreset_outseq; /* Update after receiving response */
 	__u32 strreset_inseq; /* Update after receiving request */
 
+	struct sctp_chunk *strreset_chunk; /* save request chunk */
+
 	struct sctp_priv_assoc_stats stats;
 
 	int sent_cnt_removable;

commit cc16f00f6529aa2378f2b949a6f68e9dc6dec363
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Jan 18 00:44:42 2017 +0800

    sctp: add support for generating stream reconf ssn reset request chunk
    
    This patch is to add asoc strreset_outseq and strreset_inseq for
    saving the reconf request sequence, initialize them when create
    assoc and process init, and also to define Incoming and Outgoing
    SSN Reset Request Parameter described in rfc6525 section 4.1 and
    4.2, As they can be in one same chunk as section rfc6525 3.1-3
    describes, it makes them in one function.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4741ec240caf..3dc983e97564 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1865,6 +1865,9 @@ struct sctp_association {
 	     temp:1,		/* Is it a temporary association? */
 	     prsctp_enable:1;
 
+	__u32 strreset_outseq; /* Update after receiving response */
+	__u32 strreset_inseq; /* Update after receiving request */
+
 	struct sctp_priv_assoc_stats stats;
 
 	int sent_cnt_removable;

commit a83863174a6137fb3e03f279c9dcdba9e35315d0
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jan 6 22:18:33 2017 +0800

    sctp: prepare asoc stream for stream reconf
    
    sctp stream reconf, described in RFC 6525, needs a structure to
    save per stream information in assoc, like stream state.
    
    In the future, sctp stream scheduler also needs it to save some
    stream scheduler params and queues.
    
    This patchset is to prepare the stream array in assoc for stream
    reconf. It defines sctp_stream that includes stream arrays inside
    to replace ssnmap.
    
    Note that we use different structures for IN and OUT streams, as
    the members in per OUT stream will get more and more different
    from per IN stream.
    
    v1->v2:
      - put these patches into a smaller group.
    v2->v3:
      - define sctp_stream to contain stream arrays, and create stream.c
        to put stream-related functions.
      - merge 3 patches into 1, as new sctp_stream has the same name
        with before.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 87d56cc80a3c..4741ec240caf 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -82,7 +82,6 @@ struct sctp_outq;
 struct sctp_bind_addr;
 struct sctp_ulpq;
 struct sctp_ep_common;
-struct sctp_ssnmap;
 struct crypto_shash;
 
 
@@ -377,54 +376,22 @@ typedef struct sctp_sender_hb_info {
 	__u64 hb_nonce;
 } __packed sctp_sender_hb_info_t;
 
-/*
- *  RFC 2960 1.3.2 Sequenced Delivery within Streams
- *
- *  The term "stream" is used in SCTP to refer to a sequence of user
- *  messages that are to be delivered to the upper-layer protocol in
- *  order with respect to other messages within the same stream.  This is
- *  in contrast to its usage in TCP, where it refers to a sequence of
- *  bytes (in this document a byte is assumed to be eight bits).
- *  ...
- *
- *  This is the structure we use to track both our outbound and inbound
- *  SSN, or Stream Sequence Numbers.
- */
-
-struct sctp_stream {
-	__u16 *ssn;
-	unsigned int len;
-};
-
-struct sctp_ssnmap {
-	struct sctp_stream in;
-	struct sctp_stream out;
-};
-
-struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out,
-				    gfp_t gfp);
-void sctp_ssnmap_free(struct sctp_ssnmap *map);
-void sctp_ssnmap_clear(struct sctp_ssnmap *map);
+struct sctp_stream *sctp_stream_new(__u16 incnt, __u16 outcnt, gfp_t gfp);
+void sctp_stream_free(struct sctp_stream *stream);
+void sctp_stream_clear(struct sctp_stream *stream);
 
 /* What is the current SSN number for this stream? */
-static inline __u16 sctp_ssn_peek(struct sctp_stream *stream, __u16 id)
-{
-	return stream->ssn[id];
-}
+#define sctp_ssn_peek(stream, type, sid) \
+	((stream)->type[sid].ssn)
 
 /* Return the next SSN number for this stream.	*/
-static inline __u16 sctp_ssn_next(struct sctp_stream *stream, __u16 id)
-{
-	return stream->ssn[id]++;
-}
+#define sctp_ssn_next(stream, type, sid) \
+	((stream)->type[sid].ssn++)
 
 /* Skip over this ssn and all below. */
-static inline void sctp_ssn_skip(struct sctp_stream *stream, __u16 id, 
-				 __u16 ssn)
-{
-	stream->ssn[id] = ssn+1;
-}
-              
+#define sctp_ssn_skip(stream, type, sid, ssn) \
+	((stream)->type[sid].ssn = ssn + 1)
+
 /*
  * Pointers to address related SCTP functions.
  * (i.e. things that depend on the address family.)
@@ -1331,6 +1298,25 @@ struct sctp_inithdr_host {
 	__u32 initial_tsn;
 };
 
+struct sctp_stream_out {
+	__u16	ssn;
+	__u8	state;
+};
+
+struct sctp_stream_in {
+	__u16	ssn;
+};
+
+struct sctp_stream {
+	struct sctp_stream_out *out;
+	struct sctp_stream_in *in;
+	__u16 outcnt;
+	__u16 incnt;
+};
+
+#define SCTP_STREAM_CLOSED		0x00
+#define SCTP_STREAM_OPEN		0x01
+
 /* SCTP_GET_ASSOC_STATS counters */
 struct sctp_priv_assoc_stats {
 	/* Maximum observed rto in the association during subsequent
@@ -1746,8 +1732,8 @@ struct sctp_association {
 	/* Default receive parameters */
 	__u32 default_rcv_context;
 
-	/* This tracks outbound ssn for a given stream.	 */
-	struct sctp_ssnmap *ssnmap;
+	/* Stream arrays */
+	struct sctp_stream *stream;
 
 	/* All outbound chunks go through this structure.  */
 	struct sctp_outq outqueue;

commit 66b91d2cd0344c417194596ef6e387e52be69e57
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Dec 28 09:26:34 2016 -0200

    sctp: remove return value from sctp_packet_init/config
    
    There is no reason to use this cascading. It doesn't add anything.
    Let's remove it and simplify.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 92daabdc007d..87d56cc80a3c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -722,10 +722,9 @@ struct sctp_packet {
 	    ipfragok:1;		/* So let ip fragment this packet */
 };
 
-struct sctp_packet *sctp_packet_init(struct sctp_packet *,
-				     struct sctp_transport *,
-				     __u16 sport, __u16 dport);
-struct sctp_packet *sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
+void sctp_packet_init(struct sctp_packet *, struct sctp_transport *,
+		      __u16 sport, __u16 dport);
+void sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
 sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *,
 				       struct sctp_chunk *, int, gfp_t);
 sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *,

commit 7fda702f9315e6f4a74fee155c540750788a2d66
Author: Xin Long <lucien.xin@gmail.com>
Date:   Tue Nov 15 23:23:11 2016 +0800

    sctp: use new rhlist interface on sctp transport rhashtable
    
    Now sctp transport rhashtable uses hash(lport, dport, daddr) as the key
    to hash a node to one chain. If in one host thousands of assocs connect
    to one server with the same lport and different laddrs (although it's
    not a normal case), all the transports would be hashed into the same
    chain.
    
    It may cause to keep returning -EBUSY when inserting a new node, as the
    chain is too long and sctp inserts a transport node in a loop, which
    could even lead to system hangs there.
    
    The new rhlist interface works for this case that there are many nodes
    with the same key in one chain. It puts them into a list then makes this
    list be as a node of the chain.
    
    This patch is to replace rhashtable_ interface with rhltable_ interface.
    Since a chain would not be too long and it would not return -EBUSY with
    this fix when inserting a node, the reinsert loop is also removed here.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index bd4a3ded7c87..92daabdc007d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -124,7 +124,7 @@ extern struct sctp_globals {
 	/* This is the sctp port control hash.	*/
 	struct sctp_bind_hashbucket *port_hashtable;
 	/* This is the hash of all transports. */
-	struct rhashtable transport_hashtable;
+	struct rhltable transport_hashtable;
 
 	/* Sizes of above hashtables. */
 	int ep_hashsize;
@@ -761,7 +761,7 @@ static inline int sctp_packet_empty(struct sctp_packet *packet)
 struct sctp_transport {
 	/* A list of transports. */
 	struct list_head transports;
-	struct rhash_head node;
+	struct rhlist_head node;
 
 	/* Reference counting. */
 	atomic_t refcnt;

commit 8ae808eb853e3789b81b8a502cdf22bb01b76880
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Oct 8 11:40:16 2016 +0800

    sctp: remove the old ttl expires policy
    
    The prsctp polices include ttl expires policy already, we should remove
    the old ttl expires codes, and just adjust the new polices' codes to be
    compatible with the old one for users.
    
    This patch is to remove all the old expires codes, and if prsctp polices
    are not set, it will still set msg's expires_at and check the expires in
    sctp_check_abandoned.
    
    Note that asoc->prsctp_enable is set by default, so users can't feel any
    difference even if they use the old expires api in userspace.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 27a933e4c90e..bd4a3ded7c87 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -530,7 +530,6 @@ struct sctp_datamsg {
 	/* Did the messenge fail to send? */
 	int send_error;
 	u8 send_failed:1,
-	   can_abandon:1,   /* can chunks from this message can be abandoned. */
 	   can_delay;	    /* should this message be Nagle delayed */
 };
 

commit cc6ac9bccf6b9814d37932e86a92f8e6a92960dc
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Oct 8 11:36:05 2016 +0800

    sctp: reuse sent_count to avoid retransmitted chunks for RTT measurements
    
    Now sctp uses chunk->resent to record if a chunk is retransmitted, for
    RTT measurements with retransmitted DATA chunks. chunk->sent_count was
    introduced to record how many times one chunk has been sent for prsctp
    RTX policy before. We actually can know if one chunk is retransmitted
    by checking chunk->sent_count is greater than 1.
    
    This patch is to remove resent from sctp_chunk and reuse sent_count
    to avoid retransmitted chunks for RTT measurements.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 11c3bf262a85..27a933e4c90e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -641,7 +641,6 @@ struct sctp_chunk {
 #define SCTP_NEED_FRTX 0x1
 #define SCTP_DONT_FRTX 0x2
 	__u16	rtt_in_progress:1,	/* This chunk used for RTT calc? */
-		resent:1,		/* Has this chunk ever been resent. */
 		has_tsn:1,		/* Does this chunk have a TSN yet? */
 		has_ssn:1,		/* Does this chunk have a SSN yet? */
 		singleton:1,		/* Only chunk in the packet? */
@@ -656,6 +655,7 @@ struct sctp_chunk {
 		fast_retransmit:2;	/* Is this chunk fast retransmitted? */
 };
 
+#define sctp_chunk_retransmitted(chunk)	(chunk->sent_count > 1)
 void sctp_chunk_hold(struct sctp_chunk *);
 void sctp_chunk_put(struct sctp_chunk *);
 int sctp_user_addto_chunk(struct sctp_chunk *chunk, int len,

commit b50afd203a5ef1998c18d6519ad2b2c546d6af22
Merge: d6169b0206db c8d2bc9bc39e
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Oct 2 21:17:07 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Three sets of overlapping changes.  Nothing serious.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0605483f6ace1f6b63e397c819a115ddcd13af0d
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Sep 29 02:37:27 2016 +0800

    sctp: remove prsctp_param from sctp_chunk
    
    Now sctp uses chunk->prsctp_param to save the prsctp param for all the
    prsctp polices, we didn't need to introduce prsctp_param to sctp_chunk.
    We can just use chunk->sinfo.sinfo_timetolive for RTX and BUF polices,
    and reuse msg->expires_at for TTL policy, as the prsctp polices and old
    expires policy are mutual exclusive.
    
    This patch is to remove prsctp_param from sctp_chunk, and reuse msg's
    expires_at for TTL and chunk's sinfo.sinfo_timetolive for RTX and BUF
    polices.
    
    Note that sctp can't use chunk's sinfo.sinfo_timetolive for TTL policy,
    as it needs a u64 variables to save the expires_at time.
    
    This one also fixes the "netperf-Throughput_Mbps -37.2% regression"
    issue.
    
    Fixes: a6c2f792873a ("sctp: implement prsctp TTL policy")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4f097f538fff..ced0df374e60 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -606,13 +606,6 @@ struct sctp_chunk {
 	/* This needs to be recoverable for SCTP_SEND_FAILED events. */
 	struct sctp_sndrcvinfo sinfo;
 
-	/* We use this field to record param for prsctp policies,
-	 * for TTL policy, it is the time_to_drop of this chunk,
-	 * for RTX policy, it is the max_sent_count of this chunk,
-	 * for PRIO policy, it is the priority of this chunk.
-	 */
-	unsigned long prsctp_param;
-
 	/* Which association does this belong to?  */
 	struct sctp_association *asoc;
 

commit 73dca124cdbad2d67d47d6196c08325f18447d07
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Sep 29 02:37:26 2016 +0800

    sctp: move sent_count to the memory hole in sctp_chunk
    
    Now pahole sctp_chunk, it has 2 memory holes:
       struct sctp_chunk {
            struct list_head           list;
            atomic_t                   refcnt;
            /* XXX 4 bytes hole, try to pack */
            ...
            long unsigned int          prsctp_param;
            int                        sent_count;
            /* XXX 4 bytes hole, try to pack */
    
    This patch is to move up sent_count to fill the 1st one and eliminate
    the 2nd one.
    
    It's not just another struct compaction, it also fixes the "netperf-
    Throughput_Mbps -37.2% regression" issue when overloading the CPU.
    
    Fixes: a6c2f792873a ("sctp: implement prsctp TTL policy")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ce93c4b10d26..4f097f538fff 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -554,6 +554,9 @@ struct sctp_chunk {
 
 	atomic_t refcnt;
 
+	/* How many times this chunk have been sent, for prsctp RTX policy */
+	int sent_count;
+
 	/* This is our link to the per-transport transmitted list.  */
 	struct list_head transmitted_list;
 
@@ -610,9 +613,6 @@ struct sctp_chunk {
 	 */
 	unsigned long prsctp_param;
 
-	/* How many times this chunk have been sent, for prsctp RTX policy */
-	int sent_count;
-
 	/* Which association does this belong to?  */
 	struct sctp_association *asoc;
 

commit 83dbc3d4a38411ef38f680d7045c8478cc9c5a56
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Sep 14 02:04:22 2016 +0800

    sctp: make sctp_outq_flush/tail/uncork return void
    
    sctp_outq_flush return value is meaningless now, this patch is
    to make sctp_outq_flush return void, as well as sctp_outq_fail
    and sctp_outq_uncork.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f61fb7c87e53..8693dc452a7f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1077,7 +1077,7 @@ struct sctp_outq {
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
 void sctp_outq_teardown(struct sctp_outq *);
 void sctp_outq_free(struct sctp_outq*);
-int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);
+void sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);
 int sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);
@@ -1085,7 +1085,7 @@ void sctp_outq_restart(struct sctp_outq *);
 void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
 		     sctp_retransmit_reason_t);
 void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
-int sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
+void sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
 void sctp_prsctp_prune(struct sctp_association *asoc,
 		       struct sctp_sndrcvinfo *sinfo, int msg_len);
 /* Uncork and flush an outqueue.  */

commit b61c654f9b3f1a271217e46c893f80565b1f754d
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Sep 14 02:04:20 2016 +0800

    sctp: free msg->chunks when sctp_primitive_SEND return err
    
    Last patch "sctp: do not return the transmit err back to sctp_sendmsg"
    made sctp_primitive_SEND return err only when asoc state is unavailable.
    In this case, chunks are not enqueued, they have no chance to be freed if
    we don't take care of them later.
    
    This Patch is actually to revert commit 1cd4d5c4326a ("sctp: remove the
    unused sctp_datamsg_free()"), commit 69b5777f2e57 ("sctp: hold the chunks
    only after the chunk is enqueued in outq") and commit 8b570dc9f7b6 ("sctp:
    only drop the reference on the datamsg after sending a msg"), to use
    sctp_datamsg_free to free the chunks of current msg.
    
    Fixes: 8b570dc9f7b6 ("sctp: only drop the reference on the datamsg after sending a msg")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ce93c4b10d26..f61fb7c87e53 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -537,6 +537,7 @@ struct sctp_datamsg {
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
 					    struct sctp_sndrcvinfo *,
 					    struct iov_iter *);
+void sctp_datamsg_free(struct sctp_datamsg *);
 void sctp_datamsg_put(struct sctp_datamsg *);
 void sctp_chunk_fail(struct sctp_chunk *, int error);
 int sctp_chunk_abandoned(struct sctp_chunk *);

commit e7487c86dc5c4a528a7dbd9dc14f453a0de61a84
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Jul 13 15:08:58 2016 -0300

    sctp: avoid identifying address family many times for a chunk
    
    Identifying address family operations during rx path is not something
    expensive but it's ugly to the eye to have it done multiple times,
    specially when we already validated it during initial rx processing.
    
    This patch takes advantage of the now shared sctp_input_cb and make the
    pointer to the operations readily available.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f6f201de6fa4..ce93c4b10d26 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1104,6 +1104,7 @@ struct sctp_input_cb {
 #endif
 	} header;
 	struct sctp_chunk *chunk;
+	struct sctp_af *af;
 };
 #define SCTP_INPUT_CB(__skb)	((struct sctp_input_cb *)&((__skb)->cb[0]))
 

commit 1f45f78f8e511203f03138f2ccde3d2cf90d2cbf
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Jul 13 15:08:57 2016 -0300

    sctp: allow GSO frags to access the chunk too
    
    SCTP will try to access original IP headers on sctp_recvmsg in order to
    copy the addresses used. There are also other places that do similar access
    to IP or even SCTP headers. But after 90017accff61 ("sctp: Add GSO
    support") they aren't always there because they are only present in the
    header skb.
    
    SCTP handles the queueing of incoming data by cloning the incoming skb
    and limiting to only the relevant payload. This clone has its cb updated
    to something different and it's then queued on socket rx queue. Thus we
    need to fix this in two moments.
    
    For rx path, not related to socket queue yet, this patch uses a
    partially copied sctp_input_cb to such GSO frags. This restores the
    ability to access the headers for this part of the code.
    
    Regarding the socket rx queue, it removes iif member from sctp_event and
    also add a chunk pointer on it.
    
    With these changes we're always able to reach the headers again.
    
    The biggest change here is that now the sctp_chunk struct and the
    original skb are only freed after the application consumed the buffer.
    Note however that the original payload was already like this due to the
    skb cloning.
    
    For iif, SCTP's IPv4 code doesn't use it, so no change is necessary.
    IPv6 now can fetch it directly from original's IPv6 CB as the original
    skb is still accessible.
    
    In the future we probably can simplify sctp_v*_skb_iif() stuff, as
    sctp_v4_skb_iif() was called but it's return value not used, and now
    it's not even called, but such cleanup is out of scope for this change.
    
    Fixes: 90017accff61 ("sctp: Add GSO support")
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 966c3a40039c..f6f201de6fa4 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1107,6 +1107,13 @@ struct sctp_input_cb {
 };
 #define SCTP_INPUT_CB(__skb)	((struct sctp_input_cb *)&((__skb)->cb[0]))
 
+static inline const struct sk_buff *sctp_gso_headskb(const struct sk_buff *skb)
+{
+	const struct sctp_chunk *chunk = SCTP_INPUT_CB(skb)->chunk;
+
+	return chunk->head_skb ? : skb;
+}
+
 /* These bind address data fields common between endpoints and associations */
 struct sctp_bind_addr {
 

commit 9e238323799fb8c2add2b1de9a22edd4d4e51e30
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Jul 13 15:08:55 2016 -0300

    sctp: allow others to use sctp_input_cb
    
    We process input path in other files too and having access to it is
    nice, so move it to a header where it's shared.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8626bdd3249a..966c3a40039c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -59,6 +59,7 @@
 #include <linux/workqueue.h>	/* We need tq_struct.	 */
 #include <linux/sctp.h>		/* We need sctp* header structs.  */
 #include <net/sctp/auth.h>	/* We need auth specific structs */
+#include <net/ip.h>		/* For inet_skb_parm */
 
 /* A convenience structure for handling sockaddr structures.
  * We should wean ourselves off this.
@@ -1092,6 +1093,20 @@ static inline void sctp_outq_cork(struct sctp_outq *q)
 	q->cork = 1;
 }
 
+/* SCTP skb control block.
+ * sctp_input_cb is currently used on rx and sock rx queue
+ */
+struct sctp_input_cb {
+	union {
+		struct inet_skb_parm	h4;
+#if IS_ENABLED(CONFIG_IPV6)
+		struct inet6_skb_parm	h6;
+#endif
+	} header;
+	struct sctp_chunk *chunk;
+};
+#define SCTP_INPUT_CB(__skb)	((struct sctp_input_cb *)&((__skb)->cb[0]))
+
 /* These bind address data fields common between endpoints and associations */
 struct sctp_bind_addr {
 

commit 8dbdf1f5b09cb22560e7c7173b52fe3c631046bd
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Jul 9 19:47:45 2016 +0800

    sctp: implement prsctp PRIO policy
    
    prsctp PRIO policy is a policy to abandon lower priority chunks when
    asoc doesn't have enough snd buffer, so that the current chunk with
    higher priority can be queued successfully.
    
    Similar to TTL/RTX policy, we will set the priority of the chunk to
    prsctp_param with sinfo->sinfo_timetolive in sctp_set_prsctp_policy().
    So if PRIO policy is enabled, msg->expire_at won't work.
    
    asoc->sent_cnt_removable will record how many chunks can be checked to
    remove. If priority policy is enabled, when the chunk is queued into
    the out_queue, we will increase sent_cnt_removable. When the chunk is
    moved to abandon_queue or dequeue and free, we will decrease
    sent_cnt_removable.
    
    In sctp_sendmsg, we will check if there is enough snd buffer for current
    msg and if sent_cnt_removable is not 0. Then try to abandon chunks in
    sctp_prune_prsctp when sendmsg from the retransmit/transmited queue, and
    free chunks from out_queue in right order until the abandon+free size >
    msg_len - sctp_wfree. For the abandon size, we have to wait until it
    sends FORWARD TSN, receives the sack and the chunks are really freed.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6bcda715008e..8626bdd3249a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1084,6 +1084,8 @@ void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
 		     sctp_retransmit_reason_t);
 void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
 int sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
+void sctp_prsctp_prune(struct sctp_association *asoc,
+		       struct sctp_sndrcvinfo *sinfo, int msg_len);
 /* Uncork and flush an outqueue.  */
 static inline void sctp_outq_cork(struct sctp_outq *q)
 {
@@ -1864,6 +1866,8 @@ struct sctp_association {
 
 	struct sctp_priv_assoc_stats stats;
 
+	int sent_cnt_removable;
+
 	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
 	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
 };

commit a6c2f792873aff332a4689717c3cd6104f46684c
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Jul 9 19:47:43 2016 +0800

    sctp: implement prsctp TTL policy
    
    prsctp TTL policy is a policy to abandon chunks when they expire
    at the specific time in local stack. It's similar with expires_at
    in struct sctp_datamsg.
    
    This patch uses sinfo->sinfo_timetolive to set the specific time for
    TTL policy. sinfo->sinfo_timetolive is also used for msg->expires_at.
    So if prsctp_enable or TTL policy is not enabled, msg->expires_at
    still works as before.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d8e464aacb20..6bcda715008e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -602,6 +602,16 @@ struct sctp_chunk {
 	/* This needs to be recoverable for SCTP_SEND_FAILED events. */
 	struct sctp_sndrcvinfo sinfo;
 
+	/* We use this field to record param for prsctp policies,
+	 * for TTL policy, it is the time_to_drop of this chunk,
+	 * for RTX policy, it is the max_sent_count of this chunk,
+	 * for PRIO policy, it is the priority of this chunk.
+	 */
+	unsigned long prsctp_param;
+
+	/* How many times this chunk have been sent, for prsctp RTX policy */
+	int sent_count;
+
 	/* Which association does this belong to?  */
 	struct sctp_association *asoc;
 

commit 826d253d57b11f69add81c8086d2e7f1dce5ec77
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Jul 9 19:47:42 2016 +0800

    sctp: add SCTP_PR_ASSOC_STATUS on sctp sockopt
    
    This patch adds SCTP_PR_ASSOC_STATUS to sctp sockopt, which is used
    to dump the prsctp statistics info from the asoc. The prsctp statistics
    includes abandoned_sent/unsent from the asoc. abandoned_sent is the
    count of the packets we drop packets from retransmit/transmited queue,
    and abandoned_unsent is the count of the packets we drop from out_queue
    according to the policy.
    
    Note: another option for prsctp statistics dump described in rfc is
    SCTP_PR_STREAM_STATUS, which is used to dump the prsctp statistics
    info from each stream. But by now, linux doesn't yet have per stream
    statistics info, it needs rfc6525 to be implemented. As the prsctp
    statistics for each stream has to be based on per stream statistics,
    we will delay it until rfc6525 is done in linux.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 07115ca9de4d..d8e464aacb20 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1853,6 +1853,9 @@ struct sctp_association {
 	     prsctp_enable:1;
 
 	struct sctp_priv_assoc_stats stats;
+
+	__u64 abandoned_unsent[SCTP_PR_INDEX(MAX) + 1];
+	__u64 abandoned_sent[SCTP_PR_INDEX(MAX) + 1];
 };
 
 

commit 28aa4c26fce2202db8d42ae76b639ca1d9a23d25
Author: Xin Long <lucien.xin@gmail.com>
Date:   Sat Jul 9 19:47:40 2016 +0800

    sctp: add SCTP_PR_SUPPORTED on sctp sockopt
    
    According to section 4.5 of rfc7496, prsctp_enable should be per asoc.
    We will add prsctp_enable to both asoc and ep, and replace the places
    where it used net.sctp->prsctp_enable with asoc->prsctp_enable.
    
    ep->prsctp_enable will be initialized with net.sctp->prsctp_enable, and
    asoc->prsctp_enable will be initialized with ep->prsctp_enable. We can
    also modify it's value through sockopt SCTP_PR_SUPPORTED.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 83c5ec58b93a..07115ca9de4d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1256,7 +1256,8 @@ struct sctp_endpoint {
 	/* SCTP-AUTH: endpoint shared keys */
 	struct list_head endpoint_shared_keys;
 	__u16 active_key_id;
-	__u8  auth_enable;
+	__u8  auth_enable:1,
+	      prsctp_enable:1;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1848,7 +1849,8 @@ struct sctp_association {
 	__u16 active_key_id;
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
-	     temp:1;		/* Is it a temporary association? */
+	     temp:1,		/* Is it a temporary association? */
+	     prsctp_enable:1;
 
 	struct sctp_priv_assoc_stats stats;
 };

commit 90017accff61ae89283ad9a51f9ac46ca01633fb
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Thu Jun 2 15:05:43 2016 -0300

    sctp: Add GSO support
    
    SCTP has this pecualiarity that its packets cannot be just segmented to
    (P)MTU. Its chunks must be contained in IP segments, padding respected.
    So we can't just generate a big skb, set gso_size to the fragmentation
    point and deliver it to IP layer.
    
    This patch takes a different approach. SCTP will now build a skb as it
    would be if it was received using GRO. That is, there will be a cover
    skb with protocol headers and children ones containing the actual
    segments, already segmented to a way that respects SCTP RFCs.
    
    With that, we can tell skb_segment() to just split based on frag_list,
    trusting its sizes are already in accordance.
    
    This way SCTP can benefit from GSO and instead of passing several
    packets through the stack, it can pass a single large packet.
    
    v2:
    - Added support for receiving GSO frames, as requested by Dave Miller.
    - Clear skb->cb if packet is GSO (otherwise it's not used by SCTP)
    - Added heuristics similar to what we have in TCP for not generating
      single GSO packets that fills cwnd.
    v3:
    - consider sctphdr size in skb_gso_transport_seglen()
    - rebased due to 5c7cdf339af5 ("gso: Remove arbitrary checks for
      unsupported GSO")
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Tested-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 16b013a6191c..83c5ec58b93a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -566,6 +566,9 @@ struct sctp_chunk {
 	/* This points to the sk_buff containing the actual data.  */
 	struct sk_buff *skb;
 
+	/* In case of GSO packets, this will store the head one */
+	struct sk_buff *head_skb;
+
 	/* These are the SCTP headers by reverse order in a packet.
 	 * Note that some of these may happen more than once.  In that
 	 * case, we point at the "current" one, whatever that means
@@ -696,6 +699,8 @@ struct sctp_packet {
 	size_t overhead;
 	/* This is the total size of all chunks INCLUDING padding.  */
 	size_t size;
+	/* This is the maximum size this packet may have */
+	size_t max_size;
 
 	/* The packet is destined for this transport address.
 	 * The function we finally use to pass down to the next lower

commit 0970f5b3665933f5f0d069607c78fb10bd918b62
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Fri Apr 29 14:17:08 2016 -0300

    sctp: signal sk_data_ready earlier on data chunks reception
    
    Dave Miller pointed out that fb586f25300f ("sctp: delay calls to
    sk_data_ready() as much as possible") may insert latency specially if
    the receiving application is running on another CPU and that it would be
    better if we signalled as early as possible.
    
    This patch thus basically inverts the logic on fb586f25300f and signals
    it as early as possible, similar to what we had before.
    
    Fixes: fb586f25300f ("sctp: delay calls to sk_data_ready() as much as possible")
    Reported-by: Dave Miller <davem@davemloft.net>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 558bae3cbe0d..16b013a6191c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -218,7 +218,7 @@ struct sctp_sock {
 		frag_interleave:1,
 		recvrcvinfo:1,
 		recvnxtinfo:1,
-		pending_data_ready:1;
+		data_ready_signalled:1;
 
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */

commit 1602f49b58abcb0d34a5f0a29d68e7c1769547aa
Merge: 22d37b6b0058 5f44abd041c5
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Apr 23 18:26:24 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts were two cases of simple overlapping changes,
    nothing serious.
    
    In the UDP case, we need to add a hlist_add_tail_rcu()
    to linux/rculist.h, because we've moved UDP socket handling
    away from using nulls lists.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit fb586f25300f4587c7ebd097a604bf269b25bfa7
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Fri Apr 8 16:41:28 2016 -0300

    sctp: delay calls to sk_data_ready() as much as possible
    
    Currently processing of multiple chunks in a single SCTP packet leads to
    multiple calls to sk_data_ready, causing multiple wake up signals which
    are costy and doesn't make it wake up any faster.
    
    With this patch it will note that the wake up is pending and will do it
    before leaving the state machine interpreter, latest place possible to
    do it realiably and cleanly.
    
    Note that sk_data_ready events are not dependent on asocs, unlike waking
    up writers.
    
    v2: series re-checked
    v3: use local vars to cleanup the code, suggested by Jakub Sitnicki
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 1a6a626904bb..21cb11107e37 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -217,7 +217,8 @@ struct sctp_sock {
 		v4mapped:1,
 		frag_interleave:1,
 		recvrcvinfo:1,
-		recvnxtinfo:1;
+		recvnxtinfo:1,
+		pending_data_ready:1;
 
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */

commit 250eb1f8815303f71c94a5680f8e4f2dcfa25cf5
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Fri Apr 8 16:41:27 2016 -0300

    sctp: compress bit-wide flags to a bitfield on sctp_sock
    
    It wastes space and gets worse as we add new flags, so convert bit-wide
    flags to a bitfield.
    
    Currently it already saves 4 bytes in sctp_sock, which are left as holes
    in it for now. The whole struct needs packing, which should be done in
    another patch.
    
    Note that do_auto_asconf cannot be merged, as explained in the comment
    before it.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6df1ce7a411c..1a6a626904bb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -210,14 +210,14 @@ struct sctp_sock {
 	int user_frag;
 
 	__u32 autoclose;
-	__u8 nodelay;
-	__u8 disable_fragments;
-	__u8 v4mapped;
-	__u8 frag_interleave;
 	__u32 adaptation_ind;
 	__u32 pd_point;
-	__u8 recvrcvinfo;
-	__u8 recvnxtinfo;
+	__u16	nodelay:1,
+		disable_fragments:1,
+		v4mapped:1,
+		frag_interleave:1,
+		recvrcvinfo:1,
+		recvnxtinfo:1;
 
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */

commit ba6f5e33bdbb9ed2014b778fbbaecf20060ca989
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Wed Apr 6 15:15:19 2016 -0300

    sctp: avoid refreshing heartbeat timer too often
    
    Currently on high rate SCTP streams the heartbeat timer refresh can
    consume quite a lot of resources as timer updates are costly and it
    contains a random factor, which a) is also costly and b) invalidates
    mod_timer() optimization for not editing a timer to the same value.
    It may even cause the timer to be slightly advanced, for no good reason.
    
    As suggested by David Laight this patch now removes this timer update
    from hot path by leaving the timer on and re-evaluating upon its
    expiration if the heartbeat is still needed or not, similarly to what is
    done for TCP. If it's not needed anymore the timer is re-scheduled to
    the new timeout, considering the time already elapsed.
    
    For this, we now record the last tx timestamp per transport, updated in
    the same spots as hb timer was restarted on tx. Also split up
    sctp_transport_reset_timers into sctp_transport_reset_t3_rtx and
    sctp_transport_reset_hb_timer, so we can re-arm T3 without re-arming the
    heartbeat one.
    
    On loopback with MTU of 65535 and data chunks with 1636, so that we
    have a considerable amount of chunks without stressing system calls,
    netperf -t SCTP_STREAM -l 30, perf looked like this before:
    
    Samples: 103K of event 'cpu-clock', Event count (approx.): 25833000000
      Overhead  Command  Shared Object      Symbol
    +    6,15%  netperf  [kernel.vmlinux]   [k] copy_user_enhanced_fast_string
    -    5,43%  netperf  [kernel.vmlinux]   [k] _raw_write_unlock_irqrestore
       - _raw_write_unlock_irqrestore
          - 96,54% _raw_spin_unlock_irqrestore
             - 36,14% mod_timer
                + 97,24% sctp_transport_reset_timers
                + 2,76% sctp_do_sm
             + 33,65% __wake_up_sync_key
             + 28,77% sctp_ulpq_tail_event
             + 1,40% del_timer
          - 1,84% mod_timer
             + 99,03% sctp_transport_reset_timers
             + 0,97% sctp_do_sm
          + 1,50% sctp_ulpq_tail_event
    
    And after this patch, now with netperf -l 60:
    
    Samples: 230K of event 'cpu-clock', Event count (approx.): 57707250000
      Overhead  Command  Shared Object      Symbol
    +    5,65%  netperf  [kernel.vmlinux]   [k] memcpy_erms
    +    5,59%  netperf  [kernel.vmlinux]   [k] copy_user_enhanced_fast_string
    -    5,05%  netperf  [kernel.vmlinux]   [k] _raw_spin_unlock_irqrestore
       - _raw_spin_unlock_irqrestore
          + 49,89% __wake_up_sync_key
          + 45,68% sctp_ulpq_tail_event
          - 2,85% mod_timer
             + 76,51% sctp_transport_reset_t3_rtx
             + 23,49% sctp_do_sm
          + 1,55% del_timer
    +    2,50%  netperf  [sctp]             [k] sctp_datamsg_from_user
    +    2,26%  netperf  [sctp]             [k] sctp_sendmsg
    
    Throughput-wise, from 6800mbps without the patch to 7050mbps with it,
    ~3.7%.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6df1ce7a411c..5a404c354f4c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -847,6 +847,11 @@ struct sctp_transport {
 	 */
 	ktime_t last_time_heard;
 
+	/* When was the last time that we sent a chunk using this
+	 * transport? We use this to check for idle transports
+	 */
+	unsigned long last_time_sent;
+
 	/* Last time(in jiffies) when cwnd is reduced due to the congestion
 	 * indication based on ECNE chunk.
 	 */
@@ -952,7 +957,8 @@ void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
 			  struct sctp_sock *);
 void sctp_transport_pmtu(struct sctp_transport *, struct sock *sk);
 void sctp_transport_free(struct sctp_transport *);
-void sctp_transport_reset_timers(struct sctp_transport *);
+void sctp_transport_reset_t3_rtx(struct sctp_transport *);
+void sctp_transport_reset_hb_timer(struct sctp_transport *);
 int sctp_transport_hold(struct sctp_transport *);
 void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);

commit c78a85a8430e35aecd53e190a2f6b999062b1037
Merge: 133800d1f028 de06dbfa7861
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 19 21:05:24 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux

commit 1200b6809dfd9d73bc4c7db76d288c35fa4b2ebe
Merge: 6b5f04b6cf8e fe30937b6535
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 10:05:34 2016 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Highlights:
    
       1) Support more Realtek wireless chips, from Jes Sorenson.
    
       2) New BPF types for per-cpu hash and arrap maps, from Alexei
          Starovoitov.
    
       3) Make several TCP sysctls per-namespace, from Nikolay Borisov.
    
       4) Allow the use of SO_REUSEPORT in order to do per-thread processing
       of incoming TCP/UDP connections.  The muxing can be done using a
       BPF program which hashes the incoming packet.  From Craig Gallek.
    
       5) Add a multiplexer for TCP streams, to provide a messaged based
          interface.  BPF programs can be used to determine the message
          boundaries.  From Tom Herbert.
    
       6) Add 802.1AE MACSEC support, from Sabrina Dubroca.
    
       7) Avoid factorial complexity when taking down an inetdev interface
          with lots of configured addresses.  We were doing things like
          traversing the entire address less for each address removed, and
          flushing the entire netfilter conntrack table for every address as
          well.
    
       8) Add and use SKB bulk free infrastructure, from Jesper Brouer.
    
       9) Allow offloading u32 classifiers to hardware, and implement for
          ixgbe, from John Fastabend.
    
      10) Allow configuring IRQ coalescing parameters on a per-queue basis,
          from Kan Liang.
    
      11) Extend ethtool so that larger link mode masks can be supported.
          From David Decotigny.
    
      12) Introduce devlink, which can be used to configure port link types
          (ethernet vs Infiniband, etc.), port splitting, and switch device
          level attributes as a whole.  From Jiri Pirko.
    
      13) Hardware offload support for flower classifiers, from Amir Vadai.
    
      14) Add "Local Checksum Offload".  Basically, for a tunneled packet
          the checksum of the outer header is 'constant' (because with the
          checksum field filled into the inner protocol header, the payload
          of the outer frame checksums to 'zero'), and we can take advantage
          of that in various ways.  From Edward Cree"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1548 commits)
      bonding: fix bond_get_stats()
      net: bcmgenet: fix dma api length mismatch
      net/mlx4_core: Fix backward compatibility on VFs
      phy: mdio-thunder: Fix some Kconfig typos
      lan78xx: add ndo_get_stats64
      lan78xx: handle statistics counter rollover
      RDS: TCP: Remove unused constant
      RDS: TCP: Add sysctl tunables for sndbuf/rcvbuf on rds-tcp socket
      net: smc911x: convert pxa dma to dmaengine
      team: remove duplicate set of flag IFF_MULTICAST
      bonding: remove duplicate set of flag IFF_MULTICAST
      net: fix a comment typo
      ethernet: micrel: fix some error codes
      ip_tunnels, bpf: define IP_TUNNEL_OPTS_MAX and use it
      bpf, dst: add and use dst_tclassid helper
      bpf: make skb->tc_classid also readable
      net: mvneta: bm: clarify dependencies
      cls_bpf: reset class and reuse major in da
      ldmvsw: Checkpatch sunvnet.c and sunvnet_common.c
      ldmvsw: Add ldmvsw.c driver code
      ...

commit 70477371dc350746d10431d74f0f213a8d59924c
Merge: 09fd671ccb24 34074205bb9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 17 11:22:54 2016 -0700

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto update from Herbert Xu:
     "Here is the crypto update for 4.6:
    
      API:
       - Convert remaining crypto_hash users to shash or ahash, also convert
         blkcipher/ablkcipher users to skcipher.
       - Remove crypto_hash interface.
       - Remove crypto_pcomp interface.
       - Add crypto engine for async cipher drivers.
       - Add akcipher documentation.
       - Add skcipher documentation.
    
      Algorithms:
       - Rename crypto/crc32 to avoid name clash with lib/crc32.
       - Fix bug in keywrap where we zero the wrong pointer.
    
      Drivers:
       - Support T5/M5, T7/M7 SPARC CPUs in n2 hwrng driver.
       - Add PIC32 hwrng driver.
       - Support BCM6368 in bcm63xx hwrng driver.
       - Pack structs for 32-bit compat users in qat.
       - Use crypto engine in omap-aes.
       - Add support for sama5d2x SoCs in atmel-sha.
       - Make atmel-sha available again.
       - Make sahara hashing available again.
       - Make ccp hashing available again.
       - Make sha1-mb available again.
       - Add support for multiple devices in ccp.
       - Improve DMA performance in caam.
       - Add hashing support to rockchip"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (116 commits)
      crypto: qat - remove redundant arbiter configuration
      crypto: ux500 - fix checks of error code returned by devm_ioremap_resource()
      crypto: atmel - fix checks of error code returned by devm_ioremap_resource()
      crypto: qat - Change the definition of icp_qat_uof_regtype
      hwrng: exynos - use __maybe_unused to hide pm functions
      crypto: ccp - Add abstraction for device-specific calls
      crypto: ccp - CCP versioning support
      crypto: ccp - Support for multiple CCPs
      crypto: ccp - Remove check for x86 family and model
      crypto: ccp - memset request context to zero during import
      lib/mpi: use "static inline" instead of "extern inline"
      lib/mpi: avoid assembler warning
      hwrng: bcm63xx - fix non device tree compatibility
      crypto: testmgr - allow rfc3686 aes-ctr variants in fips mode.
      crypto: qat - The AE id should be less than the maximal AE number
      lib/mpi: Endianness fix
      crypto: rockchip - add hash support for crypto engine in rk3288
      crypto: xts - fix compile errors
      crypto: doc - add skcipher API documentation
      crypto: doc - update AEAD AD handling
      ...

commit cea8768f333e3f0bc231d8b815aa4a9e63fa990c
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Thu Mar 10 18:33:07 2016 -0300

    sctp: allow sctp_transmit_packet and others to use gfp
    
    Currently sctp_sendmsg() triggers some calls that will allocate memory
    with GFP_ATOMIC even when not necessary. In the case of
    sctp_packet_transmit it will allocate a linear skb that will be used to
    construct the packet and this may cause sends to fail due to ENOMEM more
    often than anticipated specially with big MTUs.
    
    This patch thus allows it to inherit gfp flags from upper calls so that
    it can use GFP_KERNEL if it was triggered by a sctp_sendmsg call or
    similar. All others, like retransmits or flushes started from BH, are
    still allocated using GFP_ATOMIC.
    
    In netperf tests this didn't result in any performance drawbacks when
    memory is not too fragmented and made it trigger ENOMEM way less often.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d05b56641abc..9d237669c52c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -655,7 +655,7 @@ void sctp_chunk_free(struct sctp_chunk *);
 void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,
 				 const struct sctp_association *,
-				 struct sock *);
+				 struct sock *, gfp_t gfp);
 void sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,
 		     union sctp_addr *);
 const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
@@ -717,10 +717,10 @@ struct sctp_packet *sctp_packet_init(struct sctp_packet *,
 				     __u16 sport, __u16 dport);
 struct sctp_packet *sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
 sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *,
-                                       struct sctp_chunk *, int);
+				       struct sctp_chunk *, int, gfp_t);
 sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *,
                                      struct sctp_chunk *);
-int sctp_packet_transmit(struct sctp_packet *);
+int sctp_packet_transmit(struct sctp_packet *, gfp_t);
 void sctp_packet_free(struct sctp_packet *);
 
 static inline int sctp_packet_empty(struct sctp_packet *packet)
@@ -1053,7 +1053,7 @@ struct sctp_outq {
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
 void sctp_outq_teardown(struct sctp_outq *);
 void sctp_outq_free(struct sctp_outq*);
-int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk);
+int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk, gfp_t);
 int sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);
@@ -1061,7 +1061,7 @@ void sctp_outq_restart(struct sctp_outq *);
 void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
 		     sctp_retransmit_reason_t);
 void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
-int sctp_outq_uncork(struct sctp_outq *);
+int sctp_outq_uncork(struct sctp_outq *, gfp_t gfp);
 /* Uncork and flush an outqueue.  */
 static inline void sctp_outq_cork(struct sctp_outq *q)
 {

commit 133800d1f0288b9ddfc0d0aded10d9efa82d5b8c
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Tue Mar 8 10:34:28 2016 -0300

    sctp: fix copying more bytes than expected in sctp_add_bind_addr
    
    Dmitry reported that sctp_add_bind_addr may read more bytes than
    expected in case the parameter is a IPv4 addr supplied by the user
    through calls such as sctp_bindx_add(), because it always copies
    sizeof(union sctp_addr) while the buffer may be just a struct
    sockaddr_in, which is smaller.
    
    This patch then fixes it by limiting the memcpy to the min between the
    union size and a (new parameter) provided addr size. Where possible this
    parameter still is the size of that union, except for reading from
    user-provided buffers, which then it accounts for protocol type.
    
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 205630bb5010..f816344f65f2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1098,7 +1098,7 @@ int sctp_bind_addr_dup(struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
 			gfp_t gfp);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-		       __u8 addr_state, gfp_t gfp);
+		       int new_size, __u8 addr_state, gfp_t gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);

commit 1cd4d5c4326a7ed3bb0e346bd7d20f5057a80ae6
Author: Xin Long <lucien.xin@gmail.com>
Date:   Mon Feb 15 14:28:05 2016 +0800

    sctp: remove the unused sctp_datamsg_free()
    
    Since commit 8b570dc9f7b6 ("sctp: only drop the reference on the datamsg
    after sending a msg") used sctp_datamsg_put in sctp_sendmsg, instead of
    sctp_datamsg_free, this function has no use in sctp.
    
    So we will remove it.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 205630bb5010..d05b56641abc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -535,7 +535,6 @@ struct sctp_datamsg {
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
 					    struct sctp_sndrcvinfo *,
 					    struct iov_iter *);
-void sctp_datamsg_free(struct sctp_datamsg *);
 void sctp_datamsg_put(struct sctp_datamsg *);
 void sctp_chunk_fail(struct sctp_chunk *, int error);
 int sctp_chunk_abandoned(struct sctp_chunk *);

commit 47faa1e4c50ec26e6e75dcd1ce53f064bd45f729
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jan 22 01:49:09 2016 +0800

    sctp: remove the dead field of sctp_transport
    
    After we use refcnt to check if transport is alive, the dead can be
    removed from sctp_transport.
    
    The traversal of transport_addr_list in procfs dump is using
    list_for_each_entry_rcu, no need to check if it has been freed.
    
    sctp_generate_t3_rtx_event and sctp_generate_heartbeat_event is
    protected by sock lock, it's not necessary to check dead, either.
    also, the timers are cancelled when sctp_transport_free() is
    called, that it doesn't wait for refcnt to reach 0 to cancel them.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 344da04e2e30..205630bb5010 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -756,7 +756,6 @@ struct sctp_transport {
 
 	/* Reference counting. */
 	atomic_t refcnt;
-	__u32	 dead:1,
 		/* RTO-Pending : A flag used to track if one of the DATA
 		 *		chunks sent to this address is currently being
 		 *		used to compute a RTT. If this flag is 0,
@@ -766,7 +765,7 @@ struct sctp_transport {
 		 *		calculation completes (i.e. the DATA chunk
 		 *		is SACK'd) clear this flag.
 		 */
-		 rto_pending:1,
+	__u32	rto_pending:1,
 
 		/*
 		 * hb_sent : a flag that signals that we have a pending

commit 1eed677933b816978abc4e3e18ecae5f254cb9be
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Jan 22 01:49:07 2016 +0800

    sctp: fix the transport dead race check by using atomic_add_unless on refcnt
    
    Now when __sctp_lookup_association is running in BH, it will try to
    check if t->dead is set, but meanwhile other CPUs may be freeing this
    transport and this assoc and if it happens that
    __sctp_lookup_association checked t->dead a bit too early, it may think
    that the association is still good while it was already freed.
    
    So we fix this race by using atomic_add_unless in sctp_transport_hold.
    After we get one transport from hashtable, we will hold it only when
    this transport's refcnt is not 0, so that we can make sure t->asoc
    cannot be freed before we hold the asoc again.
    
    Note that sctp association is not freed using RCU so we can't use
    atomic_add_unless() with it as it may just be too late for that either.
    
    Fixes: 4f0087812648 ("sctp: apply rhashtable api to send/recv path")
    Reported-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 20e72129be1c..344da04e2e30 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -955,7 +955,7 @@ void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
 void sctp_transport_pmtu(struct sctp_transport *, struct sock *sk);
 void sctp_transport_free(struct sctp_transport *);
 void sctp_transport_reset_timers(struct sctp_transport *);
-void sctp_transport_hold(struct sctp_transport *);
+int sctp_transport_hold(struct sctp_transport *);
 void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);
 void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);

commit 5821c769706561da81e9fcec4a6ca6dbbb2f30cb
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Jan 24 21:20:12 2016 +0800

    sctp: Use shash
    
    This patch replaces uses of the long obsolete hash interface with
    shash.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 20e72129be1c..6b1e3838667e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -82,7 +82,7 @@ struct sctp_bind_addr;
 struct sctp_ulpq;
 struct sctp_ep_common;
 struct sctp_ssnmap;
-struct crypto_hash;
+struct crypto_shash;
 
 
 #include <net/sctp/tsnmap.h>
@@ -166,7 +166,7 @@ struct sctp_sock {
 	struct sctp_pf *pf;
 
 	/* Access to HMAC transform. */
-	struct crypto_hash *hmac;
+	struct crypto_shash *hmac;
 	char *sctp_hmac_alg;
 
 	/* What is our base endpointer? */
@@ -1235,7 +1235,7 @@ struct sctp_endpoint {
 	/* SCTP AUTH: array of the HMACs that will be allocated
 	 * we need this per association so that we don't serialize
 	 */
-	struct crypto_hash **auth_hmacs;
+	struct crypto_shash **auth_hmacs;
 
 	/* SCTP-AUTH: hmacs for the endpoint encoded into parameter */
 	 struct sctp_hmac_algo_param *auth_hmacs_list;

commit b5eff7128366c4a7a9b502097a968ec9cae2bea2
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Dec 30 23:50:49 2015 +0800

    sctp: drop the old assoc hashtable of sctp
    
    transport hashtable will replace the association hashtable,
    so association hashtable is not used in sctp any more, so
    drop the codes about that.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4ab87d08e766..20e72129be1c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -120,8 +120,6 @@ extern struct sctp_globals {
 
 	/* This is the hash of all endpoints. */
 	struct sctp_hashbucket *ep_hashtable;
-	/* This is the hash of all associations. */
-	struct sctp_hashbucket *assoc_hashtable;
 	/* This is the sctp port control hash.	*/
 	struct sctp_bind_hashbucket *port_hashtable;
 	/* This is the hash of all transports. */
@@ -129,7 +127,6 @@ extern struct sctp_globals {
 
 	/* Sizes of above hashtables. */
 	int ep_hashsize;
-	int assoc_hashsize;
 	int port_hashsize;
 
 	/* Default initialization values to be applied to new associations. */
@@ -146,8 +143,6 @@ extern struct sctp_globals {
 #define sctp_address_families		(sctp_globals.address_families)
 #define sctp_ep_hashsize		(sctp_globals.ep_hashsize)
 #define sctp_ep_hashtable		(sctp_globals.ep_hashtable)
-#define sctp_assoc_hashsize		(sctp_globals.assoc_hashsize)
-#define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_transport_hashtable	(sctp_globals.transport_hashtable)

commit d6c0256a60e685214cc8cc2b886809f11efc0084
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Dec 30 23:50:46 2015 +0800

    sctp: add the rhashtable apis for sctp global transport hashtable
    
    tranport hashtbale will replace the association hashtable to do the
    lookup for transport, and then get association by t->assoc, rhashtable
    apis will be used because of it's resizable, scalable and using rcu.
    
    lport + rport + paddr will be the base hashkey to locate the chain,
    with net to protect one netns from another, then plus the laddr to
    compare to get the target.
    
    this patch will provider the lookup functions:
    - sctp_epaddr_lookup_transport
    - sctp_addrs_lookup_transport
    
    hash/unhash functions:
    - sctp_hash_transport
    - sctp_unhash_transport
    
    init/destroy functions:
    - sctp_transport_hashtable_init
    - sctp_transport_hashtable_destroy
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index eea9bdeecba2..4ab87d08e766 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -48,6 +48,7 @@
 #define __sctp_structs_h__
 
 #include <linux/ktime.h>
+#include <linux/rhashtable.h>
 #include <linux/socket.h>	/* linux/in.h needs this!!    */
 #include <linux/in.h>		/* We get struct sockaddr_in. */
 #include <linux/in6.h>		/* We get struct in6_addr     */
@@ -123,6 +124,8 @@ extern struct sctp_globals {
 	struct sctp_hashbucket *assoc_hashtable;
 	/* This is the sctp port control hash.	*/
 	struct sctp_bind_hashbucket *port_hashtable;
+	/* This is the hash of all transports. */
+	struct rhashtable transport_hashtable;
 
 	/* Sizes of above hashtables. */
 	int ep_hashsize;
@@ -147,6 +150,7 @@ extern struct sctp_globals {
 #define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
+#define sctp_transport_hashtable	(sctp_globals.transport_hashtable)
 #define sctp_checksum_disable		(sctp_globals.checksum_disable)
 
 /* SCTP Socket type: UDP or TCP style. */
@@ -753,6 +757,7 @@ static inline int sctp_packet_empty(struct sctp_packet *packet)
 struct sctp_transport {
 	/* A list of transports. */
 	struct list_head transports;
+	struct rhash_head node;
 
 	/* Reference counting. */
 	atomic_t refcnt;

commit 8a0d19c5ed417c78d03f4e0fa7215e58c40896d8
Author: lucien <lucien.xin@gmail.com>
Date:   Sat Dec 5 15:35:36 2015 +0800

    sctp: start t5 timer only when peer rwnd is 0 and local state is SHUTDOWN_PENDING
    
    when A sends a data to B, then A close() and enter into SHUTDOWN_PENDING
    state, if B neither claim his rwnd is 0 nor send SACK for this data, A
    will keep retransmitting this data until t5 timeout, Max.Retrans times
    can't work anymore, which is bad.
    
    if B's rwnd is not 0, it should send abort after Max.Retrans times, only
    when B's rwnd == 0 and A's retransmitting beyonds Max.Retrans times, A
    will start t5 timer, which is also commit f8d960524328 ("sctp: Enforce
    retransmission limit during shutdown") means, but it lacks the condition
    peer rwnd == 0.
    
    so fix it by adding a bit (zero_window_announced) in peer to record if
    the last rwnd is 0. If it was, zero_window_announced will be set. and use
    this bit to decide if start t5 timer when local.state is SHUTDOWN_PENDING.
    
    Fixes: commit f8d960524328 ("sctp: Enforce retransmission limit during shutdown")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7bbb71081aeb..eea9bdeecba2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1493,7 +1493,8 @@ struct sctp_association {
 		 *             : SACK's are not delayed (see Section 6).
 		 */
 		__u8    sack_needed:1,     /* Do we need to sack the peer? */
-			sack_generation:1;
+			sack_generation:1,
+			zero_window_announced:1;
 		__u32	sack_cnt;
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */

commit 38ee8fb67c3457f36f5137073c4b8ac2436d2393
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Mon Nov 30 12:17:06 2015 -0200

    sctp: convert sack_needed and sack_generation to bits
    
    They don't need to be any bigger than that and with this we start a new
    bitfield for tracking association runtime stuff, like zero window
    situation.
    
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 495c87e367b3..7bbb71081aeb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -775,10 +775,10 @@ struct sctp_transport {
 		hb_sent:1,
 
 		/* Is the Path MTU update pending on this tranport */
-		pmtu_pending:1;
+		pmtu_pending:1,
 
-	/* Has this transport moved the ctsn since we last sacked */
-	__u32 sack_generation;
+		/* Has this transport moved the ctsn since we last sacked */
+		sack_generation:1;
 	u32 dst_cookie;
 
 	struct flowi fl;
@@ -1482,19 +1482,19 @@ struct sctp_association {
 			prsctp_capable:1,   /* Can peer do PR-SCTP? */
 			auth_capable:1;     /* Is peer doing SCTP-AUTH? */
 
-		/* Ack State   : This flag indicates if the next received
+		/* sack_needed : This flag indicates if the next received
 		 *             : packet is to be responded to with a
-		 *             : SACK. This is initializedto 0.  When a packet
-		 *             : is received it is incremented. If this value
+		 *             : SACK. This is initialized to 0.  When a packet
+		 *             : is received sack_cnt is incremented. If this value
 		 *             : reaches 2 or more, a SACK is sent and the
 		 *             : value is reset to 0. Note: This is used only
 		 *             : when no DATA chunks are received out of
 		 *             : order.  When DATA chunks are out of order,
 		 *             : SACK's are not delayed (see Section 6).
 		 */
-		__u8    sack_needed;     /* Do we need to sack the peer? */
+		__u8    sack_needed:1,     /* Do we need to sack the peer? */
+			sack_generation:1;
 		__u32	sack_cnt;
-		__u32	sack_generation;
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 

commit 2d45a02d0166caf2627fe91897c6ffc3b19514c4
Author: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
Date:   Fri Jun 12 10:16:41 2015 -0300

    sctp: fix ASCONF list handling
    
    ->auto_asconf_splist is per namespace and mangled by functions like
    sctp_setsockopt_auto_asconf() which doesn't guarantee any serialization.
    
    Also, the call to inet_sk_copy_descendant() was backuping
    ->auto_asconf_list through the copy but was not honoring
    ->do_auto_asconf, which could lead to list corruption if it was
    different between both sockets.
    
    This commit thus fixes the list handling by using ->addr_wq_lock
    spinlock to protect the list. A special handling is done upon socket
    creation and destruction for that. Error handlig on sctp_init_sock()
    will never return an error after having initialized asconf, so
    sctp_destroy_sock() can be called without addrq_wq_lock. The lock now
    will be take on sctp_close_sock(), before locking the socket, so we
    don't do it in inverse order compared to sctp_addr_wq_timeout_handler().
    
    Instead of taking the lock on sctp_sock_migrate() for copying and
    restoring the list values, it's preferred to avoid rewritting it by
    implementing sctp_copy_descendant().
    
    Issue was found with a test application that kept flipping sysctl
    default_auto_asconf on and off, but one could trigger it by issuing
    simultaneous setsockopt() calls on multiple sockets or by
    creating/destroying sockets fast enough. This is only triggerable
    locally.
    
    Fixes: 9f7d653b67ae ("sctp: Add Auto-ASCONF support (core).")
    Reported-by: Ji Jianwen <jiji@redhat.com>
    Suggested-by: Neil Horman <nhorman@tuxdriver.com>
    Suggested-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2bb2fcf5b11f..495c87e367b3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -223,6 +223,10 @@ struct sctp_sock {
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
+
+	/* These must be the last fields, as they will skipped on copies,
+	 * like on accept and peeloff operations
+	 */
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };

commit e0eb093e794452791b0f932a0120f410f614ad82
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Nov 15 01:11:23 2014 -0500

    switch sctp_user_addto_chunk() and sctp_datamsg_from_user() to passing iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 806e3b5b3351..2bb2fcf5b11f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -531,7 +531,7 @@ struct sctp_datamsg {
 
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
 					    struct sctp_sndrcvinfo *,
-					    struct msghdr *, int len);
+					    struct iov_iter *);
 void sctp_datamsg_free(struct sctp_datamsg *);
 void sctp_datamsg_put(struct sctp_datamsg *);
 void sctp_chunk_fail(struct sctp_chunk *, int error);
@@ -647,8 +647,8 @@ struct sctp_chunk {
 
 void sctp_chunk_hold(struct sctp_chunk *);
 void sctp_chunk_put(struct sctp_chunk *);
-int sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,
-			  struct iovec *data);
+int sctp_user_addto_chunk(struct sctp_chunk *chunk, int len,
+			  struct iov_iter *from);
 void sctp_chunk_free(struct sctp_chunk *);
 void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,

commit 16704b129bc1e497862e88253da20b13a1b94b33
Author: Sbastien Barr <sebastien.barre@uclouvain.be>
Date:   Tue Oct 21 15:26:15 2014 +0200

    Removed unused function sctp_addr_is_valid()
    
    sctp_addr_is_valid() only appeared in its definition.
    
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Sbastien Barr <sebastien.barre@uclouvain.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4ff3f67be62c..806e3b5b3351 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1116,7 +1116,6 @@ int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
 sctp_scope_t sctp_scope(const union sctp_addr *);
 int sctp_in_scope(struct net *net, const union sctp_addr *addr, const sctp_scope_t scope);
 int sctp_is_any(struct sock *sk, const union sctp_addr *addr);
-int sctp_addr_is_valid(const union sctp_addr *addr);
 int sctp_is_ep_boundall(struct sock *sk);
 
 

commit 299ee123e19889d511092347f5fc14db0f10e3a6
Author: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
Date:   Wed Jul 30 12:40:53 2014 -0600

    sctp: Fixup v4mapped behaviour to comply with Sock API
    
    The SCTP socket extensions API document describes the v4mapping option as
    follows:
    
    8.1.15.  Set/Clear IPv4 Mapped Addresses (SCTP_I_WANT_MAPPED_V4_ADDR)
    
       This socket option is a Boolean flag which turns on or off the
       mapping of IPv4 addresses.  If this option is turned on, then IPv4
       addresses will be mapped to V6 representation.  If this option is
       turned off, then no mapping will be done of V4 addresses and a user
       will receive both PF_INET6 and PF_INET type addresses on the socket.
       See [RFC3542] for more details on mapped V6 addresses.
    
    This description isn't really in line with what the code does though.
    
    Introduce addr_to_user (renamed addr_v4map), which should be called
    before any sockaddr is passed back to user space. The new function
    places the sockaddr into the correct format depending on the
    SCTP_I_WANT_MAPPED_V4_ADDR option.
    
    Audit all places that touched v4mapped and either sanely construct
    a v4 or v6 address then call addr_to_user, or drop the
    unnecessary v4mapped check entirely.
    
    Audit all places that call addr_to_user and verify they are on a sycall
    return path.
    
    Add a custom getname that formats the address properly.
    
    Several bugs are addressed:
     - SCTP_I_WANT_MAPPED_V4_ADDR=0 often returned garbage for
       addresses to user space
     - The addr_len returned from recvmsg was not correct when
       returning AF_INET on a v6 socket
     - flowlabel and scope_id were not zerod when promoting
       a v4 to v6
     - Some syscalls like bind and connect behaved differently
       depending on v4mapped
    
    Tested bind, getpeername, getsockname, connect, and recvmsg for proper
    behaviour in v4mapped = 1 and 0 cases.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Tested-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7741d1b66967..4ff3f67be62c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -465,10 +465,6 @@ struct sctp_af {
 					 int saddr);
 	void		(*from_sk)	(union sctp_addr *,
 					 struct sock *sk);
-	void		(*to_sk_saddr)	(union sctp_addr *,
-					 struct sock *sk);
-	void		(*to_sk_daddr)	(union sctp_addr *,
-					 struct sock *sk);
 	void		(*from_addr_param) (union sctp_addr *,
 					    union sctp_addr_param *,
 					    __be16 port, int iif);
@@ -509,7 +505,9 @@ struct sctp_pf {
 	int  (*supported_addrs)(const struct sctp_sock *, __be16 *);
 	struct sock *(*create_accept_sk) (struct sock *sk,
 					  struct sctp_association *asoc);
-	void (*addr_v4map) (struct sctp_sock *, union sctp_addr *);
+	int (*addr_to_user)(struct sctp_sock *sk, union sctp_addr *addr);
+	void (*to_sk_saddr)(union sctp_addr *, struct sock *sk);
+	void (*to_sk_daddr)(union sctp_addr *, struct sock *sk);
 	struct sctp_af *af;
 };
 

commit 2347c80ff127b94ddaa675e2b78ab4cef46dc905
Author: Geir Ola Vaagland <geirola@gmail.com>
Date:   Sat Jul 12 20:30:38 2014 +0200

    net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support
    
    This patch implements section 5.3.6. of RFC6458, that is, support
    for 'SCTP Next Receive Information Structure' (SCTP_NXTINFO) which
    is placed into ancillary data cmsghdr structure for each recvmsg()
    call, if this information is already available when delivering the
    current message.
    
    This option can be enabled/disabled via setsockopt(2) on SOL_SCTP
    level by setting an int value with 1/0 for SCTP_RECVNXTINFO in
    user space applications as per RFC6458, section 8.1.30.
    
    The sctp_nxtinfo structure is defined as per RFC as below ...
    
      struct sctp_nxtinfo {
        uint16_t nxt_sid;
        uint16_t nxt_flags;
        uint32_t nxt_ppid;
        uint32_t nxt_length;
        sctp_assoc_t nxt_assoc_id;
      };
    
    ... and provided under cmsg_level IPPROTO_SCTP, cmsg_type
    SCTP_NXTINFO, while cmsg_data[] contains struct sctp_nxtinfo.
    
    Joint work with Daniel Borkmann.
    
    Signed-off-by: Geir Ola Vaagland <geirola@gmail.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 11d5df015370..7741d1b66967 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -218,6 +218,7 @@ struct sctp_sock {
 	__u32 adaptation_ind;
 	__u32 pd_point;
 	__u8 recvrcvinfo;
+	__u8 recvnxtinfo;
 
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */

commit 0d3a421d284812d07970b4ccee74d4fa38737e4d
Author: Geir Ola Vaagland <geirola@gmail.com>
Date:   Sat Jul 12 20:30:37 2014 +0200

    net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support
    
    This patch implements section 5.3.5. of RFC6458, that is, support
    for 'SCTP Receive Information Structure' (SCTP_RCVINFO) which is
    placed into ancillary data cmsghdr structure for each recvmsg()
    call.
    
    This option can be enabled/disabled via setsockopt(2) on SOL_SCTP
    level by setting an int value with 1/0 for SCTP_RECVRCVINFO in user
    space applications as per RFC6458, section 8.1.29.
    
    The sctp_rcvinfo structure is defined as per RFC as below ...
    
      struct sctp_rcvinfo {
        uint16_t rcv_sid;
        uint16_t rcv_ssn;
        uint16_t rcv_flags;
        <-- 2 bytes hole  -->
        uint32_t rcv_ppid;
        uint32_t rcv_tsn;
        uint32_t rcv_cumtsn;
        uint32_t rcv_context;
        sctp_assoc_t rcv_assoc_id;
      };
    
    ... and provided under cmsg_level IPPROTO_SCTP, cmsg_type
    SCTP_RCVINFO, while cmsg_data[] contains struct sctp_rcvinfo.
    An sctp_rcvinfo item always corresponds to the data in msg_iov.
    
    Joint work with Daniel Borkmann.
    
    Signed-off-by: Geir Ola Vaagland <geirola@gmail.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7af9a0f5d8ce..11d5df015370 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -207,7 +207,9 @@ struct sctp_sock {
 	struct sctp_paddrparams paddrparam;
 	struct sctp_event_subscribe subscribe;
 	struct sctp_assocparams assocparams;
+
 	int user_frag;
+
 	__u32 autoclose;
 	__u8 nodelay;
 	__u8 disable_fragments;
@@ -215,6 +217,7 @@ struct sctp_sock {
 	__u8 frag_interleave;
 	__u32 adaptation_ind;
 	__u32 pd_point;
+	__u8 recvrcvinfo;
 
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */

commit 63b949382c5f263746b1c177f6ff84de2201ae9d
Author: Geir Ola Vaagland <geirola@gmail.com>
Date:   Sat Jul 12 20:30:36 2014 +0200

    net: sctp: implement rfc6458, 5.3.4. SCTP_SNDINFO cmsg support
    
    This patch implements section 5.3.4. of RFC6458, that is, support
    for 'SCTP Send Information Structure' (SCTP_SNDINFO) which can be
    placed into ancillary data cmsghdr structure for sendmsg() calls.
    
    The sctp_sndinfo structure is defined as per RFC as below ...
    
      struct sctp_sndinfo {
        uint16_t snd_sid;
        uint16_t snd_flags;
        uint32_t snd_ppid;
        uint32_t snd_context;
        sctp_assoc_t snd_assoc_id;
      };
    
    ... and supplied under cmsg_level IPPROTO_SCTP, cmsg_type
    SCTP_SNDINFO, while cmsg_data[] contains struct sctp_sndinfo.
    An sctp_sndinfo item always corresponds to the data in msg_iov.
    
    Joint work with Daniel Borkmann.
    
    Signed-off-by: Geir Ola Vaagland <geirola@gmail.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f38588bf3462..7af9a0f5d8ce 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1919,7 +1919,8 @@ struct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc);
 /* A convenience structure to parse out SCTP specific CMSGs. */
 typedef struct sctp_cmsgs {
 	struct sctp_initmsg *init;
-	struct sctp_sndrcvinfo *info;
+	struct sctp_sndrcvinfo *srinfo;
+	struct sctp_sndinfo *sinfo;
 } sctp_cmsgs_t;
 
 /* Structure for tracking memory objects */

commit e575235fc6026bb75e166ff68f84118c62d73f94
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Jun 11 18:19:30 2014 +0200

    net: sctp: migrate most recently used transport to ktime
    
    Be more precise in transport path selection and use ktime
    helpers instead of jiffies to compare and pick the better
    primary and secondary recently used transports. This also
    avoids any side-effects during a possible roll-over, and
    could lead to better path decision-making.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0dfcc92600e8..f38588bf3462 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -838,10 +838,10 @@ struct sctp_transport {
 	unsigned long sackdelay;
 	__u32 sackfreq;
 
-	/* When was the last time (in jiffies) that we heard from this
-	 * transport?  We use this to pick new active and retran paths.
+	/* When was the last time that we heard from this transport? We use
+	 * this to pick new active and retran paths.
 	 */
-	unsigned long last_time_heard;
+	ktime_t last_time_heard;
 
 	/* Last time(in jiffies) when cwnd is reduced due to the congestion
 	 * indication based on ECNE chunk.

commit b14878ccb7fac0242db82720b784ab62c467c0dc
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Thu Apr 17 17:26:50 2014 +0200

    net: sctp: cache auth_enable per endpoint
    
    Currently, it is possible to create an SCTP socket, then switch
    auth_enable via sysctl setting to 1 and crash the system on connect:
    
    Oops[#1]:
    CPU: 0 PID: 0 Comm: swapper Not tainted 3.14.1-mipsgit-20140415 #1
    task: ffffffff8056ce80 ti: ffffffff8055c000 task.ti: ffffffff8055c000
    [...]
    Call Trace:
    [<ffffffff8043c4e8>] sctp_auth_asoc_set_default_hmac+0x68/0x80
    [<ffffffff8042b300>] sctp_process_init+0x5e0/0x8a4
    [<ffffffff8042188c>] sctp_sf_do_5_1B_init+0x234/0x34c
    [<ffffffff804228c8>] sctp_do_sm+0xb4/0x1e8
    [<ffffffff80425a08>] sctp_endpoint_bh_rcv+0x1c4/0x214
    [<ffffffff8043af68>] sctp_rcv+0x588/0x630
    [<ffffffff8043e8e8>] sctp6_rcv+0x10/0x24
    [<ffffffff803acb50>] ip6_input+0x2c0/0x440
    [<ffffffff8030fc00>] __netif_receive_skb_core+0x4a8/0x564
    [<ffffffff80310650>] process_backlog+0xb4/0x18c
    [<ffffffff80313cbc>] net_rx_action+0x12c/0x210
    [<ffffffff80034254>] __do_softirq+0x17c/0x2ac
    [<ffffffff800345e0>] irq_exit+0x54/0xb0
    [<ffffffff800075a4>] ret_from_irq+0x0/0x4
    [<ffffffff800090ec>] rm7k_wait_irqoff+0x24/0x48
    [<ffffffff8005e388>] cpu_startup_entry+0xc0/0x148
    [<ffffffff805a88b0>] start_kernel+0x37c/0x398
    Code: dd0900b8  000330f8  0126302d <dcc60000> 50c0fff1  0047182a  a48306a0
    03e00008  00000000
    ---[ end trace b530b0551467f2fd ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    What happens while auth_enable=0 in that case is, that
    ep->auth_hmacs is initialized to NULL in sctp_auth_init_hmacs()
    when endpoint is being created.
    
    After that point, if an admin switches over to auth_enable=1,
    the machine can crash due to NULL pointer dereference during
    reception of an INIT chunk. When we enter sctp_process_init()
    via sctp_sf_do_5_1B_init() in order to respond to an INIT chunk,
    the INIT verification succeeds and while we walk and process
    all INIT params via sctp_process_param() we find that
    net->sctp.auth_enable is set, therefore do not fall through,
    but invoke sctp_auth_asoc_set_default_hmac() instead, and thus,
    dereference what we have set to NULL during endpoint
    initialization phase.
    
    The fix is to make auth_enable immutable by caching its value
    during endpoint initialization, so that its original value is
    being carried along until destruction. The bug seems to originate
    from the very first days.
    
    Fix in joint work with Daniel Borkmann.
    
    Reported-by: Joshua Kinard <kumba@gentoo.org>
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Tested-by: Joshua Kinard <kumba@gentoo.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d992ca3145fe..0dfcc92600e8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1241,6 +1241,7 @@ struct sctp_endpoint {
 	/* SCTP-AUTH: endpoint shared keys */
 	struct list_head endpoint_shared_keys;
 	__u16 active_key_id;
+	__u8  auth_enable;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1269,7 +1270,8 @@ struct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *,
 int sctp_has_association(struct net *net, const union sctp_addr *laddr,
 			 const union sctp_addr *paddr);
 
-int sctp_verify_init(struct net *net, const struct sctp_association *asoc,
+int sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,
+		     const struct sctp_association *asoc,
 		     sctp_cid_t, sctp_init_chunk_t *peer_init,
 		     struct sctp_chunk *chunk, struct sctp_chunk **err_chunk);
 int sctp_process_init(struct sctp_association *, struct sctp_chunk *chunk,

commit 362d52040c71f6e8d8158be48c812d7729cb8df1
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Apr 14 21:45:17 2014 +0200

    Revert "net: sctp: Fix a_rwnd/rwnd management to reflect real state of the receiver's buffer"
    
    This reverts commit ef2820a735f7 ("net: sctp: Fix a_rwnd/rwnd management
    to reflect real state of the receiver's buffer") as it introduced a
    serious performance regression on SCTP over IPv4 and IPv6, though a not
    as dramatic on the latter. Measurements are on 10Gbit/s with ixgbe NICs.
    
    Current state:
    
    [root@Lab200slot2 ~]# iperf3 --sctp -4 -c 192.168.241.3 -V -l 1452 -t 60
    iperf version 3.0.1 (10 January 2014)
    Linux Lab200slot2 3.14.0 #1 SMP Thu Apr 3 23:18:29 EDT 2014 x86_64
    Time: Fri, 11 Apr 2014 17:56:21 GMT
    Connecting to host 192.168.241.3, port 5201
          Cookie: Lab200slot2.1397238981.812898.548918
    [  4] local 192.168.241.2 port 38616 connected to 192.168.241.3 port 5201
    Starting Test: protocol: SCTP, 1 streams, 1452 byte blocks, omitting 0 seconds, 60 second test
    [ ID] Interval           Transfer     Bandwidth
    [  4]   0.00-1.09   sec  20.8 MBytes   161 Mbits/sec
    [  4]   1.09-2.13   sec  10.8 MBytes  86.8 Mbits/sec
    [  4]   2.13-3.15   sec  3.57 MBytes  29.5 Mbits/sec
    [  4]   3.15-4.16   sec  4.33 MBytes  35.7 Mbits/sec
    [  4]   4.16-6.21   sec  10.4 MBytes  42.7 Mbits/sec
    [  4]   6.21-6.21   sec  0.00 Bytes    0.00 bits/sec
    [  4]   6.21-7.35   sec  34.6 MBytes   253 Mbits/sec
    [  4]   7.35-11.45  sec  22.0 MBytes  45.0 Mbits/sec
    [  4]  11.45-11.45  sec  0.00 Bytes    0.00 bits/sec
    [  4]  11.45-11.45  sec  0.00 Bytes    0.00 bits/sec
    [  4]  11.45-11.45  sec  0.00 Bytes    0.00 bits/sec
    [  4]  11.45-12.51  sec  16.0 MBytes   126 Mbits/sec
    [  4]  12.51-13.59  sec  20.3 MBytes   158 Mbits/sec
    [  4]  13.59-14.65  sec  13.4 MBytes   107 Mbits/sec
    [  4]  14.65-16.79  sec  33.3 MBytes   130 Mbits/sec
    [  4]  16.79-16.79  sec  0.00 Bytes    0.00 bits/sec
    [  4]  16.79-17.82  sec  5.94 MBytes  48.7 Mbits/sec
    (etc)
    
    [root@Lab200slot2 ~]#  iperf3 --sctp -6 -c 2001:db8:0:f101::1 -V -l 1400 -t 60
    iperf version 3.0.1 (10 January 2014)
    Linux Lab200slot2 3.14.0 #1 SMP Thu Apr 3 23:18:29 EDT 2014 x86_64
    Time: Fri, 11 Apr 2014 19:08:41 GMT
    Connecting to host 2001:db8:0:f101::1, port 5201
          Cookie: Lab200slot2.1397243321.714295.2b3f7c
    [  4] local 2001:db8:0:f101::2 port 55804 connected to 2001:db8:0:f101::1 port 5201
    Starting Test: protocol: SCTP, 1 streams, 1400 byte blocks, omitting 0 seconds, 60 second test
    [ ID] Interval           Transfer     Bandwidth
    [  4]   0.00-1.00   sec   169 MBytes  1.42 Gbits/sec
    [  4]   1.00-2.00   sec   201 MBytes  1.69 Gbits/sec
    [  4]   2.00-3.00   sec   188 MBytes  1.58 Gbits/sec
    [  4]   3.00-4.00   sec   174 MBytes  1.46 Gbits/sec
    [  4]   4.00-5.00   sec   165 MBytes  1.39 Gbits/sec
    [  4]   5.00-6.00   sec   199 MBytes  1.67 Gbits/sec
    [  4]   6.00-7.00   sec   163 MBytes  1.36 Gbits/sec
    [  4]   7.00-8.00   sec   174 MBytes  1.46 Gbits/sec
    [  4]   8.00-9.00   sec   193 MBytes  1.62 Gbits/sec
    [  4]   9.00-10.00  sec   196 MBytes  1.65 Gbits/sec
    [  4]  10.00-11.00  sec   157 MBytes  1.31 Gbits/sec
    [  4]  11.00-12.00  sec   175 MBytes  1.47 Gbits/sec
    [  4]  12.00-13.00  sec   192 MBytes  1.61 Gbits/sec
    [  4]  13.00-14.00  sec   199 MBytes  1.67 Gbits/sec
    (etc)
    
    After patch:
    
    [root@Lab200slot2 ~]#  iperf3 --sctp -4 -c 192.168.240.3 -V -l 1452 -t 60
    iperf version 3.0.1 (10 January 2014)
    Linux Lab200slot2 3.14.0+ #1 SMP Mon Apr 14 12:06:40 EDT 2014 x86_64
    Time: Mon, 14 Apr 2014 16:40:48 GMT
    Connecting to host 192.168.240.3, port 5201
          Cookie: Lab200slot2.1397493648.413274.65e131
    [  4] local 192.168.240.2 port 50548 connected to 192.168.240.3 port 5201
    Starting Test: protocol: SCTP, 1 streams, 1452 byte blocks, omitting 0 seconds, 60 second test
    [ ID] Interval           Transfer     Bandwidth
    [  4]   0.00-1.00   sec   240 MBytes  2.02 Gbits/sec
    [  4]   1.00-2.00   sec   239 MBytes  2.01 Gbits/sec
    [  4]   2.00-3.00   sec   240 MBytes  2.01 Gbits/sec
    [  4]   3.00-4.00   sec   239 MBytes  2.00 Gbits/sec
    [  4]   4.00-5.00   sec   245 MBytes  2.05 Gbits/sec
    [  4]   5.00-6.00   sec   240 MBytes  2.01 Gbits/sec
    [  4]   6.00-7.00   sec   240 MBytes  2.02 Gbits/sec
    [  4]   7.00-8.00   sec   239 MBytes  2.01 Gbits/sec
    
    With the reverted patch applied, the SCTP/IPv4 performance is back
    to normal on latest upstream for IPv4 and IPv6 and has same throughput
    as 3.4.2 test kernel, steady and interval reports are smooth again.
    
    Fixes: ef2820a735f7 ("net: sctp: Fix a_rwnd/rwnd management to reflect real state of the receiver's buffer")
    Reported-by: Peter Butler <pbutler@sonusnet.com>
    Reported-by: Dongsheng Song <dongsheng.song@gmail.com>
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Tested-by: Peter Butler <pbutler@sonusnet.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nsn.com>
    Cc: Alexander Sverdlin <alexander.sverdlin@nsn.com>
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6ee76c804893..d992ca3145fe 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1653,6 +1653,17 @@ struct sctp_association {
 	/* This is the last advertised value of rwnd over a SACK chunk. */
 	__u32 a_rwnd;
 
+	/* Number of bytes by which the rwnd has slopped.  The rwnd is allowed
+	 * to slop over a maximum of the association's frag_point.
+	 */
+	__u32 rwnd_over;
+
+	/* Keeps treack of rwnd pressure.  This happens when we have
+	 * a window, but not recevie buffer (i.e small packets).  This one
+	 * is releases slowly (1 PMTU at a time ).
+	 */
+	__u32 rwnd_press;
+
 	/* This is the sndbuf size in use for the association.
 	 * This corresponds to the sndbuf size for the association,
 	 * as specified in the sk->sndbuf.
@@ -1881,7 +1892,8 @@ void sctp_assoc_update(struct sctp_association *old,
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
 void sctp_assoc_sync_pmtu(struct sock *, struct sctp_association *);
-void sctp_assoc_rwnd_update(struct sctp_association *, bool);
+void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);
+void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);
 void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
 void sctp_assoc_del_nonprimary_peers(struct sctp_association *,

commit ef2820a735f74ea60335f8ba3801b844f0cb184d
Author: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nsn.com>
Date:   Fri Feb 14 14:51:18 2014 +0100

    net: sctp: Fix a_rwnd/rwnd management to reflect real state of the receiver's buffer
    
    Implementation of (a)rwnd calculation might lead to severe performance issues
    and associations completely stalling. These problems are described and solution
    is proposed which improves lksctp's robustness in congestion state.
    
    1) Sudden drop of a_rwnd and incomplete window recovery afterwards
    
    Data accounted in sctp_assoc_rwnd_decrease takes only payload size (sctp data),
    but size of sk_buff, which is blamed against receiver buffer, is not accounted
    in rwnd. Theoretically, this should not be the problem as actual size of buffer
    is double the amount requested on the socket (SO_RECVBUF). Problem here is
    that this will have bad scaling for data which is less then sizeof sk_buff.
    E.g. in 4G (LTE) networks, link interfacing radio side will have a large portion
    of traffic of this size (less then 100B).
    
    An example of sudden drop and incomplete window recovery is given below. Node B
    exhibits problematic behavior. Node A initiates association and B is configured
    to advertise rwnd of 10000. A sends messages of size 43B (size of typical sctp
    message in 4G (LTE) network). On B data is left in buffer by not reading socket
    in userspace.
    
    Lets examine when we will hit pressure state and declare rwnd to be 0 for
    scenario with above stated parameters (rwnd == 10000, chunk size == 43, each
    chunk is sent in separate sctp packet)
    
    Logic is implemented in sctp_assoc_rwnd_decrease:
    
    socket_buffer (see below) is maximum size which can be held in socket buffer
    (sk_rcvbuf). current_alloced is amount of data currently allocated (rx_count)
    
    A simple expression is given for which it will be examined after how many
    packets for above stated parameters we enter pressure state:
    
    We start by condition which has to be met in order to enter pressure state:
    
            socket_buffer < currently_alloced;
    
    currently_alloced is represented as size of sctp packets received so far and not
    yet delivered to userspace. x is the number of chunks/packets (since there is no
    bundling, and each chunk is delivered in separate packet, we can observe each
    chunk also as sctp packet, and what is important here, having its own sk_buff):
    
            socket_buffer < x*each_sctp_packet;
    
    each_sctp_packet is sctp chunk size + sizeof(struct sk_buff). socket_buffer is
    twice the amount of initially requested size of socket buffer, which is in case
    of sctp, twice the a_rwnd requested:
    
            2*rwnd < x*(payload+sizeof(struc sk_buff));
    
    sizeof(struct sk_buff) is 190 (3.13.0-rc4+). Above is stated that rwnd is 10000
    and each payload size is 43
    
            20000 < x(43+190);
    
            x > 20000/233;
    
            x ~> 84;
    
    After ~84 messages, pressure state is entered and 0 rwnd is advertised while
    received 84*43B ~= 3612B sctp data. This is why external observer notices sudden
    drop from 6474 to 0, as it will be now shown in example:
    
    IP A.34340 > B.12345: sctp (1) [INIT] [init tag: 1875509148] [rwnd: 81920] [OS: 10] [MIS: 65535] [init TSN: 1096057017]
    IP B.12345 > A.34340: sctp (1) [INIT ACK] [init tag: 3198966556] [rwnd: 10000] [OS: 10] [MIS: 10] [init TSN: 902132839]
    IP A.34340 > B.12345: sctp (1) [COOKIE ECHO]
    IP B.12345 > A.34340: sctp (1) [COOKIE ACK]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057017] [SID: 0] [SSEQ 0] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057017] [a_rwnd 9957] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057018] [SID: 0] [SSEQ 1] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057018] [a_rwnd 9957] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057019] [SID: 0] [SSEQ 2] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057019] [a_rwnd 9914] [#gap acks 0] [#dup tsns 0]
    <...>
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057098] [SID: 0] [SSEQ 81] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057098] [a_rwnd 6517] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057099] [SID: 0] [SSEQ 82] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057099] [a_rwnd 6474] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057100] [SID: 0] [SSEQ 83] [PPID 0x18]
    
    --> Sudden drop
    
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057100] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    At this point, rwnd_press stores current rwnd value so it can be later restored
    in sctp_assoc_rwnd_increase. This however doesn't happen as condition to start
    slowly increasing rwnd until rwnd_press is returned to rwnd is never met. This
    condition is not met since rwnd, after it hit 0, must first reach rwnd_press by
    adding amount which is read from userspace. Let us observe values in above
    example. Initial a_rwnd is 10000, pressure was hit when rwnd was ~6500 and the
    amount of actual sctp data currently waiting to be delivered to userspace
    is ~3500. When userspace starts to read, sctp_assoc_rwnd_increase will be blamed
    only for sctp data, which is ~3500. Condition is never met, and when userspace
    reads all data, rwnd stays on 3569.
    
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057100] [a_rwnd 1505] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057100] [a_rwnd 3010] [#gap acks 0] [#dup tsns 0]
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057101] [SID: 0] [SSEQ 84] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057101] [a_rwnd 3569] [#gap acks 0] [#dup tsns 0]
    
    --> At this point userspace read everything, rwnd recovered only to 3569
    
    IP A.34340 > B.12345: sctp (1) [DATA] (B)(E) [TSN: 1096057102] [SID: 0] [SSEQ 85] [PPID 0x18]
    IP B.12345 > A.34340: sctp (1) [SACK] [cum ack 1096057102] [a_rwnd 3569] [#gap acks 0] [#dup tsns 0]
    
    Reproduction is straight forward, it is enough for sender to send packets of
    size less then sizeof(struct sk_buff) and receiver keeping them in its buffers.
    
    2) Minute size window for associations sharing the same socket buffer
    
    In case multiple associations share the same socket, and same socket buffer
    (sctp.rcvbuf_policy == 0), different scenarios exist in which congestion on one
    of the associations can permanently drop rwnd of other association(s).
    
    Situation will be typically observed as one association suddenly having rwnd
    dropped to size of last packet received and never recovering beyond that point.
    Different scenarios will lead to it, but all have in common that one of the
    associations (let it be association from 1)) nearly depleted socket buffer, and
    the other association blames socket buffer just for the amount enough to start
    the pressure. This association will enter pressure state, set rwnd_press and
    announce 0 rwnd.
    When data is read by userspace, similar situation as in 1) will occur, rwnd will
    increase just for the size read by userspace but rwnd_press will be high enough
    so that association doesn't have enough credit to reach rwnd_press and restore
    to previous state. This case is special case of 1), being worse as there is, in
    the worst case, only one packet in buffer for which size rwnd will be increased.
    Consequence is association which has very low maximum rwnd ('minute size', in
    our case down to 43B - size of packet which caused pressure) and as such
    unusable.
    
    Scenario happened in the field and labs frequently after congestion state (link
    breaks, different probabilities of packet drop, packet reordering) and with
    scenario 1) preceding. Here is given a deterministic scenario for reproduction:
    
    >From node A establish two associations on the same socket, with rcvbuf_policy
    being set to share one common buffer (sctp.rcvbuf_policy == 0). On association 1
    repeat scenario from 1), that is, bring it down to 0 and restore up. Observe
    scenario 1). Use small payload size (here we use 43). Once rwnd is 'recovered',
    bring it down close to 0, as in just one more packet would close it. This has as
    a consequence that association number 2 is able to receive (at least) one more
    packet which will bring it in pressure state. E.g. if association 2 had rwnd of
    10000, packet received was 43, and we enter at this point into pressure,
    rwnd_press will have 9957. Once payload is delivered to userspace, rwnd will
    increase for 43, but conditions to restore rwnd to original state, just as in
    1), will never be satisfied.
    
    --> Association 1, between A.y and B.12345
    
    IP A.55915 > B.12345: sctp (1) [INIT] [init tag: 836880897] [rwnd: 10000] [OS: 10] [MIS: 65535] [init TSN: 4032536569]
    IP B.12345 > A.55915: sctp (1) [INIT ACK] [init tag: 2873310749] [rwnd: 81920] [OS: 10] [MIS: 10] [init TSN: 3799315613]
    IP A.55915 > B.12345: sctp (1) [COOKIE ECHO]
    IP B.12345 > A.55915: sctp (1) [COOKIE ACK]
    
    --> Association 2, between A.z and B.12346
    
    IP A.55915 > B.12346: sctp (1) [INIT] [init tag: 534798321] [rwnd: 10000] [OS: 10] [MIS: 65535] [init TSN: 2099285173]
    IP B.12346 > A.55915: sctp (1) [INIT ACK] [init tag: 516668823] [rwnd: 81920] [OS: 10] [MIS: 10] [init TSN: 3676403240]
    IP A.55915 > B.12346: sctp (1) [COOKIE ECHO]
    IP B.12346 > A.55915: sctp (1) [COOKIE ACK]
    
    --> Deplete socket buffer by sending messages of size 43B over association 1
    
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315613] [SID: 0] [SSEQ 0] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315613] [a_rwnd 9957] [#gap acks 0] [#dup tsns 0]
    
    <...>
    
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315696] [a_rwnd 6388] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315697] [SID: 0] [SSEQ 84] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315697] [a_rwnd 6345] [#gap acks 0] [#dup tsns 0]
    
    --> Sudden drop on 1
    
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315698] [SID: 0] [SSEQ 85] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315698] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    --> Here userspace read, rwnd 'recovered' to 3698, now deplete again using
        association 1 so there is place in buffer for only one more packet
    
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315799] [SID: 0] [SSEQ 186] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315799] [a_rwnd 86] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315800] [SID: 0] [SSEQ 187] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315800] [a_rwnd 43] [#gap acks 0] [#dup tsns 0]
    
    --> Socket buffer is almost depleted, but there is space for one more packet,
        send them over association 2, size 43B
    
    IP B.12346 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3676403240] [SID: 0] [SSEQ 0] [PPID 0x18]
    IP A.55915 > B.12346: sctp (1) [SACK] [cum ack 3676403240] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    --> Immediate drop
    
    IP A.60995 > B.12346: sctp (1) [SACK] [cum ack 387491510] [a_rwnd 0] [#gap acks 0] [#dup tsns 0]
    
    --> Read everything from the socket, both association recover up to maximum rwnd
        they are capable of reaching, note that association 1 recovered up to 3698,
        and association 2 recovered only to 43
    
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315800] [a_rwnd 1548] [#gap acks 0] [#dup tsns 0]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315800] [a_rwnd 3053] [#gap acks 0] [#dup tsns 0]
    IP B.12345 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3799315801] [SID: 0] [SSEQ 188] [PPID 0x18]
    IP A.55915 > B.12345: sctp (1) [SACK] [cum ack 3799315801] [a_rwnd 3698] [#gap acks 0] [#dup tsns 0]
    IP B.12346 > A.55915: sctp (1) [DATA] (B)(E) [TSN: 3676403241] [SID: 0] [SSEQ 1] [PPID 0x18]
    IP A.55915 > B.12346: sctp (1) [SACK] [cum ack 3676403241] [a_rwnd 43] [#gap acks 0] [#dup tsns 0]
    
    A careful reader might wonder why it is necessary to reproduce 1) prior
    reproduction of 2). It is simply easier to observe when to send packet over
    association 2 which will push association into the pressure state.
    
    Proposed solution:
    
    Both problems share the same root cause, and that is improper scaling of socket
    buffer with rwnd. Solution in which sizeof(sk_buff) is taken into concern while
    calculating rwnd is not possible due to fact that there is no linear
    relationship between amount of data blamed in increase/decrease with IP packet
    in which payload arrived. Even in case such solution would be followed,
    complexity of the code would increase. Due to nature of current rwnd handling,
    slow increase (in sctp_assoc_rwnd_increase) of rwnd after pressure state is
    entered is rationale, but it gives false representation to the sender of current
    buffer space. Furthermore, it implements additional congestion control mechanism
    which is defined on implementation, and not on standard basis.
    
    Proposed solution simplifies whole algorithm having on mind definition from rfc:
    
    o  Receiver Window (rwnd): This gives the sender an indication of the space
       available in the receiver's inbound buffer.
    
    Core of the proposed solution is given with these lines:
    
    sctp_assoc_rwnd_update:
            if ((asoc->base.sk->sk_rcvbuf - rx_count) > 0)
                    asoc->rwnd = (asoc->base.sk->sk_rcvbuf - rx_count) >> 1;
            else
                    asoc->rwnd = 0;
    
    We advertise to sender (half of) actual space we have. Half is in the braces
    depending whether you would like to observe size of socket buffer as SO_RECVBUF
    or twice the amount, i.e. size is the one visible from userspace, that is,
    from kernelspace.
    In this way sender is given with good approximation of our buffer space,
    regardless of the buffer policy - we always advertise what we have. Proposed
    solution fixes described problems and removes necessity for rwnd restoration
    algorithm. Finally, as proposed solution is simplification, some lines of code,
    along with some bytes in struct sctp_association are saved.
    
    Version 2 of the patch addressed comments from Vlad. Name of the function is set
    to be more descriptive, and two parts of code are changed, in one removing the
    superfluous call to sctp_assoc_rwnd_update since call would not result in update
    of rwnd, and the other being reordering of the code in a way that call to
    sctp_assoc_rwnd_update updates rwnd. Version 3 corrected change introduced in v2
    in a way that existing function is not reordered/copied in line, but it is
    correctly called. Thanks Vlad for suggesting.
    
    Signed-off-by: Matija Glavinic Pecotic <matija.glavinic-pecotic.ext@nsn.com>
    Reviewed-by: Alexander Sverdlin <alexander.sverdlin@nsn.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d992ca3145fe..6ee76c804893 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1653,17 +1653,6 @@ struct sctp_association {
 	/* This is the last advertised value of rwnd over a SACK chunk. */
 	__u32 a_rwnd;
 
-	/* Number of bytes by which the rwnd has slopped.  The rwnd is allowed
-	 * to slop over a maximum of the association's frag_point.
-	 */
-	__u32 rwnd_over;
-
-	/* Keeps treack of rwnd pressure.  This happens when we have
-	 * a window, but not recevie buffer (i.e small packets).  This one
-	 * is releases slowly (1 PMTU at a time ).
-	 */
-	__u32 rwnd_press;
-
 	/* This is the sndbuf size in use for the association.
 	 * This corresponds to the sndbuf size for the association,
 	 * as specified in the sk->sndbuf.
@@ -1892,8 +1881,7 @@ void sctp_assoc_update(struct sctp_association *old,
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
 void sctp_assoc_sync_pmtu(struct sock *, struct sctp_association *);
-void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);
-void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);
+void sctp_assoc_rwnd_update(struct sctp_association *, bool);
 void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
 void sctp_assoc_del_nonprimary_peers(struct sctp_association *,

commit 6daaf0de2f3170206f57e7881adfbd8682cdd7fb
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Thu Jan 9 22:31:11 2014 -0800

    sctp: make sctp_addto_chunk_fixed local
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e9f732fda950..d992ca3145fe 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -649,7 +649,6 @@ int sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,
 			  struct iovec *data);
 void sctp_chunk_free(struct sctp_chunk *);
 void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
-void  *sctp_addto_chunk_fixed(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,
 				 const struct sctp_association *,
 				 struct sock *);

commit 56a4342dfe3145cd66f766adccb28fd9b571606d
Merge: 805c1f4aedab fe0d692bbc64
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jan 6 17:37:45 2014 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_pf.c
            net/ipv6/ip6_tunnel.c
            net/ipv6/ip6_vti.c
    
    ipv6 tunnel statistic bug fixes conflicting with consolidation into
    generic sw per-cpu net stats.
    
    qlogic conflict between queue counting bug fix and the addition
    of multiple MAC address support.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 619a60ee04be33238721a15c1f9704a2a515a33e
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Thu Jan 2 14:39:44 2014 -0500

    sctp: Remove outqueue empty state
    
    The SCTP outqueue structure maintains a data chunks
    that are pending transmission, the list of chunks that
    are pending a retransmission and a length of data in
    flight.  It also tries to keep the emtpy state so that
    it can performe shutdown sequence or notify user.
    
    The problem is that the empy state is inconsistently
    tracked.  It is possible to completely drain the queue
    without sending anything when using PR-SCTP.  In this
    case, the empty state will not be correctly state as
    report by Jamal Hadi Salim <jhs@mojatatu.com>.  This
    can cause an association to be perminantly stuck in the
    SHUTDOWN_PENDING state.
    
    Additionally, SCTP is incredibly inefficient when setting
    the empty state.  Even though all the data is availaible
    in the outqueue structure, we ignore it and walk a list
    of trasnports.
    
    In the end, we can completely remove the extra empty
    state and figure out if the queue is empty by looking
    at 3 things:  length of pending data, length of in-flight
    data, and exisiting of retransmit data.  All of these
    are already in the strucutre.
    
    Reported-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Tested-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 67b5d0068273..0a248b323d87 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1046,9 +1046,6 @@ struct sctp_outq {
 
 	/* Corked? */
 	char cork;
-
-	/* Is this structure empty?  */
-	char empty;
 };
 
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);

commit 143c9054949436cb05e468439dc5e46231f33d09
Merge: 0b6807034791 35eecf052250
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Dec 18 16:42:06 2013 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/intel/i40e/i40e_main.c
            drivers/net/macvtap.c
    
    Both minor merge hassles, simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit be78cfcb25fd163ad7c415cdc0ff343fbc8d22ec
Author: wangweidong <wangweidong1@huawei.com>
Date:   Fri Dec 13 13:51:04 2013 +0800

    sctp: Reorder 'struc association' members to reduce its size
    
    Members of 'struct association' are not in appropriate order to
    reuse compiler added padding on 64bit architectures. In this patch
    we reorder those struct members and help reduce the size of the
    structure from 2776 bytes to 2720 bytes on 64 bit architectures.
    
    Signed-off-by: Wang Weidong <wangweidong1@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e416d6ac9c70..e8b2ff5c2804 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1360,12 +1360,6 @@ struct sctp_association {
 
 	/* This is all information about our peer.  */
 	struct {
-		/* rwnd
-		 *
-		 * Peer Rwnd   : Current calculated value of the peer's rwnd.
-		 */
-		__u32 rwnd;
-
 		/* transport_addr_list
 		 *
 		 * Peer	       : A list of SCTP transport addresses that the
@@ -1383,6 +1377,12 @@ struct sctp_association {
 		 */
 		struct list_head transport_addr_list;
 
+		/* rwnd
+		 *
+		 * Peer Rwnd   : Current calculated value of the peer's rwnd.
+		 */
+		__u32 rwnd;
+
 		/* transport_count
 		 *
 		 * Peer        : A count of the number of peer addresses
@@ -1465,6 +1465,20 @@ struct sctp_association {
 		 */
 		struct sctp_tsnmap tsn_map;
 
+		/* This mask is used to disable sending the ASCONF chunk
+		 * with specified parameter to peer.
+		 */
+		__be16 addip_disabled_mask;
+
+		/* These are capabilities which our peer advertised.  */
+		__u8	ecn_capable:1,      /* Can peer do ECN? */
+			ipv4_address:1,     /* Peer understands IPv4 addresses? */
+			ipv6_address:1,     /* Peer understands IPv6 addresses? */
+			hostname_address:1, /* Peer understands DNS addresses? */
+			asconf_capable:1,   /* Does peer support ADDIP? */
+			prsctp_capable:1,   /* Can peer do PR-SCTP? */
+			auth_capable:1;     /* Is peer doing SCTP-AUTH? */
+
 		/* Ack State   : This flag indicates if the next received
 		 *             : packet is to be responded to with a
 		 *             : SACK. This is initializedto 0.  When a packet
@@ -1479,25 +1493,11 @@ struct sctp_association {
 		__u32	sack_cnt;
 		__u32	sack_generation;
 
-		/* These are capabilities which our peer advertised.  */
-		__u8	ecn_capable:1,	    /* Can peer do ECN? */
-			ipv4_address:1,	    /* Peer understands IPv4 addresses? */
-			ipv6_address:1,	    /* Peer understands IPv6 addresses? */
-			hostname_address:1, /* Peer understands DNS addresses? */
-			asconf_capable:1,   /* Does peer support ADDIP? */
-			prsctp_capable:1,   /* Can peer do PR-SCTP? */
-			auth_capable:1;	    /* Is peer doing SCTP-AUTH? */
-
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 
-		/* This mask is used to disable sending the ASCONF chunk
-		 * with specified parameter to peer.
-		 */
-		__be16 addip_disabled_mask;
-
 		struct sctp_inithdr_host i;
-		int cookie_len;
 		void *cookie;
+		int cookie_len;
 
 		/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.
 		 * C1) ... "Peer-Serial-Number'. This value MUST be initialized to the
@@ -1529,14 +1529,14 @@ struct sctp_association {
 	 */
 	sctp_state_t state;
 
-	/* The cookie life I award for any cookie.  */
-	ktime_t cookie_life;
-
 	/* Overall     : The overall association error count.
 	 * Error Count : [Clear this any time I get something.]
 	 */
 	int overall_error_count;
 
+	/* The cookie life I award for any cookie.  */
+	ktime_t cookie_life;
+
 	/* These are the association's initial, max, and min RTO values.
 	 * These values will be initialized by system defaults, but can
 	 * be modified via the SCTP_RTOINFO socket option.
@@ -1591,10 +1591,9 @@ struct sctp_association {
 	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
+	__u32 sackfreq;
 	/* SACK delay timeout */
 	unsigned long sackdelay;
-	__u32 sackfreq;
-
 
 	unsigned long timeouts[SCTP_NUM_TIMEOUT_TYPES];
 	struct timer_list timers[SCTP_NUM_TIMEOUT_TYPES];
@@ -1602,12 +1601,12 @@ struct sctp_association {
 	/* Transport to which SHUTDOWN chunk was last sent.  */
 	struct sctp_transport *shutdown_last_sent_to;
 
-	/* How many times have we resent a SHUTDOWN */
-	int shutdown_retries;
-
 	/* Transport to which INIT chunk was last sent.  */
 	struct sctp_transport *init_last_sent_to;
 
+	/* How many times have we resent a SHUTDOWN */
+	int shutdown_retries;
+
 	/* Next TSN    : The next TSN number to be assigned to a new
 	 *	       : DATA chunk.  This is sent in the INIT or INIT
 	 *	       : ACK chunk to the peer and incremented each
@@ -1818,8 +1817,8 @@ struct sctp_association {
 	 * after reaching 4294967295.
 	 */
 	__u32 addip_serial;
-	union sctp_addr *asconf_addr_del_pending;
 	int src_out_of_asoc_ok;
+	union sctp_addr *asconf_addr_del_pending;
 	struct sctp_transport *new_transport;
 
 	/* SCTP AUTH: list of the endpoint shared keys.  These

commit 9f70f46bd4c7267d48ef461a1d613ec9ec0d520c
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Tue Dec 10 06:48:15 2013 -0500

    sctp: properly latch and use autoclose value from sock to association
    
    Currently, sctp associations latch a sockets autoclose value to an association
    at association init time, subject to capping constraints from the max_autoclose
    sysctl value.  This leads to an odd situation where an application may set a
    socket level autoclose timeout, but sliently sctp will limit the autoclose
    timeout to something less than that.
    
    Fix this by modifying the autoclose setsockopt function to check the limit, cap
    it and warn the user via syslog that the timeout is capped.  This will allow
    getsockopt to return valid autoclose timeout values that reflect what subsequent
    associations actually use.
    
    While were at it, also elimintate the assoc->autoclose variable, it duplicates
    whats in the timeout array, which leads to multiple sources for the same
    information, that may differ (as the former isn't subject to any capping).  This
    gives us the timeout information in a canonical place and saves some space in
    the association structure as well.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    CC: Wang Weidong <wangweidong1@huawei.com>
    CC: David Miller <davem@davemloft.net>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: netdev@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ea0ca5f6e629..67b5d0068273 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1726,12 +1726,6 @@ struct sctp_association {
 	/* How many duplicated TSNs have we seen?  */
 	int numduptsns;
 
-	/* Number of seconds of idle time before an association is closed.
-	 * In the association context, this is really used as a boolean
-	 * since the real timeout is stored in the timeouts array
-	 */
-	__u32 autoclose;
-
 	/* These are to support
 	 * "SCTP Extensions for Dynamic Reconfiguration of IP Addresses
 	 *  and Enforcement of Flow and Message Limits"

commit 4b2f13a25133b115eb56771bd4a8e71a82aea968
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri Dec 6 06:28:48 2013 -0800

    sctp: Fix FSF address in file headers
    
    Several files refer to an old address for the Free Software Foundation
    in the file header comment.  Resolve by replacing the address with
    the URL <http://www.gnu.org/licenses/> so that we do not have to keep
    updating the header comments anytime the address changes.
    
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ea0ca5f6e629..e416d6ac9c70 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -19,9 +19,8 @@
  * See the GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with GNU CC; see the file COPYING.  If not, write to
- * the Free Software Foundation, 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
+ * along with GNU CC; see the file COPYING.  If not, see
+ * <http://www.gnu.org/licenses/>.
  *
  * Please send any bug reports or fixes you make to the
  * email addresses:

commit 6eabca54d6781f61c7318517c1463a098acb7a87
Author: Xufeng Zhang <xufeng.zhang@windriver.com>
Date:   Mon Nov 25 11:26:57 2013 +0800

    sctp: Restore 'resent' bit to avoid retransmitted chunks for RTT measurements
    
    Currently retransmitted DATA chunks could also be used for
    RTT measurements since there are no flag to identify whether
    the transmitted DATA chunk is a new one or a retransmitted one.
    This problem is introduced by commit ae19c5486 ("sctp: remove
    'resent' bit from the chunk") which inappropriately removed the
    'resent' bit completely, instead of doing this, we should set
    the resent bit only for the retransmitted DATA chunks.
    
    Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2174d8da0770..ea0ca5f6e629 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -629,6 +629,7 @@ struct sctp_chunk {
 #define SCTP_NEED_FRTX 0x1
 #define SCTP_DONT_FRTX 0x2
 	__u16	rtt_in_progress:1,	/* This chunk used for RTT calc? */
+		resent:1,		/* Has this chunk ever been resent. */
 		has_tsn:1,		/* Does this chunk have a TSN yet? */
 		has_ssn:1,		/* Does this chunk have a SSN yet? */
 		singleton:1,		/* Only chunk in the packet? */

commit 76bfd8984430be5b19727d09f6ab5e1d7a247f8c
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Aug 26 16:34:00 2013 +0200

    net: sctp: reorder sctp_globals to reduce cacheline usage
    
    Reduce cacheline usage from 2 to 1 cacheline for sctp_globals structure. By
    reordering elements, we can close gaps and simply achieve the following:
    
    Current situation:
      /* size: 80, cachelines: 2, members: 10 */
      /* sum members: 57, holes: 4, sum holes: 16 */
      /* padding: 7 */
      /* last cacheline: 16 bytes */
    
    Afterwards:
      /* size: 64, cachelines: 1, members: 10 */
      /* padding: 7 */
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 422db6cc3214..2174d8da0770 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -113,29 +113,27 @@ struct sctp_hashbucket {
 
 /* The SCTP globals structure. */
 extern struct sctp_globals {
-	/* The following variables are implementation specific.	 */
-
-	/* Default initialization values to be applied to new associations. */
-	__u16 max_instreams;
-	__u16 max_outstreams;
-
 	/* This is a list of groups of functions for each address
 	 * family that we support.
 	 */
 	struct list_head address_families;
 
 	/* This is the hash of all endpoints. */
-	int ep_hashsize;
 	struct sctp_hashbucket *ep_hashtable;
-
 	/* This is the hash of all associations. */
-	int assoc_hashsize;
 	struct sctp_hashbucket *assoc_hashtable;
-
 	/* This is the sctp port control hash.	*/
-	int port_hashsize;
 	struct sctp_bind_hashbucket *port_hashtable;
 
+	/* Sizes of above hashtables. */
+	int ep_hashsize;
+	int assoc_hashsize;
+	int port_hashsize;
+
+	/* Default initialization values to be applied to new associations. */
+	__u16 max_instreams;
+	__u16 max_outstreams;
+
 	/* Flag to indicate whether computing and verifying checksum
 	 * is disabled. */
         bool checksum_disable;

commit 71acc0ddd499cc323199fb1ae350ce9ea0744352
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Aug 9 13:09:41 2013 -0700

    Revert "net: sctp: convert sctp_checksum_disable module param into sctp sysctl"
    
    This reverts commit cda5f98e36576596b9230483ec52bff3cc97eb21.
    
    As per Vlad's request.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 78eedf0cd4b3..422db6cc3214 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -135,6 +135,10 @@ extern struct sctp_globals {
 	/* This is the sctp port control hash.	*/
 	int port_hashsize;
 	struct sctp_bind_hashbucket *port_hashtable;
+
+	/* Flag to indicate whether computing and verifying checksum
+	 * is disabled. */
+        bool checksum_disable;
 } sctp_globals;
 
 #define sctp_max_instreams		(sctp_globals.max_instreams)
@@ -146,6 +150,7 @@ extern struct sctp_globals {
 #define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
+#define sctp_checksum_disable		(sctp_globals.checksum_disable)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {

commit 477143e3fece3dc12629bb1ebd7b47e8e6e72b2b
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Aug 6 21:18:13 2013 +0200

    net: sctp: trivial: update bug report in header comment
    
    With the restructuring of the lksctp.org site, we only allow bug
    reports through the SCTP mailing list linux-sctp@vger.kernel.org,
    not via SF, as SF is only used for web hosting and nothing more.
    While at it, also remove the obvious statement that bugs will be
    fixed and incooperated into the kernel.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 06ebeaaaa9aa..78eedf0cd4b3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -27,9 +27,6 @@
  * email addresses:
  *    lksctp developers <linux-sctp@vger.kernel.org>
  *
- * Or submit a bug report through the following website:
- *    http://www.sf.net/projects/lksctp
- *
  * Written or modified by:
  *    Randall Stewart	    <randall@sctp.chicago.il.us>
  *    Ken Morneau	    <kmorneau@cisco.com>
@@ -46,9 +43,6 @@
  *    Ryan Layer	    <rmlayer@us.ibm.com>
  *    Anup Pemmaiah	    <pemmaiah@cc.usu.edu>
  *    Kevin Gao             <kevin.gao@intel.com>
- *
- * Any bugs reported given to us we will try to fix... any fixes shared will
- * be incorporated into the next SCTP release.
  */
 
 #ifndef __sctp_structs_h__

commit cda5f98e36576596b9230483ec52bff3cc97eb21
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Aug 6 21:18:12 2013 +0200

    net: sctp: convert sctp_checksum_disable module param into sctp sysctl
    
    Get rid of the last module parameter for SCTP and make this
    configurable via sysctl for SCTP like all the rest of SCTP's
    configuration knobs.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d9c93a77b1a9..06ebeaaaa9aa 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -141,10 +141,6 @@ extern struct sctp_globals {
 	/* This is the sctp port control hash.	*/
 	int port_hashsize;
 	struct sctp_bind_hashbucket *port_hashtable;
-
-	/* Flag to indicate whether computing and verifying checksum
-	 * is disabled. */
-        bool checksum_disable;
 } sctp_globals;
 
 #define sctp_max_instreams		(sctp_globals.max_instreams)
@@ -156,7 +152,6 @@ extern struct sctp_globals {
 #define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
-#define sctp_checksum_disable		(sctp_globals.checksum_disable)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {

commit 5a139296f872d438f17f7219411321b603c1622b
Author: fan.du <fan.du@windriver.com>
Date:   Mon Aug 5 17:13:03 2013 +0800

    sctp: Pack dst_cookie into 1st cacheline hole for 64bit host
    
    As dst_cookie is used in fast path sctp_transport_dst_check.
    
    Before:
    struct sctp_transport {
            struct list_head           transports;           /*     0    16 */
            atomic_t                   refcnt;               /*    16     4 */
            __u32                      dead:1;               /*    20:31  4 */
            __u32                      rto_pending:1;        /*    20:30  4 */
            __u32                      hb_sent:1;            /*    20:29  4 */
            __u32                      pmtu_pending:1;       /*    20:28  4 */
    
            /* XXX 28 bits hole, try to pack */
    
            __u32                      sack_generation;      /*    24     4 */
    
            /* XXX 4 bytes hole, try to pack */
    
            struct flowi               fl;                   /*    32    64 */
            /* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
            union sctp_addr            ipaddr;               /*    96    28 */
    
    After:
    struct sctp_transport {
            struct list_head           transports;           /*     0    16 */
            atomic_t                   refcnt;               /*    16     4 */
            __u32                      dead:1;               /*    20:31  4 */
            __u32                      rto_pending:1;        /*    20:30  4 */
            __u32                      hb_sent:1;            /*    20:29  4 */
            __u32                      pmtu_pending:1;       /*    20:28  4 */
    
            /* XXX 28 bits hole, try to pack */
    
            __u32                      sack_generation;      /*    24     4 */
            u32                        dst_cookie;           /*    28     4 */
            struct flowi               fl;                   /*    32    64 */
            /* --- cacheline 1 boundary (64 bytes) was 32 bytes ago --- */
            union sctp_addr            ipaddr;               /*    96    28 */
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c0f4e29eedd5..d9c93a77b1a9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -782,6 +782,7 @@ struct sctp_transport {
 
 	/* Has this transport moved the ctsn since we last sacked */
 	__u32 sack_generation;
+	u32 dst_cookie;
 
 	struct flowi fl;
 
@@ -946,7 +947,6 @@ struct sctp_transport {
 	__u64 hb_nonce;
 
 	struct rcu_head rcu;
-	u32 dst_cookie;
 };
 
 struct sctp_transport *sctp_transport_new(struct net *, const union sctp_addr *,

commit d27fc78208b53ccdfd6a57d4ac44a459ca66806f
Author: fan.du <fan.du@windriver.com>
Date:   Fri Aug 2 10:45:13 2013 +0800

    sctp: Don't lookup dst if transport dst is still valid
    
    When sctp sits on IPv6, sctp_transport_dst_check pass cookie as ZERO,
    as a result ip6_dst_check always fail out. This behaviour makes
    transport->dst useless, because every sctp_packet_transmit must look
    for valid dst.
    
    Add a dst_cookie into sctp_transport, and set the cookie whenever we
    get new dst for sctp_transport. So dst validness could be checked
    against it.
    
    Since I have split genid for IPv4 and IPv6, also delete/add IPv6 address
    will also bump IPv6 genid. So issues we discussed in:
    http://marc.info/?l=linux-netdev&m=137404469219410&w=4
    have all been sloved for this patch.
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 75c4c16601b6..c0f4e29eedd5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -946,6 +946,7 @@ struct sctp_transport {
 	__u64 hb_nonce;
 
 	struct rcu_head rcu;
+	u32 dst_cookie;
 };
 
 struct sctp_transport *sctp_transport_new(struct net *, const union sctp_addr *,

commit 91705c61b52029ab5da67a15a23eef08667bf40e
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Jul 23 14:51:47 2013 +0200

    net: sctp: trivial: update mailing list address
    
    The SCTP mailing list address to send patches or questions
    to is linux-sctp@vger.kernel.org and not
    lksctp-developers@lists.sourceforge.net anymore. Therefore,
    update all occurences.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e745c92a1532..75c4c16601b6 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -25,7 +25,7 @@
  *
  * Please send any bug reports or fixes you make to the
  * email addresses:
- *    lksctp developers <lksctp-developers@lists.sourceforge.net>
+ *    lksctp developers <linux-sctp@vger.kernel.org>
  *
  * Or submit a bug report through the following website:
  *    http://www.sf.net/projects/lksctp

commit 52db882f3fc2903014e638ee91e690085fe37fdb
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Jun 25 18:17:27 2013 +0200

    net: sctp: migrate cookie life from timeval to ktime
    
    Currently, SCTP code defines its own timeval functions (since timeval
    is rarely used inside the kernel by others), namely tv_lt() and
    TIMEVAL_ADD() macros, that operate on SCTP cookie expiration.
    
    We might as well remove all those, and operate directly on ktime
    structures for a couple of reasons: ktime is available on all archs;
    complexity of ktime calculations depending on the arch is less than
    (reduces to a simple arithmetic operations on archs with
    BITS_PER_LONG == 64 or CONFIG_KTIME_SCALAR) or equal to timeval
    functions (other archs); code becomes more readable; macros can be
    thrown out.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 1bd4c4144fe8..e745c92a1532 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -54,7 +54,7 @@
 #ifndef __sctp_structs_h__
 #define __sctp_structs_h__
 
-#include <linux/time.h>		/* We get struct timespec.    */
+#include <linux/ktime.h>
 #include <linux/socket.h>	/* linux/in.h needs this!!    */
 #include <linux/in.h>		/* We get struct sockaddr_in. */
 #include <linux/in6.h>		/* We get struct in6_addr     */
@@ -284,7 +284,7 @@ struct sctp_cookie {
 	__u32 peer_ttag;
 
 	/* When does this cookie expire? */
-	struct timeval expiration;
+	ktime_t expiration;
 
 	/* Number of inbound/outbound streams which are set
 	 * and negotiated during the INIT process.
@@ -1537,7 +1537,7 @@ struct sctp_association {
 	sctp_state_t state;
 
 	/* The cookie life I award for any cookie.  */
-	struct timeval cookie_life;
+	ktime_t cookie_life;
 
 	/* Overall     : The overall association error count.
 	 * Error Count : [Clear this any time I get something.]

commit 3e3251b3f289528732edab386ddf73ac428359b7
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Apr 18 21:59:37 2013 +0000

    net: sctp: minor: remove dead code from sctp_packet
    
    struct sctp_packet is currently embedded into sctp_transport or
    sits on the stack as 'singleton' in sctp_outq_flush(). Therefore,
    its member 'malloced' is always 0, thus a kfree() is never called.
    Because of that, we can just remove this code.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 64d469845f25..1bd4c4144fe8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -714,8 +714,7 @@ struct sctp_packet {
 	    has_sack:1,		/* This packet contains a SACK chunk. */
 	    has_auth:1,		/* This packet contains an AUTH chunk */
 	    has_data:1,		/* This packet contains at least 1 DATA chunk */
-	    ipfragok:1,		/* So let ip fragment this packet */
-	    malloced:1;		/* Is it malloced? */
+	    ipfragok:1;		/* So let ip fragment this packet */
 };
 
 struct sctp_packet *sctp_packet_init(struct sctp_packet *,

commit 50181c07cbde370986c4925b830ca291a2fc31ab
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:16 2013 +0000

    net: sctp: sctp_bind_addr: remove dead code
    
    The sctp_bind_addr structure has a 'malloced' member that is
    always set to 0, thus in sctp_bind_addr_free() the kfree()
    part can never be called. This part is embedded into
    sctp_ep_common anyway and never alloced.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d581af00120b..64d469845f25 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1093,8 +1093,6 @@ struct sctp_bind_addr {
 	 *	peer(s) in INIT and INIT ACK chunks.
 	 */
 	struct list_head address_list;
-
-	int malloced;	     /* Are we kfree()able?  */
 };
 
 void sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);

commit 8fa5df6d210a09241876b74d156c57d833dd057b
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:15 2013 +0000

    net: sctp: sctp_transport: remove unused variable
    
    sctp_transport's member 'malloced' is set to 1, never evaluated
    and the structure is kfreed anyway. So just remove it.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 73fd5de4d4cc..d581af00120b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -779,10 +779,7 @@ struct sctp_transport {
 		hb_sent:1,
 
 		/* Is the Path MTU update pending on this tranport */
-		pmtu_pending:1,
-
-		/* Is this structure kfree()able? */
-		malloced:1;
+		pmtu_pending:1;
 
 	/* Has this transport moved the ctsn since we last sacked */
 	__u32 sack_generation;

commit 165a4c31278c980862b2c2ddec408cf30341f3ec
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:12 2013 +0000

    net: sctp: sctp_outq: remove 'malloced' from its struct
    
    sctp_outq is embedded into sctp_association, and thus never
    kmalloced in any way. Also, malloced is always 0, thus kfree()
    is never called. Therefore, remove that dead piece of code.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 125a19c73531..73fd5de4d4cc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1059,9 +1059,6 @@ struct sctp_outq {
 
 	/* Is this structure empty?  */
 	char empty;
-
-	/* Are we kfree()able? */
-	char malloced;
 };
 
 void sctp_outq_init(struct sctp_association *, struct sctp_outq *);

commit ee16371e6c737684215ee10b4b9756b610d81272
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:11 2013 +0000

    net: sctp: sctp_inq: remove dead code
    
    sctp_inq is never kmalloced, since it's integrated into sctp_ep_common
    and only initialized from eps and assocs. Therefore, remove the dead
    code from there.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 3c1bb8dd1e26..125a19c73531 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -991,8 +991,6 @@ struct sctp_inq {
 	 * messages.
 	 */
 	struct work_struct immediate;
-
-	int malloced;	     /* Is this structure kfree()able?	*/
 };
 
 void sctp_inq_init(struct sctp_inq *);

commit 542c2d832087aa78566be49aa4284779a0a687b3
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 16 11:07:10 2013 +0000

    net: sctp: sctp_ssnmap: remove 'malloced' element from struct
    
    sctp_ssnmap_init() can only be called from sctp_ssnmap_new()
    where malloced is always set to 1. Thus, when we call
    sctp_ssnmap_free() the test for map->malloced evaluates always
    to true.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e12aa77abc59..3c1bb8dd1e26 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -399,7 +399,6 @@ struct sctp_stream {
 struct sctp_ssnmap {
 	struct sctp_stream in;
 	struct sctp_stream out;
-	int malloced;
 };
 
 struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out,

commit 0022d2dd4d76e0e7d5c241c343a5016fdfa2ad4f
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Apr 15 03:27:18 2013 +0000

    net: sctp: minor: make sctp_ep_common's member 'dead' a bool
    
    Since dead only holds two states (0,1), make it a bool instead
    of a 'char', which is more appropriate for its purpose.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 3e80eedab17d..e12aa77abc59 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1176,7 +1176,7 @@ struct sctp_ep_common {
 	 *   dead     - Do not attempt to use this object.
 	 */
 	atomic_t    refcnt;
-	char	    dead;
+	bool	    dead;
 
 	/* What socket does this endpoint belong to?  */
 	struct sock *sk;

commit ff2266cddd69f5e0c9d5121ed9218d2f694406cc
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Apr 15 03:27:17 2013 +0000

    net: sctp: remove sctp_ep_common struct member 'malloced'
    
    There is actually no need to keep this member in the structure, because
    after init it's always 1 anyway, thus always kfree called. This seems to
    be an ancient leftover from the very initial implementation from 2.5
    times. Only in case the initialization of an association fails, we leave
    base.malloced as 0, but we nevertheless kfree it in the error path in
    sctp_association_new().
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0e0f9d2322e3..3e80eedab17d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1174,11 +1174,9 @@ struct sctp_ep_common {
 	/* Some fields to help us manage this object.
 	 *   refcnt   - Reference count access to this object.
 	 *   dead     - Do not attempt to use this object.
-	 *   malloced - Do we need to kfree this object?
 	 */
 	atomic_t    refcnt;
 	char	    dead;
-	char	    malloced;
 
 	/* What socket does this endpoint belong to?  */
 	struct sock *sk;

commit 570617e79c3ab31ce426efe9024af84efca862eb
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Feb 12 05:15:33 2013 +0000

    net: sctp: remove unused multiple cookie keys
    
    Vlad says: The whole multiple cookie keys code is completely unused
    and has been all this time. Noone uses anything other then the
    secret_key[0] since there is no changeover support anywhere.
    
    Thus, for now clean up its left-over fragments.
    
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fdeb85a970fc..0e0f9d2322e3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1236,10 +1236,7 @@ struct sctp_endpoint {
 	 *	      Discussion in [RFC1750] can be helpful in
 	 *	      selection of the key.
 	 */
-	__u8 secret_key[SCTP_HOW_MANY_SECRETS][SCTP_SECRET_SIZE];
-	int current_key;
-	int last_key;
-	int key_changed_at;
+	__u8 secret_key[SCTP_SECRET_SIZE];
 
  	/* digest:  This is a digest of the sctp cookie.  This field is
  	 * 	    only used on the receive path when we try to validate

commit 45122ca26ced7fae41049326a3797a73f961db2e
Author: Thomas Graf <tgraf@suug.ch>
Date:   Thu Dec 6 09:25:05 2012 +0000

    sctp: Add RCU protection to assoc->transport_addr_list
    
    peer.transport_addr_list is currently only protected by sk_sock
    which is inpractical to acquire for procfs dumping purposes.
    
    This patch adds RCU protection allowing for the procfs readers to
    enter RCU read-side critical sections.
    
    Modification of the list continues to be serialized via sk_lock.
    
    V2: Use list_del_rcu() in sctp_association_free() to be safe
        Skip transports marked dead when dumping for procfs
    
    Cc: Vlad Yasevich <vyasevich@gmail.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c2521016d646..fdeb85a970fc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -949,6 +949,8 @@ struct sctp_transport {
 
 	/* 64-bit random number sent with heartbeat. */
 	__u64 hb_nonce;
+
+	struct rcu_head rcu;
 };
 
 struct sctp_transport *sctp_transport_new(struct net *, const union sctp_addr *,

commit 196d67593439b03088913227093e374235596e33
Author: Michele Baldessari <michele@acksyn.org>
Date:   Sat Dec 1 04:49:42 2012 +0000

    sctp: Add support to per-association statistics via a new SCTP_GET_ASSOC_STATS call
    
    The current SCTP stack is lacking a mechanism to have per association
    statistics. This is an implementation modeled after OpenSolaris'
    SCTP_GET_ASSOC_STATS.
    
    Userspace part will follow on lksctp if/when there is a general ACK on
    this.
    V4:
    - Move ipackets++ before q->immediate.func() for consistency reasons
    - Move sctp_max_rto() at the end of sctp_transport_update_rto() to avoid
      returning bogus RTO values
    - return asoc->rto_min when max_obs_rto value has not changed
    
    V3:
    - Increase ictrlchunks in sctp_assoc_bh_rcv() as well
    - Move ipackets++ to sctp_inq_push()
    - return 0 when no rto updates took place since the last call
    
    V2:
    - Implement partial retrieval of stat struct to cope for future expansion
    - Kill the rtxpackets counter as it cannot be precise anyway
    - Rename outseqtsns to outofseqtsns to make it clearer that these are out
      of sequence unexpected TSNs
    - Move asoc->ipackets++ under a lock to avoid potential miscounts
    - Fold asoc->opackets++ into the already existing asoc check
    - Kill unneeded (q->asoc) test when increasing rtxchunks
    - Do not count octrlchunks if sending failed (SCTP_XMIT_OK != 0)
    - Don't count SHUTDOWNs as SACKs
    - Move SCTP_GET_ASSOC_STATS to the private space API
    - Adjust the len check in sctp_getsockopt_assoc_stats() to allow for
      future struct growth
    - Move association statistics in their own struct
    - Update idupchunks when we send a SACK with dup TSNs
    - return min_rto in max_rto when RTO has not changed. Also return the
      transport when max_rto last changed.
    
    Signed-off: Michele Baldessari <michele@acksyn.org>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2b2f61dd4036..c2521016d646 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1312,6 +1312,40 @@ struct sctp_inithdr_host {
 	__u32 initial_tsn;
 };
 
+/* SCTP_GET_ASSOC_STATS counters */
+struct sctp_priv_assoc_stats {
+	/* Maximum observed rto in the association during subsequent
+	 * observations. Value is set to 0 if no RTO measurement took place
+	 * The transport where the max_rto was observed is returned in
+	 * obs_rto_ipaddr
+	 */
+	struct sockaddr_storage obs_rto_ipaddr;
+	__u64 max_obs_rto;
+	/* Total In and Out SACKs received and sent */
+	__u64 isacks;
+	__u64 osacks;
+	/* Total In and Out packets received and sent */
+	__u64 opackets;
+	__u64 ipackets;
+	/* Total retransmitted chunks */
+	__u64 rtxchunks;
+	/* TSN received > next expected */
+	__u64 outofseqtsns;
+	/* Duplicate Chunks received */
+	__u64 idupchunks;
+	/* Gap Ack Blocks received */
+	__u64 gapcnt;
+	/* Unordered data chunks sent and received */
+	__u64 ouodchunks;
+	__u64 iuodchunks;
+	/* Ordered data chunks sent and received */
+	__u64 oodchunks;
+	__u64 iodchunks;
+	/* Control chunks sent and received */
+	__u64 octrlchunks;
+	__u64 ictrlchunks;
+};
+
 /* RFC2960
  *
  * 12. Recommended Transmission Control Block (TCB) Parameters
@@ -1830,6 +1864,8 @@ struct sctp_association {
 
 	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
 	     temp:1;		/* Is it a temporary association? */
+
+	struct sctp_priv_assoc_stats stats;
 };
 
 

commit 3c68198e75111a905ac2412be12bf7b29099729b
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Oct 24 09:20:03 2012 +0000

    sctp: Make hmac algorithm selection for cookie generation dynamic
    
    Currently sctp allows for the optional use of md5 of sha1 hmac algorithms to
    generate cookie values when establishing new connections via two build time
    config options.  Theres no real reason to make this a static selection.  We can
    add a sysctl that allows for the dynamic selection of these algorithms at run
    time, with the default value determined by the corresponding crypto library
    availability.
    This comes in handy when, for example running a system in FIPS mode, where use
    of md5 is disallowed, but SHA1 is permitted.
    
    Note: This new sysctl has no corresponding socket option to select the cookie
    hmac algorithm.  I chose not to implement that intentionally, as RFC 6458
    contains no option for this value, and I opted not to pollute the socket option
    namespace.
    
    Change notes:
    v2)
            * Updated subject to have the proper sctp prefix as per Dave M.
            * Replaced deafult selection options with new options that allow
              developers to explicitly select available hmac algs at build time
              as per suggestion by Vlad Y.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: netdev@vger.kernel.org
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 64158aa1bb5f..2b2f61dd4036 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -177,6 +177,7 @@ struct sctp_sock {
 
 	/* Access to HMAC transform. */
 	struct crypto_hash *hmac;
+	char *sctp_hmac_alg;
 
 	/* What is our base endpointer? */
 	struct sctp_endpoint *ep;

commit edfee0339e681a784ebacec7e8c2dc97dc6d2839
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Wed Oct 3 05:43:22 2012 +0000

    sctp: check src addr when processing SACK to update transport state
    
    Suppose we have an SCTP connection with two paths. After connection is
    established, path1 is not available, thus this path is marked as inactive. Then
    traffic goes through path2, but for some reasons packets are delayed (after
    rto.max). Because packets are delayed, the retransmit mechanism will switch
    again to path1. At this time, we receive a delayed SACK from path2. When we
    update the state of the path in sctp_check_transmitted(), we do not take into
    account the source address of the SACK, hence we update the wrong path.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0fef00f5d3ce..64158aa1bb5f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1068,7 +1068,7 @@ void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
 void sctp_outq_teardown(struct sctp_outq *);
 void sctp_outq_free(struct sctp_outq*);
 int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk);
-int sctp_outq_sack(struct sctp_outq *, struct sctp_sackhdr *);
+int sctp_outq_sack(struct sctp_outq *, struct sctp_chunk *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);
 

commit e1fc3b14f9a90d9591016749289f2c3d7b35fbf4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Aug 7 07:29:57 2012 +0000

    sctp: Make sysctl tunables per net
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 18052b421203..0fef00f5d3ce 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -119,69 +119,6 @@ struct sctp_hashbucket {
 
 /* The SCTP globals structure. */
 extern struct sctp_globals {
-	/* RFC2960 Section 14. Suggested SCTP Protocol Parameter Values
-	 *
-	 * The following protocol parameters are RECOMMENDED:
-	 *
-	 * RTO.Initial		    - 3	 seconds
-	 * RTO.Min		    - 1	 second
-	 * RTO.Max		   -  60 seconds
-	 * RTO.Alpha		    - 1/8  (3 when converted to right shifts.)
-	 * RTO.Beta		    - 1/4  (2 when converted to right shifts.)
-	 */
-	unsigned int rto_initial;
-	unsigned int rto_min;
-	unsigned int rto_max;
-
-	/* Note: rto_alpha and rto_beta are really defined as inverse
-	 * powers of two to facilitate integer operations.
-	 */
-	int rto_alpha;
-	int rto_beta;
-
-	/* Max.Burst		    - 4 */
-	int max_burst;
-
-	/* Whether Cookie Preservative is enabled(1) or not(0) */
-	int cookie_preserve_enable;
-
-	/* Valid.Cookie.Life	    - 60  seconds  */
-	unsigned int valid_cookie_life;
-
-	/* Delayed SACK timeout  200ms default*/
-	unsigned int sack_timeout;
-
-	/* HB.interval		    - 30 seconds  */
-	unsigned int hb_interval;
-
-	/* Association.Max.Retrans  - 10 attempts
-	 * Path.Max.Retrans	    - 5	 attempts (per destination address)
-	 * Max.Init.Retransmits	    - 8	 attempts
-	 */
-	int max_retrans_association;
-	int max_retrans_path;
-	int max_retrans_init;
-
-	/* Potentially-Failed.Max.Retrans sysctl value
-	 * taken from:
-	 * http://tools.ietf.org/html/draft-nishida-tsvwg-sctp-failover-05
-	 */
-	int pf_retrans;
-
-	/*
-	 * Policy for preforming sctp/socket accounting
-	 * 0   - do socket level accounting, all assocs share sk_sndbuf
-	 * 1   - do sctp accounting, each asoc may use sk_sndbuf bytes
-	 */
-	int sndbuf_policy;
-
-	/*
-	 * Policy for preforming sctp/socket accounting
-	 * 0   - do socket level accounting, all assocs share sk_rcvbuf
-	 * 1   - do sctp accounting, each asoc may use sk_rcvbuf bytes
-	 */
-	int rcvbuf_policy;
-
 	/* The following variables are implementation specific.	 */
 
 	/* Default initialization values to be applied to new associations. */
@@ -205,56 +142,11 @@ extern struct sctp_globals {
 	int port_hashsize;
 	struct sctp_bind_hashbucket *port_hashtable;
 
-	int default_auto_asconf;
-	
-	/* Flag to indicate if addip is enabled. */
-	int addip_enable;
-	int addip_noauth_enable;
-
-	/* Flag to indicate if PR-SCTP is enabled. */
-	int prsctp_enable;
-
-	/* Flag to idicate if SCTP-AUTH is enabled */
-	int auth_enable;
-
-	/*
-	 * Policy to control SCTP IPv4 address scoping
-	 * 0   - Disable IPv4 address scoping
-	 * 1   - Enable IPv4 address scoping
-	 * 2   - Selectively allow only IPv4 private addresses
-	 * 3   - Selectively allow only IPv4 link local address
-	 */
-	int ipv4_scope_policy;
-
 	/* Flag to indicate whether computing and verifying checksum
 	 * is disabled. */
         bool checksum_disable;
-
-	/* Threshold for rwnd update SACKS.  Receive buffer shifted this many
-	 * bits is an indicator of when to send and window update SACK.
-	 */
-	int rwnd_update_shift;
-
-	/* Threshold for autoclose timeout, in seconds. */
-	unsigned long max_autoclose;
 } sctp_globals;
 
-#define sctp_rto_initial		(sctp_globals.rto_initial)
-#define sctp_rto_min			(sctp_globals.rto_min)
-#define sctp_rto_max			(sctp_globals.rto_max)
-#define sctp_rto_alpha			(sctp_globals.rto_alpha)
-#define sctp_rto_beta			(sctp_globals.rto_beta)
-#define sctp_max_burst			(sctp_globals.max_burst)
-#define sctp_valid_cookie_life		(sctp_globals.valid_cookie_life)
-#define sctp_cookie_preserve_enable	(sctp_globals.cookie_preserve_enable)
-#define sctp_max_retrans_association	(sctp_globals.max_retrans_association)
-#define sctp_sndbuf_policy	 	(sctp_globals.sndbuf_policy)
-#define sctp_rcvbuf_policy	 	(sctp_globals.rcvbuf_policy)
-#define sctp_max_retrans_path		(sctp_globals.max_retrans_path)
-#define sctp_pf_retrans			(sctp_globals.pf_retrans)
-#define sctp_max_retrans_init		(sctp_globals.max_retrans_init)
-#define sctp_sack_timeout		(sctp_globals.sack_timeout)
-#define sctp_hb_interval		(sctp_globals.hb_interval)
 #define sctp_max_instreams		(sctp_globals.max_instreams)
 #define sctp_max_outstreams		(sctp_globals.max_outstreams)
 #define sctp_address_families		(sctp_globals.address_families)
@@ -264,15 +156,7 @@ extern struct sctp_globals {
 #define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
-#define sctp_default_auto_asconf	(sctp_globals.default_auto_asconf)
-#define sctp_scope_policy		(sctp_globals.ipv4_scope_policy)
-#define sctp_addip_enable		(sctp_globals.addip_enable)
-#define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
-#define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
-#define sctp_auth_enable		(sctp_globals.auth_enable)
 #define sctp_checksum_disable		(sctp_globals.checksum_disable)
-#define sctp_rwnd_upd_shift		(sctp_globals.rwnd_update_shift)
-#define sctp_max_autoclose		(sctp_globals.max_autoclose)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {

commit f53b5b097e58361668b785eff9f7bcd12b4255ec
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Aug 7 07:29:08 2012 +0000

    sctp: Push struct net down into sctp_verify_ext_param
    
    Add struct net as a parameter to sctp_verify_param so it can be passed
    to sctp_verify_ext_param where struct net will be needed when the sctp
    tunables become per net tunables.
    
    Add struct net as a parameter to sctp_verify_init so struct net can be
    passed to sctp_verify_param.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b0882f3a3a51..18052b421203 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1410,9 +1410,9 @@ struct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *,
 int sctp_has_association(struct net *net, const union sctp_addr *laddr,
 			 const union sctp_addr *paddr);
 
-int sctp_verify_init(const struct sctp_association *asoc, sctp_cid_t,
-		     sctp_init_chunk_t *peer_init, struct sctp_chunk *chunk,
-		     struct sctp_chunk **err_chunk);
+int sctp_verify_init(struct net *net, const struct sctp_association *asoc,
+		     sctp_cid_t, sctp_init_chunk_t *peer_init,
+		     struct sctp_chunk *chunk, struct sctp_chunk **err_chunk);
 int sctp_process_init(struct sctp_association *, struct sctp_chunk *chunk,
 		      const union sctp_addr *peer,
 		      sctp_init_chunk_t *init, gfp_t gfp);

commit e7ff4a7037e6908b7a5f4682945a0b097d5b3535
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Aug 7 07:27:02 2012 +0000

    sctp: Push struct net down into sctp_in_scope
    
    struct net will be needed shortly when the tunables are made per network
    namespace.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 88d217941579..b0882f3a3a51 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1248,7 +1248,7 @@ int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
 			   __u16 port, gfp_t gfp);
 
 sctp_scope_t sctp_scope(const union sctp_addr *);
-int sctp_in_scope(const union sctp_addr *addr, const sctp_scope_t scope);
+int sctp_in_scope(struct net *net, const union sctp_addr *addr, const sctp_scope_t scope);
 int sctp_is_any(struct sock *sk, const union sctp_addr *addr);
 int sctp_addr_is_valid(const union sctp_addr *addr);
 int sctp_is_ep_boundall(struct sock *sk);

commit 89bf3450cb9b041b1bb4bcc5e7cbdeab4545b1c1
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Aug 7 07:26:14 2012 +0000

    sctp: Push struct net down into sctp_transport_init
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6bdfcabe560e..88d217941579 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1066,7 +1066,7 @@ struct sctp_transport {
 	__u64 hb_nonce;
 };
 
-struct sctp_transport *sctp_transport_new(const union sctp_addr *,
+struct sctp_transport *sctp_transport_new(struct net *, const union sctp_addr *,
 					  gfp_t);
 void sctp_transport_set_owner(struct sctp_transport *,
 			      struct sctp_association *);

commit 4db67e808640e3934d82ce61ee8e2e89fd877ba8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 6 08:42:04 2012 +0000

    sctp: Make the address lists per network namespace
    
    - Move the address lists into struct net
    - Add per network namespace initialization and cleanup
    - Pass around struct net so it is everywhere I need it.
    - Rename all of the global variable references into references
      to the variables moved into struct net
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c0563d1dd7c7..6bdfcabe560e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -205,21 +205,7 @@ extern struct sctp_globals {
 	int port_hashsize;
 	struct sctp_bind_hashbucket *port_hashtable;
 
-	/* This is the global local address list.
-	 * We actively maintain this complete list of addresses on
-	 * the system by catching address add/delete events.
-	 *
-	 * It is a list of sctp_sockaddr_entry.
-	 */
-	struct list_head local_addr_list;
 	int default_auto_asconf;
-	struct list_head addr_waitq;
-	struct timer_list addr_wq_timer;
-	struct list_head auto_asconf_splist;
-	spinlock_t addr_wq_lock;
-
-	/* Lock that protects the local_addr_list writers */
-	spinlock_t addr_list_lock;
 	
 	/* Flag to indicate if addip is enabled. */
 	int addip_enable;
@@ -278,12 +264,6 @@ extern struct sctp_globals {
 #define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
-#define sctp_local_addr_list		(sctp_globals.local_addr_list)
-#define sctp_local_addr_lock		(sctp_globals.addr_list_lock)
-#define sctp_auto_asconf_splist		(sctp_globals.auto_asconf_splist)
-#define sctp_addr_waitq			(sctp_globals.addr_waitq)
-#define sctp_addr_wq_timer		(sctp_globals.addr_wq_timer)
-#define sctp_addr_wq_lock		(sctp_globals.addr_wq_lock)
 #define sctp_default_auto_asconf	(sctp_globals.default_auto_asconf)
 #define sctp_scope_policy		(sctp_globals.ipv4_scope_policy)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
@@ -1241,7 +1221,7 @@ struct sctp_bind_addr {
 
 void sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);
 void sctp_bind_addr_free(struct sctp_bind_addr *);
-int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
+int sctp_bind_addr_copy(struct net *net, struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
 			sctp_scope_t scope, gfp_t gfp,
 			int flags);

commit 4110cc255ddec59c79fba4d71cdd948d0a382140
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 6 08:41:13 2012 +0000

    sctp: Make the association hashtable handle multiple network namespaces
    
    - Use struct net in the hash calculation
    - Use sock_net(association.base.sk) in the association lookups.
    - On receive calculate the network namespace from skb->dev.
    - Pass struct net from receive down to the functions that actually
      do the association lookup.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9f9de558541f..c0563d1dd7c7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1427,7 +1427,7 @@ int sctp_endpoint_is_peeled_off(struct sctp_endpoint *,
 				const union sctp_addr *);
 struct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *,
 					struct net *, const union sctp_addr *);
-int sctp_has_association(const union sctp_addr *laddr,
+int sctp_has_association(struct net *net, const union sctp_addr *laddr,
 			 const union sctp_addr *paddr);
 
 int sctp_verify_init(const struct sctp_association *asoc, sctp_cid_t,
@@ -2014,6 +2014,7 @@ void sctp_assoc_control_transport(struct sctp_association *,
 				  sctp_transport_cmd_t, sctp_sn_error_t);
 struct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *, __u32);
 struct sctp_transport *sctp_assoc_is_match(struct sctp_association *,
+					   struct net *,
 					   const union sctp_addr *,
 					   const union sctp_addr *);
 void sctp_assoc_migrate(struct sctp_association *, struct sock *);

commit 4cdadcbcb64bdf3ae8bdf3ef5bb2b91c85444cfa
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 6 08:40:21 2012 +0000

    sctp: Make the endpoint hashtable handle multiple network namespaces
    
    - Use struct net in the hash calculation
    - Use sock_net(endpoint.base.sk) in the endpoint lookups.
    - On receive calculate the network namespace from skb->dev.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c089bb12af77..9f9de558541f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1426,7 +1426,7 @@ struct sctp_association *sctp_endpoint_lookup_assoc(
 int sctp_endpoint_is_peeled_off(struct sctp_endpoint *,
 				const union sctp_addr *);
 struct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *,
-					const union sctp_addr *);
+					struct net *, const union sctp_addr *);
 int sctp_has_association(const union sctp_addr *laddr,
 			 const union sctp_addr *paddr);
 

commit f1f4376307ca45558eb22487022aefceed7385e8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Aug 6 08:39:38 2012 +0000

    sctp: Make the port hash table use struct net in it's key.
    
    - Add struct net into the port hash table hash calculation
    - Add struct net inot the struct sctp_bind_bucket so there
      is a memory of which network namespace a port is allocated in.
      No need for a ref count because sctp_bind_bucket only exists
      when there are sockets in the hash table and sockets can not
      change their network namspace, and sockets already ref count
      their network namespace.
    - Add struct net into the key comparison when we are testing
      to see if we have found the port hash table entry we are
      looking for.
    
    With these changes lookups in the port hash table becomes
    safe to use in multiple network namespaces.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fc5e60016e37..c089bb12af77 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -102,6 +102,7 @@ struct sctp_bind_bucket {
 	unsigned short	fastreuse;
 	struct hlist_node	node;
 	struct hlist_head	owner;
+	struct net	*net;
 };
 
 struct sctp_bind_hashbucket {

commit 5aa93bcf66f4af094d6f11096e81d5501a0b4ba5
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Sat Jul 21 07:56:07 2012 +0000

    sctp: Implement quick failover draft from tsvwg
    
    I've seen several attempts recently made to do quick failover of sctp transports
    by reducing various retransmit timers and counters.  While its possible to
    implement a faster failover on multihomed sctp associations, its not
    particularly robust, in that it can lead to unneeded retransmits, as well as
    false connection failures due to intermittent latency on a network.
    
    Instead, lets implement the new ietf quick failover draft found here:
    http://tools.ietf.org/html/draft-nishida-tsvwg-sctp-failover-05
    
    This will let the sctp stack identify transports that have had a small number of
    errors, and avoid using them quickly until their reliability can be
    re-established.  I've tested this out on two virt guests connected via multiple
    isolated virt networks and believe its in compliance with the above draft and
    works well.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Vlad Yasevich <vyasevich@gmail.com>
    CC: Sridhar Samudrala <sri@us.ibm.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: linux-sctp@vger.kernel.org
    CC: joe@perches.com
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 536e439ddf1d..fc5e60016e37 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -161,6 +161,12 @@ extern struct sctp_globals {
 	int max_retrans_path;
 	int max_retrans_init;
 
+	/* Potentially-Failed.Max.Retrans sysctl value
+	 * taken from:
+	 * http://tools.ietf.org/html/draft-nishida-tsvwg-sctp-failover-05
+	 */
+	int pf_retrans;
+
 	/*
 	 * Policy for preforming sctp/socket accounting
 	 * 0   - do socket level accounting, all assocs share sk_sndbuf
@@ -258,6 +264,7 @@ extern struct sctp_globals {
 #define sctp_sndbuf_policy	 	(sctp_globals.sndbuf_policy)
 #define sctp_rcvbuf_policy	 	(sctp_globals.rcvbuf_policy)
 #define sctp_max_retrans_path		(sctp_globals.max_retrans_path)
+#define sctp_pf_retrans			(sctp_globals.pf_retrans)
 #define sctp_max_retrans_init		(sctp_globals.max_retrans_init)
 #define sctp_sack_timeout		(sctp_globals.sack_timeout)
 #define sctp_hb_interval		(sctp_globals.hb_interval)
@@ -990,10 +997,15 @@ struct sctp_transport {
 
 	/* This is the max_retrans value for the transport and will
 	 * be initialized from the assocs value.  This can be changed
-	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
+	 * using the SCTP_SET_PEER_ADDR_PARAMS socket option.
 	 */
 	__u16 pathmaxrxt;
 
+	/* This is the partially failed retrans value for the transport
+	 * and will be initialized from the assocs value.  This can be changed
+	 * using the SCTP_PEER_ADDR_THLDS socket option
+	 */
+	int pf_retrans;
 	/* PMTU	      : The current known path MTU.  */
 	__u32 pathmtu;
 
@@ -1664,6 +1676,12 @@ struct sctp_association {
 	 */
 	int max_retrans;
 
+	/* This is the partially failed retrans value for the transport
+	 * and will be initialized from the assocs value.  This can be
+	 * changed using the SCTP_PEER_ADDR_THLDS socket option
+	 */
+	int pf_retrans;
+
 	/* Maximum number of times the endpoint will retransmit INIT  */
 	__u16 max_init_attempts;
 

commit 02f3d4ce9e81434a365f4643020b0402f6fe3332
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jul 16 03:57:14 2012 -0700

    sctp: Adjust PMTU updates to accomodate route invalidation.
    
    This adjusts the call to dst_ops->update_pmtu() so that we can
    transparently handle the fact that, in the future, the dst itself can
    be invalidated by the PMTU update (when we have non-host routes cached
    in sockets).
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fecdf31816f2..536e439ddf1d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1091,7 +1091,7 @@ void sctp_transport_burst_limited(struct sctp_transport *);
 void sctp_transport_burst_reset(struct sctp_transport *);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
 void sctp_transport_reset(struct sctp_transport *);
-void sctp_transport_update_pmtu(struct sctp_transport *, u32);
+void sctp_transport_update_pmtu(struct sock *, struct sctp_transport *, u32);
 void sctp_transport_immediate_rtx(struct sctp_transport *);
 
 
@@ -2003,7 +2003,7 @@ void sctp_assoc_update(struct sctp_association *old,
 
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
-void sctp_assoc_sync_pmtu(struct sctp_association *);
+void sctp_assoc_sync_pmtu(struct sock *, struct sctp_association *);
 void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);
 void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);
 void sctp_assoc_set_primary(struct sctp_association *,

commit 4244854d22bf8f782698c5224b9191c8d2d42610
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Sat Jun 30 03:04:26 2012 +0000

    sctp: be more restrictive in transport selection on bundled sacks
    
    It was noticed recently that when we send data on a transport, its possible that
    we might bundle a sack that arrived on a different transport.  While this isn't
    a major problem, it does go against the SHOULD requirement in section 6.4 of RFC
    2960:
    
     An endpoint SHOULD transmit reply chunks (e.g., SACK, HEARTBEAT ACK,
       etc.) to the same destination transport address from which it
       received the DATA or control chunk to which it is replying.  This
       rule should also be followed if the endpoint is bundling DATA chunks
       together with the reply chunk.
    
    This patch seeks to correct that.  It restricts the bundling of sack operations
    to only those transports which have moved the ctsn of the association forward
    since the last sack.  By doing this we guarantee that we only bundle outbound
    saks on a transport that has received a chunk since the last sack.  This brings
    us into stricter compliance with the RFC.
    
    Vlad had initially suggested that we strictly allow only sack bundling on the
    transport that last moved the ctsn forward.  While this makes sense, I was
    concerned that doing so prevented us from bundling in the case where we had
    received chunks that moved the ctsn on multiple transports.  In those cases, the
    RFC allows us to select any of the transports having received chunks to bundle
    the sack on.  so I've modified the approach to allow for that, by adding a state
    variable to each transport that tracks weather it has moved the ctsn since the
    last sack.  This I think keeps our behavior (and performance), close enough to
    our current profile that I think we can do this without a sysctl knob to
    enable/disable it.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: Vlad Yaseivch <vyasevich@gmail.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: linux-sctp@vger.kernel.org
    Reported-by: Michele Baldessari <michele@redhat.com>
    Reported-by: sorin serban <sserban@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e4652fe58958..fecdf31816f2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -912,6 +912,9 @@ struct sctp_transport {
 		/* Is this structure kfree()able? */
 		malloced:1;
 
+	/* Has this transport moved the ctsn since we last sacked */
+	__u32 sack_generation;
+
 	struct flowi fl;
 
 	/* This is the peer's IP address and port. */
@@ -1584,6 +1587,7 @@ struct sctp_association {
 		 */
 		__u8    sack_needed;     /* Do we need to sack the peer? */
 		__u32	sack_cnt;
+		__u32	sack_generation;
 
 		/* These are capabilities which our peer advertised.  */
 		__u8	ecn_capable:1,	    /* Can peer do ECN? */

commit 95c961747284a6b83a5e2d81240e214b0fa3464d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sun Apr 15 05:58:06 2012 +0000

    net: cleanup unsigned to unsigned int
    
    Use of "unsigned int" is preferred to bare "unsigned" in net tree.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 88949a994538..e4652fe58958 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1145,10 +1145,10 @@ struct sctp_outq {
 	/* Data pending that has never been transmitted.  */
 	struct list_head out_chunk_list;
 
-	unsigned out_qlen;	/* Total length of queued data chunks. */
+	unsigned int out_qlen;	/* Total length of queued data chunks. */
 
 	/* Error of send failed, may used in SCTP_SEND_FAILED event. */
-	unsigned error;
+	unsigned int error;
 
 	/* These are control chunks we want to send.  */
 	struct list_head control_chunk_list;
@@ -2000,8 +2000,8 @@ void sctp_assoc_update(struct sctp_association *old,
 __u32 sctp_association_get_next_tsn(struct sctp_association *);
 
 void sctp_assoc_sync_pmtu(struct sctp_association *);
-void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned);
-void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned);
+void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned int);
+void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned int);
 void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
 void sctp_assoc_del_nonprimary_peers(struct sctp_association *,

commit abb434cb0539fb355c1c921f8fd761efbbac3462
Merge: 2494654d4890 6350323ad8de
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Dec 23 17:13:56 2011 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            net/bluetooth/l2cap_core.c
    
    Just two overlapping changes, one added an initialization of
    a local variable, and another change added a new local variable.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit eb93992207dadb946a3b5cf4544957dc924a6f58
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 19 14:08:01 2011 +0000

    module_param: make bool parameters really bool (net & drivers/net)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    (Thanks to Joe Perches for suggesting coccinelle for 0/1 -> true/false).
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ad0e31bf7450..07e2cb1ae1f8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -235,7 +235,7 @@ extern struct sctp_globals {
 
 	/* Flag to indicate whether computing and verifying checksum
 	 * is disabled. */
-        int checksum_disable;
+        bool checksum_disable;
 
 	/* Threshold for rwnd update SACKS.  Receive buffer shifted this many
 	 * bits is an indicator of when to send and window update SACK.

commit 2692ba61a82203404abd7dd2a027bda962861f74
Author: Xi Wang <xi.wang@gmail.com>
Date:   Fri Dec 16 12:44:15 2011 +0000

    sctp: fix incorrect overflow check on autoclose
    
    Commit 8ffd3208 voids the previous patches f6778aab and 810c0719 for
    limiting the autoclose value.  If userspace passes in -1 on 32-bit
    platform, the overflow check didn't work and autoclose would be set
    to 0xffffffff.
    
    This patch defines a max_autoclose (in seconds) for limiting the value
    and exposes it through sysctl, with the following intentions.
    
    1) Avoid overflowing autoclose * HZ.
    
    2) Keep the default autoclose bound consistent across 32- and 64-bit
       platforms (INT_MAX / HZ in this patch).
    
    3) Keep the autoclose value consistent between setsockopt() and
       getsockopt() calls.
    
    Suggested-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Xi Wang <xi.wang@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e90e7a9935dd..a15432da27c3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -241,6 +241,9 @@ extern struct sctp_globals {
 	 * bits is an indicator of when to send and window update SACK.
 	 */
 	int rwnd_update_shift;
+
+	/* Threshold for autoclose timeout, in seconds. */
+	unsigned long max_autoclose;
 } sctp_globals;
 
 #define sctp_rto_initial		(sctp_globals.rto_initial)
@@ -281,6 +284,7 @@ extern struct sctp_globals {
 #define sctp_auth_enable		(sctp_globals.auth_enable)
 #define sctp_checksum_disable		(sctp_globals.checksum_disable)
 #define sctp_rwnd_upd_shift		(sctp_globals.rwnd_update_shift)
+#define sctp_max_autoclose		(sctp_globals.max_autoclose)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {

commit dfd56b8b38fff3586f36232db58e1e9f7885a605
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sat Dec 10 09:48:31 2011 +0000

    net: use IS_ENABLED(CONFIG_IPV6)
    
    Instead of testing defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 3382615bd710..ad0e31bf7450 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -365,7 +365,7 @@ static inline struct sock *sctp_opt2sk(const struct sctp_sock *sp)
        return (struct sock *)sp;
 }
 
-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#if IS_ENABLED(CONFIG_IPV6)
 struct sctp6_sock {
        struct sctp_sock  sctp;
        struct ipv6_pinfo inet6;

commit ddc4bbee6ef1ed20314be3888dd39ceefe233e79
Author: Michio Honda <micchie@sfc.wide.ad.jp>
Date:   Fri Jun 17 11:03:23 2011 +0900

    sctp: fasthandoff with ASCONF at mobile-node
    
    Fast retransmission after changing the last address
    with ASCONF negotiation
    
    Signed-off-by: Michio Honda <micchie@sfc.wide.ad.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e90e7a9935dd..3382615bd710 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1085,6 +1085,7 @@ void sctp_transport_burst_reset(struct sctp_transport *);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
 void sctp_transport_reset(struct sctp_transport *);
 void sctp_transport_update_pmtu(struct sctp_transport *, u32);
+void sctp_transport_immediate_rtx(struct sctp_transport *);
 
 
 /* This is the structure we use to queue packets as they come into

commit 6af29ccc223b0feb6fc6112281c3fa3cdb1afddf
Author: Michio Honda <micchie@sfc.wide.ad.jp>
Date:   Thu Jun 16 17:14:34 2011 +0900

    sctp: Bundle HEAERTBEAT into ASCONF_ACK
    
    With this patch a HEARTBEAT chunk is bundled into the ASCONF-ACK
    for ADD IP ADDRESS, confirming the new destination as quickly as
    possible.
    
    Signed-off-by: Michio Honda <micchie@sfc.wide.ad.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f7d9c3fc06fd..e90e7a9935dd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1915,6 +1915,7 @@ struct sctp_association {
 	__u32 addip_serial;
 	union sctp_addr *asconf_addr_del_pending;
 	int src_out_of_asoc_ok;
+	struct sctp_transport *new_transport;
 
 	/* SCTP AUTH: list of the endpoint shared keys.  These
 	 * keys are provided out of band by the user applicaton

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 31d7ea2e1d2a..f7d9c3fc06fd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -60,7 +60,7 @@
 #include <linux/in6.h>		/* We get struct in6_addr     */
 #include <linux/ipv6.h>
 #include <asm/param.h>		/* We get MAXHOSTNAMELEN.     */
-#include <asm/atomic.h>		/* This gets us atomic counters.  */
+#include <linux/atomic.h>		/* This gets us atomic counters.  */
 #include <linux/skbuff.h>	/* We need sk_buff_head. */
 #include <linux/workqueue.h>	/* We need tq_struct.	 */
 #include <linux/sctp.h>		/* We need sctp* header structs.  */

commit 8a07eb0a50aebc8c95478d49c28c7f8419a26cef
Author: Michio Honda <micchie@sfc.wide.ad.jp>
Date:   Tue Apr 26 20:19:36 2011 +0900

    sctp: Add ASCONF operation on the single-homed host
    
    In this case, the SCTP association transmits an ASCONF packet
    including addition of the new IP address and deletion of the old
    address.  This patch implements this functionality.
    In this case, the ASCONF chunk is added to the beginning of the
    queue, because the other chunks cannot be transmitted in this state.
    
    Signed-off-by: Michio Honda <micchie@sfc.wide.ad.jp>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Acked-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index cd8c929e6b0d..31d7ea2e1d2a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1913,6 +1913,8 @@ struct sctp_association {
 	 * after reaching 4294967295.
 	 */
 	__u32 addip_serial;
+	union sctp_addr *asconf_addr_del_pending;
+	int src_out_of_asoc_ok;
 
 	/* SCTP AUTH: list of the endpoint shared keys.  These
 	 * keys are provided out of band by the user applicaton

commit 9f7d653b67aed2d92540fbb0a8adaf32fcf352ae
Author: Michio Honda <micchie@sfc.wide.ad.jp>
Date:   Tue Apr 26 19:32:51 2011 +0900

    sctp: Add Auto-ASCONF support (core).
    
    SCTP reconfigure the IP addresses in the association by using
    ASCONF chunks as mentioned in RFC5061.  For example, we can
    start to use the newly configured IP address in the existing
    association.  This patch implements automatic ASCONF operation
    in the SCTP stack with address events in the host computer,
    which is called auto_asconf.
    
    Signed-off-by: Michio Honda <micchie@sfc.wide.ad.jp>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Acked-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7df327a6d564..cd8c929e6b0d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -205,6 +205,11 @@ extern struct sctp_globals {
 	 * It is a list of sctp_sockaddr_entry.
 	 */
 	struct list_head local_addr_list;
+	int default_auto_asconf;
+	struct list_head addr_waitq;
+	struct timer_list addr_wq_timer;
+	struct list_head auto_asconf_splist;
+	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
 	spinlock_t addr_list_lock;
@@ -264,6 +269,11 @@ extern struct sctp_globals {
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_local_addr_list		(sctp_globals.local_addr_list)
 #define sctp_local_addr_lock		(sctp_globals.addr_list_lock)
+#define sctp_auto_asconf_splist		(sctp_globals.auto_asconf_splist)
+#define sctp_addr_waitq			(sctp_globals.addr_waitq)
+#define sctp_addr_wq_timer		(sctp_globals.addr_wq_timer)
+#define sctp_addr_wq_lock		(sctp_globals.addr_wq_lock)
+#define sctp_default_auto_asconf	(sctp_globals.default_auto_asconf)
 #define sctp_scope_policy		(sctp_globals.ipv4_scope_policy)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
 #define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
@@ -341,6 +351,8 @@ struct sctp_sock {
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
+	struct list_head auto_asconf_list;
+	int do_auto_asconf;
 };
 
 static inline struct sctp_sock *sctp_sk(const struct sock *sk)
@@ -792,6 +804,8 @@ struct sctp_sockaddr_entry {
 	__u8 valid;
 };
 
+#define SCTP_ADDRESS_TICK_DELAY	500
+
 typedef struct sctp_chunk *(sctp_packet_phandler_t)(struct sctp_association *);
 
 /* This structure holds lists of chunks as we are assembling for
@@ -1236,6 +1250,7 @@ sctp_scope_t sctp_scope(const union sctp_addr *);
 int sctp_in_scope(const union sctp_addr *addr, const sctp_scope_t scope);
 int sctp_is_any(struct sock *sk, const union sctp_addr *addr);
 int sctp_addr_is_valid(const union sctp_addr *addr);
+int sctp_is_ep_boundall(struct sock *sk);
 
 
 /* What type of endpoint?  */

commit a000c01e60e40e15304ffe48fff051d17a7bea91
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Sun May 29 23:23:36 2011 +0000

    sctp: stop pending timers and purge queues when peer restart asoc
    
    If the peer restart the asoc, we should not only fail any unsent/unacked
    data, but also stop the T3-rtx, SACK, T4-rto timers, and teardown ASCONF
    queues.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 795f4886e111..7df327a6d564 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1993,7 +1993,7 @@ void sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc);
 struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
 					const struct sctp_association *asoc,
 					__be32 serial);
-
+void sctp_asconf_queue_teardown(struct sctp_association *asoc);
 
 int sctp_cmp_addr_exact(const union sctp_addr *ss1,
 			const union sctp_addr *ss2);

commit 8663c938ceb72f47941c95ff0ea491ebbdd68f26
Author: David S. Miller <davem@davemloft.net>
Date:   Fri May 6 16:32:47 2011 -0700

    sctp: Store a flowi in transports to provide persistent keying.
    
    Several future simplifications are possible now because of this.
    
    For example, the sctp_addr unions can simply refer directly to
    the flowi information.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ff3e8cce7d66..795f4886e111 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -894,6 +894,7 @@ struct sctp_transport {
 		/* Is this structure kfree()able? */
 		malloced:1;
 
+	struct flowi fl;
 
 	/* This is the peer's IP address and port. */
 	union sctp_addr ipaddr;

commit da0420bee24a1ba54e55a61e95b1a53205d7e62d
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Apr 26 21:54:17 2011 +0000

    sctp: clean up route lookup calls
    
    Change the call to take the transport parameter and set the
    cached 'dst' appropriately inside the get_dst() function calls.
    
    This will allow us in the future  to clean up source address
    storage as well.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index bb2f43b7e9a8..ff3e8cce7d66 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -564,8 +564,7 @@ struct sctp_af {
 					 int optname,
 					 char __user *optval,
 					 int __user *optlen);
-	struct dst_entry *(*get_dst)	(struct sctp_association *asoc,
-					 union sctp_addr *daddr,
+	void		(*get_dst)	(struct sctp_transport *t,
 					 union sctp_addr *saddr,
 					 struct flowi *fl,
 					 struct sock *sk);

commit af1384703f8a4ff3d245925d6596ef1c5c6e469e
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Apr 26 21:53:20 2011 +0000

    sctp: remove useless arguments from get_saddr() call
    
    There is no point in passing a destination address to
    a get_saddr() call.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 1d465d62f34f..bb2f43b7e9a8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -571,7 +571,6 @@ struct sctp_af {
 					 struct sock *sk);
 	void		(*get_saddr)	(struct sctp_sock *sk,
 					 struct sctp_transport *t,
-					 union sctp_addr *daddr,
 					 struct flowi *fl);
 	void		(*copy_addrlist) (struct list_head *,
 					  struct net_device *);

commit 9914ae3ca770389a3bec3114d0a07532a7f235dd
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Apr 26 21:51:31 2011 +0000

    sctp: cache the ipv6 source after route lookup
    
    The ipv6 routing lookup does give us a source address,
    but instead of filling it into the dst, it's stored in
    the flowi.  We can use that instead of going through the
    entire source address selection again.
    Also the useless ->dst_saddr member of sctp_pf is removed.
    And sctp_v6_dst_saddr() is removed, instead by introduce
    sctp_v6_to_addr(), which can be reused to cleanup some dup
    code.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5c9bada51d2d..1d465d62f34f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -566,17 +566,15 @@ struct sctp_af {
 					 int __user *optlen);
 	struct dst_entry *(*get_dst)	(struct sctp_association *asoc,
 					 union sctp_addr *daddr,
-					 union sctp_addr *saddr);
+					 union sctp_addr *saddr,
+					 struct flowi *fl,
+					 struct sock *sk);
 	void		(*get_saddr)	(struct sctp_sock *sk,
-					 struct sctp_association *asoc,
-					 struct dst_entry *dst,
+					 struct sctp_transport *t,
 					 union sctp_addr *daddr,
-					 union sctp_addr *saddr);
+					 struct flowi *fl);
 	void		(*copy_addrlist) (struct list_head *,
 					  struct net_device *);
-	void		(*dst_saddr)	(union sctp_addr *saddr,
-					 struct dst_entry *dst,
-					 __be16 port);
 	int		(*cmp_addr)	(const union sctp_addr *addr1,
 					 const union sctp_addr *addr2);
 	void		(*addr_copy)	(union sctp_addr *dst,
@@ -1061,7 +1059,7 @@ void sctp_transport_set_owner(struct sctp_transport *,
 			      struct sctp_association *);
 void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
 			  struct sctp_sock *);
-void sctp_transport_pmtu(struct sctp_transport *);
+void sctp_transport_pmtu(struct sctp_transport *, struct sock *sk);
 void sctp_transport_free(struct sctp_transport *);
 void sctp_transport_reset_timers(struct sctp_transport *);
 void sctp_transport_hold(struct sctp_transport *);

commit de6becdc0844ff92b38ffd9f0c4db1d3de02835f
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Tue Apr 19 21:30:51 2011 +0000

    sctp: fix to check the source address of COOKIE-ECHO chunk
    
    SCTP does not check whether the source address of COOKIE-ECHO
    chunk is the original address of INIT chunk or part of the any
    address parameters saved in COOKIE in CLOSED state. So even if
    the COOKIE-ECHO chunk is from any address but with correct COOKIE,
    the COOKIE-ECHO chunk still be accepted. If the COOKIE is not from
    a valid address, the assoc should not be established.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0f6e60a9c308..5c9bada51d2d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1400,7 +1400,7 @@ int sctp_has_association(const union sctp_addr *laddr,
 int sctp_verify_init(const struct sctp_association *asoc, sctp_cid_t,
 		     sctp_init_chunk_t *peer_init, struct sctp_chunk *chunk,
 		     struct sctp_chunk **err_chunk);
-int sctp_process_init(struct sctp_association *, sctp_cid_t cid,
+int sctp_process_init(struct sctp_association *, struct sctp_chunk *chunk,
 		      const union sctp_addr *peer,
 		      sctp_init_chunk_t *init, gfp_t gfp);
 __u32 sctp_generate_tag(const struct sctp_endpoint *);

commit 028dba0ac3fc3c82da06110b011fce22a5ffad00
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Thu Mar 31 23:38:54 2011 +0000

    sctp: fix auth_hmacs field's length of struct sctp_cookie
    
    auth_hmacs field of struct sctp_cookie is used for store
    Requested HMAC Algorithm Parameter, and each HMAC Identifier
    is 2 bytes, so the length should be:
      SCTP_AUTH_NUM_HMACS * sizeof(__u16) + 2
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index cc9185ca8fd1..0f6e60a9c308 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -422,7 +422,7 @@ struct sctp_cookie {
 	__u32 adaptation_ind;
 
 	__u8 auth_random[sizeof(sctp_paramhdr_t) + SCTP_AUTH_RANDOM_LENGTH];
-	__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS + 2];
+	__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS * sizeof(__u16) + 2];
 	__u8 auth_chunks[sizeof(sctp_paramhdr_t) + SCTP_AUTH_MAX_CHUNKS];
 
 	/* This is a shim for my peer's INIT packet, followed by

commit 49b4a6546fac02f58784f0744e0f99a6562ccc03
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Mon Nov 29 00:14:58 2010 +0000

    sctp: kill unused macros in head file
    
    1. SCTP_CMD_NUM_VERBS,SCTP_CMD_MAX
    These two macros have never been used for several years since v2.6.12-rc2.
    
    2.sctp_port_rover,sctp_port_alloc_lock
    The commit 063930 abandoned global variables of port_rover and port_alloc_lock,
    but still keep two macros to refer to them.
    So, remove them now.
    
    commit 06393009000779b00a558fd2f280882cc7dc2008
    Author: Stephen Hemminger <shemminger@linux-foundation.org>
    Date:   Wed Oct 10 17:30:18 2007 -0700
    
        [SCTP]: port randomization
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 69fef4fb79c0..cc9185ca8fd1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -261,8 +261,6 @@ extern struct sctp_globals {
 #define sctp_assoc_hashsize		(sctp_globals.assoc_hashsize)
 #define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
 #define sctp_port_hashsize		(sctp_globals.port_hashsize)
-#define sctp_port_rover			(sctp_globals.port_rover)
-#define sctp_port_alloc_lock		(sctp_globals.port_alloc_lock)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_local_addr_list		(sctp_globals.local_addr_list)
 #define sctp_local_addr_lock		(sctp_globals.addr_list_lock)

commit a02cec2155fbea457eca8881870fd2de1a4c4c76
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Sep 22 20:43:57 2010 +0000

    net: return operator cleanup
    
    Change "return (EXPR);" to "return EXPR;"
    
    return is not a function, parentheses are not required.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f9e7473613bd..69fef4fb79c0 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -847,7 +847,7 @@ void sctp_packet_free(struct sctp_packet *);
 
 static inline int sctp_packet_empty(struct sctp_packet *packet)
 {
-	return (packet->size == packet->overhead);
+	return packet->size == packet->overhead;
 }
 
 /* This represents a remote transport address.

commit bc10502dba37d3b210efd9f3867212298f13b78e
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Jun 3 03:21:52 2010 -0700

    net: use __packed annotation
    
    cleanup patch.
    
    Use new __packed annotation in net/ and include/
    (except netfilter)
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4b860116e096..f9e7473613bd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -443,7 +443,7 @@ struct sctp_signed_cookie {
 	__u8 signature[SCTP_SECRET_SIZE];
 	__u32 __pad;		/* force sctp_cookie alignment to 64 bits */
 	struct sctp_cookie c;
-} __attribute__((packed));
+} __packed;
 
 /* This is another convenience type to allocate memory for address
  * params for the maximum size and pass such structures around
@@ -488,7 +488,7 @@ typedef struct sctp_sender_hb_info {
 	union sctp_addr daddr;
 	unsigned long sent_at;
 	__u64 hb_nonce;
-} __attribute__((packed)) sctp_sender_hb_info_t;
+} __packed sctp_sender_hb_info_t;
 
 /*
  *  RFC 2960 1.3.2 Sequenced Delivery within Streams

commit ff937938e7781b2c1bffce0a5400af308e3946d5
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed May 26 00:40:11 2010 -0700

    sctp: dubious bitfields in sctp_transport
    
    Sparse complains because these one-bit bitfields are signed.
      include/net/sctp/structs.h:879:24: error: dubious one-bit signed bitfield
      include/net/sctp/structs.h:889:31: error: dubious one-bit signed bitfield
      include/net/sctp/structs.h:895:26: error: dubious one-bit signed bitfield
      include/net/sctp/structs.h:898:31: error: dubious one-bit signed bitfield
      include/net/sctp/structs.h:901:27: error: dubious one-bit signed bitfield
    
    It doesn't cause a problem in the current code, but it would be better
    to clean it up.  This was introduced by c0058a35aacc7: "sctp: Save some
    room in the sctp_transport by using bitfields".
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6173c619913a..4b860116e096 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -876,7 +876,7 @@ struct sctp_transport {
 
 	/* Reference counting. */
 	atomic_t refcnt;
-	int	 dead:1,
+	__u32	 dead:1,
 		/* RTO-Pending : A flag used to track if one of the DATA
 		 *		chunks sent to this address is currently being
 		 *		used to compute a RTT. If this flag is 0,

commit 278554bd6579206921f5d8a523649a7a57f8850d
Merge: 5a147e8bf982 cea0d767c296
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 12 00:05:35 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            Documentation/feature-removal-schedule.txt
            drivers/net/wireless/ath/ar9170/usb.c
            drivers/scsi/iscsi_tcp.c
            net/ipv4/ipmr.c

commit 50b5d6ad63821cea324a5a7a19854d4de1a0a819
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu May 6 00:56:07 2010 -0700

    sctp: Fix a race between ICMP protocol unreachable and connect()
    
    ICMP protocol unreachable handling completely disregarded
    the fact that the user may have locked the socket.  It proceeded
    to destroy the association, even though the user may have
    held the lock and had a ref on the association.  This resulted
    in the following:
    
    Attempt to release alive inet socket f6afcc00
    
    =========================
    [ BUG: held lock freed! ]
    -------------------------
    somenu/2672 is freeing memory f6afcc00-f6afcfff, with a lock still held
    there!
     (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    1 lock held by somenu/2672:
     #0:  (sk_lock-AF_INET){+.+.+.}, at: [<c122098a>] sctp_connect+0x13/0x4c
    
    stack backtrace:
    Pid: 2672, comm: somenu Not tainted 2.6.32-telco #55
    Call Trace:
     [<c1232266>] ? printk+0xf/0x11
     [<c1038553>] debug_check_no_locks_freed+0xce/0xff
     [<c10620b4>] kmem_cache_free+0x21/0x66
     [<c1185f25>] __sk_free+0x9d/0xab
     [<c1185f9c>] sk_free+0x1c/0x1e
     [<c1216e38>] sctp_association_put+0x32/0x89
     [<c1220865>] __sctp_connect+0x36d/0x3f4
     [<c122098a>] ? sctp_connect+0x13/0x4c
     [<c102d073>] ? autoremove_wake_function+0x0/0x33
     [<c12209a8>] sctp_connect+0x31/0x4c
     [<c11d1e80>] inet_dgram_connect+0x4b/0x55
     [<c11834fa>] sys_connect+0x54/0x71
     [<c103a3a2>] ? lock_release_non_nested+0x88/0x239
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c1054026>] ? might_fault+0x42/0x7c
     [<c11847ab>] sys_socketcall+0x6d/0x178
     [<c10da994>] ? trace_hardirqs_on_thunk+0xc/0x10
     [<c1002959>] syscall_call+0x7/0xb
    
    This was because the sctp_wait_for_connect() would aqcure the socket
    lock and then proceed to release the last reference count on the
    association, thus cause the fully destruction path to finish freeing
    the socket.
    
    The simplest solution is to start a very short timer in case the socket
    is owned by user.  When the timer expires, we can do some verification
    and be able to do the release properly.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 597f8e27aaf6..219043a67bf7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1010,6 +1010,9 @@ struct sctp_transport {
 	/* Heartbeat timer is per destination. */
 	struct timer_list hb_timer;
 
+	/* Timer to handle ICMP proto unreachable envets */
+	struct timer_list proto_unreach_timer;
+
 	/* Since we're using per-destination retransmission timers
 	 * (see above), we're also using per-destination "transmitted"
 	 * queues.  This probably ought to be a private struct

commit f5460618405eec8c3300947a499011528a115acd
Merge: 4f70ecca9c57 0e3aef8d09a8
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 3 16:20:44 2010 -0700

    Merge branch 'net-next' of git://git.kernel.org/pub/scm/linux/kernel/git/vxy/lksctp-dev
    
    Add missing linux/vmalloc.h include to net/sctp/probe.c
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 0e3aef8d09a8c11e3fb83cdcb24b5bc7421b3726
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Apr 30 22:41:10 2010 -0400

    sctp: Tag messages that can be Nagle delayed at creation.
    
    When we create the sctp_datamsg and fragment the user data,
    we know exactly if we are sending full segments or not and
    how they might be bundled.  During this time, we can mark
    messages a Nagle capable or not.  This makes the check at
    transmit time much simpler.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d463296d9f79..9d44aef365da 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -643,17 +643,15 @@ struct sctp_pf {
 struct sctp_datamsg {
 	/* Chunks waiting to be submitted to lower layer. */
 	struct list_head chunks;
-	/* Chunks that have been transmitted. */
-	size_t msg_size;
 	/* Reference counting. */
 	atomic_t refcnt;
 	/* When is this message no longer interesting to the peer? */
 	unsigned long expires_at;
 	/* Did the messenge fail to send? */
 	int send_error;
-	char send_failed;
-	/* Control whether chunks from this message can be abandoned. */
-	char can_abandon;
+	u8 send_failed:1,
+	   can_abandon:1,   /* can chunks from this message can be abandoned. */
+	   can_delay;	    /* should this message be Nagle delayed */
 };
 
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,

commit cf9b4812e18aab6f86ff998bd7425a9e823269c3
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Apr 30 22:41:10 2010 -0400

    sctp: fast recovery algorithm is per association.
    
    SCTP fast recovery algorithm really applies per association
    and impacts all transports.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9072dd67d8ad..d463296d9f79 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -895,9 +895,6 @@ struct sctp_transport {
 		 */
 		hb_sent:1,
 
-		/* Flag to track the current fast recovery state */
-		fast_recovery:1,
-
 		/* Is the Path MTU update pending on this tranport */
 		pmtu_pending:1,
 
@@ -952,9 +949,6 @@ struct sctp_transport {
 
 	__u32 burst_limited;	/* Holds old cwnd when max.burst is applied */
 
-	/* TSN marking the fast recovery exit point */
-	__u32 fast_recovery_exit;
-
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */
@@ -1723,6 +1717,12 @@ struct sctp_association {
 	/* Highest TSN that is acknowledged by incoming SACKs. */
 	__u32 highest_sacked;
 
+	/* TSN marking the fast recovery exit point */
+	__u32 fast_recovery_exit;
+
+	/* Flag to track the current fast recovery state */
+	__u8 fast_recovery;
+
 	/* The number of unacknowledged data chunks.  Reported through
 	 * the SCTP_STATUS sockopt.
 	 */

commit c0058a35aacc79406e867ec33c5cb75624fd5860
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Apr 30 22:41:09 2010 -0400

    sctp: Save some room in the sctp_transport by using bitfields
    
    Saves some room in the sctp_transport structure.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 03deffb1886b..9072dd67d8ad 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -877,7 +877,33 @@ struct sctp_transport {
 
 	/* Reference counting. */
 	atomic_t refcnt;
-	int	 dead;
+	int	 dead:1,
+		/* RTO-Pending : A flag used to track if one of the DATA
+		 *		chunks sent to this address is currently being
+		 *		used to compute a RTT. If this flag is 0,
+		 *		the next DATA chunk sent to this destination
+		 *		should be used to compute a RTT and this flag
+		 *		should be set. Every time the RTT
+		 *		calculation completes (i.e. the DATA chunk
+		 *		is SACK'd) clear this flag.
+		 */
+		 rto_pending:1,
+
+		/*
+		 * hb_sent : a flag that signals that we have a pending
+		 * heartbeat.
+		 */
+		hb_sent:1,
+
+		/* Flag to track the current fast recovery state */
+		fast_recovery:1,
+
+		/* Is the Path MTU update pending on this tranport */
+		pmtu_pending:1,
+
+		/* Is this structure kfree()able? */
+		malloced:1;
+
 
 	/* This is the peer's IP address and port. */
 	union sctp_addr ipaddr;
@@ -907,22 +933,6 @@ struct sctp_transport {
 	/* SRTT	       : The current smoothed round trip time.	*/
 	__u32 srtt;
 
-	/* RTO-Pending : A flag used to track if one of the DATA
-	 *		chunks sent to this address is currently being
-	 *		used to compute a RTT. If this flag is 0,
-	 *		the next DATA chunk sent to this destination
-	 *		should be used to compute a RTT and this flag
-	 *		should be set. Every time the RTT
-	 *		calculation completes (i.e. the DATA chunk
-	 *		is SACK'd) clear this flag.
-	 * hb_sent : a flag that signals that we have a pending heartbeat.
-	 */
-	__u8 rto_pending;
-	__u8 hb_sent;
-
-	/* Flag to track the current fast recovery state */
-	__u8 fast_recovery;
-
 	/*
 	 * These are the congestion stats.
 	 */
@@ -975,9 +985,6 @@ struct sctp_transport {
 	 */
 	__u16 pathmaxrxt;
 
-	/* is the Path MTU update pending on this tranport */
-	__u8 pmtu_pending;
-
 	/* PMTU	      : The current known path MTU.  */
 	__u32 pathmtu;
 
@@ -1021,8 +1028,6 @@ struct sctp_transport {
 	/* This is the list of transports that have chunks to send.  */
 	struct list_head send_ready;
 
-	int malloced; /* Is this structure kfree()able? */
-
 	/* State information saved for SFR_CACC algorithm. The key
 	 * idea in SFR_CACC is to maintain state at the sender on a
 	 * per-destination basis when a changeover happens.

commit ae19c54866450f6c6f79223ca7d37965859a54e1
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Apr 30 22:41:09 2010 -0400

    sctp: remove 'resent' bit from the chunk
    
    The 'resent' bit is used to make sure that we don't update
    rto estimate based on retransmitted chunks.  However, we already
    have the 'rto_pending' bit that we test when need to update rto,
    so 'resent' bit is just extra.  Additionally, we currently have
    a bug in that we always set a 'resent' bit and thus rto estimate
    is only updated by Heartbeats.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ff3017744711..03deffb1886b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -757,7 +757,6 @@ struct sctp_chunk {
 #define SCTP_NEED_FRTX 0x1
 #define SCTP_DONT_FRTX 0x2
 	__u16	rtt_in_progress:1,	/* This chunk used for RTT calc? */
-		resent:1,		/* Has this chunk ever been resent. */
 		has_tsn:1,		/* Does this chunk have a TSN yet? */
 		has_ssn:1,		/* Does this chunk have a SSN yet? */
 		singleton:1,		/* Only chunk in the packet? */
@@ -1065,7 +1064,7 @@ void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
 			  struct sctp_sock *);
 void sctp_transport_pmtu(struct sctp_transport *);
 void sctp_transport_free(struct sctp_transport *);
-void sctp_transport_reset_timers(struct sctp_transport *, int);
+void sctp_transport_reset_timers(struct sctp_transport *);
 void sctp_transport_hold(struct sctp_transport *);
 void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);

commit 5fa782c2f5ef6c2e4f04d3e228412c9b4a4c8809
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Apr 28 10:30:59 2010 +0000

    sctp: Fix skb_over_panic resulting from multiple invalid parameter errors (CVE-2010-1173) (v4)
    
    Ok, version 4
    
    Change Notes:
    1) Minor cleanups, from Vlads notes
    
    Summary:
    
    Hey-
            Recently, it was reported to me that the kernel could oops in the
    following way:
    
    <5> kernel BUG at net/core/skbuff.c:91!
    <5> invalid operand: 0000 [#1]
    <5> Modules linked in: sctp netconsole nls_utf8 autofs4 sunrpc iptable_filter
    ip_tables cpufreq_powersave parport_pc lp parport vmblock(U) vsock(U) vmci(U)
    vmxnet(U) vmmemctl(U) vmhgfs(U) acpiphp dm_mirror dm_mod button battery ac md5
    ipv6 uhci_hcd ehci_hcd snd_ens1371 snd_rawmidi snd_seq_device snd_pcm_oss
    snd_mixer_oss snd_pcm snd_timer snd_page_alloc snd_ac97_codec snd soundcore
    pcnet32 mii floppy ext3 jbd ata_piix libata mptscsih mptsas mptspi mptscsi
    mptbase sd_mod scsi_mod
    <5> CPU:    0
    <5> EIP:    0060:[<c02bff27>]    Not tainted VLI
    <5> EFLAGS: 00010216   (2.6.9-89.0.25.EL)
    <5> EIP is at skb_over_panic+0x1f/0x2d
    <5> eax: 0000002c   ebx: c033f461   ecx: c0357d96   edx: c040fd44
    <5> esi: c033f461   edi: df653280   ebp: 00000000   esp: c040fd40
    <5> ds: 007b   es: 007b   ss: 0068
    <5> Process swapper (pid: 0, threadinfo=c040f000 task=c0370be0)
    <5> Stack: c0357d96 e0c29478 00000084 00000004 c033f461 df653280 d7883180
    e0c2947d
    <5>        00000000 00000080 df653490 00000004 de4f1ac0 de4f1ac0 00000004
    df653490
    <5>        00000001 e0c2877a 08000800 de4f1ac0 df653490 00000000 e0c29d2e
    00000004
    <5> Call Trace:
    <5>  [<e0c29478>] sctp_addto_chunk+0xb0/0x128 [sctp]
    <5>  [<e0c2947d>] sctp_addto_chunk+0xb5/0x128 [sctp]
    <5>  [<e0c2877a>] sctp_init_cause+0x3f/0x47 [sctp]
    <5>  [<e0c29d2e>] sctp_process_unk_param+0xac/0xb8 [sctp]
    <5>  [<e0c29e90>] sctp_verify_init+0xcc/0x134 [sctp]
    <5>  [<e0c20322>] sctp_sf_do_5_1B_init+0x83/0x28e [sctp]
    <5>  [<e0c25333>] sctp_do_sm+0x41/0x77 [sctp]
    <5>  [<c01555a4>] cache_grow+0x140/0x233
    <5>  [<e0c26ba1>] sctp_endpoint_bh_rcv+0xc5/0x108 [sctp]
    <5>  [<e0c2b863>] sctp_inq_push+0xe/0x10 [sctp]
    <5>  [<e0c34600>] sctp_rcv+0x454/0x509 [sctp]
    <5>  [<e084e017>] ipt_hook+0x17/0x1c [iptable_filter]
    <5>  [<c02d005e>] nf_iterate+0x40/0x81
    <5>  [<c02e0bb9>] ip_local_deliver_finish+0x0/0x151
    <5>  [<c02e0c7f>] ip_local_deliver_finish+0xc6/0x151
    <5>  [<c02d0362>] nf_hook_slow+0x83/0xb5
    <5>  [<c02e0bb2>] ip_local_deliver+0x1a2/0x1a9
    <5>  [<c02e0bb9>] ip_local_deliver_finish+0x0/0x151
    <5>  [<c02e103e>] ip_rcv+0x334/0x3b4
    <5>  [<c02c66fd>] netif_receive_skb+0x320/0x35b
    <5>  [<e0a0928b>] init_stall_timer+0x67/0x6a [uhci_hcd]
    <5>  [<c02c67a4>] process_backlog+0x6c/0xd9
    <5>  [<c02c690f>] net_rx_action+0xfe/0x1f8
    <5>  [<c012a7b1>] __do_softirq+0x35/0x79
    <5>  [<c0107efb>] handle_IRQ_event+0x0/0x4f
    <5>  [<c01094de>] do_softirq+0x46/0x4d
    
    Its an skb_over_panic BUG halt that results from processing an init chunk in
    which too many of its variable length parameters are in some way malformed.
    
    The problem is in sctp_process_unk_param:
    if (NULL == *errp)
            *errp = sctp_make_op_error_space(asoc, chunk,
                                             ntohs(chunk->chunk_hdr->length));
    
            if (*errp) {
                    sctp_init_cause(*errp, SCTP_ERROR_UNKNOWN_PARAM,
                                     WORD_ROUND(ntohs(param.p->length)));
                    sctp_addto_chunk(*errp,
                            WORD_ROUND(ntohs(param.p->length)),
                                      param.v);
    
    When we allocate an error chunk, we assume that the worst case scenario requires
    that we have chunk_hdr->length data allocated, which would be correct nominally,
    given that we call sctp_addto_chunk for the violating parameter.  Unfortunately,
    we also, in sctp_init_cause insert a sctp_errhdr_t structure into the error
    chunk, so the worst case situation in which all parameters are in violation
    requires chunk_hdr->length+(sizeof(sctp_errhdr_t)*param_count) bytes of data.
    
    The result of this error is that a deliberately malformed packet sent to a
    listening host can cause a remote DOS, described in CVE-2010-1173:
    http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-1173
    
    I've tested the below fix and confirmed that it fixes the issue.  We move to a
    strategy whereby we allocate a fixed size error chunk and ignore errors we don't
    have space to report.  Tested by me successfully
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ff3017744711..597f8e27aaf6 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -778,6 +778,7 @@ int sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,
 			  struct iovec *data);
 void sctp_chunk_free(struct sctp_chunk *);
 void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
+void  *sctp_addto_chunk_fixed(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,
 				 const struct sctp_association *,
 				 struct sock *);

commit 4ef58d4e2ad1fa2a3e5bbf41af2284671fca8cf8
Merge: f6c4c8195b5e d014d043869c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:43:33 2009 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (42 commits)
      tree-wide: fix misspelling of "definition" in comments
      reiserfs: fix misspelling of "journaled"
      doc: Fix a typo in slub.txt.
      inotify: remove superfluous return code check
      hdlc: spelling fix in find_pvc() comment
      doc: fix regulator docs cut-and-pasteism
      mtd: Fix comment in Kconfig
      doc: Fix IRQ chip docs
      tree-wide: fix assorted typos all over the place
      drivers/ata/libata-sff.c: comment spelling fixes
      fix typos/grammos in Documentation/edac.txt
      sysctl: add missing comments
      fs/debugfs/inode.c: fix comment typos
      sgivwfb: Make use of ARRAY_SIZE.
      sky2: fix sky2_link_down copy/paste comment error
      tree-wide: fix typos "couter" -> "counter"
      tree-wide: fix typos "offest" -> "offset"
      fix kerneldoc for set_irq_msi()
      spidev: fix double "of of" in comment
      comment typo fix: sybsystem -> subsystem
      ...

commit d014d043869cdc591f3a33243d3481fa4479c2d0
Merge: 6ec22f9b037f 6070d81eb5f2
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Dec 7 18:36:35 2009 +0100

    Merge branch 'for-next' into for-linus
    
    Conflicts:
    
            kernel/irq/chip.c

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6e5f0e0c7967..ca4789e4f1e1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -988,7 +988,7 @@ struct sctp_transport {
 	int init_sent_count;
 
 	/* state       : The current state of this destination,
-	 *             : i.e. SCTP_ACTIVE, SCTP_INACTIVE, SCTP_UNKOWN.
+	 *             : i.e. SCTP_ACTIVE, SCTP_INACTIVE, SCTP_UNKNOWN.
 	 */
 	int state;
 

commit 9b963e5d0e01461099a40117b05480f24b63381f
Merge: 3b8626ba01a8 5fdd4baef619
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Nov 29 00:57:15 2009 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/ieee802154/fakehard.c
            drivers/net/e1000e/ich8lan.c
            drivers/net/e1000e/phy.c
            drivers/net/netxen/netxen_nic_init.c
            drivers/net/wireless/ath/ath9k/main.c

commit 5fdd4baef6195a1f2960e901c8877e2105f832ca
Author: Andrei Pelinescu-Onciul <andrei@iptel.org>
Date:   Sun Nov 29 00:14:02 2009 -0800

    sctp: on T3_RTX retransmit all the in-flight chunks
    
    When retransmitting due to T3 timeout, retransmit all the
    in-flight chunks for the corresponding  transport/path, including
    chunks sent less then 1 rto ago.
    This is the correct behaviour according to rfc4960 section 6.3.3
    E3 and
    "Note: Any DATA chunks that were sent to the address for which the
     T3-rtx timer expired but did not fit in one MTU (rule E3 above)
     should be marked for retransmission and sent as soon as cwnd
     allows (normally, when a SACK arrives). ".
    
    This fixes problems when more then one path is present and the T3
    retransmission of the first chunk that timeouts stops the T3 timer
    for the initial active path, leaving all the other in-flight
    chunks waiting forever or until a new chunk is transmitted on the
    same path and timeouts (and this will happen only if the cwnd
    allows sending new chunks, but since cwnd was dropped to MTU by
    the timeout => it will wait until the first heartbeat).
    
    Example: 10 packets in flight, sent at 0.1 s intervals on the
    primary path. The primary path is down and the first packet
    timeouts. The first packet is retransmitted on another path, the
    T3 timer for the primary path is stopped and cwnd is set to MTU.
    All the other 9 in-flight packets will not be retransmitted
    (unless more new packets are sent on the primary path which depend
    on cwnd allowing it, and even in this case the 9 packets will be
    retransmitted only after a new packet timeouts which even in the
    best case would be more then RTO).
    
    This commit reverts d0ce92910bc04e107b2f3f2048f07e94f570035d and
    also removes the now unused transport->last_rto, introduced in
     b6157d8e03e1e780660a328f7183bcbfa4a93a19.
    
    p.s  The problem is not only when multiple paths are there.  It
    can happen in a single homed environment.  If the application
    stops sending data, it possible to have a hung association.
    
    Signed-off-by: Andrei Pelinescu-Onciul <andrei@iptel.org>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index cd2e18778f81..0a474568b003 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -893,7 +893,6 @@ struct sctp_transport {
 	 */
 	/* RTO	       : The current retransmission timeout value.  */
 	unsigned long rto;
-	unsigned long last_rto;
 
 	__u32 rtt;		/* This is the most recent RTT.	 */
 

commit 46d5a808558181e03a4760d2188cc9879445738a
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Nov 23 15:54:00 2009 -0500

    sctp: Update max.burst implementation
    
    Current implementation of max.burst ends up limiting new
    data during cwnd decay period.  The decay is happening becuase
    the connection is idle and we are allowed to fill the congestion
    window.  The point of max.burst is to limit micro-bursts in response
    to large acks.  This still happens, as max.burst is still applied
    to each transmit opportunity.  It will also apply if a very large
    send is made (greater then allowed by burst).
    
    Tested-by: Florian Niederbacher <florian.niederbacher@student.uibk.ac.at>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ac794a6823eb..bc3f8d879c5c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -942,6 +942,8 @@ struct sctp_transport {
 	/* Data that has been sent, but not acknowledged. */
 	__u32 flight_size;
 
+	__u32 burst_limited;	/* Holds old cwnd when max.burst is applied */
+
 	/* TSN marking the fast recovery exit point */
 	__u32 fast_recovery_exit;
 
@@ -1070,6 +1072,8 @@ void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);
 void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);
 void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
+void sctp_transport_burst_limited(struct sctp_transport *);
+void sctp_transport_burst_reset(struct sctp_transport *);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
 void sctp_transport_reset(struct sctp_transport *);
 void sctp_transport_update_pmtu(struct sctp_transport *, u32);

commit 245cba7e55929dc2b10b7d915bfba0168eeeed17
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Nov 23 15:53:58 2009 -0500

    sctp: Remove useless last_time_used variable
    
    The transport last_time_used variable is rather useless.
    It was only used when determining if CWND needs to be updated
    due to idle transport.  However, idle transport detection was
    based on a Heartbeat timer and last_time_used was not incremented
    when sending Heartbeats.  As a result the check for cwnd reduction
    was always true.  We can get rid of the variable and just base
    our cwnd manipulation on the HB timer (like the code comment sais).
    We also have to call into the cwnd manipulation function regardless
    of whether HBs are enabled or not.  That way we will detect idle
    transports if the user has disabled Heartbeats.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 90876b657775..ac794a6823eb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -950,12 +950,6 @@ struct sctp_transport {
 	/* Source address. */
 	union sctp_addr saddr;
 
-	/* When was the last time(in jiffies) that a data packet was sent on
-	 * this transport?  This is used to adjust the cwnd when the transport
-	 * becomes inactive.
-	 */
-	unsigned long last_time_used;
-
 	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 	 * the destination address every heartbeat interval.
 	 */

commit 90f2f5318b3a5b0898fef0fec9b91376c7de7a2c
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Nov 23 15:53:57 2009 -0500

    sctp: Update SWS avaoidance receiver side algorithm
    
    We currently send window update SACKs every time we free up 1 PMTU
    worth of data.  That a lot more SACKs then necessary.  Instead, we'll
    now send back the actuall window every time we send a sack, and do
    window-update SACKs when a fraction of the receive buffer has been
    opened.  The fraction is controlled with a sysctl.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index cd2e18778f81..90876b657775 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -231,6 +231,11 @@ extern struct sctp_globals {
 	/* Flag to indicate whether computing and verifying checksum
 	 * is disabled. */
         int checksum_disable;
+
+	/* Threshold for rwnd update SACKS.  Receive buffer shifted this many
+	 * bits is an indicator of when to send and window update SACK.
+	 */
+	int rwnd_update_shift;
 } sctp_globals;
 
 #define sctp_rto_initial		(sctp_globals.rto_initial)
@@ -267,6 +272,7 @@ extern struct sctp_globals {
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 #define sctp_auth_enable		(sctp_globals.auth_enable)
 #define sctp_checksum_disable		(sctp_globals.checksum_disable)
+#define sctp_rwnd_upd_shift		(sctp_globals.rwnd_update_shift)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {

commit 409b95aff3583c05ac7a9247fa3d8c9aa7f9cae3
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Nov 10 08:57:34 2009 +0000

    sctp: Set source addresses on the association before adding transports
    
    Recent commit 8da645e101a8c20c6073efda3c7cc74eec01b87f
            sctp: Get rid of an extra routing lookup when adding a transport
    introduced a regression in the connection setup.  The behavior was
    
    different between IPv4 and IPv6.  IPv4 case ended up working because the
    route lookup routing returned a NULL route, which triggered another
    route lookup later in the output patch that succeeded.  In the IPv6 case,
    a valid route was returned for first call, but we could not find a valid
    source address at the time since the source addresses were not set on the
    association yet.  Thus resulted in a hung connection.
    
    The solution is to set the source addresses on the association prior to
    adding peers.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6e5f0e0c7967..cd2e18778f81 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1980,7 +1980,7 @@ void sctp_assoc_set_primary(struct sctp_association *,
 void sctp_assoc_del_nonprimary_peers(struct sctp_association *,
 				    struct sctp_transport *);
 int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *,
-				     gfp_t);
+				     sctp_scope_t, gfp_t);
 int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
 					 struct sctp_cookie*,
 					 gfp_t gfp);

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 42d00ced5eb8..6e5f0e0c7967 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -544,7 +544,7 @@ struct sctp_af {
 					 int level,
 					 int optname,
 					 char __user *optval,
-					 int optlen);
+					 unsigned int optlen);
 	int		(*getsockopt)	(struct sock *sk,
 					 int level,
 					 int optname,
@@ -554,7 +554,7 @@ struct sctp_af {
 					 int level,
 					 int optname,
 					 char __user *optval,
-					 int optlen);
+					 unsigned int optlen);
 	int		(*compat_getsockopt)	(struct sock *sk,
 					 int level,
 					 int optname,

commit 9237ccbc0b22b5aa5396463ba0b14dc5efe5b98c
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Fri Sep 4 14:33:19 2009 +0800

    sctp: turn flags in 'struct sctp_association' into bit fields
    
    This shrinks the size of struct sctp_association a little.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a48d80e77cd7..42d00ced5eb8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1568,13 +1568,13 @@ struct sctp_association {
 		__u32	sack_cnt;
 
 		/* These are capabilities which our peer advertised.  */
-		__u8	ecn_capable;	 /* Can peer do ECN? */
-		__u8	ipv4_address;	 /* Peer understands IPv4 addresses? */
-		__u8	ipv6_address;	 /* Peer understands IPv6 addresses? */
-		__u8	hostname_address;/* Peer understands DNS addresses? */
-		__u8    asconf_capable;  /* Does peer support ADDIP? */
-		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
-		__u8	auth_capable;	 /* Is peer doing SCTP-AUTH? */
+		__u8	ecn_capable:1,	    /* Can peer do ECN? */
+			ipv4_address:1,	    /* Peer understands IPv4 addresses? */
+			ipv6_address:1,	    /* Peer understands IPv6 addresses? */
+			hostname_address:1, /* Peer understands DNS addresses? */
+			asconf_capable:1,   /* Does peer support ADDIP? */
+			prsctp_capable:1,   /* Can peer do PR-SCTP? */
+			auth_capable:1;	    /* Is peer doing SCTP-AUTH? */
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 
@@ -1913,11 +1913,8 @@ struct sctp_association {
 
 	__u16 active_key_id;
 
-	/* Need to send an ECNE Chunk? */
-	char need_ecne;
-
-	/* Is it a temporary association? */
-	char temp;
+	__u8 need_ecne:1,	/* Need to send an ECNE Chunk? */
+	     temp:1;		/* Is it a temporary association? */
 };
 
 

commit 723884339f90a9c420783135168cc1045750eb5d
Author: Bhaskar Dutta <bhaskie@gmail.com>
Date:   Thu Sep 3 17:25:47 2009 +0530

    sctp: Sysctl configuration for IPv4 Address Scoping
    
    This patch introduces a new sysctl option to make IPv4 Address Scoping
    configurable <draft-stewart-tsvwg-sctp-ipv4-00.txt>.
    
    In networking environments where DNAT rules in iptables prerouting
    chains convert destination IP's to link-local/private IP addresses,
    SCTP connections fail to establish as the INIT chunk is dropped by the
    kernel due to address scope match failure.
    For example to support overlapping IP addresses (same IP address with
    different vlan id) a Layer-5 application listens on link local IP's,
    and there is a DNAT rule that maps the destination IP to a link local
    IP. Such applications never get the SCTP INIT if the address-scoping
    draft is strictly followed.
    
    This sysctl configuration allows SCTP to function in such
    unconventional networking environments.
    
    Sysctl options:
    0 - Disable IPv4 address scoping draft altogether
    1 - Enable IPv4 address scoping (default, current behavior)
    2 - Enable address scoping but allow IPv4 private addresses in init/init-ack
    3 - Enable address scoping but allow IPv4 link local address in init/init-ack
    
    Signed-off-by: Bhaskar Dutta <bhaskar.dutta@globallogic.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 993cfff9218e..a48d80e77cd7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -219,6 +219,15 @@ extern struct sctp_globals {
 	/* Flag to idicate if SCTP-AUTH is enabled */
 	int auth_enable;
 
+	/*
+	 * Policy to control SCTP IPv4 address scoping
+	 * 0   - Disable IPv4 address scoping
+	 * 1   - Enable IPv4 address scoping
+	 * 2   - Selectively allow only IPv4 private addresses
+	 * 3   - Selectively allow only IPv4 link local address
+	 */
+	int ipv4_scope_policy;
+
 	/* Flag to indicate whether computing and verifying checksum
 	 * is disabled. */
         int checksum_disable;
@@ -252,6 +261,7 @@ extern struct sctp_globals {
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_local_addr_list		(sctp_globals.local_addr_list)
 #define sctp_local_addr_lock		(sctp_globals.addr_list_lock)
+#define sctp_scope_policy		(sctp_globals.ipv4_scope_policy)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
 #define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)

commit a803c942303e6a4ef0ab6b80114529852cffa058
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Sep 4 18:21:01 2009 -0400

    sctp: Turn flags in 'sctp_packet' into bit fields
    
    This shrinks the size of sctp_packet a little.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b10612810f56..993cfff9218e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -812,22 +812,12 @@ struct sctp_packet {
 	/* pointer to the auth chunk for this packet */
 	struct sctp_chunk *auth;
 
-	/* This packet contains a COOKIE-ECHO chunk. */
-	__u8 has_cookie_echo;
-
-	/* This packet contains a SACK chunk. */
-	__u8 has_sack;
-
-	/* This packet contains an AUTH chunk */
-	__u8 has_auth;
-
-	/* This packet contains at least 1 DATA chunk */
-	__u8 has_data;
-
-	/* SCTP cannot fragment this packet. So let ip fragment it. */
-	__u8 ipfragok;
-
-	__u8 malloced;
+	u8  has_cookie_echo:1,	/* This packet contains a COOKIE-ECHO chunk. */
+	    has_sack:1,		/* This packet contains a SACK chunk. */
+	    has_auth:1,		/* This packet contains an AUTH chunk */
+	    has_data:1,		/* This packet contains at least 1 DATA chunk */
+	    ipfragok:1,		/* So let ip fragment this packet */
+	    malloced:1;		/* Is it malloced? */
 };
 
 struct sctp_packet *sctp_packet_init(struct sctp_packet *,

commit f68b2e05f326971cd76c65aa91a1a41771dd7485
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Sep 4 18:21:00 2009 -0400

    sctp: Fix SCTP_MAXSEG socket option to comply to spec.
    
    We had a bug that we never stored the user-defined value for
    MAXSEG when setting the value on an association.  Thus future
    PMTU events ended up re-writing the frag point and increasing
    it past user limit.  Additionally, when setting the option on
    the socket/endpoint, we effect all current associations, which
    is against spec.
    
    Now, we store the user 'maxseg' value along with the computed
    'frag_point'.  We inherit 'maxseg' from the socket at association
    creation and use it as an upper limit for 'frag_point' when its
    set.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index df4c6321996d..b10612810f56 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1763,6 +1763,7 @@ struct sctp_association {
 
 	/* The message size at which SCTP fragmentation will occur. */
 	__u32 frag_point;
+	__u32 user_frag;
 
 	/* Counter used to count INIT errors. */
 	int init_err_counter;

commit cb95ea32a457871f72752164de8d94fa20f4703c
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Sep 4 18:20:59 2009 -0400

    sctp: Don't do NAGLE delay on large writes that were fragmented small
    
    SCTP will delay the last part of a large write due to NAGLE, if that
    part is smaller then MTU.  Since we are doing large writes, we might
    as well send the last portion now instead of waiting untill the next
    large write happens.  The small portion will be sent as is regardless,
    so it's better to not delay it.
    
    This is a result of much discussions with Wei Yongjun <yjwei@cn.fujitsu.com>
    and Doug Graham <dgraham@nortel.com>.  Many thanks go out to them.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b1bd2689bb70..df4c6321996d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -628,7 +628,7 @@ struct sctp_datamsg {
 	/* Chunks waiting to be submitted to lower layer. */
 	struct list_head chunks;
 	/* Chunks that have been transmitted. */
-	struct list_head track;
+	size_t msg_size;
 	/* Reference counting. */
 	atomic_t refcnt;
 	/* When is this message no longer interesting to the peer? */

commit 4d3c46e6833208428d366630aa708f6876e61fc1
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Sep 4 18:20:59 2009 -0400

    sctp: drop a_rwnd to 0 when receive buffer overflows.
    
    SCTP has a problem that when small chunks are used, it is possible
    to exhaust the receiver buffer without fully closing receive window.
    This happens due to all overhead that we have account for with small
    messages.  To fix this, when receive buffer is exceeded, we'll drop
    the window to 0 and save the 'drop' portion.  When application starts
    reading data and freeing up recevie buffer space, we'll wait until
    we've reached the 'drop' window and then add back this 'drop' one
    mtu at a time.  This worked well in testing and under stress produced
    rather even recovery.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 97024faaa08f..b1bd2689bb70 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1739,6 +1739,12 @@ struct sctp_association {
 	 */
 	__u32 rwnd_over;
 
+	/* Keeps treack of rwnd pressure.  This happens when we have
+	 * a window, but not recevie buffer (i.e small packets).  This one
+	 * is releases slowly (1 PMTU at a time ).
+	 */
+	__u32 rwnd_press;
+
 	/* This is the sndbuf size in use for the association.
 	 * This corresponds to the sndbuf size for the association,
 	 * as specified in the sk->sndbuf.

commit 9c5c62be2f794c7cee533d856f9f34c3cf21ff1b
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Aug 10 13:51:03 2009 -0400

    sctp: Send user messages to the lower layer as one
    
    Currenlty, sctp breaks up user messages into fragments and
    sends each fragment to the lower layer by itself.  This means
    that for each fragment we go all the way down the stack
    and back up.  This also discourages bundling of multiple
    fragments when they can fit into a sigle packet (ex: due
    to user setting a low fragmentation threashold).
    
    We introduce a new command SCTP_CMD_SND_MSG and hand the
    whole message down state machine.  The state machine and
    the side-effect parser will cork the queue, add all chunks
    from the message to the queue, and then un-cork the queue
    thus causing the chunks to get transmitted.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index edfcacf3250e..97024faaa08f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -643,6 +643,7 @@ struct sctp_datamsg {
 struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
 					    struct sctp_sndrcvinfo *,
 					    struct msghdr *, int len);
+void sctp_datamsg_free(struct sctp_datamsg *);
 void sctp_datamsg_put(struct sctp_datamsg *);
 void sctp_chunk_fail(struct sctp_chunk *, int error);
 int sctp_chunk_abandoned(struct sctp_chunk *);

commit 9919b455fc00c995ef8141848bdc0709ce50bf36
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Tue May 12 21:52:51 2009 +0800

    sctp: fix to choose alternate destination when retransmit ASCONF chunk
    
    RFC 5061 Section 5.1 ASCONF Chunk Procedures said:
    
    B4)  Re-transmit the ASCONF Chunk last sent and if possible choose an
         alternate destination address (please refer to [RFC4960],
         Section 6.4.1).  An endpoint MUST NOT add new parameters to this
         chunk; it MUST be the same (including its Sequence Number) as
         the last ASCONF sent.  An endpoint MAY, however, bundle an
         additional ASCONF with new ASCONF parameters with the next
         Sequence Number.  For details, see Section 5.5.
    
    This patch fix to choose an alternate destination address when
    re-transmit the ASCONF chunk, with some dup codes cleanup.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 23f08fe1d50a..edfcacf3250e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1939,10 +1939,8 @@ void sctp_association_free(struct sctp_association *);
 void sctp_association_put(struct sctp_association *);
 void sctp_association_hold(struct sctp_association *);
 
-struct sctp_transport *sctp_assoc_choose_init_transport(
-	struct sctp_association *);
-struct sctp_transport *sctp_assoc_choose_shutdown_transport(
-	struct sctp_association *);
+struct sctp_transport *sctp_assoc_choose_alter_transport(
+	struct sctp_association *, struct sctp_transport *);
 void sctp_assoc_update_retran_path(struct sctp_association *);
 struct sctp_transport *sctp_assoc_lookup_paddr(const struct sctp_association *,
 					  const union sctp_addr *);

commit faee47cdbfe8d74a1573c2f81ea6dbb08d735be6
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Feb 13 08:33:43 2009 +0000

    sctp: Fix the RTO-doubling on idle-link heartbeats
    
    SCTP incorrectly doubles rto ever time a Hearbeat chunk
    is generated.   However RFC 4960 states:
    
       On an idle destination address that is allowed to heartbeat, it is
       recommended that a HEARTBEAT chunk is sent once per RTO of that
       destination address plus the protocol parameter 'HB.interval', with
       jittering of +/- 50% of the RTO value, and exponential backoff of the
       RTO if the previous HEARTBEAT is unanswered.
    
    Essentially, of if the heartbean is unacknowledged, do we double the RTO.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9f70d54fcefc..23f08fe1d50a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -910,8 +910,10 @@ struct sctp_transport {
 	 *		should be set. Every time the RTT
 	 *		calculation completes (i.e. the DATA chunk
 	 *		is SACK'd) clear this flag.
+	 * hb_sent : a flag that signals that we have a pending heartbeat.
 	 */
 	__u8 rto_pending;
+	__u8 hb_sent;
 
 	/* Flag to track the current fast recovery state */
 	__u8 fast_recovery;

commit 06e868066e3b5828383eb40ff4d1c0029100b0b5
Author: Lucas Nussbaum <lucas.nussbaum@ens-lyon.fr>
Date:   Fri Feb 13 08:33:41 2009 +0000

    sctp: Allow to disable SCTP checksums via module parameter
    
    This is a new version of my patch, now using a module parameter instead
    of a sysctl, so that the option is harder to find. Please note that,
    once the module is loaded, it is still possible to change the value of
    the parameter in /sys/module/sctp/parameters/, which is useful if you
    want to do performance comparisons without rebooting.
    
    Computation of SCTP checksums significantly affects the performance of
    SCTP. For example, using two dual-Opteron 246 connected using a Gbe
    network, it was not possible to achieve more than ~730 Mbps, compared to
    941 Mbps after disabling SCTP checksums.
    Unfortunately, SCTP checksum offloading in NICs is not commonly
    available (yet).
    
    By default, checksums are still enabled, of course.
    
    Signed-off-by: Lucas Nussbaum <lucas.nussbaum@ens-lyon.fr>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9661d7b765f0..9f70d54fcefc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -218,6 +218,10 @@ extern struct sctp_globals {
 
 	/* Flag to idicate if SCTP-AUTH is enabled */
 	int auth_enable;
+
+	/* Flag to indicate whether computing and verifying checksum
+	 * is disabled. */
+        int checksum_disable;
 } sctp_globals;
 
 #define sctp_rto_initial		(sctp_globals.rto_initial)
@@ -252,6 +256,7 @@ extern struct sctp_globals {
 #define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 #define sctp_auth_enable		(sctp_globals.auth_enable)
+#define sctp_checksum_disable		(sctp_globals.checksum_disable)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {

commit 8e1ee18c332e08bee9d8bd66e63cd564fbf17fc2
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 8 14:18:39 2008 -0700

    sctp: Rework the tsn map to use generic bitmap.
    
    The tsn map currently use is 4K large and is stuck inside
    the sctp_association structure making memory references REALLY
    expensive.  What we really need is at most 4K worth of bits
    so the biggest map we would have is 512 bytes.   Also, the
    map is only really usefull when we have gaps to store and
    report.  As such, starting with minimal map of say 32 TSNs (bits)
    should be enough for normal low-loss operations.  We can grow
    the map by some multiple of 32 along with some extra room any
    time we receive the TSN which would put us outside of the map
    boundry.  As we close gaps, we can shift the map to rebase
    it on the latest TSN we've seen.  This saves 4088 bytes per
    association just in the map alone along savings from the now
    unnecessary structure members.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 94c62e4ddea9..9661d7b765f0 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1545,7 +1545,6 @@ struct sctp_association {
 		 * in tsn_map--we get it by calling sctp_tsnmap_get_ctsn().
 		 */
 		struct sctp_tsnmap tsn_map;
-		__u8 _map[sctp_tsnmap_storage_size(SCTP_TSN_MAP_SIZE)];
 
 		/* Ack State   : This flag indicates if the next received
 		 *             : packet is to be responded to with a

commit 52cae8f06babf9eed327479c1aa024ce3732f912
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Aug 18 10:34:34 2008 -0400

    sctp: try harder to figure out address family when checking wildcards
    
    sctp_is_any() function that is used to check for wildcard addresses
    only looks at the address itself to determine the address family.
    This function is used in the API to check the address passed in from
    the user.  If the user simply zerroes out the sockaddr_storage and
    pass that in, we'll end up failing.  So, let's try harder to determine
    the address family by also checking the socket if it's possible.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0dc1b7267c37..94c62e4ddea9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1228,7 +1228,7 @@ int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
 
 sctp_scope_t sctp_scope(const union sctp_addr *);
 int sctp_in_scope(const union sctp_addr *addr, const sctp_scope_t scope);
-int sctp_is_any(const union sctp_addr *addr);
+int sctp_is_any(struct sock *sk, const union sctp_addr *addr);
 int sctp_addr_is_valid(const union sctp_addr *addr);
 
 

commit c226ef9b83694311327f3ab0036c6de9c22e9daf
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Fri Jul 25 12:44:09 2008 -0400

    sctp: reduce memory footprint of sctp_chunk structure
    
    sctp_chunks should be put on a diet.  This is some of the low hanging
    fruit that we can strip out.  Changes all the __s8/__u8 flags to
    bitfields.  Saves 12 bytes per chunk.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ab1c472ea753..0dc1b7267c37 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -731,20 +731,23 @@ struct sctp_chunk {
 	 */
 	struct sk_buff *auth_chunk;
 
-	__u8 rtt_in_progress;	/* Is this chunk used for RTT calculation? */
-	__u8 resent;		/* Has this chunk ever been retransmitted. */
-	__u8 has_tsn;		/* Does this chunk have a TSN yet? */
-	__u8 has_ssn;		/* Does this chunk have a SSN yet? */
-	__u8 singleton;		/* Was this the only chunk in the packet? */
-	__u8 end_of_packet;	/* Was this the last chunk in the packet? */
-	__u8 ecn_ce_done;	/* Have we processed the ECN CE bit? */
-	__u8 pdiscard;		/* Discard the whole packet now? */
-	__u8 tsn_gap_acked;	/* Is this chunk acked by a GAP ACK? */
-	__s8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
-	__u8 tsn_missing_report; /* Data chunk missing counter. */
-	__u8 data_accepted; 	/* At least 1 chunk in this packet accepted */
-	__u8 auth;		/* IN: was auth'ed | OUT: needs auth */
-	__u8 has_asconf;	/* IN: have seen an asconf before */
+#define SCTP_CAN_FRTX 0x0
+#define SCTP_NEED_FRTX 0x1
+#define SCTP_DONT_FRTX 0x2
+	__u16	rtt_in_progress:1,	/* This chunk used for RTT calc? */
+		resent:1,		/* Has this chunk ever been resent. */
+		has_tsn:1,		/* Does this chunk have a TSN yet? */
+		has_ssn:1,		/* Does this chunk have a SSN yet? */
+		singleton:1,		/* Only chunk in the packet? */
+		end_of_packet:1,	/* Last chunk in the packet? */
+		ecn_ce_done:1,		/* Have we processed the ECN CE bit? */
+		pdiscard:1,		/* Discard the whole packet now? */
+		tsn_gap_acked:1,	/* Is this chunk acked by a GAP ACK? */
+		data_accepted:1,	/* At least 1 chunk accepted */
+		auth:1,			/* IN: was auth'ed | OUT: needs auth */
+		has_asconf:1,		/* IN: have seen an asconf before */
+		tsn_missing_report:2,	/* Data chunk missing counter. */
+		fast_retransmit:2;	/* Is this chunk fast retransmitted? */
 };
 
 void sctp_chunk_hold(struct sctp_chunk *);

commit f880374c2fe37aad3fa62253a4bc125d7a933aad
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Aug 3 21:15:08 2008 -0700

    sctp: Drop ipfargok in sctp_xmit function
    
    The ipfragok flag controls whether the packet may be fragmented
    either on the local host on beyond.  The latter is only valid on
    IPv4.
    
    In fact, we never want to do the latter even on IPv4 when PMTU is
    enabled.  This is because even though we can't fragment packets
    within SCTP due to the prtocol's inherent faults, we can still
    fragment it at IP layer.  By setting the DF bit we will improve
    the PMTU process.
    
    RFC 2960 only says that we SHOULD clear the DF bit in this case,
    so we're compliant even if we set the DF bit.  In fact RFC 4960
    no longer has this statement.
    
    Once we make this change, we only need to control the local
    fragmentation.  There is already a bit in the skb which controls
    that, local_df.  So this patch sets that instead of using the
    ipfragok argument.
    
    The only complication is that there isn't a struct sock object
    per transport, so for IPv4 we have to resort to changing the
    pmtudisc field for every packet.  This should be safe though
    as the protocol is single-threaded.
    
    Note that after this patch we can remove ipfragok from the rest
    of the stack too.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 535a18f57a13..ab1c472ea753 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -524,8 +524,7 @@ static inline void sctp_ssn_skip(struct sctp_stream *stream, __u16 id,
  */
 struct sctp_af {
 	int		(*sctp_xmit)	(struct sk_buff *skb,
-					 struct sctp_transport *,
-					 int ipfragok);
+					 struct sctp_transport *);
 	int		(*setsockopt)	(struct sock *sk,
 					 int level,
 					 int optname,

commit abd0b198ea699578c3c3476d646c91842e19dbd2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jul 22 14:20:45 2008 -0700

    sctp: make sctp_outq_flush() static
    
    sctp_outq_flush() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 70eb64a7e1a1..535a18f57a13 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1161,7 +1161,6 @@ void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
 void sctp_outq_teardown(struct sctp_outq *);
 void sctp_outq_free(struct sctp_outq*);
 int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk);
-int sctp_outq_flush(struct sctp_outq *, int);
 int sctp_outq_sack(struct sctp_outq *, struct sctp_sackhdr *);
 int sctp_outq_is_empty(const struct sctp_outq *);
 void sctp_outq_restart(struct sctp_outq *);

commit 7dab83de50c7b2b7ceac695a0b56fa6c0f95b0bc
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Jul 18 23:05:40 2008 -0700

    sctp: Support ipv6only AF_INET6 sockets.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 82116e84ee34..70eb64a7e1a1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1211,6 +1211,8 @@ int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);
+int sctp_bind_addr_conflict(struct sctp_bind_addr *, const union sctp_addr *,
+			 struct sctp_sock *, struct sctp_sock *);
 int sctp_bind_addr_state(const struct sctp_bind_addr *bp,
 			 const union sctp_addr *addr);
 union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,

commit 2e3216cd54b142ba605e87522e15f42e0c4e3996
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Jun 19 16:08:18 2008 -0700

    sctp: Follow security requirement of responding with 1 packet
    
    RFC 4960, Section 11.4. Protection of Non-SCTP-Capable Hosts
    
    When an SCTP stack receives a packet containing multiple control or
    DATA chunks and the processing of the packet requires the sending of
    multiple chunks in response, the sender of the response chunk(s) MUST
    NOT send more than one packet.  If bundling is supported, multiple
    response chunks that fit into a single packet MAY be bundled together
    into one single response packet.  If bundling is not supported, then
    the sender MUST NOT send more than one response chunk and MUST
    discard all other responses.  Note that this rule does NOT apply to a
    SACK chunk, since a SACK chunk is, in itself, a response to DATA and
    a SACK does not require a response of more DATA.
    
    We implement this by not servicing our outqueue until we reach the end
    of the packet.  This enables maximum bundling.  We also identify
    'response' chunks and make sure that we only send 1 packet when sending
    such chunks.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fbc27ac8a09e..82116e84ee34 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -827,7 +827,7 @@ struct sctp_packet *sctp_packet_init(struct sctp_packet *,
 				     __u16 sport, __u16 dport);
 struct sctp_packet *sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
 sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *,
-                                       struct sctp_chunk *);
+                                       struct sctp_chunk *, int);
 sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *,
                                      struct sctp_chunk *);
 int sctp_packet_transmit(struct sctp_packet *);

commit 65b53e4cc90e59936733b3b95b9451d2ca47528d
Merge: 788c0a53164c 2e761e0532a7
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 10 02:22:26 2008 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
    
            drivers/net/tg3.c
            drivers/net/wireless/rt2x00/rt2x00dev.c
            net/mac80211/ieee80211_i.h

commit b9031d9d87b24e24cd32ea15b5f4220a1e8da909
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Jun 4 12:40:15 2008 -0700

    sctp: Fix ECN markings for IPv6
    
    Commit e9df2e8fd8fbc95c57dbd1d33dada66c4627b44c ("[IPV6]: Use
    appropriate sock tclass setting for routing lookup.") also changed the
    way that ECN capable transports mark this capability in IPv6.  As a
    result, SCTP was not marking ECN capablity because the traffic class
    was never set.  This patch brings back the markings for IPv6 traffic.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 714dc43c0345..7f25195f9855 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -588,6 +588,7 @@ struct sctp_af {
 	int		(*is_ce)	(const struct sk_buff *sk);
 	void		(*seq_dump_addr)(struct seq_file *seq,
 					 union sctp_addr *addr);
+	void		(*ecn_capable)(struct sock *sk);
 	__u16		net_header_len;
 	int		sockaddr_len;
 	sa_family_t	sa_family;

commit 62aeaff5ccd96462b7077046357a6d7886175a57
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Jun 4 12:39:11 2008 -0700

    sctp: Start T3-RTX timer when fast retransmitting lowest TSN
    
    When we are trying to fast retransmit the lowest outstanding TSN, we
    need to restart the T3-RTX timer, so that subsequent timeouts will
    correctly tag all the packets necessary for retransmissions.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Tested-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 67592072a32e..714dc43c0345 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1051,7 +1051,7 @@ void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
 			  struct sctp_sock *);
 void sctp_transport_pmtu(struct sctp_transport *);
 void sctp_transport_free(struct sctp_transport *);
-void sctp_transport_reset_timers(struct sctp_transport *);
+void sctp_transport_reset_timers(struct sctp_transport *, int);
 void sctp_transport_hold(struct sctp_transport *);
 void sctp_transport_put(struct sctp_transport *);
 void sctp_transport_update_rto(struct sctp_transport *, __u32);
@@ -1141,6 +1141,9 @@ struct sctp_outq {
 	/* How many unackd bytes do we have in-flight?	*/
 	__u32 outstanding_bytes;
 
+	/* Are we doing fast-rtx on this queue */
+	char fast_rtx;
+
 	/* Corked? */
 	char cork;
 

commit a6465234814efda9ed1dccdba852953f7508e827
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Jun 4 12:38:43 2008 -0700

    sctp: Correctly implement Fast Recovery cwnd manipulations.
    
    Correctly keep track of Fast Recovery state and do not reduce
    congestion window multiple times during sucht state.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Tested-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 917d425f0542..67592072a32e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -902,7 +902,10 @@ struct sctp_transport {
 	 *		calculation completes (i.e. the DATA chunk
 	 *		is SACK'd) clear this flag.
 	 */
-	int rto_pending;
+	__u8 rto_pending;
+
+	/* Flag to track the current fast recovery state */
+	__u8 fast_recovery;
 
 	/*
 	 * These are the congestion stats.
@@ -921,6 +924,9 @@ struct sctp_transport {
 	/* Data that has been sent, but not acknowledged. */
 	__u32 flight_size;
 
+	/* TSN marking the fast recovery exit point */
+	__u32 fast_recovery_exit;
+
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */

commit e51171019bb0e1f9fb57c25bd2e38ce652eaea27
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Thu May 29 19:55:05 2008 +0900

    [SCTP]: Fix NULL dereference of asoc.
    
    Commit 7cbca67c073263c179f605bdbbdc565ab29d801d ("[IPV6]: Support
    Source Address Selection API (RFC5014)") introduced NULL dereference
    of asoc to sctp_v6_get_saddr in net/sctp/ipv6.c.
    Pointed out by Johann Felix Soden <johfel@users.sourceforge.net>.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0ce0443c5b79..917d425f0542 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -548,7 +548,8 @@ struct sctp_af {
 	struct dst_entry *(*get_dst)	(struct sctp_association *asoc,
 					 union sctp_addr *daddr,
 					 union sctp_addr *saddr);
-	void		(*get_saddr)	(struct sctp_association *asoc,
+	void		(*get_saddr)	(struct sctp_sock *sk,
+					 struct sctp_association *asoc,
 					 struct dst_entry *dst,
 					 union sctp_addr *daddr,
 					 union sctp_addr *saddr);

commit d364d9276b54af16fcb4db83f1315b620daec102
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Fri May 9 15:13:26 2008 -0700

    sctp: Bring SCTP_DELAYED_ACK socket option into API compliance
    
    Brings delayed_ack socket option set/get into line with the latest ietf
    socket extensions API draft, while maintaining backwards compatibility.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0ce0443c5b79..e11151702bee 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -300,6 +300,7 @@ struct sctp_sock {
 
 	/* The default SACK delay timeout for new associations. */
 	__u32 sackdelay;
+	__u32 sackfreq;
 
 	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
@@ -938,6 +939,7 @@ struct sctp_transport {
 
 	/* SACK delay timeout */
 	unsigned long sackdelay;
+	__u32 sackfreq;
 
 	/* When was the last time (in jiffies) that we heard from this
 	 * transport?  We use this to pick new active and retran paths.
@@ -1542,6 +1544,7 @@ struct sctp_association {
 		 *             : SACK's are not delayed (see Section 6).
 		 */
 		__u8    sack_needed;     /* Do we need to sack the peer? */
+		__u32	sack_cnt;
 
 		/* These are capabilities which our peer advertised.  */
 		__u8	ecn_capable;	 /* Can peer do ECN? */
@@ -1651,6 +1654,7 @@ struct sctp_association {
 
 	/* SACK delay timeout */
 	unsigned long sackdelay;
+	__u32 sackfreq;
 
 
 	unsigned long timeouts[SCTP_NUM_TIMEOUT_TYPES];

commit 80445cfb28a6b093540582b68d9ae928bf34cfe7
Author: Florian Westphal <fw@strlen.de>
Date:   Sun Mar 23 22:47:08 2008 -0700

    [SCTP]: Remove redundant wrapper functions.
    
    sctp_datamsg_free and sctp_datamsg_track are just aliases for
    sctp_datamsg_put and sctp_chunk_hold, respectively.
    
    Saves 32 Bytes on x86.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8966599ddb9f..0ce0443c5b79 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -637,8 +637,6 @@ struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
 					    struct sctp_sndrcvinfo *,
 					    struct msghdr *, int len);
 void sctp_datamsg_put(struct sctp_datamsg *);
-void sctp_datamsg_free(struct sctp_datamsg *);
-void sctp_datamsg_track(struct sctp_chunk *);
 void sctp_chunk_fail(struct sctp_chunk *, int error);
 int sctp_chunk_abandoned(struct sctp_chunk *);
 

commit 58fbbed4fbc0094fc808a568fe99a915f85402ee
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Fri Feb 29 11:40:56 2008 -0800

    [SCTP]: extend exported data in /proc/net/sctp/assoc
    
    RFC 3873 specifies several MIB objects that can't be obtained by the
    current data set exported by /proc/sys/net/sctp/assoc.  This patch
    adds the missing pieces of data that allow us to compute all the
    objects in the sctpAssocTable object.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9c827a749b6f..8966599ddb9f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1661,6 +1661,9 @@ struct sctp_association {
 	/* Transport to which SHUTDOWN chunk was last sent.  */
 	struct sctp_transport *shutdown_last_sent_to;
 
+	/* How many times have we resent a SHUTDOWN */
+	int shutdown_retries;
+
 	/* Transport to which INIT chunk was last sent.  */
 	struct sctp_transport *init_last_sent_to;
 
@@ -1695,6 +1698,11 @@ struct sctp_association {
 	 */
 	__u16 unack_data;
 
+	/* The total number of data chunks that we've had to retransmit
+	 * as the result of a T3 timer expiration
+	 */
+	__u32 rtx_data_chunks;
+
 	/* This is the association's receive buffer space.  This value is used
 	 * to set a_rwnd field in an INIT or a SACK chunk.
 	 */

commit 60c778b25972e095df8981dd41e99d161e8738f9
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Jan 11 09:57:09 2008 -0500

    [SCTP]: Stop claiming that this is a "reference implementation"
    
    I was notified by Randy Stewart that lksctp claims to be
    "the reference implementation".  First of all, "the
    refrence implementation" was the original implementation
    of SCTP in usersapce written ty Randy and a few others.
    Second, after looking at the definiton of 'reference implementation',
    we don't really meet the requirements.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 4d591bfce452..9c827a749b6f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1,18 +1,18 @@
-/* SCTP kernel reference Implementation
+/* SCTP kernel implementation
  * (C) Copyright IBM Corp. 2001, 2004
  * Copyright (c) 1999-2000 Cisco, Inc.
  * Copyright (c) 1999-2001 Motorola, Inc.
  * Copyright (c) 2001 Intel Corp.
  *
- * This file is part of the SCTP kernel reference Implementation
+ * This file is part of the SCTP kernel implementation
  *
- * The SCTP reference implementation is free software;
+ * This SCTP implementation is free software;
  * you can redistribute it and/or modify it under the terms of
  * the GNU General Public License as published by
  * the Free Software Foundation; either version 2, or (at your option)
  * any later version.
  *
- * The SCTP reference implementation is distributed in the hope that it
+ * This SCTP implementation is distributed in the hope that it
  * will be useful, but WITHOUT ANY WARRANTY; without even the implied
  *		   ************************
  * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

commit 75205f478331cc64ce729ea72d3c8c1837fb59cb
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Dec 20 14:12:59 2007 -0800

    [SCTP]: Implement ADD-IP special case processing for ABORT chunk
    
    ADD-IP spec has a special case for processing ABORTs:
        F4) ... One special consideration is that ABORT
            Chunks arriving destined to the IP address being deleted MUST be
            ignored (see Section 5.3.1 for further details).
    
    Check if the address we received on is in the DEL state, and if
    so, ignore the ABORT.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2528f8a837d9..4d591bfce452 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1200,6 +1200,8 @@ int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);
+int sctp_bind_addr_state(const struct sctp_bind_addr *bp,
+			 const union sctp_addr *addr);
 union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,
 					const union sctp_addr	*addrs,
 					int			addrcnt,

commit f57d96b2e92d209ab3991bba9a44e0d6ef7614a8
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Dec 20 14:12:24 2007 -0800

    [SCTP]: Change use_as_src into a full address state
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fa87873fee76..2528f8a837d9 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -760,12 +760,18 @@ void sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,
 		     union sctp_addr *);
 const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 
+enum {
+	SCTP_ADDR_NEW,		/* new address added to assoc/ep */
+	SCTP_ADDR_SRC,		/* address can be used as source */
+	SCTP_ADDR_DEL,		/* address about to be deleted */
+};
+
 /* This is a structure for holding either an IPv6 or an IPv4 address.  */
 struct sctp_sockaddr_entry {
 	struct list_head list;
 	struct rcu_head	rcu;
 	union sctp_addr a;
-	__u8 use_as_src;
+	__u8 state;
 	__u8 valid;
 };
 
@@ -1190,7 +1196,7 @@ int sctp_bind_addr_dup(struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
 			gfp_t gfp);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-		       __u8 use_as_src, gfp_t gfp);
+		       __u8 addr_state, gfp_t gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);

commit a08de64d074b36a56ee3bb985cd171281db78e96
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Dec 20 14:11:47 2007 -0800

    [SCTP]: Update ASCONF processing to conform to spec.
    
    The processing of the ASCONF chunks has changed a lot in the
    spec.  New items are:
        1. A list of ASCONF-ACK chunks is now cached
        2. The source of the packet is used in response.
        3. New handling for unexpect ASCONF chunks.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8a0808eab811..fa87873fee76 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -744,6 +744,7 @@ struct sctp_chunk {
 	__u8 tsn_missing_report; /* Data chunk missing counter. */
 	__u8 data_accepted; 	/* At least 1 chunk in this packet accepted */
 	__u8 auth;		/* IN: was auth'ed | OUT: needs auth */
+	__u8 has_asconf;	/* IN: have seen an asconf before */
 };
 
 void sctp_chunk_hold(struct sctp_chunk *);
@@ -1785,20 +1786,16 @@ struct sctp_association {
 	 */
 	struct sctp_chunk *addip_last_asconf;
 
-	/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.
+	/* ADDIP Section 5.2 Upon reception of an ASCONF Chunk.
 	 *
-	 * IMPLEMENTATION NOTE: As an optimization a receiver may wish
-	 * to save the last ASCONF-ACK for some predetermined period
-	 * of time and instead of re-processing the ASCONF (with the
-	 * same serial number) it may just re-transmit the
-	 * ASCONF-ACK. It may wish to use the arrival of a new serial
-	 * number to discard the previously saved ASCONF-ACK or any
-	 * other means it may choose to expire the saved ASCONF-ACK.
+	 * This is needed to implement itmes E1 - E4 of the updated
+	 * spec.  Here is the justification:
 	 *
-	 * [This is our saved ASCONF-ACK.  We invalidate it when a new
-	 * ASCONF serial number arrives.]
+	 * Since the peer may bundle multiple ASCONF chunks toward us,
+	 * we now need the ability to cache multiple ACKs.  The section
+	 * describes in detail how they are cached and cleaned up.
 	 */
-	struct sctp_chunk *addip_last_asconf_ack;
+	struct list_head asconf_ack_list;
 
 	/* These ASCONF chunks are waiting to be sent.
 	 *
@@ -1947,6 +1944,11 @@ int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
 					 struct sctp_cookie*,
 					 gfp_t gfp);
 int sctp_assoc_set_id(struct sctp_association *, gfp_t);
+void sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc);
+struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
+					const struct sctp_association *asoc,
+					__be32 serial);
+
 
 int sctp_cmp_addr_exact(const union sctp_addr *ss1,
 			const union sctp_addr *ss2);

commit d6de3097592b7ae7f8e233a4dafb088e2aa8170f
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Dec 20 14:10:00 2007 -0800

    [SCTP]: Add the handling of "Set Primary IP Address" parameter to INIT
    
    The ADD-IP "Set Primary IP Address" parameter is allowed in the
    INIT/INIT-ACK exchange.  Allow processing of this parameter during
    the INIT/INIT-ACK.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 96621db22466..8a0808eab811 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -451,6 +451,7 @@ union sctp_params {
 	struct sctp_random_param *random;
 	struct sctp_chunks_param *chunks;
 	struct sctp_hmac_algo_param *hmac_algo;
+	struct sctp_addip_param *addip;
 };
 
 /* RFC 2960.  Section 3.3.5 Heartbeat.

commit 42e30bf3463cd37d73839376662cb79b4d5c416c
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Dec 20 14:08:56 2007 -0800

    [SCTP]: Handle the wildcard ADD-IP Address parameter
    
    The Address Parameter in the parameter list of the ASCONF chunk
    may be a wildcard address.  In this case special processing
    is required.  For the 'add' case, the source IP of the packet is
    added.  In the 'del' case, all addresses except the source IP
    of packet are removed. In the "mark primary" case, the source
    address is marked as primary.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index bb965742b64e..96621db22466 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1938,6 +1938,8 @@ void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned);
 void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned);
 void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
+void sctp_assoc_del_nonprimary_peers(struct sctp_association *,
+				    struct sctp_transport *);
 int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *,
 				     gfp_t);
 int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,

commit f4ab2f72e9340207ae95e2a7622a74220a61f46a
Author: Joe Perches <joe@perches.com>
Date:   Thu Dec 20 13:56:32 2007 -0800

    [NET] include/net/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 002a00a4e6be..bb965742b64e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -301,7 +301,7 @@ struct sctp_sock {
 	/* The default SACK delay timeout for new associations. */
 	__u32 sackdelay;
 
-	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
 	struct sctp_initmsg initmsg;
@@ -955,7 +955,7 @@ struct sctp_transport {
 	/* PMTU	      : The current known path MTU.  */
 	__u32 pathmtu;
 
-	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
 	/* The number of times INIT has been sent on this transport. */
@@ -1638,7 +1638,7 @@ struct sctp_association {
 	 */
 	__u32 pathmtu;
 
-	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	/* Flags controlling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
 	/* SACK delay timeout */

commit 8e71a11c9f3c09a01fcb445772ffd61b140f2479
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Dec 6 22:50:54 2007 -0800

    [SCTP]: Fix the bind_addr info during migration.
    
    During accept/migrate the code attempts to copy the addresses from
    the parent endpoint to the new endpoint.   However, if the parent
    was bound to a wildcard address, then we end up pointlessly copying
    all of the current addresses on the system.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index eb3113c38a94..002a00a4e6be 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1184,6 +1184,9 @@ int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
 			sctp_scope_t scope, gfp_t gfp,
 			int flags);
+int sctp_bind_addr_dup(struct sctp_bind_addr *dest,
+			const struct sctp_bind_addr *src,
+			gfp_t gfp);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
 		       __u8 use_as_src, gfp_t gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);

commit d970dbf8455eb1b8cebd3cde6e18f73dd1b3ce38
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Nov 9 11:43:40 2007 -0500

    SCTP: Convert custom hash lists to use hlist.
    
    Convert the custom hash list traversals to use hlist functions.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 44f2672859e2..eb3113c38a94 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -100,20 +100,19 @@ struct crypto_hash;
 struct sctp_bind_bucket {
 	unsigned short	port;
 	unsigned short	fastreuse;
-	struct sctp_bind_bucket *next;
-	struct sctp_bind_bucket **pprev;
+	struct hlist_node	node;
 	struct hlist_head	owner;
 };
 
 struct sctp_bind_hashbucket {
 	spinlock_t	lock;
-	struct sctp_bind_bucket	*chain;
+	struct hlist_head	chain;
 };
 
 /* Used for hashing all associations.  */
 struct sctp_hashbucket {
 	rwlock_t	lock;
-	struct sctp_ep_common  *chain;
+	struct hlist_head	chain;
 } __attribute__((__aligned__(8)));
 
 
@@ -1230,8 +1229,7 @@ typedef enum {
 
 struct sctp_ep_common {
 	/* Fields to help us manage our entries in the hash tables. */
-	struct sctp_ep_common *next;
-	struct sctp_ep_common **pprev;
+	struct hlist_node node;
 	int hashent;
 
 	/* Runtime type information.  What kind of endpoint is this? */

commit 73d9c4fd1a6ec4950b2eac8135d35506bf400d6c
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 24 17:24:26 2007 -0400

    SCTP: Allow ADD_IP to work with AUTH for backward compatibility.
    
    This patch adds a tunable that will allow ADD_IP to work without
    AUTH for backward compatibility.  The default value is off since
    the default value for ADD_IP is off as well.  People who need
    to use ADD-IP with older implementations take risks of connection
    hijacking and should consider upgrading or turning this tunable on.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 41f1039186dd..44f2672859e2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -212,6 +212,7 @@ extern struct sctp_globals {
 	
 	/* Flag to indicate if addip is enabled. */
 	int addip_enable;
+	int addip_noauth_enable;
 
 	/* Flag to indicate if PR-SCTP is enabled. */
 	int prsctp_enable;
@@ -249,6 +250,7 @@ extern struct sctp_globals {
 #define sctp_local_addr_list		(sctp_globals.local_addr_list)
 #define sctp_local_addr_lock		(sctp_globals.addr_list_lock)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
+#define sctp_addip_noauth		(sctp_globals.addip_noauth_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 #define sctp_auth_enable		(sctp_globals.auth_enable)
 

commit 88799fe5ec65fad1d5cb1d4dc5d8f78edb949f1c
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 24 17:24:23 2007 -0400

    SCTP: Correctly disable ADD-IP when AUTH is not supported.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a17701740624..41f1039186dd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1540,7 +1540,6 @@ struct sctp_association {
 		__u8    asconf_capable;  /* Does peer support ADDIP? */
 		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
 		__u8	auth_capable;	 /* Is peer doing SCTP-AUTH? */
-		__u8	addip_capable;	 /* Can peer do ADD-IP */
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 

commit 0ed90fb0f668fd07f14ae2007a809e8b26cd27a6
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 24 16:10:00 2007 -0400

    SCTP: Update RCU handling during the ADD-IP case
    
    After learning more about rcu, it looks like the ADD-IP hadling
    doesn't need to call call_rcu_bh.  All the rcu critical sections
    use rcu_read_lock, so using call_rcu_bh is wrong here.
    Now, restore the local_bh_disable() code blocks and use normal
    call_rcu() calls.  Also restore the missing return statement.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 482c2aab3d67..a17701740624 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1185,9 +1185,7 @@ int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 			int flags);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
 		       __u8 use_as_src, gfp_t gfp);
-int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-			void fastcall (*rcu_call)(struct rcu_head *,
-					  void (*func)(struct rcu_head *)));
+int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);
 union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,

commit b6157d8e03e1e780660a328f7183bcbfa4a93a19
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 24 15:59:16 2007 -0400

    SCTP: Fix difference cases of retransmit.
    
    Commit d0ce92910bc04e107b2f3f2048f07e94f570035d broke several retransmit
    cases including fast retransmit.  The reason is that we should
    only delay by rto while doing retranmists as a result of a timeout.
    Retransmit as a result of path mtu discover, fast retransmit, or
    other evernts that should trigger immidiate retransmissions got broken.
    
    Also, since rto is doubled prior to marking of packets elegable for
    retransmission, we never marked correct chunks anyway.
    
    The fix is provide a reason for a given retransmission so that we
    can mark chunks appropriately and to save the old rto value to do
    comparisons against.
    
    All regressions tests passed with this code.
    
    Spotted by Wei Yongjun <yjwei@cn.fujitsu.com>
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ef892e00c833..482c2aab3d67 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -873,10 +873,11 @@ struct sctp_transport {
 	 * address list derived from the INIT or INIT ACK chunk, a
 	 * number of data elements needs to be maintained including:
 	 */
-	__u32 rtt;		/* This is the most recent RTT.	 */
-
 	/* RTO	       : The current retransmission timeout value.  */
 	unsigned long rto;
+	unsigned long last_rto;
+
+	__u32 rtt;		/* This is the most recent RTT.	 */
 
 	/* RTTVAR      : The current RTT variation.  */
 	__u32 rttvar;

commit 06393009000779b00a558fd2f280882cc7dc2008
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Wed Oct 10 17:30:18 2007 -0700

    [SCTP]: port randomization
    
    Add port randomization rather than a simple fixed rover
    for use with SCTP.  This makes it act similar to TCP, UDP, DCCP
    when allocating ports.
    
    No longer need port_alloc_lock as well (suggestion by Brian Haley).
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 448f713a0205..ef892e00c833 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -197,8 +197,6 @@ extern struct sctp_globals {
 
 	/* This is the sctp port control hash.	*/
 	int port_hashsize;
-	int port_rover;
-	spinlock_t port_alloc_lock;  /* Protects port_rover. */
 	struct sctp_bind_hashbucket *port_hashtable;
 
 	/* This is the global local address list.

commit 6b2f9cb64db2d2460da17900bf54266030cc24f1
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sun Sep 16 19:35:39 2007 -0700

    [SCTP]: Tie ADD-IP and AUTH functionality as required by spec.
    
    ADD-IP spec requires AUTH. It is, in fact, dangerous without AUTH.
    So, disable ADD-IP functionality if the peer claims to support
    ADD-IP, but not AUTH.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 47e54f8e2b65..448f713a0205 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1543,6 +1543,7 @@ struct sctp_association {
 		__u8    asconf_capable;  /* Does peer support ADDIP? */
 		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
 		__u8	auth_capable;	 /* Is peer doing SCTP-AUTH? */
+		__u8	addip_capable;	 /* Can peer do ADD-IP */
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 

commit bbd0d59809f923ea2b540cbd781b32110e249f6e
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Wed Oct 3 17:51:34 2007 -0700

    [SCTP]: Implement the receive and verification of AUTH chunk
    
    This patch implements the receive path needed to process authenticated
    chunks.  Add ability to process the AUTH chunk and handle edge cases
    for authenticated COOKIE-ECHO as well.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 31841c3a7fe8..47e54f8e2b65 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -724,6 +724,13 @@ struct sctp_chunk {
 	 */
 	struct sctp_transport *transport;
 
+	/* SCTP-AUTH:  For the special case inbound processing of COOKIE-ECHO
+	 * we need save a pointer to the AUTH chunk, since the SCTP-AUTH
+	 * spec violates the principle premis that all chunks are processed
+	 * in order.
+	 */
+	struct sk_buff *auth_chunk;
+
 	__u8 rtt_in_progress;	/* Is this chunk used for RTT calculation? */
 	__u8 resent;		/* Has this chunk ever been retransmitted. */
 	__u8 has_tsn;		/* Does this chunk have a TSN yet? */
@@ -1067,6 +1074,7 @@ void sctp_inq_init(struct sctp_inq *);
 void sctp_inq_free(struct sctp_inq *);
 void sctp_inq_push(struct sctp_inq *, struct sctp_chunk *packet);
 struct sctp_chunk *sctp_inq_pop(struct sctp_inq *);
+struct sctp_chunkhdr *sctp_inq_peek(struct sctp_inq *);
 void sctp_inq_set_th_handler(struct sctp_inq *, work_func_t);
 
 /* This is the structure we use to hold outbound chunks.  You push

commit 4cd57c8078fae0a4b1bf421191e94626d0cba92a
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sun Sep 16 19:32:45 2007 -0700

    [SCTP]: Enable the sending of the AUTH chunk.
    
    SCTP-AUTH, Section 6.2:
    
       Endpoints MUST send all requested chunks authenticated where this has
       been requested by the peer.  The other chunks MAY be sent
       authenticated or not.  If endpoint pair shared keys are used, one of
       them MUST be selected for authentication.
    
       To send chunks in an authenticated way, the sender MUST include these
       chunks after an AUTH chunk.  This means that a sender MUST bundle
       chunks in order to authenticate them.
    
       If the endpoint has no endpoint pair shared key for the peer, it MUST
       use Shared Key Identifier 0 with an empty endpoint pair shared key.
       If there are multiple endpoint shared keys the sender selects one and
       uses the corresponding Shared Key Identifier
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 18b06afacea0..31841c3a7fe8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -798,6 +798,9 @@ struct sctp_packet {
 	/* This packet contains an AUTH chunk */
 	__u8 has_auth;
 
+	/* This packet contains at least 1 DATA chunk */
+	__u8 has_data;
+
 	/* SCTP cannot fragment this packet. So let ip fragment it. */
 	__u8 ipfragok;
 

commit 1f485649f52929d9937b346a920a522a7363e202
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Oct 9 01:15:59 2007 -0700

    [SCTP]: Implement SCTP-AUTH internals
    
    This patch implements the internals operations of the AUTH, such as
    key computation and storage.  It also adds necessary variables to
    the SCTP data structures.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b4812a2d3bb0..18b06afacea0 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -64,6 +64,7 @@
 #include <linux/skbuff.h>	/* We need sk_buff_head. */
 #include <linux/workqueue.h>	/* We need tq_struct.	 */
 #include <linux/sctp.h>		/* We need sctp* header structs.  */
+#include <net/sctp/auth.h>	/* We need auth specific structs */
 
 /* A convenience structure for handling sockaddr structures.
  * We should wean ourselves off this.
@@ -216,6 +217,9 @@ extern struct sctp_globals {
 
 	/* Flag to indicate if PR-SCTP is enabled. */
 	int prsctp_enable;
+
+	/* Flag to idicate if SCTP-AUTH is enabled */
+	int auth_enable;
 } sctp_globals;
 
 #define sctp_rto_initial		(sctp_globals.rto_initial)
@@ -248,6 +252,7 @@ extern struct sctp_globals {
 #define sctp_local_addr_lock		(sctp_globals.addr_list_lock)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
+#define sctp_auth_enable		(sctp_globals.auth_enable)
 
 /* SCTP Socket type: UDP or TCP style. */
 typedef enum {
@@ -397,6 +402,9 @@ struct sctp_cookie {
 
 	__u32 adaptation_ind;
 
+	__u8 auth_random[sizeof(sctp_paramhdr_t) + SCTP_AUTH_RANDOM_LENGTH];
+	__u8 auth_hmacs[SCTP_AUTH_NUM_HMACS + 2];
+	__u8 auth_chunks[sizeof(sctp_paramhdr_t) + SCTP_AUTH_MAX_CHUNKS];
 
 	/* This is a shim for my peer's INIT packet, followed by
 	 * a copy of the raw address list of the association.
@@ -441,6 +449,9 @@ union sctp_params {
 	union sctp_addr_param *addr;
 	struct sctp_adaptation_ind_param *aind;
 	struct sctp_supported_ext_param *ext;
+	struct sctp_random_param *random;
+	struct sctp_chunks_param *chunks;
+	struct sctp_hmac_algo_param *hmac_algo;
 };
 
 /* RFC 2960.  Section 3.3.5 Heartbeat.
@@ -679,6 +690,7 @@ struct sctp_chunk {
 		struct sctp_errhdr *err_hdr;
 		struct sctp_addiphdr *addip_hdr;
 		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
+		struct sctp_authhdr *auth_hdr;
 	} subh;
 
 	__u8 *chunk_end;
@@ -724,6 +736,7 @@ struct sctp_chunk {
 	__s8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
 	__u8 tsn_missing_report; /* Data chunk missing counter. */
 	__u8 data_accepted; 	/* At least 1 chunk in this packet accepted */
+	__u8 auth;		/* IN: was auth'ed | OUT: needs auth */
 };
 
 void sctp_chunk_hold(struct sctp_chunk *);
@@ -773,16 +786,22 @@ struct sctp_packet {
 	 */
 	struct sctp_transport *transport;
 
+	/* pointer to the auth chunk for this packet */
+	struct sctp_chunk *auth;
+
 	/* This packet contains a COOKIE-ECHO chunk. */
-	char has_cookie_echo;
+	__u8 has_cookie_echo;
+
+	/* This packet contains a SACK chunk. */
+	__u8 has_sack;
 
-	/* This packet containsa SACK chunk. */
-	char has_sack;
+	/* This packet contains an AUTH chunk */
+	__u8 has_auth;
 
 	/* SCTP cannot fragment this packet. So let ip fragment it. */
-	char ipfragok;
+	__u8 ipfragok;
 
-	int malloced;
+	__u8 malloced;
 };
 
 struct sctp_packet *sctp_packet_init(struct sctp_packet *,
@@ -1291,6 +1310,21 @@ struct sctp_endpoint {
 
 	/* rcvbuf acct. policy.	*/
 	__u32 rcvbuf_policy;
+
+	/* SCTP AUTH: array of the HMACs that will be allocated
+	 * we need this per association so that we don't serialize
+	 */
+	struct crypto_hash **auth_hmacs;
+
+	/* SCTP-AUTH: hmacs for the endpoint encoded into parameter */
+	 struct sctp_hmac_algo_param *auth_hmacs_list;
+
+	/* SCTP-AUTH: chunks to authenticate encoded into parameter */
+	struct sctp_chunks_param *auth_chunk_list;
+
+	/* SCTP-AUTH: endpoint shared keys */
+	struct list_head endpoint_shared_keys;
+	__u16 active_key_id;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1497,6 +1531,7 @@ struct sctp_association {
 		__u8	hostname_address;/* Peer understands DNS addresses? */
 		__u8    asconf_capable;  /* Does peer support ADDIP? */
 		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
+		__u8	auth_capable;	 /* Is peer doing SCTP-AUTH? */
 
 		__u32   adaptation_ind;	 /* Adaptation Code point. */
 
@@ -1514,6 +1549,14 @@ struct sctp_association {
 		 * Initial TSN Value minus 1
 		 */
 		__u32 addip_serial;
+
+		/* SCTP-AUTH: We need to know pears random number, hmac list
+		 * and authenticated chunk list.  All that is part of the
+		 * cookie and these are just pointers to those locations
+		 */
+		sctp_random_param_t *peer_random;
+		sctp_chunks_param_t *peer_chunks;
+		sctp_hmac_algo_param_t *peer_hmacs;
 	} peer;
 
 	/* State       : A state variable indicating what state the
@@ -1797,6 +1840,24 @@ struct sctp_association {
 	 */
 	__u32 addip_serial;
 
+	/* SCTP AUTH: list of the endpoint shared keys.  These
+	 * keys are provided out of band by the user applicaton
+	 * and can't change during the lifetime of the association
+	 */
+	struct list_head endpoint_shared_keys;
+
+	/* SCTP AUTH:
+	 * The current generated assocaition shared key (secret)
+	 */
+	struct sctp_auth_bytes *asoc_shared_key;
+
+	/* SCTP AUTH: hmac id of the first peer requested algorithm
+	 * that we support.
+	 */
+	__u16 default_hmac_id;
+
+	__u16 active_key_id;
+
 	/* Need to send an ECNE Chunk? */
 	char need_ecne;
 

commit 131a47e31ab1a9defd50ff16b04008ab94c21c0d
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sun Sep 16 15:53:56 2007 -0700

    [SCTP]: Implement the Supported Extensions Parameter
    
    SCTP Supported Extenions parameter is specified in Section 4.2.7
    of the ADD-IP draft (soon to be RFC).  The parameter is
    encoded as:
    
          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |     Parameter Type = 0x8008   |      Parameter Length         |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | CHUNK TYPE 1  |  CHUNK TYPE 2 |  CHUNK TYPE 3 |  CHUNK TYPE 4 |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                             ....                              |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         | CHUNK TYPE N  |      PAD      |      PAD      |      PAD      |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    
    It contains a list of chunks that a particular SCTP extension
    uses.  Current extensions supported are Partial Reliability
    (FWD-TSN) and ADD-IP (ASCONF and ASCONF-ACK).
    
    When implementing new extensions (AUTH, PKT-DROP, etc..), new
    chunks need to be added to this parameter.  Parameter processing
    would be modified to negotiate support for these new features.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 67c91d01b635..b4812a2d3bb0 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -440,6 +440,7 @@ union sctp_params {
 	struct sctp_ipv6addr_param *v6;
 	union sctp_addr_param *addr;
 	struct sctp_adaptation_ind_param *aind;
+	struct sctp_supported_ext_param *ext;
 };
 
 /* RFC 2960.  Section 3.3.5 Heartbeat.

commit 5c94bf86c865fb779f1743672b4d0f6cdd706728
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Sep 12 15:16:21 2007 +0200

    [SCTP]: Make sctp_addto_param() static.
    
    sctp_addto_param() can become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index baff49dfcdbd..67c91d01b635 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -731,7 +731,6 @@ int sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,
 			  struct iovec *data);
 void sctp_chunk_free(struct sctp_chunk *);
 void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
-void  *sctp_addto_param(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,
 				 const struct sctp_association *,
 				 struct sock *);

commit 78bd8fbbcd66fc977baa40e7fd838a4461b0f727
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Wed Sep 26 01:54:32 2007 +0100

    fix sctp_del_bind_addr() last argument type
    
    It gets pointer to fastcall function, expects a pointer to normal
    one and calls the sucker.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 490a2928817c..baff49dfcdbd 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1157,7 +1157,7 @@ int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
 		       __u8 use_as_src, gfp_t gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-			void (*rcu_call)(struct rcu_head *,
+			void fastcall (*rcu_call)(struct rcu_head *,
 					  void (*func)(struct rcu_head *)));
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);

commit 6f4c618ddb0e6b7e6d49cfc8134e694be1c0bc9b
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Wed Sep 19 17:19:52 2007 +0800

    SCTP : Add paramters validity check for ASCONF chunk
    
    If ADDIP is enabled, when an ASCONF chunk is received with ASCONF
    paramter length set to zero, this will cause infinite loop.
    By the way, if an malformed ASCONF chunk is received, will cause
    processing to access memory without verifying.
    
    This is because of not check the validity of parameters in ASCONF chunk.
    This patch fixed this.
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c2fe2dcc9afc..490a2928817c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -421,6 +421,7 @@ struct sctp_signed_cookie {
  * internally.
  */
 union sctp_addr_param {
+	struct sctp_paramhdr p;
 	struct sctp_ipv4addr_param v4;
 	struct sctp_ipv6addr_param v6;
 };

commit 559cf710b07c5e2cfa3fb8d8f4a1320fd84c53f9
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sun Sep 16 16:03:28 2007 -0700

    [SCTP]: Convert bind_addr_list locking to RCU
    
    Since the sctp_sockaddr_entry is now RCU enabled as part of
    the patch to synchronize sctp_localaddr_list, it makes sense to
    change all handling of these entries to RCU.  This includes the
    sctp_bind_addrs structure and it's list of bound addresses.
    
    This list is currently protected by an external rw_lock and that
    looks like an overkill.  There are only 2 writers to the list:
    bind()/bindx() calls, and BH processing of ASCONF-ACK chunks.
    These are already seriealized via the socket lock, so they will
    not step on each other.  These are also relatively rare, so we
    should be good with RCU.
    
    The readers are varied and they are easily converted to RCU.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Sridhar Samdurala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index a89e36197afb..c2fe2dcc9afc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1155,7 +1155,9 @@ int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 			int flags);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
 		       __u8 use_as_src, gfp_t gfp);
-int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
+int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
+			void (*rcu_call)(struct rcu_head *,
+					  void (*func)(struct rcu_head *)));
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);
 union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,
@@ -1226,9 +1228,6 @@ struct sctp_ep_common {
 	 * bind_addr.address_list is our set of local IP addresses.
 	 */
 	struct sctp_bind_addr bind_addr;
-
-	/* Protection during address list comparisons. */
-	rwlock_t   addr_lock;
 };
 
 

commit 293035479942400a7fe8e4f72465d4e4e466b91a
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sun Sep 16 16:02:12 2007 -0700

    [SCTP]: Add RCU synchronization around sctp_localaddr_list
    
    sctp_localaddr_list is modified dynamically via NETDEV_UP
    and NETDEV_DOWN events, but there is not synchronization
    between writer (even handler) and readers.  As a result,
    the readers can access an entry that has been freed and
    crash the sytem.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Sridhar Samdurala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c0d5848c33dc..a89e36197afb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -207,6 +207,9 @@ extern struct sctp_globals {
 	 * It is a list of sctp_sockaddr_entry.
 	 */
 	struct list_head local_addr_list;
+
+	/* Lock that protects the local_addr_list writers */
+	spinlock_t addr_list_lock;
 	
 	/* Flag to indicate if addip is enabled. */
 	int addip_enable;
@@ -242,6 +245,7 @@ extern struct sctp_globals {
 #define sctp_port_alloc_lock		(sctp_globals.port_alloc_lock)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_local_addr_list		(sctp_globals.local_addr_list)
+#define sctp_local_addr_lock		(sctp_globals.addr_list_lock)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 
@@ -737,8 +741,10 @@ const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 /* This is a structure for holding either an IPv6 or an IPv4 address.  */
 struct sctp_sockaddr_entry {
 	struct list_head list;
+	struct rcu_head	rcu;
 	union sctp_addr a;
 	__u8 use_as_src;
+	__u8 valid;
 };
 
 typedef struct sctp_chunk *(sctp_packet_phandler_t)(struct sctp_association *);

commit 00f1c2df2a1c4903f4daa1333bafeb6dcbc9591d
Author: Wei Yongjun <yjwei@cn.fujitsu.com>
Date:   Tue Aug 21 15:50:01 2007 +0800

    SCTP: Fix to encode PROTOCOL VIOLATION error cause correctly
    
    PROTOCOL VIOLATION error cause in ABORT is bad encode when make abort
    chunk. When SCTP encode ABORT chunk with PROTOCOL VIOLATION error cause,
    it just add the error messages to PROTOCOL VIOLATION error cause, the
    rest four bytes(struct sctp_paramhdr) is just add to the chunk, not
    change the length of error cause. This cause the ABORT chunk to be a bad
    format. The chunk is like this:
    
    ABORT chunk
      Chunk type: ABORT (6)
      Chunk flags: 0x00
      Chunk length: 72 (*1)
      Protocol violation cause
        Cause code: Protocol violation (0x000d)
        Cause length: 62 (*2)
        Cause information: 5468652063756D756C61746976652074736E2061636B2062...
        Cause padding: 0000
    [Needless] 00030010
    Chunk Length(*1) = 72 but Cause length(*2) only 62, not include the
    extend 4 bytes.
    ((72 - sizeof(chunk_hdr)) = 68) != (62 +3) / 4 * 4
    
    Signed-off-by: Wei Yongjun <yjwei@cn.fujitsu.com>
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ee4559b11302..c0d5848c33dc 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -726,6 +726,7 @@ int sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,
 			  struct iovec *data);
 void sctp_chunk_free(struct sctp_chunk *);
 void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
+void  *sctp_addto_param(struct sctp_chunk *, int len, const void *data);
 struct sctp_chunk *sctp_chunkify(struct sk_buff *,
 				 const struct sctp_association *,
 				 struct sock *);

commit 8a4794914f9cf2681235ec2311e189fe307c28c7
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Jun 7 14:21:05 2007 -0400

    [SCTP] Flag a pmtu change request
    
    Currently, if the socket is owned by the user, we drop the ICMP
    message.  As a result SCTP forgets that path MTU changed and
    never adjusting it's estimate.  This causes all subsequent
    packets to be fragmented.  With this patch, we'll flag the association
    that it needs to udpate it's estimate based on the already updated
    routing information.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Acked-by: Sridhar Samudrala <sri@us.ibm.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index dc0e70cb0f8b..ee4559b11302 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -912,6 +912,9 @@ struct sctp_transport {
 	 */
 	__u16 pathmaxrxt;
 
+	/* is the Path MTU update pending on this tranport */
+	__u8 pmtu_pending;
+
 	/* PMTU	      : The current known path MTU.  */
 	__u32 pathmtu;
 
@@ -1566,6 +1569,9 @@ struct sctp_association {
 	 */
 	__u16 pathmaxrxt;
 
+	/* Flag that path mtu update is pending */
+	__u8   pmtu_pending;
+
 	/* Association : The smallest PMTU discovered for all of the
 	 * PMTU	       : peer's transport addresses.
 	 */

commit c910b47e1811b3f8b184108c48de3d7af3e2999b
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Jun 7 13:47:03 2007 -0400

    [SCTP] Update pmtu handling to be similar to tcp
    
    Introduce new function sctp_transport_update_pmtu that updates
    the transports and destination caches view of the path mtu.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Acked-by: Sridhar Samudrala <sri@us.ibm.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5e81984b8478..dc0e70cb0f8b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1006,6 +1006,7 @@ void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);
 void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
 void sctp_transport_reset(struct sctp_transport *);
+void sctp_transport_update_pmtu(struct sctp_transport *, u32);
 
 
 /* This is the structure we use to queue packets as they come into

commit 07d939677166cc4f000c767196872a9becc2697b
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri May 4 13:55:27 2007 -0700

    [SCTP]: Set assoc_id correctly during INIT collision.
    
    During the INIT/COOKIE-ACK collision cases, it's possible to get
    into a situation where the association id is not yet set at the time
    of the user event generation.  As a result, user events have an
    association id set to 0 which will confuse applications.
    
    This happens if we hit case B of duplicate cookie processing.
    In the particular example found and provided by Oscar Isaula
    <Oscar.Isaula@motorola.com>, flow looks like this:
    A                               B
    ---- INIT------->  (lost)
                <---------INIT------
    ---- INIT-ACK--->
                <------ Cookie ECHO
    
    When the Cookie Echo is received, we end up trying to update the
    association that was created on A as a result of the (lost) INIT,
    but that association doesn't have the ID set yet.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7b4fff93ba7f..5e81984b8478 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1857,6 +1857,7 @@ int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *,
 int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
 					 struct sctp_cookie*,
 					 gfp_t gfp);
+int sctp_assoc_set_id(struct sctp_association *, gfp_t);
 
 int sctp_cmp_addr_exact(const union sctp_addr *ss1,
 			const union sctp_addr *ss2);

commit 703315712cfccfe0b45ef4aa6994527d8ee95e33
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Mar 23 11:34:36 2007 -0700

    [SCTP]: Implement SCTP_MAX_BURST socket option.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 37b4a24e589b..7b4fff93ba7f 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -276,6 +276,7 @@ struct sctp_sock {
 	__u32 default_context;
 	__u32 default_timetolive;
 	__u32 default_rcv_context;
+	int max_burst;
 
 	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 	 * the destination address every heartbeat interval. This value

commit d49d91d79a8dc5e85108a5ae1c8eef23dec135c1
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Mar 23 11:32:00 2007 -0700

    [SCTP]: Implement SCTP_PARTIAL_DELIVERY_POINT option.
    
    This option induces partial delivery to run as soon
    as the specified amount of data has been accumulated on
    the association.  However, we give preference to fully
    reassembled messages over PD messages.  In any case,
    window and buffer is freed up.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@.hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index fe7f5ae1c513..37b4a24e589b 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -307,6 +307,7 @@ struct sctp_sock {
 	__u8 v4mapped;
 	__u8 frag_interleave;
 	__u32 adaptation_ind;
+	__u32 pd_point;
 
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */

commit b6e1331f3ce25a56edb956054eaf8011654686cb
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Apr 20 12:23:15 2007 -0700

    [SCTP]: Implement SCTP_FRAGMENT_INTERLEAVE socket option
    
    This option was introduced in draft-ietf-tsvwg-sctpsocket-13.  It
    prevents head-of-line blocking in the case of one-to-many endpoint.
    Applications enabling this option really must enable SCTP_SNDRCV event
    so that they would know where the data belongs.  Based on an
    earlier patch by Ivan Skytte Jrgensen.
    
    Additionally, this functionality now permits multiple associations
    on the same endpoint to enter Partial Delivery.  Applications should
    be extra careful, when using this functionality, to track EOR indicators.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f431acf3dcea..fe7f5ae1c513 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -304,10 +304,11 @@ struct sctp_sock {
 	__u32 autoclose;
 	__u8 nodelay;
 	__u8 disable_fragments;
-	__u8 pd_mode;
 	__u8 v4mapped;
+	__u8 frag_interleave;
 	__u32 adaptation_ind;
 
+	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
 };

commit 749bf9215ed1a8b6edb4bb03693c2b62c6b9c2a4
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Mon Mar 19 17:02:30 2007 -0700

    [SCTP]: Reset some transport and association variables on restart
    
    If the association has been restarted, we need to reset the
    transport congestion variables as well as accumulated error
    counts and CACC variables.  If we do not, the association
    will use the wrong values and may terminate prematurely.
    
    This was found with a scenario where the peer restarted
    the association when lksctp was in the last HB timeout for
    its association.  The restart happened, but the error counts
    have not been reset and when the timeout occurred, a newly
    restarted association was terminated due to excessive
    retransmits.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 31a8e88f1a74..f431acf3dcea 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1002,6 +1002,7 @@ void sctp_transport_update_rto(struct sctp_transport *, __u32);
 void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);
 void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
 unsigned long sctp_transport_timeout(struct sctp_transport *);
+void sctp_transport_reset(struct sctp_transport *);
 
 
 /* This is the structure we use to queue packets as they come into

commit 0f3fffd8ab1db7658c97c167e8ab001cc814e1f4
Author: Ivan Skytte Jorgensen <isj-sctp@i1.dk>
Date:   Wed Dec 20 16:07:04 2006 -0800

    [SCTP]: Fix typo adaption -> adaptation as per the latest API draft.
    
    Signed-off-by: Ivan Skytte Jorgensen <isj-sctp@i1.dk>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8d7f26d684e5..31a8e88f1a74 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -306,7 +306,7 @@ struct sctp_sock {
 	__u8 disable_fragments;
 	__u8 pd_mode;
 	__u8 v4mapped;
-	__u32 adaption_ind;
+	__u32 adaptation_ind;
 
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
@@ -388,7 +388,7 @@ struct sctp_cookie {
 	/* Padding for future use */
 	__u8 padding;  		
 
-	__u32 adaption_ind;	
+	__u32 adaptation_ind;
 
 
 	/* This is a shim for my peer's INIT packet, followed by
@@ -431,7 +431,7 @@ union sctp_params {
 	struct sctp_ipv4addr_param *v4;
 	struct sctp_ipv6addr_param *v6;
 	union sctp_addr_param *addr;
-	struct sctp_adaption_ind_param *aind;
+	struct sctp_adaptation_ind_param *aind;
 };
 
 /* RFC 2960.  Section 3.3.5 Heartbeat.
@@ -1483,7 +1483,7 @@ struct sctp_association {
 		__u8    asconf_capable;  /* Does peer support ADDIP? */
 		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
 
-		__u32   adaption_ind;	 /* Adaption Code point. */
+		__u32   adaptation_ind;	 /* Adaptation Code point. */
 
 		/* This mask is used to disable sending the ASCONF chunk
 		 * with specified parameter to peer.

commit 6ab792f577012312a760a3a1e679ae8fae012442
Author: Ivan Skytte Jorgensen <isj-sctp@i1.dk>
Date:   Wed Dec 13 16:34:22 2006 -0800

    [SCTP]: Add support for SCTP_CONTEXT socket option.
    
    Signed-off-by: Ivan Skytte Jorgensen <isj-sctp@i1.dk>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index b00d85e14fe1..8d7f26d684e5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -275,6 +275,7 @@ struct sctp_sock {
 	__u16 default_flags;
 	__u32 default_context;
 	__u32 default_timetolive;
+	__u32 default_rcv_context;
 
 	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 	 * the destination address every heartbeat interval. This value
@@ -1657,6 +1658,9 @@ struct sctp_association {
 	__u32 default_context;
 	__u32 default_timetolive;
 
+	/* Default receive parameters */
+	__u32 default_rcv_context;
+
 	/* This tracks outbound ssn for a given stream.	 */
 	struct sctp_ssnmap *ssnmap;
 

commit 29c7cf96186ac14ce7380633f690fc39732ff03a
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Wed Dec 13 16:26:26 2006 -0800

    [SCTP]: Handle address add/delete events in a more efficient way.
    
    Currently in SCTP, we maintain a local address list by rebuilding the whole
    list from the device list whenever we get a address add/delete event.
    
    This patch fixes it by only adding/deleting the address for which we
    receive the event.
    
    Also removed the sctp_local_addr_lock() which is no longer needed as we
    now use list_for_each_safe() to traverse this list. This fixes the bugs
    in sctp_copy_laddrs_xxx() routines where we do copy_to_user() while
    holding this lock.
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c089f93ba591..b00d85e14fe1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -201,13 +201,12 @@ extern struct sctp_globals {
 	struct sctp_bind_hashbucket *port_hashtable;
 
 	/* This is the global local address list.
-	 * We actively maintain this complete list of interfaces on
-	 * the system by catching routing events.
+	 * We actively maintain this complete list of addresses on
+	 * the system by catching address add/delete events.
 	 *
 	 * It is a list of sctp_sockaddr_entry.
 	 */
 	struct list_head local_addr_list;
-	spinlock_t local_addr_lock;
 	
 	/* Flag to indicate if addip is enabled. */
 	int addip_enable;
@@ -243,7 +242,6 @@ extern struct sctp_globals {
 #define sctp_port_alloc_lock		(sctp_globals.port_alloc_lock)
 #define sctp_port_hashtable		(sctp_globals.port_hashtable)
 #define sctp_local_addr_list		(sctp_globals.local_addr_list)
-#define sctp_local_addr_lock		(sctp_globals.local_addr_lock)
 #define sctp_addip_enable		(sctp_globals.addip_enable)
 #define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
 

commit 4c1ac1b49122b805adfa4efc620592f68dccf5db
Merge: c4028958b6ec d916faace3ef
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 14:37:56 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/infiniband/core/iwcm.c
            drivers/net/chelsio/cxgb2.c
            drivers/net/wireless/bcm43xx/bcm43xx_main.c
            drivers/net/wireless/prism54/islpci_eth.c
            drivers/usb/core/hub.h
            drivers/usb/input/hid-core.c
            net/core/netpoll.c
    
    Fix up merge failures with Linus's head and fix new compilation failures.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit 3dbe86566ed262dae3b5472b9360cb5b65d42716
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:25:49 2006 -0800

    [SCTP]: Annotate ->supported_addrs().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2db4a1bdd1a7..f8cbe40f52c0 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -587,7 +587,7 @@ struct sctp_pf {
 			  struct sctp_sock *);
 	int  (*bind_verify) (struct sctp_sock *, union sctp_addr *);
 	int  (*send_verify) (struct sctp_sock *, union sctp_addr *);
-	int  (*supported_addrs)(const struct sctp_sock *, __u16 *);
+	int  (*supported_addrs)(const struct sctp_sock *, __be16 *);
 	struct sock *(*create_accept_sk) (struct sock *sk,
 					  struct sctp_association *asoc);
 	void (*addr_v4map) (struct sctp_sock *, union sctp_addr *);

commit e1857ea28dc76e2a929d1fff4d5d5cf712f12f4e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:25:32 2006 -0800

    [SCTP]: sctp_association ->peer.i is a host-endian analog of sctp_inthdr.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 3a6b8745538c..2db4a1bdd1a7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1314,6 +1314,13 @@ int sctp_process_init(struct sctp_association *, sctp_cid_t cid,
 __u32 sctp_generate_tag(const struct sctp_endpoint *);
 __u32 sctp_generate_tsn(const struct sctp_endpoint *);
 
+struct sctp_inithdr_host {
+	__u32 init_tag;
+	__u32 a_rwnd;
+	__u16 num_outbound_streams;
+	__u16 num_inbound_streams;
+	__u32 initial_tsn;
+};
 
 /* RFC2960
  *
@@ -1484,7 +1491,7 @@ struct sctp_association {
 		 */
 		__be16 addip_disabled_mask;
 
-		struct sctp_inithdr i;
+		struct sctp_inithdr_host i;
 		int cookie_len;
 		void *cookie;
 

commit 6fbfa9f951878ab489147d9e459191d4aacfa819
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:24:53 2006 -0800

    [SCTP]: Annotate ->inaddr_any().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index d44202b0487d..3a6b8745538c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -560,7 +560,7 @@ struct sctp_af {
 					 struct sctp_sock *,
 					 const struct sk_buff *);
 	sctp_scope_t	(*scope) (union sctp_addr *);
-	void		(*inaddr_any)	(union sctp_addr *, unsigned short);
+	void		(*inaddr_any)	(union sctp_addr *, __be16);
 	int		(*is_any)	(const union sctp_addr *);
 	int		(*available)	(union sctp_addr *,
 					 struct sctp_sock *);

commit c9c938cb050e6d45088c5c39e4097742e875c496
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:24:36 2006 -0800

    [SCTP]: flip_to_{h,n}() are not needed anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 02f1fd5de4be..d44202b0487d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -74,28 +74,6 @@ union sctp_addr {
 	struct sockaddr sa;
 };
 
-static inline void flip_to_n(union sctp_addr *to, const union sctp_addr *from)
-{
-	size_t len;
-	if (from->sa.sa_family == AF_INET6)
-		len = sizeof(struct sockaddr_in6);
-	else
-		len = sizeof(struct sockaddr);
-	memcpy(to, from, len);
-	to->v4.sin_port = htons(from->v4.sin_port);
-}
-
-static inline void flip_to_h(union sctp_addr *to, const union sctp_addr *from)
-{
-	size_t len;
-	if (from->sa.sa_family == AF_INET6)
-		len = sizeof(struct sockaddr_in6);
-	else
-		len = sizeof(struct sockaddr);
-	memcpy(to, from, len);
-	to->v4.sin_port = ntohs(from->v4.sin_port);
-}
-
 /* Forward declarations for data structures. */
 struct sctp_globals;
 struct sctp_endpoint;

commit 516b20ee2d4df76e7f76332e161a25c70e8f7bea
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:24:02 2006 -0800

    [SCTP]: ->a_h is gone now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index bb857957a88a..02f1fd5de4be 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -843,7 +843,6 @@ struct sctp_transport {
 
 	/* This is the peer's IP address and port. */
 	union sctp_addr ipaddr;
-	union sctp_addr ipaddr_h;
 
 	/* These are the functions we call to handle LLP stuff.	 */
 	struct sctp_af *af_specific;

commit 74af924ab6562717ef9aab1061ec05bbbf31d979
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:22:26 2006 -0800

    [SCTP]: ->a_h is gone now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9bb5c038b95a..bb857957a88a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -757,7 +757,6 @@ const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 struct sctp_sockaddr_entry {
 	struct list_head list;
 	union sctp_addr a;
-	union sctp_addr a_h;
 	__u8 use_as_src;
 };
 

commit 80f15d62418040e78849f5fc3a4a5af9c9d1fec7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:14:23 2006 -0800

    [SCTP]: ->source_h is not used anymore.
    
    kill it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 275195620145..9bb5c038b95a 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -714,7 +714,6 @@ struct sctp_chunk {
 
 	/* What is the origin IP address for this chunk?  */
 	union sctp_addr source;
-	union sctp_addr source_h;
 	/* Destination address for this chunk. */
 	union sctp_addr dest;
 

commit a926626893aca20567f27af1c5edc830e1c51b2b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:13:58 2006 -0800

    [SCTP]: Switch all remaining users of ->saddr_h to ->saddr.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8f6619dbb666..275195620145 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -904,7 +904,6 @@ struct sctp_transport {
 	struct dst_entry *dst;
 	/* Source address. */
 	union sctp_addr saddr;
-	union sctp_addr saddr_h;
 
 	/* When was the last time(in jiffies) that a data packet was sent on
 	 * this transport?  This is used to adjust the cwnd when the transport

commit dd86d136f9feb72c52a5b07707affe80edbc8dda
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:11:13 2006 -0800

    [SCTP]: Switch ->from_addr_param() to net-endian.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 1616a38a0be3..8f6619dbb666 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -575,7 +575,7 @@ struct sctp_af {
 					 struct sock *sk);
 	void		(*from_addr_param) (union sctp_addr *,
 					    union sctp_addr_param *,
-					    __u16 port, int iif);	
+					    __be16 port, int iif);
 	int		(*to_addr_param) (const union sctp_addr *,
 					  union sctp_addr_param *); 
 	int		(*addr_valid)	(union sctp_addr *,

commit 854d43a465cc8ba8e501320b3bc27359d909da2f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:06:24 2006 -0800

    [SCTP]: Annotate ->dst_saddr()
    
    switched to taking a pointer to net-endian sctp_addr
    and a net-endian port number.  Instances and callers
    adjusted; interestingly enough, the only calls are
    direct calls of specific instances - the method is not
    used at all.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2c35f2fd5601..1616a38a0be3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -559,7 +559,7 @@ struct sctp_af {
 					  struct net_device *);
 	void		(*dst_saddr)	(union sctp_addr *saddr,
 					 struct dst_entry *dst,
-					 unsigned short port);
+					 __be16 port);
 	int		(*cmp_addr)	(const union sctp_addr *addr1,
 					 const union sctp_addr *addr2);
 	void		(*addr_copy)	(union sctp_addr *dst,

commit 2a6fd78adec062f16f8662563115679e669efaca
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:04:42 2006 -0800

    [SCTP] embedded sctp_addr: net-endian mirrors
    
    Add sctp_chunk->source, sctp_sockaddr_entry->a, sctp_transport->ipaddr
    and sctp_transport->saddr, maintain them as net-endian mirrors of
    their host-endian counterparts.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 953a73f9689c..2c35f2fd5601 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -713,6 +713,7 @@ struct sctp_chunk {
 	unsigned long sent_at;
 
 	/* What is the origin IP address for this chunk?  */
+	union sctp_addr source;
 	union sctp_addr source_h;
 	/* Destination address for this chunk. */
 	union sctp_addr dest;
@@ -756,6 +757,7 @@ const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 /* This is a structure for holding either an IPv6 or an IPv4 address.  */
 struct sctp_sockaddr_entry {
 	struct list_head list;
+	union sctp_addr a;
 	union sctp_addr a_h;
 	__u8 use_as_src;
 };
@@ -842,6 +844,7 @@ struct sctp_transport {
 	int	 dead;
 
 	/* This is the peer's IP address and port. */
+	union sctp_addr ipaddr;
 	union sctp_addr ipaddr_h;
 
 	/* These are the functions we call to handle LLP stuff.	 */
@@ -900,6 +903,7 @@ struct sctp_transport {
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */
+	union sctp_addr saddr;
 	union sctp_addr saddr_h;
 
 	/* When was the last time(in jiffies) that a data packet was sent on

commit 09ef7fecea40c5e4c0dfe35bed3f0ed8da554cf5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:04:10 2006 -0800

    [SCTP]: Beginning of conversion to net-endian for embedded sctp_addr.
    
    Part 1: rename sctp_chunk->source, sctp_sockaddr_entry->a,
    sctp_transport->ipaddr and sctp_transport->saddr (to ..._h)
    
    The next patch will reintroduce these fields and keep them as
    net-endian mirrors of the original (renamed) ones.  Split in
    two patches to make sure that we hadn't forgotten any instanes.
    
    Later in the series we'll eliminate uses of host-endian variants
    (basically switching users to net-endian counterparts as we
    progress through that mess).  Then host-endian ones will die.
    
    Other embedded host-endian sctp_addr will be easier to switch
    directly, so we leave them alone for now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2aa61ac9a9f3..953a73f9689c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -713,7 +713,7 @@ struct sctp_chunk {
 	unsigned long sent_at;
 
 	/* What is the origin IP address for this chunk?  */
-	union sctp_addr source;
+	union sctp_addr source_h;
 	/* Destination address for this chunk. */
 	union sctp_addr dest;
 
@@ -756,7 +756,7 @@ const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 /* This is a structure for holding either an IPv6 or an IPv4 address.  */
 struct sctp_sockaddr_entry {
 	struct list_head list;
-	union sctp_addr a;
+	union sctp_addr a_h;
 	__u8 use_as_src;
 };
 
@@ -842,7 +842,7 @@ struct sctp_transport {
 	int	 dead;
 
 	/* This is the peer's IP address and port. */
-	union sctp_addr ipaddr;
+	union sctp_addr ipaddr_h;
 
 	/* These are the functions we call to handle LLP stuff.	 */
 	struct sctp_af *af_specific;
@@ -900,7 +900,7 @@ struct sctp_transport {
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */
-	union sctp_addr saddr;
+	union sctp_addr saddr_h;
 
 	/* When was the last time(in jiffies) that a data packet was sent on
 	 * this transport?  This is used to adjust the cwnd when the transport

commit 04afd8b282d702bc122051751466000e9513ef96
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:02:01 2006 -0800

    [SCTP]: Beginning of sin_port fixes.
    
    That's going to be a long series.  Introduced temporary helpers
    doing copy-and-convert for sctp_addr; they are used to kill
    flip-in-place in global data structures and will be used
    to gradually push host-endian uses of sctp_addr out of existence.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ca77bc5b7ff5..2aa61ac9a9f3 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -74,6 +74,28 @@ union sctp_addr {
 	struct sockaddr sa;
 };
 
+static inline void flip_to_n(union sctp_addr *to, const union sctp_addr *from)
+{
+	size_t len;
+	if (from->sa.sa_family == AF_INET6)
+		len = sizeof(struct sockaddr_in6);
+	else
+		len = sizeof(struct sockaddr);
+	memcpy(to, from, len);
+	to->v4.sin_port = htons(from->v4.sin_port);
+}
+
+static inline void flip_to_h(union sctp_addr *to, const union sctp_addr *from)
+{
+	size_t len;
+	if (from->sa.sa_family == AF_INET6)
+		len = sizeof(struct sockaddr_in6);
+	else
+		len = sizeof(struct sockaddr);
+	memcpy(to, from, len);
+	to->v4.sin_port = ntohs(from->v4.sin_port);
+}
+
 /* Forward declarations for data structures. */
 struct sctp_globals;
 struct sctp_endpoint;

commit dbc16db1e58da6c346ca3e63870c17b93fbed0f0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 20 17:01:42 2006 -0800

    [SCTP]: Trivial sctp endianness annotations.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5596f5d97ed2..ca77bc5b7ff5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1482,7 +1482,7 @@ struct sctp_association {
 		/* This mask is used to disable sending the ASCONF chunk
 		 * with specified parameter to peer.
 		 */
-		__u16 addip_disabled_mask;
+		__be16 addip_disabled_mask;
 
 		struct sctp_inithdr i;
 		int cookie_len;

commit b68dbcab1dc70938fa5516d0ee82c0bf94e9a768
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Nov 9 16:29:57 2006 -0800

    [SCTP]: Fix warning
    
    An alternate solution would be to make the digest a pointer, allocate
    it in sctp_endpoint_init() and free it in sctp_endpoint_destroy().
    
    I guess I should have originally done it this way...
    
      CC [M]  net/sctp/sm_make_chunk.o
    net/sctp/sm_make_chunk.c: In function 'sctp_unpack_cookie':
    net/sctp/sm_make_chunk.c:1358: warning: initialization discards qualifiers from pointer target type
    
    The reason is that sctp_unpack_cookie() takes a const struct
    sctp_endpoint and modifies the digest in it (digest being embedded in
    the struct, not a pointer).  Make digest a pointer to fix this
    warning.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Acked-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c6d93bb0dcd2..5596f5d97ed2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1270,7 +1270,7 @@ struct sctp_endpoint {
  	 * 	    this here so we pre-allocate this once and can re-use
  	 * 	    on every receive.
  	 */
- 	__u8 digest[SCTP_SIGNATURE_SIZE];
+ 	__u8 *digest;
  
 	/* sendbuf acct. policy.	*/
 	__u32 sndbuf_policy;

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index c6d93bb0dcd2..60b684470db8 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1030,7 +1030,7 @@ void sctp_inq_init(struct sctp_inq *);
 void sctp_inq_free(struct sctp_inq *);
 void sctp_inq_push(struct sctp_inq *, struct sctp_chunk *packet);
 struct sctp_chunk *sctp_inq_pop(struct sctp_inq *);
-void sctp_inq_set_th_handler(struct sctp_inq *, void (*)(void *), void *);
+void sctp_inq_set_th_handler(struct sctp_inq *, work_func_t);
 
 /* This is the structure we use to hold outbound chunks.  You push
  * chunks in and they automatically pop out the other end as bundled

commit 3fd091e73b81f131e1567c4d4a1ec042940bf2f7
Author: Vladislav Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Aug 22 13:29:17 2006 -0700

    [SCTP]: Remove multiple levels of msecs to jiffies conversions.
    
    The SCTP sysctl entries are displayed in milliseconds, but stored
    internally in jiffies. This results in multiple levels of msecs to
    jiffies conversion and as a result produces a truncation error. This
    patch makes things consistent in that we store and display defaults
    in milliseconds and only convert once for use by association.
    This patch also adds some sane min/max values so that we don't go off
    the deep end.
    
    Signed-off-by: Vladislav Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 0412e730c765..c6d93bb0dcd2 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -128,9 +128,9 @@ extern struct sctp_globals {
 	 * RTO.Alpha		    - 1/8  (3 when converted to right shifts.)
 	 * RTO.Beta		    - 1/4  (2 when converted to right shifts.)
 	 */
-	unsigned long rto_initial;
-	unsigned long rto_min;
-	unsigned long rto_max;
+	unsigned int rto_initial;
+	unsigned int rto_min;
+	unsigned int rto_max;
 
 	/* Note: rto_alpha and rto_beta are really defined as inverse
 	 * powers of two to facilitate integer operations.
@@ -145,13 +145,13 @@ extern struct sctp_globals {
 	int cookie_preserve_enable;
 
 	/* Valid.Cookie.Life	    - 60  seconds  */
-	unsigned long valid_cookie_life;
+	unsigned int valid_cookie_life;
 
 	/* Delayed SACK timeout  200ms default*/
-	unsigned long sack_timeout;
+	unsigned int sack_timeout;
 
 	/* HB.interval		    - 30 seconds  */
-	unsigned long hb_interval;
+	unsigned int hb_interval;
 
 	/* Association.Max.Retrans  - 10 attempts
 	 * Path.Max.Retrans	    - 5	 attempts (per destination address)

commit 1b489e11d4df82514792f9f981f31976f8a94ddf
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Aug 20 15:07:14 2006 +1000

    [SCTP]: Use HMAC template and hash interface
    
    This patch converts SCTP to use the new HMAC template and hash interface.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index e5aa7ff1f5b5..0412e730c765 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -87,6 +87,7 @@ struct sctp_bind_addr;
 struct sctp_ulpq;
 struct sctp_ep_common;
 struct sctp_ssnmap;
+struct crypto_hash;
 
 
 #include <net/sctp/tsnmap.h>
@@ -264,7 +265,7 @@ struct sctp_sock {
 	struct sctp_pf *pf;
 
 	/* Access to HMAC transform. */
-	struct crypto_tfm *hmac;
+	struct crypto_hash *hmac;
 
 	/* What is our base endpointer? */
 	struct sctp_endpoint *ep;

commit dc022a9874d026c7d1635ae66d1afafc5f053731
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Fri Jul 21 14:49:25 2006 -0700

    [SCTP]: ADDIP: Don't use an address as source until it is ASCONF-ACKed
    
    This implements Rules D1 and D4 of Sec 4.3 in the ADDIP draft.
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 268f2e19ccbb..e5aa7ff1f5b5 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -731,13 +731,10 @@ void sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,
 const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
 
 /* This is a structure for holding either an IPv6 or an IPv4 address.  */
-/* sin_family -- AF_INET or AF_INET6
- * sin_port -- ordinary port number
- * sin_addr -- cast to either (struct in_addr) or (struct in6_addr)
- */
 struct sctp_sockaddr_entry {
 	struct list_head list;
 	union sctp_addr a;
+	__u8 use_as_src;
 };
 
 typedef struct sctp_chunk *(sctp_packet_phandler_t)(struct sctp_association *);
@@ -1142,7 +1139,7 @@ int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 			sctp_scope_t scope, gfp_t gfp,
 			int flags);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-		       gfp_t gfp);
+		       __u8 use_as_src, gfp_t gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);

commit ad8fec1720e000ba2384de6408076a60fc92a981
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Fri Jul 21 14:48:50 2006 -0700

    [SCTP]: Verify all the paths to a peer via heartbeat before using them.
    
    This patch implements Path Initialization procedure as described in
    Sec 2.36 of RFC4460.
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 5f69158c1006..268f2e19ccbb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -445,6 +445,7 @@ typedef struct sctp_sender_hb_info {
 	struct sctp_paramhdr param_hdr;
 	union sctp_addr daddr;
 	unsigned long sent_at;
+	__u64 hb_nonce;
 } __attribute__((packed)) sctp_sender_hb_info_t;
 
 /*
@@ -984,6 +985,9 @@ struct sctp_transport {
 		 */
 		char cacc_saw_newack;
 	} cacc;
+
+	/* 64-bit random number sent with heartbeat. */
+	__u64 hb_nonce;
 };
 
 struct sctp_transport *sctp_transport_new(const union sctp_addr *,

commit 5636bef7324f49e36f05ec8a5f6284e11b1bcca4
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Sat Jun 17 22:55:35 2006 -0700

    [SCTP]: Reject sctp packets with broadcast addresses.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7f4fea173fb1..5f69158c1006 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -555,7 +555,8 @@ struct sctp_af {
 	int		(*to_addr_param) (const union sctp_addr *,
 					  union sctp_addr_param *); 
 	int		(*addr_valid)	(union sctp_addr *,
-					 struct sctp_sock *);
+					 struct sctp_sock *,
+					 const struct sk_buff *);
 	sctp_scope_t	(*scope) (union sctp_addr *);
 	void		(*inaddr_any)	(union sctp_addr *, unsigned short);
 	int		(*is_any)	(const union sctp_addr *);

commit 7c3ceb4fb9667f34f1599a062efecf4cdc4a4ce5
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Fri May 5 17:02:09 2006 -0700

    [SCTP]: Allow spillover of receive buffer to avoid deadlock.
    
    This patch fixes a deadlock situation in the receive path by allowing
    temporary spillover of the receive buffer.
    
    - If the chunk we receive has a tsn that immediately follows the ctsn,
      accept it even if we run out of receive buffer space and renege data with
      higher TSNs.
    - Once we accept one chunk in a packet, accept all the remaining chunks
      even if we run out of receive buffer space.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Mark Butler <butlerm@middle.net>
    Acked-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index eba99f375517..7f4fea173fb1 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -712,6 +712,7 @@ struct sctp_chunk {
 	__u8 tsn_gap_acked;	/* Is this chunk acked by a GAP ACK? */
 	__s8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
 	__u8 tsn_missing_report; /* Data chunk missing counter. */
+	__u8 data_accepted; 	/* At least 1 chunk in this packet accepted */
 };
 
 void sctp_chunk_hold(struct sctp_chunk *);

commit 3fdadf7d27e3fbcf72930941884387d1f4936f04
Author: Dmitry Mishin <dim@openvz.org>
Date:   Mon Mar 20 22:45:21 2006 -0800

    [NET]: {get|set}sockopt compatibility layer
    
    This patch extends {get|set}sockopt compatibility layer in order to
    move protocol specific parts to their place and avoid huge universal
    net/compat.c file in the future.
    
    Signed-off-by: Dmitry Mishin <dim@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 072f407848a6..eba99f375517 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -514,6 +514,16 @@ struct sctp_af {
 					 int optname,
 					 char __user *optval,
 					 int __user *optlen);
+	int		(*compat_setsockopt)	(struct sock *sk,
+					 int level,
+					 int optname,
+					 char __user *optval,
+					 int optlen);
+	int		(*compat_getsockopt)	(struct sock *sk,
+					 int level,
+					 int optname,
+					 char __user *optval,
+					 int __user *optlen);
 	struct dst_entry *(*get_dst)	(struct sctp_association *asoc,
 					 union sctp_addr *daddr,
 					 union sctp_addr *saddr);

commit 27852c26baab8b95fc9a2b3e8a18770ecd553f10
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Thu Feb 2 16:57:31 2006 -0800

    [SCTP]: Fix 'fast retransmit' to send a TSN only once.
    
    SCTP used to "fast retransmit" a TSN every time we hit the number
    of missing reports for the TSN.  However the Implementers Guide
    specifies that we should only "fast retransmit" a given TSN once.
    Subsequent retransmits should be timeouts only. Also change the
    number of missing reports to 3 as per the latest IG(similar to TCP).
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8c522ae031bb..072f407848a6 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -700,7 +700,7 @@ struct sctp_chunk {
 	__u8 ecn_ce_done;	/* Have we processed the ECN CE bit? */
 	__u8 pdiscard;		/* Discard the whole packet now? */
 	__u8 tsn_gap_acked;	/* Is this chunk acked by a GAP ACK? */
-	__u8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
+	__s8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
 	__u8 tsn_missing_report; /* Data chunk missing counter. */
 };
 

commit 313e7b4d2588539e388d31c1febd50503a0083fc
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Jan 17 11:55:57 2006 -0800

    [SCTP]: Fix machine check/connection hang on IA64.
    
    sctp_unpack_cookie used an on-stack array called digest as a result/out
    parameter in the call to crypto_hmac. However, hmac code
    (crypto_hmac_final)
    assumes that the 'out' argument is in virtual memory (identity mapped
    region)
    and can use virt_to_page call on it.  This does not work with the on-stack
    declared digest.  The problems observed so far have been:
     a) incorrect hmac digest
     b) machine check and hardware reset.
    
    Solution is to define the digest in an identity mapped region by
    kmalloc'ing
    it.  We can do this once as part of the endpoint structure and re-use it
    when
    verifying the SCTP cookie.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index ad3d15cb0a0d..8c522ae031bb 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1250,6 +1250,14 @@ struct sctp_endpoint {
 	int last_key;
 	int key_changed_at;
 
+ 	/* digest:  This is a digest of the sctp cookie.  This field is
+ 	 * 	    only used on the receive path when we try to validate
+ 	 * 	    that the cookie has not been tampered with.  We put
+ 	 * 	    this here so we pre-allocate this once and can re-use
+ 	 * 	    on every receive.
+ 	 */
+ 	__u8 digest[SCTP_SIGNATURE_SIZE];
+ 
 	/* sendbuf acct. policy.	*/
 	__u32 sndbuf_policy;
 

commit 8116ffad4180b39d7a755345c1fde09da83930c0
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Jan 17 11:55:17 2006 -0800

    [SCTP]: Fix bad sysctl formatting of SCTP timeout values on 64-bit m/cs.
    
    Change all the structure members that hold jiffies to be of type
    unsigned long.  This also corrects bad sysctl formating on 64 bit
    architectures.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 72aeae4a0067..ad3d15cb0a0d 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -127,9 +127,9 @@ extern struct sctp_globals {
 	 * RTO.Alpha		    - 1/8  (3 when converted to right shifts.)
 	 * RTO.Beta		    - 1/4  (2 when converted to right shifts.)
 	 */
-	__u32 rto_initial;
-	__u32 rto_min;
-	__u32 rto_max;
+	unsigned long rto_initial;
+	unsigned long rto_min;
+	unsigned long rto_max;
 
 	/* Note: rto_alpha and rto_beta are really defined as inverse
 	 * powers of two to facilitate integer operations.
@@ -140,12 +140,18 @@ extern struct sctp_globals {
 	/* Max.Burst		    - 4 */
 	int max_burst;
 
-	/* Valid.Cookie.Life	    - 60  seconds  */
-	int valid_cookie_life;
-
 	/* Whether Cookie Preservative is enabled(1) or not(0) */
 	int cookie_preserve_enable;
 
+	/* Valid.Cookie.Life	    - 60  seconds  */
+	unsigned long valid_cookie_life;
+
+	/* Delayed SACK timeout  200ms default*/
+	unsigned long sack_timeout;
+
+	/* HB.interval		    - 30 seconds  */
+	unsigned long hb_interval;
+
 	/* Association.Max.Retrans  - 10 attempts
 	 * Path.Max.Retrans	    - 5	 attempts (per destination address)
 	 * Max.Init.Retransmits	    - 8	 attempts
@@ -168,12 +174,6 @@ extern struct sctp_globals {
 	 */
 	int rcvbuf_policy;
 
-	/* Delayed SACK timeout  200ms default*/
-	int sack_timeout;
-
-	/* HB.interval		    - 30 seconds  */
-	int hb_interval;
-
 	/* The following variables are implementation specific.	 */
 
 	/* Default initialization values to be applied to new associations. */
@@ -828,7 +828,7 @@ struct sctp_transport {
 	__u32 rtt;		/* This is the most recent RTT.	 */
 
 	/* RTO	       : The current retransmission timeout value.  */
-	__u32 rto;
+	unsigned long rto;
 
 	/* RTTVAR      : The current RTT variation.  */
 	__u32 rttvar;
@@ -878,22 +878,10 @@ struct sctp_transport {
 	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 	 * the destination address every heartbeat interval.
 	 */
-	__u32 hbinterval;
-
-	/* This is the max_retrans value for the transport and will
-	 * be initialized from the assocs value.  This can be changed
-	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
-	 */
-	__u16 pathmaxrxt;
-
-	/* PMTU	      : The current known path MTU.  */
-	__u32 pathmtu;
+	unsigned long hbinterval;
 
 	/* SACK delay timeout */
-	__u32 sackdelay;
-
-	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
-	__u32 param_flags;
+	unsigned long sackdelay;
 
 	/* When was the last time (in jiffies) that we heard from this
 	 * transport?  We use this to pick new active and retran paths.
@@ -905,6 +893,18 @@ struct sctp_transport {
 	 */
 	unsigned long last_time_ecne_reduced;
 
+	/* This is the max_retrans value for the transport and will
+	 * be initialized from the assocs value.  This can be changed
+	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
+	 */
+	__u16 pathmaxrxt;
+
+	/* PMTU	      : The current known path MTU.  */
+	__u32 pathmtu;
+
+	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	__u32 param_flags;
+
 	/* The number of times INIT has been sent on this transport. */
 	int init_sent_count;
 
@@ -1500,9 +1500,9 @@ struct sctp_association {
 	 * These values will be initialized by system defaults, but can
 	 * be modified via the SCTP_RTOINFO socket option.
 	 */
-	__u32 rto_initial;
-	__u32 rto_max;
-	__u32 rto_min;
+	unsigned long rto_initial;
+	unsigned long rto_max;
+	unsigned long rto_min;
 
 	/* Maximum number of new data packets that can be sent in a burst.  */
 	int max_burst;
@@ -1520,13 +1520,13 @@ struct sctp_association {
 	__u16 init_retries;
 
 	/* The largest timeout or RTO value to use in attempting an INIT */
-	__u16 max_init_timeo;
+	unsigned long max_init_timeo;
 
 	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 	 * the destination address every heartbeat interval. This value
 	 * will be inherited by all new transports.
 	 */
-	__u32 hbinterval;
+	unsigned long hbinterval;
 
 	/* This is the max_retrans value for new transports in the
 	 * association.
@@ -1538,13 +1538,14 @@ struct sctp_association {
 	 */
 	__u32 pathmtu;
 
-	/* SACK delay timeout */
-	__u32 sackdelay;
-
 	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
 	__u32 param_flags;
 
-	int timeouts[SCTP_NUM_TIMEOUT_TYPES];
+	/* SACK delay timeout */
+	unsigned long sackdelay;
+
+
+	unsigned long timeouts[SCTP_NUM_TIMEOUT_TYPES];
 	struct timer_list timers[SCTP_NUM_TIMEOUT_TYPES];
 
 	/* Transport to which SHUTDOWN chunk was last sent.  */
@@ -1649,7 +1650,10 @@ struct sctp_association {
 	/* How many duplicated TSNs have we seen?  */
 	int numduptsns;
 
-	/* Number of seconds of idle time before an association is closed.  */
+	/* Number of seconds of idle time before an association is closed.
+	 * In the association context, this is really used as a boolean
+	 * since the real timeout is stored in the timeouts array
+	 */
 	__u32 autoclose;
 
 	/* These are to support

commit 9834a2bb4970547540222fcba04e0a37d04cb0a0
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Jan 17 11:52:12 2006 -0800

    [SCTP]: Fix sctp_cookie alignment in the packet.
    
    On 64 bit architectures, sctp_cookie sent as part of INIT-ACK is not
    aligned on a 64 bit boundry and thus causes unaligned access exceptions.
    
    The layout of the cookie prameter is this:
    |<----- Parameter Header --------------------|<--- Cookie DATA --------
    -----------------------------------------------------------------------
    | param type (16 bits) | param len (16 bits) | sig [32 bytes] | cookie..
    -----------------------------------------------------------------------
    
    The cookie data portion contains 64 bit values on 64 bit architechtures
    (timeval) that fall on a 32 bit alignment boundry when used as part of
    the on-wire format, but align correctly when used in internal
    structures.  This patch explicitely pads the on-wire format so that
    it is properly aligned.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index f5c22d77feab..72aeae4a0067 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -405,8 +405,9 @@ struct sctp_cookie {
 /* The format of our cookie that we send to our peer. */
 struct sctp_signed_cookie {
 	__u8 signature[SCTP_SECRET_SIZE];
+	__u32 __pad;		/* force sctp_cookie alignment to 64 bits */
 	struct sctp_cookie c;
-};
+} __attribute__((packed));
 
 /* This is another convenience type to allocate memory for address
  * params for the maximum size and pass such structures around

commit 52ccb8e90c0ace233b8b740f2fc5de0dbd706b27
Author: Frank Filz <ffilz@us.ibm.com>
Date:   Thu Dec 22 11:36:46 2005 -0800

    [SCTP]: Update SCTP_PEER_ADDR_PARAMS socket option to the latest api draft.
    
    This patch adds support to set/get heartbeat interval, maximum number of
    retransmissions, pathmtu, sackdelay time for a particular transport/
    association/socket as per the latest SCTP sockets api draft11.
    
    Signed-off-by: Frank Filz <ffilz@us.ibm.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 8e7794ee27ff..f5c22d77feab 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -277,6 +277,24 @@ struct sctp_sock {
 	__u32 default_context;
 	__u32 default_timetolive;
 
+	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
+	 * the destination address every heartbeat interval. This value
+	 * will be inherited by all new associations.
+	 */
+	__u32 hbinterval;
+
+	/* This is the max_retrans value for new associations. */
+	__u16 pathmaxrxt;
+
+	/* The initial Path MTU to use for new associations. */
+	__u32 pathmtu;
+
+	/* The default SACK delay timeout for new associations. */
+	__u32 sackdelay;
+
+	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	__u32 param_flags;
+
 	struct sctp_initmsg initmsg;
 	struct sctp_rtoinfo rtoinfo;
 	struct sctp_paddrparams paddrparam;
@@ -845,9 +863,6 @@ struct sctp_transport {
 	/* Data that has been sent, but not acknowledged. */
 	__u32 flight_size;
 
-	/* PMTU	      : The current known path MTU.  */
-	__u32 pmtu;
-
 	/* Destination */
 	struct dst_entry *dst;
 	/* Source address. */
@@ -862,7 +877,22 @@ struct sctp_transport {
 	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
 	 * the destination address every heartbeat interval.
 	 */
-	int hb_interval;
+	__u32 hbinterval;
+
+	/* This is the max_retrans value for the transport and will
+	 * be initialized from the assocs value.  This can be changed
+	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
+	 */
+	__u16 pathmaxrxt;
+
+	/* PMTU	      : The current known path MTU.  */
+	__u32 pathmtu;
+
+	/* SACK delay timeout */
+	__u32 sackdelay;
+
+	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	__u32 param_flags;
 
 	/* When was the last time (in jiffies) that we heard from this
 	 * transport?  We use this to pick new active and retran paths.
@@ -882,22 +912,11 @@ struct sctp_transport {
 	 */
 	int state;
 
-	/* hb_allowed  : The current heartbeat state of this destination,
-	 *	       :  i.e. ALLOW-HB, NO-HEARTBEAT, etc.
-	 */
-	int hb_allowed;
-
 	/* These are the error stats for this destination.  */
 
 	/* Error count : The current error count for this destination.	*/
 	unsigned short error_count;
 
-	/* This is the max_retrans value for the transport and will
-	 * be initialized to proto.max_retrans.path.  This can be changed
-	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
-	 */
-	int max_retrans;
-
 	/* Per	       : A timer used by each destination.
 	 * Destination :
 	 * Timer       :
@@ -1502,6 +1521,28 @@ struct sctp_association {
 	/* The largest timeout or RTO value to use in attempting an INIT */
 	__u16 max_init_timeo;
 
+	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
+	 * the destination address every heartbeat interval. This value
+	 * will be inherited by all new transports.
+	 */
+	__u32 hbinterval;
+
+	/* This is the max_retrans value for new transports in the
+	 * association.
+	 */
+	__u16 pathmaxrxt;
+
+	/* Association : The smallest PMTU discovered for all of the
+	 * PMTU	       : peer's transport addresses.
+	 */
+	__u32 pathmtu;
+
+	/* SACK delay timeout */
+	__u32 sackdelay;
+
+	/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */
+	__u32 param_flags;
+
 	int timeouts[SCTP_NUM_TIMEOUT_TYPES];
 	struct timer_list timers[SCTP_NUM_TIMEOUT_TYPES];
 
@@ -1571,11 +1612,6 @@ struct sctp_association {
 	 */
 	wait_queue_head_t	wait;
 
-	/* Association : The smallest PMTU discovered for all of the
-	 * PMTU	       : peer's transport addresses.
-	 */
-	__u32 pmtu;
-
 	/* The message size at which SCTP fragmentation will occur. */
 	__u32 frag_point;
 

commit 049b3ff5a86d0187184a189d2e31b8654d58fe22
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Fri Nov 11 16:08:24 2005 -0800

    [SCTP]: Include ulpevents in socket receive buffer accounting.
    
    Also introduces a sysctl option to configure the receive buffer
    accounting policy to be either at socket or association level.
    Default is all the associations on the same socket share the
    receive buffer.
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 2aad4468797e..8e7794ee27ff 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -161,6 +161,13 @@ extern struct sctp_globals {
 	 */
 	int sndbuf_policy;
 
+	/*
+	 * Policy for preforming sctp/socket accounting
+	 * 0   - do socket level accounting, all assocs share sk_rcvbuf
+	 * 1   - do sctp accounting, each asoc may use sk_rcvbuf bytes
+	 */
+	int rcvbuf_policy;
+
 	/* Delayed SACK timeout  200ms default*/
 	int sack_timeout;
 
@@ -218,6 +225,7 @@ extern struct sctp_globals {
 #define sctp_cookie_preserve_enable	(sctp_globals.cookie_preserve_enable)
 #define sctp_max_retrans_association	(sctp_globals.max_retrans_association)
 #define sctp_sndbuf_policy	 	(sctp_globals.sndbuf_policy)
+#define sctp_rcvbuf_policy	 	(sctp_globals.rcvbuf_policy)
 #define sctp_max_retrans_path		(sctp_globals.max_retrans_path)
 #define sctp_max_retrans_init		(sctp_globals.max_retrans_init)
 #define sctp_sack_timeout		(sctp_globals.sack_timeout)
@@ -1224,6 +1232,9 @@ struct sctp_endpoint {
 
 	/* sendbuf acct. policy.	*/
 	__u32 sndbuf_policy;
+
+	/* rcvbuf acct. policy.	*/
+	__u32 rcvbuf_policy;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1550,6 +1561,11 @@ struct sctp_association {
 	 */
 	int sndbuf_used;
 
+	/* This is the amount of memory that this association has allocated
+	 * in the receive path at any given time.
+	 */
+	atomic_t rmem_alloc;
+
 	/* This is the wait queue head for send requests waiting on
 	 * the association sndbuf space.
 	 */

commit 1e7d3d90c95b32374057e454417b2f50440be20e
Author: Vladislav Yasevich <vladislav.yasevich@hp.com>
Date:   Fri Nov 11 16:06:16 2005 -0800

    [SCTP]: Remove timeouts[] array from sctp_endpoint.
    
    The socket level timeout values are maintained in sctp_sock and
    association level timeouts are in sctp_association. So there is
    no need for ep->timeouts.
    
    Signed-off-by: Vladislav Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 9c385b6417c7..2aad4468797e 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -1222,9 +1222,6 @@ struct sctp_endpoint {
 	int last_key;
 	int key_changed_at;
 
-	/* Default timeouts.  */
-	int timeouts[SCTP_NUM_TIMEOUT_TYPES];
-
 	/* sendbuf acct. policy.	*/
 	__u32 sndbuf_policy;
 };

commit dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Oct 7 07:46:04 2005 +0100

    [PATCH] gfp flags annotations - part 1
    
     - added typedef unsigned int __nocast gfp_t;
    
     - replaced __nocast uses for gfp flags with gfp_t - it gives exactly
       the same warnings as far as sparse is concerned, doesn't change
       generated code (from gcc point of view we replaced unsigned int with
       typedef) and documents what's going on far better.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 994009bbe3b4..9c385b6417c7 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -446,7 +446,7 @@ struct sctp_ssnmap {
 };
 
 struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out,
-				    unsigned int __nocast gfp);
+				    gfp_t gfp);
 void sctp_ssnmap_free(struct sctp_ssnmap *map);
 void sctp_ssnmap_clear(struct sctp_ssnmap *map);
 
@@ -947,7 +947,7 @@ struct sctp_transport {
 };
 
 struct sctp_transport *sctp_transport_new(const union sctp_addr *,
-					  unsigned int __nocast);
+					  gfp_t);
 void sctp_transport_set_owner(struct sctp_transport *,
 			      struct sctp_association *);
 void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
@@ -1095,10 +1095,10 @@ void sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);
 void sctp_bind_addr_free(struct sctp_bind_addr *);
 int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
-			sctp_scope_t scope, unsigned int __nocast gfp,
+			sctp_scope_t scope, gfp_t gfp,
 			int flags);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-		       unsigned int __nocast gfp);
+		       gfp_t gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);
@@ -1108,9 +1108,9 @@ union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,
 					struct sctp_sock	*opt);
 union sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,
 					 int *addrs_len,
-					 unsigned int __nocast gfp);
+					 gfp_t gfp);
 int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
-			   __u16 port, unsigned int __nocast gfp);
+			   __u16 port, gfp_t gfp);
 
 sctp_scope_t sctp_scope(const union sctp_addr *);
 int sctp_in_scope(const union sctp_addr *addr, const sctp_scope_t scope);
@@ -1239,7 +1239,7 @@ static inline struct sctp_endpoint *sctp_ep(struct sctp_ep_common *base)
 }
 
 /* These are function signatures for manipulating endpoints.  */
-struct sctp_endpoint *sctp_endpoint_new(struct sock *, unsigned int __nocast);
+struct sctp_endpoint *sctp_endpoint_new(struct sock *, gfp_t);
 void sctp_endpoint_free(struct sctp_endpoint *);
 void sctp_endpoint_put(struct sctp_endpoint *);
 void sctp_endpoint_hold(struct sctp_endpoint *);
@@ -1260,7 +1260,7 @@ int sctp_verify_init(const struct sctp_association *asoc, sctp_cid_t,
 		     struct sctp_chunk **err_chunk);
 int sctp_process_init(struct sctp_association *, sctp_cid_t cid,
 		      const union sctp_addr *peer,
-		      sctp_init_chunk_t *init, unsigned int __nocast gfp);
+		      sctp_init_chunk_t *init, gfp_t gfp);
 __u32 sctp_generate_tag(const struct sctp_endpoint *);
 __u32 sctp_generate_tsn(const struct sctp_endpoint *);
 
@@ -1723,7 +1723,7 @@ static inline struct sctp_association *sctp_assoc(struct sctp_ep_common *base)
 
 struct sctp_association *
 sctp_association_new(const struct sctp_endpoint *, const struct sock *,
-		     sctp_scope_t scope, unsigned int __nocast gfp);
+		     sctp_scope_t scope, gfp_t gfp);
 void sctp_association_free(struct sctp_association *);
 void sctp_association_put(struct sctp_association *);
 void sctp_association_hold(struct sctp_association *);
@@ -1739,7 +1739,7 @@ int sctp_assoc_lookup_laddr(struct sctp_association *asoc,
 			    const union sctp_addr *laddr);
 struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *,
 				     const union sctp_addr *address,
-				     const unsigned int __nocast gfp,
+				     const gfp_t gfp,
 				     const int peer_state);
 void sctp_assoc_del_peer(struct sctp_association *asoc,
 			 const union sctp_addr *addr);
@@ -1764,10 +1764,10 @@ void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned);
 void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
 int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *,
-				     unsigned int __nocast);
+				     gfp_t);
 int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
 					 struct sctp_cookie*,
-					 unsigned int __nocast gfp);
+					 gfp_t gfp);
 
 int sctp_cmp_addr_exact(const union sctp_addr *ss1,
 			const union sctp_addr *ss2);

commit 3182cd84f0e132558bbe106c070405ae49f1f0e3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jul 11 20:57:47 2005 -0700

    [SCTP]: __nocast annotations
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7435528a1747..994009bbe3b4 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -445,7 +445,8 @@ struct sctp_ssnmap {
 	int malloced;
 };
 
-struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out, int gfp);
+struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out,
+				    unsigned int __nocast gfp);
 void sctp_ssnmap_free(struct sctp_ssnmap *map);
 void sctp_ssnmap_clear(struct sctp_ssnmap *map);
 
@@ -945,7 +946,8 @@ struct sctp_transport {
 	} cacc;
 };
 
-struct sctp_transport *sctp_transport_new(const union sctp_addr *, int);
+struct sctp_transport *sctp_transport_new(const union sctp_addr *,
+					  unsigned int __nocast);
 void sctp_transport_set_owner(struct sctp_transport *,
 			      struct sctp_association *);
 void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
@@ -1093,9 +1095,10 @@ void sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);
 void sctp_bind_addr_free(struct sctp_bind_addr *);
 int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
 			const struct sctp_bind_addr *src,
-			sctp_scope_t scope, int gfp,int flags);
+			sctp_scope_t scope, unsigned int __nocast gfp,
+			int flags);
 int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
-		       int gfp);
+		       unsigned int __nocast gfp);
 int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
 int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
 			 struct sctp_sock *);
@@ -1104,9 +1107,10 @@ union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,
 					int			addrcnt,
 					struct sctp_sock	*opt);
 union sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,
-					 int *addrs_len, int gfp);
+					 int *addrs_len,
+					 unsigned int __nocast gfp);
 int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
-			   __u16 port, int gfp);
+			   __u16 port, unsigned int __nocast gfp);
 
 sctp_scope_t sctp_scope(const union sctp_addr *);
 int sctp_in_scope(const union sctp_addr *addr, const sctp_scope_t scope);
@@ -1235,7 +1239,7 @@ static inline struct sctp_endpoint *sctp_ep(struct sctp_ep_common *base)
 }
 
 /* These are function signatures for manipulating endpoints.  */
-struct sctp_endpoint *sctp_endpoint_new(struct sock *, int);
+struct sctp_endpoint *sctp_endpoint_new(struct sock *, unsigned int __nocast);
 void sctp_endpoint_free(struct sctp_endpoint *);
 void sctp_endpoint_put(struct sctp_endpoint *);
 void sctp_endpoint_hold(struct sctp_endpoint *);
@@ -1256,7 +1260,7 @@ int sctp_verify_init(const struct sctp_association *asoc, sctp_cid_t,
 		     struct sctp_chunk **err_chunk);
 int sctp_process_init(struct sctp_association *, sctp_cid_t cid,
 		      const union sctp_addr *peer,
-		      sctp_init_chunk_t *init, int gfp);
+		      sctp_init_chunk_t *init, unsigned int __nocast gfp);
 __u32 sctp_generate_tag(const struct sctp_endpoint *);
 __u32 sctp_generate_tsn(const struct sctp_endpoint *);
 
@@ -1719,7 +1723,7 @@ static inline struct sctp_association *sctp_assoc(struct sctp_ep_common *base)
 
 struct sctp_association *
 sctp_association_new(const struct sctp_endpoint *, const struct sock *,
-		     sctp_scope_t scope, int gfp);
+		     sctp_scope_t scope, unsigned int __nocast gfp);
 void sctp_association_free(struct sctp_association *);
 void sctp_association_put(struct sctp_association *);
 void sctp_association_hold(struct sctp_association *);
@@ -1735,7 +1739,7 @@ int sctp_assoc_lookup_laddr(struct sctp_association *asoc,
 			    const union sctp_addr *laddr);
 struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *,
 				     const union sctp_addr *address,
-				     const int gfp,
+				     const unsigned int __nocast gfp,
 				     const int peer_state);
 void sctp_assoc_del_peer(struct sctp_association *asoc,
 			 const union sctp_addr *addr);
@@ -1759,9 +1763,11 @@ void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned);
 void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned);
 void sctp_assoc_set_primary(struct sctp_association *,
 			    struct sctp_transport *);
-int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *, int);
+int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *,
+				     unsigned int __nocast);
 int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
-					 struct sctp_cookie*, int gfp);
+					 struct sctp_cookie*,
+					 unsigned int __nocast gfp);
 
 int sctp_cmp_addr_exact(const union sctp_addr *ss1,
 			const union sctp_addr *ss2);

commit 79af02c2538d54ff0dcd3f43646f506207f2ee62
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 8 21:47:49 2005 -0700

    [SCTP]: Use struct list_head for chunk lists, not sk_buff_head.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 47727c7cc628..7435528a1747 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -582,7 +582,6 @@ void sctp_datamsg_track(struct sctp_chunk *);
 void sctp_chunk_fail(struct sctp_chunk *, int error);
 int sctp_chunk_abandoned(struct sctp_chunk *);
 
-
 /* RFC2960 1.4 Key Terms
  *
  * o Chunk: A unit of information within an SCTP packet, consisting of
@@ -592,13 +591,8 @@ int sctp_chunk_abandoned(struct sctp_chunk *);
  * each chunk as well as a few other header pointers...
  */
 struct sctp_chunk {
-	/* These first three elements MUST PRECISELY match the first
-	 * three elements of struct sk_buff.  This allows us to reuse
-	 * all the skb_* queue management functions.
-	 */
-	struct sctp_chunk *next;
-	struct sctp_chunk *prev;
-	struct sk_buff_head *list;
+	struct list_head list;
+
 	atomic_t refcnt;
 
 	/* This is our link to the per-transport transmitted list.  */
@@ -717,7 +711,7 @@ struct sctp_packet {
 	__u32 vtag;
 
 	/* This contains the payload chunks.  */
-	struct sk_buff_head chunks;
+	struct list_head chunk_list;
 
 	/* This is the overhead of the sctp and ip headers. */
 	size_t overhead;
@@ -974,7 +968,7 @@ struct sctp_inq {
 	/* This is actually a queue of sctp_chunk each
 	 * containing a partially decoded packet.
 	 */
-	struct sk_buff_head in;
+	struct list_head in_chunk_list;
 	/* This is the packet which is currently off the in queue and is
 	 * being worked on through the inbound chunk processing.
 	 */
@@ -1017,7 +1011,7 @@ struct sctp_outq {
 	struct sctp_association *asoc;
 
 	/* Data pending that has never been transmitted.  */
-	struct sk_buff_head out;
+	struct list_head out_chunk_list;
 
 	unsigned out_qlen;	/* Total length of queued data chunks. */
 
@@ -1025,7 +1019,7 @@ struct sctp_outq {
 	unsigned error;
 
 	/* These are control chunks we want to send.  */
-	struct sk_buff_head control;
+	struct list_head control_chunk_list;
 
 	/* These are chunks that have been sacked but are above the
 	 * CTSN, or cumulative tsn ack point.
@@ -1672,7 +1666,7 @@ struct sctp_association {
 	 *  which already resides in sctp_outq.	 Please move this
 	 *  queue and its supporting logic down there.	--piggy]
 	 */
-	struct sk_buff_head addip_chunks;
+	struct list_head addip_chunk_list;
 
 	/* ADDIP Section 4.1 ASCONF Chunk Procedures
 	 *

commit 2f85a42964dd43fed3a339701db046bee5a8b903
Author: Vlad Yasevich <vladislav.yasevich@hp.com>
Date:   Tue Jun 28 13:24:23 2005 -0700

    [SCTP] Make init & delayed sack timeouts configurable by user.
    
    Signed-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index dfad4d3c581c..47727c7cc628 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -161,6 +161,9 @@ extern struct sctp_globals {
 	 */
 	int sndbuf_policy;
 
+	/* Delayed SACK timeout  200ms default*/
+	int sack_timeout;
+
 	/* HB.interval		    - 30 seconds  */
 	int hb_interval;
 
@@ -217,6 +220,7 @@ extern struct sctp_globals {
 #define sctp_sndbuf_policy	 	(sctp_globals.sndbuf_policy)
 #define sctp_max_retrans_path		(sctp_globals.max_retrans_path)
 #define sctp_max_retrans_init		(sctp_globals.max_retrans_init)
+#define sctp_sack_timeout		(sctp_globals.sack_timeout)
 #define sctp_hb_interval		(sctp_globals.hb_interval)
 #define sctp_max_instreams		(sctp_globals.max_instreams)
 #define sctp_max_outstreams		(sctp_globals.max_outstreams)

commit 3f7a87d2fa9b42f7aade43914f060df68cc89cc7
Author: Frank Filz <ffilzlnx@us.ibm.com>
Date:   Mon Jun 20 13:14:57 2005 -0700

    [SCTP] sctp_connectx() API support
    
    Implements sctp_connectx() as defined in the SCTP sockets API draft by
    tunneling the request through a setsockopt().
    
    Signed-off-by: Frank Filz <ffilzlnx@us.ibm.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 6c24d9cd3d66..dfad4d3c581c 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -867,10 +867,13 @@ struct sctp_transport {
 	 */
 	unsigned long last_time_ecne_reduced;
 
-	/* active      : The current active state of this destination,
-	 *	       :  i.e. DOWN, UP, etc.
+	/* The number of times INIT has been sent on this transport. */
+	int init_sent_count;
+
+	/* state       : The current state of this destination,
+	 *             : i.e. SCTP_ACTIVE, SCTP_INACTIVE, SCTP_UNKOWN.
 	 */
-	int active;
+	int state;
 
 	/* hb_allowed  : The current heartbeat state of this destination,
 	 *	       :  i.e. ALLOW-HB, NO-HEARTBEAT, etc.
@@ -1222,9 +1225,6 @@ struct sctp_endpoint {
 
 	/* sendbuf acct. policy.	*/
 	__u32 sndbuf_policy;
-
-	/* Name for debugging output... */
-	char *debug_name;
 };
 
 /* Recover the outter endpoint structure. */
@@ -1314,11 +1314,23 @@ struct sctp_association {
 		 *	       : association. Normally this information is
 		 *	       : hashed or keyed for quick lookup and access
 		 *	       : of the TCB.
+		 *	       : The list is also initialized with the list
+		 *	       : of addresses passed with the sctp_connectx()
+		 *	       : call.
 		 *
 		 * It is a list of SCTP_transport's.
 		 */
 		struct list_head transport_addr_list;
 
+		/* transport_count
+		 *
+		 * Peer        : A count of the number of peer addresses
+		 * Transport   : in the Peer Transport Address List.
+		 * Address     :
+		 * Count       :
+		 */
+		__u16 transport_count;
+
 		/* port
 		 *   The transport layer port number.
 		 */
@@ -1486,6 +1498,9 @@ struct sctp_association {
 	/* Transport to which SHUTDOWN chunk was last sent.  */
 	struct sctp_transport *shutdown_last_sent_to;
 
+	/* Transport to which INIT chunk was last sent.  */
+	struct sctp_transport *init_last_sent_to;
+
 	/* Next TSN    : The next TSN number to be assigned to a new
 	 *	       : DATA chunk.  This is sent in the INIT or INIT
 	 *	       : ACK chunk to the peer and incremented each
@@ -1549,8 +1564,11 @@ struct sctp_association {
 	/* The message size at which SCTP fragmentation will occur. */
 	__u32 frag_point;
 
-	/* Currently only one counter is used to count INIT errors. */
-	int counters[SCTP_NUMBER_COUNTERS];
+	/* Counter used to count INIT errors. */
+	int init_err_counter;
+
+	/* Count the number of INIT cycles (for doubling timeout). */
+	int init_cycle;
 
 	/* Default send parameters. */
 	__u16 default_stream;
@@ -1708,6 +1726,8 @@ void sctp_association_free(struct sctp_association *);
 void sctp_association_put(struct sctp_association *);
 void sctp_association_hold(struct sctp_association *);
 
+struct sctp_transport *sctp_assoc_choose_init_transport(
+	struct sctp_association *);
 struct sctp_transport *sctp_assoc_choose_shutdown_transport(
 	struct sctp_association *);
 void sctp_assoc_update_retran_path(struct sctp_association *);
@@ -1717,9 +1737,12 @@ int sctp_assoc_lookup_laddr(struct sctp_association *asoc,
 			    const union sctp_addr *laddr);
 struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *,
 				     const union sctp_addr *address,
-				     const int gfp);
+				     const int gfp,
+				     const int peer_state);
 void sctp_assoc_del_peer(struct sctp_association *asoc,
 			 const union sctp_addr *addr);
+void sctp_assoc_rm_peer(struct sctp_association *asoc,
+			 struct sctp_transport *peer);
 void sctp_assoc_control_transport(struct sctp_association *,
 				  struct sctp_transport *,
 				  sctp_transport_cmd_t, sctp_sn_error_t);

commit 4eb701dfc618491c9b97377df6e61de36dfc39ce
Author: Neil Horman <nhorman@redhat.com>
Date:   Thu Apr 28 12:02:04 2005 -0700

    [SCTP] Fix SCTP sendbuffer accouting.
    
    - Include chunk and skb sizes in sendbuffer accounting.
    - 2 policies are supported. 0: per socket accouting, 1: per association
      accounting
    
    DaveM: I've made the default per-socket.
    
    Signed-off-by: Neil Horman <nhorman@redhat.com>
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
index 7e64cf6bda1e..6c24d9cd3d66 100644
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@ -154,6 +154,13 @@ extern struct sctp_globals {
 	int max_retrans_path;
 	int max_retrans_init;
 
+	/*
+	 * Policy for preforming sctp/socket accounting
+	 * 0   - do socket level accounting, all assocs share sk_sndbuf
+	 * 1   - do sctp accounting, each asoc may use sk_sndbuf bytes
+	 */
+	int sndbuf_policy;
+
 	/* HB.interval		    - 30 seconds  */
 	int hb_interval;
 
@@ -207,6 +214,7 @@ extern struct sctp_globals {
 #define sctp_valid_cookie_life		(sctp_globals.valid_cookie_life)
 #define sctp_cookie_preserve_enable	(sctp_globals.cookie_preserve_enable)
 #define sctp_max_retrans_association	(sctp_globals.max_retrans_association)
+#define sctp_sndbuf_policy	 	(sctp_globals.sndbuf_policy)
 #define sctp_max_retrans_path		(sctp_globals.max_retrans_path)
 #define sctp_max_retrans_init		(sctp_globals.max_retrans_init)
 #define sctp_hb_interval		(sctp_globals.hb_interval)
@@ -1212,7 +1220,8 @@ struct sctp_endpoint {
 	/* Default timeouts.  */
 	int timeouts[SCTP_NUM_TIMEOUT_TYPES];
 
-	/* Various thresholds.	*/
+	/* sendbuf acct. policy.	*/
+	__u32 sndbuf_policy;
 
 	/* Name for debugging output... */
 	char *debug_name;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h
new file mode 100644
index 000000000000..7e64cf6bda1e
--- /dev/null
+++ b/include/net/sctp/structs.h
@@ -0,0 +1,1752 @@
+/* SCTP kernel reference Implementation
+ * (C) Copyright IBM Corp. 2001, 2004
+ * Copyright (c) 1999-2000 Cisco, Inc.
+ * Copyright (c) 1999-2001 Motorola, Inc.
+ * Copyright (c) 2001 Intel Corp.
+ *
+ * This file is part of the SCTP kernel reference Implementation
+ *
+ * The SCTP reference implementation is free software;
+ * you can redistribute it and/or modify it under the terms of
+ * the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * The SCTP reference implementation is distributed in the hope that it
+ * will be useful, but WITHOUT ANY WARRANTY; without even the implied
+ *		   ************************
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU CC; see the file COPYING.  If not, write to
+ * the Free Software Foundation, 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Please send any bug reports or fixes you make to the
+ * email addresses:
+ *    lksctp developers <lksctp-developers@lists.sourceforge.net>
+ *
+ * Or submit a bug report through the following website:
+ *    http://www.sf.net/projects/lksctp
+ *
+ * Written or modified by:
+ *    Randall Stewart	    <randall@sctp.chicago.il.us>
+ *    Ken Morneau	    <kmorneau@cisco.com>
+ *    Qiaobing Xie	    <qxie1@email.mot.com>
+ *    La Monte H.P. Yarroll <piggy@acm.org>
+ *    Karl Knutson	    <karl@athena.chicago.il.us>
+ *    Jon Grimm		    <jgrimm@us.ibm.com>
+ *    Xingang Guo	    <xingang.guo@intel.com>
+ *    Hui Huang		    <hui.huang@nokia.com>
+ *    Sridhar Samudrala	    <sri@us.ibm.com>
+ *    Daisy Chang	    <daisyc@us.ibm.com>
+ *    Dajiang Zhang	    <dajiang.zhang@nokia.com>
+ *    Ardelle Fan	    <ardelle.fan@intel.com>
+ *    Ryan Layer	    <rmlayer@us.ibm.com>
+ *    Anup Pemmaiah	    <pemmaiah@cc.usu.edu>
+ *    Kevin Gao             <kevin.gao@intel.com>
+ *
+ * Any bugs reported given to us we will try to fix... any fixes shared will
+ * be incorporated into the next SCTP release.
+ */
+
+#ifndef __sctp_structs_h__
+#define __sctp_structs_h__
+
+#include <linux/time.h>		/* We get struct timespec.    */
+#include <linux/socket.h>	/* linux/in.h needs this!!    */
+#include <linux/in.h>		/* We get struct sockaddr_in. */
+#include <linux/in6.h>		/* We get struct in6_addr     */
+#include <linux/ipv6.h>
+#include <asm/param.h>		/* We get MAXHOSTNAMELEN.     */
+#include <asm/atomic.h>		/* This gets us atomic counters.  */
+#include <linux/skbuff.h>	/* We need sk_buff_head. */
+#include <linux/workqueue.h>	/* We need tq_struct.	 */
+#include <linux/sctp.h>		/* We need sctp* header structs.  */
+
+/* A convenience structure for handling sockaddr structures.
+ * We should wean ourselves off this.
+ */
+union sctp_addr {
+	struct sockaddr_in v4;
+	struct sockaddr_in6 v6;
+	struct sockaddr sa;
+};
+
+/* Forward declarations for data structures. */
+struct sctp_globals;
+struct sctp_endpoint;
+struct sctp_association;
+struct sctp_transport;
+struct sctp_packet;
+struct sctp_chunk;
+struct sctp_inq;
+struct sctp_outq;
+struct sctp_bind_addr;
+struct sctp_ulpq;
+struct sctp_ep_common;
+struct sctp_ssnmap;
+
+
+#include <net/sctp/tsnmap.h>
+#include <net/sctp/ulpevent.h>
+#include <net/sctp/ulpqueue.h>
+
+/* Structures useful for managing bind/connect. */
+
+struct sctp_bind_bucket {
+	unsigned short	port;
+	unsigned short	fastreuse;
+	struct sctp_bind_bucket *next;
+	struct sctp_bind_bucket **pprev;
+	struct hlist_head	owner;
+};
+
+struct sctp_bind_hashbucket {
+	spinlock_t	lock;
+	struct sctp_bind_bucket	*chain;
+};
+
+/* Used for hashing all associations.  */
+struct sctp_hashbucket {
+	rwlock_t	lock;
+	struct sctp_ep_common  *chain;
+} __attribute__((__aligned__(8)));
+
+
+/* The SCTP globals structure. */
+extern struct sctp_globals {
+	/* RFC2960 Section 14. Suggested SCTP Protocol Parameter Values
+	 *
+	 * The following protocol parameters are RECOMMENDED:
+	 *
+	 * RTO.Initial		    - 3	 seconds
+	 * RTO.Min		    - 1	 second
+	 * RTO.Max		   -  60 seconds
+	 * RTO.Alpha		    - 1/8  (3 when converted to right shifts.)
+	 * RTO.Beta		    - 1/4  (2 when converted to right shifts.)
+	 */
+	__u32 rto_initial;
+	__u32 rto_min;
+	__u32 rto_max;
+
+	/* Note: rto_alpha and rto_beta are really defined as inverse
+	 * powers of two to facilitate integer operations.
+	 */
+	int rto_alpha;
+	int rto_beta;
+
+	/* Max.Burst		    - 4 */
+	int max_burst;
+
+	/* Valid.Cookie.Life	    - 60  seconds  */
+	int valid_cookie_life;
+
+	/* Whether Cookie Preservative is enabled(1) or not(0) */
+	int cookie_preserve_enable;
+
+	/* Association.Max.Retrans  - 10 attempts
+	 * Path.Max.Retrans	    - 5	 attempts (per destination address)
+	 * Max.Init.Retransmits	    - 8	 attempts
+	 */
+	int max_retrans_association;
+	int max_retrans_path;
+	int max_retrans_init;
+
+	/* HB.interval		    - 30 seconds  */
+	int hb_interval;
+
+	/* The following variables are implementation specific.	 */
+
+	/* Default initialization values to be applied to new associations. */
+	__u16 max_instreams;
+	__u16 max_outstreams;
+
+	/* This is a list of groups of functions for each address
+	 * family that we support.
+	 */
+	struct list_head address_families;
+
+	/* This is the hash of all endpoints. */
+	int ep_hashsize;
+	struct sctp_hashbucket *ep_hashtable;
+
+	/* This is the hash of all associations. */
+	int assoc_hashsize;
+	struct sctp_hashbucket *assoc_hashtable;
+
+	/* This is the sctp port control hash.	*/
+	int port_hashsize;
+	int port_rover;
+	spinlock_t port_alloc_lock;  /* Protects port_rover. */
+	struct sctp_bind_hashbucket *port_hashtable;
+
+	/* This is the global local address list.
+	 * We actively maintain this complete list of interfaces on
+	 * the system by catching routing events.
+	 *
+	 * It is a list of sctp_sockaddr_entry.
+	 */
+	struct list_head local_addr_list;
+	spinlock_t local_addr_lock;
+	
+	/* Flag to indicate if addip is enabled. */
+	int addip_enable;
+
+	/* Flag to indicate if PR-SCTP is enabled. */
+	int prsctp_enable;
+} sctp_globals;
+
+#define sctp_rto_initial		(sctp_globals.rto_initial)
+#define sctp_rto_min			(sctp_globals.rto_min)
+#define sctp_rto_max			(sctp_globals.rto_max)
+#define sctp_rto_alpha			(sctp_globals.rto_alpha)
+#define sctp_rto_beta			(sctp_globals.rto_beta)
+#define sctp_max_burst			(sctp_globals.max_burst)
+#define sctp_valid_cookie_life		(sctp_globals.valid_cookie_life)
+#define sctp_cookie_preserve_enable	(sctp_globals.cookie_preserve_enable)
+#define sctp_max_retrans_association	(sctp_globals.max_retrans_association)
+#define sctp_max_retrans_path		(sctp_globals.max_retrans_path)
+#define sctp_max_retrans_init		(sctp_globals.max_retrans_init)
+#define sctp_hb_interval		(sctp_globals.hb_interval)
+#define sctp_max_instreams		(sctp_globals.max_instreams)
+#define sctp_max_outstreams		(sctp_globals.max_outstreams)
+#define sctp_address_families		(sctp_globals.address_families)
+#define sctp_ep_hashsize		(sctp_globals.ep_hashsize)
+#define sctp_ep_hashtable		(sctp_globals.ep_hashtable)
+#define sctp_assoc_hashsize		(sctp_globals.assoc_hashsize)
+#define sctp_assoc_hashtable		(sctp_globals.assoc_hashtable)
+#define sctp_port_hashsize		(sctp_globals.port_hashsize)
+#define sctp_port_rover			(sctp_globals.port_rover)
+#define sctp_port_alloc_lock		(sctp_globals.port_alloc_lock)
+#define sctp_port_hashtable		(sctp_globals.port_hashtable)
+#define sctp_local_addr_list		(sctp_globals.local_addr_list)
+#define sctp_local_addr_lock		(sctp_globals.local_addr_lock)
+#define sctp_addip_enable		(sctp_globals.addip_enable)
+#define sctp_prsctp_enable		(sctp_globals.prsctp_enable)
+
+/* SCTP Socket type: UDP or TCP style. */
+typedef enum {
+	SCTP_SOCKET_UDP = 0,
+	SCTP_SOCKET_UDP_HIGH_BANDWIDTH,
+	SCTP_SOCKET_TCP
+} sctp_socket_type_t;
+
+/* Per socket SCTP information. */
+struct sctp_sock {
+	/* inet_sock has to be the first member of sctp_sock */
+	struct inet_sock inet;
+	/* What kind of a socket is this? */
+	sctp_socket_type_t type;
+
+	/* PF_ family specific functions.  */
+	struct sctp_pf *pf;
+
+	/* Access to HMAC transform. */
+	struct crypto_tfm *hmac;
+
+	/* What is our base endpointer? */
+	struct sctp_endpoint *ep;
+
+	struct sctp_bind_bucket *bind_hash;
+	/* Various Socket Options.  */
+	__u16 default_stream;
+	__u32 default_ppid;
+	__u16 default_flags;
+	__u32 default_context;
+	__u32 default_timetolive;
+
+	struct sctp_initmsg initmsg;
+	struct sctp_rtoinfo rtoinfo;
+	struct sctp_paddrparams paddrparam;
+	struct sctp_event_subscribe subscribe;
+	struct sctp_assocparams assocparams;
+	int user_frag;
+	__u32 autoclose;
+	__u8 nodelay;
+	__u8 disable_fragments;
+	__u8 pd_mode;
+	__u8 v4mapped;
+	__u32 adaption_ind;
+
+	/* Receive to here while partial delivery is in effect. */
+	struct sk_buff_head pd_lobby;
+};
+
+static inline struct sctp_sock *sctp_sk(const struct sock *sk)
+{
+       return (struct sctp_sock *)sk;
+}
+
+static inline struct sock *sctp_opt2sk(const struct sctp_sock *sp)
+{
+       return (struct sock *)sp;
+}
+
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+struct sctp6_sock {
+       struct sctp_sock  sctp;
+       struct ipv6_pinfo inet6;
+};
+#endif /* CONFIG_IPV6 */
+
+
+/* This is our APPLICATION-SPECIFIC state cookie.
+ * THIS IS NOT DICTATED BY THE SPECIFICATION.
+ */
+/* These are the parts of an association which we send in the cookie.
+ * Most of these are straight out of:
+ * RFC2960 12.2 Parameters necessary per association (i.e. the TCB)
+ *
+ */
+
+struct sctp_cookie {
+
+	/* My	       : Tag expected in every inbound packet and sent
+	 * Verification: in the INIT or INIT ACK chunk.
+	 * Tag	       :
+	 */
+	__u32 my_vtag;
+
+	/* Peer's      : Tag expected in every outbound packet except
+	 * Verification: in the INIT chunk.
+	 * Tag	       :
+	 */
+	__u32 peer_vtag;
+
+	/* The rest of these are not from the spec, but really need to
+	 * be in the cookie.
+	 */
+
+	/* My Tie Tag  : Assist in discovering a restarting association. */
+	__u32 my_ttag;
+
+	/* Peer's Tie Tag: Assist in discovering a restarting association. */
+	__u32 peer_ttag;
+
+	/* When does this cookie expire? */
+	struct timeval expiration;
+
+	/* Number of inbound/outbound streams which are set
+	 * and negotiated during the INIT process.
+	 */
+	__u16 sinit_num_ostreams;
+	__u16 sinit_max_instreams;
+
+	/* This is the first sequence number I used.  */
+	__u32 initial_tsn;
+
+	/* This holds the originating address of the INIT packet.  */
+	union sctp_addr peer_addr;
+
+	/* IG Section 2.35.3 
+	 * Include the source port of the INIT-ACK
+	 */
+	__u16		my_port;
+
+	__u8 prsctp_capable;
+
+	/* Padding for future use */
+	__u8 padding;  		
+
+	__u32 adaption_ind;	
+
+
+	/* This is a shim for my peer's INIT packet, followed by
+	 * a copy of the raw address list of the association.
+	 * The length of the raw address list is saved in the
+	 * raw_addr_list_len field, which will be used at the time when
+	 * the association TCB is re-constructed from the cookie.
+	 */
+	__u32 raw_addr_list_len;
+	struct sctp_init_chunk peer_init[0];
+};
+
+
+/* The format of our cookie that we send to our peer. */
+struct sctp_signed_cookie {
+	__u8 signature[SCTP_SECRET_SIZE];
+	struct sctp_cookie c;
+};
+
+/* This is another convenience type to allocate memory for address
+ * params for the maximum size and pass such structures around
+ * internally.
+ */
+union sctp_addr_param {
+	struct sctp_ipv4addr_param v4;
+	struct sctp_ipv6addr_param v6;
+};
+
+/* A convenience type to allow walking through the various
+ * parameters and avoid casting all over the place.
+ */
+union sctp_params {
+	void *v;
+	struct sctp_paramhdr *p;
+	struct sctp_cookie_preserve_param *life;
+	struct sctp_hostname_param *dns;
+	struct sctp_cookie_param *cookie;
+	struct sctp_supported_addrs_param *sat;
+	struct sctp_ipv4addr_param *v4;
+	struct sctp_ipv6addr_param *v6;
+	union sctp_addr_param *addr;
+	struct sctp_adaption_ind_param *aind;
+};
+
+/* RFC 2960.  Section 3.3.5 Heartbeat.
+ *    Heartbeat Information: variable length
+ *    The Sender-specific Heartbeat Info field should normally include
+ *    information about the sender's current time when this HEARTBEAT
+ *    chunk is sent and the destination transport address to which this
+ *    HEARTBEAT is sent (see Section 8.3).
+ */
+typedef struct sctp_sender_hb_info {
+	struct sctp_paramhdr param_hdr;
+	union sctp_addr daddr;
+	unsigned long sent_at;
+} __attribute__((packed)) sctp_sender_hb_info_t;
+
+/*
+ *  RFC 2960 1.3.2 Sequenced Delivery within Streams
+ *
+ *  The term "stream" is used in SCTP to refer to a sequence of user
+ *  messages that are to be delivered to the upper-layer protocol in
+ *  order with respect to other messages within the same stream.  This is
+ *  in contrast to its usage in TCP, where it refers to a sequence of
+ *  bytes (in this document a byte is assumed to be eight bits).
+ *  ...
+ *
+ *  This is the structure we use to track both our outbound and inbound
+ *  SSN, or Stream Sequence Numbers.
+ */
+
+struct sctp_stream {
+	__u16 *ssn;
+	unsigned int len;
+};
+
+struct sctp_ssnmap {
+	struct sctp_stream in;
+	struct sctp_stream out;
+	int malloced;
+};
+
+struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out, int gfp);
+void sctp_ssnmap_free(struct sctp_ssnmap *map);
+void sctp_ssnmap_clear(struct sctp_ssnmap *map);
+
+/* What is the current SSN number for this stream? */
+static inline __u16 sctp_ssn_peek(struct sctp_stream *stream, __u16 id)
+{
+	return stream->ssn[id];
+}
+
+/* Return the next SSN number for this stream.	*/
+static inline __u16 sctp_ssn_next(struct sctp_stream *stream, __u16 id)
+{
+	return stream->ssn[id]++;
+}
+
+/* Skip over this ssn and all below. */
+static inline void sctp_ssn_skip(struct sctp_stream *stream, __u16 id, 
+				 __u16 ssn)
+{
+	stream->ssn[id] = ssn+1;
+}
+              
+/*
+ * Pointers to address related SCTP functions.
+ * (i.e. things that depend on the address family.)
+ */
+struct sctp_af {
+	int		(*sctp_xmit)	(struct sk_buff *skb,
+					 struct sctp_transport *,
+					 int ipfragok);
+	int		(*setsockopt)	(struct sock *sk,
+					 int level,
+					 int optname,
+					 char __user *optval,
+					 int optlen);
+	int		(*getsockopt)	(struct sock *sk,
+					 int level,
+					 int optname,
+					 char __user *optval,
+					 int __user *optlen);
+	struct dst_entry *(*get_dst)	(struct sctp_association *asoc,
+					 union sctp_addr *daddr,
+					 union sctp_addr *saddr);
+	void		(*get_saddr)	(struct sctp_association *asoc,
+					 struct dst_entry *dst,
+					 union sctp_addr *daddr,
+					 union sctp_addr *saddr);
+	void		(*copy_addrlist) (struct list_head *,
+					  struct net_device *);
+	void		(*dst_saddr)	(union sctp_addr *saddr,
+					 struct dst_entry *dst,
+					 unsigned short port);
+	int		(*cmp_addr)	(const union sctp_addr *addr1,
+					 const union sctp_addr *addr2);
+	void		(*addr_copy)	(union sctp_addr *dst,
+					 union sctp_addr *src);
+	void		(*from_skb)	(union sctp_addr *,
+					 struct sk_buff *skb,
+					 int saddr);
+	void		(*from_sk)	(union sctp_addr *,
+					 struct sock *sk);
+	void		(*to_sk_saddr)	(union sctp_addr *,
+					 struct sock *sk);
+	void		(*to_sk_daddr)	(union sctp_addr *,
+					 struct sock *sk);
+	void		(*from_addr_param) (union sctp_addr *,
+					    union sctp_addr_param *,
+					    __u16 port, int iif);	
+	int		(*to_addr_param) (const union sctp_addr *,
+					  union sctp_addr_param *); 
+	int		(*addr_valid)	(union sctp_addr *,
+					 struct sctp_sock *);
+	sctp_scope_t	(*scope) (union sctp_addr *);
+	void		(*inaddr_any)	(union sctp_addr *, unsigned short);
+	int		(*is_any)	(const union sctp_addr *);
+	int		(*available)	(union sctp_addr *,
+					 struct sctp_sock *);
+	int		(*skb_iif)	(const struct sk_buff *sk);
+	int		(*is_ce)	(const struct sk_buff *sk);
+	void		(*seq_dump_addr)(struct seq_file *seq,
+					 union sctp_addr *addr);
+	__u16		net_header_len;
+	int		sockaddr_len;
+	sa_family_t	sa_family;
+	struct list_head list;
+};
+
+struct sctp_af *sctp_get_af_specific(sa_family_t);
+int sctp_register_af(struct sctp_af *);
+
+/* Protocol family functions. */
+struct sctp_pf {
+	void (*event_msgname)(struct sctp_ulpevent *, char *, int *);
+	void (*skb_msgname)  (struct sk_buff *, char *, int *);
+	int  (*af_supported) (sa_family_t, struct sctp_sock *);
+	int  (*cmp_addr) (const union sctp_addr *,
+			  const union sctp_addr *,
+			  struct sctp_sock *);
+	int  (*bind_verify) (struct sctp_sock *, union sctp_addr *);
+	int  (*send_verify) (struct sctp_sock *, union sctp_addr *);
+	int  (*supported_addrs)(const struct sctp_sock *, __u16 *);
+	struct sock *(*create_accept_sk) (struct sock *sk,
+					  struct sctp_association *asoc);
+	void (*addr_v4map) (struct sctp_sock *, union sctp_addr *);
+	struct sctp_af *af;
+};
+
+
+/* Structure to track chunk fragments that have been acked, but peer
+ * fragments of the same message have not.
+ */
+struct sctp_datamsg {
+	/* Chunks waiting to be submitted to lower layer. */
+	struct list_head chunks;
+	/* Chunks that have been transmitted. */
+	struct list_head track;
+	/* Reference counting. */
+	atomic_t refcnt;
+	/* When is this message no longer interesting to the peer? */
+	unsigned long expires_at;
+	/* Did the messenge fail to send? */
+	int send_error;
+	char send_failed;
+	/* Control whether chunks from this message can be abandoned. */
+	char can_abandon;
+};
+
+struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *,
+					    struct sctp_sndrcvinfo *,
+					    struct msghdr *, int len);
+void sctp_datamsg_put(struct sctp_datamsg *);
+void sctp_datamsg_free(struct sctp_datamsg *);
+void sctp_datamsg_track(struct sctp_chunk *);
+void sctp_chunk_fail(struct sctp_chunk *, int error);
+int sctp_chunk_abandoned(struct sctp_chunk *);
+
+
+/* RFC2960 1.4 Key Terms
+ *
+ * o Chunk: A unit of information within an SCTP packet, consisting of
+ * a chunk header and chunk-specific content.
+ *
+ * As a matter of convenience, we remember the SCTP common header for
+ * each chunk as well as a few other header pointers...
+ */
+struct sctp_chunk {
+	/* These first three elements MUST PRECISELY match the first
+	 * three elements of struct sk_buff.  This allows us to reuse
+	 * all the skb_* queue management functions.
+	 */
+	struct sctp_chunk *next;
+	struct sctp_chunk *prev;
+	struct sk_buff_head *list;
+	atomic_t refcnt;
+
+	/* This is our link to the per-transport transmitted list.  */
+	struct list_head transmitted_list;
+
+	/* This field is used by chunks that hold fragmented data.
+	 * For the first fragment this is the list that holds the rest of
+	 * fragments. For the remaining fragments, this is the link to the
+	 * frag_list maintained in the first fragment.
+	 */
+	struct list_head frag_list;
+
+	/* This points to the sk_buff containing the actual data.  */
+	struct sk_buff *skb;
+
+	/* These are the SCTP headers by reverse order in a packet.
+	 * Note that some of these may happen more than once.  In that
+	 * case, we point at the "current" one, whatever that means
+	 * for that level of header.
+	 */
+
+	/* We point this at the FIRST TLV parameter to chunk_hdr.  */
+	union sctp_params param_hdr;
+	union {
+		__u8 *v;
+		struct sctp_datahdr *data_hdr;
+		struct sctp_inithdr *init_hdr;
+		struct sctp_sackhdr *sack_hdr;
+		struct sctp_heartbeathdr *hb_hdr;
+		struct sctp_sender_hb_info *hbs_hdr;
+		struct sctp_shutdownhdr *shutdown_hdr;
+		struct sctp_signed_cookie *cookie_hdr;
+		struct sctp_ecnehdr *ecne_hdr;
+		struct sctp_cwrhdr *ecn_cwr_hdr;
+		struct sctp_errhdr *err_hdr;
+		struct sctp_addiphdr *addip_hdr;
+		struct sctp_fwdtsn_hdr *fwdtsn_hdr;
+	} subh;
+
+	__u8 *chunk_end;
+
+	struct sctp_chunkhdr *chunk_hdr;
+	struct sctphdr *sctp_hdr;
+
+	/* This needs to be recoverable for SCTP_SEND_FAILED events. */
+	struct sctp_sndrcvinfo sinfo;
+
+	/* Which association does this belong to?  */
+	struct sctp_association *asoc;
+
+	/* What endpoint received this chunk? */
+	struct sctp_ep_common *rcvr;
+
+	/* We fill this in if we are calculating RTT. */
+	unsigned long sent_at;
+
+	/* What is the origin IP address for this chunk?  */
+	union sctp_addr source;
+	/* Destination address for this chunk. */
+	union sctp_addr dest;
+
+	/* For outbound message, track all fragments for SEND_FAILED. */
+	struct sctp_datamsg *msg;
+
+	/* For an inbound chunk, this tells us where it came from.
+	 * For an outbound chunk, it tells us where we'd like it to
+	 * go.	It is NULL if we have no preference.
+	 */
+	struct sctp_transport *transport;
+
+	__u8 rtt_in_progress;	/* Is this chunk used for RTT calculation? */
+	__u8 resent;		/* Has this chunk ever been retransmitted. */
+	__u8 has_tsn;		/* Does this chunk have a TSN yet? */
+	__u8 has_ssn;		/* Does this chunk have a SSN yet? */
+	__u8 singleton;		/* Was this the only chunk in the packet? */
+	__u8 end_of_packet;	/* Was this the last chunk in the packet? */
+	__u8 ecn_ce_done;	/* Have we processed the ECN CE bit? */
+	__u8 pdiscard;		/* Discard the whole packet now? */
+	__u8 tsn_gap_acked;	/* Is this chunk acked by a GAP ACK? */
+	__u8 fast_retransmit;	 /* Is this chunk fast retransmitted? */
+	__u8 tsn_missing_report; /* Data chunk missing counter. */
+};
+
+void sctp_chunk_hold(struct sctp_chunk *);
+void sctp_chunk_put(struct sctp_chunk *);
+int sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,
+			  struct iovec *data);
+void sctp_chunk_free(struct sctp_chunk *);
+void  *sctp_addto_chunk(struct sctp_chunk *, int len, const void *data);
+struct sctp_chunk *sctp_chunkify(struct sk_buff *,
+				 const struct sctp_association *,
+				 struct sock *);
+void sctp_init_addrs(struct sctp_chunk *, union sctp_addr *,
+		     union sctp_addr *);
+const union sctp_addr *sctp_source(const struct sctp_chunk *chunk);
+
+/* This is a structure for holding either an IPv6 or an IPv4 address.  */
+/* sin_family -- AF_INET or AF_INET6
+ * sin_port -- ordinary port number
+ * sin_addr -- cast to either (struct in_addr) or (struct in6_addr)
+ */
+struct sctp_sockaddr_entry {
+	struct list_head list;
+	union sctp_addr a;
+};
+
+typedef struct sctp_chunk *(sctp_packet_phandler_t)(struct sctp_association *);
+
+/* This structure holds lists of chunks as we are assembling for
+ * transmission.
+ */
+struct sctp_packet {
+	/* These are the SCTP header values (host order) for the packet. */
+	__u16 source_port;
+	__u16 destination_port;
+	__u32 vtag;
+
+	/* This contains the payload chunks.  */
+	struct sk_buff_head chunks;
+
+	/* This is the overhead of the sctp and ip headers. */
+	size_t overhead;
+	/* This is the total size of all chunks INCLUDING padding.  */
+	size_t size;
+
+	/* The packet is destined for this transport address.
+	 * The function we finally use to pass down to the next lower
+	 * layer lives in the transport structure.
+	 */
+	struct sctp_transport *transport;
+
+	/* This packet contains a COOKIE-ECHO chunk. */
+	char has_cookie_echo;
+
+	/* This packet containsa SACK chunk. */
+	char has_sack;
+
+	/* SCTP cannot fragment this packet. So let ip fragment it. */
+	char ipfragok;
+
+	int malloced;
+};
+
+struct sctp_packet *sctp_packet_init(struct sctp_packet *,
+				     struct sctp_transport *,
+				     __u16 sport, __u16 dport);
+struct sctp_packet *sctp_packet_config(struct sctp_packet *, __u32 vtag, int);
+sctp_xmit_t sctp_packet_transmit_chunk(struct sctp_packet *,
+                                       struct sctp_chunk *);
+sctp_xmit_t sctp_packet_append_chunk(struct sctp_packet *,
+                                     struct sctp_chunk *);
+int sctp_packet_transmit(struct sctp_packet *);
+void sctp_packet_free(struct sctp_packet *);
+
+static inline int sctp_packet_empty(struct sctp_packet *packet)
+{
+	return (packet->size == packet->overhead);
+}
+
+/* This represents a remote transport address.
+ * For local transport addresses, we just use union sctp_addr.
+ *
+ * RFC2960 Section 1.4 Key Terms
+ *
+ *   o	Transport address:  A Transport Address is traditionally defined
+ *	by Network Layer address, Transport Layer protocol and Transport
+ *	Layer port number.  In the case of SCTP running over IP, a
+ *	transport address is defined by the combination of an IP address
+ *	and an SCTP port number (where SCTP is the Transport protocol).
+ *
+ * RFC2960 Section 7.1 SCTP Differences from TCP Congestion control
+ *
+ *   o	The sender keeps a separate congestion control parameter set for
+ *	each of the destination addresses it can send to (not each
+ *	source-destination pair but for each destination).  The parameters
+ *	should decay if the address is not used for a long enough time
+ *	period.
+ *
+ */
+struct sctp_transport {
+	/* A list of transports. */
+	struct list_head transports;
+
+	/* Reference counting. */
+	atomic_t refcnt;
+	int	 dead;
+
+	/* This is the peer's IP address and port. */
+	union sctp_addr ipaddr;
+
+	/* These are the functions we call to handle LLP stuff.	 */
+	struct sctp_af *af_specific;
+
+	/* Which association do we belong to?  */
+	struct sctp_association *asoc;
+
+	/* RFC2960
+	 *
+	 * 12.3 Per Transport Address Data
+	 *
+	 * For each destination transport address in the peer's
+	 * address list derived from the INIT or INIT ACK chunk, a
+	 * number of data elements needs to be maintained including:
+	 */
+	__u32 rtt;		/* This is the most recent RTT.	 */
+
+	/* RTO	       : The current retransmission timeout value.  */
+	__u32 rto;
+
+	/* RTTVAR      : The current RTT variation.  */
+	__u32 rttvar;
+
+	/* SRTT	       : The current smoothed round trip time.	*/
+	__u32 srtt;
+
+	/* RTO-Pending : A flag used to track if one of the DATA
+	 *		chunks sent to this address is currently being
+	 *		used to compute a RTT. If this flag is 0,
+	 *		the next DATA chunk sent to this destination
+	 *		should be used to compute a RTT and this flag
+	 *		should be set. Every time the RTT
+	 *		calculation completes (i.e. the DATA chunk
+	 *		is SACK'd) clear this flag.
+	 */
+	int rto_pending;
+
+	/*
+	 * These are the congestion stats.
+	 */
+	/* cwnd	       : The current congestion window.	 */
+	__u32 cwnd;		  /* This is the actual cwnd.  */
+
+	/* ssthresh    : The current slow start threshold value.  */
+	__u32 ssthresh;
+
+	/* partial     : The tracking method for increase of cwnd when in
+	 * bytes acked : congestion avoidance mode (see Section 6.2.2)
+	 */
+	__u32 partial_bytes_acked;
+
+	/* Data that has been sent, but not acknowledged. */
+	__u32 flight_size;
+
+	/* PMTU	      : The current known path MTU.  */
+	__u32 pmtu;
+
+	/* Destination */
+	struct dst_entry *dst;
+	/* Source address. */
+	union sctp_addr saddr;
+
+	/* When was the last time(in jiffies) that a data packet was sent on
+	 * this transport?  This is used to adjust the cwnd when the transport
+	 * becomes inactive.
+	 */
+	unsigned long last_time_used;
+
+	/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to
+	 * the destination address every heartbeat interval.
+	 */
+	int hb_interval;
+
+	/* When was the last time (in jiffies) that we heard from this
+	 * transport?  We use this to pick new active and retran paths.
+	 */
+	unsigned long last_time_heard;
+
+	/* Last time(in jiffies) when cwnd is reduced due to the congestion
+	 * indication based on ECNE chunk.
+	 */
+	unsigned long last_time_ecne_reduced;
+
+	/* active      : The current active state of this destination,
+	 *	       :  i.e. DOWN, UP, etc.
+	 */
+	int active;
+
+	/* hb_allowed  : The current heartbeat state of this destination,
+	 *	       :  i.e. ALLOW-HB, NO-HEARTBEAT, etc.
+	 */
+	int hb_allowed;
+
+	/* These are the error stats for this destination.  */
+
+	/* Error count : The current error count for this destination.	*/
+	unsigned short error_count;
+
+	/* This is the max_retrans value for the transport and will
+	 * be initialized to proto.max_retrans.path.  This can be changed
+	 * using SCTP_SET_PEER_ADDR_PARAMS socket option.
+	 */
+	int max_retrans;
+
+	/* Per	       : A timer used by each destination.
+	 * Destination :
+	 * Timer       :
+	 *
+	 * [Everywhere else in the text this is called T3-rtx. -ed]
+	 */
+	struct timer_list T3_rtx_timer;
+
+	/* Heartbeat timer is per destination. */
+	struct timer_list hb_timer;
+
+	/* Since we're using per-destination retransmission timers
+	 * (see above), we're also using per-destination "transmitted"
+	 * queues.  This probably ought to be a private struct
+	 * accessible only within the outqueue, but it's not, yet.
+	 */
+	struct list_head transmitted;
+
+	/* We build bundle-able packets for this transport here.  */
+	struct sctp_packet packet;
+
+	/* This is the list of transports that have chunks to send.  */
+	struct list_head send_ready;
+
+	int malloced; /* Is this structure kfree()able? */
+
+	/* State information saved for SFR_CACC algorithm. The key
+	 * idea in SFR_CACC is to maintain state at the sender on a
+	 * per-destination basis when a changeover happens.
+	 *	char changeover_active;
+	 *	char cycling_changeover;
+	 *	__u32 next_tsn_at_change;
+	 *	char cacc_saw_newack;
+	 */
+	struct {
+		/* An unsigned integer, which stores the next TSN to be
+		 * used by the sender, at the moment of changeover.
+		 */
+		__u32 next_tsn_at_change;
+
+		/* A flag which indicates the occurrence of a changeover */
+		char changeover_active;
+
+		/* A flag which indicates whether the change of primary is
+		 * the first switch to this destination address during an
+		 * active switch.
+		 */
+		char cycling_changeover;
+
+		/* A temporary flag, which is used during the processing of
+		 * a SACK to estimate the causative TSN(s)'s group.
+		 */
+		char cacc_saw_newack;
+	} cacc;
+};
+
+struct sctp_transport *sctp_transport_new(const union sctp_addr *, int);
+void sctp_transport_set_owner(struct sctp_transport *,
+			      struct sctp_association *);
+void sctp_transport_route(struct sctp_transport *, union sctp_addr *,
+			  struct sctp_sock *);
+void sctp_transport_pmtu(struct sctp_transport *);
+void sctp_transport_free(struct sctp_transport *);
+void sctp_transport_reset_timers(struct sctp_transport *);
+void sctp_transport_hold(struct sctp_transport *);
+void sctp_transport_put(struct sctp_transport *);
+void sctp_transport_update_rto(struct sctp_transport *, __u32);
+void sctp_transport_raise_cwnd(struct sctp_transport *, __u32, __u32);
+void sctp_transport_lower_cwnd(struct sctp_transport *, sctp_lower_cwnd_t);
+unsigned long sctp_transport_timeout(struct sctp_transport *);
+
+
+/* This is the structure we use to queue packets as they come into
+ * SCTP.  We write packets to it and read chunks from it.
+ */
+struct sctp_inq {
+	/* This is actually a queue of sctp_chunk each
+	 * containing a partially decoded packet.
+	 */
+	struct sk_buff_head in;
+	/* This is the packet which is currently off the in queue and is
+	 * being worked on through the inbound chunk processing.
+	 */
+	struct sctp_chunk *in_progress;
+
+	/* This is the delayed task to finish delivering inbound
+	 * messages.
+	 */
+	struct work_struct immediate;
+
+	int malloced;	     /* Is this structure kfree()able?	*/
+};
+
+void sctp_inq_init(struct sctp_inq *);
+void sctp_inq_free(struct sctp_inq *);
+void sctp_inq_push(struct sctp_inq *, struct sctp_chunk *packet);
+struct sctp_chunk *sctp_inq_pop(struct sctp_inq *);
+void sctp_inq_set_th_handler(struct sctp_inq *, void (*)(void *), void *);
+
+/* This is the structure we use to hold outbound chunks.  You push
+ * chunks in and they automatically pop out the other end as bundled
+ * packets (it calls (*output_handler)()).
+ *
+ * This structure covers sections 6.3, 6.4, 6.7, 6.8, 6.10, 7., 8.1,
+ * and 8.2 of the v13 draft.
+ *
+ * It handles retransmissions.	The connection to the timeout portion
+ * of the state machine is through sctp_..._timeout() and timeout_handler.
+ *
+ * If you feed it SACKs, it will eat them.
+ *
+ * If you give it big chunks, it will fragment them.
+ *
+ * It assigns TSN's to data chunks.  This happens at the last possible
+ * instant before transmission.
+ *
+ * When free()'d, it empties itself out via output_handler().
+ */
+struct sctp_outq {
+	struct sctp_association *asoc;
+
+	/* Data pending that has never been transmitted.  */
+	struct sk_buff_head out;
+
+	unsigned out_qlen;	/* Total length of queued data chunks. */
+
+	/* Error of send failed, may used in SCTP_SEND_FAILED event. */
+	unsigned error;
+
+	/* These are control chunks we want to send.  */
+	struct sk_buff_head control;
+
+	/* These are chunks that have been sacked but are above the
+	 * CTSN, or cumulative tsn ack point.
+	 */
+	struct list_head sacked;
+
+	/* Put chunks on this list to schedule them for
+	 * retransmission.
+	 */
+	struct list_head retransmit;
+
+	/* Put chunks on this list to save them for FWD TSN processing as
+	 * they were abandoned.
+	 */
+	struct list_head abandoned;
+
+	/* How many unackd bytes do we have in-flight?	*/
+	__u32 outstanding_bytes;
+
+	/* Corked? */
+	char cork;
+
+	/* Is this structure empty?  */
+	char empty;
+
+	/* Are we kfree()able? */
+	char malloced;
+};
+
+void sctp_outq_init(struct sctp_association *, struct sctp_outq *);
+void sctp_outq_teardown(struct sctp_outq *);
+void sctp_outq_free(struct sctp_outq*);
+int sctp_outq_tail(struct sctp_outq *, struct sctp_chunk *chunk);
+int sctp_outq_flush(struct sctp_outq *, int);
+int sctp_outq_sack(struct sctp_outq *, struct sctp_sackhdr *);
+int sctp_outq_is_empty(const struct sctp_outq *);
+void sctp_outq_restart(struct sctp_outq *);
+
+void sctp_retransmit(struct sctp_outq *, struct sctp_transport *,
+		     sctp_retransmit_reason_t);
+void sctp_retransmit_mark(struct sctp_outq *, struct sctp_transport *, __u8);
+int sctp_outq_uncork(struct sctp_outq *);
+/* Uncork and flush an outqueue.  */
+static inline void sctp_outq_cork(struct sctp_outq *q)
+{
+	q->cork = 1;
+}
+
+/* These bind address data fields common between endpoints and associations */
+struct sctp_bind_addr {
+
+	/* RFC 2960 12.1 Parameters necessary for the SCTP instance
+	 *
+	 * SCTP Port:	The local SCTP port number the endpoint is
+	 *		bound to.
+	 */
+	__u16 port;
+
+	/* RFC 2960 12.1 Parameters necessary for the SCTP instance
+	 *
+	 * Address List: The list of IP addresses that this instance
+	 *	has bound.  This information is passed to one's
+	 *	peer(s) in INIT and INIT ACK chunks.
+	 */
+	struct list_head address_list;
+
+	int malloced;	     /* Are we kfree()able?  */
+};
+
+void sctp_bind_addr_init(struct sctp_bind_addr *, __u16 port);
+void sctp_bind_addr_free(struct sctp_bind_addr *);
+int sctp_bind_addr_copy(struct sctp_bind_addr *dest,
+			const struct sctp_bind_addr *src,
+			sctp_scope_t scope, int gfp,int flags);
+int sctp_add_bind_addr(struct sctp_bind_addr *, union sctp_addr *,
+		       int gfp);
+int sctp_del_bind_addr(struct sctp_bind_addr *, union sctp_addr *);
+int sctp_bind_addr_match(struct sctp_bind_addr *, const union sctp_addr *,
+			 struct sctp_sock *);
+union sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr	*bp,
+					const union sctp_addr	*addrs,
+					int			addrcnt,
+					struct sctp_sock	*opt);
+union sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,
+					 int *addrs_len, int gfp);
+int sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw, int len,
+			   __u16 port, int gfp);
+
+sctp_scope_t sctp_scope(const union sctp_addr *);
+int sctp_in_scope(const union sctp_addr *addr, const sctp_scope_t scope);
+int sctp_is_any(const union sctp_addr *addr);
+int sctp_addr_is_valid(const union sctp_addr *addr);
+
+
+/* What type of endpoint?  */
+typedef enum {
+	SCTP_EP_TYPE_SOCKET,
+	SCTP_EP_TYPE_ASSOCIATION,
+} sctp_endpoint_type_t;
+
+/*
+ * A common base class to bridge the implmentation view of a
+ * socket (usually listening) endpoint versus an association's
+ * local endpoint.
+ * This common structure is useful for several purposes:
+ *   1) Common interface for lookup routines.
+ *	a) Subfunctions work for either endpoint or association
+ *	b) Single interface to lookup allows hiding the lookup lock rather
+ *	   than acquiring it externally.
+ *   2) Common interface for the inbound chunk handling/state machine.
+ *   3) Common object handling routines for reference counting, etc.
+ *   4) Disentangle association lookup from endpoint lookup, where we
+ *	do not have to find our endpoint to find our association.
+ *
+ */
+
+struct sctp_ep_common {
+	/* Fields to help us manage our entries in the hash tables. */
+	struct sctp_ep_common *next;
+	struct sctp_ep_common **pprev;
+	int hashent;
+
+	/* Runtime type information.  What kind of endpoint is this? */
+	sctp_endpoint_type_t type;
+
+	/* Some fields to help us manage this object.
+	 *   refcnt   - Reference count access to this object.
+	 *   dead     - Do not attempt to use this object.
+	 *   malloced - Do we need to kfree this object?
+	 */
+	atomic_t    refcnt;
+	char	    dead;
+	char	    malloced;
+
+	/* What socket does this endpoint belong to?  */
+	struct sock *sk;
+
+	/* This is where we receive inbound chunks.  */
+	struct sctp_inq	  inqueue;
+
+	/* This substructure includes the defining parameters of the
+	 * endpoint:
+	 * bind_addr.port is our shared port number.
+	 * bind_addr.address_list is our set of local IP addresses.
+	 */
+	struct sctp_bind_addr bind_addr;
+
+	/* Protection during address list comparisons. */
+	rwlock_t   addr_lock;
+};
+
+
+/* RFC Section 1.4 Key Terms
+ *
+ * o SCTP endpoint: The logical sender/receiver of SCTP packets. On a
+ *   multi-homed host, an SCTP endpoint is represented to its peers as a
+ *   combination of a set of eligible destination transport addresses to
+ *   which SCTP packets can be sent and a set of eligible source
+ *   transport addresses from which SCTP packets can be received.
+ *   All transport addresses used by an SCTP endpoint must use the
+ *   same port number, but can use multiple IP addresses. A transport
+ *   address used by an SCTP endpoint must not be used by another
+ *   SCTP endpoint. In other words, a transport address is unique
+ *   to an SCTP endpoint.
+ *
+ * From an implementation perspective, each socket has one of these.
+ * A TCP-style socket will have exactly one association on one of
+ * these.  An UDP-style socket will have multiple associations hanging
+ * off one of these.
+ */
+
+struct sctp_endpoint {
+	/* Common substructure for endpoint and association. */
+	struct sctp_ep_common base;
+
+	/* Associations: A list of current associations and mappings
+	 *	      to the data consumers for each association. This
+	 *	      may be in the form of a hash table or other
+	 *	      implementation dependent structure. The data
+	 *	      consumers may be process identification
+	 *	      information such as file descriptors, named pipe
+	 *	      pointer, or table pointers dependent on how SCTP
+	 *	      is implemented.
+	 */
+	/* This is really a list of struct sctp_association entries. */
+	struct list_head asocs;
+
+	/* Secret Key: A secret key used by this endpoint to compute
+	 *	      the MAC.	This SHOULD be a cryptographic quality
+	 *	      random number with a sufficient length.
+	 *	      Discussion in [RFC1750] can be helpful in
+	 *	      selection of the key.
+	 */
+	__u8 secret_key[SCTP_HOW_MANY_SECRETS][SCTP_SECRET_SIZE];
+	int current_key;
+	int last_key;
+	int key_changed_at;
+
+	/* Default timeouts.  */
+	int timeouts[SCTP_NUM_TIMEOUT_TYPES];
+
+	/* Various thresholds.	*/
+
+	/* Name for debugging output... */
+	char *debug_name;
+};
+
+/* Recover the outter endpoint structure. */
+static inline struct sctp_endpoint *sctp_ep(struct sctp_ep_common *base)
+{
+	struct sctp_endpoint *ep;
+
+	ep = container_of(base, struct sctp_endpoint, base);
+	return ep;
+}
+
+/* These are function signatures for manipulating endpoints.  */
+struct sctp_endpoint *sctp_endpoint_new(struct sock *, int);
+void sctp_endpoint_free(struct sctp_endpoint *);
+void sctp_endpoint_put(struct sctp_endpoint *);
+void sctp_endpoint_hold(struct sctp_endpoint *);
+void sctp_endpoint_add_asoc(struct sctp_endpoint *, struct sctp_association *);
+struct sctp_association *sctp_endpoint_lookup_assoc(
+	const struct sctp_endpoint *ep,
+	const union sctp_addr *paddr,
+	struct sctp_transport **);
+int sctp_endpoint_is_peeled_off(struct sctp_endpoint *,
+				const union sctp_addr *);
+struct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *,
+					const union sctp_addr *);
+int sctp_has_association(const union sctp_addr *laddr,
+			 const union sctp_addr *paddr);
+
+int sctp_verify_init(const struct sctp_association *asoc, sctp_cid_t,
+		     sctp_init_chunk_t *peer_init, struct sctp_chunk *chunk,
+		     struct sctp_chunk **err_chunk);
+int sctp_process_init(struct sctp_association *, sctp_cid_t cid,
+		      const union sctp_addr *peer,
+		      sctp_init_chunk_t *init, int gfp);
+__u32 sctp_generate_tag(const struct sctp_endpoint *);
+__u32 sctp_generate_tsn(const struct sctp_endpoint *);
+
+
+/* RFC2960
+ *
+ * 12. Recommended Transmission Control Block (TCB) Parameters
+ *
+ * This section details a recommended set of parameters that should
+ * be contained within the TCB for an implementation. This section is
+ * for illustrative purposes and should not be deemed as requirements
+ * on an implementation or as an exhaustive list of all parameters
+ * inside an SCTP TCB. Each implementation may need its own additional
+ * parameters for optimization.
+ */
+
+
+/* Here we have information about each individual association. */
+struct sctp_association {
+
+	/* A base structure common to endpoint and association.
+	 * In this context, it represents the associations's view
+	 * of the local endpoint of the association.
+	 */
+	struct sctp_ep_common base;
+
+	/* Associations on the same socket. */
+	struct list_head asocs;
+
+	/* association id. */
+	sctp_assoc_t assoc_id;
+
+	/* This is our parent endpoint.	 */
+	struct sctp_endpoint *ep;
+
+	/* These are those association elements needed in the cookie.  */
+	struct sctp_cookie c;
+
+	/* This is all information about our peer.  */
+	struct {
+		/* rwnd
+		 *
+		 * Peer Rwnd   : Current calculated value of the peer's rwnd.
+		 */
+		__u32 rwnd;
+
+		/* transport_addr_list
+		 *
+		 * Peer	       : A list of SCTP transport addresses that the
+		 * Transport   : peer is bound to. This information is derived
+		 * Address     : from the INIT or INIT ACK and is used to
+		 * List	       : associate an inbound packet with a given
+		 *	       : association. Normally this information is
+		 *	       : hashed or keyed for quick lookup and access
+		 *	       : of the TCB.
+		 *
+		 * It is a list of SCTP_transport's.
+		 */
+		struct list_head transport_addr_list;
+
+		/* port
+		 *   The transport layer port number.
+		 */
+		__u16 port;
+
+		/* primary_path
+		 *
+		 * Primary     : This is the current primary destination
+		 * Path	       : transport address of the peer endpoint.  It
+		 *	       : may also specify a source transport address
+		 *	       : on this endpoint.
+		 *
+		 * All of these paths live on transport_addr_list.
+		 *
+		 * At the bakeoffs, we discovered that the intent of
+		 * primaryPath is that it only changes when the ULP
+		 * asks to have it changed.  We add the activePath to
+		 * designate the connection we are currently using to
+		 * transmit new data and most control chunks.
+		 */
+		struct sctp_transport *primary_path;
+
+		/* Cache the primary path address here, when we
+		 * need a an address for msg_name.
+		 */
+		union sctp_addr primary_addr;
+
+		/* active_path
+		 *   The path that we are currently using to
+		 *   transmit new data and most control chunks.
+		 */
+		struct sctp_transport *active_path;
+
+		/* retran_path
+		 *
+		 * RFC2960 6.4 Multi-homed SCTP Endpoints
+		 * ...
+		 * Furthermore, when its peer is multi-homed, an
+		 * endpoint SHOULD try to retransmit a chunk to an
+		 * active destination transport address that is
+		 * different from the last destination address to
+		 * which the DATA chunk was sent.
+		 */
+		struct sctp_transport *retran_path;
+
+		/* Pointer to last transport I have sent on.  */
+		struct sctp_transport *last_sent_to;
+
+		/* This is the last transport I have received DATA on.	*/
+		struct sctp_transport *last_data_from;
+
+		/*
+		 * Mapping  An array of bits or bytes indicating which out of
+		 * Array    order TSN's have been received (relative to the
+		 *	    Last Rcvd TSN). If no gaps exist, i.e. no out of
+		 *	    order packets have been received, this array
+		 *	    will be set to all zero. This structure may be
+		 *	    in the form of a circular buffer or bit array.
+		 *
+		 * Last Rcvd   : This is the last TSN received in
+		 * TSN	       : sequence. This value is set initially by
+		 *	       : taking the peer's Initial TSN, received in
+		 *	       : the INIT or INIT ACK chunk, and subtracting
+		 *	       : one from it.
+		 *
+		 * Throughout most of the specification this is called the
+		 * "Cumulative TSN ACK Point".	In this case, we
+		 * ignore the advice in 12.2 in favour of the term
+		 * used in the bulk of the text.  This value is hidden
+		 * in tsn_map--we get it by calling sctp_tsnmap_get_ctsn().
+		 */
+		struct sctp_tsnmap tsn_map;
+		__u8 _map[sctp_tsnmap_storage_size(SCTP_TSN_MAP_SIZE)];
+
+		/* Ack State   : This flag indicates if the next received
+		 *             : packet is to be responded to with a
+		 *             : SACK. This is initializedto 0.  When a packet
+		 *             : is received it is incremented. If this value
+		 *             : reaches 2 or more, a SACK is sent and the
+		 *             : value is reset to 0. Note: This is used only
+		 *             : when no DATA chunks are received out of
+		 *             : order.  When DATA chunks are out of order,
+		 *             : SACK's are not delayed (see Section 6).
+		 */
+		__u8    sack_needed;     /* Do we need to sack the peer? */
+
+		/* These are capabilities which our peer advertised.  */
+		__u8	ecn_capable;	 /* Can peer do ECN? */
+		__u8	ipv4_address;	 /* Peer understands IPv4 addresses? */
+		__u8	ipv6_address;	 /* Peer understands IPv6 addresses? */
+		__u8	hostname_address;/* Peer understands DNS addresses? */
+		__u8    asconf_capable;  /* Does peer support ADDIP? */
+		__u8    prsctp_capable;  /* Can peer do PR-SCTP? */
+
+		__u32   adaption_ind;	 /* Adaption Code point. */
+
+		/* This mask is used to disable sending the ASCONF chunk
+		 * with specified parameter to peer.
+		 */
+		__u16 addip_disabled_mask;
+
+		struct sctp_inithdr i;
+		int cookie_len;
+		void *cookie;
+
+		/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.
+		 * C1) ... "Peer-Serial-Number'. This value MUST be initialized to the
+		 * Initial TSN Value minus 1
+		 */
+		__u32 addip_serial;
+	} peer;
+
+	/* State       : A state variable indicating what state the
+	 *	       : association is in, i.e. COOKIE-WAIT,
+	 *	       : COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING,
+	 *	       : SHUTDOWN-SENT, SHUTDOWN-RECEIVED, SHUTDOWN-ACK-SENT.
+	 *
+	 *		Note: No "CLOSED" state is illustrated since if a
+	 *		association is "CLOSED" its TCB SHOULD be removed.
+	 *
+	 *		In this implementation we DO have a CLOSED
+	 *		state which is used during initiation and shutdown.
+	 *
+	 *		State takes values from SCTP_STATE_*.
+	 */
+	sctp_state_t state;
+
+	/* The cookie life I award for any cookie.  */
+	struct timeval cookie_life;
+
+	/* Overall     : The overall association error count.
+	 * Error Count : [Clear this any time I get something.]
+	 */
+	int overall_error_count;
+
+	/* These are the association's initial, max, and min RTO values.
+	 * These values will be initialized by system defaults, but can
+	 * be modified via the SCTP_RTOINFO socket option.
+	 */
+	__u32 rto_initial;
+	__u32 rto_max;
+	__u32 rto_min;
+
+	/* Maximum number of new data packets that can be sent in a burst.  */
+	int max_burst;
+
+	/* This is the max_retrans value for the association.  This value will
+	 * be initialized initialized from system defaults, but can be
+	 * modified by the SCTP_ASSOCINFO socket option.
+	 */
+	int max_retrans;
+
+	/* Maximum number of times the endpoint will retransmit INIT  */
+	__u16 max_init_attempts;
+
+	/* How many times have we resent an INIT? */
+	__u16 init_retries;
+
+	/* The largest timeout or RTO value to use in attempting an INIT */
+	__u16 max_init_timeo;
+
+	int timeouts[SCTP_NUM_TIMEOUT_TYPES];
+	struct timer_list timers[SCTP_NUM_TIMEOUT_TYPES];
+
+	/* Transport to which SHUTDOWN chunk was last sent.  */
+	struct sctp_transport *shutdown_last_sent_to;
+
+	/* Next TSN    : The next TSN number to be assigned to a new
+	 *	       : DATA chunk.  This is sent in the INIT or INIT
+	 *	       : ACK chunk to the peer and incremented each
+	 *	       : time a DATA chunk is assigned a TSN
+	 *	       : (normally just prior to transmit or during
+	 *	       : fragmentation).
+	 */
+	__u32 next_tsn;
+
+	/*
+	 * Last Rcvd   : This is the last TSN received in sequence.  This value
+	 * TSN	       : is set initially by taking the peer's Initial TSN,
+	 *	       : received in the INIT or INIT ACK chunk, and
+	 *	       : subtracting one from it.
+	 *
+	 * Most of RFC 2960 refers to this as the Cumulative TSN Ack Point.
+	 */
+
+	__u32 ctsn_ack_point;
+
+	/* PR-SCTP Advanced.Peer.Ack.Point */
+	__u32 adv_peer_ack_point;
+
+	/* Highest TSN that is acknowledged by incoming SACKs. */
+	__u32 highest_sacked;
+
+	/* The number of unacknowledged data chunks.  Reported through
+	 * the SCTP_STATUS sockopt.
+	 */
+	__u16 unack_data;
+
+	/* This is the association's receive buffer space.  This value is used
+	 * to set a_rwnd field in an INIT or a SACK chunk.
+	 */
+	__u32 rwnd;
+
+	/* This is the last advertised value of rwnd over a SACK chunk. */
+	__u32 a_rwnd;
+
+	/* Number of bytes by which the rwnd has slopped.  The rwnd is allowed
+	 * to slop over a maximum of the association's frag_point.
+	 */
+	__u32 rwnd_over;
+
+	/* This is the sndbuf size in use for the association.
+	 * This corresponds to the sndbuf size for the association,
+	 * as specified in the sk->sndbuf.
+	 */
+	int sndbuf_used;
+
+	/* This is the wait queue head for send requests waiting on
+	 * the association sndbuf space.
+	 */
+	wait_queue_head_t	wait;
+
+	/* Association : The smallest PMTU discovered for all of the
+	 * PMTU	       : peer's transport addresses.
+	 */
+	__u32 pmtu;
+
+	/* The message size at which SCTP fragmentation will occur. */
+	__u32 frag_point;
+
+	/* Currently only one counter is used to count INIT errors. */
+	int counters[SCTP_NUMBER_COUNTERS];
+
+	/* Default send parameters. */
+	__u16 default_stream;
+	__u16 default_flags;
+	__u32 default_ppid;
+	__u32 default_context;
+	__u32 default_timetolive;
+
+	/* This tracks outbound ssn for a given stream.	 */
+	struct sctp_ssnmap *ssnmap;
+
+	/* All outbound chunks go through this structure.  */
+	struct sctp_outq outqueue;
+
+	/* A smart pipe that will handle reordering and fragmentation,
+	 * as well as handle passing events up to the ULP.
+	 */
+	struct sctp_ulpq ulpq;
+
+	/* Last TSN that caused an ECNE Chunk to be sent.  */
+	__u32 last_ecne_tsn;
+
+	/* Last TSN that caused a CWR Chunk to be sent.	 */
+	__u32 last_cwr_tsn;
+
+	/* How many duplicated TSNs have we seen?  */
+	int numduptsns;
+
+	/* Number of seconds of idle time before an association is closed.  */
+	__u32 autoclose;
+
+	/* These are to support
+	 * "SCTP Extensions for Dynamic Reconfiguration of IP Addresses
+	 *  and Enforcement of Flow and Message Limits"
+	 * <draft-ietf-tsvwg-addip-sctp-02.txt>
+	 * or "ADDIP" for short.
+	 */
+
+
+
+	/* ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks
+	 *
+	 * R1) One and only one ASCONF Chunk MAY be in transit and
+	 * unacknowledged at any one time.  If a sender, after sending
+	 * an ASCONF chunk, decides it needs to transfer another
+	 * ASCONF Chunk, it MUST wait until the ASCONF-ACK Chunk
+	 * returns from the previous ASCONF Chunk before sending a
+	 * subsequent ASCONF. Note this restriction binds each side,
+	 * so at any time two ASCONF may be in-transit on any given
+	 * association (one sent from each endpoint).
+	 *
+	 * [This is our one-and-only-one ASCONF in flight.  If we do
+	 * not have an ASCONF in flight, this is NULL.]
+	 */
+	struct sctp_chunk *addip_last_asconf;
+
+	/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.
+	 *
+	 * IMPLEMENTATION NOTE: As an optimization a receiver may wish
+	 * to save the last ASCONF-ACK for some predetermined period
+	 * of time and instead of re-processing the ASCONF (with the
+	 * same serial number) it may just re-transmit the
+	 * ASCONF-ACK. It may wish to use the arrival of a new serial
+	 * number to discard the previously saved ASCONF-ACK or any
+	 * other means it may choose to expire the saved ASCONF-ACK.
+	 *
+	 * [This is our saved ASCONF-ACK.  We invalidate it when a new
+	 * ASCONF serial number arrives.]
+	 */
+	struct sctp_chunk *addip_last_asconf_ack;
+
+	/* These ASCONF chunks are waiting to be sent.
+	 *
+	 * These chunaks can't be pushed to outqueue until receiving
+	 * ASCONF_ACK for the previous ASCONF indicated by
+	 * addip_last_asconf, so as to guarantee that only one ASCONF
+	 * is in flight at any time.
+	 *
+	 * ADDIP Section 4.1.1 Congestion Control of ASCONF Chunks
+	 *
+	 * In defining the ASCONF Chunk transfer procedures, it is
+	 * essential that these transfers MUST NOT cause congestion
+	 * within the network.	To achieve this, we place these
+	 * restrictions on the transfer of ASCONF Chunks:
+	 *
+	 * R1) One and only one ASCONF Chunk MAY be in transit and
+	 * unacknowledged at any one time.  If a sender, after sending
+	 * an ASCONF chunk, decides it needs to transfer another
+	 * ASCONF Chunk, it MUST wait until the ASCONF-ACK Chunk
+	 * returns from the previous ASCONF Chunk before sending a
+	 * subsequent ASCONF. Note this restriction binds each side,
+	 * so at any time two ASCONF may be in-transit on any given
+	 * association (one sent from each endpoint).
+	 *
+	 *
+	 * [I really think this is EXACTLY the sort of intelligence
+	 *  which already resides in sctp_outq.	 Please move this
+	 *  queue and its supporting logic down there.	--piggy]
+	 */
+	struct sk_buff_head addip_chunks;
+
+	/* ADDIP Section 4.1 ASCONF Chunk Procedures
+	 *
+	 * A2) A serial number should be assigned to the Chunk. The
+	 * serial number SHOULD be a monotonically increasing
+	 * number. The serial number SHOULD be initialized at
+	 * the start of the association to the same value as the
+	 * Initial TSN and every time a new ASCONF chunk is created
+	 * it is incremented by one after assigning the serial number
+	 * to the newly created chunk.
+	 *
+	 * ADDIP
+	 * 3.1.1  Address/Stream Configuration Change Chunk (ASCONF)
+	 *
+	 * Serial Number : 32 bits (unsigned integer)
+	 *
+	 * This value represents a Serial Number for the ASCONF
+	 * Chunk. The valid range of Serial Number is from 0 to
+	 * 4294967295 (2^32 - 1).  Serial Numbers wrap back to 0
+	 * after reaching 4294967295.
+	 */
+	__u32 addip_serial;
+
+	/* Need to send an ECNE Chunk? */
+	char need_ecne;
+
+	/* Is it a temporary association? */
+	char temp;
+};
+
+
+/* An eyecatcher for determining if we are really looking at an
+ * association data structure.
+ */
+enum {
+	SCTP_ASSOC_EYECATCHER = 0xa550c123,
+};
+
+/* Recover the outter association structure. */
+static inline struct sctp_association *sctp_assoc(struct sctp_ep_common *base)
+{
+	struct sctp_association *asoc;
+
+	asoc = container_of(base, struct sctp_association, base);
+	return asoc;
+}
+
+/* These are function signatures for manipulating associations.	 */
+
+
+struct sctp_association *
+sctp_association_new(const struct sctp_endpoint *, const struct sock *,
+		     sctp_scope_t scope, int gfp);
+void sctp_association_free(struct sctp_association *);
+void sctp_association_put(struct sctp_association *);
+void sctp_association_hold(struct sctp_association *);
+
+struct sctp_transport *sctp_assoc_choose_shutdown_transport(
+	struct sctp_association *);
+void sctp_assoc_update_retran_path(struct sctp_association *);
+struct sctp_transport *sctp_assoc_lookup_paddr(const struct sctp_association *,
+					  const union sctp_addr *);
+int sctp_assoc_lookup_laddr(struct sctp_association *asoc,
+			    const union sctp_addr *laddr);
+struct sctp_transport *sctp_assoc_add_peer(struct sctp_association *,
+				     const union sctp_addr *address,
+				     const int gfp);
+void sctp_assoc_del_peer(struct sctp_association *asoc,
+			 const union sctp_addr *addr);
+void sctp_assoc_control_transport(struct sctp_association *,
+				  struct sctp_transport *,
+				  sctp_transport_cmd_t, sctp_sn_error_t);
+struct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *, __u32);
+struct sctp_transport *sctp_assoc_is_match(struct sctp_association *,
+					   const union sctp_addr *,
+					   const union sctp_addr *);
+void sctp_assoc_migrate(struct sctp_association *, struct sock *);
+void sctp_assoc_update(struct sctp_association *old,
+		       struct sctp_association *new);
+
+__u32 sctp_association_get_next_tsn(struct sctp_association *);
+
+void sctp_assoc_sync_pmtu(struct sctp_association *);
+void sctp_assoc_rwnd_increase(struct sctp_association *, unsigned);
+void sctp_assoc_rwnd_decrease(struct sctp_association *, unsigned);
+void sctp_assoc_set_primary(struct sctp_association *,
+			    struct sctp_transport *);
+int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *, int);
+int sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *,
+					 struct sctp_cookie*, int gfp);
+
+int sctp_cmp_addr_exact(const union sctp_addr *ss1,
+			const union sctp_addr *ss2);
+struct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc);
+
+/* A convenience structure to parse out SCTP specific CMSGs. */
+typedef struct sctp_cmsgs {
+	struct sctp_initmsg *init;
+	struct sctp_sndrcvinfo *info;
+} sctp_cmsgs_t;
+
+/* Structure for tracking memory objects */
+typedef struct {
+	char *label;
+	atomic_t *counter;
+} sctp_dbg_objcnt_entry_t;
+
+#endif /* __sctp_structs_h__ */
