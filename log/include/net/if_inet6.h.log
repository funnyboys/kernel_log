commit 0fa39d6dd0478b080a420aa764280e1a3bdb0cee
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 14:02:16 2020 -0500

    ipv6: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 212eb278bda6..8bf5906073bc 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -78,7 +78,7 @@ struct inet6_ifaddr {
 struct ip6_sf_socklist {
 	unsigned int		sl_max;
 	unsigned int		sl_count;
-	struct in6_addr		sl_addr[0];
+	struct in6_addr		sl_addr[];
 };
 
 #define IP6_SFLSIZE(count)	(sizeof(struct ip6_sf_socklist) + \

commit 969c54646af0d7d94a5f0f37adbbfe024e85466e
Author: Fernando Gont <fgont@si6networks.com>
Date:   Fri May 1 00:51:47 2020 -0300

    ipv6: Implement draft-ietf-6man-rfc4941bis
    
    Implement the upcoming rev of RFC4941 (IPv6 temporary addresses):
    https://tools.ietf.org/html/draft-ietf-6man-rfc4941bis-09
    
    * Reduces the default Valid Lifetime to 2 days
      The number of extra addresses employed when Valid Lifetime was
      7 days exacerbated the stress caused on network
      elements/devices. Additionally, the motivation for temporary
      addresses is indeed privacy and reduced exposure. With a
      default Valid Lifetime of 7 days, an address that becomes
      revealed by active communication is reachable and exposed for
      one whole week. The only use case for a Valid Lifetime of 7
      days could be some application that is expecting to have long
      lived connections. But if you want to have a long lived
      connections, you shouldn't be using a temporary address in the
      first place. Additionally, in the era of mobile devices, general
      applications should nevertheless be prepared and robust to
      address changes (e.g. nodes swap wifi <-> 4G, etc.)
    
    * Employs different IIDs for different prefixes
      To avoid network activity correlation among addresses configured
      for different prefixes
    
    * Uses a simpler algorithm for IID generation
      No need to store "history" anywhere
    
    Signed-off-by: Fernando Gont <fgont@si6networks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index a01981d7108f..212eb278bda6 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -190,7 +190,6 @@ struct inet6_dev {
 	int			dead;
 
 	u32			desync_factor;
-	u8			rndid[8];
 	struct list_head	tempaddr_list;
 
 	struct in6_addr		token;

commit 14105c191e09b698782026827dbac966cbd30446
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Aug 27 00:08:12 2019 -0700

    ipv6: shrink struct ipv6_mc_socklist
    
    Remove two holes on 64bit arches, to bring the size
    to one cache line exactly.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 50037913c9b1..a01981d7108f 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -89,9 +89,9 @@ struct ip6_sf_socklist {
 struct ipv6_mc_socklist {
 	struct in6_addr		addr;
 	int			ifindex;
+	unsigned int		sfmode;		/* MCAST_{INCLUDE,EXCLUDE} */
 	struct ipv6_mc_socklist __rcu *next;
 	rwlock_t		sflock;
-	unsigned int		sfmode;		/* MCAST_{INCLUDE,EXCLUDE} */
 	struct ip6_sf_socklist	*sflist;
 	struct rcu_head		rcu;
 };

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index c9c78c15bce0..50037913c9b1 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -1,15 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *	inet6 interface/address list definitions
  *	Linux INET6 implementation 
  *
  *	Authors:
  *	Pedro Roque		<roque@di.fc.ul.pt>	
- *
- *
- *	This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
  */
 
 #ifndef _NET_IF_INET6_H

commit 2384d02520ff2a916169b2fd85ea50e923ed56c2
Author: Jeff Barnhill <0xeffeff@gmail.com>
Date:   Fri Nov 2 20:23:57 2018 +0000

    net/ipv6: Add anycast addresses to a global hashtable
    
    icmp6_send() function is expensive on systems with a large number of
    interfaces. Every time it’s called, it has to verify that the source
    address does not correspond to an existing anycast address by looping
    through every device and every anycast address on the device.  This can
    result in significant delays for a CPU when there are a large number of
    neighbors and ND timers are frequently timing out and calling
    neigh_invalidate().
    
    Add anycast addresses to a global hashtable to allow quick searching for
    matching anycast addresses.  This is based on inet6_addr_lst in addrconf.c.
    
    Signed-off-by: Jeff Barnhill <0xeffeff@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index d7578cf49c3a..c9c78c15bce0 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -146,10 +146,12 @@ struct ifacaddr6 {
 	struct in6_addr		aca_addr;
 	struct fib6_info	*aca_rt;
 	struct ifacaddr6	*aca_next;
+	struct hlist_node	aca_addr_lst;
 	int			aca_users;
 	refcount_t		aca_refcnt;
 	unsigned long		aca_cstamp;
 	unsigned long		aca_tstamp;
+	struct rcu_head		rcu;
 };
 
 #define	IFA_HOST	IPV6_ADDR_LOOPBACK

commit 8308f3ff1753d001f7a73f9bb0f02292b5400557
Author: David Ahern <dsahern@gmail.com>
Date:   Sun May 27 08:09:58 2018 -0700

    net/ipv6: Add support for specifying metric of connected routes
    
    Add support for IFA_RT_PRIORITY to ipv6 addresses.
    
    If the metric is changed on an existing address then the new route
    is inserted before removing the old one. Since the metric is one
    of the route keys, the prefix route can not be atomically replaced.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index db389253dc2a..d7578cf49c3a 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -42,6 +42,7 @@ enum {
 struct inet6_ifaddr {
 	struct in6_addr		addr;
 	__u32			prefix_len;
+	__u32			rt_priority;
 
 	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */
 	__u32			valid_lft;

commit 9ee8cbb2fd4a7d6f483a20c4b8e82d8b1cf685fa
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Apr 18 15:39:01 2018 -0700

    net/ipv6: Remove aca_idev
    
    aca_idev has only 1 user - inet6_fill_ifacaddr - and it only
    wants the device index which can be extracted from the fib6_info
    nexthop.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index d6089b2e64fe..db389253dc2a 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -143,7 +143,6 @@ struct ipv6_ac_socklist {
 
 struct ifacaddr6 {
 	struct in6_addr		aca_addr;
-	struct inet6_dev	*aca_idev;
 	struct fib6_info	*aca_rt;
 	struct ifacaddr6	*aca_next;
 	int			aca_users;

commit 8d1c802b2815edc97af8a58c5045ebaf3848621a
Author: David Ahern <dsahern@gmail.com>
Date:   Tue Apr 17 17:33:26 2018 -0700

    net/ipv6: Flip FIB entries to fib6_info
    
    Convert all code paths referencing a FIB entry from
    rt6_info to fib6_info.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index d4088d1a688d..d6089b2e64fe 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -64,7 +64,7 @@ struct inet6_ifaddr {
 	struct delayed_work	dad_work;
 
 	struct inet6_dev	*idev;
-	struct rt6_info		*rt;
+	struct fib6_info	*rt;
 
 	struct hlist_node	addr_lst;
 	struct list_head	if_list;
@@ -144,7 +144,7 @@ struct ipv6_ac_socklist {
 struct ifacaddr6 {
 	struct in6_addr		aca_addr;
 	struct inet6_dev	*aca_idev;
-	struct rt6_info		*aca_rt;
+	struct fib6_info	*aca_rt;
 	struct ifacaddr6	*aca_next;
 	int			aca_users;
 	refcount_t		aca_refcnt;

commit affa78bc6a204fac1b5ced4f34376f53c70ec0ac
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 09:34:58 2017 +0300

    net, ipv6: convert ifacaddr6.aca_refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 4bb52ce634e8..d4088d1a688d 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -147,7 +147,7 @@ struct ifacaddr6 {
 	struct rt6_info		*aca_rt;
 	struct ifacaddr6	*aca_next;
 	int			aca_users;
-	atomic_t		aca_refcnt;
+	refcount_t		aca_refcnt;
 	unsigned long		aca_cstamp;
 	unsigned long		aca_tstamp;
 };

commit d3981bc615f652b9ead0762dd180125ac2b21a3a
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 09:34:57 2017 +0300

    net, ipv6: convert ifmcaddr6.mca_refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 2b41cb86d62f..4bb52ce634e8 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -127,7 +127,7 @@ struct ifmcaddr6 {
 	struct timer_list	mca_timer;
 	unsigned int		mca_flags;
 	int			mca_users;
-	atomic_t		mca_refcnt;
+	refcount_t		mca_refcnt;
 	spinlock_t		mca_lock;
 	unsigned long		mca_cstamp;
 	unsigned long		mca_tstamp;

commit 271201c09c86cd75e0fd6206bde689176e85aa21
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 09:34:56 2017 +0300

    net, ipv6: convert inet6_ifaddr.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index e7a17b231afc..2b41cb86d62f 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -46,7 +46,7 @@ struct inet6_ifaddr {
 	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */
 	__u32			valid_lft;
 	__u32			prefered_lft;
-	atomic_t		refcnt;
+	refcount_t		refcnt;
 	spinlock_t		lock;
 
 	int			state;

commit 1be9246077f6bb1583f9347c599480621d63c66a
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 09:34:55 2017 +0300

    net, ipv6: convert inet6_dev.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index f656f9051aca..e7a17b231afc 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -17,6 +17,7 @@
 
 #include <net/snmp.h>
 #include <linux/ipv6.h>
+#include <linux/refcount.h>
 
 /* inet6_dev.if_flags */
 
@@ -187,7 +188,7 @@ struct inet6_dev {
 
 	struct ifacaddr6	*ac_list;
 	rwlock_t		lock;
-	atomic_t		refcnt;
+	refcount_t		refcnt;
 	__u32			if_flags;
 	int			dead;
 

commit d35a00b8e33dab7385f724e713ae71c8be0a49f4
Author: Felix Jia <felix.jia@alliedtelesis.co.nz>
Date:   Thu Jan 26 16:59:17 2017 +1300

    net/ipv6: allow sysctl to change link-local address generation mode
    
    The address generation mode for IPv6 link-local can only be configured
    by netlink messages. This patch adds the ability to change the address
    generation mode via sysctl.
    
    v1 -> v2
    Removed the rtnl lock and switch to use RCU lock to iterate through
    the netdev list.
    
    v2 -> v3
    Removed the addrgenmode variable from the idev structure and use the
    systcl storage for the flag.
    
    Simplifed the logic for sysctl handling by removing the supported
    for all operation.
    
    Added support for more types of tunnel interfaces for link-local
    address generation.
    
    Based the patches from net-next.
    
    v3 -> v4
    Removed unnecessary whitespace changes.
    
    Signed-off-by: Felix Jia <felix.jia@alliedtelesis.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 0fa4c324b713..f656f9051aca 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -205,7 +205,6 @@ struct inet6_dev {
 	__s32			rs_interval;	/* in jiffies */
 	__u8			rs_probes;
 
-	__u8			addr_gen_mode;
 	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */
 	struct rcu_head		rcu;
 };

commit adc176c5472214971d77c1a61c83db9b01e9cdc7
Author: Erik Nordmark <nordmark@arista.com>
Date:   Fri Dec 2 14:00:08 2016 -0800

    ipv6 addrconf: Implemented enhanced DAD (RFC7527)
    
    Implemented RFC7527 Enhanced DAD.
    IPv6 duplicate address detection can fail if there is some temporary
    loopback of Ethernet frames. RFC7527 solves this by including a random
    nonce in the NS messages used for DAD, and if an NS is received with the
    same nonce it is assumed to be a looped back DAD probe and is ignored.
    RFC7527 is enabled by default. Can be disabled by setting both of
    conf/{all,interface}/enhanced_dad to zero.
    
    Signed-off-by: Erik Nordmark <nordmark@arista.com>
    Signed-off-by: Bob Gilligan <gilligan@arista.com>
    Reviewed-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index b0576cb2ab25..0fa4c324b713 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -55,6 +55,7 @@ struct inet6_ifaddr {
 	__u8			stable_privacy_retry;
 
 	__u16			scope;
+	__u64			dad_nonce;
 
 	unsigned long		cstamp;	/* created timestamp */
 	unsigned long		tstamp; /* updated timestamp */

commit 76506a986dc31394fd1f2741db037d29c7e57843
Author: Jiri Bohac <jbohac@suse.cz>
Date:   Thu Oct 13 18:52:15 2016 +0200

    IPv6: fix DESYNC_FACTOR
    
    The IPv6 temporary address generation uses a variable called DESYNC_FACTOR
    to prevent hosts updating the addresses at the same time. Quoting RFC 4941:
    
       ... The value DESYNC_FACTOR is a random value (different for each
       client) that ensures that clients don't synchronize with each other and
       generate new addresses at exactly the same time ...
    
    DESYNC_FACTOR is defined as:
    
       DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR.
       It is computed once at system start (rather than each time it is used)
       and must never be greater than (TEMP_VALID_LIFETIME - REGEN_ADVANCE).
    
    First, I believe the RFC has a typo in it and meant to say: "and must
    never be greater than (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE)"
    
    The reason is that at various places in the RFC, DESYNC_FACTOR is used in
    a calculation like (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR) or
    (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR). It needs to be
    smaller than (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE) for the result of
    these calculations to be larger than zero. It's never used in a
    calculation together with TEMP_VALID_LIFETIME.
    
    I already submitted an errata to the rfc-editor:
    https://www.rfc-editor.org/errata_search.php?rfc=4941
    
    The Linux implementation of DESYNC_FACTOR is very wrong:
    max_desync_factor is used in places DESYNC_FACTOR should be used.
    max_desync_factor is initialized to the RFC-recommended value for
    MAX_DESYNC_FACTOR (600) but the whole point is to get a _random_ value.
    
    And nothing ensures that the value used is not greater than
    (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE), which leads to underflows.  The
    effect can easily be observed when setting the temp_prefered_lft sysctl
    e.g. to 60. The preferred lifetime of the temporary addresses will be
    bogus.
    
    TEMP_PREFERRED_LIFETIME and REGEN_ADVANCE are not constants and can be
    influenced by these three sysctls: regen_max_retry, dad_transmits and
    temp_prefered_lft. Thus, the upper bound for desync_factor needs to be
    re-calculated each time a new address is generated and if desync_factor is
    larger than the new upper bound, a new random value needs to be
    re-generated.
    
    And since we already have max_desync_factor configurable per interface, we
    also need to calculate and store desync_factor per interface.
    
    Signed-off-by: Jiri Bohac <jbohac@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index ae707352f463..b0576cb2ab25 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -190,6 +190,7 @@ struct inet6_dev {
 	__u32			if_flags;
 	int			dead;
 
+	u32			desync_factor;
 	u8			rndid[8];
 	struct list_head	tempaddr_list;
 

commit 9d6280da39c04832d6abf5f4ecc8175c9aad91c0
Author: Jiri Bohac <jbohac@suse.cz>
Date:   Thu Oct 13 18:50:02 2016 +0200

    IPv6: Drop the temporary address regen_timer
    
    The randomized interface identifier (rndid) was periodically updated from
    the regen_timer timer. Simplify the code by updating the rndid only when
    needed by ipv6_try_regen_rndid().
    
    This makes the follow-up DESYNC_FACTOR fix much simpler.  Also it fixes a
    reference counting error in this error path, where an in6_dev_put was
    missing:
                    err = addrconf_sysctl_register(ndev);
                    if (err) {
                            ipv6_mc_destroy_dev(ndev);
            -               del_timer(&ndev->regen_timer);
                            snmp6_unregister_dev(ndev);
                            goto err_release;
    
    Signed-off-by: Jiri Bohac <jbohac@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 515352c6280a..ae707352f463 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -191,7 +191,6 @@ struct inet6_dev {
 	int			dead;
 
 	u8			rndid[8];
-	struct timer_list	regen_timer;
 	struct list_head	tempaddr_list;
 
 	struct in6_addr		token;

commit bd11f0741fa5a2c296629898ad07759dd12b35bb
Author: Maciej Żenczykowski <maze@google.com>
Date:   Tue Sep 27 23:57:58 2016 -0700

    ipv6 addrconf: implement RFC7559 router solicitation backoff
    
    This implements:
      https://tools.ietf.org/html/rfc7559
    
    Backoff is performed according to RFC3315 section 14:
      https://tools.ietf.org/html/rfc3315#section-14
    
    We allow setting /proc/sys/net/ipv6/conf/*/router_solicitations
    to a negative value meaning an unlimited number of retransmits,
    and we make this the new default (inline with the RFC).
    
    We also add a new setting:
      /proc/sys/net/ipv6/conf/*/router_solicitation_max_interval
    defaulting to 1 hour (per RFC recommendation).
    
    Signed-off-by: Maciej Żenczykowski <maze@google.com>
    Acked-by: Erik Kline <ek@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 1c8b6820b694..515352c6280a 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -201,6 +201,7 @@ struct inet6_dev {
 	struct ipv6_devstat	stats;
 
 	struct timer_list	rs_timer;
+	__s32			rs_interval;	/* in jiffies */
 	__u8			rs_probes;
 
 	__u8			addr_gen_mode;

commit 5f40ef77adb237954d615a76621df1b80a329b31
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Mon Mar 23 23:36:04 2015 +0100

    ipv6: do retries on stable privacy addresses
    
    If a DAD conflict is detected, we want to retry privacy stable address
    generation up to idgen_retries (= 3) times with a delay of idgen_delay
    (= 1 second). Add the logic to addrconf_dad_failure.
    
    By design, we don't clean up dad failed permanent addresses.
    
    Cc: Erik Kline <ek@google.com>
    Cc: Fernando Gont <fgont@si6networks.com>
    Cc: Lorenzo Colitti <lorenzo@google.com>
    Cc: YOSHIFUJI Hideaki/吉藤英明 <hideaki.yoshifuji@miraclelinux.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index d89397a22903..1c8b6820b694 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -52,6 +52,7 @@ struct inet6_ifaddr {
 
 	__u32			flags;
 	__u8			dad_probes;
+	__u8			stable_privacy_retry;
 
 	__u16			scope;
 

commit 8e8e676d0b3c7f074c719c7c05b20296b9b0b0b1
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Mon Mar 23 23:36:03 2015 +0100

    ipv6: collapse state_lock and lock
    
    Cc: Erik Kline <ek@google.com>
    Cc: Fernando Gont <fgont@si6networks.com>
    Cc: Lorenzo Colitti <lorenzo@google.com>
    Cc: YOSHIFUJI Hideaki/吉藤英明 <hideaki.yoshifuji@miraclelinux.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 98e5f9578f86..d89397a22903 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -41,13 +41,12 @@ enum {
 struct inet6_ifaddr {
 	struct in6_addr		addr;
 	__u32			prefix_len;
-	
+
 	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */
 	__u32			valid_lft;
 	__u32			prefered_lft;
 	atomic_t		refcnt;
 	spinlock_t		lock;
-	spinlock_t		state_lock;
 
 	int			state;
 

commit 02ea80741a25435123e8a5ca40cac6a0bcf0c9f1
Author: Li RongQing <roy.qing.li@gmail.com>
Date:   Sat Oct 11 13:03:34 2014 +0800

    ipv6: remove aca_lock spinlock from struct ifacaddr6
    
    no user uses this lock.
    
    Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 55a8d4056cc9..98e5f9578f86 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -146,7 +146,6 @@ struct ifacaddr6 {
 	struct ifacaddr6	*aca_next;
 	int			aca_users;
 	atomic_t		aca_refcnt;
-	spinlock_t		aca_lock;
 	unsigned long		aca_cstamp;
 	unsigned long		aca_tstamp;
 };

commit dd3619f2ed5bd5ffce90f4fd8361ccd46d59b9b6
Author: Sébastien Barré <sebastien.barre@uclouvain.be>
Date:   Thu Oct 2 21:15:22 2014 +0200

    Removed unused inet6 address state
    
    the inet6 state INET6_IFADDR_STATE_UP only appeared in its definition.
    
    Cc: Christoph Paasch <christoph.paasch@uclouvain.be>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Sébastien Barré <sebastien.barre@uclouvain.be>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index d07b1a64b4e7..55a8d4056cc9 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -35,7 +35,6 @@ enum {
 	INET6_IFADDR_STATE_DAD,
 	INET6_IFADDR_STATE_POSTDAD,
 	INET6_IFADDR_STATE_ERRDAD,
-	INET6_IFADDR_STATE_UP,
 	INET6_IFADDR_STATE_DEAD,
 };
 

commit bc91b0f07ada5535427373a4e2050877bcc12218
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Jul 11 21:10:18 2014 +0200

    ipv6: addrconf: implement address generation modes
    
    This patch introduces a possibility for userspace to set various (so far
    two) modes of generating addresses. This is useful for example for
    NetworkManager because it can set the mode to NONE and take care of link
    local addresses itself. That allow it to have the interface up,
    monitoring carrier but still don't have any addresses on it.
    
    One more use-case by Dan Williams:
    <quote>
    WWAN devices often have their LL address provided by the firmware of the
    device, which sometimes refuses to respond to incorrect LL addresses
    when doing DHCPv6 or IPv6 ND.  The kernel cannot generate the correct LL
    address for two reasons:
    
    1) WWAN pseudo-ethernet interfaces often construct a fake MAC address,
    or read a meaningless MAC address from the firmware.  Thus the EUI64 and
    the IPv6LL address the kernel assigns will be wrong.  The real LL
    address is often retrieved from the firmware with AT or proprietary
    commands.
    
    2) WWAN PPP interfaces receive their LL address from IPV6CP, not from
    kernel assignments.  Only after IPV6CP has completed do we know the LL
    address of the PPP interface and its peer.  But the kernel has already
    assigned an incorrect LL address to the interface.
    
    So being able to suppress the kernel LL address generation and assign
    the one retrieved from the firmware is less complicated and more robust.
    </quote>
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index b4956a5fcc3f..d07b1a64b4e7 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -205,6 +205,7 @@ struct inet6_dev {
 	struct timer_list	rs_timer;
 	__u8			rs_probes;
 
+	__u8			addr_gen_mode;
 	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */
 	struct rcu_head		rcu;
 };

commit c15b1ccadb323ea50023e8f1cca2954129a62b51
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Mar 27 18:28:07 2014 +0100

    ipv6: move DAD and addrconf_verify processing to workqueue
    
    addrconf_join_solict and addrconf_join_anycast may cause actions which
    need rtnl locked, especially on first address creation.
    
    A new DAD state is introduced which defers processing of the initial
    DAD processing into a workqueue.
    
    To get rtnl lock we need to push the code paths which depend on those
    calls up to workqueues, specifically addrconf_verify and the DAD
    processing.
    
    (v2)
    addrconf_dad_failure needs to be queued up to the workqueue, too. This
    patch introduces a new DAD state and stop the DAD processing in the
    workqueue (this is because of the possible ipv6_del_addr processing
    which removes the solicited multicast address from the device).
    
    addrconf_verify_lock is removed, too. After the transition it is not
    needed any more.
    
    As we are not processing in bottom half anymore we need to be a bit more
    careful about disabling bottom half out when we lock spin_locks which are also
    used in bh.
    
    Relevant backtrace:
    [  541.030090] RTNL: assertion failed at net/core/dev.c (4496)
    [  541.031143] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G           O 3.10.33-1-amd64-vyatta #1
    [  541.031145] Hardware name: Bochs Bochs, BIOS Bochs 01/01/2007
    [  541.031146]  ffffffff8148a9f0 000000000000002f ffffffff813c98c1 ffff88007c4451f8
    [  541.031148]  0000000000000000 0000000000000000 ffffffff813d3540 ffff88007fc03d18
    [  541.031150]  0000880000000006 ffff88007c445000 ffffffffa0194160 0000000000000000
    [  541.031152] Call Trace:
    [  541.031153]  <IRQ>  [<ffffffff8148a9f0>] ? dump_stack+0xd/0x17
    [  541.031180]  [<ffffffff813c98c1>] ? __dev_set_promiscuity+0x101/0x180
    [  541.031183]  [<ffffffff813d3540>] ? __hw_addr_create_ex+0x60/0xc0
    [  541.031185]  [<ffffffff813cfe1a>] ? __dev_set_rx_mode+0xaa/0xc0
    [  541.031189]  [<ffffffff813d3a81>] ? __dev_mc_add+0x61/0x90
    [  541.031198]  [<ffffffffa01dcf9c>] ? igmp6_group_added+0xfc/0x1a0 [ipv6]
    [  541.031208]  [<ffffffff8111237b>] ? kmem_cache_alloc+0xcb/0xd0
    [  541.031212]  [<ffffffffa01ddcd7>] ? ipv6_dev_mc_inc+0x267/0x300 [ipv6]
    [  541.031216]  [<ffffffffa01c2fae>] ? addrconf_join_solict+0x2e/0x40 [ipv6]
    [  541.031219]  [<ffffffffa01ba2e9>] ? ipv6_dev_ac_inc+0x159/0x1f0 [ipv6]
    [  541.031223]  [<ffffffffa01c0772>] ? addrconf_join_anycast+0x92/0xa0 [ipv6]
    [  541.031226]  [<ffffffffa01c311e>] ? __ipv6_ifa_notify+0x11e/0x1e0 [ipv6]
    [  541.031229]  [<ffffffffa01c3213>] ? ipv6_ifa_notify+0x33/0x50 [ipv6]
    [  541.031233]  [<ffffffffa01c36c8>] ? addrconf_dad_completed+0x28/0x100 [ipv6]
    [  541.031241]  [<ffffffff81075c1d>] ? task_cputime+0x2d/0x50
    [  541.031244]  [<ffffffffa01c38d6>] ? addrconf_dad_timer+0x136/0x150 [ipv6]
    [  541.031247]  [<ffffffffa01c37a0>] ? addrconf_dad_completed+0x100/0x100 [ipv6]
    [  541.031255]  [<ffffffff8105313a>] ? call_timer_fn.isra.22+0x2a/0x90
    [  541.031258]  [<ffffffffa01c37a0>] ? addrconf_dad_completed+0x100/0x100 [ipv6]
    
    Hunks and backtrace stolen from a patch by Stephen Hemminger.
    
    Reported-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 9650a3ffd2d2..b4956a5fcc3f 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -31,8 +31,10 @@
 #define IF_PREFIX_AUTOCONF	0x02
 
 enum {
+	INET6_IFADDR_STATE_PREDAD,
 	INET6_IFADDR_STATE_DAD,
 	INET6_IFADDR_STATE_POSTDAD,
+	INET6_IFADDR_STATE_ERRDAD,
 	INET6_IFADDR_STATE_UP,
 	INET6_IFADDR_STATE_DEAD,
 };
@@ -58,7 +60,7 @@ struct inet6_ifaddr {
 	unsigned long		cstamp;	/* created timestamp */
 	unsigned long		tstamp; /* updated timestamp */
 
-	struct timer_list	dad_timer;
+	struct delayed_work	dad_work;
 
 	struct inet6_dev	*idev;
 	struct rt6_info		*rt;

commit 41804420586ab41049a14ab7ef04eaa2280b8647
Merge: 7b1e46c5a265 7d0d46da750a
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Jan 18 00:55:41 2014 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
            net/ipv4/tcp_metrics.c
    
    Overlapping changes between the "don't create two tcp metrics objects
    with the same key" race fix in net and the addition of the destination
    address in the lookup key in net-next.
    
    Minor overlapping changes in bnx2x driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 11ffff752c6a5adc86f7dd397b2f75af8f917c51
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Jan 16 20:13:04 2014 +0100

    ipv6: simplify detection of first operational link-local address on interface
    
    In commit 1ec047eb4751e3 ("ipv6: introduce per-interface counter for
    dad-completed ipv6 addresses") I build the detection of the first
    operational link-local address much to complex. Additionally this code
    now has a race condition.
    
    Replace it with a much simpler variant, which just scans the address
    list when duplicate address detection completes, to check if this is
    the first valid link local address and send RS and MLD reports then.
    
    Fixes: 1ec047eb4751e3 ("ipv6: introduce per-interface counter for dad-completed ipv6 addresses")
    Reported-by: Jiri Pirko <jiri@resnulli.us>
    Cc: Flavio Leitner <fbl@redhat.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Flavio Leitner <fbl@redhat.com>
    Acked-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 76d54270f2e2..65bb13035598 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -165,7 +165,6 @@ struct inet6_dev {
 	struct net_device	*dev;
 
 	struct list_head	addr_list;
-	int			valid_ll_addr_cnt;
 
 	struct ifmcaddr6	*mc_list;
 	struct ifmcaddr6	*mc_tomb;

commit 479840ffdbe4242e8a25349218c8e0859223aa35
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Dec 6 09:45:21 2013 +0100

    ipv6 addrconf: extend ifa_flags to u32
    
    There is no more space in u8 ifa_flags. So do what davem suffested and
    add another netlink attr called IFA_FLAGS for carry more flags.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: Thomas Haller <thaller@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 76d54270f2e2..b58c36c1c3f6 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -50,8 +50,8 @@ struct inet6_ifaddr {
 
 	int			state;
 
+	__u32			flags;
 	__u8			dad_probes;
-	__u8			flags;
 
 	__u16			scope;
 

commit 5d9efa7ee99eed58388f186c13cf2e2a87e9ceb4
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 28 20:07:50 2013 -0400

    ipv6: Remove privacy config option.
    
    The code for privacy extentions is very mature, and making it
    configurable only gives marginal memory/code savings in exchange
    for obfuscation and hard to read code via CPP ifdef'ery.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 02ef7727bb55..76d54270f2e2 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -66,11 +66,10 @@ struct inet6_ifaddr {
 	struct hlist_node	addr_lst;
 	struct list_head	if_list;
 
-#ifdef CONFIG_IPV6_PRIVACY
 	struct list_head	tmp_list;
 	struct inet6_ifaddr	*ifpub;
 	int			regen_count;
-#endif
+
 	bool			tokenized;
 
 	struct rcu_head		rcu;
@@ -192,11 +191,9 @@ struct inet6_dev {
 	__u32			if_flags;
 	int			dead;
 
-#ifdef CONFIG_IPV6_PRIVACY
 	u8			rndid[8];
 	struct timer_list	regen_timer;
 	struct list_head	tempaddr_list;
-#endif
 
 	struct in6_addr		token;
 

commit 89225d1ce6af3916bf32aecbe9d83f571a098588
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Sep 4 00:19:37 2013 +0200

    net: ipv6: mld: fix v1/v2 switchback timeout to rfc3810, 9.12.
    
    i) RFC3810, 9.2. Query Interval [QI] says:
    
       The Query Interval variable denotes the interval between General
       Queries sent by the Querier. Default value: 125 seconds. [...]
    
    ii) RFC3810, 9.3. Query Response Interval [QRI] says:
    
      The Maximum Response Delay used to calculate the Maximum Response
      Code inserted into the periodic General Queries. Default value:
      10000 (10 seconds) [...] The number of seconds represented by the
      [Query Response Interval] must be less than the [Query Interval].
    
    iii) RFC3810, 9.12. Older Version Querier Present Timeout [OVQPT] says:
    
      The Older Version Querier Present Timeout is the time-out for
      transitioning a host back to MLDv2 Host Compatibility Mode. When an
      MLDv1 query is received, MLDv2 hosts set their Older Version Querier
      Present Timer to [Older Version Querier Present Timeout].
    
      This value MUST be ([Robustness Variable] times (the [Query Interval]
      in the last Query received)) plus ([Query Response Interval]).
    
    Hence, on *default* the timeout results in:
    
      [RV] = 2, [QI] = 125sec, [QRI] = 10sec
      [OVQPT] = [RV] * [QI] + [QRI] = 260sec
    
    Having that said, we currently calculate [OVQPT] (here given as 'switchback'
    variable) as ...
    
      switchback = (idev->mc_qrv + 1) * max_delay
    
    RFC3810, 9.12. says "the [Query Interval] in the last Query received". In
    section "9.14. Configuring timers", it is said:
    
      This section is meant to provide advice to network administrators on
      how to tune these settings to their network. Ambitious router
      implementations might tune these settings dynamically based upon
      changing characteristics of the network. [...]
    
    iv) RFC38010, 9.14.2. Query Interval:
    
      The overall level of periodic MLD traffic is inversely proportional
      to the Query Interval. A longer Query Interval results in a lower
      overall level of MLD traffic. The value of the Query Interval MUST
      be equal to or greater than the Maximum Response Delay used to
      calculate the Maximum Response Code inserted in General Query
      messages.
    
    I assume that was why switchback is calculated as is (3 * max_delay), although
    this setting seems to be meant for routers only to configure their [QI]
    interval for non-default intervals. So usage here like this is clearly wrong.
    
    Concluding, the current behaviour in IPv6's multicast code is not conform
    to the RFC as switch back is calculated wrongly. That is, it has a too small
    value, so MLDv2 hosts switch back again to MLDv2 way too early, i.e. ~30secs
    instead of ~260secs on default.
    
    Hence, introduce necessary helper functions and fix this up properly as it
    should be.
    
    Introduced in 06da92283 ("[IPV6]: Add MLDv2 support."). Credits to Hannes
    Frederic Sowa who also had a hand in this as well. Also thanks to Hangbin Liu
    who did initial testing.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 736b5fb95474..02ef7727bb55 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -171,12 +171,17 @@ struct inet6_dev {
 	struct ifmcaddr6	*mc_list;
 	struct ifmcaddr6	*mc_tomb;
 	spinlock_t		mc_lock;
-	unsigned char		mc_qrv;
+
+	unsigned char		mc_qrv;		/* Query Robustness Variable */
 	unsigned char		mc_gq_running;
 	unsigned char		mc_ifc_count;
 	unsigned char		mc_dad_count;
-	unsigned long		mc_v1_seen;
+
+	unsigned long		mc_v1_seen;	/* Max time we stay in MLDv1 mode */
+	unsigned long		mc_qi;		/* Query Interval */
+	unsigned long		mc_qri;		/* Query Response Interval */
 	unsigned long		mc_maxdelay;
+
 	struct timer_list	mc_gq_timer;	/* general query timer */
 	struct timer_list	mc_ifc_timer;	/* interface change timer */
 	struct timer_list	mc_dad_timer;	/* dad complete mc timer */

commit b173ee488dcc545e77ed482158a2f0d06d7a5860
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Jun 27 00:07:01 2013 +0200

    ipv6: resend MLD report if a link-local address completes DAD
    
    RFC3590/RFC3810 specifies we should resend MLD reports as soon as a
    valid link-local address is available.
    
    We now use the valid_ll_addr_cnt to check if it is necessary to resend
    a new report.
    
    Changes since Flavio Leitner's version:
    a) adapt for valid_ll_addr_cnt
    b) resend first reports directly in the path and just arm the timer for
       mc_qrv-1 resends.
    
    Reported-by: Flavio Leitner <fleitner@redhat.com>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Flavio Leitner <fbl@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 1628b8f5fb26..736b5fb95474 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -174,10 +174,12 @@ struct inet6_dev {
 	unsigned char		mc_qrv;
 	unsigned char		mc_gq_running;
 	unsigned char		mc_ifc_count;
+	unsigned char		mc_dad_count;
 	unsigned long		mc_v1_seen;
 	unsigned long		mc_maxdelay;
 	struct timer_list	mc_gq_timer;	/* general query timer */
 	struct timer_list	mc_ifc_timer;	/* interface change timer */
+	struct timer_list	mc_dad_timer;	/* dad complete mc timer */
 
 	struct ifacaddr6	*ac_list;
 	rwlock_t		lock;

commit 1ec047eb4751e331bc61cff0e98f0db67db8b8dc
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Thu Jun 27 00:06:56 2013 +0200

    ipv6: introduce per-interface counter for dad-completed ipv6 addresses
    
    To reduce the number of unnecessary router solicitations, MLDv2 and IGMPv3
    messages we need to track the number of valid (as in non-optimistic,
    no-dad-failed and non-tentative) link-local addresses. Therefore, this
    patch implements a valid_ll_addr_cnt in struct inet6_dev.
    
    We now only emit router solicitations if the first link-local address
    finishes duplicate address detection.
    
    The changes for MLDv2 and IGMPv3 are in a follow-up patch.
    
    While there, also simplify one if statement(one minor nit I made in one
    of my previous patches):
    
    if (!...)
            do();
    else
            return;
    
    <<into>>
    
    if (...)
            return;
    do();
    
    Cc: Flavio Leitner <fbl@redhat.com>
    Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Suggested-by: David Stevens <dlstevens@us.ibm.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Acked-by: Flavio Leitner <fbl@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index e4c5a2d2ba34..1628b8f5fb26 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -166,6 +166,7 @@ struct inet6_dev {
 	struct net_device	*dev;
 
 	struct list_head	addr_list;
+	int			valid_ll_addr_cnt;
 
 	struct ifmcaddr6	*mc_list;
 	struct ifmcaddr6	*mc_tomb;

commit b7b1bfce0bb68bd8f6e62a28295922785cc63781
Author: Hannes Frederic Sowa <hannes@stressinduktion.org>
Date:   Sun Jun 23 18:39:01 2013 +0200

    ipv6: split duplicate address detection and router solicitation timer
    
    This patch splits the timers for duplicate address detection and router
    solicitations apart. The router solicitations timer goes into inet6_dev
    and the dad timer stays in inet6_ifaddr.
    
    The reason behind this patch is to reduce the number of unneeded router
    solicitations send out by the host if additional link-local addresses
    are created. Currently we send out RS for every link-local address on
    an interface.
    
    If the RS timer fires we pick a source address with ipv6_get_lladdr. This
    change could hurt people adding additional link-local addresses and
    specifying these addresses in the radvd clients section because we
    no longer guarantee that we use every ll address as source address in
    router solicitations.
    
    Cc: Flavio Leitner <fleitner@redhat.com>
    Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
    Cc: David Stevens <dlstevens@us.ibm.com>
    Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Reviewed-by: Flavio Leitner <fbl@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index e07feb456d19..e4c5a2d2ba34 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -50,7 +50,7 @@ struct inet6_ifaddr {
 
 	int			state;
 
-	__u8			probes;
+	__u8			dad_probes;
 	__u8			flags;
 
 	__u16			scope;
@@ -58,7 +58,7 @@ struct inet6_ifaddr {
 	unsigned long		cstamp;	/* created timestamp */
 	unsigned long		tstamp; /* updated timestamp */
 
-	struct timer_list	timer;
+	struct timer_list	dad_timer;
 
 	struct inet6_dev	*idev;
 	struct rt6_info		*rt;
@@ -195,6 +195,10 @@ struct inet6_dev {
 	struct neigh_parms	*nd_parms;
 	struct ipv6_devconf	cnf;
 	struct ipv6_devstat	stats;
+
+	struct timer_list	rs_timer;
+	__u8			rs_probes;
+
 	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */
 	struct rcu_head		rcu;
 };

commit 168fc21a971e4bc821a7838ccc39b7bdaf316c11
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon May 20 04:53:38 2013 +0000

    net: ipv6: remove 'next' member from inet6_dev
    
    The next pointer within the inet6_dev structure seems not to be used
    anywhere. So just remove it. Tested with allmodconfig on x86_64.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 0727d0e4af3b..e07feb456d19 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -193,7 +193,6 @@ struct inet6_dev {
 	struct in6_addr		token;
 
 	struct neigh_parms	*nd_parms;
-	struct inet6_dev	*next;
 	struct ipv6_devconf	cnf;
 	struct ipv6_devstat	stats;
 	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */

commit caeaba79009c2ee858c3b2bf8caf922cd719fead
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Thu May 16 22:32:00 2013 +0000

    ipv6: add support of peer address
    
    This patch adds the support of peer address for IPv6. For example, it is
    possible to specify the remote end of a 6inY tunnel.
    This was already possible in IPv4:
     ip addr add ip1 peer ip2 dev dev1
    
    The peer address is specified with IFA_ADDRESS and the local address with
    IFA_LOCAL (like explained in include/uapi/linux/if_addr.h).
    Note that the API is not changed, because before this patch, it was not
    possible to specify two different addresses in IFA_LOCAL and IFA_REMOTE.
    There is a small change for the dump: if the peer is different from ::,
    IFA_ADDRESS will contain the peer address instead of the local address.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 100fb8cec17c..0727d0e4af3b 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -74,6 +74,7 @@ struct inet6_ifaddr {
 	bool			tokenized;
 
 	struct rcu_head		rcu;
+	struct in6_addr		peer_addr;
 };
 
 struct ip6_sf_socklist {

commit 617fe29d45bdfffba2739e6512c83e766e6ae72c
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 9 03:47:16 2013 +0000

    net: ipv6: only invalidate previously tokenized addresses
    
    Instead of invalidating all IPv6 addresses with global scope
    when one decides to use IPv6 tokens, we should only invalidate
    previous tokens and leave the rest intact until they expire
    eventually (or are intact forever). For doing this less greedy
    approach, we're adding a bool at the end of inet6_ifaddr structure
    instead, for two reasons: i) per-inet6_ifaddr flag space is
    already used up, making it wider might not be a good idea,
    since ii) also we do not necessarily need to export this
    information into user space.
    
    Suggested-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index f1063d62cd13..100fb8cec17c 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -71,6 +71,8 @@ struct inet6_ifaddr {
 	struct inet6_ifaddr	*ifpub;
 	int			regen_count;
 #endif
+	bool			tokenized;
+
 	struct rcu_head		rcu;
 };
 

commit f53adae4eae5ad9f7343ff4a0fc68b468c981138
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Apr 8 04:01:30 2013 +0000

    net: ipv6: add tokenized interface identifier support
    
    This patch adds support for IPv6 tokenized IIDs, that allow
    for administrators to assign well-known host-part addresses
    to nodes whilst still obtaining global network prefix from
    Router Advertisements. It is currently in draft status.
    
      The primary target for such support is server platforms
      where addresses are usually manually configured, rather
      than using DHCPv6 or SLAAC. By using tokenised identifiers,
      hosts can still determine their network prefix by use of
      SLAAC, but more readily be automatically renumbered should
      their network prefix change. [...]
    
      The disadvantage with static addresses is that they are
      likely to require manual editing should the network prefix
      in use change.  If instead there were a method to only
      manually configure the static identifier part of the IPv6
      address, then the address could be automatically updated
      when a new prefix was introduced, as described in [RFC4192]
      for example.  In such cases a DNS server might be
      configured with such a tokenised interface identifier of
      ::53, and SLAAC would use the token in constructing the
      interface address, using the advertised prefix. [...]
    
      http://tools.ietf.org/html/draft-chown-6man-tokenised-ipv6-identifiers-02
    
    The implementation is partially based on top of Mark K.
    Thompson's proof of concept. However, it uses the Netlink
    interface for configuration resp. data retrival, so that
    it can be easily extended in future. Successfully tested
    by myself.
    
    Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
    Cc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Cc: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 93563221d29a..f1063d62cd13 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -187,6 +187,8 @@ struct inet6_dev {
 	struct list_head	tempaddr_list;
 #endif
 
+	struct in6_addr		token;
+
 	struct neigh_parms	*nd_parms;
 	struct inet6_dev	*next;
 	struct ipv6_devconf	cnf;

commit 211ed865108e24697b44bee5daac502ee6bdd4a4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu May 10 17:14:35 2012 -0400

    net: delete all instances of special processing for token ring
    
    We are going to delete the Token ring support.  This removes any
    special processing in the core networking for token ring, (aside
    from net/tr.c itself), leaving the drivers and remaining tokenring
    support present but inert.
    
    The mass removal of the drivers and net/tr.c will be in a separate
    commit, so that the history of these files that we still care
    about won't have the giant deletion tied into their history.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 50f325fd0691..93563221d29a 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -209,60 +209,6 @@ static inline void ipv6_eth_mc_map(const struct in6_addr *addr, char *buf)
 	memcpy(buf + 2, &addr->s6_addr32[3], sizeof(__u32));
 }
 
-static inline void ipv6_tr_mc_map(const struct in6_addr *addr, char *buf)
-{
-	/* All nodes FF01::1, FF02::1, FF02::1:FFxx:xxxx */
-
-	if (((addr->s6_addr[0] == 0xFF) &&
-	    ((addr->s6_addr[1] == 0x01) || (addr->s6_addr[1] == 0x02)) &&
-	     (addr->s6_addr16[1] == 0) &&
-	     (addr->s6_addr32[1] == 0) &&
-	     (addr->s6_addr32[2] == 0) &&
-	     (addr->s6_addr16[6] == 0) &&
-	     (addr->s6_addr[15] == 1)) ||
-	    ((addr->s6_addr[0] == 0xFF) &&
-	     (addr->s6_addr[1] == 0x02) &&
-	     (addr->s6_addr16[1] == 0) &&
-	     (addr->s6_addr32[1] == 0) &&
-	     (addr->s6_addr16[4] == 0) &&
-	     (addr->s6_addr[10] == 0) &&
-	     (addr->s6_addr[11] == 1) &&
-	     (addr->s6_addr[12] == 0xff)))
-	{
-		buf[0]=0xC0;
-		buf[1]=0x00;
-		buf[2]=0x01;
-		buf[3]=0x00;
-		buf[4]=0x00;
-		buf[5]=0x00;
-	/* All routers FF0x::2 */
-	} else if ((addr->s6_addr[0] ==0xff) &&
-		((addr->s6_addr[1] & 0xF0) == 0) &&
-		(addr->s6_addr16[1] == 0) &&
-		(addr->s6_addr32[1] == 0) &&
-		(addr->s6_addr32[2] == 0) &&
-		(addr->s6_addr16[6] == 0) &&
-		(addr->s6_addr[15] == 2))
-	{
-		buf[0]=0xC0;
-		buf[1]=0x00;
-		buf[2]=0x02;
-		buf[3]=0x00;
-		buf[4]=0x00;
-		buf[5]=0x00;
-	} else {
-		unsigned char i ; 
-		
-		i = addr->s6_addr[15] & 7 ; 
-		buf[0]=0xC0;
-		buf[1]=0x00;
-		buf[2]=0x00;
-		buf[3]=0x01 << i ; 
-		buf[4]=0x00;
-		buf[5]=0x00;
-	}
-}
-
 static inline void ipv6_arcnet_mc_map(const struct in6_addr *addr, char *buf)
 {
 	buf[0] = 0x00;

commit 95c961747284a6b83a5e2d81240e214b0fa3464d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sun Apr 15 05:58:06 2012 +0000

    net: cleanup unsigned to unsigned int
    
    Use of "unsigned int" is preferred to bare "unsigned" in net tree.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 51a7031b4aa3..50f325fd0691 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -120,7 +120,7 @@ struct ifmcaddr6 {
 	unsigned char		mca_crcount;
 	unsigned long		mca_sfcount[2];
 	struct timer_list	mca_timer;
-	unsigned		mca_flags;
+	unsigned int		mca_flags;
 	int			mca_users;
 	atomic_t		mca_refcnt;
 	spinlock_t		mca_lock;

commit 76f793e3a47139d340185cbc1a314740c09b13d3
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Tue Jul 26 13:50:49 2011 +0000

    ipv6: updates to privacy addresses per RFC 4941.
    
    Update the code to handle some of the differences between
    RFC 3041 and RFC 4941, which obsoletes it. Also a couple
    of janitorial fixes.
    
    - Allow router advertisements to increase the lifetime of
      temporary addresses. This was not allowed by RFC 3041,
      but is specified by RFC 4941. It is useful when RA
      lifetimes are lower than TEMP_{VALID,PREFERRED}_LIFETIME:
      in this case, the previous code would delete or deprecate
      addresses prematurely.
    
    - Change the default of MAX_RETRY to 3 per RFC 4941.
    
    - Add a comment to clarify that the preferred and valid
      lifetimes in inet6_ifaddr are relative to the timestamp.
    
    - Shorten lines to 80 characters in a couple of places.
    
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 11cf373970a9..51a7031b4aa3 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -41,6 +41,7 @@ struct inet6_ifaddr {
 	struct in6_addr		addr;
 	__u32			prefix_len;
 	
+	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */
 	__u32			valid_lft;
 	__u32			prefered_lft;
 	atomic_t		refcnt;

commit be281e554e2a4cf2478df7a8b8926c89454bccfa
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu May 19 01:14:23 2011 +0000

    ipv6: reduce per device ICMP mib sizes
    
    ipv6 has per device ICMP SNMP counters, taking too much space because
    they use percpu storage.
    
    needed size per device is :
    (512+4)*sizeof(long)*number_of_possible_cpus*2
    
    On a 32bit kernel, 16 possible cpus, this wastes more than 64kbytes of
    memory per ipv6 enabled network device, taken in vmalloc pool.
    
    Since ICMP messages are rare, just use shared counters (atomic_long_t)
    
    Per network space ICMP counters are still using percpu memory, we might
    also convert them to shared counters in a future patch.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    CC: Denys Fedoryshchenko <denys@visp.net.lb>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 0c603fe65377..11cf373970a9 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -154,8 +154,8 @@ struct ifacaddr6 {
 struct ipv6_devstat {
 	struct proc_dir_entry	*proc_dir_entry;
 	DEFINE_SNMP_STAT(struct ipstats_mib, ipv6);
-	DEFINE_SNMP_STAT(struct icmpv6_mib, icmpv6);
-	DEFINE_SNMP_STAT(struct icmpv6msg_mib, icmpv6msg);
+	DEFINE_SNMP_STAT_ATOMIC(struct icmpv6_mib_device, icmpv6dev);
+	DEFINE_SNMP_STAT_ATOMIC(struct icmpv6msg_mib_device, icmpv6msgdev);
 };
 
 struct inet6_dev {

commit 2a9e9507011440a57d6356ded630ba0c0f5d4b77
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Apr 24 10:54:56 2011 -0700

    net: Remove __KERNEL__ cpp checks from include/net
    
    These header files are never installed to user consumption, so any
    __KERNEL__ cpp checks are superfluous.
    
    Projects should also not copy these files into their userland utility
    sources and try to use them there.  If they insist on doing so, the
    onus is on them to sanitize the headers as needed.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 3d982f72d48e..0c603fe65377 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -30,8 +30,6 @@
 #define IF_PREFIX_ONLINK	0x01
 #define IF_PREFIX_AUTOCONF	0x02
 
-#ifdef __KERNEL__
-
 enum {
 	INET6_IFADDR_STATE_DAD,
 	INET6_IFADDR_STATE_POSTDAD,
@@ -303,4 +301,3 @@ static inline int ipv6_ipgre_mc_map(const struct in6_addr *addr,
 }
 
 #endif
-#endif

commit b71d1d426d263b0b6cb5760322efebbfc89d4463
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Fri Apr 22 04:53:02 2011 +0000

    inet: constify ip headers and in6_addr
    
    Add const qualifiers to structs iphdr, ipv6hdr and in6_addr pointers
    where possible, to make code intention more obvious.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index fccc2180c61b..3d982f72d48e 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -196,7 +196,7 @@ struct inet6_dev {
 	struct rcu_head		rcu;
 };
 
-static inline void ipv6_eth_mc_map(struct in6_addr *addr, char *buf)
+static inline void ipv6_eth_mc_map(const struct in6_addr *addr, char *buf)
 {
 	/*
 	 *	+-------+-------+-------+-------+-------+-------+
@@ -210,7 +210,7 @@ static inline void ipv6_eth_mc_map(struct in6_addr *addr, char *buf)
 	memcpy(buf + 2, &addr->s6_addr32[3], sizeof(__u32));
 }
 
-static inline void ipv6_tr_mc_map(struct in6_addr *addr, char *buf)
+static inline void ipv6_tr_mc_map(const struct in6_addr *addr, char *buf)
 {
 	/* All nodes FF01::1, FF02::1, FF02::1:FFxx:xxxx */
 

commit 93ca3bb5df9bc8b2c60485e1cc6507c3d7c8e1fa
Author: Timo Teräs <timo.teras@iki.fi>
Date:   Mon Mar 28 22:40:53 2011 +0000

    net: gre: provide multicast mappings for ipv4 and ipv6
    
    My commit 6d55cb91a0020ac0 (gre: fix hard header destination
    address checking) broke multicast.
    
    The reason is that ip_gre used to get ipgre_header() calls with
    zero destination if we have NOARP or multicast destination. Instead
    the actual target was decided at ipgre_tunnel_xmit() time based on
    per-protocol dissection.
    
    Instead of allowing the "abuse" of ->header() calls with invalid
    destination, this creates multicast mappings for ip_gre. This also
    fixes "ip neigh show nud noarp" to display the proper multicast
    mappings used by the gre device.
    
    Reported-by: Doug Kehn <rdkehn@yahoo.com>
    Signed-off-by: Timo Teräs <timo.teras@iki.fi>
    Acked-by: Doug Kehn <rdkehn@yahoo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 04977eefb0ee..fccc2180c61b 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -286,5 +286,21 @@ static inline void ipv6_ib_mc_map(const struct in6_addr *addr,
 	buf[9]  = broadcast[9];
 	memcpy(buf + 10, addr->s6_addr + 6, 10);
 }
+
+static inline int ipv6_ipgre_mc_map(const struct in6_addr *addr,
+				    const unsigned char *broadcast, char *buf)
+{
+	if ((broadcast[0] | broadcast[1] | broadcast[2] | broadcast[3]) != 0) {
+		memcpy(buf, broadcast, 4);
+	} else {
+		/* v4mapped? */
+		if ((addr->s6_addr32[0] | addr->s6_addr32[1] |
+		     (addr->s6_addr32[2] ^ htonl(0x0000ffff))) != 0)
+			return -EINVAL;
+		memcpy(buf, &addr->s6_addr32[3], 4);
+	}
+	return 0;
+}
+
 #endif
 #endif

commit 456b61bca8ee324ab6c18b065e632c9a8c88aa39
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Nov 23 13:12:15 2010 +0000

    ipv6: mcast: RCU conversion
    
    ipv6_sk_mc_lock rwlock becomes a spinlock.
    
    readers (inet6_mc_check()) now takes rcu_read_lock() instead of read
    lock. Writers dont need to disable BH anymore.
    
    struct ipv6_mc_socklist objects are reclaimed after one RCU grace
    period.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index f95ff8d9aa47..04977eefb0ee 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -89,10 +89,11 @@ struct ip6_sf_socklist {
 struct ipv6_mc_socklist {
 	struct in6_addr		addr;
 	int			ifindex;
-	struct ipv6_mc_socklist *next;
+	struct ipv6_mc_socklist __rcu *next;
 	rwlock_t		sflock;
 	unsigned int		sfmode;		/* MCAST_{INCLUDE,EXCLUDE} */
 	struct ip6_sf_socklist	*sflist;
+	struct rcu_head		rcu;
 };
 
 struct ip6_sf_list {

commit e9d3e084975869754d16f639378675c353560be9
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue May 18 15:36:06 2010 -0700

    ipv6: Replace inet6_ifaddr->dead with state
    
    This patch replaces the boolean dead flag on inet6_ifaddr with
    a state enum.  This allows us to roll back changes when deleting
    an address according to whether DAD has completed or not.
    
    This patch only adds the state field and does not change the logic.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 13f9fc086d54..f95ff8d9aa47 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -32,6 +32,13 @@
 
 #ifdef __KERNEL__
 
+enum {
+	INET6_IFADDR_STATE_DAD,
+	INET6_IFADDR_STATE_POSTDAD,
+	INET6_IFADDR_STATE_UP,
+	INET6_IFADDR_STATE_DEAD,
+};
+
 struct inet6_ifaddr {
 	struct in6_addr		addr;
 	__u32			prefix_len;
@@ -40,6 +47,9 @@ struct inet6_ifaddr {
 	__u32			prefered_lft;
 	atomic_t		refcnt;
 	spinlock_t		lock;
+	spinlock_t		state_lock;
+
+	int			state;
 
 	__u8			probes;
 	__u8			flags;
@@ -62,8 +72,6 @@ struct inet6_ifaddr {
 	struct inet6_ifaddr	*ifpub;
 	int			regen_count;
 #endif
-
-	int			dead;
 	struct rcu_head		rcu;
 };
 

commit 502a2ffd7376ae27cfde6172257db0ff9d8cfec2
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Wed Mar 17 20:31:13 2010 +0000

    ipv6: convert idev_list to list macros
    
    Convert to list macro's for the list of addresses per interface
    in IPv6.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 22a00b1d2c38..13f9fc086d54 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -55,7 +55,7 @@ struct inet6_ifaddr {
 	struct rt6_info		*rt;
 
 	struct hlist_node	addr_lst;
-	struct inet6_ifaddr	*if_next;       /* next addr in inet6_dev */
+	struct list_head	if_list;
 
 #ifdef CONFIG_IPV6_PRIVACY
 	struct list_head	tmp_list;
@@ -152,9 +152,9 @@ struct ipv6_devstat {
 };
 
 struct inet6_dev {
-	struct net_device		*dev;
+	struct net_device	*dev;
 
-	struct inet6_ifaddr	*addr_list;
+	struct list_head	addr_list;
 
 	struct ifmcaddr6	*mc_list;
 	struct ifmcaddr6	*mc_tomb;

commit 5c578aedcb21d79eeb4e9cf04ca5b276ac82614c
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Wed Mar 17 20:31:11 2010 +0000

    IPv6: convert addrconf hash list to RCU
    
    Convert from reader/writer lock to RCU and spinlock for addrconf
    hash list.
    
    Adds an additional helper macro for hlist_for_each_entry_continue_rcu
    to handle the continue case.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 498401541519..22a00b1d2c38 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -64,6 +64,7 @@ struct inet6_ifaddr {
 #endif
 
 	int			dead;
+	struct rcu_head		rcu;
 };
 
 struct ip6_sf_socklist {

commit c2e21293c054817c42eb5fa9c613d2ad51954136
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Wed Mar 17 20:31:10 2010 +0000

    ipv6: convert addrconf list to hlist
    
    Using hash list macros, simplifies code and helps later RCU.
    
    This patch includes some initialization that is not strictly necessary,
    since an empty hlist node/list is all zero; and list is in BSS
    and node is allocated with kzalloc.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 09d906460a43..498401541519 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -54,7 +54,7 @@ struct inet6_ifaddr {
 	struct inet6_dev	*idev;
 	struct rt6_info		*rt;
 
-	struct inet6_ifaddr	*lst_next;      /* next addr in addr_lst */
+	struct hlist_node	addr_lst;
 	struct inet6_ifaddr	*if_next;       /* next addr in inet6_dev */
 
 #ifdef CONFIG_IPV6_PRIVACY

commit 372e6c8f1f7b2bb68f9992d2e664925c73552a1d
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Wed Mar 17 20:31:09 2010 +0000

    ipv6: convert temporary address list to list macros
    
    Use list macros instead of open coded linked list.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 545d8b059bef..09d906460a43 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -58,7 +58,7 @@ struct inet6_ifaddr {
 	struct inet6_ifaddr	*if_next;       /* next addr in inet6_dev */
 
 #ifdef CONFIG_IPV6_PRIVACY
-	struct inet6_ifaddr	*tmp_next;	/* next addr in tempaddr_lst */
+	struct list_head	tmp_list;
 	struct inet6_ifaddr	*ifpub;
 	int			regen_count;
 #endif
@@ -175,7 +175,7 @@ struct inet6_dev {
 #ifdef CONFIG_IPV6_PRIVACY
 	u8			rndid[8];
 	struct timer_list	regen_timer;
-	struct inet6_ifaddr	*tempaddr_list;
+	struct list_head	tempaddr_list;
 #endif
 
 	struct neigh_parms	*nd_parms;

commit 6457d26bd40077238799e31df2b800bcf4ef9177
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Feb 17 18:48:44 2010 -0800

    IPv6: convert mc_lock to spinlock
    
    Only used for writing, so convert to spinlock
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index e9d69d198495..545d8b059bef 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -157,7 +157,7 @@ struct inet6_dev {
 
 	struct ifmcaddr6	*mc_list;
 	struct ifmcaddr6	*mc_tomb;
-	rwlock_t		mc_lock;
+	spinlock_t		mc_lock;
 	unsigned char		mc_qrv;
 	unsigned char		mc_gq_running;
 	unsigned char		mc_ifc_count;

commit fd2c3ef761fbc5e6c27fa7d40b30cda06bfcd7d8
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Nov 3 03:26:03 2009 +0000

    net: cleanup include/net
    
    This cleanup patch puts struct/union/enum opening braces,
    in first line to ease grep games.
    
    struct something
    {
    
    becomes :
    
    struct something {
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 38b78132019b..e9d69d198495 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -32,8 +32,7 @@
 
 #ifdef __KERNEL__
 
-struct inet6_ifaddr 
-{
+struct inet6_ifaddr {
 	struct in6_addr		addr;
 	__u32			prefix_len;
 	
@@ -67,8 +66,7 @@ struct inet6_ifaddr
 	int			dead;
 };
 
-struct ip6_sf_socklist
-{
+struct ip6_sf_socklist {
 	unsigned int		sl_max;
 	unsigned int		sl_count;
 	struct in6_addr		sl_addr[0];
@@ -79,8 +77,7 @@ struct ip6_sf_socklist
 
 #define IP6_SFBLOCK	10	/* allocate this many at once */
 
-struct ipv6_mc_socklist
-{
+struct ipv6_mc_socklist {
 	struct in6_addr		addr;
 	int			ifindex;
 	struct ipv6_mc_socklist *next;
@@ -89,8 +86,7 @@ struct ipv6_mc_socklist
 	struct ip6_sf_socklist	*sflist;
 };
 
-struct ip6_sf_list
-{
+struct ip6_sf_list {
 	struct ip6_sf_list	*sf_next;
 	struct in6_addr		sf_addr;
 	unsigned long		sf_count[2];	/* include/exclude counts */
@@ -105,8 +101,7 @@ struct ip6_sf_list
 #define MAF_NOREPORT		0x08
 #define MAF_GSQUERY		0x10
 
-struct ifmcaddr6
-{
+struct ifmcaddr6 {
 	struct in6_addr		mca_addr;
 	struct inet6_dev	*idev;
 	struct ifmcaddr6	*next;
@@ -126,15 +121,13 @@ struct ifmcaddr6
 
 /* Anycast stuff */
 
-struct ipv6_ac_socklist
-{
+struct ipv6_ac_socklist {
 	struct in6_addr		acl_addr;
 	int			acl_ifindex;
 	struct ipv6_ac_socklist *acl_next;
 };
 
-struct ifacaddr6
-{
+struct ifacaddr6 {
 	struct in6_addr		aca_addr;
 	struct inet6_dev	*aca_idev;
 	struct rt6_info		*aca_rt;
@@ -157,8 +150,7 @@ struct ipv6_devstat {
 	DEFINE_SNMP_STAT(struct icmpv6msg_mib, icmpv6msg);
 };
 
-struct inet6_dev 
-{
+struct inet6_dev {
 	struct net_device		*dev;
 
 	struct inet6_ifaddr	*addr_list;

commit 04ec5cfcfd9a69c16fc8adb9d7f4836eedb84e53
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Sat Mar 21 13:29:05 2009 -0700

    ipv6: reorder struct inet6_ifaddr to remove padding on 64 bit builds
    
    reorder struct inet6_ifaddr to remove padding on 64 bit builds
    
    remove 8 bytes of padding so inet6_ifaddr becomes 192 bytes & fits into
    a smaller slab.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index c8effa4b1feb..38b78132019b 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -39,8 +39,6 @@ struct inet6_ifaddr
 	
 	__u32			valid_lft;
 	__u32			prefered_lft;
-	unsigned long		cstamp;	/* created timestamp */
-	unsigned long		tstamp; /* updated timestamp */
 	atomic_t		refcnt;
 	spinlock_t		lock;
 
@@ -49,6 +47,9 @@ struct inet6_ifaddr
 
 	__u16			scope;
 
+	unsigned long		cstamp;	/* created timestamp */
+	unsigned long		tstamp; /* updated timestamp */
+
 	struct timer_list	timer;
 
 	struct inet6_dev	*idev;

commit 888c848ed34bd5f8cb56567624c0d951ab35174e
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jul 22 14:21:58 2008 -0700

    ipv6: make struct ipv6_devconf static
    
    struct ipv6_devconf can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index db66c7927743..c8effa4b1feb 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -193,8 +193,6 @@ struct inet6_dev
 	struct rcu_head		rcu;
 };
 
-extern struct ipv6_devconf ipv6_devconf;
-
 static inline void ipv6_eth_mc_map(struct in6_addr *addr, char *buf)
 {
 	/*

commit 0399e5f07ad7024f70881d44f19d767d3f25a980
Author: Rami Rosen <ramirose@gmail.com>
Date:   Wed Apr 23 14:36:58 2008 +0300

    ipv6 addrconf: Remove IFA_GLOBAL definition from include/net/if_inet6.h.
    
    This patches removes IFA_GLOBAL definition from linux/include/net/if_inet6.h
    as it is unused.
    
    Signed-off-by: Rami Rosen <ramirose@gmail.com>
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index b2cfc4927257..db66c7927743 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -148,7 +148,6 @@ struct ifacaddr6
 #define	IFA_HOST	IPV6_ADDR_LOOPBACK
 #define	IFA_LINK	IPV6_ADDR_LINKLOCAL
 #define	IFA_SITE	IPV6_ADDR_SITELOCAL
-#define	IFA_GLOBAL	0x0000U
 
 struct ipv6_devstat {
 	struct proc_dir_entry	*proc_dir_entry;

commit 246f19d194ec99ee8992106e129a133142dc6a10
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Feb 3 04:09:17 2008 -0800

    [IPV6]: Reorg struct ifmcaddr6 to save some bytes
    
    /home/acme/git/net-2.6/net/ipv6/mcast.c:
      struct ifmcaddr6 |   -8
     1 struct changed
      igmp6_group_dropped  |   -6
      add_grec             |   -3
      mld_ifc_timer_expire |  -18
      ip6_mc_add_src       |   -3
      ip6_mc_del_src       |   -3
      igmp6_group_added    |   -3
     6 functions changed, 36 bytes removed, diff: -36
    
    ipv6.ko:
     6 functions changed, 36 bytes removed, diff: -36
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 66c43e29ea0a..b2cfc4927257 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -112,13 +112,13 @@ struct ifmcaddr6
 	struct ip6_sf_list	*mca_sources;
 	struct ip6_sf_list	*mca_tomb;
 	unsigned int		mca_sfmode;
+	unsigned char		mca_crcount;
 	unsigned long		mca_sfcount[2];
 	struct timer_list	mca_timer;
 	unsigned		mca_flags;
 	int			mca_users;
 	atomic_t		mca_refcnt;
 	spinlock_t		mca_lock;
-	unsigned char		mca_crcount;
 	unsigned long		mca_cstamp;
 	unsigned long		mca_tstamp;
 };

commit 4e7e5cfe3825b4d854fc005d784a6f551b3c039f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Feb 3 04:06:59 2008 -0800

    [INET6]: Reorganize struct inet6_dev to save 8 bytes
    
    And make it a multiple of a 64 bytes, reducing cacheline trashing:
    
    Before:
    
    [acme@doppio net-2.6]$ pahole -C inet6_dev net/dccp/ipv6.o
    struct inet6_dev {
            <SNIP>
            long unsigned int          mc_maxdelay;          /*    48     8 */
            unsigned char              mc_qrv;               /*    56     1 */
            unsigned char              mc_gq_running;        /*    57     1 */
            unsigned char              mc_ifc_count;         /*    58     1 */
    
            /* XXX 5 bytes hole, try to pack */
    
            /* --- cacheline 1 boundary (64 bytes) --- */
            struct timer_list          mc_gq_timer;          /*    64    48 */
            <SNIP>
            __u32                      if_flags;             /*   180     4 */
            int                        dead;                 /*   184     4 */
            u8                         rndid[8];             /*   188     8 */
    
            /* XXX 4 bytes hole, try to pack */
    
            /* --- cacheline 3 boundary (192 bytes) was 8 bytes ago --- */
            struct timer_list          regen_timer;          /*   200    48 */
    
            <SNIP>
    
            /* size: 456, cachelines: 8 */
            /* sum members: 447, holes: 2, sum holes: 9 */
            /* last cacheline: 8 bytes */
    };
    
    After:
    
    net-2.6/net/ipv6/af_inet6.c:
      struct inet6_dev |   -8
     1 struct changed
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index b24508abb850..66c43e29ea0a 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -166,11 +166,11 @@ struct inet6_dev
 	struct ifmcaddr6	*mc_list;
 	struct ifmcaddr6	*mc_tomb;
 	rwlock_t		mc_lock;
-	unsigned long		mc_v1_seen;
-	unsigned long		mc_maxdelay;
 	unsigned char		mc_qrv;
 	unsigned char		mc_gq_running;
 	unsigned char		mc_ifc_count;
+	unsigned long		mc_v1_seen;
+	unsigned long		mc_maxdelay;
 	struct timer_list	mc_gq_timer;	/* general query timer */
 	struct timer_list	mc_ifc_timer;	/* interface change timer */
 

commit a9e527e3f9f4510e9f3450ca3bc51bc3ef2854fd
Author: Rolf Manderscheid <rvm@obsidianresearch.com>
Date:   Mon Dec 10 13:38:41 2007 -0700

    IPoIB: improve IPv4/IPv6 to IB mcast mapping functions
    
    An IPoIB subnet on an IB fabric that spans multiple IB subnets can't
    use link-local scope in multicast GIDs.  The existing routines that
    map IP/IPv6 multicast addresses into IB link-level addresses hard-code
    the scope to link-local, and they also leave the partition key field
    uninitialised.  This patch adds a parameter (the link-level broadcast
    address) to the mapping routines, allowing them to initialise both the
    scope and the P_Key appropriately, and fixes up the call sites.
    
    The next step will be to add a way to configure the scope for an IPoIB
    interface.
    
    Signed-off-by: Rolf Manderscheid <rvm@obsidianresearch.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 448eccb20638..b24508abb850 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -269,18 +269,21 @@ static inline void ipv6_arcnet_mc_map(const struct in6_addr *addr, char *buf)
 	buf[0] = 0x00;
 }
 
-static inline void ipv6_ib_mc_map(struct in6_addr *addr, char *buf)
+static inline void ipv6_ib_mc_map(const struct in6_addr *addr,
+				  const unsigned char *broadcast, char *buf)
 {
+	unsigned char scope = broadcast[5] & 0xF;
+
 	buf[0]  = 0;		/* Reserved */
 	buf[1]  = 0xff;		/* Multicast QPN */
 	buf[2]  = 0xff;
 	buf[3]  = 0xff;
 	buf[4]  = 0xff;
-	buf[5]  = 0x12;		/* link local scope */
+	buf[5]  = 0x10 | scope;	/* scope from broadcast address */
 	buf[6]  = 0x60;		/* IPv6 signature */
 	buf[7]  = 0x1b;
-	buf[8]  = 0;		/* P_Key */
-	buf[9]  = 0;
+	buf[8]  = broadcast[8];	/* P_Key */
+	buf[9]  = broadcast[9];
 	memcpy(buf + 10, addr->s6_addr + 6, 10);
 }
 #endif

commit 14878f75abd5bf1d38becb405801cd491ee215dc
Author: David L Stevens <dlstevens@us.ibm.com>
Date:   Sun Sep 16 16:52:35 2007 -0700

    [IPV6]: Add ICMPMsgStats MIB (RFC 4293) [rev 2]
    
    Background: RFC 4293 deprecates existing individual, named ICMP
    type counters to be replaced with the ICMPMsgStatsTable. This table
    includes entries for both IPv4 and IPv6, and requires counting of all
    ICMP types, whether or not the machine implements the type.
    
    These patches "remove" (but not really) the existing counters, and
    replace them with the ICMPMsgStats tables for v4 and v6.
    It includes the named counters in the /proc places they were, but gets the
    values for them from the new tables. It also counts packets generated
    from raw socket output (e.g., OutEchoes, MLD queries, RA's from
    radvd, etc).
    
    Changes:
    1) create icmpmsg_statistics mib
    2) create icmpv6msg_statistics mib
    3) modify existing counters to use these
    4) modify /proc/net/snmp to add "IcmpMsg" with all ICMP types
            listed by number for easy SNMP parsing
    5) modify /proc/net/snmp printing for "Icmp" to get the named data
            from new counters.
    [new to 2nd revision]
    6) support per-interface ICMP stats
    7) use common macro for per-device stat macros
    
    Signed-off-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 3ec7d07346d6..448eccb20638 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -154,6 +154,7 @@ struct ipv6_devstat {
 	struct proc_dir_entry	*proc_dir_entry;
 	DEFINE_SNMP_STAT(struct ipstats_mib, ipv6);
 	DEFINE_SNMP_STAT(struct icmpv6_mib, icmpv6);
+	DEFINE_SNMP_STAT(struct icmpv6msg_mib, icmpv6msg);
 };
 
 struct inet6_dev 

commit a11d206d0f88e092419877c7f706cafb5e1c2e57
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Sat Nov 4 20:11:37 2006 +0900

    [IPV6]: Per-interface statistics support.
    
    For IP MIB (RFC4293).
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index 34489c13c119..3ec7d07346d6 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -152,6 +152,7 @@ struct ifacaddr6
 
 struct ipv6_devstat {
 	struct proc_dir_entry	*proc_dir_entry;
+	DEFINE_SNMP_STAT(struct ipstats_mib, ipv6);
 	DEFINE_SNMP_STAT(struct icmpv6_mib, icmpv6);
 };
 

commit 8814c4b533817df825485ff32ce6ac406c3a54d1
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Sep 22 14:44:24 2006 -0700

    [IPV6] ADDRCONF: Convert addrconf_lock to RCU.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index e459e1a0ae4a..34489c13c119 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -189,6 +189,7 @@ struct inet6_dev
 	struct ipv6_devconf	cnf;
 	struct ipv6_devstat	stats;
 	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */
+	struct rcu_head		rcu;
 };
 
 extern struct ipv6_devconf ipv6_devconf;

commit 955189efb44742890f33c91df478877af25246da
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 20 16:54:09 2006 -0800

    [IPV6]: ADDRCONF: Use our standard algorithm for randomized ifid.
    
    RFC 3041 describes an algorithm to generate random interface
    identifier.  In RFC 3041bis, it is allowed to use different
    algorithm than one described in RFC 3041.
    
    So, let's use our standard pseudo random algorithm to simplify
    our implementation.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index eb8afe3499a9..e459e1a0ae4a 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -180,11 +180,8 @@ struct inet6_dev
 
 #ifdef CONFIG_IPV6_PRIVACY
 	u8			rndid[8];
-	u8			entropy[8];
 	struct timer_list	regen_timer;
 	struct inet6_ifaddr	*tempaddr_list;
-	__u8			work_eui64[8];
-	__u8			work_digest[16];
 #endif
 
 	struct neigh_parms	*nd_parms;

commit 5ab4a6c81eb3dbe32361791d1535f9153f79b0ed
Author: David L Stevens <dlstevens@us.ibm.com>
Date:   Tue Dec 27 14:03:00 2005 -0800

    [IPV6] mcast: Fix multiple issues in MLDv2 reports.
    
    The below "jumbo" patch fixes the following problems in MLDv2.
    
    1) Add necessary "ntohs" to recent "pskb_may_pull" check [breaks
            all nonzero source queries on little-endian (!)]
    
    2) Add locking to source filter list [resend of prior patch]
    
    3) fix "mld_marksources()" to
            a) send nothing when all queried sources are excluded
            b) send full exclude report when source queried sources are
                    not excluded
            c) don't schedule a timer when there's nothing to report
    
    NOTE: RFC 3810 specifies the source list should be saved and each
      source reported individually as an IS_IN. This is an obvious DOS
      path, requiring the host to store and then multicast as many sources
      as are queried (e.g., millions...). This alternative sends a full,
      relevant report that's limited to number of sources present on the
      machine.
    
    4) fix "add_grec()" to send empty-source records when it should
            The original check doesn't account for a non-empty source
            list with all sources inactive; the new code keeps that
            short-circuit case, and also generates the group header
            with an empty list if needed.
    
    5) fix mca_crcount decrement to be after add_grec(), which needs
            its original value
    
    These issues (other than item #1 ;-) ) were all found by Yan Zheng,
    much thanks!
    
    Signed-off-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index d8234f9bd4c4..eb8afe3499a9 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -83,6 +83,7 @@ struct ipv6_mc_socklist
 	struct in6_addr		addr;
 	int			ifindex;
 	struct ipv6_mc_socklist *next;
+	rwlock_t		sflock;
 	unsigned int		sfmode;		/* MCAST_{INCLUDE,EXCLUDE} */
 	struct ip6_sf_socklist	*sflist;
 };

commit 3c21edbd113788b110116141c8078623a0900b6a
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Wed Dec 21 22:57:24 2005 +0900

    [IPV6]: Defer IPv6 device initialization until the link becomes ready.
    
    NETDEV_UP might be sent even if the link attached to the interface was
    not ready.  DAD does not make sense in such case, so we won't do so.
    After interface
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
index e97a9accb71d..d8234f9bd4c4 100644
--- a/include/net/if_inet6.h
+++ b/include/net/if_inet6.h
@@ -24,6 +24,7 @@
 #define IF_RA_MANAGED	0x40
 #define IF_RA_RCVD	0x20
 #define IF_RS_SENT	0x10
+#define IF_READY	0x80000000
 
 /* prefix flags */
 #define IF_PREFIX_ONLINK	0x01

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/net/if_inet6.h b/include/net/if_inet6.h
new file mode 100644
index 000000000000..e97a9accb71d
--- /dev/null
+++ b/include/net/if_inet6.h
@@ -0,0 +1,285 @@
+/*
+ *	inet6 interface/address list definitions
+ *	Linux INET6 implementation 
+ *
+ *	Authors:
+ *	Pedro Roque		<roque@di.fc.ul.pt>	
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _NET_IF_INET6_H
+#define _NET_IF_INET6_H
+
+#include <net/snmp.h>
+#include <linux/ipv6.h>
+
+/* inet6_dev.if_flags */
+
+#define IF_RA_OTHERCONF	0x80
+#define IF_RA_MANAGED	0x40
+#define IF_RA_RCVD	0x20
+#define IF_RS_SENT	0x10
+
+/* prefix flags */
+#define IF_PREFIX_ONLINK	0x01
+#define IF_PREFIX_AUTOCONF	0x02
+
+#ifdef __KERNEL__
+
+struct inet6_ifaddr 
+{
+	struct in6_addr		addr;
+	__u32			prefix_len;
+	
+	__u32			valid_lft;
+	__u32			prefered_lft;
+	unsigned long		cstamp;	/* created timestamp */
+	unsigned long		tstamp; /* updated timestamp */
+	atomic_t		refcnt;
+	spinlock_t		lock;
+
+	__u8			probes;
+	__u8			flags;
+
+	__u16			scope;
+
+	struct timer_list	timer;
+
+	struct inet6_dev	*idev;
+	struct rt6_info		*rt;
+
+	struct inet6_ifaddr	*lst_next;      /* next addr in addr_lst */
+	struct inet6_ifaddr	*if_next;       /* next addr in inet6_dev */
+
+#ifdef CONFIG_IPV6_PRIVACY
+	struct inet6_ifaddr	*tmp_next;	/* next addr in tempaddr_lst */
+	struct inet6_ifaddr	*ifpub;
+	int			regen_count;
+#endif
+
+	int			dead;
+};
+
+struct ip6_sf_socklist
+{
+	unsigned int		sl_max;
+	unsigned int		sl_count;
+	struct in6_addr		sl_addr[0];
+};
+
+#define IP6_SFLSIZE(count)	(sizeof(struct ip6_sf_socklist) + \
+	(count) * sizeof(struct in6_addr))
+
+#define IP6_SFBLOCK	10	/* allocate this many at once */
+
+struct ipv6_mc_socklist
+{
+	struct in6_addr		addr;
+	int			ifindex;
+	struct ipv6_mc_socklist *next;
+	unsigned int		sfmode;		/* MCAST_{INCLUDE,EXCLUDE} */
+	struct ip6_sf_socklist	*sflist;
+};
+
+struct ip6_sf_list
+{
+	struct ip6_sf_list	*sf_next;
+	struct in6_addr		sf_addr;
+	unsigned long		sf_count[2];	/* include/exclude counts */
+	unsigned char		sf_gsresp;	/* include in g & s response? */
+	unsigned char		sf_oldin;	/* change state */
+	unsigned char		sf_crcount;	/* retrans. left to send */
+};
+
+#define MAF_TIMER_RUNNING	0x01
+#define MAF_LAST_REPORTER	0x02
+#define MAF_LOADED		0x04
+#define MAF_NOREPORT		0x08
+#define MAF_GSQUERY		0x10
+
+struct ifmcaddr6
+{
+	struct in6_addr		mca_addr;
+	struct inet6_dev	*idev;
+	struct ifmcaddr6	*next;
+	struct ip6_sf_list	*mca_sources;
+	struct ip6_sf_list	*mca_tomb;
+	unsigned int		mca_sfmode;
+	unsigned long		mca_sfcount[2];
+	struct timer_list	mca_timer;
+	unsigned		mca_flags;
+	int			mca_users;
+	atomic_t		mca_refcnt;
+	spinlock_t		mca_lock;
+	unsigned char		mca_crcount;
+	unsigned long		mca_cstamp;
+	unsigned long		mca_tstamp;
+};
+
+/* Anycast stuff */
+
+struct ipv6_ac_socklist
+{
+	struct in6_addr		acl_addr;
+	int			acl_ifindex;
+	struct ipv6_ac_socklist *acl_next;
+};
+
+struct ifacaddr6
+{
+	struct in6_addr		aca_addr;
+	struct inet6_dev	*aca_idev;
+	struct rt6_info		*aca_rt;
+	struct ifacaddr6	*aca_next;
+	int			aca_users;
+	atomic_t		aca_refcnt;
+	spinlock_t		aca_lock;
+	unsigned long		aca_cstamp;
+	unsigned long		aca_tstamp;
+};
+
+#define	IFA_HOST	IPV6_ADDR_LOOPBACK
+#define	IFA_LINK	IPV6_ADDR_LINKLOCAL
+#define	IFA_SITE	IPV6_ADDR_SITELOCAL
+#define	IFA_GLOBAL	0x0000U
+
+struct ipv6_devstat {
+	struct proc_dir_entry	*proc_dir_entry;
+	DEFINE_SNMP_STAT(struct icmpv6_mib, icmpv6);
+};
+
+struct inet6_dev 
+{
+	struct net_device		*dev;
+
+	struct inet6_ifaddr	*addr_list;
+
+	struct ifmcaddr6	*mc_list;
+	struct ifmcaddr6	*mc_tomb;
+	rwlock_t		mc_lock;
+	unsigned long		mc_v1_seen;
+	unsigned long		mc_maxdelay;
+	unsigned char		mc_qrv;
+	unsigned char		mc_gq_running;
+	unsigned char		mc_ifc_count;
+	struct timer_list	mc_gq_timer;	/* general query timer */
+	struct timer_list	mc_ifc_timer;	/* interface change timer */
+
+	struct ifacaddr6	*ac_list;
+	rwlock_t		lock;
+	atomic_t		refcnt;
+	__u32			if_flags;
+	int			dead;
+
+#ifdef CONFIG_IPV6_PRIVACY
+	u8			rndid[8];
+	u8			entropy[8];
+	struct timer_list	regen_timer;
+	struct inet6_ifaddr	*tempaddr_list;
+	__u8			work_eui64[8];
+	__u8			work_digest[16];
+#endif
+
+	struct neigh_parms	*nd_parms;
+	struct inet6_dev	*next;
+	struct ipv6_devconf	cnf;
+	struct ipv6_devstat	stats;
+	unsigned long		tstamp; /* ipv6InterfaceTable update timestamp */
+};
+
+extern struct ipv6_devconf ipv6_devconf;
+
+static inline void ipv6_eth_mc_map(struct in6_addr *addr, char *buf)
+{
+	/*
+	 *	+-------+-------+-------+-------+-------+-------+
+	 *      |   33  |   33  | DST13 | DST14 | DST15 | DST16 |
+	 *      +-------+-------+-------+-------+-------+-------+
+	 */
+
+	buf[0]= 0x33;
+	buf[1]= 0x33;
+
+	memcpy(buf + 2, &addr->s6_addr32[3], sizeof(__u32));
+}
+
+static inline void ipv6_tr_mc_map(struct in6_addr *addr, char *buf)
+{
+	/* All nodes FF01::1, FF02::1, FF02::1:FFxx:xxxx */
+
+	if (((addr->s6_addr[0] == 0xFF) &&
+	    ((addr->s6_addr[1] == 0x01) || (addr->s6_addr[1] == 0x02)) &&
+	     (addr->s6_addr16[1] == 0) &&
+	     (addr->s6_addr32[1] == 0) &&
+	     (addr->s6_addr32[2] == 0) &&
+	     (addr->s6_addr16[6] == 0) &&
+	     (addr->s6_addr[15] == 1)) ||
+	    ((addr->s6_addr[0] == 0xFF) &&
+	     (addr->s6_addr[1] == 0x02) &&
+	     (addr->s6_addr16[1] == 0) &&
+	     (addr->s6_addr32[1] == 0) &&
+	     (addr->s6_addr16[4] == 0) &&
+	     (addr->s6_addr[10] == 0) &&
+	     (addr->s6_addr[11] == 1) &&
+	     (addr->s6_addr[12] == 0xff)))
+	{
+		buf[0]=0xC0;
+		buf[1]=0x00;
+		buf[2]=0x01;
+		buf[3]=0x00;
+		buf[4]=0x00;
+		buf[5]=0x00;
+	/* All routers FF0x::2 */
+	} else if ((addr->s6_addr[0] ==0xff) &&
+		((addr->s6_addr[1] & 0xF0) == 0) &&
+		(addr->s6_addr16[1] == 0) &&
+		(addr->s6_addr32[1] == 0) &&
+		(addr->s6_addr32[2] == 0) &&
+		(addr->s6_addr16[6] == 0) &&
+		(addr->s6_addr[15] == 2))
+	{
+		buf[0]=0xC0;
+		buf[1]=0x00;
+		buf[2]=0x02;
+		buf[3]=0x00;
+		buf[4]=0x00;
+		buf[5]=0x00;
+	} else {
+		unsigned char i ; 
+		
+		i = addr->s6_addr[15] & 7 ; 
+		buf[0]=0xC0;
+		buf[1]=0x00;
+		buf[2]=0x00;
+		buf[3]=0x01 << i ; 
+		buf[4]=0x00;
+		buf[5]=0x00;
+	}
+}
+
+static inline void ipv6_arcnet_mc_map(const struct in6_addr *addr, char *buf)
+{
+	buf[0] = 0x00;
+}
+
+static inline void ipv6_ib_mc_map(struct in6_addr *addr, char *buf)
+{
+	buf[0]  = 0;		/* Reserved */
+	buf[1]  = 0xff;		/* Multicast QPN */
+	buf[2]  = 0xff;
+	buf[3]  = 0xff;
+	buf[4]  = 0xff;
+	buf[5]  = 0x12;		/* link local scope */
+	buf[6]  = 0x60;		/* IPv6 signature */
+	buf[7]  = 0x1b;
+	buf[8]  = 0;		/* P_Key */
+	buf[9]  = 0;
+	memcpy(buf + 10, addr->s6_addr + 6, 10);
+}
+#endif
+#endif
