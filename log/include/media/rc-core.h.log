commit e6c6d7d4a15d499821c41b7e43d92b29c98293ad
Author: Sean Young <sean@mess.org>
Date:   Fri Jan 17 17:46:36 2020 +0100

    media: rc: make scancodes 64 bit
    
    There are many protocols that encode more than 32 bit. We want 64 bit
    support so that BPF IR decoders can decode more than 32 bit. None of
    the existing kernel IR decoders/encoders support 64 bit, for now.
    
    The MSC_SCAN event can only contain 32 bit scancodes, so we only generate
    MSC_SCAN events if the scancode fits into 32 bits. The full 64 bit
    scancode can be read from the lirc chardev.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 1f695d9c200a..d3f85df64bb2 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -192,7 +192,7 @@ struct rc_dev {
 	struct timer_list		timer_repeat;
 	u32				last_keycode;
 	enum rc_proto			last_protocol;
-	u32				last_scancode;
+	u64				last_scancode;
 	u8				last_toggle;
 	u32				timeout;
 	u32				min_timeout;
@@ -284,12 +284,12 @@ int devm_rc_register_device(struct device *parent, struct rc_dev *dev);
 void rc_unregister_device(struct rc_dev *dev);
 
 void rc_repeat(struct rc_dev *dev);
-void rc_keydown(struct rc_dev *dev, enum rc_proto protocol, u32 scancode,
+void rc_keydown(struct rc_dev *dev, enum rc_proto protocol, u64 scancode,
 		u8 toggle);
 void rc_keydown_notimeout(struct rc_dev *dev, enum rc_proto protocol,
-			  u32 scancode, u8 toggle);
+			  u64 scancode, u8 toggle);
 void rc_keyup(struct rc_dev *dev);
-u32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
+u32 rc_g_keycode_from_table(struct rc_dev *dev, u64 scancode);
 
 /*
  * From rc-raw.c

commit 8e8e69d67e5fad1a1edf97acebd649a6c8f1febd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 285
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 100 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.918357685@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index c0cfbe16a854..1f695d9c200a 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -1,16 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Remote Controller core header
  *
  * Copyright (C) 2009-2010 by Mauro Carvalho Chehab
- *
- * This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #ifndef _RC_CORE

commit 183e19f5b9ee18fc7bc4b3983a91b5d0dd6c7871
Author: Sean Young <sean@mess.org>
Date:   Tue Aug 21 15:57:52 2018 -0400

    media: rc: Remove init_ir_raw_event and DEFINE_IR_RAW_EVENT macros
    
    This can be done with c99 initializers, which makes the code cleaner
    and more transparent. It does require gcc 4.6, because of this bug
    in earlier versions:
    
            https://gcc.gnu.org/bugzilla/show_bug.cgi?id=10676
    
    Since commit cafa0010cd51 ("Raise the minimum required gcc version to
    4.6"), this is the case.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 61571773a98d..c0cfbe16a854 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -317,13 +317,6 @@ struct ir_raw_event {
 	unsigned                carrier_report:1;
 };
 
-#define DEFINE_IR_RAW_EVENT(event) struct ir_raw_event event = {}
-
-static inline void init_ir_raw_event(struct ir_raw_event *ev)
-{
-	memset(ev, 0, sizeof(*ev));
-}
-
 #define IR_DEFAULT_TIMEOUT	MS_TO_NS(125)
 #define IR_MAX_DURATION         500000000	/* 500 ms */
 #define US_TO_NS(usec)		((usec) * 1000)
@@ -344,9 +337,7 @@ int ir_raw_encode_carrier(enum rc_proto protocol);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
 {
-	struct ir_raw_event ev = { .reset = true };
-
-	ir_raw_event_store(dev, &ev);
+	ir_raw_event_store(dev, &((struct ir_raw_event) { .reset = true }));
 	dev->idle = true;
 	ir_raw_event_handle(dev);
 }

commit e0d51e6ceff818c5d7a812c26bbd1bb84348a71a
Author: Sean Young <sean@mess.org>
Date:   Thu May 10 16:41:15 2018 -0400

    media: rc: default to idle on at startup or after reset
    
    Any spaces events received after a reset or startup should be discarded,
    so ensure the rc device is in idle mode.
    
    This also makes it much easier to detect incorrect raw events, as we will
    do in a following commit.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 6742fd86ff65..61571773a98d 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -347,6 +347,7 @@ static inline void ir_raw_event_reset(struct rc_dev *dev)
 	struct ir_raw_event ev = { .reset = true };
 
 	ir_raw_event_store(dev, &ev);
+	dev->idle = true;
 	ir_raw_event_handle(dev);
 }
 

commit 8d7a77ce56cdb5f50b83ca0c59a31362e1a5eeb4
Author: Sean Young <sean@mess.org>
Date:   Thu Mar 8 09:42:44 2018 -0500

    media: rc: meson-ir: add timeout on idle
    
    Meson doesn't seem to be able to generate timeout events in hardware. So
    install a software timer to generate the timeout events required by the
    decoders to prevent "ghost keypresses".
    
    Reported-by: Matthias Reichl <hias@horus.com>
    Tested-by: Matthias Reichl <hias@horus.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index fc3a92668bab..6742fd86ff65 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -334,7 +334,9 @@ void ir_raw_event_handle(struct rc_dev *dev);
 int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);
 int ir_raw_event_store_edge(struct rc_dev *dev, bool pulse);
 int ir_raw_event_store_with_filter(struct rc_dev *dev,
-				struct ir_raw_event *ev);
+				   struct ir_raw_event *ev);
+int ir_raw_event_store_with_timeout(struct rc_dev *dev,
+				    struct ir_raw_event *ev);
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
 int ir_raw_encode_scancode(enum rc_proto protocol, u32 scancode,
 			   struct ir_raw_event *events, unsigned int max);

commit 1f17f684d9ea3aafccbb5d727b19c5ffafb07e75
Author: Sean Young <sean@mess.org>
Date:   Mon Feb 12 07:27:50 2018 -0500

    media: rc: remove IR_dprintk() from rc-core
    
    Use dev_dbg() rather than custom debug function.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index aed4272d47f5..fc3a92668bab 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -23,13 +23,6 @@
 #include <linux/timer.h>
 #include <media/rc-map.h>
 
-extern int rc_core_debug;
-#define IR_dprintk(level, fmt, ...)				\
-do {								\
-	if (rc_core_debug >= level)				\
-		printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);	\
-} while (0)
-
 /**
  * enum rc_driver_type - type of the RC driver.
  *

commit f4ab70e3d241f70b9ad43efa8898cbddfe7a6bc5
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun Sep 24 05:24:58 2017 -0400

    media: rc-core.h: minor adjustments at rc_driver_type doc
    
    The description of this enum doesn't match what it
    actually represents. Adjust it.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 0a4026cf64f3..aed4272d47f5 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -31,9 +31,9 @@ do {								\
 } while (0)
 
 /**
- * enum rc_driver_type - type of the RC output
+ * enum rc_driver_type - type of the RC driver.
  *
- * @RC_DRIVER_SCANCODE:	 Driver or hardware generates a scancode
+ * @RC_DRIVER_SCANCODE:	 Driver or hardware generates a scancode.
  * @RC_DRIVER_IR_RAW:	 Driver or hardware generates pulse/space sequences.
  *			 It needs a Infra-Red pulse/space decoder
  * @RC_DRIVER_IR_RAW_TX: Device transmitter only,

commit 57c642cb45d6f7d0d950c3bc67439989062ac743
Author: Sean Young <sean@mess.org>
Date:   Thu Nov 23 17:37:10 2017 -0500

    media: cec: move cec autorepeat handling to rc-core
    
    CEC autorepeat is different than other protocols. Autorepeat is triggered
    by the first repeated user control pressed CEC message, rather than a
    fixed REP_DELAY.
    
    This change also does away with the KEY_UP event directly after the first
    KEY_DOWN event, which was used to stop autorepeat from starting.
    
    See commit a9a249a2c997 ("media: cec: fix remote control passthrough")
    for the original change.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 3a47a25a6593..0a4026cf64f3 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -134,6 +134,8 @@ struct lirc_fh {
  * @keypressed: whether a key is currently pressed
  * @keyup_jiffies: time (in jiffies) when the current keypress should be released
  * @timer_keyup: timer for releasing a keypress
+ * @timer_repeat: timer for autorepeat events. This is needed for CEC, which
+ *	has non-standard repeats.
  * @last_keycode: keycode of last keypress
  * @last_protocol: protocol of last keypress
  * @last_scancode: scancode of last keypress
@@ -202,6 +204,7 @@ struct rc_dev {
 	bool				keypressed;
 	unsigned long			keyup_jiffies;
 	struct timer_list		timer_keyup;
+	struct timer_list		timer_repeat;
 	u32				last_keycode;
 	enum rc_proto			last_protocol;
 	u32				last_scancode;

commit 7e45d660e4d487aa2cbeb003bd4338433feba30a
Author: Sean Young <sean@mess.org>
Date:   Thu Nov 2 17:21:13 2017 -0400

    media: lirc: allow lirc device to be opened more than once
    
    This makes it possible for lircd to read from a lirc chardev, and not
    keep it busy.
    
    Note that this changes the default for timeout reports to on. lircd
    already enables timeout reports when it opens a lirc device, leaving
    them on until the next reboot.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index fbf1648d2ec9..3a47a25a6593 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -68,6 +68,33 @@ enum rc_filter_type {
 	RC_FILTER_MAX
 };
 
+/**
+ * struct lirc_fh - represents an open lirc file
+ * @list: list of open file handles
+ * @rc: rcdev for this lirc chardev
+ * @carrier_low: when setting the carrier range, first the low end must be
+ *	set with an ioctl and then the high end with another ioctl
+ * @send_timeout_reports: report timeouts in lirc raw IR.
+ * @rawir: queue for incoming raw IR
+ * @scancodes: queue for incoming decoded scancodes
+ * @wait_poll: poll struct for lirc device
+ * @send_mode: lirc mode for sending, either LIRC_MODE_SCANCODE or
+ *	LIRC_MODE_PULSE
+ * @rec_mode: lirc mode for receiving, either LIRC_MODE_SCANCODE or
+ *	LIRC_MODE_MODE2
+ */
+struct lirc_fh {
+	struct list_head list;
+	struct rc_dev *rc;
+	int				carrier_low;
+	bool				send_timeout_reports;
+	DECLARE_KFIFO_PTR(rawir, unsigned int);
+	DECLARE_KFIFO_PTR(scancodes, struct lirc_scancode);
+	wait_queue_head_t		wait_poll;
+	u8				send_mode;
+	u8				rec_mode;
+};
+
 /**
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
@@ -118,20 +145,11 @@ enum rc_filter_type {
  * @tx_resolution: resolution (in ns) of output sampler
  * @lirc_dev: lirc device
  * @lirc_cdev: lirc char cdev
- * @lirc_open: count of the number of times the device has been opened
- * @carrier_low: when setting the carrier range, first the low end must be
- *	set with an ioctl and then the high end with another ioctl
  * @gap_start: time when gap starts
  * @gap_duration: duration of initial gap
  * @gap: true if we're in a gap
- * @send_timeout_reports: report timeouts in lirc raw IR.
- * @rawir: queue for incoming raw IR
- * @scancodes: queue for incoming decoded scancodes
- * @wait_poll: poll struct for lirc device
- * @send_mode: lirc mode for sending, either LIRC_MODE_SCANCODE or
- *	LIRC_MODE_PULSE
- * @rec_mode: lirc mode for receiving, either LIRC_MODE_SCANCODE or
- *	LIRC_MODE_MODE2
+ * @lirc_fh_lock: protects lirc_fh list
+ * @lirc_fh: list of open files
  * @registered: set to true by rc_register_device(), false by
  *	rc_unregister_device
  * @change_protocol: allow changing the protocol used on hardware decoders
@@ -196,17 +214,11 @@ struct rc_dev {
 #ifdef CONFIG_LIRC
 	struct device			lirc_dev;
 	struct cdev			lirc_cdev;
-	int				lirc_open;
-	int				carrier_low;
 	ktime_t				gap_start;
 	u64				gap_duration;
 	bool				gap;
-	bool				send_timeout_reports;
-	DECLARE_KFIFO_PTR(rawir, unsigned int);
-	DECLARE_KFIFO_PTR(scancodes, struct lirc_scancode);
-	wait_queue_head_t		wait_poll;
-	u8				send_mode;
-	u8				rec_mode;
+	spinlock_t			lirc_fh_lock;
+	struct list_head		lirc_fh;
 #endif
 	bool				registered;
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);

commit de142c32410649e64d44928505ffad2176a96a9e
Author: Sean Young <sean@mess.org>
Date:   Sat Feb 25 06:51:32 2017 -0500

    media: lirc: implement reading scancode
    
    This implements LIRC_MODE_SCANCODE reading from the lirc device. The
    scancode can be read from the input device too, but with this interface
    you get the rc protocol, keycode, toggle and repeat status in addition
    to just the scancode.
    
    int main()
    {
            int fd, mode, rc;
            fd = open("/dev/lirc0", O_RDWR);
    
            mode = LIRC_MODE_SCANCODE;
            if (ioctl(fd, LIRC_SET_REC_MODE, &mode)) {
                    // kernel too old or lirc does not support transmit
            }
            struct lirc_scancode scancode;
            while (read(fd, &scancode, sizeof(scancode)) == sizeof(scancode)) {
                    printf("protocol:%d scancode:0x%x toggle:%d repeat:%d\n",
                            scancode.rc_proto, scancode.scancode,
                            !!(scancode.flags & LIRC_SCANCODE_FLAG_TOGGLE),
                            !!(scancode.flags & LIRC_SCANCODE_FLAG_REPEAT));
            }
            close(fd);
    }
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 2d24c88652aa..fbf1648d2ec9 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -126,9 +126,12 @@ enum rc_filter_type {
  * @gap: true if we're in a gap
  * @send_timeout_reports: report timeouts in lirc raw IR.
  * @rawir: queue for incoming raw IR
+ * @scancodes: queue for incoming decoded scancodes
  * @wait_poll: poll struct for lirc device
  * @send_mode: lirc mode for sending, either LIRC_MODE_SCANCODE or
  *	LIRC_MODE_PULSE
+ * @rec_mode: lirc mode for receiving, either LIRC_MODE_SCANCODE or
+ *	LIRC_MODE_MODE2
  * @registered: set to true by rc_register_device(), false by
  *	rc_unregister_device
  * @change_protocol: allow changing the protocol used on hardware decoders
@@ -200,8 +203,10 @@ struct rc_dev {
 	bool				gap;
 	bool				send_timeout_reports;
 	DECLARE_KFIFO_PTR(rawir, unsigned int);
+	DECLARE_KFIFO_PTR(scancodes, struct lirc_scancode);
 	wait_queue_head_t		wait_poll;
 	u8				send_mode;
+	u8				rec_mode;
 #endif
 	bool				registered;
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);

commit a6ddd4fecbb02d8ec5a865621bd2b746d585a01c
Author: Sean Young <sean@mess.org>
Date:   Tue Sep 26 09:34:47 2017 -0400

    media: lirc: remove last remnants of lirc kapi
    
    rc-core has replaced the lirc kapi many years ago, and now with the last
    driver ported to rc-core, we can finally remove it.
    
    Note this has no effect on userspace.
    
    All future IR drivers should use the rc-core api.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 4f585bff1347..2d24c88652aa 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -17,10 +17,10 @@
 #define _RC_CORE
 
 #include <linux/spinlock.h>
+#include <linux/cdev.h>
 #include <linux/kfifo.h>
 #include <linux/time.h>
 #include <linux/timer.h>
-#include <media/lirc_dev.h>
 #include <media/rc-map.h>
 
 extern int rc_core_debug;
@@ -116,7 +116,8 @@ enum rc_filter_type {
  * @max_timeout: maximum timeout supported by device
  * @rx_resolution : resolution (in ns) of input sampler
  * @tx_resolution: resolution (in ns) of output sampler
- * @lirc_dev: lirc char device
+ * @lirc_dev: lirc device
+ * @lirc_cdev: lirc char cdev
  * @lirc_open: count of the number of times the device has been opened
  * @carrier_low: when setting the carrier range, first the low end must be
  *	set with an ioctl and then the high end with another ioctl
@@ -190,7 +191,8 @@ struct rc_dev {
 	u32				rx_resolution;
 	u32				tx_resolution;
 #ifdef CONFIG_LIRC
-	struct lirc_dev			*lirc_dev;
+	struct device			lirc_dev;
+	struct cdev			lirc_cdev;
 	int				lirc_open;
 	int				carrier_low;
 	ktime_t				gap_start;

commit 111429fb73b1f5f584d977614b87ce9e6f8361c6
Author: Sean Young <sean@mess.org>
Date:   Tue Sep 26 07:44:20 2017 -0400

    media: lirc: create rc-core open and close lirc functions
    
    Replace the generic kernel lirc api with ones which use rc-core, further
    reducing the lirc_dev members.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b6d719734744..4f585bff1347 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -117,6 +117,7 @@ enum rc_filter_type {
  * @rx_resolution : resolution (in ns) of input sampler
  * @tx_resolution: resolution (in ns) of output sampler
  * @lirc_dev: lirc char device
+ * @lirc_open: count of the number of times the device has been opened
  * @carrier_low: when setting the carrier range, first the low end must be
  *	set with an ioctl and then the high end with another ioctl
  * @gap_start: time when gap starts
@@ -190,6 +191,7 @@ struct rc_dev {
 	u32				tx_resolution;
 #ifdef CONFIG_LIRC
 	struct lirc_dev			*lirc_dev;
+	int				lirc_open;
 	int				carrier_low;
 	ktime_t				gap_start;
 	u64				gap_duration;

commit 7790e81f7e1f7f122f8fcccd91443a2571421aba
Author: Sean Young <sean@mess.org>
Date:   Tue Sep 26 07:31:29 2017 -0400

    media: lirc: move lirc_dev->attached to rc_dev->registered
    
    This is done to further remove the lirc kernel api. Ensure that every
    fops checks for this.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index fb91666bf881..b6d719734744 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -127,6 +127,8 @@ enum rc_filter_type {
  * @wait_poll: poll struct for lirc device
  * @send_mode: lirc mode for sending, either LIRC_MODE_SCANCODE or
  *	LIRC_MODE_PULSE
+ * @registered: set to true by rc_register_device(), false by
+ *	rc_unregister_device
  * @change_protocol: allow changing the protocol used on hardware decoders
  * @open: callback to allow drivers to enable polling/irq when IR input device
  *	is opened.
@@ -197,6 +199,7 @@ struct rc_dev {
 	wait_queue_head_t		wait_poll;
 	u8				send_mode;
 #endif
+	bool				registered;
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);

commit 71695aff9fe036857596965635e2607cf561a230
Author: Sean Young <sean@mess.org>
Date:   Sat Sep 23 14:44:18 2017 -0400

    media: lirc: use kfifo rather than lirc_buffer for raw IR
    
    Since the only mode lirc devices can handle is raw IR, handle this
    in a plain kfifo.
    
    Remove lirc_buffer since this is no longer needed.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 5d6e415c7acc..fb91666bf881 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -123,6 +123,8 @@ enum rc_filter_type {
  * @gap_duration: duration of initial gap
  * @gap: true if we're in a gap
  * @send_timeout_reports: report timeouts in lirc raw IR.
+ * @rawir: queue for incoming raw IR
+ * @wait_poll: poll struct for lirc device
  * @send_mode: lirc mode for sending, either LIRC_MODE_SCANCODE or
  *	LIRC_MODE_PULSE
  * @change_protocol: allow changing the protocol used on hardware decoders
@@ -191,6 +193,8 @@ struct rc_dev {
 	u64				gap_duration;
 	bool				gap;
 	bool				send_timeout_reports;
+	DECLARE_KFIFO_PTR(rawir, unsigned int);
+	wait_queue_head_t		wait_poll;
 	u8				send_mode;
 #endif
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);

commit a60d64b15c20d178ba3a9bc3a542492b4ddeea70
Author: Sean Young <sean@mess.org>
Date:   Sat Sep 23 10:41:13 2017 -0400

    media: lirc: lirc interface should not be a raw decoder
    
    The lirc user interface exists as a raw decoder, which does not make
    much sense for transmit-only devices.
    
    In addition, we want to have lirc char devices for devices which do not
    use raw IR, i.e. scancode only devices.
    
    Note that rc-code, lirc_dev, ir-lirc-codec are now calling functions of
    each other, so they've been merged into one module rc-core to avoid
    circular dependencies.
    
    Since ir-lirc-codec no longer exists as separate codec module, there is no
    need for RC_DRIVER_IR_RAW_TX type drivers to call ir_raw_event_register().
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index ca48632ec8e2..5d6e415c7acc 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -20,6 +20,7 @@
 #include <linux/kfifo.h>
 #include <linux/time.h>
 #include <linux/timer.h>
+#include <media/lirc_dev.h>
 #include <media/rc-map.h>
 
 extern int rc_core_debug;
@@ -115,6 +116,15 @@ enum rc_filter_type {
  * @max_timeout: maximum timeout supported by device
  * @rx_resolution : resolution (in ns) of input sampler
  * @tx_resolution: resolution (in ns) of output sampler
+ * @lirc_dev: lirc char device
+ * @carrier_low: when setting the carrier range, first the low end must be
+ *	set with an ioctl and then the high end with another ioctl
+ * @gap_start: time when gap starts
+ * @gap_duration: duration of initial gap
+ * @gap: true if we're in a gap
+ * @send_timeout_reports: report timeouts in lirc raw IR.
+ * @send_mode: lirc mode for sending, either LIRC_MODE_SCANCODE or
+ *	LIRC_MODE_PULSE
  * @change_protocol: allow changing the protocol used on hardware decoders
  * @open: callback to allow drivers to enable polling/irq when IR input device
  *	is opened.
@@ -174,6 +184,15 @@ struct rc_dev {
 	u32				max_timeout;
 	u32				rx_resolution;
 	u32				tx_resolution;
+#ifdef CONFIG_LIRC
+	struct lirc_dev			*lirc_dev;
+	int				carrier_low;
+	ktime_t				gap_start;
+	u64				gap_duration;
+	bool				gap;
+	bool				send_timeout_reports;
+	u8				send_mode;
+#endif
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
@@ -248,20 +267,6 @@ int devm_rc_register_device(struct device *parent, struct rc_dev *dev);
  */
 void rc_unregister_device(struct rc_dev *dev);
 
-/**
- * rc_open - Opens a RC device
- *
- * @rdev: pointer to struct rc_dev.
- */
-int rc_open(struct rc_dev *rdev);
-
-/**
- * rc_close - Closes a RC device
- *
- * @rdev: pointer to struct rc_dev.
- */
-void rc_close(struct rc_dev *rdev);
-
 void rc_repeat(struct rc_dev *dev);
 void rc_keydown(struct rc_dev *dev, enum rc_proto protocol, u32 scancode,
 		u8 toggle);

commit cdfaa01c1cfeb828e6d3c0c5e4f54375fc3ccb95
Author: Sean Young <sean@mess.org>
Date:   Sat Feb 25 06:51:30 2017 -0500

    media: lirc: use the correct carrier for scancode transmit
    
    If the lirc device supports it, set the carrier for the protocol.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 314a1edb6189..ca48632ec8e2 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -309,6 +309,7 @@ int ir_raw_event_store_with_filter(struct rc_dev *dev,
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
 int ir_raw_encode_scancode(enum rc_proto protocol, u32 scancode,
 			   struct ir_raw_event *events, unsigned int max);
+int ir_raw_encode_carrier(enum rc_proto protocol);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
 {

commit 6d741bfed5ed06ed42a16d30f1ed7afdcaf7f092
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 7 16:20:58 2017 -0400

    media: rc: rename RC_TYPE_* to RC_PROTO_* and RC_BIT_* to RC_PROTO_BIT_*
    
    RC_TYPE is confusing and it's just the protocol. So rename it.
    
    Suggested-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 5be527ff851d..314a1edb6189 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -87,11 +87,12 @@ enum rc_filter_type {
  * @idle: used to keep track of RX state
  * @encode_wakeup: wakeup filtering uses IR encode API, therefore the allowed
  *	wakeup protocols is the set of all raw encoders
- * @allowed_protocols: bitmask with the supported RC_BIT_* protocols
- * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
- * @allowed_wakeup_protocols: bitmask with the supported RC_BIT_* wakeup protocols
- * @wakeup_protocol: the enabled RC_TYPE_* wakeup protocol or
- *	RC_TYPE_UNKNOWN if disabled.
+ * @allowed_protocols: bitmask with the supported RC_PROTO_BIT_* protocols
+ * @enabled_protocols: bitmask with the enabled RC_PROTO_BIT_* protocols
+ * @allowed_wakeup_protocols: bitmask with the supported RC_PROTO_BIT_* wakeup
+ *	protocols
+ * @wakeup_protocol: the enabled RC_PROTO_* wakeup protocol or
+ *	RC_PROTO_UNKNOWN if disabled.
  * @scancode_filter: scancode filter
  * @scancode_wakeup_filter: scancode wakeup filters
  * @scancode_mask: some hardware decoders are not capable of providing the full
@@ -154,7 +155,7 @@ struct rc_dev {
 	u64				allowed_protocols;
 	u64				enabled_protocols;
 	u64				allowed_wakeup_protocols;
-	enum rc_type			wakeup_protocol;
+	enum rc_proto			wakeup_protocol;
 	struct rc_scancode_filter	scancode_filter;
 	struct rc_scancode_filter	scancode_wakeup_filter;
 	u32				scancode_mask;
@@ -165,7 +166,7 @@ struct rc_dev {
 	unsigned long			keyup_jiffies;
 	struct timer_list		timer_keyup;
 	u32				last_keycode;
-	enum rc_type			last_protocol;
+	enum rc_proto			last_protocol;
 	u32				last_scancode;
 	u8				last_toggle;
 	u32				timeout;
@@ -173,7 +174,7 @@ struct rc_dev {
 	u32				max_timeout;
 	u32				rx_resolution;
 	u32				tx_resolution;
-	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_type);
+	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_proto);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
 	int				(*s_tx_mask)(struct rc_dev *dev, u32 mask);
@@ -262,8 +263,10 @@ int rc_open(struct rc_dev *rdev);
 void rc_close(struct rc_dev *rdev);
 
 void rc_repeat(struct rc_dev *dev);
-void rc_keydown(struct rc_dev *dev, enum rc_type protocol, u32 scancode, u8 toggle);
-void rc_keydown_notimeout(struct rc_dev *dev, enum rc_type protocol, u32 scancode, u8 toggle);
+void rc_keydown(struct rc_dev *dev, enum rc_proto protocol, u32 scancode,
+		u8 toggle);
+void rc_keydown_notimeout(struct rc_dev *dev, enum rc_proto protocol,
+			  u32 scancode, u8 toggle);
 void rc_keyup(struct rc_dev *dev);
 u32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
 
@@ -304,7 +307,7 @@ int ir_raw_event_store_edge(struct rc_dev *dev, bool pulse);
 int ir_raw_event_store_with_filter(struct rc_dev *dev,
 				struct ir_raw_event *ev);
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
-int ir_raw_encode_scancode(enum rc_type protocol, u32 scancode,
+int ir_raw_encode_scancode(enum rc_proto protocol, u32 scancode,
 			   struct ir_raw_event *events, unsigned int max);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
@@ -335,7 +338,7 @@ static inline u32 ir_extract_bits(u32 data, u32 mask)
 /* Get NEC scancode and protocol type from address and command bytes */
 static inline u32 ir_nec_bytes_to_scancode(u8 address, u8 not_address,
 					   u8 command, u8 not_command,
-					   enum rc_type *protocol)
+					   enum rc_proto *protocol)
 {
 	u32 scancode;
 
@@ -347,17 +350,17 @@ static inline u32 ir_nec_bytes_to_scancode(u8 address, u8 not_address,
 			address     << 16 |
 			not_command <<  8 |
 			command;
-		*protocol = RC_TYPE_NEC32;
+		*protocol = RC_PROTO_NEC32;
 	} else if ((address ^ not_address) != 0xff) {
 		/* Extended NEC */
 		scancode = address     << 16 |
 			   not_address <<  8 |
 			   command;
-		*protocol = RC_TYPE_NECX;
+		*protocol = RC_PROTO_NECX;
 	} else {
 		/* Normal NEC */
 		scancode = address << 8 | command;
-		*protocol = RC_TYPE_NEC;
+		*protocol = RC_PROTO_NEC;
 	}
 
 	return scancode;

commit 86fe1ac0d563477b1d10d49a92237e3f3d74e7be
Author: Sean Young <sean@mess.org>
Date:   Mon Aug 7 08:38:10 2017 -0400

    media: rc: simplify ir_raw_event_store_edge()
    
    Since commit 12749b198fa4 ("[media] rc: saa7134: add trailing space for
    timely decoding"), the workaround of inserting reset events is no
    longer needed.
    
    Note that the initial reset is not needed either; other rc-core drivers
    that don't use ir_raw_event_store_edge() never call this at all.
    
    Verified on a HVR-1150 and Raspberry Pi.
    
    Fixes: 3f5c4c73322e ("[media] rc: fix ghost keypresses with certain hw")
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b6c18840d125..5be527ff851d 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -272,14 +272,6 @@ u32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
  * The Raw interface is specific to InfraRed. It may be a good idea to
  * split it later into a separate header.
  */
-
-enum raw_event_type {
-	IR_SPACE        = (1 << 0),
-	IR_PULSE        = (1 << 1),
-	IR_START_EVENT  = (1 << 2),
-	IR_STOP_EVENT   = (1 << 3),
-};
-
 struct ir_raw_event {
 	union {
 		u32             duration;
@@ -308,7 +300,7 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 
 void ir_raw_event_handle(struct rc_dev *dev);
 int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);
-int ir_raw_event_store_edge(struct rc_dev *dev, enum raw_event_type type);
+int ir_raw_event_store_edge(struct rc_dev *dev, bool pulse);
 int ir_raw_event_store_with_filter(struct rc_dev *dev,
 				struct ir_raw_event *ev);
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);

commit e8ffda78623677f7935b30901a173405b4861bda
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sun Jul 30 09:23:11 2017 -0400

    media: rc: ir-nec-decoder: move scancode composing code into a shared function
    
    The NEC scancode composing and protocol type detection in
    ir_nec_decode() is generic enough to be a shared function.  Let's create
    an inline function in rc-core.h, so that other remote control drivers
    can reuse this function to save some code.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 16bd89caa22d..b6c18840d125 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -340,4 +340,35 @@ static inline u32 ir_extract_bits(u32 data, u32 mask)
 	return value;
 }
 
+/* Get NEC scancode and protocol type from address and command bytes */
+static inline u32 ir_nec_bytes_to_scancode(u8 address, u8 not_address,
+					   u8 command, u8 not_command,
+					   enum rc_type *protocol)
+{
+	u32 scancode;
+
+	if ((command ^ not_command) != 0xff) {
+		/* NEC transport, but modified protocol, used by at
+		 * least Apple and TiVo remotes
+		 */
+		scancode = not_address << 24 |
+			address     << 16 |
+			not_command <<  8 |
+			command;
+		*protocol = RC_TYPE_NEC32;
+	} else if ((address ^ not_address) != 0xff) {
+		/* Extended NEC */
+		scancode = address     << 16 |
+			   not_address <<  8 |
+			   command;
+		*protocol = RC_TYPE_NECX;
+	} else {
+		/* Normal NEC */
+		scancode = address << 8 | command;
+		*protocol = RC_TYPE_NEC;
+	}
+
+	return scancode;
+}
+
 #endif /* _RC_CORE */

commit 518f4b26be1ebf6ce220c4e37b5c7e5410c4d064
Author: Sean Young <sean@mess.org>
Date:   Sat Jul 1 12:13:19 2017 -0400

    media: rc-core: rename input_name to device_name
    
    When an ir-spi is registered, you get this message.
    
    rc rc0: Unspecified device as /devices/platform/soc/3f215080.spi/spi_master/spi32766/spi32766.128/rc/rc0
    
    "Unspecified device" refers to input_name, which makes no sense for IR
    TX only devices. So, rename to device_name.
    
    Also make driver_name const char* so that no casts are needed anywhere.
    
    Now ir-spi reports:
    
    rc rc0: IR SPI as /devices/platform/soc/3f215080.spi/spi_master/spi32766/spi32766.128/rc/rc0
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 78dea39a9b39..16bd89caa22d 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -72,7 +72,7 @@ enum rc_filter_type {
  * @dev: driver model's view of this device
  * @managed_alloc: devm_rc_allocate_device was used to create rc_dev
  * @sysfs_groups: sysfs attribute groups
- * @input_name: name of the input child device
+ * @device_name: name of the rc child device
  * @input_phys: physical path to the input child device
  * @input_id: id of the input child device (struct input_id)
  * @driver_name: name of the hardware driver which registered this device
@@ -138,10 +138,10 @@ struct rc_dev {
 	struct device			dev;
 	bool				managed_alloc;
 	const struct attribute_group	*sysfs_groups[5];
-	const char			*input_name;
+	const char			*device_name;
 	const char			*input_phys;
 	struct input_id			input_id;
-	char				*driver_name;
+	const char			*driver_name;
 	const char			*map_name;
 	struct rc_map			rc_map;
 	struct mutex			lock;

commit 18726a349de262f5bf03fab73fc7c46e79e6c41e
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 27 17:34:08 2017 -0300

    [media] rc-core: cleanup rc_register_device pt2
    
    Now that rc_register_device() is reorganised, the dev->initialized
    hack can be removed. Any driver which calls rc_register_device()
    must be prepared for the device to go live immediately.
    
    The dev->initialized commits that are relevant are commit c73bbaa4ec3e
    ("[media] rc-core: don't lock device at rc_register_device()") and
    commit 08aeb7c9a42a ("[media] rc: add locking to fix register/show race").
    
    The original problem was that show_protocols() would access
    dev->rc_map.* and various other bits which are now properly
    initialized before device_add() is called.
    
    At the same time, remove the bogus "device is being removed" check.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 73ddd721d7ba..78dea39a9b39 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -70,7 +70,6 @@ enum rc_filter_type {
 /**
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
- * @initialized: 1 if the device init has completed, 0 otherwise
  * @managed_alloc: devm_rc_allocate_device was used to create rc_dev
  * @sysfs_groups: sysfs attribute groups
  * @input_name: name of the input child device
@@ -137,7 +136,6 @@ enum rc_filter_type {
  */
 struct rc_dev {
 	struct device			dev;
-	atomic_t			initialized;
 	bool				managed_alloc;
 	const struct attribute_group	*sysfs_groups[5];
 	const char			*input_name;

commit d34aee1018342568334de27fa04f0b916ff7d7a1
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Fri Dec 16 04:12:15 2016 -0200

    [media] rc-core: add support for IR raw transmitters
    
    IR raw transmitter driver type is specified in the enum
    rc_driver_type as RC_DRIVER_IR_RAW_TX which includes all those
    devices that transmit raw stream of bit to a receiver.
    
    The data are provided by userspace applications, therefore they
    don't need any input device allocation, but still they need to be
    registered as raw devices.
    
    Suggested-by: Sean Young <sean@mess.org>
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 8c2252686955..73ddd721d7ba 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -32,13 +32,16 @@ do {								\
 /**
  * enum rc_driver_type - type of the RC output
  *
- * @RC_DRIVER_SCANCODE:	Driver or hardware generates a scancode
- * @RC_DRIVER_IR_RAW:	Driver or hardware generates pulse/space sequences.
- *			It needs a Infra-Red pulse/space decoder
+ * @RC_DRIVER_SCANCODE:	 Driver or hardware generates a scancode
+ * @RC_DRIVER_IR_RAW:	 Driver or hardware generates pulse/space sequences.
+ *			 It needs a Infra-Red pulse/space decoder
+ * @RC_DRIVER_IR_RAW_TX: Device transmitter only,
+ *			 driver requires pulse/space data sequence.
  */
 enum rc_driver_type {
 	RC_DRIVER_SCANCODE = 0,
 	RC_DRIVER_IR_RAW,
+	RC_DRIVER_IR_RAW_TX,
 };
 
 /**

commit 0f7499fddb153a333dff3c1dc4280c178b9b5a80
Author: Andi Shyti <andi.shyti@samsung.com>
Date:   Fri Dec 16 06:50:58 2016 -0200

    [media] rc-main: assign driver type during allocation
    
    The driver type can be assigned immediately when an RC device
    requests to the framework to allocate the device.
    
    This is an 'enum rc_driver_type' data type and specifies whether
    the device is a raw receiver or scancode receiver. The type will
    be given as parameter to the rc_allocate_device device.
    
    Change accordingly all the drivers calling rc_allocate_device()
    so that the device type is specified during the rc device
    allocation. Whenever the device type is not specified, it will be
    set as RC_DRIVER_SCANCODE which was the default '0' value.
    
    Suggested-by: Sean Young <sean@mess.org>
    Signed-off-by: Andi Shyti <andi.shyti@samsung.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index cf9fabcee33e..8c2252686955 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -203,17 +203,19 @@ struct rc_dev {
 /**
  * rc_allocate_device - Allocates a RC device
  *
+ * @rc_driver_type: specifies the type of the RC output to be allocated
  * returns a pointer to struct rc_dev.
  */
-struct rc_dev *rc_allocate_device(void);
+struct rc_dev *rc_allocate_device(enum rc_driver_type);
 
 /**
  * devm_rc_allocate_device - Managed RC device allocation
  *
  * @dev: pointer to struct device
+ * @rc_driver_type: specifies the type of the RC output to be allocated
  * returns a pointer to struct rc_dev.
  */
-struct rc_dev *devm_rc_allocate_device(struct device *dev);
+struct rc_dev *devm_rc_allocate_device(struct device *dev, enum rc_driver_type);
 
 /**
  * rc_free_device - Frees a RC device

commit f423ccc1a32f8111ddfec9ef7efbccc8b73f3ea5
Author: James Hogan <james@albanarts.com>
Date:   Tue Mar 31 14:48:10 2015 -0300

    [media] rc: rc-core: Add support for encode_wakeup drivers
    
    Add support in rc-core for drivers which implement the wakeup scancode
    filter by encoding the scancode using the raw IR encoders. This is by
    way of rc_dev::encode_wakeup which should be set to true and
    rc_dev::allowed_wakeup_protocols should be set to the raw IR encoders.
    
    We also do not permit the mask to be set as we cannot generate IR
    which would match that.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Cc: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 62d69b171bb6..cf9fabcee33e 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -83,6 +83,8 @@ enum rc_filter_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
+ * @encode_wakeup: wakeup filtering uses IR encode API, therefore the allowed
+ *	wakeup protocols is the set of all raw encoders
  * @allowed_protocols: bitmask with the supported RC_BIT_* protocols
  * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
  * @allowed_wakeup_protocols: bitmask with the supported RC_BIT_* wakeup protocols
@@ -147,6 +149,7 @@ struct rc_dev {
 	struct input_dev		*input_dev;
 	enum rc_driver_type		driver_type;
 	bool				idle;
+	bool				encode_wakeup;
 	u64				allowed_protocols;
 	u64				enabled_protocols;
 	u64				allowed_wakeup_protocols;

commit 3875233d0b42c6d194657735d1a4b6a8797bfaaa
Author: James Hogan <james@albanarts.com>
Date:   Tue Mar 31 14:48:06 2015 -0300

    [media] rc: rc-ir-raw: Add scancode encoder callback
    
    Add a callback to raw ir handlers for encoding and modulating a scancode
    to a set of raw events. This could be used for transmit, or for
    converting a wakeup scancode to a form that is more suitable for raw
    hardware wake up filters.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Sean Young <sean@mess.org>
    Cc: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index af4009399d1a..62d69b171bb6 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -306,6 +306,8 @@ int ir_raw_event_store_edge(struct rc_dev *dev, enum raw_event_type type);
 int ir_raw_event_store_with_filter(struct rc_dev *dev,
 				struct ir_raw_event *ev);
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
+int ir_raw_encode_scancode(enum rc_type protocol, u32 scancode,
+			   struct ir_raw_event *events, unsigned int max);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
 {

commit 0751d33c27eacfcd4e15a3425a9e035614ab9713
Author: Sean Young <sean@mess.org>
Date:   Mon Dec 5 17:08:35 2016 -0200

    [media] rc: change wakeup_protocols to list all protocol variants
    
    For IR wakeup, a driver has to program the hardware to wakeup at a
    specific IR sequence, so it makes no sense to allow multiple wakeup
    protocols to be selected. In the same manner the sysfs interface only
    allows one scancode to be provided.
    
    In addition, we need to know the specific variant of the protocol.
    
    In short, these changes are made to the wakeup_protocols sysfs entry:
     - list all the protocol variants rather than the protocol groups,
       e.g. "nec nec-x nec-32" rather than just "nec".
     - only allow one protocol variant to be selected rather than multiple
     - wakeup_filter can only be set once a protocol has been selected in
       wakeup_protocols.
    
    This is an API change, however the only user of this API is the img-ir,
    but the wakeup code was never merged to mainline, so it was never used.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Sifan Naeem <sifan.naeem@imgtec.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 55281b92105a..af4009399d1a 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -86,7 +86,8 @@ enum rc_filter_type {
  * @allowed_protocols: bitmask with the supported RC_BIT_* protocols
  * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
  * @allowed_wakeup_protocols: bitmask with the supported RC_BIT_* wakeup protocols
- * @enabled_wakeup_protocols: bitmask with the enabled RC_BIT_* wakeup protocols
+ * @wakeup_protocol: the enabled RC_TYPE_* wakeup protocol or
+ *	RC_TYPE_UNKNOWN if disabled.
  * @scancode_filter: scancode filter
  * @scancode_wakeup_filter: scancode wakeup filters
  * @scancode_mask: some hardware decoders are not capable of providing the full
@@ -110,8 +111,6 @@ enum rc_filter_type {
  * @rx_resolution : resolution (in ns) of input sampler
  * @tx_resolution: resolution (in ns) of output sampler
  * @change_protocol: allow changing the protocol used on hardware decoders
- * @change_wakeup_protocol: allow changing the protocol used for wakeup
- *	filtering
  * @open: callback to allow drivers to enable polling/irq when IR input device
  *	is opened.
  * @close: callback to allow drivers to disable polling/irq when IR input device
@@ -126,7 +125,9 @@ enum rc_filter_type {
  * @s_learning_mode: enable wide band receiver used for learning
  * @s_carrier_report: enable carrier reports
  * @s_filter: set the scancode filter
- * @s_wakeup_filter: set the wakeup scancode filter
+ * @s_wakeup_filter: set the wakeup scancode filter. If the mask is zero
+ *	then wakeup should be disabled. wakeup_protocol will be set to
+ *	a valid protocol if mask is nonzero.
  * @s_timeout: set hardware timeout in ns
  */
 struct rc_dev {
@@ -149,7 +150,7 @@ struct rc_dev {
 	u64				allowed_protocols;
 	u64				enabled_protocols;
 	u64				allowed_wakeup_protocols;
-	u64				enabled_wakeup_protocols;
+	enum rc_type			wakeup_protocol;
 	struct rc_scancode_filter	scancode_filter;
 	struct rc_scancode_filter	scancode_wakeup_filter;
 	u32				scancode_mask;
@@ -169,7 +170,6 @@ struct rc_dev {
 	u32				rx_resolution;
 	u32				tx_resolution;
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_type);
-	int				(*change_wakeup_protocol)(struct rc_dev *dev, u64 *rc_type);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
 	int				(*s_tx_mask)(struct rc_dev *dev, u32 mask);

commit ddbf7d5a698c4d8553ad2f77cb281d7b37898d34
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Sep 30 17:42:07 2016 -0300

    [media] rc: core: add managed versions of rc_allocate_device and rc_register_device
    
    Introduce managed versions of both functions.
    They allows to simplify the error path in the probe function of
    rc drivers, and usually also to simplify the remove function.
    
    New element managed_alloc in struct rc_dev is needed to correctly
    handle mixed use, e.g. managed version of rc_register_device and
    normal version of rc_allocate_device.
    
    In addition devm_rc_allocate_device sets rc->dev.parent as having a
    reference to the parent device might be useful for future extensions.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 40188d362486..55281b92105a 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -68,6 +68,7 @@ enum rc_filter_type {
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
  * @initialized: 1 if the device init has completed, 0 otherwise
+ * @managed_alloc: devm_rc_allocate_device was used to create rc_dev
  * @sysfs_groups: sysfs attribute groups
  * @input_name: name of the input child device
  * @input_phys: physical path to the input child device
@@ -131,6 +132,7 @@ enum rc_filter_type {
 struct rc_dev {
 	struct device			dev;
 	atomic_t			initialized;
+	bool				managed_alloc;
 	const struct attribute_group	*sysfs_groups[5];
 	const char			*input_name;
 	const char			*input_phys;
@@ -202,6 +204,14 @@ struct rc_dev {
  */
 struct rc_dev *rc_allocate_device(void);
 
+/**
+ * devm_rc_allocate_device - Managed RC device allocation
+ *
+ * @dev: pointer to struct device
+ * returns a pointer to struct rc_dev.
+ */
+struct rc_dev *devm_rc_allocate_device(struct device *dev);
+
 /**
  * rc_free_device - Frees a RC device
  *
@@ -216,6 +226,14 @@ void rc_free_device(struct rc_dev *dev);
  */
 int rc_register_device(struct rc_dev *dev);
 
+/**
+ * devm_rc_register_device - Manageded registering of a RC device
+ *
+ * @parent: pointer to struct device.
+ * @dev: pointer to struct rc_dev.
+ */
+int devm_rc_register_device(struct device *parent, struct rc_dev *dev);
+
 /**
  * rc_unregister_device - Unregisters a RC device
  *

commit e383ce0736f5ce74bbc0e989c6d044e29fefb9dc
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Thu Sep 22 07:59:03 2016 -0300

    [media] get rid of a number of problems at the cross references
    
    As warned by linuxdoc[1] tool, using:
    
    $ for i in $(git grep kernel-doc Documentation/media/kapi/|cut -d: -f4); do kernel-lintdoc --sloppy $i; done
    
        include/media/v4l2-dev.h:118 :WARN: function name from comment differs:  v4l2_prio_close <--> v4l2_prio_check
        include/media/v4l2-mc.h:56 [kernel-doc WARN] : enum name from comment differs:  if_vid_dec_index <--> if_vid_dec_pad_index
        include/media/v4l2-mc.h:71 [kernel-doc WARN] : enum name from comment differs:  if_aud_dec_index <--> if_aud_dec_pad_index
        include/media/v4l2-mem2mem.h:396 [kernel-doc WARN] : function name from comment differs:  v4l2_m2m_num_src_bufs_ready <--> v4l2_m2m_num_dst_bufs_ready
        drivers/media/dvb-core/dvb_math.h:28 [kernel-doc WARN] : function name from comment differs:  cintlog2 <--> intlog2
        include/media/v4l2-subdev.h:215 [kernel-doc WARN] : struct name from comment differs:  s_radio <--> v4l2_subdev_tuner_ops
        include/media/v4l2-subdev.h:890 [kernel-doc WARN] : function name from comment differs:  v4l2_set_subdevdata <--> v4l2_set_subdev_hostdata
        include/media/v4l2-subdev.h:901 [kernel-doc WARN] : function name from comment differs:  v4l2_get_subdevdata <--> v4l2_get_subdev_hostdata
        drivers/media/dvb-core/dvb_ringbuffer.h:196 [kernel-doc WARN] : function name from comment differs:  dvb_ringbuffer_writeuser <--> dvb_ringbuffer_write_user
        include/media/videobuf2-core.h:399 [kernel-doc WARN] : struct name from comment differs:  vb2_ops <--> vb2_buf_ops
        include/media/media-entity.h:132 [kernel-doc ERROR] : duplicate parameter definition 'source'
        include/media/media-entity.h:477 [kernel-doc WARN] : function name from comment differs:  media_entity_enum_test <--> media_entity_enum_test_and_set
        include/media/media-entity.h:535 [kernel-doc WARN] : function name from comment differs:  gobj_to_entity <--> gobj_to_pad
        include/media/media-entity.h:544 [kernel-doc WARN] : function name from comment differs:  gobj_to_entity <--> gobj_to_link
        include/media/media-entity.h:553 [kernel-doc WARN] : function name from comment differs:  gobj_to_entity <--> gobj_to_intf
        include/media/media-entity.h:562 [kernel-doc WARN] : function name from comment differs:  gobj_to_entity <--> intf_to_devnode
        include/media/rc-core.h:234 [kernel-doc WARN] : function name from comment differs:  rc_open <--> rc_close
        include/media/v4l2-ctrls.h:397 [kernel-doc WARN] : missing initial short description of 'v4l2_ctrl_handler_init'
        include/media/v4l2-dev.h:118 [kernel-doc WARN] : function name from comment differs:  v4l2_prio_close <--> v4l2_prio_check
        include/media/v4l2-event.h:225 [kernel-doc WARN] : missing initial short description of 'v4l2_src_change_event_subscribe'
    
    [1] https://return42.github.io/linuxdoc/linux.html
    
    The above are real issues at the documentation. On several cases,
    caused by cut-and-paste.
    
     Fix them.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 10908e356b23..40188d362486 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -231,7 +231,7 @@ void rc_unregister_device(struct rc_dev *dev);
 int rc_open(struct rc_dev *rdev);
 
 /**
- * rc_open - Closes a RC device
+ * rc_close - Closes a RC device
  *
  * @rdev: pointer to struct rc_dev.
  */

commit c278256d05a2fc75b427fa6a5dc0024faa93465d
Merge: 7e5b7d1b3a8f 009a62084821
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Jul 23 07:59:19 2016 -0300

    Merge branch 'patchwork' into topic/docs-next
    
    * patchwork: (1492 commits)
      [media] cec: always check all_device_types and features
      [media] cec: poll should check if there is room in the tx queue
      [media] vivid: support monitor all mode
      [media] cec: fix test for unconfigured adapter in main message loop
      [media] cec: limit the size of the transmit queue
      [media] cec: zero unused msg part after msg->len
      [media] cec: don't set fh to NULL in CEC_TRANSMIT
      [media] cec: clear all status fields before transmit and always fill in sequence
      [media] cec: CEC_RECEIVE overwrote the timeout field
      [media] cxd2841er: Reading SNR for DVB-C added
      [media] cxd2841er: Reading BER and UCB for DVB-C added
      [media] cxd2841er: fix switch-case for DVB-C
      [media] cxd2841er: fix signal strength scale for ISDB-T
      [media] cxd2841er: adjust the dB scale for DVB-C
      [media] cxd2841er: provide signal strength for DVB-C
      [media] cxd2841er: fix BER report via DVBv5 stats API
      [media] mb86a20s: apply mask to val after checking for read failure
      [media] airspy: fix error logic during device register
      [media] s5p-cec/TODO: add TODO item
      [media] cec/TODO: drop comment about sphinx documentation
      ...
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

commit 5b6137dc84f627e8497e554890ae02378c54f9f0
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun Jul 17 09:16:57 2016 -0300

    [media] doc-rst: Fix issues with RC documentation
    
    The kernel-doc script is now broken if it doesn't find all
    exported symbols documented.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b6586a91129c..ff54a71f5cd2 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -29,9 +29,16 @@ do {								\
 		printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);	\
 } while (0)
 
+/**
+ * enum rc_driver_type - type of the RC output
+ *
+ * @RC_DRIVER_SCANCODE:	Driver or hardware generates a scancode
+ * @RC_DRIVER_IR_RAW:	Driver or hardware generates pulse/space sequences.
+ *			It needs a Infra-Red pulse/space decoder
+ */
 enum rc_driver_type {
-	RC_DRIVER_SCANCODE = 0,	/* Driver or hardware generates a scancode */
-	RC_DRIVER_IR_RAW,	/* Needs a Infra-Red pulse/space decoder */
+	RC_DRIVER_SCANCODE = 0,
+	RC_DRIVER_IR_RAW,
 };
 
 /**
@@ -185,12 +192,46 @@ struct rc_dev {
  * Remote Controller, at sys/class/rc.
  */
 
+/**
+ * rc_allocate_device - Allocates a RC device
+ *
+ * returns a pointer to struct rc_dev.
+ */
 struct rc_dev *rc_allocate_device(void);
+
+/**
+ * rc_free_device - Frees a RC device
+ *
+ * @dev: pointer to struct rc_dev.
+ */
 void rc_free_device(struct rc_dev *dev);
+
+/**
+ * rc_register_device - Registers a RC device
+ *
+ * @dev: pointer to struct rc_dev.
+ */
 int rc_register_device(struct rc_dev *dev);
+
+/**
+ * rc_unregister_device - Unregisters a RC device
+ *
+ * @dev: pointer to struct rc_dev.
+ */
 void rc_unregister_device(struct rc_dev *dev);
 
+/**
+ * rc_open - Opens a RC device
+ *
+ * @rdev: pointer to struct rc_dev.
+ */
 int rc_open(struct rc_dev *rdev);
+
+/**
+ * rc_open - Closes a RC device
+ *
+ * @rdev: pointer to struct rc_dev.
+ */
 void rc_close(struct rc_dev *rdev);
 
 void rc_repeat(struct rc_dev *dev);

commit 4f253cecf8cb59816d53267170440efa3e1df018
Author: Sean Young <sean@mess.org>
Date:   Sun Jul 10 13:34:38 2016 -0300

    [media] redrat3: make hardware timeout configurable
    
    Instead of hardcoding a timeout, let userspace change it dynamically
    by adding a s_timeout ops.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b6586a91129c..324232cfc08d 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -119,6 +119,7 @@ enum rc_filter_type {
  * @s_carrier_report: enable carrier reports
  * @s_filter: set the scancode filter
  * @s_wakeup_filter: set the wakeup scancode filter
+ * @s_timeout: set hardware timeout in ns
  */
 struct rc_dev {
 	struct device			dev;
@@ -174,6 +175,8 @@ struct rc_dev {
 						    struct rc_scancode_filter *filter);
 	int				(*s_wakeup_filter)(struct rc_dev *dev,
 							   struct rc_scancode_filter *filter);
+	int				(*s_timeout)(struct rc_dev *dev,
+						     unsigned int timeout);
 };
 
 #define to_rc_dev(d) container_of(d, struct rc_dev, dev)

commit 5f61ff86116cf637ae926f44c1857716ec89e9fb
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Mar 17 16:39:13 2016 -0300

    [media] media: rc: reduce size of struct ir_raw_event
    
    struct ir_raw_event currently has a size of 12 bytes on most (all?)
    architectures. This can be reduced to 8 bytes whilst maintaining
    full backwards compatibility.
    This saves 2KB in size of struct ir_raw_event_ctrl (as element
    kfifo is reduced by 512 * 4 bytes) and it allows to copy the
    full struct ir_raw_event with a single 64 bit operation.
    
    Successfully tested with the Nuvoton driver and successfully
    compile-tested with the ene_ir driver (as it uses the carrier /
    duty_cycle elements).
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 0f77b3dffb37..b6586a91129c 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -215,12 +215,9 @@ enum raw_event_type {
 struct ir_raw_event {
 	union {
 		u32             duration;
-
-		struct {
-			u32     carrier;
-			u8      duty_cycle;
-		};
+		u32             carrier;
 	};
+	u8                      duty_cycle;
 
 	unsigned                pulse:1;
 	unsigned                reset:1;
@@ -228,13 +225,7 @@ struct ir_raw_event {
 	unsigned                carrier_report:1;
 };
 
-#define DEFINE_IR_RAW_EVENT(event) \
-	struct ir_raw_event event = { \
-		{ .duration = 0 } , \
-		.pulse = 0, \
-		.reset = 0, \
-		.timeout = 0, \
-		.carrier_report = 0 }
+#define DEFINE_IR_RAW_EVENT(event) struct ir_raw_event event = {}
 
 static inline void init_ir_raw_event(struct ir_raw_event *ev)
 {
@@ -256,8 +247,7 @@ void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
 {
-	DEFINE_IR_RAW_EVENT(ev);
-	ev.reset = true;
+	struct ir_raw_event ev = { .reset = true };
 
 	ir_raw_event_store(dev, &ev);
 	ir_raw_event_handle(dev);

commit 078600f514a12fd763ac84c86af68ef5b5267563
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Mar 2 08:00:15 2016 -0300

    [media] rc-core: allow calling rc_open with device not initialized
    
    The device initialization completes only after calling
    input_register_device(). However, rc_open() can be called while
    the device is being registered by the input/evdev core. So, we
    can't expect that rc_dev->initialized to be true.
    
    Change the logic to don't require initialized == true at rc_open
    and change the type of initialized to be atomic.
    
    this way, we can check for it earlier where it is really needed,
    without needing to lock the mutex just for testing it.
    
    Tested with nuvoton_cir driver on a NUC5i7RYB with CIR integrated on it.
    
    Reported-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index c41dd7018fa8..0f77b3dffb37 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -60,7 +60,7 @@ enum rc_filter_type {
 /**
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
- * @initialized: true if the device init has completed
+ * @initialized: 1 if the device init has completed, 0 otherwise
  * @sysfs_groups: sysfs attribute groups
  * @input_name: name of the input child device
  * @input_phys: physical path to the input child device
@@ -122,7 +122,7 @@ enum rc_filter_type {
  */
 struct rc_dev {
 	struct device			dev;
-	bool				initialized;
+	atomic_t			initialized;
 	const struct attribute_group	*sysfs_groups[5];
 	const char			*input_name;
 	const char			*input_phys;

commit c73bbaa4ec3eb225ffe468f80d45724d0496bf03
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 11 10:33:31 2016 -0200

    [media] rc-core: don't lock device at rc_register_device()
    
    The mutex lock at rc_register_device() was added by commit 08aeb7c9a42a
    ("[media] rc: add locking to fix register/show race").
    
    It is meant to avoid race issues when trying to open a sysfs file while
    the RC register didn't complete.
    
    Adding a lock there causes troubles, as detected by the Kernel lock
    debug instrumentation at the Kernel:
    
        ======================================================
        [ INFO: possible circular locking dependency detected ]
        4.5.0-rc3+ #46 Not tainted
        -------------------------------------------------------
        systemd-udevd/2681 is trying to acquire lock:
         (s_active#171){++++.+}, at: [<ffffffff8171a115>] kernfs_remove_by_name_ns+0x45/0xa0
    
        but task is already holding lock:
         (&dev->lock){+.+.+.}, at: [<ffffffffa0724def>] rc_register_device+0xb2f/0x1450 [rc_core]
    
        which lock already depends on the new lock.
    
        the existing dependency chain (in reverse order) is:
    
        -> #1 (&dev->lock){+.+.+.}:
               [<ffffffff8124817d>] lock_acquire+0x13d/0x320
               [<ffffffff822de966>] mutex_lock_nested+0xb6/0x860
               [<ffffffffa0721f2b>] show_protocols+0x3b/0x3f0 [rc_core]
               [<ffffffff81cdaba5>] dev_attr_show+0x45/0xc0
               [<ffffffff8171f1b3>] sysfs_kf_seq_show+0x203/0x3c0
               [<ffffffff8171a6a1>] kernfs_seq_show+0x121/0x1b0
               [<ffffffff81617c71>] seq_read+0x2f1/0x1160
               [<ffffffff8171c911>] kernfs_fop_read+0x321/0x460
               [<ffffffff815abc20>] __vfs_read+0xe0/0x3d0
               [<ffffffff815ae90e>] vfs_read+0xde/0x2d0
               [<ffffffff815b1d01>] SyS_read+0x111/0x230
               [<ffffffff822e8636>] entry_SYSCALL_64_fastpath+0x16/0x76
    
        -> #0 (s_active#171){++++.+}:
               [<ffffffff81244f24>] __lock_acquire+0x4304/0x5990
               [<ffffffff8124817d>] lock_acquire+0x13d/0x320
               [<ffffffff81717d3a>] __kernfs_remove+0x58a/0x810
               [<ffffffff8171a115>] kernfs_remove_by_name_ns+0x45/0xa0
               [<ffffffff81721592>] remove_files.isra.0+0x72/0x190
               [<ffffffff8172174b>] sysfs_remove_group+0x9b/0x150
               [<ffffffff81721854>] sysfs_remove_groups+0x54/0xa0
               [<ffffffff81cd97d0>] device_remove_attrs+0xb0/0x140
               [<ffffffff81cdb27c>] device_del+0x38c/0x6b0
               [<ffffffffa0724b8b>] rc_register_device+0x8cb/0x1450 [rc_core]
               [<ffffffffa1326a7b>] dvb_usb_remote_init+0x66b/0x14d0 [dvb_usb]
               [<ffffffffa1321c81>] dvb_usb_device_init+0xf21/0x1860 [dvb_usb]
               [<ffffffffa13517dc>] dib0700_probe+0x14c/0x410 [dvb_usb_dib0700]
               [<ffffffff81dbb1dd>] usb_probe_interface+0x45d/0x940
               [<ffffffff81ce7e7a>] driver_probe_device+0x21a/0xc30
               [<ffffffff81ce89b1>] __driver_attach+0x121/0x160
               [<ffffffff81ce21bf>] bus_for_each_dev+0x11f/0x1a0
               [<ffffffff81ce6cdd>] driver_attach+0x3d/0x50
               [<ffffffff81ce5df9>] bus_add_driver+0x4c9/0x770
               [<ffffffff81cea39c>] driver_register+0x18c/0x3b0
               [<ffffffff81db6e98>] usb_register_driver+0x1f8/0x440
               [<ffffffffa074001e>] dib0700_driver_init+0x1e/0x1000 [dvb_usb_dib0700]
               [<ffffffff810021b1>] do_one_initcall+0x141/0x300
               [<ffffffff8144d8eb>] do_init_module+0x1d0/0x5ad
               [<ffffffff812f27b6>] load_module+0x6666/0x9ba0
               [<ffffffff812f5fe8>] SyS_finit_module+0x108/0x130
               [<ffffffff822e8636>] entry_SYSCALL_64_fastpath+0x16/0x76
    
        other info that might help us debug this:
    
         Possible unsafe locking scenario:
    
               CPU0                    CPU1
               ----                    ----
          lock(&dev->lock);
                                       lock(s_active#171);
                                       lock(&dev->lock);
          lock(s_active#171);
    
         *** DEADLOCK ***
    
        3 locks held by systemd-udevd/2681:
         #0:  (&dev->mutex){......}, at: [<ffffffff81ce8933>] __driver_attach+0xa3/0x160
         #1:  (&dev->mutex){......}, at: [<ffffffff81ce8941>] __driver_attach+0xb1/0x160
         #2:  (&dev->lock){+.+.+.}, at: [<ffffffffa0724def>] rc_register_device+0xb2f/0x1450 [rc_core]
    
    In this specific case, some error happened during device init,
    causing IR to be disabled.
    
    Let's fix it by adding a var that will tell when the device is
    initialized. Any calls before that will return a -EINVAL.
    
    That should prevent the race issues.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index f6494709e230..c41dd7018fa8 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -60,6 +60,7 @@ enum rc_filter_type {
 /**
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
+ * @initialized: true if the device init has completed
  * @sysfs_groups: sysfs attribute groups
  * @input_name: name of the input child device
  * @input_phys: physical path to the input child device
@@ -121,6 +122,7 @@ enum rc_filter_type {
  */
 struct rc_dev {
 	struct device			dev;
+	bool				initialized;
 	const struct attribute_group	*sysfs_groups[5];
 	const char			*input_name;
 	const char			*input_phys;

commit c8e1bbc52d259a07a81b0f845191ee901ff44e01
Author: Eric Nelson <eric@nelint.com>
Date:   Sat Oct 3 08:18:50 2015 -0700

    [media] rc-core: define a default timeout for drivers
    
    A default timeout value of 125 ms should work for all decoders.
    
    Declare a constant to help standardize its' use.
    
    Signed-off-by: Eric Nelson <eric@nelint.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index ec921f6538c7..f6494709e230 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -239,6 +239,7 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 	memset(ev, 0, sizeof(*ev));
 }
 
+#define IR_DEFAULT_TIMEOUT	MS_TO_NS(125)
 #define IR_MAX_DURATION         500000000	/* 500 ms */
 #define US_TO_NS(usec)		((usec) * 1000)
 #define MS_TO_US(msec)		((msec) * 1000)

commit 9cfcc658da9693f65e7224e8329e40ada2f3c699
Merge: e3a98ac47698 50ef28a6ac21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 5 18:21:14 2015 -0700

    Merge tag 'media/v4.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
     - new DVB frontend drivers: ascot2e, cxd2841er, horus3a, lnbh25
     - new HDMI capture driver: tc358743
     - new driver for NetUP DVB new boards (netup_unidvb)
     - IR support for DVBSky cards (smipcie-ir)
     - Coda driver has gain macroblock tiling support
     - Renesas R-Car gains JPEG codec driver
     - new DVB platform driver for STi boards: c8sectpfe
     - added documentation for the media core kABI to device-drivers DocBook
     - lots of driver fixups, cleanups and improvements
    
    * tag 'media/v4.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (297 commits)
      [media] c8sectpfe: Remove select on undefined LIBELF_32
      [media] i2c: fix platform_no_drv_owner.cocci warnings
      [media] cx231xx: Use wake_up_interruptible() instead of wake_up_interruptible_nr()
      [media] tc358743: only queue subdev notifications if devnode is set
      [media] tc358743: add missing Kconfig dependency/select
      [media] c8sectpfe: Use %pad to print 'dma_addr_t'
      [media] DocBook media: Fix typo "the the" in xml files
      [media] tc358743: make reset gpio optional
      [media] tc358743: set direction of reset gpio using devm_gpiod_get
      [media] dvbdev: document most of the functions/data structs
      [media] dvb_frontend.h: document the struct dvb_frontend
      [media] dvb-frontend.h: document struct dtv_frontend_properties
      [media] dvb-frontend.h: document struct dvb_frontend_ops
      [media] dvb: Use DVBFE_ALGO_HW where applicable
      [media] dvb_frontend.h: document struct analog_demod_ops
      [media] dvb_frontend.h: Document struct dvb_tuner_ops
      [media] Docbook: Document struct analog_parameters
      [media] dvb_frontend.h: get rid of dvbfe_modcod
      [media] add documentation for struct dvb_tuner_info
      [media] dvb_frontend: document dvb_frontend_tune_settings
      ...

commit fa810845efc4d3c0f159a3e7a35f009e0249c857
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sat Aug 22 05:25:45 2015 -0300

    [media] Docbook: Fix s_rx_carrier_range parameter description
    
    Warning(.//include/media/rc-core.h:178): No description found for parameter 's_rx_carrier_range'
    Warning(.//include/media/rc-core.h:178): Excess struct/union/enum/typedef member 's_rx_carrier' description in 'rc_dev'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Acked-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 5642fbea886e..63eb5217edd5 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -112,7 +112,7 @@ enum rc_filter_type {
  * @s_tx_mask: set transmitter mask (for devices with multiple tx outputs)
  * @s_tx_carrier: set transmit carrier frequency
  * @s_tx_duty_cycle: set transmit duty cycle (0% - 100%)
- * @s_rx_carrier: inform driver about carrier it is expected to handle
+ * @s_rx_carrier_range: inform driver about carrier it is expected to handle
  * @tx_ir: transmit IR
  * @s_idle: enable/disable hardware idle mode, upon which,
  *	device doesn't interrupt host until it sees IR pulses

commit 72c5b7b24f3800bf8b1b1c78511c6da09d33c590
Author: David Härdeman <david@hardeman.nu>
Date:   Mon Jul 20 16:17:01 2015 -0300

    Revert "[media] rc: rc-ir-raw: Add scancode encoder callback"
    
    This reverts commit 9869da5bacc5c9b865a183bd36c04be76cdd325d.
    
    The current code is not mature enough, the API should allow a single
    protocol to be specified. Also, the current code contains heuristics
    that will depend on module load order.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index f0d09590ce58..644bdc61c387 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -250,9 +250,6 @@ int ir_raw_event_store_edge(struct rc_dev *dev, enum raw_event_type type);
 int ir_raw_event_store_with_filter(struct rc_dev *dev,
 				struct ir_raw_event *ev);
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
-int ir_raw_encode_scancode(u64 protocols,
-			   const struct rc_scancode_filter *scancode,
-			   struct ir_raw_event *events, unsigned int max);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
 {

commit 3a03b86fdc1634e81d77f84e987c5a15426eff3d
Author: David Härdeman <david@hardeman.nu>
Date:   Mon Jul 20 16:16:41 2015 -0300

    Revert "[media] rc: rc-core: Add support for encode_wakeup drivers"
    
    This reverts commit 0d830b2d1295fee82546d57185da5a6604f11ae2.
    
    The current code is not mature enough, the API should allow a single
    protocol to be specified. Also, the current code contains heuristics
    that will depend on module load order.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index df73d85b30c1..f0d09590ce58 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -74,8 +74,6 @@ enum rc_filter_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
- * @encode_wakeup: wakeup filtering uses IR encode API, therefore the allowed
- *	wakeup protocols is the set of all raw encoders
  * @allowed_protocols: bitmask with the supported RC_BIT_* protocols
  * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
  * @allowed_wakeup_protocols: bitmask with the supported RC_BIT_* wakeup protocols
@@ -136,7 +134,6 @@ struct rc_dev {
 	struct input_dev		*input_dev;
 	enum rc_driver_type		driver_type;
 	bool				idle;
-	bool				encode_wakeup;
 	u64				allowed_protocols;
 	u64				enabled_protocols;
 	u64				allowed_wakeup_protocols;

commit 23f28f2adcf608170c9062b1f490c4f0dcc995e3
Author: David Härdeman <david@hardeman.nu>
Date:   Mon Jul 20 16:16:31 2015 -0300

    Revert "[media] rc: nuvoton-cir: Add support for writing wakeup samples via sysfs filter callback"
    
    This reverts commit da7ee60b03bd66bb10974d7444aa444de6391312.
    
    The current code is not mature enough, the API should allow a single
    protocol to be specified. Also, the current code contains heuristics
    that will depend on module load order.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 45534da57759..df73d85b30c1 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -246,7 +246,6 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 #define US_TO_NS(usec)		((usec) * 1000)
 #define MS_TO_US(msec)		((msec) * 1000)
 #define MS_TO_NS(msec)		((msec) * 1000 * 1000)
-#define NS_TO_US(nsec)		DIV_ROUND_UP(nsec, 1000L)
 
 void ir_raw_event_handle(struct rc_dev *dev);
 int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);

commit fcb13097867757d360d5226d36ed3ffe849dc3ae
Author: David Härdeman <david@hardeman.nu>
Date:   Tue May 19 19:03:17 2015 -0300

    [media] rc-core: use an IDA rather than a bitmap
    
    This patch changes rc-core to use the kernel facilities that are already
    available for handling unique numbers instead of rolling its own bitmap
    stuff.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Tested-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 45534da57759..5642fbea886e 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -69,7 +69,7 @@ enum rc_filter_type {
  * @rc_map: current scan/key table
  * @lock: used to ensure we've filled in all protocol details before
  *	anyone can call show_protocols or store_protocols
- * @devno: unique remote control device number
+ * @minor: unique minor remote control device number
  * @raw: additional data for raw pulse/space devices
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
@@ -131,7 +131,7 @@ struct rc_dev {
 	const char			*map_name;
 	struct rc_map			rc_map;
 	struct mutex			lock;
-	unsigned long			devno;
+	unsigned int			minor;
 	struct ir_raw_event_ctrl	*raw;
 	struct input_dev		*input_dev;
 	enum rc_driver_type		driver_type;

commit 6b20cf3c0fbd242a337b15577905785bd95ca529
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Jun 5 10:30:44 2015 -0300

    [media] rc: set IR_MAX_DURATION to 500 ms
    
    The current definition is weird, and produce lots of sparse
    warnings:
    
            drivers/media/i2c/cx25840/cx25840-ir.c:448 txclk_tx_s_max_pulse_width() warn: impossible condition '(ns > 4294967295) => (0-u32max > u32max)'
            drivers/media/i2c/cx25840/cx25840-ir.c:461 rxclk_rx_s_max_pulse_width() warn: impossible condition '(ns > 4294967295) => (0-u32max > u32max)'
            drivers/media/i2c/cx25840/cx25840-ir.c:706 cx25840_ir_rx_read() warn: impossible condition '(v > 4294967295) => (0-u32max > u32max)'
            drivers/media/pci/ivtv/ivtv-queue.c:145 ivtv_queue_move() error: we previously assumed 'steal' could be null (see line 138)
            drivers/media/rc/streamzap.c:155 sz_push_full_pulse() warn: impossible condition '(rawir.duration > 4294967295) => (0-u32max > u32max)'
            drivers/media/rc/streamzap.c:169 sz_push_full_pulse() warn: impossible condition '(rawir.duration > 4294967295) => (0-u32max > u32max)'
            drivers/media/rc/redrat3.c:325 redrat3_us_to_len() warn: impossible condition '(microsec > 4294967295) => (0-u32max > u32max)'
            drivers/media/rc/redrat3.c:383 redrat3_process_ir_data() warn: impossible condition '(rawir.duration > 4294967295) => (0-u32max > u32max)'
            drivers/media/usb/pvrusb2/pvrusb2-hdw.c:3676 pvr2_send_request_ex() error: we previously assumed 'write_data' could be null (see line 3648)
            drivers/media/usb/pvrusb2/pvrusb2-hdw.c:3829 pvr2_send_request_ex() error: we previously assumed 'read_data' could be null (see line 3649)
            drivers/media/pci/cx23885/cx23888-ir.c:463 txclk_tx_s_max_pulse_width() warn: impossible condition '(ns > 4294967295) => (0-u32max > u32max)'
            drivers/media/pci/cx23885/cx23888-ir.c:476 rxclk_rx_s_max_pulse_width() warn: impossible condition '(ns > 4294967295) => (0-u32max > u32max)'
            drivers/media/pci/cx23885/cx23888-ir.c:696 cx23888_ir_rx_read() warn: impossible condition '(v > 4294967295) => (0-u32max > u32max)'
    
    Use a more realistic value for it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index f1cb9daba489..45534da57759 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -242,7 +242,7 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 	memset(ev, 0, sizeof(*ev));
 }
 
-#define IR_MAX_DURATION         0xFFFFFFFF      /* a bit more than 4 seconds */
+#define IR_MAX_DURATION         500000000	/* 500 ms */
 #define US_TO_NS(usec)		((usec) * 1000)
 #define MS_TO_US(msec)		((msec) * 1000)
 #define MS_TO_NS(msec)		((msec) * 1000 * 1000)

commit da7ee60b03bd66bb10974d7444aa444de6391312
Author: Antti Seppälä <a.seppala@gmail.com>
Date:   Tue Mar 31 14:48:12 2015 -0300

    [media] rc: nuvoton-cir: Add support for writing wakeup samples via sysfs filter callback
    
    Nuvoton-cir utilizes the encoding capabilities of rc-core to convert
    scancodes from user space to pulse/space format understood by the
    underlying hardware.
    
    Converted samples are then written to the wakeup fifo along with other
    necessary configuration to enable wake up functionality.
    
    Signed-off-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: James Hogan <james@albanarts.com>
    Cc: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 9ae433c7f14b..f1cb9daba489 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -246,6 +246,7 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 #define US_TO_NS(usec)		((usec) * 1000)
 #define MS_TO_US(msec)		((msec) * 1000)
 #define MS_TO_NS(msec)		((msec) * 1000 * 1000)
+#define NS_TO_US(nsec)		DIV_ROUND_UP(nsec, 1000L)
 
 void ir_raw_event_handle(struct rc_dev *dev);
 int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);

commit 0d830b2d1295fee82546d57185da5a6604f11ae2
Author: James Hogan <james@albanarts.com>
Date:   Tue Mar 31 14:48:10 2015 -0300

    [media] rc: rc-core: Add support for encode_wakeup drivers
    
    Add support in rc-core for drivers which implement the wakeup scancode
    filter by encoding the scancode using the raw IR encoders. This is by
    way of rc_dev::encode_wakeup which should be set to true to make the
    allowed wakeup protocols the same as the set of raw IR encoders.
    
    As well as updating the sysfs interface to know which wakeup protocols
    are allowed for encode_wakeup drivers, also ensure that the IR
    decoders/encoders are loaded when an encode_wakeup driver is registered.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Antti Seppälä <a.seppala@gmail.com>
    Cc: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 5703c082fba6..9ae433c7f14b 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -74,6 +74,8 @@ enum rc_filter_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
+ * @encode_wakeup: wakeup filtering uses IR encode API, therefore the allowed
+ *	wakeup protocols is the set of all raw encoders
  * @allowed_protocols: bitmask with the supported RC_BIT_* protocols
  * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
  * @allowed_wakeup_protocols: bitmask with the supported RC_BIT_* wakeup protocols
@@ -134,6 +136,7 @@ struct rc_dev {
 	struct input_dev		*input_dev;
 	enum rc_driver_type		driver_type;
 	bool				idle;
+	bool				encode_wakeup;
 	u64				allowed_protocols;
 	u64				enabled_protocols;
 	u64				allowed_wakeup_protocols;

commit 9869da5bacc5c9b865a183bd36c04be76cdd325d
Author: James Hogan <james@albanarts.com>
Date:   Tue Mar 31 14:48:06 2015 -0300

    [media] rc: rc-ir-raw: Add scancode encoder callback
    
    Add a callback to raw ir handlers for encoding and modulating a scancode
    to a set of raw events. This could be used for transmit, or for
    converting a wakeup scancode filter to a form that is more suitable for
    raw hardware wake up filters.
    
    Signed-off-by: James Hogan <james@albanarts.com>
    Signed-off-by: Antti Seppälä <a.seppala@gmail.com>
    Cc: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 2c7fbca40b69..5703c082fba6 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -250,6 +250,9 @@ int ir_raw_event_store_edge(struct rc_dev *dev, enum raw_event_type type);
 int ir_raw_event_store_with_filter(struct rc_dev *dev,
 				struct ir_raw_event *ev);
 void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
+int ir_raw_encode_scancode(u64 protocols,
+			   const struct rc_scancode_filter *scancode,
+			   struct ir_raw_event *events, unsigned int max);
 
 static inline void ir_raw_event_reset(struct rc_dev *dev)
 {

commit 7cec72ce00c174fd74d1183599d3d3dcc5dedc26
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Jul 25 23:25:36 2014 -0300

    [media] rc-core: don't use dynamic_pr_debug for IR_dprintk()
    
    The hole point of IR_dprintk() is that, once a level is
    given at debug parameter, all enabled IR parsers will show their
    debug messages.
    
    While converting it to dynamic_printk might be a good idea,
    right now it just makes very hard to debug the drivers, as
    one needs to both pass debug=1 or debug=2 to rc-core and
    to use the dynamic printk to enable all the desired lines.
    
    That doesn't make sense!
    
    So, revert to the old way, as a single line is changed,
    and the debug parameter will now work as expected.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 3047837db1cc..2c7fbca40b69 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -26,7 +26,7 @@ extern int rc_core_debug;
 #define IR_dprintk(level, fmt, ...)				\
 do {								\
 	if (rc_core_debug >= level)				\
-		pr_debug("%s: " fmt, __func__, ##__VA_ARGS__);	\
+		printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__);	\
 } while (0)
 
 enum rc_driver_type {

commit 9d2f1d3cdedd4d3efff8d14f1f49cf73e2f5cc36
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:32:26 2014 -0300

    [media] rc-core: rename dev->scanmask to dev->scancode_mask
    
    We already have dev->scancode_filter and dev->scancode_wakeup_filter
    so rename dev->scanmask to dev->scancode_mask for consistency.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 4f9e187d05bf..3047837db1cc 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -80,11 +80,12 @@ enum rc_filter_type {
  * @enabled_wakeup_protocols: bitmask with the enabled RC_BIT_* wakeup protocols
  * @scancode_filter: scancode filter
  * @scancode_wakeup_filter: scancode wakeup filters
- * @scanmask: some hardware decoders are not capable of providing the full
+ * @scancode_mask: some hardware decoders are not capable of providing the full
  *	scancode to the application. As this is a hardware limit, we can't do
  *	anything with it. Yet, as the same keycode table can be used with other
  *	devices, a mask is provided to allow its usage. Drivers should generally
  *	leave this field in blank
+ * @users: number of current users of the device
  * @priv: driver-specific data
  * @keylock: protects the remaining members of the struct
  * @keypressed: whether a key is currently pressed
@@ -139,8 +140,8 @@ struct rc_dev {
 	u64				enabled_wakeup_protocols;
 	struct rc_scancode_filter	scancode_filter;
 	struct rc_scancode_filter	scancode_wakeup_filter;
+	u32				scancode_mask;
 	u32				users;
-	u32				scanmask;
 	void				*priv;
 	spinlock_t			keylock;
 	bool				keypressed;

commit c5540fbb9de39ceec108a889133664a887c2f55a
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:32:21 2014 -0300

    [media] rc-core: remove protocol arrays
    
    The basic API of rc-core used to be:
    
            dev = rc_allocate_device();
            dev->x = a;
            dev->y = b;
            dev->z = c;
            rc_register_device();
    
    which is a pretty common pattern in the kernel, after the introduction of
    protocol arrays the API looks something like:
    
            dev = rc_allocate_device();
            dev->x = a;
            rc_set_allowed_protocols(dev, RC_BIT_X);
            dev->z = c;
            rc_register_device();
    
    There's no real need for the protocols to be an array, so change it
    back to be consistent (and in preparation for the following patches).
    
    [m.chehab@samsung.com: added missing changes at some files]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 00811c9e22b0..4f9e187d05bf 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -74,10 +74,12 @@ enum rc_filter_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
- * @allowed_protocols: bitmask with the supported RC_BIT_* protocols for each
- *	filter type
- * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols for each
- *	filter type
+ * @allowed_protocols: bitmask with the supported RC_BIT_* protocols
+ * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
+ * @allowed_wakeup_protocols: bitmask with the supported RC_BIT_* wakeup protocols
+ * @enabled_wakeup_protocols: bitmask with the enabled RC_BIT_* wakeup protocols
+ * @scancode_filter: scancode filter
+ * @scancode_wakeup_filter: scancode wakeup filters
  * @scanmask: some hardware decoders are not capable of providing the full
  *	scancode to the application. As this is a hardware limit, we can't do
  *	anything with it. Yet, as the same keycode table can be used with other
@@ -97,7 +99,6 @@ enum rc_filter_type {
  * @max_timeout: maximum timeout supported by device
  * @rx_resolution : resolution (in ns) of input sampler
  * @tx_resolution: resolution (in ns) of output sampler
- * @scancode_filters: scancode filters (indexed by enum rc_filter_type)
  * @change_protocol: allow changing the protocol used on hardware decoders
  * @change_wakeup_protocol: allow changing the protocol used for wakeup
  *	filtering
@@ -132,8 +133,12 @@ struct rc_dev {
 	struct input_dev		*input_dev;
 	enum rc_driver_type		driver_type;
 	bool				idle;
-	u64				allowed_protocols[RC_FILTER_MAX];
-	u64				enabled_protocols[RC_FILTER_MAX];
+	u64				allowed_protocols;
+	u64				enabled_protocols;
+	u64				allowed_wakeup_protocols;
+	u64				enabled_wakeup_protocols;
+	struct rc_scancode_filter	scancode_filter;
+	struct rc_scancode_filter	scancode_wakeup_filter;
 	u32				users;
 	u32				scanmask;
 	void				*priv;
@@ -150,7 +155,6 @@ struct rc_dev {
 	u32				max_timeout;
 	u32				rx_resolution;
 	u32				tx_resolution;
-	struct rc_scancode_filter	scancode_filters[RC_FILTER_MAX];
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_type);
 	int				(*change_wakeup_protocol)(struct rc_dev *dev, u64 *rc_type);
 	int				(*open)(struct rc_dev *dev);
@@ -171,42 +175,6 @@ struct rc_dev {
 
 #define to_rc_dev(d) container_of(d, struct rc_dev, dev)
 
-static inline bool rc_protocols_allowed(struct rc_dev *rdev, u64 protos)
-{
-	return rdev->allowed_protocols[RC_FILTER_NORMAL] & protos;
-}
-
-/* should be called prior to registration or with mutex held */
-static inline void rc_set_allowed_protocols(struct rc_dev *rdev, u64 protos)
-{
-	rdev->allowed_protocols[RC_FILTER_NORMAL] = protos;
-}
-
-static inline bool rc_protocols_enabled(struct rc_dev *rdev, u64 protos)
-{
-	return rdev->enabled_protocols[RC_FILTER_NORMAL] & protos;
-}
-
-/* should be called prior to registration or with mutex held */
-static inline void rc_set_enabled_protocols(struct rc_dev *rdev, u64 protos)
-{
-	rdev->enabled_protocols[RC_FILTER_NORMAL] = protos;
-}
-
-/* should be called prior to registration or with mutex held */
-static inline void rc_set_allowed_wakeup_protocols(struct rc_dev *rdev,
-						   u64 protos)
-{
-	rdev->allowed_protocols[RC_FILTER_WAKEUP] = protos;
-}
-
-/* should be called prior to registration or with mutex held */
-static inline void rc_set_enabled_wakeup_protocols(struct rc_dev *rdev,
-						   u64 protos)
-{
-	rdev->enabled_protocols[RC_FILTER_WAKEUP] = protos;
-}
-
 /*
  * From rc-main.c
  * Those functions can be used on any type of Remote Controller. They

commit 120703f9eb32033f0e39bdc552c0273c8ab45f33
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 3 20:31:30 2014 -0300

    [media] rc-core: document the protocol type
    
    Right now the protocol information is not preserved, rc-core gets handed a
    scancode but has no idea which protocol it corresponds to.
    
    This patch (which required reading through the source/keymap for all drivers,
    not fun) makes the protocol information explicit which is important
    documentation and makes it easier to e.g. support multiple protocols with one
    decoder (think rc5 and rc-streamzap). The information isn't used yet so there
    should be no functional changes.
    
    [m.chehab@samsung.com: rebased, added cxusb and removed bad whitespacing]
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index fde142e5f25a..00811c9e22b0 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -89,6 +89,7 @@ enum rc_filter_type {
  * @keyup_jiffies: time (in jiffies) when the current keypress should be released
  * @timer_keyup: timer for releasing a keypress
  * @last_keycode: keycode of last keypress
+ * @last_protocol: protocol of last keypress
  * @last_scancode: scancode of last keypress
  * @last_toggle: toggle value of last command
  * @timeout: optional time after which device stops sending data
@@ -113,7 +114,7 @@ enum rc_filter_type {
  *	device doesn't interrupt host until it sees IR pulses
  * @s_learning_mode: enable wide band receiver used for learning
  * @s_carrier_report: enable carrier reports
- * @s_filter: set the scancode filter 
+ * @s_filter: set the scancode filter
  * @s_wakeup_filter: set the wakeup scancode filter
  */
 struct rc_dev {
@@ -141,6 +142,7 @@ struct rc_dev {
 	unsigned long			keyup_jiffies;
 	struct timer_list		timer_keyup;
 	u32				last_keycode;
+	enum rc_type			last_protocol;
 	u32				last_scancode;
 	u8				last_toggle;
 	u32				timeout;
@@ -221,8 +223,8 @@ int rc_open(struct rc_dev *rdev);
 void rc_close(struct rc_dev *rdev);
 
 void rc_repeat(struct rc_dev *dev);
-void rc_keydown(struct rc_dev *dev, int scancode, u8 toggle);
-void rc_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle);
+void rc_keydown(struct rc_dev *dev, enum rc_type protocol, u32 scancode, u8 toggle);
+void rc_keydown_notimeout(struct rc_dev *dev, enum rc_type protocol, u32 scancode, u8 toggle);
 void rc_keyup(struct rc_dev *dev);
 u32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
 

commit 99b0f3c96cebf3af9a645d9b00db14cb04fcdfa2
Author: David Härdeman <david@hardeman.nu>
Date:   Fri Apr 4 19:06:06 2014 -0300

    [media] rc-core: remove generic scancode filter
    
    The generic scancode filtering has questionable value and makes it
    impossible to determine from userspace if there is an actual
    scancode hw filter present or not.
    
    So revert the generic parts.
    
    Based on a patch from James Hogan <james.hogan@imgtec.com>, but this
    version also makes sure that only the valid sysfs files are created
    in the first place.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 6dbc7c11224f..fde142e5f25a 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -60,6 +60,7 @@ enum rc_filter_type {
 /**
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
+ * @sysfs_groups: sysfs attribute groups
  * @input_name: name of the input child device
  * @input_phys: physical path to the input child device
  * @input_id: id of the input child device (struct input_id)
@@ -117,6 +118,7 @@ enum rc_filter_type {
  */
 struct rc_dev {
 	struct device			dev;
+	const struct attribute_group	*sysfs_groups[5];
 	const char			*input_name;
 	const char			*input_phys;
 	struct input_id			input_id;

commit 23c843b5eb11198e7de3a2af0756d1f897117932
Author: David Härdeman <david@hardeman.nu>
Date:   Fri Apr 4 19:06:01 2014 -0300

    [media] rc-core: split dev->s_filter
    
    Overloading dev->s_filter to do two different functions (set wakeup filters
    and generic hardware filters) makes it impossible to tell what the
    hardware actually supports, so create a separate dev->s_wakeup_filter and
    make the distinction explicit.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Acked-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 0b9f890ce431..6dbc7c11224f 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -112,7 +112,8 @@ enum rc_filter_type {
  *	device doesn't interrupt host until it sees IR pulses
  * @s_learning_mode: enable wide band receiver used for learning
  * @s_carrier_report: enable carrier reports
- * @s_filter: set the scancode filter of a given type
+ * @s_filter: set the scancode filter 
+ * @s_wakeup_filter: set the wakeup scancode filter
  */
 struct rc_dev {
 	struct device			dev;
@@ -159,8 +160,9 @@ struct rc_dev {
 	int				(*s_learning_mode)(struct rc_dev *dev, int enable);
 	int				(*s_carrier_report) (struct rc_dev *dev, int enable);
 	int				(*s_filter)(struct rc_dev *dev,
-						    enum rc_filter_type type,
 						    struct rc_scancode_filter *filter);
+	int				(*s_wakeup_filter)(struct rc_dev *dev,
+							   struct rc_scancode_filter *filter);
 };
 
 #define to_rc_dev(d) container_of(d, struct rc_dev, dev)

commit ab88c66deace78989aa71cb139284cf7fb227ba4
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 28 20:17:05 2014 -0300

    [media] rc: add wakeup_protocols sysfs file
    
    Add a wakeup_protocols sysfs file which controls the new
    rc_dev::enabled_protocols[RC_FILTER_WAKEUP], which is the mask of
    protocols that are used for the wakeup filter.
    
    A new RC driver callback change_wakeup_protocol() is called to change
    the wakeup protocol mask.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index f165115597f5..0b9f890ce431 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -97,6 +97,8 @@ enum rc_filter_type {
  * @tx_resolution: resolution (in ns) of output sampler
  * @scancode_filters: scancode filters (indexed by enum rc_filter_type)
  * @change_protocol: allow changing the protocol used on hardware decoders
+ * @change_wakeup_protocol: allow changing the protocol used for wakeup
+ *	filtering
  * @open: callback to allow drivers to enable polling/irq when IR input device
  *	is opened.
  * @close: callback to allow drivers to disable polling/irq when IR input device
@@ -145,6 +147,7 @@ struct rc_dev {
 	u32				tx_resolution;
 	struct rc_scancode_filter	scancode_filters[RC_FILTER_MAX];
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_type);
+	int				(*change_wakeup_protocol)(struct rc_dev *dev, u64 *rc_type);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
 	int				(*s_tx_mask)(struct rc_dev *dev, u32 mask);

commit acff5f24732acc8a55d0a0f0ee1d19442267df63
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 28 20:17:04 2014 -0300

    [media] rc: add allowed/enabled wakeup protocol masks
    
    Only a single allowed and enabled protocol mask currently exists in
    struct rc_dev, however to support a separate wakeup filter protocol two
    of each are needed, ideally as an array.
    
    Therefore make both rc_dev::allowed_protos and rc_dev::enabled_protocols
    arrays, update all users to reference the first element
    (RC_FILTER_NORMAL), and add a couple more helper functions for drivers
    to use for setting the allowed and enabled wakeup protocols.
    
    We also rename allowed_protos to allowed_protocols while we're at it,
    which is more consistent with enabled_protocols.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 6f3c3d977c81..f165115597f5 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -73,8 +73,10 @@ enum rc_filter_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
- * @allowed_protos: bitmask with the supported RC_BIT_* protocols
- * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
+ * @allowed_protocols: bitmask with the supported RC_BIT_* protocols for each
+ *	filter type
+ * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols for each
+ *	filter type
  * @scanmask: some hardware decoders are not capable of providing the full
  *	scancode to the application. As this is a hardware limit, we can't do
  *	anything with it. Yet, as the same keycode table can be used with other
@@ -124,8 +126,8 @@ struct rc_dev {
 	struct input_dev		*input_dev;
 	enum rc_driver_type		driver_type;
 	bool				idle;
-	u64				allowed_protos;
-	u64				enabled_protocols;
+	u64				allowed_protocols[RC_FILTER_MAX];
+	u64				enabled_protocols[RC_FILTER_MAX];
 	u32				users;
 	u32				scanmask;
 	void				*priv;
@@ -162,24 +164,38 @@ struct rc_dev {
 
 static inline bool rc_protocols_allowed(struct rc_dev *rdev, u64 protos)
 {
-	return rdev->allowed_protos & protos;
+	return rdev->allowed_protocols[RC_FILTER_NORMAL] & protos;
 }
 
 /* should be called prior to registration or with mutex held */
 static inline void rc_set_allowed_protocols(struct rc_dev *rdev, u64 protos)
 {
-	rdev->allowed_protos = protos;
+	rdev->allowed_protocols[RC_FILTER_NORMAL] = protos;
 }
 
 static inline bool rc_protocols_enabled(struct rc_dev *rdev, u64 protos)
 {
-	return rdev->enabled_protocols & protos;
+	return rdev->enabled_protocols[RC_FILTER_NORMAL] & protos;
 }
 
 /* should be called prior to registration or with mutex held */
 static inline void rc_set_enabled_protocols(struct rc_dev *rdev, u64 protos)
 {
-	rdev->enabled_protocols = protos;
+	rdev->enabled_protocols[RC_FILTER_NORMAL] = protos;
+}
+
+/* should be called prior to registration or with mutex held */
+static inline void rc_set_allowed_wakeup_protocols(struct rc_dev *rdev,
+						   u64 protos)
+{
+	rdev->allowed_protocols[RC_FILTER_WAKEUP] = protos;
+}
+
+/* should be called prior to registration or with mutex held */
+static inline void rc_set_enabled_wakeup_protocols(struct rc_dev *rdev,
+						   u64 protos)
+{
+	rdev->enabled_protocols[RC_FILTER_WAKEUP] = protos;
 }
 
 /*

commit 1a1934fab0c920f0d3bceeb60c9fe2dae8a56be9
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 28 20:17:03 2014 -0300

    [media] rc: abstract access to allowed/enabled protocols
    
    The allowed and enabled protocol masks need to be expanded to be per
    filter type in order to support wakeup filter protocol selection. To
    ease that process abstract access to the rc_dev::allowed_protos and
    rc_dev::enabled_protocols members with inline functions.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Antti Seppälä <a.seppala@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 5e7197e40c14..6f3c3d977c81 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -160,6 +160,28 @@ struct rc_dev {
 
 #define to_rc_dev(d) container_of(d, struct rc_dev, dev)
 
+static inline bool rc_protocols_allowed(struct rc_dev *rdev, u64 protos)
+{
+	return rdev->allowed_protos & protos;
+}
+
+/* should be called prior to registration or with mutex held */
+static inline void rc_set_allowed_protocols(struct rc_dev *rdev, u64 protos)
+{
+	rdev->allowed_protos = protos;
+}
+
+static inline bool rc_protocols_enabled(struct rc_dev *rdev, u64 protos)
+{
+	return rdev->enabled_protocols & protos;
+}
+
+/* should be called prior to registration or with mutex held */
+static inline void rc_set_enabled_protocols(struct rc_dev *rdev, u64 protos)
+{
+	rdev->enabled_protocols = protos;
+}
+
 /*
  * From rc-main.c
  * Those functions can be used on any type of Remote Controller. They

commit 37e59f876bc710d67a30b660826a5e83e07101ce
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Feb 7 08:03:07 2014 -0200

    [media, edac] Change my email address
    
    There are several left overs with my old email address.
    Remove their occurrences and add myself at CREDITS, to
    allow people to be able to reach me on my new addresses.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 4a72176e04f6..5e7197e40c14 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -1,7 +1,7 @@
 /*
  * Remote Controller core header
  *
- * Copyright (C) 2009-2010 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ * Copyright (C) 2009-2010 by Mauro Carvalho Chehab
  *
  * This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by

commit 00942d1a1bd93ac108c1b92d504c568a37be1833
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Jan 17 10:58:49 2014 -0300

    [media] media: rc: add sysfs scancode filtering interface
    
    Add and document a generic sysfs based scancode filtering interface for
    making use of IR data matching hardware to filter out uninteresting
    scancodes. Two filters exist, one for normal operation and one for
    filtering scancodes which are permitted to wake the system from suspend.
    
    The following files are added to /sys/class/rc/rc?/:
     - filter: normal scancode filter value
     - filter_mask: normal scancode filter mask
     - wakeup_filter: wakeup scancode filter value
     - wakeup_filter_mask: wakeup scancode filter mask
    
    A new s_filter() driver callback is added which must arrange for the
    specified filter to be applied at the right time. Drivers can convert
    the scancode filter into a raw IR data filter, which can be applied
    immediately or later (for wake up filters).
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Cc: linux-media@vger.kernel.org
    Cc: Rob Landley <rob@landley.net>
    Cc: linux-doc@vger.kernel.org
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 2f6f1f78d958..4a72176e04f6 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -34,6 +34,29 @@ enum rc_driver_type {
 	RC_DRIVER_IR_RAW,	/* Needs a Infra-Red pulse/space decoder */
 };
 
+/**
+ * struct rc_scancode_filter - Filter scan codes.
+ * @data:	Scancode data to match.
+ * @mask:	Mask of bits of scancode to compare.
+ */
+struct rc_scancode_filter {
+	u32 data;
+	u32 mask;
+};
+
+/**
+ * enum rc_filter_type - Filter type constants.
+ * @RC_FILTER_NORMAL:	Filter for normal operation.
+ * @RC_FILTER_WAKEUP:	Filter for waking from suspend.
+ * @RC_FILTER_MAX:	Number of filter types.
+ */
+enum rc_filter_type {
+	RC_FILTER_NORMAL = 0,
+	RC_FILTER_WAKEUP,
+
+	RC_FILTER_MAX
+};
+
 /**
  * struct rc_dev - represents a remote control device
  * @dev: driver model's view of this device
@@ -70,6 +93,7 @@ enum rc_driver_type {
  * @max_timeout: maximum timeout supported by device
  * @rx_resolution : resolution (in ns) of input sampler
  * @tx_resolution: resolution (in ns) of output sampler
+ * @scancode_filters: scancode filters (indexed by enum rc_filter_type)
  * @change_protocol: allow changing the protocol used on hardware decoders
  * @open: callback to allow drivers to enable polling/irq when IR input device
  *	is opened.
@@ -84,6 +108,7 @@ enum rc_driver_type {
  *	device doesn't interrupt host until it sees IR pulses
  * @s_learning_mode: enable wide band receiver used for learning
  * @s_carrier_report: enable carrier reports
+ * @s_filter: set the scancode filter of a given type
  */
 struct rc_dev {
 	struct device			dev;
@@ -116,6 +141,7 @@ struct rc_dev {
 	u32				max_timeout;
 	u32				rx_resolution;
 	u32				tx_resolution;
+	struct rc_scancode_filter	scancode_filters[RC_FILTER_MAX];
 	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_type);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
@@ -127,6 +153,9 @@ struct rc_dev {
 	void				(*s_idle)(struct rc_dev *dev, bool enable);
 	int				(*s_learning_mode)(struct rc_dev *dev, int enable);
 	int				(*s_carrier_report) (struct rc_dev *dev, int enable);
+	int				(*s_filter)(struct rc_dev *dev,
+						    enum rc_filter_type type,
+						    struct rc_scancode_filter *filter);
 };
 
 #define to_rc_dev(d) container_of(d, struct rc_dev, dev)

commit 8b2ff3204909687be26f20d63dcddc8e3d7a6c14
Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>
Date:   Mon Jul 22 04:22:57 2013 -0300

    [media] media: rc: Add rc_open/close and use count to rc_dev
    
    This patch adds user count to rc_dev structure, the reason to add this
    new member is to allow other code like lirc to open rc device directly.
    In the existing code, rc device is only opened by input subsystem which
    works ok if we have any input drivers to match. But in case like lirc
    where there will be no input driver, rc device will be never opened.
    Having this user count variable will be usefull to allow rc device to be
    opened from code other than rc-main.
    This patch also adds rc_open and rc_close functions for other drivers
    like lirc to open and close rc devices. This functions safely increment
    and decrement the user count. Other driver wanting to open rc device
    should call rc_open and rc_close, rather than directly modifying the
    rc_dev structure.
    
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@st.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 06a75deff553..2f6f1f78d958 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -101,6 +101,7 @@ struct rc_dev {
 	bool				idle;
 	u64				allowed_protos;
 	u64				enabled_protocols;
+	u32				users;
 	u32				scanmask;
 	void				*priv;
 	spinlock_t			keylock;
@@ -142,6 +143,9 @@ void rc_free_device(struct rc_dev *dev);
 int rc_register_device(struct rc_dev *dev);
 void rc_unregister_device(struct rc_dev *dev);
 
+int rc_open(struct rc_dev *rdev);
+void rc_close(struct rc_dev *rdev);
+
 void rc_repeat(struct rc_dev *dev);
 void rc_keydown(struct rc_dev *dev, int scancode, u8 toggle);
 void rc_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle);

commit 9719afae5e589b409e137c36f89073d134f0de33
Author: David Härdeman <david@hardeman.nu>
Date:   Wed Mar 6 16:52:05 2013 -0300

    [media] rc-core: don't treat dev->rc_map.rc_type as a bitmap
    
    store_protocols() treats dev->rc_map.rc_type as a bitmap which is wrong for
    two reasons. First of all, it is pretty bogus to change the protocol type of
    the keymap just because the hardware has been asked to decode a different
    protocol.
    Second, dev->rc_map.rc_type is an enum (i.e. a single protocol) as pointed
    out by James Hogan <james.hogan@imgtec.com>.
    Fix both issues by introducing a separate enabled_protocols member to
    struct rc_dev.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index f03445f3c767..06a75deff553 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -51,6 +51,7 @@ enum rc_driver_type {
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
  * @allowed_protos: bitmask with the supported RC_BIT_* protocols
+ * @enabled_protocols: bitmask with the enabled RC_BIT_* protocols
  * @scanmask: some hardware decoders are not capable of providing the full
  *	scancode to the application. As this is a hardware limit, we can't do
  *	anything with it. Yet, as the same keycode table can be used with other
@@ -99,6 +100,7 @@ struct rc_dev {
 	enum rc_driver_type		driver_type;
 	bool				idle;
 	u64				allowed_protos;
+	u64				enabled_protocols;
 	u32				scanmask;
 	void				*priv;
 	spinlock_t			keylock;

commit c003ab1bedf028db15b0185b683d5c387204e8f5
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Oct 11 19:11:54 2012 -0300

    [media] rc-core: add separate defines for protocol bitmaps and numbers
    
    The RC_TYPE_* defines are currently used both where a single protocol is
    expected and where a bitmap of protocols is expected.
    
    Functions like rc_keydown() and functions which add/remove entries to the
    keytable want a single protocol. Future userspace APIs would also
    benefit from numeric protocols (rather than bitmap ones). Keytables are
    smaller if they can use a small(ish) integer rather than a bitmap.
    
    Other functions or struct members (e.g. allowed_protos,
    enabled_protocols, etc) accept multiple protocols and need a bitmap.
    
    Using different types reduces the risk of programmer error. Using a
    protocol enum whereever possible also makes for a more future-proof
    user-space API as we don't need to worry about a sufficient number of
    bits being available (e.g. in structs used for ioctl() calls).
    
    The use of both a number and a corresponding bit is dalso one in e.g.
    the input subsystem as well (see all the references to set/clear bit when
    changing keytables for example).
    
    This patch separate the different usages in preparation for
    upcoming patches.
    
    Where a single protocol is expected, enum rc_type is used; where one or more
    protocol(s) are expected, something like u64 is used.
    
    The patch has been rewritten so that the format of the sysfs "protocols"
    file is no longer altered (at the loss of some detail). The file itself
    should probably be deprecated in the future though.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Cc: Andy Walls <awalls@md.metrocast.net>
    Cc: Maxim Levitsky <maximlevitsky@gmail.com>
    Cc: Antti Palosaari <crope@iki.fi>
    Cc: Mike Isely <isely@pobox.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b0c494a69079..f03445f3c767 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -50,7 +50,7 @@ enum rc_driver_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
- * @allowed_protos: bitmask with the supported RC_TYPE_* protocols
+ * @allowed_protos: bitmask with the supported RC_BIT_* protocols
  * @scanmask: some hardware decoders are not capable of providing the full
  *	scancode to the application. As this is a hardware limit, we can't do
  *	anything with it. Yet, as the same keycode table can be used with other
@@ -113,7 +113,7 @@ struct rc_dev {
 	u32				max_timeout;
 	u32				rx_resolution;
 	u32				tx_resolution;
-	int				(*change_protocol)(struct rc_dev *dev, u64 rc_type);
+	int				(*change_protocol)(struct rc_dev *dev, u64 *rc_type);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
 	int				(*s_tx_mask)(struct rc_dev *dev, u32 mask);

commit 86b0dbef777a1fbb9922e304f047921d4e9d9c40
Author: Joe Perches <joe@perches.com>
Date:   Sun Aug 21 19:56:45 2011 -0300

    [media] rc-core.h: Surround macro with do {} while (0)
    
    Macros coded with if statements should be do { if... } while (0)
    so the macros can be used in other if tests.
    
    Use ##__VA_ARGS__ for variadic macro as well.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index b1f19b77ecd4..b0c494a69079 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -23,8 +23,11 @@
 #include <media/rc-map.h>
 
 extern int rc_core_debug;
-#define IR_dprintk(level, fmt, arg...)	if (rc_core_debug >= level) \
-	printk(KERN_DEBUG "%s: " fmt , __func__, ## arg)
+#define IR_dprintk(level, fmt, ...)				\
+do {								\
+	if (rc_core_debug >= level)				\
+		pr_debug("%s: " fmt, __func__, ##__VA_ARGS__);	\
+} while (0)
 
 enum rc_driver_type {
 	RC_DRIVER_SCANCODE = 0,	/* Driver or hardware generates a scancode */

commit 5588dc2b025fd8b2188142b8d59efe562bd57d80
Author: David Härdeman <david@hardeman.nu>
Date:   Thu Apr 28 12:13:58 2011 -0300

    [media] rc-core: lirc use unsigned int
    
    Durations can never be negative, so it makes sense to consistently use
    unsigned int for LIRC transmission. Contrary to the initial impression,
    this shouldn't actually change the userspace API.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 60536c74c1ea..b1f19b77ecd4 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -117,7 +117,7 @@ struct rc_dev {
 	int				(*s_tx_carrier)(struct rc_dev *dev, u32 carrier);
 	int				(*s_tx_duty_cycle)(struct rc_dev *dev, u32 duty_cycle);
 	int				(*s_rx_carrier_range)(struct rc_dev *dev, u32 min, u32 max);
-	int				(*tx_ir)(struct rc_dev *dev, int *txbuf, u32 n);
+	int				(*tx_ir)(struct rc_dev *dev, unsigned *txbuf, unsigned n);
 	void				(*s_idle)(struct rc_dev *dev, bool enable);
 	int				(*s_learning_mode)(struct rc_dev *dev, int enable);
 	int				(*s_carrier_report) (struct rc_dev *dev, int enable);

commit 08aeb7c9a42ab7aa8b53c8f7779ec58f860a565c
Author: Jarod Wilson <jarod@redhat.com>
Date:   Wed May 11 15:14:31 2011 -0300

    [media] rc: add locking to fix register/show race
    
    When device_add is called in rc_register_device, the rc sysfs nodes show
    up, and there's a window in which ir-keytable can be launched via udev
    and trigger a show_protocols call, which runs without various rc_dev
    fields filled in yet. Add some locking around registration and
    store/show_protocols to prevent that from happening.
    
    The problem manifests thusly:
    
    [64692.957872] BUG: unable to handle kernel NULL pointer dereference at 0000000000000090
    [64692.957878] IP: [<ffffffffa036a4c1>] show_protocols+0x47/0xf1 [rc_core]
    [64692.957890] PGD 19cfc7067 PUD 19cfc6067 PMD 0
    [64692.957894] Oops: 0000 [#1] SMP
    [64692.957897] last sysfs file: /sys/devices/pci0000:00/0000:00:03.1/usb3/3-1/3-1:1.0/rc/rc2/protocols
    [64692.957902] CPU 3
    [64692.957903] Modules linked in: redrat3(+) ir_lirc_codec lirc_dev ir_sony_decoder ir_jvc_decoder ir_rc6_decoder ir_rc5_decoder rc_hauppauge ir_nec
    _decoder rc_core ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 ip6table_filter ip6_tables snd_emu10k1_synth snd_emux_synth snd_seq_virmidi snd_seq_mi
    di_event snd_seq_midi_emul snd_emu10k1 snd_rawmidi snd_ac97_codec ac97_bus snd_seq snd_pcm snd_seq_device snd_timer snd_page_alloc snd_util_mem pcsp
    kr tg3 snd_hwdep emu10k1_gp snd amd64_edac_mod gameport edac_core soundcore edac_mce_amd k8temp shpchp i2c_piix4 lm63 e100 mii uinput ipv6 raid0 rai
    d1 ata_generic firewire_ohci pata_acpi firewire_core crc_itu_t sata_svw pata_serverworks floppy radeon ttm drm_kms_helper drm i2c_algo_bit i2c_core
    [last unloaded: redrat3]
    [64692.957949] [64692.957952] Pid: 12265, comm: ir-keytable Tainted: G   M    W   2.6.39-rc6+ #2 empty empty/TYAN Thunder K8HM S3892
    [64692.957957] RIP: 0010:[<ffffffffa036a4c1>]  [<ffffffffa036a4c1>] show_protocols+0x47/0xf1 [rc_core]
    [64692.957962] RSP: 0018:ffff880194509e38  EFLAGS: 00010202
    [64692.957964] RAX: 0000000000000000 RBX: ffffffffa036d1e0 RCX: ffffffffa036a47a
    [64692.957966] RDX: ffff88019a84d000 RSI: ffffffffa036d1e0 RDI: ffff88019cf2f3f0
    [64692.957969] RBP: ffff880194509e68 R08: 0000000000000002 R09: 0000000000000000
    [64692.957971] R10: 0000000000000002 R11: 0000000000001617 R12: ffff88019a84d000
    [64692.957973] R13: 0000000000001000 R14: ffff8801944d2e38 R15: ffff88019ce5f190
    [64692.957976] FS:  00007f0a30c9a720(0000) GS:ffff88019fc00000(0000) knlGS:0000000000000000
    [64692.957979] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [64692.957981] CR2: 0000000000000090 CR3: 000000019a8e0000 CR4: 00000000000006e0
    [64692.957983] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [64692.957986] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [64692.957989] Process ir-keytable (pid: 12265, threadinfo ffff880194508000, task ffff88019a9fc720)
    [64692.957991] Stack:
    [64692.957992]  0000000000000002 ffffffffa036d1e0 ffff880194509f58 0000000000001000
    [64692.957997]  ffff8801944d2e38 ffff88019ce5f190 ffff880194509e98 ffffffff8131484b
    [64692.958001]  ffffffff8118e923 ffffffff810e9b2f ffff880194509e98 ffff8801944d2e18
    [64692.958005] Call Trace:
    [64692.958014]  [<ffffffff8131484b>] dev_attr_show+0x27/0x4e
    [64692.958014]  [<ffffffff8118e923>] ? sysfs_read_file+0x94/0x172
    [64692.958014]  [<ffffffff810e9b2f>] ? __get_free_pages+0x16/0x52
    [64692.958014]  [<ffffffff8118e94c>] sysfs_read_file+0xbd/0x172
    [64692.958014]  [<ffffffff8113205e>] vfs_read+0xac/0xf3
    [64692.958014]  [<ffffffff8113347b>] ? fget_light+0x3a/0xa1
    [64692.958014]  [<ffffffff811320f2>] sys_read+0x4d/0x74
    [64692.958014]  [<ffffffff814c19c2>] system_call_fastpath+0x16/0x1b
    
    Its a bit difficult to reproduce, but I'm fairly confident this has
    fixed the problem.
    
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 2963263f31e2..60536c74c1ea 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -40,10 +40,12 @@ enum rc_driver_type {
  * @driver_name: name of the hardware driver which registered this device
  * @map_name: name of the default keymap
  * @rc_map: current scan/key table
+ * @lock: used to ensure we've filled in all protocol details before
+ *	anyone can call show_protocols or store_protocols
  * @devno: unique remote control device number
  * @raw: additional data for raw pulse/space devices
  * @input_dev: the input child device used to communicate events to userspace
- * @driver_type: specifies if protocol decoding is done in hardware or software 
+ * @driver_type: specifies if protocol decoding is done in hardware or software
  * @idle: used to keep track of RX state
  * @allowed_protos: bitmask with the supported RC_TYPE_* protocols
  * @scanmask: some hardware decoders are not capable of providing the full
@@ -86,7 +88,8 @@ struct rc_dev {
 	struct input_id			input_id;
 	char				*driver_name;
 	const char			*map_name;
-	struct rc_map	rc_map;
+	struct rc_map			rc_map;
+	struct mutex			lock;
 	unsigned long			devno;
 	struct ir_raw_event_ctrl	*raw;
 	struct input_dev		*input_dev;

commit 5aad724280b9f8ffff3a55311ef0ba35ebb4099a
Author: Jarod Wilson <jarod@redhat.com>
Date:   Thu Jan 6 16:59:36 2011 -0300

    [media] rc: fix up and genericize some time unit conversions
    
    The ene_ir driver was using a private define of MS_TO_NS, which is meant
    to be microseconds to nanoseconds. The mceusb driver copied it,
    intending to use is a milliseconds to microseconds. Lets move the
    defines to a common location, expand and standardize them a touch, so
    that we now have:
    
      MS_TO_NS - milliseconds to nanoseconds
      MS_TO_US - milliseconds to microseconds
      US_TO_NS - microseconds to nanoseconds
    
    Reported-by: David Härdeman <david@hardeman.nu>
    CC: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index a23c1fc685a1..2963263f31e2 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -183,6 +183,9 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 }
 
 #define IR_MAX_DURATION         0xFFFFFFFF      /* a bit more than 4 seconds */
+#define US_TO_NS(usec)		((usec) * 1000)
+#define MS_TO_US(msec)		((msec) * 1000)
+#define MS_TO_NS(msec)		((msec) * 1000 * 1000)
 
 void ir_raw_event_handle(struct rc_dev *dev);
 int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);

commit 829ba9fe34246f1f5e813b6bf84171d36e776734
Author: David HÃ¤rdeman <david@hardeman.nu>
Date:   Fri Nov 19 20:43:27 2010 -0300

    [media] rc-core: fix some leftovers from the renaming patches
    
    Fix some minor comments etc which are leftover from the old naming scheme.
    
    Signed-off-by: David Härdeman <david@hardeman.nu>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index affb93feed3b..a23c1fc685a1 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -206,12 +206,12 @@ static inline u32 ir_extract_bits(u32 data, u32 mask)
 	u32 vbit = 1, value = 0;
 
 	do {
-	    if (mask & 1) {
-		if (data & 1)
-			value |= vbit;
-		vbit <<= 1;
-	    }
-	    data >>= 1;
+		if (mask & 1) {
+			if (data & 1)
+				value |= vbit;
+			vbit <<= 1;
+		}
+		data >>= 1;
 	} while (mask >>= 1);
 
 	return value;

commit b088ba658b3438056dab4d744701364db3f08b9a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 17 14:28:27 2010 -0300

    [media] rc: Properly name the rc_map struct
    
    The struct that describes a rc mapping had an weird and long name.
    We should properly name it, to make easier for developers to work
    with it, and to avoid confusion.
    
    Basically, generated by this script:
    
    for i in `find drivers/staging -type f -name *.[ch]` `find include/media -type f -name *.[ch]` `find drivers/media -type f -name *.[ch]`; do sed s,ir_scancode_table,rc_map,g <$i >a && mv a $i; done
    for i in `find drivers/staging -type f -name *.[ch]` `find include/media -type f -name *.[ch]` `find drivers/media -type f -name *.[ch]`; do sed s,rc_tab,rc_map,g <$i >a && mv a $i; done
    
    (and manually fixed where needed)
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 42543257fa0f..affb93feed3b 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -39,7 +39,7 @@ enum rc_driver_type {
  * @input_id: id of the input child device (struct input_id)
  * @driver_name: name of the hardware driver which registered this device
  * @map_name: name of the default keymap
- * @rc_tab: current scan/key table
+ * @rc_map: current scan/key table
  * @devno: unique remote control device number
  * @raw: additional data for raw pulse/space devices
  * @input_dev: the input child device used to communicate events to userspace
@@ -86,7 +86,7 @@ struct rc_dev {
 	struct input_id			input_id;
 	char				*driver_name;
 	const char			*map_name;
-	struct ir_scancode_table	rc_tab;
+	struct rc_map	rc_map;
 	unsigned long			devno;
 	struct ir_raw_event_ctrl	*raw;
 	struct input_dev		*input_dev;

commit 52b661449aecc47e652a164c0d8078b31e10aca0
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 17 14:20:52 2010 -0300

    [media] rc: Rename remote controller type to rc_type instead of ir_type
    
    for i in `find drivers/staging -type f -name *.[ch]` `find include/media -type f -name *.[ch]` `find drivers/media -type f -name *.[ch]`; do sed s,IR_TYPE,RC_TYPE,g <$i >a && mv a $i; done
    for i in `find drivers/staging -type f -name *.[ch]` `find include/media -type f -name *.[ch]` `find drivers/media -type f -name *.[ch]`; do sed s,ir_type,rc_type,g <$i >a && mv a $i; done
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index 170581b4fa84..42543257fa0f 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -45,7 +45,7 @@ enum rc_driver_type {
  * @input_dev: the input child device used to communicate events to userspace
  * @driver_type: specifies if protocol decoding is done in hardware or software 
  * @idle: used to keep track of RX state
- * @allowed_protos: bitmask with the supported IR_TYPE_* protocols
+ * @allowed_protos: bitmask with the supported RC_TYPE_* protocols
  * @scanmask: some hardware decoders are not capable of providing the full
  *	scancode to the application. As this is a hardware limit, we can't do
  *	anything with it. Yet, as the same keycode table can be used with other
@@ -107,7 +107,7 @@ struct rc_dev {
 	u32				max_timeout;
 	u32				rx_resolution;
 	u32				tx_resolution;
-	int				(*change_protocol)(struct rc_dev *dev, u64 ir_type);
+	int				(*change_protocol)(struct rc_dev *dev, u64 rc_type);
 	int				(*open)(struct rc_dev *dev);
 	void				(*close)(struct rc_dev *dev);
 	int				(*s_tx_mask)(struct rc_dev *dev, u32 mask);

commit ca86674b8a93ea11c4bb6f4dd0113b1adf1fa841
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 17 13:53:11 2010 -0300

    [media] Rename all public generic RC functions from ir_ to rc_
    
    Those functions are not InfraRed specific. So, rename them to properly
    reflect it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
index eedb2f0575a4..170581b4fa84 100644
--- a/include/media/rc-core.h
+++ b/include/media/rc-core.h
@@ -13,8 +13,8 @@
  *  GNU General Public License for more details.
  */
 
-#ifndef _IR_CORE
-#define _IR_CORE
+#ifndef _RC_CORE
+#define _RC_CORE
 
 #include <linux/spinlock.h>
 #include <linux/kfifo.h>
@@ -120,6 +120,32 @@ struct rc_dev {
 	int				(*s_carrier_report) (struct rc_dev *dev, int enable);
 };
 
+#define to_rc_dev(d) container_of(d, struct rc_dev, dev)
+
+/*
+ * From rc-main.c
+ * Those functions can be used on any type of Remote Controller. They
+ * basically creates an input_dev and properly reports the device as a
+ * Remote Controller, at sys/class/rc.
+ */
+
+struct rc_dev *rc_allocate_device(void);
+void rc_free_device(struct rc_dev *dev);
+int rc_register_device(struct rc_dev *dev);
+void rc_unregister_device(struct rc_dev *dev);
+
+void rc_repeat(struct rc_dev *dev);
+void rc_keydown(struct rc_dev *dev, int scancode, u8 toggle);
+void rc_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle);
+void rc_keyup(struct rc_dev *dev);
+u32 rc_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
+
+/*
+ * From rc-raw.c
+ * The Raw interface is specific to InfraRed. It may be a good idea to
+ * split it later into a separate header.
+ */
+
 enum raw_event_type {
 	IR_SPACE        = (1 << 0),
 	IR_PULSE        = (1 << 1),
@@ -127,16 +153,6 @@ enum raw_event_type {
 	IR_STOP_EVENT   = (1 << 3),
 };
 
-#define to_rc_dev(d) container_of(d, struct rc_dev, dev)
-
-
-void ir_repeat(struct rc_dev *dev);
-void ir_keydown(struct rc_dev *dev, int scancode, u8 toggle);
-void ir_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle);
-void ir_keyup(struct rc_dev *dev);
-u32 ir_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
-
-/* From ir-raw-event.c */
 struct ir_raw_event {
 	union {
 		u32             duration;
@@ -168,11 +184,6 @@ static inline void init_ir_raw_event(struct ir_raw_event *ev)
 
 #define IR_MAX_DURATION         0xFFFFFFFF      /* a bit more than 4 seconds */
 
-struct rc_dev *rc_allocate_device(void);
-void rc_free_device(struct rc_dev *dev);
-int rc_register_device(struct rc_dev *dev);
-void rc_unregister_device(struct rc_dev *dev);
-
 void ir_raw_event_handle(struct rc_dev *dev);
 int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);
 int ir_raw_event_store_edge(struct rc_dev *dev, enum raw_event_type type);
@@ -189,7 +200,6 @@ static inline void ir_raw_event_reset(struct rc_dev *dev)
 	ir_raw_event_handle(dev);
 }
 
-
 /* extract mask bits out of data and pack them into the result */
 static inline u32 ir_extract_bits(u32 data, u32 mask)
 {
@@ -207,5 +217,4 @@ static inline u32 ir_extract_bits(u32 data, u32 mask)
 	return value;
 }
 
-
-#endif /* _IR_CORE */
+#endif /* _RC_CORE */

commit 6bda96447cef24fbf97a798b1ea664224d5fdc25
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Nov 17 13:28:38 2010 -0300

    [media] rc: rename the remaining things to rc_core
    
    The Remote Controller subsystem is meant to be used not only by Infra Red
    but also for similar types of Remote Controllers. The core is not specific
    to Infra Red. As such, rename:
            - ir-core.h to rc-core.h
            - IR_CORE to RC_CORE
            - namespace inside rc-core.c/rc-core.h
    
    To be consistent with the other changes.
    
    No functional change on this patch.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/rc-core.h b/include/media/rc-core.h
new file mode 100644
index 000000000000..eedb2f0575a4
--- /dev/null
+++ b/include/media/rc-core.h
@@ -0,0 +1,211 @@
+/*
+ * Remote Controller core header
+ *
+ * Copyright (C) 2009-2010 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef _IR_CORE
+#define _IR_CORE
+
+#include <linux/spinlock.h>
+#include <linux/kfifo.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <media/rc-map.h>
+
+extern int rc_core_debug;
+#define IR_dprintk(level, fmt, arg...)	if (rc_core_debug >= level) \
+	printk(KERN_DEBUG "%s: " fmt , __func__, ## arg)
+
+enum rc_driver_type {
+	RC_DRIVER_SCANCODE = 0,	/* Driver or hardware generates a scancode */
+	RC_DRIVER_IR_RAW,	/* Needs a Infra-Red pulse/space decoder */
+};
+
+/**
+ * struct rc_dev - represents a remote control device
+ * @dev: driver model's view of this device
+ * @input_name: name of the input child device
+ * @input_phys: physical path to the input child device
+ * @input_id: id of the input child device (struct input_id)
+ * @driver_name: name of the hardware driver which registered this device
+ * @map_name: name of the default keymap
+ * @rc_tab: current scan/key table
+ * @devno: unique remote control device number
+ * @raw: additional data for raw pulse/space devices
+ * @input_dev: the input child device used to communicate events to userspace
+ * @driver_type: specifies if protocol decoding is done in hardware or software 
+ * @idle: used to keep track of RX state
+ * @allowed_protos: bitmask with the supported IR_TYPE_* protocols
+ * @scanmask: some hardware decoders are not capable of providing the full
+ *	scancode to the application. As this is a hardware limit, we can't do
+ *	anything with it. Yet, as the same keycode table can be used with other
+ *	devices, a mask is provided to allow its usage. Drivers should generally
+ *	leave this field in blank
+ * @priv: driver-specific data
+ * @keylock: protects the remaining members of the struct
+ * @keypressed: whether a key is currently pressed
+ * @keyup_jiffies: time (in jiffies) when the current keypress should be released
+ * @timer_keyup: timer for releasing a keypress
+ * @last_keycode: keycode of last keypress
+ * @last_scancode: scancode of last keypress
+ * @last_toggle: toggle value of last command
+ * @timeout: optional time after which device stops sending data
+ * @min_timeout: minimum timeout supported by device
+ * @max_timeout: maximum timeout supported by device
+ * @rx_resolution : resolution (in ns) of input sampler
+ * @tx_resolution: resolution (in ns) of output sampler
+ * @change_protocol: allow changing the protocol used on hardware decoders
+ * @open: callback to allow drivers to enable polling/irq when IR input device
+ *	is opened.
+ * @close: callback to allow drivers to disable polling/irq when IR input device
+ *	is opened.
+ * @s_tx_mask: set transmitter mask (for devices with multiple tx outputs)
+ * @s_tx_carrier: set transmit carrier frequency
+ * @s_tx_duty_cycle: set transmit duty cycle (0% - 100%)
+ * @s_rx_carrier: inform driver about carrier it is expected to handle
+ * @tx_ir: transmit IR
+ * @s_idle: enable/disable hardware idle mode, upon which,
+ *	device doesn't interrupt host until it sees IR pulses
+ * @s_learning_mode: enable wide band receiver used for learning
+ * @s_carrier_report: enable carrier reports
+ */
+struct rc_dev {
+	struct device			dev;
+	const char			*input_name;
+	const char			*input_phys;
+	struct input_id			input_id;
+	char				*driver_name;
+	const char			*map_name;
+	struct ir_scancode_table	rc_tab;
+	unsigned long			devno;
+	struct ir_raw_event_ctrl	*raw;
+	struct input_dev		*input_dev;
+	enum rc_driver_type		driver_type;
+	bool				idle;
+	u64				allowed_protos;
+	u32				scanmask;
+	void				*priv;
+	spinlock_t			keylock;
+	bool				keypressed;
+	unsigned long			keyup_jiffies;
+	struct timer_list		timer_keyup;
+	u32				last_keycode;
+	u32				last_scancode;
+	u8				last_toggle;
+	u32				timeout;
+	u32				min_timeout;
+	u32				max_timeout;
+	u32				rx_resolution;
+	u32				tx_resolution;
+	int				(*change_protocol)(struct rc_dev *dev, u64 ir_type);
+	int				(*open)(struct rc_dev *dev);
+	void				(*close)(struct rc_dev *dev);
+	int				(*s_tx_mask)(struct rc_dev *dev, u32 mask);
+	int				(*s_tx_carrier)(struct rc_dev *dev, u32 carrier);
+	int				(*s_tx_duty_cycle)(struct rc_dev *dev, u32 duty_cycle);
+	int				(*s_rx_carrier_range)(struct rc_dev *dev, u32 min, u32 max);
+	int				(*tx_ir)(struct rc_dev *dev, int *txbuf, u32 n);
+	void				(*s_idle)(struct rc_dev *dev, bool enable);
+	int				(*s_learning_mode)(struct rc_dev *dev, int enable);
+	int				(*s_carrier_report) (struct rc_dev *dev, int enable);
+};
+
+enum raw_event_type {
+	IR_SPACE        = (1 << 0),
+	IR_PULSE        = (1 << 1),
+	IR_START_EVENT  = (1 << 2),
+	IR_STOP_EVENT   = (1 << 3),
+};
+
+#define to_rc_dev(d) container_of(d, struct rc_dev, dev)
+
+
+void ir_repeat(struct rc_dev *dev);
+void ir_keydown(struct rc_dev *dev, int scancode, u8 toggle);
+void ir_keydown_notimeout(struct rc_dev *dev, int scancode, u8 toggle);
+void ir_keyup(struct rc_dev *dev);
+u32 ir_g_keycode_from_table(struct rc_dev *dev, u32 scancode);
+
+/* From ir-raw-event.c */
+struct ir_raw_event {
+	union {
+		u32             duration;
+
+		struct {
+			u32     carrier;
+			u8      duty_cycle;
+		};
+	};
+
+	unsigned                pulse:1;
+	unsigned                reset:1;
+	unsigned                timeout:1;
+	unsigned                carrier_report:1;
+};
+
+#define DEFINE_IR_RAW_EVENT(event) \
+	struct ir_raw_event event = { \
+		{ .duration = 0 } , \
+		.pulse = 0, \
+		.reset = 0, \
+		.timeout = 0, \
+		.carrier_report = 0 }
+
+static inline void init_ir_raw_event(struct ir_raw_event *ev)
+{
+	memset(ev, 0, sizeof(*ev));
+}
+
+#define IR_MAX_DURATION         0xFFFFFFFF      /* a bit more than 4 seconds */
+
+struct rc_dev *rc_allocate_device(void);
+void rc_free_device(struct rc_dev *dev);
+int rc_register_device(struct rc_dev *dev);
+void rc_unregister_device(struct rc_dev *dev);
+
+void ir_raw_event_handle(struct rc_dev *dev);
+int ir_raw_event_store(struct rc_dev *dev, struct ir_raw_event *ev);
+int ir_raw_event_store_edge(struct rc_dev *dev, enum raw_event_type type);
+int ir_raw_event_store_with_filter(struct rc_dev *dev,
+				struct ir_raw_event *ev);
+void ir_raw_event_set_idle(struct rc_dev *dev, bool idle);
+
+static inline void ir_raw_event_reset(struct rc_dev *dev)
+{
+	DEFINE_IR_RAW_EVENT(ev);
+	ev.reset = true;
+
+	ir_raw_event_store(dev, &ev);
+	ir_raw_event_handle(dev);
+}
+
+
+/* extract mask bits out of data and pack them into the result */
+static inline u32 ir_extract_bits(u32 data, u32 mask)
+{
+	u32 vbit = 1, value = 0;
+
+	do {
+	    if (mask & 1) {
+		if (data & 1)
+			value |= vbit;
+		vbit <<= 1;
+	    }
+	    data >>= 1;
+	} while (mask >>= 1);
+
+	return value;
+}
+
+
+#endif /* _IR_CORE */
