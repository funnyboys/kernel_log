commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index c8ddbfe8b74c..fa0895430720 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Media device
  *
@@ -5,15 +6,6 @@
  *
  * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *	     Sakari Ailus <sakari.ailus@iki.fi>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #ifndef _MEDIA_DEVICE_H

commit 10905d70d78841a6fa191be5ec193e3c0d63555f
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Mon May 21 04:54:27 2018 -0400

    media: media-request: implement media requests
    
    Add initial media request support:
    
    1) Add MEDIA_IOC_REQUEST_ALLOC ioctl support to media-device.c
    2) Add struct media_request to store request objects.
    3) Add struct media_request_object to represent a request object.
    4) Add MEDIA_REQUEST_IOC_QUEUE/REINIT ioctl support.
    
    Basic lifecycle: the application allocates a request, adds
    objects to it, queues the request, polls until it is completed
    and can then read the final values of the objects at the time
    of completion. When it closes the file descriptor the request
    memory will be freed (actually, when the last user of that request
    releases the request).
    
    Drivers will bind an object to a request (the 'adds objects to it'
    phase), when MEDIA_REQUEST_IOC_QUEUE is called the request is
    validated (req_validate op), then queued (the req_queue op).
    
    When done with an object it can either be unbound from the request
    (e.g. when the driver has finished with a vb2 buffer) or marked as
    completed (e.g. for controls associated with a buffer). When all
    objects in the request are completed (or unbound), then the request
    fd will signal an exception (poll).
    
    Co-developed-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Co-developed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Co-developed-by: Alexandre Courbot <acourbot@chromium.org>
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index bcc6ec434f1f..c8ddbfe8b74c 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -27,6 +27,7 @@
 
 struct ida;
 struct device;
+struct media_device;
 
 /**
  * struct media_entity_notify - Media Entity Notify
@@ -50,10 +51,32 @@ struct media_entity_notify {
  * struct media_device_ops - Media device operations
  * @link_notify: Link state change notification callback. This callback is
  *		 called with the graph_mutex held.
+ * @req_alloc: Allocate a request. Set this if you need to allocate a struct
+ *	       larger then struct media_request. @req_alloc and @req_free must
+ *	       either both be set or both be NULL.
+ * @req_free: Free a request. Set this if @req_alloc was set as well, leave
+ *	      to NULL otherwise.
+ * @req_validate: Validate a request, but do not queue yet. The req_queue_mutex
+ *	          lock is held when this op is called.
+ * @req_queue: Queue a validated request, cannot fail. If something goes
+ *	       wrong when queueing this request then it should be marked
+ *	       as such internally in the driver and any related buffers
+ *	       must eventually return to vb2 with state VB2_BUF_STATE_ERROR.
+ *	       The req_queue_mutex lock is held when this op is called.
+ *	       It is important that vb2 buffer objects are queued last after
+ *	       all other object types are queued: queueing a buffer kickstarts
+ *	       the request processing, so all other objects related to the
+ *	       request (and thus the buffer) must be available to the driver.
+ *	       And once a buffer is queued, then the driver can complete
+ *	       or delete objects from the request before req_queue exits.
  */
 struct media_device_ops {
 	int (*link_notify)(struct media_link *link, u32 flags,
 			   unsigned int notification);
+	struct media_request *(*req_alloc)(struct media_device *mdev);
+	void (*req_free)(struct media_request *req);
+	int (*req_validate)(struct media_request *req);
+	void (*req_queue)(struct media_request *req);
 };
 
 /**
@@ -88,6 +111,9 @@ struct media_device_ops {
  * @disable_source: Disable Source Handler function pointer
  *
  * @ops:	Operation handler callbacks
+ * @req_queue_mutex: Serialise the MEDIA_REQUEST_IOC_QUEUE ioctl w.r.t.
+ *		     other operations that stop or start streaming.
+ * @request_id: Used to generate unique request IDs
  *
  * This structure represents an abstract high-level media device. It allows easy
  * access to entities and provides basic media device-level support. The
@@ -158,6 +184,9 @@ struct media_device {
 	void (*disable_source)(struct media_entity *entity);
 
 	const struct media_device_ops *ops;
+
+	struct mutex req_queue_mutex;
+	atomic_t request_id;
 };
 
 /* We don't need to include pci.h or usb.h here */

commit 2bd8682375f3a79e463d8840794d2872b02d755b
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Jul 21 04:49:44 2017 -0400

    media: media-device: remove driver_version
    
    Since the driver_version field in struct media_device is no longer
    used, just remove it.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 7ae200d89a9f..bcc6ec434f1f 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -68,7 +68,6 @@ struct media_device_ops {
  * @serial:	Device serial number (optional)
  * @bus_info:	Unique and stable device location identifier
  * @hw_revision: Hardware device revision
- * @driver_version: Device driver version
  * @topology_version: Monotonic counter for storing the version of the graph
  *		topology. Should be incremented each time the topology changes.
  * @id:		Unique ID used on the last registered graph object
@@ -134,7 +133,6 @@ struct media_device {
 	char serial[40];
 	char bus_info[32];
 	u32 hw_revision;
-	u32 driver_version;
 
 	u64 topology_version;
 

commit 4c7089ee66026f38275d43e26d9da6e2945af6f9
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Fri Jul 21 06:48:33 2017 -0400

    media: media-device: set driver_version directly
    
    Don't use driver_version from struct media_device, just return
    LINUX_VERSION_CODE as the other media subsystems do.
    
    The driver_version field in struct media_device will be removed
    in the following patches.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 6896266031b9..7ae200d89a9f 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -249,11 +249,6 @@ void media_device_cleanup(struct media_device *mdev);
  *    driver-specific format. When possible the revision should be formatted
  *    with the KERNEL_VERSION() macro.
  *
- *  - &media_entity.driver_version is formatted with the KERNEL_VERSION()
- *    macro. The version minor must be incremented when new features are added
- *    to the userspace API without breaking binary compatibility. The version
- *    major must be incremented when binary compatibility is broken.
- *
  * .. note::
  *
  *    #) Upon successful registration a character device named media[0-9]+ is created. The device major and minor numbers are dynamic. The model name is exported as a sysfs attribute.

commit 90cd366bc61cd539c797b7ad957a9d749d97200f
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Tue Nov 29 21:59:54 2016 -0200

    [media] media: Protect enable_source and disable_source handler code paths
    
    Drivers might try to access and run enable_source and disable_source
    handlers when the driver that implements these handlers is clearing
    the handlers during its unregister.
    
    Fix the following race condition:
    
    process 1                               process 2
    
    request video streaming                 unbind au0828
    v4l2 checks if tuner is free
    ...                                     ...
    
                                            au0828_unregister_media_device()
    ...                                     ...
                                            (doesn't hold graph_mutex)
                                            mdev->enable_source = NULL;
    if (mdev && mdev->enable_source)        mdev->disable_source = NULL;
            mdev->enable_source()
    (enable_source holds graph_mutex)
    
    As shown above enable_source check is done without holding the graph_mutex.
    If unbind happens to be in progress, au0828 could clear enable_source and
    disable_source handlers leading to null pointer de-reference.
    
    Fix it by protecting enable_source and disable_source set and clear and
    protecting enable_source and disable_source handler access and the call
    itself.
    
    process 1                               process 2
    
    request video streaming                 unbind au0828
    v4l2 checks if tuner is free
    ...                                     ...
    
                                            au0828_unregister_media_device()
    ...                                     ...
                                            (hold graph_mutex while clearing)
                                            mdev->enable_source = NULL;
    if (mdev)                               mdev->disable_source = NULL;
    (hold graph_mutex to check and
     call enable_source)
        if (mdev->enable_source)
            mdev->enable_source()
    
    If graph_mutex is held to just heck for handler being null and needs to be
    released before calling the handler, there will be another window for the
    handlers to be cleared. Hence, enable_source and disable_source handlers
    no longer hold the graph_mutex and expect callers to hold it to avoid
    forcing them release the graph_mutex before calling the handlers.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index ae4eef416d70..6896266031b9 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -121,6 +121,8 @@ struct media_device_ops {
  *    bridge driver finds the media_device during probe.
  *    Bridge driver sets source_priv with information
  *    necessary to run @enable_source and @disable_source handlers.
+ *    Callers should hold graph_mutex to access and call @enable_source
+ *    and @disable_source handlers.
  */
 struct media_device {
 	/* dev->driver_data points to this struct. */

commit 20b852273642f41ce5c97601acb89185cbcee772
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Mon Nov 21 14:48:30 2016 -0200

    [media] media: Rename graph and pipeline structs and functions
    
    The media_entity_pipeline_start() and media_entity_pipeline_stop()
    functions are renamed as media_pipeline_start() and media_pipeline_stop(),
    respectively. The reason is two-fold: the pipeline struct is, rightly,
    already called media_pipeline (rather than media_entity_pipeline) and what
    this really is about is a pipeline. A pipeline consists of entities ---
    and, well, other objects embedded in these entities.
    
    As the pipeline object will be in the future moved from entities to pads
    in order to support multiple pipelines through a single entity, do the
    renaming now.
    
    Similarly, functions operating on struct media_entity_graph as well as the
    struct itself are renamed by dropping the "entity_" part from the prefix
    of the function family and the data structure. The graph traversal which
    is what the functions are about is not specifically about entities only
    and will operate on pads for the same reason as the media pipeline.
    
    The patch has been generated using the following command:
    
    git grep -l media_entity |xargs perl -i -pe '
            s/media_entity_pipeline/media_pipeline/g;
            s/media_entity_graph/media_graph/g'
    
    And a few manual edits related to line start alignment and line wrapping.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index e9f1224ca45b..ae4eef416d70 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -150,7 +150,7 @@ struct media_device {
 
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;
-	struct media_entity_graph pm_count_walk;
+	struct media_graph pm_count_walk;
 
 	void *source_priv;
 	int (*enable_source)(struct media_entity *entity,

commit bcb63314e2c23f1ed622418b65f9409512659c73
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Oct 28 09:31:20 2016 -0200

    [media] media: Drop FSF's postal address from the source code files
    
    Drop the FSF's postal address from the source code files that typically
    contain mostly the license text. Of the 628 removed instances, 578 are
    outdated.
    
    The patch has been created with the following command without manual edits:
    
    git grep -l "675 Mass Ave\|59 Temple Place\|51 Franklin St" -- \
            drivers/media/ include/media|while read i; do i=$i perl -e '
    open(F,"< $ENV{i}");
    $a=join("", <F>);
    $a =~ s/[ \t]*\*\n.*You should.*\n.*along with.*\n.*(\n.*USA.*$)?\n//m
            && $a =~ s/(^.*)Or, (point your browser to) /$1To obtain the license, $2\n$1/m;
    close(F);
    open(F, "> $ENV{i}");
    print F $a;
    close(F);'; done
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index c21b4c5f5871..e9f1224ca45b 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -14,10 +14,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #ifndef _MEDIA_DEVICE_H

commit 8c2ebcf103b106bd8b9c5517bf72885d126d3d27
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Wed Nov 16 18:49:50 2016 -0200

    [media] media: remove obsolete Media Device Managed resource interfaces
    
    Remove obsolete media_device_get_devres(), media_device_find_devres(),
    and media_device_release_devres() interfaces. These interfaces are now
    obsolete.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index a267f9ceee8f..c21b4c5f5871 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -375,30 +375,6 @@ int __must_check media_device_register_entity_notify(struct media_device *mdev,
 void media_device_unregister_entity_notify(struct media_device *mdev,
 					struct media_entity_notify *nptr);
 
-/**
- * media_device_get_devres() -	get media device as device resource
- *				creates if one doesn't exist
- *
- * @dev: pointer to struct &device.
- *
- * Sometimes, the media controller &media_device needs to be shared by more
- * than one driver. This function adds support for that, by dynamically
- * allocating the &media_device and allowing it to be obtained from the
- * struct &device associated with the common device where all sub-device
- * components belong. So, for example, on an USB device with multiple
- * interfaces, each interface may be handled by a separate per-interface
- * drivers. While each interface have its own &device, they all share a
- * common &device associated with the hole USB device.
- */
-struct media_device *media_device_get_devres(struct device *dev);
-
-/**
- * media_device_find_devres() - find media device as device resource
- *
- * @dev: pointer to struct &device.
- */
-struct media_device *media_device_find_devres(struct device *dev);
-
 /* Iterate over all entities. */
 #define media_device_for_each_entity(entity, mdev)			\
 	list_for_each_entry(entity, &(mdev)->entities, graph_obj.list)
@@ -476,14 +452,6 @@ static inline void media_device_unregister_entity_notify(
 					struct media_entity_notify *nptr)
 {
 }
-static inline struct media_device *media_device_get_devres(struct device *dev)
-{
-	return NULL;
-}
-static inline struct media_device *media_device_find_devres(struct device *dev)
-{
-	return NULL;
-}
 
 static inline void media_device_pci_init(struct media_device *mdev,
 					 struct pci_dev *pci_dev,

commit fc641261e1227ed7d083d55c8b47f3e9cd173681
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Mon Mar 14 19:24:25 2016 -0300

    [media] media: Update documentation for media_entity_notify
    
    Update documentation for media_entity_notify to clearly state the usage
    restrictions. This handler is intended for creating links between exiting
    entities and should not used to create and register entities.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index ef93e21335df..a267f9ceee8f 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -39,8 +39,10 @@ struct device;
  * @notify_data: Input data to invoke the callback
  * @notify: Callback function pointer
  *
- * Drivers may register a callback to take action when
- * new entities get registered with the media device.
+ * Drivers may register a callback to take action when new entities get
+ * registered with the media device. This handler is intended for creating
+ * links between existing entities and should not create entities and register
+ * them.
  */
 struct media_entity_notify {
 	struct list_head list;

commit 68429f50ab60074e58b98010103fcc5bac4afd54
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue Nov 3 00:27:51 2015 -0200

    [media] media: Move media_device link_notify operation to an ops structure
    
    This will allow adding new operations without increasing the
    media_device structure size for drivers that don't implement any media
    device operation.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 481dd6c672cb..ef93e21335df 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -48,6 +48,16 @@ struct media_entity_notify {
 	void (*notify)(struct media_entity *entity, void *notify_data);
 };
 
+/**
+ * struct media_device_ops - Media device operations
+ * @link_notify: Link state change notification callback. This callback is
+ *		 called with the graph_mutex held.
+ */
+struct media_device_ops {
+	int (*link_notify)(struct media_link *link, u32 flags,
+			   unsigned int notification);
+};
+
 /**
  * struct media_device - Media device
  * @dev:	Parent device
@@ -80,8 +90,7 @@ struct media_entity_notify {
  * @enable_source: Enable Source Handler function pointer
  * @disable_source: Disable Source Handler function pointer
  *
- * @link_notify: Link state change notification callback. This callback is
- *		 called with the graph_mutex held.
+ * @ops:	Operation handler callbacks
  *
  * This structure represents an abstract high-level media device. It allows easy
  * access to entities and provides basic media device-level support. The
@@ -150,8 +159,7 @@ struct media_device {
 			     struct media_pipeline *pipe);
 	void (*disable_source)(struct media_entity *entity);
 
-	int (*link_notify)(struct media_link *link, u32 flags,
-			   unsigned int notification);
+	const struct media_device_ops *ops;
 };
 
 /* We don't need to include pci.h or usb.h here */

commit 48a7c4bac94dfb367d1d64123b5182536912c03e
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Mon Aug 29 16:09:11 2016 -0300

    [media] docs-rst: improve the kAPI documentation for the mediactl
    
    There are several issues on the documentation:
      - the media.h header were not properly referenced;
      - verbatim expressions were not properly marked as such;
      - struct member references were wrong;
      - some notes were not using the right markup;
      - a comment that were moved to the kernel-doc markup were
        duplicated as a comment inside the struct media_entity;
      - some args were not pointing to the struct they're using;
      - macros weren't documented.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 28195242386c..481dd6c672cb 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -53,7 +53,7 @@ struct media_entity_notify {
  * @dev:	Parent device
  * @devnode:	Media device node
  * @driver_name: Optional device driver name. If not set, calls to
- *		%MEDIA_IOC_DEVICE_INFO will return dev->driver->name.
+ *		%MEDIA_IOC_DEVICE_INFO will return ``dev->driver->name``.
  *		This is needed for USB drivers for example, as otherwise
  *		they'll all appear as if the driver name was "usb".
  * @model:	Device model name
@@ -102,16 +102,18 @@ struct media_entity_notify {
  * sink entity  and deactivate the link between them. Drivers
  * should call this handler to release the source.
  *
- * Note: Bridge driver is expected to implement and set the
- * handler when media_device is registered or when
- * bridge driver finds the media_device during probe.
- * Bridge driver sets source_priv with information
- * necessary to run enable/disable source handlers.
- *
  * Use-case: find tuner entity connected to the decoder
  * entity and check if it is available, and activate the
- * the link between them from enable_source and deactivate
- * from disable_source.
+ * the link between them from @enable_source and deactivate
+ * from @disable_source.
+ *
+ * .. note::
+ *
+ *    Bridge driver is expected to implement and set the
+ *    handler when &media_device is registered or when
+ *    bridge driver finds the media_device during probe.
+ *    Bridge driver sets source_priv with information
+ *    necessary to run @enable_source and @disable_source handlers.
  */
 struct media_device {
 	/* dev->driver_data points to this struct. */
@@ -168,7 +170,7 @@ struct usb_device;
  * @ent_enum: Entity enumeration to be initialised
  * @mdev: The related media device
  *
- * Returns zero on success or a negative error code.
+ * Return: zero on success or a negative error code.
  */
 static inline __must_check int media_entity_enum_init(
 	struct media_entity_enum *ent_enum, struct media_device *mdev)
@@ -211,36 +213,38 @@ void media_device_cleanup(struct media_device *mdev);
  *
  * Users, should, instead, call the media_device_register() macro.
  *
- * The caller is responsible for initializing the media_device structure before
- * registration. The following fields must be set:
+ * The caller is responsible for initializing the &media_device structure
+ * before registration. The following fields of &media_device must be set:
  *
- *  - dev must point to the parent device (usually a &pci_dev, &usb_interface or
- *    &platform_device instance).
+ *  - &media_entity.dev must point to the parent device (usually a &pci_dev,
+ *    &usb_interface or &platform_device instance).
  *
- *  - model must be filled with the device model name as a NUL-terminated UTF-8
- *    string. The device/model revision must not be stored in this field.
+ *  - &media_entity.model must be filled with the device model name as a
+ *    NUL-terminated UTF-8 string. The device/model revision must not be
+ *    stored in this field.
  *
  * The following fields are optional:
  *
- *  - serial is a unique serial number stored as a NUL-terminated ASCII string.
- *    The field is big enough to store a GUID in text form. If the hardware
- *    doesn't provide a unique serial number this field must be left empty.
+ *  - &media_entity.serial is a unique serial number stored as a
+ *    NUL-terminated ASCII string. The field is big enough to store a GUID
+ *    in text form. If the hardware doesn't provide a unique serial number
+ *    this field must be left empty.
  *
- *  - bus_info represents the location of the device in the system as a
- *    NUL-terminated ASCII string. For PCI/PCIe devices bus_info must be set to
- *    "PCI:" (or "PCIe:") followed by the value of pci_name(). For USB devices,
- *    the usb_make_path() function must be used. This field is used by
- *    applications to distinguish between otherwise identical devices that don't
- *    provide a serial number.
+ *  - &media_entity.bus_info represents the location of the device in the
+ *    system as a NUL-terminated ASCII string. For PCI/PCIe devices
+ *    &media_entity.bus_info must be set to "PCI:" (or "PCIe:") followed by
+ *    the value of pci_name(). For USB devices,the usb_make_path() function
+ *    must be used. This field is used by applications to distinguish between
+ *    otherwise identical devices that don't provide a serial number.
  *
- *  - hw_revision is the hardware device revision in a driver-specific format.
- *    When possible the revision should be formatted with the KERNEL_VERSION
- *    macro.
+ *  - &media_entity.hw_revision is the hardware device revision in a
+ *    driver-specific format. When possible the revision should be formatted
+ *    with the KERNEL_VERSION() macro.
  *
- *  - driver_version is formatted with the KERNEL_VERSION macro. The version
- *    minor must be incremented when new features are added to the userspace API
- *    without breaking binary compatibility. The version major must be
- *    incremented when binary compatibility is broken.
+ *  - &media_entity.driver_version is formatted with the KERNEL_VERSION()
+ *    macro. The version minor must be incremented when new features are added
+ *    to the userspace API without breaking binary compatibility. The version
+ *    major must be incremented when binary compatibility is broken.
  *
  * .. note::
  *
@@ -252,6 +256,16 @@ void media_device_cleanup(struct media_device *mdev);
  */
 int __must_check __media_device_register(struct media_device *mdev,
 					 struct module *owner);
+
+
+/**
+ * media_device_register() - Registers a media device element
+ *
+ * @mdev:	pointer to struct &media_device
+ *
+ * This macro calls __media_device_register() passing %THIS_MODULE as
+ * the __media_device_register() second argument (**owner**).
+ */
 #define media_device_register(mdev) __media_device_register(mdev, THIS_MODULE)
 
 /**
@@ -259,7 +273,6 @@ int __must_check __media_device_register(struct media_device *mdev,
  *
  * @mdev:	pointer to struct &media_device
  *
- *
  * It is safe to call this function on an unregistered (but initialised)
  * media device.
  */
@@ -285,14 +298,15 @@ void media_device_unregister(struct media_device *mdev);
  * framework.
  *
  * If the device has pads, media_entity_pads_init() should be called before
- * this function. Otherwise, the &media_entity.@pad and &media_entity.@num_pads
+ * this function. Otherwise, the &media_entity.pad and &media_entity.num_pads
  * should be zeroed before calling this function.
  *
  * Entities have flags that describe the entity capabilities and state:
  *
- * %MEDIA_ENT_FL_DEFAULT indicates the default entity for a given type.
- *	This can be used to report the default audio and video devices or the
- *	default camera sensor.
+ * %MEDIA_ENT_FL_DEFAULT
+ *    indicates the default entity for a given type.
+ *    This can be used to report the default audio and video devices or the
+ *    default camera sensor.
  *
  * .. note::
  *
@@ -331,8 +345,10 @@ void media_device_unregister_entity(struct media_entity *entity);
  * @mdev:      The media device
  * @nptr:      The media_entity_notify
  *
- * Note: When a new entity is registered, all the registered
- * media_entity_notify callbacks are invoked.
+ * .. note::
+ *
+ *    When a new entity is registered, all the registered
+ *    media_entity_notify callbacks are invoked.
  */
 
 int __must_check media_device_register_entity_notify(struct media_device *mdev,
@@ -410,11 +426,13 @@ void media_device_pci_init(struct media_device *mdev,
  * @board_name:	media device name. If %NULL, the routine will use the usb
  *		product name, if available.
  * @driver_name: name of the driver. if %NULL, the routine will use the name
- *		given by udev->dev->driver->name, with is usually the wrong
+ *		given by ``udev->dev->driver->name``, with is usually the wrong
  *		thing to do.
  *
- * NOTE: It is better to call media_device_usb_init() instead, as
- * such macro fills driver_name with %KBUILD_MODNAME.
+ * .. note::
+ *
+ *    It is better to call media_device_usb_init() instead, as
+ *    such macro fills driver_name with %KBUILD_MODNAME.
  */
 void __media_device_usb_init(struct media_device *mdev,
 			     struct usb_device *udev,
@@ -472,6 +490,19 @@ static inline void __media_device_usb_init(struct media_device *mdev,
 
 #endif /* CONFIG_MEDIA_CONTROLLER */
 
+/**
+ * media_device_usb_init() - create and initialize a
+ *	struct &media_device from a PCI device.
+ *
+ * @mdev:	pointer to struct &media_device
+ * @udev:	pointer to struct usb_device
+ * @name:	media device name. If %NULL, the routine will use the usb
+ *		product name, if available.
+ *
+ * This macro calls media_device_usb_init() passing the
+ * media_device_usb_init() **driver_name** parameter filled with
+ * %KBUILD_MODNAME.
+ */
 #define media_device_usb_init(mdev, udev, name) \
 	__media_device_usb_init(mdev, udev, name, KBUILD_MODNAME)
 

commit 74604b7390af3afb1bcb055b87787b5cfabd03a0
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun Jul 17 09:18:03 2016 -0300

    [media] doc-rst: Fix conversion for MC core functions
    
    There were lots of issues at the media controller side,
    after the conversion:
    
    - Some documentation at the header files weren't using the
      kernel-doc start block;
    
    - Now, the C files with the exported symbols also need to be
      added. So, all headers need to be included twice: one to
      get the structs/enums/.. and another one for the functions;
    
    - Notes should use the ReST tag, as kernel-doc doesn't
      recognizes it anymore;
    
    - Identation needs to be fixed, as ReST uses it to identify
      when a format "tag" ends.
    
    - Fix the cross-references at the media controller description.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 4605fee0c228..28195242386c 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -242,13 +242,11 @@ void media_device_cleanup(struct media_device *mdev);
  *    without breaking binary compatibility. The version major must be
  *    incremented when binary compatibility is broken.
  *
- * Notes:
+ * .. note::
  *
- * Upon successful registration a character device named media[0-9]+ is created.
- * The device major and minor numbers are dynamic. The model name is exported as
- * a sysfs attribute.
+ *    #) Upon successful registration a character device named media[0-9]+ is created. The device major and minor numbers are dynamic. The model name is exported as a sysfs attribute.
  *
- * Unregistering a media device that hasn't been registered is *NOT* safe.
+ *    #) Unregistering a media device that hasn't been registered is **NOT** safe.
  *
  * Return: returns zero on success or a negative error code.
  */
@@ -296,14 +294,16 @@ void media_device_unregister(struct media_device *mdev);
  *	This can be used to report the default audio and video devices or the
  *	default camera sensor.
  *
- * NOTE: Drivers should set the entity function before calling this function.
- * Please notice that the values %MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN and
- * %MEDIA_ENT_F_UNKNOWN should not be used by the drivers.
+ * .. note::
+ *
+ *    Drivers should set the entity function before calling this function.
+ *    Please notice that the values %MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN and
+ *    %MEDIA_ENT_F_UNKNOWN should not be used by the drivers.
  */
 int __must_check media_device_register_entity(struct media_device *mdev,
 					      struct media_entity *entity);
 
-/*
+/**
  * media_device_unregister_entity() - unregisters a media entity.
  *
  * @entity:	pointer to struct &media_entity to be unregistered
@@ -317,8 +317,10 @@ int __must_check media_device_register_entity(struct media_device *mdev,
  * When a media device is unregistered, all its entities are unregistered
  * automatically. No manual entities unregistration is then required.
  *
- * Note: the media_entity instance itself must be freed explicitly by
- * the driver if required.
+ * .. note::
+ *
+ *    The media_entity instance itself must be freed explicitly by
+ *    the driver if required.
  */
 void media_device_unregister_entity(struct media_entity *entity);
 

commit d26a5d4350fd234c1f35d8b262527c8cb97c630d
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun Jul 17 07:20:06 2016 -0300

    [media] doc-rst: Convert media API to rst
    
    Move the contents of the media section at
    DocBooks/DocBook/device-drivers.tmpl to a new ReST book.
    
    For now, the contents is kept as-is. Next patches will fix
    the warnings and add cross-references that were removed due to
    the conversion.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index f743ae2210ee..4605fee0c228 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -29,237 +29,6 @@
 #include <media/media-devnode.h>
 #include <media/media-entity.h>
 
-/**
- * DOC: Media Controller
- *
- * The media controller userspace API is documented in DocBook format in
- * Documentation/DocBook/media/v4l/media-controller.xml. This document focus
- * on the kernel-side implementation of the media framework.
- *
- * * Abstract media device model:
- *
- * Discovering a device internal topology, and configuring it at runtime, is one
- * of the goals of the media framework. To achieve this, hardware devices are
- * modelled as an oriented graph of building blocks called entities connected
- * through pads.
- *
- * An entity is a basic media hardware building block. It can correspond to
- * a large variety of logical blocks such as physical hardware devices
- * (CMOS sensor for instance), logical hardware devices (a building block
- * in a System-on-Chip image processing pipeline), DMA channels or physical
- * connectors.
- *
- * A pad is a connection endpoint through which an entity can interact with
- * other entities. Data (not restricted to video) produced by an entity
- * flows from the entity's output to one or more entity inputs. Pads should
- * not be confused with physical pins at chip boundaries.
- *
- * A link is a point-to-point oriented connection between two pads, either
- * on the same entity or on different entities. Data flows from a source
- * pad to a sink pad.
- *
- *
- * * Media device:
- *
- * A media device is represented by a struct &media_device instance, defined in
- * include/media/media-device.h. Allocation of the structure is handled by the
- * media device driver, usually by embedding the &media_device instance in a
- * larger driver-specific structure.
- *
- * Drivers register media device instances by calling
- *	__media_device_register() via the macro media_device_register()
- * and unregistered by calling
- *	media_device_unregister().
- *
- * * Entities, pads and links:
- *
- * - Entities
- *
- * Entities are represented by a struct &media_entity instance, defined in
- * include/media/media-entity.h. The structure is usually embedded into a
- * higher-level structure, such as a v4l2_subdev or video_device instance,
- * although drivers can allocate entities directly.
- *
- * Drivers initialize entity pads by calling
- *	media_entity_pads_init().
- *
- * Drivers register entities with a media device by calling
- *	media_device_register_entity()
- * and unregistred by calling
- *	media_device_unregister_entity().
- *
- * - Interfaces
- *
- * Interfaces are represented by a struct &media_interface instance, defined in
- * include/media/media-entity.h. Currently, only one type of interface is
- * defined: a device node. Such interfaces are represented by a struct
- * &media_intf_devnode.
- *
- * Drivers initialize and create device node interfaces by calling
- *	media_devnode_create()
- * and remove them by calling:
- *	media_devnode_remove().
- *
- * - Pads
- *
- * Pads are represented by a struct &media_pad instance, defined in
- * include/media/media-entity.h. Each entity stores its pads in a pads array
- * managed by the entity driver. Drivers usually embed the array in a
- * driver-specific structure.
- *
- * Pads are identified by their entity and their 0-based index in the pads
- * array.
- * Both information are stored in the &media_pad structure, making the
- * &media_pad pointer the canonical way to store and pass link references.
- *
- * Pads have flags that describe the pad capabilities and state.
- *
- *	%MEDIA_PAD_FL_SINK indicates that the pad supports sinking data.
- *	%MEDIA_PAD_FL_SOURCE indicates that the pad supports sourcing data.
- *
- * NOTE: One and only one of %MEDIA_PAD_FL_SINK and %MEDIA_PAD_FL_SOURCE must
- * be set for each pad.
- *
- * - Links
- *
- * Links are represented by a struct &media_link instance, defined in
- * include/media/media-entity.h. There are two types of links:
- *
- * 1. pad to pad links:
- *
- * Associate two entities via their PADs. Each entity has a list that points
- * to all links originating at or targeting any of its pads.
- * A given link is thus stored twice, once in the source entity and once in
- * the target entity.
- *
- * Drivers create pad to pad links by calling:
- *	media_create_pad_link() and remove with media_entity_remove_links().
- *
- * 2. interface to entity links:
- *
- * Associate one interface to a Link.
- *
- * Drivers create interface to entity links by calling:
- *	media_create_intf_link() and remove with media_remove_intf_links().
- *
- * NOTE:
- *
- * Links can only be created after having both ends already created.
- *
- * Links have flags that describe the link capabilities and state. The
- * valid values are described at media_create_pad_link() and
- * media_create_intf_link().
- *
- * Graph traversal:
- *
- * The media framework provides APIs to iterate over entities in a graph.
- *
- * To iterate over all entities belonging to a media device, drivers can use
- * the media_device_for_each_entity macro, defined in
- * include/media/media-device.h.
- *
- * 	struct media_entity *entity;
- *
- * 	media_device_for_each_entity(entity, mdev) {
- * 		// entity will point to each entity in turn
- * 		...
- * 	}
- *
- * Drivers might also need to iterate over all entities in a graph that can be
- * reached only through enabled links starting at a given entity. The media
- * framework provides a depth-first graph traversal API for that purpose.
- *
- * Note that graphs with cycles (whether directed or undirected) are *NOT*
- * supported by the graph traversal API. To prevent infinite loops, the graph
- * traversal code limits the maximum depth to MEDIA_ENTITY_ENUM_MAX_DEPTH,
- * currently defined as 16.
- *
- * Drivers initiate a graph traversal by calling
- *	media_entity_graph_walk_start()
- *
- * The graph structure, provided by the caller, is initialized to start graph
- * traversal at the given entity.
- *
- * Drivers can then retrieve the next entity by calling
- *	media_entity_graph_walk_next()
- *
- * When the graph traversal is complete the function will return NULL.
- *
- * Graph traversal can be interrupted at any moment. No cleanup function call
- * is required and the graph structure can be freed normally.
- *
- * Helper functions can be used to find a link between two given pads, or a pad
- * connected to another pad through an enabled link
- *	media_entity_find_link() and media_entity_remote_pad()
- *
- * Use count and power handling:
- *
- * Due to the wide differences between drivers regarding power management
- * needs, the media controller does not implement power management. However,
- * the &media_entity structure includes a use_count field that media drivers
- * can use to track the number of users of every entity for power management
- * needs.
- *
- * The &media_entity.@use_count field is owned by media drivers and must not be
- * touched by entity drivers. Access to the field must be protected by the
- * &media_device.@graph_mutex lock.
- *
- * Links setup:
- *
- * Link properties can be modified at runtime by calling
- *	media_entity_setup_link()
- *
- * Pipelines and media streams:
- *
- * When starting streaming, drivers must notify all entities in the pipeline to
- * prevent link states from being modified during streaming by calling
- *	media_entity_pipeline_start().
- *
- * The function will mark all entities connected to the given entity through
- * enabled links, either directly or indirectly, as streaming.
- *
- * The &media_pipeline instance pointed to by the pipe argument will be stored
- * in every entity in the pipeline. Drivers should embed the &media_pipeline
- * structure in higher-level pipeline structures and can then access the
- * pipeline through the &media_entity pipe field.
- *
- * Calls to media_entity_pipeline_start() can be nested. The pipeline pointer
- * must be identical for all nested calls to the function.
- *
- * media_entity_pipeline_start() may return an error. In that case, it will
- * clean up any of the changes it did by itself.
- *
- * When stopping the stream, drivers must notify the entities with
- *	media_entity_pipeline_stop().
- *
- * If multiple calls to media_entity_pipeline_start() have been made the same
- * number of media_entity_pipeline_stop() calls are required to stop streaming.
- * The &media_entity pipe field is reset to NULL on the last nested stop call.
- *
- * Link configuration will fail with -%EBUSY by default if either end of the
- * link is a streaming entity. Links that can be modified while streaming must
- * be marked with the %MEDIA_LNK_FL_DYNAMIC flag.
- *
- * If other operations need to be disallowed on streaming entities (such as
- * changing entities configuration parameters) drivers can explicitly check the
- * media_entity stream_count field to find out if an entity is streaming. This
- * operation must be done with the media_device graph_mutex held.
- *
- * Link validation:
- *
- * Link validation is performed by media_entity_pipeline_start() for any
- * entity which has sink pads in the pipeline. The
- * &media_entity.@link_validate() callback is used for that purpose. In
- * @link_validate() callback, entity driver should check that the properties of
- * the source pad of the connected entity and its own sink pad match. It is up
- * to the type of the entity (and in the end, the properties of the hardware)
- * what matching actually means.
- *
- * Subsystems should facilitate link validation by providing subsystem specific
- * helper functions to provide easy access for commonly needed information, and
- * in the end provide a way to use driver-specific callbacks.
- */
-
 struct ida;
 struct device;
 

commit a087ce704b802becbb4b0f2a20f2cb3f6911802e
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Apr 27 19:28:26 2016 -0300

    [media] media-device: dynamically allocate struct media_devnode
    
    struct media_devnode is currently embedded at struct media_device.
    
    While this works fine during normal usage, it leads to a race
    condition during devnode unregister. the problem is that drivers
    assume that, after calling media_device_unregister(), the struct
    that contains media_device can be freed. This is not true, as it
    can't be freed until userspace closes all opened /dev/media devnodes.
    
    In other words, if the media devnode is still open, and media_device
    gets freed, any call to an ioctl will make the core to try to access
    struct media_device, with will cause an use-after-free and even GPF.
    
    Fix this by dynamically allocating the struct media_devnode and only
    freeing it when it is safe.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index a9b33c47310d..f743ae2210ee 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -347,7 +347,7 @@ struct media_entity_notify {
 struct media_device {
 	/* dev->driver_data points to this struct. */
 	struct device *dev;
-	struct media_devnode devnode;
+	struct media_devnode *devnode;
 
 	char model[32];
 	char driver_name[32];
@@ -393,9 +393,6 @@ struct usb_device;
 #define MEDIA_DEV_NOTIFY_PRE_LINK_CH	0
 #define MEDIA_DEV_NOTIFY_POST_LINK_CH	1
 
-/* media_devnode to media_device */
-#define to_media_device(node) container_of(node, struct media_device, devnode)
-
 /**
  * media_entity_enum_init - Initialise an entity enumeration
  *

commit 5ed470feb9a121582dbd455c72b133dc1a856a0a
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Apr 6 10:55:25 2016 -0300

    [media] media: Improve documentation for link_setup/link_modify
    
    Those callbacks are called with the media_device.graph_mutex held.
    
    Add a note about that, as the code called by those notifiers should
    not be touching in the mutex.
    
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index b21ef244ad3e..a9b33c47310d 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -311,7 +311,8 @@ struct media_entity_notify {
  * @enable_source: Enable Source Handler function pointer
  * @disable_source: Disable Source Handler function pointer
  *
- * @link_notify: Link state change notification callback
+ * @link_notify: Link state change notification callback. This callback is
+ *		 called with the graph_mutex held.
  *
  * This structure represents an abstract high-level media device. It allows easy
  * access to entities and provides basic media device-level support. The

commit e2c91d4d78ee3a69ad634bc7ef90688704baab9d
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Apr 6 10:55:24 2016 -0300

    [media] media-device: get rid of the spinlock
    
    Right now, the lock schema for media_device struct is messy,
    since sometimes, it is protected via a spin lock, while, for
    media graph traversal, it is protected by a mutex.
    
    Solve this conflict by always using a mutex.
    
    As a side effect, this prevents a bug when the media notifiers
    is called at atomic context, while running the notifier callback:
    
     BUG: sleeping function called from invalid context at mm/slub.c:1289
     in_atomic(): 1, irqs_disabled(): 0, pid: 3479, name: modprobe
     4 locks held by modprobe/3479:
     #0:  (&dev->mutex){......}, at: [<ffffffff81ce8933>] __driver_attach+0xa3/0x160
     #1:  (&dev->mutex){......}, at: [<ffffffff81ce8941>] __driver_attach+0xb1/0x160
     #2:  (register_mutex#5){+.+.+.}, at: [<ffffffffa10596c7>] usb_audio_probe+0x257/0x1c90 [snd_usb_audio]
     #3:  (&(&mdev->lock)->rlock){+.+.+.}, at: [<ffffffffa0e6051b>] media_device_register_entity+0x1cb/0x700 [media]
     CPU: 2 PID: 3479 Comm: modprobe Not tainted 4.5.0-rc3+ #49
     Hardware name:                  /NUC5i7RYB, BIOS RYBDWi35.86A.0350.2015.0812.1722 08/12/2015
     0000000000000000 ffff8803b3f6f288 ffffffff81933901 ffff8803c4bae000
     ffff8803c4bae5c8 ffff8803b3f6f2b0 ffffffff811c6af5 ffff8803c4bae000
     ffffffff8285d7f6 0000000000000509 ffff8803b3f6f2f0 ffffffff811c6ce5
     Call Trace:
     [<ffffffff81933901>] dump_stack+0x85/0xc4
     [<ffffffff811c6af5>] ___might_sleep+0x245/0x3a0
     [<ffffffff811c6ce5>] __might_sleep+0x95/0x1a0
     [<ffffffff8155aade>] kmem_cache_alloc_trace+0x20e/0x300
     [<ffffffffa0e66e3d>] ? media_add_link+0x4d/0x140 [media]
     [<ffffffffa0e66e3d>] media_add_link+0x4d/0x140 [media]
     [<ffffffffa0e69931>] media_create_pad_link+0xa1/0x600 [media]
     [<ffffffffa0fe11b3>] au0828_media_graph_notify+0x173/0x360 [au0828]
     [<ffffffffa0e68a6a>] ? media_gobj_create+0x1ba/0x480 [media]
     [<ffffffffa0e606fb>] media_device_register_entity+0x3ab/0x700 [media]
    
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 07809f698464..b21ef244ad3e 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -25,7 +25,6 @@
 
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/spinlock.h>
 
 #include <media/media-devnode.h>
 #include <media/media-entity.h>
@@ -304,8 +303,7 @@ struct media_entity_notify {
  * @pads:	List of registered pads
  * @links:	List of registered links
  * @entity_notify: List of registered entity_notify callbacks
- * @lock:	Entities list lock
- * @graph_mutex: Entities graph operation lock
+ * @graph_mutex: Protects access to struct media_device data
  * @pm_count_walk: Graph walk for power state walk. Access serialised using
  *		   graph_mutex.
  *
@@ -371,8 +369,6 @@ struct media_device {
 	/* notify callback list invoked when a new entity is registered */
 	struct list_head entity_notify;
 
-	/* Protects the graph objects creation/removal */
-	spinlock_t lock;
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;
 	struct media_entity_graph pm_count_walk;

commit 952f8eef901b170dbe6b48e80f098be5d835a82c
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Mar 16 05:34:39 2016 -0700

    [media] media-device: make topology_version u64
    
    The uAPI defines it with 64 bits. Let's change the Kernel
    implementation too.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 6d2860657021..07809f698464 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -357,7 +357,7 @@ struct media_device {
 	u32 hw_revision;
 	u32 driver_version;
 
-	u32 topology_version;
+	u64 topology_version;
 
 	u32 id;
 	struct ida entity_internal_idx;

commit 3047f3f98eabd655ca2db4e42219a2990052f73a
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Mar 16 05:04:03 2016 -0700

    [media] media-device: Fix a comment
    
    The comment is for the wrong function. Fix it.
    
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index df74cfa7da4a..6d2860657021 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -494,7 +494,7 @@ int __must_check __media_device_register(struct media_device *mdev,
 #define media_device_register(mdev) __media_device_register(mdev, THIS_MODULE)
 
 /**
- * __media_device_unregister() - Unegisters a media device element
+ * media_device_unregister() - Unregisters a media device element
  *
  * @mdev:	pointer to struct &media_device
  *

commit 0c426c472b5585ed6e59160359c979506d45ae49
Author: Sakari Ailus <sakari.ailus@iki.fi>
Date:   Sun Feb 21 13:25:08 2016 -0300

    [media] media: Always keep a graph walk large enough around
    
    Re-create the graph walk object as needed in order to have one large enough
    available for all entities in the graph.
    
    This enumeration is used for pipeline power management in the future.
    
    [mchehab@osg.samsung.com: fix documentation bug:
     " warning: bad line: graph_mutex"]
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 32bbba7d8115..df74cfa7da4a 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -306,6 +306,8 @@ struct media_entity_notify {
  * @entity_notify: List of registered entity_notify callbacks
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
+ * @pm_count_walk: Graph walk for power state walk. Access serialised using
+ *		   graph_mutex.
  *
  * @source_priv: Driver Private data for enable/disable source handlers
  * @enable_source: Enable Source Handler function pointer
@@ -373,6 +375,7 @@ struct media_device {
 	spinlock_t lock;
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;
+	struct media_entity_graph pm_count_walk;
 
 	void *source_priv;
 	int (*enable_source)(struct media_entity *entity,

commit 697fe725f37aaa5fb15f581bc6e5b588f5fc8f7b
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Fri Feb 26 04:44:35 2016 -0300

    [media] media-device.h: fix compiler warning
    
    Fix these compiler warnings:
    
    media-git/include/media/media-device.h: In function 'media_device_pci_init':
    media-git/include/media/media-device.h:610:9: warning: 'return' with a value, in function returning void
      return NULL;
             ^
    media-git/include/media/media-device.h: In function '__media_device_usb_init':
    media-git/include/media/media-device.h:618:9: warning: 'return' with a value, in function returning void
      return NULL;
             ^
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 0b946a895c3a..32bbba7d8115 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -693,7 +693,6 @@ static inline void media_device_pci_init(struct media_device *mdev,
 					 struct pci_dev *pci_dev,
 					 char *name)
 {
-	return NULL;
 }
 
 static inline void __media_device_usb_init(struct media_device *mdev,
@@ -701,7 +700,6 @@ static inline void __media_device_usb_init(struct media_device *mdev,
 					   char *board_name,
 					   char *driver_name)
 {
-	return NULL;
 }
 
 #endif /* CONFIG_MEDIA_CONTROLLER */

commit cd87ce873ffd7f9b593bcba40bc1a5b9e3053295
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Feb 11 21:41:22 2016 -0200

    [media] media: Media Controller enable/disable source handler API
    
    Add new fields to struct media_device to add enable_source, and
    disable_source handlers, and source_priv to stash driver private
    data that is used to run these handlers. The enable_source handler
    finds source entity for the passed in entity and checks if it is
    available. When link is found, it activates it. Disable source
    handler deactivates the link.
    
    Bridge driver is expected to implement and set these handlers.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 5436c954281b..0b946a895c3a 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -306,6 +306,11 @@ struct media_entity_notify {
  * @entity_notify: List of registered entity_notify callbacks
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
+ *
+ * @source_priv: Driver Private data for enable/disable source handlers
+ * @enable_source: Enable Source Handler function pointer
+ * @disable_source: Disable Source Handler function pointer
+ *
  * @link_notify: Link state change notification callback
  *
  * This structure represents an abstract high-level media device. It allows easy
@@ -317,6 +322,26 @@ struct media_entity_notify {
  *
  * @model is a descriptive model name exported through sysfs. It doesn't have to
  * be unique.
+ *
+ * @enable_source is a handler to find source entity for the
+ * sink entity  and activate the link between them if source
+ * entity is free. Drivers should call this handler before
+ * accessing the source.
+ *
+ * @disable_source is a handler to find source entity for the
+ * sink entity  and deactivate the link between them. Drivers
+ * should call this handler to release the source.
+ *
+ * Note: Bridge driver is expected to implement and set the
+ * handler when media_device is registered or when
+ * bridge driver finds the media_device during probe.
+ * Bridge driver sets source_priv with information
+ * necessary to run enable/disable source handlers.
+ *
+ * Use-case: find tuner entity connected to the decoder
+ * entity and check if it is available, and activate the
+ * the link between them from enable_source and deactivate
+ * from disable_source.
  */
 struct media_device {
 	/* dev->driver_data points to this struct. */
@@ -349,6 +374,11 @@ struct media_device {
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;
 
+	void *source_priv;
+	int (*enable_source)(struct media_entity *entity,
+			     struct media_pipeline *pipe);
+	void (*disable_source)(struct media_entity *entity);
+
 	int (*link_notify)(struct media_link *link, u32 flags,
 			   unsigned int notification);
 };

commit afcbdb55898b469606220fcb1868fc1bdd859675
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Feb 11 21:41:21 2016 -0200

    [media] media: Media Controller register/unregister entity_notify API
    
    Add new interfaces to register and unregister entity_notify
    hook to media device. These interfaces allow drivers to add
    hooks to take appropriate actions when new entities get added
    to a shared media device. For example, au0828 bridge driver
    registers an entity_notify hook to create links as needed
    between media graph nodes.
    
    [mchehab@osg.samsung.com: simple comments should be /* and not /**]
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 49dda6c7e664..5436c954281b 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -264,6 +264,22 @@
 struct ida;
 struct device;
 
+/**
+ * struct media_entity_notify - Media Entity Notify
+ *
+ * @list: List head
+ * @notify_data: Input data to invoke the callback
+ * @notify: Callback function pointer
+ *
+ * Drivers may register a callback to take action when
+ * new entities get registered with the media device.
+ */
+struct media_entity_notify {
+	struct list_head list;
+	void *notify_data;
+	void (*notify)(struct media_entity *entity, void *notify_data);
+};
+
 /**
  * struct media_device - Media device
  * @dev:	Parent device
@@ -287,6 +303,7 @@ struct device;
  * @interfaces:	List of registered interfaces
  * @pads:	List of registered pads
  * @links:	List of registered links
+ * @entity_notify: List of registered entity_notify callbacks
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
  * @link_notify: Link state change notification callback
@@ -324,6 +341,9 @@ struct media_device {
 	struct list_head pads;
 	struct list_head links;
 
+	/* notify callback list invoked when a new entity is registered */
+	struct list_head entity_notify;
+
 	/* Protects the graph objects creation/removal */
 	spinlock_t lock;
 	/* Serializes graph operations. */
@@ -506,6 +526,31 @@ int __must_check media_device_register_entity(struct media_device *mdev,
  */
 void media_device_unregister_entity(struct media_entity *entity);
 
+/**
+ * media_device_register_entity_notify() - Registers a media entity_notify
+ *					   callback
+ *
+ * @mdev:      The media device
+ * @nptr:      The media_entity_notify
+ *
+ * Note: When a new entity is registered, all the registered
+ * media_entity_notify callbacks are invoked.
+ */
+
+int __must_check media_device_register_entity_notify(struct media_device *mdev,
+					struct media_entity_notify *nptr);
+
+/**
+ * media_device_unregister_entity_notify() - Unregister a media entity notify
+ *					     callback
+ *
+ * @mdev:      The media device
+ * @nptr:      The media_entity_notify
+ *
+ */
+void media_device_unregister_entity_notify(struct media_device *mdev,
+					struct media_entity_notify *nptr);
+
 /**
  * media_device_get_devres() -	get media device as device resource
  *				creates if one doesn't exist
@@ -594,6 +639,17 @@ static inline int media_device_register_entity(struct media_device *mdev,
 static inline void media_device_unregister_entity(struct media_entity *entity)
 {
 }
+static inline int media_device_register_entity_notify(
+					struct media_device *mdev,
+					struct media_entity_notify *nptr)
+{
+	return 0;
+}
+static inline void media_device_unregister_entity_notify(
+					struct media_device *mdev,
+					struct media_entity_notify *nptr)
+{
+}
 static inline struct media_device *media_device_get_devres(struct device *dev)
 {
 	return NULL;

commit 6cf5dad17e913fce1ccb0c38e199eff15b0f03cc
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Feb 22 12:10:49 2016 -0300

    [media] media_device: move allocation out of media_device_*_init
    
    Right now, media_device_pci_init and media_device_usb_init does
    media_device allocation internaly. That preents its usage when
    the media_device struct is embedded on some other structure.
    
    Move memory allocation outside it, to make it more generic.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 2d144fed936e..49dda6c7e664 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -550,16 +550,19 @@ struct media_device *media_device_find_devres(struct device *dev);
  * media_device_pci_init() - create and initialize a
  *	struct &media_device from a PCI device.
  *
+ * @mdev:	pointer to struct &media_device
  * @pci_dev:	pointer to struct pci_dev
  * @name:	media device name. If %NULL, the routine will use the default
  *		name for the pci device, given by pci_name() macro.
  */
-struct media_device *media_device_pci_init(struct pci_dev *pci_dev,
-					   const char *name);
+void media_device_pci_init(struct media_device *mdev,
+			   struct pci_dev *pci_dev,
+			   const char *name);
 /**
  * __media_device_usb_init() - create and initialize a
  *	struct &media_device from a PCI device.
  *
+ * @mdev:	pointer to struct &media_device
  * @udev:	pointer to struct usb_device
  * @board_name:	media device name. If %NULL, the routine will use the usb
  *		product name, if available.
@@ -570,9 +573,10 @@ struct media_device *media_device_pci_init(struct pci_dev *pci_dev,
  * NOTE: It is better to call media_device_usb_init() instead, as
  * such macro fills driver_name with %KBUILD_MODNAME.
  */
-struct media_device *__media_device_usb_init(struct usb_device *udev,
-					     const char *board_name,
-					     const char *driver_name);
+void __media_device_usb_init(struct media_device *mdev,
+			     struct usb_device *udev,
+			     const char *board_name,
+			     const char *driver_name);
 
 #else
 static inline int media_device_register(struct media_device *mdev)
@@ -599,24 +603,24 @@ static inline struct media_device *media_device_find_devres(struct device *dev)
 	return NULL;
 }
 
-static inline
-struct media_device *media_device_pci_init(struct pci_dev *pci_dev,
-					   char *name)
+static inline void media_device_pci_init(struct media_device *mdev,
+					 struct pci_dev *pci_dev,
+					 char *name)
 {
 	return NULL;
 }
 
-static inline
-struct media_device *__media_device_usb_init(struct usb_device *udev,
-					     char *board_name,
-					     char *driver_name)
+static inline void __media_device_usb_init(struct media_device *mdev,
+					   struct usb_device *udev,
+					   char *board_name,
+					   char *driver_name)
 {
 	return NULL;
 }
 
 #endif /* CONFIG_MEDIA_CONTROLLER */
 
-#define media_device_usb_init(udev, name) \
-	__media_device_usb_init(udev, name, KBUILD_MODNAME)
+#define media_device_usb_init(mdev, udev, name) \
+	__media_device_usb_init(mdev, udev, name, KBUILD_MODNAME)
 
 #endif

commit 41b44e35ba9b34e50a65c05ecf7642c07bd3e8aa
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Mon Feb 22 11:42:04 2016 -0300

    [media] media-device: move PCI/USB helper functions from v4l2-mc
    
    Those ancillary functions could be called even when compiled
    without V4L2 support, as warned by ktest build robot:
    
    All errors (new ones prefixed by >>):
    
    >> ERROR: "__v4l2_mc_usb_media_device_init" [drivers/media/usb/dvb-usb/dvb-usb.ko] undefined!
    >> ERROR: "__v4l2_mc_usb_media_device_init" [drivers/media/usb/dvb-usb-v2/dvb_usb_v2.ko] undefined!
    >> ERROR: "__v4l2_mc_usb_media_device_init" [drivers/media/usb/au0828/au0828.ko] undefined!
    
    Also, there's nothing there that are specific to V4L2. So, move
    those ancillary functions to MC core.
    
    No functional changes. Just function rename.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 165451bc3985..2d144fed936e 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -333,6 +333,10 @@ struct media_device {
 			   unsigned int notification);
 };
 
+/* We don't need to include pci.h or usb.h here */
+struct pci_dev;
+struct usb_device;
+
 #ifdef CONFIG_MEDIA_CONTROLLER
 
 /* Supported link_notify @notification values. */
@@ -541,6 +545,35 @@ struct media_device *media_device_find_devres(struct device *dev);
 /* Iterate over all links. */
 #define media_device_for_each_link(link, mdev)			\
 	list_for_each_entry(link, &(mdev)->links, graph_obj.list)
+
+/**
+ * media_device_pci_init() - create and initialize a
+ *	struct &media_device from a PCI device.
+ *
+ * @pci_dev:	pointer to struct pci_dev
+ * @name:	media device name. If %NULL, the routine will use the default
+ *		name for the pci device, given by pci_name() macro.
+ */
+struct media_device *media_device_pci_init(struct pci_dev *pci_dev,
+					   const char *name);
+/**
+ * __media_device_usb_init() - create and initialize a
+ *	struct &media_device from a PCI device.
+ *
+ * @udev:	pointer to struct usb_device
+ * @board_name:	media device name. If %NULL, the routine will use the usb
+ *		product name, if available.
+ * @driver_name: name of the driver. if %NULL, the routine will use the name
+ *		given by udev->dev->driver->name, with is usually the wrong
+ *		thing to do.
+ *
+ * NOTE: It is better to call media_device_usb_init() instead, as
+ * such macro fills driver_name with %KBUILD_MODNAME.
+ */
+struct media_device *__media_device_usb_init(struct usb_device *udev,
+					     const char *board_name,
+					     const char *driver_name);
+
 #else
 static inline int media_device_register(struct media_device *mdev)
 {
@@ -565,5 +598,25 @@ static inline struct media_device *media_device_find_devres(struct device *dev)
 {
 	return NULL;
 }
+
+static inline
+struct media_device *media_device_pci_init(struct pci_dev *pci_dev,
+					   char *name)
+{
+	return NULL;
+}
+
+static inline
+struct media_device *__media_device_usb_init(struct usb_device *udev,
+					     char *board_name,
+					     char *driver_name)
+{
+	return NULL;
+}
+
 #endif /* CONFIG_MEDIA_CONTROLLER */
+
+#define media_device_usb_init(udev, name) \
+	__media_device_usb_init(udev, name, KBUILD_MODNAME)
+
 #endif

commit bb07bd6b6851120ac9b25bb315d62d9782d2c345
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Feb 11 14:24:23 2016 -0200

    [media] allow overriding the driver name
    
    On USB drivers, the dev struct is usually filled with the USB
    device. That would mean that the name of the driver specified
    by media_device.dev.driver.name would be "usb", instead of the
    name of the actual driver that created the media entity.
    
    Add an optional field at the internal struct to allow drivers
    to override the driver name.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index d3855898c3fc..165451bc3985 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -268,6 +268,10 @@ struct device;
  * struct media_device - Media device
  * @dev:	Parent device
  * @devnode:	Media device node
+ * @driver_name: Optional device driver name. If not set, calls to
+ *		%MEDIA_IOC_DEVICE_INFO will return dev->driver->name.
+ *		This is needed for USB drivers for example, as otherwise
+ *		they'll all appear as if the driver name was "usb".
  * @model:	Device model name
  * @serial:	Device serial number (optional)
  * @bus_info:	Unique and stable device location identifier
@@ -303,6 +307,7 @@ struct media_device {
 	struct media_devnode devnode;
 
 	char model[32];
+	char driver_name[32];
 	char serial[40];
 	char bus_info[32];
 	u32 hw_revision;

commit 05b3b77cbbb01180b681bc9211f3d471123809ca
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Dec 16 14:28:01 2015 -0200

    [media] media-device.h: use just one u32 counter for object ID
    
    Instead of using one u32 counter per type for object IDs, use
    just one counter. With such change, it makes sense to simplify
    the debug logs too.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 0dc67f2c2d0a..d3855898c3fc 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -275,10 +275,7 @@ struct device;
  * @driver_version: Device driver version
  * @topology_version: Monotonic counter for storing the version of the graph
  *		topology. Should be incremented each time the topology changes.
- * @entity_id:	Unique ID used on the last entity registered
- * @pad_id:	Unique ID used on the last pad registered
- * @link_id:	Unique ID used on the last link registered
- * @intf_devnode_id: Unique ID used on the last interface devnode registered
+ * @id:		Unique ID used on the last registered graph object
  * @entity_internal_idx: Unique internal entity ID used by the graph traversal
  *		algorithms
  * @entity_internal_idx_max: Allocated internal entity indices
@@ -313,10 +310,7 @@ struct media_device {
 
 	u32 topology_version;
 
-	u32 entity_id;
-	u32 pad_id;
-	u32 link_id;
-	u32 intf_devnode_id;
+	u32 id;
 	struct ida entity_internal_idx;
 	int entity_internal_idx_max;
 

commit 03e493388415df701d4b9e362021a83529018a3b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Dec 16 13:58:31 2015 -0200

    [media] media-entity.h fix documentation for several parameters
    
    Several parameters added by the media_ent_enum patches
    were declared with wrong argument names:
            include/media/media-device.h:333: warning: No description found for parameter 'entity_internal_idx_max'
            include/media/media-device.h:354: warning: No description found for parameter 'ent_enum'
            include/media/media-device.h:354: warning: Excess function parameter 'e' description in 'media_entity_enum_init'
            include/media/media-device.h:333: warning: No description found for parameter 'entity_internal_idx_max'
            include/media/media-device.h:354: warning: No description found for parameter 'ent_enum'
            include/media/media-device.h:354: warning: Excess function parameter 'e' description in 'media_entity_enum_init'
            include/media/media-entity.h:397: warning: No description found for parameter 'ent_enum'
            include/media/media-entity.h:397: warning: Excess function parameter 'e' description in 'media_entity_enum_zero'
            include/media/media-entity.h:409: warning: No description found for parameter 'ent_enum'
            include/media/media-entity.h:409: warning: Excess function parameter 'e' description in 'media_entity_enum_set'
            include/media/media-entity.h:424: warning: No description found for parameter 'ent_enum'
            include/media/media-entity.h:424: warning: Excess function parameter 'e' description in 'media_entity_enum_clear'
            include/media/media-entity.h:441: warning: No description found for parameter 'ent_enum'
            include/media/media-entity.h:441: warning: Excess function parameter 'e' description in 'media_entity_enum_test'
            include/media/media-entity.h:458: warning: No description found for parameter 'ent_enum'
            include/media/media-entity.h:458: warning: Excess function parameter 'e' description in 'media_entity_enum_test_and_set'
            include/media/media-entity.h:474: warning: No description found for parameter 'ent_enum'
            include/media/media-entity.h:474: warning: Excess function parameter 'e' description in 'media_entity_enum_empty'
            include/media/media-entity.h:474: warning: Excess function parameter 'entity' description in 'media_entity_enum_empty'
            include/media/media-entity.h:489: warning: No description found for parameter 'ent_enum1'
            include/media/media-entity.h:489: warning: No description found for parameter 'ent_enum2'
            include/media/media-entity.h:489: warning: Excess function parameter 'e' description in 'media_entity_enum_intersects'
            include/media/media-entity.h:489: warning: Excess function parameter 'f' description in 'media_entity_enum_intersects'
    
    Fix them.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 706afdb22d0d..0dc67f2c2d0a 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -279,7 +279,9 @@ struct device;
  * @pad_id:	Unique ID used on the last pad registered
  * @link_id:	Unique ID used on the last link registered
  * @intf_devnode_id: Unique ID used on the last interface devnode registered
- * @entity_internal_idx: Allocated internal entity indices
+ * @entity_internal_idx: Unique internal entity ID used by the graph traversal
+ *		algorithms
+ * @entity_internal_idx_max: Allocated internal entity indices
  * @entities:	List of registered entities
  * @interfaces:	List of registered interfaces
  * @pads:	List of registered pads
@@ -344,7 +346,7 @@ struct media_device {
 /**
  * media_entity_enum_init - Initialise an entity enumeration
  *
- * @e: Entity enumeration to be initialised
+ * @ent_enum: Entity enumeration to be initialised
  * @mdev: The related media device
  *
  * Returns zero on success or a negative error code.

commit 92777994a52e6c1fe0a6156a8b49e83efea6fd2c
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Dec 16 13:53:04 2015 -0200

    [media] move documentation to the header files
    
    Some exported functions were still documented at the .c file,
    instead of documenting at the .h one.
    
    Move the documentation to the right place, as we only use headers
    at media device-drivers.xml DocBook.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index da4e12ca259c..706afdb22d0d 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -428,6 +428,8 @@ void media_device_cleanup(struct media_device *mdev);
  * a sysfs attribute.
  *
  * Unregistering a media device that hasn't been registered is *NOT* safe.
+ *
+ * Return: returns zero on success or a negative error code.
  */
 int __must_check __media_device_register(struct media_device *mdev,
 					 struct module *owner);
@@ -437,6 +439,10 @@ int __must_check __media_device_register(struct media_device *mdev,
  * __media_device_unregister() - Unegisters a media device element
  *
  * @mdev:	pointer to struct &media_device
+ *
+ *
+ * It is safe to call this function on an unregistered (but initialised)
+ * media device.
  */
 void media_device_unregister(struct media_device *mdev);
 

commit c8d54cd53b43c514fbd8d36abf0f2f00f719dd54
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Wed Dec 16 11:44:32 2015 -0200

    [media] media: Add an API to manage entity enumerations
    
    This is useful in e.g. knowing whether certain operations have already
    been performed for an entity. The users include the framework itself (for
    graph walking) and a number of drivers.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 2ab4e6803842..da4e12ca259c 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -341,6 +341,21 @@ struct media_device {
 /* media_devnode to media_device */
 #define to_media_device(node) container_of(node, struct media_device, devnode)
 
+/**
+ * media_entity_enum_init - Initialise an entity enumeration
+ *
+ * @e: Entity enumeration to be initialised
+ * @mdev: The related media device
+ *
+ * Returns zero on success or a negative error code.
+ */
+static inline __must_check int media_entity_enum_init(
+	struct media_entity_enum *ent_enum, struct media_device *mdev)
+{
+	return __media_entity_enum_init(ent_enum,
+					mdev->entity_internal_idx_max + 1);
+}
+
 /**
  * media_device_init() - Initializes a media device element
  *

commit 665faa971d087e8b968ef75d04079a7a462ddfca
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Wed Dec 16 11:32:17 2015 -0200

    [media] media: Introduce internal index for media entities
    
    The internal index can be used internally by the framework in order to keep
    track of entities for a purpose or another. The internal index is constant
    while it's registered to a media device, but the same index may be re-used
    once the entity having that index is unregistered.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index e01bbc427fcd..2ab4e6803842 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -261,6 +261,7 @@
  * in the end provide a way to use driver-specific callbacks.
  */
 
+struct ida;
 struct device;
 
 /**
@@ -278,6 +279,7 @@ struct device;
  * @pad_id:	Unique ID used on the last pad registered
  * @link_id:	Unique ID used on the last link registered
  * @intf_devnode_id: Unique ID used on the last interface devnode registered
+ * @entity_internal_idx: Allocated internal entity indices
  * @entities:	List of registered entities
  * @interfaces:	List of registered interfaces
  * @pads:	List of registered pads
@@ -313,6 +315,8 @@ struct media_device {
 	u32 pad_id;
 	u32 link_id;
 	u32 intf_devnode_id;
+	struct ida entity_internal_idx;
+	int entity_internal_idx_max;
 
 	struct list_head entities;
 	struct list_head interfaces;

commit 9832e155f1ed3030fdfaa19e72c06472dc2ecb1d
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Fri Dec 11 20:57:08 2015 -0200

    [media] media-device: split media initialization and registration
    
    The media device node is registered and so made visible to user-space
    before entities are registered and links created which means that the
    media graph obtained by user-space could be only partially enumerated
    if that happens too early before all the graph has been created.
    
    To avoid this race condition, split the media init and registration
    in separate functions and only register the media device node when
    all the pending subdevices have been registered, either explicitly
    by the driver or asynchronously using v4l2_async_register_subdev().
    
    The media_device_register() had a check for drivers not filling dev
    and model fields but all drivers in mainline set them and not doing
    it will be a driver bug so change the function return to void and
    add a BUG_ON() for dev being NULL instead.
    
    Also, add a media_device_cleanup() function that will destroy the
    graph_mutex that is initialized in media_device_init().
    
    [mchehab@osg.samsung.com: Fix compilation if !CONFIG_MEDIA_CONTROLLER
     and remove two warnings added by this changeset]
    Suggested-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index ebc2f3a239eb..e01bbc427fcd 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -337,6 +337,32 @@ struct media_device {
 /* media_devnode to media_device */
 #define to_media_device(node) container_of(node, struct media_device, devnode)
 
+/**
+ * media_device_init() - Initializes a media device element
+ *
+ * @mdev:	pointer to struct &media_device
+ *
+ * This function initializes the media device prior to its registration.
+ * The media device initialization and registration is split in two functions
+ * to avoid race conditions and make the media device available to user-space
+ * before the media graph has been completed.
+ *
+ * So drivers need to first initialize the media device, register any entity
+ * within the media device, create pad to pad links and then finally register
+ * the media device by calling media_device_register() as a final step.
+ */
+void media_device_init(struct media_device *mdev);
+
+/**
+ * media_device_cleanup() - Cleanups a media device element
+ *
+ * @mdev:	pointer to struct &media_device
+ *
+ * This function that will destroy the graph_mutex that is
+ * initialized in media_device_init().
+ */
+void media_device_cleanup(struct media_device *mdev);
+
 /**
  * __media_device_register() - Registers a media device element
  *

commit b6e4ca8129ad65a0b1552586c1d42d2fd219661e
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Dec 13 08:36:58 2015 -0200

    [media] media-device.h: document the last functions
    
    Add kernel-doc documentation for media_device_get_devres and
    media_device_find_devres.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 215a0d88241d..ebc2f3a239eb 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -449,7 +449,29 @@ int __must_check media_device_register_entity(struct media_device *mdev,
  * the driver if required.
  */
 void media_device_unregister_entity(struct media_entity *entity);
+
+/**
+ * media_device_get_devres() -	get media device as device resource
+ *				creates if one doesn't exist
+ *
+ * @dev: pointer to struct &device.
+ *
+ * Sometimes, the media controller &media_device needs to be shared by more
+ * than one driver. This function adds support for that, by dynamically
+ * allocating the &media_device and allowing it to be obtained from the
+ * struct &device associated with the common device where all sub-device
+ * components belong. So, for example, on an USB device with multiple
+ * interfaces, each interface may be handled by a separate per-interface
+ * drivers. While each interface have its own &device, they all share a
+ * common &device associated with the hole USB device.
+ */
 struct media_device *media_device_get_devres(struct device *dev);
+
+/**
+ * media_device_find_devres() - find media device as device resource
+ *
+ * @dev: pointer to struct &device.
+ */
 struct media_device *media_device_find_devres(struct device *dev);
 
 /* Iterate over all entities. */

commit d1b9da2d606ecec587177c4c90f1905c57538149
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Dec 11 12:41:12 2015 -0200

    [media] media-device.h: Let clearer that entity function must be initialized
    
    Improve the documentation to let it clear that the entity function
    must be initialized.
    
    Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index f9907a7728d4..215a0d88241d 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -423,6 +423,10 @@ void media_device_unregister(struct media_device *mdev);
  * %MEDIA_ENT_FL_DEFAULT indicates the default entity for a given type.
  *	This can be used to report the default audio and video devices or the
  *	default camera sensor.
+ *
+ * NOTE: Drivers should set the entity function before calling this function.
+ * Please notice that the values %MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN and
+ * %MEDIA_ENT_F_UNKNOWN should not be used by the drivers.
  */
 int __must_check media_device_register_entity(struct media_device *mdev,
 					      struct media_entity *entity);

commit 97d0a70ae5e2391f213966a69c3b6f96f2c9f25b
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Dec 11 11:12:57 2015 -0200

    [media] media: remove extra blank lines
    
    No functional changes.
    
    Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 65fdd44e05ef..f9907a7728d4 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -463,8 +463,6 @@ struct media_device *media_device_find_devres(struct device *dev);
 /* Iterate over all links. */
 #define media_device_for_each_link(link, mdev)			\
 	list_for_each_entry(link, &(mdev)->links, graph_obj.list)
-
-
 #else
 static inline int media_device_register(struct media_device *mdev)
 {

commit db7ee32aa1859c155e634a4d5c44b9cff4c9a6e5
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Dec 11 11:06:08 2015 -0200

    [media] media-device.h: Improve documentation and update it
    
    Now that we moved the content of the media-framework.txt into
    the kerneldoc documentation, move the per-function specific
    documentation to the corresponding functions and clean it up.
    
    It would be good if we had already the markdown kernel-doc
    patches merged upstream, but, while we doesn't have it,
    let's make it less ugly at device-drivers.xml.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 6728528df9e2..65fdd44e05ef 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -33,23 +33,11 @@
 /**
  * DOC: Media Controller
  *
- * Linux kernel media framework
- * ============================
- *
- * This document describes the Linux kernel media framework, its data structures,
- * functions and their usage.
- *
- *
- * Introduction
- * ------------
- *
- * The media controller API is documented in DocBook format in
- * Documentation/DocBook/media/v4l/media-controller.xml. This document will focus
+ * The media controller userspace API is documented in DocBook format in
+ * Documentation/DocBook/media/v4l/media-controller.xml. This document focus
  * on the kernel-side implementation of the media framework.
  *
- *
- * Abstract media device model
- * ---------------------------
+ * * Abstract media device model:
  *
  * Discovering a device internal topology, and configuring it at runtime, is one
  * of the goals of the media framework. To achieve this, hardware devices are
@@ -72,195 +60,104 @@
  * pad to a sink pad.
  *
  *
- * Media device
- * ------------
+ * * Media device:
  *
- * A media device is represented by a struct media_device instance, defined in
+ * A media device is represented by a struct &media_device instance, defined in
  * include/media/media-device.h. Allocation of the structure is handled by the
- * media device driver, usually by embedding the media_device instance in a
+ * media device driver, usually by embedding the &media_device instance in a
  * larger driver-specific structure.
  *
  * Drivers register media device instances by calling
+ *	__media_device_register() via the macro media_device_register()
+ * and unregistered by calling
+ *	media_device_unregister().
  *
- * 	media_device_register(struct media_device *mdev);
- *
- * The caller is responsible for initializing the media_device structure before
- * registration. The following fields must be set:
- *
- *  - dev must point to the parent device (usually a pci_dev, usb_interface or
- *    platform_device instance).
- *
- *  - model must be filled with the device model name as a NUL-terminated UTF-8
- *    string. The device/model revision must not be stored in this field.
- *
- * The following fields are optional:
- *
- *  - serial is a unique serial number stored as a NUL-terminated ASCII string.
- *    The field is big enough to store a GUID in text form. If the hardware
- *    doesn't provide a unique serial number this field must be left empty.
- *
- *  - bus_info represents the location of the device in the system as a
- *    NUL-terminated ASCII string. For PCI/PCIe devices bus_info must be set to
- *    "PCI:" (or "PCIe:") followed by the value of pci_name(). For USB devices,
- *    the usb_make_path() function must be used. This field is used by
- *    applications to distinguish between otherwise identical devices that don't
- *    provide a serial number.
- *
- *  - hw_revision is the hardware device revision in a driver-specific format.
- *    When possible the revision should be formatted with the KERNEL_VERSION
- *    macro.
- *
- *  - driver_version is formatted with the KERNEL_VERSION macro. The version
- *    minor must be incremented when new features are added to the userspace API
- *    without breaking binary compatibility. The version major must be
- *    incremented when binary compatibility is broken.
- *
- * Upon successful registration a character device named media[0-9]+ is created.
- * The device major and minor numbers are dynamic. The model name is exported as
- * a sysfs attribute.
- *
- * Drivers unregister media device instances by calling
- *
- * 	media_device_unregister(struct media_device *mdev);
- *
- * Unregistering a media device that hasn't been registered is *NOT* safe.
- *
- *
- * Entities, pads and links
- * ------------------------
+ * * Entities, pads and links:
  *
  * - Entities
  *
- * Entities are represented by a struct media_entity instance, defined in
+ * Entities are represented by a struct &media_entity instance, defined in
  * include/media/media-entity.h. The structure is usually embedded into a
  * higher-level structure, such as a v4l2_subdev or video_device instance,
  * although drivers can allocate entities directly.
  *
  * Drivers initialize entity pads by calling
- *
- * 	media_entity_pads_init(struct media_entity *entity, u16 num_pads,
- * 			  struct media_pad *pads);
- *
- * If no pads are needed, drivers could directly fill entity->num_pads
- * with 0 and entity->pads with NULL or to call the above function that
- * will do the same.
- *
- * The media_entity name, type and flags fields should be initialized before
- * calling media_device_register_entity(). Entities embedded in higher-level
- * standard structures can have some of those fields set by the higher-level
- * framework.
- *
- * As the number of pads is known in advance, the pads array is not allocated
- * dynamically but is managed by the entity driver. Most drivers will embed the
- * pads array in a driver-specific structure, avoiding dynamic allocation.
- *
- * Drivers must set the direction of every pad in the pads array before calling
- * media_entity_pads_init. The function will initialize the other pads fields.
- *
- * Unlike the number of pads, the total number of links isn't always known in
- * advance by the entity driver. As an initial estimate, media_entity_pads_init
- * pre-allocates a number of links equal to the number of pads. The links array
- * will be reallocated if it grows beyond the initial estimate.
+ *	media_entity_pads_init().
  *
  * Drivers register entities with a media device by calling
+ *	media_device_register_entity()
+ * and unregistred by calling
+ *	media_device_unregister_entity().
  *
- * 	media_device_register_entity(struct media_device *mdev,
- * 				     struct media_entity *entity);
+ * - Interfaces
  *
- * Entities are identified by a unique positive integer ID. Drivers can provide an
- * ID by filling the media_entity id field prior to registration, or request the
- * media controller framework to assign an ID automatically. Drivers that provide
- * IDs manually must ensure that all IDs are unique. IDs are not guaranteed to be
- * contiguous even when they are all assigned automatically by the framework.
+ * Interfaces are represented by a struct &media_interface instance, defined in
+ * include/media/media-entity.h. Currently, only one type of interface is
+ * defined: a device node. Such interfaces are represented by a struct
+ * &media_intf_devnode.
  *
- * Drivers unregister entities by calling
- *
- * 	media_device_unregister_entity(struct media_entity *entity);
- *
- * Unregistering an entity will not change the IDs of the other entities, and the
- * ID will never be reused for a newly registered entity.
- *
- * When a media device is unregistered, all its entities are unregistered
- * automatically. No manual entities unregistration is then required.
- *
- * Drivers free resources associated with an entity by calling
- *
- * 	media_entity_cleanup(struct media_entity *entity);
- *
- * This function must be called during the cleanup phase after unregistering the
- * entity. Note that the media_entity instance itself must be freed explicitly by
- * the driver if required.
- *
- * Entities have flags that describe the entity capabilities and state.
- *
- * 	MEDIA_ENT_FL_DEFAULT indicates the default entity for a given type.
- * 	This can be used to report the default audio and video devices or the
- * 	default camera sensor.
- *
- * Logical entity groups can be defined by setting the group ID of all member
- * entities to the same non-zero value. An entity group serves no purpose in the
- * kernel, but is reported to userspace during entities enumeration.
- *
- * Media device drivers should define groups if several entities are logically
- * bound together. Example usages include reporting
- *
- * 	- ALSA, VBI and video nodes that carry the same media stream
- * 	- lens and flash controllers associated with a sensor
+ * Drivers initialize and create device node interfaces by calling
+ *	media_devnode_create()
+ * and remove them by calling:
+ *	media_devnode_remove().
  *
  * - Pads
  *
- * Pads are represented by a struct media_pad instance, defined in
+ * Pads are represented by a struct &media_pad instance, defined in
  * include/media/media-entity.h. Each entity stores its pads in a pads array
  * managed by the entity driver. Drivers usually embed the array in a
  * driver-specific structure.
  *
- * Pads are identified by their entity and their 0-based index in the pads array.
- * Both information are stored in the media_pad structure, making the media_pad
- * pointer the canonical way to store and pass link references.
+ * Pads are identified by their entity and their 0-based index in the pads
+ * array.
+ * Both information are stored in the &media_pad structure, making the
+ * &media_pad pointer the canonical way to store and pass link references.
  *
  * Pads have flags that describe the pad capabilities and state.
  *
- * 	MEDIA_PAD_FL_SINK indicates that the pad supports sinking data.
- * 	MEDIA_PAD_FL_SOURCE indicates that the pad supports sourcing data.
+ *	%MEDIA_PAD_FL_SINK indicates that the pad supports sinking data.
+ *	%MEDIA_PAD_FL_SOURCE indicates that the pad supports sourcing data.
  *
- * One and only one of MEDIA_PAD_FL_SINK and MEDIA_PAD_FL_SOURCE must be set for
- * each pad.
+ * NOTE: One and only one of %MEDIA_PAD_FL_SINK and %MEDIA_PAD_FL_SOURCE must
+ * be set for each pad.
  *
  * - Links
  *
- * Links are represented by a struct media_link instance, defined in
- * include/media/media-entity.h. Each entity stores all links originating at or
- * targeting any of its pads in a links array. A given link is thus stored
- * twice, once in the source entity and once in the target entity. The array is
- * pre-allocated and grows dynamically as needed.
+ * Links are represented by a struct &media_link instance, defined in
+ * include/media/media-entity.h. There are two types of links:
+ *
+ * 1. pad to pad links:
  *
- * Drivers create links by calling
+ * Associate two entities via their PADs. Each entity has a list that points
+ * to all links originating at or targeting any of its pads.
+ * A given link is thus stored twice, once in the source entity and once in
+ * the target entity.
  *
- * 	media_create_pad_link(struct media_entity *source, u16 source_pad,
- * 				 struct media_entity *sink,   u16 sink_pad,
- * 				 u32 flags);
+ * Drivers create pad to pad links by calling:
+ *	media_create_pad_link() and remove with media_entity_remove_links().
  *
- * An entry in the link array of each entity is allocated and stores pointers
- * to source and sink pads.
+ * 2. interface to entity links:
  *
- * Links have flags that describe the link capabilities and state.
+ * Associate one interface to a Link.
  *
- * 	MEDIA_LNK_FL_ENABLED indicates that the link is enabled and can be used
- * 	to transfer media data. When two or more links target a sink pad, only
- * 	one of them can be enabled at a time.
- * 	MEDIA_LNK_FL_IMMUTABLE indicates that the link enabled state can't be
- * 	modified at runtime. If MEDIA_LNK_FL_IMMUTABLE is set, then
- * 	MEDIA_LNK_FL_ENABLED must also be set since an immutable link is always
- * 	enabled.
+ * Drivers create interface to entity links by calling:
+ *	media_create_intf_link() and remove with media_remove_intf_links().
  *
+ * NOTE:
  *
- * Graph traversal
- * ---------------
+ * Links can only be created after having both ends already created.
+ *
+ * Links have flags that describe the link capabilities and state. The
+ * valid values are described at media_create_pad_link() and
+ * media_create_intf_link().
+ *
+ * Graph traversal:
  *
  * The media framework provides APIs to iterate over entities in a graph.
  *
- * To iterate over all entities belonging to a media device, drivers can use the
- * media_device_for_each_entity macro, defined in include/media/media-device.h.
+ * To iterate over all entities belonging to a media device, drivers can use
+ * the media_device_for_each_entity macro, defined in
+ * include/media/media-device.h.
  *
  * 	struct media_entity *entity;
  *
@@ -279,126 +176,82 @@
  * currently defined as 16.
  *
  * Drivers initiate a graph traversal by calling
- *
- * 	media_entity_graph_walk_start(struct media_entity_graph *graph,
- * 				      struct media_entity *entity);
+ *	media_entity_graph_walk_start()
  *
  * The graph structure, provided by the caller, is initialized to start graph
  * traversal at the given entity.
  *
  * Drivers can then retrieve the next entity by calling
- *
- * 	media_entity_graph_walk_next(struct media_entity_graph *graph);
+ *	media_entity_graph_walk_next()
  *
  * When the graph traversal is complete the function will return NULL.
  *
- * Graph traversal can be interrupted at any moment. No cleanup function call is
- * required and the graph structure can be freed normally.
+ * Graph traversal can be interrupted at any moment. No cleanup function call
+ * is required and the graph structure can be freed normally.
  *
  * Helper functions can be used to find a link between two given pads, or a pad
  * connected to another pad through an enabled link
+ *	media_entity_find_link() and media_entity_remote_pad()
  *
- * 	media_entity_find_link(struct media_pad *source,
- * 			       struct media_pad *sink);
- *
- * 	media_entity_remote_pad(struct media_pad *pad);
- *
- * Refer to the kerneldoc documentation for more information.
- *
- *
- * Use count and power handling
- * ----------------------------
- *
- * Due to the wide differences between drivers regarding power management needs,
- * the media controller does not implement power management. However, the
- * media_entity structure includes a use_count field that media drivers can use to
- * track the number of users of every entity for power management needs.
+ * Use count and power handling:
  *
- * The use_count field is owned by media drivers and must not be touched by entity
- * drivers. Access to the field must be protected by the media device graph_mutex
- * lock.
+ * Due to the wide differences between drivers regarding power management
+ * needs, the media controller does not implement power management. However,
+ * the &media_entity structure includes a use_count field that media drivers
+ * can use to track the number of users of every entity for power management
+ * needs.
  *
+ * The &media_entity.@use_count field is owned by media drivers and must not be
+ * touched by entity drivers. Access to the field must be protected by the
+ * &media_device.@graph_mutex lock.
  *
- * Links setup
- * -----------
+ * Links setup:
  *
  * Link properties can be modified at runtime by calling
+ *	media_entity_setup_link()
  *
- * 	media_entity_setup_link(struct media_link *link, u32 flags);
- *
- * The flags argument contains the requested new link flags.
- *
- * The only configurable property is the ENABLED link flag to enable/disable a
- * link. Links marked with the IMMUTABLE link flag can not be enabled or disabled.
- *
- * When a link is enabled or disabled, the media framework calls the
- * link_setup operation for the two entities at the source and sink of the link,
- * in that order. If the second link_setup call fails, another link_setup call is
- * made on the first entity to restore the original link flags.
- *
- * Media device drivers can be notified of link setup operations by setting the
- * media_device::link_notify pointer to a callback function. If provided, the
- * notification callback will be called before enabling and after disabling
- * links.
- *
- * Entity drivers must implement the link_setup operation if any of their links
- * is non-immutable. The operation must either configure the hardware or store
- * the configuration information to be applied later.
- *
- * Link configuration must not have any side effect on other links. If an enabled
- * link at a sink pad prevents another link at the same pad from being enabled,
- * the link_setup operation must return -EBUSY and can't implicitly disable the
- * first enabled link.
- *
- *
- * Pipelines and media streams
- * ---------------------------
+ * Pipelines and media streams:
  *
  * When starting streaming, drivers must notify all entities in the pipeline to
  * prevent link states from being modified during streaming by calling
- *
- * 	media_entity_pipeline_start(struct media_entity *entity,
- * 				    struct media_pipeline *pipe);
+ *	media_entity_pipeline_start().
  *
  * The function will mark all entities connected to the given entity through
  * enabled links, either directly or indirectly, as streaming.
  *
- * The media_pipeline instance pointed to by the pipe argument will be stored in
- * every entity in the pipeline. Drivers should embed the media_pipeline structure
- * in higher-level pipeline structures and can then access the pipeline through
- * the media_entity pipe field.
+ * The &media_pipeline instance pointed to by the pipe argument will be stored
+ * in every entity in the pipeline. Drivers should embed the &media_pipeline
+ * structure in higher-level pipeline structures and can then access the
+ * pipeline through the &media_entity pipe field.
  *
- * Calls to media_entity_pipeline_start() can be nested. The pipeline pointer must
- * be identical for all nested calls to the function.
+ * Calls to media_entity_pipeline_start() can be nested. The pipeline pointer
+ * must be identical for all nested calls to the function.
  *
  * media_entity_pipeline_start() may return an error. In that case, it will
  * clean up any of the changes it did by itself.
  *
  * When stopping the stream, drivers must notify the entities with
- *
- * 	media_entity_pipeline_stop(struct media_entity *entity);
+ *	media_entity_pipeline_stop().
  *
  * If multiple calls to media_entity_pipeline_start() have been made the same
- * number of media_entity_pipeline_stop() calls are required to stop streaming. The
- * media_entity pipe field is reset to NULL on the last nested stop call.
+ * number of media_entity_pipeline_stop() calls are required to stop streaming.
+ * The &media_entity pipe field is reset to NULL on the last nested stop call.
  *
- * Link configuration will fail with -EBUSY by default if either end of the link is
- * a streaming entity. Links that can be modified while streaming must be marked
- * with the MEDIA_LNK_FL_DYNAMIC flag.
+ * Link configuration will fail with -%EBUSY by default if either end of the
+ * link is a streaming entity. Links that can be modified while streaming must
+ * be marked with the %MEDIA_LNK_FL_DYNAMIC flag.
  *
  * If other operations need to be disallowed on streaming entities (such as
  * changing entities configuration parameters) drivers can explicitly check the
  * media_entity stream_count field to find out if an entity is streaming. This
  * operation must be done with the media_device graph_mutex held.
  *
- *
- * Link validation
- * ---------------
+ * Link validation:
  *
  * Link validation is performed by media_entity_pipeline_start() for any
  * entity which has sink pads in the pipeline. The
- * media_entity::link_validate() callback is used for that purpose. In
- * link_validate() callback, entity driver should check that the properties of
+ * &media_entity.@link_validate() callback is used for that purpose. In
+ * @link_validate() callback, entity driver should check that the properties of
  * the source pad of the connected entity and its own sink pad match. It is up
  * to the type of the entity (and in the end, the properties of the hardware)
  * what matching actually means.
@@ -484,13 +337,113 @@ struct media_device {
 /* media_devnode to media_device */
 #define to_media_device(node) container_of(node, struct media_device, devnode)
 
+/**
+ * __media_device_register() - Registers a media device element
+ *
+ * @mdev:	pointer to struct &media_device
+ * @owner:	should be filled with %THIS_MODULE
+ *
+ * Users, should, instead, call the media_device_register() macro.
+ *
+ * The caller is responsible for initializing the media_device structure before
+ * registration. The following fields must be set:
+ *
+ *  - dev must point to the parent device (usually a &pci_dev, &usb_interface or
+ *    &platform_device instance).
+ *
+ *  - model must be filled with the device model name as a NUL-terminated UTF-8
+ *    string. The device/model revision must not be stored in this field.
+ *
+ * The following fields are optional:
+ *
+ *  - serial is a unique serial number stored as a NUL-terminated ASCII string.
+ *    The field is big enough to store a GUID in text form. If the hardware
+ *    doesn't provide a unique serial number this field must be left empty.
+ *
+ *  - bus_info represents the location of the device in the system as a
+ *    NUL-terminated ASCII string. For PCI/PCIe devices bus_info must be set to
+ *    "PCI:" (or "PCIe:") followed by the value of pci_name(). For USB devices,
+ *    the usb_make_path() function must be used. This field is used by
+ *    applications to distinguish between otherwise identical devices that don't
+ *    provide a serial number.
+ *
+ *  - hw_revision is the hardware device revision in a driver-specific format.
+ *    When possible the revision should be formatted with the KERNEL_VERSION
+ *    macro.
+ *
+ *  - driver_version is formatted with the KERNEL_VERSION macro. The version
+ *    minor must be incremented when new features are added to the userspace API
+ *    without breaking binary compatibility. The version major must be
+ *    incremented when binary compatibility is broken.
+ *
+ * Notes:
+ *
+ * Upon successful registration a character device named media[0-9]+ is created.
+ * The device major and minor numbers are dynamic. The model name is exported as
+ * a sysfs attribute.
+ *
+ * Unregistering a media device that hasn't been registered is *NOT* safe.
+ */
 int __must_check __media_device_register(struct media_device *mdev,
 					 struct module *owner);
 #define media_device_register(mdev) __media_device_register(mdev, THIS_MODULE)
+
+/**
+ * __media_device_unregister() - Unegisters a media device element
+ *
+ * @mdev:	pointer to struct &media_device
+ */
 void media_device_unregister(struct media_device *mdev);
 
+/**
+ * media_device_register_entity() - registers a media entity inside a
+ *	previously registered media device.
+ *
+ * @mdev:	pointer to struct &media_device
+ * @entity:	pointer to struct &media_entity to be registered
+ *
+ * Entities are identified by a unique positive integer ID. The media
+ * controller framework will such ID automatically. IDs are not guaranteed
+ * to be contiguous, and the ID number can change on newer Kernel versions.
+ * So, neither the driver nor userspace should hardcode ID numbers to refer
+ * to the entities, but, instead, use the framework to find the ID, when
+ * needed.
+ *
+ * The media_entity name, type and flags fields should be initialized before
+ * calling media_device_register_entity(). Entities embedded in higher-level
+ * standard structures can have some of those fields set by the higher-level
+ * framework.
+ *
+ * If the device has pads, media_entity_pads_init() should be called before
+ * this function. Otherwise, the &media_entity.@pad and &media_entity.@num_pads
+ * should be zeroed before calling this function.
+ *
+ * Entities have flags that describe the entity capabilities and state:
+ *
+ * %MEDIA_ENT_FL_DEFAULT indicates the default entity for a given type.
+ *	This can be used to report the default audio and video devices or the
+ *	default camera sensor.
+ */
 int __must_check media_device_register_entity(struct media_device *mdev,
 					      struct media_entity *entity);
+
+/*
+ * media_device_unregister_entity() - unregisters a media entity.
+ *
+ * @entity:	pointer to struct &media_entity to be unregistered
+ *
+ * All links associated with the entity and all PADs are automatically
+ * unregistered from the media_device when this function is called.
+ *
+ * Unregistering an entity will not change the IDs of the other entities and
+ * the previoully used ID will never be reused for a newly registered entities.
+ *
+ * When a media device is unregistered, all its entities are unregistered
+ * automatically. No manual entities unregistration is then required.
+ *
+ * Note: the media_entity instance itself must be freed explicitly by
+ * the driver if required.
+ */
 void media_device_unregister_entity(struct media_entity *entity);
 struct media_device *media_device_get_devres(struct device *dev);
 struct media_device *media_device_find_devres(struct device *dev);

commit cc2dd94a051c8a467c66a258391cb980c3fb3312
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Dec 11 08:21:39 2015 -0200

    [media] DocBook: Move media-framework.txt contents to media-device.h
    
    Instead of using a text file, let's put it together with the
    struct documentation for the Media Controller.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 87ff299e1265..6728528df9e2 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -30,6 +30,384 @@
 #include <media/media-devnode.h>
 #include <media/media-entity.h>
 
+/**
+ * DOC: Media Controller
+ *
+ * Linux kernel media framework
+ * ============================
+ *
+ * This document describes the Linux kernel media framework, its data structures,
+ * functions and their usage.
+ *
+ *
+ * Introduction
+ * ------------
+ *
+ * The media controller API is documented in DocBook format in
+ * Documentation/DocBook/media/v4l/media-controller.xml. This document will focus
+ * on the kernel-side implementation of the media framework.
+ *
+ *
+ * Abstract media device model
+ * ---------------------------
+ *
+ * Discovering a device internal topology, and configuring it at runtime, is one
+ * of the goals of the media framework. To achieve this, hardware devices are
+ * modelled as an oriented graph of building blocks called entities connected
+ * through pads.
+ *
+ * An entity is a basic media hardware building block. It can correspond to
+ * a large variety of logical blocks such as physical hardware devices
+ * (CMOS sensor for instance), logical hardware devices (a building block
+ * in a System-on-Chip image processing pipeline), DMA channels or physical
+ * connectors.
+ *
+ * A pad is a connection endpoint through which an entity can interact with
+ * other entities. Data (not restricted to video) produced by an entity
+ * flows from the entity's output to one or more entity inputs. Pads should
+ * not be confused with physical pins at chip boundaries.
+ *
+ * A link is a point-to-point oriented connection between two pads, either
+ * on the same entity or on different entities. Data flows from a source
+ * pad to a sink pad.
+ *
+ *
+ * Media device
+ * ------------
+ *
+ * A media device is represented by a struct media_device instance, defined in
+ * include/media/media-device.h. Allocation of the structure is handled by the
+ * media device driver, usually by embedding the media_device instance in a
+ * larger driver-specific structure.
+ *
+ * Drivers register media device instances by calling
+ *
+ * 	media_device_register(struct media_device *mdev);
+ *
+ * The caller is responsible for initializing the media_device structure before
+ * registration. The following fields must be set:
+ *
+ *  - dev must point to the parent device (usually a pci_dev, usb_interface or
+ *    platform_device instance).
+ *
+ *  - model must be filled with the device model name as a NUL-terminated UTF-8
+ *    string. The device/model revision must not be stored in this field.
+ *
+ * The following fields are optional:
+ *
+ *  - serial is a unique serial number stored as a NUL-terminated ASCII string.
+ *    The field is big enough to store a GUID in text form. If the hardware
+ *    doesn't provide a unique serial number this field must be left empty.
+ *
+ *  - bus_info represents the location of the device in the system as a
+ *    NUL-terminated ASCII string. For PCI/PCIe devices bus_info must be set to
+ *    "PCI:" (or "PCIe:") followed by the value of pci_name(). For USB devices,
+ *    the usb_make_path() function must be used. This field is used by
+ *    applications to distinguish between otherwise identical devices that don't
+ *    provide a serial number.
+ *
+ *  - hw_revision is the hardware device revision in a driver-specific format.
+ *    When possible the revision should be formatted with the KERNEL_VERSION
+ *    macro.
+ *
+ *  - driver_version is formatted with the KERNEL_VERSION macro. The version
+ *    minor must be incremented when new features are added to the userspace API
+ *    without breaking binary compatibility. The version major must be
+ *    incremented when binary compatibility is broken.
+ *
+ * Upon successful registration a character device named media[0-9]+ is created.
+ * The device major and minor numbers are dynamic. The model name is exported as
+ * a sysfs attribute.
+ *
+ * Drivers unregister media device instances by calling
+ *
+ * 	media_device_unregister(struct media_device *mdev);
+ *
+ * Unregistering a media device that hasn't been registered is *NOT* safe.
+ *
+ *
+ * Entities, pads and links
+ * ------------------------
+ *
+ * - Entities
+ *
+ * Entities are represented by a struct media_entity instance, defined in
+ * include/media/media-entity.h. The structure is usually embedded into a
+ * higher-level structure, such as a v4l2_subdev or video_device instance,
+ * although drivers can allocate entities directly.
+ *
+ * Drivers initialize entity pads by calling
+ *
+ * 	media_entity_pads_init(struct media_entity *entity, u16 num_pads,
+ * 			  struct media_pad *pads);
+ *
+ * If no pads are needed, drivers could directly fill entity->num_pads
+ * with 0 and entity->pads with NULL or to call the above function that
+ * will do the same.
+ *
+ * The media_entity name, type and flags fields should be initialized before
+ * calling media_device_register_entity(). Entities embedded in higher-level
+ * standard structures can have some of those fields set by the higher-level
+ * framework.
+ *
+ * As the number of pads is known in advance, the pads array is not allocated
+ * dynamically but is managed by the entity driver. Most drivers will embed the
+ * pads array in a driver-specific structure, avoiding dynamic allocation.
+ *
+ * Drivers must set the direction of every pad in the pads array before calling
+ * media_entity_pads_init. The function will initialize the other pads fields.
+ *
+ * Unlike the number of pads, the total number of links isn't always known in
+ * advance by the entity driver. As an initial estimate, media_entity_pads_init
+ * pre-allocates a number of links equal to the number of pads. The links array
+ * will be reallocated if it grows beyond the initial estimate.
+ *
+ * Drivers register entities with a media device by calling
+ *
+ * 	media_device_register_entity(struct media_device *mdev,
+ * 				     struct media_entity *entity);
+ *
+ * Entities are identified by a unique positive integer ID. Drivers can provide an
+ * ID by filling the media_entity id field prior to registration, or request the
+ * media controller framework to assign an ID automatically. Drivers that provide
+ * IDs manually must ensure that all IDs are unique. IDs are not guaranteed to be
+ * contiguous even when they are all assigned automatically by the framework.
+ *
+ * Drivers unregister entities by calling
+ *
+ * 	media_device_unregister_entity(struct media_entity *entity);
+ *
+ * Unregistering an entity will not change the IDs of the other entities, and the
+ * ID will never be reused for a newly registered entity.
+ *
+ * When a media device is unregistered, all its entities are unregistered
+ * automatically. No manual entities unregistration is then required.
+ *
+ * Drivers free resources associated with an entity by calling
+ *
+ * 	media_entity_cleanup(struct media_entity *entity);
+ *
+ * This function must be called during the cleanup phase after unregistering the
+ * entity. Note that the media_entity instance itself must be freed explicitly by
+ * the driver if required.
+ *
+ * Entities have flags that describe the entity capabilities and state.
+ *
+ * 	MEDIA_ENT_FL_DEFAULT indicates the default entity for a given type.
+ * 	This can be used to report the default audio and video devices or the
+ * 	default camera sensor.
+ *
+ * Logical entity groups can be defined by setting the group ID of all member
+ * entities to the same non-zero value. An entity group serves no purpose in the
+ * kernel, but is reported to userspace during entities enumeration.
+ *
+ * Media device drivers should define groups if several entities are logically
+ * bound together. Example usages include reporting
+ *
+ * 	- ALSA, VBI and video nodes that carry the same media stream
+ * 	- lens and flash controllers associated with a sensor
+ *
+ * - Pads
+ *
+ * Pads are represented by a struct media_pad instance, defined in
+ * include/media/media-entity.h. Each entity stores its pads in a pads array
+ * managed by the entity driver. Drivers usually embed the array in a
+ * driver-specific structure.
+ *
+ * Pads are identified by their entity and their 0-based index in the pads array.
+ * Both information are stored in the media_pad structure, making the media_pad
+ * pointer the canonical way to store and pass link references.
+ *
+ * Pads have flags that describe the pad capabilities and state.
+ *
+ * 	MEDIA_PAD_FL_SINK indicates that the pad supports sinking data.
+ * 	MEDIA_PAD_FL_SOURCE indicates that the pad supports sourcing data.
+ *
+ * One and only one of MEDIA_PAD_FL_SINK and MEDIA_PAD_FL_SOURCE must be set for
+ * each pad.
+ *
+ * - Links
+ *
+ * Links are represented by a struct media_link instance, defined in
+ * include/media/media-entity.h. Each entity stores all links originating at or
+ * targeting any of its pads in a links array. A given link is thus stored
+ * twice, once in the source entity and once in the target entity. The array is
+ * pre-allocated and grows dynamically as needed.
+ *
+ * Drivers create links by calling
+ *
+ * 	media_create_pad_link(struct media_entity *source, u16 source_pad,
+ * 				 struct media_entity *sink,   u16 sink_pad,
+ * 				 u32 flags);
+ *
+ * An entry in the link array of each entity is allocated and stores pointers
+ * to source and sink pads.
+ *
+ * Links have flags that describe the link capabilities and state.
+ *
+ * 	MEDIA_LNK_FL_ENABLED indicates that the link is enabled and can be used
+ * 	to transfer media data. When two or more links target a sink pad, only
+ * 	one of them can be enabled at a time.
+ * 	MEDIA_LNK_FL_IMMUTABLE indicates that the link enabled state can't be
+ * 	modified at runtime. If MEDIA_LNK_FL_IMMUTABLE is set, then
+ * 	MEDIA_LNK_FL_ENABLED must also be set since an immutable link is always
+ * 	enabled.
+ *
+ *
+ * Graph traversal
+ * ---------------
+ *
+ * The media framework provides APIs to iterate over entities in a graph.
+ *
+ * To iterate over all entities belonging to a media device, drivers can use the
+ * media_device_for_each_entity macro, defined in include/media/media-device.h.
+ *
+ * 	struct media_entity *entity;
+ *
+ * 	media_device_for_each_entity(entity, mdev) {
+ * 		// entity will point to each entity in turn
+ * 		...
+ * 	}
+ *
+ * Drivers might also need to iterate over all entities in a graph that can be
+ * reached only through enabled links starting at a given entity. The media
+ * framework provides a depth-first graph traversal API for that purpose.
+ *
+ * Note that graphs with cycles (whether directed or undirected) are *NOT*
+ * supported by the graph traversal API. To prevent infinite loops, the graph
+ * traversal code limits the maximum depth to MEDIA_ENTITY_ENUM_MAX_DEPTH,
+ * currently defined as 16.
+ *
+ * Drivers initiate a graph traversal by calling
+ *
+ * 	media_entity_graph_walk_start(struct media_entity_graph *graph,
+ * 				      struct media_entity *entity);
+ *
+ * The graph structure, provided by the caller, is initialized to start graph
+ * traversal at the given entity.
+ *
+ * Drivers can then retrieve the next entity by calling
+ *
+ * 	media_entity_graph_walk_next(struct media_entity_graph *graph);
+ *
+ * When the graph traversal is complete the function will return NULL.
+ *
+ * Graph traversal can be interrupted at any moment. No cleanup function call is
+ * required and the graph structure can be freed normally.
+ *
+ * Helper functions can be used to find a link between two given pads, or a pad
+ * connected to another pad through an enabled link
+ *
+ * 	media_entity_find_link(struct media_pad *source,
+ * 			       struct media_pad *sink);
+ *
+ * 	media_entity_remote_pad(struct media_pad *pad);
+ *
+ * Refer to the kerneldoc documentation for more information.
+ *
+ *
+ * Use count and power handling
+ * ----------------------------
+ *
+ * Due to the wide differences between drivers regarding power management needs,
+ * the media controller does not implement power management. However, the
+ * media_entity structure includes a use_count field that media drivers can use to
+ * track the number of users of every entity for power management needs.
+ *
+ * The use_count field is owned by media drivers and must not be touched by entity
+ * drivers. Access to the field must be protected by the media device graph_mutex
+ * lock.
+ *
+ *
+ * Links setup
+ * -----------
+ *
+ * Link properties can be modified at runtime by calling
+ *
+ * 	media_entity_setup_link(struct media_link *link, u32 flags);
+ *
+ * The flags argument contains the requested new link flags.
+ *
+ * The only configurable property is the ENABLED link flag to enable/disable a
+ * link. Links marked with the IMMUTABLE link flag can not be enabled or disabled.
+ *
+ * When a link is enabled or disabled, the media framework calls the
+ * link_setup operation for the two entities at the source and sink of the link,
+ * in that order. If the second link_setup call fails, another link_setup call is
+ * made on the first entity to restore the original link flags.
+ *
+ * Media device drivers can be notified of link setup operations by setting the
+ * media_device::link_notify pointer to a callback function. If provided, the
+ * notification callback will be called before enabling and after disabling
+ * links.
+ *
+ * Entity drivers must implement the link_setup operation if any of their links
+ * is non-immutable. The operation must either configure the hardware or store
+ * the configuration information to be applied later.
+ *
+ * Link configuration must not have any side effect on other links. If an enabled
+ * link at a sink pad prevents another link at the same pad from being enabled,
+ * the link_setup operation must return -EBUSY and can't implicitly disable the
+ * first enabled link.
+ *
+ *
+ * Pipelines and media streams
+ * ---------------------------
+ *
+ * When starting streaming, drivers must notify all entities in the pipeline to
+ * prevent link states from being modified during streaming by calling
+ *
+ * 	media_entity_pipeline_start(struct media_entity *entity,
+ * 				    struct media_pipeline *pipe);
+ *
+ * The function will mark all entities connected to the given entity through
+ * enabled links, either directly or indirectly, as streaming.
+ *
+ * The media_pipeline instance pointed to by the pipe argument will be stored in
+ * every entity in the pipeline. Drivers should embed the media_pipeline structure
+ * in higher-level pipeline structures and can then access the pipeline through
+ * the media_entity pipe field.
+ *
+ * Calls to media_entity_pipeline_start() can be nested. The pipeline pointer must
+ * be identical for all nested calls to the function.
+ *
+ * media_entity_pipeline_start() may return an error. In that case, it will
+ * clean up any of the changes it did by itself.
+ *
+ * When stopping the stream, drivers must notify the entities with
+ *
+ * 	media_entity_pipeline_stop(struct media_entity *entity);
+ *
+ * If multiple calls to media_entity_pipeline_start() have been made the same
+ * number of media_entity_pipeline_stop() calls are required to stop streaming. The
+ * media_entity pipe field is reset to NULL on the last nested stop call.
+ *
+ * Link configuration will fail with -EBUSY by default if either end of the link is
+ * a streaming entity. Links that can be modified while streaming must be marked
+ * with the MEDIA_LNK_FL_DYNAMIC flag.
+ *
+ * If other operations need to be disallowed on streaming entities (such as
+ * changing entities configuration parameters) drivers can explicitly check the
+ * media_entity stream_count field to find out if an entity is streaming. This
+ * operation must be done with the media_device graph_mutex held.
+ *
+ *
+ * Link validation
+ * ---------------
+ *
+ * Link validation is performed by media_entity_pipeline_start() for any
+ * entity which has sink pads in the pipeline. The
+ * media_entity::link_validate() callback is used for that purpose. In
+ * link_validate() callback, entity driver should check that the properties of
+ * the source pad of the connected entity and its own sink pad match. It is up
+ * to the type of the entity (and in the end, the properties of the hardware)
+ * what matching actually means.
+ *
+ * Subsystems should facilitate link validation by providing subsystem specific
+ * helper functions to provide easy access for commonly needed information, and
+ * in the end provide a way to use driver-specific callbacks.
+ */
+
 struct device;
 
 /**

commit a08fad1ec80c69c79b3ffb6d84968b0952d32da1
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Wed Dec 9 19:47:35 2015 -0200

    [media] media-entity: protect object creation/removal using spin lock
    
    Some parts of the media controller are using mutexes while
    others are using spin locks in order to protect creation
    and removal of elements in the graph. That's wrong!
    
    Also, the V4L2 core can remove graph elements on non-interactive
    context:
            BUG: sleeping function called from invalid context at include/linux/sched.h:2776
    
    Fix it by always using spin locks for graph element addition/removal,
    just like entity creation/removal is protected at media-device.c
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 1b12774a9ab4..87ff299e1265 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -88,7 +88,7 @@ struct media_device {
 	struct list_head pads;
 	struct list_head links;
 
-	/* Protects the entities list */
+	/* Protects the graph objects creation/removal */
 	spinlock_t lock;
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;

commit 2521fdac28d0ceea659be1620fef96b1cbff09b6
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Aug 23 09:40:26 2015 -0300

    [media] media_device: add a topology version field
    
    Every time a graph object is added or removed, the version
    of the topology changes. That's a requirement for the new
    MEDIA_IOC_G_TOPOLOGY, in order to allow userspace to know
    that the topology has changed after a previous call to it.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 0d1b9c687454..1b12774a9ab4 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -41,6 +41,8 @@ struct device;
  * @bus_info:	Unique and stable device location identifier
  * @hw_revision: Hardware device revision
  * @driver_version: Device driver version
+ * @topology_version: Monotonic counter for storing the version of the graph
+ *		topology. Should be incremented each time the topology changes.
  * @entity_id:	Unique ID used on the last entity registered
  * @pad_id:	Unique ID used on the last pad registered
  * @link_id:	Unique ID used on the last link registered
@@ -74,6 +76,8 @@ struct media_device {
 	u32 hw_revision;
 	u32 driver_version;
 
+	u32 topology_version;
+
 	u32 entity_id;
 	u32 pad_id;
 	u32 link_id;

commit 9155d859b6bec29cdbbd80a509be35de55115f00
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Aug 23 08:00:33 2015 -0300

    [media] media-device: add pads and links to media_device
    
    The MC next gen API sends objects to userspace grouped by
    their types.
    
    In the case of pads and links, in order to improve performance
    and have a simpler code, the best is to store them also on
    separate linked lists at MC.
    
    If we don't do that, we would need this kind of interaction
    to send data to userspace (code is in structured english):
    
            for each entity:
                    for each pad:
                            store pads
    
            for each entity:
                    for each link:
                            store link
    
            for each interface:
                    for each link:
                            store link
    
    With would require one nested loop for pads and two nested
    loops for links. By using  separate linked lists for them,
    just one loop would be enough.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 85fa302047bd..0d1b9c687454 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -47,6 +47,8 @@ struct device;
  * @intf_devnode_id: Unique ID used on the last interface devnode registered
  * @entities:	List of registered entities
  * @interfaces:	List of registered interfaces
+ * @pads:	List of registered pads
+ * @links:	List of registered links
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
  * @link_notify: Link state change notification callback
@@ -79,6 +81,8 @@ struct media_device {
 
 	struct list_head entities;
 	struct list_head interfaces;
+	struct list_head pads;
+	struct list_head links;
 
 	/* Protects the entities list */
 	spinlock_t lock;
@@ -117,6 +121,14 @@ struct media_device *media_device_find_devres(struct device *dev);
 #define media_device_for_each_intf(intf, mdev)			\
 	list_for_each_entry(intf, &(mdev)->interfaces, graph_obj.list)
 
+/* Iterate over all pads. */
+#define media_device_for_each_pad(pad, mdev)			\
+	list_for_each_entry(pad, &(mdev)->pads, graph_obj.list)
+
+/* Iterate over all links. */
+#define media_device_for_each_link(link, mdev)			\
+	list_for_each_entry(link, &(mdev)->links, graph_obj.list)
+
 
 #else
 static inline int media_device_register(struct media_device *mdev)

commit 05bfa9fa1cda91953e1b5975b059542b83c5245c
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Aug 23 07:51:33 2015 -0300

    [media] media: move mdev list init to gobj
    
    Let's control the topology changes inside the graph_object. So, move the
    addition and removal of interfaces/entities from the mdev lists to
    media_gobj_init() and media_gobj_remove().
    
    The main reason is that mdev should have lists for all object types, as
    the new MC api will require to store objects in separate places.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index f23d686aaac6..85fa302047bd 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -111,11 +111,11 @@ struct media_device *media_device_find_devres(struct device *dev);
 
 /* Iterate over all entities. */
 #define media_device_for_each_entity(entity, mdev)			\
-	list_for_each_entry(entity, &(mdev)->entities, list)
+	list_for_each_entry(entity, &(mdev)->entities, graph_obj.list)
 
 /* Iterate over all interfaces. */
 #define media_device_for_each_intf(intf, mdev)			\
-	list_for_each_entry(intf, &(mdev)->interfaces, list)
+	list_for_each_entry(intf, &(mdev)->interfaces, graph_obj.list)
 
 
 #else

commit cf975a4b40ec9a947dae614b23128f3984a2d324
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Sun Aug 23 07:51:22 2015 -0300

    [media] media: Use a macro to interate between all interfaces
    
    Just like we do with entities, use a similar macro for the
    interfaces loop.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 51807efa505b..f23d686aaac6 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -113,6 +113,11 @@ struct media_device *media_device_find_devres(struct device *dev);
 #define media_device_for_each_entity(entity, mdev)			\
 	list_for_each_entry(entity, &(mdev)->entities, list)
 
+/* Iterate over all interfaces. */
+#define media_device_for_each_intf(intf, mdev)			\
+	list_for_each_entry(intf, &(mdev)->interfaces, list)
+
+
 #else
 static inline int media_device_register(struct media_device *mdev)
 {

commit 57cf79b79b18d885c144889989b47149e23c8dc2
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Aug 21 09:23:22 2015 -0300

    [media] media: add a linked list to track interfaces by mdev
    
    The media device should list the interface objects, so add a linked list
    for those interfaces in struct media_device.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 3b14394d5701..51807efa505b 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -46,6 +46,7 @@ struct device;
  * @link_id:	Unique ID used on the last link registered
  * @intf_devnode_id: Unique ID used on the last interface devnode registered
  * @entities:	List of registered entities
+ * @interfaces:	List of registered interfaces
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
  * @link_notify: Link state change notification callback
@@ -77,6 +78,7 @@ struct media_device {
 	u32 intf_devnode_id;
 
 	struct list_head entities;
+	struct list_head interfaces;
 
 	/* Protects the entities list */
 	spinlock_t lock;

commit 27e543fa87deea308f0cc5224ab19e397b0a5ded
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Thu Aug 20 09:07:34 2015 -0300

    [media] media: add functions to allow creating interfaces
    
    Interfaces are different than entities: they represent a
    Kernel<->userspace interaction, while entities represent a
    piece of hardware/firmware/software that executes a function.
    
    Let's distinguish them by creating a separate structure to
    store the interfaces.
    
    Later patches should change the existing drivers and logic
    to split the current interface embedded inside the entity
    structure (device nodes) into a separate object of the graph.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 05414e351f8e..3b14394d5701 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -44,6 +44,7 @@ struct device;
  * @entity_id:	Unique ID used on the last entity registered
  * @pad_id:	Unique ID used on the last pad registered
  * @link_id:	Unique ID used on the last link registered
+ * @intf_devnode_id: Unique ID used on the last interface devnode registered
  * @entities:	List of registered entities
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
@@ -73,6 +74,7 @@ struct media_device {
 	u32 entity_id;
 	u32 pad_id;
 	u32 link_id;
+	u32 intf_devnode_id;
 
 	struct list_head entities;
 

commit 6b6a42780597028135f82c96e42c6d2bcd83fbae
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Aug 14 12:54:36 2015 -0300

    [media] media: use media_gobj inside links
    
    Just like entities and pads, links also need to have unique
    Object IDs along a given media controller.
    
    So, let's add a media_gobj inside it and initialize
    the object then a new link is created.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 9493721f630e..05414e351f8e 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -43,6 +43,7 @@ struct device;
  * @driver_version: Device driver version
  * @entity_id:	Unique ID used on the last entity registered
  * @pad_id:	Unique ID used on the last pad registered
+ * @link_id:	Unique ID used on the last link registered
  * @entities:	List of registered entities
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
@@ -71,6 +72,7 @@ struct media_device {
 
 	u32 entity_id;
 	u32 pad_id;
+	u32 link_id;
 
 	struct list_head entities;
 

commit 18710dc67a433ed2c3ecaaffefd8e34502e53262
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Aug 14 12:50:08 2015 -0300

    [media] media: use media_gobj inside pads
    
    PADs also need unique object IDs that won't conflict with
    the entity object IDs.
    
    The pad objects are currently created via media_entity_init()
    and, once created, never change.
    
    While this will likely change in the future in order to
    support dynamic changes, for now we'll keep PADs as arrays
    and initialize the media_gobj embedded structs when
    registering the entity.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index f6deef6e5820..9493721f630e 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -42,6 +42,7 @@ struct device;
  * @hw_revision: Hardware device revision
  * @driver_version: Device driver version
  * @entity_id:	Unique ID used on the last entity registered
+ * @pad_id:	Unique ID used on the last pad registered
  * @entities:	List of registered entities
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
@@ -69,6 +70,7 @@ struct media_device {
 	u32 driver_version;
 
 	u32 entity_id;
+	u32 pad_id;
 
 	struct list_head entities;
 

commit bfab2aacccfc144e2cceccb71ec89f1eff1b8c51
Author: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
Date:   Fri Aug 14 12:47:48 2015 -0300

    [media] media: use media_gobj inside entities
    
    As entities are graph objects, let's embed media_gobj
    on it. That ensures an unique ID for entities that can be
    global along the entire media controller.
    
    For now, we'll keep the already existing entity ID. Such
    field need to be dropped at some point, but for now, let's
    not do this, to avoid needing to review all drivers and
    the userspace apps.
    
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index a44f18fdf321..f6deef6e5820 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -41,7 +41,7 @@ struct device;
  * @bus_info:	Unique and stable device location identifier
  * @hw_revision: Hardware device revision
  * @driver_version: Device driver version
- * @entity_id:	ID of the next entity to be registered
+ * @entity_id:	Unique ID used on the last entity registered
  * @entities:	List of registered entities
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
@@ -69,6 +69,7 @@ struct media_device {
 	u32 driver_version;
 
 	u32 entity_id;
+
 	struct list_head entities;
 
 	/* Protects the entities list */

commit e576d60bb21e7add884f052ff0e5c28ebf7b7461
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Fri Jun 5 17:11:54 2015 -0300

    [media] media: define Media Controller API when CONFIG_MEDIA_CONTROLLER enabled
    
    Change to define Media Controller API when CONFIG_MEDIA_CONTROLLER
    is enabled. Define stubs for CONFIG_MEDIA_CONTROLLER disabled case.
    This will help avoid drivers needing to enclose Media Controller
    code within ifdef CONFIG_MEDIA_CONTROLLER block.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 22792cd5b1d1..a44f18fdf321 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -80,6 +80,8 @@ struct media_device {
 			   unsigned int notification);
 };
 
+#ifdef CONFIG_MEDIA_CONTROLLER
+
 /* Supported link_notify @notification values. */
 #define MEDIA_DEV_NOTIFY_PRE_LINK_CH	0
 #define MEDIA_DEV_NOTIFY_POST_LINK_CH	1
@@ -102,4 +104,29 @@ struct media_device *media_device_find_devres(struct device *dev);
 #define media_device_for_each_entity(entity, mdev)			\
 	list_for_each_entry(entity, &(mdev)->entities, list)
 
+#else
+static inline int media_device_register(struct media_device *mdev)
+{
+	return 0;
+}
+static inline void media_device_unregister(struct media_device *mdev)
+{
+}
+static inline int media_device_register_entity(struct media_device *mdev,
+						struct media_entity *entity)
+{
+	return 0;
+}
+static inline void media_device_unregister_entity(struct media_entity *entity)
+{
+}
+static inline struct media_device *media_device_get_devres(struct device *dev)
+{
+	return NULL;
+}
+static inline struct media_device *media_device_find_devres(struct device *dev)
+{
+	return NULL;
+}
+#endif /* CONFIG_MEDIA_CONTROLLER */
 #endif

commit d062f91193dbd5a0c1d8469c8517ec8dd552c3f2
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Wed Jun 3 12:12:53 2015 -0300

    [media] media: new media controller API for device resource support
    
    Add new media controller API to allocate media device as a
    device resource. When a media device is created on the main
    struct device which is the parent device for the interface
    device, it will be available to all drivers associated with
    that interface. For example, if a usb media device driver
    creates the media device on the main struct device which is
    common for all the drivers that control the media device,
    including the non-media ALSA driver, media controller API
    can be used to share access to the resources on the media
    device. This new interface provides the above described
    feature. A second interface that finds and returns the media
    device is added to allow drivers to find the media device
    created by any of the drivers associated with the device.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 6e6db78f1ee2..22792cd5b1d1 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -95,6 +95,8 @@ void media_device_unregister(struct media_device *mdev);
 int __must_check media_device_register_entity(struct media_device *mdev,
 					      struct media_entity *entity);
 void media_device_unregister_entity(struct media_entity *entity);
+struct media_device *media_device_get_devres(struct device *dev);
+struct media_device *media_device_find_devres(struct device *dev);
 
 /* Iterate over all entities. */
 #define media_device_for_each_entity(entity, mdev)			\

commit 85de721c46ba8ad9b283b2b3e307c9a3e8425042
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Thu Dec 12 12:38:17 2013 -0300

    [media] media: Use a better owner for the media device
    
    mdev->fops->owner is actually the owner of the very same module which
    implements media_device_register(), so it can't be unloaded anyway. Instead,
    use THIS_MODULE through a macro as does video_register_device().
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 12155a9596c4..6e6db78f1ee2 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -87,7 +87,9 @@ struct media_device {
 /* media_devnode to media_device */
 #define to_media_device(node) container_of(node, struct media_device, devnode)
 
-int __must_check media_device_register(struct media_device *mdev);
+int __must_check __media_device_register(struct media_device *mdev,
+					 struct module *owner);
+#define media_device_register(mdev) __media_device_register(mdev, THIS_MODULE)
 void media_device_unregister(struct media_device *mdev);
 
 int __must_check media_device_register_entity(struct media_device *mdev,

commit 813f5c0ac5ccf7dd9c216a8f7fbe827ca36cb83f
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Fri May 31 10:37:26 2013 -0300

    [media] media: Change media device link_notify behaviour
    
    Currently the media device link_notify callback is invoked before the
    actual change of state of a link when the link is being enabled, and
    after the actual change of state when the link is being disabled.
    This doesn't allow a media device driver to perform any operations
    on a full graph before a link is disabled, as well as performing
    any tasks on a modified graph right after a link's state is changed.
    This patch modifies signature of the link_notify callback. This
    callback is now called always before and after a link's state change.
    To distinguish the notifications a 'notification' argument is added
    to the link_notify callback: MEDIA_DEV_NOTIFY_PRE_LINK_CH indicates
    notification before link's state change and
    MEDIA_DEV_NOTIFY_POST_LINK_CH corresponds to a notification after
    link flags change.
    
    [mchehab@redhat.com: whitespace cleanups]
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Sakari Ailus <sakari.ailus@iki.fi>
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index eaade9815bb6..12155a9596c4 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -45,6 +45,7 @@ struct device;
  * @entities:	List of registered entities
  * @lock:	Entities list lock
  * @graph_mutex: Entities graph operation lock
+ * @link_notify: Link state change notification callback
  *
  * This structure represents an abstract high-level media device. It allows easy
  * access to entities and provides basic media device-level support. The
@@ -75,10 +76,14 @@ struct media_device {
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;
 
-	int (*link_notify)(struct media_pad *source,
-			   struct media_pad *sink, u32 flags);
+	int (*link_notify)(struct media_link *link, u32 flags,
+			   unsigned int notification);
 };
 
+/* Supported link_notify @notification values. */
+#define MEDIA_DEV_NOTIFY_PRE_LINK_CH	0
+#define MEDIA_DEV_NOTIFY_POST_LINK_CH	1
+
 /* media_devnode to media_device */
 #define to_media_device(node) container_of(node, struct media_device, devnode)
 

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 6a27d916c250..eaade9815bb6 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -23,7 +23,6 @@
 #ifndef _MEDIA_DEVICE_H
 #define _MEDIA_DEVICE_H
 
-#include <linux/device.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include <linux/spinlock.h>
@@ -31,6 +30,8 @@
 #include <media/media-devnode.h>
 #include <media/media-entity.h>
 
+struct device;
+
 /**
  * struct media_device - Media device
  * @dev:	Parent device

commit 97548ed4c4661502cdfd1aabd5d3876fa4f5cc2e
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Dec 9 08:40:03 2009 -0300

    [media] media: Links setup
    
    Create the following ioctl and implement it at the media device level to
    setup links.
    
    - MEDIA_IOC_SETUP_LINK: Modify the properties of a given link
    
    The only property that can currently be modified is the ENABLED link
    flag to enable/disable a link. Links marked with the IMMUTABLE link flag
    can not be enabled or disabled.
    
    Enabling or disabling a link has effects on entities' use count. Those
    changes are automatically propagated through the graph.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Stanimir Varbanov <svarbanov@mm-sol.com>
    Signed-off-by: Sakari Ailus <sakari.ailus@iki.fi>
    Acked-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 5d2bff4fc9e0..6a27d916c250 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -73,6 +73,9 @@ struct media_device {
 	spinlock_t lock;
 	/* Serializes graph operations. */
 	struct mutex graph_mutex;
+
+	int (*link_notify)(struct media_pad *source,
+			   struct media_pad *sink, u32 flags);
 };
 
 /* media_devnode to media_device */

commit 503c3d829eaf48837dd5bff5d97ad66369bb955a
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Mar 7 15:04:59 2010 -0300

    [media] media: Entity use count
    
    Due to the wide differences between drivers regarding power management
    needs, the media controller does not implement power management.
    However, the media_entity structure includes a use_count field that
    media drivers can use to track the number of users of every entity for
    power management needs.
    
    The use_count field is owned by media drivers and must not be touched by
    entity drivers. Access to the field must be protected by the media
    device graph_mutex lock.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index a8390fe87e83..5d2bff4fc9e0 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -25,6 +25,7 @@
 
 #include <linux/device.h>
 #include <linux/list.h>
+#include <linux/mutex.h>
 #include <linux/spinlock.h>
 
 #include <media/media-devnode.h>
@@ -42,6 +43,7 @@
  * @entity_id:	ID of the next entity to be registered
  * @entities:	List of registered entities
  * @lock:	Entities list lock
+ * @graph_mutex: Entities graph operation lock
  *
  * This structure represents an abstract high-level media device. It allows easy
  * access to entities and provides basic media device-level support. The
@@ -69,6 +71,8 @@ struct media_device {
 
 	/* Protects the entities list */
 	spinlock_t lock;
+	/* Serializes graph operations. */
+	struct mutex graph_mutex;
 };
 
 /* media_devnode to media_device */

commit 53e269c102fbaf77e7dc526b1606ad4a48e57200
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Dec 9 08:40:00 2009 -0300

    [media] media: Entities, pads and links
    
    As video hardware pipelines become increasingly complex and
    configurable, the current hardware description through v4l2 subdevices
    reaches its limits. In addition to enumerating and configuring
    subdevices, video camera drivers need a way to discover and modify at
    runtime how those subdevices are connected. This is done through new
    elements called entities, pads and links.
    
    An entity is a basic media hardware building block. It can correspond to
    a large variety of logical blocks such as physical hardware devices
    (CMOS sensor for instance), logical hardware devices (a building block
    in a System-on-Chip image processing pipeline), DMA channels or physical
    connectors.
    
    A pad is a connection endpoint through which an entity can interact with
    other entities. Data (not restricted to video) produced by an entity
    flows from the entity's output to one or more entity inputs. Pads should
    not be confused with physical pins at chip boundaries.
    
    A link is a point-to-point oriented connection between two pads, either
    on the same entity or on different entities. Data flows from a source
    pad to a sink pad.
    
    Links are stored in the source entity. To make backwards graph walk
    faster, a copy of all links is also stored in the sink entity. The copy
    is known as a backlink and is only used to help graph traversal.
    
    The entity API is made of three functions:
    
    - media_entity_init() initializes an entity. The caller must provide an
    array of pads as well as an estimated number of links. The links array
    is allocated dynamically and will be reallocated if it grows beyond the
    initial estimate.
    
    - media_entity_cleanup() frees resources allocated for an entity. It
    must be called during the cleanup phase after unregistering the entity
    and before freeing it.
    
    - media_entity_create_link() creates a link between two entities. An
    entry in the link array of each entity is allocated and stores pointers
    to source and sink pads.
    
    When a media device is unregistered, all its entities are unregistered
    automatically.
    
    The code is based on Hans Verkuil <hverkuil@xs4all.nl> initial work.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Sakari Ailus <sakari.ailus@iki.fi>
    Acked-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
index 30857f7fc22b..a8390fe87e83 100644
--- a/include/media/media-device.h
+++ b/include/media/media-device.h
@@ -25,8 +25,10 @@
 
 #include <linux/device.h>
 #include <linux/list.h>
+#include <linux/spinlock.h>
 
 #include <media/media-devnode.h>
+#include <media/media-entity.h>
 
 /**
  * struct media_device - Media device
@@ -37,6 +39,9 @@
  * @bus_info:	Unique and stable device location identifier
  * @hw_revision: Hardware device revision
  * @driver_version: Device driver version
+ * @entity_id:	ID of the next entity to be registered
+ * @entities:	List of registered entities
+ * @lock:	Entities list lock
  *
  * This structure represents an abstract high-level media device. It allows easy
  * access to entities and provides basic media device-level support. The
@@ -58,6 +63,12 @@ struct media_device {
 	char bus_info[32];
 	u32 hw_revision;
 	u32 driver_version;
+
+	u32 entity_id;
+	struct list_head entities;
+
+	/* Protects the entities list */
+	spinlock_t lock;
 };
 
 /* media_devnode to media_device */
@@ -66,4 +77,12 @@ struct media_device {
 int __must_check media_device_register(struct media_device *mdev);
 void media_device_unregister(struct media_device *mdev);
 
+int __must_check media_device_register_entity(struct media_device *mdev,
+					      struct media_entity *entity);
+void media_device_unregister_entity(struct media_entity *entity);
+
+/* Iterate over all entities. */
+#define media_device_for_each_entity(entity, mdev)			\
+	list_for_each_entry(entity, &(mdev)->entities, list)
+
 #endif

commit 176fb0d108f7495ccf9aa127e1342a1a0d87e004
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Dec 9 08:39:58 2009 -0300

    [media] media: Media device
    
    The media_device structure abstracts functions common to all kind of
    media devices (v4l2, dvb, alsa, ...). It manages media entities and
    offers a userspace API to discover and configure the media device
    internal topology.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Hans Verkuil <hverkuil@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/media/media-device.h b/include/media/media-device.h
new file mode 100644
index 000000000000..30857f7fc22b
--- /dev/null
+++ b/include/media/media-device.h
@@ -0,0 +1,69 @@
+/*
+ * Media device
+ *
+ * Copyright (C) 2010 Nokia Corporation
+ *
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *	     Sakari Ailus <sakari.ailus@iki.fi>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _MEDIA_DEVICE_H
+#define _MEDIA_DEVICE_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+
+#include <media/media-devnode.h>
+
+/**
+ * struct media_device - Media device
+ * @dev:	Parent device
+ * @devnode:	Media device node
+ * @model:	Device model name
+ * @serial:	Device serial number (optional)
+ * @bus_info:	Unique and stable device location identifier
+ * @hw_revision: Hardware device revision
+ * @driver_version: Device driver version
+ *
+ * This structure represents an abstract high-level media device. It allows easy
+ * access to entities and provides basic media device-level support. The
+ * structure can be allocated directly or embedded in a larger structure.
+ *
+ * The parent @dev is a physical device. It must be set before registering the
+ * media device.
+ *
+ * @model is a descriptive model name exported through sysfs. It doesn't have to
+ * be unique.
+ */
+struct media_device {
+	/* dev->driver_data points to this struct. */
+	struct device *dev;
+	struct media_devnode devnode;
+
+	char model[32];
+	char serial[40];
+	char bus_info[32];
+	u32 hw_revision;
+	u32 driver_version;
+};
+
+/* media_devnode to media_device */
+#define to_media_device(node) container_of(node, struct media_device, devnode)
+
+int __must_check media_device_register(struct media_device *mdev);
+void media_device_unregister(struct media_device *mdev);
+
+#endif
