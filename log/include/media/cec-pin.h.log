commit e5ad7db4b2f35aaed796669b47e24c6d79cab3d0
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Tue Apr 21 11:23:41 2020 +0200

    media: cec-gpio: handle gpiod_get_value errors correctly
    
    gpiod_get_value() can return negative values if an error occurs.
    In several places this error code was ignored.
    
    Ensure that errors codes are handled correctly throughout the CEC
    pin framework and CEC pin drivers.
    
    The return code of the cec_pin_ops read() callback had to be changed
    from 'bool' to 'int', which mean the prototype of that callback in the
    sun4i drm driver also had to be changed.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index 88c8b016eb09..483bc4769fe9 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -13,7 +13,8 @@
 
 /**
  * struct cec_pin_ops - low-level CEC pin operations
- * @read:	read the CEC pin. Return true if high, false if low.
+ * @read:	read the CEC pin. Returns > 0 if high, 0 if low, or an error
+ *		if negative.
  * @low:	drive the CEC pin low.
  * @high:	stop driving the CEC pin. The pull-up will drive the pin
  *		high, unless someone else is driving the pin low.
@@ -22,13 +23,10 @@
  * @free:	optional. Free any allocated resources. Called when the
  *		adapter is deleted.
  * @status:	optional, log status information.
- * @read_hpd:	read the HPD pin. Return true if high, false if low or
- *		an error if negative. If NULL or -ENOTTY is returned,
- *		then this is not supported.
- * @read_5v:	read the 5V pin. Return true if high, false if low or
- *		an error if negative. If NULL or -ENOTTY is returned,
- *		then this is not supported.
- *
+ * @read_hpd:	optional. Read the HPD pin. Returns > 0 if high, 0 if low or
+ *		an error if negative.
+ * @read_5v:	optional. Read the 5V pin. Returns > 0 if high, 0 if low or
+ *		an error if negative.
  * @received:	optional. High-level CEC message callback. Allows the driver
  *		to process CEC messages.
  *
@@ -36,7 +34,7 @@
  * cec pin framework to manipulate the CEC pin.
  */
 struct cec_pin_ops {
-	bool (*read)(struct cec_adapter *adap);
+	int  (*read)(struct cec_adapter *adap);
 	void (*low)(struct cec_adapter *adap);
 	void (*high)(struct cec_adapter *adap);
 	bool (*enable_irq)(struct cec_adapter *adap);

commit 69e3235d58260d3d03570271da314829f9486237
Author: Hans Verkuil <hverkuil-cisco@xs4all.nl>
Date:   Wed Oct 9 11:49:19 2019 -0300

    media: cec-pin: add 'received' callback
    
    Drivers that use the CEC pin framework have no way of processing messages
    themselves by providing the 'received' callback. This is present in
    cec_ops, but not in cec_pin_ops.
    
    Add support for this callback.
    
    Signed-off-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index 604e79cb6cbf..88c8b016eb09 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -29,8 +29,11 @@
  *		an error if negative. If NULL or -ENOTTY is returned,
  *		then this is not supported.
  *
- * These operations are used by the cec pin framework to manipulate
- * the CEC pin.
+ * @received:	optional. High-level CEC message callback. Allows the driver
+ *		to process CEC messages.
+ *
+ * These operations (except for the @received op) are used by the
+ * cec pin framework to manipulate the CEC pin.
  */
 struct cec_pin_ops {
 	bool (*read)(struct cec_adapter *adap);
@@ -42,6 +45,9 @@ struct cec_pin_ops {
 	void (*status)(struct cec_adapter *adap, struct seq_file *file);
 	int  (*read_hpd)(struct cec_adapter *adap);
 	int  (*read_5v)(struct cec_adapter *adap);
+
+	/* High-level CEC message callback */
+	int (*received)(struct cec_adapter *adap, struct cec_msg *msg);
 };
 
 /**

commit 4786b0d6f3ca6da8db02b0a58cd2b785cb0b80ab
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Thu Jun 28 07:43:46 2018 -0400

    media: cec: add support for 5V signal testing
    
    Add support for the new 5V CEC events
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index ed16c6dde0ba..604e79cb6cbf 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -25,6 +25,9 @@
  * @read_hpd:	read the HPD pin. Return true if high, false if low or
  *		an error if negative. If NULL or -ENOTTY is returned,
  *		then this is not supported.
+ * @read_5v:	read the 5V pin. Return true if high, false if low or
+ *		an error if negative. If NULL or -ENOTTY is returned,
+ *		then this is not supported.
  *
  * These operations are used by the cec pin framework to manipulate
  * the CEC pin.
@@ -38,6 +41,7 @@ struct cec_pin_ops {
 	void (*free)(struct cec_adapter *adap);
 	void (*status)(struct cec_adapter *adap, struct seq_file *file);
 	int  (*read_hpd)(struct cec_adapter *adap);
+	int  (*read_5v)(struct cec_adapter *adap);
 };
 
 /**

commit ab15d248cc96d12c928a69d3485a98d223c607ae
Author: Hans Verkuil <hansverk@cisco.com>
Date:   Wed Feb 7 09:05:46 2018 -0500

    media: include/(uapi/)media: add SPDX license info
    
    Replace the old license information with the corresponding SPDX
    license for those headers that I authored.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index 83b3e17e0a07..ed16c6dde0ba 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -1,20 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * cec-pin.h - low-level CEC pin control
  *
  * Copyright 2017 Cisco Systems, Inc. and/or its affiliates. All rights reserved.
- *
- * This program is free software; you may redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
  */
 
 #ifndef LINUX_CEC_PIN_H

commit 5bf24e08b685d862f1249987a6d3423b42989622
Author: Hans Verkuil <hansverk@cisco.com>
Date:   Fri Oct 13 18:01:32 2017 +0200

    media: cec-pin.h: move non-kAPI parts into cec-pin-priv.h
    
    The kAPI cec-pin.h header also defined data structures that did
    not belong here but were private to the CEC core code.
    
    Split that part off into a cec-pin-priv.h header.
    
    Signed-off-by: Hans Verkuil <hansverk@cisco.com>
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index ea84b9c9e0c3..83b3e17e0a07 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -21,71 +21,8 @@
 #define LINUX_CEC_PIN_H
 
 #include <linux/types.h>
-#include <linux/atomic.h>
 #include <media/cec.h>
 
-enum cec_pin_state {
-	/* CEC is off */
-	CEC_ST_OFF,
-	/* CEC is idle, waiting for Rx or Tx */
-	CEC_ST_IDLE,
-
-	/* Tx states */
-
-	/* Pending Tx, waiting for Signal Free Time to expire */
-	CEC_ST_TX_WAIT,
-	/* Low-drive was detected, wait for bus to go high */
-	CEC_ST_TX_WAIT_FOR_HIGH,
-	/* Drive CEC low for the start bit */
-	CEC_ST_TX_START_BIT_LOW,
-	/* Drive CEC high for the start bit */
-	CEC_ST_TX_START_BIT_HIGH,
-	/* Drive CEC low for the 0 bit */
-	CEC_ST_TX_DATA_BIT_0_LOW,
-	/* Drive CEC high for the 0 bit */
-	CEC_ST_TX_DATA_BIT_0_HIGH,
-	/* Drive CEC low for the 1 bit */
-	CEC_ST_TX_DATA_BIT_1_LOW,
-	/* Drive CEC high for the 1 bit */
-	CEC_ST_TX_DATA_BIT_1_HIGH,
-	/*
-	 * Wait for start of sample time to check for Ack bit or first
-	 * four initiator bits to check for Arbitration Lost.
-	 */
-	CEC_ST_TX_DATA_BIT_1_HIGH_PRE_SAMPLE,
-	/* Wait for end of bit period after sampling */
-	CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE,
-
-	/* Rx states */
-
-	/* Start bit low detected */
-	CEC_ST_RX_START_BIT_LOW,
-	/* Start bit high detected */
-	CEC_ST_RX_START_BIT_HIGH,
-	/* Wait for bit sample time */
-	CEC_ST_RX_DATA_SAMPLE,
-	/* Wait for earliest end of bit period after sampling */
-	CEC_ST_RX_DATA_POST_SAMPLE,
-	/* Wait for CEC to go high (i.e. end of bit period */
-	CEC_ST_RX_DATA_HIGH,
-	/* Drive CEC low to send 0 Ack bit */
-	CEC_ST_RX_ACK_LOW,
-	/* End of 0 Ack time, wait for earliest end of bit period */
-	CEC_ST_RX_ACK_LOW_POST,
-	/* Wait for CEC to go high (i.e. end of bit period */
-	CEC_ST_RX_ACK_HIGH_POST,
-	/* Wait for earliest end of bit period and end of message */
-	CEC_ST_RX_ACK_FINISH,
-
-	/* Start low drive */
-	CEC_ST_LOW_DRIVE,
-	/* Monitor pin using interrupts */
-	CEC_ST_RX_IRQ,
-
-	/* Total number of pin states */
-	CEC_PIN_STATES
-};
-
 /**
  * struct cec_pin_ops - low-level CEC pin operations
  * @read:	read the CEC pin. Return true if high, false if low.
@@ -115,50 +52,6 @@ struct cec_pin_ops {
 	int  (*read_hpd)(struct cec_adapter *adap);
 };
 
-#define CEC_NUM_PIN_EVENTS 128
-
-#define CEC_PIN_IRQ_UNCHANGED	0
-#define CEC_PIN_IRQ_DISABLE	1
-#define CEC_PIN_IRQ_ENABLE	2
-
-struct cec_pin {
-	struct cec_adapter		*adap;
-	const struct cec_pin_ops	*ops;
-	struct task_struct		*kthread;
-	wait_queue_head_t		kthread_waitq;
-	struct hrtimer			timer;
-	ktime_t				ts;
-	unsigned int			wait_usecs;
-	u16				la_mask;
-	bool				enabled;
-	bool				monitor_all;
-	bool				rx_eom;
-	bool				enable_irq_failed;
-	enum cec_pin_state		state;
-	struct cec_msg			tx_msg;
-	u32				tx_bit;
-	bool				tx_nacked;
-	u32				tx_signal_free_time;
-	struct cec_msg			rx_msg;
-	u32				rx_bit;
-
-	struct cec_msg			work_rx_msg;
-	u8				work_tx_status;
-	ktime_t				work_tx_ts;
-	atomic_t			work_irq_change;
-	atomic_t			work_pin_events;
-	unsigned int			work_pin_events_wr;
-	unsigned int			work_pin_events_rd;
-	ktime_t				work_pin_ts[CEC_NUM_PIN_EVENTS];
-	bool				work_pin_is_high[CEC_NUM_PIN_EVENTS];
-	ktime_t				timer_ts;
-	u32				timer_cnt;
-	u32				timer_100ms_overruns;
-	u32				timer_300ms_overruns;
-	u32				timer_max_overrun;
-	u32				timer_sum_overrun;
-};
-
 /**
  * cec_pin_changed() - update pin state from interrupt
  *

commit 333ef6bd10c3ffdaf6da94e34dc6cae675ed27fc
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Aug 15 10:07:25 2017 -0400

    media: cec: add CEC_EVENT_PIN_HPD_LOW/HIGH events
    
    Add support for two new low-level events: PIN_HPD_LOW and PIN_HPD_HIGH.
    
    This is specifically meant for use with the upcoming cec-gpio driver
    and makes it possible to trace when the HPD pin changes. Some HDMI
    sinks do strange things with the HPD and this makes it easy to debug
    this.
    
    Note that this also moves the initialization of a devnode mutex and
    list to the allocate_adapter function: if the HPD is high, then as
    soon as the HPD interrupt is created an interrupt occurs and
    cec_queue_pin_hpd_event() is called which requires that the devnode
    mutex and list are initialized.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index f09cc9579d53..ea84b9c9e0c3 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -97,6 +97,9 @@ enum cec_pin_state {
  * @free:	optional. Free any allocated resources. Called when the
  *		adapter is deleted.
  * @status:	optional, log status information.
+ * @read_hpd:	read the HPD pin. Return true if high, false if low or
+ *		an error if negative. If NULL or -ENOTTY is returned,
+ *		then this is not supported.
  *
  * These operations are used by the cec pin framework to manipulate
  * the CEC pin.
@@ -109,6 +112,7 @@ struct cec_pin_ops {
 	void (*disable_irq)(struct cec_adapter *adap);
 	void (*free)(struct cec_adapter *adap);
 	void (*status)(struct cec_adapter *adap, struct seq_file *file);
+	int  (*read_hpd)(struct cec_adapter *adap);
 };
 
 #define CEC_NUM_PIN_EVENTS 128

commit 28e11b15b6606c3308f87f7c9c4c9e404eddde6d
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Sun Aug 20 06:53:10 2017 -0400

    media: cec: replace pin->cur_value by adap->cec_pin_is_high
    
    The current CEC pin value (0 or 1) was part of the cec_pin struct,
    but that assumes that CEC pin monitoring can only be used with
    a driver that uses the low-level CEC pin framework.
    
    But hardware that has both a high-level API and can monitor the
    CEC pin at low-level at the same time does not need to depend on
    the cec pin framework.
    
    To support such devices remove the cur_value field from struct cec_pin
    and add a cec_pin_is_high field to cec_adapter. This also makes it
    possible to drop the '#ifdef CONFIG_CEC_PIN' in cec-api.c.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index d28d07fa312e..f09cc9579d53 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -128,7 +128,6 @@ struct cec_pin {
 	u16				la_mask;
 	bool				enabled;
 	bool				monitor_all;
-	bool				cur_value;
 	bool				rx_eom;
 	bool				enable_irq_failed;
 	enum cec_pin_state		state;

commit cb7474949371ba8d7591a62924f05b627a2601d9
Author: Hans Verkuil <hverkuil@xs4all.nl>
Date:   Wed Aug 16 03:13:02 2017 -0400

    media: cec-pin: fix irq handling
    
    The free_irq() function could be called from interrupt context,
    which is invalid. Move this to the thread.
    
    In the interrupt handler we just request that the thread disables
    the irq. This is done through an atomic so we don't need to add
    any spinlocks.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
index 44b82d29d480..d28d07fa312e 100644
--- a/include/media/cec-pin.h
+++ b/include/media/cec-pin.h
@@ -113,6 +113,10 @@ struct cec_pin_ops {
 
 #define CEC_NUM_PIN_EVENTS 128
 
+#define CEC_PIN_IRQ_UNCHANGED	0
+#define CEC_PIN_IRQ_DISABLE	1
+#define CEC_PIN_IRQ_ENABLE	2
+
 struct cec_pin {
 	struct cec_adapter		*adap;
 	const struct cec_pin_ops	*ops;
@@ -137,8 +141,8 @@ struct cec_pin {
 
 	struct cec_msg			work_rx_msg;
 	u8				work_tx_status;
-	bool				work_enable_irq;
 	ktime_t				work_tx_ts;
+	atomic_t			work_irq_change;
 	atomic_t			work_pin_events;
 	unsigned int			work_pin_events_wr;
 	unsigned int			work_pin_events_rd;

commit ea5c8ef296681b53480ebeeffd06083bb60e693d
Author: Hans Verkuil <hans.verkuil@cisco.com>
Date:   Tue Jul 11 03:30:42 2017 -0300

    media: cec-pin: add low-level pin hardware support
    
    Add support for CEC hardware that relies on low-level pin polling or
    GPIO interrupts.
    
    One example is the Allwinner SoC. But any GPIO-based CEC implementation can
    use this as well.
    
    A GPIO implementation is very suitable as well for debugging: it can use
    interrupts to detect state changes and report it. Userspace can then verify
    if the bus traffic is correct. This also makes error injection possible.
    
    The disadvantage is that it is hard to get the timings right since linux
    isn't a hard realtime system.
    
    In general on an idle system it works quite well, but under load the timer
    will miss its mark every so often.
    
    The debugfs file /sys/kernel/debug/cec/cecX/status gives some statistics
    with respect to the timer overruns.
    
    When the adapter is unconfigured and the low-level driver supports
    interrupts, then the interrupt will be used to detect changes. This should
    be quite accurate. But when the adapter is configured a hrtimer has to be
    used.
    
    The hrtimer implements a state machine where for each state the code will
    read the bus or drive the bus and go on to the next state. It will re-arm
    the timer with a delay based on the next state.
    
    Signed-off-by: Hans Verkuil <hans.verkuil@cisco.com>
    Reviewed-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/media/cec-pin.h b/include/media/cec-pin.h
new file mode 100644
index 000000000000..44b82d29d480
--- /dev/null
+++ b/include/media/cec-pin.h
@@ -0,0 +1,183 @@
+/*
+ * cec-pin.h - low-level CEC pin control
+ *
+ * Copyright 2017 Cisco Systems, Inc. and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef LINUX_CEC_PIN_H
+#define LINUX_CEC_PIN_H
+
+#include <linux/types.h>
+#include <linux/atomic.h>
+#include <media/cec.h>
+
+enum cec_pin_state {
+	/* CEC is off */
+	CEC_ST_OFF,
+	/* CEC is idle, waiting for Rx or Tx */
+	CEC_ST_IDLE,
+
+	/* Tx states */
+
+	/* Pending Tx, waiting for Signal Free Time to expire */
+	CEC_ST_TX_WAIT,
+	/* Low-drive was detected, wait for bus to go high */
+	CEC_ST_TX_WAIT_FOR_HIGH,
+	/* Drive CEC low for the start bit */
+	CEC_ST_TX_START_BIT_LOW,
+	/* Drive CEC high for the start bit */
+	CEC_ST_TX_START_BIT_HIGH,
+	/* Drive CEC low for the 0 bit */
+	CEC_ST_TX_DATA_BIT_0_LOW,
+	/* Drive CEC high for the 0 bit */
+	CEC_ST_TX_DATA_BIT_0_HIGH,
+	/* Drive CEC low for the 1 bit */
+	CEC_ST_TX_DATA_BIT_1_LOW,
+	/* Drive CEC high for the 1 bit */
+	CEC_ST_TX_DATA_BIT_1_HIGH,
+	/*
+	 * Wait for start of sample time to check for Ack bit or first
+	 * four initiator bits to check for Arbitration Lost.
+	 */
+	CEC_ST_TX_DATA_BIT_1_HIGH_PRE_SAMPLE,
+	/* Wait for end of bit period after sampling */
+	CEC_ST_TX_DATA_BIT_1_HIGH_POST_SAMPLE,
+
+	/* Rx states */
+
+	/* Start bit low detected */
+	CEC_ST_RX_START_BIT_LOW,
+	/* Start bit high detected */
+	CEC_ST_RX_START_BIT_HIGH,
+	/* Wait for bit sample time */
+	CEC_ST_RX_DATA_SAMPLE,
+	/* Wait for earliest end of bit period after sampling */
+	CEC_ST_RX_DATA_POST_SAMPLE,
+	/* Wait for CEC to go high (i.e. end of bit period */
+	CEC_ST_RX_DATA_HIGH,
+	/* Drive CEC low to send 0 Ack bit */
+	CEC_ST_RX_ACK_LOW,
+	/* End of 0 Ack time, wait for earliest end of bit period */
+	CEC_ST_RX_ACK_LOW_POST,
+	/* Wait for CEC to go high (i.e. end of bit period */
+	CEC_ST_RX_ACK_HIGH_POST,
+	/* Wait for earliest end of bit period and end of message */
+	CEC_ST_RX_ACK_FINISH,
+
+	/* Start low drive */
+	CEC_ST_LOW_DRIVE,
+	/* Monitor pin using interrupts */
+	CEC_ST_RX_IRQ,
+
+	/* Total number of pin states */
+	CEC_PIN_STATES
+};
+
+/**
+ * struct cec_pin_ops - low-level CEC pin operations
+ * @read:	read the CEC pin. Return true if high, false if low.
+ * @low:	drive the CEC pin low.
+ * @high:	stop driving the CEC pin. The pull-up will drive the pin
+ *		high, unless someone else is driving the pin low.
+ * @enable_irq:	optional, enable the interrupt to detect pin voltage changes.
+ * @disable_irq: optional, disable the interrupt.
+ * @free:	optional. Free any allocated resources. Called when the
+ *		adapter is deleted.
+ * @status:	optional, log status information.
+ *
+ * These operations are used by the cec pin framework to manipulate
+ * the CEC pin.
+ */
+struct cec_pin_ops {
+	bool (*read)(struct cec_adapter *adap);
+	void (*low)(struct cec_adapter *adap);
+	void (*high)(struct cec_adapter *adap);
+	bool (*enable_irq)(struct cec_adapter *adap);
+	void (*disable_irq)(struct cec_adapter *adap);
+	void (*free)(struct cec_adapter *adap);
+	void (*status)(struct cec_adapter *adap, struct seq_file *file);
+};
+
+#define CEC_NUM_PIN_EVENTS 128
+
+struct cec_pin {
+	struct cec_adapter		*adap;
+	const struct cec_pin_ops	*ops;
+	struct task_struct		*kthread;
+	wait_queue_head_t		kthread_waitq;
+	struct hrtimer			timer;
+	ktime_t				ts;
+	unsigned int			wait_usecs;
+	u16				la_mask;
+	bool				enabled;
+	bool				monitor_all;
+	bool				cur_value;
+	bool				rx_eom;
+	bool				enable_irq_failed;
+	enum cec_pin_state		state;
+	struct cec_msg			tx_msg;
+	u32				tx_bit;
+	bool				tx_nacked;
+	u32				tx_signal_free_time;
+	struct cec_msg			rx_msg;
+	u32				rx_bit;
+
+	struct cec_msg			work_rx_msg;
+	u8				work_tx_status;
+	bool				work_enable_irq;
+	ktime_t				work_tx_ts;
+	atomic_t			work_pin_events;
+	unsigned int			work_pin_events_wr;
+	unsigned int			work_pin_events_rd;
+	ktime_t				work_pin_ts[CEC_NUM_PIN_EVENTS];
+	bool				work_pin_is_high[CEC_NUM_PIN_EVENTS];
+	ktime_t				timer_ts;
+	u32				timer_cnt;
+	u32				timer_100ms_overruns;
+	u32				timer_300ms_overruns;
+	u32				timer_max_overrun;
+	u32				timer_sum_overrun;
+};
+
+/**
+ * cec_pin_changed() - update pin state from interrupt
+ *
+ * @adap:	pointer to the cec adapter
+ * @value:	when true the pin is high, otherwise it is low
+ *
+ * If changes of the CEC voltage are detected via an interrupt, then
+ * cec_pin_changed is called from the interrupt with the new value.
+ */
+void cec_pin_changed(struct cec_adapter *adap, bool value);
+
+/**
+ * cec_pin_allocate_adapter() - allocate a pin-based cec adapter
+ *
+ * @pin_ops:	low-level pin operations
+ * @priv:	will be stored in adap->priv and can be used by the adapter ops.
+ *		Use cec_get_drvdata(adap) to get the priv pointer.
+ * @name:	the name of the CEC adapter. Note: this name will be copied.
+ * @caps:	capabilities of the CEC adapter. This will be ORed with
+ *		CEC_CAP_MONITOR_ALL and CEC_CAP_MONITOR_PIN.
+ *
+ * Allocate a cec adapter using the cec pin framework.
+ *
+ * Return: a pointer to the cec adapter or an error pointer
+ */
+struct cec_adapter *cec_pin_allocate_adapter(const struct cec_pin_ops *pin_ops,
+					void *priv, const char *name, u32 caps);
+
+#endif
