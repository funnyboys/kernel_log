commit 97f2650e504033376e8813691cb6eccf73151676
Author: Stephan Müller <smueller@chronox.de>
Date:   Fri Apr 17 21:34:03 2020 +0200

    crypto: drbg - always seeded with SP800-90B compliant noise source
    
    As the Jitter RNG provides an SP800-90B compliant noise source, use this
    noise source always for the (re)seeding of the DRBG.
    
    To make sure the DRBG is always properly seeded, the reseed threshold
    is reduced to 1<<20 generate operations.
    
    The Jitter RNG may report health test failures. Such health test
    failures are treated as transient as follows. The DRBG will not reseed
    from the Jitter RNG (but from get_random_bytes) in case of a health
    test failure. Though, it produces the requested random number.
    
    The Jitter RNG has a failure counter where at most 1024 consecutive
    resets due to a health test failure are considered as a transient error.
    If more consecutive resets are required, the Jitter RNG will return
    a permanent error which is returned to the caller by the DRBG. With this
    approach, the worst case reseed threshold is significantly lower than
    mandated by SP800-90A in order to seed with an SP800-90B noise source:
    the DRBG has a reseed threshold of 2^20 * 1024 = 2^30 generate requests.
    
    Yet, in case of a transient Jitter RNG health test failure, the DRBG is
    seeded with the data obtained from get_random_bytes.
    
    However, if the Jitter RNG fails during the initial seeding operation
    even due to a health test error, the DRBG will send an error to the
    caller because at that time, the DRBG has received no seed that is
    SP800-90B compliant.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 8c9af21efce1..c4165126937e 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -184,11 +184,7 @@ static inline size_t drbg_max_addtl(struct drbg_state *drbg)
 static inline size_t drbg_max_requests(struct drbg_state *drbg)
 {
 	/* SP800-90A requires 2**48 maximum requests before reseeding */
-#if (__BITS_PER_LONG == 32)
-	return SIZE_MAX;
-#else
-	return (1UL<<48);
-#endif
+	return (1<<20);
 }
 
 /*

commit db07cd26ac6a418dc2823187958edcfdb415fa83
Author: Stephan Mueller <smueller@chronox.de>
Date:   Wed May 8 16:19:24 2019 +0200

    crypto: drbg - add FIPS 140-2 CTRNG for noise source
    
    FIPS 140-2 section 4.9.2 requires a continuous self test of the noise
    source. Up to kernel 4.8 drivers/char/random.c provided this continuous
    self test. Afterwards it was moved to a location that is inconsistent
    with the FIPS 140-2 requirements. The relevant patch was
    e192be9d9a30555aae2ca1dc3aad37cba484cd4a .
    
    Thus, the FIPS 140-2 CTRNG is added to the DRBG when it obtains the
    seed. This patch resurrects the function drbg_fips_continous_test that
    existed some time ago and applies it to the noise sources. The patch
    that removed the drbg_fips_continous_test was
    b3614763059b82c26bdd02ffcb1c016c1132aad0 .
    
    The Jitter RNG implements its own FIPS 140-2 self test and thus does not
    need to be subjected to the test in the DRBG.
    
    The patch contains a tiny fix to ensure proper zeroization in case of an
    error during the Jitter RNG data gathering.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Reviewed-by: Yann Droneaud <ydroneaud@opteya.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 3fb581bf3b87..8c9af21efce1 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -129,6 +129,8 @@ struct drbg_state {
 
 	bool seeded;		/* DRBG fully seeded? */
 	bool pr;		/* Prediction resistance enabled? */
+	bool fips_primed;	/* Continuous test primed? */
+	unsigned char *prev;	/* FIPS 140-2 continuous test value */
 	struct work_struct seed_work;	/* asynchronous seeding support */
 	struct crypto_rng *jent;
 	const struct drbg_state_ops *d_ops;

commit 43490e8046b5d273eb82710b04290c5997138adc
Author: Stephan Müller <smueller@chronox.de>
Date:   Fri Jul 20 19:42:01 2018 +0200

    crypto: drbg - in-place cipher operation for CTR
    
    The cipher implementations of the kernel crypto API favor in-place
    cipher operations. Thus, switch the CTR cipher operation in the DRBG to
    perform in-place operations. This is implemented by using the output
    buffer as input buffer and zeroizing it before the cipher operation to
    implement a CTR encryption of a NULL buffer.
    
    The speed improvement is quite visibile with the following comparison
    using the LRNG implementation.
    
    Without the patch set:
    
          16 bytes|           12.267661 MB/s|    61338304 bytes |  5000000213 ns
          32 bytes|           23.603770 MB/s|   118018848 bytes |  5000000073 ns
          64 bytes|           46.732262 MB/s|   233661312 bytes |  5000000241 ns
         128 bytes|           90.038042 MB/s|   450190208 bytes |  5000000244 ns
         256 bytes|          160.399616 MB/s|   801998080 bytes |  5000000393 ns
         512 bytes|          259.878400 MB/s|  1299392000 bytes |  5000001675 ns
        1024 bytes|          386.050662 MB/s|  1930253312 bytes |  5000001661 ns
        2048 bytes|          493.641728 MB/s|  2468208640 bytes |  5000001598 ns
        4096 bytes|          581.835981 MB/s|  2909179904 bytes |  5000003426 ns
    
    With the patch set:
    
          16 bytes |         17.051142 MB/s |     85255712 bytes |  5000000854 ns
          32 bytes |         32.695898 MB/s |    163479488 bytes |  5000000544 ns
          64 bytes |         64.490739 MB/s |    322453696 bytes |  5000000954 ns
         128 bytes |        123.285043 MB/s |    616425216 bytes |  5000000201 ns
         256 bytes |        233.434573 MB/s |   1167172864 bytes |  5000000573 ns
         512 bytes |        384.405197 MB/s |   1922025984 bytes |  5000000671 ns
        1024 bytes |        566.313370 MB/s |   2831566848 bytes |  5000001080 ns
        2048 bytes |        744.518042 MB/s |   3722590208 bytes |  5000000926 ns
        4096 bytes |        867.501670 MB/s |   4337508352 bytes |  5000002181 ns
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 54b9f5d375f5..3fb581bf3b87 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -122,8 +122,6 @@ struct drbg_state {
 
 	struct crypto_skcipher *ctr_handle;	/* CTR mode cipher handle */
 	struct skcipher_request *ctr_req;	/* CTR mode request handle */
-	__u8 *ctr_null_value_buf;		/* CTR mode unaligned buffer */
-	__u8 *ctr_null_value;			/* CTR mode aligned zero buf */
 	__u8 *outscratchpadbuf;			/* CTR mode output scratchpad */
         __u8 *outscratchpad;			/* CTR mode aligned outbuf */
 	struct crypto_wait ctr_wait;		/* CTR mode async wait obj */

commit cf862cbc831982a27f14a08adf82ad9ca8d86205
Author: Stephan Mueller <smueller@chronox.de>
Date:   Tue Jul 10 17:56:33 2018 +0200

    crypto: drbg - eliminate constant reinitialization of SGL
    
    The CTR DRBG requires two SGLs pointing to input/output buffers for the
    CTR AES operation. The used SGLs always have only one entry. Thus, the
    SGL can be initialized during allocation time, preventing a
    re-initialization of the SGLs during each call.
    
    The performance is increased by about 1 to 3 percent depending on the
    size of the requested buffer size.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 8f941102af36..54b9f5d375f5 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -127,6 +127,7 @@ struct drbg_state {
 	__u8 *outscratchpadbuf;			/* CTR mode output scratchpad */
         __u8 *outscratchpad;			/* CTR mode aligned outbuf */
 	struct crypto_wait ctr_wait;		/* CTR mode async wait obj */
+	struct scatterlist sg_in, sg_out;	/* CTR mode SGLs */
 
 	bool seeded;		/* DRBG fully seeded? */
 	bool pr;		/* Prediction resistance enabled? */

commit 85a2dea4bdbfa7565818ca094d08e838cf62da77
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Wed Oct 18 08:00:41 2017 +0100

    crypto: drbg - move to generic async completion
    
    DRBG is starting an async. crypto op and waiting for it complete.
    Move it over to generic code doing the same.
    
    The code now also passes CRYPTO_TFM_REQ_MAY_SLEEP flag indicating
    crypto request memory allocation may use GFP_KERNEL which should
    be perfectly fine as the code is obviously sleeping for the
    completion of the request any way.
    
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 22f884c97387..8f941102af36 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -126,8 +126,7 @@ struct drbg_state {
 	__u8 *ctr_null_value;			/* CTR mode aligned zero buf */
 	__u8 *outscratchpadbuf;			/* CTR mode output scratchpad */
         __u8 *outscratchpad;			/* CTR mode aligned outbuf */
-	struct completion ctr_completion;	/* CTR mode async handler */
-	int ctr_async_err;			/* CTR mode async error */
+	struct crypto_wait ctr_wait;		/* CTR mode async wait obj */
 
 	bool seeded;		/* DRBG fully seeded? */
 	bool pr;		/* Prediction resistance enabled? */

commit 5102981212454998d549273ff9847f19e97a1794
Author: Stephan Mueller <smueller@chronox.de>
Date:   Tue Nov 29 09:45:04 2016 +0100

    crypto: drbg - prevent invalid SG mappings
    
    When using SGs, only heap memory (memory that is valid as per
    virt_addr_valid) is allowed to be referenced. The CTR DRBG used to
    reference the caller-provided memory directly in an SG. In case the
    caller provided stack memory pointers, the SG mapping is not considered
    to be valid. In some cases, this would even cause a paging fault.
    
    The change adds a new scratch buffer that is used unconditionally to
    catch the cases where the caller-provided buffer is not suitable for
    use in an SG. The crypto operation of the CTR DRBG produces its output
    with that scratch buffer and finally copies the content of the
    scratch buffer to the caller's buffer.
    
    The scratch buffer is allocated during allocation time of the CTR DRBG
    as its access is protected with the DRBG mutex.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 61580b19f9f6..22f884c97387 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -124,6 +124,8 @@ struct drbg_state {
 	struct skcipher_request *ctr_req;	/* CTR mode request handle */
 	__u8 *ctr_null_value_buf;		/* CTR mode unaligned buffer */
 	__u8 *ctr_null_value;			/* CTR mode aligned zero buf */
+	__u8 *outscratchpadbuf;			/* CTR mode output scratchpad */
+        __u8 *outscratchpad;			/* CTR mode aligned outbuf */
 	struct completion ctr_completion;	/* CTR mode async handler */
 	int ctr_async_err;			/* CTR mode async error */
 

commit 3cfc3b97211238ffc1a7885ebe62f899180fe043
Author: Stephan Mueller <smueller@chronox.de>
Date:   Tue Jun 14 07:35:13 2016 +0200

    crypto: drbg - use aligned buffers
    
    Hardware cipher implementation may require aligned buffers. All buffers
    that potentially are processed with a cipher are now aligned.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index b2fe15d1ceba..61580b19f9f6 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -108,13 +108,16 @@ struct drbg_test_data {
 struct drbg_state {
 	struct mutex drbg_mutex;	/* lock around DRBG */
 	unsigned char *V;	/* internal state 10.1.1.1 1a) */
+	unsigned char *Vbuf;
 	/* hash: static value 10.1.1.1 1b) hmac / ctr: key */
 	unsigned char *C;
+	unsigned char *Cbuf;
 	/* Number of RNG requests since last reseed -- 10.1.1.1 1c) */
 	size_t reseed_ctr;
 	size_t reseed_threshold;
 	 /* some memory the DRBG can use for its operation */
 	unsigned char *scratchpad;
+	unsigned char *scratchpadbuf;
 	void *priv_data;	/* Cipher handle */
 
 	struct crypto_skcipher *ctr_handle;	/* CTR mode cipher handle */

commit 355912852115cd8aa4ad02c25182ae615ce925fb
Author: Stephan Mueller <smueller@chronox.de>
Date:   Tue Jun 14 07:34:13 2016 +0200

    crypto: drbg - use CTR AES instead of ECB AES
    
    The CTR DRBG derives its random data from the CTR that is encrypted with
    AES.
    
    This patch now changes the CTR DRBG implementation such that the
    CTR AES mode is employed. This allows the use of steamlined CTR AES
    implementation such as ctr-aes-aesni.
    
    Unfortunately there are the following subtile changes we need to apply
    when using the CTR AES mode:
    
    - the CTR mode increments the counter after the cipher operation, but
      the CTR DRBG requires the increment before the cipher op. Hence, the
      crypto_inc is applied to the counter (drbg->V) once it is
      recalculated.
    
    - the CTR mode wants to encrypt data, but the CTR DRBG is interested in
      the encrypted counter only. The full CTR mode is the XOR of the
      encrypted counter with the plaintext data. To access the encrypted
      counter, the patch uses a NULL data vector as plaintext to be
      "encrypted".
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index d961b2b16f55..b2fe15d1ceba 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -43,6 +43,7 @@
 #include <linux/random.h>
 #include <linux/scatterlist.h>
 #include <crypto/hash.h>
+#include <crypto/skcipher.h>
 #include <linux/module.h>
 #include <linux/crypto.h>
 #include <linux/slab.h>
@@ -115,6 +116,14 @@ struct drbg_state {
 	 /* some memory the DRBG can use for its operation */
 	unsigned char *scratchpad;
 	void *priv_data;	/* Cipher handle */
+
+	struct crypto_skcipher *ctr_handle;	/* CTR mode cipher handle */
+	struct skcipher_request *ctr_req;	/* CTR mode request handle */
+	__u8 *ctr_null_value_buf;		/* CTR mode unaligned buffer */
+	__u8 *ctr_null_value;			/* CTR mode aligned zero buf */
+	struct completion ctr_completion;	/* CTR mode async handler */
+	int ctr_async_err;			/* CTR mode async error */
+
 	bool seeded;		/* DRBG fully seeded? */
 	bool pr;		/* Prediction resistance enabled? */
 	struct work_struct seed_work;	/* asynchronous seeding support */

commit b3614763059b82c26bdd02ffcb1c016c1132aad0
Author: Stephan Mueller <sm@eperm.de>
Date:   Fri Jan 22 09:52:28 2016 +0100

    crypto: drbg - remove FIPS 140-2 continuous test
    
    The newly released FIPS 140-2 IG 9.8 specifies that for SP800-90A
    compliant DRBGs, the FIPS 140-2 continuous random number generator test
    is not required any more.
    
    This patch removes the test and all associated data structures.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 9756c70899d8..d961b2b16f55 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -117,10 +117,6 @@ struct drbg_state {
 	void *priv_data;	/* Cipher handle */
 	bool seeded;		/* DRBG fully seeded? */
 	bool pr;		/* Prediction resistance enabled? */
-#ifdef CONFIG_CRYPTO_FIPS
-	bool fips_primed;	/* Continuous test primed? */
-	unsigned char *prev;	/* FIPS 140-2 continuous test value */
-#endif
 	struct work_struct seed_work;	/* asynchronous seeding support */
 	struct crypto_rng *jent;
 	const struct drbg_state_ops *d_ops;

commit 42ea507fae1ac4b4af0d9d715ab56fa4de2a0341
Author: Stephan Mueller <smueller@chronox.de>
Date:   Wed Jun 10 03:33:37 2015 +0200

    crypto: drbg - reseed often if seedsource is degraded
    
    As required by SP800-90A, the DRBG implements are reseeding threshold.
    This threshold is at 2**48 (64 bit) and 2**32 bit (32 bit) as
    implemented in drbg_max_requests.
    
    With the recently introduced changes, the DRBG is now always used as a
    stdrng which is initialized very early in the boot cycle. To ensure that
    sufficient entropy is present, the Jitter RNG is added to even provide
    entropy at early boot time.
    
    However, the 2nd seed source, the nonblocking pool, is usually
    degraded at that time. Therefore, the DRBG is seeded with the Jitter RNG
    (which I believe contains good entropy, which however is questioned by
    others) and is seeded with a degradded nonblocking pool. This seed is
    now used for quasi the lifetime of the system (2**48 requests is a lot).
    
    The patch now changes the reseed threshold as follows: up until the time
    the DRBG obtains a seed from a fully iniitialized nonblocking pool, the
    reseeding threshold is lowered such that the DRBG is forced to reseed
    itself resonably often. Once it obtains the seed from a fully
    initialized nonblocking pool, the reseed threshold is set to the value
    required by SP800-90A.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index fad6450b99f9..9756c70899d8 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -111,6 +111,7 @@ struct drbg_state {
 	unsigned char *C;
 	/* Number of RNG requests since last reseed -- 10.1.1.1 1c) */
 	size_t reseed_ctr;
+	size_t reseed_threshold;
 	 /* some memory the DRBG can use for its operation */
 	unsigned char *scratchpad;
 	void *priv_data;	/* Cipher handle */

commit 57225e6797885e31302e76fc5926c0bedd7e5ad4
Author: Stephan Mueller <smueller@chronox.de>
Date:   Tue Jun 9 21:55:38 2015 +0800

    crypto: drbg - Use callback API for random readiness
    
    The get_blocking_random_bytes API is broken because the wait can
    be arbitrarily long (potentially forever) so there is no safe way
    of calling it from within the kernel.
    
    This patch replaces it with the new callback API which does not
    have this problem.
    
    The patch also removes the entropy buffer registered with the DRBG
    handle in favor of stack variables to hold the seed data.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index c3f208dc83ee..fad6450b99f9 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -121,12 +121,11 @@ struct drbg_state {
 	unsigned char *prev;	/* FIPS 140-2 continuous test value */
 #endif
 	struct work_struct seed_work;	/* asynchronous seeding support */
-	u8 *seed_buf;			/* buffer holding the seed */
-	size_t seed_buf_len;
 	struct crypto_rng *jent;
 	const struct drbg_state_ops *d_ops;
 	const struct drbg_core *core;
 	struct drbg_string test_data;
+	struct random_ready_callback random_ready;
 };
 
 static inline __u8 drbg_statelen(struct drbg_state *drbg)

commit b8ec5ba42c4a3854e27c44e697d9b4f0b84b32bb
Author: Stephan Mueller <smueller@chronox.de>
Date:   Mon May 25 15:09:59 2015 +0200

    crypto: drbg - use Jitter RNG to obtain seed
    
    During initialization, the DRBG now tries to allocate a handle of the
    Jitter RNG. If such a Jitter RNG is available during seeding, the DRBG
    pulls the required entropy/nonce string from get_random_bytes and
    concatenates it with a string of equal size from the Jitter RNG. That
    combined string is now the seed for the DRBG.
    
    Written differently, the initial seed of the DRBG is now:
    
    get_random_bytes(entropy/nonce) || jitterentropy (entropy/nonce)
    
    If the Jitter RNG is not available, the DRBG only seeds from
    get_random_bytes.
    
    CC: Andreas Steffen <andreas.steffen@strongswan.org>
    CC: Theodore Ts'o <tytso@mit.edu>
    CC: Sandy Harris <sandyinchina@gmail.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 46994b25dc85..c3f208dc83ee 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -123,6 +123,7 @@ struct drbg_state {
 	struct work_struct seed_work;	/* asynchronous seeding support */
 	u8 *seed_buf;			/* buffer holding the seed */
 	size_t seed_buf_len;
+	struct crypto_rng *jent;
 	const struct drbg_state_ops *d_ops;
 	const struct drbg_core *core;
 	struct drbg_string test_data;

commit 4c7879907eddd5b3ec09489bc980aab4f44e38dd
Author: Stephan Mueller <smueller@chronox.de>
Date:   Mon May 25 15:09:36 2015 +0200

    crypto: drbg - add async seeding operation
    
    The async seeding operation is triggered during initalization right
    after the first non-blocking seeding is completed. As required by the
    asynchronous operation of random.c, a callback function is provided that
    is triggered by random.c once entropy is available. That callback
    function performs the actual seeding of the DRBG.
    
    CC: Andreas Steffen <andreas.steffen@strongswan.org>
    CC: Theodore Ts'o <tytso@mit.edu>
    CC: Sandy Harris <sandyinchina@gmail.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index b0526981aa85..46994b25dc85 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -51,6 +51,7 @@
 #include <linux/fips.h>
 #include <linux/mutex.h>
 #include <linux/list.h>
+#include <linux/workqueue.h>
 
 /*
  * Concatenation Helper and string operation helper
@@ -119,6 +120,7 @@ struct drbg_state {
 	bool fips_primed;	/* Continuous test primed? */
 	unsigned char *prev;	/* FIPS 140-2 continuous test value */
 #endif
+	struct work_struct seed_work;	/* asynchronous seeding support */
 	u8 *seed_buf;			/* buffer holding the seed */
 	size_t seed_buf_len;
 	const struct drbg_state_ops *d_ops;

commit 3d6a5f75d1340539dcdcec4609761fa4b836a1f2
Author: Stephan Mueller <smueller@chronox.de>
Date:   Mon May 25 15:09:14 2015 +0200

    crypto: drbg - prepare for async seeding
    
    In order to prepare for the addition of the asynchronous seeding call,
    the invocation of seeding the DRBG is moved out into a helper function.
    
    In addition, a block of memory is allocated during initialization time
    that will be used as a scratchpad for obtaining entropy. That scratchpad
    is used for the initial seeding operation as well as by the
    asynchronous seeding call. The memory must be zeroized every time the
    DRBG seeding call succeeds to avoid entropy data lingering in memory.
    
    CC: Andreas Steffen <andreas.steffen@strongswan.org>
    CC: Theodore Ts'o <tytso@mit.edu>
    CC: Sandy Harris <sandyinchina@gmail.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 480d7a0f4dac..b0526981aa85 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -119,6 +119,8 @@ struct drbg_state {
 	bool fips_primed;	/* Continuous test primed? */
 	unsigned char *prev;	/* FIPS 140-2 continuous test value */
 #endif
+	u8 *seed_buf;			/* buffer holding the seed */
+	size_t seed_buf_len;
 	const struct drbg_state_ops *d_ops;
 	const struct drbg_core *core;
 	struct drbg_string test_data;

commit 8fded5925d0a733c46f8d0b5edd1c9b315882b1d
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Apr 21 10:46:41 2015 +0800

    crypto: drbg - Convert to new rng interface
    
    This patch converts the DRBG implementation to the new low-level
    rng interface.
    
    This allows us to get rid of struct drbg_gen by using the new RNG
    API instead.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Stephan Mueller <smueller@chronox.de>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index a43a7ed4d9fc..480d7a0f4dac 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -121,7 +121,7 @@ struct drbg_state {
 #endif
 	const struct drbg_state_ops *d_ops;
 	const struct drbg_core *core;
-	struct drbg_test_data *test_data;
+	struct drbg_string test_data;
 };
 
 static inline __u8 drbg_statelen(struct drbg_state *drbg)
@@ -176,20 +176,9 @@ static inline size_t drbg_max_requests(struct drbg_state *drbg)
 #endif
 }
 
-/*
- * kernel crypto API input data structure for DRBG generate in case dlen
- * is set to 0
- */
-struct drbg_gen {
-	unsigned char *outbuf;	/* output buffer for random numbers */
-	unsigned int outlen;	/* size of output buffer */
-	struct drbg_string *addtl;	/* additional information string */
-	struct drbg_test_data *test_data;	/* test data */
-};
-
 /*
  * This is a wrapper to the kernel crypto API function of
- * crypto_rng_get_bytes() to allow the caller to provide additional data.
+ * crypto_rng_generate() to allow the caller to provide additional data.
  *
  * @drng DRBG handle -- see crypto_rng_get_bytes
  * @outbuf output buffer -- see crypto_rng_get_bytes
@@ -204,21 +193,15 @@ static inline int crypto_drbg_get_bytes_addtl(struct crypto_rng *drng,
 			unsigned char *outbuf, unsigned int outlen,
 			struct drbg_string *addtl)
 {
-	int ret;
-	struct drbg_gen genbuf;
-	genbuf.outbuf = outbuf;
-	genbuf.outlen = outlen;
-	genbuf.addtl = addtl;
-	genbuf.test_data = NULL;
-	ret = crypto_rng_get_bytes(drng, (u8 *)&genbuf, 0);
-	return ret;
+	return crypto_rng_generate(drng, addtl->buf, addtl->len,
+				   outbuf, outlen);
 }
 
 /*
  * TEST code
  *
  * This is a wrapper to the kernel crypto API function of
- * crypto_rng_get_bytes() to allow the caller to provide additional data and
+ * crypto_rng_generate() to allow the caller to provide additional data and
  * allow furnishing of test_data
  *
  * @drng DRBG handle -- see crypto_rng_get_bytes
@@ -236,14 +219,10 @@ static inline int crypto_drbg_get_bytes_addtl_test(struct crypto_rng *drng,
 			struct drbg_string *addtl,
 			struct drbg_test_data *test_data)
 {
-	int ret;
-	struct drbg_gen genbuf;
-	genbuf.outbuf = outbuf;
-	genbuf.outlen = outlen;
-	genbuf.addtl = addtl;
-	genbuf.test_data = test_data;
-	ret = crypto_rng_get_bytes(drng, (u8 *)&genbuf, 0);
-	return ret;
+	crypto_rng_set_entropy(drng, test_data->testentropy->buf,
+			       test_data->testentropy->len);
+	return crypto_rng_generate(drng, addtl->buf, addtl->len,
+				   outbuf, outlen);
 }
 
 /*
@@ -264,14 +243,9 @@ static inline int crypto_drbg_reset_test(struct crypto_rng *drng,
 					 struct drbg_string *pers,
 					 struct drbg_test_data *test_data)
 {
-	int ret;
-	struct drbg_gen genbuf;
-	genbuf.outbuf = NULL;
-	genbuf.outlen = 0;
-	genbuf.addtl = pers;
-	genbuf.test_data = test_data;
-	ret = crypto_rng_reset(drng, (u8 *)&genbuf, 0);
-	return ret;
+	crypto_rng_set_entropy(drng, test_data->testentropy->buf,
+			       test_data->testentropy->len);
+	return crypto_rng_reset(drng, pers->buf, pers->len);
 }
 
 /* DRBG type flags */

commit 76899a41f830d17affe6f9c58cc4b23ba26f5e00
Author: Stephan Mueller <smueller@chronox.de>
Date:   Sat Apr 18 19:36:17 2015 +0200

    crypto: drbg - replace spinlock with mutex
    
    The creation of a shadow copy is intended to only hold a short term
    lock. But the drawback is that parallel users have a very similar DRBG
    state which only differs by a high-resolution time stamp.
    
    The DRBG will now hold a long term lock. Therefore, the lock is changed
    to a mutex which implies that the DRBG can only be used in process
    context.
    
    The lock now guards the instantiation as well as the entire DRBG
    generation operation. Therefore, multiple callers are fully serialized
    when generating a random number.
    
    As the locking is changed to use a long-term lock to avoid such similar
    DRBG states, the entire creation and maintenance of a shadow copy can be
    removed.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 5186f750c713..a43a7ed4d9fc 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -49,7 +49,7 @@
 #include <crypto/internal/rng.h>
 #include <crypto/rng.h>
 #include <linux/fips.h>
-#include <linux/spinlock.h>
+#include <linux/mutex.h>
 #include <linux/list.h>
 
 /*
@@ -104,7 +104,7 @@ struct drbg_test_data {
 };
 
 struct drbg_state {
-	spinlock_t drbg_lock;	/* lock around DRBG */
+	struct mutex drbg_mutex;	/* lock around DRBG */
 	unsigned char *V;	/* internal state 10.1.1.1 1a) */
 	/* hash: static value 10.1.1.1 1b) hmac / ctr: key */
 	unsigned char *C;

commit b9347aff91ce4789619168539f08202d8d6a1177
Author: Stephan Mueller <smueller@chronox.de>
Date:   Tue Aug 26 10:29:45 2014 +0200

    crypto: drbg - fix maximum value checks on 32 bit systems
    
    The maximum values for additional input string or generated blocks is
    larger than 1<<32. To ensure a sensible value on 32 bit systems, return
    SIZE_MAX on 32 bit systems. This value is lower than the maximum
    allowed values defined in SP800-90A. The standard allow lower maximum
    values, but not larger values.
    
    SIZE_MAX - 1 is used for drbg_max_addtl to allow
    drbg_healthcheck_sanity to check the enforcement of the variable
    without wrapping.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 3d8e73a1a1c7..5186f750c713 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -154,13 +154,26 @@ static inline size_t drbg_max_request_bytes(struct drbg_state *drbg)
 static inline size_t drbg_max_addtl(struct drbg_state *drbg)
 {
 	/* SP800-90A requires 2**35 bytes additional info str / pers str */
+#if (__BITS_PER_LONG == 32)
+	/*
+	 * SP800-90A allows smaller maximum numbers to be returned -- we
+	 * return SIZE_MAX - 1 to allow the verification of the enforcement
+	 * of this value in drbg_healthcheck_sanity.
+	 */
+	return (SIZE_MAX - 1);
+#else
 	return (1UL<<35);
+#endif
 }
 
 static inline size_t drbg_max_requests(struct drbg_state *drbg)
 {
 	/* SP800-90A requires 2**48 maximum requests before reseeding */
+#if (__BITS_PER_LONG == 32)
+	return SIZE_MAX;
+#else
 	return (1UL<<48);
+#endif
 }
 
 /*

commit 05c81ccd9087d238c10b234eadb55632742e5518
Author: Stephan Mueller <smueller@chronox.de>
Date:   Sun Aug 17 17:41:10 2014 +0200

    crypto: drbg - remove configuration of fixed values
    
    SP800-90A mandates several hard-coded values. The old drbg_cores allows
    the setting of these values per DRBG implementation. However, due to the
    hard requirement of SP800-90A, these values are now returned globally
    for each DRBG.
    
    The ability to set such values per DRBG is therefore removed.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 831d786976c5..3d8e73a1a1c7 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -82,15 +82,6 @@ typedef uint32_t drbg_flag_t;
 struct drbg_core {
 	drbg_flag_t flags;	/* flags for the cipher */
 	__u8 statelen;		/* maximum state length */
-	/*
-	 * maximum length of personalization string or additional input
-	 * string -- exponent for base 2
-	 */
-	__u8 max_addtllen;
-	/* maximum bits per RNG request -- exponent for base 2*/
-	__u8 max_bits;
-	/* maximum number of requests -- exponent for base 2 */
-	__u8 max_req;
 	__u8 blocklen_bytes;	/* block size of output in bytes */
 	char cra_name[CRYPTO_MAX_ALG_NAME]; /* mapping to kernel crypto API */
 	 /* kernel crypto API backend cipher name */
@@ -156,18 +147,20 @@ static inline __u8 drbg_keylen(struct drbg_state *drbg)
 
 static inline size_t drbg_max_request_bytes(struct drbg_state *drbg)
 {
-	/* max_bits is in bits, but buflen is in bytes */
-	return (1 << (drbg->core->max_bits - 3));
+	/* SP800-90A requires the limit 2**19 bits, but we return bytes */
+	return (1 << 16);
 }
 
 static inline size_t drbg_max_addtl(struct drbg_state *drbg)
 {
-	return (1UL<<(drbg->core->max_addtllen));
+	/* SP800-90A requires 2**35 bytes additional info str / pers str */
+	return (1UL<<35);
 }
 
 static inline size_t drbg_max_requests(struct drbg_state *drbg)
 {
-	return (1UL<<(drbg->core->max_req));
+	/* SP800-90A requires 2**48 maximum requests before reseeding */
+	return (1UL<<48);
 }
 
 /*

commit 27e4de2bd1804c24e3e517dd54026c1f60e8fe27
Author: Stephan Mueller <smueller@chronox.de>
Date:   Sun Jul 6 02:25:36 2014 +0200

    crypto: drbg - Mix a time stamp into DRBG state
    
    The current locking approach of the DRBG tries to keep the protected
    code paths very minimal. It is therefore possible that two threads query
    one DRBG instance at the same time. When thread A requests random
    numbers, a shadow copy of the DRBG state is created upon which the
    request for A is processed. After finishing the state for A's request is
    merged back into the DRBG state. If now thread B requests random numbers
    from the same DRBG after the request for thread A is received, but
    before A's shadow state is merged back, the random numbers for B will be
    identical to the ones for A. Please note that the time window is very
    small for this scenario.
    
    To prevent that there is even a theoretical chance for thread A and B
    having the same DRBG state, the current time stamp is provided as
    additional information string for each new request.
    
    The addition of the time stamp as additional information string implies
    that now all generate functions must be capable to process a linked
    list with additional information strings instead of a scalar.
    
    CC: Rafael Aquini <aquini@redhat.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index 4065dfca146a..831d786976c5 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -102,7 +102,7 @@ struct drbg_state_ops {
 		      int reseed);
 	int (*generate)(struct drbg_state *drbg,
 			unsigned char *buf, unsigned int buflen,
-			struct drbg_string *addtl);
+			struct list_head *addtl);
 	int (*crypto_init)(struct drbg_state *drbg);
 	int (*crypto_fini)(struct drbg_state *drbg);
 

commit 8c98716601bc05091ff49aa8ebf5299a0c6604a0
Author: Stephan Mueller <smueller@chronox.de>
Date:   Sat Jun 28 21:58:24 2014 +0200

    crypto: drbg - use of kernel linked list
    
    The DRBG-style linked list to manage input data that is fed into the
    cipher invocations is replaced with the kernel linked list
    implementation.
    
    The change is transparent to users of the interfaces offered by the
    DRBG. Therefore, no changes to the testmgr code is needed.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
index b507c5b6020a..4065dfca146a 100644
--- a/include/crypto/drbg.h
+++ b/include/crypto/drbg.h
@@ -50,6 +50,7 @@
 #include <crypto/rng.h>
 #include <linux/fips.h>
 #include <linux/spinlock.h>
+#include <linux/list.h>
 
 /*
  * Concatenation Helper and string operation helper
@@ -64,7 +65,7 @@
 struct drbg_string {
 	const unsigned char *buf;
 	size_t len;
-	struct drbg_string *next;
+	struct list_head list;
 };
 
 static inline void drbg_string_fill(struct drbg_string *string,
@@ -72,7 +73,7 @@ static inline void drbg_string_fill(struct drbg_string *string,
 {
 	string->buf = buf;
 	string->len = len;
-	string->next = NULL;
+	INIT_LIST_HEAD(&string->list);
 }
 
 struct drbg_state;
@@ -97,7 +98,7 @@ struct drbg_core {
 };
 
 struct drbg_state_ops {
-	int (*update)(struct drbg_state *drbg, struct drbg_string *seed,
+	int (*update)(struct drbg_state *drbg, struct list_head *seed,
 		      int reseed);
 	int (*generate)(struct drbg_state *drbg,
 			unsigned char *buf, unsigned int buflen,

commit 3e16f959b93fd323e1d1a37760e10f39fa3007bb
Author: Stephan Mueller <smueller@chronox.de>
Date:   Sat May 31 17:21:48 2014 +0200

    crypto: drbg - header file for DRBG
    
    The header file includes the definition of:
    
    * DRBG data structures with
            - struct drbg_state as main structure
            - struct drbg_core referencing the backend ciphers
            - struct drbg_state_ops callbach handlers for specific code
              supporting the Hash, HMAC, CTR DRBG implementations
            - struct drbg_conc defining a linked list for input data
            - struct drbg_test_data holding the test "entropy" data for CAVS
              testing and testmgr.c
            - struct drbg_gen allowing test data, additional information
              string and personalization string data to be funneled through
              the kernel crypto API -- the DRBG requires additional
              parameters when invoking the reset and random number
              generation requests than intended by the kernel crypto API
    
    * wrapper function to the kernel crypto API functions using struct
      drbg_gen to pass through all data needed for DRBG
    
    * wrapper functions to kernel crypto API functions usable for testing
      code to inject test_data into the DRBG as needed by CAVS testing and
      testmgr.c.
    
    * DRBG flags required for the operation of the DRBG and for selecting
      the particular DRBG type and backend cipher
    
    * getter functions for data from struct drbg_core
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/drbg.h b/include/crypto/drbg.h
new file mode 100644
index 000000000000..b507c5b6020a
--- /dev/null
+++ b/include/crypto/drbg.h
@@ -0,0 +1,289 @@
+/*
+ * DRBG based on NIST SP800-90A
+ *
+ * Copyright Stephan Mueller <smueller@chronox.de>, 2014
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, and the entire permission notice in its entirety,
+ *    including the disclaimer of warranties.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * ALTERNATIVELY, this product may be distributed under the terms of
+ * the GNU General Public License, in which case the provisions of the GPL are
+ * required INSTEAD OF the above restrictions.  (This clause is
+ * necessary due to a potential bad interaction between the GPL and
+ * the restrictions contained in a BSD-style copyright.)
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
+ * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ */
+
+#ifndef _DRBG_H
+#define _DRBG_H
+
+
+#include <linux/random.h>
+#include <linux/scatterlist.h>
+#include <crypto/hash.h>
+#include <linux/module.h>
+#include <linux/crypto.h>
+#include <linux/slab.h>
+#include <crypto/internal/rng.h>
+#include <crypto/rng.h>
+#include <linux/fips.h>
+#include <linux/spinlock.h>
+
+/*
+ * Concatenation Helper and string operation helper
+ *
+ * SP800-90A requires the concatenation of different data. To avoid copying
+ * buffers around or allocate additional memory, the following data structure
+ * is used to point to the original memory with its size. In addition, it
+ * is used to build a linked list. The linked list defines the concatenation
+ * of individual buffers. The order of memory block referenced in that
+ * linked list determines the order of concatenation.
+ */
+struct drbg_string {
+	const unsigned char *buf;
+	size_t len;
+	struct drbg_string *next;
+};
+
+static inline void drbg_string_fill(struct drbg_string *string,
+				    const unsigned char *buf, size_t len)
+{
+	string->buf = buf;
+	string->len = len;
+	string->next = NULL;
+}
+
+struct drbg_state;
+typedef uint32_t drbg_flag_t;
+
+struct drbg_core {
+	drbg_flag_t flags;	/* flags for the cipher */
+	__u8 statelen;		/* maximum state length */
+	/*
+	 * maximum length of personalization string or additional input
+	 * string -- exponent for base 2
+	 */
+	__u8 max_addtllen;
+	/* maximum bits per RNG request -- exponent for base 2*/
+	__u8 max_bits;
+	/* maximum number of requests -- exponent for base 2 */
+	__u8 max_req;
+	__u8 blocklen_bytes;	/* block size of output in bytes */
+	char cra_name[CRYPTO_MAX_ALG_NAME]; /* mapping to kernel crypto API */
+	 /* kernel crypto API backend cipher name */
+	char backend_cra_name[CRYPTO_MAX_ALG_NAME];
+};
+
+struct drbg_state_ops {
+	int (*update)(struct drbg_state *drbg, struct drbg_string *seed,
+		      int reseed);
+	int (*generate)(struct drbg_state *drbg,
+			unsigned char *buf, unsigned int buflen,
+			struct drbg_string *addtl);
+	int (*crypto_init)(struct drbg_state *drbg);
+	int (*crypto_fini)(struct drbg_state *drbg);
+
+};
+
+struct drbg_test_data {
+	struct drbg_string *testentropy; /* TEST PARAMETER: test entropy */
+};
+
+struct drbg_state {
+	spinlock_t drbg_lock;	/* lock around DRBG */
+	unsigned char *V;	/* internal state 10.1.1.1 1a) */
+	/* hash: static value 10.1.1.1 1b) hmac / ctr: key */
+	unsigned char *C;
+	/* Number of RNG requests since last reseed -- 10.1.1.1 1c) */
+	size_t reseed_ctr;
+	 /* some memory the DRBG can use for its operation */
+	unsigned char *scratchpad;
+	void *priv_data;	/* Cipher handle */
+	bool seeded;		/* DRBG fully seeded? */
+	bool pr;		/* Prediction resistance enabled? */
+#ifdef CONFIG_CRYPTO_FIPS
+	bool fips_primed;	/* Continuous test primed? */
+	unsigned char *prev;	/* FIPS 140-2 continuous test value */
+#endif
+	const struct drbg_state_ops *d_ops;
+	const struct drbg_core *core;
+	struct drbg_test_data *test_data;
+};
+
+static inline __u8 drbg_statelen(struct drbg_state *drbg)
+{
+	if (drbg && drbg->core)
+		return drbg->core->statelen;
+	return 0;
+}
+
+static inline __u8 drbg_blocklen(struct drbg_state *drbg)
+{
+	if (drbg && drbg->core)
+		return drbg->core->blocklen_bytes;
+	return 0;
+}
+
+static inline __u8 drbg_keylen(struct drbg_state *drbg)
+{
+	if (drbg && drbg->core)
+		return (drbg->core->statelen - drbg->core->blocklen_bytes);
+	return 0;
+}
+
+static inline size_t drbg_max_request_bytes(struct drbg_state *drbg)
+{
+	/* max_bits is in bits, but buflen is in bytes */
+	return (1 << (drbg->core->max_bits - 3));
+}
+
+static inline size_t drbg_max_addtl(struct drbg_state *drbg)
+{
+	return (1UL<<(drbg->core->max_addtllen));
+}
+
+static inline size_t drbg_max_requests(struct drbg_state *drbg)
+{
+	return (1UL<<(drbg->core->max_req));
+}
+
+/*
+ * kernel crypto API input data structure for DRBG generate in case dlen
+ * is set to 0
+ */
+struct drbg_gen {
+	unsigned char *outbuf;	/* output buffer for random numbers */
+	unsigned int outlen;	/* size of output buffer */
+	struct drbg_string *addtl;	/* additional information string */
+	struct drbg_test_data *test_data;	/* test data */
+};
+
+/*
+ * This is a wrapper to the kernel crypto API function of
+ * crypto_rng_get_bytes() to allow the caller to provide additional data.
+ *
+ * @drng DRBG handle -- see crypto_rng_get_bytes
+ * @outbuf output buffer -- see crypto_rng_get_bytes
+ * @outlen length of output buffer -- see crypto_rng_get_bytes
+ * @addtl_input additional information string input buffer
+ * @addtllen length of additional information string buffer
+ *
+ * return
+ *	see crypto_rng_get_bytes
+ */
+static inline int crypto_drbg_get_bytes_addtl(struct crypto_rng *drng,
+			unsigned char *outbuf, unsigned int outlen,
+			struct drbg_string *addtl)
+{
+	int ret;
+	struct drbg_gen genbuf;
+	genbuf.outbuf = outbuf;
+	genbuf.outlen = outlen;
+	genbuf.addtl = addtl;
+	genbuf.test_data = NULL;
+	ret = crypto_rng_get_bytes(drng, (u8 *)&genbuf, 0);
+	return ret;
+}
+
+/*
+ * TEST code
+ *
+ * This is a wrapper to the kernel crypto API function of
+ * crypto_rng_get_bytes() to allow the caller to provide additional data and
+ * allow furnishing of test_data
+ *
+ * @drng DRBG handle -- see crypto_rng_get_bytes
+ * @outbuf output buffer -- see crypto_rng_get_bytes
+ * @outlen length of output buffer -- see crypto_rng_get_bytes
+ * @addtl_input additional information string input buffer
+ * @addtllen length of additional information string buffer
+ * @test_data filled test data
+ *
+ * return
+ *	see crypto_rng_get_bytes
+ */
+static inline int crypto_drbg_get_bytes_addtl_test(struct crypto_rng *drng,
+			unsigned char *outbuf, unsigned int outlen,
+			struct drbg_string *addtl,
+			struct drbg_test_data *test_data)
+{
+	int ret;
+	struct drbg_gen genbuf;
+	genbuf.outbuf = outbuf;
+	genbuf.outlen = outlen;
+	genbuf.addtl = addtl;
+	genbuf.test_data = test_data;
+	ret = crypto_rng_get_bytes(drng, (u8 *)&genbuf, 0);
+	return ret;
+}
+
+/*
+ * TEST code
+ *
+ * This is a wrapper to the kernel crypto API function of
+ * crypto_rng_reset() to allow the caller to provide test_data
+ *
+ * @drng DRBG handle -- see crypto_rng_reset
+ * @pers personalization string input buffer
+ * @perslen length of additional information string buffer
+ * @test_data filled test data
+ *
+ * return
+ *	see crypto_rng_reset
+ */
+static inline int crypto_drbg_reset_test(struct crypto_rng *drng,
+					 struct drbg_string *pers,
+					 struct drbg_test_data *test_data)
+{
+	int ret;
+	struct drbg_gen genbuf;
+	genbuf.outbuf = NULL;
+	genbuf.outlen = 0;
+	genbuf.addtl = pers;
+	genbuf.test_data = test_data;
+	ret = crypto_rng_reset(drng, (u8 *)&genbuf, 0);
+	return ret;
+}
+
+/* DRBG type flags */
+#define DRBG_CTR	((drbg_flag_t)1<<0)
+#define DRBG_HMAC	((drbg_flag_t)1<<1)
+#define DRBG_HASH	((drbg_flag_t)1<<2)
+#define DRBG_TYPE_MASK	(DRBG_CTR | DRBG_HMAC | DRBG_HASH)
+/* DRBG strength flags */
+#define DRBG_STRENGTH128	((drbg_flag_t)1<<3)
+#define DRBG_STRENGTH192	((drbg_flag_t)1<<4)
+#define DRBG_STRENGTH256	((drbg_flag_t)1<<5)
+#define DRBG_STRENGTH_MASK	(DRBG_STRENGTH128 | DRBG_STRENGTH192 | \
+				 DRBG_STRENGTH256)
+
+enum drbg_prefixes {
+	DRBG_PREFIX0 = 0x00,
+	DRBG_PREFIX1,
+	DRBG_PREFIX2,
+	DRBG_PREFIX3
+};
+
+#endif /* _DRBG_H */
