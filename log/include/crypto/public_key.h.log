commit b4d0d230ccfb5d1a9ea85da64aa584df7c148ee9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 36
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public licence as published by
      the free software foundation either version 2 of the licence or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 114 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.552531963@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 712fe1214b5f..0588ef3bc6ff 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -1,14 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /* Asymmetric public-key algorithm definitions
  *
  * See Documentation/crypto/asymmetric-keys.txt
  *
  * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
  * Written by David Howells (dhowells@redhat.com)
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public Licence
- * as published by the Free Software Foundation; either version
- * 2 of the Licence, or (at your option) any later version.
  */
 
 #ifndef _LINUX_PUBLIC_KEY_H

commit f1774cb8956a35269f539efcee99fe7eda838b77
Author: Vitaly Chikunov <vt@altlinux.org>
Date:   Thu Apr 11 18:51:17 2019 +0300

    X.509: parse public key parameters from x509 for akcipher
    
    Some public key algorithms (like EC-DSA) keep in parameters field
    important data such as digest and curve OIDs (possibly more for
    different EC-DSA variants). Thus, just setting a public key (as
    for RSA) is not enough.
    
    Append parameters into the key stream for akcipher_set_{pub,priv}_key.
    Appended data is: (u32) algo OID, (u32) parameters length, parameters
    data.
    
    This does not affect current akcipher API nor RSA ciphers (they could
    ignore it). Idea of appending parameters to the key stream is by Herbert
    Xu.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: Denis Kenzior <denkenz@gmail.com>
    Cc: keyrings@vger.kernel.org
    Signed-off-by: Vitaly Chikunov <vt@altlinux.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index be626eac9113..712fe1214b5f 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -15,6 +15,7 @@
 #define _LINUX_PUBLIC_KEY_H
 
 #include <linux/keyctl.h>
+#include <linux/oid_registry.h>
 
 /*
  * Cryptographic data for the public-key subtype of the asymmetric key type.
@@ -25,6 +26,9 @@
 struct public_key {
 	void *key;
 	u32 keylen;
+	enum OID algo;
+	void *params;
+	u32 paramlen;
 	bool key_is_private;
 	const char *id_type;
 	const char *pkey_algo;

commit f7c4e06e066c3df282e6e3d4e7d8c498be9e1e46
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 9 17:47:31 2018 +0100

    KEYS: Allow the public_key struct to hold a private key [ver #2]
    
    Put a flag in the public_key struct to indicate if the structure is holding
    a private key.  The private key must be held ASN.1 encoded in the format
    specified in RFC 3447 A.1.2.  This is the form required by crypto/rsa.c.
    
    The software encryption subtype's verification and query functions then
    need to select the appropriate crypto function to set the key.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Tested-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 3a1047a0195c..be626eac9113 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -25,6 +25,7 @@
 struct public_key {
 	void *key;
 	u32 keylen;
+	bool key_is_private;
 	const char *id_type;
 	const char *pkey_algo;
 };

commit 5a30771832aab228e0863e414f9182f86797429e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 9 17:47:07 2018 +0100

    KEYS: Provide missing asymmetric key subops for new key type ops [ver #2]
    
    Provide the missing asymmetric key subops for new key type ops.  This
    include query, encrypt, decrypt and create signature.  Verify signature
    already exists.  Also provided are accessor functions for this:
    
            int query_asymmetric_key(const struct key *key,
                                     struct kernel_pkey_query *info);
    
            int encrypt_blob(struct kernel_pkey_params *params,
                             const void *data, void *enc);
            int decrypt_blob(struct kernel_pkey_params *params,
                             const void *enc, void *data);
            int create_signature(struct kernel_pkey_params *params,
                                 const void *data, void *enc);
    
    The public_key_signature struct gains an encoding field to carry the
    encoding for verify_signature().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Tested-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index e0b681a717ba..3a1047a0195c 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -14,6 +14,8 @@
 #ifndef _LINUX_PUBLIC_KEY_H
 #define _LINUX_PUBLIC_KEY_H
 
+#include <linux/keyctl.h>
+
 /*
  * Cryptographic data for the public-key subtype of the asymmetric key type.
  *
@@ -40,6 +42,7 @@ struct public_key_signature {
 	u8 digest_size;		/* Number of bytes in digest */
 	const char *pkey_algo;
 	const char *hash_algo;
+	const char *encoding;
 };
 
 extern void public_key_signature_free(struct public_key_signature *sig);
@@ -65,8 +68,14 @@ extern int restrict_link_by_key_or_keyring_chain(struct key *trust_keyring,
 						 const union key_payload *payload,
 						 struct key *trusted);
 
-extern int verify_signature(const struct key *key,
-			    const struct public_key_signature *sig);
+extern int query_asymmetric_key(const struct kernel_pkey_params *,
+				struct kernel_pkey_query *);
+
+extern int encrypt_blob(struct kernel_pkey_params *, const void *, void *);
+extern int decrypt_blob(struct kernel_pkey_params *, const void *, void *);
+extern int create_signature(struct kernel_pkey_params *, const void *, void *);
+extern int verify_signature(const struct key *,
+			    const struct public_key_signature *);
 
 int public_key_verify_signature(const struct public_key *pkey,
 				const struct public_key_signature *sig);

commit 8e323a02e866014091180443ccb186fee1e3d30d
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Oct 4 16:42:45 2016 -0700

    KEYS: Keyring asymmetric key restrict method with chaining
    
    Add a restrict_link_by_key_or_keyring_chain link restriction that
    searches for signing keys in the destination keyring in addition to the
    signing key or keyring designated when the destination keyring was
    created. Userspace enables this behavior by including the "chain" option
    in the keyring restriction:
    
      keyctl(KEYCTL_RESTRICT_KEYRING, keyring, "asymmetric",
             "key_or_keyring:<signing key>:chain");
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index bb6a884352a5..e0b681a717ba 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -60,6 +60,11 @@ extern int restrict_link_by_key_or_keyring(struct key *dest_keyring,
 					   const union key_payload *payload,
 					   struct key *trusted);
 
+extern int restrict_link_by_key_or_keyring_chain(struct key *trust_keyring,
+						 const struct key_type *type,
+						 const union key_payload *payload,
+						 struct key *trusted);
+
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 

commit 7e3c4d22083f6e7316c5229b6197ca2d5335aa35
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Mon Jun 27 16:45:16 2016 -0700

    KEYS: Restrict asymmetric key linkage using a specific keychain
    
    Adds restrict_link_by_signature_keyring(), which uses the restrict_key
    member of the provided destination_keyring data structure as the
    key or keyring to search for signing keys.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index ec0262fa08f8..bb6a884352a5 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -55,6 +55,11 @@ extern int restrict_link_by_signature(struct key *dest_keyring,
 				      const union key_payload *payload,
 				      struct key *trust_keyring);
 
+extern int restrict_link_by_key_or_keyring(struct key *dest_keyring,
+					   const struct key_type *type,
+					   const union key_payload *payload,
+					   struct key *trusted);
+
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 

commit aaf66c883813f0078e3dafe7d20d1461321ac14f
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Aug 30 11:33:13 2016 -0700

    KEYS: Split role of the keyring pointer for keyring restrict functions
    
    The first argument to the restrict_link_func_t functions was a keyring
    pointer. These functions are called by the key subsystem with this
    argument set to the destination keyring, but restrict_link_by_signature
    expects a pointer to the relevant trusted keyring.
    
    Restrict functions may need something other than a single struct key
    pointer to allow or reject key linkage, so the data used to make that
    decision (such as the trust keyring) is moved to a new, fourth
    argument. The first argument is now always the destination keyring.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 882ca0e1e7a5..ec0262fa08f8 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -50,9 +50,10 @@ struct key;
 struct key_type;
 union key_payload;
 
-extern int restrict_link_by_signature(struct key *trust_keyring,
+extern int restrict_link_by_signature(struct key *dest_keyring,
 				      const struct key_type *type,
-				      const union key_payload *payload);
+				      const union key_payload *payload,
+				      struct key *trust_keyring);
 
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);

commit a511e1af8b12f44c6e55786c463c9f093c214fb6
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:26 2016 +0100

    KEYS: Move the point of trust determination to __key_link()
    
    Move the point at which a key is determined to be trustworthy to
    __key_link() so that we use the contents of the keyring being linked in to
    to determine whether the key being linked in is trusted or not.
    
    What is 'trusted' then becomes a matter of what's in the keyring.
    
    Currently, the test is done when the key is parsed, but given that at that
    point we can only sensibly refer to the contents of the system trusted
    keyring, we can only use that as the basis for working out the
    trustworthiness of a new key.
    
    With this change, a trusted keyring is a set of keys that once the
    trusted-only flag is set cannot be added to except by verification through
    one of the contained keys.
    
    Further, adding a key into a trusted keyring, whilst it might grant
    trustworthiness in the context of that keyring, does not automatically
    grant trustworthiness in the context of a second keyring to which it could
    be secondarily linked.
    
    To accomplish this, the authentication data associated with the key source
    must now be retained.  For an X.509 cert, this means the contents of the
    AuthorityKeyIdentifier and the signature data.
    
    
    If system keyrings are disabled then restrict_link_by_builtin_trusted()
    resolves to restrict_link_reject().  The integrity digital signature code
    still works correctly with this as it was previously using
    KEY_FLAG_TRUSTED_ONLY, which doesn't permit anything to be added if there
    is no system keyring against which trust can be determined.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 96ef27b8dd41..882ca0e1e7a5 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -47,6 +47,13 @@ extern void public_key_signature_free(struct public_key_signature *sig);
 extern struct asymmetric_key_subtype public_key_subtype;
 
 struct key;
+struct key_type;
+union key_payload;
+
+extern int restrict_link_by_signature(struct key *trust_keyring,
+				      const struct key_type *type,
+				      const union key_payload *payload);
+
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 

commit 983023f28bff62b4462fd3575a86a8947ac592d8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:25 2016 +0100

    KEYS: Move x509_request_asymmetric_key() to asymmetric_type.c
    
    Move x509_request_asymmetric_key() to asymmetric_type.c so that it can be
    generalised.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index b3928e801b8c..96ef27b8dd41 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -50,12 +50,6 @@ struct key;
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 
-struct asymmetric_key_id;
-extern struct key *x509_request_asymmetric_key(struct key *keyring,
-					       const struct asymmetric_key_id *id,
-					       const struct asymmetric_key_id *skid,
-					       bool partial);
-
 int public_key_verify_signature(const struct public_key *pkey,
 				const struct public_key_signature *sig);
 

commit e68503bd6836ba765dc8e0ee77ea675fedc07e41
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:14:24 2016 +0100

    KEYS: Generalise system_verify_data() to provide access to internal content
    
    Generalise system_verify_data() to provide access to internal content
    through a callback.  This allows all the PKCS#7 stuff to be hidden inside
    this function and removed from the PE file parser and the PKCS#7 test key.
    
    If external content is not required, NULL should be passed as data to the
    function.  If the callback is not required, that can be set to NULL.
    
    The function is now called verify_pkcs7_signature() to contrast with
    verify_pefile_signature() and the definitions of both have been moved into
    linux/verification.h along with the key_being_used_for enum.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 2f5de5c1a3a0..b3928e801b8c 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -14,20 +14,6 @@
 #ifndef _LINUX_PUBLIC_KEY_H
 #define _LINUX_PUBLIC_KEY_H
 
-/*
- * The use to which an asymmetric key is being put.
- */
-enum key_being_used_for {
-	VERIFYING_MODULE_SIGNATURE,
-	VERIFYING_FIRMWARE_SIGNATURE,
-	VERIFYING_KEXEC_PE_SIGNATURE,
-	VERIFYING_KEY_SIGNATURE,
-	VERIFYING_KEY_SELF_SIGNATURE,
-	VERIFYING_UNSPECIFIED_SIGNATURE,
-	NR__KEY_BEING_USED_FOR
-};
-extern const char *const key_being_used_for[NR__KEY_BEING_USED_FOR];
-
 /*
  * Cryptographic data for the public-key subtype of the asymmetric key type.
  *

commit a022ec02691cf68e1fe237d5f79d54aa95446cc6
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:13:33 2016 +0100

    KEYS: Add identifier pointers to public_key_signature struct
    
    Add key identifier pointers to public_key_signature struct so that they can
    be used to retain the identifier of the key to be used to verify the
    signature in both PKCS#7 and X.509.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 19f557ca50ba..2f5de5c1a3a0 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -47,6 +47,7 @@ extern void public_key_free(struct public_key *key);
  * Public key cryptography signature data
  */
 struct public_key_signature {
+	struct asymmetric_key_id *auth_ids[2];
 	u8 *s;			/* Signature */
 	u32 s_size;		/* Number of bytes in signature */
 	u8 *digest;

commit 3b764563177c1e435ef3e2608271c07955f73ea6
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 6 16:13:33 2016 +0100

    KEYS: Allow authentication data to be stored in an asymmetric key
    
    Allow authentication data to be stored in an asymmetric key in the 4th
    element of the key payload and provide a way for it to be destroyed.
    
    For the public key subtype, this will be a public_key_signature struct.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index aa730ea7faf8..19f557ca50ba 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -41,7 +41,7 @@ struct public_key {
 	const char *pkey_algo;
 };
 
-extern void public_key_destroy(void *payload);
+extern void public_key_free(struct public_key *key);
 
 /*
  * Public key cryptography signature data
@@ -55,7 +55,10 @@ struct public_key_signature {
 	const char *hash_algo;
 };
 
+extern void public_key_signature_free(struct public_key_signature *sig);
+
 extern struct asymmetric_key_subtype public_key_subtype;
+
 struct key;
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);

commit 4e8ae72a75aae285ec5b93518b9680da198afd0d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 3 21:49:27 2016 +0000

    X.509: Make algo identifiers text instead of enum
    
    Make the identifier public key and digest algorithm fields text instead of
    enum.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 80ab099a3edf..aa730ea7faf8 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -14,28 +14,6 @@
 #ifndef _LINUX_PUBLIC_KEY_H
 #define _LINUX_PUBLIC_KEY_H
 
-#include <crypto/hash_info.h>
-
-enum pkey_algo {
-	PKEY_ALGO_DSA,
-	PKEY_ALGO_RSA,
-	PKEY_ALGO__LAST
-};
-
-extern const char *const pkey_algo_name[PKEY_ALGO__LAST];
-
-/* asymmetric key implementation supports only up to SHA224 */
-#define PKEY_HASH__LAST		(HASH_ALGO_SHA224 + 1)
-
-enum pkey_id_type {
-	PKEY_ID_PGP,		/* OpenPGP generated key ID */
-	PKEY_ID_X509,		/* X.509 arbitrary subjectKeyIdentifier */
-	PKEY_ID_PKCS7,		/* Signature in PKCS#7 message */
-	PKEY_ID_TYPE__LAST
-};
-
-extern const char *const pkey_id_type_name[PKEY_ID_TYPE__LAST];
-
 /*
  * The use to which an asymmetric key is being put.
  */
@@ -59,8 +37,8 @@ extern const char *const key_being_used_for[NR__KEY_BEING_USED_FOR];
 struct public_key {
 	void *key;
 	u32 keylen;
-	enum pkey_algo pkey_algo : 8;
-	enum pkey_id_type id_type : 8;
+	const char *id_type;
+	const char *pkey_algo;
 };
 
 extern void public_key_destroy(void *payload);
@@ -73,8 +51,8 @@ struct public_key_signature {
 	u32 s_size;		/* Number of bytes in signature */
 	u8 *digest;
 	u8 digest_size;		/* Number of bytes in digest */
-	enum pkey_algo pkey_algo : 8;
-	enum hash_algo pkey_hash_algo : 8;
+	const char *pkey_algo;
+	const char *hash_algo;
 };
 
 extern struct asymmetric_key_subtype public_key_subtype;

commit d43de6c780a84def056afaf4fb3e66bdaa1efc00
Author: David Howells <dhowells@redhat.com>
Date:   Thu Mar 3 21:49:27 2016 +0000

    akcipher: Move the RSA DER encoding check to the crypto layer
    
    Move the RSA EMSA-PKCS1-v1_5 encoding from the asymmetric-key public_key
    subtype to the rsa crypto module's pkcs1pad template.  This means that the
    public_key subtype no longer has any dependencies on public key type.
    
    To make this work, the following changes have been made:
    
     (1) The rsa pkcs1pad template is now used for RSA keys.  This strips off the
         padding and returns just the message hash.
    
     (2) In a previous patch, the pkcs1pad template gained an optional second
         parameter that, if given, specifies the hash used.  We now give this,
         and pkcs1pad checks the encoded message E(M) for the EMSA-PKCS1-v1_5
         encoding and verifies that the correct digest OID is present.
    
     (3) The crypto driver in crypto/asymmetric_keys/rsa.c is now reduced to
         something that doesn't care about what the encryption actually does
         and and has been merged into public_key.c.
    
     (4) CONFIG_PUBLIC_KEY_ALGO_RSA is gone.  Module signing must set
         CONFIG_CRYPTO_RSA=y instead.
    
    Thoughts:
    
     (*) Should the encoding style (eg. raw, EMSA-PKCS1-v1_5) also be passed to
         the padding template?  Should there be multiple padding templates
         registered that share most of the code?
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index a1693ed77be6..80ab099a3edf 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -91,6 +91,4 @@ extern struct key *x509_request_asymmetric_key(struct key *keyring,
 int public_key_verify_signature(const struct public_key *pkey,
 				const struct public_key_signature *sig);
 
-int rsa_verify_signature(const struct public_key *pkey,
-			 const struct public_key_signature *sig);
 #endif /* _LINUX_PUBLIC_KEY_H */

commit d846e78e491ff4dd0747026c02414844d504fcb6
Author: Tadeusz Struk <tadeusz.struk@intel.com>
Date:   Tue Feb 2 10:09:03 2016 -0800

    crypto: public_key: remove MPIs from public_key_signature struct
    
    After digsig_asymmetric.c is converted the MPIs can be now
    safely removed from the public_key_signature structure.
    
    Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 50ac8759d7ee..a1693ed77be6 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -14,7 +14,6 @@
 #ifndef _LINUX_PUBLIC_KEY_H
 #define _LINUX_PUBLIC_KEY_H
 
-#include <linux/mpi.h>
 #include <crypto/hash_info.h>
 
 enum pkey_algo {
@@ -73,20 +72,9 @@ struct public_key_signature {
 	u8 *s;			/* Signature */
 	u32 s_size;		/* Number of bytes in signature */
 	u8 *digest;
-	u8 digest_size;			/* Number of bytes in digest */
-	u8 nr_mpi;			/* Occupancy of mpi[] */
+	u8 digest_size;		/* Number of bytes in digest */
 	enum pkey_algo pkey_algo : 8;
 	enum hash_algo pkey_hash_algo : 8;
-	union {
-		MPI mpi[2];
-		struct {
-			MPI s;		/* m^d mod n */
-		} rsa;
-		struct {
-			MPI r;
-			MPI s;
-		} dsa;
-	};
 };
 
 extern struct asymmetric_key_subtype public_key_subtype;

commit db6c43bd2132dc2dd63d73a6d1ed601cffd0ae06
Author: Tadeusz Struk <tadeusz.struk@intel.com>
Date:   Tue Feb 2 10:08:53 2016 -0800

    crypto: KEYS: convert public key and digsig asym to the akcipher api
    
    This patch converts the module verification code to the new akcipher API.
    
    Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index cc2516df0efa..50ac8759d7ee 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -24,7 +24,6 @@ enum pkey_algo {
 };
 
 extern const char *const pkey_algo_name[PKEY_ALGO__LAST];
-extern const struct public_key_algorithm *pkey_algo[PKEY_ALGO__LAST];
 
 /* asymmetric key implementation supports only up to SHA224 */
 #define PKEY_HASH__LAST		(HASH_ALGO_SHA224 + 1)
@@ -59,31 +58,10 @@ extern const char *const key_being_used_for[NR__KEY_BEING_USED_FOR];
  * part.
  */
 struct public_key {
-	const struct public_key_algorithm *algo;
-	u8	capabilities;
-#define PKEY_CAN_ENCRYPT	0x01
-#define PKEY_CAN_DECRYPT	0x02
-#define PKEY_CAN_SIGN		0x04
-#define PKEY_CAN_VERIFY		0x08
+	void *key;
+	u32 keylen;
 	enum pkey_algo pkey_algo : 8;
 	enum pkey_id_type id_type : 8;
-	union {
-		MPI	mpi[5];
-		struct {
-			MPI	p;	/* DSA prime */
-			MPI	q;	/* DSA group order */
-			MPI	g;	/* DSA group generator */
-			MPI	y;	/* DSA public-key value = g^x mod p */
-			MPI	x;	/* DSA secret exponent (if present) */
-		} dsa;
-		struct {
-			MPI	n;	/* RSA public modulus */
-			MPI	e;	/* RSA public encryption exponent */
-			MPI	d;	/* RSA secret encryption exponent (if present) */
-			MPI	p;	/* RSA secret prime (if present) */
-			MPI	q;	/* RSA secret prime (if present) */
-		} rsa;
-	};
 };
 
 extern void public_key_destroy(void *payload);
@@ -92,6 +70,8 @@ extern void public_key_destroy(void *payload);
  * Public key cryptography signature data
  */
 struct public_key_signature {
+	u8 *s;			/* Signature */
+	u32 s_size;		/* Number of bytes in signature */
 	u8 *digest;
 	u8 digest_size;			/* Number of bytes in digest */
 	u8 nr_mpi;			/* Occupancy of mpi[] */
@@ -109,6 +89,7 @@ struct public_key_signature {
 	};
 };
 
+extern struct asymmetric_key_subtype public_key_subtype;
 struct key;
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
@@ -119,4 +100,9 @@ extern struct key *x509_request_asymmetric_key(struct key *keyring,
 					       const struct asymmetric_key_id *skid,
 					       bool partial);
 
+int public_key_verify_signature(const struct public_key *pkey,
+				const struct public_key_signature *sig);
+
+int rsa_verify_signature(const struct public_key *pkey,
+			 const struct public_key_signature *sig);
 #endif /* _LINUX_PUBLIC_KEY_H */

commit 146aa8b1453bd8f1ff2304ffb71b4ee0eb9acdcc
Author: David Howells <dhowells@redhat.com>
Date:   Wed Oct 21 14:04:48 2015 +0100

    KEYS: Merge the type-specific data with the payload data
    
    Merge the type-specific data with the payload data into one four-word chunk
    as it seems pointless to keep them separate.
    
    Use user_key_payload() for accessing the payloads of overloaded
    user-defined keys.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-cifs@vger.kernel.org
    cc: ecryptfs@vger.kernel.org
    cc: linux-ext4@vger.kernel.org
    cc: linux-f2fs-devel@lists.sourceforge.net
    cc: linux-nfs@vger.kernel.org
    cc: ceph-devel@vger.kernel.org
    cc: linux-ima-devel@lists.sourceforge.net

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 067c242b1e15..cc2516df0efa 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -15,7 +15,6 @@
 #define _LINUX_PUBLIC_KEY_H
 
 #include <linux/mpi.h>
-#include <keys/asymmetric-type.h>
 #include <crypto/hash_info.h>
 
 enum pkey_algo {

commit 99db44350672c8a5ee9a7b0a6f4cd6ff10136065
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 5 15:22:27 2015 +0100

    PKCS#7: Appropriately restrict authenticated attributes and content type
    
    A PKCS#7 or CMS message can have per-signature authenticated attributes
    that are digested as a lump and signed by the authorising key for that
    signature.  If such attributes exist, the content digest isn't itself
    signed, but rather it is included in a special authattr which then
    contributes to the signature.
    
    Further, we already require the master message content type to be
    pkcs7_signedData - but there's also a separate content type for the data
    itself within the SignedData object and this must be repeated inside the
    authattrs for each signer [RFC2315 9.2, RFC5652 11.1].
    
    We should really validate the authattrs if they exist or forbid them
    entirely as appropriate.  To this end:
    
     (1) Alter the PKCS#7 parser to reject any message that has more than one
         signature where at least one signature has authattrs and at least one
         that does not.
    
     (2) Validate authattrs if they are present and strongly restrict them.
         Only the following authattrs are permitted and all others are
         rejected:
    
         (a) contentType.  This is checked to be an OID that matches the
             content type in the SignedData object.
    
         (b) messageDigest.  This must match the crypto digest of the data.
    
         (c) signingTime.  If present, we check that this is a valid, parseable
             UTCTime or GeneralTime and that the date it encodes fits within
             the validity window of the matching X.509 cert.
    
         (d) S/MIME capabilities.  We don't check the contents.
    
         (e) Authenticode SP Opus Info.  We don't check the contents.
    
         (f) Authenticode Statement Type.  We don't check the contents.
    
         The message is rejected if (a) or (b) are missing.  If the message is
         an Authenticode type, the message is rejected if (e) is missing; if
         not Authenticode, the message is rejected if (d) - (f) are present.
    
         The S/MIME capabilities authattr (d) unfortunately has to be allowed
         to support kernels already signed by the pesign program.  This only
         affects kexec.  sign-file suppresses them (CMS_NOSMIMECAP).
    
         The message is also rejected if an authattr is given more than once or
         if it contains more than one element in its set of values.
    
     (3) Add a parameter to pkcs7_verify() to select one of the following
         restrictions and pass in the appropriate option from the callers:
    
         (*) VERIFYING_MODULE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             forbids authattrs.  sign-file sets CMS_NOATTR.  We could be more
             flexible and permit authattrs optionally, but only permit minimal
             content.
    
         (*) VERIFYING_FIRMWARE_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data and
             requires authattrs.  In future, this will require an attribute
             holding the target firmware name in addition to the minimal set.
    
         (*) VERIFYING_UNSPECIFIED_SIGNATURE
    
             This requires that the SignedData content type be pkcs7-data but
             allows either no authattrs or only permits the minimal set.
    
         (*) VERIFYING_KEXEC_PE_SIGNATURE
    
             This only supports the Authenticode SPC_INDIRECT_DATA content type
             and requires at least an SpcSpOpusInfo authattr in addition to the
             minimal set.  It also permits an SPC_STATEMENT_TYPE authattr (and
             an S/MIME capabilities authattr because the pesign program doesn't
             remove these).
    
         (*) VERIFYING_KEY_SIGNATURE
         (*) VERIFYING_KEY_SELF_SIGNATURE
    
             These are invalid in this context but are included for later use
             when limiting the use of X.509 certs.
    
     (4) The pkcs7_test key type is given a module parameter to select between
         the above options for testing purposes.  For example:
    
            echo 1 >/sys/module/pkcs7_test_key/parameters/usage
            keyctl padd pkcs7_test foo @s </tmp/stuff.pkcs7
    
         will attempt to check the signature on stuff.pkcs7 as if it contains a
         firmware blob (1 being VERIFYING_FIRMWARE_SIGNATURE).
    
    Suggested-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index fda097e079a4..067c242b1e15 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -39,6 +39,20 @@ enum pkey_id_type {
 
 extern const char *const pkey_id_type_name[PKEY_ID_TYPE__LAST];
 
+/*
+ * The use to which an asymmetric key is being put.
+ */
+enum key_being_used_for {
+	VERIFYING_MODULE_SIGNATURE,
+	VERIFYING_FIRMWARE_SIGNATURE,
+	VERIFYING_KEXEC_PE_SIGNATURE,
+	VERIFYING_KEY_SIGNATURE,
+	VERIFYING_KEY_SELF_SIGNATURE,
+	VERIFYING_UNSPECIFIED_SIGNATURE,
+	NR__KEY_BEING_USED_FOR
+};
+extern const char *const key_being_used_for[NR__KEY_BEING_USED_FOR];
+
 /*
  * Cryptographic data for the public-key subtype of the asymmetric key type.
  *

commit bc1c373dd2a5113800360f7152be729c9da996cc
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 20 21:16:27 2015 +0100

    MODSIGN: Provide a utility to append a PKCS#7 signature to a module
    
    Provide a utility that:
    
     (1) Digests a module using the specified hash algorithm (typically sha256).
    
         [The digest can be dumped into a file by passing the '-d' flag]
    
     (2) Generates a PKCS#7 message that:
    
         (a) Has detached data (ie. the module content).
    
         (b) Is signed with the specified private key.
    
         (c) Refers to the specified X.509 certificate.
    
         (d) Has an empty X.509 certificate list.
    
         [The PKCS#7 message can be dumped into a file by passing the '-p' flag]
    
     (3) Generates a signed module by concatenating the old module, the PKCS#7
         message, a descriptor and a magic string.  The descriptor contains the
         size of the PKCS#7 message and indicates the id_type as PKEY_ID_PKCS7.
    
     (4) Either writes the signed module to the specified destination or renames
         it over the source module.
    
    This allows module signing to reuse the PKCS#7 handling code that was added
    for PE file parsing for signed kexec.
    
    Note that the utility is written in C and must be linked against the OpenSSL
    crypto library.
    
    Note further that I have temporarily dropped support for handling externally
    created signatures until we can work out the best way to do those.  Hopefully,
    whoever creates the signature can give me a PKCS#7 certificate.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index b6f27a240856..fda097e079a4 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -33,6 +33,7 @@ extern const struct public_key_algorithm *pkey_algo[PKEY_ALGO__LAST];
 enum pkey_id_type {
 	PKEY_ID_PGP,		/* OpenPGP generated key ID */
 	PKEY_ID_X509,		/* X.509 arbitrary subjectKeyIdentifier */
+	PKEY_ID_PKCS7,		/* Signature in PKCS#7 message */
 	PKEY_ID_TYPE__LAST
 };
 

commit 4573b64a31cd8cb4cfeb1d1b95536cfe71980cf4
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 20 21:16:26 2015 +0100

    X.509: Support X.509 lookup by Issuer+Serial form AuthorityKeyIdentifier
    
    If an X.509 certificate has an AuthorityKeyIdentifier extension that provides
    an issuer and serialNumber, then make it so that these are used in preference
    to the keyIdentifier field also held therein for searching for the signing
    certificate.
    
    If both the issuer+serialNumber and the keyIdentifier are supplied, then the
    certificate is looked up by the former but the latter is checked as well.  If
    the latter doesn't match the subjectKeyIdentifier of the parent certificate,
    EKEYREJECTED is returned.
    
    This makes it possible to chain X.509 certificates based on the issuer and
    serialNumber fields rather than on subjectKeyIdentifier.  This is necessary as
    we are having to deal with keys that are represented by X.509 certificates
    that lack a subjectKeyIdentifier.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 54add2069901..b6f27a240856 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -101,7 +101,8 @@ extern int verify_signature(const struct key *key,
 
 struct asymmetric_key_id;
 extern struct key *x509_request_asymmetric_key(struct key *keyring,
-					       const struct asymmetric_key_id *kid,
+					       const struct asymmetric_key_id *id,
+					       const struct asymmetric_key_id *skid,
 					       bool partial);
 
 #endif /* _LINUX_PUBLIC_KEY_H */

commit f1b731dbc2530cab93fcfc5fcb18c9f3a100feeb
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Mon Oct 6 15:21:05 2014 +0100

    KEYS: Restore partial ID matching functionality for asymmetric keys
    
    Bring back the functionality whereby an asymmetric key can be matched with a
    partial match on one of its IDs.
    
    Whilst we're at it, allow for the possibility of having an increased number of
    IDs.
    
    Reported-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index fa73a6fd536c..54add2069901 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -101,6 +101,7 @@ extern int verify_signature(const struct key *key,
 
 struct asymmetric_key_id;
 extern struct key *x509_request_asymmetric_key(struct key *keyring,
-					       const struct asymmetric_key_id *kid);
+					       const struct asymmetric_key_id *kid,
+					       bool partial);
 
 #endif /* _LINUX_PUBLIC_KEY_H */

commit 46963b774d441c833afc1535f6d84b3df2a94204
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 16 17:36:13 2014 +0100

    KEYS: Overhaul key identification when searching for asymmetric keys
    
    Make use of the new match string preparsing to overhaul key identification
    when searching for asymmetric keys.  The following changes are made:
    
     (1) Use the previously created asymmetric_key_id struct to hold the following
         key IDs derived from the X.509 certificate or PKCS#7 message:
    
            id: serial number + issuer
            skid: subjKeyId + subject
            authority: authKeyId + issuer
    
     (2) Replace the hex fingerprint attached to key->type_data[1] with an
         asymmetric_key_ids struct containing the id and the skid (if present).
    
     (3) Make the asymmetric_type match data preparse select one of two searches:
    
         (a) An iterative search for the key ID given if prefixed with "id:".  The
             prefix is expected to be followed by a hex string giving the ID to
             search for.  The criterion key ID is checked against all key IDs
             recorded on the key.
    
         (b) A direct search if the key ID is not prefixed with "id:".  This will
             look for an exact match on the key description.
    
     (4) Make x509_request_asymmetric_key() take a key ID.  This is then converted
         into "id:<hex>" and passed into keyring_search() where match preparsing
         will turn it back into a binary ID.
    
     (5) X.509 certificate verification then takes the authority key ID and looks
         up a key that matches it to find the public key for the certificate
         signature.
    
     (6) PKCS#7 certificate verification then takes the id key ID and looks up a
         key that matches it to find the public key for the signed information
         block signature.
    
    Additional changes:
    
     (1) Multiple subjKeyId and authKeyId values on an X.509 certificate cause the
         cert to be rejected with -EBADMSG.
    
     (2) The 'fingerprint' ID is gone.  This was primarily intended to convey PGP
         public key fingerprints.  If PGP is supported in future, this should
         generate a key ID that carries the fingerprint.
    
     (3) Th ca_keyid= kernel command line option is now converted to a key ID and
         used to match the authority key ID.  Possibly this should only match the
         actual authKeyId part and not the issuer as well.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Vivek Goyal <vgoyal@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 0d164c6af539..fa73a6fd536c 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -15,6 +15,7 @@
 #define _LINUX_PUBLIC_KEY_H
 
 #include <linux/mpi.h>
+#include <keys/asymmetric-type.h>
 #include <crypto/hash_info.h>
 
 enum pkey_algo {
@@ -98,8 +99,8 @@ struct key;
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 
+struct asymmetric_key_id;
 extern struct key *x509_request_asymmetric_key(struct key *keyring,
-					       const char *issuer,
-					       const char *key_id);
+					       const struct asymmetric_key_id *kid);
 
 #endif /* _LINUX_PUBLIC_KEY_H */

commit 5ce43ad28262115a1eab866392f8cfb985094160
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 28 14:11:32 2014 +0100

    PKCS#7: Use x509_request_asymmetric_key()
    
    pkcs7_request_asymmetric_key() and x509_request_asymmetric_key() do the same
    thing, the latter being a copy of the former created by the IMA folks, so drop
    the PKCS#7 version as the X.509 location is more general.
    
    Whilst we're at it, rename the arguments of x509_request_asymmetric_key() to
    better reflect what the values being passed in are intended to match on an
    X.509 cert.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index fc09732613ad..0d164c6af539 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -98,4 +98,8 @@ struct key;
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 
+extern struct key *x509_request_asymmetric_key(struct key *keyring,
+					       const char *issuer,
+					       const char *key_id);
+
 #endif /* _LINUX_PUBLIC_KEY_H */

commit 3fe78ca2fb1d61ea598e63fcbf38aec76b36b3a8
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Mon May 6 15:58:15 2013 +0300

    keys: change asymmetric keys to use common hash definitions
    
    This patch makes use of the newly defined common hash algorithm info,
    replacing, for example, PKEY_HASH with HASH_ALGO.
    
    Changelog:
    - Lindent fixes - Mimi
    
    CC: David Howells <dhowells@redhat.com>
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index b34fda4dcabf..fc09732613ad 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -15,6 +15,7 @@
 #define _LINUX_PUBLIC_KEY_H
 
 #include <linux/mpi.h>
+#include <crypto/hash_info.h>
 
 enum pkey_algo {
 	PKEY_ALGO_DSA,
@@ -25,19 +26,8 @@ enum pkey_algo {
 extern const char *const pkey_algo_name[PKEY_ALGO__LAST];
 extern const struct public_key_algorithm *pkey_algo[PKEY_ALGO__LAST];
 
-enum pkey_hash_algo {
-	PKEY_HASH_MD4,
-	PKEY_HASH_MD5,
-	PKEY_HASH_SHA1,
-	PKEY_HASH_RIPE_MD_160,
-	PKEY_HASH_SHA256,
-	PKEY_HASH_SHA384,
-	PKEY_HASH_SHA512,
-	PKEY_HASH_SHA224,
-	PKEY_HASH__LAST
-};
-
-extern const char *const pkey_hash_algo_name[PKEY_HASH__LAST];
+/* asymmetric key implementation supports only up to SHA224 */
+#define PKEY_HASH__LAST		(HASH_ALGO_SHA224 + 1)
 
 enum pkey_id_type {
 	PKEY_ID_PGP,		/* OpenPGP generated key ID */
@@ -91,7 +81,7 @@ struct public_key_signature {
 	u8 digest_size;			/* Number of bytes in digest */
 	u8 nr_mpi;			/* Occupancy of mpi[] */
 	enum pkey_algo pkey_algo : 8;
-	enum pkey_hash_algo pkey_hash_algo : 8;
+	enum hash_algo pkey_hash_algo : 8;
 	union {
 		MPI mpi[2];
 		struct {

commit 1573801fa89d022b9f5bd1b189d23221335f9f56
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:15:37 2013 +0100

    KEYS: Store public key algo ID in public_key_signature struct
    
    Store public key algorithm ID in public_key_signature struct for reference
    purposes.  This allows a public_key_signature struct to be embedded in
    struct x509_certificate and other places more easily.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 05778df0e3b4..b34fda4dcabf 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -90,6 +90,7 @@ struct public_key_signature {
 	u8 *digest;
 	u8 digest_size;			/* Number of bytes in digest */
 	u8 nr_mpi;			/* Occupancy of mpi[] */
+	enum pkey_algo pkey_algo : 8;
 	enum pkey_hash_algo pkey_hash_algo : 8;
 	union {
 		MPI mpi[2];

commit 67f7d60b3a08a3e3ec51c29c25767a9d9d0bd2b1
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:15:24 2013 +0100

    KEYS: Store public key algo ID in public_key struct
    
    Store public key algo ID in public_key struct for reference purposes.  This
    allows it to be removed from the x509_certificate struct and used to find a
    default in public_key_verify_signature().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 46bde250bfae..05778df0e3b4 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -60,6 +60,7 @@ struct public_key {
 #define PKEY_CAN_DECRYPT	0x02
 #define PKEY_CAN_SIGN		0x04
 #define PKEY_CAN_VERIFY		0x08
+	enum pkey_algo pkey_algo : 8;
 	enum pkey_id_type id_type : 8;
 	union {
 		MPI	mpi[5];

commit 206ce59a109f3b4bb352845bcd04f3cf504ae592
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:15:18 2013 +0100

    KEYS: Move the algorithm pointer array from x509 to public_key.c
    
    Move the public-key algorithm pointer array from x509_public_key.c to
    public_key.c as it isn't X.509 specific.
    
    Note that to make this configure correctly, the public key part must be
    dependent on the RSA module rather than the other way round.  This needs a
    further patch to make use of the crypto module loading stuff rather than using
    a fixed table.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 619d5706d837..46bde250bfae 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -23,6 +23,7 @@ enum pkey_algo {
 };
 
 extern const char *const pkey_algo_name[PKEY_ALGO__LAST];
+extern const struct public_key_algorithm *pkey_algo[PKEY_ALGO__LAST];
 
 enum pkey_hash_algo {
 	PKEY_HASH_MD4,

commit 9abc4e66eb839c28516916543768be08c814a3c8
Author: David Howells <dhowells@redhat.com>
Date:   Fri Aug 30 16:15:10 2013 +0100

    KEYS: Rename public key parameter name arrays
    
    Rename the arrays of public key parameters (public key algorithm names, hash
    algorithm names and ID type names) so that the array name ends in "_name".
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Josh Boyer <jwboyer@redhat.com>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index f5b0224c9967..619d5706d837 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -22,7 +22,7 @@ enum pkey_algo {
 	PKEY_ALGO__LAST
 };
 
-extern const char *const pkey_algo[PKEY_ALGO__LAST];
+extern const char *const pkey_algo_name[PKEY_ALGO__LAST];
 
 enum pkey_hash_algo {
 	PKEY_HASH_MD4,
@@ -36,7 +36,7 @@ enum pkey_hash_algo {
 	PKEY_HASH__LAST
 };
 
-extern const char *const pkey_hash_algo[PKEY_HASH__LAST];
+extern const char *const pkey_hash_algo_name[PKEY_HASH__LAST];
 
 enum pkey_id_type {
 	PKEY_ID_PGP,		/* OpenPGP generated key ID */
@@ -44,7 +44,7 @@ enum pkey_id_type {
 	PKEY_ID_TYPE__LAST
 };
 
-extern const char *const pkey_id_type[PKEY_ID_TYPE__LAST];
+extern const char *const pkey_id_type_name[PKEY_ID_TYPE__LAST];
 
 /*
  * Cryptographic data for the public-key subtype of the asymmetric key type.

commit 4ae71c1dce1e3d2270a0755988033e236b8e45d6
Author: David Howells <dhowells@redhat.com>
Date:   Fri Sep 21 23:25:04 2012 +0100

    KEYS: Provide signature verification with an asymmetric key
    
    Provide signature verification using an asymmetric-type key to indicate the
    public key to be used.
    
    The API is a single function that can be found in crypto/public_key.h:
    
            int verify_signature(const struct key *key,
                                 const struct public_key_signature *sig)
    
    The first argument is the appropriate key to be used and the second argument
    is the parsed signature data:
    
            struct public_key_signature {
                    u8 *digest;
                    u16 digest_size;
                    enum pkey_hash_algo pkey_hash_algo : 8;
                    union {
                            MPI mpi[2];
                            struct {
                                    MPI s;          /* m^d mod n */
                            } rsa;
                            struct {
                                    MPI r;
                                    MPI s;
                            } dsa;
                    };
            };
    
    This should be filled in prior to calling the function.  The hash algorithm
    should already have been called and the hash finalised and the output should
    be in a buffer pointed to by the 'digest' member.
    
    Any extra data to be added to the hash by the hash format (eg. PGP) should
    have been added by the caller prior to finalising the hash.
    
    It is assumed that the signature is made up of a number of MPI values.  If an
    algorithm becomes available for which this is not the case, the above structure
    will have to change.
    
    It is also assumed that it will have been checked that the signature algorithm
    matches the key algorithm.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index 4b8b6c16eac6..f5b0224c9967 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -101,4 +101,8 @@ struct public_key_signature {
 	};
 };
 
+struct key;
+extern int verify_signature(const struct key *key,
+			    const struct public_key_signature *sig);
+
 #endif /* _LINUX_PUBLIC_KEY_H */

commit a9681bf3dd7ccd2b32eba27d327ab76607429f7a
Author: David Howells <dhowells@redhat.com>
Date:   Fri Sep 21 23:24:55 2012 +0100

    KEYS: Asymmetric public-key algorithm crypto key subtype
    
    Add a subtype for supporting asymmetric public-key encryption algorithms such
    as DSA (FIPS-186) and RSA (PKCS#1 / RFC1337).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
new file mode 100644
index 000000000000..4b8b6c16eac6
--- /dev/null
+++ b/include/crypto/public_key.h
@@ -0,0 +1,104 @@
+/* Asymmetric public-key algorithm definitions
+ *
+ * See Documentation/crypto/asymmetric-keys.txt
+ *
+ * Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_PUBLIC_KEY_H
+#define _LINUX_PUBLIC_KEY_H
+
+#include <linux/mpi.h>
+
+enum pkey_algo {
+	PKEY_ALGO_DSA,
+	PKEY_ALGO_RSA,
+	PKEY_ALGO__LAST
+};
+
+extern const char *const pkey_algo[PKEY_ALGO__LAST];
+
+enum pkey_hash_algo {
+	PKEY_HASH_MD4,
+	PKEY_HASH_MD5,
+	PKEY_HASH_SHA1,
+	PKEY_HASH_RIPE_MD_160,
+	PKEY_HASH_SHA256,
+	PKEY_HASH_SHA384,
+	PKEY_HASH_SHA512,
+	PKEY_HASH_SHA224,
+	PKEY_HASH__LAST
+};
+
+extern const char *const pkey_hash_algo[PKEY_HASH__LAST];
+
+enum pkey_id_type {
+	PKEY_ID_PGP,		/* OpenPGP generated key ID */
+	PKEY_ID_X509,		/* X.509 arbitrary subjectKeyIdentifier */
+	PKEY_ID_TYPE__LAST
+};
+
+extern const char *const pkey_id_type[PKEY_ID_TYPE__LAST];
+
+/*
+ * Cryptographic data for the public-key subtype of the asymmetric key type.
+ *
+ * Note that this may include private part of the key as well as the public
+ * part.
+ */
+struct public_key {
+	const struct public_key_algorithm *algo;
+	u8	capabilities;
+#define PKEY_CAN_ENCRYPT	0x01
+#define PKEY_CAN_DECRYPT	0x02
+#define PKEY_CAN_SIGN		0x04
+#define PKEY_CAN_VERIFY		0x08
+	enum pkey_id_type id_type : 8;
+	union {
+		MPI	mpi[5];
+		struct {
+			MPI	p;	/* DSA prime */
+			MPI	q;	/* DSA group order */
+			MPI	g;	/* DSA group generator */
+			MPI	y;	/* DSA public-key value = g^x mod p */
+			MPI	x;	/* DSA secret exponent (if present) */
+		} dsa;
+		struct {
+			MPI	n;	/* RSA public modulus */
+			MPI	e;	/* RSA public encryption exponent */
+			MPI	d;	/* RSA secret encryption exponent (if present) */
+			MPI	p;	/* RSA secret prime (if present) */
+			MPI	q;	/* RSA secret prime (if present) */
+		} rsa;
+	};
+};
+
+extern void public_key_destroy(void *payload);
+
+/*
+ * Public key cryptography signature data
+ */
+struct public_key_signature {
+	u8 *digest;
+	u8 digest_size;			/* Number of bytes in digest */
+	u8 nr_mpi;			/* Occupancy of mpi[] */
+	enum pkey_hash_algo pkey_hash_algo : 8;
+	union {
+		MPI mpi[2];
+		struct {
+			MPI s;		/* m^d mod n */
+		} rsa;
+		struct {
+			MPI r;
+			MPI s;
+		} dsa;
+	};
+};
+
+#endif /* _LINUX_PUBLIC_KEY_H */
