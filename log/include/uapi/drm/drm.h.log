commit 455e00f1412fe51fa7bd21ad6fe0015b163fa9e5
Author: Daniel Stone <daniels@collabora.com>
Date:   Mon Dec 16 19:46:43 2019 -0800

    drm: Add getfb2 ioctl
    
    getfb2 allows us to pass multiple planes and modifiers, just like addfb2
    over addfb.
    
    Changes since v2:
     - add privilege checks from getfb1 since handles should only be
       returned to master/root
    
    Changes since v1:
     - unused modifiers set to 0 instead of DRM_FORMAT_MOD_INVALID
     - update ioctl number
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Signed-off-by: Juston Li <juston.li@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Lyude Paul <lyude@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191217034642.3814-1-juston.li@intel.com

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 868bf7996c0f..808b48a93330 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -948,6 +948,8 @@ extern "C" {
 #define DRM_IOCTL_SYNCOBJ_TRANSFER	DRM_IOWR(0xCC, struct drm_syncobj_transfer)
 #define DRM_IOCTL_SYNCOBJ_TIMELINE_SIGNAL	DRM_IOWR(0xCD, struct drm_syncobj_timeline_array)
 
+#define DRM_IOCTL_MODE_GETFB2		DRM_IOWR(0xCE, struct drm_mode_fb_cmd2)
+
 /**
  * Device specific ioctls should only be in their respective headers
  * The device specific ioctl range is from 0x40 to 0x9f.

commit 2093dea3def9d5bf3000697ae3b0ec36c43354e0
Author: Chunming Zhou <david1.zhou@amd.com>
Date:   Tue Jul 30 21:02:08 2019 +0800

    drm/syncobj: extend syncobj query ability v3
    
    user space needs a flexiable query ability.
    So that umd can get last signaled or submitted point.
    v2:
    add sanitizer checking.
    v3:
    rebase
    
    Change-Id: I6512b430524ebabe715e602a2bf5abb0a7e780ea
    Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Christian König <Christian.Koenig@amd.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Link: https://patchwork.freedesktop.org/series/64044/

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 8a5b2f8f8eb9..868bf7996c0f 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -778,11 +778,12 @@ struct drm_syncobj_array {
 	__u32 pad;
 };
 
+#define DRM_SYNCOBJ_QUERY_FLAGS_LAST_SUBMITTED (1 << 0) /* last available point on timeline syncobj */
 struct drm_syncobj_timeline_array {
 	__u64 handles;
 	__u64 points;
 	__u32 count_handles;
-	__u32 pad;
+	__u32 flags;
 };
 
 

commit 75b3f1cb50bdbdc7fd557ca3ed63b3eb87c2bab3
Author: James Clarke <jrtc27@jrtc27.com>
Date:   Tue Jan 15 15:04:18 2019 +0000

    drm: Fix drm.h uapi header for GNU/kFreeBSD
    
    Like GNU/Linux, GNU/kFreeBSD's sys/types.h does not define the uintX_t
    types, which differs from the BSDs' headers. Thus we should include
    stdint.h to ensure we have all the required integer types.
    
    Signed-off-by: James Clarke <jrtc27@jrtc27.com>
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190115150418.68080-1-jrtc27@jrtc27.com
    Reviewed-by: Eric Anholt <eric@anholt.net>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 661d73f9a919..8a5b2f8f8eb9 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -50,6 +50,7 @@ typedef unsigned int drm_handle_t;
 
 #else /* One of the BSDs */
 
+#include <stdint.h>
 #include <sys/ioccom.h>
 #include <sys/types.h>
 typedef int8_t   __s8;

commit 060cebb20cdbcd3185d593e7194fa7a738201817
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Apr 16 13:57:50 2019 +0100

    drm: introduce a capability flag for syncobj timeline support
    
    Unfortunately userspace users of this API cannot be publicly disclosed
    yet.
    
    This commit effectively disables timeline syncobj ioctls for all
    drivers. Each driver wishing to support this feature will need to
    expose DRIVER_SYNCOBJ_TIMELINE.
    
    v2: Add uAPI capability check (Christian)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Christian König <christian.koenig@amd.com> (v1)
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Christian König <christian.koenig@amd.com>
    Cc: Chunming Zhou <david1.zhou@amd.com>
    Reviewed-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190416125750.31370-1-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 236b01a1fabf..661d73f9a919 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -649,6 +649,7 @@ struct drm_gem_open {
 #define DRM_CAP_PAGE_FLIP_TARGET	0x11
 #define DRM_CAP_CRTC_IN_VBLANK_EVENT	0x12
 #define DRM_CAP_SYNCOBJ		0x13
+#define DRM_CAP_SYNCOBJ_TIMELINE	0x14
 
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {

commit 50d1ebef79ef6d09f4fb91f0b424e4f87db1d8a8
Author: Chunming Zhou <david1.zhou@amd.com>
Date:   Mon Apr 1 17:51:02 2019 +0800

    drm/syncobj: add timeline signal ioctl for syncobj v5
    
    v2: individually allocate chain array, since chain node is free independently.
    v3: all existing points must be already signaled before cpu perform signal operation,
        so add check condition for that.
    v4: remove v3 change and add checking to prevent out-of-order
    v5: unify binary and timeline
    
    Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Cc: Tobias Hector <Tobias.Hector@amd.com>
    Cc: Jason Ekstrand <jason@jlekstrand.net>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/295792/?series=58813&rev=1

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index e8d0d6b51875..236b01a1fabf 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -943,6 +943,7 @@ extern "C" {
 #define DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT	DRM_IOWR(0xCA, struct drm_syncobj_timeline_wait)
 #define DRM_IOCTL_SYNCOBJ_QUERY		DRM_IOWR(0xCB, struct drm_syncobj_timeline_array)
 #define DRM_IOCTL_SYNCOBJ_TRANSFER	DRM_IOWR(0xCC, struct drm_syncobj_transfer)
+#define DRM_IOCTL_SYNCOBJ_TIMELINE_SIGNAL	DRM_IOWR(0xCD, struct drm_syncobj_timeline_array)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit ea569910cbab980abb42daa603ad4e8f5f9deaaa
Author: Chunming Zhou <david1.zhou@amd.com>
Date:   Mon Apr 1 17:51:01 2019 +0800

    drm/syncobj: add transition iotcls between binary and timeline v2
    
    we need to import/export timeline point.
    
    v2: unify to one transfer ioctl
    
    Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/295790/?series=58813&rev=1

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index c62be0840ba5..e8d0d6b51875 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -735,6 +735,15 @@ struct drm_syncobj_handle {
 	__u32 pad;
 };
 
+struct drm_syncobj_transfer {
+	__u32 src_handle;
+	__u32 dst_handle;
+	__u64 src_point;
+	__u64 dst_point;
+	__u32 flags;
+	__u32 pad;
+};
+
 #define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL (1 << 0)
 #define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT (1 << 1)
 #define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE (1 << 2) /* wait for time point to become available */
@@ -933,6 +942,7 @@ extern "C" {
 
 #define DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT	DRM_IOWR(0xCA, struct drm_syncobj_timeline_wait)
 #define DRM_IOCTL_SYNCOBJ_QUERY		DRM_IOWR(0xCB, struct drm_syncobj_timeline_array)
+#define DRM_IOCTL_SYNCOBJ_TRANSFER	DRM_IOWR(0xCC, struct drm_syncobj_transfer)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit 27b575a9aa2ff0358c5f4410a14f6413d5c792e4
Author: Chunming Zhou <david1.zhou@amd.com>
Date:   Mon Apr 1 17:50:58 2019 +0800

    drm/syncobj: add timeline payload query ioctl v6
    
    user mode can query timeline payload.
    v2: check return value of copy_to_user
    v3: handle querying entry by entry
    v4: rebase on new chain container, simplify interface
    v5: query last signaled timeline point, not last point.
    v6: add unorder point check
    
    Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Cc: Tobias Hector <Tobias.Hector@amd.com>
    Cc: Jason Ekstrand <jason@jlekstrand.net>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/295784/?series=58813&rev=1

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 44ebcdd9bd1d..c62be0840ba5 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -767,6 +767,14 @@ struct drm_syncobj_array {
 	__u32 pad;
 };
 
+struct drm_syncobj_timeline_array {
+	__u64 handles;
+	__u64 points;
+	__u32 count_handles;
+	__u32 pad;
+};
+
+
 /* Query current scanout sequence number */
 struct drm_crtc_get_sequence {
 	__u32 crtc_id;		/* requested crtc_id */
@@ -924,6 +932,8 @@ extern "C" {
 #define DRM_IOCTL_MODE_REVOKE_LEASE	DRM_IOWR(0xC9, struct drm_mode_revoke_lease)
 
 #define DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT	DRM_IOWR(0xCA, struct drm_syncobj_timeline_wait)
+#define DRM_IOCTL_SYNCOBJ_QUERY		DRM_IOWR(0xCB, struct drm_syncobj_timeline_array)
+
 /**
  * Device specific ioctls should only be in their respective headers
  * The device specific ioctl range is from 0x40 to 0x9f.

commit 01d6c357837918d8186b9f520e167d98e3d560cc
Author: Chunming Zhou <david1.zhou@amd.com>
Date:   Mon Apr 1 17:50:57 2019 +0800

    drm/syncobj: add support for timeline point wait v8
    
    points array is one-to-one match with syncobjs array.
    v2:
    add seperate ioctl for timeline point wait, otherwise break uapi.
    v3:
    userspace can specify two kinds waits::
    a. Wait for time point to be completed.
    b. and wait for time point to become available
    v4:
    rebase
    v5:
    add comment for xxx_WAIT_AVAILABLE
    v6: rebase and rework on new container
    v7: drop _WAIT_COMPLETED, it is the default anyway
    v8: correctly handle garbage collected fences
    
    Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Cc: Tobias Hector <Tobias.Hector@amd.com>
    Cc: Jason Ekstrand <jason@jlekstrand.net>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/295782/?series=58813&rev=1

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 300f336633f2..44ebcdd9bd1d 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -737,6 +737,7 @@ struct drm_syncobj_handle {
 
 #define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL (1 << 0)
 #define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT (1 << 1)
+#define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE (1 << 2) /* wait for time point to become available */
 struct drm_syncobj_wait {
 	__u64 handles;
 	/* absolute timeout */
@@ -747,6 +748,19 @@ struct drm_syncobj_wait {
 	__u32 pad;
 };
 
+struct drm_syncobj_timeline_wait {
+	__u64 handles;
+	/* wait on specific timeline point for every handles*/
+	__u64 points;
+	/* absolute timeout */
+	__s64 timeout_nsec;
+	__u32 count_handles;
+	__u32 flags;
+	__u32 first_signaled; /* only valid when not waiting all */
+	__u32 pad;
+};
+
+
 struct drm_syncobj_array {
 	__u64 handles;
 	__u32 count_handles;
@@ -909,6 +923,7 @@ extern "C" {
 #define DRM_IOCTL_MODE_GET_LEASE	DRM_IOWR(0xC8, struct drm_mode_get_lease)
 #define DRM_IOCTL_MODE_REVOKE_LEASE	DRM_IOWR(0xC9, struct drm_mode_revoke_lease)
 
+#define DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT	DRM_IOWR(0xCA, struct drm_syncobj_timeline_wait)
 /**
  * Device specific ioctls should only be in their respective headers
  * The device specific ioctl range is from 0x40 to 0x9f.

commit 783195ec1cada862d54dee8f312a60bcbba5c0e4
Author: Christian König <christian.koenig@amd.com>
Date:   Thu Nov 8 09:39:46 2018 +0100

    drm/syncobj: disable the timeline UAPI for now v2
    
    Until we have sorted out all problems.
    
    v2: return -EINVAL during create if flag is set.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/260937/

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index cebdb2541eb7..300f336633f2 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -717,7 +717,6 @@ struct drm_prime_handle {
 struct drm_syncobj_create {
 	__u32 handle;
 #define DRM_SYNCOBJ_CREATE_SIGNALED (1 << 0)
-#define DRM_SYNCOBJ_CREATE_TYPE_TIMELINE (1 << 1)
 	__u32 flags;
 };
 

commit 48197bc564c7a1888c86024a1ba4f956e0ec2300
Author: Chunming Zhou <david1.zhou@amd.com>
Date:   Thu Oct 18 14:18:36 2018 +0800

    drm: add syncobj timeline support v9
    
    This patch is for VK_KHR_timeline_semaphore extension, semaphore is called syncobj in kernel side:
    This extension introduces a new type of syncobj that has an integer payload
    identifying a point in a timeline. Such timeline syncobjs support the
    following operations:
       * CPU query - A host operation that allows querying the payload of the
         timeline syncobj.
       * CPU wait - A host operation that allows a blocking wait for a
         timeline syncobj to reach a specified value.
       * Device wait - A device operation that allows waiting for a
         timeline syncobj to reach a specified value.
       * Device signal - A device operation that allows advancing the
         timeline syncobj to a specified value.
    
    v1:
    Since it's a timeline, that means the front time point(PT) always is signaled before the late PT.
    a. signal PT design:
    Signal PT fence N depends on PT[N-1] fence and signal opertion fence, when PT[N] fence is signaled,
    the timeline will increase to value of PT[N].
    b. wait PT design:
    Wait PT fence is signaled by reaching timeline point value, when timeline is increasing, will compare
    wait PTs value with new timeline value, if PT value is lower than timeline value, then wait PT will be
    signaled, otherwise keep in list. syncobj wait operation can wait on any point of timeline,
    so need a RB tree to order them. And wait PT could ahead of signal PT, we need a sumission fence to
    perform that.
    
    v2:
    1. remove unused DRM_SYNCOBJ_CREATE_TYPE_NORMAL. (Christian)
    2. move unexposed denitions to .c file. (Daniel Vetter)
    3. split up the change to drm_syncobj_find_fence() in a separate patch. (Christian)
    4. split up the change to drm_syncobj_replace_fence() in a separate patch.
    5. drop the submission_fence implementation and instead use wait_event() for that. (Christian)
    6. WARN_ON(point != 0) for NORMAL type syncobj case. (Daniel Vetter)
    
    v3:
    1. replace normal syncobj with timeline implemenation. (Vetter and Christian)
        a. normal syncobj signal op will create a signal PT to tail of signal pt list.
        b. normal syncobj wait op will create a wait pt with last signal point, and this wait PT is only signaled by related signal point PT.
    2. many bug fix and clean up
    3. stub fence moving is moved to other patch.
    
    v4：
    1. fix RB tree loop with while(node=rb_first(...)). (Christian)
    2. fix syncobj lifecycle. (Christian)
    3. only enable_signaling when there is wait_pt. (Christian)
    4. fix timeline path issues.
    5. write a timeline test in libdrm
    
    v5: (Christian)
    1. semaphore is called syncobj in kernel side.
    2. don't need 'timeline' characters in some function name.
    3. keep syncobj cb.
    
    v6: (Christian)
    1. merge syncobj_timeline to syncobj structure.
    2. simplify some check sentences.
    3. some misc change.
    4. fix CTS failed issue.
    
    v7: (Christian)
    1. error handling when creating signal pt.
    2. remove timeline naming in func.
    3. export flags in find_fence.
    4. allow reset timeline.
    
    v8:
    1. use wait_event_interruptible without timeout
    2. rename _TYPE_INDIVIDUAL to _TYPE_BINARY
    
    v9:
    1. rename signal_pt->base to signal_pt->fence_array to avoid misleading
    2. improve kerneldoc
    
    individual syncobj is tested by ./deqp-vk -n dEQP-VK*semaphore*
    timeline syncobj is tested by ./amdgpu_test -s 9
    
    Signed-off-by: Chunming Zhou <david1.zhou@amd.com>
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Cc: Christian Konig <christian.koenig@amd.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Daniel Rakos <Daniel.Rakos@amd.com>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
    Cc: Jason Ekstrand <jason@jlekstrand.net>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/257258/

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 300f336633f2..cebdb2541eb7 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -717,6 +717,7 @@ struct drm_prime_handle {
 struct drm_syncobj_create {
 	__u32 handle;
 #define DRM_SYNCOBJ_CREATE_SIGNALED (1 << 0)
+#define DRM_SYNCOBJ_CREATE_TYPE_TIMELINE (1 << 1)
 	__u32 flags;
 };
 

commit d67b6a2065076d763c7df626b8c54f16038ad862
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Wed Feb 28 14:11:23 2018 +0000

    drm: writeback: Add client capability for exposing writeback connectors
    
    Due to the fact that writeback connectors behave in a special way
    in DRM (they always report being disconnected) we might confuse some
    userspace. Add a client capability for writeback connectors that will
    filter them out for clients that don't understand the capability.
    
    Changelog:
     - only accept the capability if the client has already set the
    DRM_CLIENT_CAP_ATOMIC one.
    
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: Brian Starkey <brian.starkey@arm.com>
    Signed-off-by: Liviu Dudau <liviu.dudau@arm.com>
    Reviewed-by: Eric Anholt <eric@anholt.net>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Link: https://patchwork.freedesktop.org/patch/229038/

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 9c660e1688ab..300f336633f2 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -687,6 +687,15 @@ struct drm_get_cap {
  */
 #define DRM_CLIENT_CAP_ASPECT_RATIO    4
 
+/**
+ * DRM_CLIENT_CAP_WRITEBACK_CONNECTORS
+ *
+ * If set to 1, the DRM core will expose special connectors to be used for
+ * writing back to memory the scene setup in the commit. Depends on client
+ * also supporting DRM_CLIENT_CAP_ATOMIC
+ */
+#define DRM_CLIENT_CAP_WRITEBACK_CONNECTORS	5
+
 /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
 struct drm_set_client_cap {
 	__u64 capability;

commit 7595bda2fb4378ccbb8db1d0e8de56d15ea7f7fa
Author: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
Date:   Tue May 8 16:39:41 2018 +0530

    drm: Add DRM client cap for aspect-ratio
    
    To enable aspect-ratio support in DRM, blindly exposing the aspect
    ratio information along with mode, can break things in existing
    non-atomic user-spaces which have no intention or support to use this
    aspect ratio information.
    
    To avoid this, a new drm client cap is required to enable a non-atomic
    user-space to advertise if it supports modes with aspect-ratio. Based
    on this cap value, the kernel will take a call on exposing the aspect
    ratio info in modes or not.
    
    This patch adds the client cap for aspect-ratio.
    
    Since no atomic-userspaces blow up on receiving aspect-ratio
    information, the client cap for aspect-ratio is always enabled
    for atomic clients.
    
    Cc: Ville Syrjala <ville.syrjala@linux.intel.com>
    Cc: Shashank Sharma <shashank.sharma@intel.com>
    Signed-off-by: Ankit Nautiyal <ankit.k.nautiyal@intel.com>
    
    V3: rebase
    V4: As suggested by Marteen Lankhorst modified the commit message
        explaining the need to use the DRM cap for aspect-ratio. Also,
        tweaked the comment lines in the code for better understanding and
        clarity, as recommended by Shashank Sharma.
    V5: rebase
    V6: rebase
    V7: rebase
    V8: rebase
    V9: rebase
    V10: rebase
    V11: rebase
    V12: As suggested by Daniel Vetter and Ville Syrjala,
         always enable aspect-ratio client cap for atomic userspaces,
         if no atomic userspace breaks on aspect-ratio bits.
    V13: rebase
    V14: rebase
    
    Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/1525777785-9740-7-git-send-email-ankit.k.nautiyal@intel.com

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 6fdff5945c8a..9c660e1688ab 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -680,6 +680,13 @@ struct drm_get_cap {
  */
 #define DRM_CLIENT_CAP_ATOMIC	3
 
+/**
+ * DRM_CLIENT_CAP_ASPECT_RATIO
+ *
+ * If set to 1, the DRM core will provide aspect ratio information in modes.
+ */
+#define DRM_CLIENT_CAP_ASPECT_RATIO    4
+
 /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
 struct drm_set_client_cap {
 	__u64 capability;

commit 62884cd386b876638720ef88374b31a84ca7ee5f
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Mar 16 17:56:28 2017 -0700

    drm: Add four ioctls for managing drm mode object leases [v7]
    
    drm_mode_create_lease
    
            Creates a lease for a list of drm mode objects, returning an
            fd for the new drm_master and a 64-bit identifier for the lessee
    
    drm_mode_list_lesees
    
            List the identifiers of the lessees for a master file
    
    drm_mode_get_lease
    
            List the leased objects for a master file
    
    drm_mode_revoke_lease
    
            Erase the set of objects managed by a lease.
    
    This should suffice to at least create and query leases.
    
    Changes for v2 as suggested by Daniel Vetter <daniel.vetter@ffwll.ch>:
    
     * query ioctls only query the master associated with
       the provided file.
    
     * 'mask_lease' value has been removed
    
     * change ioctl has been removed.
    
    Changes for v3 suggested in part by Dave Airlie <airlied@gmail.com>
    
     * Add revoke ioctl.
    
    Changes for v4 suggested by Dave Airlie <airlied@gmail.com>
    
     * Expand on the comment about the magic use of &drm_lease_idr_object
     * Pad lease ioctl structures to align on 64-bit boundaries
    
    Changes for v5 suggested by Dave Airlie <airlied@gmail.com>
    
     * Check for non-negative object_id in create_lease to avoid debug
       output from the kernel.
    
    Changes for v6 provided by Dave Airlie <airlied@gmail.com>
    
     * For non-universal planes add primary/cursor planes to lease
    
       If we aren't exposing universal planes to this userspace client,
       and it requests a lease on a crtc, we should implicitly export the
       primary and cursor planes for the crtc.
    
       If the lessee doesn't request universal planes, it will just see
       the crtc, but if it does request them it will then see the plane
       objects as well.
    
       This also moves the object look ups earlier as a side effect, so
       we'd exit the ioctl quicker for non-existant objects.
    
     * Restrict leases to crtc/connector/planes.
    
       This only allows leasing for objects we wish to allow.
    
    Changes for v7 provided by Dave Airlie <airlied@gmail.com>
    
     * Check pad args are 0
     * Check create flags and object count are valid.
     * Check return from fd allocation
     * Refactor lease idr setup and add some simple validation
     * Use idr_mutex uniformly (Keith)
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 91d83c1747c0..6fdff5945c8a 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -888,6 +888,11 @@ extern "C" {
 #define DRM_IOCTL_SYNCOBJ_RESET		DRM_IOWR(0xC4, struct drm_syncobj_array)
 #define DRM_IOCTL_SYNCOBJ_SIGNAL	DRM_IOWR(0xC5, struct drm_syncobj_array)
 
+#define DRM_IOCTL_MODE_CREATE_LEASE	DRM_IOWR(0xC6, struct drm_mode_create_lease)
+#define DRM_IOCTL_MODE_LIST_LESSEES	DRM_IOWR(0xC7, struct drm_mode_list_lessees)
+#define DRM_IOCTL_MODE_GET_LEASE	DRM_IOWR(0xC8, struct drm_mode_get_lease)
+#define DRM_IOCTL_MODE_REVOKE_LEASE	DRM_IOWR(0xC9, struct drm_mode_revoke_lease)
+
 /**
  * Device specific ioctls should only be in their respective headers
  * The device specific ioctl range is from 0x40 to 0x9f.

commit 3064abfa932bd09faf8da01741d171d476cf7193
Author: Keith Packard <keithp@keithp.com>
Date:   Thu Jun 29 22:49:31 2017 -0700

    drm: Add CRTC_GET_SEQUENCE and CRTC_QUEUE_SEQUENCE ioctls [v3]
    
    These provide crtc-id based functions instead of pipe-number, while
    also offering higher resolution time (ns) and wider frame count (64)
    as required by the Vulkan API.
    
    v2:
    
     * Check for DRIVER_MODESET in new crtc-based vblank ioctls
    
            Failing to check this will oops the driver.
    
     * Ensure vblank interupt is running in crtc_get_sequence ioctl
    
            The sequence and timing values are not correct while the
            interrupt is off, so make sure it's running before asking for
            them.
    
     * Short-circuit get_sequence if the counter is enabled and accurate
    
            Steal the idea from the code in wait_vblank to avoid the
            expense of drm_vblank_get/put
    
     * Return active state of crtc in crtc_get_sequence ioctl
    
            Might be useful for applications that aren't in charge of
            modesetting?
    
     * Use drm_crtc_vblank_get/put in new crtc-based vblank sequence ioctls
    
            Daniel Vetter prefers these over the old drm_vblank_put/get
            APIs.
    
     * Return s64 ns instead of u64 in new sequence event
    
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    Suggested-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    
    v3:
    
     * Removed FIRST_PIXEL_OUT_FLAG
     * Document that the timestamp in the query and event are
       that of the first pixel leaving the display engine for
       the display (using the same wording as the Vulkan spec).
    
    Suggested-by: Michel Dänzer <michel@daenzer.net>
    Acked-by: Dave Airlie <airlied@redhat.com>
    
    [airlied: left->leaves (Michel)]
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 97677cd6964d..91d83c1747c0 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -737,6 +737,28 @@ struct drm_syncobj_array {
 	__u32 pad;
 };
 
+/* Query current scanout sequence number */
+struct drm_crtc_get_sequence {
+	__u32 crtc_id;		/* requested crtc_id */
+	__u32 active;		/* return: crtc output is active */
+	__u64 sequence;		/* return: most recent vblank sequence */
+	__s64 sequence_ns;	/* return: most recent time of first pixel out */
+};
+
+/* Queue event to be delivered at specified sequence. Time stamp marks
+ * when the first pixel of the refresh cycle leaves the display engine
+ * for the display
+ */
+#define DRM_CRTC_SEQUENCE_RELATIVE		0x00000001	/* sequence is relative to current */
+#define DRM_CRTC_SEQUENCE_NEXT_ON_MISS		0x00000002	/* Use next sequence if we've missed */
+
+struct drm_crtc_queue_sequence {
+	__u32 crtc_id;
+	__u32 flags;
+	__u64 sequence;		/* on input, target sequence. on output, actual sequence */
+	__u64 user_data;	/* user data passed to event */
+};
+
 #if defined(__cplusplus)
 }
 #endif
@@ -819,6 +841,9 @@ extern "C" {
 
 #define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)
 
+#define DRM_IOCTL_CRTC_GET_SEQUENCE	DRM_IOWR(0x3b, struct drm_crtc_get_sequence)
+#define DRM_IOCTL_CRTC_QUEUE_SEQUENCE	DRM_IOWR(0x3c, struct drm_crtc_queue_sequence)
+
 #define DRM_IOCTL_UPDATE_DRAW		DRM_IOW(0x3f, struct drm_update_draw)
 
 #define DRM_IOCTL_MODE_GETRESOURCES	DRM_IOWR(0xA0, struct drm_mode_card_res)
@@ -893,6 +918,7 @@ struct drm_event {
 
 #define DRM_EVENT_VBLANK 0x01
 #define DRM_EVENT_FLIP_COMPLETE 0x02
+#define DRM_EVENT_CRTC_SEQUENCE	0x03
 
 struct drm_event_vblank {
 	struct drm_event base;
@@ -903,6 +929,16 @@ struct drm_event_vblank {
 	__u32 crtc_id; /* 0 on older kernels that do not support this */
 };
 
+/* Event delivered at sequence. Time stamp marks when the first pixel
+ * of the refresh cycle leaves the display engine for the display
+ */
+struct drm_event_crtc_sequence {
+	struct drm_event	base;
+	__u64			user_data;
+	__s64			time_ns;
+	__u64			sequence;
+};
+
 /* typedef area */
 #ifndef __KERNEL__
 typedef struct drm_clip_rect drm_clip_rect_t;

commit ffa9443fb3d3eddf0fdf6ac473dc8b5c87f08f15
Author: Jason Ekstrand <jason@jlekstrand.net>
Date:   Mon Aug 28 14:10:28 2017 -0700

    drm/syncobj: Add a signal ioctl (v3)
    
    This IOCTL provides a mechanism for userspace to trigger a sync object
    directly.  There are other ways that userspace can trigger a syncobj
    such as submitting a dummy batch somewhere or hanging on to a triggered
    sync_file and doing an import.  This just provides an easy way to
    manually trigger the sync object without weird hacks.
    
    The motivation for this IOCTL is Vulkan fences.  Vulkan lets you create
    a fence already in the signaled state so that you can wait on it
    immediatly without stalling.  We could also handle this with a new
    create flag to ask the driver to create a syncobj that is already
    signaled but the IOCTL seemed a bit cleaner and more generic.
    
    v2:
     - Take an array of sync objects (Dave Airlie)
    v3:
     - Throw -EINVAL if pad != 0
    
    Signed-off-by: Jason Ekstrand <jason@jlekstrand.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index b037fdf9e43b..97677cd6964d 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -861,6 +861,7 @@ extern "C" {
 #define DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE	DRM_IOWR(0xC2, struct drm_syncobj_handle)
 #define DRM_IOCTL_SYNCOBJ_WAIT		DRM_IOWR(0xC3, struct drm_syncobj_wait)
 #define DRM_IOCTL_SYNCOBJ_RESET		DRM_IOWR(0xC4, struct drm_syncobj_array)
+#define DRM_IOCTL_SYNCOBJ_SIGNAL	DRM_IOWR(0xC5, struct drm_syncobj_array)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit aa4035d2c7683d2f2fb0ffe8087abd9eabf6d54a
Author: Jason Ekstrand <jason@jlekstrand.net>
Date:   Mon Aug 28 14:10:27 2017 -0700

    drm/syncobj: Add a reset ioctl (v3)
    
    This just resets the dma_fence to NULL so it looks like it's never been
    signaled.  This will be useful once we add the new wait API for allowing
    wait on "submit and signal" behavior.
    
    v2:
     - Take an array of sync objects (Dave Airlie)
    v3:
     - Throw -EINVAL if pad != 0
    
    Signed-off-by: Jason Ekstrand <jason@jlekstrand.net>
    Reviewed-by: Christian König <christian.koenig@amd.com> (v1)
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 4c746597225e..b037fdf9e43b 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -731,6 +731,12 @@ struct drm_syncobj_wait {
 	__u32 pad;
 };
 
+struct drm_syncobj_array {
+	__u64 handles;
+	__u32 count_handles;
+	__u32 pad;
+};
+
 #if defined(__cplusplus)
 }
 #endif
@@ -854,6 +860,7 @@ extern "C" {
 #define DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD	DRM_IOWR(0xC1, struct drm_syncobj_handle)
 #define DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE	DRM_IOWR(0xC2, struct drm_syncobj_handle)
 #define DRM_IOCTL_SYNCOBJ_WAIT		DRM_IOWR(0xC3, struct drm_syncobj_wait)
+#define DRM_IOCTL_SYNCOBJ_RESET		DRM_IOWR(0xC4, struct drm_syncobj_array)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit e7aca5031a2fb51b6120864d0eff5478c95e6651
Author: Jason Ekstrand <jason@jlekstrand.net>
Date:   Fri Aug 25 10:52:24 2017 -0700

    drm/syncobj: Allow wait for submit and signal behavior (v5)
    
    Vulkan VkFence semantics require that the application be able to perform
    a CPU wait on work which may not yet have been submitted.  This is
    perfectly safe because the CPU wait has a timeout which will get
    triggered eventually if no work is ever submitted.  This behavior is
    advantageous for multi-threaded workloads because, so long as all of the
    threads agree on what fences to use up-front, you don't have the extra
    cross-thread synchronization cost of thread A telling thread B that it
    has submitted its dependent work and thread B is now free to wait.
    
    Within a single process, this can be implemented in the userspace driver
    by doing exactly the same kind of tracking the app would have to do
    using posix condition variables or similar.  However, in order for this
    to work cross-process (as is required by VK_KHR_external_fence), we need
    to handle this in the kernel.
    
    This commit adds a WAIT_FOR_SUBMIT flag to DRM_IOCTL_SYNCOBJ_WAIT which
    instructs the IOCTL to wait for the syncobj to have a non-null fence and
    then wait on the fence.  Combined with DRM_IOCTL_SYNCOBJ_RESET, you can
    easily get the Vulkan behavior.
    
    v2:
     - Fix a bug in the invalid syncobj error path
     - Unify the wait-all and wait-any cases
    v3:
     - Unify the timeout == 0 case a bit with the timeout > 0 case
     - Use wait_event_interruptible_timeout
    v4:
     - Use proxy fence
    v5:
     - Revert to a combination of v2 and v3
     - Don't use proxy fences
     - Don't use wait_event_interruptible_timeout because it just adds an
       extra layer of callbacks
    
    Signed-off-by: Jason Ekstrand <jason@jlekstrand.net>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Christian König <christian.koenig@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index ade7f68d32b5..4c746597225e 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -720,6 +720,7 @@ struct drm_syncobj_handle {
 };
 
 #define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL (1 << 0)
+#define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT (1 << 1)
 struct drm_syncobj_wait {
 	__u64 handles;
 	/* absolute timeout */

commit 1fc08218ed2a42c86af5c905fe4c00885376a07e
Author: Jason Ekstrand <jason@jlekstrand.net>
Date:   Fri Aug 25 10:52:25 2017 -0700

    drm/syncobj: Add a CREATE_SIGNALED flag
    
    This requests that the driver create the sync object such that it
    already has a signaled dma_fence attached.  Because we don't need
    anything in particular (just something signaled), we use a dummy null
    fence.  This is useful for Vulkan which has a similar flag that can be
    passed to vkCreateFence.
    
    Signed-off-by: Jason Ekstrand <jason@jlekstrand.net>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 0757c1a41821..ade7f68d32b5 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -700,6 +700,7 @@ struct drm_prime_handle {
 
 struct drm_syncobj_create {
 	__u32 handle;
+#define DRM_SYNCOBJ_CREATE_SIGNALED (1 << 0)
 	__u32 flags;
 };
 

commit 5e60a10eaebab93f823295cd7ec3848ba3b6e553
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Aug 25 10:52:22 2017 -0700

    drm/syncobj: add sync obj wait interface. (v8)
    
    This interface will allow sync object to be used to back
    Vulkan fences. This API is pretty much the vulkan fence waiting
    API, and I've ported the code from amdgpu.
    
    v2: accept relative timeout, pass remaining time back
    to userspace.
    v3: return to absolute timeouts.
    v4: absolute zero = poll,
        rewrite any/all code to have same operation for arrays
        return -EINVAL for 0 fences.
    v4.1: fixup fences allocation check, use u64_to_user_ptr
    v5: move to sec/nsec, and use timespec64 for calcs.
    v6: use -ETIME and drop the out status flag. (-ETIME
    is suggested by ickle, I can feel a shed painting)
    v7: talked to Daniel/Arnd, use ktime and ns everywhere.
    v8: be more careful in the timeout calculations
        use uint32_t for counter variables so we don't overflow
        graciously handle -ENOINT being returned from dma_fence_wait_timeout
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Reviewed-by: Jason Ekstrand <jason@jlekstrand.net>
    Acked-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 101593ab10ac..0757c1a41821 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -718,6 +718,17 @@ struct drm_syncobj_handle {
 	__u32 pad;
 };
 
+#define DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL (1 << 0)
+struct drm_syncobj_wait {
+	__u64 handles;
+	/* absolute timeout */
+	__s64 timeout_nsec;
+	__u32 count_handles;
+	__u32 flags;
+	__u32 first_signaled; /* only valid when not waiting all */
+	__u32 pad;
+};
+
 #if defined(__cplusplus)
 }
 #endif
@@ -840,6 +851,7 @@ extern "C" {
 #define DRM_IOCTL_SYNCOBJ_DESTROY	DRM_IOWR(0xC0, struct drm_syncobj_destroy)
 #define DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD	DRM_IOWR(0xC1, struct drm_syncobj_handle)
 #define DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE	DRM_IOWR(0xC2, struct drm_syncobj_handle)
+#define DRM_IOCTL_SYNCOBJ_WAIT		DRM_IOWR(0xC3, struct drm_syncobj_wait)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit 3ee45a3b533a20ed9fcc11ddb880fc4b30d28f51
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 26 04:09:02 2017 +0100

    drm/syncobj: add sync_file interaction. (v1.2)
    
    This interface allows importing the fence from a sync_file into
    an existing drm sync object, or exporting the fence attached to
    an existing drm sync object into a new sync file object.
    
    This should only be used to interact with sync files where necessary.
    
    v1.1: fence put fixes (Chris), drop fence from ioctl names (Chris)
    fixup for new fence replace API.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 96c5c789e73d..101593ab10ac 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -708,6 +708,8 @@ struct drm_syncobj_destroy {
 	__u32 pad;
 };
 
+#define DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE (1 << 0)
+#define DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE (1 << 0)
 struct drm_syncobj_handle {
 	__u32 handle;
 	__u32 flags;

commit e9083420bbacce27e43d418064d0d2dfb4b37aaa
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Apr 4 13:26:24 2017 +1000

    drm: introduce sync objects (v4)
    
    Sync objects are new toplevel drm object, that contain a
    pointer to a fence. This fence can be updated via command
    submission ioctls via drivers.
    
    There is also a generic wait obj API modelled on the vulkan
    wait API (with code modelled on some amdgpu code).
    
    These objects can be converted to an opaque fd that can be
    passes between processes.
    
    v2: rename reference/unreference to put/get (Chris)
    fix leaked reference (David Zhou)
    drop mutex in favour of cmpxchg (Chris)
    v3: cleanups from danvet, rebase on drm_fops rename
    check fd_flags is 0 in ioctls.
    v4: export find/free, change replace fence to take a
    syncobj. In order to support lookup first, replace
    later semantics which seem in the end to be cleaner.
    
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 42d9f64ce416..96c5c789e73d 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -648,6 +648,7 @@ struct drm_gem_open {
 #define DRM_CAP_ADDFB2_MODIFIERS	0x10
 #define DRM_CAP_PAGE_FLIP_TARGET	0x11
 #define DRM_CAP_CRTC_IN_VBLANK_EVENT	0x12
+#define DRM_CAP_SYNCOBJ		0x13
 
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {
@@ -697,6 +698,24 @@ struct drm_prime_handle {
 	__s32 fd;
 };
 
+struct drm_syncobj_create {
+	__u32 handle;
+	__u32 flags;
+};
+
+struct drm_syncobj_destroy {
+	__u32 handle;
+	__u32 pad;
+};
+
+struct drm_syncobj_handle {
+	__u32 handle;
+	__u32 flags;
+
+	__s32 fd;
+	__u32 pad;
+};
+
 #if defined(__cplusplus)
 }
 #endif
@@ -815,6 +834,11 @@ extern "C" {
 #define DRM_IOCTL_MODE_CREATEPROPBLOB	DRM_IOWR(0xBD, struct drm_mode_create_blob)
 #define DRM_IOCTL_MODE_DESTROYPROPBLOB	DRM_IOWR(0xBE, struct drm_mode_destroy_blob)
 
+#define DRM_IOCTL_SYNCOBJ_CREATE	DRM_IOWR(0xBF, struct drm_syncobj_create)
+#define DRM_IOCTL_SYNCOBJ_DESTROY	DRM_IOWR(0xC0, struct drm_syncobj_destroy)
+#define DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD	DRM_IOWR(0xC1, struct drm_syncobj_handle)
+#define DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE	DRM_IOWR(0xC2, struct drm_syncobj_handle)
+
 /**
  * Device specific ioctls should only be in their respective headers
  * The device specific ioctl range is from 0x40 to 0x9f.

commit 5db06a8a98f515f67446a69c57577c4c363ec65d
Author: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date:   Tue Apr 4 17:52:21 2017 +0100

    drm: Pass CRTC ID in userspace vblank events
    
    With the atomic API, it is possible that a single commit affects
    multiple crtcs. If the user requests an event with that commit, one
    event will be sent for each CRTC, but it is not possible to distinguish
    which crtc an event is for in user space. To solve this, the reserved
    field in struct drm_vblank_event is repurposed to include the crtc_id
    which the event is for.
    
    The DRM_CAP_CRTC_IN_VBLANK_EVENT is added to allow userspace to query if
    the crtc field will be set properly.
    
    [daniels: Rebased, using Maarten's forward-port.]
    
    Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Cc: Maarten Lankhorst <maarten.lankhorst@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170404165221.28240-2-daniels@collabora.com

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index b2c52843bc70..42d9f64ce416 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -647,6 +647,7 @@ struct drm_gem_open {
 #define DRM_CAP_CURSOR_HEIGHT		0x9
 #define DRM_CAP_ADDFB2_MODIFIERS	0x10
 #define DRM_CAP_PAGE_FLIP_TARGET	0x11
+#define DRM_CAP_CRTC_IN_VBLANK_EVENT	0x12
 
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {
@@ -851,7 +852,7 @@ struct drm_event_vblank {
 	__u32 tv_sec;
 	__u32 tv_usec;
 	__u32 sequence;
-	__u32 reserved;
+	__u32 crtc_id; /* 0 on older kernels that do not support this */
 };
 
 /* typedef area */

commit f837297ad82480024d3ad08cd84f6670bcafa862
Author: Michel Dänzer <michel.daenzer@amd.com>
Date:   Mon Aug 8 16:23:39 2016 +0900

    drm: Add DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE/RELATIVE flags v2
    
    These flags allow userspace to explicitly specify the target vertical
    blank period when a flip should take effect.
    
    v2:
    * Add new struct drm_mode_crtc_page_flip_target instead of modifying
      struct drm_mode_crtc_page_flip, to make sure all existing userspace
      code keeps compiling (Daniel Vetter)
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 452675fb55d9..b2c52843bc70 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -646,6 +646,7 @@ struct drm_gem_open {
 #define DRM_CAP_CURSOR_WIDTH		0x8
 #define DRM_CAP_CURSOR_HEIGHT		0x9
 #define DRM_CAP_ADDFB2_MODIFIERS	0x10
+#define DRM_CAP_PAGE_FLIP_TARGET	0x11
 
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {

commit ebbb0e5cfd2ceb1150b1af7f9fcf7aeebfb1b69f
Author: Emil Velikov <emil.l.velikov@gmail.com>
Date:   Thu Apr 7 18:49:00 2016 +0100

    drm: add extern C guard for the UAPI headers
    
    Signed-off-by: Emil Velikov <emil.l.velikov@gmail.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 368325061ca7..452675fb55d9 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -65,6 +65,10 @@ typedef unsigned long drm_handle_t;
 
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define DRM_NAME	"drm"	  /**< Name in kernel, /dev, and /proc */
 #define DRM_MIN_ORDER	5	  /**< At least 2^5 bytes = 32 bytes */
 #define DRM_MAX_ORDER	22	  /**< Up to 2^22 bytes = 4MB */
@@ -691,8 +695,16 @@ struct drm_prime_handle {
 	__s32 fd;
 };
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "drm_mode.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define DRM_IOCTL_BASE			'd'
 #define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)
 #define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)
@@ -886,4 +898,8 @@ typedef struct drm_scatter_gather drm_scatter_gather_t;
 typedef struct drm_set_version drm_set_version_t;
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif

commit 00fdf360d05111d4dfc4cb03727ff26f8ab2fd46
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 16:42:23 2016 +0200

    drm: Make uapi headers C89 pendantic compliant
    
    This ports the below libdrm commit to the kernel
    
    commit 0f4452bb51306024fbf4cbf77d8baab20cefba67
    Author: Daniel Kurtz <djkurtz@chromium.org>
    Date:   Mon Aug 26 23:39:16 2013 +0800
    
        libdrm: Make some drm headers compatible with gcc -std=c89 -pedantic
    
        The following minor changes were needed to these headers:
         * Convert // comments to /* */
         * No , after final member of enum
    
        With these changes, these header files can be included by a program that
        is built with gcc options:
          -std=c89 -Werror -pedantic
    
        Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
        Signed-off-by: Eric Anholt <eric@anholt.net>
        Reviewed-by: Eric Anholt <eric@anholt.net>
    
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459348943-12803-2-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index fbc0818bb95b..368325061ca7 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -187,7 +187,7 @@ enum drm_map_type {
 	_DRM_SHM = 2,		  /**< shared, cached */
 	_DRM_AGP = 3,		  /**< AGP/GART */
 	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
-	_DRM_CONSISTENT = 5,	  /**< Consistent memory for PCI DMA */
+	_DRM_CONSISTENT = 5	  /**< Consistent memory for PCI DMA */
 };
 
 /**
@@ -441,7 +441,7 @@ struct drm_draw {
  * DRM_IOCTL_UPDATE_DRAW ioctl argument type.
  */
 typedef enum {
-	DRM_DRAWABLE_CLIPRECTS,
+	DRM_DRAWABLE_CLIPRECTS
 } drm_drawable_info_type_t;
 
 struct drm_update_draw {

commit 00c9672606f781f2db7e904127dcbdc2831701ca
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 16:42:22 2016 +0200

    drm: Untangle __KERNEL__ guards
    
    make headers_install can't handle fancy conditions, so let's simplify
    things for it a bit.
    
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459348943-12803-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 85ada499574b..fbc0818bb95b 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -36,7 +36,13 @@
 #ifndef _DRM_H_
 #define _DRM_H_
 
-#if defined(__KERNEL__) || defined(__linux__)
+#if defined(__KERNEL__)
+
+#include <linux/types.h>
+#include <asm/ioctl.h>
+typedef unsigned int drm_handle_t;
+
+#elif defined(__linux__)
 
 #include <linux/types.h>
 #include <asm/ioctl.h>

commit 0b1ccd49ba3252c5cbb0ac98ee2a8682b9a529cb
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 17:54:52 2016 +0200

    drm: align #include directives with libdrm in uapi headers
    
    We can't use <drm/*.h> because that upsets the serach paths in libdrm.
    Also, drop the circular inclusion in drm_mode.h.
    
    v2: Actually change the right headers.
    
    v3: Drop the #include removal per Emil's request.
    
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459353292-9063-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 7d42d105f32a..85ada499574b 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -685,7 +685,7 @@ struct drm_prime_handle {
 	__s32 fd;
 };
 
-#include <drm/drm_mode.h>
+#include "drm_mode.h"
 
 #define DRM_IOCTL_BASE			'd'
 #define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)

commit 4c4925fa0c2b5943655ef28b2d6a379961db551f
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Mar 30 17:12:33 2016 +0200

    drm: Make drm.h uapi header safe for C++
    
    virtual is a protected keyword in C++ and can't be used at all. Ugh.
    
    This aligns the kernel versions of the drm headers with the ones in
    libdrm.
    
    v2: Also annote with __user, as request by Emil&Ilia.
    
    Cc: Ilia Mirkin <imirkin@alum.mit.edu>
    Cc: Emil Velikov <emil.l.velikov@gmail.com>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1459350753-18320-1-git-send-email-daniel.vetter@ffwll.ch

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index a0ebfe7c9a28..7d42d105f32a 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -373,7 +373,11 @@ struct drm_buf_pub {
  */
 struct drm_buf_map {
 	int count;		/**< Length of the buffer list */
+#ifdef __cplusplus
+	void __user *virt;
+#else
 	void __user *virtual;		/**< Mmap'd area in user-virtual */
+#endif
 	struct drm_buf_pub __user *list;	/**< Buffer information */
 };
 

commit bfe981a0952880df43d08a050bf3ae44aaebd795
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Tue Dec 22 19:36:44 2015 -0200

    drm: prime: Honour O_RDWR during prime-handle-to-fd
    
    Currently DRM_IOCTL_PRIME_HANDLE_TO_FD rejects all flags except
    (DRM|O)_CLOEXEC making it difficult (maybe impossible) for userspace
    to mmap() the resulting dma-buf even when this is supported by the
    DRM driver.
    
    It is trivial to relax the restriction and permit read/write access.
    This is safe because the flags are seldom touched by drm; mostly they
    are passed verbatim to dma_buf calls.
    
    v3 (Tiago): removed unused flags variable from drm_prime_handle_to_fd_ioctl.
    
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Tiago Vignatti <tiago.vignatti@intel.com>
    Reviewed-by: Stéphane Marchesin <marcheu@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1450820214-12509-2-git-send-email-tiago.vignatti@intel.com

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index b4e92eb12044..a0ebfe7c9a28 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -669,6 +669,7 @@ struct drm_set_client_cap {
 	__u64 value;
 };
 
+#define DRM_RDWR O_RDWR
 #define DRM_CLOEXEC O_CLOEXEC
 struct drm_prime_handle {
 	__u32 handle;

commit 1a2a42c8bfa25ef0f7e14c5973c6a0bebe625a96
Author: Mikko Rapeli <mikko.rapeli@iki.fi>
Date:   Sun Aug 31 12:58:46 2014 +0200

    drm.h: use __kernel_size_t instead of size_t
    
    Fall back to size_t for non Linux platforms.
    
    Fixes userspace compilation error:
    
    drm/drm.h:132:2: error: unknown type name ‘size_t’
    
    Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 3801584a0c53..b4e92eb12044 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -54,6 +54,7 @@ typedef int32_t  __s32;
 typedef uint32_t __u32;
 typedef int64_t  __s64;
 typedef uint64_t __u64;
+typedef size_t   __kernel_size_t;
 typedef unsigned long drm_handle_t;
 
 #endif
@@ -129,11 +130,11 @@ struct drm_version {
 	int version_major;	  /**< Major version */
 	int version_minor;	  /**< Minor version */
 	int version_patchlevel;	  /**< Patch level */
-	size_t name_len;	  /**< Length of name buffer */
+	__kernel_size_t name_len;	  /**< Length of name buffer */
 	char __user *name;	  /**< Name of driver */
-	size_t date_len;	  /**< Length of date buffer */
+	__kernel_size_t date_len;	  /**< Length of date buffer */
 	char __user *date;	  /**< User-space buffer to hold date */
-	size_t desc_len;	  /**< Length of desc buffer */
+	__kernel_size_t desc_len;	  /**< Length of desc buffer */
 	char __user *desc;	  /**< User-space buffer to hold desc */
 };
 
@@ -143,7 +144,7 @@ struct drm_version {
  * \sa drmGetBusid() and drmSetBusId().
  */
 struct drm_unique {
-	size_t unique_len;	  /**< Length of unique */
+	__kernel_size_t unique_len;	  /**< Length of unique */
 	char __user *unique;	  /**< Unique name for driver instantiation */
 };
 

commit e2f5d2ea479b9b2619965d43db70939589afe43a
Author: Daniel Stone <daniels@collabora.com>
Date:   Fri May 22 13:34:51 2015 +0100

    drm/mode: Add user blob-creation ioctl
    
    Add an ioctl which allows users to create blob properties from supplied
    data. Currently this only supports modes, creating a drm_display_mode from
    the userspace drm_mode_modeinfo.
    
    v2: Removed size/type checks.
        Rebased on new patches to allow error propagation from create_blob,
        as well as avoiding double-allocation.
    
    Signed-off-by: Daniel Stone <daniels@collabora.com>
    Reviewed-by: Maarten Lankhorst <maarten.lankhorst@intel.com>
    Tested-by: Sean Paul <seanpaul@chromium.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index ff6ef62d084b..3801584a0c53 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -786,6 +786,8 @@ struct drm_prime_handle {
 #define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)
 #define DRM_IOCTL_MODE_CURSOR2		DRM_IOWR(0xBB, struct drm_mode_cursor2)
 #define DRM_IOCTL_MODE_ATOMIC		DRM_IOWR(0xBC, struct drm_mode_atomic)
+#define DRM_IOCTL_MODE_CREATEPROPBLOB	DRM_IOWR(0xBD, struct drm_mode_create_blob)
+#define DRM_IOCTL_MODE_DESTROYPROPBLOB	DRM_IOWR(0xBE, struct drm_mode_destroy_blob)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit e3eb3250d84ef97b766312345774367b6a310db8
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Feb 5 14:41:52 2015 +0000

    drm: add support for tiled/compressed/etc modifier in addfb2
    
    In DRM/KMS we are lacking a good way to deal with tiled/compressed
    formats.  Especially in the case of dmabuf/prime buffer sharing, where
    we cannot always rely on under-the-hood flags passed to driver specific
    gem-create ioctl to pass around these extra flags.
    
    The proposal is to add a per-plane format modifier.  This allows to, if
    necessary, use different tiling patters for sub-sampled planes, etc.
    The format modifiers are added at the end of the ioctl struct, so for
    legacy userspace it will be zero padded.
    
    v1: original
    v1.5: increase modifier to 64b
    
    v2: Incorporate review comments from the big thread, plus a few more.
    
    - Add a getcap so that userspace doesn't have to jump through hoops.
    - Allow modifiers only when a flag is set. That way drivers know when
      they're dealing with old userspace and need to fish out e.g. tiling
      from other information.
    - After rolling out checks for ->modifier to all drivers I've decided
      that this is way too fragile and needs an explicit opt-in flag. So
      do that instead.
    - Add a define (just for documentation really) for the "NONE"
      modifier. Imo we don't need to add mask #defines since drivers
      really should only do exact matches against values defined with
      fourcc_mod_code.
    - Drop the Samsung tiling modifier on Rob's request since he's not yet
      sure whether that one is accurate.
    
    v3:
    - Also add a new ->modifier[] array to struct drm_framebuffer and fill
      it in drm_helper_mode_fill_fb_struct. Requested by Tvrkto Uruslin.
    - Remove TODO in comment and add code comment that modifiers should be
      properly documented, requested by Rob.
    
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Daniel Stone <daniel@fooishbar.org>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Michel Dänzer <michel@daenzer.net>
    Signed-off-by: Rob Clark <robdclark@gmail.com> (v1.5)
    Reviewed-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Daniel Stone <daniels@collabora.com>
    Acked-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 01b2d6d0e355..ff6ef62d084b 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -630,6 +630,7 @@ struct drm_gem_open {
  */
 #define DRM_CAP_CURSOR_WIDTH		0x8
 #define DRM_CAP_CURSOR_HEIGHT		0x9
+#define DRM_CAP_ADDFB2_MODIFIERS	0x10
 
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {

commit d34f20d6e2f21bd3531b969dc40913181a8ae31a
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:56 2014 -0500

    drm: Atomic modeset ioctl
    
    The atomic modeset ioctl can be used to push any number of new values
    for object properties. The driver can then check the full device
    configuration as single unit, and try to apply the changes atomically.
    
    The ioctl simply takes a list of object IDs and property IDs and their
    values.
    
    Originally based on a patch from Ville Syrjälä, although it has mutated
    (mutilated?) enough since then that you probably shouldn't blame it on
    him ;-)
    
    The atomic support is hidden behind the DRM_CLIENT_CAP_ATOMIC cap (to
    protect legacy userspace) and drm.atomic module param (for now).
    
    v2: Check for file_priv->atomic to make sure we only allow userspace
    in-the-know to use atomic.
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    Reviewed-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index f7b2baf7ecb2..01b2d6d0e355 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -784,6 +784,7 @@ struct drm_prime_handle {
 #define DRM_IOCTL_MODE_OBJ_GETPROPERTIES	DRM_IOWR(0xB9, struct drm_mode_obj_get_properties)
 #define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)
 #define DRM_IOCTL_MODE_CURSOR2		DRM_IOWR(0xBB, struct drm_mode_cursor2)
+#define DRM_IOCTL_MODE_ATOMIC		DRM_IOWR(0xBC, struct drm_mode_atomic)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit 88a48e297b3a3bac6022c03babfb038f1a886cea
Author: Rob Clark <robdclark@gmail.com>
Date:   Thu Dec 18 16:01:50 2014 -0500

    drm: add atomic properties
    
    Once a driver is using atomic helpers for modeset, the next step is to
    switch over to atomic properties.  To do this, make sure that any
    modeset objects have their ->atomic_{get,set}_property() vfuncs suitably
    populated if they have custom properties (you did already remember to
    plug in atomic-helper func for the legacy ->set_property() vfuncs,
    right?), and then set DRIVER_ATOMIC bit in driver_features flag.
    
    A new cap is introduced, DRM_CLIENT_CAP_ATOMIC, for the purposes of
    shielding legacy userspace from atomic properties.  Mostly for the
    benefit of legacy DDX drivers that do silly things like getting/setting
    each property at startup (since some of the new atomic properties will
    be able to trigger modeset).
    
    Signed-off-by: Rob Clark <robdclark@gmail.com>
    [danvet: Squash in fixup patch to check for DRM_MODE_PROP_ATOMIC
    instaed of the CAP define when filtering properties. Reported by
    Tvrtko Uruslin, acked by Rob.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index b0b855613641..f7b2baf7ecb2 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -654,6 +654,13 @@ struct drm_get_cap {
  */
 #define DRM_CLIENT_CAP_UNIVERSAL_PLANES  2
 
+/**
+ * DRM_CLIENT_CAP_ATOMIC
+ *
+ * If set to 1, the DRM core will expose atomic properties to userspace
+ */
+#define DRM_CLIENT_CAP_ATOMIC	3
+
 /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
 struct drm_set_client_cap {
 	__u64 capability;

commit 735b9ffada0563afa52d0879cf6d630819ee68ad
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Mon Jun 9 14:39:50 2014 +0100

    drm: Driver-specific ioctls range from 0x40 to 0x9f
    
    DRM_COMMAND_END is 0xa0, so the last driver ioctl is 0x9f, not 0x99.
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 9abbeb924cbb..b0b855613641 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -780,7 +780,7 @@ struct drm_prime_handle {
 
 /**
  * Device specific ioctls should only be in their respective headers
- * The device specific ioctl range is from 0x40 to 0x99.
+ * The device specific ioctl range is from 0x40 to 0x9f.
  * Generic IOCTLS restart at 0xA0.
  *
  * \sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and

commit 2844ea3f252331cc0ecf3ae74f6226db2f580f8a
Merge: e3d6ddb35f62 6efa1f2f5417
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Apr 2 10:31:43 2014 +1000

    Merge branch 'primary-plane' of git://people.freedesktop.org/~robclark/linux into drm-next
    
    Here's the latest iteration of the universal planes work, which I believe is
    finally ready for merging.  Aside from the minor driver patches to use the
    new drm_for_each_legacy_plane() macro for plane loops, these should all have
    an r-b from Rob Clark now.
    
    Actual userspace-visibility is currently hidden behind a
    drm.universal_planes module parameter so that we can do some experimental
    testing of this before flipping it on universally.
    
    * 'primary-plane' of git://people.freedesktop.org/~robclark/linux:
      drm/doc: Update plane documentation and add plane helper library
      drm: Allow userspace to ask for universal plane list (v2)
      drm: Remove unused drm_crtc->fb
      drm: Replace crtc fb with primary plane fb (v3)
      drm/msm: Switch to universal plane API's
      drm: Add drm_crtc_init_with_planes() (v2)
      drm: Add plane type property (v2)
      drm: Add drm_universal_plane_init()
      drm: Add primary plane helpers (v3)
      drm: Make drm_crtc_check_viewport non-static
      drm/shmobile: Restrict plane loops to only operate on legacy planes
      drm/i915: Restrict plane loops to only operate on overlay planes (v2)
      drm/exynos: Restrict plane loops to only operate on overlay planes (v2)
      drm: Add support for multiple plane types (v2)

commit bfe8b5738a5d99156d83dc298729552ce82309d5
Author: Lespiau, Damien <damien.lespiau@intel.com>
Date:   Fri Mar 28 12:31:05 2014 +0000

    drm: Specify a bit more the DRM_CAP_CURSOR_{WIDTH, HEIGHT} caps
    
    Earlier this week, there was a bit of confusion about those new
    capabilities, to the point I think it's better to document the intention
    and API contract.
    
    The comment documents the current situation:
     - the radeon driver returns the only valid size for the hw
     - i915 returns the maximun cursor size
     - other drivers fall back to returning 64x64
    
    The common contract is to return a valid cursor size.
    
    Cc: Sagar Kamble <sagar.a.kamble@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Alex Deucher <alexander.deucher@amd.com>
    Cc: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index b06c8ed68707..ec6b259a879c 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -619,6 +619,15 @@ struct drm_gem_open {
 #define  DRM_PRIME_CAP_EXPORT		0x2
 #define DRM_CAP_TIMESTAMP_MONOTONIC	0x6
 #define DRM_CAP_ASYNC_PAGE_FLIP		0x7
+/*
+ * The CURSOR_WIDTH and CURSOR_HEIGHT capabilities return a valid widthxheight
+ * combination for the hardware cursor. The intention is that a hardware
+ * agnostic userspace can query a cursor plane size to use.
+ *
+ * Note that the cross-driver contract is to merely return a valid size;
+ * drivers are free to attach another meaning on top, eg. i915 returns the
+ * maximum plane size.
+ */
 #define DRM_CAP_CURSOR_WIDTH		0x8
 #define DRM_CAP_CURSOR_HEIGHT		0x9
 

commit 681e7ec730444b616a1e7278a22a2691094a64e6
Author: Matt Roper <matthew.d.roper@intel.com>
Date:   Tue Apr 1 15:22:42 2014 -0700

    drm: Allow userspace to ask for universal plane list (v2)
    
    Userspace clients which wish to receive all DRM planes (primary and
    cursor planes in addition to the traditional overlay planes) may set the
    DRM_CLIENT_CAP_UNIVERSAL_PLANES capability.
    
    v2: Hide behind drm.universal_planes module option [suggested by
        Daniel Vetter]
    
    Signed-off-by: Matt Roper <matthew.d.roper@intel.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index b06c8ed68707..6e4952b20e2e 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -637,6 +637,14 @@ struct drm_get_cap {
  */
 #define DRM_CLIENT_CAP_STEREO_3D	1
 
+/**
+ * DRM_CLIENT_CAP_UNIVERSAL_PLANES
+ *
+ * If set to 1, the DRM core will expose all planes (overlay, primary, and
+ * cursor) to userspace.
+ */
+#define DRM_CLIENT_CAP_UNIVERSAL_PLANES  2
+
 /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
 struct drm_set_client_cap {
 	__u64 capability;

commit 8716ed4e7bed4e4c7e3f37940e950ddc0362f450
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Wed Feb 12 12:48:23 2014 -0500

    drm: add DRM_CAPs for cursor size
    
    Some hardware may not support standard 64x64 cursors.  Add
    a drm cap to query the cursor size from the kernel.  Some examples
    include radeon CIK parts (128x128 cursors) and armada (32x64 or 64x32).
    This allows things like device specific ddxes to remove asics specific
    logic and also allows xf86-video-modesetting to work properly with hw
    cursors on this hardware. Default to 64 if the driver doesn't specify
    a size.
    
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Reviewed-by: Rob Clark <robdclark@gmail.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 3c9a833992e8..b06c8ed68707 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -619,6 +619,8 @@ struct drm_gem_open {
 #define  DRM_PRIME_CAP_EXPORT		0x2
 #define DRM_CAP_TIMESTAMP_MONOTONIC	0x6
 #define DRM_CAP_ASYNC_PAGE_FLIP		0x7
+#define DRM_CAP_CURSOR_WIDTH		0x8
+#define DRM_CAP_CURSOR_HEIGHT		0x9
 
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {

commit 05f51722a154e73019434bd020e50ddb941046c5
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Wed Dec 11 11:34:32 2013 +0100

    drm/bufs: remove handling of _DRM_GEM mappings
    
    Gone with the new gem vma offset manager from David.
    
    We can also ditch the uapi header definition from the enum since
    userspace never used this. It ended up in there purely for historical
    reasons (for reusing the old drm mmap code essentially), not because
    userspace ever needed it.
    
    Cc: David Herrmann <dh.herrmann@gmail.com>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 9b24d65fed72..3c9a833992e8 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -181,7 +181,6 @@ enum drm_map_type {
 	_DRM_AGP = 3,		  /**< AGP/GART */
 	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
 	_DRM_CONSISTENT = 5,	  /**< Consistent memory for PCI DMA */
-	_DRM_GEM = 6,		  /**< GEM object (obsolete) */
 };
 
 /**

commit 61d8e3282541139cf5bb31e4c42f952a6cc168f8
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:22 2013 +0100

    drm: Add a STEREO_3D capability to the SET_CLIENT_CAP ioctl
    
    This capability allows user space to control the delivery of modes with
    the 3D flags set. This is to not play games with current user space
    users not knowing anything about stereo 3D flags and that could try
    to set a mode with one or several of those bits set.
    
    So, the plan is to remove the stereo modes from the list of modes we
    give to DRM clients by default, and let them through if we are being
    told otherwise.
    
    stereo_allowed is bound to the drm_file structure to make it a
    per-client setting, not a global one.
    
    v2: Replace clearing 3D flags by discarding the stereo modes now that
        they are regular modes.
    v3: SET_CAP -> SET_CLIENT_CAP rename (Chris Wilson)
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 526baed365ff..9b24d65fed72 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -627,6 +627,15 @@ struct drm_get_cap {
 	__u64 value;
 };
 
+/**
+ * DRM_CLIENT_CAP_STEREO_3D
+ *
+ * if set to 1, the DRM core will expose the stereo 3D capabilities of the
+ * monitor by advertising the supported 3D layouts in the flags of struct
+ * drm_mode_modeinfo.
+ */
+#define DRM_CLIENT_CAP_STEREO_3D	1
+
 /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
 struct drm_set_client_cap {
 	__u64 capability;

commit 1c0814fed3a558146402713028cb7114734ec172
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:20 2013 +0100

    drm: Add a SET_CLIENT_CAP ioctl
    
    This ioctl can be used to turn some knobs in a DRM driver. The client
    can ask the DRM core for an alternate view of the reality: it can be
    useful to be able to instruct the core that the DRM client can handle
    new functionnality that would otherwise break current ABI.
    
    v2: Rename to ioctl from SET_CAP to SET_CLIENT_CAP (Chris Wilson)
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 1e09e8f257ba..526baed365ff 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -627,6 +627,12 @@ struct drm_get_cap {
 	__u64 value;
 };
 
+/** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */
+struct drm_set_client_cap {
+	__u64 capability;
+	__u64 value;
+};
+
 #define DRM_CLOEXEC O_CLOEXEC
 struct drm_prime_handle {
 	__u32 handle;
@@ -659,6 +665,7 @@ struct drm_prime_handle {
 #define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)
 #define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)
 #define DRM_IOCTL_GET_CAP		DRM_IOWR(0x0c, struct drm_get_cap)
+#define DRM_IOCTL_SET_CLIENT_CAP	DRM_IOW( 0x0d, struct drm_set_client_cap)
 
 #define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)
 #define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)

commit a99b57dbc09bfff57acd8a7c20f25dfa6cb892a5
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Wed Sep 25 16:45:19 2013 +0100

    drm: Move the GET_CAP macros next to the corresponding ioctl structure
    
    It's a tiny bit more logical to find the different capabilities you can
    use with the GET_CAP ioctl next to the structure rather than putting
    them at the end of the file.
    
    v2: Tab align the litterals (David Herrmann)
    v3: Make it clearer that DRM_PRIME_CAP_EXPORT/IMPORT are flags of
        DRM_CAP_PRIME.
    v4: Rebase on top of latest bits (DRM_CAP_ASYNC_PAGE_FLIP was
        introduced)
    
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com> (for v2)
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index ece867889cc7..1e09e8f257ba 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -611,6 +611,16 @@ struct drm_gem_open {
 	__u64 size;
 };
 
+#define DRM_CAP_DUMB_BUFFER		0x1
+#define DRM_CAP_VBLANK_HIGH_CRTC	0x2
+#define DRM_CAP_DUMB_PREFERRED_DEPTH	0x3
+#define DRM_CAP_DUMB_PREFER_SHADOW	0x4
+#define DRM_CAP_PRIME			0x5
+#define  DRM_PRIME_CAP_IMPORT		0x1
+#define  DRM_PRIME_CAP_EXPORT		0x2
+#define DRM_CAP_TIMESTAMP_MONOTONIC	0x6
+#define DRM_CAP_ASYNC_PAGE_FLIP		0x7
+
 /** DRM_IOCTL_GET_CAP ioctl argument type */
 struct drm_get_cap {
 	__u64 capability;
@@ -774,17 +784,6 @@ struct drm_event_vblank {
 	__u32 reserved;
 };
 
-#define DRM_CAP_DUMB_BUFFER 0x1
-#define DRM_CAP_VBLANK_HIGH_CRTC 0x2
-#define DRM_CAP_DUMB_PREFERRED_DEPTH 0x3
-#define DRM_CAP_DUMB_PREFER_SHADOW 0x4
-#define DRM_CAP_PRIME 0x5
-#define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
-#define DRM_CAP_ASYNC_PAGE_FLIP 0x7
-
-#define DRM_PRIME_CAP_IMPORT 0x1
-#define DRM_PRIME_CAP_EXPORT 0x2
-
 /* typedef area */
 #ifndef __KERNEL__
 typedef struct drm_clip_rect drm_clip_rect_t;

commit 62f2104f3fc11c4cfd1307429cb955bfa48dcb37
Author: Keith Packard <keithp@keithp.com>
Date:   Mon Jul 22 18:50:00 2013 -0700

    drm: Advertise async page flip ability through GETCAP ioctl
    
    Let applications know whether the kernel supports asynchronous page
    flipping.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 272580ca320f..ece867889cc7 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -780,6 +780,7 @@ struct drm_event_vblank {
 #define DRM_CAP_DUMB_PREFER_SHADOW 0x4
 #define DRM_CAP_PRIME 0x5
 #define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
+#define DRM_CAP_ASYNC_PAGE_FLIP 0x7
 
 #define DRM_PRIME_CAP_IMPORT 0x1
 #define DRM_PRIME_CAP_EXPORT 0x2

commit 0de23977cfeb5b357ec884ba15417ae118ff9e9b
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Wed Jul 24 21:07:52 2013 +0200

    drm/gem: convert to new unified vma manager
    
    Use the new vma manager instead of the old hashtable. Also convert all
    drivers to use the new convenience helpers. This drops all the
    (map_list.hash.key << PAGE_SHIFT) non-sense.
    
    Locking and access-management is exactly the same as before with an
    additional lock inside of the vma-manager, which strictly wouldn't be
    needed for gem.
    
    v2:
     - rebase on drm-next
     - init nodes via drm_vma_node_reset() in drm_gem.c
    v3:
     - fix tegra
    v4:
     - remove duplicate if (drm_vma_node_has_offset()) checks
     - inline now trivial drm_vma_node_offset_addr() calls
    v5:
     - skip node-reset on gem-init due to kzalloc()
     - do not allow mapping gem-objects with offsets (backwards compat)
     - remove unneccessary casts
    
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Rob Clark <robdclark@gmail.com>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Patrik Jakobsson <patrik.r.jakobsson@gmail.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@gmail.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 238a166b9fe6..272580ca320f 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -181,7 +181,7 @@ enum drm_map_type {
 	_DRM_AGP = 3,		  /**< AGP/GART */
 	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
 	_DRM_CONSISTENT = 5,	  /**< Consistent memory for PCI DMA */
-	_DRM_GEM = 6,		  /**< GEM object */
+	_DRM_GEM = 6,		  /**< GEM object (obsolete) */
 };
 
 /**

commit 4c813d4d759c0e6b83bfd73795e9526493556dc2
Author: Dave Airlie <airlied@redhat.com>
Date:   Thu Jun 20 11:48:52 2013 +1000

    drm: add hotspot support for cursors.
    
    So it looks like for virtual hw cursors on QXL we need to inform
    the "hw" device what the cursor hotspot parameters are. This
    makes sense if you think the host has to draw the cursor and interpret
    clicks from it. However the current modesetting interface doesn't support
    passing the hotspot information from userspace.
    
    This implements a new cursor ioctl, that takes the hotspot info as well,
    userspace can try calling the new interface and if it gets -ENOSYS it means
    its on an older kernel and can just fallback.
    
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 5a57be68bab7..238a166b9fe6 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -732,6 +732,7 @@ struct drm_prime_handle {
 #define DRM_IOCTL_MODE_ADDFB2		DRM_IOWR(0xB8, struct drm_mode_fb_cmd2)
 #define DRM_IOCTL_MODE_OBJ_GETPROPERTIES	DRM_IOWR(0xB9, struct drm_mode_obj_get_properties)
 #define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)
+#define DRM_IOCTL_MODE_CURSOR2		DRM_IOWR(0xBB, struct drm_mode_cursor2)
 
 /**
  * Device specific ioctls should only be in their respective headers

commit c55b6b3da25aa3af36ec51a13a4ed15fef0d7a73
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Apr 26 17:40:28 2013 +0300

    drm: Kill user_modes list and the associated ioctls
    
    There is no way to use modes added to the user_modes list. We never
    look at the contents of said list in the kernel, and the only operations
    userspace can do are attach and detach. So the only "benefit" of this
    interface is wasting kernel memory.
    
    Fortunately it seems no real user space application ever used these
    ioctls. So just kill them.
    
    Also remove the prototypes for the non-existing drm_mode_addmode_ioctl()
    and drm_mode_rmmode_ioctl() functions.
    
    v2: Use drm_noop instead of completely removing the ioctls
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 73a99e4664be..5a57be68bab7 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -711,8 +711,8 @@ struct drm_prime_handle {
 #define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)
 #define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)
 #define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)
-#define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd)
-#define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd)
+#define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd) /* deprecated (never worked) */
+#define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd) /* deprecated (never worked) */
 
 #define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)
 #define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)

commit b6330548383cf18d608faf1c2dc0c81c60476233
Author: Paul Sokolovsky <paul.sokolovsky@linaro.org>
Date:   Fri Apr 12 18:28:26 2013 -0500

    drm.h: Fix DRM compilation with bare-metal toolchain.
    
    An ifdef in drm.h expects to be compiled with full-fledged Linux
    toolchain, but it's common to compile kernel with just bare-metal
    toolchain which doesn't define __linux__. So, also add __KERNEL__
    check.
    
    [nm@ti.com: port forward to 3.9-rc6 and post to dri devel for feedback as RFC]
    Signed-off-by: Paul Sokolovsky <paul.sokolovsky@linaro.org>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 8d1e2bbee83a..73a99e4664be 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -36,7 +36,7 @@
 #ifndef _DRM_H_
 #define _DRM_H_
 
-#if defined(__linux__)
+#if defined(__KERNEL__) || defined(__linux__)
 
 #include <linux/types.h>
 #include <asm/ioctl.h>

commit c61eef726a78ae77b6ce223d01ea2130f465fe5c
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue Oct 23 18:53:26 2012 +0000

    drm: add support for monotonic vblank timestamps
    
    Jumps in the vblank and page flip event timestamps cause trouble for
    clients, so we should avoid them. The timestamp we get currently with
    gettimeofday can jump, so use instead monotonic timestamps.
    
    For backward compatibility use a module flag to revert back to using
    gettimeofday timestamps. Add also a DRM_CAP_TIMESTAMP_MONOTONIC flag
    that is simply a read only version of the module flag, so that clients
    can query this without depending on sysfs.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
index 1e3481edf062..8d1e2bbee83a 100644
--- a/include/uapi/drm/drm.h
+++ b/include/uapi/drm/drm.h
@@ -778,6 +778,7 @@ struct drm_event_vblank {
 #define DRM_CAP_DUMB_PREFERRED_DEPTH 0x3
 #define DRM_CAP_DUMB_PREFER_SHADOW 0x4
 #define DRM_CAP_PRIME 0x5
+#define DRM_CAP_TIMESTAMP_MONOTONIC 0x6
 
 #define DRM_PRIME_CAP_IMPORT 0x1
 #define DRM_PRIME_CAP_EXPORT 0x2

commit 718dcedd7e87f448a1eeeda4d1a986284c243110
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 4 18:21:50 2012 +0100

    UAPI: (Scripted) Disintegrate include/drm
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/drm/drm.h b/include/uapi/drm/drm.h
new file mode 100644
index 000000000000..1e3481edf062
--- /dev/null
+++ b/include/uapi/drm/drm.h
@@ -0,0 +1,830 @@
+/**
+ * \file drm.h
+ * Header for the Direct Rendering Manager
+ *
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ *
+ * \par Acknowledgments:
+ * Dec 1999, Richard Henderson <rth@twiddle.net>, move to generic \c cmpxchg.
+ */
+
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_H_
+#define _DRM_H_
+
+#if defined(__linux__)
+
+#include <linux/types.h>
+#include <asm/ioctl.h>
+typedef unsigned int drm_handle_t;
+
+#else /* One of the BSDs */
+
+#include <sys/ioccom.h>
+#include <sys/types.h>
+typedef int8_t   __s8;
+typedef uint8_t  __u8;
+typedef int16_t  __s16;
+typedef uint16_t __u16;
+typedef int32_t  __s32;
+typedef uint32_t __u32;
+typedef int64_t  __s64;
+typedef uint64_t __u64;
+typedef unsigned long drm_handle_t;
+
+#endif
+
+#define DRM_NAME	"drm"	  /**< Name in kernel, /dev, and /proc */
+#define DRM_MIN_ORDER	5	  /**< At least 2^5 bytes = 32 bytes */
+#define DRM_MAX_ORDER	22	  /**< Up to 2^22 bytes = 4MB */
+#define DRM_RAM_PERCENT 10	  /**< How much system ram can we lock? */
+
+#define _DRM_LOCK_HELD	0x80000000U /**< Hardware lock is held */
+#define _DRM_LOCK_CONT	0x40000000U /**< Hardware lock is contended */
+#define _DRM_LOCK_IS_HELD(lock)	   ((lock) & _DRM_LOCK_HELD)
+#define _DRM_LOCK_IS_CONT(lock)	   ((lock) & _DRM_LOCK_CONT)
+#define _DRM_LOCKING_CONTEXT(lock) ((lock) & ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))
+
+typedef unsigned int drm_context_t;
+typedef unsigned int drm_drawable_t;
+typedef unsigned int drm_magic_t;
+
+/**
+ * Cliprect.
+ *
+ * \warning: If you change this structure, make sure you change
+ * XF86DRIClipRectRec in the server as well
+ *
+ * \note KW: Actually it's illegal to change either for
+ * backwards-compatibility reasons.
+ */
+struct drm_clip_rect {
+	unsigned short x1;
+	unsigned short y1;
+	unsigned short x2;
+	unsigned short y2;
+};
+
+/**
+ * Drawable information.
+ */
+struct drm_drawable_info {
+	unsigned int num_rects;
+	struct drm_clip_rect *rects;
+};
+
+/**
+ * Texture region,
+ */
+struct drm_tex_region {
+	unsigned char next;
+	unsigned char prev;
+	unsigned char in_use;
+	unsigned char padding;
+	unsigned int age;
+};
+
+/**
+ * Hardware lock.
+ *
+ * The lock structure is a simple cache-line aligned integer.  To avoid
+ * processor bus contention on a multiprocessor system, there should not be any
+ * other data stored in the same cache line.
+ */
+struct drm_hw_lock {
+	__volatile__ unsigned int lock;		/**< lock variable */
+	char padding[60];			/**< Pad to cache line */
+};
+
+/**
+ * DRM_IOCTL_VERSION ioctl argument type.
+ *
+ * \sa drmGetVersion().
+ */
+struct drm_version {
+	int version_major;	  /**< Major version */
+	int version_minor;	  /**< Minor version */
+	int version_patchlevel;	  /**< Patch level */
+	size_t name_len;	  /**< Length of name buffer */
+	char __user *name;	  /**< Name of driver */
+	size_t date_len;	  /**< Length of date buffer */
+	char __user *date;	  /**< User-space buffer to hold date */
+	size_t desc_len;	  /**< Length of desc buffer */
+	char __user *desc;	  /**< User-space buffer to hold desc */
+};
+
+/**
+ * DRM_IOCTL_GET_UNIQUE ioctl argument type.
+ *
+ * \sa drmGetBusid() and drmSetBusId().
+ */
+struct drm_unique {
+	size_t unique_len;	  /**< Length of unique */
+	char __user *unique;	  /**< Unique name for driver instantiation */
+};
+
+struct drm_list {
+	int count;		  /**< Length of user-space structures */
+	struct drm_version __user *version;
+};
+
+struct drm_block {
+	int unused;
+};
+
+/**
+ * DRM_IOCTL_CONTROL ioctl argument type.
+ *
+ * \sa drmCtlInstHandler() and drmCtlUninstHandler().
+ */
+struct drm_control {
+	enum {
+		DRM_ADD_COMMAND,
+		DRM_RM_COMMAND,
+		DRM_INST_HANDLER,
+		DRM_UNINST_HANDLER
+	} func;
+	int irq;
+};
+
+/**
+ * Type of memory to map.
+ */
+enum drm_map_type {
+	_DRM_FRAME_BUFFER = 0,	  /**< WC (no caching), no core dump */
+	_DRM_REGISTERS = 1,	  /**< no caching, no core dump */
+	_DRM_SHM = 2,		  /**< shared, cached */
+	_DRM_AGP = 3,		  /**< AGP/GART */
+	_DRM_SCATTER_GATHER = 4,  /**< Scatter/gather memory for PCI DMA */
+	_DRM_CONSISTENT = 5,	  /**< Consistent memory for PCI DMA */
+	_DRM_GEM = 6,		  /**< GEM object */
+};
+
+/**
+ * Memory mapping flags.
+ */
+enum drm_map_flags {
+	_DRM_RESTRICTED = 0x01,	     /**< Cannot be mapped to user-virtual */
+	_DRM_READ_ONLY = 0x02,
+	_DRM_LOCKED = 0x04,	     /**< shared, cached, locked */
+	_DRM_KERNEL = 0x08,	     /**< kernel requires access */
+	_DRM_WRITE_COMBINING = 0x10, /**< use write-combining if available */
+	_DRM_CONTAINS_LOCK = 0x20,   /**< SHM page that contains lock */
+	_DRM_REMOVABLE = 0x40,	     /**< Removable mapping */
+	_DRM_DRIVER = 0x80	     /**< Managed by driver */
+};
+
+struct drm_ctx_priv_map {
+	unsigned int ctx_id;	 /**< Context requesting private mapping */
+	void *handle;		 /**< Handle of map */
+};
+
+/**
+ * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
+ * argument type.
+ *
+ * \sa drmAddMap().
+ */
+struct drm_map {
+	unsigned long offset;	 /**< Requested physical address (0 for SAREA)*/
+	unsigned long size;	 /**< Requested physical size (bytes) */
+	enum drm_map_type type;	 /**< Type of memory to map */
+	enum drm_map_flags flags;	 /**< Flags */
+	void *handle;		 /**< User-space: "Handle" to pass to mmap() */
+				 /**< Kernel-space: kernel-virtual address */
+	int mtrr;		 /**< MTRR slot used */
+	/*   Private data */
+};
+
+/**
+ * DRM_IOCTL_GET_CLIENT ioctl argument type.
+ */
+struct drm_client {
+	int idx;		/**< Which client desired? */
+	int auth;		/**< Is client authenticated? */
+	unsigned long pid;	/**< Process ID */
+	unsigned long uid;	/**< User ID */
+	unsigned long magic;	/**< Magic */
+	unsigned long iocs;	/**< Ioctl count */
+};
+
+enum drm_stat_type {
+	_DRM_STAT_LOCK,
+	_DRM_STAT_OPENS,
+	_DRM_STAT_CLOSES,
+	_DRM_STAT_IOCTLS,
+	_DRM_STAT_LOCKS,
+	_DRM_STAT_UNLOCKS,
+	_DRM_STAT_VALUE,	/**< Generic value */
+	_DRM_STAT_BYTE,		/**< Generic byte counter (1024bytes/K) */
+	_DRM_STAT_COUNT,	/**< Generic non-byte counter (1000/k) */
+
+	_DRM_STAT_IRQ,		/**< IRQ */
+	_DRM_STAT_PRIMARY,	/**< Primary DMA bytes */
+	_DRM_STAT_SECONDARY,	/**< Secondary DMA bytes */
+	_DRM_STAT_DMA,		/**< DMA */
+	_DRM_STAT_SPECIAL,	/**< Special DMA (e.g., priority or polled) */
+	_DRM_STAT_MISSED	/**< Missed DMA opportunity */
+	    /* Add to the *END* of the list */
+};
+
+/**
+ * DRM_IOCTL_GET_STATS ioctl argument type.
+ */
+struct drm_stats {
+	unsigned long count;
+	struct {
+		unsigned long value;
+		enum drm_stat_type type;
+	} data[15];
+};
+
+/**
+ * Hardware locking flags.
+ */
+enum drm_lock_flags {
+	_DRM_LOCK_READY = 0x01,	     /**< Wait until hardware is ready for DMA */
+	_DRM_LOCK_QUIESCENT = 0x02,  /**< Wait until hardware quiescent */
+	_DRM_LOCK_FLUSH = 0x04,	     /**< Flush this context's DMA queue first */
+	_DRM_LOCK_FLUSH_ALL = 0x08,  /**< Flush all DMA queues first */
+	/* These *HALT* flags aren't supported yet
+	   -- they will be used to support the
+	   full-screen DGA-like mode. */
+	_DRM_HALT_ALL_QUEUES = 0x10, /**< Halt all current and future queues */
+	_DRM_HALT_CUR_QUEUES = 0x20  /**< Halt all current queues */
+};
+
+/**
+ * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
+ *
+ * \sa drmGetLock() and drmUnlock().
+ */
+struct drm_lock {
+	int context;
+	enum drm_lock_flags flags;
+};
+
+/**
+ * DMA flags
+ *
+ * \warning
+ * These values \e must match xf86drm.h.
+ *
+ * \sa drm_dma.
+ */
+enum drm_dma_flags {
+	/* Flags for DMA buffer dispatch */
+	_DRM_DMA_BLOCK = 0x01,	      /**<
+				       * Block until buffer dispatched.
+				       *
+				       * \note The buffer may not yet have
+				       * been processed by the hardware --
+				       * getting a hardware lock with the
+				       * hardware quiescent will ensure
+				       * that the buffer has been
+				       * processed.
+				       */
+	_DRM_DMA_WHILE_LOCKED = 0x02, /**< Dispatch while lock held */
+	_DRM_DMA_PRIORITY = 0x04,     /**< High priority dispatch */
+
+	/* Flags for DMA buffer request */
+	_DRM_DMA_WAIT = 0x10,	      /**< Wait for free buffers */
+	_DRM_DMA_SMALLER_OK = 0x20,   /**< Smaller-than-requested buffers OK */
+	_DRM_DMA_LARGER_OK = 0x40     /**< Larger-than-requested buffers OK */
+};
+
+/**
+ * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
+ *
+ * \sa drmAddBufs().
+ */
+struct drm_buf_desc {
+	int count;		 /**< Number of buffers of this size */
+	int size;		 /**< Size in bytes */
+	int low_mark;		 /**< Low water mark */
+	int high_mark;		 /**< High water mark */
+	enum {
+		_DRM_PAGE_ALIGN = 0x01,	/**< Align on page boundaries for DMA */
+		_DRM_AGP_BUFFER = 0x02,	/**< Buffer is in AGP space */
+		_DRM_SG_BUFFER = 0x04,	/**< Scatter/gather memory buffer */
+		_DRM_FB_BUFFER = 0x08,	/**< Buffer is in frame buffer */
+		_DRM_PCI_BUFFER_RO = 0x10 /**< Map PCI DMA buffer read-only */
+	} flags;
+	unsigned long agp_start; /**<
+				  * Start address of where the AGP buffers are
+				  * in the AGP aperture
+				  */
+};
+
+/**
+ * DRM_IOCTL_INFO_BUFS ioctl argument type.
+ */
+struct drm_buf_info {
+	int count;		/**< Entries in list */
+	struct drm_buf_desc __user *list;
+};
+
+/**
+ * DRM_IOCTL_FREE_BUFS ioctl argument type.
+ */
+struct drm_buf_free {
+	int count;
+	int __user *list;
+};
+
+/**
+ * Buffer information
+ *
+ * \sa drm_buf_map.
+ */
+struct drm_buf_pub {
+	int idx;		       /**< Index into the master buffer list */
+	int total;		       /**< Buffer size */
+	int used;		       /**< Amount of buffer in use (for DMA) */
+	void __user *address;	       /**< Address of buffer */
+};
+
+/**
+ * DRM_IOCTL_MAP_BUFS ioctl argument type.
+ */
+struct drm_buf_map {
+	int count;		/**< Length of the buffer list */
+	void __user *virtual;		/**< Mmap'd area in user-virtual */
+	struct drm_buf_pub __user *list;	/**< Buffer information */
+};
+
+/**
+ * DRM_IOCTL_DMA ioctl argument type.
+ *
+ * Indices here refer to the offset into the buffer list in drm_buf_get.
+ *
+ * \sa drmDMA().
+ */
+struct drm_dma {
+	int context;			  /**< Context handle */
+	int send_count;			  /**< Number of buffers to send */
+	int __user *send_indices;	  /**< List of handles to buffers */
+	int __user *send_sizes;		  /**< Lengths of data to send */
+	enum drm_dma_flags flags;	  /**< Flags */
+	int request_count;		  /**< Number of buffers requested */
+	int request_size;		  /**< Desired size for buffers */
+	int __user *request_indices;	  /**< Buffer information */
+	int __user *request_sizes;
+	int granted_count;		  /**< Number of buffers granted */
+};
+
+enum drm_ctx_flags {
+	_DRM_CONTEXT_PRESERVED = 0x01,
+	_DRM_CONTEXT_2DONLY = 0x02
+};
+
+/**
+ * DRM_IOCTL_ADD_CTX ioctl argument type.
+ *
+ * \sa drmCreateContext() and drmDestroyContext().
+ */
+struct drm_ctx {
+	drm_context_t handle;
+	enum drm_ctx_flags flags;
+};
+
+/**
+ * DRM_IOCTL_RES_CTX ioctl argument type.
+ */
+struct drm_ctx_res {
+	int count;
+	struct drm_ctx __user *contexts;
+};
+
+/**
+ * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
+ */
+struct drm_draw {
+	drm_drawable_t handle;
+};
+
+/**
+ * DRM_IOCTL_UPDATE_DRAW ioctl argument type.
+ */
+typedef enum {
+	DRM_DRAWABLE_CLIPRECTS,
+} drm_drawable_info_type_t;
+
+struct drm_update_draw {
+	drm_drawable_t handle;
+	unsigned int type;
+	unsigned int num;
+	unsigned long long data;
+};
+
+/**
+ * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
+ */
+struct drm_auth {
+	drm_magic_t magic;
+};
+
+/**
+ * DRM_IOCTL_IRQ_BUSID ioctl argument type.
+ *
+ * \sa drmGetInterruptFromBusID().
+ */
+struct drm_irq_busid {
+	int irq;	/**< IRQ number */
+	int busnum;	/**< bus number */
+	int devnum;	/**< device number */
+	int funcnum;	/**< function number */
+};
+
+enum drm_vblank_seq_type {
+	_DRM_VBLANK_ABSOLUTE = 0x0,	/**< Wait for specific vblank sequence number */
+	_DRM_VBLANK_RELATIVE = 0x1,	/**< Wait for given number of vblanks */
+	/* bits 1-6 are reserved for high crtcs */
+	_DRM_VBLANK_HIGH_CRTC_MASK = 0x0000003e,
+	_DRM_VBLANK_EVENT = 0x4000000,   /**< Send event instead of blocking */
+	_DRM_VBLANK_FLIP = 0x8000000,   /**< Scheduled buffer swap should flip */
+	_DRM_VBLANK_NEXTONMISS = 0x10000000,	/**< If missed, wait for next vblank */
+	_DRM_VBLANK_SECONDARY = 0x20000000,	/**< Secondary display controller */
+	_DRM_VBLANK_SIGNAL = 0x40000000	/**< Send signal instead of blocking, unsupported */
+};
+#define _DRM_VBLANK_HIGH_CRTC_SHIFT 1
+
+#define _DRM_VBLANK_TYPES_MASK (_DRM_VBLANK_ABSOLUTE | _DRM_VBLANK_RELATIVE)
+#define _DRM_VBLANK_FLAGS_MASK (_DRM_VBLANK_EVENT | _DRM_VBLANK_SIGNAL | \
+				_DRM_VBLANK_SECONDARY | _DRM_VBLANK_NEXTONMISS)
+
+struct drm_wait_vblank_request {
+	enum drm_vblank_seq_type type;
+	unsigned int sequence;
+	unsigned long signal;
+};
+
+struct drm_wait_vblank_reply {
+	enum drm_vblank_seq_type type;
+	unsigned int sequence;
+	long tval_sec;
+	long tval_usec;
+};
+
+/**
+ * DRM_IOCTL_WAIT_VBLANK ioctl argument type.
+ *
+ * \sa drmWaitVBlank().
+ */
+union drm_wait_vblank {
+	struct drm_wait_vblank_request request;
+	struct drm_wait_vblank_reply reply;
+};
+
+#define _DRM_PRE_MODESET 1
+#define _DRM_POST_MODESET 2
+
+/**
+ * DRM_IOCTL_MODESET_CTL ioctl argument type
+ *
+ * \sa drmModesetCtl().
+ */
+struct drm_modeset_ctl {
+	__u32 crtc;
+	__u32 cmd;
+};
+
+/**
+ * DRM_IOCTL_AGP_ENABLE ioctl argument type.
+ *
+ * \sa drmAgpEnable().
+ */
+struct drm_agp_mode {
+	unsigned long mode;	/**< AGP mode */
+};
+
+/**
+ * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
+ *
+ * \sa drmAgpAlloc() and drmAgpFree().
+ */
+struct drm_agp_buffer {
+	unsigned long size;	/**< In bytes -- will round to page boundary */
+	unsigned long handle;	/**< Used for binding / unbinding */
+	unsigned long type;	/**< Type of memory to allocate */
+	unsigned long physical;	/**< Physical used by i810 */
+};
+
+/**
+ * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
+ *
+ * \sa drmAgpBind() and drmAgpUnbind().
+ */
+struct drm_agp_binding {
+	unsigned long handle;	/**< From drm_agp_buffer */
+	unsigned long offset;	/**< In bytes -- will round to page boundary */
+};
+
+/**
+ * DRM_IOCTL_AGP_INFO ioctl argument type.
+ *
+ * \sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),
+ * drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
+ * drmAgpVendorId() and drmAgpDeviceId().
+ */
+struct drm_agp_info {
+	int agp_version_major;
+	int agp_version_minor;
+	unsigned long mode;
+	unsigned long aperture_base;	/* physical address */
+	unsigned long aperture_size;	/* bytes */
+	unsigned long memory_allowed;	/* bytes */
+	unsigned long memory_used;
+
+	/* PCI information */
+	unsigned short id_vendor;
+	unsigned short id_device;
+};
+
+/**
+ * DRM_IOCTL_SG_ALLOC ioctl argument type.
+ */
+struct drm_scatter_gather {
+	unsigned long size;	/**< In bytes -- will round to page boundary */
+	unsigned long handle;	/**< Used for mapping / unmapping */
+};
+
+/**
+ * DRM_IOCTL_SET_VERSION ioctl argument type.
+ */
+struct drm_set_version {
+	int drm_di_major;
+	int drm_di_minor;
+	int drm_dd_major;
+	int drm_dd_minor;
+};
+
+/** DRM_IOCTL_GEM_CLOSE ioctl argument type */
+struct drm_gem_close {
+	/** Handle of the object to be closed. */
+	__u32 handle;
+	__u32 pad;
+};
+
+/** DRM_IOCTL_GEM_FLINK ioctl argument type */
+struct drm_gem_flink {
+	/** Handle for the object being named */
+	__u32 handle;
+
+	/** Returned global name */
+	__u32 name;
+};
+
+/** DRM_IOCTL_GEM_OPEN ioctl argument type */
+struct drm_gem_open {
+	/** Name of object being opened */
+	__u32 name;
+
+	/** Returned handle for the object */
+	__u32 handle;
+
+	/** Returned size of the object */
+	__u64 size;
+};
+
+/** DRM_IOCTL_GET_CAP ioctl argument type */
+struct drm_get_cap {
+	__u64 capability;
+	__u64 value;
+};
+
+#define DRM_CLOEXEC O_CLOEXEC
+struct drm_prime_handle {
+	__u32 handle;
+
+	/** Flags.. only applicable for handle->fd */
+	__u32 flags;
+
+	/** Returned dmabuf file descriptor */
+	__s32 fd;
+};
+
+#include <drm/drm_mode.h>
+
+#define DRM_IOCTL_BASE			'd'
+#define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)
+#define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)
+#define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)
+#define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)
+
+#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)
+#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)
+#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)
+#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)
+#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)
+#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)
+#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)
+#define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)
+#define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08, struct drm_modeset_ctl)
+#define DRM_IOCTL_GEM_CLOSE		DRM_IOW (0x09, struct drm_gem_close)
+#define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)
+#define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)
+#define DRM_IOCTL_GET_CAP		DRM_IOWR(0x0c, struct drm_get_cap)
+
+#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)
+#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)
+#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)
+#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)
+#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)
+#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)
+#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)
+#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)
+#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)
+#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)
+#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)
+
+#define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)
+
+#define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)
+#define DRM_IOCTL_GET_SAREA_CTX 	DRM_IOWR(0x1d, struct drm_ctx_priv_map)
+
+#define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)
+#define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)
+
+#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)
+#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)
+#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)
+#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)
+#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)
+#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)
+#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)
+#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)
+#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)
+#define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)
+#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)
+#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)
+#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)
+
+#define DRM_IOCTL_PRIME_HANDLE_TO_FD    DRM_IOWR(0x2d, struct drm_prime_handle)
+#define DRM_IOCTL_PRIME_FD_TO_HANDLE    DRM_IOWR(0x2e, struct drm_prime_handle)
+
+#define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)
+#define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)
+#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)
+#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)
+#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)
+#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)
+
+#define DRM_IOCTL_SG_ALLOC		DRM_IOWR(0x38, struct drm_scatter_gather)
+#define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)
+
+#define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)
+
+#define DRM_IOCTL_UPDATE_DRAW		DRM_IOW(0x3f, struct drm_update_draw)
+
+#define DRM_IOCTL_MODE_GETRESOURCES	DRM_IOWR(0xA0, struct drm_mode_card_res)
+#define DRM_IOCTL_MODE_GETCRTC		DRM_IOWR(0xA1, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_SETCRTC		DRM_IOWR(0xA2, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_CURSOR		DRM_IOWR(0xA3, struct drm_mode_cursor)
+#define DRM_IOCTL_MODE_GETGAMMA		DRM_IOWR(0xA4, struct drm_mode_crtc_lut)
+#define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)
+#define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)
+#define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)
+#define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd)
+#define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd)
+
+#define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)
+#define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)
+#define DRM_IOCTL_MODE_GETPROPBLOB	DRM_IOWR(0xAC, struct drm_mode_get_blob)
+#define DRM_IOCTL_MODE_GETFB		DRM_IOWR(0xAD, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_ADDFB		DRM_IOWR(0xAE, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_RMFB		DRM_IOWR(0xAF, unsigned int)
+#define DRM_IOCTL_MODE_PAGE_FLIP	DRM_IOWR(0xB0, struct drm_mode_crtc_page_flip)
+#define DRM_IOCTL_MODE_DIRTYFB		DRM_IOWR(0xB1, struct drm_mode_fb_dirty_cmd)
+
+#define DRM_IOCTL_MODE_CREATE_DUMB DRM_IOWR(0xB2, struct drm_mode_create_dumb)
+#define DRM_IOCTL_MODE_MAP_DUMB    DRM_IOWR(0xB3, struct drm_mode_map_dumb)
+#define DRM_IOCTL_MODE_DESTROY_DUMB    DRM_IOWR(0xB4, struct drm_mode_destroy_dumb)
+#define DRM_IOCTL_MODE_GETPLANERESOURCES DRM_IOWR(0xB5, struct drm_mode_get_plane_res)
+#define DRM_IOCTL_MODE_GETPLANE	DRM_IOWR(0xB6, struct drm_mode_get_plane)
+#define DRM_IOCTL_MODE_SETPLANE	DRM_IOWR(0xB7, struct drm_mode_set_plane)
+#define DRM_IOCTL_MODE_ADDFB2		DRM_IOWR(0xB8, struct drm_mode_fb_cmd2)
+#define DRM_IOCTL_MODE_OBJ_GETPROPERTIES	DRM_IOWR(0xB9, struct drm_mode_obj_get_properties)
+#define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)
+
+/**
+ * Device specific ioctls should only be in their respective headers
+ * The device specific ioctl range is from 0x40 to 0x99.
+ * Generic IOCTLS restart at 0xA0.
+ *
+ * \sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and
+ * drmCommandReadWrite().
+ */
+#define DRM_COMMAND_BASE                0x40
+#define DRM_COMMAND_END			0xA0
+
+/**
+ * Header for events written back to userspace on the drm fd.  The
+ * type defines the type of event, the length specifies the total
+ * length of the event (including the header), and user_data is
+ * typically a 64 bit value passed with the ioctl that triggered the
+ * event.  A read on the drm fd will always only return complete
+ * events, that is, if for example the read buffer is 100 bytes, and
+ * there are two 64 byte events pending, only one will be returned.
+ *
+ * Event types 0 - 0x7fffffff are generic drm events, 0x80000000 and
+ * up are chipset specific.
+ */
+struct drm_event {
+	__u32 type;
+	__u32 length;
+};
+
+#define DRM_EVENT_VBLANK 0x01
+#define DRM_EVENT_FLIP_COMPLETE 0x02
+
+struct drm_event_vblank {
+	struct drm_event base;
+	__u64 user_data;
+	__u32 tv_sec;
+	__u32 tv_usec;
+	__u32 sequence;
+	__u32 reserved;
+};
+
+#define DRM_CAP_DUMB_BUFFER 0x1
+#define DRM_CAP_VBLANK_HIGH_CRTC 0x2
+#define DRM_CAP_DUMB_PREFERRED_DEPTH 0x3
+#define DRM_CAP_DUMB_PREFER_SHADOW 0x4
+#define DRM_CAP_PRIME 0x5
+
+#define DRM_PRIME_CAP_IMPORT 0x1
+#define DRM_PRIME_CAP_EXPORT 0x2
+
+/* typedef area */
+#ifndef __KERNEL__
+typedef struct drm_clip_rect drm_clip_rect_t;
+typedef struct drm_drawable_info drm_drawable_info_t;
+typedef struct drm_tex_region drm_tex_region_t;
+typedef struct drm_hw_lock drm_hw_lock_t;
+typedef struct drm_version drm_version_t;
+typedef struct drm_unique drm_unique_t;
+typedef struct drm_list drm_list_t;
+typedef struct drm_block drm_block_t;
+typedef struct drm_control drm_control_t;
+typedef enum drm_map_type drm_map_type_t;
+typedef enum drm_map_flags drm_map_flags_t;
+typedef struct drm_ctx_priv_map drm_ctx_priv_map_t;
+typedef struct drm_map drm_map_t;
+typedef struct drm_client drm_client_t;
+typedef enum drm_stat_type drm_stat_type_t;
+typedef struct drm_stats drm_stats_t;
+typedef enum drm_lock_flags drm_lock_flags_t;
+typedef struct drm_lock drm_lock_t;
+typedef enum drm_dma_flags drm_dma_flags_t;
+typedef struct drm_buf_desc drm_buf_desc_t;
+typedef struct drm_buf_info drm_buf_info_t;
+typedef struct drm_buf_free drm_buf_free_t;
+typedef struct drm_buf_pub drm_buf_pub_t;
+typedef struct drm_buf_map drm_buf_map_t;
+typedef struct drm_dma drm_dma_t;
+typedef union drm_wait_vblank drm_wait_vblank_t;
+typedef struct drm_agp_mode drm_agp_mode_t;
+typedef enum drm_ctx_flags drm_ctx_flags_t;
+typedef struct drm_ctx drm_ctx_t;
+typedef struct drm_ctx_res drm_ctx_res_t;
+typedef struct drm_draw drm_draw_t;
+typedef struct drm_update_draw drm_update_draw_t;
+typedef struct drm_auth drm_auth_t;
+typedef struct drm_irq_busid drm_irq_busid_t;
+typedef enum drm_vblank_seq_type drm_vblank_seq_type_t;
+
+typedef struct drm_agp_buffer drm_agp_buffer_t;
+typedef struct drm_agp_binding drm_agp_binding_t;
+typedef struct drm_agp_info drm_agp_info_t;
+typedef struct drm_scatter_gather drm_scatter_gather_t;
+typedef struct drm_set_version drm_set_version_t;
+#endif
+
+#endif
