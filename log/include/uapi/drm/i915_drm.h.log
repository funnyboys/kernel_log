commit 4ef10fe05ba0b08ce7029c07878afe3c8d5754d8
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 24 11:54:57 2020 -0700

    drm/i915/perf: add new open param to configure polling of OA buffer
    
    This new parameter let's the application choose how often the OA
    buffer should be checked on the CPU side for data availability. Longer
    polling period tend to reduce CPU overhead if the application does not
    care about somewhat real time data collection.
    
    v2: Allow disabling polling completely with 0 value (Lionel)
    v3: Version the new parameter (Joonas)
    v4: Rebase (Umesh)
    v5: Make poll delay value of 0 invalid (Umesh)
    v6:
    - Describe poll_oa_period (Ashutosh)
    - Fix comment for new poll parameter (Lionel)
    - Drop open_flags in read_properties_unlocked (Lionel)
    - Rename uapi parameter (Ashutosh)
    v7: Reword the comment in uapi (Ashutosh)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Umesh Nerlige Ramappa <umesh.nerlige.ramappa@intel.com>
    Reviewed-by: Ashutosh Dixit <ashutosh.dixit@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200324185457.14635-4-umesh.nerlige.ramappa@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index db649d03ab52..14b67cd6b54b 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1980,6 +1980,19 @@ enum drm_i915_perf_property_id {
 	 */
 	DRM_I915_PERF_PROP_GLOBAL_SSEU,
 
+	/**
+	 * This optional parameter specifies the timer interval in nanoseconds
+	 * at which the i915 driver will check the OA buffer for available data.
+	 * Minimum allowed value is 100 microseconds. A default value is used by
+	 * the driver if this parameter is not specified. Note that larger timer
+	 * values will reduce cpu consumption during OA perf captures. However,
+	 * excessively large values would potentially result in OA buffer
+	 * overwrites as captures reach end of the OA buffer.
+	 *
+	 * This property is available in perf revision 5.
+	 */
+	DRM_I915_PERF_PROP_POLL_OA_PERIOD,
+
 	DRM_I915_PERF_PROP_MAX /* non-ABI */
 };
 

commit 11ecbdddf2f8b6cc2480aff6d877b7a4076e3b7f
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 17 15:22:22 2020 +0200

    drm/i915/perf: introduce global sseu pinning
    
    On Gen11 powergating half the execution units is a functional
    requirement when using the VME samplers. Not fullfilling this
    requirement can lead to hangs.
    
    This unfortunately plays fairly poorly with the NOA requirements. NOA
    requires a stable power configuration to maintain its configuration.
    
    As a result using OA (and NOA feeding into it) so far has required us
    to use a power configuration that can work for all contexts. The only
    power configuration fullfilling this is powergating half the execution
    units.
    
    This makes performance analysis for 3D workloads somewhat pointless.
    
    Failing to find a solution that would work for everybody, this change
    introduces a new i915-perf stream open parameter that punts the
    decision off to userspace. If this parameter is omitted, the existing
    Gen11 behavior remains (half EU array powergating).
    
    This change takes the initiative to move all perf related sseu
    configuration into i915_perf.c
    
    v2: Make parameter priviliged if different from default
    
    v3: Fix context modifying its sseu config while i915-perf is enabled
    
    v4: Always consider global sseu a privileged operation (Tvrtko)
        Override req_sseu point in intel_sseu_make_rpcs() (Tvrtko)
        Remove unrelated changes (Tvrtko)
    
    v5: Some typos (Tvrtko)
        Process sseu param in read_properties_unlocked() (Tvrtko)
    
    v6: Actually commit the bits from v5...
        Fixup some checkpath warnings
    
    v7: Only compare engine uabi field (Chris)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200317132222.2638719-3-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 2813e579b480..db649d03ab52 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1969,6 +1969,17 @@ enum drm_i915_perf_property_id {
 	 */
 	DRM_I915_PERF_PROP_HOLD_PREEMPTION,
 
+	/**
+	 * Specifying this pins all contexts to the specified SSEU power
+	 * configuration for the duration of the recording.
+	 *
+	 * This parameter's value is a pointer to a struct
+	 * drm_i915_gem_context_param_sseu.
+	 *
+	 * This property is available in perf revision 4.
+	 */
+	DRM_I915_PERF_PROP_GLOBAL_SSEU,
+
 	DRM_I915_PERF_PROP_MAX /* non-ABI */
 };
 

commit 88be76cdafc7e60e2e4ed883bfe7e8dd7f35fa3a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Feb 25 19:22:05 2020 +0000

    drm/i915: Allow userspace to specify ringsize on construction
    
    No good reason why we must always use a static ringsize, so let
    userspace select one during construction.
    
    Link: https://github.com/intel/compute-runtime/pull/261
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Steve Carbonari <steven.carbonari@intel.com>
    Reviewed-by: Janusz Krzysztofik <janusz.krzysztofik@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200225192206.1107336-2-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 829c0a48577f..2813e579b480 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1619,6 +1619,27 @@ struct drm_i915_gem_context_param {
  * By default, new contexts allow persistence.
  */
 #define I915_CONTEXT_PARAM_PERSISTENCE	0xb
+
+/*
+ * I915_CONTEXT_PARAM_RINGSIZE:
+ *
+ * Sets the size of the CS ringbuffer to use for logical ring contexts. This
+ * applies a limit of how many batches can be queued to HW before the caller
+ * is blocked due to lack of space for more commands.
+ *
+ * Only reliably possible to be set prior to first use, i.e. during
+ * construction. At any later point, the current execution must be flushed as
+ * the ring can only be changed while the context is idle. Note, the ringsize
+ * can be specified as a constructor property, see
+ * I915_CONTEXT_CREATE_EXT_SETPARAM, but can also be set later if required.
+ *
+ * Only applies to the current set of engine and lost when those engines
+ * are replaced by a new mapping (see I915_CONTEXT_PARAM_ENGINES).
+ *
+ * Must be between 4 - 512 KiB, in intervals of page size [4 KiB].
+ * Default is 16 KiB.
+ */
+#define I915_CONTEXT_PARAM_RINGSIZE	0xc
 /* Must be kept compact -- no holes and well documented */
 
 	__u64 value;

commit cc662126b4134e25fcfb6cad480de0fa95a4d3d8
Author: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
Date:   Wed Dec 4 12:00:32 2019 +0000

    drm/i915: Introduce DRM_I915_GEM_MMAP_OFFSET
    
    This is really just an alias of mmap_gtt. The 'mmap offset' nomenclature
    comes from the value returned by this ioctl which is the offset into the
    device fd which userpace uses with mmap(2).
    
    mmap_gtt was our initial mmap_offset implementation, this extends
    our CPU mmap support to allow additional fault handlers that depends on
    the object's backing pages.
    
    Note that we multiplex mmap_gtt and mmap_offset through the same ioctl,
    and use the zero extending behaviour of drm to differentiate between
    them, when we inspect the flags.
    
    To support multiple mmap types on an object we need to support multiple
    mmap_offsets for an object (each offset in the global device address
    space corresponding to a unique instance of the object for a file + mmap
    type). As we drop the simplified drm core idea of a single mmap_offset,
    we need to provide replacement hooks for the dumb mmap interface as
    well.
    
    Link: https://gitlab.freedesktop.org/mesa/mesa/merge_requests/1675
    Testcase: igt/gem_mmap_offset
    Signed-off-by: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191204120032.3682839-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 5400d7e057f1..829c0a48577f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -395,6 +395,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)
 #define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)
 #define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)
+#define DRM_IOCTL_I915_GEM_MMAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_offset)
 #define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)
 #define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)
 #define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)
@@ -793,6 +794,37 @@ struct drm_i915_gem_mmap_gtt {
 	__u64 offset;
 };
 
+struct drm_i915_gem_mmap_offset {
+	/** Handle for the object being mapped. */
+	__u32 handle;
+	__u32 pad;
+	/**
+	 * Fake offset to use for subsequent mmap call
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 offset;
+
+	/**
+	 * Flags for extended behaviour.
+	 *
+	 * It is mandatory that one of the MMAP_OFFSET types
+	 * (GTT, WC, WB, UC, etc) should be included.
+	 */
+	__u64 flags;
+#define I915_MMAP_OFFSET_GTT 0
+#define I915_MMAP_OFFSET_WC  1
+#define I915_MMAP_OFFSET_WB  2
+#define I915_MMAP_OFFSET_UC  3
+
+	/*
+	 * Zero-terminated chain of extensions.
+	 *
+	 * No current extensions defined; mbz.
+	 */
+	__u64 extensions;
+};
+
 struct drm_i915_gem_set_domain {
 	/** Handle for the object */
 	__u32 handle;

commit a0e047156cdebbccf253768b39d7e1dbf954c449
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 29 20:23:38 2019 +0000

    drm/i915/gem: Make context persistence optional
    
    Our existing behaviour is to allow contexts and their GPU requests to
    persist past the point of closure until the requests are complete. This
    allows clients to operate in a 'fire-and-forget' manner where they can
    setup a rendering pipeline and hand it over to the display server and
    immediately exit. As the rendering pipeline is kept alive until
    completion, the display server (or other consumer) can use the results
    in the future and present them to the user.
    
    The compute model is a little different. They have little to no buffer
    sharing between processes as their kernels tend to operate on a
    continuous stream, feeding the results back to the client application.
    These kernels operate for an indeterminate length of time, with many
    clients wishing that the kernel was always running for as long as they
    keep feeding in the data, i.e. acting like a DSP.
    
    Not all clients want this persistent "desktop" behaviour and would prefer
    that the contexts are cleaned up immediately upon closure. This ensures
    that when clients are run without hangchecking (e.g. for compute kernels
    of indeterminate runtime), any GPU hang or other unexpected workloads
    are terminated with the process and does not continue to hog resources.
    
    The default behaviour for new contexts is the legacy persistence mode,
    as some desktop applications are dependent upon the existing behaviour.
    New clients will have to opt in to immediate cleanup on context
    closure. If the hangchecking modparam is disabled, so is persistent
    context support -- all contexts will be terminated on closure.
    
    We expect this behaviour change to be welcomed by compute users, who
    have often been caught between a rock and a hard place. They disable
    hangchecking to avoid their kernels being "unfairly" declared hung, but
    have also experienced true hangs that the system was then unable to
    clean up. Naturally, this leads to bug reports.
    
    Testcase: igt/gem_ctx_persistence
    Link: https://github.com/intel/compute-runtime/pull/228
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: Jon Bloomfield <jon.bloomfield@intel.com>
    Reviewed-by: Jon Bloomfield <jon.bloomfield@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Jason Ekstrand <jason@jlekstrand.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191029202338.8841-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 63d40cba97e0..5400d7e057f1 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1572,6 +1572,21 @@ struct drm_i915_gem_context_param {
  *   i915_context_engines_bond (I915_CONTEXT_ENGINES_EXT_BOND)
  */
 #define I915_CONTEXT_PARAM_ENGINES	0xa
+
+/*
+ * I915_CONTEXT_PARAM_PERSISTENCE:
+ *
+ * Allow the context and active rendering to survive the process until
+ * completion. Persistence allows fire-and-forget clients to queue up a
+ * bunch of work, hand the output over to a display server and then quit.
+ * If the context is marked as not persistent, upon closing (either via
+ * an explicit DRM_I915_GEM_CONTEXT_DESTROY or implicitly from file closure
+ * or process termination), the context and any outstanding requests will be
+ * cancelled (and exported fences for cancelled requests marked as -EIO).
+ *
+ * By default, new contexts allow persistence.
+ */
+#define I915_CONTEXT_PARAM_PERSISTENCE	0xb
 /* Must be kept compact -- no holes and well documented */
 
 	__u64 value;

commit 9cd20ef7803cc53a00c6eb7198b3d870ac7b3766
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Oct 14 21:14:04 2019 +0100

    drm/i915/perf: allow holding preemption on filtered ctx
    
    We would like to make use of perf in Vulkan. The Vulkan API is much
    lower level than OpenGL, with applications directly exposed to the
    concept of command buffers (pretty much equivalent to our batch
    buffers). In Vulkan, queries are always limited in scope to a command
    buffer. In OpenGL, the lack of command buffer concept meant that
    queries' duration could span multiple command buffers.
    
    With that restriction gone in Vulkan, we would like to simplify
    measuring performance just by measuring the deltas between the counter
    snapshots written by 2 MI_RECORD_PERF_COUNT commands, rather than the
    more complex scheme we currently have in the GL driver, using 2
    MI_RECORD_PERF_COUNT commands and doing some post processing on the
    stream of OA reports, coming from the global OA buffer, to remove any
    unrelated deltas in between the 2 MI_RECORD_PERF_COUNT.
    
    Disabling preemption only apply to a single context with which want to
    query performance counters for and is considered a privileged
    operation, by default protected by CAP_SYS_ADMIN. It is possible to
    enable it for a normal user by disabling the paranoid stream setting.
    
    v2: Store preemption setting in intel_context (Chris)
    
    v3: Use priorities to avoid preemption rather than the HW mechanism
    
    v4: Just modify the port priority reporting function
    
    v5: Add nopreempt flag on gem context and always flag requests
        appropriately, regarless of OA reconfiguration.
    
    Link: https://gitlab.freedesktop.org/mesa/mesa/merge_requests/932
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191014201404.22468-4-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index b008ce8b4e6f..63d40cba97e0 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1890,6 +1890,17 @@ enum drm_i915_perf_property_id {
 	 */
 	DRM_I915_PERF_PROP_OA_EXPONENT,
 
+	/**
+	 * Specifying this property is only valid when specify a context to
+	 * filter with DRM_I915_PERF_PROP_CTX_HANDLE. Specifying this property
+	 * will hold preemption of the particular context we want to gather
+	 * performance data about. The execbuf2 submissions must include a
+	 * drm_i915_gem_execbuffer_ext_perf parameter for this to apply.
+	 *
+	 * This property is available in perf revision 3.
+	 */
+	DRM_I915_PERF_PROP_HOLD_PREEMPTION,
+
 	DRM_I915_PERF_PROP_MAX /* non-ABI */
 };
 

commit 7831e9a965ea2ca91855995d62197bc8078bb762
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Oct 14 21:14:03 2019 +0100

    drm/i915/perf: Allow dynamic reconfiguration of the OA stream
    
    Introduce a new perf_ioctl command to change the OA configuration of the
    active stream. This allows the OA stream to be reconfigured between
    batch buffers, giving greater flexibility in sampling. We inject a
    request into the OA context to reconfigure the stream asynchronously on
    the GPU in between and ordered with execbuffer calls.
    
    Original patch for dynamic reconfiguration by Lionel Landwerlin.
    
    Link: https://gitlab.freedesktop.org/mesa/mesa/merge_requests/932
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191014201404.22468-3-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 0c7b2815fbf1..b008ce8b4e6f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1932,6 +1932,19 @@ struct drm_i915_perf_open_param {
  */
 #define I915_PERF_IOCTL_DISABLE	_IO('i', 0x1)
 
+/**
+ * Change metrics_set captured by a stream.
+ *
+ * If the stream is bound to a specific context, the configuration change
+ * will performed inline with that context such that it takes effect before
+ * the next execbuf submission.
+ *
+ * Returns the previously bound metrics set id, or a negative error code.
+ *
+ * This ioctl is available in perf revision 2.
+ */
+#define I915_PERF_IOCTL_CONFIG	_IO('i', 0x2)
+
 /**
  * Common to all i915 perf records
  */

commit 4f6ccc74a85cbb4cdd373c374dc76398dc7603a1
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Oct 14 21:14:02 2019 +0100

    drm/i915: add support for perf configuration queries
    
    Listing configurations at the moment is supported only through sysfs.
    This might cause issues for applications wanting to list
    configurations from a container where sysfs isn't available.
    
    This change adds a way to query the number of configurations and their
    content through the i915 query uAPI.
    
    v2: Fix sparse warnings (Lionel)
        Add support to query configuration using uuid (Lionel)
    
    v3: Fix some inconsistency in uapi header (Lionel)
        Fix unlocking when not locked issue (Lionel)
        Add debug messages (Lionel)
    
    v4: Fix missing unlock (Dan)
    
    v5: Drop lock when copying config content to userspace (Chris)
    
    v6: Drop lock when copying config list to userspace (Chris)
        Fix deadlock when calling i915_perf_get_oa_config() under
        perf.metrics_lock (Lionel)
        Add i915_oa_config_get() (Chris)
    
    Link: https://gitlab.freedesktop.org/mesa/mesa/merge_requests/932
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191014201404.22468-2-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index c50c712b3771..0c7b2815fbf1 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -2005,6 +2005,7 @@ struct drm_i915_query_item {
 	__u64 query_id;
 #define DRM_I915_QUERY_TOPOLOGY_INFO    1
 #define DRM_I915_QUERY_ENGINE_INFO	2
+#define DRM_I915_QUERY_PERF_CONFIG      3
 /* Must be kept compact -- no holes and well documented */
 
 	/*
@@ -2016,9 +2017,18 @@ struct drm_i915_query_item {
 	__s32 length;
 
 	/*
-	 * Unused for now. Must be cleared to zero.
+	 * When query_id == DRM_I915_QUERY_TOPOLOGY_INFO, must be 0.
+	 *
+	 * When query_id == DRM_I915_QUERY_PERF_CONFIG, must be one of the
+	 * following :
+	 *         - DRM_I915_QUERY_PERF_CONFIG_LIST
+	 *         - DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID
+	 *         - DRM_I915_QUERY_PERF_CONFIG_FOR_UUID
 	 */
 	__u32 flags;
+#define DRM_I915_QUERY_PERF_CONFIG_LIST          1
+#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID 2
+#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID   3
 
 	/*
 	 * Data will be written at the location pointed by data_ptr when the
@@ -2146,6 +2156,56 @@ struct drm_i915_query_engine_info {
 	struct drm_i915_engine_info engines[];
 };
 
+/*
+ * Data written by the kernel with query DRM_I915_QUERY_PERF_CONFIG.
+ */
+struct drm_i915_query_perf_config {
+	union {
+		/*
+		 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_LIST, i915 sets
+		 * this fields to the number of configurations available.
+		 */
+		__u64 n_configs;
+
+		/*
+		 * When query_id == DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID,
+		 * i915 will use the value in this field as configuration
+		 * identifier to decide what data to write into config_ptr.
+		 */
+		__u64 config;
+
+		/*
+		 * When query_id == DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID,
+		 * i915 will use the value in this field as configuration
+		 * identifier to decide what data to write into config_ptr.
+		 *
+		 * String formatted like "%08x-%04x-%04x-%04x-%012x"
+		 */
+		char uuid[36];
+	};
+
+	/*
+	 * Unused for now. Must be cleared to zero.
+	 */
+	__u32 flags;
+
+	/*
+	 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_LIST, i915 will
+	 * write an array of __u64 of configuration identifiers.
+	 *
+	 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_DATA, i915 will
+	 * write a struct drm_i915_perf_oa_config. If the following fields of
+	 * drm_i915_perf_oa_config are set not set to 0, i915 will write into
+	 * the associated pointers the values of submitted when the
+	 * configuration was created :
+	 *
+	 *         - n_mux_regs
+	 *         - n_boolean_regs
+	 *         - n_flex_regs
+	 */
+	__u8 data[];
+};
+
 #if defined(__cplusplus)
 }
 #endif

commit b8d49f28aa03e4678e450e588b10c0faf96e4118
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Oct 14 21:14:01 2019 +0100

    drm/i915/perf: introduce a versioning of the i915-perf uapi
    
    Reporting this version will help application figure out what level of
    the support the running kernel provides.
    
    v2: Add i915_perf_ioctl_version() (Chris)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191014201404.22468-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 30c542144016..c50c712b3771 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -611,6 +611,13 @@ typedef struct drm_i915_irq_wait {
  * See I915_EXEC_FENCE_OUT and I915_EXEC_FENCE_SUBMIT.
  */
 #define I915_PARAM_HAS_EXEC_SUBMIT_FENCE 53
+
+/*
+ * Revision of the i915-perf uAPI. The value returned helps determine what
+ * i915-perf features are available. See drm_i915_perf_property_id.
+ */
+#define I915_PARAM_PERF_REVISION	54
+
 /* Must be kept compact -- no holes and well documented */
 
 typedef struct drm_i915_getparam {
@@ -1844,23 +1851,31 @@ enum drm_i915_perf_property_id {
 	 * Open the stream for a specific context handle (as used with
 	 * execbuffer2). A stream opened for a specific context this way
 	 * won't typically require root privileges.
+	 *
+	 * This property is available in perf revision 1.
 	 */
 	DRM_I915_PERF_PROP_CTX_HANDLE = 1,
 
 	/**
 	 * A value of 1 requests the inclusion of raw OA unit reports as
 	 * part of stream samples.
+	 *
+	 * This property is available in perf revision 1.
 	 */
 	DRM_I915_PERF_PROP_SAMPLE_OA,
 
 	/**
 	 * The value specifies which set of OA unit metrics should be
 	 * be configured, defining the contents of any OA unit reports.
+	 *
+	 * This property is available in perf revision 1.
 	 */
 	DRM_I915_PERF_PROP_OA_METRICS_SET,
 
 	/**
 	 * The value specifies the size and layout of OA unit reports.
+	 *
+	 * This property is available in perf revision 1.
 	 */
 	DRM_I915_PERF_PROP_OA_FORMAT,
 
@@ -1870,6 +1885,8 @@ enum drm_i915_perf_property_id {
 	 * from this exponent as follows:
 	 *
 	 *   80ns * 2^(period_exponent + 1)
+	 *
+	 * This property is available in perf revision 1.
 	 */
 	DRM_I915_PERF_PROP_OA_EXPONENT,
 
@@ -1901,6 +1918,8 @@ struct drm_i915_perf_open_param {
  * to close and re-open a stream with the same configuration.
  *
  * It's undefined whether any pending data for the stream will be lost.
+ *
+ * This ioctl is available in perf revision 1.
  */
 #define I915_PERF_IOCTL_ENABLE	_IO('i', 0x0)
 
@@ -1908,6 +1927,8 @@ struct drm_i915_perf_open_param {
  * Disable data capture for a stream.
  *
  * It is an error to try and read a stream that is disabled.
+ *
+ * This ioctl is available in perf revision 1.
  */
 #define I915_PERF_IOCTL_DISABLE	_IO('i', 0x1)
 

commit 601734f7aabd46d3a988554e59908d9de7f8b013
Author: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
Date:   Fri Sep 13 08:51:37 2019 +0100

    drm/i915/tgl: s/ss/eu fuse reading support
    
    Gen12 has dual-subslices (DSS), which compared to gen11 subslices have
    some duplicated resources/paths. Although DSS behave similarly to 2
    subslices, instead of splitting this and presenting userspace with bits
    not directly representative of hardware resources, present userspace
    with a subslice_mask made up of DSS bits instead.
    
    v2: GEM_BUG_ON on mask size (Lionel)
    
    Bspec: 29547
    Bspec: 12247
    Cc: Kelvin Gardiner <kelvin.gardiner@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    CC: Radhakrishna Sripada <radhakrishna.sripada@intel.com>
    Cc: Michel Thierry <michel.thierry@intel.com> #v1
    Cc: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Cc: José Roberto de Souza <jose.souza@intel.com>
    Signed-off-by: Daniele Ceraolo Spurio <daniele.ceraolospurio@intel.com>
    Signed-off-by: James Ausmus <james.ausmus@intel.com>
    Signed-off-by: Oscar Mateo <oscar.mateo@intel.com>
    Signed-off-by: Sudeep Dutt <sudeep.dutt@intel.com>
    Signed-off-by: Stuart Summers <stuart.summers@intel.com>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Acked-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190913075137.18476-2-chris@chris-wilson.co.uk
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 469dc512cca3..30c542144016 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -2033,8 +2033,10 @@ struct drm_i915_query {
  *           (data[X / 8] >> (X % 8)) & 1
  *
  * - the subslice mask for each slice with one bit per subslice telling
- *   whether a subslice is available. The availability of subslice Y in slice
- *   X can be queried with the following formula :
+ *   whether a subslice is available. Gen12 has dual-subslices, which are
+ *   similar to two gen11 subslices. For gen12, this array represents dual-
+ *   subslices. The availability of subslice Y in slice X can be queried
+ *   with the following formula :
  *
  *           (data[subslice_offset +
  *                 X * subslice_stride +

commit bf73fc0fa9cf78e37d6ee99e8d12bfa2083594d6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Jul 3 15:37:02 2019 +0100

    drm/i915: Show support for accurate sw PMU busyness tracking
    
    Expose whether or not we support the PMU software tracking in our
    scheduler capabilities, so userspace can query at runtime.
    
    v2: Use I915_SCHEDULER_CAP_ENGINE_BUSY_STATS for a less ambiguous
    capability name.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190703143702.11339-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 328d05e77d9f..469dc512cca3 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -521,6 +521,7 @@ typedef struct drm_i915_irq_wait {
 #define   I915_SCHEDULER_CAP_PRIORITY	(1ul << 1)
 #define   I915_SCHEDULER_CAP_PREEMPTION	(1ul << 2)
 #define   I915_SCHEDULER_CAP_SEMAPHORES	(1ul << 3)
+#define   I915_SCHEDULER_CAP_ENGINE_BUSY_STATS	(1ul << 4)
 
 #define I915_PARAM_HUC_STATUS		 42
 

commit c5d3e39caa456b1e061644b739131f2b54c84c08
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed May 22 10:00:54 2019 +0100

    drm/i915: Engine discovery query
    
    Engine discovery query allows userspace to enumerate engines, probe their
    configuration features, all without needing to maintain the internal PCI
    ID based database.
    
    A new query for the generic i915 query ioctl is added named
    DRM_I915_QUERY_ENGINE_INFO, together with accompanying structure
    drm_i915_query_engine_info. The address of latter should be passed to the
    kernel in the query.data_ptr field, and should be large enough for the
    kernel to fill out all known engines as struct drm_i915_engine_info
    elements trailing the query.
    
    As with other queries, setting the item query length to zero allows
    userspace to query minimum required buffer size.
    
    Enumerated engines have common type mask which can be used to query all
    hardware engines, versus engines userspace can submit to using the execbuf
    uAPI.
    
    Engines also have capabilities which are per engine class namespace of
    bits describing features not present on all engine instances.
    
    v2:
     * Fixed HEVC assignment.
     * Reorder some fields, rename type to flags, increase width. (Lionel)
     * No need to allocate temporary storage if we do it engine by engine.
       (Lionel)
    
    v3:
     * Describe engine flags and mark mbz fields. (Lionel)
     * HEVC only applies to VCS.
    
    v4:
     * Squash SFC flag into main patch.
     * Tidy some comments.
    
    v5:
     * Add uabi_ prefix to engine capabilities. (Chris Wilson)
     * Report exact size of engine info array. (Chris Wilson)
     * Drop the engine flags. (Joonas Lahtinen)
     * Added some more reserved fields.
     * Move flags after class/instance.
    
    v6:
     * Do not check engine info array was zeroed by userspace but zero the
       unused fields for them instead.
    
    v7:
     * Simplify length calculation loop. (Lionel Landwerlin)
    
    v8:
     * Remove MBZ comments where not applicable.
     * Rename ABI flags to match engine class define naming.
     * Rename SFC ABI flag to reflect it applies to VCS and VECS.
     * SFC is wired to even _logical_ engine instances.
     * SFC applies to VCS and VECS.
     * HEVC is present on all instances on Gen11. (Tony)
     * Simplify length calculation even more. (Chris Wilson)
     * Move info_ptr assigment closer to loop for clarity. (Chris Wilson)
     * Use vdbox_sfc_access from runtime info.
     * Rebase for RUNTIME_INFO.
     * Refactor for lower indentation.
     * Rename uAPI class/instance to engine_class/instance to avoid C++
       keyword.
    
    v9:
     * Rebase for s/num_rings/num_engines/ in RUNTIME_INFO.
    
    v10:
     * Use new copy_query_item.
    
    v11:
     * Consolidate with struct i915_engine_class_instnace.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jon Bloomfield <jon.bloomfield@intel.com>
    Cc: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tony Ye <tony.ye@intel.com>
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com> # v7
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190522090054.6007-1-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index bdb00ec1f8be..328d05e77d9f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1982,6 +1982,7 @@ struct drm_i915_perf_oa_config {
 struct drm_i915_query_item {
 	__u64 query_id;
 #define DRM_I915_QUERY_TOPOLOGY_INFO    1
+#define DRM_I915_QUERY_ENGINE_INFO	2
 /* Must be kept compact -- no holes and well documented */
 
 	/*
@@ -2080,6 +2081,47 @@ struct drm_i915_query_topology_info {
 	__u8 data[];
 };
 
+/**
+ * struct drm_i915_engine_info
+ *
+ * Describes one engine and it's capabilities as known to the driver.
+ */
+struct drm_i915_engine_info {
+	/** Engine class and instance. */
+	struct i915_engine_class_instance engine;
+
+	/** Reserved field. */
+	__u32 rsvd0;
+
+	/** Engine flags. */
+	__u64 flags;
+
+	/** Capabilities of this engine. */
+	__u64 capabilities;
+#define I915_VIDEO_CLASS_CAPABILITY_HEVC		(1 << 0)
+#define I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC	(1 << 1)
+
+	/** Reserved fields. */
+	__u64 rsvd1[4];
+};
+
+/**
+ * struct drm_i915_query_engine_info
+ *
+ * Engine info query enumerates all engines known to the driver by filling in
+ * an array of struct drm_i915_engine_info structures.
+ */
+struct drm_i915_query_engine_info {
+	/** Number of struct drm_i915_engine_info structs following. */
+	__u32 num_engines;
+
+	/** MBZ */
+	__u32 rsvd[3];
+
+	/** Marker for drm_i915_engine_info structures. */
+	struct drm_i915_engine_info engines[];
+};
+
 #if defined(__cplusplus)
 }
 #endif

commit a88b6e4cbafd6f23b3450c087acdbe23d90e7606
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:34 2019 +0100

    drm/i915: Allow specification of parallel execbuf
    
    There is a desire to split a task onto two engines and have them run at
    the same time, e.g. scanline interleaving to spread the workload evenly.
    Through the use of the out-fence from the first execbuf, we can
    coordinate secondary execbuf to only become ready simultaneously with
    the first, so that with all things idle the second execbufs are executed
    in parallel with the first. The key difference here between the new
    EXEC_FENCE_SUBMIT and the existing EXEC_FENCE_IN is that the in-fence
    waits for the completion of the first request (so that all of its
    rendering results are visible to the second execbuf, the more common
    userspace fence requirement).
    
    Since we only have a single input fence slot, userspace cannot mix an
    in-fence and a submit-fence. It has to use one or the other! This is not
    such a harsh requirement, since by virtue of the submit-fence, the
    secondary execbuf inherit all of the dependencies from the first
    request, and for the application the dependencies should be common
    between the primary and secondary execbuf.
    
    Suggested-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Testcase: igt/gem_exec_fence/parallel
    Link: https://github.com/intel/media-driver/pull/546
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-10-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index e2da9027bcdf..bdb00ec1f8be 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -604,6 +604,12 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_MMAP_GTT_COHERENT	52
 
+/*
+ * Query whether DRM_I915_GEM_EXECBUFFER2 supports coordination of parallel
+ * execution through use of explicit fence support.
+ * See I915_EXEC_FENCE_OUT and I915_EXEC_FENCE_SUBMIT.
+ */
+#define I915_PARAM_HAS_EXEC_SUBMIT_FENCE 53
 /* Must be kept compact -- no holes and well documented */
 
 typedef struct drm_i915_getparam {
@@ -1126,7 +1132,16 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_FENCE_ARRAY   (1<<19)
 
-#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_ARRAY<<1))
+/*
+ * Setting I915_EXEC_FENCE_SUBMIT implies that lower_32_bits(rsvd2) represent
+ * a sync_file fd to wait upon (in a nonblocking manner) prior to executing
+ * the batch.
+ *
+ * Returns -EINVAL if the sync_file fd cannot be found.
+ */
+#define I915_EXEC_FENCE_SUBMIT		(1 << 20)
+
+#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_SUBMIT << 1))
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit ee1136908e9b28173f9794be25465a13b2bb9b18
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:33 2019 +0100

    drm/i915/execlists: Virtual engine bonding
    
    Some users require that when a master batch is executed on one particular
    engine, a companion batch is run simultaneously on a specific slave
    engine. For this purpose, we introduce virtual engine bonding, allowing
    maps of master:slaves to be constructed to constrain which physical
    engines a virtual engine may select given a fence on a master engine.
    
    For the moment, we continue to ignore the issue of preemption deferring
    the master request for later. Ideally, we would like to then also remove
    the slave and run something else rather than have it stall the pipeline.
    With load balancing, we should be able to move workload around it, but
    there is a similar stall on the master pipeline while it may wait for
    the slave to be executed. At the cost of more latency for the bonded
    request, it may be interesting to launch both on their engines in
    lockstep. (Bubbles abound.)
    
    Opens: Also what about bonding an engine as its own master? It doesn't
    break anything internally, so allow the silliness.
    
    v2: Emancipate the bonds
    v3: Couple in delayed scheduling for the selftests
    v4: Handle invalid mutually exclusive bonding
    v5: Mention what the uapi does
    v6: s/nbond/num_bonds/
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-9-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index f9770948161c..e2da9027bcdf 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1543,6 +1543,10 @@ struct drm_i915_gem_context_param {
  * sized argument, will revert back to default settings.
  *
  * See struct i915_context_param_engines.
+ *
+ * Extensions:
+ *   i915_context_engines_load_balance (I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE)
+ *   i915_context_engines_bond (I915_CONTEXT_ENGINES_EXT_BOND)
  */
 #define I915_CONTEXT_PARAM_ENGINES	0xa
 /* Must be kept compact -- no holes and well documented */
@@ -1646,9 +1650,49 @@ struct i915_context_engines_load_balance {
 	struct i915_engine_class_instance engines[N__]; \
 } __attribute__((packed)) name__
 
+/*
+ * i915_context_engines_bond:
+ *
+ * Constructed bonded pairs for execution within a virtual engine.
+ *
+ * All engines are equal, but some are more equal than others. Given
+ * the distribution of resources in the HW, it may be preferable to run
+ * a request on a given subset of engines in parallel to a request on a
+ * specific engine. We enable this selection of engines within a virtual
+ * engine by specifying bonding pairs, for any given master engine we will
+ * only execute on one of the corresponding siblings within the virtual engine.
+ *
+ * To execute a request in parallel on the master engine and a sibling requires
+ * coordination with a I915_EXEC_FENCE_SUBMIT.
+ */
+struct i915_context_engines_bond {
+	struct i915_user_extension base;
+
+	struct i915_engine_class_instance master;
+
+	__u16 virtual_index; /* index of virtual engine in ctx->engines[] */
+	__u16 num_bonds;
+
+	__u64 flags; /* all undefined flags must be zero */
+	__u64 mbz64[4]; /* reserved for future use; must be zero */
+
+	struct i915_engine_class_instance engines[0];
+} __attribute__((packed));
+
+#define I915_DEFINE_CONTEXT_ENGINES_BOND(name__, N__) struct { \
+	struct i915_user_extension base; \
+	struct i915_engine_class_instance master; \
+	__u16 virtual_index; \
+	__u16 num_bonds; \
+	__u64 flags; \
+	__u64 mbz64[4]; \
+	struct i915_engine_class_instance engines[N__]; \
+} __attribute__((packed)) name__
+
 struct i915_context_param_engines {
 	__u64 extensions; /* linked chain of extension blocks, 0 terminates */
 #define I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE 0 /* see i915_context_engines_load_balance */
+#define I915_CONTEXT_ENGINES_EXT_BOND 1 /* see i915_context_engines_bond */
 	struct i915_engine_class_instance engines[0];
 } __attribute__((packed));
 

commit 6d06779e86724322d79eb53b26989edd9db188f6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:30 2019 +0100

    drm/i915: Load balancing across a virtual engine
    
    Having allowed the user to define a set of engines that they will want
    to only use, we go one step further and allow them to bind those engines
    into a single virtual instance. Submitting a batch to the virtual engine
    will then forward it to any one of the set in a manner as best to
    distribute load.  The virtual engine has a single timeline across all
    engines (it operates as a single queue), so it is not able to concurrently
    run batches across multiple engines by itself; that is left up to the user
    to submit multiple concurrent batches to multiple queues. Multiple users
    will be load balanced across the system.
    
    The mechanism used for load balancing in this patch is a late greedy
    balancer. When a request is ready for execution, it is added to each
    engine's queue, and when an engine is ready for its next request it
    claims it from the virtual engine. The first engine to do so, wins, i.e.
    the request is executed at the earliest opportunity (idle moment) in the
    system.
    
    As not all HW is created equal, the user is still able to skip the
    virtual engine and execute the batch on a specific engine, all within the
    same queue. It will then be executed in order on the correct engine,
    with execution on other virtual engines being moved away due to the load
    detection.
    
    A couple of areas for potential improvement left!
    
    - The virtual engine always take priority over equal-priority tasks.
    Mostly broken up by applying FQ_CODEL rules for prioritising new clients,
    and hopefully the virtual and real engines are not then congested (i.e.
    all work is via virtual engines, or all work is to the real engine).
    
    - We require the breadcrumb irq around every virtual engine request. For
    normal engines, we eliminate the need for the slow round trip via
    interrupt by using the submit fence and queueing in order. For virtual
    engines, we have to allow any job to transfer to a new ring, and cannot
    coalesce the submissions, so require the completion fence instead,
    forcing the persistent use of interrupts.
    
    - We only drip feed single requests through each virtual engine and onto
    the physical engines, even if there was enough work to fill all ELSP,
    leaving small stalls with an idle CS event at the end of every request.
    Could we be greedy and fill both slots? Being lazy is virtuous for load
    distribution on less-than-full workloads though.
    
    Other areas of improvement are more general, such as reducing lock
    contention, reducing dispatch overhead, looking at direct submission
    rather than bouncing around tasklets etc.
    
    sseu: Lift the restriction to allow sseu to be reconfigured on virtual
    engines composed of RENDER_CLASS (rcs).
    
    v2: macroize check_user_mbz()
    v3: Cancel virtual engines on wedging
    v4: Commence commenting
    v5: Replace 64b sibling_mask with a list of class:instance
    v6: Drop the one-element array in the uabi
    v7: Assert it is an virtual engine in to_virtual_engine()
    v8: Skip over holes in [class][inst] so we can selftest with (vcs0, vcs2)
    
    Link: https://github.com/intel/media-driver/pull/283
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-6-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 62396d575e28..f9770948161c 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -137,6 +137,7 @@ struct i915_engine_class_instance {
 	__u16 engine_class; /* see enum drm_i915_gem_engine_class */
 	__u16 engine_instance;
 #define I915_ENGINE_CLASS_INVALID_NONE -1
+#define I915_ENGINE_CLASS_INVALID_VIRTUAL -2
 };
 
 /**
@@ -1608,8 +1609,46 @@ struct drm_i915_gem_context_param_sseu {
 	__u32 rsvd;
 };
 
+/*
+ * i915_context_engines_load_balance:
+ *
+ * Enable load balancing across this set of engines.
+ *
+ * Into the I915_EXEC_DEFAULT slot [0], a virtual engine is created that when
+ * used will proxy the execbuffer request onto one of the set of engines
+ * in such a way as to distribute the load evenly across the set.
+ *
+ * The set of engines must be compatible (e.g. the same HW class) as they
+ * will share the same logical GPU context and ring.
+ *
+ * To intermix rendering with the virtual engine and direct rendering onto
+ * the backing engines (bypassing the load balancing proxy), the context must
+ * be defined to use a single timeline for all engines.
+ */
+struct i915_context_engines_load_balance {
+	struct i915_user_extension base;
+
+	__u16 engine_index;
+	__u16 num_siblings;
+	__u32 flags; /* all undefined flags must be zero */
+
+	__u64 mbz64; /* reserved for future use; must be zero */
+
+	struct i915_engine_class_instance engines[0];
+} __attribute__((packed));
+
+#define I915_DEFINE_CONTEXT_ENGINES_LOAD_BALANCE(name__, N__) struct { \
+	struct i915_user_extension base; \
+	__u16 engine_index; \
+	__u16 num_siblings; \
+	__u32 flags; \
+	__u64 mbz64; \
+	struct i915_engine_class_instance engines[N__]; \
+} __attribute__((packed)) name__
+
 struct i915_context_param_engines {
 	__u64 extensions; /* linked chain of extension blocks, 0 terminates */
+#define I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE 0 /* see i915_context_engines_load_balance */
 	struct i915_engine_class_instance engines[0];
 } __attribute__((packed));
 

commit b81dde719439c8f09bb61e742ed95bfc4b33946b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:29 2019 +0100

    drm/i915: Allow userspace to clone contexts on creation
    
    A usecase arose out of handling context recovery in mesa, whereby they
    wish to recreate a context with fresh logical state but preserving all
    other details of the original. Currently, they create a new context and
    iterate over which bits they want to copy across, but it would much more
    convenient if they were able to just pass in a target context to clone
    during creation. This essentially extends the setparam during creation
    to pull the details from a target context instead of the user supplied
    parameters.
    
    The ideal here is that we don't expose control over anything more than
    can be obtained via CONTEXT_PARAM. That is userspace retains explicit
    control over all features, and this api is just convenience.
    
    For example, you could replace
    
            struct context_param p = { .param = CONTEXT_PARAM_VM };
    
            param.ctx_id = old_id;
            gem_context_get_param(&p.param);
    
            new_id = gem_context_create();
    
            param.ctx_id = new_id;
            gem_context_set_param(&p.param);
    
            gem_vm_destroy(param.value); /* drop the ref to VM_ID handle */
    
    with
    
            struct create_ext_param p = {
              { .name = CONTEXT_CREATE_CLONE },
              .clone_id = old_id,
              .flags = CLONE_FLAGS_VM
            }
            new_id = gem_context_create_ext(&p);
    
    and not have to worry about stray namespace pollution etc.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-5-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 957ba8e60e02..62396d575e28 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1624,6 +1624,21 @@ struct drm_i915_gem_context_create_ext_setparam {
 	struct drm_i915_gem_context_param param;
 };
 
+struct drm_i915_gem_context_create_ext_clone {
+#define I915_CONTEXT_CREATE_EXT_CLONE 1
+	struct i915_user_extension base;
+	__u32 clone_id;
+	__u32 flags;
+#define I915_CONTEXT_CLONE_ENGINES	(1u << 0)
+#define I915_CONTEXT_CLONE_FLAGS	(1u << 1)
+#define I915_CONTEXT_CLONE_SCHEDATTR	(1u << 2)
+#define I915_CONTEXT_CLONE_SSEU		(1u << 3)
+#define I915_CONTEXT_CLONE_TIMELINE	(1u << 4)
+#define I915_CONTEXT_CLONE_VM		(1u << 5)
+#define I915_CONTEXT_CLONE_UNKNOWN -(I915_CONTEXT_CLONE_VM << 1)
+	__u64 rsvd;
+};
+
 struct drm_i915_gem_context_destroy {
 	__u32 ctx_id;
 	__u32 pad;

commit 8319f44c0525708c26ac7724da897cff3dbb0f84
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:28 2019 +0100

    drm/i915: Re-expose SINGLE_TIMELINE flags for context creation
    
    The SINGLE_TIMELINE flag can be used to create a context such that all
    engine instances within that context share a common timeline. This can
    be useful for mixing operations between real and virtual engines, or
    when using a composite context for a single client API context.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-4-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 82bd488ed0d1..957ba8e60e02 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1469,8 +1469,9 @@ struct drm_i915_gem_context_create_ext {
 	__u32 ctx_id; /* output: id of new context*/
 	__u32 flags;
 #define I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS	(1u << 0)
+#define I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE	(1u << 1)
 #define I915_CONTEXT_CREATE_FLAGS_UNKNOWN \
-	(-(I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS << 1))
+	(-(I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE << 1))
 	__u64 extensions;
 };
 

commit e620f7b3a26389dfce2663ad4e64c2271ad1a815
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:27 2019 +0100

    drm/i915: Extend I915_CONTEXT_PARAM_SSEU to support local ctx->engine[]
    
    Allow the user to specify a local engine index (as opposed to
    class:index) that they can use to refer to a preset engine inside the
    ctx->engine[] array defined by an earlier I915_CONTEXT_PARAM_ENGINES.
    This will be useful for setting SSEU parameters on virtual engines that
    are local to the context and do not have a valid global class:instance
    lookup.
    
    Note that due to the ambiguity in using class:instance with
    ctx->engines[], if a user supplied engine map is active the user must
    specify the engine to alter by its index into the ctx->engines[].
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-3-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 8e1bb22926e4..82bd488ed0d1 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1576,9 +1576,10 @@ struct drm_i915_gem_context_param_sseu {
 	struct i915_engine_class_instance engine;
 
 	/*
-	 * Unused for now. Must be cleared to zero.
+	 * Unknown flags must be cleared to zero.
 	 */
 	__u32 flags;
+#define I915_CONTEXT_SSEU_FLAG_ENGINE_INDEX (1u << 0)
 
 	/*
 	 * Mask of slices to enable for the context. Valid values are a subset

commit 976b55f0e1db5cb8fccb0a42f68ea77ae42604a6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:26 2019 +0100

    drm/i915: Allow a context to define its set of engines
    
    Over the last few years, we have debated how to extend the user API to
    support an increase in the number of engines, that may be sparse and
    even be heterogeneous within a class (not all video decoders created
    equal). We settled on using (class, instance) tuples to identify a
    specific engine, with an API for the user to construct a map of engines
    to capabilities. Into this picture, we then add a challenge of virtual
    engines; one user engine that maps behind the scenes to any number of
    physical engines. To keep it general, we want the user to have full
    control over that mapping. To that end, we allow the user to constrain a
    context to define the set of engines that it can access, order fully
    controlled by the user via (class, instance). With such precise control
    in context setup, we can continue to use the existing execbuf uABI of
    specifying a single index; only now it doesn't automagically map onto
    the engines, it uses the user defined engine map from the context.
    
    v2: Fixup freeing of local on success of get_engines()
    v3: Allow empty engines[]
    v4: s/nengine/num_engines/
    v5: Replace 64 limit on num_engines with a note that execbuf is
    currently limited to only using the first 64 engines.
    v6: Actually use the engines_mutex to guard the ctx->engines.
    
    Testcase: igt/gem_ctx_engines
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-2-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index d6ad4a15b2b9..8e1bb22926e4 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -136,6 +136,7 @@ enum drm_i915_gem_engine_class {
 struct i915_engine_class_instance {
 	__u16 engine_class; /* see enum drm_i915_gem_engine_class */
 	__u16 engine_instance;
+#define I915_ENGINE_CLASS_INVALID_NONE -1
 };
 
 /**
@@ -1522,6 +1523,26 @@ struct drm_i915_gem_context_param {
 	 * See DRM_I915_GEM_VM_CREATE and DRM_I915_GEM_VM_DESTROY.
 	 */
 #define I915_CONTEXT_PARAM_VM		0x9
+
+/*
+ * I915_CONTEXT_PARAM_ENGINES:
+ *
+ * Bind this context to operate on this subset of available engines. Henceforth,
+ * the I915_EXEC_RING selector for DRM_IOCTL_I915_GEM_EXECBUFFER2 operates as
+ * an index into this array of engines; I915_EXEC_DEFAULT selecting engine[0]
+ * and upwards. Slots 0...N are filled in using the specified (class, instance).
+ * Use
+ *	engine_class: I915_ENGINE_CLASS_INVALID,
+ *	engine_instance: I915_ENGINE_CLASS_INVALID_NONE
+ * to specify a gap in the array that can be filled in later, e.g. by a
+ * virtual engine used for load balancing.
+ *
+ * Setting the number of engines bound to the context to 0, by passing a zero
+ * sized argument, will revert back to default settings.
+ *
+ * See struct i915_context_param_engines.
+ */
+#define I915_CONTEXT_PARAM_ENGINES	0xa
 /* Must be kept compact -- no holes and well documented */
 
 	__u64 value;
@@ -1585,6 +1606,16 @@ struct drm_i915_gem_context_param_sseu {
 	__u32 rsvd;
 };
 
+struct i915_context_param_engines {
+	__u64 extensions; /* linked chain of extension blocks, 0 terminates */
+	struct i915_engine_class_instance engines[0];
+} __attribute__((packed));
+
+#define I915_DEFINE_CONTEXT_PARAM_ENGINES(name__, N__) struct { \
+	__u64 extensions; \
+	struct i915_engine_class_instance engines[N__]; \
+} __attribute__((packed)) name__
+
 struct drm_i915_gem_context_create_ext_setparam {
 #define I915_CONTEXT_CREATE_EXT_SETPARAM 0
 	struct i915_user_extension base;

commit 7f3f317a66cac307f6fbc1b5dd74902fb1b48860
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue May 21 22:11:25 2019 +0100

    drm/i915: Restore control over ppgtt for context creation ABI
    
    Having hid the partially exposed new ABI from the PR, put it back again
    for completion of context recovery. A significant part of context
    recovery is the ability to reuse as much of the old context as is
    feasible (to avoid expensive reconstruction). The biggest chunk kept
    hidden at the moment is fine-control over the ctx->ppgtt (the GPU page
    tables and associated translation tables and kernel maps), so make
    control over the ctx->ppgtt explicit.
    
    This allows userspace to create and share virtual memory address spaces
    (within the limits of a single fd) between contexts they own, along with
    the ability to query the contexts for the vm state.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190521211134.16117-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 3a73f5316766..d6ad4a15b2b9 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -355,6 +355,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_PERF_ADD_CONFIG	0x37
 #define DRM_I915_PERF_REMOVE_CONFIG	0x38
 #define DRM_I915_QUERY			0x39
+#define DRM_I915_GEM_VM_CREATE		0x3a
+#define DRM_I915_GEM_VM_DESTROY		0x3b
 /* Must be kept compact -- no holes */
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
@@ -415,6 +417,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_PERF_ADD_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_ADD_CONFIG, struct drm_i915_perf_oa_config)
 #define DRM_IOCTL_I915_PERF_REMOVE_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_REMOVE_CONFIG, __u64)
 #define DRM_IOCTL_I915_QUERY			DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_QUERY, struct drm_i915_query)
+#define DRM_IOCTL_I915_GEM_VM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_VM_CREATE, struct drm_i915_gem_vm_control)
+#define DRM_IOCTL_I915_GEM_VM_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_VM_DESTROY, struct drm_i915_gem_vm_control)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1507,6 +1511,17 @@ struct drm_i915_gem_context_param {
  * On creation, all new contexts are marked as recoverable.
  */
 #define I915_CONTEXT_PARAM_RECOVERABLE	0x8
+
+	/*
+	 * The id of the associated virtual memory address space (ppGTT) of
+	 * this context. Can be retrieved and passed to another context
+	 * (on the same fd) for both to use the same ppGTT and so share
+	 * address layouts, and avoid reloading the page tables on context
+	 * switches between themselves.
+	 *
+	 * See DRM_I915_GEM_VM_CREATE and DRM_I915_GEM_VM_DESTROY.
+	 */
+#define I915_CONTEXT_PARAM_VM		0x9
 /* Must be kept compact -- no holes and well documented */
 
 	__u64 value;

commit d1172ab3d443e84ade75285f8c107bfac7e386d8
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Apr 12 08:14:16 2019 +0100

    drm/i915: Introduce struct class_instance for engines across the uAPI
    
    SSEU reprogramming of the context introduced the notion of engine class
    and instance for a forwards compatible method of describing any engine
    beyond the old execbuf interface. We wish to adopt this class:instance
    description for more interfaces, so pull it out into a separate type for
    userspace convenience.
    
    Fixes: e46c2e99f600 ("drm/i915: Expose RPCS (SSEU) configuration to userspace (Gen11 only)")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Tony Ye <tony.ye@intel.com>
    Cc: Andi Shyti <andi@etezian.org>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Acked-by: Tony Ye <tony.ye@intel.com>
    Reviewed-by: Andi Shyti <andi@etezian.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190412071416.30097-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 52051d24d89d..3a73f5316766 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -126,6 +126,18 @@ enum drm_i915_gem_engine_class {
 	I915_ENGINE_CLASS_INVALID	= -1
 };
 
+/*
+ * There may be more than one engine fulfilling any role within the system.
+ * Each engine of a class is given a unique instance number and therefore
+ * any engine can be specified by its class:instance tuplet. APIs that allow
+ * access to any engine in the system will use struct i915_engine_class_instance
+ * for this identification.
+ */
+struct i915_engine_class_instance {
+	__u16 engine_class; /* see enum drm_i915_gem_engine_class */
+	__u16 engine_instance;
+};
+
 /**
  * DOC: perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915
  *
@@ -1525,8 +1537,7 @@ struct drm_i915_gem_context_param_sseu {
 	/*
 	 * Engine class & instance to be configured or queried.
 	 */
-	__u16 engine_class;
-	__u16 engine_instance;
+	struct i915_engine_class_instance engine;
 
 	/*
 	 * Unused for now. Must be cleared to zero.

commit 96fd2c6633b0484b030eb15e646ad50426c41e6a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Mar 27 10:58:14 2019 +0000

    drm/i915: Drop new chunks of context creation ABI (for now)
    
    The intent was to expose these as part of the means to perform full
    context recovery (though not the SINGLE_TIMELINE, that is for later and
    just sucked as collateral damage). As that requires a couple more
    patches to complete the series, roll back the earlier chunks of ABI for
    an intervening PR. We keep all the internals intact and under selftests.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190327105814.14694-1-chris@chris-wilson.co.uk
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 9999f7d6a5a9..52051d24d89d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -343,8 +343,6 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_PERF_ADD_CONFIG	0x37
 #define DRM_I915_PERF_REMOVE_CONFIG	0x38
 #define DRM_I915_QUERY			0x39
-#define DRM_I915_GEM_VM_CREATE		0x3a
-#define DRM_I915_GEM_VM_DESTROY		0x3b
 /* Must be kept compact -- no holes */
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
@@ -405,8 +403,6 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_PERF_ADD_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_ADD_CONFIG, struct drm_i915_perf_oa_config)
 #define DRM_IOCTL_I915_PERF_REMOVE_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_REMOVE_CONFIG, __u64)
 #define DRM_IOCTL_I915_QUERY			DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_QUERY, struct drm_i915_query)
-#define DRM_IOCTL_I915_GEM_VM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_VM_CREATE, struct drm_i915_gem_vm_control)
-#define DRM_IOCTL_I915_GEM_VM_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_VM_DESTROY, struct drm_i915_gem_vm_control)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1456,9 +1452,8 @@ struct drm_i915_gem_context_create_ext {
 	__u32 ctx_id; /* output: id of new context*/
 	__u32 flags;
 #define I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS	(1u << 0)
-#define I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE	(1u << 1)
 #define I915_CONTEXT_CREATE_FLAGS_UNKNOWN \
-	(-(I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE << 1))
+	(-(I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS << 1))
 	__u64 extensions;
 };
 
@@ -1500,17 +1495,6 @@ struct drm_i915_gem_context_param {
  * On creation, all new contexts are marked as recoverable.
  */
 #define I915_CONTEXT_PARAM_RECOVERABLE	0x8
-
-	/*
-	 * The id of the associated virtual memory address space (ppGTT) of
-	 * this context. Can be retrieved and passed to another context
-	 * (on the same fd) for both to use the same ppGTT and so share
-	 * address layouts, and avoid reloading the page tables on context
-	 * switches between themselves.
-	 *
-	 * See DRM_I915_GEM_VM_CREATE and DRM_I915_GEM_VM_DESTROY.
-	 */
-#define I915_CONTEXT_PARAM_VM		0x9
 /* Must be kept compact -- no holes and well documented */
 
 	__u64 value;

commit ea593dbba4c8ed841630fa5445202627e1046ba6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:25 2019 +0000

    drm/i915: Allow contexts to share a single timeline across all engines
    
    Previously, our view has been always to run the engines independently
    within a context. (Multiple engines happened before we had contexts and
    timelines, so they always operated independently and that behaviour
    persisted into contexts.) However, at the user level the context often
    represents a single timeline (e.g. GL contexts) and userspace must
    ensure that the individual engines are serialised to present that
    ordering to the client (or forgot about this detail entirely and hope no
    one notices - a fair ploy if the client can only directly control one
    engine themselves ;)
    
    In the next patch, we will want to construct a set of engines that
    operate as one, that have a single timeline interwoven between them, to
    present a single virtual engine to the user. (They submit to the virtual
    engine, then we decide which engine to execute on based.)
    
    To that end, we want to be able to create contexts which have a single
    timeline (fence context) shared between all engines, rather than multiple
    timelines.
    
    v2: Move the specialised timeline ordering to its own function.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-4-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index d45b79746fc4..9999f7d6a5a9 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1456,8 +1456,9 @@ struct drm_i915_gem_context_create_ext {
 	__u32 ctx_id; /* output: id of new context*/
 	__u32 flags;
 #define I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS	(1u << 0)
+#define I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE	(1u << 1)
 #define I915_CONTEXT_CREATE_FLAGS_UNKNOWN \
-	(-(I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS << 1))
+	(-(I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE << 1))
 	__u64 extensions;
 };
 

commit b91715417244a7e478304425ba671bfafee9c43e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:24 2019 +0000

    drm/i915: Extend CONTEXT_CREATE to set parameters upon construction
    
    It can be useful to have a single ioctl to create a context with all
    the initial parameters instead of a series of create + setparam + setparam
    ioctls. This extension to create context allows any of the parameters
    to be passed in as a linked list to be applied to the newly constructed
    context.
    
    v2: Make a local copy of user setparam (Tvrtko)
    v3: Use flags to detect availability of extension interface
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-3-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 9af7a8e6a46e..d45b79746fc4 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -394,6 +394,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
 #define DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, struct drm_i915_gem_wait)
 #define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)
+#define DRM_IOCTL_I915_GEM_CONTEXT_CREATE_EXT	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create_ext)
 #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
 #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
 #define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)
@@ -1447,92 +1448,17 @@ struct drm_i915_gem_wait {
 };
 
 struct drm_i915_gem_context_create {
-	/*  output: id of new context*/
-	__u32 ctx_id;
-	__u32 pad;
-};
-
-struct drm_i915_gem_context_destroy {
-	__u32 ctx_id;
-	__u32 pad;
-};
-
-/*
- * DRM_I915_GEM_VM_CREATE -
- *
- * Create a new virtual memory address space (ppGTT) for use within a context
- * on the same file. Extensions can be provided to configure exactly how the
- * address space is setup upon creation.
- *
- * The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is
- * returned in the outparam @vm_id.
- *
- * No flags are defined, with all bits reserved and must be zero.
- *
- * An extension chain maybe provided, starting with @extensions, and terminated
- * by the @next_extension being 0. Currently, no extensions are defined.
- *
- * DRM_I915_GEM_VM_DESTROY -
- *
- * Destroys a previously created VM id, specified in @vm_id.
- *
- * No extensions or flags are allowed currently, and so must be zero.
- */
-struct drm_i915_gem_vm_control {
-	__u64 extensions;
-	__u32 flags;
-	__u32 vm_id;
-};
-
-struct drm_i915_reg_read {
-	/*
-	 * Register offset.
-	 * For 64bit wide registers where the upper 32bits don't immediately
-	 * follow the lower 32bits, the offset of the lower 32bits must
-	 * be specified
-	 */
-	__u64 offset;
-#define I915_REG_READ_8B_WA (1ul << 0)
-
-	__u64 val; /* Return value */
-};
-/* Known registers:
- *
- * Render engine timestamp - 0x2358 + 64bit - gen7+
- * - Note this register returns an invalid value if using the default
- *   single instruction 8byte read, in order to workaround that pass
- *   flag I915_REG_READ_8B_WA in offset field.
- *
- */
-
-struct drm_i915_reset_stats {
-	__u32 ctx_id;
-	__u32 flags;
-
-	/* All resets since boot/module reload, for all contexts */
-	__u32 reset_count;
-
-	/* Number of batches lost when active in GPU, for this context */
-	__u32 batch_active;
-
-	/* Number of batches lost pending for execution, for this context */
-	__u32 batch_pending;
-
+	__u32 ctx_id; /* output: id of new context*/
 	__u32 pad;
 };
 
-struct drm_i915_gem_userptr {
-	__u64 user_ptr;
-	__u64 user_size;
+struct drm_i915_gem_context_create_ext {
+	__u32 ctx_id; /* output: id of new context*/
 	__u32 flags;
-#define I915_USERPTR_READ_ONLY 0x1
-#define I915_USERPTR_UNSYNCHRONIZED 0x80000000
-	/**
-	 * Returned handle for the object.
-	 *
-	 * Object handles are nonzero.
-	 */
-	__u32 handle;
+#define I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS	(1u << 0)
+#define I915_CONTEXT_CREATE_FLAGS_UNKNOWN \
+	(-(I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS << 1))
+	__u64 extensions;
 };
 
 struct drm_i915_gem_context_param {
@@ -1648,6 +1574,96 @@ struct drm_i915_gem_context_param_sseu {
 	__u32 rsvd;
 };
 
+struct drm_i915_gem_context_create_ext_setparam {
+#define I915_CONTEXT_CREATE_EXT_SETPARAM 0
+	struct i915_user_extension base;
+	struct drm_i915_gem_context_param param;
+};
+
+struct drm_i915_gem_context_destroy {
+	__u32 ctx_id;
+	__u32 pad;
+};
+
+/*
+ * DRM_I915_GEM_VM_CREATE -
+ *
+ * Create a new virtual memory address space (ppGTT) for use within a context
+ * on the same file. Extensions can be provided to configure exactly how the
+ * address space is setup upon creation.
+ *
+ * The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is
+ * returned in the outparam @id.
+ *
+ * No flags are defined, with all bits reserved and must be zero.
+ *
+ * An extension chain maybe provided, starting with @extensions, and terminated
+ * by the @next_extension being 0. Currently, no extensions are defined.
+ *
+ * DRM_I915_GEM_VM_DESTROY -
+ *
+ * Destroys a previously created VM id, specified in @id.
+ *
+ * No extensions or flags are allowed currently, and so must be zero.
+ */
+struct drm_i915_gem_vm_control {
+	__u64 extensions;
+	__u32 flags;
+	__u32 vm_id;
+};
+
+struct drm_i915_reg_read {
+	/*
+	 * Register offset.
+	 * For 64bit wide registers where the upper 32bits don't immediately
+	 * follow the lower 32bits, the offset of the lower 32bits must
+	 * be specified
+	 */
+	__u64 offset;
+#define I915_REG_READ_8B_WA (1ul << 0)
+
+	__u64 val; /* Return value */
+};
+
+/* Known registers:
+ *
+ * Render engine timestamp - 0x2358 + 64bit - gen7+
+ * - Note this register returns an invalid value if using the default
+ *   single instruction 8byte read, in order to workaround that pass
+ *   flag I915_REG_READ_8B_WA in offset field.
+ *
+ */
+
+struct drm_i915_reset_stats {
+	__u32 ctx_id;
+	__u32 flags;
+
+	/* All resets since boot/module reload, for all contexts */
+	__u32 reset_count;
+
+	/* Number of batches lost when active in GPU, for this context */
+	__u32 batch_active;
+
+	/* Number of batches lost pending for execution, for this context */
+	__u32 batch_pending;
+
+	__u32 pad;
+};
+
+struct drm_i915_gem_userptr {
+	__u64 user_ptr;
+	__u64 user_size;
+	__u32 flags;
+#define I915_USERPTR_READ_ONLY 0x1
+#define I915_USERPTR_UNSYNCHRONIZED 0x80000000
+	/**
+	 * Returned handle for the object.
+	 *
+	 * Object handles are nonzero.
+	 */
+	__u32 handle;
+};
+
 enum drm_i915_oa_format {
 	I915_OA_FORMAT_A13 = 1,	    /* HSW only */
 	I915_OA_FORMAT_A29,	    /* HSW only */

commit e0695db7298ec2181d38bd3bfc5d0ff7a46f96f3
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:23 2019 +0000

    drm/i915: Create/destroy VM (ppGTT) for use with contexts
    
    In preparation to making the ppGTT binding for a context explicit (to
    facilitate reusing the same ppGTT between different contexts), allow the
    user to create and destroy named ppGTT.
    
    v2: Replace global barrier for swapping over the ppgtt and tlbs with a
    local context barrier (Tvrtko)
    v3: serialise with struct_mutex; it's lazy but required dammit
    v4: Rewrite igt_ctx_shared_exec to be more different (aimed to be more
    similarly, turned out different!)
    
    v5: Fix up test unwind for aliasing-ppgtt (snb)
    v6: Tighten language for uapi struct drm_i915_gem_vm_control.
    v7: Patch the context image for runtime ppgtt switching!
    
    Testcase: igt/gem_vm_create
    Testcase: igt/gem_ctx_param/vm
    Testcase: igt/gem_ctx_clone/vm
    Testcase: igt/gem_ctx_shared
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-2-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 1c69ed16a923..9af7a8e6a46e 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -343,6 +343,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_PERF_ADD_CONFIG	0x37
 #define DRM_I915_PERF_REMOVE_CONFIG	0x38
 #define DRM_I915_QUERY			0x39
+#define DRM_I915_GEM_VM_CREATE		0x3a
+#define DRM_I915_GEM_VM_DESTROY		0x3b
 /* Must be kept compact -- no holes */
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
@@ -402,6 +404,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_PERF_ADD_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_ADD_CONFIG, struct drm_i915_perf_oa_config)
 #define DRM_IOCTL_I915_PERF_REMOVE_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_REMOVE_CONFIG, __u64)
 #define DRM_IOCTL_I915_QUERY			DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_QUERY, struct drm_i915_query)
+#define DRM_IOCTL_I915_GEM_VM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_VM_CREATE, struct drm_i915_gem_vm_control)
+#define DRM_IOCTL_I915_GEM_VM_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_VM_DESTROY, struct drm_i915_gem_vm_control)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1453,6 +1457,33 @@ struct drm_i915_gem_context_destroy {
 	__u32 pad;
 };
 
+/*
+ * DRM_I915_GEM_VM_CREATE -
+ *
+ * Create a new virtual memory address space (ppGTT) for use within a context
+ * on the same file. Extensions can be provided to configure exactly how the
+ * address space is setup upon creation.
+ *
+ * The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is
+ * returned in the outparam @vm_id.
+ *
+ * No flags are defined, with all bits reserved and must be zero.
+ *
+ * An extension chain maybe provided, starting with @extensions, and terminated
+ * by the @next_extension being 0. Currently, no extensions are defined.
+ *
+ * DRM_I915_GEM_VM_DESTROY -
+ *
+ * Destroys a previously created VM id, specified in @vm_id.
+ *
+ * No extensions or flags are allowed currently, and so must be zero.
+ */
+struct drm_i915_gem_vm_control {
+	__u64 extensions;
+	__u32 flags;
+	__u32 vm_id;
+};
+
 struct drm_i915_reg_read {
 	/*
 	 * Register offset.
@@ -1542,7 +1573,19 @@ struct drm_i915_gem_context_param {
  * On creation, all new contexts are marked as recoverable.
  */
 #define I915_CONTEXT_PARAM_RECOVERABLE	0x8
+
+	/*
+	 * The id of the associated virtual memory address space (ppGTT) of
+	 * this context. Can be retrieved and passed to another context
+	 * (on the same fd) for both to use the same ppGTT and so share
+	 * address layouts, and avoid reloading the page tables on context
+	 * switches between themselves.
+	 *
+	 * See DRM_I915_GEM_VM_CREATE and DRM_I915_GEM_VM_DESTROY.
+	 */
+#define I915_CONTEXT_PARAM_VM		0x9
 /* Must be kept compact -- no holes and well documented */
+
 	__u64 value;
 };
 

commit 9d1305ef80b95dde0337106ed8b826604e2155ad
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 22 09:23:22 2019 +0000

    drm/i915: Introduce the i915_user_extension_method
    
    An idea for extending uABI inspired by Vulkan's extension chains.
    Instead of expanding the data struct for each ioctl every time we need
    to add a new feature, define an extension chain instead. As we add
    optional interfaces to control the ioctl, we define a new extension
    struct that can be linked into the ioctl data only when required by the
    user. The key advantage being able to ignore large control structs for
    optional interfaces/extensions, while being able to process them in a
    consistent manner.
    
    In comparison to other extensible ioctls, the key difference is the
    use of a linked chain of extension structs vs an array of tagged
    pointers. For example,
    
    struct drm_amdgpu_cs_chunk {
            __u32           chunk_id;
            __u32           length_dw;
            __u64           chunk_data;
    };
    
    struct drm_amdgpu_cs_in {
            __u32           ctx_id;
            __u32           bo_list_handle;
            __u32           num_chunks;
            __u32           _pad;
            __u64           chunks;
    };
    
    allows userspace to pass in array of pointers to extension structs, but
    must therefore keep constructing that array along side the command stream.
    In dynamic situations like that, a linked list is preferred and does not
    similar from extra cache line misses as the extension structs themselves
    must still be loaded separate to the chunks array.
    
    v2: Apply the tail call optimisation directly to nip the worry of stack
    overflow in the bud.
    v3: Defend against recursion.
    v4: Fixup local types to match new uabi
    
    Opens:
    - do we include the result as an out-field in each chain?
    struct i915_user_extension {
            __u64 next_extension;
            __u64 name;
            __s32 result;
            __u32 mbz; /* reserved for future use */
    };
    * Undecided, so provision some room for future expansion.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190322092325.5883-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index aa2d4c73a97d..1c69ed16a923 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -62,6 +62,28 @@ extern "C" {
 #define I915_ERROR_UEVENT		"ERROR"
 #define I915_RESET_UEVENT		"RESET"
 
+/*
+ * i915_user_extension: Base class for defining a chain of extensions
+ *
+ * Many interfaces need to grow over time. In most cases we can simply
+ * extend the struct and have userspace pass in more data. Another option,
+ * as demonstrated by Vulkan's approach to providing extensions for forward
+ * and backward compatibility, is to use a list of optional structs to
+ * provide those extra details.
+ *
+ * The key advantage to using an extension chain is that it allows us to
+ * redefine the interface more easily than an ever growing struct of
+ * increasing complexity, and for large parts of that interface to be
+ * entirely optional. The downside is more pointer chasing; chasing across
+ * the __user boundary with pointers encapsulated inside u64.
+ */
+struct i915_user_extension {
+	__u64 next_extension;
+	__u32 name;
+	__u32 flags; /* All undefined bits must be zero. */
+	__u32 rsvd[4]; /* Reserved for future use; must be zero. */
+};
+
 /*
  * MOCS indexes used for GPU surfaces, defining the cacheability of the
  * surface data and the coherency for this data wrt. CPU vs. GPU accesses.

commit c8b502422bfe04422261cb2861977a5cd31cc1da
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Mar 5 16:26:43 2019 +0000

    drm/i915: Remove last traces of exec-id (GEM_BUSY)
    
    As we allow per-context engine allows the legacy concept of
    I915_EXEC_RING no longer applies universally. We are still exposing the
    unrelated exec-id in GEM_BUSY, so transition this ioctl (once more
    slightly changing its ABI, but no one cares) over to only reporting the
    uabi-class (not instance as we can not foreseeably fit those into the
    small bitmask).
    
    The only user of the extended ring information from GEM_BUSY is ddx/sna,
    which tries to use the non-rcs business information to guide which
    engine to use for subsequent operations on foreign bo. All that matters
    for it is the decision between rcs and !rcs, so it is unaffected by the
    change in higher bits.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190305162643.20243-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 1a60642c1d61..aa2d4c73a97d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1127,32 +1127,34 @@ struct drm_i915_gem_busy {
 	 * as busy may become idle before the ioctl is completed.
 	 *
 	 * Furthermore, if the object is busy, which engine is busy is only
-	 * provided as a guide. There are race conditions which prevent the
-	 * report of which engines are busy from being always accurate.
-	 * However, the converse is not true. If the object is idle, the
-	 * result of the ioctl, that all engines are idle, is accurate.
+	 * provided as a guide and only indirectly by reporting its class
+	 * (there may be more than one engine in each class). There are race
+	 * conditions which prevent the report of which engines are busy from
+	 * being always accurate.  However, the converse is not true. If the
+	 * object is idle, the result of the ioctl, that all engines are idle,
+	 * is accurate.
 	 *
 	 * The returned dword is split into two fields to indicate both
-	 * the engines on which the object is being read, and the
-	 * engine on which it is currently being written (if any).
+	 * the engine classess on which the object is being read, and the
+	 * engine class on which it is currently being written (if any).
 	 *
 	 * The low word (bits 0:15) indicate if the object is being written
 	 * to by any engine (there can only be one, as the GEM implicit
 	 * synchronisation rules force writes to be serialised). Only the
-	 * engine for the last write is reported.
+	 * engine class (offset by 1, I915_ENGINE_CLASS_RENDER is reported as
+	 * 1 not 0 etc) for the last write is reported.
 	 *
-	 * The high word (bits 16:31) are a bitmask of which engines are
-	 * currently reading from the object. Multiple engines may be
+	 * The high word (bits 16:31) are a bitmask of which engines classes
+	 * are currently reading from the object. Multiple engines may be
 	 * reading from the object simultaneously.
 	 *
-	 * The value of each engine is the same as specified in the
-	 * EXECBUFFER2 ioctl, i.e. I915_EXEC_RENDER, I915_EXEC_BSD etc.
-	 * Note I915_EXEC_DEFAULT is a symbolic value and is mapped to
-	 * the I915_EXEC_RENDER engine for execution, and so it is never
+	 * The value of each engine class is the same as specified in the
+	 * I915_CONTEXT_SET_ENGINES parameter and via perf, i.e.
+	 * I915_ENGINE_CLASS_RENDER, I915_ENGINE_CLASS_COPY, etc.
 	 * reported as active itself. Some hardware may have parallel
 	 * execution engines, e.g. multiple media engines, which are
-	 * mapped to the same identifier in the EXECBUFFER2 ioctl and
-	 * so are not separately reported for busyness.
+	 * mapped to the same class identifier and so are not separately
+	 * reported for busyness.
 	 *
 	 * Caveat emptor:
 	 * Only the boolean result of this query is reliable; that is whether

commit d90c06d57027203f73021bb7ddb30b800d65c636
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 1 14:03:47 2019 +0000

    drm/i915: Fix I915_EXEC_RING_MASK
    
    This was supposed to be a mask of all known rings, but it is being used
    by execbuffer to filter out invalid rings, and so is instead mapping high
    unused values onto valid rings. Instead of a mask of all known rings,
    we need it to be the mask of all possible rings.
    
    Fixes: 549f7365820a ("drm/i915: Enable SandyBridge blitter ring")
    Fixes: de1add360522 ("drm/i915: Decouple execbuf uAPI from internal implementation")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: <stable@vger.kernel.org> # v4.6+
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190301140404.26690-21-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index b10eea3f6d24..1a60642c1d61 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -979,7 +979,7 @@ struct drm_i915_gem_execbuffer2 {
 	 * struct drm_i915_gem_exec_fence *fences.
 	 */
 	__u64 cliprects_ptr;
-#define I915_EXEC_RING_MASK              (7<<0)
+#define I915_EXEC_RING_MASK              (0x3f)
 #define I915_EXEC_DEFAULT                (0<<0)
 #define I915_EXEC_RENDER                 (1<<0)
 #define I915_EXEC_BSD                    (2<<0)

commit e88619646971168e3baedc850c21243d303e31ca
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Mar 1 17:09:00 2019 +0000

    drm/i915: Use HW semaphores for inter-engine synchronisation on gen8+
    
    Having introduced per-context seqno, we now have a means to identity
    progress across the system without feel of rollback as befell the
    global_seqno. That is we can program a MI_SEMAPHORE_WAIT operation in
    advance of submission safe in the knowledge that our target seqno and
    address is stable.
    
    However, since we are telling the GPU to busy-spin on the target address
    until it matches the signaling seqno, we only want to do so when we are
    sure that busy-spin will be completed quickly. To achieve this we only
    submit the request to HW once the signaler is itself executing (modulo
    preemption causing us to wait longer), and we only do so for default and
    above priority requests (so that idle priority tasks never themselves
    hog the GPU waiting for others).
    
    As might be reasonably expected, HW semaphores excel in inter-engine
    synchronisation microbenchmarks (where the 3x reduced latency / increased
    throughput more than offset the power cost of spinning on a second ring)
    and have significant improvement (can be up to ~10%, most see no change)
    for single clients that utilize multiple engines (typically media players
    and transcoders), without regressing multiple clients that can saturate
    the system or changing the power envelope dramatically.
    
    v3: Drop the older NEQ branch, now we pin the signaler's HWSP anyway.
    v4: Tell the world and include it as part of scheduler caps.
    
    Testcase: igt/gem_exec_whisper
    Testcase: igt/benchmarks/gem_wsim
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190301170901.8340-3-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 8304a7f1ec3f..b10eea3f6d24 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -479,6 +479,7 @@ typedef struct drm_i915_irq_wait {
 #define   I915_SCHEDULER_CAP_ENABLED	(1ul << 0)
 #define   I915_SCHEDULER_CAP_PRIORITY	(1ul << 1)
 #define   I915_SCHEDULER_CAP_PREEMPTION	(1ul << 2)
+#define   I915_SCHEDULER_CAP_SEMAPHORES	(1ul << 3)
 
 #define I915_PARAM_HUC_STATUS		 42
 

commit be03564bd7b60b119aac60443b3602bac38d6405
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Feb 18 09:46:28 2019 +0000

    drm/i915: Include reminders about leaving no holes in uAPI enums
    
    We don't want to pre-reserve any holes in our uAPI for that is a sign of
    nefarious and hidden activity. Add a reminder about our uAPI
    expectations to encourage good practice when adding new defines/enums.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190218094628.13522-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index c890b7992d5c..8304a7f1ec3f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -99,6 +99,8 @@ enum drm_i915_gem_engine_class {
 	I915_ENGINE_CLASS_VIDEO		= 2,
 	I915_ENGINE_CLASS_VIDEO_ENHANCE	= 3,
 
+	/* should be kept compact */
+
 	I915_ENGINE_CLASS_INVALID	= -1
 };
 
@@ -319,6 +321,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_PERF_ADD_CONFIG	0x37
 #define DRM_I915_PERF_REMOVE_CONFIG	0x38
 #define DRM_I915_QUERY			0x39
+/* Must be kept compact -- no holes */
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -559,6 +562,8 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_MMAP_GTT_COHERENT	52
 
+/* Must be kept compact -- no holes and well documented */
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*
@@ -574,6 +579,7 @@ typedef struct drm_i915_getparam {
 #define I915_SETPARAM_TEX_LRU_LOG_GRANULARITY             2
 #define I915_SETPARAM_ALLOW_BATCHBUFFER                   3
 #define I915_SETPARAM_NUM_USED_FENCES                     4
+/* Must be kept compact -- no holes */
 
 typedef struct drm_i915_setparam {
 	int param;
@@ -1511,6 +1517,7 @@ struct drm_i915_gem_context_param {
  * On creation, all new contexts are marked as recoverable.
  */
 #define I915_CONTEXT_PARAM_RECOVERABLE	0x8
+/* Must be kept compact -- no holes and well documented */
 	__u64 value;
 };
 
@@ -1734,6 +1741,7 @@ struct drm_i915_perf_oa_config {
 struct drm_i915_query_item {
 	__u64 query_id;
 #define DRM_I915_QUERY_TOPOLOGY_INFO    1
+/* Must be kept compact -- no holes and well documented */
 
 	/*
 	 * When set to zero by userspace, this is filled with the size of the

commit ba4fda620a5f7db521aa9e0262cf49854c1b1d9c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Feb 18 10:58:21 2019 +0000

    drm/i915: Optionally disable automatic recovery after a GPU reset
    
    Some clients, such as mesa, may only emit minimal incremental batches
    that rely on the logical context state from previous batches. They know
    that recovery is impossible after a hang as their required GPU state is
    lost, and that each in flight and subsequent batch will hang (resetting
    the context image back to default perpetuating the problem).
    
    To avoid getting into the state in the first place, we can allow clients
    to opt out of automatic recovery and elect to ban any guilty context
    following a hang. This prevents the continual stream of hangs and allows
    the client to recreate their context and rebuild the state from scratch.
    
    v2: Prefer calling it recoverable rather than unrecoverable.
    
    References: https://lists.freedesktop.org/archives/mesa-dev/2019-February/215431.html
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Kenneth Graunke <kenneth@whitecape.org>
    Cc: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
    Acked-by: Kenneth Graunke <kenneth@whitecape.org> # for mesa
    Link: https://patchwork.freedesktop.org/patch/msgid/20190218105821.17293-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 397810fa2d33..c890b7992d5c 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1491,6 +1491,26 @@ struct drm_i915_gem_context_param {
 	 * drm_i915_gem_context_param_sseu.
 	 */
 #define I915_CONTEXT_PARAM_SSEU		0x7
+
+/*
+ * Not all clients may want to attempt automatic recover of a context after
+ * a hang (for example, some clients may only submit very small incremental
+ * batches relying on known logical state of previous batches which will never
+ * recover correctly and each attempt will hang), and so would prefer that
+ * the context is forever banned instead.
+ *
+ * If set to false (0), after a reset, subsequent (and in flight) rendering
+ * from this context is discarded, and the client will need to create a new
+ * context to use instead.
+ *
+ * If set to true (1), the kernel will automatically attempt to recover the
+ * context by skipping the hanging batch and executing the next batch starting
+ * from the default context state (discarding the incomplete logical context
+ * state lost due to the reset).
+ *
+ * On creation, all new contexts are marked as recoverable.
+ */
+#define I915_CONTEXT_PARAM_RECOVERABLE	0x8
 	__u64 value;
 };
 

commit e46c2e99f60043bfdb63f18fe775db1f688906d9
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Feb 5 09:50:31 2019 +0000

    drm/i915: Expose RPCS (SSEU) configuration to userspace (Gen11 only)
    
    We want to allow userspace to reconfigure the subslice configuration on a
    per context basis.
    
    This is required for the functional requirement of shutting down non-VME
    enabled sub-slices on Gen11 parts.
    
    To do so, we expose a context parameter to allow adjustment of the RPCS
    register stored within the context image (and currently not accessible via
    LRI).
    
    If the context is adjusted before first use or whilst idle, the adjustment
    is for "free"; otherwise if the context is active we queue a request to do
    so (using the kernel context), following all other activity by that
    context, which is also marked as barrier for all following submission
    against the same context.
    
    Since the overhead of device re-configuration during context switching can
    be significant, especially in multi-context workloads, we limit this new
    uAPI to only support the Gen11 VME use case. In this use case either the
    device is fully enabled, and exactly one slice and half of the subslices
    are enabled.
    
    Example usage:
    
            struct drm_i915_gem_context_param_sseu sseu = { };
            struct drm_i915_gem_context_param arg = {
                    .param = I915_CONTEXT_PARAM_SSEU,
                    .ctx_id = gem_context_create(fd),
                    .size = sizeof(sseu),
                    .value = to_user_pointer(&sseu)
            };
    
            /* Query device defaults. */
            gem_context_get_param(fd, &arg);
    
            /* Set VME configuration on a 1x6x8 part. */
            sseu.slice_mask = 0x1;
            sseu.subslice_mask = 0xe0;
            gem_context_set_param(fd, &arg);
    
    v2: Fix offset of CTX_R_PWR_CLK_STATE in intel_lr_context_set_sseu()
        (Lionel)
    
    v3: Add ability to program this per engine (Chris)
    
    v4: Move most get_sseu() into i915_gem_context.c (Lionel)
    
    v5: Validate sseu configuration against the device's capabilities (Lionel)
    
    v6: Change context powergating settings through MI_SDM on kernel context
        (Chris)
    
    v7: Synchronize the requests following a powergating setting change using
        a global dependency (Chris)
        Iterate timelines through dev_priv.gt.active_rings (Tvrtko)
        Disable RPCS configuration setting for non capable users
        (Lionel/Tvrtko)
    
    v8: s/union intel_sseu/struct intel_sseu/ (Lionel)
        s/dev_priv/i915/ (Tvrtko)
        Change uapi class/instance fields to u16 (Tvrtko)
        Bump mask fields to 64bits (Lionel)
        Don't return EPERM when dynamic sseu is disabled (Tvrtko)
    
    v9: Import context image into kernel context's ppgtt only when
        reconfiguring powergated slice/subslices (Chris)
        Use aliasing ppgtt when needed (Michel)
    
    Tvrtko Ursulin:
    
    v10:
     * Update for upstream changes.
     * Request submit needs a RPM reference.
     * Reject on !FULL_PPGTT for simplicity.
     * Pull out get/set param to helpers for readability and less indent.
     * Use i915_request_await_dma_fence in add_global_barrier to skip waits
       on the same timeline and avoid GEM_BUG_ON.
     * No need to explicitly assign a NULL pointer to engine in legacy mode.
     * No need to move gen8_make_rpcs up.
     * Factored out global barrier as prep patch.
     * Allow to only CAP_SYS_ADMIN if !Gen11.
    
    v11:
     * Remove engine vfunc in favour of local helper. (Chris Wilson)
     * Stop retiring requests before updates since it is not needed
       (Chris Wilson)
     * Implement direct CPU update path for idle contexts. (Chris Wilson)
     * Left side dependency needs only be on the same context timeline.
       (Chris Wilson)
     * It is sufficient to order the timeline. (Chris Wilson)
     * Reject !RCS configuration attempts with -ENODEV for now.
    
    v12:
     * Rebase for make_rpcs.
    
    v13:
     * Centralize SSEU normalization to make_rpcs.
     * Type width checking (uAPI <-> implementation).
     * Gen11 restrictions uAPI checks.
     * Gen11 subslice count differences handling.
     Chris Wilson:
     * args->size handling fixes.
     * Update context image from GGTT.
     * Postpone context image update to pinning.
     * Use i915_gem_active_raw instead of last_request_on_engine.
    
    v14:
     * Add activity tracker on intel_context to fix the lifetime issues
       and simplify the code. (Chris Wilson)
    
    v15:
     * Fix context pin leak if no space in ring by simplifying the
       context pinning sequence.
    
    v16:
     * Rebase for context get/set param locking changes.
     * Just -ENODEV on !Gen11. (Joonas)
    
    v17:
     * Fix one Gen11 subslice enablement rule.
     * Handle error from i915_sw_fence_await_sw_fence_gfp. (Chris Wilson)
    
    v18:
     * Update commit message. (Joonas)
     * Restrict uAPI to VME use case. (Joonas)
    
    v19:
     * Rebase.
    
    v20:
     * Rebase for ce->active_tracker.
    
    v21:
     * Rebase for IS_GEN changes.
    
    v22:
     * Reserve uAPI for flags straight away. (Chris Wilson)
    
    v23:
     * Rebase for RUNTIME_INFO.
    
    v24:
     * Added some headline docs for the uapi usage. (Joonas/Chris)
    
    v25:
     * Renamed class/instance to engine_class/engine_instance to avoid clash
       with C++ keyword. (Tony Ye)
    
    v26:
     * Rebased for runtime pm api changes.
    
    v27:
     * Rebased for intel_context_init.
     * Wrap commit msg to 75.
    
    v28:
     (Chris Wilson)
     * Use i915_gem_ggtt.
     * Use i915_request_await_dma_fence to show a better example.
    
    v29:
     * i915_timeline_set_barrier can now fail. (Chris Wilson)
    
    v30:
     * Capture some acks.
    
    v31:
     * Drop the WARN_ON from use controllable paths. (Chris Wilson)
     * Use overflows_type for all checks.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100899
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=107634
    Issue: https://github.com/intel/media-driver/issues/267
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Zhipeng Gong <zhipeng.gong@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tony Ye <tony.ye@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Timo Aaltonen <timo.aaltonen@canonical.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Stéphane Marchesin <marcheu@chromium.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190205095032.22673-4-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 298b2e197744..397810fa2d33 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1486,9 +1486,73 @@ struct drm_i915_gem_context_param {
 #define   I915_CONTEXT_MAX_USER_PRIORITY	1023 /* inclusive */
 #define   I915_CONTEXT_DEFAULT_PRIORITY		0
 #define   I915_CONTEXT_MIN_USER_PRIORITY	-1023 /* inclusive */
+	/*
+	 * When using the following param, value should be a pointer to
+	 * drm_i915_gem_context_param_sseu.
+	 */
+#define I915_CONTEXT_PARAM_SSEU		0x7
 	__u64 value;
 };
 
+/**
+ * Context SSEU programming
+ *
+ * It may be necessary for either functional or performance reason to configure
+ * a context to run with a reduced number of SSEU (where SSEU stands for Slice/
+ * Sub-slice/EU).
+ *
+ * This is done by configuring SSEU configuration using the below
+ * @struct drm_i915_gem_context_param_sseu for every supported engine which
+ * userspace intends to use.
+ *
+ * Not all GPUs or engines support this functionality in which case an error
+ * code -ENODEV will be returned.
+ *
+ * Also, flexibility of possible SSEU configuration permutations varies between
+ * GPU generations and software imposed limitations. Requesting such a
+ * combination will return an error code of -EINVAL.
+ *
+ * NOTE: When perf/OA is active the context's SSEU configuration is ignored in
+ * favour of a single global setting.
+ */
+struct drm_i915_gem_context_param_sseu {
+	/*
+	 * Engine class & instance to be configured or queried.
+	 */
+	__u16 engine_class;
+	__u16 engine_instance;
+
+	/*
+	 * Unused for now. Must be cleared to zero.
+	 */
+	__u32 flags;
+
+	/*
+	 * Mask of slices to enable for the context. Valid values are a subset
+	 * of the bitmask value returned for I915_PARAM_SLICE_MASK.
+	 */
+	__u64 slice_mask;
+
+	/*
+	 * Mask of subslices to enable for the context. Valid values are a
+	 * subset of the bitmask value return by I915_PARAM_SUBSLICE_MASK.
+	 */
+	__u64 subslice_mask;
+
+	/*
+	 * Minimum/Maximum number of EUs to enable per subslice for the
+	 * context. min_eus_per_subslice must be inferior or equal to
+	 * max_eus_per_subslice.
+	 */
+	__u16 min_eus_per_subslice;
+	__u16 max_eus_per_subslice;
+
+	/*
+	 * Unused for now. Must be cleared to zero.
+	 */
+	__u32 rsvd;
+};
+
 enum drm_i915_oa_format {
 	I915_OA_FORMAT_A13 = 1,	    /* HSW only */
 	I915_OA_FORMAT_A29,	    /* HSW only */

commit fe841686470d383e33b606d0704ef4295141c582
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Nov 16 15:55:09 2018 +0200

    Revert "drm/i915/perf: add a parameter to control the size of OA buffer"
    
    Userspace portion is still missing.
    
    This reverts commit cd956bfcd0f58d20485ac0a785415f7d9327a95f.
    
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181116135510.13807-1-joonas.lahtinen@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index e477ef8c644e..298b2e197744 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1540,13 +1540,6 @@ enum drm_i915_perf_property_id {
 	 */
 	DRM_I915_PERF_PROP_OA_EXPONENT,
 
-	/**
-	 * Specify a global OA buffer size to be allocated in bytes. The size
-	 * specified must be supported by HW (currently supported sizes are
-	 * powers of 2 ranging from 128Kb to 16Mb).
-	 */
-	DRM_I915_PERF_PROP_OA_BUFFER_SIZE,
-
 	DRM_I915_PERF_PROP_MAX /* non-ABI */
 };
 

commit cd956bfcd0f58d20485ac0a785415f7d9327a95f
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Oct 23 11:07:07 2018 +0100

    drm/i915/perf: add a parameter to control the size of OA buffer
    
    The way our hardware is designed doesn't seem to let us use the
    MI_RECORD_PERF_COUNT command without setting up a circular buffer.
    
    In the case where the user didn't request OA reports to be available
    through the i915 perf stream, we can set the OA buffer to the minimum
    size to avoid consuming memory which won't be used by the driver.
    
    v2: Simplify oa buffer size exponent selection (Chris)
        Reuse vma size field (Lionel)
    
    v3: Restrict size opening parameter to values supported by HW (Chris)
    
    v4: Drop out of date comment (Matt)
        Add debug message when buffer size is rejected (Matt)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20181023100707.31738-5-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 298b2e197744..e477ef8c644e 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1540,6 +1540,13 @@ enum drm_i915_perf_property_id {
 	 */
 	DRM_I915_PERF_PROP_OA_EXPONENT,
 
+	/**
+	 * Specify a global OA buffer size to be allocated in bytes. The size
+	 * specified must be supported by HW (currently supported sizes are
+	 * powers of 2 ranging from 128Kb to 16Mb).
+	 */
+	DRM_I915_PERF_PROP_OA_BUFFER_SIZE,
+
 	DRM_I915_PERF_PROP_MAX /* non-ABI */
 };
 

commit 4bdafb9ddfa4b3d970e2194d00e1c6d5002f513f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 26 21:12:22 2018 +0100

    drm/i915: Remove i915.enable_ppgtt override
    
    Now that we are confident in providing full-ppgtt where supported,
    remove the ability to override the context isolation.
    
    v2: Remove faked aliasing-ppgtt for testing as it no longer is accepted.
    v3: s/USES/HAS/ to match usage and reject attempts to load the module on
    old GVT-g setups that do not provide support for full-ppgtt.
    v4: Insulate ABI ppGTT values from our internal enum (later plans
    involve moving ppGTT depth out of the enum, thus potentially breaking
    ABI unless we document the current values).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Zhi Wang <zhi.a.wang@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180926201222.5643-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index a4446f452040..298b2e197744 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -412,6 +412,14 @@ typedef struct drm_i915_irq_wait {
 	int irq_seq;
 } drm_i915_irq_wait_t;
 
+/*
+ * Different modes of per-process Graphics Translation Table,
+ * see I915_PARAM_HAS_ALIASING_PPGTT
+ */
+#define I915_GEM_PPGTT_NONE	0
+#define I915_GEM_PPGTT_ALIASING	1
+#define I915_GEM_PPGTT_FULL	2
+
 /* Ioctl to query kernel params:
  */
 #define I915_PARAM_IRQ_ACTIVE            1

commit 900ccf30f9e112b508a61b228bf014e3bea14bc4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jul 20 11:19:10 2018 +0100

    drm/i915: Only force GGTT coherency w/a on required chipsets
    
    Not all chipsets have an internal buffer delaying the visibility of
    writes via the GGTT being visible by other physical paths, but we use a
    very heavy workaround for all. We only need to apply that workarounds to
    the chipsets we know suffer from the delay and the resulting coherency
    issue.
    
    Similarly, the same inconsistent coherency fouls up our ABI promise that
    a write into a mmap_gtt is immediately visible to others. Since the HW
    has made that a lie, let userspace know when that contract is broken.
    (Not that userspace would want to use mmap_gtt on those chipsets for
    other performance reasons...)
    
    Testcase: igt/drv_selftest/live_coherency
    Testcase: igt/gem_mmap_gtt/coherency
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=100587
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Tomasz Lis <tomasz.lis@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180720101910.11153-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 7f5634ce8e88..a4446f452040 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -529,6 +529,28 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_CS_TIMESTAMP_FREQUENCY 51
 
+/*
+ * Once upon a time we supposed that writes through the GGTT would be
+ * immediately in physical memory (once flushed out of the CPU path). However,
+ * on a few different processors and chipsets, this is not necessarily the case
+ * as the writes appear to be buffered internally. Thus a read of the backing
+ * storage (physical memory) via a different path (with different physical tags
+ * to the indirect write via the GGTT) will see stale values from before
+ * the GGTT write. Inside the kernel, we can for the most part keep track of
+ * the different read/write domains in use (e.g. set-domain), but the assumption
+ * of coherency is baked into the ABI, hence reporting its true state in this
+ * parameter.
+ *
+ * Reports true when writes via mmap_gtt are immediately visible following an
+ * lfence to flush the WCB.
+ *
+ * Reports false when writes via mmap_gtt are indeterminately delayed in an in
+ * internal buffer and are _not_ immediately visible to third parties accessing
+ * directly via mmap_cpu/mmap_wc. Use of mmap_gtt as part of an IPC
+ * communications channel when reporting false is strongly disadvised.
+ */
+#define I915_PARAM_MMAP_GTT_COHERENT	52
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*

commit c822e059185585f79b2007b1d2cafacf4264e610
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 6 12:28:57 2018 +0000

    drm/i915: expose rcs topology through query uAPI
    
    With the introduction of asymmetric slices in CNL, we cannot rely on
    the previous SUBSLICE_MASK getparam to tell userspace what subslices
    are available. Here we introduce a more detailed way of querying the
    Gen's GPU topology that doesn't aggregate numbers.
    
    This is essential for monitoring parts of the GPU with the OA unit,
    because counters need to be normalized to the number of
    EUs/subslices/slices. The current aggregated numbers like EU_TOTAL do
    not gives us sufficient information.
    
    The Mesa series making use of this API is :
    
        https://patchwork.freedesktop.org/series/38795/
    
    As a bonus we can draw representations of the GPU :
    
        https://imgur.com/a/vuqpa
    
    v2: Rename uapi struct s/_mask/_info/ (Tvrtko)
        Report max_slice/subslice/eus_per_subslice rather than strides (Tvrtko)
        Add uapi macros to read data from *_info structs (Tvrtko)
    
    v3: Use !!(v & DRM_I915_BIT()) for uapi macros instead of custom shifts (Tvrtko)
    
    v4: factorize query item writting (Tvrtko)
        tweak uapi struct/define names (Tvrtko)
    
    v5: Replace ALIGN() macro (Chris)
    
    v6: Updated uapi comments (Tvrtko)
        Moved flags != 0 checks into vfuncs (Tvrtko)
    
    v7: Use access_ok() before copying anything, to avoid overflows (Chris)
        Switch BUG_ON() to GEM_WARN_ON() (Tvrtko)
    
    v8: Tweak uapi comments style to match the coding style (Lionel)
    
    v9: Fix error in comment about computation of enabled subslice (Tvrtko)
    
    v10: Fix/update comments in uAPI (Sagar)
    
    v11: Drop drm_i915_query_(slice|subslice|eu)_info in favor of a single
         drm_i915_query_topology_info (Joonas)
    
    v12: Add subslice_stride/eu_stride in drm_i915_query_topology_info (Joonas)
    
    v13: Fix comment in uAPI (Joonas)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180306122857.27317-7-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index eedd5a23a944..7f5634ce8e88 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1619,6 +1619,7 @@ struct drm_i915_perf_oa_config {
 
 struct drm_i915_query_item {
 	__u64 query_id;
+#define DRM_I915_QUERY_TOPOLOGY_INFO    1
 
 	/*
 	 * When set to zero by userspace, this is filled with the size of the
@@ -1655,6 +1656,67 @@ struct drm_i915_query {
 	__u64 items_ptr;
 };
 
+/*
+ * Data written by the kernel with query DRM_I915_QUERY_TOPOLOGY_INFO :
+ *
+ * data: contains the 3 pieces of information :
+ *
+ * - the slice mask with one bit per slice telling whether a slice is
+ *   available. The availability of slice X can be queried with the following
+ *   formula :
+ *
+ *           (data[X / 8] >> (X % 8)) & 1
+ *
+ * - the subslice mask for each slice with one bit per subslice telling
+ *   whether a subslice is available. The availability of subslice Y in slice
+ *   X can be queried with the following formula :
+ *
+ *           (data[subslice_offset +
+ *                 X * subslice_stride +
+ *                 Y / 8] >> (Y % 8)) & 1
+ *
+ * - the EU mask for each subslice in each slice with one bit per EU telling
+ *   whether an EU is available. The availability of EU Z in subslice Y in
+ *   slice X can be queried with the following formula :
+ *
+ *           (data[eu_offset +
+ *                 (X * max_subslices + Y) * eu_stride +
+ *                 Z / 8] >> (Z % 8)) & 1
+ */
+struct drm_i915_query_topology_info {
+	/*
+	 * Unused for now. Must be cleared to zero.
+	 */
+	__u16 flags;
+
+	__u16 max_slices;
+	__u16 max_subslices;
+	__u16 max_eus_per_subslice;
+
+	/*
+	 * Offset in data[] at which the subslice masks are stored.
+	 */
+	__u16 subslice_offset;
+
+	/*
+	 * Stride at which each of the subslice masks for each slice are
+	 * stored.
+	 */
+	__u16 subslice_stride;
+
+	/*
+	 * Offset in data[] at which the EU masks are stored.
+	 */
+	__u16 eu_offset;
+
+	/*
+	 * Stride at which each of the EU masks for each subslice are stored.
+	 */
+	__u16 eu_stride;
+
+	__u8 data[];
+};
+
 #if defined(__cplusplus)
 }
 #endif

commit a446ae2c6e6555048301f2339cfd97b8eed6d0b7
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Tue Mar 6 12:28:56 2018 +0000

    drm/i915: add query uAPI
    
    There are a number of information that are readable from hardware
    registers and that we would like to make accessible to userspace. One
    particular example is the topology of the execution units (how are
    execution units grouped in subslices and slices and also which ones
    have been fused off for die recovery).
    
    At the moment the GET_PARAM ioctl covers some basic needs, but
    generally is only able to return a single value for each defined
    parameter. This is a bit problematic with topology descriptions which
    are array/maps of available units.
    
    This change introduces a new ioctl that can deal with requests to fill
    structures of potentially variable lengths. The user is expected fill
    a query with length fields set at 0 on the first call, the kernel then
    sets the length fields to the their expected values. A second call to
    the kernel with length fields at their expected values will trigger a
    copy of the data to the pointed memory locations.
    
    The scope of this uAPI is only to provide information to userspace,
    not to allow configuration of the device.
    
    v2: Simplify dispatcher code iteration (Tvrtko)
        Tweak uapi drm_i915_query_item structure (Tvrtko)
    
    v3: Rename pad fields into flags (Chris)
        Return error on flags field != 0 (Chris)
        Only copy length back to userspace in drm_i915_query_item (Chris)
    
    v4: Use array of functions instead of switch (Chris)
    
    v5: More comments in uapi (Tvrtko)
        Return query item errors in length field (All)
    
    v6: Tweak uapi comments style to match the coding style (Lionel)
    
    v7: Add i915_query.h (Joonas)
    
    v8: (Lionel) Change the behavior of the item iterator to report
        invalid queries into the query item rather than stopping the
        iteration. This enables userspace applications to query newer
        items on older kernels and only have failure on the items that are
        not supported.
    
    v9: Edit copyright headers (Joonas)
    
    v10: Typos & comments in uapi (Joonas)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180306122857.27317-6-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 29fa48e4755d..eedd5a23a944 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -318,6 +318,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_PERF_OPEN		0x36
 #define DRM_I915_PERF_ADD_CONFIG	0x37
 #define DRM_I915_PERF_REMOVE_CONFIG	0x38
+#define DRM_I915_QUERY			0x39
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -375,6 +376,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_PERF_OPEN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_OPEN, struct drm_i915_perf_open_param)
 #define DRM_IOCTL_I915_PERF_ADD_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_ADD_CONFIG, struct drm_i915_perf_oa_config)
 #define DRM_IOCTL_I915_PERF_REMOVE_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_REMOVE_CONFIG, __u64)
+#define DRM_IOCTL_I915_QUERY			DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_QUERY, struct drm_i915_query)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1606,15 +1608,53 @@ struct drm_i915_perf_oa_config {
 	__u32 n_flex_regs;
 
 	/*
-	 * These fields are pointers to tuples of u32 values (register
-	 * address, value). For example the expected length of the buffer
-	 * pointed by mux_regs_ptr is (2 * sizeof(u32) * n_mux_regs).
+	 * These fields are pointers to tuples of u32 values (register address,
+	 * value). For example the expected length of the buffer pointed by
+	 * mux_regs_ptr is (2 * sizeof(u32) * n_mux_regs).
 	 */
 	__u64 mux_regs_ptr;
 	__u64 boolean_regs_ptr;
 	__u64 flex_regs_ptr;
 };
 
+struct drm_i915_query_item {
+	__u64 query_id;
+
+	/*
+	 * When set to zero by userspace, this is filled with the size of the
+	 * data to be written at the data_ptr pointer. The kernel sets this
+	 * value to a negative value to signal an error on a particular query
+	 * item.
+	 */
+	__s32 length;
+
+	/*
+	 * Unused for now. Must be cleared to zero.
+	 */
+	__u32 flags;
+
+	/*
+	 * Data will be written at the location pointed by data_ptr when the
+	 * value of length matches the length of the data to be written by the
+	 * kernel.
+	 */
+	__u64 data_ptr;
+};
+
+struct drm_i915_query {
+	__u32 num_items;
+
+	/*
+	 * Unused for now. Must be cleared to zero.
+	 */
+	__u32 flags;
+
+	/*
+	 * This points to an array of num_items drm_i915_query_item structures.
+	 */
+	__u64 items_ptr;
+};
+
 #if defined(__cplusplus)
 }
 #endif

commit 6ec5bd348934887494541bcc9b53d621b1f2962c
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Feb 2 22:42:31 2018 +0200

    drm/i915: Deprecate I915_SET_COLORKEY_NONE
    
    Deprecate the silly I915_SET_COLORKEY_NONE flag. The obvious
    way to disable colorkey is to just set flags to 0, which is
    exactly what the intel ddx has been doing all along.
    
    Currently when userspace sets the flags to 0, we end up in a
    funny state where colorkey is disabled, but various colorkey
    vs. scaling checks still consider colorkey to be enabled, and
    thus we don't allow plane scaling to kick in.
    
    In case there is some other userspace out there that actually
    uses this flag (unlikely as this is an i915 specific uapi)
    we'll keep on accepting it.
    
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20180202204231.27905-1-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 536ee4febd74..29fa48e4755d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1358,7 +1358,9 @@ struct drm_intel_overlay_attrs {
  * active on a given plane.
  */
 
-#define I915_SET_COLORKEY_NONE		(1<<0) /* disable color key matching */
+#define I915_SET_COLORKEY_NONE		(1<<0) /* Deprecated. Instead set
+						* flags==0 to disable colorkeying.
+						*/
 #define I915_SET_COLORKEY_DESTINATION	(1<<1)
 #define I915_SET_COLORKEY_SOURCE	(1<<2)
 struct drm_intel_sprite_colorkey {

commit 3452fa3095e91acbcb1f6290e0d70fa7d3695a3a
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Nov 24 17:13:31 2017 +0000

    drm/i915/pmu: Aggregate all RC6 states into one counter
    
    Chris has discovered that RC6, RC6p and RC6pp counters are mutually
    exclusive, and even that on some SNB SKUs you get RC6p increasing, and on
    the others RC6.
    
    Furthermore RC6p and RC6pp were only present starting from GEN6 until,
    GEN7, not including Haswell.
    
    All this combined makes it questionable whether we need to reserve new ABI
    for these counters. One idea was to just combine them all under the RC6
    counter to simplify things for userspace. So that is what this patch does.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171124171331.17981-1-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 239e8633edc9..536ee4febd74 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -137,14 +137,10 @@ enum drm_i915_pmu_engine_sample {
 
 #define I915_PMU_ACTUAL_FREQUENCY	__I915_PMU_OTHER(0)
 #define I915_PMU_REQUESTED_FREQUENCY	__I915_PMU_OTHER(1)
-
 #define I915_PMU_INTERRUPTS		__I915_PMU_OTHER(2)
-
 #define I915_PMU_RC6_RESIDENCY		__I915_PMU_OTHER(3)
-#define I915_PMU_RC6p_RESIDENCY		__I915_PMU_OTHER(4)
-#define I915_PMU_RC6pp_RESIDENCY	__I915_PMU_OTHER(5)
 
-#define I915_PMU_LAST I915_PMU_RC6pp_RESIDENCY
+#define I915_PMU_LAST I915_PMU_RC6_RESIDENCY
 
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */

commit b552ae444e454eb3254c958e05b69820c0ef346d
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Thu Nov 23 10:07:01 2017 +0000

    drm/i915/pmu: Drop I915_ENGINE_SAMPLE_MAX from uapi headers
    
    We have agreed during the engine classes discussion that fields marked as
    non-ABI are better left out altogether from uapi headers.
    
    v2: Use a local define for maintanability. (Chris Wilson)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171123100701.18430-1-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 915a6e85a855..239e8633edc9 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -110,8 +110,7 @@ enum drm_i915_gem_engine_class {
 enum drm_i915_pmu_engine_sample {
 	I915_SAMPLE_BUSY = 0,
 	I915_SAMPLE_WAIT = 1,
-	I915_SAMPLE_SEMA = 2,
-	I915_ENGINE_SAMPLE_MAX /* non-ABI */
+	I915_SAMPLE_SEMA = 2
 };
 
 #define I915_PMU_SAMPLE_BITS (4)

commit 6060b6aec03c76f9ce0977b70c27429d39d2956e
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Nov 21 18:18:52 2017 +0000

    drm/i915/pmu: Add RC6 residency metrics
    
    For clients like intel-gpu-overlay it is easier to read the
    counters via the perf API than having to parse sysfs.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171121181852.16128-9-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index d840ff083520..915a6e85a855 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -141,7 +141,11 @@ enum drm_i915_pmu_engine_sample {
 
 #define I915_PMU_INTERRUPTS		__I915_PMU_OTHER(2)
 
-#define I915_PMU_LAST I915_PMU_INTERRUPTS
+#define I915_PMU_RC6_RESIDENCY		__I915_PMU_OTHER(3)
+#define I915_PMU_RC6p_RESIDENCY		__I915_PMU_OTHER(4)
+#define I915_PMU_RC6pp_RESIDENCY	__I915_PMU_OTHER(5)
+
+#define I915_PMU_LAST I915_PMU_RC6pp_RESIDENCY
 
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */

commit 0cd4684d6ea9a4ffec33fc19de4dd667bb90d0a5
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Nov 21 18:18:50 2017 +0000

    drm/i915/pmu: Add interrupt count metric
    
    For clients like intel-gpu-overlay it is easier to read the
    count via the perf API than having to parse /proc.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171121181852.16128-7-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 40e7b438bdaa..d840ff083520 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -139,7 +139,9 @@ enum drm_i915_pmu_engine_sample {
 #define I915_PMU_ACTUAL_FREQUENCY	__I915_PMU_OTHER(0)
 #define I915_PMU_REQUESTED_FREQUENCY	__I915_PMU_OTHER(1)
 
-#define I915_PMU_LAST I915_PMU_REQUESTED_FREQUENCY
+#define I915_PMU_INTERRUPTS		__I915_PMU_OTHER(2)
+
+#define I915_PMU_LAST I915_PMU_INTERRUPTS
 
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */

commit b46a33e271ed81bd765c632b972c49d5b44729c7
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Nov 21 18:18:45 2017 +0000

    drm/i915/pmu: Expose a PMU interface for perf queries
    
    From: Chris Wilson <chris@chris-wilson.co.uk>
    From: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    From: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    
    The first goal is to be able to measure GPU (and invidual ring) busyness
    without having to poll registers from userspace. (Which not only incurs
    holding the forcewake lock indefinitely, perturbing the system, but also
    runs the risk of hanging the machine.) As an alternative we can use the
    perf event counter interface to sample the ring registers periodically
    and send those results to userspace.
    
    Functionality we are exporting to userspace is via the existing perf PMU
    API and can be exercised via the existing tools. For example:
    
      perf stat -a -e i915/rcs0-busy/ -I 1000
    
    Will print the render engine busynnes once per second. All the performance
    counters can be enumerated (perf list) and have their unit of measure
    correctly reported in sysfs.
    
    v1-v2 (Chris Wilson):
    
    v2: Use a common timer for the ring sampling.
    
    v3: (Tvrtko Ursulin)
     * Decouple uAPI from i915 engine ids.
     * Complete uAPI defines.
     * Refactor some code to helpers for clarity.
     * Skip sampling disabled engines.
     * Expose counters in sysfs.
     * Pass in fake regs to avoid null ptr deref in perf core.
     * Convert to class/instance uAPI.
     * Use shared driver code for rc6 residency, power and frequency.
    
    v4: (Dmitry Rogozhkin)
     * Register PMU with .task_ctx_nr=perf_invalid_context
     * Expose cpumask for the PMU with the single CPU in the mask
     * Properly support pmu->stop(): it should call pmu->read()
     * Properly support pmu->del(): it should call stop(event, PERF_EF_UPDATE)
     * Introduce refcounting of event subscriptions.
     * Make pmu.busy_stats a refcounter to avoid busy stats going away
       with some deleted event.
     * Expose cpumask for i915 PMU to avoid multiple events creation of
       the same type followed by counter aggregation by perf-stat.
     * Track CPUs getting online/offline to migrate perf context. If (likely)
       cpumask will initially set CPU0, CONFIG_BOOTPARAM_HOTPLUG_CPU0 will be
       needed to see effect of CPU status tracking.
     * End result is that only global events are supported and perf stat
       works correctly.
     * Deny perf driver level sampling - it is prohibited for uncore PMU.
    
    v5: (Tvrtko Ursulin)
    
     * Don't hardcode number of engine samplers.
     * Rewrite event ref-counting for correctness and simplicity.
     * Store initial counter value when starting already enabled events
       to correctly report values to all listeners.
     * Fix RC6 residency readout.
     * Comments, GPL header.
    
    v6:
     * Add missing entry to v4 changelog.
     * Fix accounting in CPU hotplug case by copying the approach from
       arch/x86/events/intel/cstate.c. (Dmitry Rogozhkin)
    
    v7:
     * Log failure message only on failure.
     * Remove CPU hotplug notification state on unregister.
    
    v8:
     * Fix error unwind on failed registration.
     * Checkpatch cleanup.
    
    v9:
     * Drop the energy metric, it is available via intel_rapl_perf.
       (Ville Syrjälä)
     * Use HAS_RC6(p). (Chris Wilson)
     * Handle unsupported non-engine events. (Dmitry Rogozhkin)
     * Rebase for intel_rc6_residency_ns needing caller managed
       runtime pm.
     * Drop HAS_RC6 checks from the read callback since creating those
       events will be rejected at init time already.
     * Add counter units to sysfs so perf stat output is nicer.
     * Cleanup the attribute tables for brevity and readability.
    
    v10:
     * Fixed queued accounting.
    
    v11:
     * Move intel_engine_lookup_user to intel_engine_cs.c
     * Commit update. (Joonas Lahtinen)
    
    v12:
     * More accurate sampling. (Chris Wilson)
     * Store and report frequency in MHz for better usability from
       perf stat.
     * Removed metrics: queued, interrupts, rc6 counters.
     * Sample engine busyness based on seqno difference only
       for less MMIO (and forcewake) on all platforms. (Chris Wilson)
    
    v13:
     * Comment spelling, use mul_u32_u32 to work around potential GCC
       issue and somne code alignment changes. (Chris Wilson)
    
    v14:
     * Rebase.
    
    v15:
     * Rebase for RPS refactoring.
    
    v16:
     * Use the dynamic slot in the CPU hotplug state machine so that we are
       free to setup our state as multi-instance. Previously we were re-using
       the CPUHP_AP_PERF_X86_UNCORE_ONLINE slot which is neither used as
       multi-instance, nor owned by our driver to start with.
     * Register the CPU hotplug handlers after the PMU, otherwise the callback
       will get called before the PMU is initialized which can end up in
       perf_pmu_migrate_context with an un-initialized base.
     * Added workaround for a probable bug in cpuhp core.
    
    v17:
     * Remove workaround for the cpuhp bug.
    
    v18:
     * Rebase for drm_i915_gem_engine_class getting upstream before us.
    
    v19:
     * Rebase. (trivial)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Dmitry Rogozhkin <dmitry.v.rogozhkin@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171121181852.16128-2-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index b57985929553..40e7b438bdaa 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -102,6 +102,45 @@ enum drm_i915_gem_engine_class {
 	I915_ENGINE_CLASS_INVALID	= -1
 };
 
+/**
+ * DOC: perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915
+ *
+ */
+
+enum drm_i915_pmu_engine_sample {
+	I915_SAMPLE_BUSY = 0,
+	I915_SAMPLE_WAIT = 1,
+	I915_SAMPLE_SEMA = 2,
+	I915_ENGINE_SAMPLE_MAX /* non-ABI */
+};
+
+#define I915_PMU_SAMPLE_BITS (4)
+#define I915_PMU_SAMPLE_MASK (0xf)
+#define I915_PMU_SAMPLE_INSTANCE_BITS (8)
+#define I915_PMU_CLASS_SHIFT \
+	(I915_PMU_SAMPLE_BITS + I915_PMU_SAMPLE_INSTANCE_BITS)
+
+#define __I915_PMU_ENGINE(class, instance, sample) \
+	((class) << I915_PMU_CLASS_SHIFT | \
+	(instance) << I915_PMU_SAMPLE_BITS | \
+	(sample))
+
+#define I915_PMU_ENGINE_BUSY(class, instance) \
+	__I915_PMU_ENGINE(class, instance, I915_SAMPLE_BUSY)
+
+#define I915_PMU_ENGINE_WAIT(class, instance) \
+	__I915_PMU_ENGINE(class, instance, I915_SAMPLE_WAIT)
+
+#define I915_PMU_ENGINE_SEMA(class, instance) \
+	__I915_PMU_ENGINE(class, instance, I915_SAMPLE_SEMA)
+
+#define __I915_PMU_OTHER(x) (__I915_PMU_ENGINE(0xff, 0xff, 0xf) + 1 + (x))
+
+#define I915_PMU_ACTUAL_FREQUENCY	__I915_PMU_OTHER(0)
+#define I915_PMU_REQUESTED_FREQUENCY	__I915_PMU_OTHER(1)
+
+#define I915_PMU_LAST I915_PMU_REQUESTED_FREQUENCY
+
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */
 #define I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use

commit dab91783338bd3dd42638f89b5f7e34c57773207
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Fri Nov 10 19:08:44 2017 +0000

    drm/i915: expose command stream timestamp frequency to userspace
    
    We use to have this fixed per generation, but starting with CNL userspace
    cannot tell just off the PCI ID. Let's make this information available. This
    is particularly useful for performance monitoring where much of the
    normalization work is done using those timestamps (this include pipeline
    statistics in both GL & Vulkan as well as OA reports).
    
    v2: Use variables for 24MHz/19.2MHz values (Ewelina)
        Renamed function & coding style (Sagar)
    
    v3: Fix frequency read on Broadwell (Sagar)
        Fix missing divide by 4 on <= gen4 (Sagar)
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Tested-by: Rafael Antognolli <rafael.antognolli@intel.com>
    Reviewed-by: Sagar Arun Kamble <sagar.a.kamble@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110190845.32574-7-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6c02ced663f8..b57985929553 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -481,6 +481,12 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_CONTEXT_ISOLATION 50
 
+/* Frequency of the command streamer timestamps given by the *_TIMESTAMP
+ * registers. This used to be fixed per platform but from CNL onwards, this
+ * might vary depending on the parts.
+ */
+#define I915_PARAM_CS_TIMESTAMP_FREQUENCY 51
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*

commit d2b4b97933f5adacfba42dc3b9200d0e21fbe2c4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Nov 10 14:26:33 2017 +0000

    drm/i915: Record the default hw state after reset upon load
    
    Take a copy of the HW state after a reset upon module loading by
    executing a context switch from a blank context to the kernel context,
    thus saving the default hw state over the blank context image.
    We can then use the default hw state to initialise any future context,
    ensuring that each starts with the default view of hw state.
    
    v2: Unmap our default state from the GTT after stealing it from the
    context. This should stop us from accidentally overwriting it via the
    GTT (and frees up some precious GTT space).
    
    Testcase: igt/gem_ctx_isolation
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110142634.10551-7-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 1f7dfb22a7c2..6c02ced663f8 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -466,6 +466,21 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_EXEC_FENCE_ARRAY  49
 
+/*
+ * Query whether every context (both per-file default and user created) is
+ * isolated (insofar as HW supports). If this parameter is not true, then
+ * freshly created contexts may inherit values from an existing context,
+ * rather than default HW values. If true, it also ensures (insofar as HW
+ * supports) that all state set by this context will not leak to any other
+ * context.
+ *
+ * As not every engine across every gen support contexts, the returned
+ * value reports the support of context isolation for individual engines by
+ * returning a bitmask of each engine class set to true if that class supports
+ * isolation.
+ */
+#define I915_PARAM_HAS_CONTEXT_ISOLATION 50
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*

commit 1803fcbca2e444f7972430c4dc1c3e98c6ee1bc9
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Fri Nov 10 14:26:27 2017 +0000

    drm/i915: Define an engine class enum for the uABI
    
    We want to be able to report back to userspace details about an engine's
    class, and in return for userspace to be able to request actions
    regarding certain classes of engines. To isolate the uABI from any
    variations between hw generations, we define an abstract class for the
    engines and internally map onto the hw.
    
    v2: Remove MAX from the uABI; keep it internal if we need it, but don't
    let userspace make the mistake of using it themselves.
    v3: s/OTHER/INVALID/
      The use of OTHER is ill-defined, so remove it from the uABI as any
      future new type of engine can define a class to suit it. But keep a
      reserved value for an invalid class, so that we can always
      unambiguously express when something doesn't belong to the
      classification.
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com> #v2
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171110142634.10551-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index ac3c6503ca27..1f7dfb22a7c2 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -86,6 +86,22 @@ enum i915_mocs_table_index {
 	I915_MOCS_CACHED,
 };
 
+/*
+ * Different engines serve different roles, and there may be more than one
+ * engine serving each role. enum drm_i915_gem_engine_class provides a
+ * classification of the role of the engine, which may be used when requesting
+ * operations to be performed on a certain subset of engines, or for providing
+ * information about that group.
+ */
+enum drm_i915_gem_engine_class {
+	I915_ENGINE_CLASS_RENDER	= 0,
+	I915_ENGINE_CLASS_COPY		= 1,
+	I915_ENGINE_CLASS_VIDEO		= 2,
+	I915_ENGINE_CLASS_VIDEO_ENHANCE	= 3,
+
+	I915_ENGINE_CLASS_INVALID	= -1
+};
+
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */
 #define I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use

commit ebcaa1ff8b59097805d548fe7a676f194625c033
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Tue Oct 31 10:23:25 2017 +0000

    drm/i915: Reject unknown syncobj flags
    
    We have to reject unknown flags for uAPI considerations, and also
    because the curent implementation limits their i915 storage space
    to two bits.
    
    v2: (Chris Wilson)
     * Fix fail in ABI check.
     * Added unknown flags and BUILD_BUG_ON.
    
    v3:
     * Use ARCH_KMALLOC_MINALIGN instead of alignof. (Chris Wilson)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Fixes: cf6e7bac6357 ("drm/i915: Add support for drm syncobjs")
    Cc: Jason Ekstrand <jason@jlekstrand.net>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: intel-gfx@lists.freedesktop.org
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171031102326.9738-1-tvrtko.ursulin@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 125bde7d9504..ac3c6503ca27 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -839,6 +839,7 @@ struct drm_i915_gem_exec_fence {
 
 #define I915_EXEC_FENCE_WAIT            (1<<0)
 #define I915_EXEC_FENCE_SIGNAL          (1<<1)
+#define __I915_EXEC_FENCE_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_SIGNAL << 1))
 	__u32 flags;
 };
 

commit 822a4b673284672af697ccd66e8795f8a712a90d
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Fri Oct 6 13:45:59 2017 +0300

    drm/i915: Don't use BIT() in UAPI section
    
    Lets not introduce BIT() macro requirement for UAPI for now.
    
    Fixes: 3fd3a6ffe279 ("drm/i915: Simplify i915_reg_read_ioctl")
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171006104559.17312-1-joonas.lahtinen@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 7266b53191ee..125bde7d9504 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1318,7 +1318,7 @@ struct drm_i915_reg_read {
 	 * be specified
 	 */
 	__u64 offset;
-#define I915_REG_READ_8B_WA BIT(0)
+#define I915_REG_READ_8B_WA (1ul << 0)
 
 	__u64 val; /* Return value */
 };

commit ac14fbd460d0ec16e7750e40dcd8199b0ff83d0a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 3 21:34:53 2017 +0100

    drm/i915/scheduler: Support user-defined priorities
    
    Use a priority stored in the context as the initial value when
    submitting a request. This allows us to change the default priority on a
    per-context basis, allowing different contexts to be favoured with GPU
    time at the expense of lower importance work. The user can adjust the
    context's priority via I915_CONTEXT_PARAM_PRIORITY, with more positive
    values being higher priority (they will be serviced earlier, after their
    dependencies have been resolved). Any prerequisite work for an execbuf
    will have its priority raised to match the new request as required.
    
    Normal users can specify any value in the range of -1023 to 0 [default],
    i.e. they can reduce the priority of their workloads (and temporarily
    boost it back to normal if so desired).
    
    Privileged users can specify any value in the range of -1023 to 1023,
    [default is 0], i.e. they can raise their priority above all overs and
    so potentially starve the system.
    
    Note that the existing schedulers are not fair, nor load balancing, the
    execution is strictly by priority on a first-come, first-served basis,
    and the driver may choose to boost some requests above the range
    available to users.
    
    This priority was originally based around nice(2), but evolved to allow
    clients to adjust their priority within a small range, and allow for a
    privileged high priority range.
    
    For example, this can be used to implement EGL_IMG_context_priority
    https://www.khronos.org/registry/egl/extensions/IMG/EGL_IMG_context_priority.txt
    
            EGL_CONTEXT_PRIORITY_LEVEL_IMG determines the priority level of
            the context to be created. This attribute is a hint, as an
            implementation may not support multiple contexts at some
            priority levels and system policy may limit access to high
            priority contexts to appropriate system privilege level. The
            default value for EGL_CONTEXT_PRIORITY_LEVEL_IMG is
            EGL_CONTEXT_PRIORITY_MEDIUM_IMG."
    
    so we can map
    
            PRIORITY_HIGH -> 1023 [privileged, will failback to 0]
            PRIORITY_MED -> 0 [default]
            PRIORITY_LOW -> -1023
    
    They also map onto the priorities used by VkQueue (and a VkQueue is
    essentially a timeline, our i915_gem_context under full-ppgtt).
    
    v2: s/CAP_SYS_ADMIN/CAP_SYS_NICE/
    v3: Report min/max user priorities as defines in the uapi, and rebase
    internal priorities on the exposed values.
    
    Testcase: igt/gem_exec_schedule
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171003203453.15692-9-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index aa4a3b20ef6b..7266b53191ee 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -402,6 +402,9 @@ typedef struct drm_i915_irq_wait {
  * priorities and the driver will attempt to execute batches in priority order.
  * The param returns a capability bitmask, nonzero implies that the scheduler
  * is enabled, with different features present according to the mask.
+ *
+ * The initial priority for each batch is supplied by the context and is
+ * controlled via I915_CONTEXT_PARAM_PRIORITY.
  */
 #define I915_PARAM_HAS_SCHEDULER	 41
 #define   I915_SCHEDULER_CAP_ENABLED	(1ul << 0)
@@ -1367,6 +1370,10 @@ struct drm_i915_gem_context_param {
 #define I915_CONTEXT_PARAM_GTT_SIZE	0x3
 #define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE	0x4
 #define I915_CONTEXT_PARAM_BANNABLE	0x5
+#define I915_CONTEXT_PARAM_PRIORITY	0x6
+#define   I915_CONTEXT_MAX_USER_PRIORITY	1023 /* inclusive */
+#define   I915_CONTEXT_DEFAULT_PRIORITY		0
+#define   I915_CONTEXT_MIN_USER_PRIORITY	-1023 /* inclusive */
 	__u64 value;
 };
 

commit bf64e0b00e1ff30449cc68e7bc7498adb6faa343
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Oct 3 21:34:51 2017 +0100

    drm/i915: Expand I915_PARAM_HAS_SCHEDULER into a capability bitmask
    
    In the next few patches, we wish to enable different features for the
    scheduler, some which may subtlety change ABI (e.g. allow requests to be
    reordered under different circumstances). So we need to make sure
    userspace is cognizant of the changes (if they care), by which we employ
    the usual method of a GETPARAM. We already have an
    I915_PARAM_HAS_SCHEDULER (which notes the existing ability to reorder
    requests to avoid bubbles), and now we wish to extend that to be a
    bitmask to describe the different capabilities implemented.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20171003203453.15692-7-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index fe25a01c81f2..aa4a3b20ef6b 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -397,10 +397,17 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_MIN_EU_IN_POOL	 39
 #define I915_PARAM_MMAP_GTT_VERSION	 40
 
-/* Query whether DRM_I915_GEM_EXECBUFFER2 supports user defined execution
+/*
+ * Query whether DRM_I915_GEM_EXECBUFFER2 supports user defined execution
  * priorities and the driver will attempt to execute batches in priority order.
+ * The param returns a capability bitmask, nonzero implies that the scheduler
+ * is enabled, with different features present according to the mask.
  */
 #define I915_PARAM_HAS_SCHEDULER	 41
+#define   I915_SCHEDULER_CAP_ENABLED	(1ul << 0)
+#define   I915_SCHEDULER_CAP_PRIORITY	(1ul << 1)
+#define   I915_SCHEDULER_CAP_PREEMPTION	(1ul << 2)
+
 #define I915_PARAM_HUC_STATUS		 42
 
 /* Query whether DRM_I915_GEM_EXECBUFFER2 supports the ability to opt-out of

commit ee427e259567bc9ba817ddfa5abaf7033f5603e9
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Mon Sep 18 12:42:41 2017 +0100

    uapi/drm/i915: document field usage of drm_i915_perf_oa_config
    
    Document the expected length of buffers config pointers (tuple of u32
    values).
    
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170918114241.30105-1-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index b4505d55990d..fe25a01c81f2 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1511,6 +1511,11 @@ struct drm_i915_perf_oa_config {
 	__u32 n_boolean_regs;
 	__u32 n_flex_regs;
 
+	/*
+	 * These fields are pointers to tuples of u32 values (register
+	 * address, value). For example the expected length of the buffer
+	 * pointed by mux_regs_ptr is (2 * sizeof(u32) * n_mux_regs).
+	 */
 	__u64 mux_regs_ptr;
 	__u64 boolean_regs_ptr;
 	__u64 flex_regs_ptr;

commit 3fd3a6ffe279827543cbf4063e307ed18bad6763
Author: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Date:   Wed Sep 13 14:52:55 2017 +0300

    drm/i915: Simplify i915_reg_read_ioctl
    
    Convert to use the freshly available made INTEL_GEN_MASK for easier
    grepping and improve function readability and clarify the UABI
    documentation.
    
    No functional changes.
    
    v2:
    - Lift GEM_BUG_ONs and use is_power_of_2 (Chris)
    - Retain -EINVAL on bad flags behavior (Chris)
    
    v3:
    - Extract flags with 'entry->size - 1' (Chris)
    
    v4:
    - Add GEM_BUG_ON on for flags vs entry offset (Chris)
    
    v5:
    - Use 'u16' to match 'dev_priv' (Ville)
    
    v6:
    - Fix checkpatch.pl errors
    
    Signed-off-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170913115255.13851-2-joonas.lahtinen@linux.intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index d8d10d932759..b4505d55990d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1308,14 +1308,16 @@ struct drm_i915_reg_read {
 	 * be specified
 	 */
 	__u64 offset;
+#define I915_REG_READ_8B_WA BIT(0)
+
 	__u64 val; /* Return value */
 };
 /* Known registers:
  *
  * Render engine timestamp - 0x2358 + 64bit - gen7+
  * - Note this register returns an invalid value if using the default
- *   single instruction 8byte read, in order to workaround that use
- *   offset (0x2538 | 1) instead.
+ *   single instruction 8byte read, in order to workaround that pass
+ *   flag I915_REG_READ_8B_WA in offset field.
  *
  */
 

commit 17ad4fdd09e1613d7047aa9e00d7de68ad350204
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Sep 1 15:57:29 2017 +0100

    drm/i915/perf: Remove __user from u64 in drm_i915_perf_oa_config
    
    Sparse complains that these integers from which we form void __user *,
    and so we don't need the annotation itself inside the uABI.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170901145729.21363-2-chris@chris-wilson.co.uk
    Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6598fb76d2c2..d8d10d932759 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1509,9 +1509,9 @@ struct drm_i915_perf_oa_config {
 	__u32 n_boolean_regs;
 	__u32 n_flex_regs;
 
-	__u64 __user mux_regs_ptr;
-	__u64 __user boolean_regs_ptr;
-	__u64 __user flex_regs_ptr;
+	__u64 mux_regs_ptr;
+	__u64 boolean_regs_ptr;
+	__u64 flex_regs_ptr;
 };
 
 #if defined(__cplusplus)

commit cf6e7bac6357f0ccca51fcb5eb325e724f6b4c95
Author: Jason Ekstrand <jason@jlekstrand.net>
Date:   Tue Aug 15 15:57:33 2017 +0100

    drm/i915: Add support for drm syncobjs
    
    This commit adds support for waiting on or signaling DRM syncobjs as
    part of execbuf.  It does so by hijacking the currently unused cliprects
    pointer to instead point to an array of i915_gem_exec_fence structs
    which containe a DRM syncobj and a flags parameter which specifies
    whether to wait on it or to signal it.  This implementation
    theoretically allows for both flags to be set in which case it waits on
    the dma_fence that was in the syncobj and then immediately replaces it
    with the dma_fence from the current execbuf.
    
    v2:
     - Rebase on new syncobj API
    v3:
     - Pull everything out into helpers
     - Do all allocation in gem_execbuffer2
     - Pack the flags in the bottom 2 bits of the drm_syncobj*
    v4:
     - Prevent a potential race on syncobj->fence
    
    Testcase: igt/gem_exec_fence/syncobj*
    Signed-off-by: Jason Ekstrand <jason@jlekstrand.net>
    Link: https://patchwork.freedesktop.org/patch/msgid/1499289202-25441-1-git-send-email-jason.ekstrand@intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170815145733.4562-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index ce3833fa1e06..6598fb76d2c2 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -435,6 +435,11 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_EXEC_BATCH_FIRST	 48
 
+/* Query whether DRM_I915_GEM_EXECBUFFER2 supports supplying an array of
+ * drm_i915_gem_exec_fence structures.  See I915_EXEC_FENCE_ARRAY.
+ */
+#define I915_PARAM_HAS_EXEC_FENCE_ARRAY  49
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*
@@ -816,6 +821,17 @@ struct drm_i915_gem_exec_object2 {
 	__u64 rsvd2;
 };
 
+struct drm_i915_gem_exec_fence {
+	/**
+	 * User's handle for a drm_syncobj to wait on or signal.
+	 */
+	__u32 handle;
+
+#define I915_EXEC_FENCE_WAIT            (1<<0)
+#define I915_EXEC_FENCE_SIGNAL          (1<<1)
+	__u32 flags;
+};
+
 struct drm_i915_gem_execbuffer2 {
 	/**
 	 * List of gem_exec_object2 structs
@@ -830,7 +846,11 @@ struct drm_i915_gem_execbuffer2 {
 	__u32 DR1;
 	__u32 DR4;
 	__u32 num_cliprects;
-	/** This is a struct drm_clip_rect *cliprects */
+	/**
+	 * This is a struct drm_clip_rect *cliprects if I915_EXEC_FENCE_ARRAY
+	 * is not set.  If I915_EXEC_FENCE_ARRAY is set, then this is a
+	 * struct drm_i915_gem_exec_fence *fences.
+	 */
 	__u64 cliprects_ptr;
 #define I915_EXEC_RING_MASK              (7<<0)
 #define I915_EXEC_DEFAULT                (0<<0)
@@ -931,7 +951,14 @@ struct drm_i915_gem_execbuffer2 {
  * element).
  */
 #define I915_EXEC_BATCH_FIRST		(1<<18)
-#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_BATCH_FIRST<<1))
+
+/* Setting I915_FENCE_ARRAY implies that num_cliprects and cliprects_ptr
+ * define an array of i915_gem_exec_fence structures which specify a set of
+ * dma fences to wait upon or signal.
+ */
+#define I915_EXEC_FENCE_ARRAY   (1<<19)
+
+#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_ARRAY<<1))
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit f89823c212246d0671cc51e69894a3df1a743aee
Author: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Date:   Thu Aug 3 18:05:50 2017 +0100

    drm/i915/perf: Implement I915_PERF_ADD/REMOVE_CONFIG interface
    
    The motivation behind this new interface is expose at runtime the
    creation of new OA configs which can be used as part of the i915 perf
    open interface. This will enable the kernel to learn new configs which
    may be experimental, or otherwise not part of the core set currently
    available through the i915 perf interface.
    
    v2: Drop DRM_ERROR for userspace errors (Matthew)
        Add padding to userspace structure (Matthew)
        s/guid/uuid/ (Matthew)
    
    v3: Use u32 instead of int to iterate through registers (Matthew)
    
    v4: Lock access to dynamic config list (Lionel)
    
    v5: by Matthew:
        Fix uninitialized error values
        Fix incorrect unwiding when opening perf stream
        Use kmalloc_array() to store register
        Use uuid_is_valid() to valid config uuids
        Declare ioctls as write only
        Check padding members are set to 0
        by Lionel:
        Return ENOENT rather than EINVAL when trying to remove non
        existing config
    
    v6: by Chris:
        Use ref counts for OA configs
        Store UUID in drm_i915_perf_oa_config rather then using pointer
        Shuffle fields of drm_i915_perf_oa_config to avoid padding
    
    v7: by Chris
        Rename uapi pointers fields to end with '_ptr'
    
    v8: by Andrzej, Marek, Sebastian
        Update register whitelisting
        by Lionel
        Add more register names for documentation
        Allow configuration programming in non-paranoid mode
        Add support for value filter for a couple of registers already
        programmed in other part of the kernel
    
    v9: Documentation fix (Lionel)
        Allow writing WAIT_FOR_RC6_EXIT only on Gen8+ (Andrzej)
    
    v10: Perform read access_ok() on register pointers (Lionel)
    
    Signed-off-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Andrzej Datczuk <andrzej.datczuk@intel.com>
    Reviewed-by: Andrzej Datczuk <andrzej.datczuk@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20170803165812.2373-2-lionel.g.landwerlin@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 7ccbd6a2bbe0..ce3833fa1e06 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -260,6 +260,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_GEM_CONTEXT_GETPARAM	0x34
 #define DRM_I915_GEM_CONTEXT_SETPARAM	0x35
 #define DRM_I915_PERF_OPEN		0x36
+#define DRM_I915_PERF_ADD_CONFIG	0x37
+#define DRM_I915_PERF_REMOVE_CONFIG	0x38
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -315,6 +317,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_CONTEXT_GETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_GETPARAM, struct drm_i915_gem_context_param)
 #define DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, struct drm_i915_gem_context_param)
 #define DRM_IOCTL_I915_PERF_OPEN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_OPEN, struct drm_i915_perf_open_param)
+#define DRM_IOCTL_I915_PERF_ADD_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_ADD_CONFIG, struct drm_i915_perf_oa_config)
+#define DRM_IOCTL_I915_PERF_REMOVE_CONFIG	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_REMOVE_CONFIG, __u64)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1467,6 +1471,22 @@ enum drm_i915_perf_record_type {
 	DRM_I915_PERF_RECORD_MAX /* non-ABI */
 };
 
+/**
+ * Structure to upload perf dynamic configuration into the kernel.
+ */
+struct drm_i915_perf_oa_config {
+	/** String formatted like "%08x-%04x-%04x-%04x-%012x" */
+	char uuid[36];
+
+	__u32 n_mux_regs;
+	__u32 n_boolean_regs;
+	__u32 n_flex_regs;
+
+	__u64 __user mux_regs_ptr;
+	__u64 __user boolean_regs_ptr;
+	__u64 __user flex_regs_ptr;
+};
+
 #if defined(__cplusplus)
 }
 #endif

commit 1a71cf2fa646799d4397a49b223549d8617fece0
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jun 16 15:05:23 2017 +0100

    drm/i915: Allow execbuffer to use the first object as the batch
    
    Currently, the last object in the execlist is the always the batch.
    However, when building the batch buffer we often know the batch object
    first and if we can use the first slot in the execlist we can emit
    relocation instructions relative to it immediately and avoid a separate
    pass to adjust the relocations to point to the last execlist slot.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 15bc9f78ba4d..7ccbd6a2bbe0 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -418,7 +418,6 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_EXEC_CAPTURE	 45
 
-/* Query the mask of slices available for this system */
 #define I915_PARAM_SLICE_MASK		 46
 
 /* Assuming it's uniform for each slice, this queries the mask of subslices
@@ -426,6 +425,12 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_SUBSLICE_MASK	 47
 
+/*
+ * Query whether DRM_I915_GEM_EXECBUFFER2 supports supplying the batch buffer
+ * as the first execobject as opposed to the last. See I915_EXEC_BATCH_FIRST.
+ */
+#define I915_PARAM_HAS_EXEC_BATCH_FIRST	 48
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*
@@ -912,7 +917,17 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_FENCE_OUT		(1<<17)
 
-#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_OUT<<1))
+/*
+ * Traditionally the execbuf ioctl has only considered the final element in
+ * the execobject[] to be the executable batch. Often though, the client
+ * will known the batch object prior to construction and being able to place
+ * it into the execobject[] array first can simplify the relocation tracking.
+ * Setting I915_EXEC_BATCH_FIRST tells execbuf to use element 0 of the
+ * execobject[] as the * batch instead (the default is to use the last
+ * element).
+ */
+#define I915_EXEC_BATCH_FIRST		(1<<18)
+#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_BATCH_FIRST<<1))
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit 19f81df2859eb10e92d68991cefa39f826dea013
Author: Robert Bragg <robert@sixbynine.org>
Date:   Tue Jun 13 12:23:03 2017 +0100

    drm/i915/perf: Add OA unit support for Gen 8+
    
    Enables access to OA unit metrics for BDW, CHV, SKL and BXT which all
    share (more-or-less) the same OA unit design.
    
    Of particular note in comparison to Haswell: some OA unit HW config
    state has become per-context state and as a consequence it is somewhat
    more complicated to manage synchronous state changes from the cpu while
    there's no guarantee of what context (if any) is currently actively
    running on the gpu.
    
    The periodic sampling frequency which can be particularly useful for
    system-wide analysis (as opposed to command stream synchronised
    MI_REPORT_PERF_COUNT commands) is perhaps the most surprising state to
    have become per-context save and restored (while the OABUFFER
    destination is still a shared, system-wide resource).
    
    This support for gen8+ takes care to consider a number of timing
    challenges involved in synchronously updating per-context state
    primarily by programming all config state from the cpu and updating all
    current and saved contexts synchronously while the OA unit is still
    disabled.
    
    The driver intentionally avoids depending on command streamer
    programming to update OA state considering the lack of synchronization
    between the automatic loading of OACTXCONTROL state (that includes the
    periodic sampling state and enable state) on context restore and the
    parsing of any general purpose BB the driver can control. I.e. this
    implementation is careful to avoid the possibility of a context restore
    temporarily enabling any out-of-date periodic sampling state. In
    addition to the risk of transiently-out-of-date state being loaded
    automatically; there are also internal HW latencies involved in the
    loading of MUX configurations which would be difficult to account for
    from the command streamer (and we only want to enable the unit when once
    the MUX configuration is complete).
    
    Since the Gen8+ OA unit design no longer supports clock gating the unit
    off for a single given context (which effectively stopped any progress
    of counters while any other context was running) and instead supports
    tagging OA reports with a context ID for filtering on the CPU, it means
    we can no longer hide the system-wide progress of counters from a
    non-privileged application only interested in metrics for its own
    context. Although we could theoretically try and subtract the progress
    of other contexts before forwarding reports via read() we aren't in a
    position to filter reports captured via MI_REPORT_PERF_COUNT commands.
    As a result, for Gen8+, we always require the
    dev.i915.perf_stream_paranoid to be unset for any access to OA metrics
    if not root.
    
    v5: Drain submitted requests when enabling metric set to ensure no
        lite-restore erases the context image we just updated (Lionel)
    
    v6: In addition to drain, switch to kernel context & update all
        context in place (Chris)
    
    v7: Add missing mutex_unlock() if switching to kernel context fails
        (Matthew)
    
    v8: Simplify OA period/flex-eu-counters programming by using the
        batchbuffer instead of modifying ctx-image (Lionel)
    
    v9: Back to updating the context image (due to erroneous testing,
        batchbuffer programming the OA unit doesn't actually work)
        (Lionel)
        Pin context before updating context image (Chris)
        Drop MMIO programming now that we switch to a kernel context with
        right values in initial context image (Chris)
    
    v10: Just pin_map the contexts we want to modify or let the
         configuration happen on first use (Chris)
    
    v11: Update kernel context OA config through the batchbuffer rather
         than on the fly ctx-image update (Lionel)
    
    v12: Rework OA context registers update again by swithing away from
         user contexts and reconfiguring the kernel context through the
         batchbuffer and updating all the other contexts' context image.
         Also take care to lock slice/subslice configuration when OA is
         on. (Lionel)
    
    v13: Request rpcs updates on all engine when updating the OA config
         (Lionel)
    
    v14: Drop any kind of rpcs management now that we monitor sseu
         configuration changes in a later patch (Lionel)
         Remove usleep after programming the NOA configs on Gen8+, this
         doesn't seem to be needed (Lionel)
    
    v15: Respect coding style for block comments (Chris)
    
    v16: Add missing i915_add_request() in case we fail to emit OA
         configuration (Matthew)
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com> \o/
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 464547d08173..15bc9f78ba4d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1316,13 +1316,18 @@ struct drm_i915_gem_context_param {
 };
 
 enum drm_i915_oa_format {
-	I915_OA_FORMAT_A13 = 1,
-	I915_OA_FORMAT_A29,
-	I915_OA_FORMAT_A13_B8_C8,
-	I915_OA_FORMAT_B4_C8,
-	I915_OA_FORMAT_A45_B8_C8,
-	I915_OA_FORMAT_B4_C8_A16,
-	I915_OA_FORMAT_C4_B8,
+	I915_OA_FORMAT_A13 = 1,	    /* HSW only */
+	I915_OA_FORMAT_A29,	    /* HSW only */
+	I915_OA_FORMAT_A13_B8_C8,   /* HSW only */
+	I915_OA_FORMAT_B4_C8,	    /* HSW only */
+	I915_OA_FORMAT_A45_B8_C8,   /* HSW only */
+	I915_OA_FORMAT_B4_C8_A16,   /* HSW only */
+	I915_OA_FORMAT_C4_B8,	    /* HSW+ */
+
+	/* Gen8+ */
+	I915_OA_FORMAT_A12,
+	I915_OA_FORMAT_A12_B8_C8,
+	I915_OA_FORMAT_A32u40_A4u32_B8_C8,
 
 	I915_OA_FORMAT_MAX	    /* non-ABI */
 };

commit f532023381df49ac00cb2d1e70df607cf534720d
Author: Robert Bragg <robert@sixbynine.org>
Date:   Tue Jun 13 12:23:00 2017 +0100

    drm/i915: expose _SUBSLICE_MASK GETPARM
    
    Assuming a uniform mask across all slices, this enables userspace to
    determine the specific sub slices can be enabled. This information is
    required, for example, to be able to analyse some OA counter reports
    where the counter configuration depends on the HW sub slice
    configuration.
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 25695c3d9a76..464547d08173 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -421,6 +421,11 @@ typedef struct drm_i915_irq_wait {
 /* Query the mask of slices available for this system */
 #define I915_PARAM_SLICE_MASK		 46
 
+/* Assuming it's uniform for each slice, this queries the mask of subslices
+ * per-slice for this system.
+ */
+#define I915_PARAM_SUBSLICE_MASK	 47
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*

commit 7fed555c02f754af44f8963890b5ef8e30e97391
Author: Robert Bragg <robert@sixbynine.org>
Date:   Tue Jun 13 12:22:59 2017 +0100

    drm/i915: expose _SLICE_MASK GETPARM
    
    Enables userspace to determine the maximum number of slices that can
    be enabled on the device and also know what specific slices can be
    enabled. This information is required, for example, to be able to
    analyse some OA counter reports where the counter configuration
    depends on the HW slice configuration.
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index f24a80d2d42e..25695c3d9a76 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -418,6 +418,9 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_EXEC_CAPTURE	 45
 
+/* Query the mask of slices available for this system */
+#define I915_PARAM_SLICE_MASK		 46
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*

commit b0fd47adc6233e4c198a97e1ddb05accd31eeacb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Apr 15 10:39:02 2017 +0100

    drm/i915: Copy user requested buffers into the error state
    
    Introduce a new execobject.flag (EXEC_OBJECT_CAPTURE) that userspace may
    use to indicate that it wants the contents of this buffer preserved in
    the error state (/sys/class/drm/cardN/error) following a GPU hang
    involving this batch.
    
    Use this at your discretion, the contents of the error state. although
    compressed, are allocated with GFP_ATOMIC (i.e. limited) and kept for all
    eternity (until the error state is destroyed).
    
    Based on an earlier patch by Ben Widawsky <ben@bwidawsk.net>
    Testcase: igt/gem_exec_capture
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ben Widawsky <ben@bwidawsk.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Acked-by: Ben Widawsky <ben@bwidawsk.net>
    Acked-by: Matt Turner <mattst88@gmail.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170415093902.22581-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 9ee06ec8a2d6..f24a80d2d42e 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -412,6 +412,12 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_EXEC_FENCE	 44
 
+/* Query whether DRM_I915_GEM_EXECBUFFER2 supports the ability to capture
+ * user specified bufffers for post-mortem debugging of GPU hangs. See
+ * EXEC_OBJECT_CAPTURE.
+ */
+#define I915_PARAM_HAS_EXEC_CAPTURE	 45
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*
@@ -775,8 +781,15 @@ struct drm_i915_gem_exec_object2 {
  * I915_PARAM_HAS_EXEC_FENCE to order execbufs and execute them asynchronously.
  */
 #define EXEC_OBJECT_ASYNC		(1<<6)
+/* Request that the contents of this execobject be copied into the error
+ * state upon a GPU hang involving this batch for post-mortem debugging.
+ * These buffers are recorded in no particular order as "user" in
+ * /sys/class/drm/cardN/error. Query I915_PARAM_HAS_EXEC_CAPTURE to see
+ * if the kernel supports this flag.
+ */
+#define EXEC_OBJECT_CAPTURE		(1<<7)
 /* All remaining bits are MBZ and RESERVED FOR FUTURE USE */
-#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_ASYNC<<1)
+#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_CAPTURE<<1)
 	__u64 flags;
 
 	union {

commit e22d8e3c69a9f432b40baaaf3f894a128fdc2222
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Apr 12 12:01:11 2017 +0100

    drm/i915: Treat WC a separate cache domain
    
    When discussing a new WC mmap, we based the interface upon the
    assumption that GTT was fully coherent. How naive! Commits 3b5724d702ef
    ("drm/i915: Wait for writes through the GTT to land before reading
    back") and ed4596ea992d ("drm/i915/guc: WA to address the Ringbuffer
    coherency issue") demonstrate that writes through the GTT are indeed
    delayed and may be overtaken by direct WC access. To be safe, if
    userspace is mixing WC mmaps with other potential GTT access (pwrite,
    GTT mmaps) it should use set_domain(WC).
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=96563
    Testcase: igt/gem_pwrite/small-gtt*
    Testcase: igt/drv_selftest/coherency
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170412110111.26626-2-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 3554495bef13..9ee06ec8a2d6 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -666,6 +666,8 @@ struct drm_i915_gem_relocation_entry {
 #define I915_GEM_DOMAIN_VERTEX		0x00000020
 /** GTT domain - aperture and scanout */
 #define I915_GEM_DOMAIN_GTT		0x00000040
+/** WC domain - uncached access */
+#define I915_GEM_DOMAIN_WC		0x00000080
 /** @} */
 
 struct drm_i915_gem_exec_object {

commit fec0445caa273209d2809760ac7c63e743d6f512
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 27 09:40:08 2017 +0000

    drm/i915: Support explicit fencing for execbuf
    
    Now that the user can opt-out of implicit fencing, we need to give them
    back control over the fencing. We employ sync_file to wrap our
    drm_i915_gem_request and provide an fd that userspace can merge with
    other sync_file fds and pass back to the kernel to wait upon before
    future execution.
    
    Testcase: igt/gem_exec_fence
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Chad Versace <chadversary@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127094008.27489-2-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6620b6ad76ed..3554495bef13 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -246,6 +246,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_OVERLAY_PUT_IMAGE	0x27
 #define DRM_I915_OVERLAY_ATTRS	0x28
 #define DRM_I915_GEM_EXECBUFFER2	0x29
+#define DRM_I915_GEM_EXECBUFFER2_WR	DRM_I915_GEM_EXECBUFFER2
 #define DRM_I915_GET_SPRITE_COLORKEY	0x2a
 #define DRM_I915_SET_SPRITE_COLORKEY	0x2b
 #define DRM_I915_GEM_WAIT	0x2c
@@ -280,6 +281,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)
 #define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)
 #define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)
+#define DRM_IOCTL_I915_GEM_EXECBUFFER2_WR	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2_WR, struct drm_i915_gem_execbuffer2)
 #define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)
 #define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)
 #define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)
@@ -403,6 +405,13 @@ typedef struct drm_i915_irq_wait {
  */
 #define I915_PARAM_HAS_EXEC_ASYNC	 43
 
+/* Query whether DRM_I915_GEM_EXECBUFFER2 supports explicit fence support -
+ * both being able to pass in a sync_file fd to wait upon before executing,
+ * and being able to return a new sync_file fd that is signaled when the
+ * current request is complete. See I915_EXEC_FENCE_IN and I915_EXEC_FENCE_OUT.
+ */
+#define I915_PARAM_HAS_EXEC_FENCE	 44
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*
@@ -855,7 +864,32 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_RESOURCE_STREAMER     (1<<15)
 
-#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_RESOURCE_STREAMER<<1)
+/* Setting I915_EXEC_FENCE_IN implies that lower_32_bits(rsvd2) represent
+ * a sync_file fd to wait upon (in a nonblocking manner) prior to executing
+ * the batch.
+ *
+ * Returns -EINVAL if the sync_file fd cannot be found.
+ */
+#define I915_EXEC_FENCE_IN		(1<<16)
+
+/* Setting I915_EXEC_FENCE_OUT causes the ioctl to return a sync_file fd
+ * in the upper_32_bits(rsvd2) upon success. Ownership of the fd is given
+ * to the caller, and it should be close() after use. (The fd is a regular
+ * file descriptor and will be cleaned up on process termination. It holds
+ * a reference to the request, but nothing else.)
+ *
+ * The sync_file fd can be combined with other sync_file and passed either
+ * to execbuf using I915_EXEC_FENCE_IN, to atomic KMS ioctls (so that a flip
+ * will only occur after this request completes), or to other devices.
+ *
+ * Using I915_EXEC_FENCE_OUT requires use of
+ * DRM_IOCTL_I915_GEM_EXECBUFFER2_WR ioctl so that the result is written
+ * back to userspace. Failure to do so will cause the out-fence to always
+ * be reported as zero, and the real fence fd to be leaked.
+ */
+#define I915_EXEC_FENCE_OUT		(1<<17)
+
+#define __I915_EXEC_UNKNOWN_FLAGS (-(I915_EXEC_FENCE_OUT<<1))
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit 77ae9957897df86e627089688265e0db029dd0df
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 27 09:40:07 2017 +0000

    drm/i915: Enable userspace to opt-out of implicit fencing
    
    Userspace is faced with a dilemma. The kernel requires implicit fencing
    to manage resource usage (we always must wait for the GPU to finish
    before releasing its PTE) and for third parties. However, userspace may
    wish to avoid this serialisation if it is either using explicit fencing
    between parties and wants more fine-grained access to buffers (e.g. it
    may partition the buffer between uses and track fences on ranges rather
    than the implicit fences tracking the whole object). It follows that
    userspace needs a mechanism to avoid the kernel's serialisation on its
    implicit fences before execbuf execution.
    
    The next question is whether this is an object, execbuf or context flag.
    Hybrid users (such as using explicit EGL_ANDROID_native_sync fencing on
    shared winsys buffers, but implicit fencing on internal surfaces)
    require a per-object level flag. Given that this flag need to be only
    set once for the lifetime of the object, this reduces the convenience of
    having an execbuf or context level flag (and avoids having multiple
    pieces of uABI controlling the same feature).
    
    Incorrect use of this flag will result in rendering corruption and GPU
    hangs - but will not result in use-after-free or similar resource
    tracking issues.
    
    Serious caveat: write ordering is not strictly correct after setting
    this flag on a render target on multiple engines. This affects all
    subsequent GEM operations (execbuf, set-domain, pread) and shared
    dma-buf operations. A fix is possible - but costly (both in terms of
    further ABI changes and runtime overhead).
    
    Testcase: igt/gem_exec_async
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Acked-by: Chad Versace <chadversary@chromium.org>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170127094008.27489-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 57093b455db6..6620b6ad76ed 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -397,6 +397,12 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_SCHEDULER	 41
 #define I915_PARAM_HUC_STATUS		 42
 
+/* Query whether DRM_I915_GEM_EXECBUFFER2 supports the ability to opt-out of
+ * synchronisation with implicit fencing on individual objects.
+ * See EXEC_OBJECT_ASYNC.
+ */
+#define I915_PARAM_HAS_EXEC_ASYNC	 43
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*
@@ -737,8 +743,29 @@ struct drm_i915_gem_exec_object2 {
 #define EXEC_OBJECT_SUPPORTS_48B_ADDRESS (1<<3)
 #define EXEC_OBJECT_PINNED		 (1<<4)
 #define EXEC_OBJECT_PAD_TO_SIZE		 (1<<5)
+/* The kernel implicitly tracks GPU activity on all GEM objects, and
+ * synchronises operations with outstanding rendering. This includes
+ * rendering on other devices if exported via dma-buf. However, sometimes
+ * this tracking is too coarse and the user knows better. For example,
+ * if the object is split into non-overlapping ranges shared between different
+ * clients or engines (i.e. suballocating objects), the implicit tracking
+ * by kernel assumes that each operation affects the whole object rather
+ * than an individual range, causing needless synchronisation between clients.
+ * The kernel will also forgo any CPU cache flushes prior to rendering from
+ * the object as the client is expected to be also handling such domain
+ * tracking.
+ *
+ * The kernel maintains the implicit tracking in order to manage resources
+ * used by the GPU - this flag only disables the synchronisation prior to
+ * rendering with this object in this execbuf.
+ *
+ * Opting out of implicit synhronisation requires the user to do its own
+ * explicit tracking to avoid rendering corruption. See, for example,
+ * I915_PARAM_HAS_EXEC_FENCE to order execbufs and execute them asynchronously.
+ */
+#define EXEC_OBJECT_ASYNC		(1<<6)
 /* All remaining bits are MBZ and RESERVED FOR FUTURE USE */
-#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_PAD_TO_SIZE<<1)
+#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_ASYNC<<1)
 	__u64 flags;
 
 	union {

commit 5464cd657632502c61c64775dffef1cc7ebd4839
Author: Anusha Srivatsa <anusha.srivatsa@intel.com>
Date:   Wed Jan 18 08:05:58 2017 -0800

    drm/i915/get_params: Add HuC status to getparams
    
    This patch will allow for getparams to return the status of the HuC.
    As the HuC has to be validated by the GuC this patch uses the validated
    status to show when the HuC is loaded and ready for use. You cannot use
    the loaded status as with the GuC as the HuC is verified after it is
    loaded and is not usable until it is verified.
    
    v2: removed the forewakes as the registers are already force-woken.
         (T.Ursulin)
    v3: rebased on top of drm-tip. Removed any reference to intel_huc.h
    v4: rebased. Rename I915_PARAM_HAS_HUC to I915_PARAM_HUC_STATUS.
    Remove intel_is_huc_valid() since it is used only in one place.
    Put the case of I915_PARAM_HAS_HUC() in the right place.
    v5: rebased. Add a comment to specify that I915_READ(reg)
    does not read garbage value. The register HUC_STATUS2 is force
    woken and no rpm is needed.
    
    Signed-off-by: Anusha Srivatsa <anusha.srivatsa@intel.com>
    Signed-off-by: Peter Antoine <peter.antoine@intel.com>
    Reviewed-by: Arkadiusz Hiler <arkadiusz.hiler@intel.com>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1484755558-1234-6-git-send-email-anusha.srivatsa@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index da32c2f6c3f9..57093b455db6 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -395,6 +395,7 @@ typedef struct drm_i915_irq_wait {
  * priorities and the driver will attempt to execute batches in priority order.
  */
 #define I915_PARAM_HAS_SCHEDULER	 41
+#define I915_PARAM_HUC_STATUS		 42
 
 typedef struct drm_i915_getparam {
 	__s32 param;

commit cd8bddc4ab535009a3cdf700a14f10d75eda899c
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Nov 30 16:46:49 2016 +0000

    drm/i915/perf: Treat u64 in uabi as a normal integer
    
    Forgo marking up the u64 integer representing a user pointer as this
    just annoys sparse. The conversion from u64 to a user pointer is managed
    by u64_to_user_ptr().
    
    Fixes: eec688e1420d ("drm/i915: Add i915 perf infrastructure")
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Robert Bragg <robert@sixbynine.org>
    Cc: Matthew Auld <matthew.auld@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161130164649.26809-1-chris@chris-wilson.co.uk
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index bdfc68876990..da32c2f6c3f9 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1292,7 +1292,7 @@ struct drm_i915_perf_open_param {
 	 * Pointer to array of u64 (id, value) pairs configuring the stream
 	 * to open.
 	 */
-	__u64 __user properties_ptr;
+	__u64 properties_ptr;
 };
 
 /**

commit d79651522e89c4ffa8992b48dfe449f0c583f809
Author: Robert Bragg <robert@sixbynine.org>
Date:   Mon Nov 7 19:49:52 2016 +0000

    drm/i915: Enable i915 perf stream for Haswell OA unit
    
    Gen graphics hardware can be set up to periodically write snapshots of
    performance counters into a circular buffer via its Observation
    Architecture and this patch exposes that capability to userspace via the
    i915 perf interface.
    
    v2:
       Make sure to initialize ->specific_ctx_id when opening, without
       relying on _pin_notify hook, in case ctx already pinned.
    v3:
       Revert back to pinning ctx upfront when opening stream, removing
       need to hook in to pinning and to update OACONTROL on the fly.
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Signed-off-by: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Sourab Gupta <sourab.gupta@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161107194957.3385-7-robert@sixbynine.org

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 192dc1f8256b..bdfc68876990 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1230,6 +1230,18 @@ struct drm_i915_gem_context_param {
 	__u64 value;
 };
 
+enum drm_i915_oa_format {
+	I915_OA_FORMAT_A13 = 1,
+	I915_OA_FORMAT_A29,
+	I915_OA_FORMAT_A13_B8_C8,
+	I915_OA_FORMAT_B4_C8,
+	I915_OA_FORMAT_A45_B8_C8,
+	I915_OA_FORMAT_B4_C8_A16,
+	I915_OA_FORMAT_C4_B8,
+
+	I915_OA_FORMAT_MAX	    /* non-ABI */
+};
+
 enum drm_i915_perf_property_id {
 	/**
 	 * Open the stream for a specific context handle (as used with
@@ -1238,6 +1250,32 @@ enum drm_i915_perf_property_id {
 	 */
 	DRM_I915_PERF_PROP_CTX_HANDLE = 1,
 
+	/**
+	 * A value of 1 requests the inclusion of raw OA unit reports as
+	 * part of stream samples.
+	 */
+	DRM_I915_PERF_PROP_SAMPLE_OA,
+
+	/**
+	 * The value specifies which set of OA unit metrics should be
+	 * be configured, defining the contents of any OA unit reports.
+	 */
+	DRM_I915_PERF_PROP_OA_METRICS_SET,
+
+	/**
+	 * The value specifies the size and layout of OA unit reports.
+	 */
+	DRM_I915_PERF_PROP_OA_FORMAT,
+
+	/**
+	 * Specifying this property implicitly requests periodic OA unit
+	 * sampling and (at least on Haswell) the sampling frequency is derived
+	 * from this exponent as follows:
+	 *
+	 *   80ns * 2^(period_exponent + 1)
+	 */
+	DRM_I915_PERF_PROP_OA_EXPONENT,
+
 	DRM_I915_PERF_PROP_MAX /* non-ABI */
 };
 
@@ -1257,7 +1295,23 @@ struct drm_i915_perf_open_param {
 	__u64 __user properties_ptr;
 };
 
+/**
+ * Enable data capture for a stream that was either opened in a disabled state
+ * via I915_PERF_FLAG_DISABLED or was later disabled via
+ * I915_PERF_IOCTL_DISABLE.
+ *
+ * It is intended to be cheaper to disable and enable a stream than it may be
+ * to close and re-open a stream with the same configuration.
+ *
+ * It's undefined whether any pending data for the stream will be lost.
+ */
 #define I915_PERF_IOCTL_ENABLE	_IO('i', 0x0)
+
+/**
+ * Disable data capture for a stream.
+ *
+ * It is an error to try and read a stream that is disabled.
+ */
 #define I915_PERF_IOCTL_DISABLE	_IO('i', 0x1)
 
 /**
@@ -1281,17 +1335,30 @@ enum drm_i915_perf_record_type {
 	 * every sample.
 	 *
 	 * The order of these sample properties given by userspace has no
-	 * affect on the ordering of data within a sample. The order will be
+	 * affect on the ordering of data within a sample. The order is
 	 * documented here.
 	 *
 	 * struct {
 	 *     struct drm_i915_perf_record_header header;
 	 *
-	 *     TODO: itemize extensible sample data here
+	 *     { u32 oa_report[]; } && DRM_I915_PERF_PROP_SAMPLE_OA
 	 * };
 	 */
 	DRM_I915_PERF_RECORD_SAMPLE = 1,
 
+	/*
+	 * Indicates that one or more OA reports were not written by the
+	 * hardware. This can happen for example if an MI_REPORT_PERF_COUNT
+	 * command collides with periodic sampling - which would be more likely
+	 * at higher sampling frequencies.
+	 */
+	DRM_I915_PERF_RECORD_OA_REPORT_LOST = 2,
+
+	/**
+	 * An error occurred that resulted in all pending OA reports being lost.
+	 */
+	DRM_I915_PERF_RECORD_OA_BUFFER_LOST = 3,
+
 	DRM_I915_PERF_RECORD_MAX /* non-ABI */
 };
 

commit eec688e1420da584afb36ffa5f0cad75f53cf286
Author: Robert Bragg <robert@sixbynine.org>
Date:   Mon Nov 7 19:49:47 2016 +0000

    drm/i915: Add i915 perf infrastructure
    
    Adds base i915 perf infrastructure for Gen performance metrics.
    
    This adds a DRM_IOCTL_I915_PERF_OPEN ioctl that takes an array of uint64
    properties to configure a stream of metrics and returns a new fd usable
    with standard VFS system calls including read() to read typed and sized
    records; ioctl() to enable or disable capture and poll() to wait for
    data.
    
    A stream is opened something like:
    
      uint64_t properties[] = {
          /* Single context sampling */
          DRM_I915_PERF_PROP_CTX_HANDLE,        ctx_handle,
    
          /* Include OA reports in samples */
          DRM_I915_PERF_PROP_SAMPLE_OA,         true,
    
          /* OA unit configuration */
          DRM_I915_PERF_PROP_OA_METRICS_SET,    metrics_set_id,
          DRM_I915_PERF_PROP_OA_FORMAT,         report_format,
          DRM_I915_PERF_PROP_OA_EXPONENT,       period_exponent,
       };
       struct drm_i915_perf_open_param parm = {
          .flags = I915_PERF_FLAG_FD_CLOEXEC |
                   I915_PERF_FLAG_FD_NONBLOCK |
                   I915_PERF_FLAG_DISABLED,
          .properties_ptr = (uint64_t)properties,
          .num_properties = sizeof(properties) / 16,
       };
       int fd = drmIoctl(drm_fd, DRM_IOCTL_I915_PERF_OPEN, &param);
    
    Records read all start with a common { type, size } header with
    DRM_I915_PERF_RECORD_SAMPLE being of most interest. Sample records
    contain an extensible number of fields and it's the
    DRM_I915_PERF_PROP_SAMPLE_xyz properties given when opening that
    determine what's included in every sample.
    
    No specific streams are supported yet so any attempt to open a stream
    will return an error.
    
    v2:
        use i915_gem_context_get() - Chris Wilson
    v3:
        update read() interface to avoid passing state struct - Chris Wilson
        fix some rebase fallout, with i915-perf init/deinit
    v4:
        s/DRM_IORW/DRM_IOW/ - Emil Velikov
    
    Signed-off-by: Robert Bragg <robert@sixbynine.org>
    Reviewed-by: Matthew Auld <matthew.auld@intel.com>
    Reviewed-by: Sourab Gupta <sourab.gupta@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161107194957.3385-2-robert@sixbynine.org

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 12003f0d8c7f..192dc1f8256b 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -258,6 +258,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_GEM_USERPTR		0x33
 #define DRM_I915_GEM_CONTEXT_GETPARAM	0x34
 #define DRM_I915_GEM_CONTEXT_SETPARAM	0x35
+#define DRM_I915_PERF_OPEN		0x36
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -311,6 +312,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_USERPTR			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR, struct drm_i915_gem_userptr)
 #define DRM_IOCTL_I915_GEM_CONTEXT_GETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_GETPARAM, struct drm_i915_gem_context_param)
 #define DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, struct drm_i915_gem_context_param)
+#define DRM_IOCTL_I915_PERF_OPEN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_PERF_OPEN, struct drm_i915_perf_open_param)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1228,6 +1230,71 @@ struct drm_i915_gem_context_param {
 	__u64 value;
 };
 
+enum drm_i915_perf_property_id {
+	/**
+	 * Open the stream for a specific context handle (as used with
+	 * execbuffer2). A stream opened for a specific context this way
+	 * won't typically require root privileges.
+	 */
+	DRM_I915_PERF_PROP_CTX_HANDLE = 1,
+
+	DRM_I915_PERF_PROP_MAX /* non-ABI */
+};
+
+struct drm_i915_perf_open_param {
+	__u32 flags;
+#define I915_PERF_FLAG_FD_CLOEXEC	(1<<0)
+#define I915_PERF_FLAG_FD_NONBLOCK	(1<<1)
+#define I915_PERF_FLAG_DISABLED		(1<<2)
+
+	/** The number of u64 (id, value) pairs */
+	__u32 num_properties;
+
+	/**
+	 * Pointer to array of u64 (id, value) pairs configuring the stream
+	 * to open.
+	 */
+	__u64 __user properties_ptr;
+};
+
+#define I915_PERF_IOCTL_ENABLE	_IO('i', 0x0)
+#define I915_PERF_IOCTL_DISABLE	_IO('i', 0x1)
+
+/**
+ * Common to all i915 perf records
+ */
+struct drm_i915_perf_record_header {
+	__u32 type;
+	__u16 pad;
+	__u16 size;
+};
+
+enum drm_i915_perf_record_type {
+
+	/**
+	 * Samples are the work horse record type whose contents are extensible
+	 * and defined when opening an i915 perf stream based on the given
+	 * properties.
+	 *
+	 * Boolean properties following the naming convention
+	 * DRM_I915_PERF_SAMPLE_xyz_PROP request the inclusion of 'xyz' data in
+	 * every sample.
+	 *
+	 * The order of these sample properties given by userspace has no
+	 * affect on the ordering of data within a sample. The order will be
+	 * documented here.
+	 *
+	 * struct {
+	 *     struct drm_i915_perf_record_header header;
+	 *
+	 *     TODO: itemize extensible sample data here
+	 * };
+	 */
+	DRM_I915_PERF_RECORD_SAMPLE = 1,
+
+	DRM_I915_PERF_RECORD_MAX /* non-ABI */
+};
+
 #if defined(__cplusplus)
 }
 #endif

commit 841021713a4d700059774e0d3c77ec6c538daae2
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Wed Nov 16 17:20:32 2016 +0200

    drm/i915: Add bannable context parameter
    
    Now when driver has per context scoring of 'hanging badness'
    and also subsequent hangs during short windows are allowed,
    if there is progress made in between, it does not make sense
    to expose a ban timing window as a context parameter anymore.
    
    Let the scoring be the sole indicator for ban policy and substitute
    ban period context parameter as a boolean to get/set context
    bannable property.
    
    v2: allow non root to opt into being banned (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 1c12a350eca3..12003f0d8c7f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1224,6 +1224,7 @@ struct drm_i915_gem_context_param {
 #define I915_CONTEXT_PARAM_NO_ZEROMAP	0x2
 #define I915_CONTEXT_PARAM_GTT_SIZE	0x3
 #define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE	0x4
+#define I915_CONTEXT_PARAM_BANNABLE	0x5
 	__u64 value;
 };
 

commit 0de9136dbbc9f6882bb375270eaddf1b999081bf
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Nov 14 20:41:01 2016 +0000

    drm/i915/scheduler: Signal the arrival of a new request
    
    The start of the scheduler, add a hook into request submission for the
    scheduler to see the arrival of new requests and prepare its runqueues.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/20161114204105.29171-6-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 03725fe89859..1c12a350eca3 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -389,6 +389,11 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_MIN_EU_IN_POOL	 39
 #define I915_PARAM_MMAP_GTT_VERSION	 40
 
+/* Query whether DRM_I915_GEM_EXECBUFFER2 supports user defined execution
+ * priorities and the driver will attempt to execute batches in priority order.
+ */
+#define I915_PARAM_HAS_SCHEDULER	 41
+
 typedef struct drm_i915_getparam {
 	__s32 param;
 	/*

commit 4cc6907501ed2393a70ad92a30e00dc54c536e50
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 25 19:05:19 2016 +0100

    drm/i915: Add I915_PARAM_MMAP_GTT_VERSION to advertise unlimited mmaps
    
    Now that we have working partial VMA and faulting support for all
    objects, including fence support, advertise to userspace that it can
    take advantage of unlimited GGTT mmaps.
    
    v2: Make room in the kerneldoc for a more detailed explanation of the
    limitations of the GTT mmap interface.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20160825180519.11341-1-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 5501fe83ed92..03725fe89859 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -387,6 +387,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_EXEC_SOFTPIN	 37
 #define I915_PARAM_HAS_POOLED_EU	 38
 #define I915_PARAM_MIN_EU_IN_POOL	 39
+#define I915_PARAM_MMAP_GTT_VERSION	 40
 
 typedef struct drm_i915_getparam {
 	__s32 param;

commit 1255501d8681775d564de45742c6e82b7782b7f5
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Aug 16 09:50:40 2016 +0100

    drm/i915: Embrace the race in busy-ioctl
    
    Daniel Vetter proposed a new challenge to the serialisation inside the
    busy-ioctl that exposed a flaw that could result in us reporting the
    wrong engine as being busy. If the request is reallocated as we test
    its busyness and then reassigned to this object by another thread, we
    would not notice that the test itself was incorrect.
    
    We are faced with a choice of using __i915_gem_active_get_request_rcu()
    to first acquire a reference to the request preventing the race, or to
    acknowledge the race and accept the limitations upon the accuracy of the
    busy flags. Note that we guarantee that we never falsely report the
    object as idle (providing userspace itself doesn't race), and so the
    most important use of the busy-ioctl and its guarantees are fulfilled.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@intel.com>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1471337440-16777-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 452629de7a57..5501fe83ed92 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -855,7 +855,16 @@ struct drm_i915_gem_busy {
 	 * having flushed any pending activity), and a non-zero return that
 	 * the object is still in-flight on the GPU. (The GPU has not yet
 	 * signaled completion for all pending requests that reference the
-	 * object.)
+	 * object.) An object is guaranteed to become idle eventually (so
+	 * long as no new GPU commands are executed upon it). Due to the
+	 * asynchronous nature of the hardware, an object reported
+	 * as busy may become idle before the ioctl is completed.
+	 *
+	 * Furthermore, if the object is busy, which engine is busy is only
+	 * provided as a guide. There are race conditions which prevent the
+	 * report of which engines are busy from being always accurate.
+	 * However, the converse is not true. If the object is idle, the
+	 * result of the ioctl, that all engines are idle, is accurate.
 	 *
 	 * The returned dword is split into two fields to indicate both
 	 * the engines on which the object is being read, and the
@@ -878,6 +887,11 @@ struct drm_i915_gem_busy {
 	 * execution engines, e.g. multiple media engines, which are
 	 * mapped to the same identifier in the EXECBUFFER2 ioctl and
 	 * so are not separately reported for busyness.
+	 *
+	 * Caveat emptor:
+	 * Only the boolean result of this query is reliable; that is whether
+	 * the object is idle or busy. The report of which engines are busy
+	 * should be only used as a heuristic.
 	 */
 	__u32 busy;
 };

commit deeb1519b65a92ca06c8e8554a92df0fdb4d5dea
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Aug 5 10:14:22 2016 +0100

    drm/i915: Document and reject invalid tiling modes
    
    Through the GTT interface to the fence registers, we can only handle
    linear, X and Y tiling. The more esoteric tiling patterns are ignored.
    Document that the tiling ABI only supports upto Y tiling, and reject any
    attempts to set a tiling mode other than NONE, X or Y.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Reviewed-by: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470388464-28458-17-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 0f292733cffc..452629de7a57 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -926,6 +926,7 @@ struct drm_i915_gem_caching {
 #define I915_TILING_NONE	0
 #define I915_TILING_X		1
 #define I915_TILING_Y		2
+#define I915_TILING_LAST	I915_TILING_Y
 
 #define I915_BIT_6_SWIZZLE_NONE		0
 #define I915_BIT_6_SWIZZLE_9		1

commit 91b2db6f65fbbb1a6688bcc2e52596b723ea2472
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 4 16:32:23 2016 +0100

    drm/i915: Pad GTT views of exec objects up to user specified size
    
    Our GPUs impose certain requirements upon buffers that depend upon how
    exactly they are used. Typically this is expressed as that they require
    a larger surface than would be naively computed by pitch * height.
    Normally such requirements are hidden away in the userspace driver, but
    when we accept pointers from strangers and later impose extra conditions
    on them, the original client allocator has no idea about the
    monstrosities in the GPU and we require the userspace driver to inform
    the kernel how many padding pages are required beyond the client
    allocation.
    
    v2: Long time, no see
    v3: Try an anonymous union for uapi struct compatibility
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1470324762-2545-7-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 33ce5ff9556a..0f292733cffc 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -727,11 +727,15 @@ struct drm_i915_gem_exec_object2 {
 #define EXEC_OBJECT_WRITE		 (1<<2)
 #define EXEC_OBJECT_SUPPORTS_48B_ADDRESS (1<<3)
 #define EXEC_OBJECT_PINNED		 (1<<4)
+#define EXEC_OBJECT_PAD_TO_SIZE		 (1<<5)
 /* All remaining bits are MBZ and RESERVED FOR FUTURE USE */
-#define __EXEC_OBJECT_UNKNOWN_FLAGS	(-(EXEC_OBJECT_PINNED<<1))
+#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_PAD_TO_SIZE<<1)
 	__u64 flags;
 
-	__u64 rsvd1;
+	union {
+		__u64 rsvd1;
+		__u64 pad_to_size;
+	};
 	__u64 rsvd2;
 };
 

commit 3373ce2eccd56651579b1864fecf98b46fd1cb67
Author: Imre Deak <imre.deak@intel.com>
Date:   Fri Jul 1 17:32:08 2016 +0300

    drm/i915: Give proper names to MOCS entries
    
    The purpose for each MOCS entry isn't well defined atm. Defining these
    is important to remove any uncertainty about the use of these entries
    for example in terms of performance and GPU/CPU coherency.
    
    Suggested by Ville.
    
    v4:
    - Rename I915_MOCS_AUTO to I915_MOCS_PTE. (Chris)
    
    CC: Rong R Yang <rong.r.yang@intel.com>
    CC: Yakui Zhao <yakui.zhao@intel.com>
    CC: Ville Syrjälä <ville.syrjala@linux.intel.com>
    CC: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467383528-16142-1-git-send-email-imre.deak@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 51b9360bb376..33ce5ff9556a 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -62,6 +62,30 @@ extern "C" {
 #define I915_ERROR_UEVENT		"ERROR"
 #define I915_RESET_UEVENT		"RESET"
 
+/*
+ * MOCS indexes used for GPU surfaces, defining the cacheability of the
+ * surface data and the coherency for this data wrt. CPU vs. GPU accesses.
+ */
+enum i915_mocs_table_index {
+	/*
+	 * Not cached anywhere, coherency between CPU and GPU accesses is
+	 * guaranteed.
+	 */
+	I915_MOCS_UNCACHED,
+	/*
+	 * Cacheability and coherency controlled by the kernel automatically
+	 * based on the DRM_I915_GEM_SET_CACHING IOCTL setting and the current
+	 * usage of the surface (used for display scanout or not).
+	 */
+	I915_MOCS_PTE,
+	/*
+	 * Cached in all GPU caches available on the platform.
+	 * Coherency between CPU and GPU accesses to the surface is not
+	 * guaranteed without extra synchronization.
+	 */
+	I915_MOCS_CACHED,
+};
+
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */
 #define I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use

commit 9e2793f6e4e2ca452457e459f013cc8e6b08a789
Author: Dave Gordon <david.s.gordon@intel.com>
Date:   Thu Jul 14 14:52:03 2016 +0100

    drm/i915: compile-time consistency check on __EXEC_OBJECT flags
    
    Two different sets of flag bits are stored in the 'flags' member of a
    'struct drm_i915_gem_exec_object2', and they're defined in two different
    source files, increasing the risk of an accidental clash.
    
    Some flags in this field are supplied by the user; these are defined in
    i915_drm.h, and they start from the LSB and work up.
    
    Other flags are defined in i915_gem_execbuffer, for internal use within
    that file only; they start from the MSB and work down.
    
    So here we add a compile-time check that the two sets of flags do not
    overlap, which would cause all sorts of confusion.
    
    Signed-off-by: Dave Gordon <david.s.gordon@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1468504324-12690-1-git-send-email-david.s.gordon@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index d7e81a3886fd..51b9360bb376 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -698,12 +698,13 @@ struct drm_i915_gem_exec_object2 {
 	 */
 	__u64 offset;
 
-#define EXEC_OBJECT_NEEDS_FENCE (1<<0)
-#define EXEC_OBJECT_NEEDS_GTT	(1<<1)
-#define EXEC_OBJECT_WRITE	(1<<2)
+#define EXEC_OBJECT_NEEDS_FENCE		 (1<<0)
+#define EXEC_OBJECT_NEEDS_GTT		 (1<<1)
+#define EXEC_OBJECT_WRITE		 (1<<2)
 #define EXEC_OBJECT_SUPPORTS_48B_ADDRESS (1<<3)
-#define EXEC_OBJECT_PINNED	(1<<4)
-#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_PINNED<<1)
+#define EXEC_OBJECT_PINNED		 (1<<4)
+/* All remaining bits are MBZ and RESERVED FOR FUTURE USE */
+#define __EXEC_OBJECT_UNKNOWN_FLAGS	(-(EXEC_OBJECT_PINNED<<1))
 	__u64 flags;
 
 	__u64 rsvd1;

commit bc3d674462e5df5f2b33adbfcaad9edff8b827f4
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jul 4 08:08:39 2016 +0100

    drm/i915: Allow userspace to request no-error-capture upon GPU hangs
    
    igt likes to inject GPU hangs into its command streams. However, as we
    expect these hangs, we don't actually want them recorded in the dmesg
    output or stored in the i915_error_state (usually). To accommodate this
    allow userspace to set a flag on the context that any hang emanating
    from that context will not be recorded. We still do the error capture
    (otherwise how do we find the guilty context and know its intent?) as
    part of the reason for random GPU hang injection is to exercise the race
    conditions between the error capture and normal execution.
    
    v2: Split out the request->ringbuf error capture changes.
    v3: Move the flag defines next to the intel_context->flags definition
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Dave Gordon <david.s.gordon@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467616119-4093-9-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index a642bbc7777d..d7e81a3886fd 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1173,6 +1173,7 @@ struct drm_i915_gem_context_param {
 #define I915_CONTEXT_PARAM_BAN_PERIOD	0x1
 #define I915_CONTEXT_PARAM_NO_ZEROMAP	0x2
 #define I915_CONTEXT_PARAM_GTT_SIZE	0x3
+#define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE	0x4
 	__u64 value;
 };
 

commit 37f501afed23fa1126017255495d5be5e97c9d6d
Author: arun.siluvery@linux.intel.com <arun.siluvery@linux.intel.com>
Date:   Fri Jul 1 11:43:02 2016 +0100

    drm/i915/bxt: Export pooled eu info to userspace
    
    Pooled EU is a bxt only feature and kernel changes are already merged. This
    feature is not yet exposed to userspace as the support was not yet
    available. Beignet team expressed interest and added patches to use this.
    
    Since we now have a user and patches to use them, expose them from the
    kernel side as well.
    
    v2: fix compile error
    
    [1] https://lists.freedesktop.org/archives/beignet/2016-June/007698.html
    [2] https://lists.freedesktop.org/archives/beignet/2016-June/007699.html
    
    Cc: Winiarski, Michal <michal.winiarski@intel.com>
    Cc: Zou, Nanhai <nanhai.zou@intel.com>
    Cc: Yang, Rong R <rong.r.yang@intel.com>
    Cc: Tim Gore <tim.gore@intel.com>
    Cc: Jeff McGee <jeff.mcgee@intel.com>
    Signed-off-by: Arun Siluvery <arun.siluvery@linux.intel.com>
    Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1467369782-25992-1-git-send-email-arun.siluvery@linux.intel.com
    Acked-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index c17d63d8b543..a642bbc7777d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -361,6 +361,8 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_GPU_RESET	 35
 #define I915_PARAM_HAS_RESOURCE_STREAMER 36
 #define I915_PARAM_HAS_EXEC_SOFTPIN	 37
+#define I915_PARAM_HAS_POOLED_EU	 38
+#define I915_PARAM_MIN_EU_IN_POOL	 39
 
 typedef struct drm_i915_getparam {
 	__s32 param;

commit b1c1f5c400f4c5dfd5405c210fcc9e019b734335
Author: Emil Velikov <emil.l.velikov@gmail.com>
Date:   Thu Apr 7 19:00:35 2016 +0100

    drm/i915: add extern C guard for the UAPI header
    
    Cc: Jani Nikula <jani.nikula@linux.intel.com>
    Signed-off-by: Emil Velikov <emil.l.velikov@gmail.com>
    Acked-by: Daniel Vetter <daniel.vetter@intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index a5524cc95ff8..c17d63d8b543 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -29,6 +29,10 @@
 
 #include "drm.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* Please note that modifications to all structs defined here are
  * subject to backwards-compatibility constraints.
  */
@@ -1170,4 +1174,8 @@ struct drm_i915_gem_context_param {
 	__u64 value;
 };
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _UAPI_I915_DRM_H_ */

commit d9da6aa035c6dfdb003ff9776532b9b356d83f15
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Jan 27 13:41:09 2016 +0000

    drm/i915: Fix VCS ring selection after uapi decoupling
    
    This got broken in:
    
       commit de1add360522c876c25ef2bbbbab1c94bdb509ab
       Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
       Date:   Fri Jan 15 15:12:50 2016 +0000
    
           drm/i915: Decouple execbuf uAPI from internal implementation
    
    BSD ring flags need to be shifted before they can be considered
    indices into the ring array.
    
    Reported by Zhipeng Gong.
    
    v2: Simplify the code. (Chris Wilson)
    
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Zhipeng Gong <zhipeng.gong@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Link: http://patchwork.freedesktop.org/patch/msgid/1453902069-31353-1-git-send-email-tvrtko.ursulin@linux.intel.com
    Testcase: igt/gem_exec_basic # bdw-gt3

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6a19371391fa..a5524cc95ff8 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -772,10 +772,12 @@ struct drm_i915_gem_execbuffer2 {
 #define I915_EXEC_HANDLE_LUT		(1<<12)
 
 /** Used for switching BSD rings on the platforms with two BSD rings */
-#define I915_EXEC_BSD_MASK		(3<<13)
-#define I915_EXEC_BSD_DEFAULT		(0<<13) /* default ping-pong mode */
-#define I915_EXEC_BSD_RING1		(1<<13)
-#define I915_EXEC_BSD_RING2		(2<<13)
+#define I915_EXEC_BSD_SHIFT	 (13)
+#define I915_EXEC_BSD_MASK	 (3 << I915_EXEC_BSD_SHIFT)
+/* default ping-pong mode */
+#define I915_EXEC_BSD_DEFAULT	 (0 << I915_EXEC_BSD_SHIFT)
+#define I915_EXEC_BSD_RING1	 (1 << I915_EXEC_BSD_SHIFT)
+#define I915_EXEC_BSD_RING2	 (2 << I915_EXEC_BSD_SHIFT)
 
 /** Tell the kernel that the batchbuffer is processed by
  *  the resource streamer.

commit 426960bed3217f72a1b7bb94f084d79cc616ec0f
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Jan 15 16:51:46 2016 +0000

    drm/i915: Seal busy-ioctl uABI and prevent leaking of internal ids
    
    Tvrtko was looking through the execbuffer-ioctl and noticed that the
    uABI was tightly coupled to our internal engine identifiers. Close
    inspection also revealed that we leak those internal engine identifiers
    through the busy-ioctl, and those internal identifiers already do not
    match the user identifiers. Fortuitiously, there is only one user of the
    set of busy rings from the busy-ioctl, and they only wish to choose
    between the RENDER and the BLT engines.
    
    Let's fix the userspace ABI while we still can.
    
    v2: Update the uAPI documentation to explain the identifiers.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Testcase: igt/gem_busy
    Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/1452876706-21620-1-git-send-email-chris@chris-wilson.co.uk

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index acf21026c78a..6a19371391fa 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -812,10 +812,35 @@ struct drm_i915_gem_busy {
 	/** Handle of the buffer to check for busy */
 	__u32 handle;
 
-	/** Return busy status (1 if busy, 0 if idle).
-	 * The high word is used to indicate on which rings the object
-	 * currently resides:
-	 *  16:31 - busy (r or r/w) rings (16 render, 17 bsd, 18 blt, etc)
+	/** Return busy status
+	 *
+	 * A return of 0 implies that the object is idle (after
+	 * having flushed any pending activity), and a non-zero return that
+	 * the object is still in-flight on the GPU. (The GPU has not yet
+	 * signaled completion for all pending requests that reference the
+	 * object.)
+	 *
+	 * The returned dword is split into two fields to indicate both
+	 * the engines on which the object is being read, and the
+	 * engine on which it is currently being written (if any).
+	 *
+	 * The low word (bits 0:15) indicate if the object is being written
+	 * to by any engine (there can only be one, as the GEM implicit
+	 * synchronisation rules force writes to be serialised). Only the
+	 * engine for the last write is reported.
+	 *
+	 * The high word (bits 16:31) are a bitmask of which engines are
+	 * currently reading from the object. Multiple engines may be
+	 * reading from the object simultaneously.
+	 *
+	 * The value of each engine is the same as specified in the
+	 * EXECBUFFER2 ioctl, i.e. I915_EXEC_RENDER, I915_EXEC_BSD etc.
+	 * Note I915_EXEC_DEFAULT is a symbolic value and is mapped to
+	 * the I915_EXEC_RENDER engine for execution, and so it is never
+	 * reported as active itself. Some hardware may have parallel
+	 * execution engines, e.g. multiple media engines, which are
+	 * mapped to the same identifier in the EXECBUFFER2 ioctl and
+	 * so are not separately reported for busyness.
 	 */
 	__u32 busy;
 };

commit ade1ba7346070709856d7e38f8d1a77b7aa710aa
Merge: fd3e14ffbd9e 7447a2b221cd
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed Dec 23 14:22:09 2015 +1000

    Merge tag 'drm-intel-next-2015-12-18' of git://anongit.freedesktop.org/drm-intel into drm-next
    
    - fix atomic watermark recomputation logic (Maarten)
    - modeset sequence fixes for LPT (Ville)
    - more kbl enabling&prep work (Rodrigo, Wayne)
    - first bits for mst audio
    - page dirty tracking fixes from Dave Gordon
    - new get_eld hook from Takashi, also included in the sound tree
    - fixup cursor handling when placed at address 0 (Ville)
    - refactor VBT parsing code (Jani)
    - rpm wakelock debug infrastructure ( Imre)
    - fbdev is pinned again (Chris)
    - tune the busywait logic to avoid wasting cpu cycles (Chris)
    
    * tag 'drm-intel-next-2015-12-18' of git://anongit.freedesktop.org/drm-intel: (81 commits)
      drm/i915: Update DRIVER_DATE to 20151218
      drm/i915/skl: Default to noncoherent access up to F0
      drm/i915: Only spin whilst waiting on the current request
      drm/i915: Limit the busy wait on requests to 5us not 10ms!
      drm/i915: Break busywaiting for requests on pending signals
      drm/i915: don't enable autosuspend on platforms without RPM support
      drm/i915/backlight: prefer dev_priv over dev pointer
      drm/i915: Disable primary plane if we fail to reconstruct BIOS fb (v2)
      drm/i915: Pin the ifbdev for the info->system_base GGTT mmapping
      drm/i915: Set the map-and-fenceable flag for preallocated objects
      drm/i915: mdelay(10) considered harmful
      drm/i915: check that we are in an RPM atomic section in GGTT PTE updaters
      drm/i915: add support for checking RPM atomic sections
      drm/i915: check that we hold an RPM wakelock ref before we put it
      drm/i915: add support for checking if we hold an RPM reference
      drm/i915: use assert_rpm_wakelock_held instead of opencoding it
      drm/i915: add assert_rpm_wakelock_held helper
      drm/i915: remove HAS_RUNTIME_PM check from RPM get/put/assert helpers
      drm/i915: get a permanent RPM reference on platforms w/o RPM support
      drm/i915: refactor RPM disabling due to RC6 being disabled
      ...

commit 663a233eef643b38f36c05535cb5c9a4972edcc1
Merge: e876b41ab074 d7e12cd7b8c6
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Dec 11 13:46:05 2015 +1000

    Merge branch 'drm-header-fixes' of https://github.com/GabrielL/linux into drm-next
    
    Fix all the problems with the header files and userspace builds
    off them. I really care so little about this, but hey who am
    I to stop progress.
    
    * 'drm-header-fixes' of https://github.com/GabrielL/linux: (30 commits)
      drm: fix inclusion of drm.h in via_drm.h
      drm: fix inclusion of drm.h in vmwgfx_drm.h
      drm: fix inclusion of drm.h in virtgpu_drm.h
      drm: fix inclusion of drm.h in tegra_drm.h
      drm: fix inclusion of drm.h in savage_drm.h
      drm: fix inclusion of drm.h in r128_drm.h
      drm: fix inclusion of drm.h in qxl_drm.h
      drm: fix inclusion of drm.h in omap_drm.h
      drm: fix inclusion of drm.h in msm_drm.h
      drm: fix inclusion of drm.h in mga_drm.h
      drm: fix inclusion of drm.h in exynos_sarea.h
      drm: fix inclusion of drm.h in i810_drm.h
      drm: fix inclusion of drm.h in exynos_sarea.h
      drm: fix inclusion of drm.h in drm_sarea.h
      drm: drm_mode.h fix includes
      drm: drm_fourcc.h fix includes
      drm: include drm.h in armada_drm.h
      include/uapi/drm/amdgpu_drm.h: use __u32 and __u64 from <linux/types.h>
      drm: Kbuild: add admgpu_drm.h to the installed headers
      drm: use __u{32,64} instead of uint{32,64}_t in virtgpu_drm.h
      ...

commit 1049102ff72b294bbeb1a254fe4de4a558387b46
Author: Gabriel Laskar <gabriel@lse.epita.fr>
Date:   Mon Nov 30 15:10:47 2015 +0100

    drm: fix inclusion of drm.h in exynos_sarea.h
    
    Using `#include "drm.h"` instead of `#include <drm/drm.h>` allow drm
    headers to be moved in another directory without changes, like for the
    libdrm imports.
    
    Signed-off-by: Gabriel Laskar <gabriel@lse.epita.fr>
    Reviewed-by: Emil Velikov <emil.l.velikov@gmail.com>
    CC: Emil Velikov <emil.l.velikov@gmail.com>
    CC: Mikko Rapeli <mikko.rapeli@iki.fi>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 484a9fb20479..07dcba2b002b 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -27,7 +27,7 @@
 #ifndef _UAPI_I915_DRM_H_
 #define _UAPI_I915_DRM_H_
 
-#include <drm/drm.h>
+#include "drm.h"
 
 /* Please note that modifications to all structs defined here are
  * subject to backwards-compatibility constraints.

commit 506a8e87d8d2746b9e9d2433503fe237c54e4750
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Dec 8 11:55:07 2015 +0000

    drm/i915: Add soft-pinning API for execbuffer
    
    Userspace can pass in an offset that it presumes the object is located
    at. The kernel will then do its utmost to fit the object into that
    location. The assumption is that userspace is handling its own object
    locations (for example along with full-ppgtt) and that the kernel will
    rarely have to make space for the user's requests.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    
    v2: Fixed incorrect eviction found by Michal Winiarski - fix suggested by Chris
    Wilson.  Fixed incorrect error paths causing crash found by Michal Winiarski.
    (Not published externally)
    
    v3: Rebased because of trivial conflict in object_bind_to_vm.  Fixed eviction
    to allow eviction of soft-pinned objects when another soft-pinned object used
    by a subsequent execbuffer overlaps reported by Michal Winiarski.
    (Not published externally)
    
    v4: Moved soft-pinned objects to the front of ordered_vmas so that they are
    pinned first after an address conflict happens to avoid repeated conflicts in
    rare cases (Suggested by Chris Wilson).  Expanded comment on
    drm_i915_gem_exec_object2.offset to cover this new API.
    
    v5: Added I915_PARAM_HAS_EXEC_SOFTPIN parameter for detecting this capability
    (Kristian). Added check for multiple pinnings on eviction (Akash). Made sure
    buffers are not considered misplaced without the user specifying
    EXEC_OBJECT_SUPPORTS_48B_ADDRESS.  User must assume responsibility for any
    addressing workarounds.  Updated object2.offset field comment again to clarify
    NO_RELOC case (Chris).  checkpatch cleanup.
    
    v6: Trivial rebase on latest drm-intel-nightly
    
    v7: Catch attempts to pin above the max virtual address size and return
    EINVAL (Tvrtko). Decouple EXEC_OBJECT_SUPPORTS_48B_ADDRESS and
    EXEC_OBJECT_PINNED flags, user must pass both flags in any attempt to pin
    something at an offset above 4GB (Chris, Daniel Vetter).
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Akash Goel <akash.goel@intel.com>
    Cc: Vinay Belgaumkar <vinay.belgaumkar@intel.com>
    Cc: Michal Winiarski <michal.winiarski@intel.com>
    Cc: Zou Nanhai <nanhai.zou@intel.com>
    Cc: Kristian Høgsberg <hoegsberg@gmail.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Michel Thierry <michel.thierry@intel.com>
    Acked-by: PDT
    Signed-off-by: Thomas Daniel <thomas.daniel@intel.com>
    Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1449575707-20933-1-git-send-email-thomas.daniel@intel.com

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 67ef73a5d6eb..d727b49f07ac 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -356,6 +356,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_EU_TOTAL		 34
 #define I915_PARAM_HAS_GPU_RESET	 35
 #define I915_PARAM_HAS_RESOURCE_STREAMER 36
+#define I915_PARAM_HAS_EXEC_SOFTPIN	 37
 
 typedef struct drm_i915_getparam {
 	__s32 param;
@@ -682,8 +683,12 @@ struct drm_i915_gem_exec_object2 {
 	__u64 alignment;
 
 	/**
-	 * Returned value of the updated offset of the object, for future
-	 * presumed_offset writes.
+	 * When the EXEC_OBJECT_PINNED flag is specified this is populated by
+	 * the user with the GTT offset at which this object will be pinned.
+	 * When the I915_EXEC_NO_RELOC flag is specified this must contain the
+	 * presumed_offset of the object.
+	 * During execbuffer2 the kernel populates it with the value of the
+	 * current GTT offset of the object, for future presumed_offset writes.
 	 */
 	__u64 offset;
 
@@ -691,7 +696,8 @@ struct drm_i915_gem_exec_object2 {
 #define EXEC_OBJECT_NEEDS_GTT	(1<<1)
 #define EXEC_OBJECT_WRITE	(1<<2)
 #define EXEC_OBJECT_SUPPORTS_48B_ADDRESS (1<<3)
-#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_SUPPORTS_48B_ADDRESS<<1)
+#define EXEC_OBJECT_PINNED	(1<<4)
+#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_PINNED<<1)
 	__u64 flags;
 
 	__u64 rsvd1;

commit 8697600b4046f26e497b200aff020f10ae6968ae
Author: Ville Syrjälä <ville.syrjala@linux.intel.com>
Date:   Fri Nov 6 21:43:41 2015 +0200

    drm/i915: Make the high dword offset more explicit in i915_reg_read_ioctl
    
    Store the upper dword of the register offset in the whitelist as well.
    This would allow it to read register where the two halves aren't sitting
    right next to each other, and it'll make it easier to make register
    access type safe.
    
    While at it change the register offsets to u32 from u64. Our register
    space isn't quite that big, yet :)
    
    v2: Use ldw/udw as the suffixes, and add a note about
        64bit wide split regs (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Link: http://patchwork.freedesktop.org/patch/msgid/1446839021-18599-1-git-send-email-ville.syrjala@linux.intel.com
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 67cebe6d978f..67ef73a5d6eb 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1079,6 +1079,12 @@ struct drm_i915_gem_context_destroy {
 };
 
 struct drm_i915_reg_read {
+	/*
+	 * Register offset.
+	 * For 64bit wide registers where the upper 32bits don't immediately
+	 * follow the lower 32bits, the offset of the lower 32bits must
+	 * be specified
+	 */
 	__u64 offset;
 	__u64 val; /* Return value */
 };

commit fa8848f27895bd19e16aed77868f464be24034e6
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Oct 14 14:17:11 2015 +0100

    drm/i915: Report context GTT size
    
    Since the beginning we have conflated the size of the global GTT with
    that of the per-process context sizes. In recent times (gen8+), those
    are no longer the same where the global GTT is limited to 2/4GiB but the
    per-process GTT may be anything up to 256TiB. Userspace knows nothing of
    this discrepancy and outside of one or two hacks, uses the getaperture
    ioctl to determine the maximum size it can use. Let's leave that as
    reporting the global GTT and use the context reporting method to
    describe the per-process value (which naturally fallsback to reporting
    the aliasing or global on older platforms, so userspace can always use
    this method where available).
    
    Testcase: igt/gem_userptr_blits/minor-normal-sync
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=90065
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 484a9fb20479..67cebe6d978f 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1125,8 +1125,9 @@ struct drm_i915_gem_context_param {
 	__u32 ctx_id;
 	__u32 size;
 	__u64 param;
-#define I915_CONTEXT_PARAM_BAN_PERIOD 0x1
-#define I915_CONTEXT_PARAM_NO_ZEROMAP 0x2
+#define I915_CONTEXT_PARAM_BAN_PERIOD	0x1
+#define I915_CONTEXT_PARAM_NO_ZEROMAP	0x2
+#define I915_CONTEXT_PARAM_GTT_SIZE	0x3
 	__u64 value;
 };
 

commit 101b506a7fc7be3f0d0a337ade270eb5eb5a2857
Author: Michel Thierry <michel.thierry@intel.com>
Date:   Thu Oct 1 13:33:57 2015 +0100

    drm/i915: Wa32bitGeneralStateOffset & Wa32bitInstructionBaseOffset
    
    There are some allocations that must be only referenced by 32-bit
    offsets. To limit the chances of having the first 4GB already full,
    objects not requiring this workaround use DRM_MM_SEARCH_BELOW/
    DRM_MM_CREATE_TOP flags
    
    In specific, any resource used with flat/heapless (0x00000000-0xfffff000)
    General State Heap (GSH) or Instruction State Heap (ISH) must be in a
    32-bit range, because the General State Offset and Instruction State
    Offset are limited to 32-bits.
    
    Objects must have EXEC_OBJECT_SUPPORTS_48B_ADDRESS flag to indicate if
    they can be allocated above the 32-bit address range. To limit the
    chances of having the first 4GB already full, objects will use
    DRM_MM_SEARCH_BELOW + DRM_MM_CREATE_TOP flags when possible.
    
    The libdrm user of the EXEC_OBJECT_SUPPORTS_48B_ADDRESS flag is here:
    http://lists.freedesktop.org/archives/intel-gfx/2015-September/075836.html
    
    v2: Changed flag logic from neeeds_32b, to supports_48b.
    v3: Moved 48-bit support flag back to exec_object. (Chris, Daniel)
    v4: Split pin flags into PIN_ZONE_4G and PIN_HIGH; update PIN_OFFSET_MASK
    to use last PIN_ defined instead of hard-coded value; use correct limit
    check in eb_vma_misplaced. (Chris)
    v5: Don't touch PIN_OFFSET_MASK and update workaround comment (Chris)
    v6: Apply pin-high for ggtt too (Chris)
    v7: Handle simultaneous pin-high and pin-mappable end correctly (Akash)
        Fix check for entries currently using +4GB addresses, use min_t and
        other polish in object_bind_to_vm (Chris)
    v8: Commit message updated to point to libdrm patch.
    v9: vmas are allocated in the correct ozone, so only check flag when the
        vma has not been allocated. (Chris)
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk> (v4)
    Signed-off-by: Michel Thierry <michel.thierry@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index fd5aa47bd689..484a9fb20479 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -690,7 +690,8 @@ struct drm_i915_gem_exec_object2 {
 #define EXEC_OBJECT_NEEDS_FENCE (1<<0)
 #define EXEC_OBJECT_NEEDS_GTT	(1<<1)
 #define EXEC_OBJECT_WRITE	(1<<2)
-#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_WRITE<<1)
+#define EXEC_OBJECT_SUPPORTS_48B_ADDRESS (1<<3)
+#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_SUPPORTS_48B_ADDRESS<<1)
 	__u64 flags;
 
 	__u64 rsvd1;

commit 16f7249ddf831f5ec0e1358222ce5db300446b84
Author: Artem Savkov <asavkov@redhat.com>
Date:   Wed Sep 2 13:41:18 2015 +0200

    uapi/drm/i915_drm.h: fix userspace compilation.
    
    commit 346add7834557b5b9628b9bf2387106d42e631d4
    Author: Daniel Vetter <daniel.vetter@ffwll.ch>
    Date:   Tue Jul 14 18:07:30 2015 +0200
    
        drm/i915: Use expcitly fixed type in compat32 structs
    
    changed the type of param field in drm_i915_getparam from int to
    s32. This header is exported to userspace and needs to use userspace
    type __s32 instead.
    
    This fixes userspace compilation errors like the following:
    include/drm/i915_drm.h:361:2: error: unknown type name 's32'
      s32 param;
    
    Signed-off-by: Artem Savkov <asavkov@redhat.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Jani Nikula <jani.nikula@intel.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index dbd16a2d37db..fd5aa47bd689 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -358,7 +358,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_RESOURCE_STREAMER 36
 
 typedef struct drm_i915_getparam {
-	s32 param;
+	__s32 param;
 	/*
 	 * WARNING: Using pointers instead of fixed-size u64 means we need to write
 	 * compat32 code. Don't repeat this mistake.

commit 4eebf60b7452fbd551fd7dece855ba7825a49cbc
Merge: 8f9cb50789e7 2c6625cd545b
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Aug 17 14:13:53 2015 +1000

    Merge tag 'v4.2-rc7' into drm-next
    
    Linux 4.2-rc7
    
    Backmerge master for i915 fixes

commit 648a9bc5308d952f2c80772301b339f73026f013
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Jul 16 12:37:56 2015 +0100

    drm/i915: Use two 32bit reads for select 64bit REG_READ ioctls
    
    Since the hardware sometimes mysteriously totally flummoxes the 64bit
    read of a 64bit register when read using a single instruction, split the
    read into two instructions. Since the read here is of automatically
    incrementing timestamp counters, we also have to be very careful in
    order to make sure that it does not increment between the two
    instructions.
    
    However, since userspace tried to workaround this issue and so enshrined
    this ABI for a broken hardware read and in the process neglected that
    the read only fails in some environments, we have to introduce a new
    uABI flag for userspace to request the 2x32 bit accurate read of the
    timestamp.
    
    v2: Fix alignment check and include details of the workaround for
    userspace.
    
    Reported-by: Karol Herbst <freedesktop@karolherbst.de>
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=91317
    Testcase: igt/gem_reg_read
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Michał Winiarski <michal.winiarski@intel.com>
    Cc: stable@vger.kernel.org
    Tested-by: Michał Winiarski <michal.winiarski@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6e1a2ed116cb..db809b722985 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1070,6 +1070,14 @@ struct drm_i915_reg_read {
 	__u64 offset;
 	__u64 val; /* Return value */
 };
+/* Known registers:
+ *
+ * Render engine timestamp - 0x2358 + 64bit - gen7+
+ * - Note this register returns an invalid value if using the default
+ *   single instruction 8byte read, in order to workaround that use
+ *   offset (0x2538 | 1) instead.
+ *
+ */
 
 struct drm_i915_reset_stats {
 	__u32 ctx_id;

commit 346add7834557b5b9628b9bf2387106d42e631d4
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Jul 14 18:07:30 2015 +0200

    drm/i915: Use expcitly fixed type in compat32 structs
    
    I was confused shortly whether the compat was needed for the int,
    until I noticed the pointer in the original.
    
    Also remove typedef.
    
    v2: Review from Chris.
    - Add comments.
    - Also change the int param in the original structure.
    
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index e7c29f1659ad..192027b4f031 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -358,7 +358,11 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_RESOURCE_STREAMER 36
 
 typedef struct drm_i915_getparam {
-	int param;
+	s32 param;
+	/*
+	 * WARNING: Using pointers instead of fixed-size u64 means we need to write
+	 * compat32 code. Don't repeat this mistake.
+	 */
 	int __user *value;
 } drm_i915_getparam_t;
 

commit a9ed33ca075f712cc7fd96eb84e3d322012fcaaf
Author: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
Date:   Wed Jul 1 10:12:23 2015 +0300

    drm/i915: Expose I915_EXEC_RESOURCE_STREAMER flag and getparam
    
    Ensures that the batch buffer is executed by the resource streamer.
    And will let userspace know whether Resource Streamer is supported in
    the kernel.
    
    v2: Don't skip 1<<15 for the exec flags (Jani Nikula)
    v3: Use HAS_RESOURCE_STREAMER macro for execbuf validation (Chris Wilson)
    
    (from getparam patch)
    
    v2: Update I915_PARAM_HAS_RESOURCE_STREAMER so it's after
        I915_PARAM_HAS_GPU_RESET.
    v3: Only advertise RS support for hardware that supports it.
    v4: Add HAS_RESOURCE_STREAMER() macro (Chris)
    
    Testcase: igt/gem_exec_params
    Cc: Jani Nikula <jani.nikula@intel.com>
    Cc: Kenneth Graunke <kenneth@whitecape.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Abdiel Janulgue <abdiel.janulgue@linux.intel.com>
    [danvet: squash in getparam patch since it'd break bisect, suggested
    by Chris.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index f88cc1cac5d9..e7c29f1659ad 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -355,6 +355,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_SUBSLICE_TOTAL	 33
 #define I915_PARAM_EU_TOTAL		 34
 #define I915_PARAM_HAS_GPU_RESET	 35
+#define I915_PARAM_HAS_RESOURCE_STREAMER 36
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -765,7 +766,12 @@ struct drm_i915_gem_execbuffer2 {
 #define I915_EXEC_BSD_RING1		(1<<13)
 #define I915_EXEC_BSD_RING2		(2<<13)
 
-#define __I915_EXEC_UNKNOWN_FLAGS -(1<<15)
+/** Tell the kernel that the batchbuffer is processed by
+ *  the resource streamer.
+ */
+#define I915_EXEC_RESOURCE_STREAMER     (1<<15)
+
+#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_RESOURCE_STREAMER<<1)
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit 49e4d842f0d0892c3d26c93a81b9f22c1467030e
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jun 15 12:23:48 2015 +0100

    drm/i915: Report to userspace if we have a (presumed) working GPU reset
    
    In igt, we want to test handling of GPU hangs, both for recovery
    purposes and for reporting. However, we don't want to inject a genuine
    GPU hang onto a machine that cannot recover and so be permenantly
    wedged. Rather than embed heuristics into igt, have the kernel report
    exactly when it expects the GPU reset to work.
    
    This can also be usefully extended in future to indicate different
    levels of fine-grained resets.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Tim Gore <tim.gore@intel.com>
    Cc: Tomas Elf <tomas.elf@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 92d61a7c942a..f88cc1cac5d9 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -354,6 +354,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_REVISION              32
 #define I915_PARAM_SUBSLICE_TOTAL	 33
 #define I915_PARAM_EU_TOTAL		 34
+#define I915_PARAM_HAS_GPU_RESET	 35
 
 typedef struct drm_i915_getparam {
 	int param;

commit b1b38278e12b04cf9a227f6af2c24651cf6e8a85
Author: David Weinehall <david.weinehall@linux.intel.com>
Date:   Wed May 20 17:00:13 2015 +0300

    drm/i915: add a context parameter to {en, dis}able zero address mapping
    
    Export a new context parameter that can be set/queried through the
    context_{get,set}param ioctls.  This parameter is passed as a context
    flag and decides whether or not a GPU address mapping is allowed to
    be made at address zero.  The default is to allow such mappings.
    
    Signed-off-by: David Weinehall <david.weinehall@intel.com>
    Acked-by: "Zou, Nanhai" <nanhai.zou@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6e1a2ed116cb..92d61a7c942a 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -1106,6 +1106,7 @@ struct drm_i915_gem_context_param {
 	__u32 size;
 	__u64 param;
 #define I915_CONTEXT_PARAM_BAN_PERIOD 0x1
+#define I915_CONTEXT_PARAM_NO_ZEROMAP 0x2
 	__u64 value;
 };
 

commit 21631f10ea08a9551eb32651448baad5ef64de6c
Author: Damien Lespiau <damien.lespiau@intel.com>
Date:   Tue May 26 14:57:19 2015 +0100

    drm/i915: Fix the confusing comment about the ioctl limits
    
    It was reported that this comment was confusing, and indeed it is.
    
    v2: (one year later!) Add the range for the DRM_I915_* iotcl defines
        (Daniel)
    
    Signed-off-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 4851d660243c..6e1a2ed116cb 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -171,8 +171,12 @@ typedef struct _drm_i915_sarea {
 #define I915_BOX_TEXTURE_LOAD  0x8
 #define I915_BOX_LOST_CONTEXT  0x10
 
-/* I915 specific ioctls
- * The device specific ioctl range is 0x40 to 0x79.
+/*
+ * i915 specific ioctls.
+ *
+ * The device specific ioctl range is [DRM_COMMAND_BASE, DRM_COMMAND_END) ie
+ * [0x40, 0xa0) (a0 is excluded). The numbers below are defined as offset
+ * against DRM_COMMAND_BASE and should be between [0x0, 0x60).
  */
 #define DRM_I915_INIT		0x00
 #define DRM_I915_FLUSH		0x01

commit ea9da4e4608104108c6d5eca7b178cec2720ab22
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Apr 2 10:35:08 2015 +0100

    drm/i915: Allow disabling the destination colorkey for overlay
    
    Sometimes userspace wants a true overlay that is never clipped. In such
    cases, we need to disable the destination colorkey. However, it is
    currently unconditionally enabled in the overlay with no means of
    disabling. So rectify that by always default to on, and extending the
    UPDATE_ATTR ioctl to support explicit disabling of the colorkey.
    
    This is contrast to the spite code which requires explicit enabling of
    either the destination or source colorkey. Handling source colorkey is
    still todo for the overlay. (Of course it may be worth migrating overlay
    to sprite before then.)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 551b6737f5df..4851d660243c 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -996,6 +996,7 @@ struct drm_intel_overlay_put_image {
 /* flags */
 #define I915_OVERLAY_UPDATE_ATTRS	(1<<0)
 #define I915_OVERLAY_UPDATE_GAMMA	(1<<1)
+#define I915_OVERLAY_DISABLE_DEST_COLORKEY	(1<<2)
 struct drm_intel_overlay_attrs {
 	__u32 flags;
 	__u32 color_key;

commit 2c60fae1489c70206e66c28d72b69a3e496c313d
Author: Tommi Rantala <tt.rantala@gmail.com>
Date:   Thu Mar 26 21:47:16 2015 +0200

    drm/i915: fix definition of the DRM_IOCTL_I915_GET_SPRITE_COLORKEY ioctl
    
    Fix definition of the DRM_IOCTL_I915_GET_SPRITE_COLORKEY ioctl, so that it
    is different from the DRM_IOCTL_I915_SET_SPRITE_COLORKEY ioctl.
    
    Note that this is just for accuracy, the ioctl implementation itself is totally
    unused and already ripped out.
    
    Signed-off-by: Tommi Rantala <tt.rantala@gmail.com>
    [danvet: Add note that this is a dead ioctl.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 8d1be9073380..551b6737f5df 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -270,7 +270,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, struct drm_intel_overlay_put_image)
 #define DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, struct drm_intel_overlay_attrs)
 #define DRM_IOCTL_I915_SET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
-#define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
+#define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
 #define DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, struct drm_i915_gem_wait)
 #define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)
 #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)

commit a1559ffefb2a80eabbee65d7cc04e828d4fd557d
Author: Jeff McGee <jeff.mcgee@intel.com>
Date:   Mon Mar 9 16:06:54 2015 -0700

    drm/i915: Export total subslice and EU counts
    
    Setup new I915_GETPARAM ioctl entries for subslice total and
    EU total. Userspace drivers need these values when constructing
    GPGPU commands. This kernel query method is intended to replace
    the PCI ID-based tables that userspace drivers currently maintain.
    The kernel driver can employ fuse register reads as needed to
    ensure the most accurate determination of GT config attributes.
    This first became important with Cherryview in which the config
    could differ between devices with the same PCI ID.
    
    The kernel detection of these values is device-specific and not
    included in this patch. Because zero is not a valid value for any of
    these parameters, a value of zero is interpreted as unknown for the
    device. Userspace drivers should continue to maintain ID-based tables
    for older devices not supported by the new query method.
    
    v2: Increment our I915_GETPARAM indices to fit after REVISION
        which was merged ahead of us.
    
    For: VIZ-4636
    Signed-off-by: Jeff McGee <jeff.mcgee@intel.com>
    Tested-by: Zhigang Gong <zhigang.gong@linux.intel.com>
    Acked-by: Zhigang Gong <zhigang.gong@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index b768f3b21eaa..8d1be9073380 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -348,6 +348,8 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_MMAP_VERSION          30
 #define I915_PARAM_HAS_BSD2		 31
 #define I915_PARAM_REVISION              32
+#define I915_PARAM_SUBSLICE_TOTAL	 33
+#define I915_PARAM_EU_TOTAL		 34
 
 typedef struct drm_i915_getparam {
 	int param;

commit 27cd44618b92fc8c6889e4628407791e45422bac
Author: Neil Roberts <neil@linux.intel.com>
Date:   Wed Mar 4 14:41:16 2015 +0000

    drm/i915: Add I915_PARAM_REVISION
    
    Adds a parameter which can be used with DRM_I915_GETPARAM to query the
    GPU revision. The intention is to use this in Mesa to implement the
    WaDisableSIMD16On3SrcInstr workaround on Skylake but only for
    revision 2.
    
    Signed-off-by: Neil Roberts <neil@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 6eed16b92a24..b768f3b21eaa 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -347,6 +347,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_COHERENT_PHYS_GTT 29
 #define I915_PARAM_MMAP_VERSION          30
 #define I915_PARAM_HAS_BSD2		 31
+#define I915_PARAM_REVISION              32
 
 typedef struct drm_i915_getparam {
 	int param;

commit 08e16dc874e672f1a1472a495c8351b8ce5d34d5
Author: Zhipeng Gong <zhipeng.gong@intel.com>
Date:   Tue Jan 13 08:48:25 2015 +0800

    drm/i915: add I915_PARAM_HAS_BSD2 to i915_getparam
    
    This will let userland only try to use the new ring
    when the appropriate kernel is present
    
    v2: change the number to be consistent with upstream (Zhipeng)
    
    Signed-off-by: Zhipeng Gong <zhipeng.gong@intel.com>
    Reviewed--by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index dc845614e80d..6eed16b92a24 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -346,6 +346,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_CMD_PARSER_VERSION	 28
 #define I915_PARAM_HAS_COHERENT_PHYS_GTT 29
 #define I915_PARAM_MMAP_VERSION          30
+#define I915_PARAM_HAS_BSD2		 31
 
 typedef struct drm_i915_getparam {
 	int param;

commit 8d360dffd6d8634868e433128d5178bea14cc42c
Author: Zhipeng Gong <zhipeng.gong@intel.com>
Date:   Tue Jan 13 08:48:24 2015 +0800

    drm/i915: Specify bsd rings through exec flag
    
    On Skylake GT3 we have 2 Video Command Streamers (VCS), which is asymmetrical.
    For example, HEVC GPU commands can be only dispatched to VCS1 ring.
    But userspace has no control when using VCS1 or VCS2. This patch introduces
    a mechanism to avoid the default ping-pong mode and use one specific ring
    through execution flag. This mechanism is usable for all the platforms
    with 2 VCS rings.
    
    The open source usage is from these two commits in vaapi/intel:
            commit 702050f04131a44ef8ac16651708ce8a8d98e4b8
            Author: Zhao, Yakui <yakui.zhao@intel.com>
            Date:   Mon Nov 17 12:44:19 2014 +0800
    
                Allow the batchbuffer to be submitted with override flag
    
            commit a56efcdf27d11ad9b21664b4a2cda72d7f90f5a8
            Author: Zhao Yakui <yakui.zhao@intel.com>
            Date:   Mon Nov 17 12:44:22 2014 +0800
    
                Add the override flag to assure that HEVC video command
                    always uses BSD ring0 for SKL GT3 machine
    
    v2: fix whitespace (Rodrigo)
    v3: remove incorrect chunk that came on -collector rebase. (Rodrigo)
    v4: change the comment (Zhipeng)
    v5: address Daniel's comment (Zhipeng)
    
    Signed-off-by: Zhipeng Gong <zhipeng.gong@intel.com>
    Reviewed-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 2e559f6e699e..dc845614e80d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -750,7 +750,13 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_HANDLE_LUT		(1<<12)
 
-#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_HANDLE_LUT<<1)
+/** Used for switching BSD rings on the platforms with two BSD rings */
+#define I915_EXEC_BSD_MASK		(3<<13)
+#define I915_EXEC_BSD_DEFAULT		(0<<13) /* default ping-pong mode */
+#define I915_EXEC_BSD_RING1		(1<<13)
+#define I915_EXEC_BSD_RING2		(2<<13)
+
+#define __I915_EXEC_UNKNOWN_FLAGS -(1<<15)
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit c9dc0f35986c0e2fc81e0b71ddc7e3adad733829
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Dec 24 08:13:40 2014 -0800

    drm/i915: Add ioctl to set per-context parameters
    
    Sometimes we wish to tweak how an individual context behaves. Since we
    always create a context for every filp, this means that individual
    processes can fine tune their behaviour even if they do not explicitly
    create a context.
    
    The first example parameter here is to enable multi-process GPU testing,
    but the interface should be able to cope with passing arbitrarily complex
    parameters.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Reviewed-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Testcase: igt/gem_reset_stats/ban-period-*
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index c155a0347949..2e559f6e699e 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -224,6 +224,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_REG_READ		0x31
 #define DRM_I915_GET_RESET_STATS	0x32
 #define DRM_I915_GEM_USERPTR		0x33
+#define DRM_I915_GEM_CONTEXT_GETPARAM	0x34
+#define DRM_I915_GEM_CONTEXT_SETPARAM	0x35
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -275,6 +277,8 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
 #define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)
 #define DRM_IOCTL_I915_GEM_USERPTR			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR, struct drm_i915_gem_userptr)
+#define DRM_IOCTL_I915_GEM_CONTEXT_GETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_GETPARAM, struct drm_i915_gem_context_param)
+#define DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, struct drm_i915_gem_context_param)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1082,4 +1086,12 @@ struct drm_i915_gem_userptr {
 	__u32 handle;
 };
 
+struct drm_i915_gem_context_param {
+	__u32 ctx_id;
+	__u32 size;
+	__u64 param;
+#define I915_CONTEXT_PARAM_BAN_PERIOD 0x1
+	__u64 value;
+};
+
 #endif /* _UAPI_I915_DRM_H_ */

commit 1816f92363036600f2387bb8273b1e5e1f5b304e
Author: Akash Goel <akash.goel@intel.com>
Date:   Fri Jan 2 16:29:30 2015 +0530

    drm/i915: Support creation of unbound wc user mappings for objects
    
    This patch provides support to create write-combining virtual mappings of
    GEM object. It intends to provide the same funtionality of 'mmap_gtt'
    interface without the constraints and contention of a limited aperture
    space, but requires clients handles the linear to tile conversion on their
    own. This is for improving the CPU write operation performance, as with such
    mapping, writes and reads are almost 50% faster than with mmap_gtt. Similar
    to the GTT mmapping, unlike the regular CPU mmapping, it avoids the cache
    flush after update from CPU side, when object is passed onto GPU.  This
    type of mapping is specially useful in case of sub-region update,
    i.e. when only a portion of the object is to be updated. Using a CPU mmap
    in such cases would normally incur a clflush of the whole object, and
    using a GTT mmapping would likely require eviction of an active object or
    fence and thus stall. The write-combining CPU mmap avoids both.
    
    To ensure the cache coherency, before using this mapping, the GTT domain
    has been reused here. This provides the required cache flush if the object
    is in CPU domain or synchronization against the concurrent rendering.
    Although the access through an uncached mmap should automatically
    invalidate the cache lines, this may not be true for non-temporal write
    instructions and also not all pages of the object may be updated at any
    given point of time through this mapping.  Having a call to get_pages in
    set_to_gtt_domain function, as added in the earlier patch 'drm/i915:
    Broaden application of set-domain(GTT)', would guarantee the clflush and
    so there will be no cachelines holding the data for the object before it
    is accessed through this map.
    
    The drm_i915_gem_mmap structure (for the DRM_I915_GEM_MMAP_IOCTL) has been
    extended with a new flags field (defaulting to 0 for existent users). In
    order for userspace to detect the extended ioctl, a new parameter
    I915_PARAM_MMAP_VERSION has been added for versioning the ioctl interface.
    
    v2: Fix error handling, invalid flag detection, renaming (ickle)
    
    v3: Rebase to latest drm-intel-nightly codebase
    
    The new mmapping is exercised by igt/gem_mmap_wc,
    igt/gem_concurrent_blit and igt/gem_gtt_speed.
    
    Change-Id: Ie883942f9e689525f72fe9a8d3780c3a9faa769a
    Signed-off-by: Akash Goel <akash.goel@intel.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 250262265ee3..c155a0347949 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -341,6 +341,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_WT     	 	 27
 #define I915_PARAM_CMD_PARSER_VERSION	 28
 #define I915_PARAM_HAS_COHERENT_PHYS_GTT 29
+#define I915_PARAM_MMAP_VERSION          30
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -488,6 +489,14 @@ struct drm_i915_gem_mmap {
 	 * This is a fixed-size type for 32/64 compatibility.
 	 */
 	__u64 addr_ptr;
+
+	/**
+	 * Flags for extended behaviour.
+	 *
+	 * Added in version 2.
+	 */
+	__u64 flags;
+#define I915_MMAP_WC 0x1
 };
 
 struct drm_i915_gem_mmap_gtt {

commit 6a2c4232ece145d8b5a8f95f767bd6d0d2d2f2bb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Nov 4 04:51:40 2014 -0800

    drm/i915: Make the physical object coherent with GTT
    
    Currently objects for which the hardware needs a contiguous physical
    address are allocated a shadow backing storage to satisfy the contraint.
    This shadow buffer is not wired into the normal obj->pages and so the
    physical object is incoherent with accesses via the GPU, GTT and CPU. By
    setting up the appropriate scatter-gather table, we can allow userspace
    to access the physical object via either a GTT mmaping of or by rendering
    into the GEM bo. However, keeping the CPU mmap of the shmemfs backing
    storage coherent with the contiguous shadow is not yet possible.
    Fortuituously, CPU mmaps of objects requiring physical addresses are not
    expected to be coherent anyway.
    
    This allows the physical constraint of the GEM object to be transparent
    to userspace and allow it to efficiently render into or update them via
    the GTT and GPU.
    
    v2: Fix leak of pci handle spotted by Ville
    v3: Remove the now duplicate call to detach_phys_object during free.
    v4: Wait for rendering before pwrite. As this patch makes it possible to
    render into the phys object, we should make it correct as well!
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Rodrigo Vivi <rodrigo.vivi@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 2ec0efcaa719..250262265ee3 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -340,6 +340,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_EXEC_HANDLE_LUT   26
 #define I915_PARAM_HAS_WT     	 	 27
 #define I915_PARAM_CMD_PARSER_VERSION	 28
+#define I915_PARAM_HAS_COHERENT_PHYS_GTT 29
 
 typedef struct drm_i915_getparam {
 	int param;

commit 70f2f5c70440feff01d9ba7c8b4432eb72bd69eb
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri Oct 24 12:11:11 2014 +0100

    drm/i915: Report the actual swizzling back to userspace
    
    Userspace cares about whether or not swizzling depends on the page
    address for its direct access into bound objects. Extend the get_tiling
    ioctl to report the physical swizzling value in addition to the logical
    swizzling value so that userspace can accurately determine when it is
    possible for manual detiling.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Akash Goel <akash.goel@intel.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Testcase: igt/gem_tiled_wc
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index ff57f07c3249..2ec0efcaa719 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -876,6 +876,12 @@ struct drm_i915_gem_get_tiling {
 	 * mmap mapping.
 	 */
 	__u32 swizzle_mode;
+
+	/**
+	 * Returned address bit 6 swizzling required for CPU access through
+	 * mmap mapping whilst bound.
+	 */
+	__u32 phys_swizzle_mode;
 };
 
 struct drm_i915_gem_get_aperture {

commit 5cc9ed4b9a7ac579362ccebac67f7a4cdb36de06
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Fri May 16 14:22:37 2014 +0100

    drm/i915: Introduce mapping of user pages into video memory (userptr) ioctl
    
    By exporting the ability to map user address and inserting PTEs
    representing their backing pages into the GTT, we can exploit UMA in order
    to utilize normal application data as a texture source or even as a
    render target (depending upon the capabilities of the chipset). This has
    a number of uses, with zero-copy downloads to the GPU and efficient
    readback making the intermixed streaming of CPU and GPU operations
    fairly efficient. This ability has many widespread implications from
    faster rendering of client-side software rasterisers (chromium),
    mitigation of stalls due to read back (firefox) and to faster pipelining
    of texture data (such as pixel buffer objects in GL or data blobs in CL).
    
    v2: Compile with CONFIG_MMU_NOTIFIER
    v3: We can sleep while performing invalidate-range, which we can utilise
    to drop our page references prior to the kernel manipulating the vma
    (for either discard or cloning) and so protect normal users.
    v4: Only run the invalidate notifier if the range intercepts the bo.
    v5: Prevent userspace from attempting to GTT mmap non-page aligned buffers
    v6: Recheck after reacquire mutex for lost mmu.
    v7: Fix implicit padding of ioctl struct by rounding to next 64bit boundary.
    v8: Fix rebasing error after forwarding porting the back port.
    v9: Limit the userptr to page aligned entries. We now expect userspace
        to handle all the offset-in-page adjustments itself.
    v10: Prevent vma from being copied across fork to avoid issues with cow.
    v11: Drop vma behaviour changes -- locking is nigh on impossible.
         Use a worker to load user pages to avoid lock inversions.
    v12: Use get_task_mm()/mmput() for correct refcounting of mm.
    v13: Use a worker to release the mmu_notifier to avoid lock inversion
    v14: Decouple mmu_notifier from struct_mutex using a custom mmu_notifer
         with its own locking and tree of objects for each mm/mmu_notifier.
    v15: Prevent overlapping userptr objects, and invalidate all objects
         within the mmu_notifier range
    v16: Fix a typo for iterating over multiple objects in the range and
         rearrange error path to destroy the mmu_notifier locklessly.
         Also close a race between invalidate_range and the get_pages_worker.
    v17: Close a race between get_pages_worker/invalidate_range and fresh
         allocations of the same userptr range - and notice that
         struct_mutex was presumed to be held when during creation it wasn't.
    v18: Sigh. Fix the refactor of st_set_pages() to allocate enough memory
         for the struct sg_table and to clear it before reporting an error.
    v19: Always error out on read-only userptr requests as we don't have the
         hardware infrastructure to support them at the moment.
    v20: Refuse to implement read-only support until we have the required
         infrastructure - but reserve the bit in flags for future use.
    v21: use_mm() is not required for get_user_pages(). It is only meant to
         be used to fix up the kernel thread's current->mm for use with
         copy_user().
    v22: Use sg_alloc_table_from_pages for that chunky feeling
    v23: Export a function for sanity checking dma-buf rather than encode
         userptr details elsewhere, and clean up comments based on
         suggestions by Bradley.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Cc: "Gong, Zhipeng" <zhipeng.gong@intel.com>
    Cc: Akash Goel <akash.goel@intel.com>
    Cc: "Volkin, Bradley D" <bradley.d.volkin@intel.com>
    Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@linux.intel.com>
    Reviewed-by: Brad Volkin <bradley.d.volkin@intel.com>
    [danvet: Frob ioctl allocation to pick the next one - will cause a bit
    of fuss with create2 apparently, but such are the rules.]
    [danvet2: oops, forgot to git add after manual patch application]
    [danvet3: Appease sparse.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 8a3e4ef00c3d..ff57f07c3249 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -223,6 +223,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_GEM_GET_CACHING	0x30
 #define DRM_I915_REG_READ		0x31
 #define DRM_I915_GET_RESET_STATS	0x32
+#define DRM_I915_GEM_USERPTR		0x33
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -273,6 +274,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
 #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
 #define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)
+#define DRM_IOCTL_I915_GEM_USERPTR			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR, struct drm_i915_gem_userptr)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1050,4 +1052,18 @@ struct drm_i915_reset_stats {
 	__u32 pad;
 };
 
+struct drm_i915_gem_userptr {
+	__u64 user_ptr;
+	__u64 user_size;
+	__u32 flags;
+#define I915_USERPTR_READ_ONLY 0x1
+#define I915_USERPTR_UNSYNCHRONIZED 0x80000000
+	/**
+	 * Returned handle for the object.
+	 *
+	 * Object handles are nonzero.
+	 */
+	__u32 handle;
+};
+
 #endif /* _UAPI_I915_DRM_H_ */

commit d728c8ef8bea6e81f44933c0237531cda499577e
Author: Brad Volkin <bradley.d.volkin@intel.com>
Date:   Tue Feb 18 10:15:56 2014 -0800

    drm/i915: Add a CMD_PARSER_VERSION getparam
    
    So userspace can query the kernel for command parser support.
    
    v2: Add i915_cmd_parser_get_version(), history log, and kerneldoc
    
    OTC-Tracker: AXIA-4631
    Change-Id: I58af650db9f6753c2dcac9c54ab432fd31db302f
    Signed-off-by: Brad Volkin <bradley.d.volkin@intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 126bfaa8bb6b..8a3e4ef00c3d 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -337,6 +337,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_EXEC_NO_RELOC	 25
 #define I915_PARAM_HAS_EXEC_HANDLE_LUT   26
 #define I915_PARAM_HAS_WT     	 	 27
+#define I915_PARAM_CMD_PARSER_VERSION	 28
 
 typedef struct drm_i915_getparam {
 	int param;

commit c3d19d3c3fb0085fbfb81f546abb8d50fdf58d17
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Sun Jan 12 14:08:43 2014 +0100

    drm/i915: Spelling s/auxilliary/auxiliary/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 52aed893710a..126bfaa8bb6b 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -721,7 +721,7 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_IS_PINNED		(1<<10)
 
-/** Provide a hint to the kernel that the command stream and auxilliary
+/** Provide a hint to the kernel that the command stream and auxiliary
  * state buffers already holds the correct presumed addresses and so the
  * relocation process may be skipped if no buffers need to be moved in
  * preparation for the execbuffer.

commit b6359918b885da7c7b58c050674278dbd06020ab
Author: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date:   Wed Oct 30 15:44:16 2013 +0200

    drm/i915: add i915_get_reset_stats_ioctl
    
    This ioctl returns reset stats for specified context.
    
    The struct returned contains context loss counters.
    
    reset_count:    all resets across all contexts
    batch_active:   active batches lost on resets
    batch_pending:  pending batches lost on resets
    
    v2: get rid of state tracking completely and deliver only counts. Idea
        from Chris Wilson.
    
    v3: fix commit message
    
    v4: default context handled inside i915_gem_context_get_hang_stats
    
    v5: reset_count only for priviledged process
    
    v6: ctx=0 needs CAP_SYS_ADMIN for batch_* counters (Chris Wilson)
    
    v7: context hang stats never returns NULL
    
    v8: rebased on top of reworked context hang stats
        DRM_RENDER_ALLOW for ioctl
    
    v9: use DEFAULT_CONTEXT_ID. Improve comments for ioctl struct members
    
    Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
    Cc: Ian Romanick <idr@freedesktop.org>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Reviewed-by: Ian Romanick <ian.d.romanick@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 3a4e97bd8607..52aed893710a 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -222,6 +222,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_I915_GEM_SET_CACHING	0x2f
 #define DRM_I915_GEM_GET_CACHING	0x30
 #define DRM_I915_REG_READ		0x31
+#define DRM_I915_GET_RESET_STATS	0x32
 
 #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
 #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
@@ -271,6 +272,7 @@ typedef struct _drm_i915_sarea {
 #define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)
 #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
 #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
+#define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)
 
 /* Allow drivers to submit batchbuffers directly to hardware, relying
  * on the security mechanisms provided by hardware.
@@ -1030,4 +1032,21 @@ struct drm_i915_reg_read {
 	__u64 offset;
 	__u64 val; /* Return value */
 };
+
+struct drm_i915_reset_stats {
+	__u32 ctx_id;
+	__u32 flags;
+
+	/* All resets since boot/module reload, for all contexts */
+	__u32 reset_count;
+
+	/* Number of batches lost when active in GPU, for this context */
+	__u32 batch_active;
+
+	/* Number of batches lost pending for execution, for this context */
+	__u32 batch_pending;
+
+	__u32 pad;
+};
+
 #endif /* _UAPI_I915_DRM_H_ */

commit 35a85ac60618521d41cfdb14f3fbfc8ad7329e9e
Author: Ben Widawsky <benjamin.widawsky@intel.com>
Date:   Thu Sep 19 11:13:41 2013 -0700

    drm/i915: Add second slice l3 remapping
    
    Certain HSW SKUs have a second bank of L3. This L3 remapping has a
    separate register set, and interrupt from the first "slice". A slice is
    simply a term to define some subset of the GPU's l3 cache. This patch
    implements both the interrupt handler, and ability to communicate with
    userspace about this second slice.
    
    v2:  Remove redundant check about non-existent slice.
    Change warning about interrupts of unknown slices to WARN_ON_ONCE
    Handle the case where we get 2 slice interrupts concurrently, and switch
    the tracking of interrupts to be non-destructive (all Ville)
    Don't enable/mask the second slice parity interrupt for ivb/vlv (even
    though all docs I can find claim it's rsvd) (Ville + Bryan)
    Keep BYT excluded from L3 parity
    
    v3: Fix the slice = ffs to be decremented by one (found by Ville). When
    I initially did my testing on the series, I was using 1-based slice
    counting, so this code was correct. Not sure why my simpler tests that
    I've been running since then didn't pick it up sooner.
    
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 55bb5729bd78..3a4e97bd8607 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -38,10 +38,10 @@
  *
  * I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch
  *	event from the gpu l3 cache. Additional information supplied is ROW,
- *	BANK, SUBBANK of the affected cacheline. Userspace should keep track of
- *	these events and if a specific cache-line seems to have a persistent
- *	error remap it with the l3 remapping tool supplied in intel-gpu-tools.
- *	The value supplied with the event is always 1.
+ *	BANK, SUBBANK, SLICE of the affected cacheline. Userspace should keep
+ *	track of these events and if a specific cache-line seems to have a
+ *	persistent error remap it with the l3 remapping tool supplied in
+ *	intel-gpu-tools.  The value supplied with the event is always 1.
  *
  * I915_ERROR_UEVENT - Generated upon error detection, currently only via
  *	hangcheck. The error detection event is a good indicator of when things

commit 651d794fae9b79237aae1c97f8a9d9f3817bd31d
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Aug 8 14:41:10 2013 +0100

    drm/i915: Use Write-Through cacheing for the display plane on Iris
    
    Haswell GT3e has the unique feature of supporting Write-Through cacheing
    of objects within the eLLC/LLC. The purpose of this is to enable the display
    plane to remain coherent whilst objects lie resident in the eLLC/LLC - so
    that we, in theory, get the best of both worlds, perfect display and fast
    access.
    
    However, we still need to be careful as the CPU does not see the WT when
    accessing the cache. In particular, this means that we need to flush the
    cache lines after writing to an object through the CPU, and on
    transitioning from a cached state to WT.
    
    v2: Actually do the clflush on transition to WT, nagging by Ville.
    v3: Flush the CPU cache after writes into WT objects.
    v4: Rease onto LLC updates and report WT as "uncached" for
    get_cache_level_ioctl to remain symmetric with set_cache_level_ioctl.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Cc: Kenneth Graunke <kenneth@whitecape.org>
    Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 0bb3e5524382..55bb5729bd78 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -334,6 +334,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_PINNED_BATCHES	 24
 #define I915_PARAM_HAS_EXEC_NO_RELOC	 25
 #define I915_PARAM_HAS_EXEC_HANDLE_LUT   26
+#define I915_PARAM_HAS_WT     	 	 27
 
 typedef struct drm_i915_getparam {
 	int param;

commit 35c7ab421a13f8327e3fd627c6ebafb1c13b2e55
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sat Aug 10 14:51:11 2013 +0200

    drm/i915: reserve I915_CACHING_DISPLAY and document cache modes
    
    Resolve the catch-22 of igt needing a stable number and patches first
    needing testcases by reserving the interface number up-front.
    
    v2: Improve the spelling a bit.
    
    v3: More spelling fail spotted by Chris.
    
    Requested-by: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Chris Wilson <chris@chris-wilson.co.uk>
    Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
    Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index a1a7b6bd60d8..0bb3e5524382 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -768,8 +768,32 @@ struct drm_i915_gem_busy {
 	__u32 busy;
 };
 
+/**
+ * I915_CACHING_NONE
+ *
+ * GPU access is not coherent with cpu caches. Default for machines without an
+ * LLC.
+ */
 #define I915_CACHING_NONE		0
+/**
+ * I915_CACHING_CACHED
+ *
+ * GPU access is coherent with cpu caches and furthermore the data is cached in
+ * last-level caches shared between cpu cores and the gpu GT. Default on
+ * machines with HAS_LLC.
+ */
 #define I915_CACHING_CACHED		1
+/**
+ * I915_CACHING_DISPLAY
+ *
+ * Special GPU caching mode which is coherent with the scanout engines.
+ * Transparently falls back to I915_CACHING_NONE on platforms where no special
+ * cache mode (like write-through or gfdt flushing) is available. The kernel
+ * automatically sets this mode when using a buffer as a scanout target.
+ * Userspace can manually set this mode to avoid a costly stall and clflush in
+ * the hotpath of drawing the first frame.
+ */
+#define I915_CACHING_DISPLAY		2
 
 struct drm_i915_gem_caching {
 	/**

commit cce723ed091ac304d48386bcc3524994c345123e
Author: Ben Widawsky <ben@bwidawsk.net>
Date:   Fri Jul 19 09:16:42 2013 -0700

    drm/i915: Make i915 events part of uapi
    
    Make the uevent strings part of the user API for people who wish to
    write their own listeners.
    
    v2: Make a space in the string concatenation. (Chad)
    Use the "UEVENT" suffix intead of "EVENT" (Chad)
    Make kernel-doc parseable Docbook comments (Daniel)
    
    v3: Undid reset change introduced in last submission (Daniel)
    Fixed up comments to address removal changes.
    
    Thanks to Daniel Vetter for a majority of the parity error comments.
    
    CC: Chad Versace <chad.versace@linux.intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 923ed7fe5775..a1a7b6bd60d8 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -33,6 +33,30 @@
  * subject to backwards-compatibility constraints.
  */
 
+/**
+ * DOC: uevents generated by i915 on it's device node
+ *
+ * I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch
+ *	event from the gpu l3 cache. Additional information supplied is ROW,
+ *	BANK, SUBBANK of the affected cacheline. Userspace should keep track of
+ *	these events and if a specific cache-line seems to have a persistent
+ *	error remap it with the l3 remapping tool supplied in intel-gpu-tools.
+ *	The value supplied with the event is always 1.
+ *
+ * I915_ERROR_UEVENT - Generated upon error detection, currently only via
+ *	hangcheck. The error detection event is a good indicator of when things
+ *	began to go badly. The value supplied with the event is a 1 upon error
+ *	detection, and a 0 upon reset completion, signifying no more error
+ *	exists. NOTE: Disabling hangcheck or reset via module parameter will
+ *	cause the related events to not be seen.
+ *
+ * I915_RESET_UEVENT - Event is generated just before an attempt to reset the
+ *	the GPU. The value supplied with the event is always 1. NOTE: Disable
+ *	reset via module parameter will cause this event to not be seen.
+ */
+#define I915_L3_PARITY_UEVENT		"L3_PARITY_ERROR"
+#define I915_ERROR_UEVENT		"ERROR"
+#define I915_RESET_UEVENT		"RESET"
 
 /* Each region is a minimum of 16k, and there are at most 255 of them.
  */

commit a1f2cc73c762868435ae6ec9126bb2240337c61c
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Tue May 28 19:22:34 2013 -0700

    drm/i915: add I915_PARAM_HAS_VEBOX to i915_getparam
    
    This will let userland only try to use the new ring
    when the appropriate kernel is present
    
    Signed-off-by: Xiang, Haihao <haihao.xiang@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 81b99817198e..923ed7fe5775 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -305,7 +305,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_WAIT_TIMEOUT	 19
 #define I915_PARAM_HAS_SEMAPHORES	 20
 #define I915_PARAM_HAS_PRIME_VMAP_FLUSH	 21
-#define I915_PARAM_RSVD_FOR_FUTURE_USE	 22
+#define I915_PARAM_HAS_VEBOX		 22
 #define I915_PARAM_HAS_SECURE_BATCHES	 23
 #define I915_PARAM_HAS_PINNED_BATCHES	 24
 #define I915_PARAM_HAS_EXEC_NO_RELOC	 25

commit 82f91b6e93e2138c7e02b5a866f63d04cf040c86
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Tue May 28 19:22:33 2013 -0700

    drm/i915: add I915_EXEC_VEBOX to i915_gem_do_execbuffer()
    
    A user can run batchbuffer via VEBOX ring.
    
    Signed-off-by: Xiang, Haihao <haihao.xiang@intel.com>
    Reviewed-by: Damien Lespiau <damien.lespiau@intel.com>
    Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 07d59419fe6b..81b99817198e 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -660,6 +660,7 @@ struct drm_i915_gem_execbuffer2 {
 #define I915_EXEC_RENDER                 (1<<0)
 #define I915_EXEC_BSD                    (2<<0)
 #define I915_EXEC_BLT                    (3<<0)
+#define I915_EXEC_VEBOX                  (4<<0)
 
 /* Used for switching the constants addressing mode on gen4+ RENDER ring.
  * Gen6+ only supports relative addressing to dynamic state (default) and

commit eef90ccb8a4d50b219a95cc53878ebb007315b32
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Tue Jan 8 10:53:17 2013 +0000

    drm/i915: Use the reloc.handle as an index into the execbuffer array
    
    Using copywinwin10 as an example that is dependent upon emitting a lot
    of relocations (2 per operation), we see improvements of:
    
    c2d/gm45: 618000.0/sec to 623000.0/sec.
    i3-330m: 748000.0/sec to 789000.0/sec.
    
    (measured relative to a baseline with neither optimisations applied).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index 2430b6ad6a85..07d59419fe6b 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -309,6 +309,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_SECURE_BATCHES	 23
 #define I915_PARAM_HAS_PINNED_BATCHES	 24
 #define I915_PARAM_HAS_EXEC_NO_RELOC	 25
+#define I915_PARAM_HAS_EXEC_HANDLE_LUT   26
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -699,7 +700,12 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_NO_RELOC		(1<<11)
 
-#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_NO_RELOC<<1)
+/** Use the reloc.handle as an index into the exec object array rather
+ * than as the per-file handle.
+ */
+#define I915_EXEC_HANDLE_LUT		(1<<12)
+
+#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_HANDLE_LUT<<1)
 
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \

commit ed5982e6ce5f106abcbf071f80730db344a6da42
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Thu Jan 17 22:23:36 2013 +0100

    drm/i915: Allow userspace to hint that the relocations were known
    
    Userspace is able to hint to the kernel that its command stream and
    auxiliary state buffers already hold the correct presumed addresses and
    so the relocation process may be skipped if the kernel does not need to
    move any buffers in preparation for the execbuffer. Thus for the common
    case where the allotment of buffers is static between batches, we can
    avoid the overhead of individually checking the relocation entries.
    
    Note that this requires userspace to supply the domain tracking and
    requests for workarounds itself that would otherwise be computed based
    upon the relocation entries.
    
    Using copywinwin10 as an example that is dependent upon emitting a lot
    of relocations (2 per operation), we see improvements of:
    
    c2d/gm45: 618000.0/sec to 632000.0/sec.
    i3-330m: 748000.0/sec to 830000.0/sec.
    
    (measured relative to a baseline with neither optimisations applied).
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    Reviewed-by: Imre Deak <imre.deak@intel.com>
    [danvet: Fixup merge conflict in userspace header due to different
    baseline trees.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index c4d2e9c74002..2430b6ad6a85 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -308,6 +308,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_RSVD_FOR_FUTURE_USE	 22
 #define I915_PARAM_HAS_SECURE_BATCHES	 23
 #define I915_PARAM_HAS_PINNED_BATCHES	 24
+#define I915_PARAM_HAS_EXEC_NO_RELOC	 25
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -628,7 +629,11 @@ struct drm_i915_gem_exec_object2 {
 	__u64 offset;
 
 #define EXEC_OBJECT_NEEDS_FENCE (1<<0)
+#define EXEC_OBJECT_NEEDS_GTT	(1<<1)
+#define EXEC_OBJECT_WRITE	(1<<2)
+#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_WRITE<<1)
 	__u64 flags;
+
 	__u64 rsvd1;
 	__u64 rsvd2;
 };
@@ -687,6 +692,15 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_IS_PINNED		(1<<10)
 
+/** Provide a hint to the kernel that the command stream and auxilliary
+ * state buffers already holds the correct presumed addresses and so the
+ * relocation process may be skipped if no buffers need to be moved in
+ * preparation for the execbuffer.
+ */
+#define I915_EXEC_NO_RELOC		(1<<11)
+
+#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_NO_RELOC<<1)
+
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \
 	(eb2).rsvd1 = context & I915_EXEC_CONTEXT_ID_MASK

commit b45305fce5bb1abec263fcff9d81ebecd6306ede
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Dec 17 16:21:27 2012 +0100

    drm/i915: Implement workaround for broken CS tlb on i830/845
    
    Now that Chris Wilson demonstrated that the key for stability on early
    gen 2 is to simple _never_ exchange the physical backing storage of
    batch buffers I've tried a stab at a kernel solution. Doesn't look too
    nefarious imho, now that I don't try to be too clever for my own good
    any more.
    
    v2: After discussing the various techniques, we've decided to always blit
    batches on the suspect devices, but allow userspace to opt out of the
    kernel workaround assume full responsibility for providing coherent
    batches. The principal reason is that avoiding the blit does improve
    performance in a few key microbenchmarks and also in cairo-trace
    replays.
    
    Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    [danvet:
    - Drop the hunk which uses HAS_BROKEN_CS_TLB to implement the ring
      wrap w/a. Suggested by Chris Wilson.
    - Also add the ACTHD check from Chris Wilson for the error state
      dumping, so that we still catch batches when userspace opts out of
      the w/a.]
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
index b746a3cf5fa9..c4d2e9c74002 100644
--- a/include/uapi/drm/i915_drm.h
+++ b/include/uapi/drm/i915_drm.h
@@ -307,6 +307,7 @@ typedef struct drm_i915_irq_wait {
 #define I915_PARAM_HAS_PRIME_VMAP_FLUSH	 21
 #define I915_PARAM_RSVD_FOR_FUTURE_USE	 22
 #define I915_PARAM_HAS_SECURE_BATCHES	 23
+#define I915_PARAM_HAS_PINNED_BATCHES	 24
 
 typedef struct drm_i915_getparam {
 	int param;
@@ -677,6 +678,15 @@ struct drm_i915_gem_execbuffer2 {
  */
 #define I915_EXEC_SECURE		(1<<9)
 
+/** Inform the kernel that the batch is and will always be pinned. This
+ * negates the requirement for a workaround to be performed to avoid
+ * an incoherent CS (such as can be found on 830/845). If this flag is
+ * not passed, the kernel will endeavour to make sure the batch is
+ * coherent with the CS before execution. If this flag is passed,
+ * userspace assumes the responsibility for ensuring the same.
+ */
+#define I915_EXEC_IS_PINNED		(1<<10)
+
 #define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
 #define i915_execbuffer2_set_context_id(eb2, context) \
 	(eb2).rsvd1 = context & I915_EXEC_CONTEXT_ID_MASK

commit c2fb7916927e989ea424e61ce5fe617e54878827
Merge: 29de6ce57487 6f0c0580b70c
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Mon Oct 22 14:34:51 2012 +0200

    Merge tag 'v3.7-rc2' into drm-intel-next-queued
    
    Linux 3.7-rc2
    
    Backmerge to solve two ugly conflicts:
    - uapi. We've already added new ioctl definitions for -next. Do I need to say more?
    - wc support gtt ptes. We've had to revert this for snb+ for 3.7 and
      also fix a few other things in the code. Now we know how to make it
      work on snb+, but to avoid losing the other fixes do the backmerge
      first before re-enabling wc gtt ptes on snb+.
    
    And a few other minor things, among them git getting confused in
    intel_dp.c and seemingly causing a conflict out of nothing ...
    
    Conflicts:
            drivers/gpu/drm/i915/i915_reg.h
            drivers/gpu/drm/i915/intel_display.c
            drivers/gpu/drm/i915/intel_dp.c
            drivers/gpu/drm/i915/intel_modes.c
            include/drm/i915_drm.h
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit 718dcedd7e87f448a1eeeda4d1a986284c243110
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 4 18:21:50 2012 +0100

    UAPI: (Scripted) Disintegrate include/drm
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h
new file mode 100644
index 000000000000..4322b1e7d2ed
--- /dev/null
+++ b/include/uapi/drm/i915_drm.h
@@ -0,0 +1,947 @@
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _UAPI_I915_DRM_H_
+#define _UAPI_I915_DRM_H_
+
+#include <drm/drm.h>
+
+/* Please note that modifications to all structs defined here are
+ * subject to backwards-compatibility constraints.
+ */
+
+
+/* Each region is a minimum of 16k, and there are at most 255 of them.
+ */
+#define I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use
+				 * of chars for next/prev indices */
+#define I915_LOG_MIN_TEX_REGION_SIZE 14
+
+typedef struct _drm_i915_init {
+	enum {
+		I915_INIT_DMA = 0x01,
+		I915_CLEANUP_DMA = 0x02,
+		I915_RESUME_DMA = 0x03
+	} func;
+	unsigned int mmio_offset;
+	int sarea_priv_offset;
+	unsigned int ring_start;
+	unsigned int ring_end;
+	unsigned int ring_size;
+	unsigned int front_offset;
+	unsigned int back_offset;
+	unsigned int depth_offset;
+	unsigned int w;
+	unsigned int h;
+	unsigned int pitch;
+	unsigned int pitch_bits;
+	unsigned int back_pitch;
+	unsigned int depth_pitch;
+	unsigned int cpp;
+	unsigned int chipset;
+} drm_i915_init_t;
+
+typedef struct _drm_i915_sarea {
+	struct drm_tex_region texList[I915_NR_TEX_REGIONS + 1];
+	int last_upload;	/* last time texture was uploaded */
+	int last_enqueue;	/* last time a buffer was enqueued */
+	int last_dispatch;	/* age of the most recently dispatched buffer */
+	int ctxOwner;		/* last context to upload state */
+	int texAge;
+	int pf_enabled;		/* is pageflipping allowed? */
+	int pf_active;
+	int pf_current_page;	/* which buffer is being displayed? */
+	int perf_boxes;		/* performance boxes to be displayed */
+	int width, height;      /* screen size in pixels */
+
+	drm_handle_t front_handle;
+	int front_offset;
+	int front_size;
+
+	drm_handle_t back_handle;
+	int back_offset;
+	int back_size;
+
+	drm_handle_t depth_handle;
+	int depth_offset;
+	int depth_size;
+
+	drm_handle_t tex_handle;
+	int tex_offset;
+	int tex_size;
+	int log_tex_granularity;
+	int pitch;
+	int rotation;           /* 0, 90, 180 or 270 */
+	int rotated_offset;
+	int rotated_size;
+	int rotated_pitch;
+	int virtualX, virtualY;
+
+	unsigned int front_tiled;
+	unsigned int back_tiled;
+	unsigned int depth_tiled;
+	unsigned int rotated_tiled;
+	unsigned int rotated2_tiled;
+
+	int pipeA_x;
+	int pipeA_y;
+	int pipeA_w;
+	int pipeA_h;
+	int pipeB_x;
+	int pipeB_y;
+	int pipeB_w;
+	int pipeB_h;
+
+	/* fill out some space for old userspace triple buffer */
+	drm_handle_t unused_handle;
+	__u32 unused1, unused2, unused3;
+
+	/* buffer object handles for static buffers. May change
+	 * over the lifetime of the client.
+	 */
+	__u32 front_bo_handle;
+	__u32 back_bo_handle;
+	__u32 unused_bo_handle;
+	__u32 depth_bo_handle;
+
+} drm_i915_sarea_t;
+
+/* due to userspace building against these headers we need some compat here */
+#define planeA_x pipeA_x
+#define planeA_y pipeA_y
+#define planeA_w pipeA_w
+#define planeA_h pipeA_h
+#define planeB_x pipeB_x
+#define planeB_y pipeB_y
+#define planeB_w pipeB_w
+#define planeB_h pipeB_h
+
+/* Flags for perf_boxes
+ */
+#define I915_BOX_RING_EMPTY    0x1
+#define I915_BOX_FLIP          0x2
+#define I915_BOX_WAIT          0x4
+#define I915_BOX_TEXTURE_LOAD  0x8
+#define I915_BOX_LOST_CONTEXT  0x10
+
+/* I915 specific ioctls
+ * The device specific ioctl range is 0x40 to 0x79.
+ */
+#define DRM_I915_INIT		0x00
+#define DRM_I915_FLUSH		0x01
+#define DRM_I915_FLIP		0x02
+#define DRM_I915_BATCHBUFFER	0x03
+#define DRM_I915_IRQ_EMIT	0x04
+#define DRM_I915_IRQ_WAIT	0x05
+#define DRM_I915_GETPARAM	0x06
+#define DRM_I915_SETPARAM	0x07
+#define DRM_I915_ALLOC		0x08
+#define DRM_I915_FREE		0x09
+#define DRM_I915_INIT_HEAP	0x0a
+#define DRM_I915_CMDBUFFER	0x0b
+#define DRM_I915_DESTROY_HEAP	0x0c
+#define DRM_I915_SET_VBLANK_PIPE	0x0d
+#define DRM_I915_GET_VBLANK_PIPE	0x0e
+#define DRM_I915_VBLANK_SWAP	0x0f
+#define DRM_I915_HWS_ADDR	0x11
+#define DRM_I915_GEM_INIT	0x13
+#define DRM_I915_GEM_EXECBUFFER	0x14
+#define DRM_I915_GEM_PIN	0x15
+#define DRM_I915_GEM_UNPIN	0x16
+#define DRM_I915_GEM_BUSY	0x17
+#define DRM_I915_GEM_THROTTLE	0x18
+#define DRM_I915_GEM_ENTERVT	0x19
+#define DRM_I915_GEM_LEAVEVT	0x1a
+#define DRM_I915_GEM_CREATE	0x1b
+#define DRM_I915_GEM_PREAD	0x1c
+#define DRM_I915_GEM_PWRITE	0x1d
+#define DRM_I915_GEM_MMAP	0x1e
+#define DRM_I915_GEM_SET_DOMAIN	0x1f
+#define DRM_I915_GEM_SW_FINISH	0x20
+#define DRM_I915_GEM_SET_TILING	0x21
+#define DRM_I915_GEM_GET_TILING	0x22
+#define DRM_I915_GEM_GET_APERTURE 0x23
+#define DRM_I915_GEM_MMAP_GTT	0x24
+#define DRM_I915_GET_PIPE_FROM_CRTC_ID	0x25
+#define DRM_I915_GEM_MADVISE	0x26
+#define DRM_I915_OVERLAY_PUT_IMAGE	0x27
+#define DRM_I915_OVERLAY_ATTRS	0x28
+#define DRM_I915_GEM_EXECBUFFER2	0x29
+#define DRM_I915_GET_SPRITE_COLORKEY	0x2a
+#define DRM_I915_SET_SPRITE_COLORKEY	0x2b
+#define DRM_I915_GEM_WAIT	0x2c
+#define DRM_I915_GEM_CONTEXT_CREATE	0x2d
+#define DRM_I915_GEM_CONTEXT_DESTROY	0x2e
+#define DRM_I915_GEM_SET_CACHING	0x2f
+#define DRM_I915_GEM_GET_CACHING	0x30
+#define DRM_I915_REG_READ		0x31
+
+#define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
+#define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
+#define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)
+#define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)
+#define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)
+#define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)
+#define DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)
+#define DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)
+#define DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)
+#define DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_free_t)
+#define DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)
+#define DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)
+#define DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)
+#define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
+#define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
+#define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)
+#define DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_HWS_ADDR, struct drm_i915_gem_init)
+#define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)
+#define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)
+#define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)
+#define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)
+#define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)
+#define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)
+#define DRM_IOCTL_I915_GEM_SET_CACHING		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_SET_CACHING, struct drm_i915_gem_caching)
+#define DRM_IOCTL_I915_GEM_GET_CACHING		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_GET_CACHING, struct drm_i915_gem_caching)
+#define DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)
+#define DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)
+#define DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)
+#define DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, struct drm_i915_gem_create)
+#define DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, struct drm_i915_gem_pread)
+#define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)
+#define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)
+#define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)
+#define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)
+#define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)
+#define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)
+#define DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, struct drm_i915_gem_get_tiling)
+#define DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, struct drm_i915_gem_get_aperture)
+#define DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, struct drm_i915_get_pipe_from_crtc_id)
+#define DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, struct drm_i915_gem_madvise)
+#define DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, struct drm_intel_overlay_put_image)
+#define DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, struct drm_intel_overlay_attrs)
+#define DRM_IOCTL_I915_SET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
+#define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
+#define DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, struct drm_i915_gem_wait)
+#define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)
+#define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
+#define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
+
+/* Allow drivers to submit batchbuffers directly to hardware, relying
+ * on the security mechanisms provided by hardware.
+ */
+typedef struct drm_i915_batchbuffer {
+	int start;		/* agp offset */
+	int used;		/* nr bytes in use */
+	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
+	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
+	int num_cliprects;	/* mulitpass with multiple cliprects? */
+	struct drm_clip_rect __user *cliprects;	/* pointer to userspace cliprects */
+} drm_i915_batchbuffer_t;
+
+/* As above, but pass a pointer to userspace buffer which can be
+ * validated by the kernel prior to sending to hardware.
+ */
+typedef struct _drm_i915_cmdbuffer {
+	char __user *buf;	/* pointer to userspace command buffer */
+	int sz;			/* nr bytes in buf */
+	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
+	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
+	int num_cliprects;	/* mulitpass with multiple cliprects? */
+	struct drm_clip_rect __user *cliprects;	/* pointer to userspace cliprects */
+} drm_i915_cmdbuffer_t;
+
+/* Userspace can request & wait on irq's:
+ */
+typedef struct drm_i915_irq_emit {
+	int __user *irq_seq;
+} drm_i915_irq_emit_t;
+
+typedef struct drm_i915_irq_wait {
+	int irq_seq;
+} drm_i915_irq_wait_t;
+
+/* Ioctl to query kernel params:
+ */
+#define I915_PARAM_IRQ_ACTIVE            1
+#define I915_PARAM_ALLOW_BATCHBUFFER     2
+#define I915_PARAM_LAST_DISPATCH         3
+#define I915_PARAM_CHIPSET_ID            4
+#define I915_PARAM_HAS_GEM               5
+#define I915_PARAM_NUM_FENCES_AVAIL      6
+#define I915_PARAM_HAS_OVERLAY           7
+#define I915_PARAM_HAS_PAGEFLIPPING	 8
+#define I915_PARAM_HAS_EXECBUF2          9
+#define I915_PARAM_HAS_BSD		 10
+#define I915_PARAM_HAS_BLT		 11
+#define I915_PARAM_HAS_RELAXED_FENCING	 12
+#define I915_PARAM_HAS_COHERENT_RINGS	 13
+#define I915_PARAM_HAS_EXEC_CONSTANTS	 14
+#define I915_PARAM_HAS_RELAXED_DELTA	 15
+#define I915_PARAM_HAS_GEN7_SOL_RESET	 16
+#define I915_PARAM_HAS_LLC     	 	 17
+#define I915_PARAM_HAS_ALIASING_PPGTT	 18
+#define I915_PARAM_HAS_WAIT_TIMEOUT	 19
+#define I915_PARAM_HAS_SEMAPHORES	 20
+#define I915_PARAM_HAS_PRIME_VMAP_FLUSH	 21
+#define I915_PARAM_RSVD_FOR_FUTURE_USE	 22
+
+typedef struct drm_i915_getparam {
+	int param;
+	int __user *value;
+} drm_i915_getparam_t;
+
+/* Ioctl to set kernel params:
+ */
+#define I915_SETPARAM_USE_MI_BATCHBUFFER_START            1
+#define I915_SETPARAM_TEX_LRU_LOG_GRANULARITY             2
+#define I915_SETPARAM_ALLOW_BATCHBUFFER                   3
+#define I915_SETPARAM_NUM_USED_FENCES                     4
+
+typedef struct drm_i915_setparam {
+	int param;
+	int value;
+} drm_i915_setparam_t;
+
+/* A memory manager for regions of shared memory:
+ */
+#define I915_MEM_REGION_AGP 1
+
+typedef struct drm_i915_mem_alloc {
+	int region;
+	int alignment;
+	int size;
+	int __user *region_offset;	/* offset from start of fb or agp */
+} drm_i915_mem_alloc_t;
+
+typedef struct drm_i915_mem_free {
+	int region;
+	int region_offset;
+} drm_i915_mem_free_t;
+
+typedef struct drm_i915_mem_init_heap {
+	int region;
+	int size;
+	int start;
+} drm_i915_mem_init_heap_t;
+
+/* Allow memory manager to be torn down and re-initialized (eg on
+ * rotate):
+ */
+typedef struct drm_i915_mem_destroy_heap {
+	int region;
+} drm_i915_mem_destroy_heap_t;
+
+/* Allow X server to configure which pipes to monitor for vblank signals
+ */
+#define	DRM_I915_VBLANK_PIPE_A	1
+#define	DRM_I915_VBLANK_PIPE_B	2
+
+typedef struct drm_i915_vblank_pipe {
+	int pipe;
+} drm_i915_vblank_pipe_t;
+
+/* Schedule buffer swap at given vertical blank:
+ */
+typedef struct drm_i915_vblank_swap {
+	drm_drawable_t drawable;
+	enum drm_vblank_seq_type seqtype;
+	unsigned int sequence;
+} drm_i915_vblank_swap_t;
+
+typedef struct drm_i915_hws_addr {
+	__u64 addr;
+} drm_i915_hws_addr_t;
+
+struct drm_i915_gem_init {
+	/**
+	 * Beginning offset in the GTT to be managed by the DRM memory
+	 * manager.
+	 */
+	__u64 gtt_start;
+	/**
+	 * Ending offset in the GTT to be managed by the DRM memory
+	 * manager.
+	 */
+	__u64 gtt_end;
+};
+
+struct drm_i915_gem_create {
+	/**
+	 * Requested size for the object.
+	 *
+	 * The (page-aligned) allocated size for the object will be returned.
+	 */
+	__u64 size;
+	/**
+	 * Returned handle for the object.
+	 *
+	 * Object handles are nonzero.
+	 */
+	__u32 handle;
+	__u32 pad;
+};
+
+struct drm_i915_gem_pread {
+	/** Handle for the object being read. */
+	__u32 handle;
+	__u32 pad;
+	/** Offset into the object to read from */
+	__u64 offset;
+	/** Length of data to read */
+	__u64 size;
+	/**
+	 * Pointer to write the data into.
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 data_ptr;
+};
+
+struct drm_i915_gem_pwrite {
+	/** Handle for the object being written to. */
+	__u32 handle;
+	__u32 pad;
+	/** Offset into the object to write to */
+	__u64 offset;
+	/** Length of data to write */
+	__u64 size;
+	/**
+	 * Pointer to read the data from.
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 data_ptr;
+};
+
+struct drm_i915_gem_mmap {
+	/** Handle for the object being mapped. */
+	__u32 handle;
+	__u32 pad;
+	/** Offset in the object to map. */
+	__u64 offset;
+	/**
+	 * Length of data to map.
+	 *
+	 * The value will be page-aligned.
+	 */
+	__u64 size;
+	/**
+	 * Returned pointer the data was mapped at.
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 addr_ptr;
+};
+
+struct drm_i915_gem_mmap_gtt {
+	/** Handle for the object being mapped. */
+	__u32 handle;
+	__u32 pad;
+	/**
+	 * Fake offset to use for subsequent mmap call
+	 *
+	 * This is a fixed-size type for 32/64 compatibility.
+	 */
+	__u64 offset;
+};
+
+struct drm_i915_gem_set_domain {
+	/** Handle for the object */
+	__u32 handle;
+
+	/** New read domains */
+	__u32 read_domains;
+
+	/** New write domain */
+	__u32 write_domain;
+};
+
+struct drm_i915_gem_sw_finish {
+	/** Handle for the object */
+	__u32 handle;
+};
+
+struct drm_i915_gem_relocation_entry {
+	/**
+	 * Handle of the buffer being pointed to by this relocation entry.
+	 *
+	 * It's appealing to make this be an index into the mm_validate_entry
+	 * list to refer to the buffer, but this allows the driver to create
+	 * a relocation list for state buffers and not re-write it per
+	 * exec using the buffer.
+	 */
+	__u32 target_handle;
+
+	/**
+	 * Value to be added to the offset of the target buffer to make up
+	 * the relocation entry.
+	 */
+	__u32 delta;
+
+	/** Offset in the buffer the relocation entry will be written into */
+	__u64 offset;
+
+	/**
+	 * Offset value of the target buffer that the relocation entry was last
+	 * written as.
+	 *
+	 * If the buffer has the same offset as last time, we can skip syncing
+	 * and writing the relocation.  This value is written back out by
+	 * the execbuffer ioctl when the relocation is written.
+	 */
+	__u64 presumed_offset;
+
+	/**
+	 * Target memory domains read by this operation.
+	 */
+	__u32 read_domains;
+
+	/**
+	 * Target memory domains written by this operation.
+	 *
+	 * Note that only one domain may be written by the whole
+	 * execbuffer operation, so that where there are conflicts,
+	 * the application will get -EINVAL back.
+	 */
+	__u32 write_domain;
+};
+
+/** @{
+ * Intel memory domains
+ *
+ * Most of these just align with the various caches in
+ * the system and are used to flush and invalidate as
+ * objects end up cached in different domains.
+ */
+/** CPU cache */
+#define I915_GEM_DOMAIN_CPU		0x00000001
+/** Render cache, used by 2D and 3D drawing */
+#define I915_GEM_DOMAIN_RENDER		0x00000002
+/** Sampler cache, used by texture engine */
+#define I915_GEM_DOMAIN_SAMPLER		0x00000004
+/** Command queue, used to load batch buffers */
+#define I915_GEM_DOMAIN_COMMAND		0x00000008
+/** Instruction cache, used by shader programs */
+#define I915_GEM_DOMAIN_INSTRUCTION	0x00000010
+/** Vertex address cache */
+#define I915_GEM_DOMAIN_VERTEX		0x00000020
+/** GTT domain - aperture and scanout */
+#define I915_GEM_DOMAIN_GTT		0x00000040
+/** @} */
+
+struct drm_i915_gem_exec_object {
+	/**
+	 * User's handle for a buffer to be bound into the GTT for this
+	 * operation.
+	 */
+	__u32 handle;
+
+	/** Number of relocations to be performed on this buffer */
+	__u32 relocation_count;
+	/**
+	 * Pointer to array of struct drm_i915_gem_relocation_entry containing
+	 * the relocations to be performed in this buffer.
+	 */
+	__u64 relocs_ptr;
+
+	/** Required alignment in graphics aperture */
+	__u64 alignment;
+
+	/**
+	 * Returned value of the updated offset of the object, for future
+	 * presumed_offset writes.
+	 */
+	__u64 offset;
+};
+
+struct drm_i915_gem_execbuffer {
+	/**
+	 * List of buffers to be validated with their relocations to be
+	 * performend on them.
+	 *
+	 * This is a pointer to an array of struct drm_i915_gem_validate_entry.
+	 *
+	 * These buffers must be listed in an order such that all relocations
+	 * a buffer is performing refer to buffers that have already appeared
+	 * in the validate list.
+	 */
+	__u64 buffers_ptr;
+	__u32 buffer_count;
+
+	/** Offset in the batchbuffer to start execution from. */
+	__u32 batch_start_offset;
+	/** Bytes used in batchbuffer from batch_start_offset */
+	__u32 batch_len;
+	__u32 DR1;
+	__u32 DR4;
+	__u32 num_cliprects;
+	/** This is a struct drm_clip_rect *cliprects */
+	__u64 cliprects_ptr;
+};
+
+struct drm_i915_gem_exec_object2 {
+	/**
+	 * User's handle for a buffer to be bound into the GTT for this
+	 * operation.
+	 */
+	__u32 handle;
+
+	/** Number of relocations to be performed on this buffer */
+	__u32 relocation_count;
+	/**
+	 * Pointer to array of struct drm_i915_gem_relocation_entry containing
+	 * the relocations to be performed in this buffer.
+	 */
+	__u64 relocs_ptr;
+
+	/** Required alignment in graphics aperture */
+	__u64 alignment;
+
+	/**
+	 * Returned value of the updated offset of the object, for future
+	 * presumed_offset writes.
+	 */
+	__u64 offset;
+
+#define EXEC_OBJECT_NEEDS_FENCE (1<<0)
+	__u64 flags;
+	__u64 rsvd1;
+	__u64 rsvd2;
+};
+
+struct drm_i915_gem_execbuffer2 {
+	/**
+	 * List of gem_exec_object2 structs
+	 */
+	__u64 buffers_ptr;
+	__u32 buffer_count;
+
+	/** Offset in the batchbuffer to start execution from. */
+	__u32 batch_start_offset;
+	/** Bytes used in batchbuffer from batch_start_offset */
+	__u32 batch_len;
+	__u32 DR1;
+	__u32 DR4;
+	__u32 num_cliprects;
+	/** This is a struct drm_clip_rect *cliprects */
+	__u64 cliprects_ptr;
+#define I915_EXEC_RING_MASK              (7<<0)
+#define I915_EXEC_DEFAULT                (0<<0)
+#define I915_EXEC_RENDER                 (1<<0)
+#define I915_EXEC_BSD                    (2<<0)
+#define I915_EXEC_BLT                    (3<<0)
+
+/* Used for switching the constants addressing mode on gen4+ RENDER ring.
+ * Gen6+ only supports relative addressing to dynamic state (default) and
+ * absolute addressing.
+ *
+ * These flags are ignored for the BSD and BLT rings.
+ */
+#define I915_EXEC_CONSTANTS_MASK 	(3<<6)
+#define I915_EXEC_CONSTANTS_REL_GENERAL (0<<6) /* default */
+#define I915_EXEC_CONSTANTS_ABSOLUTE 	(1<<6)
+#define I915_EXEC_CONSTANTS_REL_SURFACE (2<<6) /* gen4/5 only */
+	__u64 flags;
+	__u64 rsvd1; /* now used for context info */
+	__u64 rsvd2;
+};
+
+/** Resets the SO write offset registers for transform feedback on gen7. */
+#define I915_EXEC_GEN7_SOL_RESET	(1<<8)
+
+#define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
+#define i915_execbuffer2_set_context_id(eb2, context) \
+	(eb2).rsvd1 = context & I915_EXEC_CONTEXT_ID_MASK
+#define i915_execbuffer2_get_context_id(eb2) \
+	((eb2).rsvd1 & I915_EXEC_CONTEXT_ID_MASK)
+
+struct drm_i915_gem_pin {
+	/** Handle of the buffer to be pinned. */
+	__u32 handle;
+	__u32 pad;
+
+	/** alignment required within the aperture */
+	__u64 alignment;
+
+	/** Returned GTT offset of the buffer. */
+	__u64 offset;
+};
+
+struct drm_i915_gem_unpin {
+	/** Handle of the buffer to be unpinned. */
+	__u32 handle;
+	__u32 pad;
+};
+
+struct drm_i915_gem_busy {
+	/** Handle of the buffer to check for busy */
+	__u32 handle;
+
+	/** Return busy status (1 if busy, 0 if idle).
+	 * The high word is used to indicate on which rings the object
+	 * currently resides:
+	 *  16:31 - busy (r or r/w) rings (16 render, 17 bsd, 18 blt, etc)
+	 */
+	__u32 busy;
+};
+
+#define I915_CACHING_NONE		0
+#define I915_CACHING_CACHED		1
+
+struct drm_i915_gem_caching {
+	/**
+	 * Handle of the buffer to set/get the caching level of. */
+	__u32 handle;
+
+	/**
+	 * Cacheing level to apply or return value
+	 *
+	 * bits0-15 are for generic caching control (i.e. the above defined
+	 * values). bits16-31 are reserved for platform-specific variations
+	 * (e.g. l3$ caching on gen7). */
+	__u32 caching;
+};
+
+#define I915_TILING_NONE	0
+#define I915_TILING_X		1
+#define I915_TILING_Y		2
+
+#define I915_BIT_6_SWIZZLE_NONE		0
+#define I915_BIT_6_SWIZZLE_9		1
+#define I915_BIT_6_SWIZZLE_9_10		2
+#define I915_BIT_6_SWIZZLE_9_11		3
+#define I915_BIT_6_SWIZZLE_9_10_11	4
+/* Not seen by userland */
+#define I915_BIT_6_SWIZZLE_UNKNOWN	5
+/* Seen by userland. */
+#define I915_BIT_6_SWIZZLE_9_17		6
+#define I915_BIT_6_SWIZZLE_9_10_17	7
+
+struct drm_i915_gem_set_tiling {
+	/** Handle of the buffer to have its tiling state updated */
+	__u32 handle;
+
+	/**
+	 * Tiling mode for the object (I915_TILING_NONE, I915_TILING_X,
+	 * I915_TILING_Y).
+	 *
+	 * This value is to be set on request, and will be updated by the
+	 * kernel on successful return with the actual chosen tiling layout.
+	 *
+	 * The tiling mode may be demoted to I915_TILING_NONE when the system
+	 * has bit 6 swizzling that can't be managed correctly by GEM.
+	 *
+	 * Buffer contents become undefined when changing tiling_mode.
+	 */
+	__u32 tiling_mode;
+
+	/**
+	 * Stride in bytes for the object when in I915_TILING_X or
+	 * I915_TILING_Y.
+	 */
+	__u32 stride;
+
+	/**
+	 * Returned address bit 6 swizzling required for CPU access through
+	 * mmap mapping.
+	 */
+	__u32 swizzle_mode;
+};
+
+struct drm_i915_gem_get_tiling {
+	/** Handle of the buffer to get tiling state for. */
+	__u32 handle;
+
+	/**
+	 * Current tiling mode for the object (I915_TILING_NONE, I915_TILING_X,
+	 * I915_TILING_Y).
+	 */
+	__u32 tiling_mode;
+
+	/**
+	 * Returned address bit 6 swizzling required for CPU access through
+	 * mmap mapping.
+	 */
+	__u32 swizzle_mode;
+};
+
+struct drm_i915_gem_get_aperture {
+	/** Total size of the aperture used by i915_gem_execbuffer, in bytes */
+	__u64 aper_size;
+
+	/**
+	 * Available space in the aperture used by i915_gem_execbuffer, in
+	 * bytes
+	 */
+	__u64 aper_available_size;
+};
+
+struct drm_i915_get_pipe_from_crtc_id {
+	/** ID of CRTC being requested **/
+	__u32 crtc_id;
+
+	/** pipe of requested CRTC **/
+	__u32 pipe;
+};
+
+#define I915_MADV_WILLNEED 0
+#define I915_MADV_DONTNEED 1
+#define __I915_MADV_PURGED 2 /* internal state */
+
+struct drm_i915_gem_madvise {
+	/** Handle of the buffer to change the backing store advice */
+	__u32 handle;
+
+	/* Advice: either the buffer will be needed again in the near future,
+	 *         or wont be and could be discarded under memory pressure.
+	 */
+	__u32 madv;
+
+	/** Whether the backing store still exists. */
+	__u32 retained;
+};
+
+/* flags */
+#define I915_OVERLAY_TYPE_MASK 		0xff
+#define I915_OVERLAY_YUV_PLANAR 	0x01
+#define I915_OVERLAY_YUV_PACKED 	0x02
+#define I915_OVERLAY_RGB		0x03
+
+#define I915_OVERLAY_DEPTH_MASK		0xff00
+#define I915_OVERLAY_RGB24		0x1000
+#define I915_OVERLAY_RGB16		0x2000
+#define I915_OVERLAY_RGB15		0x3000
+#define I915_OVERLAY_YUV422		0x0100
+#define I915_OVERLAY_YUV411		0x0200
+#define I915_OVERLAY_YUV420		0x0300
+#define I915_OVERLAY_YUV410		0x0400
+
+#define I915_OVERLAY_SWAP_MASK		0xff0000
+#define I915_OVERLAY_NO_SWAP		0x000000
+#define I915_OVERLAY_UV_SWAP		0x010000
+#define I915_OVERLAY_Y_SWAP		0x020000
+#define I915_OVERLAY_Y_AND_UV_SWAP	0x030000
+
+#define I915_OVERLAY_FLAGS_MASK		0xff000000
+#define I915_OVERLAY_ENABLE		0x01000000
+
+struct drm_intel_overlay_put_image {
+	/* various flags and src format description */
+	__u32 flags;
+	/* source picture description */
+	__u32 bo_handle;
+	/* stride values and offsets are in bytes, buffer relative */
+	__u16 stride_Y; /* stride for packed formats */
+	__u16 stride_UV;
+	__u32 offset_Y; /* offset for packet formats */
+	__u32 offset_U;
+	__u32 offset_V;
+	/* in pixels */
+	__u16 src_width;
+	__u16 src_height;
+	/* to compensate the scaling factors for partially covered surfaces */
+	__u16 src_scan_width;
+	__u16 src_scan_height;
+	/* output crtc description */
+	__u32 crtc_id;
+	__u16 dst_x;
+	__u16 dst_y;
+	__u16 dst_width;
+	__u16 dst_height;
+};
+
+/* flags */
+#define I915_OVERLAY_UPDATE_ATTRS	(1<<0)
+#define I915_OVERLAY_UPDATE_GAMMA	(1<<1)
+struct drm_intel_overlay_attrs {
+	__u32 flags;
+	__u32 color_key;
+	__s32 brightness;
+	__u32 contrast;
+	__u32 saturation;
+	__u32 gamma0;
+	__u32 gamma1;
+	__u32 gamma2;
+	__u32 gamma3;
+	__u32 gamma4;
+	__u32 gamma5;
+};
+
+/*
+ * Intel sprite handling
+ *
+ * Color keying works with a min/mask/max tuple.  Both source and destination
+ * color keying is allowed.
+ *
+ * Source keying:
+ * Sprite pixels within the min & max values, masked against the color channels
+ * specified in the mask field, will be transparent.  All other pixels will
+ * be displayed on top of the primary plane.  For RGB surfaces, only the min
+ * and mask fields will be used; ranged compares are not allowed.
+ *
+ * Destination keying:
+ * Primary plane pixels that match the min value, masked against the color
+ * channels specified in the mask field, will be replaced by corresponding
+ * pixels from the sprite plane.
+ *
+ * Note that source & destination keying are exclusive; only one can be
+ * active on a given plane.
+ */
+
+#define I915_SET_COLORKEY_NONE		(1<<0) /* disable color key matching */
+#define I915_SET_COLORKEY_DESTINATION	(1<<1)
+#define I915_SET_COLORKEY_SOURCE	(1<<2)
+struct drm_intel_sprite_colorkey {
+	__u32 plane_id;
+	__u32 min_value;
+	__u32 channel_mask;
+	__u32 max_value;
+	__u32 flags;
+};
+
+struct drm_i915_gem_wait {
+	/** Handle of BO we shall wait on */
+	__u32 bo_handle;
+	__u32 flags;
+	/** Number of nanoseconds to wait, Returns time remaining. */
+	__s64 timeout_ns;
+};
+
+struct drm_i915_gem_context_create {
+	/*  output: id of new context*/
+	__u32 ctx_id;
+	__u32 pad;
+};
+
+struct drm_i915_gem_context_destroy {
+	__u32 ctx_id;
+	__u32 pad;
+};
+
+struct drm_i915_reg_read {
+	__u64 offset;
+	__u64 val; /* Return value */
+};
+#endif /* _UAPI_I915_DRM_H_ */
