commit b1db551324f72fa14ad82ca31237a7ed418104df
Author: Christophe Lombard <clombard@linux.vnet.ibm.com>
Date:   Thu Jan 11 09:55:25 2018 +0100

    cxl: Add support for ASB_Notify on POWER9
    
    The POWER9 core supports a new feature: ASB_Notify which requires the
    support of the Special Purpose Register: TIDR.
    
    The ASB_Notify command, generated by the AFU, will attempt to
    wake-up the host thread identified by the particular LPID:PID:TID.
    
    This patch assign a unique TIDR (thread id) for the current thread which
    will be used in the process element entry.
    
    Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
    Reviewed-by: Philippe Bergheaud <felix@linux.vnet.ibm.com>
    Acked-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Reviewed-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
    Acked-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index 49e8fd08855a..56376d3907d8 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -20,20 +20,22 @@ struct cxl_ioctl_start_work {
 	__u64 work_element_descriptor;
 	__u64 amr;
 	__s16 num_interrupts;
-	__s16 reserved1;
-	__s32 reserved2;
+	__u16 tid;
+	__s32 reserved1;
+	__u64 reserved2;
 	__u64 reserved3;
 	__u64 reserved4;
 	__u64 reserved5;
-	__u64 reserved6;
 };
 
 #define CXL_START_WORK_AMR		0x0000000000000001ULL
 #define CXL_START_WORK_NUM_IRQS		0x0000000000000002ULL
 #define CXL_START_WORK_ERR_FF		0x0000000000000004ULL
+#define CXL_START_WORK_TID		0x0000000000000008ULL
 #define CXL_START_WORK_ALL		(CXL_START_WORK_AMR |\
 					 CXL_START_WORK_NUM_IRQS |\
-					 CXL_START_WORK_ERR_FF)
+					 CXL_START_WORK_ERR_FF |\
+					 CXL_START_WORK_TID)
 
 
 /* Possible modes that an afu can be in */

commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index 180d526a55c3..49e8fd08855a 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
 /*
  * Copyright 2014 IBM Corp.
  *

commit cbd74e1bc8129efb9908f130a8a6e60fd95d2106
Author: Philippe Bergheaud <felix@linux.vnet.ibm.com>
Date:   Fri Aug 5 14:02:00 2016 +0200

    cxl: Use fixed width predefined types in data structure.
    
    This patch fixes a regression introduced by commit b810253bd934 ("cxl:
    Add mechanism for delivering AFU driver specific events").
    
    It changes the type u8 to __u8 in the uapi header cxl.h, because the
    former is a kernel internal type, and may not be defined in userland
    build environments, in particular when cross-compiling libcxl on x86_64
    linux machines (RHEL6.7 and Ubuntu 16.04).
    
    This patch also changes the size of the field data_size, and makes it
    constant, to support 32-bit userland applications running on big-endian
    ppc64 kernels transparently.
    
    mpe: This is an ABI change, however the ABI was only added during the
    4.8 merge window so has never been part of a released kernel - therefore
    we give ourselves permission to change it.
    
    Fixes: b810253bd934 ("cxl: Add mechanism for delivering AFU driver specific events")
    Signed-off-by: Philippe Bergheaud <felix@linux.vnet.ibm.com>
    Reviewed-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index cbae529b7ce0..180d526a55c3 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -136,8 +136,8 @@ struct cxl_event_afu_driver_reserved {
 	 *
 	 * Of course the contents will be ABI, but that's up the AFU driver.
 	 */
-	size_t data_size;
-	u8 data[];
+	__u32 data_size;
+	__u8 data[];
 };
 
 struct cxl_event {

commit b810253bd9342f863a86ec7dfff4a5a7a0394d2f
Author: Philippe Bergheaud <felix@linux.vnet.ibm.com>
Date:   Thu Jun 23 15:03:53 2016 +0200

    cxl: Add mechanism for delivering AFU driver specific events
    
    This adds an afu_driver_ops structure with fetch_event() and
    event_delivered() callbacks. An AFU driver such as cxlflash can fill
    this out and associate it with a context to enable passing custom AFU
    specific events to userspace.
    
    This also adds a new kernel API function cxl_context_pending_events(),
    that the AFU driver can use to notify the cxl driver that new specific
    events are ready to be delivered, and wake up anyone waiting on the
    context wait queue.
    
    The current count of AFU driver specific events is stored in the field
    afu_driver_events of the context structure.
    
    The cxl driver checks the afu_driver_events count during poll, select,
    read, etc. calls to check if an AFU driver specific event is pending,
    and calls fetch_event() to obtain and deliver that event. This way, the
    cxl driver takes care of all the usual locking semantics around these
    calls and handles all the generic cxl events, so that the AFU driver
    only needs to worry about it's own events.
    
    fetch_event() return a struct cxl_event_afu_driver_reserved, allocated
    by the AFU driver, and filled in with the specific event information and
    size. Total event size (header + data) should not be greater than
    CXL_READ_MIN_SIZE (4K).
    
    Th cxl driver prepends an appropriate cxl event header, copies the event
    to userspace, and finally calls event_delivered() to return the status of
    the operation to the AFU driver. The event is identified by the context
    and cxl_event_afu_driver_reserved pointers.
    
    Since AFU drivers provide their own means for userspace to obtain the
    AFU file descriptor (i.e. cxlflash uses an ioctl on their scsi file
    descriptor to obtain the AFU file descriptor) and the generic cxl driver
    will never use this event, the ABI of the event is up to each individual
    AFU driver.
    
    Signed-off-by: Philippe Bergheaud <felix@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index 8cd334f99ddc..cbae529b7ce0 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -93,6 +93,7 @@ enum cxl_event_type {
 	CXL_EVENT_AFU_INTERRUPT = 1,
 	CXL_EVENT_DATA_STORAGE  = 2,
 	CXL_EVENT_AFU_ERROR     = 3,
+	CXL_EVENT_AFU_DRIVER    = 4,
 };
 
 struct cxl_event_header {
@@ -124,12 +125,28 @@ struct cxl_event_afu_error {
 	__u64 error;
 };
 
+struct cxl_event_afu_driver_reserved {
+	/*
+	 * Defines the buffer passed to the cxl driver by the AFU driver.
+	 *
+	 * This is not ABI since the event header.size passed to the user for
+	 * existing events is set in the read call to sizeof(cxl_event_header)
+	 * + sizeof(whatever event is being dispatched) and the user is already
+	 * required to use a 4K buffer on the read call.
+	 *
+	 * Of course the contents will be ABI, but that's up the AFU driver.
+	 */
+	size_t data_size;
+	u8 data[];
+};
+
 struct cxl_event {
 	struct cxl_event_header header;
 	union {
 		struct cxl_event_afu_interrupt irq;
 		struct cxl_event_data_storage fault;
 		struct cxl_event_afu_error afu_error;
+		struct cxl_event_afu_driver_reserved afu_driver_event;
 	};
 };
 

commit 594ff7d067ca42676e27e2a7b5dcc0ff039d08ca
Author: Christophe Lombard <clombard@linux.vnet.ibm.com>
Date:   Fri Mar 4 12:26:38 2016 +0100

    cxl: Support to flash a new image on the adapter from a guest
    
    The new flash.c file contains the logic to flash a new image on the
    adapter, through a hcall. It is an iterative process, with chunks of
    data of 1M at a time. There are also 2 phases: write and verify. The
    flash operation itself is driven from a user-land tool.
    Once flashing is successful, an rtas call is made to update the device
    tree with the new properties values for the adapter and the AFU(s)
    
    Add a new char device for the adapter, so that the flash tool can
    access the card, even if there is no valid AFU on it.
    
    Co-authored-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Christophe Lombard <clombard@linux.vnet.ibm.com>
    Reviewed-by: Manoj Kumar <manoj@linux.vnet.ibm.com>
    Acked-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index 1e889aa8a36e..8cd334f99ddc 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -55,11 +55,35 @@ struct cxl_afu_id {
 	__u64 reserved6;
 };
 
+/* base adapter image header is included in the image */
+#define CXL_AI_NEED_HEADER	0x0000000000000001ULL
+#define CXL_AI_ALL		CXL_AI_NEED_HEADER
+
+#define CXL_AI_HEADER_SIZE 128
+#define CXL_AI_BUFFER_SIZE 4096
+#define CXL_AI_MAX_ENTRIES 256
+#define CXL_AI_MAX_CHUNK_SIZE (CXL_AI_BUFFER_SIZE * CXL_AI_MAX_ENTRIES)
+
+struct cxl_adapter_image {
+	__u64 flags;
+	__u64 data;
+	__u64 len_data;
+	__u64 len_image;
+	__u64 reserved1;
+	__u64 reserved2;
+	__u64 reserved3;
+	__u64 reserved4;
+};
+
 /* ioctl numbers */
 #define CXL_MAGIC 0xCA
+/* AFU devices */
 #define CXL_IOCTL_START_WORK		_IOW(CXL_MAGIC, 0x00, struct cxl_ioctl_start_work)
 #define CXL_IOCTL_GET_PROCESS_ELEMENT	_IOR(CXL_MAGIC, 0x01, __u32)
 #define CXL_IOCTL_GET_AFU_ID            _IOR(CXL_MAGIC, 0x02, struct cxl_afu_id)
+/* adapter devices */
+#define CXL_IOCTL_DOWNLOAD_IMAGE        _IOW(CXL_MAGIC, 0x0A, struct cxl_adapter_image)
+#define CXL_IOCTL_VALIDATE_IMAGE        _IOW(CXL_MAGIC, 0x0B, struct cxl_adapter_image)
 
 #define CXL_READ_MIN_SIZE 0x1000 /* 4K */
 

commit d9232a3da8683cd9c9854a858bcca968fe5f3bca
Author: Ian Munsie <imunsie@au1.ibm.com>
Date:   Thu Jul 23 16:43:56 2015 +1000

    cxl: Add alternate MMIO error handling
    
    userspace programs using cxl currently have to use two strategies for
    dealing with MMIO errors simultaneously. They have to check every read
    for a return of all Fs in case the adapter has gone away and the kernel
    has not yet noticed, and they have to deal with SIGBUS in case the
    kernel has already noticed, invalidated the mapping and marked the
    context as failed.
    
    In order to simplify things, this patch adds an alternative approach
    where the kernel will return a page filled with Fs instead of delivering
    a SIGBUS. This allows userspace to only need to deal with one of these
    two error paths, and is intended for use in libraries that use cxl
    transparently and may not be able to safely install a signal handler.
    
    This approach will only work if certain constraints are met. Namely, if
    the application is both reading and writing to an address in the problem
    state area it cannot assume that a non-FF read is OK, as it may just be
    reading out a value it has previously written. Further - since only one
    page is used per context a write to a given offset would be visible when
    reading the same offset from a different page in the mapping (this only
    applies within a single context, not between contexts).
    
    An application could deal with this by e.g. making sure it also reads
    from a read-only offset after any reads to a read/write offset.
    
    Due to these constraints, this functionality must be explicitly
    requested by userspace when starting the context by passing in the
    CXL_START_WORK_ERR_FF flag.
    
    Signed-off-by: Ian Munsie <imunsie@au1.ibm.com>
    Acked-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index 99a8ca15fe64..1e889aa8a36e 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -29,8 +29,10 @@ struct cxl_ioctl_start_work {
 
 #define CXL_START_WORK_AMR		0x0000000000000001ULL
 #define CXL_START_WORK_NUM_IRQS		0x0000000000000002ULL
+#define CXL_START_WORK_ERR_FF		0x0000000000000004ULL
 #define CXL_START_WORK_ALL		(CXL_START_WORK_AMR |\
-					 CXL_START_WORK_NUM_IRQS)
+					 CXL_START_WORK_NUM_IRQS |\
+					 CXL_START_WORK_ERR_FF)
 
 
 /* Possible modes that an afu can be in */

commit 27d4dc7116eed98775902627ba61b70e9045e321
Author: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
Date:   Wed Apr 29 15:47:23 2015 +0530

    cxl: Implement an ioctl to fetch afu card-id, offset-id and mode
    
    Given a file descriptor on an afu device, libcxl currently uses the
    major/minor number obtained from fstat on the fd to construct path to
    the afu's sysfs directory. However it is possible that rather than using
    one of the device in /dev/cxl, a kernel driver creates its own device
    which export generic cxl interface to the userspace. This causes
    problems with libcxl as it tries to use a wrong major/minor number to
    construct the sysfs path and fail.
    
    So this patch introduces a new ioctl called CXL_IOCTL_GET_AFU_ID on the
    afu file descriptor to fetch the cxl_afu_id struct that holds the
    card/offset-id and mode information. These info is then used by libcxl to
    construct the correct path to the afu sysfs directory.
    
    Testing:
            - Build against pseries be/le configs
            - Testing with corresponding libcxl changes to verify that it constructs
              right sysfs path to the afu.
    
    Signed-off-by: Vaibhav Jain <vaibhav@linux.vnet.ibm.com>
    Acked-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index cd6d789b73ec..99a8ca15fe64 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -32,10 +32,32 @@ struct cxl_ioctl_start_work {
 #define CXL_START_WORK_ALL		(CXL_START_WORK_AMR |\
 					 CXL_START_WORK_NUM_IRQS)
 
+
+/* Possible modes that an afu can be in */
+#define CXL_MODE_DEDICATED   0x1
+#define CXL_MODE_DIRECTED    0x2
+
+/* possible flags for the cxl_afu_id flags field */
+#define CXL_AFUID_FLAG_SLAVE    0x1  /* In directed-mode afu is in slave mode */
+
+struct cxl_afu_id {
+	__u64 flags;     /* One of CXL_AFUID_FLAG_X */
+	__u32 card_id;
+	__u32 afu_offset;
+	__u32 afu_mode;  /* one of the CXL_MODE_X */
+	__u32 reserved1;
+	__u64 reserved2;
+	__u64 reserved3;
+	__u64 reserved4;
+	__u64 reserved5;
+	__u64 reserved6;
+};
+
 /* ioctl numbers */
 #define CXL_MAGIC 0xCA
 #define CXL_IOCTL_START_WORK		_IOW(CXL_MAGIC, 0x00, struct cxl_ioctl_start_work)
 #define CXL_IOCTL_GET_PROCESS_ELEMENT	_IOR(CXL_MAGIC, 0x01, __u32)
+#define CXL_IOCTL_GET_AFU_ID            _IOR(CXL_MAGIC, 0x02, struct cxl_afu_id)
 
 #define CXL_READ_MIN_SIZE 0x1000 /* 4K */
 

commit a9282d01cf357379ce29103cec5e7651a53c634d
Author: Ian Munsie <imunsie@au1.ibm.com>
Date:   Wed Oct 8 19:55:05 2014 +1100

    cxl: Add documentation for userspace APIs
    
    This documentation gives an overview of the hardware architecture, userspace
    APIs via /dev/cxl/afuM.N and the syfs files. It also adds a MAINTAINERS file
    entry for cxl.
    
    Signed-off-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
index c232be6ae21f..cd6d789b73ec 100644
--- a/include/uapi/misc/cxl.h
+++ b/include/uapi/misc/cxl.h
@@ -13,7 +13,7 @@
 #include <linux/types.h>
 #include <linux/ioctl.h>
 
-/* Structs for IOCTLS for userspace to talk to the kernel */
+
 struct cxl_ioctl_start_work {
 	__u64 flags;
 	__u64 work_element_descriptor;
@@ -26,19 +26,20 @@ struct cxl_ioctl_start_work {
 	__u64 reserved5;
 	__u64 reserved6;
 };
+
 #define CXL_START_WORK_AMR		0x0000000000000001ULL
 #define CXL_START_WORK_NUM_IRQS		0x0000000000000002ULL
 #define CXL_START_WORK_ALL		(CXL_START_WORK_AMR |\
 					 CXL_START_WORK_NUM_IRQS)
 
-/* IOCTL numbers */
+/* ioctl numbers */
 #define CXL_MAGIC 0xCA
 #define CXL_IOCTL_START_WORK		_IOW(CXL_MAGIC, 0x00, struct cxl_ioctl_start_work)
 #define CXL_IOCTL_GET_PROCESS_ELEMENT	_IOR(CXL_MAGIC, 0x01, __u32)
 
-/* Events from read() */
 #define CXL_READ_MIN_SIZE 0x1000 /* 4K */
 
+/* Events from read() */
 enum cxl_event_type {
 	CXL_EVENT_RESERVED      = 0,
 	CXL_EVENT_AFU_INTERRUPT = 1,

commit 66b43081c0bde3171208a7cb52f5807dce4a79e4
Author: Ian Munsie <imunsie@au1.ibm.com>
Date:   Wed Oct 8 19:55:03 2014 +1100

    cxl: Add userspace header file
    
    This adds a header file for use by userspace programs wanting to interact with
    the kernel cxl driver.  It defines structs and magic numbers required for
    userspace to interact with devices in /dev/cxl/afuM.N.
    
    Further documentation on this interface is added in a subsequent patch in
    Documentation/powerpc/cxl.txt.
    
    It also adds this new userspace header file to Kbuild so it's exported when
    doing "make headers_installs".
    
    Signed-off-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/misc/cxl.h b/include/uapi/misc/cxl.h
new file mode 100644
index 000000000000..c232be6ae21f
--- /dev/null
+++ b/include/uapi/misc/cxl.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2014 IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _UAPI_MISC_CXL_H
+#define _UAPI_MISC_CXL_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/* Structs for IOCTLS for userspace to talk to the kernel */
+struct cxl_ioctl_start_work {
+	__u64 flags;
+	__u64 work_element_descriptor;
+	__u64 amr;
+	__s16 num_interrupts;
+	__s16 reserved1;
+	__s32 reserved2;
+	__u64 reserved3;
+	__u64 reserved4;
+	__u64 reserved5;
+	__u64 reserved6;
+};
+#define CXL_START_WORK_AMR		0x0000000000000001ULL
+#define CXL_START_WORK_NUM_IRQS		0x0000000000000002ULL
+#define CXL_START_WORK_ALL		(CXL_START_WORK_AMR |\
+					 CXL_START_WORK_NUM_IRQS)
+
+/* IOCTL numbers */
+#define CXL_MAGIC 0xCA
+#define CXL_IOCTL_START_WORK		_IOW(CXL_MAGIC, 0x00, struct cxl_ioctl_start_work)
+#define CXL_IOCTL_GET_PROCESS_ELEMENT	_IOR(CXL_MAGIC, 0x01, __u32)
+
+/* Events from read() */
+#define CXL_READ_MIN_SIZE 0x1000 /* 4K */
+
+enum cxl_event_type {
+	CXL_EVENT_RESERVED      = 0,
+	CXL_EVENT_AFU_INTERRUPT = 1,
+	CXL_EVENT_DATA_STORAGE  = 2,
+	CXL_EVENT_AFU_ERROR     = 3,
+};
+
+struct cxl_event_header {
+	__u16 type;
+	__u16 size;
+	__u16 process_element;
+	__u16 reserved1;
+};
+
+struct cxl_event_afu_interrupt {
+	__u16 flags;
+	__u16 irq; /* Raised AFU interrupt number */
+	__u32 reserved1;
+};
+
+struct cxl_event_data_storage {
+	__u16 flags;
+	__u16 reserved1;
+	__u32 reserved2;
+	__u64 addr;
+	__u64 dsisr;
+	__u64 reserved3;
+};
+
+struct cxl_event_afu_error {
+	__u16 flags;
+	__u16 reserved1;
+	__u32 reserved2;
+	__u64 error;
+};
+
+struct cxl_event {
+	struct cxl_event_header header;
+	union {
+		struct cxl_event_afu_interrupt irq;
+		struct cxl_event_data_storage fault;
+		struct cxl_event_afu_error afu_error;
+	};
+};
+
+#endif /* _UAPI_MISC_CXL_H */
