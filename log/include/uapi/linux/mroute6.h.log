commit ca8d4794f669e721fb5198f6d142e42dd8080239
Author: Callum Sinclair <callum.sinclair@alliedtelesis.co.nz>
Date:   Mon Feb 18 10:07:52 2019 +1300

    ipmr: ip6mr: Create new sockopt to clear mfc cache or vifs
    
    Currently the only way to clear the forwarding cache was to delete the
    entries one by one using the MRT_DEL_MFC socket option or to destroy and
    recreate the socket.
    
    Create a new socket option which with the use of optional flags can
    clear any combination of multicast entries (static or not static) and
    multicast vifs (static or not static).
    
    Calling the new socket option MRT_FLUSH with the flags MRT_FLUSH_MFC and
    MRT_FLUSH_VIFS will clear all entries and vifs on the socket except for
    static entries.
    
    Signed-off-by: Callum Sinclair <callum.sinclair@alliedtelesis.co.nz>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index 9999cc006390..c36177a86516 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -31,12 +31,19 @@
 #define MRT6_TABLE	(MRT6_BASE+9)	/* Specify mroute table ID		*/
 #define MRT6_ADD_MFC_PROXY	(MRT6_BASE+10)	/* Add a (*,*|G) mfc entry	*/
 #define MRT6_DEL_MFC_PROXY	(MRT6_BASE+11)	/* Del a (*,*|G) mfc entry	*/
-#define MRT6_MAX	(MRT6_BASE+11)
+#define MRT6_FLUSH	(MRT6_BASE+12)	/* Flush all mfc entries and/or vifs	*/
+#define MRT6_MAX	(MRT6_BASE+12)
 
 #define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
 #define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
 
+/* MRT6_FLUSH optional flags */
+#define MRT6_FLUSH_MFC	1	/* Flush multicast entries */
+#define MRT6_FLUSH_MFC_STATIC	2	/* Flush static multicast entries */
+#define MRT6_FLUSH_MIFS	4	/* Flushing multicast vifs */
+#define MRT6_FLUSH_MIFS_STATIC	8	/* Flush static multicast vifs */
+
 #define MAXMIFS		32
 typedef unsigned long mifbitmap_t;	/* User mode code depends on this lot */
 typedef unsigned short mifi_t;

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index e4746816c855..9999cc006390 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI__LINUX_MROUTE6_H
 #define _UAPI__LINUX_MROUTE6_H
 

commit dd12d15c9a5b422331426980ddf70522c57c3392
Author: Julien Gomes <julien@arista.com>
Date:   Tue Jun 20 13:54:18 2017 -0700

    ip6mr: add netlink notifications on mrt6msg cache reports
    
    Add Netlink notifications on cache reports in ip6mr, in addition to the
    existing mrt6msg sent to mroute6_sk.
    Send RTM_NEWCACHEREPORT notifications to RTNLGRP_IPV6_MROUTE_R.
    
    MSGTYPE, MIF_ID, SRC_ADDR and DST_ADDR Netlink attributes contain the
    same data as their equivalent fields in the mrt6msg header.
    PKT attribute is the packet sent to mroute6_sk, without the added
    mrt6msg header.
    
    Suggested-by: Ryan Halbrook <halbrook@arista.com>
    Signed-off-by: Julien Gomes <julien@arista.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index ed5721148768..e4746816c855 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -133,4 +133,16 @@ struct mrt6msg {
 	struct in6_addr	im6_src, im6_dst;
 };
 
+/* ip6mr netlink cache report attributes */
+enum {
+	IP6MRA_CREPORT_UNSPEC,
+	IP6MRA_CREPORT_MSGTYPE,
+	IP6MRA_CREPORT_MIF_ID,
+	IP6MRA_CREPORT_SRC_ADDR,
+	IP6MRA_CREPORT_DST_ADDR,
+	IP6MRA_CREPORT_PKT,
+	__IP6MRA_CREPORT_MAX
+};
+#define IP6MRA_CREPORT_MAX (__IP6MRA_CREPORT_MAX - 1)
+
 #endif /* _UAPI__LINUX_MROUTE6_H */

commit 72aa107df6a275cf03359934ca5799a2be7a1bf7
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Thu Feb 16 18:04:29 2017 +0300

    uapi: fix linux/mroute6.h userspace compilation errors
    
    Include <linux/in6.h> to fix the following linux/mroute6.h userspace
    compilation errors:
    
    /usr/include/linux/mroute6.h:80:22: error: field 'mf6cc_origin' has incomplete type
      struct sockaddr_in6 mf6cc_origin;  /* Origin of mcast */
    /usr/include/linux/mroute6.h:81:22: error: field 'mf6cc_mcastgrp' has incomplete type
      struct sockaddr_in6 mf6cc_mcastgrp;  /* Group in question */
    /usr/include/linux/mroute6.h:91:22: error: field 'src' has incomplete type
      struct sockaddr_in6 src;
    /usr/include/linux/mroute6.h:92:22: error: field 'grp' has incomplete type
      struct sockaddr_in6 grp;
    /usr/include/linux/mroute6.h:132:18: error: field 'im6_src' has incomplete type
      struct in6_addr im6_src, im6_dst;
    /usr/include/linux/mroute6.h:132:27: error: field 'im6_dst' has incomplete type
      struct in6_addr im6_src, im6_dst;
    
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index 5062fb5751e1..ed5721148768 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -4,6 +4,7 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/sockios.h>
+#include <linux/in6.h>		/* For struct sockaddr_in6. */
 
 /*
  *	Based on the MROUTING 3.5 defines primarily to keep

commit b5d3755a22e0cc4c369c0985aef0c52c2477c1e7
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Fri Mar 4 11:52:16 2016 +0100

    uapi: define DIV_ROUND_UP for userland
    
    DIV_ROUND_UP is defined in linux/kernel.h only for the kernel.
    When ethtool.h is included by a userland app, we got the following error:
    
    include/linux/ethtool.h:1218:8: error: variably modified 'queue_mask' at file scope
      __u32 queue_mask[DIV_ROUND_UP(MAX_NUM_QUEUE, 32)];
            ^
    
    Let's add a common definition in uapi and use it everywhere.
    
    Fixes: ac2c7ad0e5d6 ("net/ethtool: introduce a new ioctl for per queue setting")
    CC: Kan Liang <kan.liang@intel.com>
    Suggested-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index ce91215cf7e6..5062fb5751e1 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -1,6 +1,7 @@
 #ifndef _UAPI__LINUX_MROUTE6_H
 #define _UAPI__LINUX_MROUTE6_H
 
+#include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/sockios.h>
 
@@ -46,14 +47,8 @@ typedef unsigned short mifi_t;
 typedef	__u32		if_mask;
 #define NIFBITS (sizeof(if_mask) * 8)        /* bits per mask */
 
-#if !defined(__KERNEL__)
-#if !defined(DIV_ROUND_UP)
-#define	DIV_ROUND_UP(x,y)	(((x) + ((y) - 1)) / (y))
-#endif
-#endif
-
 typedef struct if_set {
-	if_mask ifs_bits[DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];
+	if_mask ifs_bits[__KERNEL_DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];
 } if_set;
 
 #define IF_SET(n, p)    ((p)->ifs_bits[(n)/NIFBITS] |= (1 << ((n) % NIFBITS)))

commit 660b26dc1a8aeb33c2a2246ebf1b3684449a74b7
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Mon Jan 21 06:00:26 2013 +0000

    mcast: add multicast proxy support (IPv4 and IPv6)
    
    This patch add the support of proxy multicast, ie being able to build a static
    multicast tree. It adds the support of (*,*) and (*,G) entries.
    
    The user should define an (*,*) entry which is not used for real forwarding.
    This entry defines the upstream in iif and contains all interfaces from the
    static tree in its oifs. It will be used to forward packet upstream when they
    come from an interface belonging to the static tree.
    Hence, the user should define (*,G) entries to build its static tree. Note that
    upstream interface must be part of oifs: packets are sent to all oifs
    interfaces except the input interface. This ensures to always join the whole
    static tree, even if the packet is not coming from the upstream interface.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index c206ae3a2327..ce91215cf7e6 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -26,7 +26,9 @@
 #define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
 #define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code			*/
 #define MRT6_TABLE	(MRT6_BASE+9)	/* Specify mroute table ID		*/
-#define MRT6_MAX	(MRT6_BASE+9)
+#define MRT6_ADD_MFC_PROXY	(MRT6_BASE+10)	/* Add a (*,*|G) mfc entry	*/
+#define MRT6_DEL_MFC_PROXY	(MRT6_BASE+11)	/* Del a (*,*|G) mfc entry	*/
+#define MRT6_MAX	(MRT6_BASE+11)
 
 #define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)

commit bbb923a4c2d17ebd5ec34755fe19a33914cbd86f
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Mon Jan 21 06:00:25 2013 +0000

    mcast: define and use MRT[6]_MAX in ip[6]_mroute_opt()
    
    This will ease further addition of new MRT[6]_* values and avoid to update
    in6.h each time.
    Note that we reduce the maximum value from 210 to 209, but 210 does not match
    any known value in ip[6]_mroute_setsockopt().
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
index 3e89b5e7f9e3..c206ae3a2327 100644
--- a/include/uapi/linux/mroute6.h
+++ b/include/uapi/linux/mroute6.h
@@ -26,6 +26,7 @@
 #define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
 #define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code			*/
 #define MRT6_TABLE	(MRT6_BASE+9)	/* Specify mroute table ID		*/
+#define MRT6_MAX	(MRT6_BASE+9)
 
 #define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/mroute6.h b/include/uapi/linux/mroute6.h
new file mode 100644
index 000000000000..3e89b5e7f9e3
--- /dev/null
+++ b/include/uapi/linux/mroute6.h
@@ -0,0 +1,137 @@
+#ifndef _UAPI__LINUX_MROUTE6_H
+#define _UAPI__LINUX_MROUTE6_H
+
+#include <linux/types.h>
+#include <linux/sockios.h>
+
+/*
+ *	Based on the MROUTING 3.5 defines primarily to keep
+ *	source compatibility with BSD.
+ *
+ *	See the pim6sd code for the original history.
+ *
+ *      Protocol Independent Multicast (PIM) data structures included
+ *      Carlos Picoto (cap@di.fc.ul.pt)
+ *
+ */
+
+#define MRT6_BASE	200
+#define MRT6_INIT	(MRT6_BASE)	/* Activate the kernel mroute code 	*/
+#define MRT6_DONE	(MRT6_BASE+1)	/* Shutdown the kernel mroute		*/
+#define MRT6_ADD_MIF	(MRT6_BASE+2)	/* Add a virtual interface		*/
+#define MRT6_DEL_MIF	(MRT6_BASE+3)	/* Delete a virtual interface		*/
+#define MRT6_ADD_MFC	(MRT6_BASE+4)	/* Add a multicast forwarding entry	*/
+#define MRT6_DEL_MFC	(MRT6_BASE+5)	/* Delete a multicast forwarding entry	*/
+#define MRT6_VERSION	(MRT6_BASE+6)	/* Get the kernel multicast version	*/
+#define MRT6_ASSERT	(MRT6_BASE+7)	/* Activate PIM assert mode		*/
+#define MRT6_PIM	(MRT6_BASE+8)	/* enable PIM code			*/
+#define MRT6_TABLE	(MRT6_BASE+9)	/* Specify mroute table ID		*/
+
+#define SIOCGETMIFCNT_IN6	SIOCPROTOPRIVATE	/* IP protocol privates */
+#define SIOCGETSGCNT_IN6	(SIOCPROTOPRIVATE+1)
+#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+
+#define MAXMIFS		32
+typedef unsigned long mifbitmap_t;	/* User mode code depends on this lot */
+typedef unsigned short mifi_t;
+#define ALL_MIFS	((mifi_t)(-1))
+
+#ifndef IF_SETSIZE
+#define IF_SETSIZE	256
+#endif
+
+typedef	__u32		if_mask;
+#define NIFBITS (sizeof(if_mask) * 8)        /* bits per mask */
+
+#if !defined(__KERNEL__)
+#if !defined(DIV_ROUND_UP)
+#define	DIV_ROUND_UP(x,y)	(((x) + ((y) - 1)) / (y))
+#endif
+#endif
+
+typedef struct if_set {
+	if_mask ifs_bits[DIV_ROUND_UP(IF_SETSIZE, NIFBITS)];
+} if_set;
+
+#define IF_SET(n, p)    ((p)->ifs_bits[(n)/NIFBITS] |= (1 << ((n) % NIFBITS)))
+#define IF_CLR(n, p)    ((p)->ifs_bits[(n)/NIFBITS] &= ~(1 << ((n) % NIFBITS)))
+#define IF_ISSET(n, p)  ((p)->ifs_bits[(n)/NIFBITS] & (1 << ((n) % NIFBITS)))
+#define IF_COPY(f, t)   bcopy(f, t, sizeof(*(f)))
+#define IF_ZERO(p)      bzero(p, sizeof(*(p)))
+
+/*
+ *	Passed by mrouted for an MRT_ADD_MIF - again we use the
+ *	mrouted 3.6 structures for compatibility
+ */
+
+struct mif6ctl {
+	mifi_t	mif6c_mifi;		/* Index of MIF */
+	unsigned char mif6c_flags;	/* MIFF_ flags */
+	unsigned char vifc_threshold;	/* ttl limit */
+	__u16	 mif6c_pifi;		/* the index of the physical IF */
+	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
+};
+
+#define MIFF_REGISTER	0x1	/* register vif	*/
+
+/*
+ *	Cache manipulation structures for mrouted and PIMd
+ */
+
+struct mf6cctl {
+	struct sockaddr_in6 mf6cc_origin;		/* Origin of mcast	*/
+	struct sockaddr_in6 mf6cc_mcastgrp;		/* Group in question	*/
+	mifi_t	mf6cc_parent;			/* Where it arrived	*/
+	struct if_set mf6cc_ifset;		/* Where it is going */
+};
+
+/*
+ *	Group count retrieval for pim6sd
+ */
+
+struct sioc_sg_req6 {
+	struct sockaddr_in6 src;
+	struct sockaddr_in6 grp;
+	unsigned long pktcnt;
+	unsigned long bytecnt;
+	unsigned long wrong_if;
+};
+
+/*
+ *	To get vif packet counts
+ */
+
+struct sioc_mif_req6 {
+	mifi_t	mifi;		/* Which iface */
+	unsigned long icount;	/* In packets */
+	unsigned long ocount;	/* Out packets */
+	unsigned long ibytes;	/* In bytes */
+	unsigned long obytes;	/* Out bytes */
+};
+
+/*
+ *	That's all usermode folks
+ */
+
+
+
+/*
+ * Structure used to communicate from kernel to multicast router.
+ * We'll overlay the structure onto an MLD header (not an IPv6 heder like igmpmsg{}
+ * used for IPv4 implementation). This is because this structure will be passed via an
+ * IPv6 raw socket, on which an application will only receiver the payload i.e the data after
+ * the IPv6 header and all the extension headers. (See section 3 of RFC 3542)
+ */
+
+struct mrt6msg {
+#define MRT6MSG_NOCACHE		1
+#define MRT6MSG_WRONGMIF	2
+#define MRT6MSG_WHOLEPKT	3		/* used for use level encap */
+	__u8		im6_mbz;		/* must be zero		   */
+	__u8		im6_msgtype;		/* what type of message    */
+	__u16		im6_mif;		/* mif rec'd on		   */
+	__u32		im6_pad;		/* padding for 64 bit arch */
+	struct in6_addr	im6_src, im6_dst;
+};
+
+#endif /* _UAPI__LINUX_MROUTE6_H */
