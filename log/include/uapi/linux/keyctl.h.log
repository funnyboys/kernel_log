commit f7e47677e39a03057dcced2016c92a9c868693ec
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 14 17:07:11 2020 +0000

    watch_queue: Add a key/keyring notification facility
    
    Add a key/keyring change notification facility whereby notifications about
    changes in key and keyring content and attributes can be received.
    
    Firstly, an event queue needs to be created:
    
            pipe2(fds, O_NOTIFICATION_PIPE);
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_SIZE, 256);
    
    then a notification can be set up to report notifications via that queue:
    
            struct watch_notification_filter filter = {
                    .nr_filters = 1,
                    .filters = {
                            [0] = {
                                    .type = WATCH_TYPE_KEY_NOTIFY,
                                    .subtype_filter[0] = UINT_MAX,
                            },
                    },
            };
            ioctl(fds[1], IOC_WATCH_QUEUE_SET_FILTER, &filter);
            keyctl_watch_key(KEY_SPEC_SESSION_KEYRING, fds[1], 0x01);
    
    After that, records will be placed into the queue when events occur in
    which keys are changed in some way.  Records are of the following format:
    
            struct key_notification {
                    struct watch_notification watch;
                    __u32   key_id;
                    __u32   aux;
            } *n;
    
    Where:
    
            n->watch.type will be WATCH_TYPE_KEY_NOTIFY.
    
            n->watch.subtype will indicate the type of event, such as
            NOTIFY_KEY_REVOKED.
    
            n->watch.info & WATCH_INFO_LENGTH will indicate the length of the
            record.
    
            n->watch.info & WATCH_INFO_ID will be the second argument to
            keyctl_watch_key(), shifted.
    
            n->key will be the ID of the affected key.
    
            n->aux will hold subtype-dependent information, such as the key
            being linked into the keyring specified by n->key in the case of
            NOTIFY_KEY_LINKED.
    
    Note that it is permissible for event records to be of variable length -
    or, at least, the length may be dependent on the subtype.  Note also that
    the queue can be shared between multiple notifications of various types.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jamorris@linux.microsoft.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index ed3d5893830d..4c8884eea808 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -69,6 +69,7 @@
 #define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
 #define KEYCTL_MOVE			30	/* Move keys between keyrings */
 #define KEYCTL_CAPABILITIES		31	/* Find capabilities of keyrings subsystem */
+#define KEYCTL_WATCH_KEY		32	/* Watch a key or ring of keys for changes */
 
 /* keyctl structures */
 struct keyctl_dh_params {
@@ -130,5 +131,6 @@ struct keyctl_pkey_params {
 #define KEYCTL_CAPS0_MOVE		0x80 /* KEYCTL_MOVE supported */
 #define KEYCTL_CAPS1_NS_KEYRING_NAME	0x01 /* Keyring names are per-user_namespace */
 #define KEYCTL_CAPS1_NS_KEY_TAG		0x02 /* Key indexing can include a namespace tag */
+#define KEYCTL_CAPS1_NOTIFICATIONS	0x04 /* Keys generate watchable notifications */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 028db3e290f15ac509084c0fc3b9d021f668f877
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 18:43:43 2019 -0700

    Revert "Merge tag 'keys-acl-20190703' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs"
    
    This reverts merge 0f75ef6a9cff49ff612f7ce0578bced9d0b38325 (and thus
    effectively commits
    
       7a1ade847596 ("keys: Provide KEYCTL_GRANT_PERMISSION")
       2e12256b9a76 ("keys: Replace uid/gid/perm permissions checking with an ACL")
    
    that the merge brought in).
    
    It turns out that it breaks booting with an encrypted volume, and Eric
    biggers reports that it also breaks the fscrypt tests [1] and loading of
    in-kernel X.509 certificates [2].
    
    The root cause of all the breakage is likely the same, but David Howells
    is off email so rather than try to work it out it's getting reverted in
    order to not impact the rest of the merge window.
    
     [1] https://lore.kernel.org/lkml/20190710011559.GA7973@sol.localdomain/
     [2] https://lore.kernel.org/lkml/20190710013225.GB7973@sol.localdomain/
    
    Link: https://lore.kernel.org/lkml/CAHk-=wjxoeMJfeBahnWH=9zShKp2bsVy527vo3_y8HfOdhwAAw@mail.gmail.com/
    Reported-by: Eric Biggers <ebiggers@kernel.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 1f7a4e737214..ed3d5893830d 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -15,69 +15,6 @@
 
 #include <linux/types.h>
 
-/*
- * Keyring permission grant definitions
- */
-enum key_ace_subject_type {
-	KEY_ACE_SUBJ_STANDARD	= 0,	/* subject is one of key_ace_standard_subject */
-	nr__key_ace_subject_type
-};
-
-enum key_ace_standard_subject {
-	KEY_ACE_EVERYONE	= 0,	/* Everyone, including owner and group */
-	KEY_ACE_GROUP		= 1,	/* The key's group */
-	KEY_ACE_OWNER		= 2,	/* The owner of the key */
-	KEY_ACE_POSSESSOR	= 3,	/* Any process that possesses of the key */
-	nr__key_ace_standard_subject
-};
-
-#define KEY_ACE_VIEW		0x00000001 /* Can describe the key */
-#define KEY_ACE_READ		0x00000002 /* Can read the key content */
-#define KEY_ACE_WRITE		0x00000004 /* Can update/modify the key content */
-#define KEY_ACE_SEARCH		0x00000008 /* Can find the key by search */
-#define KEY_ACE_LINK		0x00000010 /* Can make a link to the key */
-#define KEY_ACE_SET_SECURITY	0x00000020 /* Can set owner, group, ACL */
-#define KEY_ACE_INVAL		0x00000040 /* Can invalidate the key */
-#define KEY_ACE_REVOKE		0x00000080 /* Can revoke the key */
-#define KEY_ACE_JOIN		0x00000100 /* Can join keyring */
-#define KEY_ACE_CLEAR		0x00000200 /* Can clear keyring */
-#define KEY_ACE__PERMS		0xffffffff
-
-/*
- * Old-style permissions mask, deprecated in favour of ACL.
- */
-#define KEY_POS_VIEW	0x01000000	/* possessor can view a key's attributes */
-#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
-#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
-#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
-#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
-#define KEY_POS_SETATTR	0x20000000	/* possessor can set key attributes */
-#define KEY_POS_ALL	0x3f000000
-
-#define KEY_USR_VIEW	0x00010000	/* user permissions... */
-#define KEY_USR_READ	0x00020000
-#define KEY_USR_WRITE	0x00040000
-#define KEY_USR_SEARCH	0x00080000
-#define KEY_USR_LINK	0x00100000
-#define KEY_USR_SETATTR	0x00200000
-#define KEY_USR_ALL	0x003f0000
-
-#define KEY_GRP_VIEW	0x00000100	/* group permissions... */
-#define KEY_GRP_READ	0x00000200
-#define KEY_GRP_WRITE	0x00000400
-#define KEY_GRP_SEARCH	0x00000800
-#define KEY_GRP_LINK	0x00001000
-#define KEY_GRP_SETATTR	0x00002000
-#define KEY_GRP_ALL	0x00003f00
-
-#define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
-#define KEY_OTH_READ	0x00000002
-#define KEY_OTH_WRITE	0x00000004
-#define KEY_OTH_SEARCH	0x00000008
-#define KEY_OTH_LINK	0x00000010
-#define KEY_OTH_SETATTR	0x00000020
-#define KEY_OTH_ALL	0x0000003f
-
 /* special process keyring shortcut IDs */
 #define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
 #define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
@@ -132,7 +69,6 @@ enum key_ace_standard_subject {
 #define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
 #define KEYCTL_MOVE			30	/* Move keys between keyrings */
 #define KEYCTL_CAPABILITIES		31	/* Find capabilities of keyrings subsystem */
-#define KEYCTL_GRANT_PERMISSION		32	/* Grant a permit to a key */
 
 /* keyctl structures */
 struct keyctl_dh_params {
@@ -194,6 +130,5 @@ struct keyctl_pkey_params {
 #define KEYCTL_CAPS0_MOVE		0x80 /* KEYCTL_MOVE supported */
 #define KEYCTL_CAPS1_NS_KEYRING_NAME	0x01 /* Keyring names are per-user_namespace */
 #define KEYCTL_CAPS1_NS_KEY_TAG		0x02 /* Key indexing can include a namespace tag */
-#define KEYCTL_CAPS1_ACL_ALTERABLE	0x04 /* Keys have internal ACL that can be altered */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 7a1ade847596dadc94b37e49f8c03f167fd71748
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Provide KEYCTL_GRANT_PERMISSION
    
    Provide a keyctl() operation to grant/remove permissions.  The grant
    operation, wrapped by libkeyutils, looks like:
    
            int ret = keyctl_grant_permission(key_serial_t key,
                                              enum key_ace_subject_type type,
                                              unsigned int subject,
                                              unsigned int perm);
    
    Where key is the key to be modified, type and subject represent the subject
    to which permission is to be granted (or removed) and perm is the set of
    permissions to be granted.  0 is returned on success.  SET_SECURITY
    permission is required for this.
    
    The subject type currently must be KEY_ACE_SUBJ_STANDARD for the moment
    (other subject types will come along later).
    
    For subject type KEY_ACE_SUBJ_STANDARD, the following subject values are
    available:
    
            KEY_ACE_POSSESSOR       The possessor of the key
            KEY_ACE_OWNER           The owner of the key
            KEY_ACE_GROUP           The key's group
            KEY_ACE_EVERYONE        Everyone
    
    perm lists the permissions to be granted:
    
            KEY_ACE_VIEW            Can view the key metadata
            KEY_ACE_READ            Can read the key content
            KEY_ACE_WRITE           Can update/modify the key content
            KEY_ACE_SEARCH          Can find the key by searching/requesting
            KEY_ACE_LINK            Can make a link to the key
            KEY_ACE_SET_SECURITY    Can set security
            KEY_ACE_INVAL           Can invalidate
            KEY_ACE_REVOKE          Can revoke
            KEY_ACE_JOIN            Can join this keyring
            KEY_ACE_CLEAR           Can clear this keyring
    
    If an ACE already exists for the subject, then the permissions mask will be
    overwritten; if perm is 0, it will be deleted.
    
    Currently, the internal ACL is limited to a maximum of 16 entries.
    
    For example:
    
            int ret = keyctl_grant_permission(key,
                                              KEY_ACE_SUBJ_STANDARD,
                                              KEY_ACE_OWNER,
                                              KEY_ACE_VIEW | KEY_ACE_READ);
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index e783bf957da8..1f7a4e737214 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -132,6 +132,7 @@ enum key_ace_standard_subject {
 #define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
 #define KEYCTL_MOVE			30	/* Move keys between keyrings */
 #define KEYCTL_CAPABILITIES		31	/* Find capabilities of keyrings subsystem */
+#define KEYCTL_GRANT_PERMISSION		32	/* Grant a permit to a key */
 
 /* keyctl structures */
 struct keyctl_dh_params {
@@ -193,5 +194,6 @@ struct keyctl_pkey_params {
 #define KEYCTL_CAPS0_MOVE		0x80 /* KEYCTL_MOVE supported */
 #define KEYCTL_CAPS1_NS_KEYRING_NAME	0x01 /* Keyring names are per-user_namespace */
 #define KEYCTL_CAPS1_NS_KEY_TAG		0x02 /* Key indexing can include a namespace tag */
+#define KEYCTL_CAPS1_ACL_ALTERABLE	0x04 /* Keys have internal ACL that can be altered */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 2e12256b9a76584fa3a6da19210509d4775aee36
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 27 23:03:07 2019 +0100

    keys: Replace uid/gid/perm permissions checking with an ACL
    
    Replace the uid/gid/perm permissions checking on a key with an ACL to allow
    the SETATTR and SEARCH permissions to be split.  This will also allow a
    greater range of subjects to represented.
    
    ============
    WHY DO THIS?
    ============
    
    The problem is that SETATTR and SEARCH cover a slew of actions, not all of
    which should be grouped together.
    
    For SETATTR, this includes actions that are about controlling access to a
    key:
    
     (1) Changing a key's ownership.
    
     (2) Changing a key's security information.
    
     (3) Setting a keyring's restriction.
    
    And actions that are about managing a key's lifetime:
    
     (4) Setting an expiry time.
    
     (5) Revoking a key.
    
    and (proposed) managing a key as part of a cache:
    
     (6) Invalidating a key.
    
    Managing a key's lifetime doesn't really have anything to do with
    controlling access to that key.
    
    Expiry time is awkward since it's more about the lifetime of the content
    and so, in some ways goes better with WRITE permission.  It can, however,
    be set unconditionally by a process with an appropriate authorisation token
    for instantiating a key, and can also be set by the key type driver when a
    key is instantiated, so lumping it with the access-controlling actions is
    probably okay.
    
    As for SEARCH permission, that currently covers:
    
     (1) Finding keys in a keyring tree during a search.
    
     (2) Permitting keyrings to be joined.
    
     (3) Invalidation.
    
    But these don't really belong together either, since these actions really
    need to be controlled separately.
    
    Finally, there are number of special cases to do with granting the
    administrator special rights to invalidate or clear keys that I would like
    to handle with the ACL rather than key flags and special checks.
    
    
    ===============
    WHAT IS CHANGED
    ===============
    
    The SETATTR permission is split to create two new permissions:
    
     (1) SET_SECURITY - which allows the key's owner, group and ACL to be
         changed and a restriction to be placed on a keyring.
    
     (2) REVOKE - which allows a key to be revoked.
    
    The SEARCH permission is split to create:
    
     (1) SEARCH - which allows a keyring to be search and a key to be found.
    
     (2) JOIN - which allows a keyring to be joined as a session keyring.
    
     (3) INVAL - which allows a key to be invalidated.
    
    The WRITE permission is also split to create:
    
     (1) WRITE - which allows a key's content to be altered and links to be
         added, removed and replaced in a keyring.
    
     (2) CLEAR - which allows a keyring to be cleared completely.  This is
         split out to make it possible to give just this to an administrator.
    
     (3) REVOKE - see above.
    
    
    Keys acquire ACLs which consist of a series of ACEs, and all that apply are
    unioned together.  An ACE specifies a subject, such as:
    
     (*) Possessor - permitted to anyone who 'possesses' a key
     (*) Owner - permitted to the key owner
     (*) Group - permitted to the key group
     (*) Everyone - permitted to everyone
    
    Note that 'Other' has been replaced with 'Everyone' on the assumption that
    you wouldn't grant a permit to 'Other' that you wouldn't also grant to
    everyone else.
    
    Further subjects may be made available by later patches.
    
    The ACE also specifies a permissions mask.  The set of permissions is now:
    
            VIEW            Can view the key metadata
            READ            Can read the key content
            WRITE           Can update/modify the key content
            SEARCH          Can find the key by searching/requesting
            LINK            Can make a link to the key
            SET_SECURITY    Can change owner, ACL, expiry
            INVAL           Can invalidate
            REVOKE          Can revoke
            JOIN            Can join this keyring
            CLEAR           Can clear this keyring
    
    
    The KEYCTL_SETPERM function is then deprecated.
    
    The KEYCTL_SET_TIMEOUT function then is permitted if SET_SECURITY is set,
    or if the caller has a valid instantiation auth token.
    
    The KEYCTL_INVALIDATE function then requires INVAL.
    
    The KEYCTL_REVOKE function then requires REVOKE.
    
    The KEYCTL_JOIN_SESSION_KEYRING function then requires JOIN to join an
    existing keyring.
    
    The JOIN permission is enabled by default for session keyrings and manually
    created keyrings only.
    
    
    ======================
    BACKWARD COMPATIBILITY
    ======================
    
    To maintain backward compatibility, KEYCTL_SETPERM will translate the
    permissions mask it is given into a new ACL for a key - unless
    KEYCTL_SET_ACL has been called on that key, in which case an error will be
    returned.
    
    It will convert possessor, owner, group and other permissions into separate
    ACEs, if each portion of the mask is non-zero.
    
    SETATTR permission turns on all of INVAL, REVOKE and SET_SECURITY.  WRITE
    permission turns on WRITE, REVOKE and, if a keyring, CLEAR.  JOIN is turned
    on if a keyring is being altered.
    
    The KEYCTL_DESCRIBE function translates the ACL back into a permissions
    mask to return depending on possessor, owner, group and everyone ACEs.
    
    It will make the following mappings:
    
     (1) INVAL, JOIN -> SEARCH
    
     (2) SET_SECURITY -> SETATTR
    
     (3) REVOKE -> WRITE if SETATTR isn't already set
    
     (4) CLEAR -> WRITE
    
    Note that the value subsequently returned by KEYCTL_DESCRIBE may not match
    the value set with KEYCTL_SETATTR.
    
    
    =======
    TESTING
    =======
    
    This passes the keyutils testsuite for all but a couple of tests:
    
     (1) tests/keyctl/dh_compute/badargs: The first wrong-key-type test now
         returns EOPNOTSUPP rather than ENOKEY as READ permission isn't removed
         if the type doesn't have ->read().  You still can't actually read the
         key.
    
     (2) tests/keyctl/permitting/valid: The view-other-permissions test doesn't
         work as Other has been replaced with Everyone in the ACL.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index ed3d5893830d..e783bf957da8 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -15,6 +15,69 @@
 
 #include <linux/types.h>
 
+/*
+ * Keyring permission grant definitions
+ */
+enum key_ace_subject_type {
+	KEY_ACE_SUBJ_STANDARD	= 0,	/* subject is one of key_ace_standard_subject */
+	nr__key_ace_subject_type
+};
+
+enum key_ace_standard_subject {
+	KEY_ACE_EVERYONE	= 0,	/* Everyone, including owner and group */
+	KEY_ACE_GROUP		= 1,	/* The key's group */
+	KEY_ACE_OWNER		= 2,	/* The owner of the key */
+	KEY_ACE_POSSESSOR	= 3,	/* Any process that possesses of the key */
+	nr__key_ace_standard_subject
+};
+
+#define KEY_ACE_VIEW		0x00000001 /* Can describe the key */
+#define KEY_ACE_READ		0x00000002 /* Can read the key content */
+#define KEY_ACE_WRITE		0x00000004 /* Can update/modify the key content */
+#define KEY_ACE_SEARCH		0x00000008 /* Can find the key by search */
+#define KEY_ACE_LINK		0x00000010 /* Can make a link to the key */
+#define KEY_ACE_SET_SECURITY	0x00000020 /* Can set owner, group, ACL */
+#define KEY_ACE_INVAL		0x00000040 /* Can invalidate the key */
+#define KEY_ACE_REVOKE		0x00000080 /* Can revoke the key */
+#define KEY_ACE_JOIN		0x00000100 /* Can join keyring */
+#define KEY_ACE_CLEAR		0x00000200 /* Can clear keyring */
+#define KEY_ACE__PERMS		0xffffffff
+
+/*
+ * Old-style permissions mask, deprecated in favour of ACL.
+ */
+#define KEY_POS_VIEW	0x01000000	/* possessor can view a key's attributes */
+#define KEY_POS_READ	0x02000000	/* possessor can read key payload / view keyring */
+#define KEY_POS_WRITE	0x04000000	/* possessor can update key payload / add link to keyring */
+#define KEY_POS_SEARCH	0x08000000	/* possessor can find a key in search / search a keyring */
+#define KEY_POS_LINK	0x10000000	/* possessor can create a link to a key/keyring */
+#define KEY_POS_SETATTR	0x20000000	/* possessor can set key attributes */
+#define KEY_POS_ALL	0x3f000000
+
+#define KEY_USR_VIEW	0x00010000	/* user permissions... */
+#define KEY_USR_READ	0x00020000
+#define KEY_USR_WRITE	0x00040000
+#define KEY_USR_SEARCH	0x00080000
+#define KEY_USR_LINK	0x00100000
+#define KEY_USR_SETATTR	0x00200000
+#define KEY_USR_ALL	0x003f0000
+
+#define KEY_GRP_VIEW	0x00000100	/* group permissions... */
+#define KEY_GRP_READ	0x00000200
+#define KEY_GRP_WRITE	0x00000400
+#define KEY_GRP_SEARCH	0x00000800
+#define KEY_GRP_LINK	0x00001000
+#define KEY_GRP_SETATTR	0x00002000
+#define KEY_GRP_ALL	0x00003f00
+
+#define KEY_OTH_VIEW	0x00000001	/* third party permissions... */
+#define KEY_OTH_READ	0x00000002
+#define KEY_OTH_WRITE	0x00000004
+#define KEY_OTH_SEARCH	0x00000008
+#define KEY_OTH_LINK	0x00000010
+#define KEY_OTH_SETATTR	0x00000020
+#define KEY_OTH_ALL	0x0000003f
+
 /* special process keyring shortcut IDs */
 #define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
 #define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */

commit 3b6e4de05e9ee2e2f94e4a3fe14d945e2418d9a8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Include target namespace in match criteria
    
    Currently a key has a standard matching criteria of { type, description }
    and this is used to only allow keys with unique criteria in a keyring.
    This means, however, that you cannot have keys with the same type and
    description but a different target namespace in the same keyring.
    
    This is a potential problem for a containerised environment where, say, a
    container is made up of some parts of its mount space involving netfs
    superblocks from two different network namespaces.
    
    This is also a problem for shared system management keyrings such as the
    DNS records keyring or the NFS idmapper keyring that might contain keys
    from different network namespaces.
    
    Fix this by including a namespace component in a key's matching criteria.
    Keyring types are marked to indicate which, if any, namespace is relevant
    to keys of that type, and that namespace is set when the key is created
    from the current task's namespace set.
    
    The capability bit KEYCTL_CAPS1_NS_KEY_TAG is set if the kernel is
    employing this feature.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 35b405034674..ed3d5893830d 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -129,5 +129,6 @@ struct keyctl_pkey_params {
 #define KEYCTL_CAPS0_RESTRICT_KEYRING	0x40 /* KEYCTL_RESTRICT_KEYRING supported */
 #define KEYCTL_CAPS0_MOVE		0x80 /* KEYCTL_MOVE supported */
 #define KEYCTL_CAPS1_NS_KEYRING_NAME	0x01 /* Keyring names are per-user_namespace */
+#define KEYCTL_CAPS1_NS_KEY_TAG		0x02 /* Key indexing can include a namespace tag */
 
 #endif /*  _LINUX_KEYCTL_H */

commit b206f281d0ee14969878469816a69db22d5838e8
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jun 26 21:02:32 2019 +0100

    keys: Namespace keyring names
    
    Keyring names are held in a single global list that any process can pick
    from by means of keyctl_join_session_keyring (provided the keyring grants
    Search permission).  This isn't very container friendly, however.
    
    Make the following changes:
    
     (1) Make default session, process and thread keyring names begin with a
         '.' instead of '_'.
    
     (2) Keyrings whose names begin with a '.' aren't added to the list.  Such
         keyrings are system specials.
    
     (3) Replace the global list with per-user_namespace lists.  A keyring adds
         its name to the list for the user_namespace that it is currently in.
    
     (4) When a user_namespace is deleted, it just removes itself from the
         keyring name list.
    
    The global keyring_name_lock is retained for accessing the name lists.
    This allows (4) to work.
    
    This can be tested by:
    
            # keyctl newring foo @s
            995906392
            # unshare -U
            $ keyctl show
            ...
             995906392 --alswrv  65534 65534   \_ keyring: foo
            ...
            $ keyctl session foo
            Joined session keyring: 935622349
    
    As can be seen, a new session keyring was created.
    
    The capability bit KEYCTL_CAPS1_NS_KEYRING_NAME is set if the kernel is
    employing this feature.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 551b5814f53e..35b405034674 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -128,5 +128,6 @@ struct keyctl_pkey_params {
 #define KEYCTL_CAPS0_INVALIDATE		0x20 /* KEYCTL_INVALIDATE supported */
 #define KEYCTL_CAPS0_RESTRICT_KEYRING	0x40 /* KEYCTL_RESTRICT_KEYRING supported */
 #define KEYCTL_CAPS0_MOVE		0x80 /* KEYCTL_MOVE supported */
+#define KEYCTL_CAPS1_NS_KEYRING_NAME	0x01 /* Keyring names are per-user_namespace */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 45e0f30c30bb131663fbe1752974d6f2e39611e2
Author: David Howells <dhowells@redhat.com>
Date:   Thu May 30 14:53:10 2019 +0100

    keys: Add capability-checking keyctl function
    
    Add a keyctl function that requests a set of capability bits to find out
    what features are supported.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index fd9fb11b312b..551b5814f53e 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -68,6 +68,7 @@
 #define KEYCTL_PKEY_VERIFY		28	/* Verify a public key signature */
 #define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
 #define KEYCTL_MOVE			30	/* Move keys between keyrings */
+#define KEYCTL_CAPABILITIES		31	/* Find capabilities of keyrings subsystem */
 
 /* keyctl structures */
 struct keyctl_dh_params {
@@ -115,4 +116,17 @@ struct keyctl_pkey_params {
 
 #define KEYCTL_MOVE_EXCL	0x00000001 /* Do not displace from the to-keyring */
 
+/*
+ * Capabilities flags.  The capabilities list is an array of 8-bit integers;
+ * each integer can carry up to 8 flags.
+ */
+#define KEYCTL_CAPS0_CAPABILITIES	0x01 /* KEYCTL_CAPABILITIES supported */
+#define KEYCTL_CAPS0_PERSISTENT_KEYRINGS 0x02 /* Persistent keyrings enabled */
+#define KEYCTL_CAPS0_DIFFIE_HELLMAN	0x04 /* Diffie-Hellman computation enabled */
+#define KEYCTL_CAPS0_PUBLIC_KEY		0x08 /* Public key ops enabled */
+#define KEYCTL_CAPS0_BIG_KEY		0x10 /* big_key-type enabled */
+#define KEYCTL_CAPS0_INVALIDATE		0x20 /* KEYCTL_INVALIDATE supported */
+#define KEYCTL_CAPS0_RESTRICT_KEYRING	0x40 /* KEYCTL_RESTRICT_KEYRING supported */
+#define KEYCTL_CAPS0_MOVE		0x80 /* KEYCTL_MOVE supported */
+
 #endif /*  _LINUX_KEYCTL_H */

commit ed0ac5c7ec3763e3261c48e3c5d4b7528b60fd85
Author: David Howells <dhowells@redhat.com>
Date:   Mon May 20 21:51:50 2019 +0100

    keys: Add a keyctl to move a key between keyrings
    
    Add a keyctl to atomically move a link to a key from one keyring to
    another.  The key must exist in "from" keyring and a flag can be given to
    cause the operation to fail if there's a matching key already in the "to"
    keyring.
    
    This can be done with:
    
            keyctl(KEYCTL_MOVE,
                   key_serial_t key,
                   key_serial_t from_keyring,
                   key_serial_t to_keyring,
                   unsigned int flags);
    
    The key being moved must grant Link permission and both keyrings must grant
    Write permission.
    
    flags should be 0 or KEYCTL_MOVE_EXCL, with the latter preventing
    displacement of a matching key from the "to" keyring.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index f45ee0f69c0c..fd9fb11b312b 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -67,6 +67,7 @@
 #define KEYCTL_PKEY_SIGN		27	/* Create a public key signature */
 #define KEYCTL_PKEY_VERIFY		28	/* Verify a public key signature */
 #define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
+#define KEYCTL_MOVE			30	/* Move keys between keyrings */
 
 /* keyctl structures */
 struct keyctl_dh_params {
@@ -112,4 +113,6 @@ struct keyctl_pkey_params {
 	__u32		__spare[7];
 };
 
+#define KEYCTL_MOVE_EXCL	0x00000001 /* Do not displace from the to-keyring */
+
 #endif /*  _LINUX_KEYCTL_H */

commit 00d60fd3b93219ea854220f0fd264b86398cbc53
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 9 17:46:59 2018 +0100

    KEYS: Provide keyctls to drive the new key type ops for asymmetric keys [ver #2]
    
    Provide five keyctl functions that permit userspace to make use of the new
    key type ops for accessing and driving asymmetric keys.
    
     (*) Query an asymmetric key.
    
            long keyctl(KEYCTL_PKEY_QUERY,
                        key_serial_t key, unsigned long reserved,
                        struct keyctl_pkey_query *info);
    
         Get information about an asymmetric key.  The information is returned
         in the keyctl_pkey_query struct:
    
            __u32   supported_ops;
    
         A bit mask of flags indicating which ops are supported.  This is
         constructed from a bitwise-OR of:
    
            KEYCTL_SUPPORTS_{ENCRYPT,DECRYPT,SIGN,VERIFY}
    
            __u32   key_size;
    
         The size in bits of the key.
    
            __u16   max_data_size;
            __u16   max_sig_size;
            __u16   max_enc_size;
            __u16   max_dec_size;
    
         The maximum sizes in bytes of a blob of data to be signed, a signature
         blob, a blob to be encrypted and a blob to be decrypted.
    
         reserved must be set to 0.  This is intended for future use to hand
         over one or more passphrases needed unlock a key.
    
         If successful, 0 is returned.  If the key is not an asymmetric key,
         EOPNOTSUPP is returned.
    
     (*) Encrypt, decrypt, sign or verify a blob using an asymmetric key.
    
            long keyctl(KEYCTL_PKEY_ENCRYPT,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        void *out);
    
            long keyctl(KEYCTL_PKEY_DECRYPT,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        void *out);
    
            long keyctl(KEYCTL_PKEY_SIGN,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        void *out);
    
            long keyctl(KEYCTL_PKEY_VERIFY,
                        const struct keyctl_pkey_params *params,
                        const char *info,
                        const void *in,
                        const void *in2);
    
         Use an asymmetric key to perform a public-key cryptographic operation
         a blob of data.
    
         The parameter block pointed to by params contains a number of integer
         values:
    
            __s32           key_id;
            __u32           in_len;
            __u32           out_len;
            __u32           in2_len;
    
         For a given operation, the in and out buffers are used as follows:
    
            Operation ID            in,in_len       out,out_len     in2,in2_len
            ======================= =============== =============== ===========
            KEYCTL_PKEY_ENCRYPT     Raw data        Encrypted data  -
            KEYCTL_PKEY_DECRYPT     Encrypted data  Raw data        -
            KEYCTL_PKEY_SIGN        Raw data        Signature       -
            KEYCTL_PKEY_VERIFY      Raw data        -               Signature
    
         info is a string of key=value pairs that supply supplementary
         information.
    
         The __spare space in the parameter block must be set to 0.  This is
         intended, amongst other things, to allow the passing of passphrases
         required to unlock a key.
    
         If successful, encrypt, decrypt and sign all return the amount of data
         written into the output buffer.  Verification returns 0 on success.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Tested-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 1d1e9f2877af..f45ee0f69c0c 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -61,6 +61,11 @@
 #define KEYCTL_INVALIDATE		21	/* invalidate a key */
 #define KEYCTL_GET_PERSISTENT		22	/* get a user's persistent keyring */
 #define KEYCTL_DH_COMPUTE		23	/* Compute Diffie-Hellman values */
+#define KEYCTL_PKEY_QUERY		24	/* Query public key parameters */
+#define KEYCTL_PKEY_ENCRYPT		25	/* Encrypt a blob using a public key */
+#define KEYCTL_PKEY_DECRYPT		26	/* Decrypt a blob using a public key */
+#define KEYCTL_PKEY_SIGN		27	/* Create a public key signature */
+#define KEYCTL_PKEY_VERIFY		28	/* Verify a public key signature */
 #define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
 
 /* keyctl structures */
@@ -87,4 +92,24 @@ struct keyctl_kdf_params {
 #define KEYCTL_SUPPORTS_SIGN		0x04
 #define KEYCTL_SUPPORTS_VERIFY		0x08
 
+struct keyctl_pkey_query {
+	__u32		supported_ops;	/* Which ops are supported */
+	__u32		key_size;	/* Size of the key in bits */
+	__u16		max_data_size;	/* Maximum size of raw data to sign in bytes */
+	__u16		max_sig_size;	/* Maximum size of signature in bytes */
+	__u16		max_enc_size;	/* Maximum size of encrypted blob in bytes */
+	__u16		max_dec_size;	/* Maximum size of decrypted blob in bytes */
+	__u32		__spare[10];
+};
+
+struct keyctl_pkey_params {
+	__s32		key_id;		/* Serial no. of public key to use */
+	__u32		in_len;		/* Input data size */
+	union {
+		__u32		out_len;	/* Output buffer size (encrypt/decrypt/sign) */
+		__u32		in2_len;	/* 2nd input data size (verify) */
+	};
+	__u32		__spare[7];
+};
+
 #endif /*  _LINUX_KEYCTL_H */

commit 70025f84e5b79627a6739533c4fe7cef5b605886
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 9 17:46:51 2018 +0100

    KEYS: Provide key type operations for asymmetric key ops [ver #2]
    
    Provide five new operations in the key_type struct that can be used to
    provide access to asymmetric key operations.  These will be implemented for
    the asymmetric key type in a later patch and may refer to a key retained in
    RAM by the kernel or a key retained in crypto hardware.
    
         int (*asym_query)(const struct kernel_pkey_params *params,
                           struct kernel_pkey_query *info);
         int (*asym_eds_op)(struct kernel_pkey_params *params,
                            const void *in, void *out);
         int (*asym_verify_signature)(struct kernel_pkey_params *params,
                                      const void *in, const void *in2);
    
    Since encrypt, decrypt and sign are identical in their interfaces, they're
    rolled together in the asym_eds_op() operation and there's an operation ID
    in the params argument to distinguish them.
    
    Verify is different in that we supply the data and the signature instead
    and get an error value (or 0) as the only result on the expectation that
    this may well be how a hardware crypto device may work.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Marcel Holtmann <marcel@holtmann.org>
    Reviewed-by: Denis Kenzior <denkenz@gmail.com>
    Tested-by: Denis Kenzior <denkenz@gmail.com>
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 0f3cb13db8e9..1d1e9f2877af 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -82,4 +82,9 @@ struct keyctl_kdf_params {
 	__u32 __spare[8];
 };
 
+#define KEYCTL_SUPPORTS_ENCRYPT		0x01
+#define KEYCTL_SUPPORTS_DECRYPT		0x02
+#define KEYCTL_SUPPORTS_SIGN		0x04
+#define KEYCTL_SUPPORTS_VERIFY		0x08
+
 #endif /*  _LINUX_KEYCTL_H */

commit 2ecefa0a15fd0ef88b9cd5d15ceb813008136431
Author: David Howells <dhowells@redhat.com>
Date:   Fri Sep 28 00:51:20 2018 +0100

    keys: Fix the use of the C++ keyword "private" in uapi/linux/keyctl.h
    
    The keyctl_dh_params struct in uapi/linux/keyctl.h contains the symbol
    "private" which means that the header file will cause compilation failure
    if #included in to a C++ program.  Further, the patch that added the same
    struct to the keyutils package named the symbol "priv", not "private".
    
    The previous attempt to fix this (commit 8a2336e549d3) did so by simply
    renaming the kernel's copy of the field to dh_private, but this then breaks
    existing userspace and as such has been reverted (commit 8c0f9f5b309d).
    
    [And note, to those who think that wrapping the struct in extern "C" {}
     will work: it won't; that only changes how symbol names are presented to
     the assembler and linker.].
    
    Instead, insert an anonymous union around the "private" member and add a
    second member in there with the name "priv" to match the one in the
    keyutils package.  The "private" member is then wrapped in !__cplusplus
    cpp-conditionals to hide it from C++.
    
    Fixes: ddbb41148724 ("KEYS: Add KEYCTL_DH_COMPUTE command")
    Fixes: 8a2336e549d3 ("uapi/linux/keyctl.h: don't use C++ reserved keyword as a struct member name")
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Randy Dunlap <rdunlap@infradead.org>
    cc: Lubomir Rintel <lkundrak@v3.sk>
    cc: James Morris <jmorris@namei.org>
    cc: Mat Martineau <mathew.j.martineau@linux.intel.com>
    cc: Stephan Mueller <smueller@chronox.de>
    cc: Andrew Morton <akpm@linux-foundation.org>
    cc: Linus Torvalds <torvalds@linux-foundation.org>
    cc: stable@vger.kernel.org
    Signed-off-by: James Morris <james.morris@microsoft.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 7b8c9e19bad1..0f3cb13db8e9 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -65,7 +65,12 @@
 
 /* keyctl structures */
 struct keyctl_dh_params {
-	__s32 private;
+	union {
+#ifndef __cplusplus
+		__s32 private;
+#endif
+		__s32 priv;
+	};
 	__s32 prime;
 	__s32 base;
 };

commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index ef16df06642a..7b8c9e19bad1 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
 /* keyctl.h: keyctl command IDs
  *
  * Copyright (C) 2004, 2008 Red Hat, Inc. All Rights Reserved.

commit a77395447b0aeab9473a066ff28fbee01130206b
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Jun 8 14:49:57 2017 +0100

    KEYS: DH: add __user annotations to keyctl_kdf_params
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 201c6644b237..ef16df06642a 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -70,8 +70,8 @@ struct keyctl_dh_params {
 };
 
 struct keyctl_kdf_params {
-	char *hashname;
-	char *otherinfo;
+	char __user *hashname;
+	char __user *otherinfo;
 	__u32 otherinfolen;
 	__u32 __spare[8];
 };

commit f1c316a3ab9d24df6022682422fe897492f2c0c8
Author: Stephan Mueller <smueller@chronox.de>
Date:   Fri Aug 19 20:39:09 2016 +0200

    KEYS: add SP800-56A KDF support for DH
    
    SP800-56A defines the use of DH with key derivation function based on a
    counter. The input to the KDF is defined as (DH shared secret || other
    information). The value for the "other information" is to be provided by
    the caller.
    
    The KDF is implemented using the hash support from the kernel crypto API.
    The implementation uses the symmetric hash support as the input to the
    hash operation is usually very small. The caller is allowed to specify
    the hash name that he wants to use to derive the key material allowing
    the use of all supported hashes provided with the kernel crypto API.
    
    As the KDF implements the proper truncation of the DH shared secret to
    the requested size, this patch fills the caller buffer up to its size.
    
    The patch is tested with a new test added to the keyutils user space
    code which uses a CAVS test vector testing the compliance with
    SP800-56A.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index ff79c44e49a3..201c6644b237 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -69,4 +69,11 @@ struct keyctl_dh_params {
 	__s32 base;
 };
 
+struct keyctl_kdf_params {
+	char *hashname;
+	char *otherinfo;
+	__u32 otherinfolen;
+	__u32 __spare[8];
+};
+
 #endif /*  _LINUX_KEYCTL_H */

commit 6563c91fd645556c7801748f15bc727c77fcd311
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Wed Mar 1 16:44:09 2017 -0800

    KEYS: Add KEYCTL_RESTRICT_KEYRING
    
    Keyrings recently gained restrict_link capabilities that allow
    individual keys to be validated prior to linking.  This functionality
    was only available using internal kernel APIs.
    
    With the KEYCTL_RESTRICT_KEYRING command existing keyrings can be
    configured to check the content of keys before they are linked, and
    then allow or disallow linkage of that key to the keyring.
    
    To restrict a keyring, call:
    
      keyctl(KEYCTL_RESTRICT_KEYRING, key_serial_t keyring, const char *type,
             const char *restriction)
    
    where 'type' is the name of a registered key type and 'restriction' is a
    string describing how key linkage is to be restricted. The restriction
    option syntax is specific to each key type.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 86eddd6241f3..ff79c44e49a3 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -60,6 +60,7 @@
 #define KEYCTL_INVALIDATE		21	/* invalidate a key */
 #define KEYCTL_GET_PERSISTENT		22	/* get a user's persistent keyring */
 #define KEYCTL_DH_COMPUTE		23	/* Compute Diffie-Hellman values */
+#define KEYCTL_RESTRICT_KEYRING		29	/* Restrict keys allowed to link to a keyring */
 
 /* keyctl structures */
 struct keyctl_dh_params {

commit ddbb41148724367394d0880c516bfaeed127b52e
Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
Date:   Tue Apr 12 19:54:58 2016 +0100

    KEYS: Add KEYCTL_DH_COMPUTE command
    
    This adds userspace access to Diffie-Hellman computations through a
    new keyctl() syscall command to calculate shared secrets or public
    keys using input parameters stored in the keyring.
    
    Input key ids are provided in a struct due to the current 5-arg limit
    for the keyctl syscall. Only user keys are supported in order to avoid
    exposing the content of logon or encrypted keys.
    
    The output is written to the provided buffer, based on the assumption
    that the values are only needed in userspace.
    
    Future support for other types of key derivation would involve a new
    command, like KEYCTL_ECDH_COMPUTE.
    
    Once Diffie-Hellman support is included in the crypto API, this code
    can be converted to use the crypto API to take advantage of possible
    hardware acceleration and reduce redundant code.
    
    Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index 840cb990abe2..86eddd6241f3 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -12,6 +12,8 @@
 #ifndef _LINUX_KEYCTL_H
 #define _LINUX_KEYCTL_H
 
+#include <linux/types.h>
+
 /* special process keyring shortcut IDs */
 #define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
 #define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
@@ -57,5 +59,13 @@
 #define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
 #define KEYCTL_INVALIDATE		21	/* invalidate a key */
 #define KEYCTL_GET_PERSISTENT		22	/* get a user's persistent keyring */
+#define KEYCTL_DH_COMPUTE		23	/* Compute Diffie-Hellman values */
+
+/* keyctl structures */
+struct keyctl_dh_params {
+	__s32 private;
+	__s32 prime;
+	__s32 base;
+};
 
 #endif /*  _LINUX_KEYCTL_H */

commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Sep 24 10:35:19 2013 +0100

    KEYS: Add per-user_namespace registers for persistent per-UID kerberos caches
    
    Add support for per-user_namespace registers of persistent per-UID kerberos
    caches held within the kernel.
    
    This allows the kerberos cache to be retained beyond the life of all a user's
    processes so that the user's cron jobs can work.
    
    The kerberos cache is envisioned as a keyring/key tree looking something like:
    
            struct user_namespace
              \___ .krb_cache keyring               - The register
                    \___ _krb.0 keyring             - Root's Kerberos cache
                    \___ _krb.5000 keyring          - User 5000's Kerberos cache
                    \___ _krb.5001 keyring          - User 5001's Kerberos cache
                            \___ tkt785 big_key     - A ccache blob
                            \___ tkt12345 big_key   - Another ccache blob
    
    Or possibly:
    
            struct user_namespace
              \___ .krb_cache keyring               - The register
                    \___ _krb.0 keyring             - Root's Kerberos cache
                    \___ _krb.5000 keyring          - User 5000's Kerberos cache
                    \___ _krb.5001 keyring          - User 5001's Kerberos cache
                            \___ tkt785 keyring     - A ccache
                                    \___ krbtgt/REDHAT.COM@REDHAT.COM big_key
                                    \___ http/REDHAT.COM@REDHAT.COM user
                                    \___ afs/REDHAT.COM@REDHAT.COM user
                                    \___ nfs/REDHAT.COM@REDHAT.COM user
                                    \___ krbtgt/KERNEL.ORG@KERNEL.ORG big_key
                                    \___ http/KERNEL.ORG@KERNEL.ORG big_key
    
    What goes into a particular Kerberos cache is entirely up to userspace.  Kernel
    support is limited to giving you the Kerberos cache keyring that you want.
    
    The user asks for their Kerberos cache by:
    
            krb_cache = keyctl_get_krbcache(uid, dest_keyring);
    
    The uid is -1 or the user's own UID for the user's own cache or the uid of some
    other user's cache (requires CAP_SETUID).  This permits rpc.gssd or whatever to
    mess with the cache.
    
    The cache returned is a keyring named "_krb.<uid>" that the possessor can read,
    search, clear, invalidate, unlink from and add links to.  Active LSMs get a
    chance to rule on whether the caller is permitted to make a link.
    
    Each uid's cache keyring is created when it first accessed and is given a
    timeout that is extended each time this function is called so that the keyring
    goes away after a while.  The timeout is configurable by sysctl but defaults to
    three days.
    
    Each user_namespace struct gets a lazily-created keyring that serves as the
    register.  The cache keyrings are added to it.  This means that standard key
    search and garbage collection facilities are available.
    
    The user_namespace struct's register goes away when it does and anything left
    in it is then automatically gc'd.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Simo Sorce <simo@redhat.com>
    cc: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    cc: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
index c9b7f4faf97a..840cb990abe2 100644
--- a/include/uapi/linux/keyctl.h
+++ b/include/uapi/linux/keyctl.h
@@ -56,5 +56,6 @@
 #define KEYCTL_REJECT			19	/* reject a partially constructed key */
 #define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
 #define KEYCTL_INVALIDATE		21	/* invalidate a key */
+#define KEYCTL_GET_PERSISTENT		22	/* get a user's persistent keyring */
 
 #endif /*  _LINUX_KEYCTL_H */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/keyctl.h b/include/uapi/linux/keyctl.h
new file mode 100644
index 000000000000..c9b7f4faf97a
--- /dev/null
+++ b/include/uapi/linux/keyctl.h
@@ -0,0 +1,60 @@
+/* keyctl.h: keyctl command IDs
+ *
+ * Copyright (C) 2004, 2008 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _LINUX_KEYCTL_H
+#define _LINUX_KEYCTL_H
+
+/* special process keyring shortcut IDs */
+#define KEY_SPEC_THREAD_KEYRING		-1	/* - key ID for thread-specific keyring */
+#define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
+#define KEY_SPEC_SESSION_KEYRING	-3	/* - key ID for session-specific keyring */
+#define KEY_SPEC_USER_KEYRING		-4	/* - key ID for UID-specific keyring */
+#define KEY_SPEC_USER_SESSION_KEYRING	-5	/* - key ID for UID-session keyring */
+#define KEY_SPEC_GROUP_KEYRING		-6	/* - key ID for GID-specific keyring */
+#define KEY_SPEC_REQKEY_AUTH_KEY	-7	/* - key ID for assumed request_key auth key */
+#define KEY_SPEC_REQUESTOR_KEYRING	-8	/* - key ID for request_key() dest keyring */
+
+/* request-key default keyrings */
+#define KEY_REQKEY_DEFL_NO_CHANGE		-1
+#define KEY_REQKEY_DEFL_DEFAULT			0
+#define KEY_REQKEY_DEFL_THREAD_KEYRING		1
+#define KEY_REQKEY_DEFL_PROCESS_KEYRING		2
+#define KEY_REQKEY_DEFL_SESSION_KEYRING		3
+#define KEY_REQKEY_DEFL_USER_KEYRING		4
+#define KEY_REQKEY_DEFL_USER_SESSION_KEYRING	5
+#define KEY_REQKEY_DEFL_GROUP_KEYRING		6
+#define KEY_REQKEY_DEFL_REQUESTOR_KEYRING	7
+
+/* keyctl commands */
+#define KEYCTL_GET_KEYRING_ID		0	/* ask for a keyring's ID */
+#define KEYCTL_JOIN_SESSION_KEYRING	1	/* join or start named session keyring */
+#define KEYCTL_UPDATE			2	/* update a key */
+#define KEYCTL_REVOKE			3	/* revoke a key */
+#define KEYCTL_CHOWN			4	/* set ownership of a key */
+#define KEYCTL_SETPERM			5	/* set perms on a key */
+#define KEYCTL_DESCRIBE			6	/* describe a key */
+#define KEYCTL_CLEAR			7	/* clear contents of a keyring */
+#define KEYCTL_LINK			8	/* link a key into a keyring */
+#define KEYCTL_UNLINK			9	/* unlink a key from a keyring */
+#define KEYCTL_SEARCH			10	/* search for a key in a keyring */
+#define KEYCTL_READ			11	/* read a key or keyring's contents */
+#define KEYCTL_INSTANTIATE		12	/* instantiate a partially constructed key */
+#define KEYCTL_NEGATE			13	/* negate a partially constructed key */
+#define KEYCTL_SET_REQKEY_KEYRING	14	/* set default request-key keyring */
+#define KEYCTL_SET_TIMEOUT		15	/* set key timeout */
+#define KEYCTL_ASSUME_AUTHORITY		16	/* assume request_key() authorisation */
+#define KEYCTL_GET_SECURITY		17	/* get key security label */
+#define KEYCTL_SESSION_TO_PARENT	18	/* apply session keyring to parent process */
+#define KEYCTL_REJECT			19	/* reject a partially constructed key */
+#define KEYCTL_INSTANTIATE_IOV		20	/* instantiate a partially constructed key */
+#define KEYCTL_INVALIDATE		21	/* invalidate a key */
+
+#endif /*  _LINUX_KEYCTL_H */
