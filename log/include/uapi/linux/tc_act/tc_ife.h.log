commit 257eeded20b34219d5484cfc415b3e39093f37b8
Author: Eli Cohen <eli@mellanox.com>
Date:   Sun Feb 10 14:24:59 2019 +0200

    net: Move all TC actions identifiers to one place
    
    Move all the TC identifiers to one place, to the same enum that defines
    the identifier of police action. This makes it easier choose numbers for
    new actions since they are now defined in one place. We preserve the
    original values for binary compatibility. New IDs should be added inside
    the enum.
    
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
index 2f48490ef386..8c401f185675 100644
--- a/include/uapi/linux/tc_act/tc_ife.h
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -6,7 +6,6 @@
 #include <linux/pkt_cls.h>
 #include <linux/ife.h>
 
-#define TCA_ACT_IFE 25
 /* Flag bits for now just encoding/decoding; mutually exclusive */
 #define IFE_ENCODE 1
 #define IFE_DECODE 0

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
index 7c2817866c97..2f48490ef386 100644
--- a/include/uapi/linux/tc_act/tc_ife.h
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef __UAPI_TC_IFE_H
 #define __UAPI_TC_IFE_H
 

commit 295a6e06d21e1f469c9f38b00125a13b60ad4e7c
Author: Yotam Gigi <yotamg@mellanox.com>
Date:   Wed Feb 1 15:30:03 2017 +0200

    net/sched: act_ife: Change to use ife module
    
    Use the encode/decode functionality from the ife module instead of using
    implementation inside the act_ife.
    
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: Yotam Gigi <yotamg@mellanox.com>
    Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: Roman Mashak <mrv@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
index cd18360eca24..7c2817866c97 100644
--- a/include/uapi/linux/tc_act/tc_ife.h
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -3,6 +3,7 @@
 
 #include <linux/types.h>
 #include <linux/pkt_cls.h>
+#include <linux/ife.h>
 
 #define TCA_ACT_IFE 25
 /* Flag bits for now just encoding/decoding; mutually exclusive */
@@ -28,13 +29,4 @@ enum {
 };
 #define TCA_IFE_MAX (__TCA_IFE_MAX - 1)
 
-#define IFE_META_SKBMARK 1
-#define IFE_META_HASHID 2
-#define	IFE_META_PRIO 3
-#define	IFE_META_QMAP 4
-#define	IFE_META_TCINDEX 5
-/*Can be overridden at runtime by module option*/
-#define	__IFE_META_MAX 6
-#define IFE_META_MAX (__IFE_META_MAX - 1)
-
 #endif

commit 408fbc22ef1efb00dd896acd00e9f7d9b641e047
Author: Jamal Hadi Salim <jhs@mojatatu.com>
Date:   Sun Sep 18 07:31:43 2016 -0400

    net sched ife action: Introduce skb tcindex metadata encap decap
    
    Sample use case of how this is encoded:
    user space via tuntap (or a connected VM/Machine/container)
    encodes the tcindex TLV.
    
    Sample use case of decoding:
    IFE action decodes it and the skb->tc_index is then used to classify.
    So something like this for encoded ICMP packets:
    
    .. first decode then reclassify... skb->tcindex will be set
    sudo $TC filter add dev $ETH parent ffff: prio 2 protocol 0xbeef \
    u32 match u32 0 0 flowid 1:1 \
    action ife decode reclassify
    
    ...next match the decode icmp packet...
    sudo $TC filter add dev $ETH parent ffff: prio 4 protocol ip \
    u32 match ip protocol 1 0xff flowid 1:1 \
    action continue
    
    ... last classify it using the tcindex classifier and do someaction..
    sudo $TC filter add dev $ETH parent ffff: prio 5 protocol ip \
    handle 0x11 tcindex classid 1:1 \
    action blah..
    
    Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
index 4ece02a77b9a..cd18360eca24 100644
--- a/include/uapi/linux/tc_act/tc_ife.h
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -32,8 +32,9 @@ enum {
 #define IFE_META_HASHID 2
 #define	IFE_META_PRIO 3
 #define	IFE_META_QMAP 4
+#define	IFE_META_TCINDEX 5
 /*Can be overridden at runtime by module option*/
-#define	__IFE_META_MAX 5
+#define	__IFE_META_MAX 6
 #define IFE_META_MAX (__IFE_META_MAX - 1)
 
 #endif

commit 9854518ea04db33738602d45ebc96a200e6f5198
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Tue Apr 26 10:06:18 2016 +0200

    sched: align nlattr properly when needed
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
index d648ff66586f..4ece02a77b9a 100644
--- a/include/uapi/linux/tc_act/tc_ife.h
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -23,6 +23,7 @@ enum {
 	TCA_IFE_SMAC,
 	TCA_IFE_TYPE,
 	TCA_IFE_METALST,
+	TCA_IFE_PAD,
 	__TCA_IFE_MAX
 };
 #define TCA_IFE_MAX (__TCA_IFE_MAX - 1)

commit ef6980b6becb1afd9d82a4f043749a10ae81bf14
Author: Jamal Hadi Salim <jhs@mojatatu.com>
Date:   Sat Feb 27 08:08:54 2016 -0500

    introduce IFE action
    
    This action allows for a sending side to encapsulate arbitrary metadata
    which is decapsulated by the receiving end.
    The sender runs in encoding mode and the receiver in decode mode.
    Both sender and receiver must specify the same ethertype.
    At some point we hope to have a registered ethertype and we'll
    then provide a default so the user doesnt have to specify it.
    For now we enforce the user specify it.
    
    Lets show example usage where we encode icmp from a sender towards
    a receiver with an skbmark of 17; both sender and receiver use
    ethertype of 0xdead to interop.
    
    YYYY: Lets start with Receiver-side policy config:
    xxx: add an ingress qdisc
    sudo tc qdisc add dev $ETH ingress
    
    xxx: any packets with ethertype 0xdead will be subjected to ife decoding
    xxx: we then restart the classification so we can match on icmp at prio 3
    sudo $TC filter add dev $ETH parent ffff: prio 2 protocol 0xdead \
    u32 match u32 0 0 flowid 1:1 \
    action ife decode reclassify
    
    xxx: on restarting the classification from above if it was an icmp
    xxx: packet, then match it here and continue to the next rule at prio 4
    xxx: which will match based on skb mark of 17
    sudo tc filter add dev $ETH parent ffff: prio 3 protocol ip \
    u32 match ip protocol 1 0xff flowid 1:1 \
    action continue
    
    xxx: match on skbmark of 0x11 (decimal 17) and accept
    sudo tc filter add dev $ETH parent ffff: prio 4 protocol ip \
    handle 0x11 fw flowid 1:1 \
    action ok
    
    xxx: Lets show the decoding policy
    sudo tc -s filter ls dev $ETH parent ffff: protocol 0xdead
    xxx:
    filter pref 2 u32
    filter pref 2 u32 fh 800: ht divisor 1
    filter pref 2 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1  (rule hit 0 success 0)
      match 00000000/00000000 at 0 (success 0 )
            action order 1: ife decode action reclassify
             index 1 ref 1 bind 1 installed 14 sec used 14 sec
             type: 0x0
             Metadata: allow mark allow hash allow prio allow qmap
            Action statistics:
            Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
            backlog 0b 0p requeues 0
    xxx:
    Observe that above lists all metadatum it can decode. Typically these
    submodules will already be compiled into a monolithic kernel or
    loaded as modules
    
    YYYY: Lets show the sender side now ..
    
    xxx: Add an egress qdisc on the sender netdev
    sudo tc qdisc add dev $ETH root handle 1: prio
    xxx:
    xxx: Match all icmp packets to 192.168.122.237/24, then
    xxx: tag the packet with skb mark of decimal 17, then
    xxx: Encode it with:
    xxx:    ethertype 0xdead
    xxx:    add skb->mark to whitelist of metadatum to send
    xxx:    rewrite target dst MAC address to 02:15:15:15:15:15
    xxx:
    sudo $TC filter add dev $ETH parent 1: protocol ip prio 10  u32 \
    match ip dst 192.168.122.237/24 \
    match ip protocol 1 0xff \
    flowid 1:2 \
    action skbedit mark 17 \
    action ife encode \
    type 0xDEAD \
    allow mark \
    dst 02:15:15:15:15:15
    
    xxx: Lets show the encoding policy
    sudo tc -s filter ls dev $ETH parent 1: protocol ip
    xxx:
    filter pref 10 u32
    filter pref 10 u32 fh 800: ht divisor 1
    filter pref 10 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:2  (rule hit 0 success 0)
      match c0a87aed/ffffffff at 16 (success 0 )
      match 00010000/00ff0000 at 8 (success 0 )
    
            action order 1:  skbedit mark 17
             index 6 ref 1 bind 1
            Action statistics:
            Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
            backlog 0b 0p requeues 0
    
            action order 2: ife encode action pipe
             index 3 ref 1 bind 1
             dst MAC: 02:15:15:15:15:15 type: 0xDEAD
             Metadata: allow mark
            Action statistics:
            Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
            backlog 0b 0p requeues 0
    xxx:
    
    test by sending ping from sender to destination
    
    Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/tc_act/tc_ife.h b/include/uapi/linux/tc_act/tc_ife.h
new file mode 100644
index 000000000000..d648ff66586f
--- /dev/null
+++ b/include/uapi/linux/tc_act/tc_ife.h
@@ -0,0 +1,38 @@
+#ifndef __UAPI_TC_IFE_H
+#define __UAPI_TC_IFE_H
+
+#include <linux/types.h>
+#include <linux/pkt_cls.h>
+
+#define TCA_ACT_IFE 25
+/* Flag bits for now just encoding/decoding; mutually exclusive */
+#define IFE_ENCODE 1
+#define IFE_DECODE 0
+
+struct tc_ife {
+	tc_gen;
+	__u16 flags;
+};
+
+/*XXX: We need to encode the total number of bytes consumed */
+enum {
+	TCA_IFE_UNSPEC,
+	TCA_IFE_PARMS,
+	TCA_IFE_TM,
+	TCA_IFE_DMAC,
+	TCA_IFE_SMAC,
+	TCA_IFE_TYPE,
+	TCA_IFE_METALST,
+	__TCA_IFE_MAX
+};
+#define TCA_IFE_MAX (__TCA_IFE_MAX - 1)
+
+#define IFE_META_SKBMARK 1
+#define IFE_META_HASHID 2
+#define	IFE_META_PRIO 3
+#define	IFE_META_QMAP 4
+/*Can be overridden at runtime by module option*/
+#define	__IFE_META_MAX 5
+#define IFE_META_MAX (__IFE_META_MAX - 1)
+
+#endif
