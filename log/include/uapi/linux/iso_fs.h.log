commit f14fc0ccee5521e5b38cdd1df4385d32c6e1805b
Merge: 23281c803487 838bee9e756e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 14:13:11 2017 -0800

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull quota, ext2, isofs and udf fixes from Jan Kara:
    
     - two small quota error handling fixes
    
     - two isofs fixes for architectures with signed char
    
     - several udf block number overflow and signedness fixes
    
     - ext2 rework of mount option handling to avoid GFP_KERNEL allocation
       with spinlock held
    
     - ... it also contains a patch to implement auditing of responses to
       fanotify permission events. That should have been in the fanotify
       pull request but I mistakenly merged that patch into a wrong branch
       and noticed only now at which point I don't think it's worth rebasing
       and redoing.
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      quota: be aware of error from dquot_initialize
      quota: fix potential infinite loop
      isofs: use unsigned char types consistently
      isofs: fix timestamps beyond 2027
      udf: Fix some sign-conversion warnings
      udf: Fix signed/unsigned format specifiers
      udf: Fix 64-bit sign extension issues affecting blocks > 0x7FFFFFFF
      udf: Remove some outdate references from documentation
      udf: Avoid overflow when session starts at large offset
      ext2: Fix possible sleep in atomic during mount option parsing
      ext2: Parse mount options into a dedicated structure
      audit: Record fanotify access control decisions

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/iso_fs.h b/include/uapi/linux/iso_fs.h
index 4688ac4284e2..78b4ebcf8ab0 100644
--- a/include/uapi/linux/iso_fs.h
+++ b/include/uapi/linux/iso_fs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _ISOFS_FS_H
 #define _ISOFS_FS_H
 

commit cb91775711b2f3f7adea8d33aa83104baf75ee07
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Oct 19 16:47:49 2017 +0200

    isofs: use unsigned char types consistently
    
    Based on the discussion about the signed character field for the year,
    I went through all fields in the iso9660 and rockridge standards to see
    whether they should used signed or unsigned characters. Only a single
    8-bit value is defined as signed per 'section 7.1.2': the timezone
    offset in a timestamp, this has always been handled correctly through
    explicit sign-extension.
    
    All others are either '7.1.1 8-bit unsigned numerical values' or
    composite fields. I also read the linux source code and came to the
    same conclusion, also I could not find any other part of the
    implementation that actually behaves differently for signed or
    unsigned values.
    
    Since it is still ambigous to use plain 'char' in interface definitions,
    I'm changing all fields representing numbers and reserved bytes to
    the unambiguous '__u8'. Fields that hold actual strings are left as
    'char' arrays. I built the code with '-Wpointer-sign -Wsign-compare'
    to see if anything got left out, but couldn't find anything wrong
    with the remaining warnings.
    
    This patch should not change runtime behavior and does not need to
    be backported.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/uapi/linux/iso_fs.h b/include/uapi/linux/iso_fs.h
index 4688ac4284e2..07c4c6405b3c 100644
--- a/include/uapi/linux/iso_fs.h
+++ b/include/uapi/linux/iso_fs.h
@@ -12,10 +12,10 @@
 #define ISODCL(from, to) (to - from + 1)
 
 struct iso_volume_descriptor {
-	char type[ISODCL(1,1)]; /* 711 */
+	__u8 type[ISODCL(1,1)]; /* 711 */
 	char id[ISODCL(2,6)];
-	char version[ISODCL(7,7)];
-	char data[ISODCL(8,2048)];
+	__u8 version[ISODCL(7,7)];
+	__u8 data[ISODCL(8,2048)];
 };
 
 /* volume descriptor types */
@@ -26,24 +26,24 @@ struct iso_volume_descriptor {
 #define ISO_STANDARD_ID "CD001"
 
 struct iso_primary_descriptor {
-	char type			[ISODCL (  1,   1)]; /* 711 */
+	__u8 type			[ISODCL (  1,   1)]; /* 711 */
 	char id				[ISODCL (  2,   6)];
-	char version			[ISODCL (  7,   7)]; /* 711 */
-	char unused1			[ISODCL (  8,   8)];
+	__u8 version			[ISODCL (  7,   7)]; /* 711 */
+	__u8 unused1			[ISODCL (  8,   8)];
 	char system_id			[ISODCL (  9,  40)]; /* achars */
 	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
-	char unused2			[ISODCL ( 73,  80)];
-	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
-	char unused3			[ISODCL ( 89, 120)];
-	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
-	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
-	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
-	char path_table_size		[ISODCL (133, 140)]; /* 733 */
-	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
-	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
-	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
-	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
-	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	__u8 unused2			[ISODCL ( 73,  80)];
+	__u8 volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	__u8 unused3			[ISODCL ( 89, 120)];
+	__u8 volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	__u8 volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	__u8 logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	__u8 path_table_size		[ISODCL (133, 140)]; /* 733 */
+	__u8 type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	__u8 opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	__u8 type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	__u8 opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	__u8 root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
 	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
 	char publisher_id		[ISODCL (319, 446)]; /* achars */
 	char preparer_id		[ISODCL (447, 574)]; /* achars */
@@ -51,36 +51,36 @@ struct iso_primary_descriptor {
 	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
 	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
 	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
-	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
-	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
-	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
-	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
-	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
-	char unused4			[ISODCL (883, 883)];
-	char application_data		[ISODCL (884, 1395)];
-	char unused5			[ISODCL (1396, 2048)];
+	__u8 creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	__u8 modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	__u8 expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	__u8 effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	__u8 file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	__u8 unused4			[ISODCL (883, 883)];
+	__u8 application_data		[ISODCL (884, 1395)];
+	__u8 unused5			[ISODCL (1396, 2048)];
 };
 
 /* Almost the same as the primary descriptor but two fields are specified */
 struct iso_supplementary_descriptor {
-	char type			[ISODCL (  1,   1)]; /* 711 */
+	__u8 type			[ISODCL (  1,   1)]; /* 711 */
 	char id				[ISODCL (  2,   6)];
-	char version			[ISODCL (  7,   7)]; /* 711 */
-	char flags			[ISODCL (  8,   8)]; /* 853 */
+	__u8 version			[ISODCL (  7,   7)]; /* 711 */
+	__u8 flags			[ISODCL (  8,   8)]; /* 853 */
 	char system_id			[ISODCL (  9,  40)]; /* achars */
 	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
-	char unused2			[ISODCL ( 73,  80)];
-	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
-	char escape			[ISODCL ( 89, 120)]; /* 856 */
-	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
-	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
-	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
-	char path_table_size		[ISODCL (133, 140)]; /* 733 */
-	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
-	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
-	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
-	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
-	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	__u8 unused2			[ISODCL ( 73,  80)];
+	__u8 volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	__u8 escape			[ISODCL ( 89, 120)]; /* 856 */
+	__u8 volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	__u8 volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	__u8 logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	__u8 path_table_size		[ISODCL (133, 140)]; /* 733 */
+	__u8 type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	__u8 opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	__u8 type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	__u8 opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	__u8 root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
 	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
 	char publisher_id		[ISODCL (319, 446)]; /* achars */
 	char preparer_id		[ISODCL (447, 574)]; /* achars */
@@ -88,54 +88,54 @@ struct iso_supplementary_descriptor {
 	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
 	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
 	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
-	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
-	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
-	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
-	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
-	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
-	char unused4			[ISODCL (883, 883)];
-	char application_data		[ISODCL (884, 1395)];
-	char unused5			[ISODCL (1396, 2048)];
+	__u8 creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	__u8 modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	__u8 expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	__u8 effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	__u8 file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	__u8 unused4			[ISODCL (883, 883)];
+	__u8 application_data		[ISODCL (884, 1395)];
+	__u8 unused5			[ISODCL (1396, 2048)];
 };
 
 
 #define HS_STANDARD_ID "CDROM"
 
 struct  hs_volume_descriptor {
-	char foo			[ISODCL (  1,   8)]; /* 733 */
-	char type			[ISODCL (  9,   9)]; /* 711 */
+	__u8 foo			[ISODCL (  1,   8)]; /* 733 */
+	__u8 type			[ISODCL (  9,   9)]; /* 711 */
 	char id				[ISODCL ( 10,  14)];
-	char version			[ISODCL ( 15,  15)]; /* 711 */
-	char data[ISODCL(16,2048)];
+	__u8 version			[ISODCL ( 15,  15)]; /* 711 */
+	__u8 data[ISODCL(16,2048)];
 };
 
 
 struct hs_primary_descriptor {
-	char foo			[ISODCL (  1,   8)]; /* 733 */
-	char type			[ISODCL (  9,   9)]; /* 711 */
-	char id				[ISODCL ( 10,  14)];
-	char version			[ISODCL ( 15,  15)]; /* 711 */
-	char unused1			[ISODCL ( 16,  16)]; /* 711 */
+	__u8 foo			[ISODCL (  1,   8)]; /* 733 */
+	__u8 type			[ISODCL (  9,   9)]; /* 711 */
+	__u8 id				[ISODCL ( 10,  14)];
+	__u8 version			[ISODCL ( 15,  15)]; /* 711 */
+	__u8 unused1			[ISODCL ( 16,  16)]; /* 711 */
 	char system_id			[ISODCL ( 17,  48)]; /* achars */
 	char volume_id			[ISODCL ( 49,  80)]; /* dchars */
-	char unused2			[ISODCL ( 81,  88)]; /* 733 */
-	char volume_space_size		[ISODCL ( 89,  96)]; /* 733 */
-	char unused3			[ISODCL ( 97, 128)]; /* 733 */
-	char volume_set_size		[ISODCL (129, 132)]; /* 723 */
-	char volume_sequence_number	[ISODCL (133, 136)]; /* 723 */
-	char logical_block_size		[ISODCL (137, 140)]; /* 723 */
-	char path_table_size		[ISODCL (141, 148)]; /* 733 */
-	char type_l_path_table		[ISODCL (149, 152)]; /* 731 */
-	char unused4			[ISODCL (153, 180)]; /* 733 */
-	char root_directory_record	[ISODCL (181, 214)]; /* 9.1 */
+	__u8 unused2			[ISODCL ( 81,  88)]; /* 733 */
+	__u8 volume_space_size		[ISODCL ( 89,  96)]; /* 733 */
+	__u8 unused3			[ISODCL ( 97, 128)]; /* 733 */
+	__u8 volume_set_size		[ISODCL (129, 132)]; /* 723 */
+	__u8 volume_sequence_number	[ISODCL (133, 136)]; /* 723 */
+	__u8 logical_block_size		[ISODCL (137, 140)]; /* 723 */
+	__u8 path_table_size		[ISODCL (141, 148)]; /* 733 */
+	__u8 type_l_path_table		[ISODCL (149, 152)]; /* 731 */
+	__u8 unused4			[ISODCL (153, 180)]; /* 733 */
+	__u8 root_directory_record	[ISODCL (181, 214)]; /* 9.1 */
 };
 
 /* We use this to help us look up the parent inode numbers. */
 
 struct iso_path_table{
-	unsigned char  name_len[2];	/* 721 */
-	char extent[4];		/* 731 */
-	char  parent[2];	/* 721 */
+	__u8  name_len[2];	/* 721 */
+	__u8  extent[4];	/* 731 */
+	__u8  parent[2];	/* 721 */
 	char name[0];
 } __attribute__((packed));
 
@@ -143,16 +143,16 @@ struct iso_path_table{
    there is an extra reserved byte after the flags */
 
 struct iso_directory_record {
-	char length			[ISODCL (1, 1)]; /* 711 */
-	char ext_attr_length		[ISODCL (2, 2)]; /* 711 */
-	char extent			[ISODCL (3, 10)]; /* 733 */
-	char size			[ISODCL (11, 18)]; /* 733 */
-	char date			[ISODCL (19, 25)]; /* 7 by 711 */
-	char flags			[ISODCL (26, 26)];
-	char file_unit_size		[ISODCL (27, 27)]; /* 711 */
-	char interleave			[ISODCL (28, 28)]; /* 711 */
-	char volume_sequence_number	[ISODCL (29, 32)]; /* 723 */
-	unsigned char name_len		[ISODCL (33, 33)]; /* 711 */
+	__u8 length			[ISODCL (1, 1)]; /* 711 */
+	__u8 ext_attr_length		[ISODCL (2, 2)]; /* 711 */
+	__u8 extent			[ISODCL (3, 10)]; /* 733 */
+	__u8 size			[ISODCL (11, 18)]; /* 733 */
+	__u8 date			[ISODCL (19, 25)]; /* 7 by 711 */
+	__u8 flags			[ISODCL (26, 26)];
+	__u8 file_unit_size		[ISODCL (27, 27)]; /* 711 */
+	__u8 interleave			[ISODCL (28, 28)]; /* 711 */
+	__u8 volume_sequence_number	[ISODCL (29, 32)]; /* 723 */
+	__u8 name_len			[ISODCL (33, 33)]; /* 711 */
 	char name			[0];
 } __attribute__((packed));
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/iso_fs.h b/include/uapi/linux/iso_fs.h
new file mode 100644
index 000000000000..4688ac4284e2
--- /dev/null
+++ b/include/uapi/linux/iso_fs.h
@@ -0,0 +1,165 @@
+#ifndef _ISOFS_FS_H
+#define _ISOFS_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/*
+ * The isofs filesystem constants/structures
+ */
+
+/* This part borrowed from the bsd386 isofs */
+#define ISODCL(from, to) (to - from + 1)
+
+struct iso_volume_descriptor {
+	char type[ISODCL(1,1)]; /* 711 */
+	char id[ISODCL(2,6)];
+	char version[ISODCL(7,7)];
+	char data[ISODCL(8,2048)];
+};
+
+/* volume descriptor types */
+#define ISO_VD_PRIMARY 1
+#define ISO_VD_SUPPLEMENTARY 2
+#define ISO_VD_END 255
+
+#define ISO_STANDARD_ID "CD001"
+
+struct iso_primary_descriptor {
+	char type			[ISODCL (  1,   1)]; /* 711 */
+	char id				[ISODCL (  2,   6)];
+	char version			[ISODCL (  7,   7)]; /* 711 */
+	char unused1			[ISODCL (  8,   8)];
+	char system_id			[ISODCL (  9,  40)]; /* achars */
+	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
+	char unused2			[ISODCL ( 73,  80)];
+	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	char unused3			[ISODCL ( 89, 120)];
+	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	char path_table_size		[ISODCL (133, 140)]; /* 733 */
+	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
+	char publisher_id		[ISODCL (319, 446)]; /* achars */
+	char preparer_id		[ISODCL (447, 574)]; /* achars */
+	char application_id		[ISODCL (575, 702)]; /* achars */
+	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
+	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
+	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
+	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	char unused4			[ISODCL (883, 883)];
+	char application_data		[ISODCL (884, 1395)];
+	char unused5			[ISODCL (1396, 2048)];
+};
+
+/* Almost the same as the primary descriptor but two fields are specified */
+struct iso_supplementary_descriptor {
+	char type			[ISODCL (  1,   1)]; /* 711 */
+	char id				[ISODCL (  2,   6)];
+	char version			[ISODCL (  7,   7)]; /* 711 */
+	char flags			[ISODCL (  8,   8)]; /* 853 */
+	char system_id			[ISODCL (  9,  40)]; /* achars */
+	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
+	char unused2			[ISODCL ( 73,  80)];
+	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
+	char escape			[ISODCL ( 89, 120)]; /* 856 */
+	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
+	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
+	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
+	char path_table_size		[ISODCL (133, 140)]; /* 733 */
+	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
+	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
+	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
+	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
+	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
+	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
+	char publisher_id		[ISODCL (319, 446)]; /* achars */
+	char preparer_id		[ISODCL (447, 574)]; /* achars */
+	char application_id		[ISODCL (575, 702)]; /* achars */
+	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
+	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
+	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
+	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
+	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
+	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
+	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
+	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
+	char unused4			[ISODCL (883, 883)];
+	char application_data		[ISODCL (884, 1395)];
+	char unused5			[ISODCL (1396, 2048)];
+};
+
+
+#define HS_STANDARD_ID "CDROM"
+
+struct  hs_volume_descriptor {
+	char foo			[ISODCL (  1,   8)]; /* 733 */
+	char type			[ISODCL (  9,   9)]; /* 711 */
+	char id				[ISODCL ( 10,  14)];
+	char version			[ISODCL ( 15,  15)]; /* 711 */
+	char data[ISODCL(16,2048)];
+};
+
+
+struct hs_primary_descriptor {
+	char foo			[ISODCL (  1,   8)]; /* 733 */
+	char type			[ISODCL (  9,   9)]; /* 711 */
+	char id				[ISODCL ( 10,  14)];
+	char version			[ISODCL ( 15,  15)]; /* 711 */
+	char unused1			[ISODCL ( 16,  16)]; /* 711 */
+	char system_id			[ISODCL ( 17,  48)]; /* achars */
+	char volume_id			[ISODCL ( 49,  80)]; /* dchars */
+	char unused2			[ISODCL ( 81,  88)]; /* 733 */
+	char volume_space_size		[ISODCL ( 89,  96)]; /* 733 */
+	char unused3			[ISODCL ( 97, 128)]; /* 733 */
+	char volume_set_size		[ISODCL (129, 132)]; /* 723 */
+	char volume_sequence_number	[ISODCL (133, 136)]; /* 723 */
+	char logical_block_size		[ISODCL (137, 140)]; /* 723 */
+	char path_table_size		[ISODCL (141, 148)]; /* 733 */
+	char type_l_path_table		[ISODCL (149, 152)]; /* 731 */
+	char unused4			[ISODCL (153, 180)]; /* 733 */
+	char root_directory_record	[ISODCL (181, 214)]; /* 9.1 */
+};
+
+/* We use this to help us look up the parent inode numbers. */
+
+struct iso_path_table{
+	unsigned char  name_len[2];	/* 721 */
+	char extent[4];		/* 731 */
+	char  parent[2];	/* 721 */
+	char name[0];
+} __attribute__((packed));
+
+/* high sierra is identical to iso, except that the date is only 6 bytes, and
+   there is an extra reserved byte after the flags */
+
+struct iso_directory_record {
+	char length			[ISODCL (1, 1)]; /* 711 */
+	char ext_attr_length		[ISODCL (2, 2)]; /* 711 */
+	char extent			[ISODCL (3, 10)]; /* 733 */
+	char size			[ISODCL (11, 18)]; /* 733 */
+	char date			[ISODCL (19, 25)]; /* 7 by 711 */
+	char flags			[ISODCL (26, 26)];
+	char file_unit_size		[ISODCL (27, 27)]; /* 711 */
+	char interleave			[ISODCL (28, 28)]; /* 711 */
+	char volume_sequence_number	[ISODCL (29, 32)]; /* 723 */
+	unsigned char name_len		[ISODCL (33, 33)]; /* 711 */
+	char name			[0];
+} __attribute__((packed));
+
+#define ISOFS_BLOCK_BITS 11
+#define ISOFS_BLOCK_SIZE 2048
+
+#define ISOFS_BUFFER_SIZE(INODE) ((INODE)->i_sb->s_blocksize)
+#define ISOFS_BUFFER_BITS(INODE) ((INODE)->i_sb->s_blocksize_bits)
+
+#endif /* _ISOFS_FS_H */
