commit d19dc016187502dda6b8095e44eb46a18e89b2b3
Author: Carmeli Tamir <carmeli.tamir@gmail.com>
Date:   Thu Jan 3 15:27:56 2019 -0800

    fat: move MAX_FAT to fat.h and change it to inline function
    
    MAX_FAT is useless in msdos_fs.h, since it uses the MSDOS_SB function
    that is defined in fat.h.  So really, this macro can be only called from
    code that already includes fat.h.
    
    Hence, this patch moves it to fat.h, right after MSDOS_SB is defined.  I
    also changed it to an inline function in order to save the double call
    to MSDOS_SB.  This was suggested by joe@perches.com in the previous
    version.
    
    This patch is required for the next in the series, in which the variant
    (whether this is FAT12, FAT16 or FAT32) checks are replaced with new
    macros.
    
    Link: http://lkml.kernel.org/r/1544990640-11604-3-git-send-email-carmeli.tamir@gmail.com
    Signed-off-by: Carmeli Tamir <carmeli.tamir@gmail.com>
    Acked-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index 833c7079a1e3..a5773899f4d9 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -65,8 +65,6 @@
 #define MAX_FAT12	0xFF4
 #define MAX_FAT16	0xFFF4
 #define MAX_FAT32	0x0FFFFFF6
-#define MAX_FAT(s)	(MSDOS_SB(s)->fat_bits == 32 ? MAX_FAT32 : \
-	MSDOS_SB(s)->fat_bits == 16 ? MAX_FAT16 : MAX_FAT12)
 
 /* bad cluster mark */
 #define BAD_FAT12	0xFF7

commit b553337a57cf4f077464292520f4e975ea4cda83
Author: Carmeli Tamir <carmeli.tamir@gmail.com>
Date:   Thu Jan 3 15:27:53 2019 -0800

    fat: remove FAT_FIRST_ENT macro
    
    The comment edited in this patch was the only reference to the
    FAT_FIRST_ENT macro, which is not used anymore.  Moreover, the commented
    line of code does not compile with the current code.
    
    Since the FAT_FIRST_ENT macro checks the FAT variant in a way that the
    patch series changes, I removed it, and instead wrote a clear
    explanation of what was checked.
    
    I verified that the changed comment is correct according to Microsoft
    FAT spec, search for "BPB_Media" in the following references:
    
    1. Microsoft FAT specification 2005
    (http://read.pudn.com/downloads77/ebook/294884/FAT32%20Spec%20%28SDA%20Contribution%29.pdf).
    Search for 'volume label'.
    2. Microsoft Extensible Firmware Initiative, FAT32 File System Specification
    (https://staff.washington.edu/dittrich/misc/fatgen103.pdf).
    Search for 'volume label'.
    
    Link: http://lkml.kernel.org/r/1544990640-11604-2-git-send-email-carmeli.tamir@gmail.com
    Signed-off-by: Carmeli Tamir <carmeli.tamir@gmail.com>
    Acked-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index 1216e6caf59b..833c7079a1e3 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -58,9 +58,6 @@
 #define MSDOS_DOT	".          "	/* ".", padded to MSDOS_NAME chars */
 #define MSDOS_DOTDOT	"..         "	/* "..", padded to MSDOS_NAME chars */
 
-#define FAT_FIRST_ENT(s, x)	((MSDOS_SB(s)->fat_bits == 32 ? 0x0FFFFF00 : \
-	MSDOS_SB(s)->fat_bits == 16 ? 0xFF00 : 0xF00) | (x))
-
 /* start of data cluster's entry (number of reserved clusters) */
 #define FAT_START_ENT	2
 

commit 9da22854761a76c45d78aa2ae2b4bbd504b4f171
Author: Carmeli Tamir <carmeli.tamir@gmail.com>
Date:   Thu Jan 3 15:27:49 2019 -0800

    include/uapi/linux/msdos_fs.h: use MSDOS_NAME for volume label size
    
    The FAT file system volume label file stored in the root directory
    should match the volume label field in the FAT boot sector.  As
    consequence, the max length of these fields ought to be the same.  This
    patch replaces the magic '11' usef in the struct fat_boot_sector with
    MSDOS_NAME, which is used in struct msdos_dir_entry.
    
    Please check the following references:
    1. Microsoft FAT specification 2005
    (http://read.pudn.com/downloads77/ebook/294884/FAT32%20Spec%20%28SDA%20Contribution%29.pdf).
    Search for 'volume label'.
    2. Microsoft Extensible Firmware Initiative, FAT32 File System Specification
    (https://staff.washington.edu/dittrich/misc/fatgen103.pdf).
    Search for 'volume label'.
    3. User space code that creates FAT filesystem
    sometimes uses MSDOS_NAME for the label, sometimes not.
    Search for 'if (memcmp(label, NO_NAME, MSDOS_NAME))'.
    I consider to make the same patch there as well.
    https://github.com/dosfstools/dosfstools/blob/master/src/mkfs.fat.c
    
    Link: http://lkml.kernel.org/r/1543096879-82837-1-git-send-email-carmeli.tamir@gmail.com
    Signed-off-by: Carmeli Tamir <carmeli.tamir@gmail.com>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Acked-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index fde753735aba..1216e6caf59b 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -135,7 +135,7 @@ struct fat_boot_sector {
 						   for mount state. */
 			__u8	signature;  /* extended boot signature */
 			__u8	vol_id[4];	/* volume ID */
-			__u8	vol_label[11];	/* volume label */
+			__u8	vol_label[MSDOS_NAME];	/* volume label */
 			__u8	fs_type[8];		/* file system type */
 			/* other fields are not added here */
 		} fat16;
@@ -158,7 +158,7 @@ struct fat_boot_sector {
 						   for mount state. */
 			__u8	signature;  /* extended boot signature */
 			__u8	vol_id[4];	/* volume ID */
-			__u8	vol_label[11];	/* volume label */
+			__u8	vol_label[MSDOS_NAME];	/* volume label */
 			__u8	fs_type[8];		/* file system type */
 			/* other fields are not added here */
 		} fat32;

commit 233bde21aa43516baa013ef7ac33f3427056db3e
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Mar 14 15:48:06 2018 -0700

    block: Move SECTOR_SIZE and SECTOR_SHIFT definitions into <linux/blkdev.h>
    
    It happens often while I'm preparing a patch for a block driver that
    I'm wondering: is a definition of SECTOR_SIZE and/or SECTOR_SHIFT
    available for this driver? Do I have to introduce definitions of these
    constants before I can use these constants? To avoid this confusion,
    move the existing definitions of SECTOR_SIZE and SECTOR_SHIFT into the
    <linux/blkdev.h> header file such that these become available for all
    block drivers. Make the SECTOR_SIZE definition in the uapi msdos_fs.h
    header file conditional to avoid that including that header file after
    <linux/blkdev.h> causes the compiler to complain about a SECTOR_SIZE
    redefinition.
    
    Note: the SECTOR_SIZE / SECTOR_SHIFT / SECTOR_BITS definitions have
    not been removed from uapi header files nor from NAND drivers in
    which these constants are used for another purpose than converting
    block layer offsets and sizes into a number of sectors.
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Nitin Gupta <ngupta@vflare.org>
    Reviewed-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index a45d0754102e..fde753735aba 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -10,7 +10,9 @@
  * The MS-DOS filesystem constants/structures
  */
 
+#ifndef SECTOR_SIZE
 #define SECTOR_SIZE	512		/* sector size (bytes) */
+#endif
 #define SECTOR_BITS	9		/* log2(SECTOR_SIZE) */
 #define MSDOS_DPB	(MSDOS_DPS)	/* dir entries per block */
 #define MSDOS_DPB_BITS	4		/* log2(MSDOS_DPB) */

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index e956704f5fb1..a45d0754102e 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI_LINUX_MSDOS_FS_H
 #define _UAPI_LINUX_MSDOS_FS_H
 

commit 7d7d731d1f0f27d2e470d4bc6112aca5ff30476f
Author: Jeremiah Mahler <jmmahler@gmail.com>
Date:   Fri Dec 5 06:56:50 2014 -0800

    msdos_fs.h: fix 'fields' in comment
    
    Signed-off-by: Jeremiah Mahler <jmmahler@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index e284ff919d6e..e956704f5fb1 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -134,7 +134,7 @@ struct fat_boot_sector {
 			__u8	vol_id[4];	/* volume ID */
 			__u8	vol_label[11];	/* volume label */
 			__u8	fs_type[8];		/* file system type */
-			/* other fiealds are not added here */
+			/* other fields are not added here */
 		} fat16;
 
 		struct {
@@ -157,7 +157,7 @@ struct fat_boot_sector {
 			__u8	vol_id[4];	/* volume ID */
 			__u8	vol_label[11];	/* volume label */
 			__u8	fs_type[8];		/* file system type */
-			/* other fiealds are not added here */
+			/* other fields are not added here */
 		} fat32;
 	};
 };

commit 6e5b93ee55d401f1619092fb675b57c28c9ed7ec
Author: Mike Lockwood <lockwood@android.com>
Date:   Mon Jul 8 16:00:46 2013 -0700

    fatfs: add FAT_IOCTL_GET_VOLUME_ID
    
    This patch, originally from Android kernel, adds vfat ioctl command
    FAT_IOCTL_GET_VOLUME_ID, with this command we can get the vfat volume ID
    using following code:
    
            ioctl(fd, FAT_IOCTL_GET_VOLUME_ID, &volume_ID)
    
    This patch is a modified version of the patch by Mike Lockwood, with
    changes from Dmitry Pervushin, who noticed the original patch makes some
    volume IDs abiguous with error returns: for example, if volume id is
    0xFFFFFDAD, that matches -ENOIOCTLCMD, we get "FFFFFFFF" from the user
    space.
    
    So add a parameter to ioctl to get the correct volume ID.
    
    Android uses vfat volume ID to identify different sd card, when a new sd
    card is inserted to device, android can scan the media on it and pop up
    new contents.
    
    Signed-off-by: Bintian Wang <bintian.wang@linaro.org>
    Cc: dmitry pervushin <dpervushin@gmail.com>
    Cc: Mike Lockwood <lockwood@android.com>
    Cc: Colin Cross <ccross@android.com>
    Acked-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Sean McNeil <sean@mcneil.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index f055e58b3147..e284ff919d6e 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -104,6 +104,8 @@ struct __fat_dirent {
 /* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
 #define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
 #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+/*Android kernel has used 0x12, so we use 0x13*/
+#define FAT_IOCTL_GET_VOLUME_ID		_IOR('r', 0x13, __u32)
 
 struct fat_boot_sector {
 	__u8	ignored[3];	/* Boot strap short or near jump */
@@ -128,6 +130,10 @@ struct fat_boot_sector {
 			__u8	drive_number;	/* Physical drive number */
 			__u8	state;		/* undocumented, but used
 						   for mount state. */
+			__u8	signature;  /* extended boot signature */
+			__u8	vol_id[4];	/* volume ID */
+			__u8	vol_label[11];	/* volume label */
+			__u8	fs_type[8];		/* file system type */
 			/* other fiealds are not added here */
 		} fat16;
 
@@ -147,6 +153,10 @@ struct fat_boot_sector {
 			__u8	drive_number;   /* Physical drive number */
 			__u8    state;       	/* undocumented, but used
 						   for mount state. */
+			__u8	signature;  /* extended boot signature */
+			__u8	vol_id[4];	/* volume ID */
+			__u8	vol_label[11];	/* volume label */
+			__u8	fs_type[8];		/* file system type */
 			/* other fiealds are not added here */
 		} fat32;
 	};

commit b88a105802e9aeb6e234e8106659f5d1271081bb
Author: Oleksij Rempel <bug-track@fisher-privat.net>
Date:   Wed Feb 27 17:03:09 2013 -0800

    fat: mark fs as dirty on mount and clean on umount
    
    There is no documented methods to mark FAT as dirty.  Unofficially MS
    started to use reserved Byte in boot sector for this purpose, at least
    since Win 2000.  With Win 7 user is warned if fs is dirty and asked to
    clean it.
    
    Different versions of Win, handle it in different ways, but always have
    same meaning:
    
    - Win 2000 and XP, set it on write operations and
      remove it after operation was finnished
    - Win 7, set dirty flag on first write and remove it on umount.
    
    We will do it as follows:
    
    - set dirty flag on mount. If fs was initially dirty, warn user,
      remember it and do not do any changes to boot sector.
    - clean it on umount. If fs was initially dirty, leave it dirty.
    - do not do any thing if fs mounted read-only.
    - TODO: leave fs dirty if we found some error after mount.
    
    Signed-off-by: Oleksij Rempel <bug-track@fisher-privat.net>
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index b9f12450efe8..f055e58b3147 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -87,6 +87,8 @@
 #define IS_FSINFO(x)	(le32_to_cpu((x)->signature1) == FAT_FSINFO_SIG1 \
 			 && le32_to_cpu((x)->signature2) == FAT_FSINFO_SIG2)
 
+#define FAT_STATE_DIRTY 0x01
+
 struct __fat_dirent {
 	long		d_ino;
 	__kernel_off_t	d_off;

commit 6b46419b0462ae565880f02e9cd0baf9b25ea71f
Author: Oleksij Rempel <bug-track@fisher-privat.net>
Date:   Wed Feb 27 17:03:07 2013 -0800

    fat: add extended fileds to struct fat_boot_sector
    
    Later we will need "state" field to check if volume was cleanly unmounted.
    
    Signed-off-by: Oleksij Rempel <bug-track@fisher-privat.net>
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index 996719f82e28..b9f12450efe8 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -120,14 +120,34 @@ struct fat_boot_sector {
 	__le32	hidden;		/* hidden sectors (unused) */
 	__le32	total_sect;	/* number of sectors (if sectors == 0) */
 
-	/* The following fields are only used by FAT32 */
-	__le32	fat32_length;	/* sectors/FAT */
-	__le16	flags;		/* bit 8: fat mirroring, low 4: active fat */
-	__u8	version[2];	/* major, minor filesystem version */
-	__le32	root_cluster;	/* first cluster in root directory */
-	__le16	info_sector;	/* filesystem info sector */
-	__le16	backup_boot;	/* backup boot sector */
-	__le16	reserved2[6];	/* Unused */
+	union {
+		struct {
+			/*  Extended BPB Fields for FAT16 */
+			__u8	drive_number;	/* Physical drive number */
+			__u8	state;		/* undocumented, but used
+						   for mount state. */
+			/* other fiealds are not added here */
+		} fat16;
+
+		struct {
+			/* only used by FAT32 */
+			__le32	length;		/* sectors/FAT */
+			__le16	flags;		/* bit 8: fat mirroring,
+						   low 4: active fat */
+			__u8	version[2];	/* major, minor filesystem
+						   version */
+			__le32	root_cluster;	/* first cluster in
+						   root directory */
+			__le16	info_sector;	/* filesystem info sector */
+			__le16	backup_boot;	/* backup boot sector */
+			__le16	reserved2[6];	/* Unused */
+			/* Extended BPB Fields for FAT32 */
+			__u8	drive_number;   /* Physical drive number */
+			__u8    state;       	/* undocumented, but used
+						   for mount state. */
+			/* other fiealds are not added here */
+		} fat32;
+	};
 };
 
 struct fat_boot_fsinfo {

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
new file mode 100644
index 000000000000..996719f82e28
--- /dev/null
+++ b/include/uapi/linux/msdos_fs.h
@@ -0,0 +1,167 @@
+#ifndef _UAPI_LINUX_MSDOS_FS_H
+#define _UAPI_LINUX_MSDOS_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+#include <asm/byteorder.h>
+
+/*
+ * The MS-DOS filesystem constants/structures
+ */
+
+#define SECTOR_SIZE	512		/* sector size (bytes) */
+#define SECTOR_BITS	9		/* log2(SECTOR_SIZE) */
+#define MSDOS_DPB	(MSDOS_DPS)	/* dir entries per block */
+#define MSDOS_DPB_BITS	4		/* log2(MSDOS_DPB) */
+#define MSDOS_DPS	(SECTOR_SIZE / sizeof(struct msdos_dir_entry))
+#define MSDOS_DPS_BITS	4		/* log2(MSDOS_DPS) */
+#define MSDOS_LONGNAME	256		/* maximum name length */
+#define CF_LE_W(v)	le16_to_cpu(v)
+#define CF_LE_L(v)	le32_to_cpu(v)
+#define CT_LE_W(v)	cpu_to_le16(v)
+#define CT_LE_L(v)	cpu_to_le32(v)
+
+#define MSDOS_ROOT_INO	 1	/* The root inode number */
+#define MSDOS_FSINFO_INO 2	/* Used for managing the FSINFO block */
+
+#define MSDOS_DIR_BITS	5	/* log2(sizeof(struct msdos_dir_entry)) */
+
+/* directory limit */
+#define FAT_MAX_DIR_ENTRIES	(65536)
+#define FAT_MAX_DIR_SIZE	(FAT_MAX_DIR_ENTRIES << MSDOS_DIR_BITS)
+
+#define ATTR_NONE	0	/* no attribute bits */
+#define ATTR_RO		1	/* read-only */
+#define ATTR_HIDDEN	2	/* hidden */
+#define ATTR_SYS	4	/* system */
+#define ATTR_VOLUME	8	/* volume label */
+#define ATTR_DIR	16	/* directory */
+#define ATTR_ARCH	32	/* archived */
+
+/* attribute bits that are copied "as is" */
+#define ATTR_UNUSED	(ATTR_VOLUME | ATTR_ARCH | ATTR_SYS | ATTR_HIDDEN)
+/* bits that are used by the Windows 95/Windows NT extended FAT */
+#define ATTR_EXT	(ATTR_RO | ATTR_HIDDEN | ATTR_SYS | ATTR_VOLUME)
+
+#define CASE_LOWER_BASE	8	/* base is lower case */
+#define CASE_LOWER_EXT	16	/* extension is lower case */
+
+#define DELETED_FLAG	0xe5	/* marks file as deleted when in name[0] */
+#define IS_FREE(n)	(!*(n) || *(n) == DELETED_FLAG)
+
+#define FAT_LFN_LEN	255	/* maximum long name length */
+#define MSDOS_NAME	11	/* maximum name length */
+#define MSDOS_SLOTS	21	/* max # of slots for short and long names */
+#define MSDOS_DOT	".          "	/* ".", padded to MSDOS_NAME chars */
+#define MSDOS_DOTDOT	"..         "	/* "..", padded to MSDOS_NAME chars */
+
+#define FAT_FIRST_ENT(s, x)	((MSDOS_SB(s)->fat_bits == 32 ? 0x0FFFFF00 : \
+	MSDOS_SB(s)->fat_bits == 16 ? 0xFF00 : 0xF00) | (x))
+
+/* start of data cluster's entry (number of reserved clusters) */
+#define FAT_START_ENT	2
+
+/* maximum number of clusters */
+#define MAX_FAT12	0xFF4
+#define MAX_FAT16	0xFFF4
+#define MAX_FAT32	0x0FFFFFF6
+#define MAX_FAT(s)	(MSDOS_SB(s)->fat_bits == 32 ? MAX_FAT32 : \
+	MSDOS_SB(s)->fat_bits == 16 ? MAX_FAT16 : MAX_FAT12)
+
+/* bad cluster mark */
+#define BAD_FAT12	0xFF7
+#define BAD_FAT16	0xFFF7
+#define BAD_FAT32	0x0FFFFFF7
+
+/* standard EOF */
+#define EOF_FAT12	0xFFF
+#define EOF_FAT16	0xFFFF
+#define EOF_FAT32	0x0FFFFFFF
+
+#define FAT_ENT_FREE	(0)
+#define FAT_ENT_BAD	(BAD_FAT32)
+#define FAT_ENT_EOF	(EOF_FAT32)
+
+#define FAT_FSINFO_SIG1	0x41615252
+#define FAT_FSINFO_SIG2	0x61417272
+#define IS_FSINFO(x)	(le32_to_cpu((x)->signature1) == FAT_FSINFO_SIG1 \
+			 && le32_to_cpu((x)->signature2) == FAT_FSINFO_SIG2)
+
+struct __fat_dirent {
+	long		d_ino;
+	__kernel_off_t	d_off;
+	unsigned short	d_reclen;
+	char		d_name[256]; /* We must not include limits.h! */
+};
+
+/*
+ * ioctl commands
+ */
+#define VFAT_IOCTL_READDIR_BOTH		_IOR('r', 1, struct __fat_dirent[2])
+#define VFAT_IOCTL_READDIR_SHORT	_IOR('r', 2, struct __fat_dirent[2])
+/* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */
+#define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)
+#define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)
+
+struct fat_boot_sector {
+	__u8	ignored[3];	/* Boot strap short or near jump */
+	__u8	system_id[8];	/* Name - can be used to special case
+				   partition manager volumes */
+	__u8	sector_size[2];	/* bytes per logical sector */
+	__u8	sec_per_clus;	/* sectors/cluster */
+	__le16	reserved;	/* reserved sectors */
+	__u8	fats;		/* number of FATs */
+	__u8	dir_entries[2];	/* root directory entries */
+	__u8	sectors[2];	/* number of sectors */
+	__u8	media;		/* media code */
+	__le16	fat_length;	/* sectors/FAT */
+	__le16	secs_track;	/* sectors per track */
+	__le16	heads;		/* number of heads */
+	__le32	hidden;		/* hidden sectors (unused) */
+	__le32	total_sect;	/* number of sectors (if sectors == 0) */
+
+	/* The following fields are only used by FAT32 */
+	__le32	fat32_length;	/* sectors/FAT */
+	__le16	flags;		/* bit 8: fat mirroring, low 4: active fat */
+	__u8	version[2];	/* major, minor filesystem version */
+	__le32	root_cluster;	/* first cluster in root directory */
+	__le16	info_sector;	/* filesystem info sector */
+	__le16	backup_boot;	/* backup boot sector */
+	__le16	reserved2[6];	/* Unused */
+};
+
+struct fat_boot_fsinfo {
+	__le32   signature1;	/* 0x41615252L */
+	__le32   reserved1[120];	/* Nothing as far as I can tell */
+	__le32   signature2;	/* 0x61417272L */
+	__le32   free_clusters;	/* Free cluster count.  -1 if unknown */
+	__le32   next_cluster;	/* Most recently allocated cluster */
+	__le32   reserved2[4];
+};
+
+struct msdos_dir_entry {
+	__u8	name[MSDOS_NAME];/* name and extension */
+	__u8	attr;		/* attribute bits */
+	__u8    lcase;		/* Case for base and extension */
+	__u8	ctime_cs;	/* Creation time, centiseconds (0-199) */
+	__le16	ctime;		/* Creation time */
+	__le16	cdate;		/* Creation date */
+	__le16	adate;		/* Last access date */
+	__le16	starthi;	/* High 16 bits of cluster in FAT32 */
+	__le16	time,date,start;/* time, date and first cluster */
+	__le32	size;		/* file size (in bytes) */
+};
+
+/* Up to 13 characters of the name */
+struct msdos_dir_slot {
+	__u8    id;		/* sequence number for slot */
+	__u8    name0_4[10];	/* first 5 characters in name */
+	__u8    attr;		/* attribute byte */
+	__u8    reserved;	/* always 0 */
+	__u8    alias_checksum;	/* checksum for 8.3 alias */
+	__u8    name5_10[12];	/* 6 more characters in name */
+	__le16   start;		/* starting cluster number, 0 in long slots */
+	__u8    name11_12[4];	/* last 2 characters in name */
+};
+
+#endif /* _UAPI_LINUX_MSDOS_FS_H */
