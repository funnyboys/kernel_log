commit 51891498f2da78ee64dfad88fa53c9e85fb50abf
Author: Tycho Andersen <tycho@tycho.ws>
Date:   Wed Mar 4 11:05:17 2020 -0700

    seccomp: allow TSYNC and USER_NOTIF together
    
    The restriction introduced in 7a0df7fbc145 ("seccomp: Make NEW_LISTENER and
    TSYNC flags exclusive") is mostly artificial: there is enough information
    in a seccomp user notification to tell which thread triggered a
    notification. The reason it was introduced is because TSYNC makes the
    syscall return a thread-id on failure, and NEW_LISTENER returns an fd, and
    there's no way to distinguish between these two cases (well, I suppose the
    caller could check all fds it has, then do the syscall, and if the return
    value was an fd that already existed, then it must be a thread id, but
    bleh).
    
    Matthew would like to use these two flags together in the Chrome sandbox
    which wants to use TSYNC for video drivers and NEW_LISTENER to proxy
    syscalls.
    
    So, let's fix this ugliness by adding another flag, TSYNC_ESRCH, which
    tells the kernel to just return -ESRCH on a TSYNC error. This way,
    NEW_LISTENER (and any subsequent seccomp() commands that want to return
    positive values) don't conflict with each other.
    
    Suggested-by: Matthew Denton <mpdenton@google.com>
    Signed-off-by: Tycho Andersen <tycho@tycho.ws>
    Link: https://lore.kernel.org/r/20200304180517.23867-1-tycho@tycho.ws
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index be84d87f1f46..c1735455bc53 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -22,6 +22,7 @@
 #define SECCOMP_FILTER_FLAG_LOG			(1UL << 1)
 #define SECCOMP_FILTER_FLAG_SPEC_ALLOW		(1UL << 2)
 #define SECCOMP_FILTER_FLAG_NEW_LISTENER	(1UL << 3)
+#define SECCOMP_FILTER_FLAG_TSYNC_ESRCH		(1UL << 4)
 
 /*
  * All BPF programs must return a 32-bit value.

commit 23b2c96fad21886c53f5e1a4ffedd45ddd2e85ba
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Thu Oct 24 23:25:39 2019 +0200

    seccomp: rework define for SECCOMP_USER_NOTIF_FLAG_CONTINUE
    
    Switch from BIT(0) to (1UL << 0).
    First, there are already two different forms used in the header, so there's
    no need to add a third. Second, the BIT() macros is kernel internal and
    afaict not actually exposed to userspace. Maybe there's some magic there
    I'm missing but it definitely causes issues when compiling a program that
    tries to use SECCOMP_USER_NOTIF_FLAG_CONTINUE. It currently fails in the
    following way:
    
            # github.com/lxc/lxd/lxd
            /usr/bin/ld: $WORK/b001/_x003.o: in function
            `__do_user_notification_continue':
            lxd/main_checkfeature.go:240: undefined reference to `BIT'
            collect2: error: ld returned 1 exit status
    
    Switching to (1UL << 0) should prevent that and is more in line what is
    already done in the rest of the header.
    
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Link: https://lore.kernel.org/r/20191024212539.4059-1-christian.brauner@ubuntu.com
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index e48e2fa2d248..be84d87f1f46 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -103,7 +103,7 @@ struct seccomp_notif {
  * SECCOMP_USER_NOTIF_FLAG_CONTINUE. Note that SECCOMP_RET_TRACE can equally
  * be overriden by SECCOMP_USER_NOTIF_FLAG_CONTINUE.
  */
-#define SECCOMP_USER_NOTIF_FLAG_CONTINUE BIT(0)
+#define SECCOMP_USER_NOTIF_FLAG_CONTINUE (1UL << 0)
 
 struct seccomp_notif_resp {
 	__u64 id;

commit fb3c5386b382d4097476ce9647260fc89b34afdb
Author: Christian Brauner <christian.brauner@ubuntu.com>
Date:   Fri Sep 20 10:30:05 2019 +0200

    seccomp: add SECCOMP_USER_NOTIF_FLAG_CONTINUE
    
    This allows the seccomp notifier to continue a syscall. A positive
    discussion about this feature was triggered by a post to the
    ksummit-discuss mailing list (cf. [3]) and took place during KSummit
    (cf. [1]) and again at the containers/checkpoint-restore
    micro-conference at Linux Plumbers.
    
    Recently we landed seccomp support for SECCOMP_RET_USER_NOTIF (cf. [4])
    which enables a process (watchee) to retrieve an fd for its seccomp
    filter. This fd can then be handed to another (usually more privileged)
    process (watcher). The watcher will then be able to receive seccomp
    messages about the syscalls having been performed by the watchee.
    
    This feature is heavily used in some userspace workloads. For example,
    it is currently used to intercept mknod() syscalls in user namespaces
    aka in containers.
    The mknod() syscall can be easily filtered based on dev_t. This allows
    us to only intercept a very specific subset of mknod() syscalls.
    Furthermore, mknod() is not possible in user namespaces toto coelo and
    so intercepting and denying syscalls that are not in the whitelist on
    accident is not a big deal. The watchee won't notice a difference.
    
    In contrast to mknod(), a lot of other syscall we intercept (e.g.
    setxattr()) cannot be easily filtered like mknod() because they have
    pointer arguments. Additionally, some of them might actually succeed in
    user namespaces (e.g. setxattr() for all "user.*" xattrs). Since we
    currently cannot tell seccomp to continue from a user notifier we are
    stuck with performing all of the syscalls in lieu of the container. This
    is a huge security liability since it is extremely difficult to
    correctly assume all of the necessary privileges of the calling task
    such that the syscall can be successfully emulated without escaping
    other additional security restrictions (think missing CAP_MKNOD for
    mknod(), or MS_NODEV on a filesystem etc.). This can be solved by
    telling seccomp to resume the syscall.
    
    One thing that came up in the discussion was the problem that another
    thread could change the memory after userspace has decided to let the
    syscall continue which is a well known TOCTOU with seccomp which is
    present in other ways already.
    The discussion showed that this feature is already very useful for any
    syscall without pointer arguments. For any accidentally intercepted
    non-pointer syscall it is safe to continue.
    For syscalls with pointer arguments there is a race but for any cautious
    userspace and the main usec cases the race doesn't matter. The notifier
    is intended to be used in a scenario where a more privileged watcher
    supervises the syscalls of lesser privileged watchee to allow it to get
    around kernel-enforced limitations by performing the syscall for it
    whenever deemed save by the watcher. Hence, if a user tricks the watcher
    into allowing a syscall they will either get a deny based on
    kernel-enforced restrictions later or they will have changed the
    arguments in such a way that they manage to perform a syscall with
    arguments that they would've been allowed to do anyway.
    In general, it is good to point out again, that the notifier fd was not
    intended to allow userspace to implement a security policy but rather to
    work around kernel security mechanisms in cases where the watcher knows
    that a given action is safe to perform.
    
    /* References */
    [1]: https://linuxplumbersconf.org/event/4/contributions/560
    [2]: https://linuxplumbersconf.org/event/4/contributions/477
    [3]: https://lore.kernel.org/r/20190719093538.dhyopljyr5ns33qx@brauner.io
    [4]: commit 6a21cc50f0c7 ("seccomp: add a return code to trap to userspace")
    
    Co-developed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
    Reviewed-by: Tycho Andersen <tycho@tycho.ws>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Will Drewry <wad@chromium.org>
    CC: Tyler Hicks <tyhicks@canonical.com>
    Link: https://lore.kernel.org/r/20190920083007.11475-2-christian.brauner@ubuntu.com
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 90734aa5aa36..e48e2fa2d248 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -76,6 +76,35 @@ struct seccomp_notif {
 	struct seccomp_data data;
 };
 
+/*
+ * Valid flags for struct seccomp_notif_resp
+ *
+ * Note, the SECCOMP_USER_NOTIF_FLAG_CONTINUE flag must be used with caution!
+ * If set by the process supervising the syscalls of another process the
+ * syscall will continue. This is problematic because of an inherent TOCTOU.
+ * An attacker can exploit the time while the supervised process is waiting on
+ * a response from the supervising process to rewrite syscall arguments which
+ * are passed as pointers of the intercepted syscall.
+ * It should be absolutely clear that this means that the seccomp notifier
+ * _cannot_ be used to implement a security policy! It should only ever be used
+ * in scenarios where a more privileged process supervises the syscalls of a
+ * lesser privileged process to get around kernel-enforced security
+ * restrictions when the privileged process deems this safe. In other words,
+ * in order to continue a syscall the supervising process should be sure that
+ * another security mechanism or the kernel itself will sufficiently block
+ * syscalls if arguments are rewritten to something unsafe.
+ *
+ * Similar precautions should be applied when stacking SECCOMP_RET_USER_NOTIF
+ * or SECCOMP_RET_TRACE. For SECCOMP_RET_USER_NOTIF filters acting on the
+ * same syscall, the most recently added filter takes precedence. This means
+ * that the new SECCOMP_RET_USER_NOTIF filter can override any
+ * SECCOMP_IOCTL_NOTIF_SEND from earlier filters, essentially allowing all
+ * such filtered syscalls to be executed by sending the response
+ * SECCOMP_USER_NOTIF_FLAG_CONTINUE. Note that SECCOMP_RET_TRACE can equally
+ * be overriden by SECCOMP_USER_NOTIF_FLAG_CONTINUE.
+ */
+#define SECCOMP_USER_NOTIF_FLAG_CONTINUE BIT(0)
+
 struct seccomp_notif_resp {
 	__u64 id;
 	__s64 val;

commit 6a21cc50f0c7f87dae5259f6cfefe024412313f6
Author: Tycho Andersen <tycho@tycho.ws>
Date:   Sun Dec 9 11:24:13 2018 -0700

    seccomp: add a return code to trap to userspace
    
    This patch introduces a means for syscalls matched in seccomp to notify
    some other task that a particular filter has been triggered.
    
    The motivation for this is primarily for use with containers. For example,
    if a container does an init_module(), we obviously don't want to load this
    untrusted code, which may be compiled for the wrong version of the kernel
    anyway. Instead, we could parse the module image, figure out which module
    the container is trying to load and load it on the host.
    
    As another example, containers cannot mount() in general since various
    filesystems assume a trusted image. However, if an orchestrator knows that
    e.g. a particular block device has not been exposed to a container for
    writing, it want to allow the container to mount that block device (that
    is, handle the mount for it).
    
    This patch adds functionality that is already possible via at least two
    other means that I know about, both of which involve ptrace(): first, one
    could ptrace attach, and then iterate through syscalls via PTRACE_SYSCALL.
    Unfortunately this is slow, so a faster version would be to install a
    filter that does SECCOMP_RET_TRACE, which triggers a PTRACE_EVENT_SECCOMP.
    Since ptrace allows only one tracer, if the container runtime is that
    tracer, users inside the container (or outside) trying to debug it will not
    be able to use ptrace, which is annoying. It also means that older
    distributions based on Upstart cannot boot inside containers using ptrace,
    since upstart itself uses ptrace to monitor services while starting.
    
    The actual implementation of this is fairly small, although getting the
    synchronization right was/is slightly complex.
    
    Finally, it's worth noting that the classic seccomp TOCTOU of reading
    memory data from the task still applies here, but can be avoided with
    careful design of the userspace handler: if the userspace handler reads all
    of the task memory that is necessary before applying its security policy,
    the tracee's subsequent memory edits will not be read by the tracer.
    
    Signed-off-by: Tycho Andersen <tycho@tycho.ws>
    CC: Kees Cook <keescook@chromium.org>
    CC: Andy Lutomirski <luto@amacapital.net>
    CC: Oleg Nesterov <oleg@redhat.com>
    CC: Eric W. Biederman <ebiederm@xmission.com>
    CC: "Serge E. Hallyn" <serge@hallyn.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    CC: Christian Brauner <christian@brauner.io>
    CC: Tyler Hicks <tyhicks@canonical.com>
    CC: Akihiro Suda <suda.akihiro@lab.ntt.co.jp>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 9efc0e73d50b..90734aa5aa36 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -15,11 +15,13 @@
 #define SECCOMP_SET_MODE_STRICT		0
 #define SECCOMP_SET_MODE_FILTER		1
 #define SECCOMP_GET_ACTION_AVAIL	2
+#define SECCOMP_GET_NOTIF_SIZES		3
 
 /* Valid flags for SECCOMP_SET_MODE_FILTER */
-#define SECCOMP_FILTER_FLAG_TSYNC	(1UL << 0)
-#define SECCOMP_FILTER_FLAG_LOG		(1UL << 1)
-#define SECCOMP_FILTER_FLAG_SPEC_ALLOW	(1UL << 2)
+#define SECCOMP_FILTER_FLAG_TSYNC		(1UL << 0)
+#define SECCOMP_FILTER_FLAG_LOG			(1UL << 1)
+#define SECCOMP_FILTER_FLAG_SPEC_ALLOW		(1UL << 2)
+#define SECCOMP_FILTER_FLAG_NEW_LISTENER	(1UL << 3)
 
 /*
  * All BPF programs must return a 32-bit value.
@@ -35,6 +37,7 @@
 #define SECCOMP_RET_KILL	 SECCOMP_RET_KILL_THREAD
 #define SECCOMP_RET_TRAP	 0x00030000U /* disallow and force a SIGSYS */
 #define SECCOMP_RET_ERRNO	 0x00050000U /* returns an errno */
+#define SECCOMP_RET_USER_NOTIF	 0x7fc00000U /* notifies userspace */
 #define SECCOMP_RET_TRACE	 0x7ff00000U /* pass to a tracer or disallow */
 #define SECCOMP_RET_LOG		 0x7ffc0000U /* allow after logging */
 #define SECCOMP_RET_ALLOW	 0x7fff0000U /* allow */
@@ -60,4 +63,35 @@ struct seccomp_data {
 	__u64 args[6];
 };
 
+struct seccomp_notif_sizes {
+	__u16 seccomp_notif;
+	__u16 seccomp_notif_resp;
+	__u16 seccomp_data;
+};
+
+struct seccomp_notif {
+	__u64 id;
+	__u32 pid;
+	__u32 flags;
+	struct seccomp_data data;
+};
+
+struct seccomp_notif_resp {
+	__u64 id;
+	__s64 val;
+	__s32 error;
+	__u32 flags;
+};
+
+#define SECCOMP_IOC_MAGIC		'!'
+#define SECCOMP_IO(nr)			_IO(SECCOMP_IOC_MAGIC, nr)
+#define SECCOMP_IOR(nr, type)		_IOR(SECCOMP_IOC_MAGIC, nr, type)
+#define SECCOMP_IOW(nr, type)		_IOW(SECCOMP_IOC_MAGIC, nr, type)
+#define SECCOMP_IOWR(nr, type)		_IOWR(SECCOMP_IOC_MAGIC, nr, type)
+
+/* Flags for seccomp notification fd ioctl. */
+#define SECCOMP_IOCTL_NOTIF_RECV	SECCOMP_IOWR(0, struct seccomp_notif)
+#define SECCOMP_IOCTL_NOTIF_SEND	SECCOMP_IOWR(1,	\
+						struct seccomp_notif_resp)
+#define SECCOMP_IOCTL_NOTIF_ID_VALID	SECCOMP_IOR(2, __u64)
 #endif /* _UAPI_LINUX_SECCOMP_H */

commit 00a02d0c502a06d15e07b857f8ff921e3e402675
Author: Kees Cook <keescook@chromium.org>
Date:   Thu May 3 14:56:12 2018 -0700

    seccomp: Add filter flag to opt-out of SSB mitigation
    
    If a seccomp user is not interested in Speculative Store Bypass mitigation
    by default, it can set the new SECCOMP_FILTER_FLAG_SPEC_ALLOW flag when
    adding filters.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 2a0bd9dd104d..9efc0e73d50b 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -17,8 +17,9 @@
 #define SECCOMP_GET_ACTION_AVAIL	2
 
 /* Valid flags for SECCOMP_SET_MODE_FILTER */
-#define SECCOMP_FILTER_FLAG_TSYNC	1
-#define SECCOMP_FILTER_FLAG_LOG		2
+#define SECCOMP_FILTER_FLAG_TSYNC	(1UL << 0)
+#define SECCOMP_FILTER_FLAG_LOG		(1UL << 1)
+#define SECCOMP_FILTER_FLAG_SPEC_ALLOW	(1UL << 2)
 
 /*
  * All BPF programs must return a 32-bit value.

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index f6bc1dea3247..2a0bd9dd104d 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI_LINUX_SECCOMP_H
 #define _UAPI_LINUX_SECCOMP_H
 

commit 0466bdb99e8744bc9befa8d62a317f0fd7fd7421
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Aug 11 13:12:11 2017 -0700

    seccomp: Implement SECCOMP_RET_KILL_PROCESS action
    
    Right now, SECCOMP_RET_KILL_THREAD (neé SECCOMP_RET_KILL) kills the
    current thread. There have been a few requests for this to kill the entire
    process (the thread group). This cannot be just changed (discovered when
    adding coredump support since coredumping kills the entire process)
    because there are userspace programs depending on the thread-kill
    behavior.
    
    Instead, implement SECCOMP_RET_KILL_PROCESS, which is 0x80000000, and can
    be processed as "-1" by the kernel, below the existing RET_KILL that is
    ABI-set to "0". For userspace, SECCOMP_RET_ACTION_FULL is added to expand
    the mask to the signed bit. Old userspace using the SECCOMP_RET_ACTION
    mask will see SECCOMP_RET_KILL_PROCESS as 0 still, but this would only
    be visible when examining the siginfo in a core dump from a RET_KILL_*,
    where it will think it was thread-killed instead of process-killed.
    
    Attempts to introduce this behavior via other ways (filter flags,
    seccomp struct flags, masked RET_DATA bits) all come with weird
    side-effects and baggage. This change preserves the central behavioral
    expectations of the seccomp filter engine without putting too great
    a burden on changes needed in userspace to use the new action.
    
    The new action is discoverable by userspace through either the new
    actions_avail sysctl or through the SECCOMP_GET_ACTION_AVAIL seccomp
    operation. If used without checking for availability, old kernels
    will treat RET_KILL_PROCESS as RET_KILL_THREAD (since the old mask
    will produce RET_KILL_THREAD).
    
    Cc: Paul Moore <paul@paul-moore.com>
    Cc: Fabricio Voznika <fvoznika@google.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 7e77c92df78a..f6bc1dea3247 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -38,6 +38,7 @@
 #define SECCOMP_RET_ALLOW	 0x7fff0000U /* allow */
 
 /* Masks for the return value sections. */
+#define SECCOMP_RET_ACTION_FULL	0xffff0000U
 #define SECCOMP_RET_ACTION	0x7fff0000U
 #define SECCOMP_RET_DATA	0x0000ffffU
 

commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Aug 11 13:01:39 2017 -0700

    seccomp: Introduce SECCOMP_RET_KILL_PROCESS
    
    This introduces the BPF return value for SECCOMP_RET_KILL_PROCESS to kill
    an entire process. This cannot yet be reached by seccomp, but it changes
    the default-kill behavior (for unknown return values) from kill-thread to
    kill-process.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 5a03f699eb17..7e77c92df78a 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -22,18 +22,20 @@
 /*
  * All BPF programs must return a 32-bit value.
  * The bottom 16-bits are for optional return data.
- * The upper 16-bits are ordered from least permissive values to most.
+ * The upper 16-bits are ordered from least permissive values to most,
+ * as a signed value (so 0x8000000 is negative).
  *
  * The ordering ensures that a min_t() over composed return values always
  * selects the least permissive choice.
  */
-#define SECCOMP_RET_KILL_THREAD	0x00000000U /* kill the thread */
-#define SECCOMP_RET_KILL	SECCOMP_RET_KILL_THREAD
-#define SECCOMP_RET_TRAP	0x00030000U /* disallow and force a SIGSYS */
-#define SECCOMP_RET_ERRNO	0x00050000U /* returns an errno */
-#define SECCOMP_RET_TRACE	0x7ff00000U /* pass to a tracer or disallow */
-#define SECCOMP_RET_LOG		0x7ffc0000U /* allow after logging */
-#define SECCOMP_RET_ALLOW	0x7fff0000U /* allow */
+#define SECCOMP_RET_KILL_PROCESS 0x80000000U /* kill the process */
+#define SECCOMP_RET_KILL_THREAD	 0x00000000U /* kill the thread */
+#define SECCOMP_RET_KILL	 SECCOMP_RET_KILL_THREAD
+#define SECCOMP_RET_TRAP	 0x00030000U /* disallow and force a SIGSYS */
+#define SECCOMP_RET_ERRNO	 0x00050000U /* returns an errno */
+#define SECCOMP_RET_TRACE	 0x7ff00000U /* pass to a tracer or disallow */
+#define SECCOMP_RET_LOG		 0x7ffc0000U /* allow after logging */
+#define SECCOMP_RET_ALLOW	 0x7fff0000U /* allow */
 
 /* Masks for the return value sections. */
 #define SECCOMP_RET_ACTION	0x7fff0000U

commit fd76875ca289a3d4722f266fd2d5532a27083903
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Aug 11 12:53:18 2017 -0700

    seccomp: Rename SECCOMP_RET_KILL to SECCOMP_RET_KILL_THREAD
    
    In preparation for adding SECCOMP_RET_KILL_PROCESS, rename SECCOMP_RET_KILL
    to the more accurate SECCOMP_RET_KILL_THREAD.
    
    The existing selftest values are intentionally left as SECCOMP_RET_KILL
    just to be sure we're exercising the alias.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index f94433263e4b..5a03f699eb17 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -27,7 +27,8 @@
  * The ordering ensures that a min_t() over composed return values always
  * selects the least permissive choice.
  */
-#define SECCOMP_RET_KILL	0x00000000U /* kill the task immediately */
+#define SECCOMP_RET_KILL_THREAD	0x00000000U /* kill the thread */
+#define SECCOMP_RET_KILL	SECCOMP_RET_KILL_THREAD
 #define SECCOMP_RET_TRAP	0x00030000U /* disallow and force a SIGSYS */
 #define SECCOMP_RET_ERRNO	0x00050000U /* returns an errno */
 #define SECCOMP_RET_TRACE	0x7ff00000U /* pass to a tracer or disallow */

commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri Aug 11 04:33:57 2017 +0000

    seccomp: Action to log before allowing
    
    Add a new action, SECCOMP_RET_LOG, that logs a syscall before allowing
    the syscall. At the implementation level, this action is identical to
    the existing SECCOMP_RET_ALLOW action. However, it can be very useful when
    initially developing a seccomp filter for an application. The developer
    can set the default action to be SECCOMP_RET_LOG, maybe mark any
    obviously needed syscalls with SECCOMP_RET_ALLOW, and then put the
    application through its paces. A list of syscalls that triggered the
    default action (SECCOMP_RET_LOG) can be easily gleaned from the logs and
    that list can be used to build the syscall whitelist. Finally, the
    developer can change the default action to the desired value.
    
    This provides a more friendly experience than seeing the application get
    killed, then updating the filter and rebuilding the app, seeing the
    application get killed due to a different syscall, then updating the
    filter and rebuilding the app, etc.
    
    The functionality is similar to what's supported by the various LSMs.
    SELinux has permissive mode, AppArmor has complain mode, SMACK has
    bring-up mode, etc.
    
    SECCOMP_RET_LOG is given a lower value than SECCOMP_RET_ALLOW as allow
    while logging is slightly more restrictive than quietly allowing.
    
    Unfortunately, the tests added for SECCOMP_RET_LOG are not capable of
    inspecting the audit log to verify that the syscall was logged.
    
    With this patch, the logic for deciding if an action will be logged is:
    
    if action == RET_ALLOW:
      do not log
    else if action == RET_KILL && RET_KILL in actions_logged:
      log
    else if action == RET_LOG && RET_LOG in actions_logged:
      log
    else if filter-requests-logging && action in actions_logged:
      log
    else if audit_enabled && process-is-being-audited:
      log
    else:
      do not log
    
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 19a611d0712e..f94433263e4b 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -31,6 +31,7 @@
 #define SECCOMP_RET_TRAP	0x00030000U /* disallow and force a SIGSYS */
 #define SECCOMP_RET_ERRNO	0x00050000U /* returns an errno */
 #define SECCOMP_RET_TRACE	0x7ff00000U /* pass to a tracer or disallow */
+#define SECCOMP_RET_LOG		0x7ffc0000U /* allow after logging */
 #define SECCOMP_RET_ALLOW	0x7fff0000U /* allow */
 
 /* Masks for the return value sections. */

commit e66a39977985b1e69e17c4042cb290768eca9b02
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri Aug 11 04:33:56 2017 +0000

    seccomp: Filter flag to log all actions except SECCOMP_RET_ALLOW
    
    Add a new filter flag, SECCOMP_FILTER_FLAG_LOG, that enables logging for
    all actions except for SECCOMP_RET_ALLOW for the given filter.
    
    SECCOMP_RET_KILL actions are always logged, when "kill" is in the
    actions_logged sysctl, and SECCOMP_RET_ALLOW actions are never logged,
    regardless of this flag.
    
    This flag can be used to create noisy filters that result in all
    non-allowed actions to be logged. A process may have one noisy filter,
    which is loaded with this flag, as well as a quiet filter that's not
    loaded with this flag. This allows for the actions in a set of filters
    to be selectively conveyed to the admin.
    
    Since a system could have a large number of allocated seccomp_filter
    structs, struct packing was taken in consideration. On 64 bit x86, the
    new log member takes up one byte of an existing four byte hole in the
    struct. On 32 bit x86, the new log member creates a new four byte hole
    (unavoidable) and consumes one of those bytes.
    
    Unfortunately, the tests added for SECCOMP_FILTER_FLAG_LOG are not
    capable of inspecting the audit log to verify that the actions taken in
    the filter were logged.
    
    With this patch, the logic for deciding if an action will be logged is:
    
    if action == RET_ALLOW:
      do not log
    else if action == RET_KILL && RET_KILL in actions_logged:
      log
    else if filter-requests-logging && action in actions_logged:
      log
    else if audit_enabled && process-is-being-audited:
      log
    else:
      do not log
    
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index aaad61cc46bc..19a611d0712e 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -17,6 +17,7 @@
 
 /* Valid flags for SECCOMP_SET_MODE_FILTER */
 #define SECCOMP_FILTER_FLAG_TSYNC	1
+#define SECCOMP_FILTER_FLAG_LOG		2
 
 /*
  * All BPF programs must return a 32-bit value.

commit d612b1fd8010d0d67b5287fe146b8b55bcbb8655
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri Aug 11 04:33:53 2017 +0000

    seccomp: Operation for checking if an action is available
    
    Userspace code that needs to check if the kernel supports a given action
    may not be able to use the /proc/sys/kernel/seccomp/actions_avail
    sysctl. The process may be running in a sandbox and, therefore,
    sufficient filesystem access may not be available. This patch adds an
    operation to the seccomp(2) syscall that allows userspace code to ask
    the kernel if a given action is available.
    
    If the action is supported by the kernel, 0 is returned. If the action
    is not supported by the kernel, -1 is returned with errno set to
    -EOPNOTSUPP. If this check is attempted on a kernel that doesn't support
    this new operation, -1 is returned with errno set to -EINVAL meaning
    that userspace code will have the ability to differentiate between the
    two error cases.
    
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Suggested-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index 0f238a43ff1e..aaad61cc46bc 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -11,8 +11,9 @@
 #define SECCOMP_MODE_FILTER	2 /* uses user-supplied filter. */
 
 /* Valid operations for seccomp syscall. */
-#define SECCOMP_SET_MODE_STRICT	0
-#define SECCOMP_SET_MODE_FILTER	1
+#define SECCOMP_SET_MODE_STRICT		0
+#define SECCOMP_SET_MODE_FILTER		1
+#define SECCOMP_GET_ACTION_AVAIL	2
 
 /* Valid flags for SECCOMP_SET_MODE_FILTER */
 #define SECCOMP_FILTER_FLAG_TSYNC	1

commit c2e1f2e30daa551db3c670c0ccfeab20a540b9e1
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Jun 5 00:23:17 2014 -0700

    seccomp: implement SECCOMP_FILTER_FLAG_TSYNC
    
    Applying restrictive seccomp filter programs to large or diverse
    codebases often requires handling threads which may be started early in
    the process lifetime (e.g., by code that is linked in). While it is
    possible to apply permissive programs prior to process start up, it is
    difficult to further restrict the kernel ABI to those threads after that
    point.
    
    This change adds a new seccomp syscall flag to SECCOMP_SET_MODE_FILTER for
    synchronizing thread group seccomp filters at filter installation time.
    
    When calling seccomp(SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC,
    filter) an attempt will be made to synchronize all threads in current's
    threadgroup to its new seccomp filter program. This is possible iff all
    threads are using a filter that is an ancestor to the filter current is
    attempting to synchronize to. NULL filters (where the task is running as
    SECCOMP_MODE_NONE) are also treated as ancestors allowing threads to be
    transitioned into SECCOMP_MODE_FILTER. If prctrl(PR_SET_NO_NEW_PRIVS,
    ...) has been set on the calling thread, no_new_privs will be set for
    all synchronized threads too. On success, 0 is returned. On failure,
    the pid of one of the failing threads will be returned and no filters
    will have been applied.
    
    The race conditions against another thread are:
    - requesting TSYNC (already handled by sighand lock)
    - performing a clone (already handled by sighand lock)
    - changing its filter (already handled by sighand lock)
    - calling exec (handled by cred_guard_mutex)
    The clone case is assisted by the fact that new threads will have their
    seccomp state duplicated from their parent before appearing on the tasklist.
    
    Holding cred_guard_mutex means that seccomp filters cannot be assigned
    while in the middle of another thread's exec (potentially bypassing
    no_new_privs or similar). The call to de_thread() may kill threads waiting
    for the mutex.
    
    Changes across threads to the filter pointer includes a barrier.
    
    Based on patches by Will Drewry.
    
    Suggested-by: Julien Tinnes <jln@chromium.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index b258878ba754..0f238a43ff1e 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -14,6 +14,9 @@
 #define SECCOMP_SET_MODE_STRICT	0
 #define SECCOMP_SET_MODE_FILTER	1
 
+/* Valid flags for SECCOMP_SET_MODE_FILTER */
+#define SECCOMP_FILTER_FLAG_TSYNC	1
+
 /*
  * All BPF programs must return a 32-bit value.
  * The bottom 16-bits are for optional return data.

commit 48dc92b9fc3926844257316e75ba11eb5c742b2c
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jun 25 16:08:24 2014 -0700

    seccomp: add "seccomp" syscall
    
    This adds the new "seccomp" syscall with both an "operation" and "flags"
    parameter for future expansion. The third argument is a pointer value,
    used with the SECCOMP_SET_MODE_FILTER operation. Currently, flags must
    be 0. This is functionally equivalent to prctl(PR_SET_SECCOMP, ...).
    
    In addition to the TSYNC flag later in this patch series, there is a
    non-zero chance that this syscall could be used for configuring a fixed
    argument area for seccomp-tracer-aware processes to pass syscall arguments
    in the future. Hence, the use of "seccomp" not simply "seccomp_add_filter"
    for this syscall. Additionally, this syscall uses operation, flags,
    and user pointer for arguments because strictly passing arguments via
    a user pointer would mean seccomp itself would be unable to trivially
    filter the seccomp syscall itself.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Andy Lutomirski <luto@amacapital.net>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
index ac2dc9f72973..b258878ba754 100644
--- a/include/uapi/linux/seccomp.h
+++ b/include/uapi/linux/seccomp.h
@@ -10,6 +10,10 @@
 #define SECCOMP_MODE_STRICT	1 /* uses hard-coded filter. */
 #define SECCOMP_MODE_FILTER	2 /* uses user-supplied filter. */
 
+/* Valid operations for seccomp syscall. */
+#define SECCOMP_SET_MODE_STRICT	0
+#define SECCOMP_SET_MODE_FILTER	1
+
 /*
  * All BPF programs must return a 32-bit value.
  * The bottom 16-bits are for optional return data.

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/seccomp.h b/include/uapi/linux/seccomp.h
new file mode 100644
index 000000000000..ac2dc9f72973
--- /dev/null
+++ b/include/uapi/linux/seccomp.h
@@ -0,0 +1,47 @@
+#ifndef _UAPI_LINUX_SECCOMP_H
+#define _UAPI_LINUX_SECCOMP_H
+
+#include <linux/compiler.h>
+#include <linux/types.h>
+
+
+/* Valid values for seccomp.mode and prctl(PR_SET_SECCOMP, <mode>) */
+#define SECCOMP_MODE_DISABLED	0 /* seccomp is not in use. */
+#define SECCOMP_MODE_STRICT	1 /* uses hard-coded filter. */
+#define SECCOMP_MODE_FILTER	2 /* uses user-supplied filter. */
+
+/*
+ * All BPF programs must return a 32-bit value.
+ * The bottom 16-bits are for optional return data.
+ * The upper 16-bits are ordered from least permissive values to most.
+ *
+ * The ordering ensures that a min_t() over composed return values always
+ * selects the least permissive choice.
+ */
+#define SECCOMP_RET_KILL	0x00000000U /* kill the task immediately */
+#define SECCOMP_RET_TRAP	0x00030000U /* disallow and force a SIGSYS */
+#define SECCOMP_RET_ERRNO	0x00050000U /* returns an errno */
+#define SECCOMP_RET_TRACE	0x7ff00000U /* pass to a tracer or disallow */
+#define SECCOMP_RET_ALLOW	0x7fff0000U /* allow */
+
+/* Masks for the return value sections. */
+#define SECCOMP_RET_ACTION	0x7fff0000U
+#define SECCOMP_RET_DATA	0x0000ffffU
+
+/**
+ * struct seccomp_data - the format the BPF program executes over.
+ * @nr: the system call number
+ * @arch: indicates system call convention as an AUDIT_ARCH_* value
+ *        as defined in <linux/audit.h>.
+ * @instruction_pointer: at the time of the system call.
+ * @args: up to 6 system call arguments always stored as 64-bit values
+ *        regardless of the architecture.
+ */
+struct seccomp_data {
+	int nr;
+	__u32 arch;
+	__u64 instruction_pointer;
+	__u64 args[6];
+};
+
+#endif /* _UAPI_LINUX_SECCOMP_H */
