commit 51c39bb1d5d105a02e29aa7960f0a395086e6342
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Thu Jan 9 22:41:20 2020 -0800

    bpf: Introduce function-by-function verification
    
    New llvm and old llvm with libbpf help produce BTF that distinguish global and
    static functions. Unlike arguments of static function the arguments of global
    functions cannot be removed or optimized away by llvm. The compiler has to use
    exactly the arguments specified in a function prototype. The argument type
    information allows the verifier validate each global function independently.
    For now only supported argument types are pointer to context and scalars. In
    the future pointers to structures, sizes, pointer to packet data can be
    supported as well. Consider the following example:
    
    static int f1(int ...)
    {
      ...
    }
    
    int f3(int b);
    
    int f2(int a)
    {
      f1(a) + f3(a);
    }
    
    int f3(int b)
    {
      ...
    }
    
    int main(...)
    {
      f1(...) + f2(...) + f3(...);
    }
    
    The verifier will start its safety checks from the first global function f2().
    It will recursively descend into f1() because it's static. Then it will check
    that arguments match for the f3() invocation inside f2(). It will not descend
    into f3(). It will finish f2() that has to be successfully verified for all
    possible values of 'a'. Then it will proceed with f3(). That function also has
    to be safe for all possible values of 'b'. Then it will start subprog 0 (which
    is main() function). It will recursively descend into f1() and will skip full
    check of f2() and f3(), since they are global. The order of processing global
    functions doesn't affect safety, since all global functions must be proven safe
    based on their arguments only.
    
    Such function by function verification can drastically improve speed of the
    verification and reduce complexity.
    
    Note that the stack limit of 512 still applies to the call chain regardless whether
    functions were static or global. The nested level of 8 also still applies. The
    same recursion prevention checks are in place as well.
    
    The type information and static/global kind is preserved after the verification
    hence in the above example global function f2() and f3() can be replaced later
    by equivalent functions with the same types that are loaded and verified later
    without affecting safety of this main() program. Such replacement (re-linking)
    of global functions is a subject of future patches.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20200110064124.1760511-3-ast@kernel.org

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 1a2898c482ee..5a667107ad2c 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -146,6 +146,12 @@ enum {
 	BTF_VAR_GLOBAL_EXTERN = 2,
 };
 
+enum btf_func_linkage {
+	BTF_FUNC_STATIC = 0,
+	BTF_FUNC_GLOBAL = 1,
+	BTF_FUNC_EXTERN = 2,
+};
+
 /* BTF_KIND_VAR is followed by a single "struct btf_var" to describe
  * additional information related to the variable such as its linkage.
  */

commit 166750bc1dd256b2184b22588fb9fe6d3fbb93ae
Author: Andrii Nakryiko <andriin@fb.com>
Date:   Fri Dec 13 17:47:08 2019 -0800

    libbpf: Support libbpf-provided extern variables
    
    Add support for extern variables, provided to BPF program by libbpf. Currently
    the following extern variables are supported:
      - LINUX_KERNEL_VERSION; version of a kernel in which BPF program is
        executing, follows KERNEL_VERSION() macro convention, can be 4- and 8-byte
        long;
      - CONFIG_xxx values; a set of values of actual kernel config. Tristate,
        boolean, strings, and integer values are supported.
    
    Set of possible values is determined by declared type of extern variable.
    Supported types of variables are:
    - Tristate values. Are represented as `enum libbpf_tristate`. Accepted values
      are **strictly** 'y', 'n', or 'm', which are represented as TRI_YES, TRI_NO,
      or TRI_MODULE, respectively.
    - Boolean values. Are represented as bool (_Bool) types. Accepted values are
      'y' and 'n' only, turning into true/false values, respectively.
    - Single-character values. Can be used both as a substritute for
      bool/tristate, or as a small-range integer:
      - 'y'/'n'/'m' are represented as is, as characters 'y', 'n', or 'm';
      - integers in a range [-128, 127] or [0, 255] (depending on signedness of
        char in target architecture) are recognized and represented with
        respective values of char type.
    - Strings. String values are declared as fixed-length char arrays. String of
      up to that length will be accepted and put in first N bytes of char array,
      with the rest of bytes zeroed out. If config string value is longer than
      space alloted, it will be truncated and warning message emitted. Char array
      is always zero terminated. String literals in config have to be enclosed in
      double quotes, just like C-style string literals.
    - Integers. 8-, 16-, 32-, and 64-bit integers are supported, both signed and
      unsigned variants. Libbpf enforces parsed config value to be in the
      supported range of corresponding integer type. Integers values in config can
      be:
      - decimal integers, with optional + and - signs;
      - hexadecimal integers, prefixed with 0x or 0X;
      - octal integers, starting with 0.
    
    Config file itself is searched in /boot/config-$(uname -r) location with
    fallback to /proc/config.gz, unless config path is specified explicitly
    through bpf_object_open_opts' kernel_config_path option. Both gzipped and
    plain text formats are supported. Libbpf adds explicit dependency on zlib
    because of this, but this shouldn't be a problem, given libelf already depends
    on zlib.
    
    All detected extern variables, are put into a separate .extern internal map.
    It, similarly to .rodata map, is marked as read-only from BPF program side, as
    well as is frozen on load. This allows BPF verifier to track extern values as
    constants and perform enhanced branch prediction and dead code elimination.
    This can be relied upon for doing kernel version/feature detection and using
    potentially unsupported field relocations or BPF helpers in a CO-RE-based BPF
    program, while still having a single version of BPF program running on old and
    new kernels. Selftests are validating this explicitly for unexisting BPF
    helper.
    
    Signed-off-by: Andrii Nakryiko <andriin@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Link: https://lore.kernel.org/bpf/20191214014710.3449601-3-andriin@fb.com

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index c02dec97e1ce..1a2898c482ee 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -142,7 +142,8 @@ struct btf_param {
 
 enum {
 	BTF_VAR_STATIC = 0,
-	BTF_VAR_GLOBAL_ALLOCATED,
+	BTF_VAR_GLOBAL_ALLOCATED = 1,
+	BTF_VAR_GLOBAL_EXTERN = 2,
 };
 
 /* BTF_KIND_VAR is followed by a single "struct btf_var" to describe

commit a0791f0df7d212c245761538b17a9ea93607b667
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Tue Sep 17 10:45:38 2019 -0700

    bpf: fix BTF limits
    
    vmlinux BTF has more than 64k types.
    Its string section is also at the offset larger than 64k.
    Adjust both limits to make in-kernel BTF verifier successfully parse in-kernel BTF.
    
    Fixes: 69b693f0aefa ("bpf: btf: Introduce BPF Type Format (BTF)")
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 63ae4a39e58b..c02dec97e1ce 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -22,9 +22,9 @@ struct btf_header {
 };
 
 /* Max # of type identifier */
-#define BTF_MAX_TYPE	0x0000ffff
+#define BTF_MAX_TYPE	0x000fffff
 /* Max offset into the string section */
-#define BTF_MAX_NAME_OFFSET	0x0000ffff
+#define BTF_MAX_NAME_OFFSET	0x00ffffff
 /* Max # of struct/union/enum members or func args */
 #define BTF_MAX_VLEN	0xffff
 

commit 948dc8c99a22d6bdcb34c194cde392e1a125928a
Author: Gary Lin <glin@suse.com>
Date:   Mon May 13 17:45:48 2019 +0800

    bpf: btf: fix the brackets of BTF_INT_OFFSET()
    
    'VAL' should be protected by the brackets.
    
    v2:
    * Squash the fix for Documentation/bpf/btf.rst
    
    Fixes: 69b693f0aefa ("bpf: btf: Introduce BPF Type Format (BTF)")
    Signed-off-by: Gary Lin <glin@suse.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 9310652ca4f9..63ae4a39e58b 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -83,7 +83,7 @@ struct btf_type {
  * is the 32 bits arrangement:
  */
 #define BTF_INT_ENCODING(VAL)	(((VAL) & 0x0f000000) >> 24)
-#define BTF_INT_OFFSET(VAL)	(((VAL  & 0x00ff0000)) >> 16)
+#define BTF_INT_OFFSET(VAL)	(((VAL) & 0x00ff0000) >> 16)
 #define BTF_INT_BITS(VAL)	((VAL)  & 0x000000ff)
 
 /* Attributes stored in the BTF_INT_ENCODING */

commit f063c889c9458354a92b235a51cbb60d30321070
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Tue Apr 9 23:20:08 2019 +0200

    bpf: add specification for BTF Var and DataSec kinds
    
    This adds the BTF specification and UAPI bits for supporting BTF Var
    and DataSec kinds. This is following LLVM upstream commit ac4082b77e07
    ("[BPF] Add BTF Var and DataSec Support") which has been merged recently.
    Var itself is for describing a global variable and DataSec to describe
    ELF sections e.g. data/bss/rodata sections that hold one or multiple
    global variables.
    
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 7b7475ef2f17..9310652ca4f9 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -39,11 +39,11 @@ struct btf_type {
 	 *             struct, union and fwd
 	 */
 	__u32 info;
-	/* "size" is used by INT, ENUM, STRUCT and UNION.
+	/* "size" is used by INT, ENUM, STRUCT, UNION and DATASEC.
 	 * "size" tells the size of the type it is describing.
 	 *
 	 * "type" is used by PTR, TYPEDEF, VOLATILE, CONST, RESTRICT,
-	 * FUNC and FUNC_PROTO.
+	 * FUNC, FUNC_PROTO and VAR.
 	 * "type" is a type_id referring to another type.
 	 */
 	union {
@@ -70,8 +70,10 @@ struct btf_type {
 #define BTF_KIND_RESTRICT	11	/* Restrict	*/
 #define BTF_KIND_FUNC		12	/* Function	*/
 #define BTF_KIND_FUNC_PROTO	13	/* Function Proto	*/
-#define BTF_KIND_MAX		13
-#define NR_BTF_KINDS		14
+#define BTF_KIND_VAR		14	/* Variable	*/
+#define BTF_KIND_DATASEC	15	/* Section	*/
+#define BTF_KIND_MAX		BTF_KIND_DATASEC
+#define NR_BTF_KINDS		(BTF_KIND_MAX + 1)
 
 /* For some specific BTF_KIND, "struct btf_type" is immediately
  * followed by extra data.
@@ -138,4 +140,26 @@ struct btf_param {
 	__u32	type;
 };
 
+enum {
+	BTF_VAR_STATIC = 0,
+	BTF_VAR_GLOBAL_ALLOCATED,
+};
+
+/* BTF_KIND_VAR is followed by a single "struct btf_var" to describe
+ * additional information related to the variable such as its linkage.
+ */
+struct btf_var {
+	__u32	linkage;
+};
+
+/* BTF_KIND_DATASEC is followed by multiple "struct btf_var_secinfo"
+ * to describe all BTF_KIND_VAR types it contains along with it's
+ * in-section offset as well as size.
+ */
+struct btf_var_secinfo {
+	__u32	type;
+	__u32	offset;
+	__u32	size;
+};
+
 #endif /* _UAPI__LINUX_BTF_H__ */

commit 9d5f9f701b1891466fb3dbb1806ad97716f95cc3
Author: Yonghong Song <yhs@fb.com>
Date:   Sat Dec 15 22:13:51 2018 -0800

    bpf: btf: fix struct/union/fwd types with kind_flag
    
    This patch fixed two issues with BTF. One is related to
    struct/union bitfield encoding and the other is related to
    forward type.
    
    Issue #1 and solution:
    
    ======================
    
    Current btf encoding of bitfield follows what pahole generates.
    For each bitfield, pahole will duplicate the type chain and
    put the bitfield size at the final int or enum type.
    Since the BTF enum type cannot encode bit size,
    pahole workarounds the issue by generating
    an int type whenever the enum bit size is not 32.
    
    For example,
      -bash-4.4$ cat t.c
      typedef int ___int;
      enum A { A1, A2, A3 };
      struct t {
        int a[5];
        ___int b:4;
        volatile enum A c:4;
      } g;
      -bash-4.4$ gcc -c -O2 -g t.c
    The current kernel supports the following BTF encoding:
      $ pahole -JV t.o
      [1] TYPEDEF ___int type_id=2
      [2] INT int size=4 bit_offset=0 nr_bits=32 encoding=SIGNED
      [3] ENUM A size=4 vlen=3
            A1 val=0
            A2 val=1
            A3 val=2
      [4] STRUCT t size=24 vlen=3
            a type_id=5 bits_offset=0
            b type_id=9 bits_offset=160
            c type_id=11 bits_offset=164
      [5] ARRAY (anon) type_id=2 index_type_id=2 nr_elems=5
      [6] INT sizetype size=8 bit_offset=0 nr_bits=64 encoding=(none)
      [7] VOLATILE (anon) type_id=3
      [8] INT int size=1 bit_offset=0 nr_bits=4 encoding=(none)
      [9] TYPEDEF ___int type_id=8
      [10] INT (anon) size=1 bit_offset=0 nr_bits=4 encoding=SIGNED
      [11] VOLATILE (anon) type_id=10
    
    Two issues are in the above:
      . by changing enum type to int, we lost the original
        type information and this will not be ideal later
        when we try to convert BTF to a header file.
      . the type duplication for bitfields will cause
        BTF bloat. Duplicated types cannot be deduplicated
        later if the bitfield size is different.
    
    To fix this issue, this patch implemented a compatible
    change for BTF struct type encoding:
      . the bit 31 of struct_type->info, previously reserved,
        now is used to indicate whether bitfield_size is
        encoded in btf_member or not.
      . if bit 31 of struct_type->info is set,
        btf_member->offset will encode like:
          bit 0 - 23: bit offset
          bit 24 - 31: bitfield size
        if bit 31 is not set, the old behavior is preserved:
          bit 0 - 31: bit offset
    
    So if the struct contains a bit field, the maximum bit offset
    will be reduced to (2^24 - 1) instead of MAX_UINT. The maximum
    bitfield size will be 256 which is enough for today as maximum
    bitfield in compiler can be 128 where int128 type is supported.
    
    This kernel patch intends to support the new BTF encoding:
      $ pahole -JV t.o
      [1] TYPEDEF ___int type_id=2
      [2] INT int size=4 bit_offset=0 nr_bits=32 encoding=SIGNED
      [3] ENUM A size=4 vlen=3
            A1 val=0
            A2 val=1
            A3 val=2
      [4] STRUCT t kind_flag=1 size=24 vlen=3
            a type_id=5 bitfield_size=0 bits_offset=0
            b type_id=1 bitfield_size=4 bits_offset=160
            c type_id=7 bitfield_size=4 bits_offset=164
      [5] ARRAY (anon) type_id=2 index_type_id=2 nr_elems=5
      [6] INT sizetype size=8 bit_offset=0 nr_bits=64 encoding=(none)
      [7] VOLATILE (anon) type_id=3
    
    Issue #2 and solution:
    ======================
    
    Current forward type in BTF does not specify whether the original
    type is struct or union. This will not work for type pretty print
    and BTF-to-header-file conversion as struct/union must be specified.
      $ cat tt.c
      struct t;
      union u;
      int foo(struct t *t, union u *u) { return 0; }
      $ gcc -c -g -O2 tt.c
      $ pahole -JV tt.o
      [1] INT int size=4 bit_offset=0 nr_bits=32 encoding=SIGNED
      [2] FWD t type_id=0
      [3] PTR (anon) type_id=2
      [4] FWD u type_id=0
      [5] PTR (anon) type_id=4
    
    To fix this issue, similar to issue #1, type->info bit 31
    is used. If the bit is set, it is union type. Otherwise, it is
    a struct type.
    
      $ pahole -JV tt.o
      [1] INT int size=4 bit_offset=0 nr_bits=32 encoding=SIGNED
      [2] FWD t kind_flag=0 type_id=0
      [3] PTR (anon) kind_flag=0 type_id=2
      [4] FWD u kind_flag=1 type_id=0
      [5] PTR (anon) kind_flag=0 type_id=4
    
    Pahole/LLVM change:
    ===================
    
    The new kind_flag functionality has been implemented in pahole
    and llvm:
      https://github.com/yonghong-song/pahole/tree/bitfield
      https://github.com/yonghong-song/llvm/tree/bitfield
    
    Note that pahole hasn't implemented func/func_proto kind
    and .BTF.ext. So to print function signature with bpftool,
    the llvm compiler should be used.
    
    Fixes: 69b693f0aefa ("bpf: btf: Introduce BPF Type Format (BTF)")
    Acked-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 14f66948fc95..7b7475ef2f17 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -34,7 +34,9 @@ struct btf_type {
 	 * bits  0-15: vlen (e.g. # of struct's members)
 	 * bits 16-23: unused
 	 * bits 24-27: kind (e.g. int, ptr, array...etc)
-	 * bits 28-31: unused
+	 * bits 28-30: unused
+	 * bit     31: kind_flag, currently used by
+	 *             struct, union and fwd
 	 */
 	__u32 info;
 	/* "size" is used by INT, ENUM, STRUCT and UNION.
@@ -52,6 +54,7 @@ struct btf_type {
 
 #define BTF_INFO_KIND(info)	(((info) >> 24) & 0x0f)
 #define BTF_INFO_VLEN(info)	((info) & 0xffff)
+#define BTF_INFO_KFLAG(info)	((info) >> 31)
 
 #define BTF_KIND_UNKN		0	/* Unknown	*/
 #define BTF_KIND_INT		1	/* Integer	*/
@@ -110,9 +113,22 @@ struct btf_array {
 struct btf_member {
 	__u32	name_off;
 	__u32	type;
-	__u32	offset;	/* offset in bits */
+	/* If the type info kind_flag is set, the btf_member offset
+	 * contains both member bitfield size and bit offset. The
+	 * bitfield size is set for bitfield members. If the type
+	 * info kind_flag is not set, the offset contains only bit
+	 * offset.
+	 */
+	__u32	offset;
 };
 
+/* If the struct/union type info kind_flag is set, the
+ * following two macros are used to access bitfield_size
+ * and bit_offset from btf_member.offset.
+ */
+#define BTF_MEMBER_BITFIELD_SIZE(val)	((val) >> 24)
+#define BTF_MEMBER_BIT_OFFSET(val)	((val) & 0xffffff)
+
 /* BTF_KIND_FUNC_PROTO is followed by multiple "struct btf_param".
  * The exact number of btf_param is stored in the vlen (of the
  * info in "struct btf_type").

commit 2667a2626f4da370409c2830552f6e8c8b8c41e2
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Mon Nov 19 15:29:08 2018 -0800

    bpf: btf: Add BTF_KIND_FUNC and BTF_KIND_FUNC_PROTO
    
    This patch adds BTF_KIND_FUNC and BTF_KIND_FUNC_PROTO
    to support the function debug info.
    
    BTF_KIND_FUNC_PROTO must not have a name (i.e. !t->name_off)
    and it is followed by >= 0 'struct bpf_param' objects to
    describe the function arguments.
    
    The BTF_KIND_FUNC must have a valid name and it must
    refer back to a BTF_KIND_FUNC_PROTO.
    
    The above is the conclusion after the discussion between
    Edward Cree, Alexei, Daniel, Yonghong and Martin.
    
    By combining BTF_KIND_FUNC and BTF_LIND_FUNC_PROTO,
    a complete function signature can be obtained.  It will be
    used in the later patches to learn the function signature of
    a running bpf program.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 972265f32871..14f66948fc95 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -40,7 +40,8 @@ struct btf_type {
 	/* "size" is used by INT, ENUM, STRUCT and UNION.
 	 * "size" tells the size of the type it is describing.
 	 *
-	 * "type" is used by PTR, TYPEDEF, VOLATILE, CONST and RESTRICT.
+	 * "type" is used by PTR, TYPEDEF, VOLATILE, CONST, RESTRICT,
+	 * FUNC and FUNC_PROTO.
 	 * "type" is a type_id referring to another type.
 	 */
 	union {
@@ -64,8 +65,10 @@ struct btf_type {
 #define BTF_KIND_VOLATILE	9	/* Volatile	*/
 #define BTF_KIND_CONST		10	/* Const	*/
 #define BTF_KIND_RESTRICT	11	/* Restrict	*/
-#define BTF_KIND_MAX		11
-#define NR_BTF_KINDS		12
+#define BTF_KIND_FUNC		12	/* Function	*/
+#define BTF_KIND_FUNC_PROTO	13	/* Function Proto	*/
+#define BTF_KIND_MAX		13
+#define NR_BTF_KINDS		14
 
 /* For some specific BTF_KIND, "struct btf_type" is immediately
  * followed by extra data.
@@ -110,4 +113,13 @@ struct btf_member {
 	__u32	offset;	/* offset in bits */
 };
 
+/* BTF_KIND_FUNC_PROTO is followed by multiple "struct btf_param".
+ * The exact number of btf_param is stored in the vlen (of the
+ * info in "struct btf_type").
+ */
+struct btf_param {
+	__u32	name_off;
+	__u32	type;
+};
+
 #endif /* _UAPI__LINUX_BTF_H__ */

commit 36fc3c8c282c01ad1570bd864de52f128d731b75
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Thu Jul 19 22:14:31 2018 -0700

    bpf: btf: Clean up BTF_INT_BITS() in uapi btf.h
    
    This patch shrinks the BTF_INT_BITS() mask.  The current
    btf_int_check_meta() ensures the nr_bits of an integer
    cannot exceed 64.  Hence, it is mostly an uapi cleanup.
    
    The actual btf usage (i.e. seq_show()) is also modified
    to use u8 instead of u16.  The verification (e.g. btf_int_check_meta())
    path stays as is to deal with invalid BTF situation.
    
    Fixes: 69b693f0aefa ("bpf: btf: Introduce BPF Type Format (BTF)")
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 0b5ddbe135a4..972265f32871 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -76,7 +76,7 @@ struct btf_type {
  */
 #define BTF_INT_ENCODING(VAL)	(((VAL) & 0x0f000000) >> 24)
 #define BTF_INT_OFFSET(VAL)	(((VAL  & 0x00ff0000)) >> 16)
-#define BTF_INT_BITS(VAL)	((VAL)  & 0x0000ffff)
+#define BTF_INT_BITS(VAL)	((VAL)  & 0x000000ff)
 
 /* Attributes stored in the BTF_INT_ENCODING */
 #define BTF_INT_SIGNED	(1 << 0)

commit aea2f7b8911617d7a8c23fb73d69e78764f91b58
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Tue May 22 14:57:20 2018 -0700

    bpf: btf: Remove unused bits from uapi/linux/btf.h
    
    This patch does the followings:
    1. Limit BTF_MAX_TYPES and BTF_MAX_NAME_OFFSET to 64k.  We can
       raise it later.
    
    2. Remove the BTF_TYPE_PARENT and BTF_STR_TBL_ELF_ID.  They are
       currently encoded at the highest bit of a u32.
       It is because the current use case does not require supporting
       parent type (i.e type_id referring to a type in another BTF file).
       It also does not support referring to a string in ELF.
    
       The BTF_TYPE_PARENT and BTF_STR_TBL_ELF_ID checks are replaced
       by BTF_TYPE_ID_CHECK and BTF_STR_OFFSET_CHECK which are
       defined in btf.c instead of uapi/linux/btf.h.
    
    3. Limit the BTF_INFO_KIND from 5 bits to 4 bits which is enough.
       There is unused bits headroom if we ever needed it later.
    
    4. The root bit in BTF_INFO is also removed because it is not
       used in the current use case.
    
    5. Remove BTF_INT_VARARGS since func type is not supported now.
       The BTF_INT_ENCODING is limited to 4 bits instead of 8 bits.
    
    The above can be added back later because the verifier
    ensures the unused bits are zeros.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Yonghong Song <yhs@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 4fa479741a02..0b5ddbe135a4 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -22,28 +22,19 @@ struct btf_header {
 };
 
 /* Max # of type identifier */
-#define BTF_MAX_TYPE	0x7fffffff
+#define BTF_MAX_TYPE	0x0000ffff
 /* Max offset into the string section */
-#define BTF_MAX_NAME_OFFSET	0x7fffffff
+#define BTF_MAX_NAME_OFFSET	0x0000ffff
 /* Max # of struct/union/enum members or func args */
 #define BTF_MAX_VLEN	0xffff
 
-/* The type id is referring to a parent BTF */
-#define BTF_TYPE_PARENT(id)	(((id) >> 31) & 0x1)
-#define BTF_TYPE_ID(id)		((id) & BTF_MAX_TYPE)
-
-/* String is in the ELF string section */
-#define BTF_STR_TBL_ELF_ID(ref)	(((ref) >> 31) & 0x1)
-#define BTF_STR_OFFSET(ref)	((ref) & BTF_MAX_NAME_OFFSET)
-
 struct btf_type {
 	__u32 name_off;
 	/* "info" bits arrangement
 	 * bits  0-15: vlen (e.g. # of struct's members)
 	 * bits 16-23: unused
-	 * bits 24-28: kind (e.g. int, ptr, array...etc)
-	 * bits 29-30: unused
-	 * bits    31: root
+	 * bits 24-27: kind (e.g. int, ptr, array...etc)
+	 * bits 28-31: unused
 	 */
 	__u32 info;
 	/* "size" is used by INT, ENUM, STRUCT and UNION.
@@ -58,8 +49,7 @@ struct btf_type {
 	};
 };
 
-#define BTF_INFO_KIND(info)	(((info) >> 24) & 0x1f)
-#define BTF_INFO_ISROOT(info)	(!!(((info) >> 24) & 0x80))
+#define BTF_INFO_KIND(info)	(((info) >> 24) & 0x0f)
 #define BTF_INFO_VLEN(info)	((info) & 0xffff)
 
 #define BTF_KIND_UNKN		0	/* Unknown	*/
@@ -84,15 +74,14 @@ struct btf_type {
 /* BTF_KIND_INT is followed by a u32 and the following
  * is the 32 bits arrangement:
  */
-#define BTF_INT_ENCODING(VAL)	(((VAL) & 0xff000000) >> 24)
+#define BTF_INT_ENCODING(VAL)	(((VAL) & 0x0f000000) >> 24)
 #define BTF_INT_OFFSET(VAL)	(((VAL  & 0x00ff0000)) >> 16)
 #define BTF_INT_BITS(VAL)	((VAL)  & 0x0000ffff)
 
 /* Attributes stored in the BTF_INT_ENCODING */
-#define BTF_INT_SIGNED	0x1
-#define BTF_INT_CHAR	0x2
-#define BTF_INT_BOOL	0x4
-#define BTF_INT_VARARGS	0x8
+#define BTF_INT_SIGNED	(1 << 0)
+#define BTF_INT_CHAR	(1 << 1)
+#define BTF_INT_BOOL	(1 << 2)
 
 /* BTF_KIND_ENUM is followed by multiple "struct btf_enum".
  * The exact number of btf_enum is stored in the vlen (of the

commit f80442a4cd1864154beaa060bb483a2c9f7d811f
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Tue May 22 14:57:18 2018 -0700

    bpf: btf: Change how section is supported in btf_header
    
    There are currently unused section descriptions in the btf_header.  Those
    sections are here to support future BTF use cases.  For example, the
    func section (func_off) is to support function signature (e.g. the BPF
    prog function signature).
    
    Instead of spelling out all potential sections up-front in the btf_header.
    This patch makes changes to btf_header such that extending it (e.g. adding
    a section) is possible later.  The unused ones can be removed for now and
    they can be added back later.
    
    This patch:
    1. adds a hdr_len to the btf_header.  It will allow adding
    sections (and other info like parent_label and parent_name)
    later.  The check is similar to the existing bpf_attr.
    If a user passes in a longer hdr_len, the kernel
    ensures the extra tailing bytes are 0.
    
    2. allows the section order in the BTF object to be
    different from its sec_off order in btf_header.
    
    3. each sec_off is followed by a sec_len.  It must not have gap or
    overlapping among sections.
    
    The string section is ensured to be at the end due to the 4 bytes
    alignment requirement of the type section.
    
    The above changes will allow enough flexibility to
    add new sections (and other info) to the btf_header later.
    
    This patch also removes an unnecessary !err check
    at the end of btf_parse().
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index bcb56ee47014..4fa479741a02 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -12,15 +12,11 @@ struct btf_header {
 	__u16	magic;
 	__u8	version;
 	__u8	flags;
-
-	__u32	parent_label;
-	__u32	parent_name;
+	__u32	hdr_len;
 
 	/* All offsets are in bytes relative to the end of this header */
-	__u32	label_off;	/* offset of label section	*/
-	__u32	object_off;	/* offset of data object section*/
-	__u32	func_off;	/* offset of function section	*/
 	__u32	type_off;	/* offset of type section	*/
+	__u32	type_len;	/* length of type section	*/
 	__u32	str_off;	/* offset of string section	*/
 	__u32	str_len;	/* length of string section	*/
 };

commit fbcf93ebcaef7d09881ee308b52cd84f5e43c622
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Sat Apr 21 09:48:23 2018 -0700

    bpf: btf: Clean up btf.h in uapi
    
    This patch cleans up btf.h in uapi:
    1) Rename "name" to "name_off" to better reflect it is an offset to the
       string section instead of a char array.
    2) Remove unused value BTF_FLAGS_COMPR and BTF_MAGIC_SWAP
    
    Suggested-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index 74a30b1090df..bcb56ee47014 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -6,9 +6,7 @@
 #include <linux/types.h>
 
 #define BTF_MAGIC	0xeB9F
-#define BTF_MAGIC_SWAP	0x9FeB
 #define BTF_VERSION	1
-#define BTF_FLAGS_COMPR	0x01
 
 struct btf_header {
 	__u16	magic;
@@ -43,7 +41,7 @@ struct btf_header {
 #define BTF_STR_OFFSET(ref)	((ref) & BTF_MAX_NAME_OFFSET)
 
 struct btf_type {
-	__u32 name;
+	__u32 name_off;
 	/* "info" bits arrangement
 	 * bits  0-15: vlen (e.g. # of struct's members)
 	 * bits 16-23: unused
@@ -105,7 +103,7 @@ struct btf_type {
  * info in "struct btf_type").
  */
 struct btf_enum {
-	__u32	name;
+	__u32	name_off;
 	__s32	val;
 };
 
@@ -122,7 +120,7 @@ struct btf_array {
  * "struct btf_type").
  */
 struct btf_member {
-	__u32	name;
+	__u32	name_off;
 	__u32	type;
 	__u32	offset;	/* offset in bits */
 };

commit 69b693f0aefa0ed521e8bd02260523b5ae446ad7
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Wed Apr 18 15:55:57 2018 -0700

    bpf: btf: Introduce BPF Type Format (BTF)
    
    This patch introduces BPF type Format (BTF).
    
    BTF (BPF Type Format) is the meta data format which describes
    the data types of BPF program/map.  Hence, it basically focus
    on the C programming language which the modern BPF is primary
    using.  The first use case is to provide a generic pretty print
    capability for a BPF map.
    
    BTF has its root from CTF (Compact C-Type format).  To simplify
    the handling of BTF data, BTF removes the differences between
    small and big type/struct-member.  Hence, BTF consistently uses u32
    instead of supporting both "one u16" and "two u32 (+padding)" in
    describing type and struct-member.
    
    It also raises the number of types (and functions) limit
    from 0x7fff to 0x7fffffff.
    
    Due to the above changes,  the format is not compatible to CTF.
    Hence, BTF starts with a new BTF_MAGIC and version number.
    
    This patch does the first verification pass to the BTF.  The first
    pass checks:
    1. meta-data size (e.g. It does not go beyond the total btf's size)
    2. name_offset is valid
    3. Each BTF_KIND (e.g. int, enum, struct....) does its
       own check of its meta-data.
    
    Some other checks, like checking a struct's member is referring
    to a valid type, can only be done in the second pass.  The second
    verification pass will be implemented in the next patch.
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Acked-by: Alexei Starovoitov <ast@fb.com>
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>

diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
new file mode 100644
index 000000000000..74a30b1090df
--- /dev/null
+++ b/include/uapi/linux/btf.h
@@ -0,0 +1,130 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/* Copyright (c) 2018 Facebook */
+#ifndef _UAPI__LINUX_BTF_H__
+#define _UAPI__LINUX_BTF_H__
+
+#include <linux/types.h>
+
+#define BTF_MAGIC	0xeB9F
+#define BTF_MAGIC_SWAP	0x9FeB
+#define BTF_VERSION	1
+#define BTF_FLAGS_COMPR	0x01
+
+struct btf_header {
+	__u16	magic;
+	__u8	version;
+	__u8	flags;
+
+	__u32	parent_label;
+	__u32	parent_name;
+
+	/* All offsets are in bytes relative to the end of this header */
+	__u32	label_off;	/* offset of label section	*/
+	__u32	object_off;	/* offset of data object section*/
+	__u32	func_off;	/* offset of function section	*/
+	__u32	type_off;	/* offset of type section	*/
+	__u32	str_off;	/* offset of string section	*/
+	__u32	str_len;	/* length of string section	*/
+};
+
+/* Max # of type identifier */
+#define BTF_MAX_TYPE	0x7fffffff
+/* Max offset into the string section */
+#define BTF_MAX_NAME_OFFSET	0x7fffffff
+/* Max # of struct/union/enum members or func args */
+#define BTF_MAX_VLEN	0xffff
+
+/* The type id is referring to a parent BTF */
+#define BTF_TYPE_PARENT(id)	(((id) >> 31) & 0x1)
+#define BTF_TYPE_ID(id)		((id) & BTF_MAX_TYPE)
+
+/* String is in the ELF string section */
+#define BTF_STR_TBL_ELF_ID(ref)	(((ref) >> 31) & 0x1)
+#define BTF_STR_OFFSET(ref)	((ref) & BTF_MAX_NAME_OFFSET)
+
+struct btf_type {
+	__u32 name;
+	/* "info" bits arrangement
+	 * bits  0-15: vlen (e.g. # of struct's members)
+	 * bits 16-23: unused
+	 * bits 24-28: kind (e.g. int, ptr, array...etc)
+	 * bits 29-30: unused
+	 * bits    31: root
+	 */
+	__u32 info;
+	/* "size" is used by INT, ENUM, STRUCT and UNION.
+	 * "size" tells the size of the type it is describing.
+	 *
+	 * "type" is used by PTR, TYPEDEF, VOLATILE, CONST and RESTRICT.
+	 * "type" is a type_id referring to another type.
+	 */
+	union {
+		__u32 size;
+		__u32 type;
+	};
+};
+
+#define BTF_INFO_KIND(info)	(((info) >> 24) & 0x1f)
+#define BTF_INFO_ISROOT(info)	(!!(((info) >> 24) & 0x80))
+#define BTF_INFO_VLEN(info)	((info) & 0xffff)
+
+#define BTF_KIND_UNKN		0	/* Unknown	*/
+#define BTF_KIND_INT		1	/* Integer	*/
+#define BTF_KIND_PTR		2	/* Pointer	*/
+#define BTF_KIND_ARRAY		3	/* Array	*/
+#define BTF_KIND_STRUCT		4	/* Struct	*/
+#define BTF_KIND_UNION		5	/* Union	*/
+#define BTF_KIND_ENUM		6	/* Enumeration	*/
+#define BTF_KIND_FWD		7	/* Forward	*/
+#define BTF_KIND_TYPEDEF	8	/* Typedef	*/
+#define BTF_KIND_VOLATILE	9	/* Volatile	*/
+#define BTF_KIND_CONST		10	/* Const	*/
+#define BTF_KIND_RESTRICT	11	/* Restrict	*/
+#define BTF_KIND_MAX		11
+#define NR_BTF_KINDS		12
+
+/* For some specific BTF_KIND, "struct btf_type" is immediately
+ * followed by extra data.
+ */
+
+/* BTF_KIND_INT is followed by a u32 and the following
+ * is the 32 bits arrangement:
+ */
+#define BTF_INT_ENCODING(VAL)	(((VAL) & 0xff000000) >> 24)
+#define BTF_INT_OFFSET(VAL)	(((VAL  & 0x00ff0000)) >> 16)
+#define BTF_INT_BITS(VAL)	((VAL)  & 0x0000ffff)
+
+/* Attributes stored in the BTF_INT_ENCODING */
+#define BTF_INT_SIGNED	0x1
+#define BTF_INT_CHAR	0x2
+#define BTF_INT_BOOL	0x4
+#define BTF_INT_VARARGS	0x8
+
+/* BTF_KIND_ENUM is followed by multiple "struct btf_enum".
+ * The exact number of btf_enum is stored in the vlen (of the
+ * info in "struct btf_type").
+ */
+struct btf_enum {
+	__u32	name;
+	__s32	val;
+};
+
+/* BTF_KIND_ARRAY is followed by one "struct btf_array" */
+struct btf_array {
+	__u32	type;
+	__u32	index_type;
+	__u32	nelems;
+};
+
+/* BTF_KIND_STRUCT and BTF_KIND_UNION are followed
+ * by multiple "struct btf_member".  The exact number
+ * of btf_member is stored in the vlen (of the info in
+ * "struct btf_type").
+ */
+struct btf_member {
+	__u32	name;
+	__u32	type;
+	__u32	offset;	/* offset in bits */
+};
+
+#endif /* _UAPI__LINUX_BTF_H__ */
