commit 4ed3350539aa931f58c939fcd803c7510584e143
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Aug 13 16:15:38 2019 -0400

    USB: usbfs: Add a capability flag for runtime suspend
    
    The recent commit 7794f486ed0b ("usbfs: Add ioctls for runtime power
    management") neglected to add a corresponding capability flag.  This
    patch rectifies the omission.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Mayuresh Kulkarni <mkulkarni@opensource.cirrus.com>
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908131613490.1941-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index d24bbb6d3ca1..cf525cddeb94 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -158,6 +158,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_MMAP			0x20
 #define USBDEVFS_CAP_DROP_PRIVILEGES		0x40
 #define USBDEVFS_CAP_CONNINFO_EX		0x80
+#define USBDEVFS_CAP_SUSPEND			0x100
 
 /* USBDEVFS_DISCONNECT_CLAIM flags & struct */
 

commit 7794f486ed0b1fa8022dd0a27b9babf86a46d1cf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 7 10:29:50 2019 -0400

    usbfs: Add ioctls for runtime power management
    
    It has been requested that usbfs should implement runtime power
    management, instead of forcing the device to remain at full power as
    long as the device file is open.  This patch introduces that new
    feature.
    
    It does so by adding three new usbfs ioctls:
    
            USBDEVFS_FORBID_SUSPEND: Prevents the device from going into
            runtime suspend (and causes a resume if the device is already
            suspended).
    
            USBDEVFS_ALLOW_SUSPEND: Allows the device to go into runtime
            suspend.  Some time may elapse before the device actually is
            suspended, depending on things like the autosuspend delay.
    
            USBDEVFS_WAIT_FOR_RESUME: Blocks until the call is interrupted
            by a signal or at least one runtime resume has occurred since
            the most recent ALLOW_SUSPEND ioctl call (which may mean
            immediately, even if the device is currently suspended).  In
            the latter case, the device is prevented from suspending again
            just as if FORBID_SUSPEND was called before the ioctl returns.
    
    For backward compatibility, when the device file is first opened
    runtime suspends are forbidden.  The userspace program can then allow
    suspends whenever it wants, and either resume the device directly (by
    forbidding suspends again) or wait for a resume from some other source
    (such as a remote wakeup).  URBs submitted to a suspended device will
    fail or will complete with an appropriate error code.
    
    This combination of ioctls is sufficient for user programs to have
    nearly the same degree of control over a device's runtime power
    behavior as kernel drivers do.
    
    Still lacking is documentation for the new ioctls.  I intend to add it
    later, after the existing documentation for the usbfs userspace API is
    straightened out into a reasonable form.
    
    Suggested-by: Mayuresh Kulkarni <mkulkarni@opensource.cirrus.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908071013220.1514-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 78efe870c2b7..d24bbb6d3ca1 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -223,5 +223,8 @@ struct usbdevfs_streams {
  * extending size of the data returned.
  */
 #define USBDEVFS_CONNINFO_EX(len)  _IOC(_IOC_READ, 'U', 32, len)
+#define USBDEVFS_FORBID_SUSPEND    _IO('U', 33)
+#define USBDEVFS_ALLOW_SUSPEND     _IO('U', 34)
+#define USBDEVFS_WAIT_FOR_RESUME   _IO('U', 35)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */

commit b119deca1e016e37614117f56f74461eac559af5
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Jun 19 16:36:16 2019 +1000

    USB: fix types in uapi include
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 4b267fe3776e..78efe870c2b7 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -85,11 +85,11 @@ struct usbdevfs_conninfo_ex {
 				/* kernel, the device is connected to.     */
 	__u32 devnum;           /* Device address on the bus.              */
 	__u32 speed;		/* USB_SPEED_* constants from ch9.h        */
-	u8 num_ports;		/* Number of ports the device is connected */
+	__u8 num_ports;		/* Number of ports the device is connected */
 				/* to on the way to the root hub. It may   */
 				/* be bigger than size of 'ports' array so */
 				/* userspace can detect overflows.         */
-	u8 ports[7];		/* List of ports on the way from the root  */
+	__u8 ports[7];		/* List of ports on the way from the root  */
 				/* hub to the device. Current limit in     */
 				/* USB specification is 7 tiers (root hub, */
 				/* 5 intermediate hubs, device), which     */

commit 6d101f24f1dd41ef6eff3d7f175417ce27a3055a
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Jun 10 15:36:58 2019 -0700

    USB: add usbfs ioctl to retrieve the connection parameters
    
    Recently usfbs gained availability to retrieve device speed, but there
    is sill no way to determine the bus number or list of ports the device
    is connected to when using usbfs. While this information can be obtained
    from sysfs, not all environments allow sysfs access. In a jailed
    environment a program might be simply given an opened file descriptor to
    usbfs device, and it is really important that all data can be gathered
    from said file descriptor.
    
    This patch introduces a new ioctl, USBDEVFS_CONNINFO_EX, which return
    extended connection information for the device, including the bus
    number, address, port list and speed. The API allows kernel to extend
    amount of data returned by the ioctl and userspace has an option of
    adjusting the amount of data it is willing to consume. A new capability,
    USBDEVFS_CAP_CONNINFO_EX, is introduced to help userspace in determining
    whether the kernel supports this new ioctl.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 964e87217be4..4b267fe3776e 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -76,6 +76,26 @@ struct usbdevfs_connectinfo {
 	unsigned char slow;
 };
 
+struct usbdevfs_conninfo_ex {
+	__u32 size;		/* Size of the structure from the kernel's */
+				/* point of view. Can be used by userspace */
+				/* to determine how much data can be       */
+				/* used/trusted.                           */
+	__u32 busnum;           /* USB bus number, as enumerated by the    */
+				/* kernel, the device is connected to.     */
+	__u32 devnum;           /* Device address on the bus.              */
+	__u32 speed;		/* USB_SPEED_* constants from ch9.h        */
+	u8 num_ports;		/* Number of ports the device is connected */
+				/* to on the way to the root hub. It may   */
+				/* be bigger than size of 'ports' array so */
+				/* userspace can detect overflows.         */
+	u8 ports[7];		/* List of ports on the way from the root  */
+				/* hub to the device. Current limit in     */
+				/* USB specification is 7 tiers (root hub, */
+				/* 5 intermediate hubs, device), which     */
+				/* gives at most 6 port entries.           */
+};
+
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
 #define USBDEVFS_URB_BULK_CONTINUATION	0x04
@@ -137,6 +157,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10
 #define USBDEVFS_CAP_MMAP			0x20
 #define USBDEVFS_CAP_DROP_PRIVILEGES		0x40
+#define USBDEVFS_CAP_CONNINFO_EX		0x80
 
 /* USBDEVFS_DISCONNECT_CLAIM flags & struct */
 
@@ -197,5 +218,10 @@ struct usbdevfs_streams {
 #define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
 #define USBDEVFS_DROP_PRIVILEGES   _IOW('U', 30, __u32)
 #define USBDEVFS_GET_SPEED         _IO('U', 31)
+/*
+ * Returns struct usbdevfs_conninfo_ex; length is variable to allow
+ * extending size of the data returned.
+ */
+#define USBDEVFS_CONNINFO_EX(len)  _IOC(_IOC_READ, 'U', 32, len)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */

commit aa15d3d257f9edcb8d15ed27e228d1c0080cb919
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Dec 11 11:58:21 2017 -0500

    USB: remove the URB_NO_FSBR flag
    
    The URB_NO_FSBR flag has never really been used.  It was introduced as
    a potential way for UHCI to minimize PCI bus usage (by not attempting
    full-speed bulk and control transfers more than once per frame), but
    the flag was not set by any drivers.
    
    There's no point in keeping it around.  This patch simplifies the API
    by removing it.  Unfortunately, it does have to be kept as part of the
    usbfs ABI, but at least we can document in
    include/uapi/linux/usbdevice_fs.h that it doesn't do anything.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 70ed5338d447..964e87217be4 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -79,7 +79,7 @@ struct usbdevfs_connectinfo {
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
 #define USBDEVFS_URB_BULK_CONTINUATION	0x04
-#define USBDEVFS_URB_NO_FSBR		0x20
+#define USBDEVFS_URB_NO_FSBR		0x20	/* Not used */
 #define USBDEVFS_URB_ZERO_PACKET	0x40
 #define USBDEVFS_URB_NO_INTERRUPT	0x80
 

commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 0bbfd4abd2e3..70ed5338d447 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
 /*****************************************************************************/
 
 /*

commit c01b244ad848ac7f0faa141182db80650a8a761a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 5 10:28:01 2017 -0400

    USB: add usbfs ioctl to retrieve the connection speed
    
    The usbfs interface does not provide any way for the user to learn the
    speed at which a device is connected.  The current API includes a
    USBDEVFS_CONNECTINFO ioctl, but all it provides is the device's
    address and a one-bit value indicating whether the connection is low
    speed.  That may have sufficed in the era of USB-1.1, but it isn't
    good enough today.
    
    This patch introduces a new ioctl, USBDEVFS_GET_SPEED, which returns a
    numeric value indicating the speed of the connection: unknown, low,
    full, high, wireless, super, or super-plus.
    
    Similar information (not exactly the same) is available through sysfs,
    but it seems reasonable to provide the actual value in usbfs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Reinhard Huck <reinhard.huck@thesycon.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index a8653a6f40df..0bbfd4abd2e3 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -156,6 +156,11 @@ struct usbdevfs_streams {
 	unsigned char eps[0];
 };
 
+/*
+ * USB_SPEED_* values returned by USBDEVFS_GET_SPEED are defined in
+ * linux/usb/ch9.h
+ */
+
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
 #define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
 #define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
@@ -190,5 +195,6 @@ struct usbdevfs_streams {
 #define USBDEVFS_ALLOC_STREAMS     _IOR('U', 28, struct usbdevfs_streams)
 #define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
 #define USBDEVFS_DROP_PRIVILEGES   _IOW('U', 30, __u32)
+#define USBDEVFS_GET_SPEED         _IO('U', 31)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */

commit d883f52e1f6d2eca8378e3795f333c1396943873
Author: Reilly Grant <reillyg@chromium.org>
Date:   Sun Feb 21 18:38:01 2016 -0300

    usb: devio: Add ioctl to disallow detaching kernel USB drivers.
    
    The new USBDEVFS_DROP_PRIVILEGES ioctl allows a process to voluntarily
    relinquish the ability to issue other ioctls that may interfere with
    other processes and drivers that have claimed an interface on the
    device.
    
    This commit also includes a simple utility to be able to test the
    ioctl, located at Documentation/usb/usbdevfs-drop-permissions.c
    
    Example (with qemu-kvm's input device):
    
        $ lsusb
        ...
        Bus 001 Device 002: ID 0627:0001 Adomax Technology Co., Ltd
    
        $ usb-devices
        ...
        C:  #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=100mA
        I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=00 Prot=02 Driver=usbhid
    
        $ sudo ./usbdevfs-drop-permissions /dev/bus/usb/001/002
        OK: privileges dropped!
        Available options:
        [0] Exit now
        [1] Reset device. Should fail if device is in use
        [2] Claim 4 interfaces. Should succeed where not in use
        [3] Narrow interface permission mask
        Which option shall I run?: 1
        ERROR: USBDEVFS_RESET failed! (1 - Operation not permitted)
        Which test shall I run next?: 2
        ERROR claiming if 0 (1 - Operation not permitted)
        ERROR claiming if 1 (1 - Operation not permitted)
        ERROR claiming if 2 (1 - Operation not permitted)
        ERROR claiming if 3 (1 - Operation not permitted)
        Which test shall I run next?: 0
    
    After unbinding usbhid:
    
        $ usb-devices
        ...
        I:  If#= 0 Alt= 0 #EPs= 1 Cls=03(HID  ) Sub=00 Prot=02 Driver=(none)
    
        $ sudo ./usbdevfs-drop-permissions /dev/bus/usb/001/002
        ...
        Which option shall I run?: 2
        OK: claimed if 0
        ERROR claiming if 1 (1 - Operation not permitted)
        ERROR claiming if 2 (1 - Operation not permitted)
        ERROR claiming if 3 (1 - Operation not permitted)
        Which test shall I run next?: 1
        OK: USBDEVFS_RESET succeeded
        Which test shall I run next?: 0
    
    After unbinding usbhid and restricting the mask:
    
        $ sudo ./usbdevfs-drop-permissions /dev/bus/usb/001/002
        ...
        Which option shall I run?: 3
        Insert new mask: 0
        OK: privileges dropped!
        Which test shall I run next?: 2
        ERROR claiming if 0 (1 - Operation not permitted)
        ERROR claiming if 1 (1 - Operation not permitted)
        ERROR claiming if 2 (1 - Operation not permitted)
        ERROR claiming if 3 (1 - Operation not permitted)
    
    Signed-off-by: Reilly Grant <reillyg@chromium.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Emilio LÃ³pez <emilio.lopez@collabora.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index ecbd17650e6c..a8653a6f40df 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -135,6 +135,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
 #define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10
 #define USBDEVFS_CAP_MMAP			0x20
+#define USBDEVFS_CAP_DROP_PRIVILEGES		0x40
 
 /* USBDEVFS_DISCONNECT_CLAIM flags & struct */
 
@@ -188,5 +189,6 @@ struct usbdevfs_streams {
 #define USBDEVFS_DISCONNECT_CLAIM  _IOR('U', 27, struct usbdevfs_disconnect_claim)
 #define USBDEVFS_ALLOC_STREAMS     _IOR('U', 28, struct usbdevfs_streams)
 #define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
+#define USBDEVFS_DROP_PRIVILEGES   _IOW('U', 30, __u32)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */

commit f7d34b445abc00e979b7cf36b9580ac3d1a47cd8
Author: Steinar H. Gunderson <sesse@google.com>
Date:   Wed Feb 3 22:58:26 2016 +0100

    USB: Add support for usbfs zerocopy.
    
    Add a new interface for userspace to preallocate memory that can be
    used with usbfs. This gives two primary benefits:
    
     - Zerocopy; data no longer needs to be copied between the userspace
       and the kernel, but can instead be read directly by the driver from
       userspace's buffers. This works for all kinds of transfers (even if
       nonsensical for control and interrupt transfers); isochronous also
       no longer need to memset() the buffer to zero to avoid leaking kernel data.
    
     - Once the buffers are allocated, USB transfers can no longer fail due to
       memory fragmentation; previously, long-running programs could run into
       problems finding a large enough contiguous memory chunk, especially on
       embedded systems or at high rates.
    
    Memory is allocated by using mmap() against the usbfs file descriptor,
    and similarly deallocated by munmap(). Once memory has been allocated,
    using it as pointers to a bulk or isochronous operation means you will
    automatically get zerocopy behavior. Note that this also means you cannot
    modify outgoing data until the transfer is complete. The same holds for
    data on the same cache lines as incoming data; DMA modifying them at the
    same time could lead to your changes being overwritten.
    
    There's a new capability USBDEVFS_CAP_MMAP that userspace can query to see
    if the running kernel supports this functionality, if just trying mmap() is
    not acceptable.
    
    Largely based on a patch by Markus Rechberger with some updates. The original
    patch can be found at:
    
      http://sundtek.de/support/devio_mmap_v0.4.diff
    
    Signed-off-by: Steinar H. Gunderson <sesse@google.com>
    Signed-off-by: Markus Rechberger <mrechberger@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 019ba1e0799a..ecbd17650e6c 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -134,6 +134,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
 #define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10
+#define USBDEVFS_CAP_MMAP			0x20
 
 /* USBDEVFS_DISCONNECT_CLAIM flags & struct */
 

commit 3f2cee73b650921b2e214bf487b2061a1c266504
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jan 29 11:29:13 2015 -0500

    USB: usbfs: allow URBs to be reaped after disconnection
    
    The usbfs API has a peculiar hole: Users are not allowed to reap their
    URBs after the device has been disconnected.  There doesn't seem to be
    any good reason for this; it is an ad-hoc inconsistency.
    
    The patch allows users to issue the USBDEVFS_REAPURB and
    USBDEVFS_REAPURBNDELAY ioctls (together with their 32-bit counterparts
    on 64-bit systems) even after the device is gone.  If no URBs are
    pending for a disconnected device then the ioctls will return -ENODEV
    rather than -EAGAIN, because obviously no new URBs will ever be able
    to complete.
    
    The patch also adds a new capability flag for
    USBDEVFS_GET_CAPABILITIES to indicate that the reap-after-disconnect
    feature is supported.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Chris Dickens <christopher.a.dickens@gmail.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index abe5f4bd4d82..019ba1e0799a 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -128,11 +128,12 @@ struct usbdevfs_hub_portinfo {
 	char port [127];	/* e.g. port 3 connects to device 27 */
 };
 
-/* Device capability flags */
+/* System and bus capability flags */
 #define USBDEVFS_CAP_ZERO_PACKET		0x01
 #define USBDEVFS_CAP_BULK_CONTINUATION		0x02
 #define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
 #define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
+#define USBDEVFS_CAP_REAP_AFTER_DISCONNECT	0x10
 
 /* USBDEVFS_DISCONNECT_CLAIM flags & struct */
 

commit bcf7f6e39335af4f03da8c26a98185fd49754fcc
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:19:31 2013 +0200

    usbfs: Add support for allocating / freeing streams
    
    This allows userspace to use bulk-streams, just like in kernel drivers, see
    Documentation/usb/bulk-streams.txt for details on the in kernel API. This
    is exported pretty much one on one to userspace.
    
    To use streams an app must first make a USBDEVFS_ALLOC_STREAMS ioctl,
    on success this will return the number of streams available (which may be
    less then requested). If there are n streams the app can then submit
    usbdevfs_urb-s with their stream_id member set to 1-n to use a specific
    stream. IE if USBDEVFS_ALLOC_STREAMS returns 4 then stream_id 1-4 can be
    used.
    
    When the app is done using streams it should call USBDEVFS_FREE_STREAMS
    
    Note applications are advised to use libusb rather then using the
    usbdevfs api directly. The latest version of libusb has support for streams.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index cbf122db56bc..abe5f4bd4d82 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -147,6 +147,11 @@ struct usbdevfs_disconnect_claim {
 	char driver[USBDEVFS_MAXDRIVERNAME + 1];
 };
 
+struct usbdevfs_streams {
+	unsigned int num_streams; /* Not used by USBDEVFS_FREE_STREAMS */
+	unsigned int num_eps;
+	unsigned char eps[0];
+};
 
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
 #define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
@@ -179,5 +184,7 @@ struct usbdevfs_disconnect_claim {
 #define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
 #define USBDEVFS_GET_CAPABILITIES  _IOR('U', 26, __u32)
 #define USBDEVFS_DISCONNECT_CLAIM  _IOR('U', 27, struct usbdevfs_disconnect_claim)
+#define USBDEVFS_ALLOC_STREAMS     _IOR('U', 28, struct usbdevfs_streams)
+#define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */

commit 948cd8c18c466fdcbe707bb2a42a148796bfccdd
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:19:29 2013 +0200

    usbfs: Add support for bulk stream ids
    
    This patch makes it possible to specify a bulk stream id when submitting
    an urb using the async usbfs API. It overloads the number_of_packets
    usbdevfs_urb field for this. This is not pretty, but given other
    constraints it is the best we can do. The reasoning leading to this goes
    as follows:
    
    1) We want to support bulk streams in the usbfs API
    2) We do not want to extend the usbdevfs_urb struct with a new member, as
       that would mean defining new ioctl numbers for all async API ioctls +
       adding compat versions for the old ones (times 2 for 32 bit support)
    3) 1 + 2 means we need to re-use an existing field
    4) number_of_packets is only used for isoc urbs, and streams are bulk only
       so it is the best (and only) candidate for re-using
    
    Note that:
    1) This patch only uses number_of_packets as stream_id if the app has
       actually allocated streams on the ep, so that old apps which may have
       garbage in there (as it was unused until now in the bulk case), will not
       break
    2) This patch does not add support for allocating / freeing bulk-streams, that
       is done in a follow up patch
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 0c65e4b12617..cbf122db56bc 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -102,7 +102,10 @@ struct usbdevfs_urb {
 	int buffer_length;
 	int actual_length;
 	int start_frame;
-	int number_of_packets;
+	union {
+		int number_of_packets;	/* Only used for isoc urbs */
+		unsigned int stream_id;	/* Only used with bulk streams */
+	};
 	int error_count;
 	unsigned int signr;	/* signal to be sent on completion,
 				  or 0 if none should be sent. */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
new file mode 100644
index 000000000000..0c65e4b12617
--- /dev/null
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -0,0 +1,180 @@
+/*****************************************************************************/
+
+/*
+ *	usbdevice_fs.h  --  USB device file system.
+ *
+ *	Copyright (C) 2000
+ *          Thomas Sailer (sailer@ife.ee.ethz.ch)
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  History:
+ *   0.1  04.01.2000  Created
+ */
+
+/*****************************************************************************/
+
+#ifndef _UAPI_LINUX_USBDEVICE_FS_H
+#define _UAPI_LINUX_USBDEVICE_FS_H
+
+#include <linux/types.h>
+#include <linux/magic.h>
+
+/* --------------------------------------------------------------------- */
+
+/* usbdevfs ioctl codes */
+
+struct usbdevfs_ctrltransfer {
+	__u8 bRequestType;
+	__u8 bRequest;
+	__u16 wValue;
+	__u16 wIndex;
+	__u16 wLength;
+	__u32 timeout;  /* in milliseconds */
+ 	void __user *data;
+};
+
+struct usbdevfs_bulktransfer {
+	unsigned int ep;
+	unsigned int len;
+	unsigned int timeout; /* in milliseconds */
+	void __user *data;
+};
+
+struct usbdevfs_setinterface {
+	unsigned int interface;
+	unsigned int altsetting;
+};
+
+struct usbdevfs_disconnectsignal {
+	unsigned int signr;
+	void __user *context;
+};
+
+#define USBDEVFS_MAXDRIVERNAME 255
+
+struct usbdevfs_getdriver {
+	unsigned int interface;
+	char driver[USBDEVFS_MAXDRIVERNAME + 1];
+};
+
+struct usbdevfs_connectinfo {
+	unsigned int devnum;
+	unsigned char slow;
+};
+
+#define USBDEVFS_URB_SHORT_NOT_OK	0x01
+#define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_BULK_CONTINUATION	0x04
+#define USBDEVFS_URB_NO_FSBR		0x20
+#define USBDEVFS_URB_ZERO_PACKET	0x40
+#define USBDEVFS_URB_NO_INTERRUPT	0x80
+
+#define USBDEVFS_URB_TYPE_ISO		   0
+#define USBDEVFS_URB_TYPE_INTERRUPT	   1
+#define USBDEVFS_URB_TYPE_CONTROL	   2
+#define USBDEVFS_URB_TYPE_BULK		   3
+
+struct usbdevfs_iso_packet_desc {
+	unsigned int length;
+	unsigned int actual_length;
+	unsigned int status;
+};
+
+struct usbdevfs_urb {
+	unsigned char type;
+	unsigned char endpoint;
+	int status;
+	unsigned int flags;
+	void __user *buffer;
+	int buffer_length;
+	int actual_length;
+	int start_frame;
+	int number_of_packets;
+	int error_count;
+	unsigned int signr;	/* signal to be sent on completion,
+				  or 0 if none should be sent. */
+	void __user *usercontext;
+	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
+};
+
+/* ioctls for talking directly to drivers */
+struct usbdevfs_ioctl {
+	int	ifno;		/* interface 0..N ; negative numbers reserved */
+	int	ioctl_code;	/* MUST encode size + direction of data so the
+				 * macros in <asm/ioctl.h> give correct values */
+	void __user *data;	/* param buffer (in, or out) */
+};
+
+/* You can do most things with hubs just through control messages,
+ * except find out what device connects to what port. */
+struct usbdevfs_hub_portinfo {
+	char nports;		/* number of downstream ports in this hub */
+	char port [127];	/* e.g. port 3 connects to device 27 */
+};
+
+/* Device capability flags */
+#define USBDEVFS_CAP_ZERO_PACKET		0x01
+#define USBDEVFS_CAP_BULK_CONTINUATION		0x02
+#define USBDEVFS_CAP_NO_PACKET_SIZE_LIM		0x04
+#define USBDEVFS_CAP_BULK_SCATTER_GATHER	0x08
+
+/* USBDEVFS_DISCONNECT_CLAIM flags & struct */
+
+/* disconnect-and-claim if the driver matches the driver field */
+#define USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER	0x01
+/* disconnect-and-claim except when the driver matches the driver field */
+#define USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER	0x02
+
+struct usbdevfs_disconnect_claim {
+	unsigned int interface;
+	unsigned int flags;
+	char driver[USBDEVFS_MAXDRIVERNAME + 1];
+};
+
+
+#define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
+#define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
+#define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
+#define USBDEVFS_BULK32              _IOWR('U', 2, struct usbdevfs_bulktransfer32)
+#define USBDEVFS_RESETEP           _IOR('U', 3, unsigned int)
+#define USBDEVFS_SETINTERFACE      _IOR('U', 4, struct usbdevfs_setinterface)
+#define USBDEVFS_SETCONFIGURATION  _IOR('U', 5, unsigned int)
+#define USBDEVFS_GETDRIVER         _IOW('U', 8, struct usbdevfs_getdriver)
+#define USBDEVFS_SUBMITURB         _IOR('U', 10, struct usbdevfs_urb)
+#define USBDEVFS_SUBMITURB32       _IOR('U', 10, struct usbdevfs_urb32)
+#define USBDEVFS_DISCARDURB        _IO('U', 11)
+#define USBDEVFS_REAPURB           _IOW('U', 12, void *)
+#define USBDEVFS_REAPURB32         _IOW('U', 12, __u32)
+#define USBDEVFS_REAPURBNDELAY     _IOW('U', 13, void *)
+#define USBDEVFS_REAPURBNDELAY32   _IOW('U', 13, __u32)
+#define USBDEVFS_DISCSIGNAL        _IOR('U', 14, struct usbdevfs_disconnectsignal)
+#define USBDEVFS_DISCSIGNAL32      _IOR('U', 14, struct usbdevfs_disconnectsignal32)
+#define USBDEVFS_CLAIMINTERFACE    _IOR('U', 15, unsigned int)
+#define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)
+#define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)
+#define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)
+#define USBDEVFS_IOCTL32           _IOWR('U', 18, struct usbdevfs_ioctl32)
+#define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)
+#define USBDEVFS_RESET             _IO('U', 20)
+#define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
+#define USBDEVFS_DISCONNECT        _IO('U', 22)
+#define USBDEVFS_CONNECT           _IO('U', 23)
+#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
+#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
+#define USBDEVFS_GET_CAPABILITIES  _IOR('U', 26, __u32)
+#define USBDEVFS_DISCONNECT_CLAIM  _IOR('U', 27, struct usbdevfs_disconnect_claim)
+
+#endif /* _UAPI_LINUX_USBDEVICE_FS_H */
