commit ab7876a98a2160092133de4c648e94b18bc3f139
Author: Dave Martin <Dave.Martin@arm.com>
Date:   Mon Mar 16 16:50:47 2020 +0000

    arm64: elf: Enable BTI at exec based on ELF program properties
    
    For BTI protection to be as comprehensive as possible, it is
    desirable to have BTI enabled from process startup.  If this is not
    done, the process must use mprotect() to enable BTI for each of its
    executable mappings, but this is painful to do in the libc startup
    code.  It's simpler and more sound to have the kernel do it
    instead.
    
    To this end, detect BTI support in the executable (or ELF
    interpreter, as appropriate), via the
    NT_GNU_PROGRAM_PROPERTY_TYPE_0 note, and tweak the initial prot
    flags for the process' executable pages to include PROT_BTI as
    appropriate.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Dave Martin <Dave.Martin@arm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 20900f4496b7..c6dd0215482e 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -448,4 +448,10 @@ typedef struct elf64_note {
   Elf64_Word n_type;	/* Content type */
 } Elf64_Nhdr;
 
+/* .note.gnu.property types for EM_AARCH64: */
+#define GNU_PROPERTY_AARCH64_FEATURE_1_AND	0xc0000000
+
+/* Bits for GNU_PROPERTY_AARCH64_FEATURE_1_BTI */
+#define GNU_PROPERTY_AARCH64_FEATURE_1_BTI	(1U << 0)
+
 #endif /* _UAPI_LINUX_ELF_H */

commit 00e19ceec80b03a43f626f891fcc53e57919f1b3
Author: Dave Martin <Dave.Martin@arm.com>
Date:   Mon Mar 16 16:50:44 2020 +0000

    ELF: Add ELF program property parsing support
    
    ELF program properties will be needed for detecting whether to
    enable optional architecture or ABI features for a new ELF process.
    
    For now, there are no generic properties that we care about, so do
    nothing unless CONFIG_ARCH_USE_GNU_PROPERTY=y.
    
    Otherwise, the presence of properties using the PT_PROGRAM_PROPERTY
    phdrs entry (if any), and notify each property to the arch code.
    
    For now, the added code is not used.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Dave Martin <Dave.Martin@arm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index c37731407074..20900f4496b7 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -368,6 +368,7 @@ typedef struct elf64_shdr {
  * Notes used in ET_CORE. Architectures export some of the arch register sets
  * using the corresponding note types via the PTRACE_GETREGSET and
  * PTRACE_SETREGSET requests.
+ * The note name for all these is "LINUX".
  */
 #define NT_PRSTATUS	1
 #define NT_PRFPREG	2
@@ -430,6 +431,9 @@ typedef struct elf64_shdr {
 #define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
 #define NT_MIPS_MSA	0x802		/* MIPS SIMD registers */
 
+/* Note types with note name "GNU" */
+#define NT_GNU_PROPERTY_TYPE_0	5
+
 /* Note header in a PT_NOTE section */
 typedef struct elf32_note {
   Elf32_Word	n_namesz;	/* Name size */

commit db751e309ff05461a0c8e114b1238d7a69cc1f18
Author: Dave Martin <Dave.Martin@arm.com>
Date:   Mon Mar 16 16:50:43 2020 +0000

    ELF: UAPI and Kconfig additions for ELF program properties
    
    Pull the basic ELF definitions relating to the
    NT_GNU_PROPERTY_TYPE_0 note from Yu-Cheng Yu's earlier x86 shstk
    series.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Dave Martin <Dave.Martin@arm.com>
    Signed-off-by: Yu-cheng Yu <yu-cheng.yu@intel.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 34c02e4290fe..c37731407074 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -36,6 +36,7 @@ typedef __s64	Elf64_Sxword;
 #define PT_LOPROC  0x70000000
 #define PT_HIPROC  0x7fffffff
 #define PT_GNU_EH_FRAME		0x6474e550
+#define PT_GNU_PROPERTY		0x6474e553
 
 #define PT_GNU_STACK	(PT_LOOS + 0x474e551)
 

commit d0a060be573bfbf8753a15dca35497db5e968bb0
Author: Kristina Martsenko <kristina.martsenko@arm.com>
Date:   Wed Jan 30 12:02:44 2019 +0000

    arm64: add ptrace regsets for ptrauth key management
    
    Add two new ptrace regsets, which can be used to request and change the
    pointer authentication keys of a thread. NT_ARM_PACA_KEYS gives access
    to the instruction/data address keys, and NT_ARM_PACG_KEYS to the
    generic authentication key. The keys are also part of the core dump file
    of the process.
    
    The regsets are only exposed if the kernel is compiled with
    CONFIG_CHECKPOINT_RESTORE=y, as the only intended use case is
    checkpointing and restoring processes that are using pointer
    authentication. (This can be changed later if there are other use
    cases.)
    
    Reviewed-by: Dave Martin <Dave.Martin@arm.com>
    Signed-off-by: Kristina Martsenko <kristina.martsenko@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index e4d6ddd93567..34c02e4290fe 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -421,6 +421,8 @@ typedef struct elf64_shdr {
 #define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
 #define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
 #define NT_ARM_PAC_MASK		0x406	/* ARM pointer authentication code masks */
+#define NT_ARM_PACA_KEYS	0x407	/* ARM pointer authentication address keys */
+#define NT_ARM_PACG_KEYS	0x408	/* ARM pointer authentication generic key */
 #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
 #define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */

commit 89261c57021352045c4af24522c6854c9ee90139
Merge: c2f1f3e0e17d adcc81f148d7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 26 10:45:33 2018 -0800

    Merge tag 'mips_4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
    
    Pull MIPS updates from Paul Burton:
     "Here's the main MIPS pull for Linux 4.21. Core architecture changes
      include:
    
       - Syscall tables & definitions for unistd.h are now generated by
         scripts, providing greater consistency with other architectures &
         making it easier to add new syscalls.
    
       - Support for building kernels with no floating point support, upon
         which any userland attempting to use floating point instructions
         will receive a SIGILL. Mostly useful to shrink the kernel & as
         preparation for nanoMIPS support which does not yet include FP.
    
       - MIPS SIMD Architecture (MSA) vector register context is now exposed
         by ptrace via a new NT_MIPS_MSA regset.
    
       - ASIDs are now stored as 64b values even for MIPS32 kernels,
         expanding the ASID version field sufficiently that we don't need to
         worry about overflow & avoiding rare issues with reused ASIDs that
         have been observed in the wild.
    
       - The branch delay slot "emulation" page is now mapped without write
         permission for the user, preventing its use as a nice location for
         attacks to execute malicious code from.
    
       - Support for ioremap_prot(), primarily to allow gdb or other ptrace
         users the ability to view their tracee's memory using the same
         cache coherency attribute.
    
       - Optimizations to more cpu_has_* macros, allowing more to be
         compile-time constant where possible.
    
       - Enable building the whole kernel with UBSAN instrumentation.
    
       - Enable building the kernel with link-time dead code & data
         elimination.
    
      Platform specific changes include:
    
       - The Boston board gains a workaround for DMA prefetching issues with
         the EG20T Platform Controller Hub that it uses.
    
       - Cleanups to Cavium Octeon code removing about 20k lines of
         redundant code, mostly unused or duplicate register definitions in
         headers.
    
       - defconfig updates for the DECstation machines, including new
         defconfigs for r4k & 64b machines.
    
       - Further work on Loongson 3 support.
    
       - DMA fixes for SiByte machines"
    
    * tag 'mips_4.21' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux: (95 commits)
      MIPS: math-emu: Write-protect delay slot emulation pages
      MIPS: Remove struct mm_context_t fp_mode_switching field
      mips: generate uapi header and system call table files
      mips: add system call table generation support
      mips: remove syscall table entries
      mips: add +1 to __NR_syscalls in uapi header
      mips: rename scall64-64.S to scall64-n64.S
      mips: remove unused macros
      mips: add __NR_syscalls along with __NR_Linux_syscalls
      MIPS: Expand MIPS32 ASIDs to 64 bits
      MIPS: OCTEON: delete redundant register definitions
      MIPS: OCTEON: cvmx_gmxx_inf_mode: use oldest forward compatible definition
      MIPS: OCTEON: cvmx_mio_fus_dat3: use oldest forward compatible definition
      MIPS: OCTEON: cvmx_pko_mem_debug8: use oldest forward compatible definition
      MIPS: OCTEON: octeon-usb: use common gpio_bit definition
      MIPS: OCTEON: enable all OCTEON drivers in defconfig
      mips: annotate implicit fall throughs
      MIPS: Hardcode cpu_has_mips* where target ISA allows
      MIPS: MT: Remove norps command line parameter
      MIPS: Only include mmzone.h when CONFIG_NEED_MULTIPLE_NODES=y
      ...

commit ec6e822d1a22d0eef1d1fa260dff751dba9a4258
Author: Mark Rutland <mark.rutland@arm.com>
Date:   Fri Dec 7 18:39:26 2018 +0000

    arm64: expose user PAC bit positions via ptrace
    
    When pointer authentication is in use, data/instruction pointers have a
    number of PAC bits inserted into them. The number and position of these
    bits depends on the configured TCR_ELx.TxSZ and whether tagging is
    enabled. ARMv8.3 allows tagging to differ for instruction and data
    pointers.
    
    For userspace debuggers to unwind the stack and/or to follow pointer
    chains, they need to be able to remove the PAC bits before attempting to
    use a pointer.
    
    This patch adds a new structure with masks describing the location of
    the PAC bits in userspace instruction and data pointers (i.e. those
    addressable via TTBR0), which userspace can query via PTRACE_GETREGSET.
    By clearing these bits from pointers (and replacing them with the value
    of bit 55), userspace can acquire the PAC-less versions.
    
    This new regset is exposed when the kernel is built with (user) pointer
    authentication support, and the address authentication feature is
    enabled. Otherwise, the regset is hidden.
    
    Reviewed-by: Richard Henderson <richard.henderson@linaro.org>
    Signed-off-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Kristina Martsenko <kristina.martsenko@arm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Ramana Radhakrishnan <ramana.radhakrishnan@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    [will: Fix to use vabits_user instead of VA_BITS and rename macro]
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index c5358e0ae7c5..3f23273d690c 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -420,6 +420,7 @@ typedef struct elf64_shdr {
 #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
 #define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
 #define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
+#define NT_ARM_PAC_MASK		0x406	/* ARM pointer authentication code masks */
 #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
 #define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */

commit 3cd640832894b85b5929d5bda74505452c800421
Author: Paul Burton <paul.burton@mips.com>
Date:   Tue Nov 20 20:41:05 2018 +0000

    MIPS: ptrace: introduce NT_MIPS_MSA regset
    
    The current methods for obtaining FP context via ptrace only provide
    either 32 or 64 bits per data register. With MSA, where vector registers
    are aliased with scalar FP data registers, those registers are 128 bits
    wide. Thus a new mechanism is required for userland to access those
    registers via ptrace. This patch introduces an NT_MIPS_MSA regset which
    provides, in this order:
    
      - The full 128 bits value of each vector register, in native
        endianness saved as though elements are doubles. That is, the format
        of each vector register is as would be obtained by saving it to
        memory using an st.d instruction.
    
      - The 32 bit scalar FP implementation register (FIR).
    
      - The 32 bit scalar FP control & status register (FCSR).
    
      - The 32 bit MSA implementation register (MSAIR).
    
      - The 32 bit MSA control & status register (MSACSR).
    
    The provision of the FIR & FCSR registers in addition to the MSA
    equivalents allows scalar FP context to be retrieved as a subset of
    the context available via this regset. Along with the MSA equivalents
    they also nicely form the final 128 bit "register" of the regset.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21180/
    Cc: linux-mips@linux-mips.org

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index c5358e0ae7c5..d1b093f931e3 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -424,6 +424,7 @@ typedef struct elf64_shdr {
 #define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */
 #define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
+#define NT_MIPS_MSA	0x802		/* MIPS SIMD registers */
 
 /* Note header in a PT_NOTE section */
 typedef struct elf32_note {

commit 1ae22a0e35636efceab83728ba30b013df761592
Author: Maciej W. Rozycki <macro@mips.com>
Date:   Tue May 15 23:40:18 2018 +0100

    MIPS: Add FP_MODE regset support
    
    Define an NT_MIPS_FP_MODE core file note and implement a corresponding
    regset holding the state handled by PR_SET_FP_MODE and PR_GET_FP_MODE
    prctl(2) requests.  This lets debug software correctly interpret the
    contents of floating-point general registers both in live debugging and
    in core files, and also switch floating-point modes of a live process.
    
    [paul.burton@mips.com:
      - Changed NT_MIPS_FP_MODE to 0x801 to match first nibble of
        NT_MIPS_DSP, which was also changed to avoid a conflict.]
    
    Signed-off-by: Maciej W. Rozycki <macro@mips.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/19331/
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index e326c99b3881..c5358e0ae7c5 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -423,6 +423,7 @@ typedef struct elf64_shdr {
 #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
 #define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */
+#define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
 
 /* Note header in a PT_NOTE section */
 typedef struct elf32_note {

commit 44109c60176ae73924a42a6bef64ef151aba9095
Author: Maciej W. Rozycki <macro@mips.com>
Date:   Tue May 15 23:34:28 2018 +0100

    MIPS: Add DSP ASE regset support
    
    Define an NT_MIPS_DSP core file note type and implement a corresponding
    regset holding the DSP ASE register context, following the layout of the
    `mips_dsp_state' structure, except for the DSPControl register stored as
    a 64-bit rather than 32-bit quantity in a 64-bit note.
    
    The lack of DSP ASE register saving to core files can be considered a
    design flaw with commit e50c0a8fa60d ("Support the MIPS32 / MIPS64 DSP
    ASE."), leading to an incomplete state being saved.  Consequently no DSP
    ASE regset has been created with commit 7aeb753b5353 ("MIPS: Implement
    task_user_regset_view."), when regset support was added to the MIPS
    port.
    
    Additionally there is no way for ptrace(2) to correctly access the DSP
    accumulator registers in n32 processes with the existing interfaces.
    This is due to 32-bit truncation of data passed with PTRACE_PEEKUSR and
    PTRACE_POKEUSR requests, which cannot be avoided owing to how the data
    types for ptrace(3) have been defined.  This new NT_MIPS_DSP regset
    fills the missing interface gap.
    
    [paul.burton@mips.com:
      - Change NT_MIPS_DSP to 0x800 to avoid conflict with NT_VMCOREDD
        introduced by commit 2724273e8fd0 ("vmcore: add API to collect
        hardware dump in second kernel").
      - Drop stable tag. Whilst I agree the lack of this functionality can
        be considered a flaw in earlier DSP ASE support, it's still new
        functionality which doesn't meet up to the requirements set out in
        Documentation/process/stable-kernel-rules.rst.]
    
    Signed-off-by: Maciej W. Rozycki <macro@mips.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    References: 7aeb753b5353 ("MIPS: Implement task_user_regset_view.")
    Patchwork: https://patchwork.linux-mips.org/patch/19330/
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 4e12c423b9fe..e326c99b3881 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -422,6 +422,7 @@ typedef struct elf64_shdr {
 #define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
 #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
 #define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
+#define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */
 
 /* Note header in a PT_NOTE section */
 typedef struct elf32_note {

commit 2724273e8fd00b512596a77ee063f49b25f36507
Author: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
Date:   Wed May 2 15:17:17 2018 +0530

    vmcore: add API to collect hardware dump in second kernel
    
    The sequence of actions done by device drivers to append their device
    specific hardware/firmware logs to /proc/vmcore are as follows:
    
    1. During probe (before hardware is initialized), device drivers
    register to the vmcore module (via vmcore_add_device_dump()), with
    callback function, along with buffer size and log name needed for
    firmware/hardware log collection.
    
    2. vmcore module allocates the buffer with requested size. It adds
    an Elf note and invokes the device driver's registered callback
    function.
    
    3. Device driver collects all hardware/firmware logs into the buffer
    and returns control back to vmcore module.
    
    Ensure that the device dump buffer size is always aligned to page size
    so that it can be mmaped.
    
    Also, rename alloc_elfnotes_buf() to vmcore_alloc_buf() to make it more
    generic and reserve NT_VMCOREDD note type to indicate vmcore device
    dump.
    
    Suggested-by: Eric Biederman <ebiederm@xmission.com>.
    Signed-off-by: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
    Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index e2535d6dcec7..4e12c423b9fe 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -421,6 +421,7 @@ typedef struct elf64_shdr {
 #define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
 #define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
 #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
+#define NT_VMCOREDD	0x700		/* Vmcore Device Dump Note */
 
 /* Note header in a PT_NOTE section */
 typedef struct elf32_note {

commit 5f171577b4f35b44795a73bde8cf2c49b4073925
Author: James Hogan <jhogan@kernel.org>
Date:   Tue Oct 24 16:52:32 2017 +0100

    Drop a bunch of metag references
    
    Now that arch/metag/ has been removed, drop a bunch of metag references
    in various codes across the whole tree:
     - VM_GROWSUP and __VM_ARCH_SPECIFIC_1.
     - MT_METAG_* ELF note types.
     - METAG Kconfig dependencies (FRAME_POINTER) and ranges
       (MAX_STACK_SIZE_MB).
     - metag cases in tools (checkstack.pl, recordmcount.c, perf).
    
    Signed-off-by: James Hogan <jhogan@kernel.org>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Jiri Olsa <jolsa@redhat.com>
    Cc: Namhyung Kim <namhyung@kernel.org>
    Cc: linux-mm@kvack.org
    Cc: linux-metag@vger.kernel.org

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 3bf73fb58045..e2535d6dcec7 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -420,9 +420,6 @@ typedef struct elf64_shdr {
 #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
 #define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
 #define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
-#define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
-#define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
-#define NT_METAG_TLS	0x502		/* Metag TLS pointer */
 #define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
 
 /* Note header in a PT_NOTE section */

commit c5cc1f4df6b16646f8fae7aab523c1820bf916e8
Author: Thiago Jung Bauermann <bauerman@linux.vnet.ibm.com>
Date:   Thu Jan 18 17:50:43 2018 -0800

    powerpc/ptrace: Add memory protection key regset
    
    The AMR/IAMR/UAMOR are part of the program context.
    Allow it to be accessed via ptrace and through core files.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index bb6836986200..3bf73fb58045 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -396,6 +396,7 @@ typedef struct elf64_shdr {
 #define NT_PPC_TM_CTAR	0x10d		/* TM checkpointed Target Address Register */
 #define NT_PPC_TM_CPPR	0x10e		/* TM checkpointed Program Priority Register */
 #define NT_PPC_TM_CDSCR	0x10f		/* TM checkpointed Data Stream Control Register */
+#define NT_PPC_PKEY	0x110		/* Memory Protection Keys registers */
 #define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
 #define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
 #define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */

commit c9b012e5f4a1d01dfa8abc6318211a67ba7d5db2
Merge: b293fca43be5 6cfa7cc46b1a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 10:56:56 2017 -0800

    Merge tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux
    
    Pull arm64 updates from Will Deacon:
     "The big highlight is support for the Scalable Vector Extension (SVE)
      which required extensive ABI work to ensure we don't break existing
      applications by blowing away their signal stack with the rather large
      new vector context (<= 2 kbit per vector register). There's further
      work to be done optimising things like exception return, but the ABI
      is solid now.
    
      Much of the line count comes from some new PMU drivers we have, but
      they're pretty self-contained and I suspect we'll have more of them in
      future.
    
      Plenty of acronym soup here:
    
       - initial support for the Scalable Vector Extension (SVE)
    
       - improved handling for SError interrupts (required to handle RAS
         events)
    
       - enable GCC support for 128-bit integer types
    
       - remove kernel text addresses from backtraces and register dumps
    
       - use of WFE to implement long delay()s
    
       - ACPI IORT updates from Lorenzo Pieralisi
    
       - perf PMU driver for the Statistical Profiling Extension (SPE)
    
       - perf PMU driver for Hisilicon's system PMUs
    
       - misc cleanups and non-critical fixes"
    
    * tag 'arm64-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/arm64/linux: (97 commits)
      arm64: Make ARMV8_DEPRECATED depend on SYSCTL
      arm64: Implement __lshrti3 library function
      arm64: support __int128 on gcc 5+
      arm64/sve: Add documentation
      arm64/sve: Detect SVE and activate runtime support
      arm64/sve: KVM: Hide SVE from CPU features exposed to guests
      arm64/sve: KVM: Treat guest SVE use as undefined instruction execution
      arm64/sve: KVM: Prevent guests from using SVE
      arm64/sve: Add sysctl to set the default vector length for new processes
      arm64/sve: Add prctl controls for userspace vector length management
      arm64/sve: ptrace and ELF coredump support
      arm64/sve: Preserve SVE registers around EFI runtime service calls
      arm64/sve: Preserve SVE registers around kernel-mode NEON use
      arm64/sve: Probe SVE capabilities and usable vector lengths
      arm64: cpufeature: Move sys_caps_initialised declarations
      arm64/sve: Backend logic for setting the vector length
      arm64/sve: Signal handling support
      arm64/sve: Support vector length resetting for new processes
      arm64/sve: Core task context handling
      arm64/sve: Low-level CPU setup
      ...

commit d60a540ac5f2fbab3e6fe592717b445bd7343a91
Merge: 2101dd64b304 364a5607d698
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 11:47:01 2017 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux
    
    Pull s390 updates from Heiko Carstens:
     "Since Martin is on vacation you get the s390 pull request for the
      v4.15 merge window this time from me.
    
      Besides a lot of cleanups and bug fixes these are the most important
      changes:
    
       - a new regset for runtime instrumentation registers
    
       - hardware accelerated AES-GCM support for the aes_s390 module
    
       - support for the new CEX6S crypto cards
    
       - support for FORTIFY_SOURCE
    
       - addition of missing z13 and new z14 instructions to the in-kernel
         disassembler
    
       - generate opcode tables for the in-kernel disassembler out of a
         simple text file instead of having to manually maintain those
         tables
    
       - fast memset16, memset32 and memset64 implementations
    
       - removal of named saved segment support
    
       - hardware counter support for z14
    
       - queued spinlocks and queued rwlocks implementations for s390
    
       - use the stack_depth tracking feature for s390 BPF JIT
    
       - a new s390_sthyi system call which emulates the sthyi (store
         hypervisor information) instruction
    
       - removal of the old KVM virtio transport
    
       - an s390 specific CPU alternatives implementation which is used in
         the new spinlock code"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/s390/linux: (88 commits)
      MAINTAINERS: add virtio-ccw.h to virtio/s390 section
      s390/noexec: execute kexec datamover without DAT
      s390: fix transactional execution control register handling
      s390/bpf: take advantage of stack_depth tracking
      s390: simplify transactional execution elf hwcap handling
      s390/zcrypt: Rework struct ap_qact_ap_info.
      s390/virtio: remove unused header file kvm_virtio.h
      s390: avoid undefined behaviour
      s390/disassembler: generate opcode tables from text file
      s390/disassembler: remove insn_to_mnemonic()
      s390/dasd: avoid calling do_gettimeofday()
      s390: vfio-ccw: Do not attempt to free no-op, test and tic cda.
      s390: remove named saved segment support
      s390/archrandom: Reconsider s390 arch random implementation
      s390/pci: do not require AIS facility
      s390/qdio: sanitize put_indicator
      s390/qdio: use atomic_cmpxchg
      s390/nmi: avoid using long-displacement facility
      s390: pass endianness info to sparse
      s390/decompressor: remove informational messages
      ...

commit 43d4da2c45b2f5d62f8a79ff7c6f95089bb24656
Author: Dave Martin <Dave.Martin@arm.com>
Date:   Tue Oct 31 15:51:13 2017 +0000

    arm64/sve: ptrace and ELF coredump support
    
    This patch defines and implements a new regset NT_ARM_SVE, which
    describes a thread's SVE register state.  This allows a debugger to
    manipulate the SVE state, as well as being included in ELF
    coredumps for post-mortem debugging.
    
    Because the regset size and layout are dependent on the thread's
    current vector length, it is not possible to define a C struct to
    describe the regset contents as is done for existing regsets.
    Instead, and for the same reasons, NT_ARM_SVE is based on the
    freeform variable-layout approach used for the SVE signal frame.
    
    Additionally, to reduce debug overhead when debugging threads that
    might or might not have live SVE register state, NT_ARM_SVE may be
    presented in one of two different formats: the old struct
    user_fpsimd_state format is embedded for describing the state of a
    thread with no live SVE state, whereas a new variable-layout
    structure is embedded for describing live SVE state.  This avoids a
    debugger needing to poll NT_PRFPREG in addition to NT_ARM_SVE, and
    allows existing userspace code to handle the non-SVE case without
    too much modification.
    
    For this to work, NT_ARM_SVE is defined with a fixed-format header
    of type struct user_sve_header, which the recipient can use to
    figure out the content, size and layout of the reset of the regset.
    Accessor macros are defined to allow the vector-length-dependent
    parts of the regset to be manipulated.
    
    Signed-off-by: Alan Hayward <alan.hayward@arm.com>
    Signed-off-by: Dave Martin <Dave.Martin@arm.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Alex Bennée <alex.bennee@linaro.org>
    Cc: Okamoto Takayuki <tokamoto@jp.fujitsu.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index b5280db9ef6a..735b8f4d12fc 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -416,6 +416,7 @@ typedef struct elf64_shdr {
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
 #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
 #define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
+#define NT_ARM_SVE	0x405		/* ARM Scalable Vector Extension registers */
 #define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
 #define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
 #define NT_METAG_TLS	0x502		/* Metag TLS pointer */

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index b5280db9ef6a..c58627c0d6fb 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI_LINUX_ELF_H
 #define _UAPI_LINUX_ELF_H
 

commit 262832bc5acda76fd8f901d39f4da1121d951222
Author: Alice Frosi <alice@linux.vnet.ibm.com>
Date:   Thu Sep 14 12:36:03 2017 +0200

    s390/ptrace: add runtime instrumention register get/set
    
    Add runtime instrumention register get and set which allows to read
    and modify the runtime instrumention control block.
    
    Signed-off-by: Alice Frosi <alice@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index b5280db9ef6a..e3739c330c15 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -411,6 +411,7 @@ typedef struct elf64_shdr {
 #define NT_S390_VXRS_HIGH	0x30a	/* s390 vector registers 16-31 */
 #define NT_S390_GS_CB	0x30b		/* s390 guarded storage registers */
 #define NT_S390_GS_BC	0x30c		/* s390 guarded storage broadcast control block */
+#define NT_S390_RI_CB	0x30d		/* s390 runtime instrumentation */
 #define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */

commit 4a1e31c68e9f40be32838944931178b0d9ed9162
Merge: c6778ff813d2 cf4100d1cddc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 10:10:15 2017 -0700

    Merge tag 'arc-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc
    
    Pull ARC updates from Vineet Gupta:
    
     - AXS10x platform clk updates for I2S, PGU
    
     - add region based cache flush operation for ARCv2 cores
    
     - enforce PAE40 dependency on HIGHMEM
    
     - ptrace support for additional regs in ARCv2 cores
    
     - fix build failure in linux-next dut to a header include ordering
       change
    
    * tag 'arc-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc:
      Revert "ARCv2: Allow enabling PAE40 w/o HIGHMEM"
      ARC: mm: fix build failure in linux-next for UP builds
      ARCv2: ptrace: provide regset for accumulator/r30 regs
      elf: Add ARCv2 specific core note section
      ARCv2: mm: micro-optimize region flush generated code
      ARCv2: mm: Merge 2 updates to DC_CTRL for region flush
      ARCv2: mm: Implement cache region flush operations
      ARC: mm: Move full_page computation into cache version agnostic wrapper
      arc: axs10x: Fix ARC PGU default clock frequency
      arc: axs10x: Add DT bindings for I2S audio playback

commit 991c7ed6acca506983c42d51965da8b8f3677682
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed May 3 11:20:15 2017 -0700

    elf: Add ARCv2 specific core note section
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index b59ee077a596..b5c00563ed9b 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -417,7 +417,7 @@ typedef struct elf64_shdr {
 #define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
 #define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
 #define NT_METAG_TLS	0x502		/* Metag TLS pointer */
-
+#define NT_ARC_V2	0x600		/* ARCv2 accumulator/extra registers */
 
 /* Note header in a PT_NOTE section */
 typedef struct elf32_note {

commit e525f8a6e696210d15f8b8277d4da12fc4add299
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Thu Apr 20 13:54:11 2017 +0200

    s390/gs: add regset for the guarded storage broadcast control block
    
    The guarded storage interface allows to register a control block for
    each thread that is activated with the guarded storage broadcast event.
    To retrieve the complete state of a process from the kernel a register
    set for the stored broadcast control block is required.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 8c6d3bdb9a00..176b6cb1008d 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -410,6 +410,7 @@ typedef struct elf64_shdr {
 #define NT_S390_VXRS_LOW	0x309	/* s390 vector registers 0-15 upper half */
 #define NT_S390_VXRS_HIGH	0x30a	/* s390 vector registers 16-31 */
 #define NT_S390_GS_CB	0x30b		/* s390 guarded storage registers */
+#define NT_S390_GS_BC	0x30c		/* s390 guarded storage broadcast control block */
 #define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */

commit 916cda1aa1b412d7cf2991c3af7479544942d121
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Jan 26 14:10:34 2016 +0100

    s390: add a system call for guarded storage
    
    This adds a new system call to enable the use of guarded storage for
    user space processes. The system call takes two arguments, a command
    and pointer to a guarded storage control block:
    
        s390_guarded_storage(int command, struct gs_cb *gs_cb);
    
    The second argument is relevant only for the GS_SET_BC_CB command.
    
    The commands in detail:
    
    0 - GS_ENABLE
        Enable the guarded storage facility for the current task. The
        initial content of the guarded storage control block will be
        all zeros. After the enablement the user space code can use
        load-guarded-storage-controls instruction (LGSC) to load an
        arbitrary control block. While a task is enabled the kernel
        will save and restore the current content of the guarded
        storage registers on context switch.
    1 - GS_DISABLE
        Disables the use of the guarded storage facility for the current
        task. The kernel will cease to save and restore the content of
        the guarded storage registers, the task specific content of
        these registers is lost.
    2 - GS_SET_BC_CB
        Set a broadcast guarded storage control block. This is called
        per thread and stores a specific guarded storage control block
        in the task struct of the current task. This control block will
        be used for the broadcast event GS_BROADCAST.
    3 - GS_CLEAR_BC_CB
        Clears the broadcast guarded storage control block. The guarded-
        storage control block is removed from the task struct that was
        established by GS_SET_BC_CB.
    4 - GS_BROADCAST
        Sends a broadcast to all thread siblings of the current task.
        Every sibling that has established a broadcast guarded storage
        control block will load this control block and will be enabled
        for guarded storage. The broadcast guarded storage control block
        is used up, a second broadcast without a refresh of the stored
        control block with GS_SET_BC_CB will not have any effect.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index b59ee077a596..8c6d3bdb9a00 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -409,6 +409,7 @@ typedef struct elf64_shdr {
 #define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
 #define NT_S390_VXRS_LOW	0x309	/* s390 vector registers 0-15 upper half */
 #define NT_S390_VXRS_HIGH	0x30a	/* s390 vector registers 16-31 */
+#define NT_S390_GS_CB	0x30b		/* s390 guarded storage registers */
 #define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */

commit 2cfd716d2777489db54a237f466a1c42700879c6
Merge: 755b20f49220 eea8148c69f3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 5 09:00:54 2016 -0400

    Merge tag 'powerpc-4.8-2' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull more powerpc updates from Michael Ellerman:
     "These were delayed for various reasons, so I let them sit in next a
      bit longer, rather than including them in my first pull request.
    
      Fixes:
       - Fix early access to cpu_spec relocation from Benjamin Herrenschmidt
       - Fix incorrect event codes in power9-event-list from Madhavan Srinivasan
       - Move register_process_table() out of ppc_md from Michael Ellerman
    
      Use jump_label use for [cpu|mmu]_has_feature():
       - Add mmu_early_init_devtree() from Michael Ellerman
       - Move disable_radix handling into mmu_early_init_devtree() from Michael Ellerman
       - Do hash device tree scanning earlier from Michael Ellerman
       - Do radix device tree scanning earlier from Michael Ellerman
       - Do feature patching before MMU init from Michael Ellerman
       - Check features don't change after patching from Michael Ellerman
       - Make MMU_FTR_RADIX a MMU family feature from Aneesh Kumar K.V
       - Convert mmu_has_feature() to returning bool from Michael Ellerman
       - Convert cpu_has_feature() to returning bool from Michael Ellerman
       - Define radix_enabled() in one place & use static inline from Michael Ellerman
       - Add early_[cpu|mmu]_has_feature() from Michael Ellerman
       - Convert early cpu/mmu feature check to use the new helpers from Aneesh Kumar K.V
       - jump_label: Make it possible for arches to invoke jump_label_init() earlier from Kevin Hao
       - Call jump_label_init() in apply_feature_fixups() from Aneesh Kumar K.V
       - Remove mfvtb() from Kevin Hao
       - Move cpu_has_feature() to a separate file from Kevin Hao
       - Add kconfig option to use jump labels for cpu/mmu_has_feature() from Michael Ellerman
       - Add option to use jump label for cpu_has_feature() from Kevin Hao
       - Add option to use jump label for mmu_has_feature() from Kevin Hao
       - Catch usage of cpu/mmu_has_feature() before jump label init from Aneesh Kumar K.V
       - Annotate jump label assembly from Michael Ellerman
    
      TLB flush enhancements from Aneesh Kumar K.V:
       - radix: Implement tlb mmu gather flush efficiently
       - Add helper for finding SLBE LLP encoding
       - Use hugetlb flush functions
       - Drop multiple definition of mm_is_core_local
       - radix: Add tlb flush of THP ptes
       - radix: Rename function and drop unused arg
       - radix/hugetlb: Add helper for finding page size
       - hugetlb: Add flush_hugetlb_tlb_range
       - remove flush_tlb_page_nohash
    
      Add new ptrace regsets from Anshuman Khandual and Simon Guo:
       - elf: Add powerpc specific core note sections
       - Add the function flush_tmregs_to_thread
       - Enable in transaction NT_PRFPREG ptrace requests
       - Enable in transaction NT_PPC_VMX ptrace requests
       - Enable in transaction NT_PPC_VSX ptrace requests
       - Adapt gpr32_get, gpr32_set functions for transaction
       - Enable support for NT_PPC_CGPR
       - Enable support for NT_PPC_CFPR
       - Enable support for NT_PPC_CVMX
       - Enable support for NT_PPC_CVSX
       - Enable support for TM SPR state
       - Enable NT_PPC_TM_CTAR, NT_PPC_TM_CPPR, NT_PPC_TM_CDSCR
       - Enable support for NT_PPPC_TAR, NT_PPC_PPR, NT_PPC_DSCR
       - Enable support for EBB registers
       - Enable support for Performance Monitor registers"
    
    * tag 'powerpc-4.8-2' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (48 commits)
      powerpc/mm: Move register_process_table() out of ppc_md
      powerpc/perf: Fix incorrect event codes in power9-event-list
      powerpc/32: Fix early access to cpu_spec relocation
      powerpc/ptrace: Enable support for Performance Monitor registers
      powerpc/ptrace: Enable support for EBB registers
      powerpc/ptrace: Enable support for NT_PPPC_TAR, NT_PPC_PPR, NT_PPC_DSCR
      powerpc/ptrace: Enable NT_PPC_TM_CTAR, NT_PPC_TM_CPPR, NT_PPC_TM_CDSCR
      powerpc/ptrace: Enable support for TM SPR state
      powerpc/ptrace: Enable support for NT_PPC_CVSX
      powerpc/ptrace: Enable support for NT_PPC_CVMX
      powerpc/ptrace: Enable support for NT_PPC_CFPR
      powerpc/ptrace: Enable support for NT_PPC_CGPR
      powerpc/ptrace: Adapt gpr32_get, gpr32_set functions for transaction
      powerpc/ptrace: Enable in transaction NT_PPC_VSX ptrace requests
      powerpc/ptrace: Enable in transaction NT_PPC_VMX ptrace requests
      powerpc/ptrace: Enable in transaction NT_PRFPREG ptrace requests
      powerpc/process: Add the function flush_tmregs_to_thread
      elf: Add powerpc specific core note sections
      powerpc/mm: remove flush_tlb_page_nohash
      powerpc/mm/hugetlb: Add flush_hugetlb_tlb_range
      ...

commit 444d13ff10fb13bc3e64859c3cf9ce43dcfeb075
Author: Jessica Yu <jeyu@redhat.com>
Date:   Wed Jul 27 12:06:21 2016 +0930

    modules: add ro_after_init support
    
    Add ro_after_init support for modules by adding a new page-aligned section
    in the module layout (after rodata) for ro_after_init data and enabling RO
    protection for that section after module init runs.
    
    Signed-off-by: Jessica Yu <jeyu@redhat.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index cb4a72f888d5..70b172ba41ce 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -286,6 +286,7 @@ typedef struct elf64_phdr {
 #define SHF_ALLOC		0x2
 #define SHF_EXECINSTR		0x4
 #define SHF_RELA_LIVEPATCH	0x00100000
+#define SHF_RO_AFTER_INIT	0x00200000
 #define SHF_MASKPROC		0xf0000000
 
 /* special section indexes */

commit 0dc696bcf2e86f48a23fb95ca2f40c8708241e7e
Author: Anshuman Khandual <khandual@linux.vnet.ibm.com>
Date:   Thu Jul 28 10:57:30 2016 +0800

    elf: Add powerpc specific core note sections
    
    This patch adds twelve ELF core note sections for powerpc
    architecture for various registers and register sets which
    need to be accessed from ptrace interface and then gdb.
    These additions include special purpose registers like TAR,
    PPR, DSCR, TM running and checkpointed state for various
    register sets, EBB related register set, performance monitor
    register set etc. Addition of these new ELF core note
    sections extends the existing ELF ABI on powerpc arch without
    affecting it in any manner.
    
    Signed-off-by: Anshuman Khandual <khandual@linux.vnet.ibm.com>
    Signed-off-by: Simon Guo <wei.guo.simon@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index cb4a72f888d5..1be3c5f6183b 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -381,6 +381,19 @@ typedef struct elf64_shdr {
 #define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
 #define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
 #define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
+#define NT_PPC_TAR	0x103		/* Target Address Register */
+#define NT_PPC_PPR	0x104		/* Program Priority Register */
+#define NT_PPC_DSCR	0x105		/* Data Stream Control Register */
+#define NT_PPC_EBB	0x106		/* Event Based Branch Registers */
+#define NT_PPC_PMU	0x107		/* Performance Monitor Registers */
+#define NT_PPC_TM_CGPR	0x108		/* TM checkpointed GPR Registers */
+#define NT_PPC_TM_CFPR	0x109		/* TM checkpointed FPR Registers */
+#define NT_PPC_TM_CVMX	0x10a		/* TM checkpointed VMX Registers */
+#define NT_PPC_TM_CVSX	0x10b		/* TM checkpointed VSX Registers */
+#define NT_PPC_TM_SPR	0x10c		/* TM Special Purpose Registers */
+#define NT_PPC_TM_CTAR	0x10d		/* TM checkpointed Target Address Register */
+#define NT_PPC_TM_CPPR	0x10e		/* TM checkpointed Program Priority Register */
+#define NT_PPC_TM_CDSCR	0x10f		/* TM checkpointed Data Stream Control Register */
 #define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
 #define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
 #define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */

commit 8d98e96b345e13659aa42bdc611368863ce65cbe
Author: Jessica Yu <jeyu@redhat.com>
Date:   Tue Mar 22 20:03:15 2016 -0400

    Elf: add livepatch-specific Elf constants
    
    Livepatch manages its own relocation sections and symbols in order to be
    able to reuse module loader code to write relocations. This removes
    livepatch's dependence on separate "dynrela" sections to write relocations
    and also allows livepatch to patch modules that are not yet loaded.
    
    The livepatch Elf relocation section flag (SHF_RELA_LIVEPATCH),
    and symbol section index (SHN_LIVEPATCH) allow both livepatch and the
    module loader to identity livepatch relocation sections and livepatch
    symbols.
    
    Livepatch relocation sections are marked with SHF_RELA_LIVEPATCH to
    indicate to the module loader that it should not apply that relocation
    section and that livepatch will handle them.
    
    The SHN_LIVEPATCH shndx marks symbols that will be resolved by livepatch.
    The module loader ignores these symbols and does not attempt to resolve
    them.
    
    The values of these Elf constants were selected from OS-specific
    ranges according to the definitions from glibc.
    
    Signed-off-by: Jessica Yu <jeyu@redhat.com>
    Reviewed-by: Miroslav Benes <mbenes@suse.cz>
    Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 71e1d0ed92f7..cb4a72f888d5 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -282,16 +282,18 @@ typedef struct elf64_phdr {
 #define SHT_HIUSER	0xffffffff
 
 /* sh_flags */
-#define SHF_WRITE	0x1
-#define SHF_ALLOC	0x2
-#define SHF_EXECINSTR	0x4
-#define SHF_MASKPROC	0xf0000000
+#define SHF_WRITE		0x1
+#define SHF_ALLOC		0x2
+#define SHF_EXECINSTR		0x4
+#define SHF_RELA_LIVEPATCH	0x00100000
+#define SHF_MASKPROC		0xf0000000
 
 /* special section indexes */
 #define SHN_UNDEF	0
 #define SHN_LORESERVE	0xff00
 #define SHN_LOPROC	0xff00
 #define SHN_HIPROC	0xff1f
+#define SHN_LIVEPATCH	0xff20
 #define SHN_ABS		0xfff1
 #define SHN_COMMON	0xfff2
 #define SHN_HIRESERVE	0xffff

commit 766a85d7bc5d7f1ddd6de28bdb844eae45ec63b0
Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
Date:   Fri Nov 28 05:26:34 2014 +0000

    arm64: ptrace: add NT_ARM_SYSTEM_CALL regset
    
    This regeset is intended to be used to get and set a system call number
    while tracing.
    There was some discussion about possible approaches to do so:
    
    (1) modify x8 register with ptrace(PTRACE_SETREGSET) indirectly,
        and update regs->syscallno later on in syscall_trace_enter(), or
    (2) define a dedicated regset for this purpose as on s390, or
    (3) support ptrace(PTRACE_SET_SYSCALL) as on arch/arm
    
    Thinking of the fact that user_pt_regs doesn't expose 'syscallno' to
    tracer as well as that secure_computing() expects a changed syscall number,
    especially case of -1, to be visible before this function returns in
    syscall_trace_enter(), (1) doesn't work well.
    We will take (2) since it looks much cleaner.
    
    Signed-off-by: AKASHI Takahiro <takahiro.akashi@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index ea9bf2561b9e..71e1d0ed92f7 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -397,6 +397,7 @@ typedef struct elf64_shdr {
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
 #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
+#define NT_ARM_SYSTEM_CALL	0x404	/* ARM system call number */
 #define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
 #define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
 #define NT_METAG_TLS	0x502		/* Metag TLS pointer */

commit 8070361799ae1e3f4ef347bd10f0a508ac10acfb
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Oct 6 17:53:53 2014 +0200

    s390: add support for vector extension
    
    The vector extension introduces 32 128-bit vector registers and a set of
    instruction to operate on the vector registers.
    
    The kernel can control the use of vector registers for the problem state
    program with a bit in control register 0. Once enabled for a process the
    kernel needs to retain the content of the vector registers on context
    switch. The signal frame is extended to include the vector registers.
    Two new register sets NT_S390_VXRS_LOW and NT_S390_VXRS_HIGH are added
    to the regset interface for the debugger and core dumps.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index ef6103bf1f9b..ea9bf2561b9e 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -391,6 +391,8 @@ typedef struct elf64_shdr {
 #define NT_S390_LAST_BREAK	0x306	/* s390 breaking event address */
 #define NT_S390_SYSTEM_CALL	0x307	/* s390 system call restart data */
 #define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
+#define NT_S390_VXRS_LOW	0x309	/* s390 vector registers 0-15 upper half */
+#define NT_S390_VXRS_HIGH	0x30a	/* s390 vector registers 16-31 */
 #define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */

commit 876d6dcdf26a2e860801ec61195e580d03f7b204
Author: Paul Clothier <Paul.Clothier@imgtec.com>
Date:   Tue Mar 19 12:04:43 2013 +0000

    metag: ptrace: Implement NT_METAG_TLS
    
    Implement functionality to get the TLS pointer for the metag
    architecture using regsets.
    
    This provides multi-threaded debug support for GDB.
    
    Signed-off-by: Paul Clothier <Paul.Clothier@imgtec.com>
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 8072d352b98f..ef6103bf1f9b 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -397,6 +397,7 @@ typedef struct elf64_shdr {
 #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
 #define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
 #define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
+#define NT_METAG_TLS	0x502		/* Metag TLS pointer */
 
 
 /* Note header in a PT_NOTE section */

commit 8fd5e7a2d9574b3cac1c9264ad1aed3b613ed6fe
Merge: 529e5fbcd8d3 c60ac31542e9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 3 12:06:09 2013 -0800

    Merge tag 'metag-v3.9-rc1-v4' of git://git.kernel.org/pub/scm/linux/kernel/git/jhogan/metag
    
    Pull new ImgTec Meta architecture from James Hogan:
     "This adds core architecture support for Imagination's Meta processor
      cores, followed by some later miscellaneous arch/metag cleanups and
      fixes which I kept separate to ease review:
    
       - Support for basic Meta 1 (ATP) and Meta 2 (HTP) core architecture
       - A few fixes all over, particularly for symbol prefixes
       - A few privilege protection fixes
       - Several cleanups (setup.c includes, split out a lot of
         metag_ksyms.c)
       - Fix some missing exports
       - Convert hugetlb to use vm_unmapped_area()
       - Copy device tree to non-init memory
       - Provide dma_get_sgtable()"
    
    * tag 'metag-v3.9-rc1-v4' of git://git.kernel.org/pub/scm/linux/kernel/git/jhogan/metag: (61 commits)
      metag: Provide dma_get_sgtable()
      metag: prom.h: remove declaration of metag_dt_memblock_reserve()
      metag: copy devicetree to non-init memory
      metag: cleanup metag_ksyms.c includes
      metag: move mm/init.c exports out of metag_ksyms.c
      metag: move usercopy.c exports out of metag_ksyms.c
      metag: move setup.c exports out of metag_ksyms.c
      metag: move kick.c exports out of metag_ksyms.c
      metag: move traps.c exports out of metag_ksyms.c
      metag: move irq enable out of irqflags.h on SMP
      genksyms: fix metag symbol prefix on crc symbols
      metag: hugetlb: convert to vm_unmapped_area()
      metag: export clear_page and copy_page
      metag: export metag_code_cache_flush_all
      metag: protect more non-MMU memory regions
      metag: make TXPRIVEXT bits explicit
      metag: kernel/setup.c: sort includes
      perf: Enable building perf tools for Meta
      metag: add boot time LNKGET/LNKSET check
      metag: add __init to metag_cache_probe()
      ...

commit bc3966bf1583a6c22b76397535174445c43952de
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Oct 9 10:54:36 2012 +0100

    metag: ptrace
    
    The ptrace interface for metag provides access to some core register
    sets using the PTRACE_GETREGSET and PTRACE_SETREGSET operations. The
    details of the internal context structures is abstracted into user API
    structures to both ease use and allow flexibility to change the internal
    context layouts. Copyin and copyout functions for these register sets
    are exposed to allow signal handling code to use them to copy to and
    from the signal context.
    
    struct user_gp_regs (NT_PRSTATUS) provides access to the core general
    purpose register context.
    
    struct user_cb_regs (NT_METAG_CBUF) provides access to the TXCATCH*
    registers which contains information abuot a memory fault, unaligned
    access error or watchpoint. This can be modified to alter the way the
    fault is replayed on resume ("catch replay"), or to prevent the replay
    taking place.
    
    struct user_rp_state (NT_METAG_RPIPE) provides access to the state of
    the Meta read pipeline which can be used to hide memory latencies in
    hand optimised data loops.
    
    Extended DSP register state, DSP RAM, and hardware breakpoint registers
    aren't yet exposed through ptrace.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Denys Vlasenko <vda.linux@googlemail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 126a8175e3e2..eb164a298b98 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -395,6 +395,8 @@ typedef struct elf64_shdr {
 #define NT_ARM_TLS	0x401		/* ARM TLS register */
 #define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
 #define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
+#define NT_METAG_CBUF	0x500		/* Metag catch buffer registers */
+#define NT_METAG_RPIPE	0x501		/* Metag read pipeline state */
 
 
 /* Note header in a PT_NOTE section */

commit 242260fb858e99674289484bc2bfe3b41f9c4cbb
Author: Christian Kujau <lists@nerdbynature.de>
Date:   Thu Feb 21 16:43:05 2013 -0800

    sun.com documentation fixes
    
    After I came across a help text for SUNGEM mentioning a broken sun.com
    URL, I felt like fixing those up, as they are now pointing to oracle.com
    URLs.
    
    Signed-off-by: Christian Kujau <lists@nerdbynature.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 126a8175e3e2..900b9484445b 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -49,14 +49,14 @@ typedef __s64	Elf64_Sxword;
  *
  * Specifications are available in:
  *
- * - Sun microsystems: Linker and Libraries.
- *   Part No: 817-1984-17, September 2008.
- *   URL: http://docs.sun.com/app/docs/doc/817-1984
+ * - Oracle: Linker and Libraries.
+ *   Part No: 817–1984–19, August 2011.
+ *   http://docs.oracle.com/cd/E18752_01/pdf/817-1984.pdf
  *
  * - System V ABI AMD64 Architecture Processor Supplement
- *   Draft Version 0.99.,
- *   May 11, 2009.
- *   URL: http://www.x86-64.org/
+ *   Draft Version 0.99.4,
+ *   January 13, 2010.
+ *   http://www.cs.washington.edu/education/courses/cse351/12wi/supp-docs/abi.pdf
  */
 #define PN_XNUM 0xffff
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
new file mode 100644
index 000000000000..126a8175e3e2
--- /dev/null
+++ b/include/uapi/linux/elf.h
@@ -0,0 +1,414 @@
+#ifndef _UAPI_LINUX_ELF_H
+#define _UAPI_LINUX_ELF_H
+
+#include <linux/types.h>
+#include <linux/elf-em.h>
+
+/* 32-bit ELF base types. */
+typedef __u32	Elf32_Addr;
+typedef __u16	Elf32_Half;
+typedef __u32	Elf32_Off;
+typedef __s32	Elf32_Sword;
+typedef __u32	Elf32_Word;
+
+/* 64-bit ELF base types. */
+typedef __u64	Elf64_Addr;
+typedef __u16	Elf64_Half;
+typedef __s16	Elf64_SHalf;
+typedef __u64	Elf64_Off;
+typedef __s32	Elf64_Sword;
+typedef __u32	Elf64_Word;
+typedef __u64	Elf64_Xword;
+typedef __s64	Elf64_Sxword;
+
+/* These constants are for the segment types stored in the image headers */
+#define PT_NULL    0
+#define PT_LOAD    1
+#define PT_DYNAMIC 2
+#define PT_INTERP  3
+#define PT_NOTE    4
+#define PT_SHLIB   5
+#define PT_PHDR    6
+#define PT_TLS     7               /* Thread local storage segment */
+#define PT_LOOS    0x60000000      /* OS-specific */
+#define PT_HIOS    0x6fffffff      /* OS-specific */
+#define PT_LOPROC  0x70000000
+#define PT_HIPROC  0x7fffffff
+#define PT_GNU_EH_FRAME		0x6474e550
+
+#define PT_GNU_STACK	(PT_LOOS + 0x474e551)
+
+/*
+ * Extended Numbering
+ *
+ * If the real number of program header table entries is larger than
+ * or equal to PN_XNUM(0xffff), it is set to sh_info field of the
+ * section header at index 0, and PN_XNUM is set to e_phnum
+ * field. Otherwise, the section header at index 0 is zero
+ * initialized, if it exists.
+ *
+ * Specifications are available in:
+ *
+ * - Sun microsystems: Linker and Libraries.
+ *   Part No: 817-1984-17, September 2008.
+ *   URL: http://docs.sun.com/app/docs/doc/817-1984
+ *
+ * - System V ABI AMD64 Architecture Processor Supplement
+ *   Draft Version 0.99.,
+ *   May 11, 2009.
+ *   URL: http://www.x86-64.org/
+ */
+#define PN_XNUM 0xffff
+
+/* These constants define the different elf file types */
+#define ET_NONE   0
+#define ET_REL    1
+#define ET_EXEC   2
+#define ET_DYN    3
+#define ET_CORE   4
+#define ET_LOPROC 0xff00
+#define ET_HIPROC 0xffff
+
+/* This is the info that is needed to parse the dynamic section of the file */
+#define DT_NULL		0
+#define DT_NEEDED	1
+#define DT_PLTRELSZ	2
+#define DT_PLTGOT	3
+#define DT_HASH		4
+#define DT_STRTAB	5
+#define DT_SYMTAB	6
+#define DT_RELA		7
+#define DT_RELASZ	8
+#define DT_RELAENT	9
+#define DT_STRSZ	10
+#define DT_SYMENT	11
+#define DT_INIT		12
+#define DT_FINI		13
+#define DT_SONAME	14
+#define DT_RPATH 	15
+#define DT_SYMBOLIC	16
+#define DT_REL	        17
+#define DT_RELSZ	18
+#define DT_RELENT	19
+#define DT_PLTREL	20
+#define DT_DEBUG	21
+#define DT_TEXTREL	22
+#define DT_JMPREL	23
+#define DT_ENCODING	32
+#define OLD_DT_LOOS	0x60000000
+#define DT_LOOS		0x6000000d
+#define DT_HIOS		0x6ffff000
+#define DT_VALRNGLO	0x6ffffd00
+#define DT_VALRNGHI	0x6ffffdff
+#define DT_ADDRRNGLO	0x6ffffe00
+#define DT_ADDRRNGHI	0x6ffffeff
+#define DT_VERSYM	0x6ffffff0
+#define DT_RELACOUNT	0x6ffffff9
+#define DT_RELCOUNT	0x6ffffffa
+#define DT_FLAGS_1	0x6ffffffb
+#define DT_VERDEF	0x6ffffffc
+#define	DT_VERDEFNUM	0x6ffffffd
+#define DT_VERNEED	0x6ffffffe
+#define	DT_VERNEEDNUM	0x6fffffff
+#define OLD_DT_HIOS     0x6fffffff
+#define DT_LOPROC	0x70000000
+#define DT_HIPROC	0x7fffffff
+
+/* This info is needed when parsing the symbol table */
+#define STB_LOCAL  0
+#define STB_GLOBAL 1
+#define STB_WEAK   2
+
+#define STT_NOTYPE  0
+#define STT_OBJECT  1
+#define STT_FUNC    2
+#define STT_SECTION 3
+#define STT_FILE    4
+#define STT_COMMON  5
+#define STT_TLS     6
+
+#define ELF_ST_BIND(x)		((x) >> 4)
+#define ELF_ST_TYPE(x)		(((unsigned int) x) & 0xf)
+#define ELF32_ST_BIND(x)	ELF_ST_BIND(x)
+#define ELF32_ST_TYPE(x)	ELF_ST_TYPE(x)
+#define ELF64_ST_BIND(x)	ELF_ST_BIND(x)
+#define ELF64_ST_TYPE(x)	ELF_ST_TYPE(x)
+
+typedef struct dynamic{
+  Elf32_Sword d_tag;
+  union{
+    Elf32_Sword	d_val;
+    Elf32_Addr	d_ptr;
+  } d_un;
+} Elf32_Dyn;
+
+typedef struct {
+  Elf64_Sxword d_tag;		/* entry tag value */
+  union {
+    Elf64_Xword d_val;
+    Elf64_Addr d_ptr;
+  } d_un;
+} Elf64_Dyn;
+
+/* The following are used with relocations */
+#define ELF32_R_SYM(x) ((x) >> 8)
+#define ELF32_R_TYPE(x) ((x) & 0xff)
+
+#define ELF64_R_SYM(i)			((i) >> 32)
+#define ELF64_R_TYPE(i)			((i) & 0xffffffff)
+
+typedef struct elf32_rel {
+  Elf32_Addr	r_offset;
+  Elf32_Word	r_info;
+} Elf32_Rel;
+
+typedef struct elf64_rel {
+  Elf64_Addr r_offset;	/* Location at which to apply the action */
+  Elf64_Xword r_info;	/* index and type of relocation */
+} Elf64_Rel;
+
+typedef struct elf32_rela{
+  Elf32_Addr	r_offset;
+  Elf32_Word	r_info;
+  Elf32_Sword	r_addend;
+} Elf32_Rela;
+
+typedef struct elf64_rela {
+  Elf64_Addr r_offset;	/* Location at which to apply the action */
+  Elf64_Xword r_info;	/* index and type of relocation */
+  Elf64_Sxword r_addend;	/* Constant addend used to compute value */
+} Elf64_Rela;
+
+typedef struct elf32_sym{
+  Elf32_Word	st_name;
+  Elf32_Addr	st_value;
+  Elf32_Word	st_size;
+  unsigned char	st_info;
+  unsigned char	st_other;
+  Elf32_Half	st_shndx;
+} Elf32_Sym;
+
+typedef struct elf64_sym {
+  Elf64_Word st_name;		/* Symbol name, index in string tbl */
+  unsigned char	st_info;	/* Type and binding attributes */
+  unsigned char	st_other;	/* No defined meaning, 0 */
+  Elf64_Half st_shndx;		/* Associated section index */
+  Elf64_Addr st_value;		/* Value of the symbol */
+  Elf64_Xword st_size;		/* Associated symbol size */
+} Elf64_Sym;
+
+
+#define EI_NIDENT	16
+
+typedef struct elf32_hdr{
+  unsigned char	e_ident[EI_NIDENT];
+  Elf32_Half	e_type;
+  Elf32_Half	e_machine;
+  Elf32_Word	e_version;
+  Elf32_Addr	e_entry;  /* Entry point */
+  Elf32_Off	e_phoff;
+  Elf32_Off	e_shoff;
+  Elf32_Word	e_flags;
+  Elf32_Half	e_ehsize;
+  Elf32_Half	e_phentsize;
+  Elf32_Half	e_phnum;
+  Elf32_Half	e_shentsize;
+  Elf32_Half	e_shnum;
+  Elf32_Half	e_shstrndx;
+} Elf32_Ehdr;
+
+typedef struct elf64_hdr {
+  unsigned char	e_ident[EI_NIDENT];	/* ELF "magic number" */
+  Elf64_Half e_type;
+  Elf64_Half e_machine;
+  Elf64_Word e_version;
+  Elf64_Addr e_entry;		/* Entry point virtual address */
+  Elf64_Off e_phoff;		/* Program header table file offset */
+  Elf64_Off e_shoff;		/* Section header table file offset */
+  Elf64_Word e_flags;
+  Elf64_Half e_ehsize;
+  Elf64_Half e_phentsize;
+  Elf64_Half e_phnum;
+  Elf64_Half e_shentsize;
+  Elf64_Half e_shnum;
+  Elf64_Half e_shstrndx;
+} Elf64_Ehdr;
+
+/* These constants define the permissions on sections in the program
+   header, p_flags. */
+#define PF_R		0x4
+#define PF_W		0x2
+#define PF_X		0x1
+
+typedef struct elf32_phdr{
+  Elf32_Word	p_type;
+  Elf32_Off	p_offset;
+  Elf32_Addr	p_vaddr;
+  Elf32_Addr	p_paddr;
+  Elf32_Word	p_filesz;
+  Elf32_Word	p_memsz;
+  Elf32_Word	p_flags;
+  Elf32_Word	p_align;
+} Elf32_Phdr;
+
+typedef struct elf64_phdr {
+  Elf64_Word p_type;
+  Elf64_Word p_flags;
+  Elf64_Off p_offset;		/* Segment file offset */
+  Elf64_Addr p_vaddr;		/* Segment virtual address */
+  Elf64_Addr p_paddr;		/* Segment physical address */
+  Elf64_Xword p_filesz;		/* Segment size in file */
+  Elf64_Xword p_memsz;		/* Segment size in memory */
+  Elf64_Xword p_align;		/* Segment alignment, file & memory */
+} Elf64_Phdr;
+
+/* sh_type */
+#define SHT_NULL	0
+#define SHT_PROGBITS	1
+#define SHT_SYMTAB	2
+#define SHT_STRTAB	3
+#define SHT_RELA	4
+#define SHT_HASH	5
+#define SHT_DYNAMIC	6
+#define SHT_NOTE	7
+#define SHT_NOBITS	8
+#define SHT_REL		9
+#define SHT_SHLIB	10
+#define SHT_DYNSYM	11
+#define SHT_NUM		12
+#define SHT_LOPROC	0x70000000
+#define SHT_HIPROC	0x7fffffff
+#define SHT_LOUSER	0x80000000
+#define SHT_HIUSER	0xffffffff
+
+/* sh_flags */
+#define SHF_WRITE	0x1
+#define SHF_ALLOC	0x2
+#define SHF_EXECINSTR	0x4
+#define SHF_MASKPROC	0xf0000000
+
+/* special section indexes */
+#define SHN_UNDEF	0
+#define SHN_LORESERVE	0xff00
+#define SHN_LOPROC	0xff00
+#define SHN_HIPROC	0xff1f
+#define SHN_ABS		0xfff1
+#define SHN_COMMON	0xfff2
+#define SHN_HIRESERVE	0xffff
+ 
+typedef struct elf32_shdr {
+  Elf32_Word	sh_name;
+  Elf32_Word	sh_type;
+  Elf32_Word	sh_flags;
+  Elf32_Addr	sh_addr;
+  Elf32_Off	sh_offset;
+  Elf32_Word	sh_size;
+  Elf32_Word	sh_link;
+  Elf32_Word	sh_info;
+  Elf32_Word	sh_addralign;
+  Elf32_Word	sh_entsize;
+} Elf32_Shdr;
+
+typedef struct elf64_shdr {
+  Elf64_Word sh_name;		/* Section name, index in string tbl */
+  Elf64_Word sh_type;		/* Type of section */
+  Elf64_Xword sh_flags;		/* Miscellaneous section attributes */
+  Elf64_Addr sh_addr;		/* Section virtual addr at execution */
+  Elf64_Off sh_offset;		/* Section file offset */
+  Elf64_Xword sh_size;		/* Size of section in bytes */
+  Elf64_Word sh_link;		/* Index of another section */
+  Elf64_Word sh_info;		/* Additional section information */
+  Elf64_Xword sh_addralign;	/* Section alignment */
+  Elf64_Xword sh_entsize;	/* Entry size if section holds table */
+} Elf64_Shdr;
+
+#define	EI_MAG0		0		/* e_ident[] indexes */
+#define	EI_MAG1		1
+#define	EI_MAG2		2
+#define	EI_MAG3		3
+#define	EI_CLASS	4
+#define	EI_DATA		5
+#define	EI_VERSION	6
+#define	EI_OSABI	7
+#define	EI_PAD		8
+
+#define	ELFMAG0		0x7f		/* EI_MAG */
+#define	ELFMAG1		'E'
+#define	ELFMAG2		'L'
+#define	ELFMAG3		'F'
+#define	ELFMAG		"\177ELF"
+#define	SELFMAG		4
+
+#define	ELFCLASSNONE	0		/* EI_CLASS */
+#define	ELFCLASS32	1
+#define	ELFCLASS64	2
+#define	ELFCLASSNUM	3
+
+#define ELFDATANONE	0		/* e_ident[EI_DATA] */
+#define ELFDATA2LSB	1
+#define ELFDATA2MSB	2
+
+#define EV_NONE		0		/* e_version, EI_VERSION */
+#define EV_CURRENT	1
+#define EV_NUM		2
+
+#define ELFOSABI_NONE	0
+#define ELFOSABI_LINUX	3
+
+#ifndef ELF_OSABI
+#define ELF_OSABI ELFOSABI_NONE
+#endif
+
+/*
+ * Notes used in ET_CORE. Architectures export some of the arch register sets
+ * using the corresponding note types via the PTRACE_GETREGSET and
+ * PTRACE_SETREGSET requests.
+ */
+#define NT_PRSTATUS	1
+#define NT_PRFPREG	2
+#define NT_PRPSINFO	3
+#define NT_TASKSTRUCT	4
+#define NT_AUXV		6
+/*
+ * Note to userspace developers: size of NT_SIGINFO note may increase
+ * in the future to accomodate more fields, don't assume it is fixed!
+ */
+#define NT_SIGINFO      0x53494749
+#define NT_FILE         0x46494c45
+#define NT_PRXFPREG     0x46e62b7f      /* copied from gdb5.1/include/elf/common.h */
+#define NT_PPC_VMX	0x100		/* PowerPC Altivec/VMX registers */
+#define NT_PPC_SPE	0x101		/* PowerPC SPE/EVR registers */
+#define NT_PPC_VSX	0x102		/* PowerPC VSX registers */
+#define NT_386_TLS	0x200		/* i386 TLS slots (struct user_desc) */
+#define NT_386_IOPERM	0x201		/* x86 io permission bitmap (1=deny) */
+#define NT_X86_XSTATE	0x202		/* x86 extended state using xsave */
+#define NT_S390_HIGH_GPRS	0x300	/* s390 upper register halves */
+#define NT_S390_TIMER	0x301		/* s390 timer register */
+#define NT_S390_TODCMP	0x302		/* s390 TOD clock comparator register */
+#define NT_S390_TODPREG	0x303		/* s390 TOD programmable register */
+#define NT_S390_CTRS	0x304		/* s390 control registers */
+#define NT_S390_PREFIX	0x305		/* s390 prefix register */
+#define NT_S390_LAST_BREAK	0x306	/* s390 breaking event address */
+#define NT_S390_SYSTEM_CALL	0x307	/* s390 system call restart data */
+#define NT_S390_TDB	0x308		/* s390 transaction diagnostic block */
+#define NT_ARM_VFP	0x400		/* ARM VFP/NEON registers */
+#define NT_ARM_TLS	0x401		/* ARM TLS register */
+#define NT_ARM_HW_BREAK	0x402		/* ARM hardware breakpoint registers */
+#define NT_ARM_HW_WATCH	0x403		/* ARM hardware watchpoint registers */
+
+
+/* Note header in a PT_NOTE section */
+typedef struct elf32_note {
+  Elf32_Word	n_namesz;	/* Name size */
+  Elf32_Word	n_descsz;	/* Content size */
+  Elf32_Word	n_type;		/* Content type */
+} Elf32_Nhdr;
+
+/* Note header in a PT_NOTE section */
+typedef struct elf64_note {
+  Elf64_Word n_namesz;	/* Name size */
+  Elf64_Word n_descsz;	/* Content size */
+  Elf64_Word n_type;	/* Content type */
+} Elf64_Nhdr;
+
+#endif /* _UAPI_LINUX_ELF_H */
