commit 79293f49677e2e703ef0d0efc9919319adacb3fb
Author: Jiunn Chang <c0d1n61at3@gmail.com>
Date:   Wed Jun 26 22:25:30 2019 -0500

    packet: Fix undefined behavior in bit shift
    
    Shifting signed 32-bit value by 31 bits is undefined.  Changing most
    significant bit to unsigned.
    
    Changes included in v2:
      - use subsystem specific subject lines
      - CC required mailing lists
    
    Signed-off-by: Jiunn Chang <c0d1n61at3@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 467b654bd4c7..3d884d68eb30 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -123,7 +123,7 @@ struct tpacket_auxdata {
 /* Rx and Tx ring - header status */
 #define TP_STATUS_TS_SOFTWARE		(1 << 29)
 #define TP_STATUS_TS_SYS_HARDWARE	(1 << 30) /* deprecated, never set */
-#define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
+#define TP_STATUS_TS_RAW_HARDWARE	(1U << 31)
 
 /* Rx ring - feature request bits */
 #define TP_FT_REQ_FILL_RXHASH	0x1

commit fa788d986a3aac5069378ed04697bd06f83d3488
Author: Vincent Whitchurch <vincent.whitchurch@axis.com>
Date:   Mon Sep 3 16:23:36 2018 +0200

    packet: add sockopt to ignore outgoing packets
    
    Currently, the only way to ignore outgoing packets on a packet socket is
    via the BPF filter.  With MSG_ZEROCOPY, packets that are looped into
    AF_PACKET are copied in dev_queue_xmit_nit(), and this copy happens even
    if the filter run from packet_rcv() would reject them.  So the presence
    of a packet socket on the interface takes away the benefits of
    MSG_ZEROCOPY, even if the packet socket is not interested in outgoing
    packets.  (Even when MSG_ZEROCOPY is not used, the skb is unnecessarily
    cloned, but the cost for that is much lower.)
    
    Add a socket option to allow AF_PACKET sockets to ignore outgoing
    packets to solve this.  Note that the *BSDs already have something
    similar: BIOCSSEESENT/BIOCSDIRECTION and BIOCSDIRFILT.
    
    The first intended user is lldpd.
    
    Signed-off-by: Vincent Whitchurch <vincent.whitchurch@axis.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 67b61d91d89b..467b654bd4c7 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -57,6 +57,7 @@ struct sockaddr_ll {
 #define PACKET_QDISC_BYPASS		20
 #define PACKET_ROLLOVER_STATS		21
 #define PACKET_FANOUT_DATA		22
+#define PACKET_IGNORE_OUTGOING		23
 
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 4df96a7dd4fa..67b61d91d89b 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef __LINUX_IF_PACKET_H
 #define __LINUX_IF_PACKET_H
 

commit 4a69a864209e9ab436d4a58e8028ac96cc873d15
Author: Mike Maloney <maloney@google.com>
Date:   Fri Apr 21 10:56:11 2017 -0400

    packet: add PACKET_FANOUT_FLAG_UNIQUEID to assign new fanout group id.
    
    Fanout uses a per net global namespace. A process that intends to create
    a new fanout group can accidentally join an existing group. It is not
    possible to detect this.
    
    Add socket option PACKET_FANOUT_FLAG_UNIQUEID.  When specified the
    supplied fanout group id must be set to 0, and the kernel chooses an id
    that is not already in use.  This is an ephemeral flag so that
    other sockets can be added to this group using setsockopt, but NOT
    specifying this flag.  The current getsockopt(..., PACKET_FANOUT, ...)
    can be used to retrieve the new group id.
    
    We assume that there are not a lot of fanout groups and that this is not
    a high frequency call.
    
    The method assigns ids starting at zero and increases until it finds an
    unused id.  It keeps track of the last assigned id, and uses it as a
    starting point to find new ids.
    
    Signed-off-by: Mike Maloney <maloney@google.com>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 9e7edfd8141e..4df96a7dd4fa 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -66,6 +66,7 @@ struct sockaddr_ll {
 #define PACKET_FANOUT_CBPF		6
 #define PACKET_FANOUT_EBPF		7
 #define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
+#define PACKET_FANOUT_FLAG_UNIQUEID	0x2000
 #define PACKET_FANOUT_FLAG_DEFRAG	0x8000
 
 struct tpacket_stats {

commit f2e520956a1ab636698f8160194c9b8ac0989aab
Author: Willem de Bruijn <willemb@google.com>
Date:   Fri Aug 14 22:31:35 2015 -0400

    packet: add extended BPF fanout mode
    
    Add fanout mode PACKET_FANOUT_EBPF that accepts an en extended BPF
    program to select a socket.
    
    Update the internal eBPF program by passing to socket option
    SOL_PACKET/PACKET_FANOUT_DATA a file descriptor returned by bpf().
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index a4bb16fa822e..9e7edfd8141e 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -64,6 +64,7 @@ struct sockaddr_ll {
 #define PACKET_FANOUT_RND		4
 #define PACKET_FANOUT_QM		5
 #define PACKET_FANOUT_CBPF		6
+#define PACKET_FANOUT_EBPF		7
 #define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
 #define PACKET_FANOUT_FLAG_DEFRAG	0x8000
 

commit 47dceb8ecdc1c3ad1818dfea3d659a05b74c3fc2
Author: Willem de Bruijn <willemb@google.com>
Date:   Fri Aug 14 22:31:34 2015 -0400

    packet: add classic BPF fanout mode
    
    Add fanout mode PACKET_FANOUT_CBPF that accepts a classic BPF program
    to select a socket.
    
    This avoids having to keep adding special case fanout modes. One
    example use case is application layer load balancing. The QUIC
    protocol, for instance, encodes a connection ID in UDP payload.
    
    Also add socket option SOL_PACKET/PACKET_FANOUT_DATA that updates data
    associated with the socket group. Fanout mode PACKET_FANOUT_CBPF is the
    only user so far.
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index d3d715f8c88f..a4bb16fa822e 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -55,6 +55,7 @@ struct sockaddr_ll {
 #define PACKET_TX_HAS_OFF		19
 #define PACKET_QDISC_BYPASS		20
 #define PACKET_ROLLOVER_STATS		21
+#define PACKET_FANOUT_DATA		22
 
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1
@@ -62,6 +63,7 @@ struct sockaddr_ll {
 #define PACKET_FANOUT_ROLLOVER		3
 #define PACKET_FANOUT_RND		4
 #define PACKET_FANOUT_QM		5
+#define PACKET_FANOUT_CBPF		6
 #define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
 #define PACKET_FANOUT_FLAG_DEFRAG	0x8000
 

commit a9b6391814d5d6b8668fca2dace86949b7244e2e
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue May 12 11:56:50 2015 -0400

    packet: rollover statistics
    
    Rollover indicates exceptional conditions. Export a counter to inform
    socket owners of this state.
    
    If no socket with sufficient room is found, rollover fails. Also count
    these events.
    
    Finally, also count when flows are rolled over early thanks to huge
    flow detection, to validate its correctness.
    
    Tested:
      Read counters in bench_rollover on all other tests in the patchset
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 053bd102fbe0..d3d715f8c88f 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -54,6 +54,7 @@ struct sockaddr_ll {
 #define PACKET_FANOUT			18
 #define PACKET_TX_HAS_OFF		19
 #define PACKET_QDISC_BYPASS		20
+#define PACKET_ROLLOVER_STATS		21
 
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1
@@ -75,6 +76,12 @@ struct tpacket_stats_v3 {
 	unsigned int	tp_freeze_q_cnt;
 };
 
+struct tpacket_rollover_stats {
+	__aligned_u64	tp_all;
+	__aligned_u64	tp_huge;
+	__aligned_u64	tp_failed;
+};
+
 union tpacket_stats_u {
 	struct tpacket_stats stats1;
 	struct tpacket_stats_v3 stats3;

commit 682f048bd49449f4ab978664a7f69a44a74e3caa
Author: Alexander Drozdov <al.drozdov@gmail.com>
Date:   Mon Mar 23 09:11:13 2015 +0300

    af_packet: pass checksum validation status to the user
    
    Introduce TP_STATUS_CSUM_VALID tp_status flag to tell the
    af_packet user that at least the transport header checksum
    has been already validated.
    
    For now, the flag may be set for incoming packets only.
    
    Signed-off-by: Alexander Drozdov <al.drozdov@gmail.com>
    Cc: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index da2d668b8cf1..053bd102fbe0 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -99,6 +99,7 @@ struct tpacket_auxdata {
 #define TP_STATUS_VLAN_VALID		(1 << 4) /* auxdata has valid tp_vlan_tci */
 #define TP_STATUS_BLK_TMO		(1 << 5)
 #define TP_STATUS_VLAN_TPID_VALID	(1 << 6) /* auxdata has valid tp_vlan_tpid */
+#define TP_STATUS_CSUM_VALID		(1 << 7)
 
 /* Tx ring - header status */
 #define TP_STATUS_AVAILABLE	      0

commit 68a360e82e55c9b35097e7be7f7991d8f401032f
Author: Willem de Bruijn <willemb@google.com>
Date:   Fri Jul 25 18:01:31 2014 -0400

    packet: remove deprecated syststamp timestamp
    
    No device driver will ever return an skb_shared_info structure with
    syststamp non-zero, so remove the branch that tests for this and
    optionally marks the packet timestamp as TP_STATUS_TS_SYS_HARDWARE.
    
    Do not remove the definition TP_STATUS_TS_SYS_HARDWARE, as processes
    may refer to it.
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index bac27fa05f5b..da2d668b8cf1 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -108,7 +108,7 @@ struct tpacket_auxdata {
 
 /* Rx and Tx ring - header status */
 #define TP_STATUS_TS_SOFTWARE		(1 << 29)
-#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30)
+#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30) /* deprecated, never set */
 #define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
 
 /* Rx ring - feature request bits */

commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Wed Jan 22 16:01:44 2014 -0500

    af_packet: Add Queue mapping mode to af_packet fanout operation
    
    This patch adds a queue mapping mode to the fanout operation of af_packet
    sockets.  This allows user space af_packet users to better filter on flows
    ingressing and egressing via a specific hardware queue, and avoids the potential
    packet reordering that can occur when FANOUT_CPU is being used and irq affinity
    varies.
    
    Tested successfully by myself.  applies to net-next
    
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    CC: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 1988a02842cc..bac27fa05f5b 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -60,6 +60,7 @@ struct sockaddr_ll {
 #define PACKET_FANOUT_CPU		2
 #define PACKET_FANOUT_ROLLOVER		3
 #define PACKET_FANOUT_RND		4
+#define PACKET_FANOUT_QM		5
 #define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
 #define PACKET_FANOUT_FLAG_DEFRAG	0x8000
 

commit 604d13c97f0d863e41da3f5835c62e3cf899962b
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Mon Dec 23 14:35:56 2013 +0100

    netlink: specify netlink packet direction for nlmon
    
    In order to facilitate development for netlink protocol dissector,
    fill the unused field skb->pkt_type of the cloned skb with a hint
    of the address space of the new owner (receiver) socket in the
    notion of "to kernel" resp. "to user".
    
    At the time we invoke __netlink_deliver_tap_skb(), we already have
    set the new skb owner via netlink_skb_set_owner_r(), so we can use
    that for netlink_is_kernel() probing.
    
    In normal PF_PACKET network traffic, this field denotes if the
    packet is destined for us (PACKET_HOST), if it's broadcast
    (PACKET_BROADCAST), etc.
    
    As we only have 3 bit reserved, we can use the value (= 6) of
    PACKET_FASTROUTE as it's _not used_ anywhere in the whole kernel
    and not supported anywhere, and packets of such type were never
    exposed to user space, so there are no overlapping users of such
    kind. Thus, as wished, that seems the only way to make both
    PACKET_* values non-overlapping and therefore device agnostic.
    
    By using those two flags for netlink skbs on nlmon devices, they
    can be made available and picked up via sll_pkttype (previously
    unused in netlink context) in struct sockaddr_ll. We now have
    these two directions:
    
     - PACKET_USER (= 6)    ->  to user space
     - PACKET_KERNEL (= 7)  ->  to kernel space
    
    Partial `ip a` example strace for sa_family=AF_NETLINK with
    detected nl msg direction:
    
    syscall:                     direction:
    sendto(3,  ...) = 40         /* to kernel */
    recvmsg(3, ...) = 3404       /* to user */
    recvmsg(3, ...) = 1120       /* to user */
    recvmsg(3, ...) = 20         /* to user */
    sendto(3,  ...) = 40         /* to kernel */
    recvmsg(3, ...) = 168        /* to user */
    recvmsg(3, ...) = 144        /* to user */
    recvmsg(3, ...) = 20         /* to user */
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Jakub Zawadzki <darkjames-ws@darkjames.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index e9d844c80c11..1988a02842cc 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -26,8 +26,10 @@ struct sockaddr_ll {
 #define PACKET_MULTICAST	2		/* To group		*/
 #define PACKET_OTHERHOST	3		/* To someone else 	*/
 #define PACKET_OUTGOING		4		/* Outgoing of any type */
-/* These ones are invisible by user level */
 #define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
+#define PACKET_USER		6		/* To user space	*/
+#define PACKET_KERNEL		7		/* To kernel space	*/
+/* Unused, PACKET_FASTROUTE and PACKET_LOOPBACK are invisible to user space */
 #define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
 
 /* Packet socket options */

commit a0cdfcf39362410d5ea983f4daf67b38de129408
Author: Atzm Watanabe <atzm@stratosphere.co.jp>
Date:   Tue Dec 17 22:53:40 2013 +0900

    packet: deliver VLAN TPID to userspace
    
    This enables userspace to get VLAN TPID as well as the VLAN TCI.
    
    Signed-off-by: Atzm Watanabe <atzm@stratosphere.co.jp>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 9185dc9a4485..e9d844c80c11 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -84,17 +84,18 @@ struct tpacket_auxdata {
 	__u16		tp_mac;
 	__u16		tp_net;
 	__u16		tp_vlan_tci;
-	__u16		tp_padding;
+	__u16		tp_vlan_tpid;
 };
 
 /* Rx ring - header status */
-#define TP_STATUS_KERNEL	      0
-#define TP_STATUS_USER		(1 << 0)
-#define TP_STATUS_COPY		(1 << 1)
-#define TP_STATUS_LOSING	(1 << 2)
-#define TP_STATUS_CSUMNOTREADY	(1 << 3)
-#define TP_STATUS_VLAN_VALID	(1 << 4) /* auxdata has valid tp_vlan_tci */
-#define TP_STATUS_BLK_TMO	(1 << 5)
+#define TP_STATUS_KERNEL		      0
+#define TP_STATUS_USER			(1 << 0)
+#define TP_STATUS_COPY			(1 << 1)
+#define TP_STATUS_LOSING		(1 << 2)
+#define TP_STATUS_CSUMNOTREADY		(1 << 3)
+#define TP_STATUS_VLAN_VALID		(1 << 4) /* auxdata has valid tp_vlan_tci */
+#define TP_STATUS_BLK_TMO		(1 << 5)
+#define TP_STATUS_VLAN_TPID_VALID	(1 << 6) /* auxdata has valid tp_vlan_tpid */
 
 /* Tx ring - header status */
 #define TP_STATUS_AVAILABLE	      0
@@ -133,12 +134,15 @@ struct tpacket2_hdr {
 	__u32		tp_sec;
 	__u32		tp_nsec;
 	__u16		tp_vlan_tci;
-	__u8		tp_padding[6];
+	__u16		tp_vlan_tpid;
+	__u8		tp_padding[4];
 };
 
 struct tpacket_hdr_variant1 {
 	__u32	tp_rxhash;
 	__u32	tp_vlan_tci;
+	__u16	tp_vlan_tpid;
+	__u16	tp_padding;
 };
 
 struct tpacket3_hdr {
@@ -154,7 +158,7 @@ struct tpacket3_hdr {
 	union {
 		struct tpacket_hdr_variant1 hv1;
 	};
-	__u8		tp_padding[12];
+	__u8		tp_padding[8];
 };
 
 struct tpacket_bd_ts {

commit e4d26f4b080f55e9577b45e6b51a04971eb459e9
Author: Atzm Watanabe <atzm@stratosphere.co.jp>
Date:   Tue Dec 17 22:53:36 2013 +0900

    packet: fill the gap of TPACKET_ALIGNMENT with zeros
    
    struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.
    Explicitly defining and zeroing the gap of this makes additional changes
    easier.
    
    Signed-off-by: Atzm Watanabe <atzm@stratosphere.co.jp>
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 1e24aa701cbd..9185dc9a4485 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -133,7 +133,7 @@ struct tpacket2_hdr {
 	__u32		tp_sec;
 	__u32		tp_nsec;
 	__u16		tp_vlan_tci;
-	__u16		tp_padding;
+	__u8		tp_padding[6];
 };
 
 struct tpacket_hdr_variant1 {
@@ -154,6 +154,7 @@ struct tpacket3_hdr {
 	union {
 		struct tpacket_hdr_variant1 hv1;
 	};
+	__u8		tp_padding[12];
 };
 
 struct tpacket_bd_ts {

commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Dec 6 11:36:17 2013 +0100

    packet: introduce PACKET_QDISC_BYPASS socket option
    
    This patch introduces a PACKET_QDISC_BYPASS socket option, that
    allows for using a similar xmit() function as in pktgen instead
    of taking the dev_queue_xmit() path. This can be very useful when
    PF_PACKET applications are required to be used in a similar
    scenario as pktgen, but with full, flexible packet payload that
    needs to be provided, for example.
    
    On default, nothing changes in behaviour for normal PF_PACKET
    TX users, so everything stays as is for applications. New users,
    however, can now set PACKET_QDISC_BYPASS if needed to prevent
    own packets from i) reentering packet_rcv() and ii) to directly
    push the frame to the driver.
    
    In doing so we can increase pps (here 64 byte packets) for
    PF_PACKET a bit:
    
      # CPUs -- QDISC_BYPASS   -- qdisc path -- qdisc path[**]
      1 CPU  ==  1,509,628 pps --  1,208,708 --  1,247,436
      2 CPUs ==  3,198,659 pps --  2,536,012 --  1,605,779
      3 CPUs ==  4,787,992 pps --  3,788,740 --  1,735,610
      4 CPUs ==  6,173,956 pps --  4,907,799 --  1,909,114
      5 CPUs ==  7,495,676 pps --  5,956,499 --  2,014,422
      6 CPUs ==  9,001,496 pps --  7,145,064 --  2,155,261
      7 CPUs == 10,229,776 pps --  8,190,596 --  2,220,619
      8 CPUs == 11,040,732 pps --  9,188,544 --  2,241,879
      9 CPUs == 12,009,076 pps -- 10,275,936 --  2,068,447
     10 CPUs == 11,380,052 pps -- 11,265,337 --  1,578,689
     11 CPUs == 11,672,676 pps -- 11,845,344 --  1,297,412
     [...]
     20 CPUs == 11,363,192 pps -- 11,014,933 --  1,245,081
    
     [**]: qdisc path with packet_rcv(), how probably most people
           seem to use it (hopefully not anymore if not needed)
    
    The test was done using a modified trafgen, sending a simple
    static 64 bytes packet, on all CPUs.  The trick in the fast
    "qdisc path" case, is to avoid reentering packet_rcv() by
    setting the RAW socket protocol to zero, like:
    socket(PF_PACKET, SOCK_RAW, 0);
    
    Tradeoffs are documented as well in this patch, clearly, if
    queues are busy, we will drop more packets, tc disciplines are
    ignored, and these packets are not visible to taps anymore. For
    a pktgen like scenario, we argue that this is acceptable.
    
    The pointer to the xmit function has been placed in packet
    socket structure hole between cached_dev and prot_hook that
    is hot anyway as we're working on cached_dev in each send path.
    
    Done in joint work together with Jesper Dangaard Brouer.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index dbf06667394b..1e24aa701cbd 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -51,6 +51,7 @@ struct sockaddr_ll {
 #define PACKET_TIMESTAMP		17
 #define PACKET_FANOUT			18
 #define PACKET_TX_HAS_OFF		19
+#define PACKET_QDISC_BYPASS		20
 
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1

commit 5df0ddfbc9209ffafc82236509ba0e975120e3c3
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Aug 28 22:13:09 2013 +0200

    net: packet: add randomized fanout scheduler
    
    We currently allow for different fanout scheduling policies in pf_packet
    such as scheduling by skb's rxhash, round-robin, by cpu, and rollover.
    Also allow for a random, equidistributed selection of the socket from the
    fanout process group.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index b950c02030c0..dbf06667394b 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -56,6 +56,7 @@ struct sockaddr_ll {
 #define PACKET_FANOUT_LB		1
 #define PACKET_FANOUT_CPU		2
 #define PACKET_FANOUT_ROLLOVER		3
+#define PACKET_FANOUT_RND		4
 #define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
 #define PACKET_FANOUT_FLAG_DEFRAG	0x8000
 

commit b9c32fb2717094231b31a7d7dcf5fd7f3638ac2f
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 23 00:39:31 2013 +0000

    packet: if hw/sw ts enabled in rx/tx ring, report which ts we got
    
    Currently, there is no way to find out which timestamp is reported in
    tpacket{,2,3}_hdr's tp_sec, tp_{n,u}sec members. It can be one of
    SOF_TIMESTAMPING_SYS_HARDWARE, SOF_TIMESTAMPING_RAW_HARDWARE,
    SOF_TIMESTAMPING_SOFTWARE, or a fallback variant late call from the
    PF_PACKET code in software.
    
    Therefore, report in the tp_status member of the ring buffer which
    timestamp has been reported for RX and TX path. This should not break
    anything for the following reasons: i) in RX ring path, the user needs
    to test for tp_status & TP_STATUS_USER, and later for other flags as
    well such as TP_STATUS_VLAN_VALID et al, so adding other flags will
    do no harm; ii) in TX ring path, time stamps with PACKET_TIMESTAMP
    socketoption are not available resp. had no effect except that the
    application setting this is buggy. Next to TP_STATUS_AVAILABLE, the
    user also should check for other flags such as TP_STATUS_WRONG_FORMAT
    to reclaim frames to the application. Thus, in case TX ts are turned
    off (default case), nothing happens to the application logic, and in
    case we want to use this new feature, we now can also check which of
    the ts source is reported in the status field as provided in the docs.
    
    Reported-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 4dfc234d80e5..b950c02030c0 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -100,6 +100,11 @@ struct tpacket_auxdata {
 #define TP_STATUS_SENDING	(1 << 1)
 #define TP_STATUS_WRONG_FORMAT	(1 << 2)
 
+/* Rx and Tx ring - header status */
+#define TP_STATUS_TS_SOFTWARE		(1 << 29)
+#define TP_STATUS_TS_SYS_HARDWARE	(1 << 30)
+#define TP_STATUS_TS_RAW_HARDWARE	(1 << 31)
+
 /* Rx ring - feature request bits */
 #define TP_FT_REQ_FILL_RXHASH	0x1
 

commit 7276d5d743d775388bf382cd7bdea1a14e486d32
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Tue Apr 23 00:39:30 2013 +0000

    packet: minor: convert status bits into shifting format
    
    This makes it more readable and clearer what bits are still free to
    use. The compiler reduces this to a constant for us anyway.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index 8136658ea477..4dfc234d80e5 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -86,19 +86,19 @@ struct tpacket_auxdata {
 };
 
 /* Rx ring - header status */
-#define TP_STATUS_KERNEL	0x0
-#define TP_STATUS_USER		0x1
-#define TP_STATUS_COPY		0x2
-#define TP_STATUS_LOSING	0x4
-#define TP_STATUS_CSUMNOTREADY	0x8
-#define TP_STATUS_VLAN_VALID   0x10 /* auxdata has valid tp_vlan_tci */
-#define TP_STATUS_BLK_TMO	0x20
+#define TP_STATUS_KERNEL	      0
+#define TP_STATUS_USER		(1 << 0)
+#define TP_STATUS_COPY		(1 << 1)
+#define TP_STATUS_LOSING	(1 << 2)
+#define TP_STATUS_CSUMNOTREADY	(1 << 3)
+#define TP_STATUS_VLAN_VALID	(1 << 4) /* auxdata has valid tp_vlan_tci */
+#define TP_STATUS_BLK_TMO	(1 << 5)
 
 /* Tx ring - header status */
-#define TP_STATUS_AVAILABLE	0x0
-#define TP_STATUS_SEND_REQUEST	0x1
-#define TP_STATUS_SENDING	0x2
-#define TP_STATUS_WRONG_FORMAT	0x4
+#define TP_STATUS_AVAILABLE	      0
+#define TP_STATUS_SEND_REQUEST	(1 << 0)
+#define TP_STATUS_SENDING	(1 << 1)
+#define TP_STATUS_WRONG_FORMAT	(1 << 2)
 
 /* Rx ring - feature request bits */
 #define TP_FT_REQ_FILL_RXHASH	0x1

commit 77f65ebdca506870d99bfabe52bde222511022ec
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue Mar 19 10:18:11 2013 +0000

    packet: packet fanout rollover during socket overload
    
    Changes:
      v3->v2: rebase (no other changes)
              passes selftest
      v2->v1: read f->num_members only once
              fix bug: test rollover mode + flag
    
    Minimize packet drop in a fanout group. If one socket is full,
    roll over packets to another from the group. Maintain flow
    affinity during normal load using an rxhash fanout policy, while
    dispersing unexpected traffic storms that hit a single cpu, such
    as spoofed-source DoS flows. Rollover breaks affinity for flows
    arriving at saturated sockets during those conditions.
    
    The patch adds a fanout policy ROLLOVER that rotates between sockets,
    filling each socket before moving to the next. It also adds a fanout
    flag ROLLOVER. If passed along with any other fanout policy, the
    primary policy is applied until the chosen socket is full. Then,
    rollover selects another socket, to delay packet drop until the
    entire system is saturated.
    
    Probing sockets is not free. Selecting the last used socket, as
    rollover does, is a greedy approach that maximizes chance of
    success, at the cost of extreme load imbalance. In practice, with
    sufficiently long queues to absorb bursts, sockets are drained in
    parallel and load balance looks uniform in `top`.
    
    To avoid contention, scales counters with number of sockets and
    accesses them lockfree. Values are bounds checked to ensure
    correctness.
    
    Tested using an application with 9 threads pinned to CPUs, one socket
    per thread and sufficient busywork per packet operation to limits each
    thread to handling 32 Kpps. When sent 500 Kpps single UDP stream
    packets, a FANOUT_CPU setup processes 32 Kpps in total without this
    patch, 270 Kpps with the patch. Tested with read() and with a packet
    ring (V1).
    
    Also, passes psock_fanout.c unit test added to selftests.
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index f9a60375f0d0..8136658ea477 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -55,6 +55,8 @@ struct sockaddr_ll {
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1
 #define PACKET_FANOUT_CPU		2
+#define PACKET_FANOUT_ROLLOVER		3
+#define PACKET_FANOUT_FLAG_ROLLOVER	0x1000
 #define PACKET_FANOUT_FLAG_DEFRAG	0x8000
 
 struct tpacket_stats {

commit 5920cd3a41f1aefc30e9ce86384fc2fe9f5fe0c0
Author: Paul Chavent <Paul.Chavent@onera.fr>
Date:   Tue Nov 6 23:10:47 2012 +0000

    packet: tx_ring: allow the user to choose tx data offset
    
    The tx data offset of packet mmap tx ring used to be :
    (TPACKET2_HDRLEN - sizeof(struct sockaddr_ll))
    
    The problem is that, with SOCK_RAW socket, the payload (14 bytes after
    the beginning of the user data) is misaligned.
    
    This patch allows to let the user gives an offset for it's tx data if
    he desires.
    
    Set sock option PACKET_TX_HAS_OFF to 1, then specify in each frame of
    your tx ring tp_net for SOCK_DGRAM, or tp_mac for SOCK_RAW.
    
    Signed-off-by: Paul Chavent <paul.chavent@onera.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
index f3799295d231..f9a60375f0d0 100644
--- a/include/uapi/linux/if_packet.h
+++ b/include/uapi/linux/if_packet.h
@@ -50,6 +50,7 @@ struct sockaddr_ll {
 #define PACKET_TX_TIMESTAMP		16
 #define PACKET_TIMESTAMP		17
 #define PACKET_FANOUT			18
+#define PACKET_TX_HAS_OFF		19
 
 #define PACKET_FANOUT_HASH		0
 #define PACKET_FANOUT_LB		1

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/if_packet.h b/include/uapi/linux/if_packet.h
new file mode 100644
index 000000000000..f3799295d231
--- /dev/null
+++ b/include/uapi/linux/if_packet.h
@@ -0,0 +1,272 @@
+#ifndef __LINUX_IF_PACKET_H
+#define __LINUX_IF_PACKET_H
+
+#include <linux/types.h>
+
+struct sockaddr_pkt {
+	unsigned short spkt_family;
+	unsigned char spkt_device[14];
+	__be16 spkt_protocol;
+};
+
+struct sockaddr_ll {
+	unsigned short	sll_family;
+	__be16		sll_protocol;
+	int		sll_ifindex;
+	unsigned short	sll_hatype;
+	unsigned char	sll_pkttype;
+	unsigned char	sll_halen;
+	unsigned char	sll_addr[8];
+};
+
+/* Packet types */
+
+#define PACKET_HOST		0		/* To us		*/
+#define PACKET_BROADCAST	1		/* To all		*/
+#define PACKET_MULTICAST	2		/* To group		*/
+#define PACKET_OTHERHOST	3		/* To someone else 	*/
+#define PACKET_OUTGOING		4		/* Outgoing of any type */
+/* These ones are invisible by user level */
+#define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
+#define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
+
+/* Packet socket options */
+
+#define PACKET_ADD_MEMBERSHIP		1
+#define PACKET_DROP_MEMBERSHIP		2
+#define PACKET_RECV_OUTPUT		3
+/* Value 4 is still used by obsolete turbo-packet. */
+#define PACKET_RX_RING			5
+#define PACKET_STATISTICS		6
+#define PACKET_COPY_THRESH		7
+#define PACKET_AUXDATA			8
+#define PACKET_ORIGDEV			9
+#define PACKET_VERSION			10
+#define PACKET_HDRLEN			11
+#define PACKET_RESERVE			12
+#define PACKET_TX_RING			13
+#define PACKET_LOSS			14
+#define PACKET_VNET_HDR			15
+#define PACKET_TX_TIMESTAMP		16
+#define PACKET_TIMESTAMP		17
+#define PACKET_FANOUT			18
+
+#define PACKET_FANOUT_HASH		0
+#define PACKET_FANOUT_LB		1
+#define PACKET_FANOUT_CPU		2
+#define PACKET_FANOUT_FLAG_DEFRAG	0x8000
+
+struct tpacket_stats {
+	unsigned int	tp_packets;
+	unsigned int	tp_drops;
+};
+
+struct tpacket_stats_v3 {
+	unsigned int	tp_packets;
+	unsigned int	tp_drops;
+	unsigned int	tp_freeze_q_cnt;
+};
+
+union tpacket_stats_u {
+	struct tpacket_stats stats1;
+	struct tpacket_stats_v3 stats3;
+};
+
+struct tpacket_auxdata {
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u16		tp_vlan_tci;
+	__u16		tp_padding;
+};
+
+/* Rx ring - header status */
+#define TP_STATUS_KERNEL	0x0
+#define TP_STATUS_USER		0x1
+#define TP_STATUS_COPY		0x2
+#define TP_STATUS_LOSING	0x4
+#define TP_STATUS_CSUMNOTREADY	0x8
+#define TP_STATUS_VLAN_VALID   0x10 /* auxdata has valid tp_vlan_tci */
+#define TP_STATUS_BLK_TMO	0x20
+
+/* Tx ring - header status */
+#define TP_STATUS_AVAILABLE	0x0
+#define TP_STATUS_SEND_REQUEST	0x1
+#define TP_STATUS_SENDING	0x2
+#define TP_STATUS_WRONG_FORMAT	0x4
+
+/* Rx ring - feature request bits */
+#define TP_FT_REQ_FILL_RXHASH	0x1
+
+struct tpacket_hdr {
+	unsigned long	tp_status;
+	unsigned int	tp_len;
+	unsigned int	tp_snaplen;
+	unsigned short	tp_mac;
+	unsigned short	tp_net;
+	unsigned int	tp_sec;
+	unsigned int	tp_usec;
+};
+
+#define TPACKET_ALIGNMENT	16
+#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
+#define TPACKET_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + sizeof(struct sockaddr_ll))
+
+struct tpacket2_hdr {
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u32		tp_sec;
+	__u32		tp_nsec;
+	__u16		tp_vlan_tci;
+	__u16		tp_padding;
+};
+
+struct tpacket_hdr_variant1 {
+	__u32	tp_rxhash;
+	__u32	tp_vlan_tci;
+};
+
+struct tpacket3_hdr {
+	__u32		tp_next_offset;
+	__u32		tp_sec;
+	__u32		tp_nsec;
+	__u32		tp_snaplen;
+	__u32		tp_len;
+	__u32		tp_status;
+	__u16		tp_mac;
+	__u16		tp_net;
+	/* pkt_hdr variants */
+	union {
+		struct tpacket_hdr_variant1 hv1;
+	};
+};
+
+struct tpacket_bd_ts {
+	unsigned int ts_sec;
+	union {
+		unsigned int ts_usec;
+		unsigned int ts_nsec;
+	};
+};
+
+struct tpacket_hdr_v1 {
+	__u32	block_status;
+	__u32	num_pkts;
+	__u32	offset_to_first_pkt;
+
+	/* Number of valid bytes (including padding)
+	 * blk_len <= tp_block_size
+	 */
+	__u32	blk_len;
+
+	/*
+	 * Quite a few uses of sequence number:
+	 * 1. Make sure cache flush etc worked.
+	 *    Well, one can argue - why not use the increasing ts below?
+	 *    But look at 2. below first.
+	 * 2. When you pass around blocks to other user space decoders,
+	 *    you can see which blk[s] is[are] outstanding etc.
+	 * 3. Validate kernel code.
+	 */
+	__aligned_u64	seq_num;
+
+	/*
+	 * ts_last_pkt:
+	 *
+	 * Case 1.	Block has 'N'(N >=1) packets and TMO'd(timed out)
+	 *		ts_last_pkt == 'time-stamp of last packet' and NOT the
+	 *		time when the timer fired and the block was closed.
+	 *		By providing the ts of the last packet we can absolutely
+	 *		guarantee that time-stamp wise, the first packet in the
+	 *		next block will never precede the last packet of the
+	 *		previous block.
+	 * Case 2.	Block has zero packets and TMO'd
+	 *		ts_last_pkt = time when the timer fired and the block
+	 *		was closed.
+	 * Case 3.	Block has 'N' packets and NO TMO.
+	 *		ts_last_pkt = time-stamp of the last pkt in the block.
+	 *
+	 * ts_first_pkt:
+	 *		Is always the time-stamp when the block was opened.
+	 *		Case a)	ZERO packets
+	 *			No packets to deal with but atleast you know the
+	 *			time-interval of this block.
+	 *		Case b) Non-zero packets
+	 *			Use the ts of the first packet in the block.
+	 *
+	 */
+	struct tpacket_bd_ts	ts_first_pkt, ts_last_pkt;
+};
+
+union tpacket_bd_header_u {
+	struct tpacket_hdr_v1 bh1;
+};
+
+struct tpacket_block_desc {
+	__u32 version;
+	__u32 offset_to_priv;
+	union tpacket_bd_header_u hdr;
+};
+
+#define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))
+#define TPACKET3_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket3_hdr)) + sizeof(struct sockaddr_ll))
+
+enum tpacket_versions {
+	TPACKET_V1,
+	TPACKET_V2,
+	TPACKET_V3
+};
+
+/*
+   Frame structure:
+
+   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
+   - struct tpacket_hdr
+   - pad to TPACKET_ALIGNMENT=16
+   - struct sockaddr_ll
+   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
+   - Start+tp_mac: [ Optional MAC header ]
+   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
+   - Pad to align to TPACKET_ALIGNMENT=16
+ */
+
+struct tpacket_req {
+	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
+	unsigned int	tp_block_nr;	/* Number of blocks */
+	unsigned int	tp_frame_size;	/* Size of frame */
+	unsigned int	tp_frame_nr;	/* Total number of frames */
+};
+
+struct tpacket_req3 {
+	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
+	unsigned int	tp_block_nr;	/* Number of blocks */
+	unsigned int	tp_frame_size;	/* Size of frame */
+	unsigned int	tp_frame_nr;	/* Total number of frames */
+	unsigned int	tp_retire_blk_tov; /* timeout in msecs */
+	unsigned int	tp_sizeof_priv; /* offset to private data area */
+	unsigned int	tp_feature_req_word;
+};
+
+union tpacket_req_u {
+	struct tpacket_req	req;
+	struct tpacket_req3	req3;
+};
+
+struct packet_mreq {
+	int		mr_ifindex;
+	unsigned short	mr_type;
+	unsigned short	mr_alen;
+	unsigned char	mr_address[8];
+};
+
+#define PACKET_MR_MULTICAST	0
+#define PACKET_MR_PROMISC	1
+#define PACKET_MR_ALLMULTI	2
+#define PACKET_MR_UNICAST	3
+
+#endif
