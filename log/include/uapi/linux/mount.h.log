commit cf3cba4a429be43e5527a3f78859b1bfd9ebc5fb
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:36:23 2018 +0000

    vfs: syscall: Add fspick() to select a superblock for reconfiguration
    
    Provide an fspick() system call that can be used to pick an existing
    mountpoint into an fs_context which can thereafter be used to reconfigure a
    superblock (equivalent of the superblock side of -o remount).
    
    This looks like:
    
            int fd = fspick(AT_FDCWD, "/mnt",
                            FSPICK_CLOEXEC | FSPICK_NO_AUTOMOUNT);
            fsconfig(fd, FSCONFIG_SET_FLAG, "intr", NULL, 0);
            fsconfig(fd, FSCONFIG_SET_FLAG, "noac", NULL, 0);
            fsconfig(fd, FSCONFIG_CMD_RECONFIGURE, NULL, NULL, 0);
    
    At the point of fspick being called, the file descriptor referring to the
    filesystem context is in exactly the same state as the one that was created
    by fsopen() after fsmount() has been successfully called.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
index 3888d3b91dc5..96a0240f23fe 100644
--- a/include/uapi/linux/mount.h
+++ b/include/uapi/linux/mount.h
@@ -77,6 +77,14 @@
  */
 #define FSOPEN_CLOEXEC		0x00000001
 
+/*
+ * fspick() flags.
+ */
+#define FSPICK_CLOEXEC		0x00000001
+#define FSPICK_SYMLINK_NOFOLLOW	0x00000002
+#define FSPICK_NO_AUTOMOUNT	0x00000004
+#define FSPICK_EMPTY_PATH	0x00000008
+
 /*
  * The type of fsconfig() call made.
  */

commit 93766fbd2696c2c4453dd8e1070977e9cd4e6b6d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:36:14 2018 +0000

    vfs: syscall: Add fsmount() to create a mount for a superblock
    
    Provide a system call by which a filesystem opened with fsopen() and
    configured by a series of fsconfig() calls can have a detached mount object
    created for it.  This mount object can then be attached to the VFS mount
    hierarchy using move_mount() by passing the returned file descriptor as the
    from directory fd.
    
    The system call looks like:
    
            int mfd = fsmount(int fsfd, unsigned int flags,
                              unsigned int attr_flags);
    
    where fsfd is the file descriptor returned by fsopen().  flags can be 0 or
    FSMOUNT_CLOEXEC.  attr_flags is a bitwise-OR of the following flags:
    
            MOUNT_ATTR_RDONLY       Mount read-only
            MOUNT_ATTR_NOSUID       Ignore suid and sgid bits
            MOUNT_ATTR_NODEV        Disallow access to device special files
            MOUNT_ATTR_NOEXEC       Disallow program execution
            MOUNT_ATTR__ATIME       Setting on how atime should be updated
            MOUNT_ATTR_RELATIME     - Update atime relative to mtime/ctime
            MOUNT_ATTR_NOATIME      - Do not update access times
            MOUNT_ATTR_STRICTATIME  - Always perform atime updates
            MOUNT_ATTR_NODIRATIME   Do not update directory access times
    
    In the event that fsmount() fails, it may be possible to get an error
    message by calling read() on fsfd.  If no message is available, ENODATA
    will be reported.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
index 4b90ba9d1770..3888d3b91dc5 100644
--- a/include/uapi/linux/mount.h
+++ b/include/uapi/linux/mount.h
@@ -91,4 +91,22 @@ enum fsconfig_command {
 	FSCONFIG_CMD_RECONFIGURE = 7,	/* Invoke superblock reconfiguration */
 };
 
+/*
+ * fsmount() flags.
+ */
+#define FSMOUNT_CLOEXEC		0x00000001
+
+/*
+ * Mount attributes.
+ */
+#define MOUNT_ATTR_RDONLY	0x00000001 /* Mount read-only */
+#define MOUNT_ATTR_NOSUID	0x00000002 /* Ignore suid and sgid bits */
+#define MOUNT_ATTR_NODEV	0x00000004 /* Disallow access to device special files */
+#define MOUNT_ATTR_NOEXEC	0x00000008 /* Disallow program execution */
+#define MOUNT_ATTR__ATIME	0x00000070 /* Setting on how atime should be updated */
+#define MOUNT_ATTR_RELATIME	0x00000000 /* - Update atime relative to mtime/ctime. */
+#define MOUNT_ATTR_NOATIME	0x00000010 /* - Do not update access times. */
+#define MOUNT_ATTR_STRICTATIME	0x00000020 /* - Always perform atime updates */
+#define MOUNT_ATTR_NODIRATIME	0x00000080 /* Do not update directory access times */
+
 #endif /* _UAPI_LINUX_MOUNT_H */

commit ecdab150fddb42fe6a739335257949220033b782
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:36:09 2018 +0000

    vfs: syscall: Add fsconfig() for configuring and managing a context
    
    Add a syscall for configuring a filesystem creation context and triggering
    actions upon it, to be used in conjunction with fsopen, fspick and fsmount.
    
        long fsconfig(int fs_fd, unsigned int cmd, const char *key,
                      const void *value, int aux);
    
    Where fs_fd indicates the context, cmd indicates the action to take, key
    indicates the parameter name for parameter-setting actions and, if needed,
    value points to a buffer containing the value and aux can give more
    information for the value.
    
    The following command IDs are proposed:
    
     (*) FSCONFIG_SET_FLAG: No value is specified.  The parameter must be
         boolean in nature.  The key may be prefixed with "no" to invert the
         setting. value must be NULL and aux must be 0.
    
     (*) FSCONFIG_SET_STRING: A string value is specified.  The parameter can
         be expecting boolean, integer, string or take a path.  A conversion to
         an appropriate type will be attempted (which may include looking up as
         a path).  value points to a NUL-terminated string and aux must be 0.
    
     (*) FSCONFIG_SET_BINARY: A binary blob is specified.  value points to
         the blob and aux indicates its size.  The parameter must be expecting
         a blob.
    
     (*) FSCONFIG_SET_PATH: A non-empty path is specified.  The parameter must
         be expecting a path object.  value points to a NUL-terminated string
         that is the path and aux is a file descriptor at which to start a
         relative lookup or AT_FDCWD.
    
     (*) FSCONFIG_SET_PATH_EMPTY: As fsconfig_set_path, but with AT_EMPTY_PATH
         implied.
    
     (*) FSCONFIG_SET_FD: An open file descriptor is specified.  value must
         be NULL and aux indicates the file descriptor.
    
     (*) FSCONFIG_CMD_CREATE: Trigger superblock creation.
    
     (*) FSCONFIG_CMD_RECONFIGURE: Trigger superblock reconfiguration.
    
    For the "set" command IDs, the idea is that the file_system_type will point
    to a list of parameters and the types of value that those parameters expect
    to take.  The core code can then do the parse and argument conversion and
    then give the LSM and FS a cooked option or array of options to use.
    
    Source specification is also done the same way same way, using special keys
    "source", "source1", "source2", etc..
    
    [!] Note that, for the moment, the key and value are just glued back
    together and handed to the filesystem.  Every filesystem that uses options
    uses match_token() and co. to do this, and this will need to be changed -
    but not all at once.
    
    Example usage:
    
        fd = fsopen("ext4", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_path, "source", "/dev/sda1", AT_FDCWD);
        fsconfig(fd, fsconfig_set_path_empty, "journal_path", "", journal_fd);
        fsconfig(fd, fsconfig_set_fd, "journal_fd", "", journal_fd);
        fsconfig(fd, fsconfig_set_flag, "user_xattr", NULL, 0);
        fsconfig(fd, fsconfig_set_flag, "noacl", NULL, 0);
        fsconfig(fd, fsconfig_set_string, "sb", "1", 0);
        fsconfig(fd, fsconfig_set_string, "errors", "continue", 0);
        fsconfig(fd, fsconfig_set_string, "data", "journal", 0);
        fsconfig(fd, fsconfig_set_string, "context", "unconfined_u:...", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("ext4", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "/dev/sda1", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("afs", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "#grand.central.org:root.cell", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    or:
    
        fd = fsopen("jffs2", FSOPEN_CLOEXEC);
        fsconfig(fd, fsconfig_set_string, "source", "mtd0", 0);
        fsconfig(fd, fsconfig_cmd_create, NULL, NULL, 0);
        mfd = fsmount(fd, FSMOUNT_CLOEXEC, MS_NOEXEC);
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
index 7570df43d08f..4b90ba9d1770 100644
--- a/include/uapi/linux/mount.h
+++ b/include/uapi/linux/mount.h
@@ -77,4 +77,18 @@
  */
 #define FSOPEN_CLOEXEC		0x00000001
 
+/*
+ * The type of fsconfig() call made.
+ */
+enum fsconfig_command {
+	FSCONFIG_SET_FLAG	= 0,	/* Set parameter, supplying no value */
+	FSCONFIG_SET_STRING	= 1,	/* Set parameter, supplying a string value */
+	FSCONFIG_SET_BINARY	= 2,	/* Set parameter, supplying a binary blob value */
+	FSCONFIG_SET_PATH	= 3,	/* Set parameter, supplying an object by path */
+	FSCONFIG_SET_PATH_EMPTY	= 4,	/* Set parameter, supplying an object by (empty) path */
+	FSCONFIG_SET_FD		= 5,	/* Set parameter, supplying an object by fd */
+	FSCONFIG_CMD_CREATE	= 6,	/* Invoke superblock creation */
+	FSCONFIG_CMD_RECONFIGURE = 7,	/* Invoke superblock reconfiguration */
+};
+
 #endif /* _UAPI_LINUX_MOUNT_H */

commit 24dcb3d90a1f67fe08c68a004af37df059d74005
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:33:31 2018 +0000

    vfs: syscall: Add fsopen() to prepare for superblock creation
    
    Provide an fsopen() system call that starts the process of preparing to
    create a superblock that will then be mountable, using an fd as a context
    handle.  fsopen() is given the name of the filesystem that will be used:
    
            int mfd = fsopen(const char *fsname, unsigned int flags);
    
    where flags can be 0 or FSOPEN_CLOEXEC.
    
    For example:
    
            sfd = fsopen("ext4", FSOPEN_CLOEXEC);
            fsconfig(sfd, FSCONFIG_SET_PATH, "source", "/dev/sda1", AT_FDCWD);
            fsconfig(sfd, FSCONFIG_SET_FLAG, "noatime", NULL, 0);
            fsconfig(sfd, FSCONFIG_SET_FLAG, "acl", NULL, 0);
            fsconfig(sfd, FSCONFIG_SET_FLAG, "user_xattr", NULL, 0);
            fsconfig(sfd, FSCONFIG_SET_STRING, "sb", "1", 0);
            fsconfig(sfd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);
            fsinfo(sfd, NULL, ...); // query new superblock attributes
            mfd = fsmount(sfd, FSMOUNT_CLOEXEC, MS_RELATIME);
            move_mount(mfd, "", sfd, AT_FDCWD, "/mnt", MOVE_MOUNT_F_EMPTY_PATH);
    
            sfd = fsopen("afs", -1);
            fsconfig(fd, FSCONFIG_SET_STRING, "source",
                     "#grand.central.org:root.cell", 0);
            fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);
            mfd = fsmount(sfd, 0, MS_NODEV);
            move_mount(mfd, "", sfd, AT_FDCWD, "/mnt", MOVE_MOUNT_F_EMPTY_PATH);
    
    If an error is reported at any step, an error message may be available to be
    read() back (ENODATA will be reported if there isn't an error available) in
    the form:
    
            "e <subsys>:<problem>"
            "e SELinux:Mount on mountpoint not permitted"
    
    Once fsmount() has been called, further fsconfig() calls will incur EBUSY,
    even if the fsmount() fails.  read() is still possible to retrieve error
    information.
    
    The fsopen() syscall creates a mount context and hangs it of the fd that it
    returns.
    
    Netlink is not used because it is optional and would make the core VFS
    dependent on the networking layer and also potentially add network
    namespace issues.
    
    Note that, for the moment, the caller must have SYS_CAP_ADMIN to use
    fsopen().
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
index 3634e065836c..7570df43d08f 100644
--- a/include/uapi/linux/mount.h
+++ b/include/uapi/linux/mount.h
@@ -72,4 +72,9 @@
 #define MOVE_MOUNT_T_EMPTY_PATH		0x00000040 /* Empty to path permitted */
 #define MOVE_MOUNT__MASK		0x00000077
 
+/*
+ * fsopen() flags.
+ */
+#define FSOPEN_CLOEXEC		0x00000001
+
 #endif /* _UAPI_LINUX_MOUNT_H */

commit 2db154b3ea8e14b04fee23e3fdfd5e9d17fbc6ae
Author: David Howells <dhowells@redhat.com>
Date:   Mon Nov 5 17:40:30 2018 +0000

    vfs: syscall: Add move_mount(2) to move mounts around
    
    Add a move_mount() system call that will move a mount from one place to
    another and, in the next commit, allow to attach an unattached mount tree.
    
    The new system call looks like the following:
    
            int move_mount(int from_dfd, const char *from_path,
                           int to_dfd, const char *to_path,
                           unsigned int flags);
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
index fd7ae2e7eccf..3634e065836c 100644
--- a/include/uapi/linux/mount.h
+++ b/include/uapi/linux/mount.h
@@ -61,4 +61,15 @@
 #define OPEN_TREE_CLONE		1		/* Clone the target tree and attach the clone */
 #define OPEN_TREE_CLOEXEC	O_CLOEXEC	/* Close the file on execve() */
 
+/*
+ * move_mount() flags.
+ */
+#define MOVE_MOUNT_F_SYMLINKS		0x00000001 /* Follow symlinks on from path */
+#define MOVE_MOUNT_F_AUTOMOUNTS		0x00000002 /* Follow automounts on from path */
+#define MOVE_MOUNT_F_EMPTY_PATH		0x00000004 /* Empty from path permitted */
+#define MOVE_MOUNT_T_SYMLINKS		0x00000010 /* Follow symlinks on to path */
+#define MOVE_MOUNT_T_AUTOMOUNTS		0x00000020 /* Follow automounts on to path */
+#define MOVE_MOUNT_T_EMPTY_PATH		0x00000040 /* Empty to path permitted */
+#define MOVE_MOUNT__MASK		0x00000077
+
 #endif /* _UAPI_LINUX_MOUNT_H */

commit a07b20004793d8926f78d63eb5980559f7813404
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 5 17:40:30 2018 +0000

    vfs: syscall: Add open_tree(2) to reference or clone a mount
    
    open_tree(dfd, pathname, flags)
    
    Returns an O_PATH-opened file descriptor or an error.
    dfd and pathname specify the location to open, in usual
    fashion (see e.g. fstatat(2)).  flags should be an OR of
    some of the following:
            * AT_PATH_EMPTY, AT_NO_AUTOMOUNT, AT_SYMLINK_NOFOLLOW -
    same meanings as usual
            * OPEN_TREE_CLOEXEC - make the resulting descriptor
    close-on-exec
            * OPEN_TREE_CLONE or OPEN_TREE_CLONE | AT_RECURSIVE -
    instead of opening the location in question, create a detached
    mount tree matching the subtree rooted at location specified by
    dfd/pathname.  With AT_RECURSIVE the entire subtree is cloned,
    without it - only the part within in the mount containing the
    location in question.  In other words, the same as mount --rbind
    or mount --bind would've taken.  The detached tree will be
    dissolved on the final close of obtained file.  Creation of such
    detached trees requires the same capabilities as doing mount --bind.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
index 3f9ec42510b0..fd7ae2e7eccf 100644
--- a/include/uapi/linux/mount.h
+++ b/include/uapi/linux/mount.h
@@ -55,4 +55,10 @@
 #define MS_MGC_VAL 0xC0ED0000
 #define MS_MGC_MSK 0xffff0000
 
+/*
+ * open_tree() flags.
+ */
+#define OPEN_TREE_CLONE		1		/* Clone the target tree and attach the clone */
+#define OPEN_TREE_CLOEXEC	O_CLOEXEC	/* Close the file on execve() */
+
 #endif /* _UAPI_LINUX_MOUNT_H */

commit e262e32d6bde0f77fb0c95d977482fc872c51996
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:23 2018 +0000

    vfs: Suppress MS_* flag defs within the kernel unless explicitly enabled
    
    Only the mount namespace code that implements mount(2) should be using the
    MS_* flags.  Suppress them inside the kernel unless uapi/linux/mount.h is
    included.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: David Howells <dhowells@redhat.com>

diff --git a/include/uapi/linux/mount.h b/include/uapi/linux/mount.h
new file mode 100644
index 000000000000..3f9ec42510b0
--- /dev/null
+++ b/include/uapi/linux/mount.h
@@ -0,0 +1,58 @@
+#ifndef _UAPI_LINUX_MOUNT_H
+#define _UAPI_LINUX_MOUNT_H
+
+/*
+ * These are the fs-independent mount-flags: up to 32 flags are supported
+ *
+ * Usage of these is restricted within the kernel to core mount(2) code and
+ * callers of sys_mount() only.  Filesystems should be using the SB_*
+ * equivalent instead.
+ */
+#define MS_RDONLY	 1	/* Mount read-only */
+#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
+#define MS_NODEV	 4	/* Disallow access to device special files */
+#define MS_NOEXEC	 8	/* Disallow program execution */
+#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
+#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
+#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
+#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
+#define MS_NOATIME	1024	/* Do not update access times. */
+#define MS_NODIRATIME	2048	/* Do not update directory access times */
+#define MS_BIND		4096
+#define MS_MOVE		8192
+#define MS_REC		16384
+#define MS_VERBOSE	32768	/* War is peace. Verbosity is silence.
+				   MS_VERBOSE is deprecated. */
+#define MS_SILENT	32768
+#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
+#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
+#define MS_PRIVATE	(1<<18)	/* change to private */
+#define MS_SLAVE	(1<<19)	/* change to slave */
+#define MS_SHARED	(1<<20)	/* change to shared */
+#define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
+#define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
+#define MS_I_VERSION	(1<<23) /* Update inode I_version field */
+#define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
+#define MS_LAZYTIME	(1<<25) /* Update the on-disk [acm]times lazily */
+
+/* These sb flags are internal to the kernel */
+#define MS_SUBMOUNT     (1<<26)
+#define MS_NOREMOTELOCK	(1<<27)
+#define MS_NOSEC	(1<<28)
+#define MS_BORN		(1<<29)
+#define MS_ACTIVE	(1<<30)
+#define MS_NOUSER	(1<<31)
+
+/*
+ * Superblock flags that can be altered by MS_REMOUNT
+ */
+#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|\
+			 MS_LAZYTIME)
+
+/*
+ * Old magic mount flag and mask
+ */
+#define MS_MGC_VAL 0xC0ED0000
+#define MS_MGC_MSK 0xffff0000
+
+#endif /* _UAPI_LINUX_MOUNT_H */
