commit fb0255fb2941ef6f21742b2bc146d6b9aef4fedc
Merge: 449fcf3ab0ba 57f5d648c45c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 21:05:31 2017 -0800

    Merge tag 'tty-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial updates from Greg KH:
     "Here is the big tty/serial driver pull request for 4.15-rc1.
    
      Lots of serial driver updates in here, some small vt cleanups, and a
      raft of SPDX and license boilerplate cleanups, messing up the diffstat
      a bit.
    
      Nothing major, with no realy functional changes except better hardware
      support for some platforms.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'tty-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (110 commits)
      tty: ehv_bytechan: fix spelling mistake
      tty: serial: meson: allow baud-rates lower than 9600
      serial: 8250_fintek: Fix crash with baud rate B0
      serial: 8250_fintek: Disable delays for ports != 0
      serial: 8250_fintek: Return -EINVAL on invalid configuration
      tty: Remove redundant license text
      tty: serdev: Remove redundant license text
      tty: hvc: Remove redundant license text
      tty: serial: Remove redundant license text
      tty: add SPDX identifiers to all remaining files in drivers/tty/
      tty: serial: jsm: remove redundant pointer ts
      tty: serial: jsm: add space before the open parenthesis '('
      tty: serial: jsm: fix coding style
      tty: serial: jsm: delete space between function name and '('
      tty: serial: jsm: add blank line after declarations
      tty: serial: jsm: change the type of local variable
      tty: serial: imx: remove dead code imx_dma_rxint
      tty: serial: imx: disable ageing timer interrupt if dma in use
      serial: 8250: fix potential deadlock in rs485-mode
      serial: m32r_sio: Drop redundant .data assignment
      ...

commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 5db76880b4ad..619fe6111dc9 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-1.0+ WITH Linux-syscall-note */
 /*
  * include/linux/serial_reg.h
  *

commit 6263368c5b0b758d8639cad37a2a6493c9370425
Author: Ed Blake <ed.blake@sondrel.com>
Date:   Tue Sep 26 11:40:02 2017 +0100

    serial: Add define for max baud rate divisor
    
    Add a define for the maximum baud rate divisor, to improve code
    readability.
    
    Signed-off-by: Ed Blake <ed.blake@sondrel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 5db76880b4ad..dea05724c760 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -157,6 +157,7 @@
  */
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#define UART_DIV_MAX	0xFFFF	/* Max divisor value */
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)

commit 7e12357ed64afdc8e60d64b8f8f17d711acf950a
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Wed Feb 8 17:09:08 2017 +0100

    serial: exar: Move register defines from uapi header to consumer site
    
    None of these registers is relevant for the userspace API.
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 25b93a764a1a..5db76880b4ad 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -366,24 +366,6 @@
 #define UART_OMAP_MDR1_CIR_MODE		0x06	/* CIR mode */
 #define UART_OMAP_MDR1_DISABLE		0x07	/* Disable (default state) */
 
-/*
- * These are definitions for the Exar XR17V35X and XR17(C|D)15X
- */
-#define UART_EXAR_8XMODE	0x88	/* 8X sampling rate select */
-#define UART_EXAR_SLEEP		0x8b	/* Sleep mode */
-#define UART_EXAR_DVID		0x8d	/* Device identification */
-
-#define UART_EXAR_FCTR		0x08	/* Feature Control Register */
-#define UART_FCTR_EXAR_IRDA	0x10	/* IrDa data encode select */
-#define UART_FCTR_EXAR_485	0x20	/* Auto 485 half duplex dir ctl */
-#define UART_FCTR_EXAR_TRGA	0x00	/* FIFO trigger table A */
-#define UART_FCTR_EXAR_TRGB	0x60	/* FIFO trigger table B */
-#define UART_FCTR_EXAR_TRGC	0x80	/* FIFO trigger table C */
-#define UART_FCTR_EXAR_TRGD	0xc0	/* FIFO trigger table D programmable */
-
-#define UART_EXAR_TXTRG		0x0a	/* Tx FIFO trigger level write-only */
-#define UART_EXAR_RXTRG		0x0b	/* Rx FIFO trigger level write-only */
-
 /*
  * These are definitions for the Altera ALTR_16550_F32/F64/F128
  * Normalized from 0x100 to 0x40 because of shift by 2 (32 bit regs).

commit 7795753661f1a9423c3c8fbde322f6a2a8b94b68
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Wed Feb 8 17:09:05 2017 +0100

    serial: exar: Fix feature control register constants
    
    According to the XR17V352 manual, bit 4 is IrDA control and bit 5 for
    485. Fortunately, no driver used them so far.
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 274d8fc206e3..25b93a764a1a 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -374,8 +374,8 @@
 #define UART_EXAR_DVID		0x8d	/* Device identification */
 
 #define UART_EXAR_FCTR		0x08	/* Feature Control Register */
-#define UART_FCTR_EXAR_IRDA	0x08	/* IrDa data encode select */
-#define UART_FCTR_EXAR_485	0x10	/* Auto 485 half duplex dir ctl */
+#define UART_FCTR_EXAR_IRDA	0x10	/* IrDa data encode select */
+#define UART_FCTR_EXAR_485	0x20	/* Auto 485 half duplex dir ctl */
 #define UART_FCTR_EXAR_TRGA	0x00	/* FIFO trigger table A */
 #define UART_FCTR_EXAR_TRGB	0x60	/* FIFO trigger table B */
 #define UART_FCTR_EXAR_TRGC	0x80	/* FIFO trigger table C */

commit a2d6a987bfe4a2e344fae9d255200072eb082427
Author: David Lechner <david@lechnology.com>
Date:   Thu Jan 5 12:54:18 2017 -0600

    serial: 8250: Add new port type for TI DA8xx/66AK2x
    
    This adds a new UART port type for TI DA8xx/OMAPL13x/AM17xx/AM18xx/66AK2x.
    These SoCs have standard 8250 registers plus some extra non-standard
    registers.
    
    The UART will not function unless the non-standard Power and Emulation
    Management Register (PWREMU_MGMT) is configured correctly. This is
    currently handled in arch/arm/mach-davinci/serial.c for non-device-tree
    boards. Making this part of the UART driver will allow UART to work on
    device-tree boards as well and the mach code can eventually be removed.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Acked-by: Sekhar Nori <nsekhar@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index b4c04842a8c0..274d8fc206e3 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -327,6 +327,14 @@
 #define SERIAL_RSA_BAUD_BASE (921600)
 #define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
 
+/* Extra registers for TI DA8xx/66AK2x */
+#define UART_DA830_PWREMU_MGMT	12
+
+/* PWREMU_MGMT register bits */
+#define UART_DA830_PWREMU_MGMT_FREE	(1 << 0)  /* Free-running mode */
+#define UART_DA830_PWREMU_MGMT_URRST	(1 << 13) /* Receiver reset/enable */
+#define UART_DA830_PWREMU_MGMT_UTRST	(1 << 14) /* Transmitter reset/enable */
+
 /*
  * Extra serial register definitions for the internal UARTs
  * in TI OMAP processors.

commit 8e5470c9839caff94fe334e67ff7e7ace587282a
Author: Thor Thayer <tthayer@opensource.altera.com>
Date:   Thu Sep 22 14:56:16 2016 -0500

    serial: 8250: Set Altera 16550 TX FIFO Threshold
    
    The Altera 16550 soft IP UART requires 2 additional registers for
    TX FIFO threshold support. These 2 registers enable the TX FIFO
    Low Watermark and set the TX FIFO Low Watermark.
    Set the TX FIFO threshold to the FIFO size - tx_loadsz.
    
    Signed-off-by: Thor Thayer <tthayer@opensource.altera.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 1e5ac4e776da..b4c04842a8c0 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -376,5 +376,13 @@
 #define UART_EXAR_TXTRG		0x0a	/* Tx FIFO trigger level write-only */
 #define UART_EXAR_RXTRG		0x0b	/* Rx FIFO trigger level write-only */
 
+/*
+ * These are definitions for the Altera ALTR_16550_F32/F64/F128
+ * Normalized from 0x100 to 0x40 because of shift by 2 (32 bit regs).
+ */
+#define UART_ALTR_AFR		0x40	/* Additional Features Register */
+#define UART_ALTR_EN_TXFIFO_LW	0x01	/* Enable the TX FIFO Low Watermark */
+#define UART_ALTR_TX_LOW	0x41	/* Tx FIFO Low Watermark */
+
 #endif /* _LINUX_SERIAL_REG_H */
 

commit 928f81aa619d845d6faa5a459cdbc18b7a78ddce
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed May 20 09:01:20 2015 -0700

    ARM: OMAP1: Move UART defines to prepare for sparse IRQ
    
    These have been indirectly included via asm/irqs.h that
    has included mach/hardware.h unless SPARSE_IRQ is specified.
    Let's move them to where the other OMAP serial defines for
    8250 are.
    
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index e9b4cb0cd7ed..1e5ac4e776da 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -331,6 +331,9 @@
  * Extra serial register definitions for the internal UARTs
  * in TI OMAP processors.
  */
+#define OMAP1_UART1_BASE	0xfffb0000
+#define OMAP1_UART2_BASE	0xfffb0800
+#define OMAP1_UART3_BASE	0xfffb9800
 #define UART_OMAP_MDR1		0x08	/* Mode definition register */
 #define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
 #define UART_OMAP_SCR		0x10	/* Supplementary control register */

commit 1bd187de536494a27925902b9653e9ef0ace4774
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 23 16:24:44 2015 +0200

    x86, intel-mid: remove Intel MID specific serial support
    
    Since we have a native 8250 driver carrying the Intel MID serial devices the
    specific support is not needed anymore. This patch removes it for Intel MID.
    
    Note that the console device name is changed from ttyMFDx to ttySx.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 00adb01fa5f3..e9b4cb0cd7ed 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -241,25 +241,6 @@
 #define UART_FCR_PXAR16	0x80	/* receive FIFO threshold = 16 */
 #define UART_FCR_PXAR32	0xc0	/* receive FIFO threshold = 32 */
 
-/*
- * Intel MID on-chip HSU (High Speed UART) defined bits
- */
-#define UART_FCR_HSU_64_1B	0x00	/* receive FIFO treshold = 1 */
-#define UART_FCR_HSU_64_16B	0x40	/* receive FIFO treshold = 16 */
-#define UART_FCR_HSU_64_32B	0x80	/* receive FIFO treshold = 32 */
-#define UART_FCR_HSU_64_56B	0xc0	/* receive FIFO treshold = 56 */
-
-#define UART_FCR_HSU_16_1B	0x00	/* receive FIFO treshold = 1 */
-#define UART_FCR_HSU_16_4B	0x40	/* receive FIFO treshold = 4 */
-#define UART_FCR_HSU_16_8B	0x80	/* receive FIFO treshold = 8 */
-#define UART_FCR_HSU_16_14B	0xc0	/* receive FIFO treshold = 14 */
-
-#define UART_FCR_HSU_64B_FIFO	0x20	/* chose 64 bytes FIFO */
-#define UART_FCR_HSU_16B_FIFO	0x00	/* chose 16 bytes FIFO */
-
-#define UART_FCR_HALF_EMPT_TXI	0x00	/* trigger TX_EMPT IRQ for half empty */
-#define UART_FCR_FULL_EMPT_TXI	0x08	/* trigger TX_EMPT IRQ for full empty */
-
 /*
  * These register definitions are for the 16C950
  */

commit fddceb8b5399083bcc042266f188116cc779fc80
Author: Vijay Rai <vijay.rai@freescale.com>
Date:   Mon Jan 5 21:14:42 2015 +0530

    tty: 8250: Add 64byte UART support for FSL platforms
    
    Some of FSL SoCs like T1040 has new version of UART controller which
    can support 64byte FiFo.
    To enable 64 byte support, following needs to be done:
    -FCR[EN64] needs to be programmed to 1 to enable it.
    -Also, when FCR[EN64]==1, RTL bits to be used as below
    to define various Receive Trigger Levels:
            -FCR[RTL] = 00  1 byte
            -FCR[RTL] = 01  16 bytes
            -FCR[RTL] = 10  32 bytes
            -FCR[RTL] = 11  56 bytes
    -tx_loadsz is set to 63-bytes instead of 64-bytes to implement
     workaround of errata A-008006 which states that tx_loadsz should
     be configured less than Maximum supported fifo bytes
    
    Signed-off-by: Vijay Rai <vijay.rai@freescale.com>
    Signed-off-by: Priyanka Jain <Priyanka.Jain@freescale.com>
    Signed-off-by: Poonam Aggrwal <poonam.aggrwal@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 53af3b790129..00adb01fa5f3 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -86,7 +86,8 @@
 #define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
 #define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
-#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750 and
+					some Freescale UARTs) */
 
 #define UART_FCR_R_TRIG_SHIFT		6
 #define UART_FCR_R_TRIG_BITS(x)		\

commit 31a171328e870c9f65d01191e51a75cde5f78ffd
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Mon Sep 29 20:06:43 2014 +0200

    tty: serial: 8250_omap: add custom DMA-TX callback
    
    This patch provides mostly a copy of serial8250_tx_dma() +
    __dma_tx_complete() with the following extensions:
    
    - DMA bug
      At least on AM335x the following problem exists: Even if the TX FIFO is
      empty and a TX transfer is programmed (and started) the UART does not
      trigger the DMA transfer.
      After $TRESHOLD number of bytes have been written to the FIFO manually the
      UART reevaluates the whole situation and decides that now there is enough
      room in the FIFO and so the transfer begins.
      This problem has not been seen on DRA7 or beagle board xm (OMAP3). I am not
      sure if this is UART-IP core specific or DMA engine.
    
      The workaround is to use a threshold of one byte, program the DMA
      transfer minus one byte and then to put the first byte into the FIFO to
      kick start the transfer.
    
    - support for runtime PM
      RPM is enabled on start_tx(). We can't disable RPM on DMA complete callback
      because there is still data in the FIFO which is being sent. We have to wait
      until the FIFO is empty before we disable it.
      For this to happen we fake a TX sent error and enable THRI. Once the
      FIFO is empty we receive an interrupt and since the TTY-buffer is still
      empty we "put RPM" via __stop_tx(). Should it been filed then in the
      start_tx() path we should program the DMA transfer and remove the error
      flag and the THRI bit.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index df6c9ab6b0cd..53af3b790129 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -359,6 +359,7 @@
 #define UART_OMAP_SYSC		0x15	/* System configuration register */
 #define UART_OMAP_SYSS		0x16	/* System status register */
 #define UART_OMAP_WER		0x17	/* Wake-up enable register */
+#define UART_OMAP_TX_LVL	0x1a	/* TX FIFO level register */
 
 /*
  * These are the definitions for the MDR1 register

commit aef9a7bd9b676f797dd5cefd43deb30d36b976a9
Author: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
Date:   Wed Jul 16 01:19:36 2014 +0000

    serial/uart/8250: Add tunable RX interrupt trigger I/F of FIFO buffers
    
    Add tunable RX interrupt trigger I/F of FIFO buffers.
    
    Serial devices are used as not only message communication devices but control
    or sending communication devices. For the latter uses, normally small data
    will be exchanged, so user applications want to receive data unit as soon as
    possible for real-time tendency. If we have a sensor which sends a 1 byte data
    each time and must control a device based on the sensor feedback, the RX
    interrupt should be triggered for each data.
    
    According to HW specification of serial UART devices, RX interrupt trigger
    can be changed, but the trigger is hard-coded. For example, RX interrupt trigger
    in 16550A can be set to 1, 4, 8, or 14 bytes for HW, but current driver sets
    the trigger to only 8bytes.
    
    This patch makes some devices change RX interrupt trigger from userland.
    
    <How to use>
    - Read current setting
     # cat /sys/class/tty/ttyS0/rx_trig_bytes
     8
    
    - Write user setting
     # echo 1 > /sys/class/tty/ttyS0/rx_trig_bytes
     # cat /sys/class/tty/ttyS0/rx_trig_bytes
     1
    
    <Support uart devices>
    - 16550A and Tegra (1, 4, 8, or 14 bytes)
    - 16650V2 (8, 16, 24, or 28 bytes)
    - 16654 (8, 16, 56, or 60 bytes)
    - 16750 (1, 16, 32, or 56 bytes)
    
    <Change log>
    Changes in V9:
     - Use attr_group instead of dev_spec_attr_group of uart_port structure
    
    Changes in V8:
     - Divide this patch from V7's patch based on Greg's comment
    
    Changes in V7:
     - Add Documentation
     - Change I/F name from rx_int_trig to rx_trig_bytes because the name
       rx_int_trig is hard to understand how users specify the value
    
    Changes in V6:
     - Move FCR_RX_TRIG_* definition in 8250.h to include/uapi/linux/serial_reg.h,
       rename those to UART_FCR_R_TRIG_*, and use UART_FCR_TRIGGER_MASK to
       UART_FCR_R_TRIG_BITS()
     - Change following function names:
        convert_fcr2val() => fcr_get_rxtrig_bytes()
        convert_val2rxtrig() => bytes_to_fcr_rxtrig()
     - Fix typo in serial8250_do_set_termios()
     - Delete the verbose error message pr_info() in bytes_to_fcr_rxtrig()
     - Rename *rx_int_trig/rx_trig* to *rxtrig* for several functions or variables
       (but UI remains rx_int_trig)
     - Change the meaningless variable name 'val' to 'bytes' following functions:
        fcr_get_rxtrig_bytes(), bytes_to_fcr_rxtrig(), do_set_rxtrig(),
        do_serial8250_set_rxtrig(), and serial8250_set_attr_rxtrig()
     - Use up->fcr in order to get rxtrig_bytes instead of rx_trig_raw in
       fcr_get_rxtrig_bytes()
     - Use conf_type->rxtrig_bytes[0] instead of switch statement for support check
       in register_dev_spec_attr_grp()
     - Delete the checking whether a user changed FCR or not when minimum buffer
       is needed in serial8250_do_set_termios()
    
    Changes in V5.1:
     - Fix FCR_RX_TRIG_MAX_STATE definition
    
    Changes in V5:
     - Support Tegra, 16650V2, 16654, and 16750
     - Store default FCR value to up->fcr when the port is first created
     - Add rx_trig_byte[] in uart_config[] for each device and use rx_trig_byte[]
       in convert_fcr2val() and convert_val2rxtrig()
    
    Changes in V4:
     - Introduce fifo_bug flag in uart_8250_port structure
       This is enabled only when parity is enabled and UART_BUG_PARITY is enabled
       for up->bugs. If this flag is enabled, user cannot set RX trigger.
     - Return -EOPNOTSUPP when it does not support device at convert_fcr2val() and
       at convert_val2rxtrig()
     - Set the nearest lower RX trigger when users input a meaningless value at
       convert_val2rxtrig()
     - Check whether p->fcr is existing at serial8250_clear_and_reinit_fifos()
     - Set fcr = up->fcr in the begging of serial8250_do_set_termios()
    
    Changes in V3:
     - Change I/F from ioctl(2) to sysfs(rx_int_trig)
    
    Changed in V2:
     - Use _IOW for TIOCSFIFORTRIG definition
     - Pass the interrupt trigger value itself
    
    Signed-off-by: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 99b47058816a..df6c9ab6b0cd 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -88,6 +88,11 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
+#define UART_FCR_R_TRIG_SHIFT		6
+#define UART_FCR_R_TRIG_BITS(x)		\
+	(((x) & UART_FCR_TRIGGER_MASK) >> UART_FCR_R_TRIG_SHIFT)
+#define UART_FCR_R_TRIG_MAX_STATE	4
+
 #define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 

commit bd5dc09f557547399cd44d0a1224df7ff64e4a6b
Author: Felipe Balbi <balbi@ti.com>
Date:   Wed Apr 23 09:58:28 2014 -0500

    serial: fix UART_IIR_ID
    
    UART IRQ Identification bitfield is 3
    bits long (bits 3:1) but current mask only
    masks 2 bits. Fix it.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index e6322605b138..99b47058816a 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -32,7 +32,7 @@
 
 #define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
-#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+#define UART_IIR_ID		0x0e /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
 #define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
 #define UART_IIR_RDI		0x04 /* Receiver data interrupt */

commit d02f81555362e0032080af62154dca00d5ec99e0
Author: Matt Schulte <matts@commtech-fastcom.com>
Date:   Tue Nov 20 11:21:17 2012 -0600

    Add register definitions used in several Exar PCI/PCIe UARTs
    
    Add register definitions used in several Exar PCI/PCIe UARTs
    
    Signed-off-by: Matt Schulte <matts@commtech-fastcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index d0b47607b90b..e6322605b138 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -368,10 +368,22 @@
 #define UART_OMAP_MDR1_DISABLE		0x07	/* Disable (default state) */
 
 /*
- * These are definitions for the XR17V35X and XR17D15X
+ * These are definitions for the Exar XR17V35X and XR17(C|D)15X
  */
+#define UART_EXAR_8XMODE	0x88	/* 8X sampling rate select */
 #define UART_EXAR_SLEEP		0x8b	/* Sleep mode */
 #define UART_EXAR_DVID		0x8d	/* Device identification */
 
+#define UART_EXAR_FCTR		0x08	/* Feature Control Register */
+#define UART_FCTR_EXAR_IRDA	0x08	/* IrDa data encode select */
+#define UART_FCTR_EXAR_485	0x10	/* Auto 485 half duplex dir ctl */
+#define UART_FCTR_EXAR_TRGA	0x00	/* FIFO trigger table A */
+#define UART_FCTR_EXAR_TRGB	0x60	/* FIFO trigger table B */
+#define UART_FCTR_EXAR_TRGC	0x80	/* FIFO trigger table C */
+#define UART_FCTR_EXAR_TRGD	0xc0	/* FIFO trigger table D programmable */
+
+#define UART_EXAR_TXTRG		0x0a	/* Tx FIFO trigger level write-only */
+#define UART_EXAR_RXTRG		0x0b	/* Rx FIFO trigger level write-only */
+
 #endif /* _LINUX_SERIAL_REG_H */
 

commit dc96efb72054985c0912f831da009a2da4e9f6dd
Author: Matt Schulte <matts@commtech-fastcom.com>
Date:   Mon Nov 19 09:12:04 2012 -0600

    Serial: Add support for new devices: Exar's XR17V35x family of multi-port PCIe UARTs
    
    Add support for new devices: Exar's XR17V35x family of multi-port PCIe UARTs.
    
    Signed-off-by: Matt Schulte <matts@commtech-fastcom.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
index 5ed325e88a81..d0b47607b90b 100644
--- a/include/uapi/linux/serial_reg.h
+++ b/include/uapi/linux/serial_reg.h
@@ -367,5 +367,11 @@
 #define UART_OMAP_MDR1_CIR_MODE		0x06	/* CIR mode */
 #define UART_OMAP_MDR1_DISABLE		0x07	/* Disable (default state) */
 
+/*
+ * These are definitions for the XR17V35X and XR17D15X
+ */
+#define UART_EXAR_SLEEP		0x8b	/* Sleep mode */
+#define UART_EXAR_DVID		0x8d	/* Device identification */
+
 #endif /* _LINUX_SERIAL_REG_H */
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/serial_reg.h b/include/uapi/linux/serial_reg.h
new file mode 100644
index 000000000000..5ed325e88a81
--- /dev/null
+++ b/include/uapi/linux/serial_reg.h
@@ -0,0 +1,371 @@
+/*
+ * include/linux/serial_reg.h
+ *
+ * Copyright (C) 1992, 1994 by Theodore Ts'o.
+ * 
+ * Redistribution of this file is permitted under the terms of the GNU 
+ * Public License (GPL)
+ * 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#ifndef _LINUX_SERIAL_REG_H
+#define _LINUX_SERIAL_REG_H
+
+/*
+ * DLAB=0
+ */
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
+
+#define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
+#define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
+#define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
+#define UART_IER_RDI		0x01 /* Enable receiver data interrupt */
+/*
+ * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
+ */
+#define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_IIR_NO_INT		0x01 /* No interrupts pending */
+#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+#define UART_IIR_MSI		0x00 /* Modem status interrupt */
+#define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
+#define UART_IIR_RDI		0x04 /* Receiver data interrupt */
+#define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
+
+#define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
+
+#define UART_IIR_RX_TIMEOUT	0x0c /* OMAP RX Timeout interrupt */
+#define UART_IIR_XOFF		0x10 /* OMAP XOFF/Special Character */
+#define UART_IIR_CTS_RTS_DSR	0x20 /* OMAP CTS/RTS/DSR Change */
+
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+/*
+ * Note: The FIFO trigger levels are chip specific:
+ *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
+ * PC16550D:	 1   4   8  14		xx  xx  xx  xx
+ * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
+ * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
+ * ST16C550:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
+ * NS16C552:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
+ * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
+ * TI16C752:	 8  16  56  60		 8  16  32  56
+ * Tegra:	 1   4   8  14		16   8   4   1	PORT_TEGRA
+ */
+#define UART_FCR_R_TRIG_00	0x00
+#define UART_FCR_R_TRIG_01	0x40
+#define UART_FCR_R_TRIG_10	0x80
+#define UART_FCR_R_TRIG_11	0xc0
+#define UART_FCR_T_TRIG_00	0x00
+#define UART_FCR_T_TRIG_01	0x10
+#define UART_FCR_T_TRIG_10	0x20
+#define UART_FCR_T_TRIG_11	0x30
+
+#define UART_FCR_TRIGGER_MASK	0xC0 /* Mask for the FIFO trigger range */
+#define UART_FCR_TRIGGER_1	0x00 /* Mask for trigger set at 1 */
+#define UART_FCR_TRIGGER_4	0x40 /* Mask for trigger set at 4 */
+#define UART_FCR_TRIGGER_8	0x80 /* Mask for trigger set at 8 */
+#define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
+/* 16650 definitions */
+#define UART_FCR6_R_TRIGGER_8	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR6_R_TRIGGER_16	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR6_R_TRIGGER_24  0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR6_R_TRIGGER_28	0xC0 /* Mask for receive trigger set at 14 */
+#define UART_FCR6_T_TRIGGER_16	0x00 /* Mask for transmit trigger set at 16 */
+#define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
+#define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
+#define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+
+#define UART_LCR	3	/* Out: Line Control Register */
+/*
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
+ */
+#define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
+#define UART_LCR_SBC		0x40 /* Set break control */
+#define UART_LCR_SPAR		0x20 /* Stick parity (?) */
+#define UART_LCR_EPAR		0x10 /* Even parity select */
+#define UART_LCR_PARITY		0x08 /* Parity Enable */
+#define UART_LCR_STOP		0x04 /* Stop bits: 0=1 bit, 1=2 bits */
+#define UART_LCR_WLEN5		0x00 /* Wordlength: 5 bits */
+#define UART_LCR_WLEN6		0x01 /* Wordlength: 6 bits */
+#define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
+#define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
+
+/*
+ * Access to some registers depends on register access / configuration
+ * mode.
+ */
+#define UART_LCR_CONF_MODE_A	UART_LCR_DLAB	/* Configutation mode A */
+#define UART_LCR_CONF_MODE_B	0xBF		/* Configutation mode B */
+
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
+#define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
+#define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
+#define UART_MCR_AFE		0x20 /* Enable auto-RTS/CTS (TI16C550C/TI16C750) */
+#define UART_MCR_LOOP		0x10 /* Enable loopback test mode */
+#define UART_MCR_OUT2		0x08 /* Out2 complement */
+#define UART_MCR_OUT1		0x04 /* Out1 complement */
+#define UART_MCR_RTS		0x02 /* RTS complement */
+#define UART_MCR_DTR		0x01 /* DTR complement */
+
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_FIFOE		0x80 /* Fifo error */
+#define UART_LSR_TEMT		0x40 /* Transmitter empty */
+#define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
+#define UART_LSR_BI		0x10 /* Break interrupt indicator */
+#define UART_LSR_FE		0x08 /* Frame error indicator */
+#define UART_LSR_PE		0x04 /* Parity error indicator */
+#define UART_LSR_OE		0x02 /* Overrun error indicator */
+#define UART_LSR_DR		0x01 /* Receiver data ready */
+#define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
+
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_MSR_DCD		0x80 /* Data Carrier Detect */
+#define UART_MSR_RI		0x40 /* Ring Indicator */
+#define UART_MSR_DSR		0x20 /* Data Set Ready */
+#define UART_MSR_CTS		0x10 /* Clear to Send */
+#define UART_MSR_DDCD		0x08 /* Delta DCD */
+#define UART_MSR_TERI		0x04 /* Trailing edge ring indicator */
+#define UART_MSR_DDSR		0x02 /* Delta DSR */
+#define UART_MSR_DCTS		0x01 /* Delta CTS */
+#define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
+
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+/*
+ * DLAB=1
+ */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_DLM	1	/* Out: Divisor Latch High */
+
+/*
+ * LCR=0xBF (or DLAB=1 for 16C660)
+ */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_XR_EFR	9	/* I/O: Extended Features Register (XR17D15x) */
+#define UART_EFR_CTS		0x80 /* CTS flow control */
+#define UART_EFR_RTS		0x40 /* RTS flow control */
+#define UART_EFR_SCD		0x20 /* Special character detect */
+#define UART_EFR_ECB		0x10 /* Enhanced control bit */
+/*
+ * the low four bits control software flow control
+ */
+
+/*
+ * LCR=0xBF, TI16C752, ST16650, ST16650A, ST16654
+ */
+#define UART_XON1	4	/* I/O: Xon character 1 */
+#define UART_XON2	5	/* I/O: Xon character 2 */
+#define UART_XOFF1	6	/* I/O: Xoff character 1 */
+#define UART_XOFF2	7	/* I/O: Xoff character 2 */
+
+/*
+ * EFR[4]=1 MCR[6]=1, TI16C752
+ */
+#define UART_TI752_TCR	6	/* I/O: transmission control register */
+#define UART_TI752_TLR	7	/* I/O: trigger level register */
+
+/*
+ * LCR=0xBF, XR16C85x
+ */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
+/*
+ * These are the definitions for the Programmable Trigger Register
+ */
+#define UART_TRG_1		0x01
+#define UART_TRG_4		0x04
+#define UART_TRG_8		0x08
+#define UART_TRG_16		0x10
+#define UART_TRG_32		0x20
+#define UART_TRG_64		0x40
+#define UART_TRG_96		0x60
+#define UART_TRG_120		0x78
+#define UART_TRG_128		0x80
+
+#define UART_FCTR	1	/* Feature Control Register */
+#define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
+#define UART_FCTR_RTS_4DELAY	0x01
+#define UART_FCTR_RTS_6DELAY	0x02
+#define UART_FCTR_RTS_8DELAY	0x03
+#define UART_FCTR_IRDA		0x04  /* IrDa data encode select */
+#define UART_FCTR_TX_INT	0x08  /* Tx interrupt type select */
+#define UART_FCTR_TRGA		0x00  /* Tx/Rx 550 trigger table select */
+#define UART_FCTR_TRGB		0x10  /* Tx/Rx 650 trigger table select */
+#define UART_FCTR_TRGC		0x20  /* Tx/Rx 654 trigger table select */
+#define UART_FCTR_TRGD		0x30  /* Tx/Rx 850 programmable trigger select */
+#define UART_FCTR_SCR_SWAP	0x40  /* Scratch pad register swap */
+#define UART_FCTR_RX		0x00  /* Programmable trigger mode select */
+#define UART_FCTR_TX		0x80  /* Programmable trigger mode select */
+
+/*
+ * LCR=0xBF, FCTR[6]=1
+ */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+#define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
+#define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
+
+/*
+ * The Intel XScale on-chip UARTs define these bits
+ */
+#define UART_IER_DMAE	0x80	/* DMA Requests Enable */
+#define UART_IER_UUE	0x40	/* UART Unit Enable */
+#define UART_IER_NRZE	0x20	/* NRZ coding Enable */
+#define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+
+#define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
+
+#define UART_FCR_PXAR1	0x00	/* receive FIFO threshold = 1 */
+#define UART_FCR_PXAR8	0x40	/* receive FIFO threshold = 8 */
+#define UART_FCR_PXAR16	0x80	/* receive FIFO threshold = 16 */
+#define UART_FCR_PXAR32	0xc0	/* receive FIFO threshold = 32 */
+
+/*
+ * Intel MID on-chip HSU (High Speed UART) defined bits
+ */
+#define UART_FCR_HSU_64_1B	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_HSU_64_16B	0x40	/* receive FIFO treshold = 16 */
+#define UART_FCR_HSU_64_32B	0x80	/* receive FIFO treshold = 32 */
+#define UART_FCR_HSU_64_56B	0xc0	/* receive FIFO treshold = 56 */
+
+#define UART_FCR_HSU_16_1B	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_HSU_16_4B	0x40	/* receive FIFO treshold = 4 */
+#define UART_FCR_HSU_16_8B	0x80	/* receive FIFO treshold = 8 */
+#define UART_FCR_HSU_16_14B	0xc0	/* receive FIFO treshold = 14 */
+
+#define UART_FCR_HSU_64B_FIFO	0x20	/* chose 64 bytes FIFO */
+#define UART_FCR_HSU_16B_FIFO	0x00	/* chose 16 bytes FIFO */
+
+#define UART_FCR_HALF_EMPT_TXI	0x00	/* trigger TX_EMPT IRQ for half empty */
+#define UART_FCR_FULL_EMPT_TXI	0x08	/* trigger TX_EMPT IRQ for full empty */
+
+/*
+ * These register definitions are for the 16C950
+ */
+#define UART_ASR	0x01	/* Additional Status Register */
+#define UART_RFL	0x03	/* Receiver FIFO level */
+#define UART_TFL 	0x04	/* Transmitter FIFO level */
+#define UART_ICR	0x05	/* Index Control Register */
+
+/* The 16950 ICR registers */
+#define UART_ACR	0x00	/* Additional Control Register */
+#define UART_CPR	0x01	/* Clock Prescalar Register */
+#define UART_TCR	0x02	/* Times Clock Register */
+#define UART_CKS	0x03	/* Clock Select Register */
+#define UART_TTL	0x04	/* Transmitter Interrupt Trigger Level */
+#define UART_RTL	0x05	/* Receiver Interrupt Trigger Level */
+#define UART_FCL	0x06	/* Flow Control Level Lower */
+#define UART_FCH	0x07	/* Flow Control Level Higher */
+#define UART_ID1	0x08	/* ID #1 */
+#define UART_ID2	0x09	/* ID #2 */
+#define UART_ID3	0x0A	/* ID #3 */
+#define UART_REV	0x0B	/* Revision */
+#define UART_CSR	0x0C	/* Channel Software Reset */
+#define UART_NMR	0x0D	/* Nine-bit Mode Register */
+#define UART_CTR	0xFF
+
+/*
+ * The 16C950 Additional Control Register
+ */
+#define UART_ACR_RXDIS	0x01	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Transmitter disable */
+#define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
+#define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
+#define UART_ACR_ICRRD	0x40	/* ICR Read enable */
+#define UART_ACR_ASREN	0x80	/* Additional status enable */
+
+
+
+/*
+ * These definitions are for the RSA-DV II/S card, from
+ *
+ * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
+ */
+
+#define UART_RSA_BASE (-8)
+
+#define UART_RSA_MSR ((UART_RSA_BASE) + 0) /* I/O: Mode Select Register */
+
+#define UART_RSA_MSR_SWAP (1 << 0) /* Swap low/high 8 bytes in I/O port addr */
+#define UART_RSA_MSR_FIFO (1 << 2) /* Enable the external FIFO */
+#define UART_RSA_MSR_FLOW (1 << 3) /* Enable the auto RTS/CTS flow control */
+#define UART_RSA_MSR_ITYP (1 << 4) /* Level (1) / Edge triger (0) */
+
+#define UART_RSA_IER ((UART_RSA_BASE) + 1) /* I/O: Interrupt Enable Register */
+
+#define UART_RSA_IER_Rx_FIFO_H (1 << 0) /* Enable Rx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_H (1 << 1) /* Enable Tx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_E (1 << 2) /* Enable Tx FIFO empty int. */
+#define UART_RSA_IER_Rx_TOUT (1 << 3) /* Enable char receive timeout int */
+#define UART_RSA_IER_TIMER (1 << 4) /* Enable timer interrupt */
+
+#define UART_RSA_SRR ((UART_RSA_BASE) + 2) /* IN: Status Read Register */
+
+#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0) /* Tx FIFO is not empty (1) */
+#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1) /* Tx FIFO is not half full (1) */
+#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2) /* Tx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3) /* Rx FIFO is not empty (1) */
+#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4) /* Rx FIFO is not half full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5) /* Rx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_TOUT (1 << 6) /* Character reception timeout occurred (1) */
+#define UART_RSA_SRR_TIMER (1 << 7) /* Timer interrupt occurred */
+
+#define UART_RSA_FRR ((UART_RSA_BASE) + 2) /* OUT: FIFO Reset Register */
+
+#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3) /* I/O: Timer Interval Value Set Register */
+
+#define UART_RSA_TCR ((UART_RSA_BASE) + 4) /* OUT: Timer Control Register */
+
+#define UART_RSA_TCR_SWITCH (1 << 0) /* Timer on */
+
+/*
+ * The RSA DSV/II board has two fixed clock frequencies.  One is the
+ * standard rate, and the other is 8 times faster.
+ */
+#define SERIAL_RSA_BAUD_BASE (921600)
+#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
+
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+#define UART_OMAP_WER		0x17	/* Wake-up enable register */
+
+/*
+ * These are the definitions for the MDR1 register
+ */
+#define UART_OMAP_MDR1_16X_MODE		0x00	/* UART 16x mode */
+#define UART_OMAP_MDR1_SIR_MODE		0x01	/* SIR mode */
+#define UART_OMAP_MDR1_16X_ABAUD_MODE	0x02	/* UART 16x auto-baud */
+#define UART_OMAP_MDR1_13X_MODE		0x03	/* UART 13x mode */
+#define UART_OMAP_MDR1_MIR_MODE		0x04	/* MIR mode */
+#define UART_OMAP_MDR1_FIR_MODE		0x05	/* FIR mode */
+#define UART_OMAP_MDR1_CIR_MODE		0x06	/* CIR mode */
+#define UART_OMAP_MDR1_DISABLE		0x07	/* Disable (default state) */
+
+#endif /* _LINUX_SERIAL_REG_H */
+
