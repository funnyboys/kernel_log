commit 34c51814b2b87cb2e5a98c92fe957db2ee8e27f4
Author: Eugene Syromiatnikov <esyr@redhat.com>
Date:   Wed Apr 1 05:26:50 2020 +0200

    btrfs: re-instantiate the removed BTRFS_SUBVOL_CREATE_ASYNC definition
    
    The commit 9c1036fdb1d1ff1b ("btrfs: Remove BTRFS_SUBVOL_CREATE_ASYNC
    support") breaks strace build with the kernel headers from git:
    
        btrfs.c: In function "btrfs_test_subvol_ioctls":
        btrfs.c:531:23: error: "BTRFS_SUBVOL_CREATE_ASYNC" undeclared (first use
        in this function)
           vol_args_v2.flags = BTRFS_SUBVOL_CREATE_ASYNC;
    
    Moreover, it is improper to break UAPI, strace uses the definitions to
    decode ioctls that are considered part of public API.
    
    Restore the macro definition and put it under "#ifndef __KERNEL__"
    in order to prevent inadvertent in-kernel usage.
    
    Fixes: 9c1036fdb1d1ff1b ("btrfs: Remove BTRFS_SUBVOL_CREATE_ASYNC support")
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Eugene Syromiatnikov <esyr@redhat.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 8134924cfc17..e6b6cb0f8bc6 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -36,12 +36,10 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_DEVICE_PATH_NAME_MAX	1024
 #define BTRFS_SUBVOL_NAME_MAX 		4039
 
-/*
- * Deprecated since 5.7:
- *
- * BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
- */
-
+#ifndef __KERNEL__
+/* Deprecated since 5.7 */
+# define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
+#endif
 #define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
 #define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 

commit 9c1036fdb1d1ff1b09d03c8db60f4dc67cc6614e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Mar 13 17:23:18 2020 +0200

    btrfs: Remove BTRFS_SUBVOL_CREATE_ASYNC support
    
    This functionality was deprecated in kernel 5.4. Since no one has
    complained of the impending removal it's time we did so.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ add comment ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index b5f3ea36d3cb..8134924cfc17 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -36,7 +36,12 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_DEVICE_PATH_NAME_MAX	1024
 #define BTRFS_SUBVOL_NAME_MAX 		4039
 
-#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
+/*
+ * Deprecated since 5.7:
+ *
+ * BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
+ */
+
 #define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
 #define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 
@@ -45,8 +50,7 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_SUBVOL_SPEC_BY_ID	(1ULL << 4)
 
 #define BTRFS_VOL_ARG_V2_FLAGS_SUPPORTED		\
-			(BTRFS_SUBVOL_CREATE_ASYNC |	\
-			BTRFS_SUBVOL_RDONLY |		\
+			(BTRFS_SUBVOL_RDONLY |		\
 			BTRFS_SUBVOL_QGROUP_INHERIT |	\
 			BTRFS_DEVICE_SPEC_BY_ID |	\
 			BTRFS_SUBVOL_SPEC_BY_ID)
@@ -116,8 +120,7 @@ struct btrfs_ioctl_qgroup_limit_args {
 
 /* Supported flags for BTRFS_IOC_SNAP_CREATE_V2 and BTRFS_IOC_SUBVOL_CREATE_V2 */
 #define BTRFS_SUBVOL_CREATE_ARGS_MASK					\
-	(BTRFS_SUBVOL_CREATE_ASYNC |					\
-	 BTRFS_SUBVOL_RDONLY |						\
+	 (BTRFS_SUBVOL_RDONLY |						\
 	 BTRFS_SUBVOL_QGROUP_INHERIT)
 
 /* Supported flags for BTRFS_IOC_SNAP_DESTROY_V2 */

commit 949964c928430a42e0d4f514d888a58a201b6fcb
Author: Marcos Paulo de Souza <mpdesouza@suse.com>
Date:   Fri Feb 7 10:05:46 2020 -0300

    btrfs: add new BTRFS_IOC_SNAP_DESTROY_V2 ioctl
    
    This ioctl will be responsible for deleting a subvolume using its id.
    This can be used when a system has a file system mounted from a
    subvolume, rather than the root file system, like below:
    
    /
    @subvol1/
    @subvol2/
    @subvol_default/
    
    If only @subvol_default is mounted, we have no path to reach @subvol1
    and @subvol2, thus no way to delete them. Current subvolume delete ioctl
    takes a file handle point as argument, and if @subvol_default is
    mounted, we can't reach @subvol1 and @subvol2 from the same mount point.
    
    This patch introduces a new ioctl BTRFS_IOC_SNAP_DESTROY_V2 that takes
    the extended structure with flags to allow to delete subvolume using
    subvolid.
    
    Now, we can use this new ioctl specifying the subvolume id and refer to
    the same mount point. It doesn't matter which subvolume was mounted,
    since we can reach to the desired one using the subvolume id, and then
    delete it.
    
    The full path to the subvolume id is resolved internally and access is
    verified as if the subvolume was accessed by path.
    
    The volume args v2 structure is extended to use the existing union for
    subvolume id specification, that's valid in case the
    BTRFS_SUBVOL_SPEC_BY_ID is set.
    
    Signed-off-by: Marcos Paulo de Souza <mpdesouza@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 49ed71df5e94..b5f3ea36d3cb 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -42,11 +42,14 @@ struct btrfs_ioctl_vol_args {
 
 #define BTRFS_DEVICE_SPEC_BY_ID		(1ULL << 3)
 
+#define BTRFS_SUBVOL_SPEC_BY_ID	(1ULL << 4)
+
 #define BTRFS_VOL_ARG_V2_FLAGS_SUPPORTED		\
 			(BTRFS_SUBVOL_CREATE_ASYNC |	\
 			BTRFS_SUBVOL_RDONLY |		\
 			BTRFS_SUBVOL_QGROUP_INHERIT |	\
-			BTRFS_DEVICE_SPEC_BY_ID)
+			BTRFS_DEVICE_SPEC_BY_ID |	\
+			BTRFS_SUBVOL_SPEC_BY_ID)
 
 #define BTRFS_FSID_SIZE 16
 #define BTRFS_UUID_SIZE 16
@@ -117,6 +120,10 @@ struct btrfs_ioctl_qgroup_limit_args {
 	 BTRFS_SUBVOL_RDONLY |						\
 	 BTRFS_SUBVOL_QGROUP_INHERIT)
 
+/* Supported flags for BTRFS_IOC_SNAP_DESTROY_V2 */
+#define BTRFS_SUBVOL_DELETE_ARGS_MASK					\
+	(BTRFS_SUBVOL_SPEC_BY_ID)
+
 struct btrfs_ioctl_vol_args_v2 {
 	__s64 fd;
 	__u64 transid;
@@ -131,6 +138,7 @@ struct btrfs_ioctl_vol_args_v2 {
 	union {
 		char name[BTRFS_SUBVOL_NAME_MAX + 1];
 		__u64 devid;
+		__u64 subvolid;
 	};
 };
 
@@ -959,5 +967,7 @@ enum btrfs_err_code {
 				struct btrfs_ioctl_get_subvol_rootref_args)
 #define BTRFS_IOC_INO_LOOKUP_USER _IOWR(BTRFS_IOCTL_MAGIC, 62, \
 				struct btrfs_ioctl_ino_lookup_user_args)
+#define BTRFS_IOC_SNAP_DESTROY_V2 _IOW(BTRFS_IOCTL_MAGIC, 63, \
+				struct btrfs_ioctl_vol_args_v2)
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit eed0269053cd37ea6ec76ad10cdd2bccc4b807a1
Author: David Sterba <dsterba@suse.com>
Date:   Fri Feb 21 13:16:33 2020 +0100

    btrfs: define support masks for ioctl volume args v2
    
    The ioctl data for devices or subvolumes can be passed via
    btrfs_ioctl_vol_args or btrfs_ioctl_vol_args_v2. The latter is more
    versatile and needs some caution as some of the flags make sense only
    for some ioctls.
    
    As we're going to extend the flags, define support masks for each ioctl
    class separately.
    
    Reviewed-by: Marcos Paulo de Souza <mpdesouza@suse.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 7a8bc8b920f5..49ed71df5e94 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -97,16 +97,26 @@ struct btrfs_ioctl_qgroup_limit_args {
 };
 
 /*
- * flags for subvolumes
+ * Arguments for specification of subvolumes or devices, supporting by-name or
+ * by-id and flags
  *
- * Used by:
- * struct btrfs_ioctl_vol_args_v2.flags
+ * The set of supported flags depends on the ioctl
  *
  * BTRFS_SUBVOL_RDONLY is also provided/consumed by the following ioctls:
  * - BTRFS_IOC_SUBVOL_GETFLAGS
  * - BTRFS_IOC_SUBVOL_SETFLAGS
  */
 
+/* Supported flags for BTRFS_IOC_RM_DEV_V2 */
+#define BTRFS_DEVICE_REMOVE_ARGS_MASK					\
+	(BTRFS_DEVICE_SPEC_BY_ID)
+
+/* Supported flags for BTRFS_IOC_SNAP_CREATE_V2 and BTRFS_IOC_SUBVOL_CREATE_V2 */
+#define BTRFS_SUBVOL_CREATE_ARGS_MASK					\
+	(BTRFS_SUBVOL_CREATE_ASYNC |					\
+	 BTRFS_SUBVOL_RDONLY |						\
+	 BTRFS_SUBVOL_QGROUP_INHERIT)
+
 struct btrfs_ioctl_vol_args_v2 {
 	__s64 fd;
 	__u64 transid;

commit cfbb825c76198c9095428c5f9362fbf6ae06f417
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jul 10 18:15:05 2018 +0200

    btrfs: add incompat for raid1 with 3, 4 copies
    
    The new raid1c3 and raid1c4 profiles are backward incompatible and the
    name shall be 'raid1c34', the status can be found in the global
    supported features in /sys/fs/btrfs/features or in the per-filesystem
    directory.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index a2b761275bba..7a8bc8b920f5 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -270,6 +270,7 @@ struct btrfs_ioctl_fs_info_args {
 #define BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA	(1ULL << 8)
 #define BTRFS_FEATURE_INCOMPAT_NO_HOLES		(1ULL << 9)
 #define BTRFS_FEATURE_INCOMPAT_METADATA_UUID	(1ULL << 10)
+#define BTRFS_FEATURE_INCOMPAT_RAID1C34		(1ULL << 11)
 
 struct btrfs_ioctl_feature_flags {
 	__u64 compat_flags;

commit 8d6fac0087e538173f34ca7431ed9b58581acf28
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 2 22:56:53 2018 +0100

    btrfs: add support for 4-copy replication (raid1c4)
    
    Add new block group profile to store 4 copies in a simliar way that
    current RAID1 does.  The profile attributes and constraints are defined
    in the raid table and used by the same code that already handles the 2-
    and 3-copy RAID1.
    
    The minimum number of devices is 4, the maximum number of devices/chunks
    that can be lost/damaged is 3. There is no comparable traditional RAID
    level, the profile is added for future needs to accompany triple-parity
    and beyond.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index ba22f91a3f5b..a2b761275bba 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -833,6 +833,7 @@ enum btrfs_err_code {
 	BTRFS_ERROR_DEV_ONLY_WRITABLE,
 	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS,
 	BTRFS_ERROR_DEV_RAID1C3_MIN_NOT_MET,
+	BTRFS_ERROR_DEV_RAID1C4_MIN_NOT_MET,
 };
 
 #define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \

commit 47e6f7423b9196ad6832d26cae52b7015f81ee7f
Author: David Sterba <dsterba@suse.com>
Date:   Fri Mar 2 22:56:53 2018 +0100

    btrfs: add support for 3-copy replication (raid1c3)
    
    Add new block group profile to store 3 copies in a simliar way that
    current RAID1 does. The profile attributes and constraints are defined
    in the raid table and used by the same code that already handles the
    2-copy RAID1.
    
    The minimum number of devices is 3, the maximum number of devices/chunks
    that can be lost/damaged is 2. Like RAID6 but with 33% space
    utilization.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 3ee0678c0a83..ba22f91a3f5b 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -831,7 +831,8 @@ enum btrfs_err_code {
 	BTRFS_ERROR_DEV_TGT_REPLACE,
 	BTRFS_ERROR_DEV_MISSING_NOT_FOUND,
 	BTRFS_ERROR_DEV_ONLY_WRITABLE,
-	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS
+	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS,
+	BTRFS_ERROR_DEV_RAID1C3_MIN_NOT_MET,
 };
 
 #define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \

commit 73a3ca20934dd02c0912bcf32463fffec6139399
Author: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
Date:   Sat Aug 3 23:36:34 2019 +0200

    btrfs: clarify btrfs_ioctl_get_dev_stats padding
    
    In commit c11d2c236cc26 ("Btrfs: add ioctl to get and reset the device
    stats") the get_dev_stats ioctl was added.
    
    Shortly thereafter, in commit b27f7c0c150f7 ("btrfs: join DEV_STATS
    ioctls to one") , the flags field was added.  However, the calculation
    for unused padding space was not updated, which also invalidated the
    comment.
    
    Clarify what happened to reduce confusion and wasted time for anyone
    implementing this.
    
    Signed-off-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 7885d79f7515..3ee0678c0a83 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -665,7 +665,12 @@ struct btrfs_ioctl_get_dev_stats {
 	/* out values: */
 	__u64 values[BTRFS_DEV_STAT_VALUES_MAX];
 
-	__u64 unused[128 - 2 - BTRFS_DEV_STAT_VALUES_MAX]; /* pad to 1k */
+	/*
+	 * This pads the struct to 1032 bytes. It was originally meant to pad to
+	 * 1024 bytes, but when adding the flags field, the padding calculation
+	 * was not adjusted.
+	 */
+	__u64 unused[128 - 2 - BTRFS_DEV_STAT_VALUES_MAX];
 };
 
 #define BTRFS_QUOTA_CTL_ENABLE	1

commit 40cf931fa81bedea08823dda9e6e73630db41b70
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Wed Jul 17 12:39:20 2019 -0500

    btrfs: use common vfs LABEL ioctl definitions
    
    I lifted the btrfs label get/set ioctls to the vfs some time ago, but
    never followed up to use those common definitions directly in btrfs.
    
    This patch does that.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index c195896d478f..7885d79f7515 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -917,10 +917,8 @@ enum btrfs_err_code {
 #define BTRFS_IOC_QUOTA_RESCAN_STATUS _IOR(BTRFS_IOCTL_MAGIC, 45, \
 			       struct btrfs_ioctl_quota_rescan_args)
 #define BTRFS_IOC_QUOTA_RESCAN_WAIT _IO(BTRFS_IOCTL_MAGIC, 46)
-#define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
-				   char[BTRFS_LABEL_SIZE])
-#define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \
-				   char[BTRFS_LABEL_SIZE])
+#define BTRFS_IOC_GET_FSLABEL 	FS_IOC_GETFSLABEL
+#define BTRFS_IOC_SET_FSLABEL	FS_IOC_SETFSLABEL
 #define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \
 				      struct btrfs_ioctl_get_dev_stats)
 #define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \

commit 228a73abde5c04428678e917b271f8526cfd90ed
Author: Anand Jain <anand.jain@oracle.com>
Date:   Fri Jan 4 13:31:54 2019 +0800

    btrfs: introduce new ioctl to unregister a btrfs device
    
    Support for a new command that can be used eg. as a command
    
      $ btrfs device scan --forget [dev]'
    (the final name may change though)
    
    to undo the effects of 'btrfs device scan [dev]'. For this purpose
    this patch proposes to use ioctl #5 as it was empty and is next to the
    SCAN ioctl.
    
    The new ioctl BTRFS_IOC_FORGET_DEV works only on the control device
    (/dev/btrfs-control) to unregister one or all devices, devices that are
    not mounted.
    
    The argument is struct btrfs_ioctl_vol_args, ::name specifies the device
    path. To unregister all device, the path is an empty string.
    
    Again, the devices are removed only if they aren't part of a mounte
    filesystem.
    
    This new ioctl provides:
    
    - release of unwanted btrfs_fs_devices and btrfs_devices structures
      from memory if the device is not going to be mounted
    
    - ability to mount filesystem in degraded mode, when one devices is
      corrupted like in split brain raid1
    
    - running test cases which would require reloading the kernel module
      but this is not possible eg. due to mounted filesystem or built-in
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ update changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index e0763bc4158e..c195896d478f 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -837,6 +837,8 @@ enum btrfs_err_code {
 				   struct btrfs_ioctl_vol_args)
 #define BTRFS_IOC_SCAN_DEV _IOW(BTRFS_IOCTL_MAGIC, 4, \
 				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_FORGET_DEV _IOW(BTRFS_IOCTL_MAGIC, 5, \
+				   struct btrfs_ioctl_vol_args)
 /* trans start and trans end are dangerous, and only for
  * use by applications that know how to avoid the
  * resulting deadlocks

commit 7239ff4b2be8ec0c3160da7fdd1475785fdb4cb9
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Tue Oct 30 16:43:23 2018 +0200

    btrfs: Introduce support for FSID change without metadata rewrite
    
    This field is going to be used when the user wants to change the UUID
    of the filesystem without having to rewrite all metadata blocks. This
    field adds another level of indirection such that when the FSID is
    changed what really happens is the current UUID (the one with which the
    fs was created) is copied to the 'metadata_uuid' field in the superblock
    as well as a new incompat flag is set METADATA_UUID. When the kernel
    detects this flag is set it knows that the superblock in fact has 2
    UUIDs:
    
    1. Is the UUID which is user-visible, currently known as FSID.
    2. Metadata UUID - this is the UUID which is stamped into all on-disk
       datastructures belonging to this file system.
    
    When the new incompat flag is present device scanning checks whether
    both fsid/metadata_uuid of the scanned device match any of the
    registered filesystems. When the flag is not set then both UUIDs are
    equal and only the FSID is retained on disk, metadata_uuid is set only
    in-memory during mount.
    
    Additionally a new metadata_uuid field is also added to the fs_info
    struct. It's initialised either with the FSID in case METADATA_UUID
    incompat flag is not set or with the metdata_uuid of the superblock
    otherwise.
    
    This commit introduces the new fields as well as the new incompat flag
    and switches all users of the fsid to the new logic.
    
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    [ minor updates in comments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 5ca1d21fc4a7..e0763bc4158e 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -269,6 +269,7 @@ struct btrfs_ioctl_fs_info_args {
 #define BTRFS_FEATURE_INCOMPAT_RAID56		(1ULL << 7)
 #define BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA	(1ULL << 8)
 #define BTRFS_FEATURE_INCOMPAT_NO_HOLES		(1ULL << 9)
+#define BTRFS_FEATURE_INCOMPAT_METADATA_UUID	(1ULL << 10)
 
 struct btrfs_ioctl_feature_flags {
 	__u64 compat_flags;

commit 23d0b79dfaed2305b500b0215b0421701ada6b1a
Author: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
Date:   Mon May 21 10:09:44 2018 +0900

    btrfs: Add unprivileged version of ino_lookup ioctl
    
    Add unprivileged version of ino_lookup ioctl BTRFS_IOC_INO_LOOKUP_USER
    to allow normal users to call "btrfs subvolume list/show" etc. in
    combination with BTRFS_IOC_GET_SUBVOL_INFO/BTRFS_IOC_GET_SUBVOL_ROOTREF.
    
    This can be used like BTRFS_IOC_INO_LOOKUP but the argument is
    different. This is  because it always searches the fs/file tree
    correspoinding to the fd with which this ioctl is called and also
    returns the name of bottom subvolume.
    
    The main differences from original ino_lookup ioctl are:
    
      1. Read + Exec permission will be checked using inode_permission()
         during path construction. -EACCES will be returned in case
         of failure.
      2. Path construction will be stopped at the inode number which
         corresponds to the fd with which this ioctl is called. If
         constructed path does not exist under fd's inode, -EACCES
         will be returned.
      3. The name of bottom subvolume is also searched and filled.
    
    Note that the maximum length of path is shorter 256 (BTRFS_VOL_NAME_MAX+1)
    bytes than ino_lookup ioctl because of space of subvolume's name.
    
    Reviewed-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Tested-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    [ style fixes ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index f90d10478235..5ca1d21fc4a7 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -422,6 +422,21 @@ struct btrfs_ioctl_ino_lookup_args {
 	char name[BTRFS_INO_LOOKUP_PATH_MAX];
 };
 
+#define BTRFS_INO_LOOKUP_USER_PATH_MAX (4080 - BTRFS_VOL_NAME_MAX - 1)
+struct btrfs_ioctl_ino_lookup_user_args {
+	/* in, inode number containing the subvolume of 'subvolid' */
+	__u64 dirid;
+	/* in */
+	__u64 treeid;
+	/* out, name of the subvolume of 'treeid' */
+	char name[BTRFS_VOL_NAME_MAX + 1];
+	/*
+	 * out, constructed path from the directory with which the ioctl is
+	 * called to dirid
+	 */
+	char path[BTRFS_INO_LOOKUP_USER_PATH_MAX];
+};
+
 /* Search criteria for the btrfs SEARCH ioctl family. */
 struct btrfs_ioctl_search_key {
 	/*
@@ -923,5 +938,7 @@ enum btrfs_err_code {
 				struct btrfs_ioctl_get_subvol_info_args)
 #define BTRFS_IOC_GET_SUBVOL_ROOTREF _IOWR(BTRFS_IOCTL_MAGIC, 61, \
 				struct btrfs_ioctl_get_subvol_rootref_args)
+#define BTRFS_IOC_INO_LOOKUP_USER _IOWR(BTRFS_IOCTL_MAGIC, 62, \
+				struct btrfs_ioctl_ino_lookup_user_args)
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit 42e4b520c812daaf5e6177c2e4beec012ce1e2ce
Author: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
Date:   Mon May 21 10:09:43 2018 +0900

    btrfs: Add unprivileged ioctl which returns subvolume's ROOT_REF
    
    Add unprivileged ioctl BTRFS_IOC_GET_SUBVOL_ROOTREF which returns
    ROOT_REF information of the subvolume containing this inode except the
    subvolume name (this is because to prevent potential name leak). The
    subvolume name will be gained by user version of ino_lookup ioctl
    (BTRFS_IOC_INO_LOOKUP_USER) which also performs permission check.
    
    The min id of root ref's subvolume to be searched is specified by
    @min_id in struct btrfs_ioctl_get_subvol_rootref_args. After the search
    ends, @min_id is set to the last searched root ref's subvolid + 1. Also,
    if there are more root refs than BTRFS_MAX_ROOTREF_BUFFER_NUM,
    -EOVERFLOW is returned. Therefore the caller can just call this ioctl
    again without changing the argument to continue search.
    
    Reviewed-by: Qu Wenruo <wqu@suse.com>
    Reviewed-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Tested-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    [ style fixes and struct item renames ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index f8f20d72b852..f90d10478235 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -785,6 +785,22 @@ struct btrfs_ioctl_get_subvol_info_args {
 	__u64 reserved[8];
 };
 
+#define BTRFS_MAX_ROOTREF_BUFFER_NUM 255
+struct btrfs_ioctl_get_subvol_rootref_args {
+		/* in/out, minimum id of rootref's treeid to be searched */
+		__u64 min_treeid;
+
+		/* out */
+		struct {
+			__u64 treeid;
+			__u64 dirid;
+		} rootref[BTRFS_MAX_ROOTREF_BUFFER_NUM];
+
+		/* out, number of found items */
+		__u8 num_items;
+		__u8 align[7];
+};
+
 /* Error codes as returned by the kernel */
 enum btrfs_err_code {
 	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET = 1,
@@ -905,5 +921,7 @@ enum btrfs_err_code {
 					struct btrfs_ioctl_logical_ino_args)
 #define BTRFS_IOC_GET_SUBVOL_INFO _IOR(BTRFS_IOCTL_MAGIC, 60, \
 				struct btrfs_ioctl_get_subvol_info_args)
+#define BTRFS_IOC_GET_SUBVOL_ROOTREF _IOWR(BTRFS_IOCTL_MAGIC, 61, \
+				struct btrfs_ioctl_get_subvol_rootref_args)
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit b64ec075bded2b30bcd90af5aa5256d2237c885d
Author: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
Date:   Mon May 21 10:09:42 2018 +0900

    btrfs: Add unprivileged ioctl which returns subvolume information
    
    Add new unprivileged ioctl BTRFS_IOC_GET_SUBVOL_INFO which returns
    the information of subvolume containing this inode.
    (i.e. returns the information in ROOT_ITEM and ROOT_BACKREF.)
    
    Reviewed-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Tested-by: Gu Jinxiang <gujx@cn.fujitsu.com>
    Signed-off-by: Tomohiro Misono <misono.tomohiro@jp.fujitsu.com>
    [ minor style fixes, update struct comments ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index c8d99b9ca550..f8f20d72b852 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -725,6 +725,66 @@ struct btrfs_ioctl_send_args {
 	__u64 reserved[4];		/* in */
 };
 
+/*
+ * Information about a fs tree root.
+ *
+ * All items are filled by the ioctl
+ */
+struct btrfs_ioctl_get_subvol_info_args {
+	/* Id of this subvolume */
+	__u64 treeid;
+
+	/* Name of this subvolume, used to get the real name at mount point */
+	char name[BTRFS_VOL_NAME_MAX + 1];
+
+	/*
+	 * Id of the subvolume which contains this subvolume.
+	 * Zero for top-level subvolume or a deleted subvolume.
+	 */
+	__u64 parent_id;
+
+	/*
+	 * Inode number of the directory which contains this subvolume.
+	 * Zero for top-level subvolume or a deleted subvolume
+	 */
+	__u64 dirid;
+
+	/* Latest transaction id of this subvolume */
+	__u64 generation;
+
+	/* Flags of this subvolume */
+	__u64 flags;
+
+	/* UUID of this subvolume */
+	__u8 uuid[BTRFS_UUID_SIZE];
+
+	/*
+	 * UUID of the subvolume of which this subvolume is a snapshot.
+	 * All zero for a non-snapshot subvolume.
+	 */
+	__u8 parent_uuid[BTRFS_UUID_SIZE];
+
+	/*
+	 * UUID of the subvolume from which this subvolume was received.
+	 * All zero for non-received subvolume.
+	 */
+	__u8 received_uuid[BTRFS_UUID_SIZE];
+
+	/* Transaction id indicating when change/create/send/receive happened */
+	__u64 ctransid;
+	__u64 otransid;
+	__u64 stransid;
+	__u64 rtransid;
+	/* Time corresponding to c/o/s/rtransid */
+	struct btrfs_ioctl_timespec ctime;
+	struct btrfs_ioctl_timespec otime;
+	struct btrfs_ioctl_timespec stime;
+	struct btrfs_ioctl_timespec rtime;
+
+	/* Must be zero */
+	__u64 reserved[8];
+};
+
 /* Error codes as returned by the kernel */
 enum btrfs_err_code {
 	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET = 1,
@@ -843,5 +903,7 @@ enum btrfs_err_code {
 				   struct btrfs_ioctl_vol_args_v2)
 #define BTRFS_IOC_LOGICAL_INO_V2 _IOWR(BTRFS_IOCTL_MAGIC, 59, \
 					struct btrfs_ioctl_logical_ino_args)
+#define BTRFS_IOC_GET_SUBVOL_INFO _IOR(BTRFS_IOCTL_MAGIC, 60, \
+				struct btrfs_ioctl_get_subvol_info_args)
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit ad8bc4d005576e3f380ba2dab24c183519f4e9fa
Author: Anand Jain <anand.jain@oracle.com>
Date:   Wed Dec 6 11:40:10 2017 +0800

    btrfs: put btrfs_ioctl_vol_args_v2 related defines together
    
    Just a code spatial rearrangement, no functional change.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index ce615b75e855..c8d99b9ca550 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -33,7 +33,12 @@ struct btrfs_ioctl_vol_args {
 	char name[BTRFS_PATH_NAME_MAX + 1];
 };
 
-#define BTRFS_DEVICE_PATH_NAME_MAX 1024
+#define BTRFS_DEVICE_PATH_NAME_MAX	1024
+#define BTRFS_SUBVOL_NAME_MAX 		4039
+
+#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
+#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
+#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 
 #define BTRFS_DEVICE_SPEC_BY_ID		(1ULL << 3)
 
@@ -101,11 +106,7 @@ struct btrfs_ioctl_qgroup_limit_args {
  * - BTRFS_IOC_SUBVOL_GETFLAGS
  * - BTRFS_IOC_SUBVOL_SETFLAGS
  */
-#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
-#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
-#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 
-#define BTRFS_SUBVOL_NAME_MAX 4039
 struct btrfs_ioctl_vol_args_v2 {
 	__s64 fd;
 	__u64 transid;

commit 5cea7647e64657138138a3794ae172ee0fc175da
Merge: 808eb24e0e09 d28e649a5c58
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 13:35:29 2017 -0800

    Merge branch 'for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs updates from David Sterba:
     "There are some new user features and the usual load of invisible
      enhancements or cleanups.
    
      New features:
    
       - extend mount options to specify zlib compression level, -o
         compress=zlib:9
    
       - v2 of ioctl "extent to inode mapping", addressing a usecase where
         we want to retrieve more but inaccurate results and do the
         postprocessing in userspace, aiding defragmentation or
         deduplication tools
    
       - populate compression heuristics logic, do data sampling and try to
         guess compressibility by: looking for repeated patterns, counting
         unique byte values and distribution, calculating Shannon entropy;
         this will need more benchmarking and possibly fine tuning, but the
         base should be good enough
    
       - enable indexing for btrfs as lower filesystem in overlayfs
    
       - speedup page cache readahead during send on large files
    
      Internal enhancements:
    
       - more sanity checks of b-tree items when reading them from disk
    
       - more EINVAL/EUCLEAN fixups, missing BLK_STS_* conversion, other
         errno or error handling fixes
    
       - remove some homegrown IO-related logic, that's been obsoleted by
         core block layer changes (batching, plug/unplug, own counters)
    
       - add ref-verify, optional debugging feature to verify extent
         reference accounting
    
       - simplify code handling outstanding extents, make it more clear
         where and how the accounting is done
    
       - make delalloc reservations per-inode, simplify the code and make
         the logic more straightforward
    
       - extensive cleanup of delayed refs code
    
      Notable fixes:
    
       - fix send ioctl on 32bit with 64bit kernel"
    
    * 'for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux: (102 commits)
      btrfs: Fix bug for misused dev_t when lookup in dev state hash table.
      Btrfs: heuristic: add Shannon entropy calculation
      Btrfs: heuristic: add byte core set calculation
      Btrfs: heuristic: add byte set calculation
      Btrfs: heuristic: add detection of repeated data patterns
      Btrfs: heuristic: implement sampling logic
      Btrfs: heuristic: add bucket and sample counters and other defines
      Btrfs: compression: separate heuristic/compression workspaces
      btrfs: move btrfs_truncate_block out of trans handle
      btrfs: don't call btrfs_start_delalloc_roots in flushoncommit
      btrfs: track refs in a rb_tree instead of a list
      btrfs: add a comp_refs() helper
      btrfs: switch args for comp_*_refs
      btrfs: make the delalloc block rsv per inode
      btrfs: add tracepoints for outstanding extents mods
      Btrfs: rework outstanding_extents
      btrfs: increase output size for LOGICAL_INO_V2 ioctl
      btrfs: add a flags argument to LOGICAL_INO and call it LOGICAL_INO_V2
      btrfs: add a flag to iterate_inodes_from_logical to find all extent refs for uncompressed extents
      btrfs: send: remove unused code
      ...

commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 378230c163d5..6cdfd12cd14c 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 /*
  * Copyright (C) 2007 Oracle.  All rights reserved.
  *

commit d24a67b2d997c860a42516076f3315c2ad2d2884
Author: Zygo Blaxell <ce3g8jdj@umail.furryterror.org>
Date:   Fri Sep 22 13:58:46 2017 -0400

    btrfs: add a flags argument to LOGICAL_INO and call it LOGICAL_INO_V2
    
    Now that check_extent_in_eb()'s extent offset filter can be turned off,
    we need a way to do it from userspace.
    
    Add a 'flags' field to the btrfs_logical_ino_args structure to disable
    extent offset filtering, taking the place of one of the existing
    reserved[] fields.
    
    Previous versions of LOGICAL_INO neglected to check whether any of the
    reserved fields have non-zero values.  Assigning meaning to those fields
    now may change the behavior of existing programs that left these fields
    uninitialized.  The lack of a zero check also means that new programs
    have no way to know whether the kernel is honoring the flags field.
    
    To avoid these problems, define a new ioctl LOGICAL_INO_V2.  We can
    use the same argument layout as LOGICAL_INO, but shorten the reserved[]
    array by one element and turn it into the 'flags' field.  The V2 ioctl
    explicitly checks that reserved fields and unsupported flag bits are zero
    so that userspace can negotiate future feature bits as they are defined.
    
    Since the memory layouts of the two ioctls' arguments are compatible,
    there is no need for a separate function for logical_to_ino_v2 (contrast
    with tree_search_v2 vs tree_search where the layout and code are quite
    different).  A version parameter and an 'if' statement will suffice.
    
    Now that we have a flags field in logical_ino_args, add a flag
    BTRFS_LOGICAL_INO_ARGS_IGNORE_OFFSET to get the behavior we want,
    and pass it down the stack to iterate_inodes_from_logical.
    
    Motivation and background, copied from the patchset cover letter:
    
    Suppose we have a file with one extent:
    
        root@tester:~# zcat /usr/share/doc/cpio/changelog.gz > /test/a
        root@tester:~# sync
    
    Split the extent by overwriting it in the middle:
    
        root@tester:~# cat /dev/urandom | dd bs=4k seek=2 skip=2 count=1 conv=notrunc of=/test/a
    
    We should now have 3 extent refs to 2 extents, with one block unreachable.
    The extent tree looks like:
    
        root@tester:~# btrfs-debug-tree /dev/vdc -t 2
        [...]
                item 9 key (1103101952 EXTENT_ITEM 73728) itemoff 15942 itemsize 53
                        extent refs 2 gen 29 flags DATA
                        extent data backref root 5 objectid 261 offset 0 count 2
        [...]
                item 11 key (1103175680 EXTENT_ITEM 4096) itemoff 15865 itemsize 53
                        extent refs 1 gen 30 flags DATA
                        extent data backref root 5 objectid 261 offset 8192 count 1
        [...]
    
    and the ref tree looks like:
    
        root@tester:~# btrfs-debug-tree /dev/vdc -t 5
        [...]
                item 6 key (261 EXTENT_DATA 0) itemoff 15825 itemsize 53
                        extent data disk byte 1103101952 nr 73728
                        extent data offset 0 nr 8192 ram 73728
                        extent compression(none)
                item 7 key (261 EXTENT_DATA 8192) itemoff 15772 itemsize 53
                        extent data disk byte 1103175680 nr 4096
                        extent data offset 0 nr 4096 ram 4096
                        extent compression(none)
                item 8 key (261 EXTENT_DATA 12288) itemoff 15719 itemsize 53
                        extent data disk byte 1103101952 nr 73728
                        extent data offset 12288 nr 61440 ram 73728
                        extent compression(none)
        [...]
    
    There are two references to the same extent with different, non-overlapping
    byte offsets:
    
        [------------------72K extent at 1103101952----------------------]
        [--8K----------------|--4K unreachable----|--60K-----------------]
        ^                                         ^
        |                                         |
        [--8K ref offset 0--][--4K ref offset 0--][--60K ref offset 12K--]
                             |
                             v
                             [-----4K extent-----] at 1103175680
    
    We want to find all of the references to extent bytenr 1103101952.
    
    Without the patch (and without running btrfs-debug-tree), we have to
    do it with 18 LOGICAL_INO calls:
    
        root@tester:~# btrfs ins log 1103101952 -P /test/
        Using LOGICAL_INO
        inode 261 offset 0 root 5
    
        root@tester:~# for x in $(seq 0 17); do btrfs ins log $((1103101952 + x * 4096)) -P /test/; done 2>&1 | grep inode
        inode 261 offset 0 root 5
        inode 261 offset 4096 root 5   <- same extent ref as offset 0
                                       (offset 8192 returns empty set, not reachable)
        inode 261 offset 12288 root 5
        inode 261 offset 16384 root 5  \
        inode 261 offset 20480 root 5  |
        inode 261 offset 24576 root 5  |
        inode 261 offset 28672 root 5  |
        inode 261 offset 32768 root 5  |
        inode 261 offset 36864 root 5  \
        inode 261 offset 40960 root 5   > all the same extent ref as offset 12288.
        inode 261 offset 45056 root 5  /  More processing required in userspace
        inode 261 offset 49152 root 5  |  to figure out these are all duplicates.
        inode 261 offset 53248 root 5  |
        inode 261 offset 57344 root 5  |
        inode 261 offset 61440 root 5  |
        inode 261 offset 65536 root 5  |
        inode 261 offset 69632 root 5  /
    
    In the worst case the extents are 128MB long, and we have to do 32768
    iterations of the loop to find one 4K extent ref.
    
    With the patch, we just use one call to map all refs to the extent at once:
        root@tester:~# btrfs ins log 1103101952 -P /test/
        Using LOGICAL_INO_V2
        inode 261 offset 0 root 5
        inode 261 offset 12288 root 5
    
    The TREE_SEARCH ioctl allows userspace to retrieve the offset and
    extent bytenr fields easily once the root, inode and offset are known.
    This is sufficient information to build a complete map of the extent
    and all of its references.  Userspace can use this information to make
    better choices to dedup or defrag.
    
    Signed-off-by: Zygo Blaxell <ce3g8jdj@umail.furryterror.org>
    Reviewed-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Tested-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    [ copy background and motivation from cover letter ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 378230c163d5..99bb7988e6fe 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -608,10 +608,14 @@ struct btrfs_ioctl_ino_path_args {
 struct btrfs_ioctl_logical_ino_args {
 	__u64				logical;	/* in */
 	__u64				size;		/* in */
-	__u64				reserved[4];
+	__u64				reserved[3];	/* must be 0 for now */
+	__u64				flags;		/* in, v2 only */
 	/* struct btrfs_data_container	*inodes;	out   */
 	__u64				inodes;
 };
+/* Return every ref to the extent, not just those containing logical block.
+ * Requires logical == extent bytenr. */
+#define BTRFS_LOGICAL_INO_ARGS_IGNORE_OFFSET	(1ULL << 0)
 
 enum btrfs_dev_stat_values {
 	/* disk I/O failure stats */
@@ -835,5 +839,7 @@ enum btrfs_err_code {
 				   struct btrfs_ioctl_feature_flags[3])
 #define BTRFS_IOC_RM_DEV_V2 _IOW(BTRFS_IOCTL_MAGIC, 58, \
 				   struct btrfs_ioctl_vol_args_v2)
+#define BTRFS_IOC_LOGICAL_INO_V2 _IOWR(BTRFS_IOCTL_MAGIC, 59, \
+					struct btrfs_ioctl_logical_ino_args)
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit 5c1aab1dd5445ed8bdcdbb575abc1b0d7ee5b2e7
Author: Nick Terrell <terrelln@fb.com>
Date:   Wed Aug 9 19:39:02 2017 -0700

    btrfs: Add zstd support
    
    Add zstd compression and decompression support to BtrFS. zstd at its
    fastest level compresses almost as well as zlib, while offering much
    faster compression and decompression, approaching lzo speeds.
    
    I benchmarked btrfs with zstd compression against no compression, lzo
    compression, and zlib compression. I benchmarked two scenarios. Copying
    a set of files to btrfs, and then reading the files. Copying a tarball
    to btrfs, extracting it to btrfs, and then reading the extracted files.
    After every operation, I call `sync` and include the sync time.
    Between every pair of operations I unmount and remount the filesystem
    to avoid caching. The benchmark files can be found in the upstream
    zstd source repository under
    `contrib/linux-kernel/{btrfs-benchmark.sh,btrfs-extract-benchmark.sh}`
    [1] [2].
    
    I ran the benchmarks on a Ubuntu 14.04 VM with 2 cores and 4 GiB of RAM.
    The VM is running on a MacBook Pro with a 3.1 GHz Intel Core i7 processor,
    16 GB of RAM, and a SSD.
    
    The first compression benchmark is copying 10 copies of the unzipped
    Silesia corpus [3] into a BtrFS filesystem mounted with
    `-o compress-force=Method`. The decompression benchmark times how long
    it takes to `tar` all 10 copies into `/dev/null`. The compression ratio is
    measured by comparing the output of `df` and `du`. See the benchmark file
    [1] for details. I benchmarked multiple zstd compression levels, although
    the patch uses zstd level 1.
    
    | Method  | Ratio | Compression MB/s | Decompression speed |
    |---------|-------|------------------|---------------------|
    | None    |  0.99 |              504 |                 686 |
    | lzo     |  1.66 |              398 |                 442 |
    | zlib    |  2.58 |               65 |                 241 |
    | zstd 1  |  2.57 |              260 |                 383 |
    | zstd 3  |  2.71 |              174 |                 408 |
    | zstd 6  |  2.87 |               70 |                 398 |
    | zstd 9  |  2.92 |               43 |                 406 |
    | zstd 12 |  2.93 |               21 |                 408 |
    | zstd 15 |  3.01 |               11 |                 354 |
    
    The next benchmark first copies `linux-4.11.6.tar` [4] to btrfs. Then it
    measures the compression ratio, extracts the tar, and deletes the tar.
    Then it measures the compression ratio again, and `tar`s the extracted
    files into `/dev/null`. See the benchmark file [2] for details.
    
    | Method | Tar Ratio | Extract Ratio | Copy (s) | Extract (s)| Read (s) |
    |--------|-----------|---------------|----------|------------|----------|
    | None   |      0.97 |          0.78 |    0.981 |      5.501 |    8.807 |
    | lzo    |      2.06 |          1.38 |    1.631 |      8.458 |    8.585 |
    | zlib   |      3.40 |          1.86 |    7.750 |     21.544 |   11.744 |
    | zstd 1 |      3.57 |          1.85 |    2.579 |     11.479 |    9.389 |
    
    [1] https://github.com/facebook/zstd/blob/dev/contrib/linux-kernel/btrfs-benchmark.sh
    [2] https://github.com/facebook/zstd/blob/dev/contrib/linux-kernel/btrfs-extract-benchmark.sh
    [3] http://sun.aei.polsl.pl/~sdeor/index.php?page=silesia
    [4] https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.11.6.tar.xz
    
    zstd source repository: https://github.com/facebook/zstd
    
    Signed-off-by: Nick Terrell <terrelln@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 9aa74f317747..378230c163d5 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -255,13 +255,7 @@ struct btrfs_ioctl_fs_info_args {
 #define BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL	(1ULL << 1)
 #define BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS	(1ULL << 2)
 #define BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO	(1ULL << 3)
-/*
- * some patches floated around with a second compression method
- * lets save that incompat here for when they do get in
- * Note we don't actually support it, we're just reserving the
- * number
- */
-#define BTRFS_FEATURE_INCOMPAT_COMPRESS_LZOv2	(1ULL << 4)
+#define BTRFS_FEATURE_INCOMPAT_COMPRESS_ZSTD	(1ULL << 4)
 
 /*
  * older kernels tried to do bigger metadata blocks, but the

commit 1a63143dc18b2c6a2233d1c5afce95205d2676f4
Author: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
Date:   Tue Jun 6 00:20:32 2017 +0200

    Btrfs: btrfs_ioctl_search_key documentation
    
    A programmer who is trying to implement calling the btrfs SEARCH
    or SEARCH_V2 ioctl will probably soon end up reading this struct
    definition.
    
    Properly document the input fields to prevent common misconceptions:
     1. The search space is linear, not 3 dimensional. The invidual min/max
     values for objectid, type and offset cannot be used to filter the
     result, they only define the endpoints of an interval.
     2. The transaction id (a.k.a. generation) filter applies only on
     transaction id of the last COW operation on a whole metadata page, not
     on individual items.
    
    Ad 1. The first misunderstanding was helped by the previous misleading
    comments on min/max type and offset:
      "keys returned will be >= min and <= max".
    
    Ad 2. For example, running btrfs balance will happily cause rewriting of
    metadata pages that contain a filesystem tree of a read only subvolume,
    causing transids to be increased.
    
    Also, improve descriptions of tree_id and nr_items and add in/out
    annotations.
    
    Signed-off-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index a456e5309238..9aa74f317747 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -426,31 +426,54 @@ struct btrfs_ioctl_ino_lookup_args {
 	char name[BTRFS_INO_LOOKUP_PATH_MAX];
 };
 
+/* Search criteria for the btrfs SEARCH ioctl family. */
 struct btrfs_ioctl_search_key {
-	/* which root are we searching.  0 is the tree of tree roots */
-	__u64 tree_id;
-
-	/* keys returned will be >= min and <= max */
-	__u64 min_objectid;
-	__u64 max_objectid;
-
-	/* keys returned will be >= min and <= max */
-	__u64 min_offset;
-	__u64 max_offset;
-
-	/* max and min transids to search for */
-	__u64 min_transid;
-	__u64 max_transid;
+	/*
+	 * The tree we're searching in. 1 is the tree of tree roots, 2 is the
+	 * extent tree, etc...
+	 *
+	 * A special tree_id value of 0 will cause a search in the subvolume
+	 * tree that the inode which is passed to the ioctl is part of.
+	 */
+	__u64 tree_id;		/* in */
 
-	/* keys returned will be >= min and <= max */
-	__u32 min_type;
-	__u32 max_type;
+	/*
+	 * When doing a tree search, we're actually taking a slice from a
+	 * linear search space of 136-bit keys.
+	 *
+	 * A full 136-bit tree key is composed as:
+	 *   (objectid << 72) + (type << 64) + offset
+	 *
+	 * The individual min and max values for objectid, type and offset
+	 * define the min_key and max_key values for the search range. All
+	 * metadata items with a key in the interval [min_key, max_key] will be
+	 * returned.
+	 *
+	 * Additionally, we can filter the items returned on transaction id of
+	 * the metadata block they're stored in by specifying a transid range.
+	 * Be aware that this transaction id only denotes when the metadata
+	 * page that currently contains the item got written the last time as
+	 * result of a COW operation.  The number does not have any meaning
+	 * related to the transaction in which an individual item that is being
+	 * returned was created or changed.
+	 */
+	__u64 min_objectid;	/* in */
+	__u64 max_objectid;	/* in */
+	__u64 min_offset;	/* in */
+	__u64 max_offset;	/* in */
+	__u64 min_transid;	/* in */
+	__u64 max_transid;	/* in */
+	__u32 min_type;		/* in */
+	__u32 max_type;		/* in */
 
 	/*
-	 * how many items did userland ask for, and how many are we
-	 * returning
+	 * input: The maximum amount of results desired.
+	 * output: The actual amount of items returned, restricted by any of:
+	 *  - reaching the upper bound of the search range
+	 *  - reaching the input nr_items amount of items
+	 *  - completely filling the supplied memory buffer
 	 */
-	__u32 nr_items;
+	__u32 nr_items;		/* in/out */
 
 	/* align to 64 bits */
 	__u32 unused;

commit 261cc2cca0a8c1d817be65434052feb1db1fd961
Author: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
Date:   Wed Mar 8 18:58:43 2017 +0100

    Btrfs: consistent usage of types in balance_args
    
    The btrfs_balance_args are only used for the balance ioctl, so use __u
    instead of __le here for consistency. The __le usage was introduced in
    bc3094673f22d and dee32d0ac3719 and was probably a result of
    copy/pasting when the code was written.
    
    The usage of __le did not break anything, but it's unnecessary. Also,
    this change makes the code less confusing for the careful reader.
    
    Signed-off-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index dcfc3a5a9cb1..a456e5309238 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -291,10 +291,10 @@ struct btrfs_ioctl_feature_flags {
 struct btrfs_balance_args {
 	__u64 profiles;
 	union {
-		__le64 usage;
+		__u64 usage;
 		struct {
-			__le32 usage_min;
-			__le32 usage_max;
+			__u32 usage_min;
+			__u32 usage_max;
 		};
 	};
 	__u64 devid;
@@ -324,8 +324,8 @@ struct btrfs_balance_args {
 	 * Process chunks that cross stripes_min..stripes_max devices,
 	 * BTRFS_BALANCE_ARGS_STRIPES_RANGE
 	 */
-	__le32 stripes_min;
-	__le32 stripes_max;
+	__u32 stripes_min;
+	__u32 stripes_max;
 
 	__u64 unused[6];
 } __attribute__ ((__packed__));

commit 68598d2ea886322f9b4b0058e5b288418622de95
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Wed Mar 1 02:12:50 2017 +0300

    btrfs: remove btrfs_err_str function from uapi/linux/btrfs.h
    
    btrfs_err_str function is not called from anywhere and is replicated
    in the userspace headers for btrfs-progs.
    
    It's removal also fixes the following linux/btrfs.h userspace
    compilation error:
    
    /usr/include/linux/btrfs.h: In function 'btrfs_err_str':
    /usr/include/linux/btrfs.h:740:11: error: 'NULL' undeclared (first use in this function)
        return NULL;
    
    Suggested-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index db4c253f8011..dcfc3a5a9cb1 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -713,33 +713,6 @@ enum btrfs_err_code {
 	BTRFS_ERROR_DEV_ONLY_WRITABLE,
 	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS
 };
-/* An error code to error string mapping for the kernel
-*  error codes
-*/
-static inline char *btrfs_err_str(enum btrfs_err_code err_code)
-{
-	switch (err_code) {
-		case BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET:
-			return "unable to go below two devices on raid1";
-		case BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET:
-			return "unable to go below four devices on raid10";
-		case BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET:
-			return "unable to go below two devices on raid5";
-		case BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET:
-			return "unable to go below three devices on raid6";
-		case BTRFS_ERROR_DEV_TGT_REPLACE:
-			return "unable to remove the dev_replace target dev";
-		case BTRFS_ERROR_DEV_MISSING_NOT_FOUND:
-			return "no missing devices found to remove";
-		case BTRFS_ERROR_DEV_ONLY_WRITABLE:
-			return "unable to remove the only writeable device";
-		case BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS:
-			return "add/delete/balance/replace/resize operation "\
-				"in progress";
-		default:
-			return NULL;
-	}
-}
 
 #define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \
 				   struct btrfs_ioctl_vol_args)

commit 6675df311db87aa2107a04ef97e19420953cbace
Author: Omar Sandoval <osandov@fb.com>
Date:   Thu Sep 22 17:24:22 2016 -0700

    Btrfs: catch invalid free space trees
    
    There are two separate issues that can lead to corrupted free space
    trees.
    
    1. The free space tree bitmaps had an endianness issue on big-endian
       systems which is fixed by an earlier patch in this series.
    2. btrfs-progs before v4.7.3 modified filesystems without updating the
       free space tree.
    
    To catch both of these issues at once, we need to force the free space
    tree to be rebuilt. To do so, add a FREE_SPACE_TREE_VALID compat_ro bit.
    If the bit isn't set, we know that it was either produced by a broken
    big-endian kernel or may have been corrupted by btrfs-progs.
    
    This also provides us with a way to add rudimentary read-write support
    for the free space tree to btrfs-progs: it can just clear this bit and
    have the kernel rebuild the free space tree.
    
    Cc: stable@vger.kernel.org # 4.5+
    Tested-by: Holger Hoffsttte <holger@applied-asynchrony.com>
    Tested-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index ac5eacd3055b..db4c253f8011 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -239,7 +239,17 @@ struct btrfs_ioctl_fs_info_args {
  * Used by:
  * struct btrfs_ioctl_feature_flags
  */
-#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE	(1ULL << 0)
+#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE		(1ULL << 0)
+/*
+ * Older kernels (< 4.9) on big-endian systems produced broken free space tree
+ * bitmaps, and btrfs-progs also used to corrupt the free space tree (versions
+ * < 4.7.3).  If this bit is clear, then the free space tree cannot be trusted.
+ * btrfs-progs can also intentionally clear this bit to ask the kernel to
+ * rebuild the free space tree, however this might not work on older kernels
+ * that do not know about this bit. If not sure, clear the cache manually on
+ * first mount when booting older kernel versions.
+ */
+#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE_VALID	(1ULL << 1)
 
 #define BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF	(1ULL << 0)
 #define BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL	(1ULL << 1)

commit 7af7c616fa2f1ce6c0d806b89898d2df098b4bd8
Author: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
Date:   Sun Jul 3 23:23:06 2016 +0200

    Btrfs: use the correct struct for BTRFS_IOC_LOGICAL_INO
    
    BTRFS_IOC_LOGICAL_INO takes a btrfs_ioctl_logical_ino_args as argument,
    not a btrfs_ioctl_ino_path_args. The lines were probably copy/pasted
    when the code was written.
    
    Since btrfs_ioctl_logical_ino_args and btrfs_ioctl_ino_path_args have
    the same size, the actual IOCTL definition here does not change.
    
    But, it makes the code less confusing for the reader.
    
    Signed-off-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 2bdd1e3e7007..ac5eacd3055b 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -798,7 +798,7 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 #define BTRFS_IOC_INO_PATHS _IOWR(BTRFS_IOCTL_MAGIC, 35, \
 					struct btrfs_ioctl_ino_path_args)
 #define BTRFS_IOC_LOGICAL_INO _IOWR(BTRFS_IOCTL_MAGIC, 36, \
-					struct btrfs_ioctl_ino_path_args)
+					struct btrfs_ioctl_logical_ino_args)
 #define BTRFS_IOC_SET_RECEIVED_SUBVOL _IOWR(BTRFS_IOCTL_MAGIC, 37, \
 				struct btrfs_ioctl_received_subvol_args)
 #define BTRFS_IOC_SEND _IOW(BTRFS_IOCTL_MAGIC, 38, struct btrfs_ioctl_send_args)

commit 1691cf160048c0753036d0b3fad7f239234dab56
Author: Vinson Lee <vlee@freedesktop.org>
Date:   Sat May 28 07:04:38 2016 +0000

    btrfs: Use __u64 in exported linux/btrfs.h.
    
    This patch fixes this build error.
    
    /usr/include/linux/btrfs.h:121:3: error: unknown type name u64
       u64 devid;
       ^~~
    
    Fixes: 6b526ed70cf1 ("btrfs: introduce device delete by devid")
    Signed-off-by: Vinson Lee <vlee@freedesktop.org>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 23c6960e94a4..2bdd1e3e7007 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -118,7 +118,7 @@ struct btrfs_ioctl_vol_args_v2 {
 	};
 	union {
 		char name[BTRFS_SUBVOL_NAME_MAX + 1];
-		u64 devid;
+		__u64 devid;
 	};
 };
 

commit 680834ca0ad4e9827048d4bda1e38db69c3dd1e4
Merge: 36fac9e9ff20 14b05c510631
Author: David Sterba <dsterba@suse.com>
Date:   Mon May 16 15:46:29 2016 +0200

    Merge branch 'foreign/jeffm/uapi' into for-chris-4.7-20160516
    
    # Conflicts:
    #       include/uapi/linux/btrfs.h

commit 33ca913349962208e13e894ada99b9ae6e0080ee
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:28 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, move struct btrfs_ioctl_defrag_range_args
    
    struct btrfs_ioctl_defrag_range_args is used by the BTRFS_IOC_DEFRAG_RANGE
    ioctl.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index abae362d4ec7..98aff38a70d3 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -474,9 +474,45 @@ struct btrfs_ioctl_clone_range_args {
   __u64 dest_offset;
 };
 
-/* flags for the defrag range ioctl */
+/*
+ * flags definition for the defrag range ioctl
+ *
+ * Used by:
+ * struct btrfs_ioctl_defrag_range_args.flags
+ */
 #define BTRFS_DEFRAG_RANGE_COMPRESS 1
 #define BTRFS_DEFRAG_RANGE_START_IO 2
+struct btrfs_ioctl_defrag_range_args {
+	/* start of the defrag operation */
+	__u64 start;
+
+	/* number of bytes to defrag, use (u64)-1 to say all */
+	__u64 len;
+
+	/*
+	 * flags for the operation, which can include turning
+	 * on compression for this one defrag
+	 */
+	__u64 flags;
+
+	/*
+	 * any extent bigger than this will be considered
+	 * already defragged.  Use 0 to take the kernel default
+	 * Use 1 to say every single extent must be rewritten
+	 */
+	__u32 extent_thresh;
+
+	/*
+	 * which compression method to use if turning on compression
+	 * for this defrag operation.  If unspecified, zlib will
+	 * be used
+	 */
+	__u32 compress_type;
+
+	/* spare for later */
+	__u32 unused[4];
+};
+
 
 #define BTRFS_SAME_DATA_DIFFERS	1
 /* For extent-same ioctl */

commit 04cd01dffbf9be14ccc51595280c8dc8c318a9c9
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:27 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, move balance flags
    
    The BTRFS_BALANCE_* flags are used by struct btrfs_ioctl_balance_args.flags
    and btrfs_ioctl_balance_args.{data,meta,sys}.flags in the BTRFS_IOC_BALANCE
    ioctl.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index de98717386ee..abae362d4ec7 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -317,6 +317,70 @@ struct btrfs_balance_progress {
 	__u64 completed;	/* # of chunks relocated so far */
 };
 
+/*
+ * flags definition for balance
+ *
+ * Restriper's general type filter
+ *
+ * Used by:
+ * btrfs_ioctl_balance_args.flags
+ * btrfs_balance_control.flags (internal)
+ */
+#define BTRFS_BALANCE_DATA		(1ULL << 0)
+#define BTRFS_BALANCE_SYSTEM		(1ULL << 1)
+#define BTRFS_BALANCE_METADATA		(1ULL << 2)
+
+#define BTRFS_BALANCE_TYPE_MASK		(BTRFS_BALANCE_DATA |	    \
+					 BTRFS_BALANCE_SYSTEM |	    \
+					 BTRFS_BALANCE_METADATA)
+
+#define BTRFS_BALANCE_FORCE		(1ULL << 3)
+#define BTRFS_BALANCE_RESUME		(1ULL << 4)
+
+/*
+ * flags definitions for per-type balance args
+ *
+ * Balance filters
+ *
+ * Used by:
+ * struct btrfs_balance_args
+ */
+#define BTRFS_BALANCE_ARGS_PROFILES	(1ULL << 0)
+#define BTRFS_BALANCE_ARGS_USAGE	(1ULL << 1)
+#define BTRFS_BALANCE_ARGS_DEVID	(1ULL << 2)
+#define BTRFS_BALANCE_ARGS_DRANGE	(1ULL << 3)
+#define BTRFS_BALANCE_ARGS_VRANGE	(1ULL << 4)
+#define BTRFS_BALANCE_ARGS_LIMIT	(1ULL << 5)
+#define BTRFS_BALANCE_ARGS_LIMIT_RANGE	(1ULL << 6)
+#define BTRFS_BALANCE_ARGS_STRIPES_RANGE (1ULL << 7)
+#define BTRFS_BALANCE_ARGS_USAGE_RANGE	(1ULL << 10)
+
+#define BTRFS_BALANCE_ARGS_MASK			\
+	(BTRFS_BALANCE_ARGS_PROFILES |		\
+	 BTRFS_BALANCE_ARGS_USAGE |		\
+	 BTRFS_BALANCE_ARGS_DEVID | 		\
+	 BTRFS_BALANCE_ARGS_DRANGE |		\
+	 BTRFS_BALANCE_ARGS_VRANGE |		\
+	 BTRFS_BALANCE_ARGS_LIMIT |		\
+	 BTRFS_BALANCE_ARGS_LIMIT_RANGE |	\
+	 BTRFS_BALANCE_ARGS_STRIPES_RANGE |	\
+	 BTRFS_BALANCE_ARGS_USAGE_RANGE)
+
+/*
+ * Profile changing flags.  When SOFT is set we won't relocate chunk if
+ * it already has the target profile (even though it may be
+ * half-filled).
+ */
+#define BTRFS_BALANCE_ARGS_CONVERT	(1ULL << 8)
+#define BTRFS_BALANCE_ARGS_SOFT		(1ULL << 9)
+
+
+/*
+ * flags definition for balance state
+ *
+ * Used by:
+ * struct btrfs_ioctl_balance_args.state
+ */
 #define BTRFS_BALANCE_STATE_RUNNING	(1ULL << 0)
 #define BTRFS_BALANCE_STATE_PAUSE_REQ	(1ULL << 1)
 #define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 2)

commit 18db9ac644badcb948a623791e599672edade6dd
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:26 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, move feature flags
    
    The compat/compat_ro/incompat feature flags are used by the feature set/get
    ioctls.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 0316e23b32cc..de98717386ee 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -222,6 +222,37 @@ struct btrfs_ioctl_fs_info_args {
 	__u64 reserved[122];			/* pad to 1k */
 };
 
+/*
+ * feature flags
+ *
+ * Used by:
+ * struct btrfs_ioctl_feature_flags
+ */
+#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE	(1ULL << 0)
+
+#define BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF	(1ULL << 0)
+#define BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL	(1ULL << 1)
+#define BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS	(1ULL << 2)
+#define BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO	(1ULL << 3)
+/*
+ * some patches floated around with a second compression method
+ * lets save that incompat here for when they do get in
+ * Note we don't actually support it, we're just reserving the
+ * number
+ */
+#define BTRFS_FEATURE_INCOMPAT_COMPRESS_LZOv2	(1ULL << 4)
+
+/*
+ * older kernels tried to do bigger metadata blocks, but the
+ * code was pretty buggy.  Lets not let them try anymore.
+ */
+#define BTRFS_FEATURE_INCOMPAT_BIG_METADATA	(1ULL << 5)
+
+#define BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF	(1ULL << 6)
+#define BTRFS_FEATURE_INCOMPAT_RAID56		(1ULL << 7)
+#define BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA	(1ULL << 8)
+#define BTRFS_FEATURE_INCOMPAT_NO_HOLES		(1ULL << 9)
+
 struct btrfs_ioctl_feature_flags {
 	__u64 compat_flags;
 	__u64 compat_ro_flags;

commit 884f6eca59475bc3cad5c22360523a1261bd5597
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:25 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, document subvol flags
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 9651af3c46a1..0316e23b32cc 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -34,9 +34,6 @@ struct btrfs_ioctl_vol_args {
 
 #define BTRFS_DEVICE_PATH_NAME_MAX 1024
 
-#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
-#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
-#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 #define BTRFS_FSID_SIZE 16
 #define BTRFS_UUID_SIZE 16
 #define BTRFS_UUID_UNPARSED_SIZE	37
@@ -85,6 +82,20 @@ struct btrfs_ioctl_qgroup_limit_args {
 	struct btrfs_qgroup_limit lim;
 };
 
+/*
+ * flags for subvolumes
+ *
+ * Used by:
+ * struct btrfs_ioctl_vol_args_v2.flags
+ *
+ * BTRFS_SUBVOL_RDONLY is also provided/consumed by the following ioctls:
+ * - BTRFS_IOC_SUBVOL_GETFLAGS
+ * - BTRFS_IOC_SUBVOL_SETFLAGS
+ */
+#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
+#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
+#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
+
 #define BTRFS_SUBVOL_NAME_MAX 4039
 struct btrfs_ioctl_vol_args_v2 {
 	__s64 fd;

commit 83288b60bf6668933689078973136e0c9d387b38
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:24 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, qgroup limit flags
    
    The BTRFS_QGROUP_LIMIT_* flags are required to tell the kernel which
    fields are valid when using the BTRFS_IOC_QGROUP_LIMIT ioctl.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 11eee3439994..9651af3c46a1 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -41,7 +41,19 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_UUID_SIZE 16
 #define BTRFS_UUID_UNPARSED_SIZE	37
 
-#define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)
+/*
+ * flags definition for qgroup limits
+ *
+ * Used by:
+ * struct btrfs_qgroup_limit.flags
+ * struct btrfs_qgroup_limit_item.flags
+ */
+#define BTRFS_QGROUP_LIMIT_MAX_RFER	(1ULL << 0)
+#define BTRFS_QGROUP_LIMIT_MAX_EXCL	(1ULL << 1)
+#define BTRFS_QGROUP_LIMIT_RSV_RFER	(1ULL << 2)
+#define BTRFS_QGROUP_LIMIT_RSV_EXCL	(1ULL << 3)
+#define BTRFS_QGROUP_LIMIT_RFER_CMPR	(1ULL << 4)
+#define BTRFS_QGROUP_LIMIT_EXCL_CMPR	(1ULL << 5)
 
 struct btrfs_qgroup_limit {
 	__u64	flags;
@@ -51,6 +63,14 @@ struct btrfs_qgroup_limit {
 	__u64	rsv_excl;
 };
 
+/*
+ * flags definition for qgroup inheritance
+ *
+ * Used by:
+ * struct btrfs_qgroup_inherit.flags
+ */
+#define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)
+
 struct btrfs_qgroup_inherit {
 	__u64	flags;
 	__u64	num_qgroups;

commit d4ae133b2d195d88cf5394072724adfa6ccdd64b
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Apr 1 16:14:23 2016 -0400

    btrfs: uapi/linux/btrfs.h migration, move BTRFS_LABEL_SIZE
    
    BTRFS_LABEL_SIZE is required to define the BTRFS_IOC_GET_FSLABEL and
    BTRFS_IOC_SET_FSLABEL ioctls.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Reviewed-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index dea893199257..11eee3439994 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -23,6 +23,7 @@
 
 #define BTRFS_IOCTL_MAGIC 0x94
 #define BTRFS_VOL_NAME_MAX 255
+#define BTRFS_LABEL_SIZE 256
 
 /* this should be 4k */
 #define BTRFS_PATH_NAME_MAX 4087

commit 735654ea91a06a30bfe05fdfd09c8895abf6c1bf
Author: David Sterba <dsterba@suse.com>
Date:   Mon Feb 15 18:15:21 2016 +0100

    btrfs: rename flags for vol args v2
    
    Rename BTRFS_DEVICE_BY_ID so it's more descriptive that we specify the
    device by id, it'll be part of the public API. The mask of supported
    flags is also renamed, only for internal use.
    
    The error code for unknown flags is EOPNOTSUPP, fixed.
    
    Reviewed-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 396a4efca775..3975e683af72 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -36,12 +36,13 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
 #define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
 #define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
-#define BTRFS_DEVICE_BY_ID		(1ULL << 3)
-#define BTRFS_VOL_ARG_V2_FLAGS				\
+#define BTRFS_DEVICE_SPEC_BY_ID		(1ULL << 3)
+
+#define BTRFS_VOL_ARG_V2_FLAGS_SUPPORTED		\
 			(BTRFS_SUBVOL_CREATE_ASYNC |	\
 			BTRFS_SUBVOL_RDONLY |		\
 			BTRFS_SUBVOL_QGROUP_INHERIT |	\
-			BTRFS_DEVICE_BY_ID)
+			BTRFS_DEVICE_SPEC_BY_ID)
 
 #define BTRFS_FSID_SIZE 16
 #define BTRFS_UUID_SIZE 16

commit 6b526ed70cf189660d009ea6f17af77a9cca0f38
Author: Anand Jain <anand.jain@oracle.com>
Date:   Sat Feb 13 10:01:39 2016 +0800

    btrfs: introduce device delete by devid
    
    This introduces new ioctl BTRFS_IOC_RM_DEV_V2, which uses enhanced struct
    btrfs_ioctl_vol_args_v2 to carry devid as an user argument.
    
    The patch won't delete the old ioctl interface and so kernel remains
    backward compatible with user land progs.
    
    Test case/script:
    echo "0 $(blockdev --getsz /dev/sdf) linear /dev/sdf 0" | dmsetup create bad_disk
    mkfs.btrfs -f -d raid1 -m raid1 /dev/sdd /dev/sde /dev/mapper/bad_disk
    mount /dev/sdd /btrfs
    dmsetup suspend bad_disk
    echo "0 $(blockdev --getsz /dev/sdf) error /dev/sdf 0" | dmsetup load bad_disk
    dmsetup resume bad_disk
    echo "bad disk failed. now deleting/replacing"
    btrfs dev del  3  /btrfs
    echo $?
    btrfs fi show /btrfs
    umount /btrfs
    btrfs-show-super /dev/sdd | egrep num_device
    dmsetup remove bad_disk
    wipefs -a /dev/sdf
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reported-by: Martin <m_btrfs@ml1.co.uk>
    [ adjust messages, s/disk/device/ ]
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index dea893199257..396a4efca775 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -36,6 +36,13 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
 #define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
 #define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
+#define BTRFS_DEVICE_BY_ID		(1ULL << 3)
+#define BTRFS_VOL_ARG_V2_FLAGS				\
+			(BTRFS_SUBVOL_CREATE_ASYNC |	\
+			BTRFS_SUBVOL_RDONLY |		\
+			BTRFS_SUBVOL_QGROUP_INHERIT |	\
+			BTRFS_DEVICE_BY_ID)
+
 #define BTRFS_FSID_SIZE 16
 #define BTRFS_UUID_SIZE 16
 #define BTRFS_UUID_UNPARSED_SIZE	37
@@ -76,7 +83,10 @@ struct btrfs_ioctl_vol_args_v2 {
 		};
 		__u64 unused[4];
 	};
-	char name[BTRFS_SUBVOL_NAME_MAX + 1];
+	union {
+		char name[BTRFS_SUBVOL_NAME_MAX + 1];
+		u64 devid;
+	};
 };
 
 /*
@@ -659,5 +669,7 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 				   struct btrfs_ioctl_feature_flags[2])
 #define BTRFS_IOC_GET_SUPPORTED_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
 				   struct btrfs_ioctl_feature_flags[3])
+#define BTRFS_IOC_RM_DEV_V2 _IOW(BTRFS_IOCTL_MAGIC, 58, \
+				   struct btrfs_ioctl_vol_args_v2)
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit bc3094673f22d00794a8606200788e411b4ec80d
Author: David Sterba <dsterba@suse.com>
Date:   Tue Oct 20 18:22:13 2015 +0200

    btrfs: extend balance filter usage to take minimum and maximum
    
    Similar to the 'limit' filter, we can enhance the 'usage' filter to
    accept a range. The change is backward compatible, the range is applied
    only in connection with the BTRFS_BALANCE_ARGS_USAGE_RANGE flag.
    
    We don't have a usecase yet, the current syntax has been sufficient. The
    enhancement should provide parity with other range-like filters.
    
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 17a94704b183..dea893199257 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -206,7 +206,13 @@ struct btrfs_ioctl_feature_flags {
  */
 struct btrfs_balance_args {
 	__u64 profiles;
-	__u64 usage;
+	union {
+		__le64 usage;
+		struct {
+			__le32 usage_min;
+			__le32 usage_max;
+		};
+	};
 	__u64 devid;
 	__u64 pstart;
 	__u64 pend;

commit dee32d0ac3719ef8d640efaf0884111df444730f
Author: Gabrel Arthr Ptursson <gabriel@system.is>
Date:   Mon Sep 28 22:32:41 2015 +0000

    btrfs: add balance filter for stripes
    
    Balance block groups which have the given number of stripes, defined by
    a range min..max. This is useful to selectively rebalance only chunks
    that do not span enough devices, applies to RAID0/10/5/6.
    
    Signed-off-by: Gabrel Arthr Ptursson <gabriel@system.is>
    [ renamed bargs members, added to the UAPI, wrote the changelog ]
    Signed-off-by: David Sterba <dsterba@suse.com>
    
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 11f13108b78b..17a94704b183 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -229,7 +229,15 @@ struct btrfs_balance_args {
 			__u32 limit_max;
 		};
 	};
-	__u64 unused[7];
+
+	/*
+	 * Process chunks that cross stripes_min..stripes_max devices,
+	 * BTRFS_BALANCE_ARGS_STRIPES_RANGE
+	 */
+	__le32 stripes_min;
+	__le32 stripes_max;
+
+	__u64 unused[6];
 } __attribute__ ((__packed__));
 
 /* report balance progress to userspace */

commit 12907fc79818a62a2478f84f7795afa774bf7f9c
Author: David Sterba <dsterba@suse.com>
Date:   Sat Oct 10 17:16:50 2015 +0200

    btrfs: extend balance filter limit to take minimum and maximum
    
    The 'limit' filter is underdesigned, it should have been a range for
    [min,max], with some relaxed semantics when one of the bounds is
    missing. Besides that, using a full u64 for a single value is a waste of
    bytes.
    
    Let's fix both by extending the use of the u64 bytes for the [min,max]
    range. This can be done in a backward compatible way, the range will be
    interpreted only if the appropriate flag is set
    (BTRFS_BALANCE_ARGS_LIMIT_RANGE).
    
    Signed-off-by: David Sterba <dsterba@suse.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index b6dec05c7196..11f13108b78b 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -217,7 +217,18 @@ struct btrfs_balance_args {
 
 	__u64 flags;
 
-	__u64 limit;		/* limit number of processed chunks */
+	/*
+	 * BTRFS_BALANCE_ARGS_LIMIT with value 'limit'
+	 * BTRFS_BALANCE_ARGS_LIMIT_RANGE - the extend version can use minimum
+	 * and maximum
+	 */
+	union {
+		__u64 limit;		/* limit number of processed chunks */
+		struct {
+			__u32 limit_min;
+			__u32 limit_max;
+		};
+	};
 	__u64 unused[7];
 } __attribute__ ((__packed__));
 

commit eb710b152003ea74561512b3f55c1e3c71dcef39
Author: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
Date:   Wed Dec 24 14:52:04 2014 +0900

    Btrfs: Remove unnecessary placeholder in btrfs_err_code
    
    "notused" is not necessary. Set 1 to the first entry is enough.
    
    Signed-off-by: Takeuchi Satoru <takeuchi_satoru@jp.fujitsu.com
    Cc: Gui Hecheng <guihc.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 611e1c5893b4..b6dec05c7196 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -495,8 +495,7 @@ struct btrfs_ioctl_send_args {
 
 /* Error codes as returned by the kernel */
 enum btrfs_err_code {
-	notused,
-	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET,
+	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET = 1,
 	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET,
 	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET,
 	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET,

commit 2fc9f6baa24ac230166df41ed636224969523341
Author: Eryu Guan <guaneryu@gmail.com>
Date:   Mon Oct 13 12:42:12 2014 +0800

    Btrfs: return failure if btrfs_dev_replace_finishing() failed
    
    device replace could fail due to another running scrub process or any
    other errors btrfs_scrub_dev() may hit, but this failure doesn't get
    returned to userspace.
    
    The following steps could reproduce this issue
    
            mkfs -t btrfs -f /dev/sdb1 /dev/sdb2
            mount /dev/sdb1 /mnt/btrfs
            while true; do btrfs scrub start -B /mnt/btrfs >/dev/null 2>&1; done &
            btrfs replace start -Bf /dev/sdb2 /dev/sdb3 /mnt/btrfs
            # if this replace succeeded, do the following and repeat until
            # you see this log in dmesg
            # BTRFS: btrfs_scrub_dev(/dev/sdb2, 2, /dev/sdb3) failed -115
            #btrfs replace start -Bf /dev/sdb3 /dev/sdb2 /mnt/btrfs
    
            # once you see the error log in dmesg, check return value of
            # replace
            echo $?
    
    Introduce a new dev replace result
    
    BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS
    
    to catch -EINPROGRESS explicitly and return other errors directly to
    userspace.
    
    Signed-off-by: Eryu Guan <guaneryu@gmail.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 2f47824e7a36..611e1c5893b4 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -157,6 +157,7 @@ struct btrfs_ioctl_dev_replace_status_params {
 #define BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR			0
 #define BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED		1
 #define BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED		2
+#define BTRFS_IOCTL_DEV_REPLACE_RESULT_SCRUB_INPROGRESS		3
 struct btrfs_ioctl_dev_replace_args {
 	__u64 cmd;	/* in */
 	__u64 result;	/* out */

commit b2373f255cacdc1ea4da25e75a5a78949ffd9d66
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Tue Jun 3 11:36:03 2014 +0800

    btrfs: create sprout should rename fsid on the sysfs as well
    
    Creating sprout will change the fsid of the mounted root.
    do the same on the sysfs as well.
    
    reproducer:
     mount /dev/sdb /btrfs (seed disk)
     btrfs dev add /dev/sdc /btrfs
     mount -o rw,remount /btrfs
     btrfs dev del /dev/sdb /btrfs
     mount /dev/sdb /btrfs
    
    Error:
    kobject_add_internal failed for fe350492-dc28-4051-a601-e017b17e6145 with -EEXIST, don't try to register things with the same name in the same directory.
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 6f9c38ce45c7..2f47824e7a36 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -38,6 +38,7 @@ struct btrfs_ioctl_vol_args {
 #define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
 #define BTRFS_FSID_SIZE 16
 #define BTRFS_UUID_SIZE 16
+#define BTRFS_UUID_UNPARSED_SIZE	37
 
 #define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)
 

commit cc68a8a5a4330a4bb72922d0c7a7044ae13ee692
Author: Gerhard Heift <gerhard@heift.name>
Date:   Thu Jan 30 16:24:03 2014 +0100

    btrfs: new ioctl TREE_SEARCH_V2
    
    This new ioctl call allows the user to supply a buffer of varying size in which
    a tree search can store its results. This is much more flexible if you want to
    receive items which are larger than the current fixed buffer of 3992 bytes or
    if you want to fetch more items at once. Items larger than this buffer are for
    example some of the type EXTENT_CSUM.
    
    Signed-off-by: Gerhard Heift <Gerhard@Heift.Name>
    Signed-off-by: Chris Mason <clm@fb.com>
    Acked-by: David Sterba <dsterba@suse.cz>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 7554fd381a56..6f9c38ce45c7 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -306,6 +306,14 @@ struct btrfs_ioctl_search_args {
 	char buf[BTRFS_SEARCH_ARGS_BUFSIZE];
 };
 
+struct btrfs_ioctl_search_args_v2 {
+	struct btrfs_ioctl_search_key key; /* in/out - search parameters */
+	__u64 buf_size;		   /* in - size of buffer
+					    * out - on EOVERFLOW: needed size
+					    *       to store item */
+	__u64 buf[0];                       /* out - found items */
+};
+
 struct btrfs_ioctl_clone_range_args {
   __s64 src_fd;
   __u64 src_offset, src_length;
@@ -558,6 +566,8 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 				struct btrfs_ioctl_defrag_range_args)
 #define BTRFS_IOC_TREE_SEARCH _IOWR(BTRFS_IOCTL_MAGIC, 17, \
 				   struct btrfs_ioctl_search_args)
+#define BTRFS_IOC_TREE_SEARCH_V2 _IOWR(BTRFS_IOCTL_MAGIC, 17, \
+					   struct btrfs_ioctl_search_args_v2)
 #define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \
 				   struct btrfs_ioctl_ino_lookup_args)
 #define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)

commit 80a773fbfc2d6b5b2478377e8ac271d495f55e73
Author: David Sterba <dsterba@suse.cz>
Date:   Wed May 7 18:17:06 2014 +0200

    btrfs: retrieve more info from FS_INFO ioctl
    
    Provide the basic information about filesystem through the ioctl:
    * b-tree node size (same as leaf size)
    * sector size
    * expected alignment of CLONE_RANGE and EXTENT_SAME ioctl arguments
    
    Backward compatibility: if the values are 0, kernel does not provide
    this information, the applications should ignore them.
    
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 901a3c563f60..7554fd381a56 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -181,7 +181,11 @@ struct btrfs_ioctl_fs_info_args {
 	__u64 max_id;				/* out */
 	__u64 num_devices;			/* out */
 	__u8 fsid[BTRFS_FSID_SIZE];		/* out */
-	__u64 reserved[124];			/* pad to 1k */
+	__u32 nodesize;				/* out */
+	__u32 sectorsize;			/* out */
+	__u32 clone_alignment;			/* out */
+	__u32 reserved32;
+	__u64 reserved[122];			/* pad to 1k */
 };
 
 struct btrfs_ioctl_feature_flags {

commit 7d824b6f9cf28917d8a05891ef423fb0e4e34c69
Author: David Sterba <dsterba@suse.cz>
Date:   Wed May 7 17:37:51 2014 +0200

    btrfs: balance filter: add limit of processed chunks
    
    This started as debugging helper, to watch the effects of converting
    between raid levels on multiple devices, but could be useful standalone.
    
    In my case the usage filter was not finegrained enough and led to
    converting too many chunks at once. Another example use is in connection
    with drange+devid or vrange filters that allow to work with a specific
    chunk or even with a chunk on a given device.
    
    The limit filter applies last, the value of 0 means no limiting.
    
    CC: Ilya Dryomov <idryomov@gmail.com>
    CC: Hugo Mills <hugo@carfax.org.uk>
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index b4d69092fbdb..901a3c563f60 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -211,7 +211,8 @@ struct btrfs_balance_args {
 
 	__u64 flags;
 
-	__u64 unused[8];
+	__u64 limit;		/* limit number of processed chunks */
+	__u64 unused[7];
 } __attribute__ ((__packed__));
 
 /* report balance progress to userspace */

commit 11bcac89c0d73dea42f1cb8646b532035796a5d6
Author: Chris Mason <clm@fb.com>
Date:   Fri Feb 14 13:42:13 2014 -0800

    Revert "btrfs: add ioctl to export size of global metadata reservation"
    
    This reverts commit 01e219e8069516cdb98594d417b8bb8d906ed30d.
    
    David Sterba found a different way to provide these features without adding a new
    ioctl.  We haven't released any progs with this ioctl yet, so I'm taking this out
    for now until we finalize things.
    
    Signed-off-by: Chris Mason <clm@fb.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>
    CC: Jeff Mahoney <jeffm@suse.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 1b8a0f4c9590..b4d69092fbdb 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -558,7 +558,6 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 #define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)
 #define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \
 				    struct btrfs_ioctl_space_args)
-#define BTRFS_IOC_GLOBAL_RSV _IOR(BTRFS_IOCTL_MAGIC, 20, __u64)
 #define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)
 #define BTRFS_IOC_WAIT_SYNC  _IOW(BTRFS_IOCTL_MAGIC, 22, __u64)
 #define BTRFS_IOC_SNAP_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 23, \

commit 01e219e8069516cdb98594d417b8bb8d906ed30d
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Nov 1 13:07:03 2013 -0400

    btrfs: add ioctl to export size of global metadata reservation
    
    btrfs filesystem df output will show the size of the metadata space
    and how much of it is used, and the user assumes that the difference
    is all usable space. Since that's not actually the case due to the
    global metadata reservation, we should provide the full picture to the
    user.
    
    This patch adds an ioctl that exports the size of the global metadata
    reservation so that btrfs filesystem df can report it.
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index b4d69092fbdb..1b8a0f4c9590 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -558,6 +558,7 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 #define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)
 #define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \
 				    struct btrfs_ioctl_space_args)
+#define BTRFS_IOC_GLOBAL_RSV _IOR(BTRFS_IOCTL_MAGIC, 20, __u64)
 #define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)
 #define BTRFS_IOC_WAIT_SYNC  _IOW(BTRFS_IOCTL_MAGIC, 22, __u64)
 #define BTRFS_IOC_SNAP_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 23, \

commit 2eaa055fab4e3127c9f572fda1b710cbb2acdf1c
Author: Jeff Mahoney <jeffm@suse.com>
Date:   Fri Nov 15 15:33:55 2013 -0500

    btrfs: add ioctls to query/change feature bits online
    
    There are some feature bits that require no offline setup and can
    be enabled online. I've only reviewed extended irefs, but there will
    probably be more.
    
    We introduce three new ioctls:
    - BTRFS_IOC_GET_SUPPORTED_FEATURES: query the kernel for supported features.
    - BTRFS_IOC_GET_FEATURES: query the kernel for enabled features on a per-fs
      basis, as well as querying for which features are changeable with mounted.
    - BTRFS_IOC_SET_FEATURES: change features on a per-fs basis.
    
    We introduce two new masks per feature set (_SAFE_SET and _SAFE_CLEAR) that
    allow us to define which features are safe to change at runtime.
    
    The failure modes for BTRFS_IOC_SET_FEATURES are as follows:
    - Enabling a completely unsupported feature: warns and returns -ENOTSUPP
    - Enabling a feature that can only be done offline: warns and returns -EPERM
    
    Signed-off-by: Jeff Mahoney <jeffm@suse.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 45e618921c61..b4d69092fbdb 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -184,6 +184,12 @@ struct btrfs_ioctl_fs_info_args {
 	__u64 reserved[124];			/* pad to 1k */
 };
 
+struct btrfs_ioctl_feature_flags {
+	__u64 compat_flags;
+	__u64 compat_ro_flags;
+	__u64 incompat_flags;
+};
+
 /* balance control ioctl modes */
 #define BTRFS_BALANCE_CTL_PAUSE		1
 #define BTRFS_BALANCE_CTL_CANCEL	2
@@ -606,5 +612,11 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 				    struct btrfs_ioctl_dev_replace_args)
 #define BTRFS_IOC_FILE_EXTENT_SAME _IOWR(BTRFS_IOCTL_MAGIC, 54, \
 					 struct btrfs_ioctl_same_args)
+#define BTRFS_IOC_GET_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
+				   struct btrfs_ioctl_feature_flags)
+#define BTRFS_IOC_SET_FEATURES _IOW(BTRFS_IOCTL_MAGIC, 57, \
+				   struct btrfs_ioctl_feature_flags[2])
+#define BTRFS_IOC_GET_SUPPORTED_FEATURES _IOR(BTRFS_IOCTL_MAGIC, 57, \
+				   struct btrfs_ioctl_feature_flags[3])
 
 #endif /* _UAPI_LINUX_BTRFS_H */

commit 68b823ef41f17b05ce8d04e10f0635e068451f6c
Author: Mike Frysinger <vapier@gentoo.org>
Date:   Fri Aug 16 14:02:33 2013 -0400

    Btrfs: use __u64 in exported user headers
    
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 90d7bd9d839c..45e618921c61 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -549,7 +549,7 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 				   struct btrfs_ioctl_search_args)
 #define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \
 				   struct btrfs_ioctl_ino_lookup_args)
-#define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, u64)
+#define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)
 #define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \
 				    struct btrfs_ioctl_space_args)
 #define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)

commit 416161db9b63e353a8fb79d1369779175102fca1
Author: Mark Fasheh <mfasheh@suse.de>
Date:   Tue Aug 6 11:42:51 2013 -0700

    btrfs: offline dedupe
    
    This patch adds an ioctl, BTRFS_IOC_FILE_EXTENT_SAME which will try to
    de-duplicate a list of extents across a range of files.
    
    Internally, the ioctl re-uses code from the clone ioctl. This avoids
    rewriting a large chunk of extent handling code.
    
    Userspace passes in an array of file, offset pairs along with a length
    argument. The ioctl will then (for each dedupe) do a byte-by-byte comparison
    of the user data before deduping the extent. Status and number of bytes
    deduped are returned for each operation.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.de>
    Reviewed-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 05aed70627e2..90d7bd9d839c 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -305,6 +305,31 @@ struct btrfs_ioctl_clone_range_args {
 #define BTRFS_DEFRAG_RANGE_COMPRESS 1
 #define BTRFS_DEFRAG_RANGE_START_IO 2
 
+#define BTRFS_SAME_DATA_DIFFERS	1
+/* For extent-same ioctl */
+struct btrfs_ioctl_same_extent_info {
+	__s64 fd;		/* in - destination file */
+	__u64 logical_offset;	/* in - start of extent in destination */
+	__u64 bytes_deduped;	/* out - total # of bytes we were able
+				 * to dedupe from this file */
+	/* status of this dedupe operation:
+	 * 0 if dedup succeeds
+	 * < 0 for error
+	 * == BTRFS_SAME_DATA_DIFFERS if data differs
+	 */
+	__s32 status;		/* out - see above description */
+	__u32 reserved;
+};
+
+struct btrfs_ioctl_same_args {
+	__u64 logical_offset;	/* in - start of extent in source */
+	__u64 length;		/* in - length of extent */
+	__u16 dest_count;	/* in - total elements in info array */
+	__u16 reserved1;
+	__u32 reserved2;
+	struct btrfs_ioctl_same_extent_info info[0];
+};
+
 struct btrfs_ioctl_space_info {
 	__u64 flags;
 	__u64 total_bytes;
@@ -579,4 +604,7 @@ static inline char *btrfs_err_str(enum btrfs_err_code err_code)
 				      struct btrfs_ioctl_get_dev_stats)
 #define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \
 				    struct btrfs_ioctl_dev_replace_args)
+#define BTRFS_IOC_FILE_EXTENT_SAME _IOWR(BTRFS_IOCTL_MAGIC, 54, \
+					 struct btrfs_ioctl_same_args)
+
 #endif /* _UAPI_LINUX_BTRFS_H */

commit 183860f6a0646b876645ecce0553a7ef2dd71254
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Fri May 17 10:52:45 2013 +0000

    btrfs: device delete to get errors from the kernel
    
    when user runs command btrfs dev del the raid requisite error if any
    goes to the /var/log/messages, its not good idea to clutter messages
    with these user (knowledge) errors, further user don't have to review
    the system messages to know problem with the cli it should be dropped
    to the user as part of the cli return.
    
    to bring this feature created a set of the ERROR defined
    BTRFS_ERROR_DEV* error codes and created their error string.
    
    I expect this enum to be added with other error which we might
    want to communicate to the user land
    
    v3:
    moved the code with in the file no logical change
    
    v1->v2:
    introduce error codes for the device mgmt usage
    
    v1:
    adds a parameter in the ioctl arg struct to carry the error string
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 5b683b5f63cd..05aed70627e2 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -447,6 +447,46 @@ struct btrfs_ioctl_send_args {
 	__u64 reserved[4];		/* in */
 };
 
+/* Error codes as returned by the kernel */
+enum btrfs_err_code {
+	notused,
+	BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET,
+	BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET,
+	BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET,
+	BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET,
+	BTRFS_ERROR_DEV_TGT_REPLACE,
+	BTRFS_ERROR_DEV_MISSING_NOT_FOUND,
+	BTRFS_ERROR_DEV_ONLY_WRITABLE,
+	BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS
+};
+/* An error code to error string mapping for the kernel
+*  error codes
+*/
+static inline char *btrfs_err_str(enum btrfs_err_code err_code)
+{
+	switch (err_code) {
+		case BTRFS_ERROR_DEV_RAID1_MIN_NOT_MET:
+			return "unable to go below two devices on raid1";
+		case BTRFS_ERROR_DEV_RAID10_MIN_NOT_MET:
+			return "unable to go below four devices on raid10";
+		case BTRFS_ERROR_DEV_RAID5_MIN_NOT_MET:
+			return "unable to go below two devices on raid5";
+		case BTRFS_ERROR_DEV_RAID6_MIN_NOT_MET:
+			return "unable to go below three devices on raid6";
+		case BTRFS_ERROR_DEV_TGT_REPLACE:
+			return "unable to remove the dev_replace target dev";
+		case BTRFS_ERROR_DEV_MISSING_NOT_FOUND:
+			return "no missing devices found to remove";
+		case BTRFS_ERROR_DEV_ONLY_WRITABLE:
+			return "unable to remove the only writeable device";
+		case BTRFS_ERROR_DEV_EXCL_RUN_IN_PROGRESS:
+			return "add/delete/balance/replace/resize operation "\
+				"in progress";
+		default:
+			return NULL;
+	}
+}
+
 #define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \
 				   struct btrfs_ioctl_vol_args)
 #define BTRFS_IOC_DEFRAG _IOW(BTRFS_IOCTL_MAGIC, 2, \
@@ -539,5 +579,4 @@ struct btrfs_ioctl_send_args {
 				      struct btrfs_ioctl_get_dev_stats)
 #define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \
 				    struct btrfs_ioctl_dev_replace_args)
-
 #endif /* _UAPI_LINUX_BTRFS_H */

commit 57254b6ebce4ceca02d9c8b615f6059c56c19238
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Mon May 6 19:14:17 2013 +0000

    Btrfs: add ioctl to wait for qgroup rescan completion
    
    btrfs_qgroup_wait_for_completion waits until the currently running qgroup
    operation completes. It returns immediately when no rescan process is in
    progress. This is useful to automate things around the rescan process (e.g.
    testing).
    
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 5ef0df545a2a..5b683b5f63cd 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -530,6 +530,7 @@ struct btrfs_ioctl_send_args {
 			       struct btrfs_ioctl_quota_rescan_args)
 #define BTRFS_IOC_QUOTA_RESCAN_STATUS _IOR(BTRFS_IOCTL_MAGIC, 45, \
 			       struct btrfs_ioctl_quota_rescan_args)
+#define BTRFS_IOC_QUOTA_RESCAN_WAIT _IO(BTRFS_IOCTL_MAGIC, 46)
 #define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
 				   char[BTRFS_LABEL_SIZE])
 #define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \

commit 2f2320360b0c35b86938bfc561124474f0dac6e4
Author: Jan Schmidt <list.btrfs@jan-o-sch.net>
Date:   Thu Apr 25 16:04:51 2013 +0000

    Btrfs: rescan for qgroups
    
    If qgroup tracking is out of sync, a rescan operation can be started. It
    iterates the complete extent tree and recalculates all qgroup tracking data.
    This is an expensive operation and should not be used unless required.
    
    A filesystem under rescan can still be umounted. The rescan continues on the
    next mount.  Status information is provided with a separate ioctl while a
    rescan operation is in progress.
    
    Signed-off-by: Jan Schmidt <list.btrfs@jan-o-sch.net>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 5e39e859a848..5ef0df545a2a 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -376,12 +376,18 @@ struct btrfs_ioctl_get_dev_stats {
 
 #define BTRFS_QUOTA_CTL_ENABLE	1
 #define BTRFS_QUOTA_CTL_DISABLE	2
-#define BTRFS_QUOTA_CTL_RESCAN	3
+#define BTRFS_QUOTA_CTL_RESCAN__NOTUSED	3
 struct btrfs_ioctl_quota_ctl_args {
 	__u64 cmd;
 	__u64 status;
 };
 
+struct btrfs_ioctl_quota_rescan_args {
+	__u64	flags;
+	__u64   progress;
+	__u64   reserved[6];
+};
+
 struct btrfs_ioctl_qgroup_assign_args {
 	__u64 assign;
 	__u64 src;
@@ -520,6 +526,10 @@ struct btrfs_ioctl_send_args {
 			       struct btrfs_ioctl_qgroup_create_args)
 #define BTRFS_IOC_QGROUP_LIMIT _IOR(BTRFS_IOCTL_MAGIC, 43, \
 			       struct btrfs_ioctl_qgroup_limit_args)
+#define BTRFS_IOC_QUOTA_RESCAN _IOW(BTRFS_IOCTL_MAGIC, 44, \
+			       struct btrfs_ioctl_quota_rescan_args)
+#define BTRFS_IOC_QUOTA_RESCAN_STATUS _IOR(BTRFS_IOCTL_MAGIC, 45, \
+			       struct btrfs_ioctl_quota_rescan_args)
 #define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
 				   char[BTRFS_LABEL_SIZE])
 #define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \

commit c2c71324ecb471c932bc1ff59e46ffcf82f274fc
Author: Stefan Behrens <sbehrens@giantdisaster.de>
Date:   Wed Apr 10 17:10:52 2013 +0000

    Btrfs: allow omitting stream header and end-cmd for btrfs send
    
    Two new flags are added to allow omitting the stream header and the
    end command for btrfs send streams. This is used in cases where you
    send multiple snapshots back-to-back in one stream.
    
    This used to be encoded like this (with 2 snapshots in this example):
    <stream header> + <sequence of commands> + <end cmd> +
    <stream header> + <sequence of commands> + <end cmd> + EOF
    
    The new format (if the two new flags are used) is this one:
    <stream header> + <sequence of commands> +
                      <sequence of commands> + <end cmd>
    
    Note that the currently existing receivers treat <end cmd> only as
    an indication that a new <stream header> is following. This means,
    you can just skip the sequence <end cmd> <stream header> without
    loosing compatibility. As long as an EOF is following, the currently
    existing receivers handle the new format (if the two new flags are
    used) exactly as the old one.
    
    So what is the benefit of this change? The goal is to be able to use
    a single stream (one TCP connection) to multiplex a request/response
    handshake plus Btrfs send streams, all in the same stream. In this
    case you cannot evaluate an EOF condition as an end of the Btrfs send
    stream. You need something else, and the <end cmd> is just perfect
    for this purpose.
    
    The summary is:
    The format change is driven by the need to send several Btrfs send
    streams over a single TCP connections, with the ability for a repeated
    request/response handshake in the middle. And this format change does
    not break any existing tool, it is completely compatible.
    
    You could compare the old behaviour of the Btrfs send stream to the
    one of ftp where you need a seperate request/response channel and
    newly opened data transfer channels for each file, while the new
    behaviour is more like http using a single stream for everything.
    
    Signed-off-by: Stefan Behrens <sbehrens@giantdisaster.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index fa3a5f9338fc..5e39e859a848 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -412,7 +412,25 @@ struct btrfs_ioctl_received_subvol_args {
  * search of clone sources doesn't find an extent. UPDATE_EXTENT
  * commands will be sent instead of WRITE commands.
  */
-#define BTRFS_SEND_FLAG_NO_FILE_DATA     0x1
+#define BTRFS_SEND_FLAG_NO_FILE_DATA		0x1
+
+/*
+ * Do not add the leading stream header. Used when multiple snapshots
+ * are sent back to back.
+ */
+#define BTRFS_SEND_FLAG_OMIT_STREAM_HEADER	0x2
+
+/*
+ * Omit the command at the end of the stream that indicated the end
+ * of the stream. This option is used when multiple snapshots are
+ * sent back to back.
+ */
+#define BTRFS_SEND_FLAG_OMIT_END_CMD		0x4
+
+#define BTRFS_SEND_FLAG_MASK \
+	(BTRFS_SEND_FLAG_NO_FILE_DATA | \
+	 BTRFS_SEND_FLAG_OMIT_STREAM_HEADER | \
+	 BTRFS_SEND_FLAG_OMIT_END_CMD)
 
 struct btrfs_ioctl_send_args {
 	__s64 send_fd;			/* in */

commit a8bfd4abea3da0e28f215e2a2b8c2f1ca27ebe80
Author: jeff.liu <jeff.liu@oracle.com>
Date:   Sat Jan 5 02:48:08 2013 +0000

    Btrfs: set/change the label of a mounted file system
    
    With this new ioctl(2) BTRFS_IOC_SET_FSLABEL, we can set/change the label of a mounted file system.
    
    Signed-off-by: Jie Liu <jeff.liu@oracle.com>
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Reviewed-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Goffredo Baroncelli <kreijack@inwind.it>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Reviewed-by: Goffredo Baroncelli <kreijack@inwind.it>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index 51c0b335e0c8..fa3a5f9338fc 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -504,6 +504,8 @@ struct btrfs_ioctl_send_args {
 			       struct btrfs_ioctl_qgroup_limit_args)
 #define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
 				   char[BTRFS_LABEL_SIZE])
+#define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \
+				   char[BTRFS_LABEL_SIZE])
 #define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \
 				      struct btrfs_ioctl_get_dev_stats)
 #define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \

commit 867ab667e74377160c4a683375ee5b8bf8801724
Author: jeff.liu <jeff.liu@oracle.com>
Date:   Sat Jan 5 02:48:01 2013 +0000

    Btrfs: Add a new ioctl to get the label of a mounted file system
    
    Add a new ioctl(2) BTRFS_IOC_GET_FSLABLE, so that we can get the label upon a mounted filesystem.
    
    Signed-off-by: Jie Liu <jeff.liu@oracle.com>
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Cc: Miao Xie <miaox@cn.fujitsu.com>
    Cc: Goffredo Baroncelli <kreijack@inwind.it>
    Cc: David Sterba <dsterba@suse.cz>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index dd9f1293ab35..51c0b335e0c8 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -502,6 +502,8 @@ struct btrfs_ioctl_send_args {
 			       struct btrfs_ioctl_qgroup_create_args)
 #define BTRFS_IOC_QGROUP_LIMIT _IOR(BTRFS_IOCTL_MAGIC, 43, \
 			       struct btrfs_ioctl_qgroup_limit_args)
+#define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \
+				   char[BTRFS_LABEL_SIZE])
 #define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \
 				      struct btrfs_ioctl_get_dev_stats)
 #define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \

commit cb95e7bf7ba481c3d35b238b1cd671b63f54238a
Author: Mark Fasheh <mfasheh@suse.de>
Date:   Mon Feb 4 20:54:57 2013 +0000

    btrfs: add "no file data" flag to btrfs send ioctl
    
    This patch adds the flag, BTRFS_SEND_FLAG_NO_FILE_DATA to the btrfs send
    ioctl code. When this flag is set, the btrfs send code will never write file
    data into the stream (thus also avoiding expensive reads of that data in the
    first place). BTRFS_SEND_C_UPDATE_EXTENT commands will be sent (instead of
    BTRFS_SEND_C_WRITE) with an offset, length pair indicating the extent in
    question.
    
    This patch does not affect the operation of BTRFS_SEND_C_CLONE commands -
    they will continue to be sent when a search finds an appropriate extent to
    clone from.
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.de>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
index cffbb582dd90..dd9f1293ab35 100644
--- a/include/uapi/linux/btrfs.h
+++ b/include/uapi/linux/btrfs.h
@@ -407,6 +407,13 @@ struct btrfs_ioctl_received_subvol_args {
 	__u64	reserved[16];		/* in */
 };
 
+/*
+ * Caller doesn't want file data in the send stream, even if the
+ * search of clone sources doesn't find an extent. UPDATE_EXTENT
+ * commands will be sent instead of WRITE commands.
+ */
+#define BTRFS_SEND_FLAG_NO_FILE_DATA     0x1
+
 struct btrfs_ioctl_send_args {
 	__s64 send_fd;			/* in */
 	__u64 clone_sources_count;	/* in */

commit 55e301fd57a6239ec14b91a1cf2e70b3dd135194
Author: Filipe Brandenburger <filbranden@google.com>
Date:   Tue Jan 29 06:04:50 2013 +0000

    Btrfs: move fs/btrfs/ioctl.h to include/uapi/linux/btrfs.h
    
    The header file will then be installed under /usr/include/linux so that
    userspace applications can refer to Btrfs ioctls by name and use the same
    structs used internally in the kernel.
    
    Signed-off-by: Filipe Brandenburger <filbranden@google.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>

diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h
new file mode 100644
index 000000000000..cffbb582dd90
--- /dev/null
+++ b/include/uapi/linux/btrfs.h
@@ -0,0 +1,503 @@
+/*
+ * Copyright (C) 2007 Oracle.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#ifndef _UAPI_LINUX_BTRFS_H
+#define _UAPI_LINUX_BTRFS_H
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define BTRFS_IOCTL_MAGIC 0x94
+#define BTRFS_VOL_NAME_MAX 255
+
+/* this should be 4k */
+#define BTRFS_PATH_NAME_MAX 4087
+struct btrfs_ioctl_vol_args {
+	__s64 fd;
+	char name[BTRFS_PATH_NAME_MAX + 1];
+};
+
+#define BTRFS_DEVICE_PATH_NAME_MAX 1024
+
+#define BTRFS_SUBVOL_CREATE_ASYNC	(1ULL << 0)
+#define BTRFS_SUBVOL_RDONLY		(1ULL << 1)
+#define BTRFS_SUBVOL_QGROUP_INHERIT	(1ULL << 2)
+#define BTRFS_FSID_SIZE 16
+#define BTRFS_UUID_SIZE 16
+
+#define BTRFS_QGROUP_INHERIT_SET_LIMITS	(1ULL << 0)
+
+struct btrfs_qgroup_limit {
+	__u64	flags;
+	__u64	max_rfer;
+	__u64	max_excl;
+	__u64	rsv_rfer;
+	__u64	rsv_excl;
+};
+
+struct btrfs_qgroup_inherit {
+	__u64	flags;
+	__u64	num_qgroups;
+	__u64	num_ref_copies;
+	__u64	num_excl_copies;
+	struct btrfs_qgroup_limit lim;
+	__u64	qgroups[0];
+};
+
+struct btrfs_ioctl_qgroup_limit_args {
+	__u64	qgroupid;
+	struct btrfs_qgroup_limit lim;
+};
+
+#define BTRFS_SUBVOL_NAME_MAX 4039
+struct btrfs_ioctl_vol_args_v2 {
+	__s64 fd;
+	__u64 transid;
+	__u64 flags;
+	union {
+		struct {
+			__u64 size;
+			struct btrfs_qgroup_inherit __user *qgroup_inherit;
+		};
+		__u64 unused[4];
+	};
+	char name[BTRFS_SUBVOL_NAME_MAX + 1];
+};
+
+/*
+ * structure to report errors and progress to userspace, either as a
+ * result of a finished scrub, a canceled scrub or a progress inquiry
+ */
+struct btrfs_scrub_progress {
+	__u64 data_extents_scrubbed;	/* # of data extents scrubbed */
+	__u64 tree_extents_scrubbed;	/* # of tree extents scrubbed */
+	__u64 data_bytes_scrubbed;	/* # of data bytes scrubbed */
+	__u64 tree_bytes_scrubbed;	/* # of tree bytes scrubbed */
+	__u64 read_errors;		/* # of read errors encountered (EIO) */
+	__u64 csum_errors;		/* # of failed csum checks */
+	__u64 verify_errors;		/* # of occurences, where the metadata
+					 * of a tree block did not match the
+					 * expected values, like generation or
+					 * logical */
+	__u64 no_csum;			/* # of 4k data block for which no csum
+					 * is present, probably the result of
+					 * data written with nodatasum */
+	__u64 csum_discards;		/* # of csum for which no data was found
+					 * in the extent tree. */
+	__u64 super_errors;		/* # of bad super blocks encountered */
+	__u64 malloc_errors;		/* # of internal kmalloc errors. These
+					 * will likely cause an incomplete
+					 * scrub */
+	__u64 uncorrectable_errors;	/* # of errors where either no intact
+					 * copy was found or the writeback
+					 * failed */
+	__u64 corrected_errors;		/* # of errors corrected */
+	__u64 last_physical;		/* last physical address scrubbed. In
+					 * case a scrub was aborted, this can
+					 * be used to restart the scrub */
+	__u64 unverified_errors;	/* # of occurences where a read for a
+					 * full (64k) bio failed, but the re-
+					 * check succeeded for each 4k piece.
+					 * Intermittent error. */
+};
+
+#define BTRFS_SCRUB_READONLY	1
+struct btrfs_ioctl_scrub_args {
+	__u64 devid;				/* in */
+	__u64 start;				/* in */
+	__u64 end;				/* in */
+	__u64 flags;				/* in */
+	struct btrfs_scrub_progress progress;	/* out */
+	/* pad to 1k */
+	__u64 unused[(1024-32-sizeof(struct btrfs_scrub_progress))/8];
+};
+
+#define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS	0
+#define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID	1
+struct btrfs_ioctl_dev_replace_start_params {
+	__u64 srcdevid;	/* in, if 0, use srcdev_name instead */
+	__u64 cont_reading_from_srcdev_mode;	/* in, see #define
+						 * above */
+	__u8 srcdev_name[BTRFS_DEVICE_PATH_NAME_MAX + 1];	/* in */
+	__u8 tgtdev_name[BTRFS_DEVICE_PATH_NAME_MAX + 1];	/* in */
+};
+
+#define BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED	0
+#define BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED		1
+#define BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED		2
+#define BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED		3
+#define BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED		4
+struct btrfs_ioctl_dev_replace_status_params {
+	__u64 replace_state;	/* out, see #define above */
+	__u64 progress_1000;	/* out, 0 <= x <= 1000 */
+	__u64 time_started;	/* out, seconds since 1-Jan-1970 */
+	__u64 time_stopped;	/* out, seconds since 1-Jan-1970 */
+	__u64 num_write_errors;	/* out */
+	__u64 num_uncorrectable_read_errors;	/* out */
+};
+
+#define BTRFS_IOCTL_DEV_REPLACE_CMD_START			0
+#define BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS			1
+#define BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL			2
+#define BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR			0
+#define BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED		1
+#define BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED		2
+struct btrfs_ioctl_dev_replace_args {
+	__u64 cmd;	/* in */
+	__u64 result;	/* out */
+
+	union {
+		struct btrfs_ioctl_dev_replace_start_params start;
+		struct btrfs_ioctl_dev_replace_status_params status;
+	};	/* in/out */
+
+	__u64 spare[64];
+};
+
+struct btrfs_ioctl_dev_info_args {
+	__u64 devid;				/* in/out */
+	__u8 uuid[BTRFS_UUID_SIZE];		/* in/out */
+	__u64 bytes_used;			/* out */
+	__u64 total_bytes;			/* out */
+	__u64 unused[379];			/* pad to 4k */
+	__u8 path[BTRFS_DEVICE_PATH_NAME_MAX];	/* out */
+};
+
+struct btrfs_ioctl_fs_info_args {
+	__u64 max_id;				/* out */
+	__u64 num_devices;			/* out */
+	__u8 fsid[BTRFS_FSID_SIZE];		/* out */
+	__u64 reserved[124];			/* pad to 1k */
+};
+
+/* balance control ioctl modes */
+#define BTRFS_BALANCE_CTL_PAUSE		1
+#define BTRFS_BALANCE_CTL_CANCEL	2
+
+/*
+ * this is packed, because it should be exactly the same as its disk
+ * byte order counterpart (struct btrfs_disk_balance_args)
+ */
+struct btrfs_balance_args {
+	__u64 profiles;
+	__u64 usage;
+	__u64 devid;
+	__u64 pstart;
+	__u64 pend;
+	__u64 vstart;
+	__u64 vend;
+
+	__u64 target;
+
+	__u64 flags;
+
+	__u64 unused[8];
+} __attribute__ ((__packed__));
+
+/* report balance progress to userspace */
+struct btrfs_balance_progress {
+	__u64 expected;		/* estimated # of chunks that will be
+				 * relocated to fulfill the request */
+	__u64 considered;	/* # of chunks we have considered so far */
+	__u64 completed;	/* # of chunks relocated so far */
+};
+
+#define BTRFS_BALANCE_STATE_RUNNING	(1ULL << 0)
+#define BTRFS_BALANCE_STATE_PAUSE_REQ	(1ULL << 1)
+#define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 2)
+
+struct btrfs_ioctl_balance_args {
+	__u64 flags;				/* in/out */
+	__u64 state;				/* out */
+
+	struct btrfs_balance_args data;		/* in/out */
+	struct btrfs_balance_args meta;		/* in/out */
+	struct btrfs_balance_args sys;		/* in/out */
+
+	struct btrfs_balance_progress stat;	/* out */
+
+	__u64 unused[72];			/* pad to 1k */
+};
+
+#define BTRFS_INO_LOOKUP_PATH_MAX 4080
+struct btrfs_ioctl_ino_lookup_args {
+	__u64 treeid;
+	__u64 objectid;
+	char name[BTRFS_INO_LOOKUP_PATH_MAX];
+};
+
+struct btrfs_ioctl_search_key {
+	/* which root are we searching.  0 is the tree of tree roots */
+	__u64 tree_id;
+
+	/* keys returned will be >= min and <= max */
+	__u64 min_objectid;
+	__u64 max_objectid;
+
+	/* keys returned will be >= min and <= max */
+	__u64 min_offset;
+	__u64 max_offset;
+
+	/* max and min transids to search for */
+	__u64 min_transid;
+	__u64 max_transid;
+
+	/* keys returned will be >= min and <= max */
+	__u32 min_type;
+	__u32 max_type;
+
+	/*
+	 * how many items did userland ask for, and how many are we
+	 * returning
+	 */
+	__u32 nr_items;
+
+	/* align to 64 bits */
+	__u32 unused;
+
+	/* some extra for later */
+	__u64 unused1;
+	__u64 unused2;
+	__u64 unused3;
+	__u64 unused4;
+};
+
+struct btrfs_ioctl_search_header {
+	__u64 transid;
+	__u64 objectid;
+	__u64 offset;
+	__u32 type;
+	__u32 len;
+};
+
+#define BTRFS_SEARCH_ARGS_BUFSIZE (4096 - sizeof(struct btrfs_ioctl_search_key))
+/*
+ * the buf is an array of search headers where
+ * each header is followed by the actual item
+ * the type field is expanded to 32 bits for alignment
+ */
+struct btrfs_ioctl_search_args {
+	struct btrfs_ioctl_search_key key;
+	char buf[BTRFS_SEARCH_ARGS_BUFSIZE];
+};
+
+struct btrfs_ioctl_clone_range_args {
+  __s64 src_fd;
+  __u64 src_offset, src_length;
+  __u64 dest_offset;
+};
+
+/* flags for the defrag range ioctl */
+#define BTRFS_DEFRAG_RANGE_COMPRESS 1
+#define BTRFS_DEFRAG_RANGE_START_IO 2
+
+struct btrfs_ioctl_space_info {
+	__u64 flags;
+	__u64 total_bytes;
+	__u64 used_bytes;
+};
+
+struct btrfs_ioctl_space_args {
+	__u64 space_slots;
+	__u64 total_spaces;
+	struct btrfs_ioctl_space_info spaces[0];
+};
+
+struct btrfs_data_container {
+	__u32	bytes_left;	/* out -- bytes not needed to deliver output */
+	__u32	bytes_missing;	/* out -- additional bytes needed for result */
+	__u32	elem_cnt;	/* out */
+	__u32	elem_missed;	/* out */
+	__u64	val[0];		/* out */
+};
+
+struct btrfs_ioctl_ino_path_args {
+	__u64				inum;		/* in */
+	__u64				size;		/* in */
+	__u64				reserved[4];
+	/* struct btrfs_data_container	*fspath;	   out */
+	__u64				fspath;		/* out */
+};
+
+struct btrfs_ioctl_logical_ino_args {
+	__u64				logical;	/* in */
+	__u64				size;		/* in */
+	__u64				reserved[4];
+	/* struct btrfs_data_container	*inodes;	out   */
+	__u64				inodes;
+};
+
+enum btrfs_dev_stat_values {
+	/* disk I/O failure stats */
+	BTRFS_DEV_STAT_WRITE_ERRS, /* EIO or EREMOTEIO from lower layers */
+	BTRFS_DEV_STAT_READ_ERRS, /* EIO or EREMOTEIO from lower layers */
+	BTRFS_DEV_STAT_FLUSH_ERRS, /* EIO or EREMOTEIO from lower layers */
+
+	/* stats for indirect indications for I/O failures */
+	BTRFS_DEV_STAT_CORRUPTION_ERRS, /* checksum error, bytenr error or
+					 * contents is illegal: this is an
+					 * indication that the block was damaged
+					 * during read or write, or written to
+					 * wrong location or read from wrong
+					 * location */
+	BTRFS_DEV_STAT_GENERATION_ERRS, /* an indication that blocks have not
+					 * been written */
+
+	BTRFS_DEV_STAT_VALUES_MAX
+};
+
+/* Reset statistics after reading; needs SYS_ADMIN capability */
+#define	BTRFS_DEV_STATS_RESET		(1ULL << 0)
+
+struct btrfs_ioctl_get_dev_stats {
+	__u64 devid;				/* in */
+	__u64 nr_items;				/* in/out */
+	__u64 flags;				/* in/out */
+
+	/* out values: */
+	__u64 values[BTRFS_DEV_STAT_VALUES_MAX];
+
+	__u64 unused[128 - 2 - BTRFS_DEV_STAT_VALUES_MAX]; /* pad to 1k */
+};
+
+#define BTRFS_QUOTA_CTL_ENABLE	1
+#define BTRFS_QUOTA_CTL_DISABLE	2
+#define BTRFS_QUOTA_CTL_RESCAN	3
+struct btrfs_ioctl_quota_ctl_args {
+	__u64 cmd;
+	__u64 status;
+};
+
+struct btrfs_ioctl_qgroup_assign_args {
+	__u64 assign;
+	__u64 src;
+	__u64 dst;
+};
+
+struct btrfs_ioctl_qgroup_create_args {
+	__u64 create;
+	__u64 qgroupid;
+};
+struct btrfs_ioctl_timespec {
+	__u64 sec;
+	__u32 nsec;
+};
+
+struct btrfs_ioctl_received_subvol_args {
+	char	uuid[BTRFS_UUID_SIZE];	/* in */
+	__u64	stransid;		/* in */
+	__u64	rtransid;		/* out */
+	struct btrfs_ioctl_timespec stime; /* in */
+	struct btrfs_ioctl_timespec rtime; /* out */
+	__u64	flags;			/* in */
+	__u64	reserved[16];		/* in */
+};
+
+struct btrfs_ioctl_send_args {
+	__s64 send_fd;			/* in */
+	__u64 clone_sources_count;	/* in */
+	__u64 __user *clone_sources;	/* in */
+	__u64 parent_root;		/* in */
+	__u64 flags;			/* in */
+	__u64 reserved[4];		/* in */
+};
+
+#define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \
+				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_DEFRAG _IOW(BTRFS_IOCTL_MAGIC, 2, \
+				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_RESIZE _IOW(BTRFS_IOCTL_MAGIC, 3, \
+				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_SCAN_DEV _IOW(BTRFS_IOCTL_MAGIC, 4, \
+				   struct btrfs_ioctl_vol_args)
+/* trans start and trans end are dangerous, and only for
+ * use by applications that know how to avoid the
+ * resulting deadlocks
+ */
+#define BTRFS_IOC_TRANS_START  _IO(BTRFS_IOCTL_MAGIC, 6)
+#define BTRFS_IOC_TRANS_END    _IO(BTRFS_IOCTL_MAGIC, 7)
+#define BTRFS_IOC_SYNC         _IO(BTRFS_IOCTL_MAGIC, 8)
+
+#define BTRFS_IOC_CLONE        _IOW(BTRFS_IOCTL_MAGIC, 9, int)
+#define BTRFS_IOC_ADD_DEV _IOW(BTRFS_IOCTL_MAGIC, 10, \
+				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_RM_DEV _IOW(BTRFS_IOCTL_MAGIC, 11, \
+				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_BALANCE _IOW(BTRFS_IOCTL_MAGIC, 12, \
+				   struct btrfs_ioctl_vol_args)
+
+#define BTRFS_IOC_CLONE_RANGE _IOW(BTRFS_IOCTL_MAGIC, 13, \
+				  struct btrfs_ioctl_clone_range_args)
+
+#define BTRFS_IOC_SUBVOL_CREATE _IOW(BTRFS_IOCTL_MAGIC, 14, \
+				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_SNAP_DESTROY _IOW(BTRFS_IOCTL_MAGIC, 15, \
+				struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_DEFRAG_RANGE _IOW(BTRFS_IOCTL_MAGIC, 16, \
+				struct btrfs_ioctl_defrag_range_args)
+#define BTRFS_IOC_TREE_SEARCH _IOWR(BTRFS_IOCTL_MAGIC, 17, \
+				   struct btrfs_ioctl_search_args)
+#define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \
+				   struct btrfs_ioctl_ino_lookup_args)
+#define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, u64)
+#define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \
+				    struct btrfs_ioctl_space_args)
+#define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)
+#define BTRFS_IOC_WAIT_SYNC  _IOW(BTRFS_IOCTL_MAGIC, 22, __u64)
+#define BTRFS_IOC_SNAP_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 23, \
+				   struct btrfs_ioctl_vol_args_v2)
+#define BTRFS_IOC_SUBVOL_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 24, \
+				   struct btrfs_ioctl_vol_args_v2)
+#define BTRFS_IOC_SUBVOL_GETFLAGS _IOR(BTRFS_IOCTL_MAGIC, 25, __u64)
+#define BTRFS_IOC_SUBVOL_SETFLAGS _IOW(BTRFS_IOCTL_MAGIC, 26, __u64)
+#define BTRFS_IOC_SCRUB _IOWR(BTRFS_IOCTL_MAGIC, 27, \
+			      struct btrfs_ioctl_scrub_args)
+#define BTRFS_IOC_SCRUB_CANCEL _IO(BTRFS_IOCTL_MAGIC, 28)
+#define BTRFS_IOC_SCRUB_PROGRESS _IOWR(BTRFS_IOCTL_MAGIC, 29, \
+				       struct btrfs_ioctl_scrub_args)
+#define BTRFS_IOC_DEV_INFO _IOWR(BTRFS_IOCTL_MAGIC, 30, \
+				 struct btrfs_ioctl_dev_info_args)
+#define BTRFS_IOC_FS_INFO _IOR(BTRFS_IOCTL_MAGIC, 31, \
+			       struct btrfs_ioctl_fs_info_args)
+#define BTRFS_IOC_BALANCE_V2 _IOWR(BTRFS_IOCTL_MAGIC, 32, \
+				   struct btrfs_ioctl_balance_args)
+#define BTRFS_IOC_BALANCE_CTL _IOW(BTRFS_IOCTL_MAGIC, 33, int)
+#define BTRFS_IOC_BALANCE_PROGRESS _IOR(BTRFS_IOCTL_MAGIC, 34, \
+					struct btrfs_ioctl_balance_args)
+#define BTRFS_IOC_INO_PATHS _IOWR(BTRFS_IOCTL_MAGIC, 35, \
+					struct btrfs_ioctl_ino_path_args)
+#define BTRFS_IOC_LOGICAL_INO _IOWR(BTRFS_IOCTL_MAGIC, 36, \
+					struct btrfs_ioctl_ino_path_args)
+#define BTRFS_IOC_SET_RECEIVED_SUBVOL _IOWR(BTRFS_IOCTL_MAGIC, 37, \
+				struct btrfs_ioctl_received_subvol_args)
+#define BTRFS_IOC_SEND _IOW(BTRFS_IOCTL_MAGIC, 38, struct btrfs_ioctl_send_args)
+#define BTRFS_IOC_DEVICES_READY _IOR(BTRFS_IOCTL_MAGIC, 39, \
+				     struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_QUOTA_CTL _IOWR(BTRFS_IOCTL_MAGIC, 40, \
+			       struct btrfs_ioctl_quota_ctl_args)
+#define BTRFS_IOC_QGROUP_ASSIGN _IOW(BTRFS_IOCTL_MAGIC, 41, \
+			       struct btrfs_ioctl_qgroup_assign_args)
+#define BTRFS_IOC_QGROUP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 42, \
+			       struct btrfs_ioctl_qgroup_create_args)
+#define BTRFS_IOC_QGROUP_LIMIT _IOR(BTRFS_IOCTL_MAGIC, 43, \
+			       struct btrfs_ioctl_qgroup_limit_args)
+#define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \
+				      struct btrfs_ioctl_get_dev_stats)
+#define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \
+				    struct btrfs_ioctl_dev_replace_args)
+
+#endif /* _UAPI_LINUX_BTRFS_H */
