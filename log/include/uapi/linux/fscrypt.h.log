commit e3b1078bedd323df343894a27eb3b3c34944dfd1
Author: Eric Biggers <ebiggers@google.com>
Date:   Fri May 15 13:41:41 2020 -0700

    fscrypt: add support for IV_INO_LBLK_32 policies
    
    The eMMC inline crypto standard will only specify 32 DUN bits (a.k.a. IV
    bits), unlike UFS's 64.  IV_INO_LBLK_64 is therefore not applicable, but
    an encryption format which uses one key per policy and permits the
    moving of encrypted file contents (as f2fs's garbage collector requires)
    is still desirable.
    
    To support such hardware, add a new encryption format IV_INO_LBLK_32
    that makes the best use of the 32 bits: the IV is set to
    'SipHash-2-4(inode_number) + file_logical_block_number mod 2^32', where
    the SipHash key is derived from the fscrypt master key.  We hash only
    the inode number and not also the block number, because we need to
    maintain contiguity of DUNs to merge bios.
    
    Unlike with IV_INO_LBLK_64, with this format IV reuse is possible; this
    is unavoidable given the size of the DUN.  This means this format should
    only be used where the requirements of the first paragraph apply.
    However, the hash spreads out the IVs in the whole usable range, and the
    use of a keyed hash makes it difficult for an attacker to determine
    which files use which IVs.
    
    Besides the above differences, this flag works like IV_INO_LBLK_64 in
    that on ext4 it is only allowed if the stable_inodes feature has been
    enabled to prevent inode numbers and the filesystem UUID from changing.
    
    Link: https://lore.kernel.org/r/20200515204141.251098-1-ebiggers@kernel.org
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index a10e3cdc2839..7875709ccfeb 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -19,7 +19,8 @@
 #define FSCRYPT_POLICY_FLAGS_PAD_MASK		0x03
 #define FSCRYPT_POLICY_FLAG_DIRECT_KEY		0x04
 #define FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64	0x08
-#define FSCRYPT_POLICY_FLAGS_VALID		0x0F
+#define FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32	0x10
+#define FSCRYPT_POLICY_FLAGS_VALID		0x1F
 
 /* Encryption algorithms */
 #define FSCRYPT_MODE_AES_256_XTS		1

commit e98ad464750c0894bc560d10503dae8ff90ccdac
Author: Eric Biggers <ebiggers@google.com>
Date:   Sat Mar 14 13:50:49 2020 -0700

    fscrypt: add FS_IOC_GET_ENCRYPTION_NONCE ioctl
    
    Add an ioctl FS_IOC_GET_ENCRYPTION_NONCE which retrieves the nonce from
    an encrypted file or directory.  The nonce is the 16-byte random value
    stored in the inode's encryption xattr.  It is normally used together
    with the master key to derive the inode's actual encryption key.
    
    The nonces are needed by automated tests that verify the correctness of
    the ciphertext on-disk.  Except for the IV_INO_LBLK_64 case, there's no
    way to replicate a file's ciphertext without knowing that file's nonce.
    
    The nonces aren't secret, and the existing ciphertext verification tests
    in xfstests retrieve them from disk using debugfs or dump.f2fs.  But in
    environments that lack these debugging tools, getting the nonces by
    manually parsing the filesystem structure would be very hard.
    
    To make this important type of testing much easier, let's just add an
    ioctl that retrieves the nonce.
    
    Link: https://lore.kernel.org/r/20200314205052.93294-2-ebiggers@kernel.org
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 0d8a6f47711c..a10e3cdc2839 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -163,6 +163,7 @@ struct fscrypt_get_key_status_arg {
 #define FS_IOC_REMOVE_ENCRYPTION_KEY		_IOWR('f', 24, struct fscrypt_remove_key_arg)
 #define FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS	_IOWR('f', 25, struct fscrypt_remove_key_arg)
 #define FS_IOC_GET_ENCRYPTION_KEY_STATUS	_IOWR('f', 26, struct fscrypt_get_key_status_arg)
+#define FS_IOC_GET_ENCRYPTION_NONCE		_IOR('f', 27, __u8[16])
 
 /**********************************************************************/
 

commit e933adde6f97c4b51d39250c1dad0e89bd3fb1c7
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Dec 19 10:56:24 2019 -0800

    fscrypt: include <linux/ioctl.h> in UAPI header
    
    <linux/fscrypt.h> defines ioctl numbers using the macros like _IOWR()
    which are defined in <linux/ioctl.h>, so <linux/ioctl.h> should be
    included as a prerequisite, like it is in many other kernel headers.
    
    In practice this doesn't really matter since anyone referencing these
    ioctl numbers will almost certainly include <sys/ioctl.h> too in order
    to actually call ioctl().  But we might as well fix this.
    
    Link: https://lore.kernel.org/r/20191219185624.21251-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index d5112a24e8b9..0d8a6f47711c 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -8,6 +8,7 @@
 #ifndef _UAPI_LINUX_FSCRYPT_H
 #define _UAPI_LINUX_FSCRYPT_H
 
+#include <linux/ioctl.h>
 #include <linux/types.h>
 
 /* Encryption policy flags */

commit 93edd392cad7485097c2e9068c764ae30083bb05
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Nov 19 14:24:47 2019 -0800

    fscrypt: support passing a keyring key to FS_IOC_ADD_ENCRYPTION_KEY
    
    Extend the FS_IOC_ADD_ENCRYPTION_KEY ioctl to allow the raw key to be
    specified by a Linux keyring key, rather than specified directly.
    
    This is useful because fscrypt keys belong to a particular filesystem
    instance, so they are destroyed when that filesystem is unmounted.
    Usually this is desired.  But in some cases, userspace may need to
    unmount and re-mount the filesystem while keeping the keys, e.g. during
    a system update.  This requires keeping the keys somewhere else too.
    
    The keys could be kept in memory in a userspace daemon.  But depending
    on the security architecture and assumptions, it can be preferable to
    keep them only in kernel memory, where they are unreadable by userspace.
    
    We also can't solve this by going back to the original fscrypt API
    (where for each file, the master key was looked up in the process's
    keyring hierarchy) because that caused lots of problems of its own.
    
    Therefore, add the ability for FS_IOC_ADD_ENCRYPTION_KEY to accept a
    Linux keyring key.  This solves the problem by allowing userspace to (if
    needed) save the keys securely in a Linux keyring for re-provisioning,
    while still using the new fscrypt key management ioctls.
    
    This is analogous to how dm-crypt accepts a Linux keyring key, but the
    key is then stored internally in the dm-crypt data structures rather
    than being looked up again each time the dm-crypt device is accessed.
    
    Use a custom key type "fscrypt-provisioning" rather than one of the
    existing key types such as "logon".  This is strongly desired because it
    enforces that these keys are only usable for a particular purpose: for
    fscrypt as input to a particular KDF.  Otherwise, the keys could also be
    passed to any kernel API that accepts a "logon" key with any service
    prefix, e.g. dm-crypt, UBIFS, or (recently proposed) AF_ALG.  This would
    risk leaking information about the raw key despite it ostensibly being
    unreadable.  Of course, this mistake has already been made for multiple
    kernel APIs; but since this is a new API, let's do it right.
    
    This patch has been tested using an xfstest which I wrote to test it.
    
    Link: https://lore.kernel.org/r/20191119222447.226853-1-ebiggers@kernel.org
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 1beb174ad950..d5112a24e8b9 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -109,11 +109,22 @@ struct fscrypt_key_specifier {
 	} u;
 };
 
+/*
+ * Payload of Linux keyring key of type "fscrypt-provisioning", referenced by
+ * fscrypt_add_key_arg::key_id as an alternative to fscrypt_add_key_arg::raw.
+ */
+struct fscrypt_provisioning_key_payload {
+	__u32 type;
+	__u32 __reserved;
+	__u8 raw[];
+};
+
 /* Struct passed to FS_IOC_ADD_ENCRYPTION_KEY */
 struct fscrypt_add_key_arg {
 	struct fscrypt_key_specifier key_spec;
 	__u32 raw_size;
-	__u32 __reserved[9];
+	__u32 key_id;
+	__u32 __reserved[8];
 	__u8 raw[];
 };
 

commit b103fb7653fff09e7a6fb6ba9398a41584e7ae36
Author: Eric Biggers <ebiggers@google.com>
Date:   Thu Oct 24 14:54:36 2019 -0700

    fscrypt: add support for IV_INO_LBLK_64 policies
    
    Inline encryption hardware compliant with the UFS v2.1 standard or with
    the upcoming version of the eMMC standard has the following properties:
    
    (1) Per I/O request, the encryption key is specified by a previously
        loaded keyslot.  There might be only a small number of keyslots.
    
    (2) Per I/O request, the starting IV is specified by a 64-bit "data unit
        number" (DUN).  IV bits 64-127 are assumed to be 0.  The hardware
        automatically increments the DUN for each "data unit" of
        configurable size in the request, e.g. for each filesystem block.
    
    Property (1) makes it inefficient to use the traditional fscrypt
    per-file keys.  Property (2) precludes the use of the existing
    DIRECT_KEY fscrypt policy flag, which needs at least 192 IV bits.
    
    Therefore, add a new fscrypt policy flag IV_INO_LBLK_64 which causes the
    encryption to modified as follows:
    
    - The encryption keys are derived from the master key, encryption mode
      number, and filesystem UUID.
    
    - The IVs are chosen as (inode_number << 32) | file_logical_block_num.
      For filenames encryption, file_logical_block_num is 0.
    
    Since the file nonces aren't used in the key derivation, many files may
    share the same encryption key.  This is much more efficient on the
    target hardware.  Including the inode number in the IVs and mixing the
    filesystem UUID into the keys ensures that data in different files is
    nevertheless still encrypted differently.
    
    Additionally, limiting the inode and block numbers to 32 bits and
    placing the block number in the low bits maintains compatibility with
    the 64-bit DUN convention (property (2) above).
    
    Since this scheme assumes that inode numbers are stable (which may
    preclude filesystem shrinking) and that inode and file logical block
    numbers are at most 32-bit, IV_INO_LBLK_64 will only be allowed on
    filesystems that meet these constraints.  These are acceptable
    limitations for the cases where this format would actually be used.
    
    Note that IV_INO_LBLK_64 is an on-disk format, not an implementation.
    This patch just adds support for it using the existing filesystem layer
    encryption.  A later patch will add support for inline encryption.
    
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Co-developed-by: Satya Tangirala <satyat@google.com>
    Signed-off-by: Satya Tangirala <satyat@google.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 39ccfe9311c3..1beb174ad950 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -17,7 +17,8 @@
 #define FSCRYPT_POLICY_FLAGS_PAD_32		0x03
 #define FSCRYPT_POLICY_FLAGS_PAD_MASK		0x03
 #define FSCRYPT_POLICY_FLAG_DIRECT_KEY		0x04
-#define FSCRYPT_POLICY_FLAGS_VALID		0x07
+#define FSCRYPT_POLICY_FLAG_IV_INO_LBLK_64	0x08
+#define FSCRYPT_POLICY_FLAGS_VALID		0x0F
 
 /* Encryption algorithms */
 #define FSCRYPT_MODE_AES_256_XTS		1

commit 78a1b96bcf7a0721c7852bb1475218c3cbef884a
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:47 2019 -0700

    fscrypt: add FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS ioctl
    
    Add a root-only variant of the FS_IOC_REMOVE_ENCRYPTION_KEY ioctl which
    removes all users' claims of the key, not just the current user's claim.
    I.e., it always removes the key itself, no matter how many users have
    added it.
    
    This is useful for forcing a directory to be locked, without having to
    figure out which user ID(s) the key was added under.  This is planned to
    be used by a command like 'sudo fscrypt lock DIR --all-users' in the
    fscrypt userspace tool (http://github.com/google/fscrypt).
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index b9fb775e3db8..39ccfe9311c3 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -148,6 +148,7 @@ struct fscrypt_get_key_status_arg {
 #define FS_IOC_GET_ENCRYPTION_POLICY_EX		_IOWR('f', 22, __u8[9]) /* size + version */
 #define FS_IOC_ADD_ENCRYPTION_KEY		_IOWR('f', 23, struct fscrypt_add_key_arg)
 #define FS_IOC_REMOVE_ENCRYPTION_KEY		_IOWR('f', 24, struct fscrypt_remove_key_arg)
+#define FS_IOC_REMOVE_ENCRYPTION_KEY_ALL_USERS	_IOWR('f', 25, struct fscrypt_remove_key_arg)
 #define FS_IOC_GET_ENCRYPTION_KEY_STATUS	_IOWR('f', 26, struct fscrypt_get_key_status_arg)
 
 /**********************************************************************/

commit 23c688b54016eed15d39f4387ca9da241e165922
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:47 2019 -0700

    fscrypt: allow unprivileged users to add/remove keys for v2 policies
    
    Allow the FS_IOC_ADD_ENCRYPTION_KEY and FS_IOC_REMOVE_ENCRYPTION_KEY
    ioctls to be used by non-root users to add and remove encryption keys
    from the filesystem-level crypto keyrings, subject to limitations.
    
    Motivation: while privileged fscrypt key management is sufficient for
    some users (e.g. Android and Chromium OS, where a privileged process
    manages all keys), the old API by design also allows non-root users to
    set up and use encrypted directories, and we don't want to regress on
    that.  Especially, we don't want to force users to continue using the
    old API, running into the visibility mismatch between files and keyrings
    and being unable to "lock" encrypted directories.
    
    Intuitively, the ioctls have to be privileged since they manipulate
    filesystem-level state.  However, it's actually safe to make them
    unprivileged if we very carefully enforce some specific limitations.
    
    First, each key must be identified by a cryptographic hash so that a
    user can't add the wrong key for another user's files.  For v2
    encryption policies, we use the key_identifier for this.  v1 policies
    don't have this, so managing keys for them remains privileged.
    
    Second, each key a user adds is charged to their quota for the keyrings
    service.  Thus, a user can't exhaust memory by adding a huge number of
    keys.  By default each non-root user is allowed up to 200 keys; this can
    be changed using the existing sysctl 'kernel.keys.maxkeys'.
    
    Third, if multiple users add the same key, we keep track of those users
    of the key (of which there remains a single copy), and won't really
    remove the key, i.e. "lock" the encrypted files, until all those users
    have removed it.  This prevents denial of service attacks that would be
    possible under simpler schemes, such allowing the first user who added a
    key to remove it -- since that could be a malicious user who has
    compromised the key.  Of course, encryption keys should be kept secret,
    but the idea is that using encryption should never be *less* secure than
    not using encryption, even if your key was compromised.
    
    We tolerate that a user will be unable to really remove a key, i.e.
    unable to "lock" their encrypted files, if another user has added the
    same key.  But in a sense, this is actually a good thing because it will
    avoid providing a false notion of security where a key appears to have
    been removed when actually it's still in memory, available to any
    attacker who compromises the operating system kernel.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index f961ebf83e98..b9fb775e3db8 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -120,6 +120,7 @@ struct fscrypt_add_key_arg {
 struct fscrypt_remove_key_arg {
 	struct fscrypt_key_specifier key_spec;
 #define FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY	0x00000001
+#define FSCRYPT_KEY_REMOVAL_STATUS_FLAG_OTHER_USERS	0x00000002
 	__u32 removal_status_flags;	/* output */
 	__u32 __reserved[5];
 };
@@ -135,7 +136,10 @@ struct fscrypt_get_key_status_arg {
 #define FSCRYPT_KEY_STATUS_PRESENT		2
 #define FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED	3
 	__u32 status;
-	__u32 __out_reserved[15];
+#define FSCRYPT_KEY_STATUS_FLAG_ADDED_BY_SELF   0x00000001
+	__u32 status_flags;
+	__u32 user_count;
+	__u32 __out_reserved[13];
 };
 
 #define FS_IOC_SET_ENCRYPTION_POLICY		_IOR('f', 19, struct fscrypt_policy)

commit 5dae460c2292dbbdac3a7a982cd566f470d957a2
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:47 2019 -0700

    fscrypt: v2 encryption policy support
    
    Add a new fscrypt policy version, "v2".  It has the following changes
    from the original policy version, which we call "v1" (*):
    
    - Master keys (the user-provided encryption keys) are only ever used as
      input to HKDF-SHA512.  This is more flexible and less error-prone, and
      it avoids the quirks and limitations of the AES-128-ECB based KDF.
      Three classes of cryptographically isolated subkeys are defined:
    
        - Per-file keys, like used in v1 policies except for the new KDF.
    
        - Per-mode keys.  These implement the semantics of the DIRECT_KEY
          flag, which for v1 policies made the master key be used directly.
          These are also planned to be used for inline encryption when
          support for it is added.
    
        - Key identifiers (see below).
    
    - Each master key is identified by a 16-byte master_key_identifier,
      which is derived from the key itself using HKDF-SHA512.  This prevents
      users from associating the wrong key with an encrypted file or
      directory.  This was easily possible with v1 policies, which
      identified the key by an arbitrary 8-byte master_key_descriptor.
    
    - The key must be provided in the filesystem-level keyring, not in a
      process-subscribed keyring.
    
    The following UAPI additions are made:
    
    - The existing ioctl FS_IOC_SET_ENCRYPTION_POLICY can now be passed a
      fscrypt_policy_v2 to set a v2 encryption policy.  It's disambiguated
      from fscrypt_policy/fscrypt_policy_v1 by the version code prefix.
    
    - A new ioctl FS_IOC_GET_ENCRYPTION_POLICY_EX is added.  It allows
      getting the v1 or v2 encryption policy of an encrypted file or
      directory.  The existing FS_IOC_GET_ENCRYPTION_POLICY ioctl could not
      be used because it did not have a way for userspace to indicate which
      policy structure is expected.  The new ioctl includes a size field, so
      it is extensible to future fscrypt policy versions.
    
    - The ioctls FS_IOC_ADD_ENCRYPTION_KEY, FS_IOC_REMOVE_ENCRYPTION_KEY,
      and FS_IOC_GET_ENCRYPTION_KEY_STATUS now support managing keys for v2
      encryption policies.  Such keys are kept logically separate from keys
      for v1 encryption policies, and are identified by 'identifier' rather
      than by 'descriptor'.  The 'identifier' need not be provided when
      adding a key, since the kernel will calculate it anyway.
    
    This patch temporarily keeps adding/removing v2 policy keys behind the
    same permission check done for adding/removing v1 policy keys:
    capable(CAP_SYS_ADMIN).  However, the next patch will carefully take
    advantage of the cryptographically secure master_key_identifier to allow
    non-root users to add/remove v2 policy keys, thus providing a full
    replacement for v1 policies.
    
    (*) Actually, in the API fscrypt_policy::version is 0 while on-disk
        fscrypt_context::format is 1.  But I believe it makes the most sense
        to advance both to '2' to have them be in sync, and to consider the
        numbering to start at 1 except for the API quirk.
    
    Reviewed-by: Paul Crowley <paulcrowley@google.com>
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index ed5995b15016..f961ebf83e98 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -10,15 +10,13 @@
 
 #include <linux/types.h>
 
-#define FSCRYPT_KEY_DESCRIPTOR_SIZE	8
-
 /* Encryption policy flags */
 #define FSCRYPT_POLICY_FLAGS_PAD_4		0x00
 #define FSCRYPT_POLICY_FLAGS_PAD_8		0x01
 #define FSCRYPT_POLICY_FLAGS_PAD_16		0x02
 #define FSCRYPT_POLICY_FLAGS_PAD_32		0x03
 #define FSCRYPT_POLICY_FLAGS_PAD_MASK		0x03
-#define FSCRYPT_POLICY_FLAG_DIRECT_KEY		0x04	/* use master key directly */
+#define FSCRYPT_POLICY_FLAG_DIRECT_KEY		0x04
 #define FSCRYPT_POLICY_FLAGS_VALID		0x07
 
 /* Encryption algorithms */
@@ -27,14 +25,24 @@
 #define FSCRYPT_MODE_AES_128_CBC		5
 #define FSCRYPT_MODE_AES_128_CTS		6
 #define FSCRYPT_MODE_ADIANTUM			9
+#define __FSCRYPT_MODE_MAX			9
 
-struct fscrypt_policy {
+/*
+ * Legacy policy version; ad-hoc KDF and no key verification.
+ * For new encrypted directories, use fscrypt_policy_v2 instead.
+ *
+ * Careful: the .version field for this is actually 0, not 1.
+ */
+#define FSCRYPT_POLICY_V1		0
+#define FSCRYPT_KEY_DESCRIPTOR_SIZE	8
+struct fscrypt_policy_v1 {
 	__u8 version;
 	__u8 contents_encryption_mode;
 	__u8 filenames_encryption_mode;
 	__u8 flags;
 	__u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
 };
+#define fscrypt_policy	fscrypt_policy_v1
 
 /*
  * Process-subscribed "logon" key description prefix and payload format.
@@ -50,14 +58,45 @@ struct fscrypt_key {
 };
 
 /*
- * Keys are specified by an arbitrary 8-byte key "descriptor",
- * matching fscrypt_policy::master_key_descriptor.
+ * New policy version with HKDF and key verification (recommended).
+ */
+#define FSCRYPT_POLICY_V2		2
+#define FSCRYPT_KEY_IDENTIFIER_SIZE	16
+struct fscrypt_policy_v2 {
+	__u8 version;
+	__u8 contents_encryption_mode;
+	__u8 filenames_encryption_mode;
+	__u8 flags;
+	__u8 __reserved[4];
+	__u8 master_key_identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];
+};
+
+/* Struct passed to FS_IOC_GET_ENCRYPTION_POLICY_EX */
+struct fscrypt_get_policy_ex_arg {
+	__u64 policy_size; /* input/output */
+	union {
+		__u8 version;
+		struct fscrypt_policy_v1 v1;
+		struct fscrypt_policy_v2 v2;
+	} policy; /* output */
+};
+
+/*
+ * v1 policy keys are specified by an arbitrary 8-byte key "descriptor",
+ * matching fscrypt_policy_v1::master_key_descriptor.
  */
 #define FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR	1
 
 /*
- * Specifies a key.  This doesn't contain the actual key itself; this is just
- * the "name" of the key.
+ * v2 policy keys are specified by a 16-byte key "identifier" which the kernel
+ * calculates as a cryptographic hash of the key itself,
+ * matching fscrypt_policy_v2::master_key_identifier.
+ */
+#define FSCRYPT_KEY_SPEC_TYPE_IDENTIFIER	2
+
+/*
+ * Specifies a key, either for v1 or v2 policies.  This doesn't contain the
+ * actual key itself; this is just the "name" of the key.
  */
 struct fscrypt_key_specifier {
 	__u32 type;	/* one of FSCRYPT_KEY_SPEC_TYPE_* */
@@ -65,6 +104,7 @@ struct fscrypt_key_specifier {
 	union {
 		__u8 __reserved[32]; /* reserve some extra space */
 		__u8 descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
+		__u8 identifier[FSCRYPT_KEY_IDENTIFIER_SIZE];
 	} u;
 };
 
@@ -101,6 +141,7 @@ struct fscrypt_get_key_status_arg {
 #define FS_IOC_SET_ENCRYPTION_POLICY		_IOR('f', 19, struct fscrypt_policy)
 #define FS_IOC_GET_ENCRYPTION_PWSALT		_IOW('f', 20, __u8[16])
 #define FS_IOC_GET_ENCRYPTION_POLICY		_IOW('f', 21, struct fscrypt_policy)
+#define FS_IOC_GET_ENCRYPTION_POLICY_EX		_IOWR('f', 22, __u8[9]) /* size + version */
 #define FS_IOC_ADD_ENCRYPTION_KEY		_IOWR('f', 23, struct fscrypt_add_key_arg)
 #define FS_IOC_REMOVE_ENCRYPTION_KEY		_IOWR('f', 24, struct fscrypt_remove_key_arg)
 #define FS_IOC_GET_ENCRYPTION_KEY_STATUS	_IOWR('f', 26, struct fscrypt_get_key_status_arg)

commit 5a7e29924dac34f0690b06906aad9d70d3c022a5
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:46 2019 -0700

    fscrypt: add FS_IOC_GET_ENCRYPTION_KEY_STATUS ioctl
    
    Add a new fscrypt ioctl, FS_IOC_GET_ENCRYPTION_KEY_STATUS.  Given a key
    specified by 'struct fscrypt_key_specifier' (the same way a key is
    specified for the other fscrypt key management ioctls), it returns
    status information in a 'struct fscrypt_get_key_status_arg'.
    
    The main motivation for this is that applications need to be able to
    check whether an encrypted directory is "unlocked" or not, so that they
    can add the key if it is not, and avoid adding the key (which may
    involve prompting the user for a passphrase) if it already is.
    
    It's possible to use some workarounds such as checking whether opening a
    regular file fails with ENOKEY, or checking whether the filenames "look
    like gibberish" or not.  However, no workaround is usable in all cases.
    
    Like the other key management ioctls, the keyrings syscalls may seem at
    first to be a good fit for this.  Unfortunately, they are not.  Even if
    we exposed the keyring ID of the ->s_master_keys keyring and gave
    everyone Search permission on it (note: currently the keyrings
    permission system would also allow everyone to "invalidate" the keyring
    too), the fscrypt keys have an additional state that doesn't map cleanly
    to the keyrings API: the secret can be removed, but we can be still
    tracking the files that were using the key, and the removal can be
    re-attempted or the secret added again.
    
    After later patches, some applications will also need a way to determine
    whether a key was added by the current user vs. by some other user.
    Reserved fields are included in fscrypt_get_key_status_arg for this and
    other future extensions.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 07f37a27a944..ed5995b15016 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -84,11 +84,26 @@ struct fscrypt_remove_key_arg {
 	__u32 __reserved[5];
 };
 
+/* Struct passed to FS_IOC_GET_ENCRYPTION_KEY_STATUS */
+struct fscrypt_get_key_status_arg {
+	/* input */
+	struct fscrypt_key_specifier key_spec;
+	__u32 __reserved[6];
+
+	/* output */
+#define FSCRYPT_KEY_STATUS_ABSENT		1
+#define FSCRYPT_KEY_STATUS_PRESENT		2
+#define FSCRYPT_KEY_STATUS_INCOMPLETELY_REMOVED	3
+	__u32 status;
+	__u32 __out_reserved[15];
+};
+
 #define FS_IOC_SET_ENCRYPTION_POLICY		_IOR('f', 19, struct fscrypt_policy)
 #define FS_IOC_GET_ENCRYPTION_PWSALT		_IOW('f', 20, __u8[16])
 #define FS_IOC_GET_ENCRYPTION_POLICY		_IOW('f', 21, struct fscrypt_policy)
 #define FS_IOC_ADD_ENCRYPTION_KEY		_IOWR('f', 23, struct fscrypt_add_key_arg)
 #define FS_IOC_REMOVE_ENCRYPTION_KEY		_IOWR('f', 24, struct fscrypt_remove_key_arg)
+#define FS_IOC_GET_ENCRYPTION_KEY_STATUS	_IOWR('f', 26, struct fscrypt_get_key_status_arg)
 
 /**********************************************************************/
 

commit b1c0ec3599f42ad372063b0235a3c33f65eb1e30
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:46 2019 -0700

    fscrypt: add FS_IOC_REMOVE_ENCRYPTION_KEY ioctl
    
    Add a new fscrypt ioctl, FS_IOC_REMOVE_ENCRYPTION_KEY.  This ioctl
    removes an encryption key that was added by FS_IOC_ADD_ENCRYPTION_KEY.
    It wipes the secret key itself, then "locks" the encrypted files and
    directories that had been unlocked using that key -- implemented by
    evicting the relevant dentries and inodes from the VFS caches.
    
    The problem this solves is that many fscrypt users want the ability to
    remove encryption keys, causing the corresponding encrypted directories
    to appear "locked" (presented in ciphertext form) again.  Moreover,
    users want removing an encryption key to *really* remove it, in the
    sense that the removed keys cannot be recovered even if kernel memory is
    compromised, e.g. by the exploit of a kernel security vulnerability or
    by a physical attack.  This is desirable after a user logs out of the
    system, for example.  In many cases users even already assume this to be
    the case and are surprised to hear when it's not.
    
    It is not sufficient to simply unlink the master key from the keyring
    (or to revoke or invalidate it), since the actual encryption transform
    objects are still pinned in memory by their inodes.  Therefore, to
    really remove a key we must also evict the relevant inodes.
    
    Currently one workaround is to run 'sync && echo 2 >
    /proc/sys/vm/drop_caches'.  But, that evicts all unused inodes in the
    system rather than just the inodes associated with the key being
    removed, causing severe performance problems.  Moreover, it requires
    root privileges, so regular users can't "lock" their encrypted files.
    
    Another workaround, used in Chromium OS kernels, is to add a new
    VFS-level ioctl FS_IOC_DROP_CACHE which is a more restricted version of
    drop_caches that operates on a single super_block.  It does:
    
            shrink_dcache_sb(sb);
            invalidate_inodes(sb, false);
    
    But it's still a hack.  Yet, the major users of filesystem encryption
    want this feature badly enough that they are actually using these hacks.
    
    To properly solve the problem, start maintaining a list of the inodes
    which have been "unlocked" using each master key.  Originally this
    wasn't possible because the kernel didn't keep track of in-use master
    keys at all.  But, with the ->s_master_keys keyring it is now possible.
    
    Then, add an ioctl FS_IOC_REMOVE_ENCRYPTION_KEY.  It finds the specified
    master key in ->s_master_keys, then wipes the secret key itself, which
    prevents any additional inodes from being unlocked with the key.  Then,
    it syncs the filesystem and evicts the inodes in the key's list.  The
    normal inode eviction code will free and wipe the per-file keys (in
    ->i_crypt_info).  Note that freeing ->i_crypt_info without evicting the
    inodes was also considered, but would have been racy.
    
    Some inodes may still be in use when a master key is removed, and we
    can't simply revoke random file descriptors, mmap's, etc.  Thus, the
    ioctl simply skips in-use inodes, and returns -EBUSY to indicate that
    some inodes weren't evicted.  The master key *secret* is still removed,
    but the fscrypt_master_key struct remains to keep track of the remaining
    inodes.  Userspace can then retry the ioctl to evict the remaining
    inodes.  Alternatively, if userspace adds the key again, the refreshed
    secret will be associated with the existing list of inodes so they
    remain correctly tracked for future key removals.
    
    The ioctl doesn't wipe pagecache pages.  Thus, we tolerate that after a
    kernel compromise some portions of plaintext file contents may still be
    recoverable from memory.  This can be solved by enabling page poisoning
    system-wide, which security conscious users may choose to do.  But it's
    very difficult to solve otherwise, e.g. note that plaintext file
    contents may have been read in other places than pagecache pages.
    
    Like FS_IOC_ADD_ENCRYPTION_KEY, FS_IOC_REMOVE_ENCRYPTION_KEY is
    initially restricted to privileged users only.  This is sufficient for
    some use cases, but not all.  A later patch will relax this restriction,
    but it will require introducing key hashes, among other changes.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 6aeca3cb0a2d..07f37a27a944 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -76,10 +76,19 @@ struct fscrypt_add_key_arg {
 	__u8 raw[];
 };
 
+/* Struct passed to FS_IOC_REMOVE_ENCRYPTION_KEY */
+struct fscrypt_remove_key_arg {
+	struct fscrypt_key_specifier key_spec;
+#define FSCRYPT_KEY_REMOVAL_STATUS_FLAG_FILES_BUSY	0x00000001
+	__u32 removal_status_flags;	/* output */
+	__u32 __reserved[5];
+};
+
 #define FS_IOC_SET_ENCRYPTION_POLICY		_IOR('f', 19, struct fscrypt_policy)
 #define FS_IOC_GET_ENCRYPTION_PWSALT		_IOW('f', 20, __u8[16])
 #define FS_IOC_GET_ENCRYPTION_POLICY		_IOW('f', 21, struct fscrypt_policy)
 #define FS_IOC_ADD_ENCRYPTION_KEY		_IOWR('f', 23, struct fscrypt_add_key_arg)
+#define FS_IOC_REMOVE_ENCRYPTION_KEY		_IOWR('f', 24, struct fscrypt_remove_key_arg)
 
 /**********************************************************************/
 

commit 22d94f493bfb408fdd764f7b1d0363af2122fba5
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:46 2019 -0700

    fscrypt: add FS_IOC_ADD_ENCRYPTION_KEY ioctl
    
    Add a new fscrypt ioctl, FS_IOC_ADD_ENCRYPTION_KEY.  This ioctl adds an
    encryption key to the filesystem's fscrypt keyring ->s_master_keys,
    making any files encrypted with that key appear "unlocked".
    
    Why we need this
    ~~~~~~~~~~~~~~~~
    
    The main problem is that the "locked/unlocked" (ciphertext/plaintext)
    status of encrypted files is global, but the fscrypt keys are not.
    fscrypt only looks for keys in the keyring(s) the process accessing the
    filesystem is subscribed to: the thread keyring, process keyring, and
    session keyring, where the session keyring may contain the user keyring.
    
    Therefore, userspace has to put fscrypt keys in the keyrings for
    individual users or sessions.  But this means that when a process with a
    different keyring tries to access encrypted files, whether they appear
    "unlocked" or not is nondeterministic.  This is because it depends on
    whether the files are currently present in the inode cache.
    
    Fixing this by consistently providing each process its own view of the
    filesystem depending on whether it has the key or not isn't feasible due
    to how the VFS caches work.  Furthermore, while sometimes users expect
    this behavior, it is misguided for two reasons.  First, it would be an
    OS-level access control mechanism largely redundant with existing access
    control mechanisms such as UNIX file permissions, ACLs, LSMs, etc.
    Encryption is actually for protecting the data at rest.
    
    Second, almost all users of fscrypt actually do need the keys to be
    global.  The largest users of fscrypt, Android and Chromium OS, achieve
    this by having PID 1 create a "session keyring" that is inherited by
    every process.  This works, but it isn't scalable because it prevents
    session keyrings from being used for any other purpose.
    
    On general-purpose Linux distros, the 'fscrypt' userspace tool [1] can't
    similarly abuse the session keyring, so to make 'sudo' work on all
    systems it has to link all the user keyrings into root's user keyring
    [2].  This is ugly and raises security concerns.  Moreover it can't make
    the keys available to system services, such as sshd trying to access the
    user's '~/.ssh' directory (see [3], [4]) or NetworkManager trying to
    read certificates from the user's home directory (see [5]); or to Docker
    containers (see [6], [7]).
    
    By having an API to add a key to the *filesystem* we'll be able to fix
    the above bugs, remove userspace workarounds, and clearly express the
    intended semantics: the locked/unlocked status of an encrypted directory
    is global, and encryption is orthogonal to OS-level access control.
    
    Why not use the add_key() syscall
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    We use an ioctl for this API rather than the existing add_key() system
    call because the ioctl gives us the flexibility needed to implement
    fscrypt-specific semantics that will be introduced in later patches:
    
    - Supporting key removal with the semantics such that the secret is
      removed immediately and any unused inodes using the key are evicted;
      also, the eviction of any in-use inodes can be retried.
    
    - Calculating a key-dependent cryptographic identifier and returning it
      to userspace.
    
    - Allowing keys to be added and removed by non-root users, but only keys
      for v2 encryption policies; and to prevent denial-of-service attacks,
      users can only remove keys they themselves have added, and a key is
      only really removed after all users who added it have removed it.
    
    Trying to shoehorn these semantics into the keyrings syscalls would be
    very difficult, whereas the ioctls make things much easier.
    
    However, to reuse code the implementation still uses the keyrings
    service internally.  Thus we get lockless RCU-mode key lookups without
    having to re-implement it, and the keys automatically show up in
    /proc/keys for debugging purposes.
    
    References:
    
        [1] https://github.com/google/fscrypt
        [2] https://goo.gl/55cCrI#heading=h.vf09isp98isb
        [3] https://github.com/google/fscrypt/issues/111#issuecomment-444347939
        [4] https://github.com/google/fscrypt/issues/116
        [5] https://bugs.launchpad.net/ubuntu/+source/fscrypt/+bug/1770715
        [6] https://github.com/google/fscrypt/issues/128
        [7] https://askubuntu.com/questions/1130306/cannot-run-docker-on-an-encrypted-filesystem
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 29a945d165de..6aeca3cb0a2d 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -36,22 +36,51 @@ struct fscrypt_policy {
 	__u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
 };
 
-#define FS_IOC_SET_ENCRYPTION_POLICY	_IOR('f', 19, struct fscrypt_policy)
-#define FS_IOC_GET_ENCRYPTION_PWSALT	_IOW('f', 20, __u8[16])
-#define FS_IOC_GET_ENCRYPTION_POLICY	_IOW('f', 21, struct fscrypt_policy)
-
-/* Parameters for passing an encryption key into the kernel keyring */
+/*
+ * Process-subscribed "logon" key description prefix and payload format.
+ * Deprecated; prefer FS_IOC_ADD_ENCRYPTION_KEY instead.
+ */
 #define FSCRYPT_KEY_DESC_PREFIX		"fscrypt:"
-#define FSCRYPT_KEY_DESC_PREFIX_SIZE		8
-
-/* Structure that userspace passes to the kernel keyring */
-#define FSCRYPT_MAX_KEY_SIZE			64
-
+#define FSCRYPT_KEY_DESC_PREFIX_SIZE	8
+#define FSCRYPT_MAX_KEY_SIZE		64
 struct fscrypt_key {
 	__u32 mode;
 	__u8 raw[FSCRYPT_MAX_KEY_SIZE];
 	__u32 size;
 };
+
+/*
+ * Keys are specified by an arbitrary 8-byte key "descriptor",
+ * matching fscrypt_policy::master_key_descriptor.
+ */
+#define FSCRYPT_KEY_SPEC_TYPE_DESCRIPTOR	1
+
+/*
+ * Specifies a key.  This doesn't contain the actual key itself; this is just
+ * the "name" of the key.
+ */
+struct fscrypt_key_specifier {
+	__u32 type;	/* one of FSCRYPT_KEY_SPEC_TYPE_* */
+	__u32 __reserved;
+	union {
+		__u8 __reserved[32]; /* reserve some extra space */
+		__u8 descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
+	} u;
+};
+
+/* Struct passed to FS_IOC_ADD_ENCRYPTION_KEY */
+struct fscrypt_add_key_arg {
+	struct fscrypt_key_specifier key_spec;
+	__u32 raw_size;
+	__u32 __reserved[9];
+	__u8 raw[];
+};
+
+#define FS_IOC_SET_ENCRYPTION_POLICY		_IOR('f', 19, struct fscrypt_policy)
+#define FS_IOC_GET_ENCRYPTION_PWSALT		_IOW('f', 20, __u8[16])
+#define FS_IOC_GET_ENCRYPTION_POLICY		_IOW('f', 21, struct fscrypt_policy)
+#define FS_IOC_ADD_ENCRYPTION_KEY		_IOWR('f', 23, struct fscrypt_add_key_arg)
+
 /**********************************************************************/
 
 /* old names; don't add anything new here! */

commit 3b6df59bc4d242ac5847592de55d1ff327cd4549
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:44 2019 -0700

    fscrypt: use FSCRYPT_* definitions, not FS_*
    
    Update fs/crypto/ to use the new names for the UAPI constants rather
    than the old names, then make the old definitions conditional on
    !__KERNEL__.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 674b0452ef57..29a945d165de 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -55,6 +55,7 @@ struct fscrypt_key {
 /**********************************************************************/
 
 /* old names; don't add anything new here! */
+#ifndef __KERNEL__
 #define FS_KEY_DESCRIPTOR_SIZE		FSCRYPT_KEY_DESCRIPTOR_SIZE
 #define FS_POLICY_FLAGS_PAD_4		FSCRYPT_POLICY_FLAGS_PAD_4
 #define FS_POLICY_FLAGS_PAD_8		FSCRYPT_POLICY_FLAGS_PAD_8
@@ -76,5 +77,6 @@ struct fscrypt_key {
 #define FS_KEY_DESC_PREFIX		FSCRYPT_KEY_DESC_PREFIX
 #define FS_KEY_DESC_PREFIX_SIZE		FSCRYPT_KEY_DESC_PREFIX_SIZE
 #define FS_MAX_KEY_SIZE			FSCRYPT_MAX_KEY_SIZE
+#endif /* !__KERNEL__ */
 
 #endif /* _UAPI_LINUX_FSCRYPT_H */

commit 2336d0deb2d4680349de59d6fbdfc338437be191
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:44 2019 -0700

    fscrypt: use FSCRYPT_ prefix for uapi constants
    
    Prefix all filesystem encryption UAPI constants except the ioctl numbers
    with "FSCRYPT_" rather than with "FS_".  This namespaces the constants
    more appropriately and makes it clear that they are related specifically
    to the filesystem encryption feature, and to the 'fscrypt_*' structures.
    With some of the old names like "FS_POLICY_FLAGS_VALID", it was not
    immediately clear that the constant had anything to do with encryption.
    
    This is also useful because we'll be adding more encryption-related
    constants, e.g. for the policy version, and we'd otherwise have to
    choose whether to use unclear names like FS_POLICY_V1 or inconsistent
    names like FS_ENCRYPTION_POLICY_V1.
    
    For source compatibility with existing userspace programs, keep the old
    names defined as aliases to the new names.
    
    Finally, as long as new names are being defined anyway, I skipped
    defining new names for the fscrypt mode numbers that aren't actually
    used: INVALID (0), AES_256_GCM (2), AES_256_CBC (3), SPECK128_256_XTS
    (7), and SPECK128_256_CTS (8).
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
index 26f6d2c19afd..674b0452ef57 100644
--- a/include/uapi/linux/fscrypt.h
+++ b/include/uapi/linux/fscrypt.h
@@ -10,35 +10,30 @@
 
 #include <linux/types.h>
 
-#define FS_KEY_DESCRIPTOR_SIZE	8
+#define FSCRYPT_KEY_DESCRIPTOR_SIZE	8
 
 /* Encryption policy flags */
-#define FS_POLICY_FLAGS_PAD_4		0x00
-#define FS_POLICY_FLAGS_PAD_8		0x01
-#define FS_POLICY_FLAGS_PAD_16		0x02
-#define FS_POLICY_FLAGS_PAD_32		0x03
-#define FS_POLICY_FLAGS_PAD_MASK	0x03
-#define FS_POLICY_FLAG_DIRECT_KEY	0x04	/* use master key directly */
-#define FS_POLICY_FLAGS_VALID		0x07
+#define FSCRYPT_POLICY_FLAGS_PAD_4		0x00
+#define FSCRYPT_POLICY_FLAGS_PAD_8		0x01
+#define FSCRYPT_POLICY_FLAGS_PAD_16		0x02
+#define FSCRYPT_POLICY_FLAGS_PAD_32		0x03
+#define FSCRYPT_POLICY_FLAGS_PAD_MASK		0x03
+#define FSCRYPT_POLICY_FLAG_DIRECT_KEY		0x04	/* use master key directly */
+#define FSCRYPT_POLICY_FLAGS_VALID		0x07
 
 /* Encryption algorithms */
-#define FS_ENCRYPTION_MODE_INVALID		0
-#define FS_ENCRYPTION_MODE_AES_256_XTS		1
-#define FS_ENCRYPTION_MODE_AES_256_GCM		2
-#define FS_ENCRYPTION_MODE_AES_256_CBC		3
-#define FS_ENCRYPTION_MODE_AES_256_CTS		4
-#define FS_ENCRYPTION_MODE_AES_128_CBC		5
-#define FS_ENCRYPTION_MODE_AES_128_CTS		6
-#define FS_ENCRYPTION_MODE_SPECK128_256_XTS	7 /* Removed, do not use. */
-#define FS_ENCRYPTION_MODE_SPECK128_256_CTS	8 /* Removed, do not use. */
-#define FS_ENCRYPTION_MODE_ADIANTUM		9
+#define FSCRYPT_MODE_AES_256_XTS		1
+#define FSCRYPT_MODE_AES_256_CTS		4
+#define FSCRYPT_MODE_AES_128_CBC		5
+#define FSCRYPT_MODE_AES_128_CTS		6
+#define FSCRYPT_MODE_ADIANTUM			9
 
 struct fscrypt_policy {
 	__u8 version;
 	__u8 contents_encryption_mode;
 	__u8 filenames_encryption_mode;
 	__u8 flags;
-	__u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+	__u8 master_key_descriptor[FSCRYPT_KEY_DESCRIPTOR_SIZE];
 };
 
 #define FS_IOC_SET_ENCRYPTION_POLICY	_IOR('f', 19, struct fscrypt_policy)
@@ -46,16 +41,40 @@ struct fscrypt_policy {
 #define FS_IOC_GET_ENCRYPTION_POLICY	_IOW('f', 21, struct fscrypt_policy)
 
 /* Parameters for passing an encryption key into the kernel keyring */
-#define FS_KEY_DESC_PREFIX		"fscrypt:"
-#define FS_KEY_DESC_PREFIX_SIZE		8
+#define FSCRYPT_KEY_DESC_PREFIX		"fscrypt:"
+#define FSCRYPT_KEY_DESC_PREFIX_SIZE		8
 
 /* Structure that userspace passes to the kernel keyring */
-#define FS_MAX_KEY_SIZE			64
+#define FSCRYPT_MAX_KEY_SIZE			64
 
 struct fscrypt_key {
 	__u32 mode;
-	__u8 raw[FS_MAX_KEY_SIZE];
+	__u8 raw[FSCRYPT_MAX_KEY_SIZE];
 	__u32 size;
 };
+/**********************************************************************/
+
+/* old names; don't add anything new here! */
+#define FS_KEY_DESCRIPTOR_SIZE		FSCRYPT_KEY_DESCRIPTOR_SIZE
+#define FS_POLICY_FLAGS_PAD_4		FSCRYPT_POLICY_FLAGS_PAD_4
+#define FS_POLICY_FLAGS_PAD_8		FSCRYPT_POLICY_FLAGS_PAD_8
+#define FS_POLICY_FLAGS_PAD_16		FSCRYPT_POLICY_FLAGS_PAD_16
+#define FS_POLICY_FLAGS_PAD_32		FSCRYPT_POLICY_FLAGS_PAD_32
+#define FS_POLICY_FLAGS_PAD_MASK	FSCRYPT_POLICY_FLAGS_PAD_MASK
+#define FS_POLICY_FLAG_DIRECT_KEY	FSCRYPT_POLICY_FLAG_DIRECT_KEY
+#define FS_POLICY_FLAGS_VALID		FSCRYPT_POLICY_FLAGS_VALID
+#define FS_ENCRYPTION_MODE_INVALID	0	/* never used */
+#define FS_ENCRYPTION_MODE_AES_256_XTS	FSCRYPT_MODE_AES_256_XTS
+#define FS_ENCRYPTION_MODE_AES_256_GCM	2	/* never used */
+#define FS_ENCRYPTION_MODE_AES_256_CBC	3	/* never used */
+#define FS_ENCRYPTION_MODE_AES_256_CTS	FSCRYPT_MODE_AES_256_CTS
+#define FS_ENCRYPTION_MODE_AES_128_CBC	FSCRYPT_MODE_AES_128_CBC
+#define FS_ENCRYPTION_MODE_AES_128_CTS	FSCRYPT_MODE_AES_128_CTS
+#define FS_ENCRYPTION_MODE_SPECK128_256_XTS	7	/* removed */
+#define FS_ENCRYPTION_MODE_SPECK128_256_CTS	8	/* removed */
+#define FS_ENCRYPTION_MODE_ADIANTUM	FSCRYPT_MODE_ADIANTUM
+#define FS_KEY_DESC_PREFIX		FSCRYPT_KEY_DESC_PREFIX
+#define FS_KEY_DESC_PREFIX_SIZE		FSCRYPT_KEY_DESC_PREFIX_SIZE
+#define FS_MAX_KEY_SIZE			FSCRYPT_MAX_KEY_SIZE
 
 #endif /* _UAPI_LINUX_FSCRYPT_H */

commit 7af0ab0d3aab951518b0d520f95e9f6b1995ec69
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:43 2019 -0700

    fs, fscrypt: move uapi definitions to new header <linux/fscrypt.h>
    
    More fscrypt definitions are being added, and we shouldn't use a
    disproportionate amount of space in <linux/fs.h> for fscrypt stuff.
    So move the fscrypt definitions to a new header <linux/fscrypt.h>.
    
    For source compatibility with existing userspace programs, <linux/fs.h>
    still includes the new header.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/uapi/linux/fscrypt.h b/include/uapi/linux/fscrypt.h
new file mode 100644
index 000000000000..26f6d2c19afd
--- /dev/null
+++ b/include/uapi/linux/fscrypt.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * fscrypt user API
+ *
+ * These ioctls can be used on filesystems that support fscrypt.  See the
+ * "User API" section of Documentation/filesystems/fscrypt.rst.
+ */
+#ifndef _UAPI_LINUX_FSCRYPT_H
+#define _UAPI_LINUX_FSCRYPT_H
+
+#include <linux/types.h>
+
+#define FS_KEY_DESCRIPTOR_SIZE	8
+
+/* Encryption policy flags */
+#define FS_POLICY_FLAGS_PAD_4		0x00
+#define FS_POLICY_FLAGS_PAD_8		0x01
+#define FS_POLICY_FLAGS_PAD_16		0x02
+#define FS_POLICY_FLAGS_PAD_32		0x03
+#define FS_POLICY_FLAGS_PAD_MASK	0x03
+#define FS_POLICY_FLAG_DIRECT_KEY	0x04	/* use master key directly */
+#define FS_POLICY_FLAGS_VALID		0x07
+
+/* Encryption algorithms */
+#define FS_ENCRYPTION_MODE_INVALID		0
+#define FS_ENCRYPTION_MODE_AES_256_XTS		1
+#define FS_ENCRYPTION_MODE_AES_256_GCM		2
+#define FS_ENCRYPTION_MODE_AES_256_CBC		3
+#define FS_ENCRYPTION_MODE_AES_256_CTS		4
+#define FS_ENCRYPTION_MODE_AES_128_CBC		5
+#define FS_ENCRYPTION_MODE_AES_128_CTS		6
+#define FS_ENCRYPTION_MODE_SPECK128_256_XTS	7 /* Removed, do not use. */
+#define FS_ENCRYPTION_MODE_SPECK128_256_CTS	8 /* Removed, do not use. */
+#define FS_ENCRYPTION_MODE_ADIANTUM		9
+
+struct fscrypt_policy {
+	__u8 version;
+	__u8 contents_encryption_mode;
+	__u8 filenames_encryption_mode;
+	__u8 flags;
+	__u8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];
+};
+
+#define FS_IOC_SET_ENCRYPTION_POLICY	_IOR('f', 19, struct fscrypt_policy)
+#define FS_IOC_GET_ENCRYPTION_PWSALT	_IOW('f', 20, __u8[16])
+#define FS_IOC_GET_ENCRYPTION_POLICY	_IOW('f', 21, struct fscrypt_policy)
+
+/* Parameters for passing an encryption key into the kernel keyring */
+#define FS_KEY_DESC_PREFIX		"fscrypt:"
+#define FS_KEY_DESC_PREFIX_SIZE		8
+
+/* Structure that userspace passes to the kernel keyring */
+#define FS_MAX_KEY_SIZE			64
+
+struct fscrypt_key {
+	__u32 mode;
+	__u8 raw[FS_MAX_KEY_SIZE];
+	__u32 size;
+};
+
+#endif /* _UAPI_LINUX_FSCRYPT_H */
