commit 32f5f62d7991c62095ee62a060b35dec0a9ac404
Author: Jonathan Neuschäfer <j.neuschaefer@gmx.net>
Date:   Tue Mar 3 21:01:48 2020 +0100

    gpio: uapi: Improve phrasing around arrays representing empty strings
    
    Character arrays can be considered empty strings (if they are
    immediately terminated), but they cannot be NULL.
    
    Signed-off-by: Jonathan Neuschäfer <j.neuschaefer@gmx.net>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index dca320764e4d..0206383c0383 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -18,7 +18,7 @@
  * struct gpiochip_info - Information about a certain GPIO chip
  * @name: the Linux kernel name of this GPIO chip
  * @label: a functional name for this GPIO chip, such as a product
- * number, may be NULL
+ * number, may be empty
  * @lines: number of GPIO lines on this chip
  */
 struct gpiochip_info {
@@ -44,10 +44,10 @@ struct gpiochip_info {
  * @flags: various flags for this line
  * @name: the name of this GPIO line, such as the output pin of the line on the
  * chip, a rail or a pin header name on a board, as specified by the gpio
- * chip, may be NULL
+ * chip, may be empty
  * @consumer: a functional name for the consumer of this GPIO line as set by
- * whatever is using it, will be NULL if there is no current user but may
- * also be NULL if the consumer doesn't set this up
+ * whatever is using it, will be empty if there is no current user but may
+ * also be empty if the consumer doesn't set this up
  */
 struct gpioline_info {
 	__u32 line_offset;

commit 51c1064e82e77b39a49889287ca50709303e2f26
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Fri Nov 22 15:19:21 2019 +0100

    gpiolib: add new ioctl() for monitoring changes in line info
    
    Currently there is no way for user-space to be informed about changes
    in status of GPIO lines e.g. when someone else requests the line or its
    config changes. We can only periodically re-read the line-info. This
    is fine for simple one-off user-space tools, but any daemon that provides
    a centralized access to GPIO chips would benefit hugely from an event
    driven line info synchronization.
    
    This patch adds a new ioctl() that allows user-space processes to reuse
    the file descriptor associated with the character device for watching
    any changes in line properties. Every such event contains the updated
    line information.
    
    Currently the events are generated on three types of status changes: when
    a line is requested, when it's released and when its config is changed.
    The first two are self-explanatory. For the third one: this will only
    happen when another user-space process calls the new SET_CONFIG ioctl()
    as any changes that can happen from within the kernel (i.e.
    set_transitory() or set_debounce()) are of no interest to user-space.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 799cf823d493..dca320764e4d 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -59,6 +59,34 @@ struct gpioline_info {
 /* Maximum number of requested handles */
 #define GPIOHANDLES_MAX 64
 
+/* Possible line status change events */
+enum {
+	GPIOLINE_CHANGED_REQUESTED = 1,
+	GPIOLINE_CHANGED_RELEASED,
+	GPIOLINE_CHANGED_CONFIG,
+};
+
+/**
+ * struct gpioline_info_changed - Information about a change in status
+ * of a GPIO line
+ * @info: updated line information
+ * @timestamp: estimate of time of status change occurrence, in nanoseconds
+ * and GPIOLINE_CHANGED_CONFIG
+ * @event_type: one of GPIOLINE_CHANGED_REQUESTED, GPIOLINE_CHANGED_RELEASED
+ *
+ * Note: struct gpioline_info embedded here has 32-bit alignment on its own,
+ * but it works fine with 64-bit alignment too. With its 72 byte size, we can
+ * guarantee there are no implicit holes between it and subsequent members.
+ * The 20-byte padding at the end makes sure we don't add any implicit padding
+ * at the end of the structure on 64-bit architectures.
+ */
+struct gpioline_info_changed {
+	struct gpioline_info info;
+	__u64 timestamp;
+	__u32 event_type;
+	__u32 padding[5]; /* for future use */
+};
+
 /* Linerequest flags */
 #define GPIOHANDLE_REQUEST_INPUT	(1UL << 0)
 #define GPIOHANDLE_REQUEST_OUTPUT	(1UL << 1)
@@ -176,6 +204,8 @@ struct gpioevent_data {
 
 #define GPIO_GET_CHIPINFO_IOCTL _IOR(0xB4, 0x01, struct gpiochip_info)
 #define GPIO_GET_LINEINFO_IOCTL _IOWR(0xB4, 0x02, struct gpioline_info)
+#define GPIO_GET_LINEINFO_WATCH_IOCTL _IOWR(0xB4, 0x0b, struct gpioline_info)
+#define GPIO_GET_LINEINFO_UNWATCH_IOCTL _IOWR(0xB4, 0x0c, __u32)
 #define GPIO_GET_LINEHANDLE_IOCTL _IOWR(0xB4, 0x03, struct gpiohandle_request)
 #define GPIO_GET_LINEEVENT_IOCTL _IOWR(0xB4, 0x04, struct gpioevent_request)
 

commit e588bb1eae31be73fbec2b731be986a7c09635a4
Author: Kent Gibson <warthog618@gmail.com>
Date:   Tue Nov 5 10:04:29 2019 +0800

    gpio: add new SET_CONFIG ioctl() to gpio chardev
    
    Add the GPIOHANDLE_SET_CONFIG_IOCTL to the gpio chardev.
    The ioctl allows some of the configuration of a requested handle to be
    changed without having to release the line.
    The primary use case is the changing of direction for bi-directional
    lines.
    
    Based on initial work by Bartosz Golaszewski <bgolaszewski@baylibre.com>
    
    Signed-off-by: Kent Gibson <warthog618@gmail.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 7cc21c3b0839..799cf823d493 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -100,6 +100,24 @@ struct gpiohandle_request {
 	int fd;
 };
 
+/**
+ * struct gpiohandle_config - Configuration for a GPIO handle request
+ * @flags: updated flags for the requested GPIO lines, such as
+ * GPIOHANDLE_REQUEST_OUTPUT, GPIOHANDLE_REQUEST_ACTIVE_LOW etc, OR:ed
+ * together
+ * @default_values: if the GPIOHANDLE_REQUEST_OUTPUT is set in flags,
+ * this specifies the default output value, should be 0 (low) or
+ * 1 (high), anything else than 0 or 1 will be interpreted as 1 (high)
+ * @padding: reserved for future use and should be zero filled
+ */
+struct gpiohandle_config {
+	__u32 flags;
+	__u8 default_values[GPIOHANDLES_MAX];
+	__u32 padding[4]; /* padding for future use */
+};
+
+#define GPIOHANDLE_SET_CONFIG_IOCTL _IOWR(0xB4, 0x0a, struct gpiohandle_config)
+
 /**
  * struct gpiohandle_data - Information of values on a GPIO handle
  * @values: when getting the state of lines this contains the current

commit 2148ad7790ea4f1f0081e6404fbb776bdbc793bb
Author: Kent Gibson <warthog618@gmail.com>
Date:   Tue Nov 5 10:04:25 2019 +0800

    gpiolib: add support for disabling line bias
    
    Allow pull up/down bias to be disabled, allowing the line to float
    or to be biased only by external circuitry.
    Use case is for where the bias has been applied previously, either
    by default or by the user, but that setting may conflict with the
    current use of the line.
    
    Signed-off-by: Kent Gibson <warthog618@gmail.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 39e6c7854d63..7cc21c3b0839 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -35,6 +35,7 @@ struct gpiochip_info {
 #define GPIOLINE_FLAG_OPEN_SOURCE	(1UL << 4)
 #define GPIOLINE_FLAG_BIAS_PULL_UP	(1UL << 5)
 #define GPIOLINE_FLAG_BIAS_PULL_DOWN	(1UL << 6)
+#define GPIOLINE_FLAG_BIAS_DISABLE	(1UL << 7)
 
 /**
  * struct gpioline_info - Information about a certain GPIO line
@@ -66,6 +67,7 @@ struct gpioline_info {
 #define GPIOHANDLE_REQUEST_OPEN_SOURCE	(1UL << 4)
 #define GPIOHANDLE_REQUEST_BIAS_PULL_UP	(1UL << 5)
 #define GPIOHANDLE_REQUEST_BIAS_PULL_DOWN	(1UL << 6)
+#define GPIOHANDLE_REQUEST_BIAS_DISABLE	(1UL << 7)
 
 /**
  * struct gpiohandle_request - Information about a GPIO handle request

commit 9225d5169d110734099a82c39c073a11e399cb3f
Author: Drew Fustini <drew@pdp7.com>
Date:   Tue Nov 5 10:04:23 2019 +0800

    gpio: expose pull-up/pull-down line flags to userspace
    
    Add pull-up/pull-down flags to the gpio line get and
    set ioctl() calls.  Use cases include a push button
    that does not have an external resistor.
    
    Addition use cases described by Limor Fried (ladyada) of
    Adafruit in this PR for Adafruit_Blinka Python lib:
    https://github.com/adafruit/Adafruit_Blinka/pull/59
    
    Signed-off-by: Drew Fustini <drew@pdp7.com>
    [Kent: added BIAS to GPIO flag names and restrict application to input
    lines]
    Signed-off-by: Kent Gibson <warthog618@gmail.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 4ebfe0ac6c5b..39e6c7854d63 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -33,6 +33,8 @@ struct gpiochip_info {
 #define GPIOLINE_FLAG_ACTIVE_LOW	(1UL << 2)
 #define GPIOLINE_FLAG_OPEN_DRAIN	(1UL << 3)
 #define GPIOLINE_FLAG_OPEN_SOURCE	(1UL << 4)
+#define GPIOLINE_FLAG_BIAS_PULL_UP	(1UL << 5)
+#define GPIOLINE_FLAG_BIAS_PULL_DOWN	(1UL << 6)
 
 /**
  * struct gpioline_info - Information about a certain GPIO line
@@ -62,6 +64,8 @@ struct gpioline_info {
 #define GPIOHANDLE_REQUEST_ACTIVE_LOW	(1UL << 2)
 #define GPIOHANDLE_REQUEST_OPEN_DRAIN	(1UL << 3)
 #define GPIOHANDLE_REQUEST_OPEN_SOURCE	(1UL << 4)
+#define GPIOHANDLE_REQUEST_BIAS_PULL_UP	(1UL << 5)
+#define GPIOHANDLE_REQUEST_BIAS_PULL_DOWN	(1UL << 6)
 
 /**
  * struct gpiohandle_request - Information about a GPIO handle request

commit 0b35cd7b18608d80cd2e78835ee57456b220f364
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Sep 11 16:32:43 2018 +0200

    gpio: uapi: Grammar s/array/array of/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 1bf6e6df084b..4ebfe0ac6c5b 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -65,7 +65,7 @@ struct gpioline_info {
 
 /**
  * struct gpiohandle_request - Information about a GPIO handle request
- * @lineoffsets: an array desired lines, specified by offset index for the
+ * @lineoffsets: an array of desired lines, specified by offset index for the
  * associated GPIO device
  * @flags: desired flags for the desired GPIO lines, such as
  * GPIOHANDLE_REQUEST_OUTPUT, GPIOHANDLE_REQUEST_ACTIVE_LOW etc, OR:ed

commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 333d3544c964..1bf6e6df084b 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 /*
  * <linux/gpio.h> - userspace ABI for the GPIO character devices
  *

commit 61f922db72216b00386581c851db9c9095961522
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Jun 2 11:30:15 2016 +0200

    gpio: userspace ABI for reading GPIO line events
    
    This adds an ABI for listening to events on GPIO lines.
    The mechanism returns an anonymous file handle to a request
    to listen to a specific offset on a specific gpiochip.
    To fetch the stream of events from the file handle, userspace
    simply reads an event.
    
    - Events can be requested with the same flags as ordinary
      handles, i.e. open drain or open source. An ioctl() call
      GPIO_GET_LINEEVENT_IOCTL is issued indicating the desired
      line.
    
    - Events can be requested for falling edge events, rising
      edge events, or both.
    
    - All events are timestamped using the kernel real time
      nanosecond timestamp (the same as is used by IIO).
    
    - The supplied consumer label will appear in "lsgpio"
      listings of the lines, and in /proc/interrupts as the
      mechanism will request an interrupt from the gpio chip.
    
    - Events are not supported on gpiochips that do not serve
      interrupts (no legal .to_irq() call). The event interrupt
      is threaded to avoid any realtime problems.
    
    - It is possible to also directly read the current value
      of the registered GPIO line by issuing the same
      GPIOHANDLE_GET_LINE_VALUES_IOCTL as used by the
      line handles. Setting the value is not supported: we
      do not listen to events on output lines.
    
    This ABI is strongly influenced by Industrial I/O and surpasses
    the old sysfs ABI by providing proper precision timestamps,
    making it possible to set flags like open drain, and put
    consumer names on the GPIO lines.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 21905531dcf4..333d3544c964 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -55,7 +55,7 @@ struct gpioline_info {
 /* Maximum number of requested handles */
 #define GPIOHANDLES_MAX 64
 
-/* Request flags */
+/* Linerequest flags */
 #define GPIOHANDLE_REQUEST_INPUT	(1UL << 0)
 #define GPIOHANDLE_REQUEST_OUTPUT	(1UL << 1)
 #define GPIOHANDLE_REQUEST_ACTIVE_LOW	(1UL << 2)
@@ -93,10 +93,6 @@ struct gpiohandle_request {
 	int fd;
 };
 
-#define GPIO_GET_CHIPINFO_IOCTL _IOR(0xB4, 0x01, struct gpiochip_info)
-#define GPIO_GET_LINEINFO_IOCTL _IOWR(0xB4, 0x02, struct gpioline_info)
-#define GPIO_GET_LINEHANDLE_IOCTL _IOWR(0xB4, 0x03, struct gpiohandle_request)
-
 /**
  * struct gpiohandle_data - Information of values on a GPIO handle
  * @values: when getting the state of lines this contains the current
@@ -110,4 +106,52 @@ struct gpiohandle_data {
 #define GPIOHANDLE_GET_LINE_VALUES_IOCTL _IOWR(0xB4, 0x08, struct gpiohandle_data)
 #define GPIOHANDLE_SET_LINE_VALUES_IOCTL _IOWR(0xB4, 0x09, struct gpiohandle_data)
 
+/* Eventrequest flags */
+#define GPIOEVENT_REQUEST_RISING_EDGE	(1UL << 0)
+#define GPIOEVENT_REQUEST_FALLING_EDGE	(1UL << 1)
+#define GPIOEVENT_REQUEST_BOTH_EDGES	((1UL << 0) | (1UL << 1))
+
+/**
+ * struct gpioevent_request - Information about a GPIO event request
+ * @lineoffset: the desired line to subscribe to events from, specified by
+ * offset index for the associated GPIO device
+ * @handleflags: desired handle flags for the desired GPIO line, such as
+ * GPIOHANDLE_REQUEST_ACTIVE_LOW or GPIOHANDLE_REQUEST_OPEN_DRAIN
+ * @eventflags: desired flags for the desired GPIO event line, such as
+ * GPIOEVENT_REQUEST_RISING_EDGE or GPIOEVENT_REQUEST_FALLING_EDGE
+ * @consumer_label: a desired consumer label for the selected GPIO line(s)
+ * such as "my-listener"
+ * @fd: if successful this field will contain a valid anonymous file handle
+ * after a GPIO_GET_LINEEVENT_IOCTL operation, zero or negative value
+ * means error
+ */
+struct gpioevent_request {
+	__u32 lineoffset;
+	__u32 handleflags;
+	__u32 eventflags;
+	char consumer_label[32];
+	int fd;
+};
+
+/**
+ * GPIO event types
+ */
+#define GPIOEVENT_EVENT_RISING_EDGE 0x01
+#define GPIOEVENT_EVENT_FALLING_EDGE 0x02
+
+/**
+ * struct gpioevent_data - The actual event being pushed to userspace
+ * @timestamp: best estimate of time of event occurrence, in nanoseconds
+ * @id: event identifier
+ */
+struct gpioevent_data {
+	__u64 timestamp;
+	__u32 id;
+};
+
+#define GPIO_GET_CHIPINFO_IOCTL _IOR(0xB4, 0x01, struct gpiochip_info)
+#define GPIO_GET_LINEINFO_IOCTL _IOWR(0xB4, 0x02, struct gpioline_info)
+#define GPIO_GET_LINEHANDLE_IOCTL _IOWR(0xB4, 0x03, struct gpiohandle_request)
+#define GPIO_GET_LINEEVENT_IOCTL _IOWR(0xB4, 0x04, struct gpioevent_request)
+
 #endif /* _UAPI_GPIO_H_ */

commit d7c51b47ac11e66f547b55640405c1c474642d72
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 26 10:35:29 2016 +0200

    gpio: userspace ABI for reading/writing GPIO lines
    
    This adds a userspace ABI for reading and writing GPIO lines.
    The mechanism returns an anonymous file handle to a request
    to read/write n offsets from a gpiochip. This file handle
    in turn accepts two ioctl()s: one that reads and one that
    writes values to the selected lines.
    
    - Handles can be requested as input/output, active low,
      open drain, open source, however when you issue a request
      for n lines with GPIO_GET_LINEHANDLE_IOCTL, they must all
      have the same flags, i.e. all inputs or all outputs, all
      open drain etc. If a granular control of the flags for
      each line is desired, they need to be requested
      individually, not in a batch.
    
    - The GPIOHANDLE_GET_LINE_VALUES_IOCTL read ioctl() can be
      issued also to output lines to verify that the hardware
      is in the expected state.
    
    - It reads and writes up to GPIOHANDLES_MAX lines at once,
      utilizing the .set_multiple() call in the driver if
      possible, making the call efficient if several lines
      can be written with a single register update.
    
    The limitation of GPIOHANDLES_MAX to 64 lines is done under
    the assumption that we may expect hardware that can issue a
    transaction updating 64 bits at an instant but unlikely
    anything larger than that.
    
    ChangeLog v2->v3:
    - Use gpiod_get_value_cansleep() so we support also slowpath
      GPIO drivers.
    - Fix up the UAPI docs kerneldoc.
    - Allocate the anonymous fd last, so that the release
      function don't get called until that point of something
      fails. After this point, skip the errorpath.
    ChangeLog v1->v2:
    - Handle ioctl_compat() properly based on a similar patch
      to the other ioctl() handling code.
    - Use _IOWR() as we pass pointers both in and out of the
      ioctl()
    - Use kmalloc() and kfree() for the linehandled, do not
      try to be fancy with devm_* it doesn't work the way I
      thought.
    - Fix const-correctness on the linehandle name field.
    
    Acked-by: Michael Welling <mwelling@ieee.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index d0a3cac72250..21905531dcf4 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -1,7 +1,7 @@
 /*
  * <linux/gpio.h> - userspace ABI for the GPIO character devices
  *
- * Copyright (C) 2015 Linus Walleij
+ * Copyright (C) 2016 Linus Walleij
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published by
@@ -26,8 +26,8 @@ struct gpiochip_info {
 	__u32 lines;
 };
 
-/* Line is in use by the kernel */
-#define GPIOLINE_FLAG_KERNEL		(1UL << 0)
+/* Informational flags */
+#define GPIOLINE_FLAG_KERNEL		(1UL << 0) /* Line used by the kernel */
 #define GPIOLINE_FLAG_IS_OUT		(1UL << 1)
 #define GPIOLINE_FLAG_ACTIVE_LOW	(1UL << 2)
 #define GPIOLINE_FLAG_OPEN_DRAIN	(1UL << 3)
@@ -52,7 +52,62 @@ struct gpioline_info {
 	char consumer[32];
 };
 
+/* Maximum number of requested handles */
+#define GPIOHANDLES_MAX 64
+
+/* Request flags */
+#define GPIOHANDLE_REQUEST_INPUT	(1UL << 0)
+#define GPIOHANDLE_REQUEST_OUTPUT	(1UL << 1)
+#define GPIOHANDLE_REQUEST_ACTIVE_LOW	(1UL << 2)
+#define GPIOHANDLE_REQUEST_OPEN_DRAIN	(1UL << 3)
+#define GPIOHANDLE_REQUEST_OPEN_SOURCE	(1UL << 4)
+
+/**
+ * struct gpiohandle_request - Information about a GPIO handle request
+ * @lineoffsets: an array desired lines, specified by offset index for the
+ * associated GPIO device
+ * @flags: desired flags for the desired GPIO lines, such as
+ * GPIOHANDLE_REQUEST_OUTPUT, GPIOHANDLE_REQUEST_ACTIVE_LOW etc, OR:ed
+ * together. Note that even if multiple lines are requested, the same flags
+ * must be applicable to all of them, if you want lines with individual
+ * flags set, request them one by one. It is possible to select
+ * a batch of input or output lines, but they must all have the same
+ * characteristics, i.e. all inputs or all outputs, all active low etc
+ * @default_values: if the GPIOHANDLE_REQUEST_OUTPUT is set for a requested
+ * line, this specifies the default output value, should be 0 (low) or
+ * 1 (high), anything else than 0 or 1 will be interpreted as 1 (high)
+ * @consumer_label: a desired consumer label for the selected GPIO line(s)
+ * such as "my-bitbanged-relay"
+ * @lines: number of lines requested in this request, i.e. the number of
+ * valid fields in the above arrays, set to 1 to request a single line
+ * @fd: if successful this field will contain a valid anonymous file handle
+ * after a GPIO_GET_LINEHANDLE_IOCTL operation, zero or negative value
+ * means error
+ */
+struct gpiohandle_request {
+	__u32 lineoffsets[GPIOHANDLES_MAX];
+	__u32 flags;
+	__u8 default_values[GPIOHANDLES_MAX];
+	char consumer_label[32];
+	__u32 lines;
+	int fd;
+};
+
 #define GPIO_GET_CHIPINFO_IOCTL _IOR(0xB4, 0x01, struct gpiochip_info)
 #define GPIO_GET_LINEINFO_IOCTL _IOWR(0xB4, 0x02, struct gpioline_info)
+#define GPIO_GET_LINEHANDLE_IOCTL _IOWR(0xB4, 0x03, struct gpiohandle_request)
+
+/**
+ * struct gpiohandle_data - Information of values on a GPIO handle
+ * @values: when getting the state of lines this contains the current
+ * state of a line, when setting the state of lines these should contain
+ * the desired target state
+ */
+struct gpiohandle_data {
+	__u8 values[GPIOHANDLES_MAX];
+};
+
+#define GPIOHANDLE_GET_LINE_VALUES_IOCTL _IOWR(0xB4, 0x08, struct gpiohandle_data)
+#define GPIOHANDLE_SET_LINE_VALUES_IOCTL _IOWR(0xB4, 0x09, struct gpiohandle_data)
 
 #endif /* _UAPI_GPIO_H_ */

commit fae98164463948eb31d638fe207c25a3d2b9312f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 10 15:48:06 2016 +0700

    gpio: uapi: use 0xB4 as ioctl() major
    
    The previous 'o' is in conflict and not very orderly assigned.
    We want to select an ioctl() major that does not conflict with
    the existining ones.
    
    Add the new reserved major (0xB4) to Documentation/ioctl/ioctl-number.txt
    
    Fixes: 3c702e9987e2 ("gpio: add a userspace chardev ABI for GPIOs")
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index dfe8ade2742d..d0a3cac72250 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -52,7 +52,7 @@ struct gpioline_info {
 	char consumer[32];
 };
 
-#define GPIO_GET_CHIPINFO_IOCTL _IOR('o', 0x01, struct gpiochip_info)
-#define GPIO_GET_LINEINFO_IOCTL _IOWR('o', 0x02, struct gpioline_info)
+#define GPIO_GET_CHIPINFO_IOCTL _IOR(0xB4, 0x01, struct gpiochip_info)
+#define GPIO_GET_LINEINFO_IOCTL _IOWR(0xB4, 0x02, struct gpioline_info)
 
 #endif /* _UAPI_GPIO_H_ */

commit 214338e372af2b856af07978daa771dbe087f990
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Feb 25 21:01:48 2016 +0100

    gpio: present the consumer of a line to userspace
    
    I named the field representing the current user of GPIO line as
    "label" but this is too vague and ambiguous. Before anyone gets
    confused, rename it to "consumer" and indicate clearly in the
    documentation that this is a string set by the user of the line.
    
    Also clean up leftovers in the documentation.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 416ce47f2291..dfe8ade2742d 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -15,8 +15,9 @@
 
 /**
  * struct gpiochip_info - Information about a certain GPIO chip
- * @name: the name of this GPIO chip
- * @label: a functional name for this GPIO chip
+ * @name: the Linux kernel name of this GPIO chip
+ * @label: a functional name for this GPIO chip, such as a product
+ * number, may be NULL
  * @lines: number of GPIO lines on this chip
  */
 struct gpiochip_info {
@@ -34,20 +35,21 @@ struct gpiochip_info {
 
 /**
  * struct gpioline_info - Information about a certain GPIO line
- * @line_offset: the local offset on this GPIO device, fill in when
- * requesting information from the kernel
+ * @line_offset: the local offset on this GPIO device, fill this in when
+ * requesting the line information from the kernel
  * @flags: various flags for this line
- * @name: the name of this GPIO line
- * @label: a functional name for this GPIO line
- * @kernel: this GPIO is in use by the kernel
- * @out: this GPIO is an output line (false means it is an input)
- * @active_low: this GPIO is active low
+ * @name: the name of this GPIO line, such as the output pin of the line on the
+ * chip, a rail or a pin header name on a board, as specified by the gpio
+ * chip, may be NULL
+ * @consumer: a functional name for the consumer of this GPIO line as set by
+ * whatever is using it, will be NULL if there is no current user but may
+ * also be NULL if the consumer doesn't set this up
  */
 struct gpioline_info {
 	__u32 line_offset;
 	__u32 flags;
 	char name[32];
-	char label[32];
+	char consumer[32];
 };
 
 #define GPIO_GET_CHIPINFO_IOCTL _IOR('o', 0x01, struct gpiochip_info)

commit 521a2ad6f862a28e2e43cb3e254a26bf0f9452e9
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 12 22:25:22 2016 +0100

    gpio: add userspace ABI for GPIO line information
    
    This adds a GPIO line ABI for getting name, label and a few select
    flags from the kernel.
    
    This hides the kernel internals and only tells userspace what it
    may need to know: the different in-kernel consumers are masked
    behind the flag "kernel" and that is all userspace needs to know.
    
    However electric characteristics like active low, open drain etc
    are reflected to userspace, as this is important information.
    
    We provide information on all lines on all chips, later on we will
    likely add a flag for the chardev consumer so we can filter and
    display only the lines userspace actually uses in e.g. lsgpio,
    but then we first need an ABI for userspace to grab and use
    (get/set/select direction) a GPIO line.
    
    Sample output from "lsgpio" on ux500:
    
    GPIO chip: gpiochip7, "8011e000.gpio", 32 GPIO lines
            line 0: unnamed unlabeled
            line 1: unnamed unlabeled
    (...)
            line 25: unnamed "SFH7741 Proximity Sensor" [kernel output open-drain]
            line 26: unnamed unlabeled
    (...)
    
    Tested-by: Michael Welling <mwelling@ieee.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 3f93e1bcd3dd..416ce47f2291 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -25,6 +25,32 @@ struct gpiochip_info {
 	__u32 lines;
 };
 
+/* Line is in use by the kernel */
+#define GPIOLINE_FLAG_KERNEL		(1UL << 0)
+#define GPIOLINE_FLAG_IS_OUT		(1UL << 1)
+#define GPIOLINE_FLAG_ACTIVE_LOW	(1UL << 2)
+#define GPIOLINE_FLAG_OPEN_DRAIN	(1UL << 3)
+#define GPIOLINE_FLAG_OPEN_SOURCE	(1UL << 4)
+
+/**
+ * struct gpioline_info - Information about a certain GPIO line
+ * @line_offset: the local offset on this GPIO device, fill in when
+ * requesting information from the kernel
+ * @flags: various flags for this line
+ * @name: the name of this GPIO line
+ * @label: a functional name for this GPIO line
+ * @kernel: this GPIO is in use by the kernel
+ * @out: this GPIO is an output line (false means it is an input)
+ * @active_low: this GPIO is active low
+ */
+struct gpioline_info {
+	__u32 line_offset;
+	__u32 flags;
+	char name[32];
+	char label[32];
+};
+
 #define GPIO_GET_CHIPINFO_IOCTL _IOR('o', 0x01, struct gpiochip_info)
+#define GPIO_GET_LINEINFO_IOCTL _IOWR('o', 0x02, struct gpioline_info)
 
 #endif /* _UAPI_GPIO_H_ */

commit df4878e969ccc047da45d2cd3af5d08031da1593
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 12 14:48:23 2016 +0100

    gpio: store reflect the label to userspace
    
    The gpio_chip label is useful for userspace to understand what
    kind of GPIO chip it is dealing with. Let's store a copy of this
    label in the gpio_device, add it to the struct passed to userspace
    for GPIO_GET_CHIPINFO_IOCTL and modify lsgpio to show it.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
index 3188a87bdaa0..3f93e1bcd3dd 100644
--- a/include/uapi/linux/gpio.h
+++ b/include/uapi/linux/gpio.h
@@ -16,10 +16,12 @@
 /**
  * struct gpiochip_info - Information about a certain GPIO chip
  * @name: the name of this GPIO chip
+ * @label: a functional name for this GPIO chip
  * @lines: number of GPIO lines on this chip
  */
 struct gpiochip_info {
 	char name[32];
+	char label[32];
 	__u32 lines;
 };
 

commit 3c702e9987e261042a07e43460a8148be254412e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 21 15:29:53 2015 +0200

    gpio: add a userspace chardev ABI for GPIOs
    
    A new chardev that is to be used for userspace GPIO access is
    added in this patch. It is intended to gradually replace the
    horribly broken sysfs ABI.
    
    Using a chardev has many upsides:
    
    - All operations are per-gpiochip, which is the actual
      device underlying the GPIOs, making us tie in to the
      kernel device model properly.
    
    - Hotpluggable GPIO controllers can come and go, as this
      kind of problem has been know to userspace for character
      devices since ages, and if a gpiochip handle is held in
      userspace we know we will break something, whereas the
      sysfs is stateless.
    
    - The one-value-per-file rule of sysfs is really hard to
      maintain when you want to twist more than one knob at a time,
      for example have in-kernel APIs to switch several GPIO
      lines at the same time, and this will be possible to do
      with a single ioctl() from userspace, saving a lot of
      context switching.
    
    We also need to add a new bus type for GPIO. This is
    necessary for example for userspace coldplug, where sysfs is
    traversed to find the boot-time device nodes and create the
    character devices in /dev.
    
    This new chardev ABI is *non* *optional* and can be counted
    on to be present in the future, emphasizing the preference
    of this ABI.
    
    The ABI only implements one single ioctl() to get the name
    and number of GPIO lines of a chip. Even this is debatable:
    see it as a minimal example for review. This ABI shall be
    ruthlessly reviewed and etched in stone.
    
    The old /sys/class/gpio is still optional to compile in,
    but will be deprecated.
    
    Unique device IDs are created using IDR, which is overkill
    and insanely scalable, but also well tested.
    
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Michael Welling <mwelling@ieee.org>
    Cc: Markus Pargmann <mpa@pengutronix.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/uapi/linux/gpio.h b/include/uapi/linux/gpio.h
new file mode 100644
index 000000000000..3188a87bdaa0
--- /dev/null
+++ b/include/uapi/linux/gpio.h
@@ -0,0 +1,28 @@
+/*
+ * <linux/gpio.h> - userspace ABI for the GPIO character devices
+ *
+ * Copyright (C) 2015 Linus Walleij
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#ifndef _UAPI_GPIO_H_
+#define _UAPI_GPIO_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/**
+ * struct gpiochip_info - Information about a certain GPIO chip
+ * @name: the name of this GPIO chip
+ * @lines: number of GPIO lines on this chip
+ */
+struct gpiochip_info {
+	char name[32];
+	__u32 lines;
+};
+
+#define GPIO_GET_CHIPINFO_IOCTL _IOR('o', 0x01, struct gpiochip_info)
+
+#endif /* _UAPI_GPIO_H_ */
