commit 201766a20e30f982ccfe36bebfad9602c3ff574a
Author: Elvira Khabirova <lineprinter@altlinux.org>
Date:   Tue Jul 16 16:29:42 2019 -0700

    ptrace: add PTRACE_GET_SYSCALL_INFO request
    
    PTRACE_GET_SYSCALL_INFO is a generic ptrace API that lets ptracer obtain
    details of the syscall the tracee is blocked in.
    
    There are two reasons for a special syscall-related ptrace request.
    
    Firstly, with the current ptrace API there are cases when ptracer cannot
    retrieve necessary information about syscalls.  Some examples include:
    
     * The notorious int-0x80-from-64-bit-task issue. See [1] for details.
       In short, if a 64-bit task performs a syscall through int 0x80, its
       tracer has no reliable means to find out that the syscall was, in
       fact, a compat syscall, and misidentifies it.
    
     * Syscall-enter-stop and syscall-exit-stop look the same for the
       tracer. Common practice is to keep track of the sequence of
       ptrace-stops in order not to mix the two syscall-stops up. But it is
       not as simple as it looks; for example, strace had a (just recently
       fixed) long-standing bug where attaching strace to a tracee that is
       performing the execve system call led to the tracer identifying the
       following syscall-exit-stop as syscall-enter-stop, which messed up
       all the state tracking.
    
     * Since the introduction of commit 84d77d3f06e7 ("ptrace: Don't allow
       accessing an undumpable mm"), both PTRACE_PEEKDATA and
       process_vm_readv become unavailable when the process dumpable flag is
       cleared. On such architectures as ia64 this results in all syscall
       arguments being unavailable for the tracer.
    
    Secondly, ptracers also have to support a lot of arch-specific code for
    obtaining information about the tracee.  For some architectures, this
    requires a ptrace(PTRACE_PEEKUSER, ...) invocation for every syscall
    argument and return value.
    
    ptrace(2) man page:
    
    long ptrace(enum __ptrace_request request, pid_t pid,
                void *addr, void *data);
    ...
    PTRACE_GET_SYSCALL_INFO
           Retrieve information about the syscall that caused the stop.
           The information is placed into the buffer pointed by "data"
           argument, which should be a pointer to a buffer of type
           "struct ptrace_syscall_info".
           The "addr" argument contains the size of the buffer pointed to
           by "data" argument (i.e., sizeof(struct ptrace_syscall_info)).
           The return value contains the number of bytes available
           to be written by the kernel.
           If the size of data to be written by the kernel exceeds the size
           specified by "addr" argument, the output is truncated.
    
    [ldv@altlinux.org: selftests/seccomp/seccomp_bpf: update for PTRACE_GET_SYSCALL_INFO]
      Link: http://lkml.kernel.org/r/20190708182904.GA12332@altlinux.org
    Link: http://lkml.kernel.org/r/20190510152842.GF28558@altlinux.org
    Signed-off-by: Elvira Khabirova <lineprinter@altlinux.org>
    Co-developed-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Andy Lutomirski <luto@kernel.org>
    Cc: Eugene Syromyatnikov <esyr@redhat.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Greentime Hu <greentime@andestech.com>
    Cc: Helge Deller <deller@gmx.de>        [parisc]
    Cc: James E.J. Bottomley <jejb@parisc-linux.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: kbuild test robot <lkp@intel.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Shuah Khan <shuah@kernel.org>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index d5a1b8a492b9..a71b6e3b03eb 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -73,6 +73,41 @@ struct seccomp_metadata {
 	__u64 flags;		/* Output: filter's flags */
 };
 
+#define PTRACE_GET_SYSCALL_INFO		0x420e
+#define PTRACE_SYSCALL_INFO_NONE	0
+#define PTRACE_SYSCALL_INFO_ENTRY	1
+#define PTRACE_SYSCALL_INFO_EXIT	2
+#define PTRACE_SYSCALL_INFO_SECCOMP	3
+
+struct ptrace_syscall_info {
+	__u8 op;	/* PTRACE_SYSCALL_INFO_* */
+	__u32 arch __attribute__((__aligned__(sizeof(__u32))));
+	__u64 instruction_pointer;
+	__u64 stack_pointer;
+	union {
+		struct {
+			__u64 nr;
+			__u64 args[6];
+		} entry;
+		struct {
+			__s64 rval;
+			__u8 is_error;
+		} exit;
+		struct {
+			__u64 nr;
+			__u64 args[6];
+			__u32 ret_data;
+		} seccomp;
+	};
+};
+
+/*
+ * These values are stored in task->ptrace_message
+ * by tracehook_report_syscall_* to describe the current syscall-stop.
+ */
+#define PTRACE_EVENTMSG_SYSCALL_ENTRY	1
+#define PTRACE_EVENTMSG_SYSCALL_EXIT	2
+
 /* Read signals from a shared (process wide) queue */
 #define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)
 

commit 2a040f9f39d3b020c79e08dec26d12a7ce131c10
Author: Tycho Andersen <tycho@tycho.ws>
Date:   Tue Feb 20 19:47:45 2018 -0700

    seccomp, ptrace: switch get_metadata types to arch independent
    
    Commit 26500475ac1b ("ptrace, seccomp: add support for retrieving seccomp
    metadata") introduced `struct seccomp_metadata`, which contained unsigned
    longs that should be arch independent. The type of the flags member was
    chosen to match the corresponding argument to seccomp(), and so we need
    something at least as big as unsigned long. My understanding is that __u64
    should fit the bill, so let's switch both types to that.
    
    While this is userspace facing, it was only introduced in 4.16-rc2, and so
    should be safe assuming it goes in before then.
    
    Reported-by: "Dmitry V. Levin" <ldv@altlinux.org>
    Signed-off-by: Tycho Andersen <tycho@tycho.ws>
    CC: Kees Cook <keescook@chromium.org>
    CC: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: "Dmitry V. Levin" <ldv@altlinux.org>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index e46d82b91166..d5a1b8a492b9 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -69,8 +69,8 @@ struct ptrace_peeksiginfo_args {
 #define PTRACE_SECCOMP_GET_METADATA	0x420d
 
 struct seccomp_metadata {
-	unsigned long filter_off;	/* Input: which filter */
-	unsigned int flags;		/* Output: filter's flags */
+	__u64 filter_off;	/* Input: which filter */
+	__u64 flags;		/* Output: filter's flags */
 };
 
 /* Read signals from a shared (process wide) queue */

commit 26500475ac1b499d8636ff281311d633909f5d20
Author: Tycho Andersen <tycho@docker.com>
Date:   Wed Oct 11 09:39:21 2017 -0600

    ptrace, seccomp: add support for retrieving seccomp metadata
    
    With the new SECCOMP_FILTER_FLAG_LOG, we need to be able to extract these
    flags for checkpoint restore, since they describe the state of a filter.
    
    So, let's add PTRACE_SECCOMP_GET_METADATA, similar to ..._GET_FILTER, which
    returns the metadata of the nth filter (right now, just the flags).
    Hopefully this will be future proof, and new per-filter metadata can be
    added to this struct.
    
    Signed-off-by: Tycho Andersen <tycho@docker.com>
    CC: Kees Cook <keescook@chromium.org>
    CC: Andy Lutomirski <luto@amacapital.net>
    CC: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index e3939e00980b..e46d82b91166 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -66,6 +66,12 @@ struct ptrace_peeksiginfo_args {
 #define PTRACE_SETSIGMASK	0x420b
 
 #define PTRACE_SECCOMP_GET_FILTER	0x420c
+#define PTRACE_SECCOMP_GET_METADATA	0x420d
+
+struct seccomp_metadata {
+	unsigned long filter_off;	/* Input: which filter */
+	unsigned int flags;		/* Output: filter's flags */
+};
 
 /* Read signals from a shared (process wide) queue */
 #define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index fb8106509000..e3939e00980b 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI_LINUX_PTRACE_H
 #define _UAPI_LINUX_PTRACE_H
 /* ptrace.h */

commit f8e529ed941ba2bbcbf310b575d968159ce7e895
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Tue Oct 27 09:23:59 2015 +0900

    seccomp, ptrace: add support for dumping seccomp filters
    
    This patch adds support for dumping a process' (classic BPF) seccomp
    filters via ptrace.
    
    PTRACE_SECCOMP_GET_FILTER allows the tracer to dump the user's classic BPF
    seccomp filters. addr should be an integer which represents the ith seccomp
    filter (0 is the most recently installed filter). data should be a struct
    sock_filter * with enough room for the ith filter, or NULL, in which case
    the filter is not saved. The return value for this command is the number of
    BPF instructions the program represents, or negative in the case of errors.
    Command specific errors are ENOENT: which indicates that there is no ith
    filter in this seccomp tree, and EMEDIUMTYPE, which indicates that the ith
    filter was not installed as a classic BPF filter.
    
    A caveat with this approach is that there is no way to get explicitly at
    the heirarchy of seccomp filters, and users need to memcmp() filters to
    decide which are inherited. This means that a task which installs two of
    the same filter can potentially confuse users of this interface.
    
    v2: * make save_orig const
        * check that the orig_prog exists (not necessary right now, but when
           grows eBPF support it will be)
        * s/n/filter_off and make it an unsigned long to match ptrace
        * count "down" the tree instead of "up" when passing a filter offset
    
    v3: * don't take the current task's lock for inspecting its seccomp mode
        * use a 0x42** constant for the ptrace command value
    
    v4: * don't copy to userspace while holding spinlocks
    
    v5: * add another condition to WARN_ON
    
    v6: * rebase on net-next
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    CC: Will Drewry <wad@chromium.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    CC: Andy Lutomirski <luto@amacapital.net>
    CC: Pavel Emelyanov <xemul@parallels.com>
    CC: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    CC: Alexei Starovoitov <ast@kernel.org>
    CC: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index a7a697986614..fb8106509000 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -64,6 +64,8 @@ struct ptrace_peeksiginfo_args {
 #define PTRACE_GETSIGMASK	0x420a
 #define PTRACE_SETSIGMASK	0x420b
 
+#define PTRACE_SECCOMP_GET_FILTER	0x420c
+
 /* Read signals from a shared (process wide) queue */
 #define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)
 

commit 13c4a90119d28cfcb6b5bdd820c233b86c2b0237
Author: Tycho Andersen <tycho.andersen@canonical.com>
Date:   Sat Jun 13 09:02:48 2015 -0600

    seccomp: add ptrace options for suspend/resume
    
    This patch is the first step in enabling checkpoint/restore of processes
    with seccomp enabled.
    
    One of the things CRIU does while dumping tasks is inject code into them
    via ptrace to collect information that is only available to the process
    itself. However, if we are in a seccomp mode where these processes are
    prohibited from making these syscalls, then what CRIU does kills the task.
    
    This patch adds a new ptrace option, PTRACE_O_SUSPEND_SECCOMP, that enables
    a task from the init user namespace which has CAP_SYS_ADMIN and no seccomp
    filters to disable (and re-enable) seccomp filters for another task so that
    they can be successfully dumped (and restored). We restrict the set of
    processes that can disable seccomp through ptrace because although today
    ptrace can be used to bypass seccomp, there is some discussion of closing
    this loophole in the future and we would like this patch to not depend on
    that behavior and be future proofed for when it is removed.
    
    Note that seccomp can be suspended before any filters are actually
    installed; this behavior is useful on criu restore, so that we can suspend
    seccomp, restore the filters, unmap our restore code from the restored
    process' address space, and then resume the task by detaching and have the
    filters resumed as well.
    
    v2 changes:
    
    * require that the tracer have no seccomp filters installed
    * drop TIF_NOTSC manipulation from the patch
    * change from ptrace command to a ptrace option and use this ptrace option
      as the flag to check. This means that as soon as the tracer
      detaches/dies, seccomp is re-enabled and as a corrollary that one can not
      disable seccomp across PTRACE_ATTACHs.
    
    v3 changes:
    
    * get rid of various #ifdefs everywhere
    * report more sensible errors when PTRACE_O_SUSPEND_SECCOMP is incorrectly
      used
    
    v4 changes:
    
    * get rid of may_suspend_seccomp() in favor of a capable() check in ptrace
      directly
    
    v5 changes:
    
    * check that seccomp is not enabled (or suspended) on the tracer
    
    Signed-off-by: Tycho Andersen <tycho.andersen@canonical.com>
    CC: Will Drewry <wad@chromium.org>
    CC: Roland McGrath <roland@hack.frob.com>
    CC: Pavel Emelyanov <xemul@parallels.com>
    CC: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Andy Lutomirski <luto@amacapital.net>
    [kees: access seccomp.mode through seccomp_mode() instead]
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index cf1019e15f5b..a7a697986614 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -89,9 +89,11 @@ struct ptrace_peeksiginfo_args {
 #define PTRACE_O_TRACESECCOMP	(1 << PTRACE_EVENT_SECCOMP)
 
 /* eventless options */
-#define PTRACE_O_EXITKILL	(1 << 20)
+#define PTRACE_O_EXITKILL		(1 << 20)
+#define PTRACE_O_SUSPEND_SECCOMP	(1 << 21)
 
-#define PTRACE_O_MASK		(0x000000ff | PTRACE_O_EXITKILL)
+#define PTRACE_O_MASK		(\
+	0x000000ff | PTRACE_O_EXITKILL | PTRACE_O_SUSPEND_SECCOMP)
 
 #include <asm/ptrace.h>
 

commit 29000caecbe87b6b66f144f72111f0d02fbbf0c1
Author: Andrey Vagin <avagin@openvz.org>
Date:   Wed Jul 3 15:08:12 2013 -0700

    ptrace: add ability to get/set signal-blocked mask
    
    crtools uses a parasite code for dumping processes.  The parasite code is
    injected into a process with help PTRACE_SEIZE.
    
    Currently crtools blocks signals from a parasite code.  If a process has
    pending signals, crtools wait while a process handles these signals.
    
    This method is not suitable for stopped tasks.  A stopped task can have a
    few pending signals, when we will try to execute a parasite code, we will
    need to drop SIGSTOP, but all other signals must remain pending, because a
    state of processes must not be changed during checkpointing.
    
    This patch adds two ptrace commands to set/get signal-blocked mask.
    
    I think gdb can use this commands too.
    
    [akpm@linux-foundation.org: be consistent with brace layout]
    Signed-off-by: Andrey Vagin <avagin@openvz.org>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index 52ebcc89f306..cf1019e15f5b 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -61,6 +61,9 @@ struct ptrace_peeksiginfo_args {
 	__s32 nr;	/* how may siginfos to take */
 };
 
+#define PTRACE_GETSIGMASK	0x420a
+#define PTRACE_SETSIGMASK	0x420b
+
 /* Read signals from a shared (process wide) queue */
 #define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)
 

commit 84c751bd4aebbaae995fe32279d3dba48327bad4
Author: Andrey Vagin <avagin@openvz.org>
Date:   Tue Apr 30 15:27:59 2013 -0700

    ptrace: add ability to retrieve signals without removing from a queue (v4)
    
    This patch adds a new ptrace request PTRACE_PEEKSIGINFO.
    
    This request is used to retrieve information about pending signals
    starting with the specified sequence number.  Siginfo_t structures are
    copied from the child into the buffer starting at "data".
    
    The argument "addr" is a pointer to struct ptrace_peeksiginfo_args.
    struct ptrace_peeksiginfo_args {
            u64 off;        /* from which siginfo to start */
            u32 flags;
            s32 nr;         /* how may siginfos to take */
    };
    
    "nr" has type "s32", because ptrace() returns "long", which has 32 bits on
    i386 and a negative values is used for errors.
    
    Currently here is only one flag PTRACE_PEEKSIGINFO_SHARED for dumping
    signals from process-wide queue.  If this flag is not set, signals are
    read from a per-thread queue.
    
    The request PTRACE_PEEKSIGINFO returns a number of dumped signals.  If a
    signal with the specified sequence number doesn't exist, ptrace returns
    zero.  The request returns an error, if no signal has been dumped.
    
    Errors:
    EINVAL - one or more specified flags are not supported or nr is negative
    EFAULT - buf or addr is outside your accessible address space.
    
    A result siginfo contains a kernel part of si_code which usually striped,
    but it's required for queuing the same siginfo back during restore of
    pending signals.
    
    This functionality is required for checkpointing pending signals.  Pedro
    Alves suggested using it in "gdb" to peek at pending signals.  gdb already
    uses PTRACE_GETSIGINFO to get the siginfo for the signal which was already
    dequeued.  This functionality allows gdb to look at the pending signals
    which were not reported yet.
    
    The prototype of this code was developed by Oleg Nesterov.
    
    Signed-off-by: Andrew Vagin <avagin@openvz.org>
    Cc: Roland McGrath <roland@redhat.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: "Michael Kerrisk (man-pages)" <mtk.manpages@gmail.com>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Pedro Alves <palves@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index 022ab186a812..52ebcc89f306 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -5,6 +5,7 @@
 
 /* has the defines to get at the registers. */
 
+#include <linux/types.h>
 
 #define PTRACE_TRACEME		   0
 #define PTRACE_PEEKTEXT		   1
@@ -52,6 +53,17 @@
 #define PTRACE_INTERRUPT	0x4207
 #define PTRACE_LISTEN		0x4208
 
+#define PTRACE_PEEKSIGINFO	0x4209
+
+struct ptrace_peeksiginfo_args {
+	__u64 off;	/* from which siginfo to start */
+	__u32 flags;
+	__s32 nr;	/* how may siginfos to take */
+};
+
+/* Read signals from a shared (process wide) queue */
+#define PTRACE_PEEKSIGINFO_SHARED	(1 << 0)
+
 /* Wait extended result codes for the above trace options.  */
 #define PTRACE_EVENT_FORK	1
 #define PTRACE_EVENT_VFORK	2

commit 992fb6e170639b0849bace8e49bf31bd37c4123c
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Dec 17 16:03:07 2012 -0800

    ptrace: introduce PTRACE_O_EXITKILL
    
    Ptrace jailers want to be sure that the tracee can never escape
    from the control. However if the tracer dies unexpectedly the
    tracee continues to run in potentially unsafe mode.
    
    Add the new ptrace option PTRACE_O_EXITKILL. If the tracer exits
    it sends SIGKILL to every tracee which has this bit set.
    
    Note that the new option is not equal to the last-option << 1.  Because
    currently all options have an event, and the new one starts the eventless
    group.  It uses the random 20 bit, so we have the room for 12 more events,
    but we can also add the new eventless options below this one.
    
    Suggested by Amnon Shiloh.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Tested-by: Amnon Shiloh <u3557@miso.sublimeip.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Serge Hallyn <serge.hallyn@canonical.com>
    Cc: Chris Evans <scarybeasts@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
index 1ef6c056a9e4..022ab186a812 100644
--- a/include/uapi/linux/ptrace.h
+++ b/include/uapi/linux/ptrace.h
@@ -73,7 +73,10 @@
 #define PTRACE_O_TRACEEXIT	(1 << PTRACE_EVENT_EXIT)
 #define PTRACE_O_TRACESECCOMP	(1 << PTRACE_EVENT_SECCOMP)
 
-#define PTRACE_O_MASK		0x000000ff
+/* eventless options */
+#define PTRACE_O_EXITKILL	(1 << 20)
+
+#define PTRACE_O_MASK		(0x000000ff | PTRACE_O_EXITKILL)
 
 #include <asm/ptrace.h>
 

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/ptrace.h b/include/uapi/linux/ptrace.h
new file mode 100644
index 000000000000..1ef6c056a9e4
--- /dev/null
+++ b/include/uapi/linux/ptrace.h
@@ -0,0 +1,81 @@
+#ifndef _UAPI_LINUX_PTRACE_H
+#define _UAPI_LINUX_PTRACE_H
+/* ptrace.h */
+/* structs and defines to help the user use the ptrace system call. */
+
+/* has the defines to get at the registers. */
+
+
+#define PTRACE_TRACEME		   0
+#define PTRACE_PEEKTEXT		   1
+#define PTRACE_PEEKDATA		   2
+#define PTRACE_PEEKUSR		   3
+#define PTRACE_POKETEXT		   4
+#define PTRACE_POKEDATA		   5
+#define PTRACE_POKEUSR		   6
+#define PTRACE_CONT		   7
+#define PTRACE_KILL		   8
+#define PTRACE_SINGLESTEP	   9
+
+#define PTRACE_ATTACH		  16
+#define PTRACE_DETACH		  17
+
+#define PTRACE_SYSCALL		  24
+
+/* 0x4200-0x4300 are reserved for architecture-independent additions.  */
+#define PTRACE_SETOPTIONS	0x4200
+#define PTRACE_GETEVENTMSG	0x4201
+#define PTRACE_GETSIGINFO	0x4202
+#define PTRACE_SETSIGINFO	0x4203
+
+/*
+ * Generic ptrace interface that exports the architecture specific regsets
+ * using the corresponding NT_* types (which are also used in the core dump).
+ * Please note that the NT_PRSTATUS note type in a core dump contains a full
+ * 'struct elf_prstatus'. But the user_regset for NT_PRSTATUS contains just the
+ * elf_gregset_t that is the pr_reg field of 'struct elf_prstatus'. For all the
+ * other user_regset flavors, the user_regset layout and the ELF core dump note
+ * payload are exactly the same layout.
+ *
+ * This interface usage is as follows:
+ *	struct iovec iov = { buf, len};
+ *
+ *	ret = ptrace(PTRACE_GETREGSET/PTRACE_SETREGSET, pid, NT_XXX_TYPE, &iov);
+ *
+ * On the successful completion, iov.len will be updated by the kernel,
+ * specifying how much the kernel has written/read to/from the user's iov.buf.
+ */
+#define PTRACE_GETREGSET	0x4204
+#define PTRACE_SETREGSET	0x4205
+
+#define PTRACE_SEIZE		0x4206
+#define PTRACE_INTERRUPT	0x4207
+#define PTRACE_LISTEN		0x4208
+
+/* Wait extended result codes for the above trace options.  */
+#define PTRACE_EVENT_FORK	1
+#define PTRACE_EVENT_VFORK	2
+#define PTRACE_EVENT_CLONE	3
+#define PTRACE_EVENT_EXEC	4
+#define PTRACE_EVENT_VFORK_DONE	5
+#define PTRACE_EVENT_EXIT	6
+#define PTRACE_EVENT_SECCOMP	7
+/* Extended result codes which enabled by means other than options.  */
+#define PTRACE_EVENT_STOP	128
+
+/* Options set using PTRACE_SETOPTIONS or using PTRACE_SEIZE @data param */
+#define PTRACE_O_TRACESYSGOOD	1
+#define PTRACE_O_TRACEFORK	(1 << PTRACE_EVENT_FORK)
+#define PTRACE_O_TRACEVFORK	(1 << PTRACE_EVENT_VFORK)
+#define PTRACE_O_TRACECLONE	(1 << PTRACE_EVENT_CLONE)
+#define PTRACE_O_TRACEEXEC	(1 << PTRACE_EVENT_EXEC)
+#define PTRACE_O_TRACEVFORKDONE	(1 << PTRACE_EVENT_VFORK_DONE)
+#define PTRACE_O_TRACEEXIT	(1 << PTRACE_EVENT_EXIT)
+#define PTRACE_O_TRACESECCOMP	(1 << PTRACE_EVENT_SECCOMP)
+
+#define PTRACE_O_MASK		0x000000ff
+
+#include <asm/ptrace.h>
+
+
+#endif /* _UAPI_LINUX_PTRACE_H */
