commit f517f7925b7b453cb83be06c268ba057b78e4792
Author: Vaibhav Jain <vaibhav@linux.ibm.com>
Date:   Mon Jun 15 18:14:06 2020 +0530

    ndctl/papr_scm,uapi: Add support for PAPR nvdimm specific methods
    
    Introduce support for PAPR NVDIMM Specific Methods (PDSM) in papr_scm
    module and add the command family NVDIMM_FAMILY_PAPR to the white list
    of NVDIMM command sets. Also advertise support for ND_CMD_CALL for the
    nvdimm command mask and implement necessary scaffolding in the module
    to handle ND_CMD_CALL ioctl and PDSM requests that we receive.
    
    The layout of the PDSM request as we expect from libnvdimm/libndctl is
    described in newly introduced uapi header 'papr_pdsm.h' which
    defines a 'struct nd_pkg_pdsm' and a maximal union named
    'nd_pdsm_payload'. These new structs together with 'struct nd_cmd_pkg'
    for a pdsm envelop thats sent by libndctl to libnvdimm and serviced by
    papr_scm in 'papr_scm_service_pdsm()'. The PDSM request is
    communicated by member 'struct nd_cmd_pkg.nd_command' together with
    other information on the pdsm payload (size-in, size-out).
    
    The patch also introduces 'struct pdsm_cmd_desc' instances of which
    are stored in an array __pdsm_cmd_descriptors[] indexed with PDSM cmd
    and corresponding access function pdsm_cmd_desc() is
    introduced. 'struct pdsm_cdm_desc' holds the service function for a
    given PDSM and corresponding payload in/out sizes.
    
    A new function papr_scm_service_pdsm() is introduced and is called from
    papr_scm_ndctl() in case of a PDSM request is received via ND_CMD_CALL
    command from libnvdimm. The function performs validation on the PDSM
    payload based on info present in corresponding PDSM descriptor and if
    valid calls the 'struct pdcm_cmd_desc.service' function to service the
    PDSM.
    
    Signed-off-by: Vaibhav Jain <vaibhav@linux.ibm.com>
    Cc: "Aneesh Kumar K . V" <aneesh.kumar@linux.ibm.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ira Weiny <ira.weiny@intel.com>
    Link: https://lore.kernel.org/r/20200615124407.32596-6-vaibhav@linux.ibm.com
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index de5d90212409..0e09dc5cec19 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -244,6 +244,7 @@ struct nd_cmd_pkg {
 #define NVDIMM_FAMILY_HPE2 2
 #define NVDIMM_FAMILY_MSFT 3
 #define NVDIMM_FAMILY_HYPERV 4
+#define NVDIMM_FAMILY_PAPR 5
 
 #define ND_IOCTL_CALL			_IOWR(ND_IOCTL, ND_CMD_CALL,\
 					struct nd_cmd_pkg)

commit 1194c4133195dfcb6c5fc0935d54bbed872a5285
Author: Dexuan Cui <decui@microsoft.com>
Date:   Tue Jan 29 00:56:17 2019 +0000

    nfit: Add Hyper-V NVDIMM DSM command set to white list
    
    Add the Hyper-V _DSM command set to the white list of NVDIMM command
    sets.
    
    This command set is documented at http://www.uefi.org/RFIC_LIST
    (see "Virtual NVDIMM 0x1901").
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index f57c9e434d2d..de5d90212409 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -243,6 +243,7 @@ struct nd_cmd_pkg {
 #define NVDIMM_FAMILY_HPE1 1
 #define NVDIMM_FAMILY_HPE2 2
 #define NVDIMM_FAMILY_MSFT 3
+#define NVDIMM_FAMILY_HYPERV 4
 
 #define ND_IOCTL_CALL			_IOWR(ND_IOCTL, ND_CMD_CALL,\
 					struct nd_cmd_pkg)

commit f366d322aea782cf786aa821d5accdc1609f9e10
Author: David Howells <dhowells@redhat.com>
Date:   Thu Sep 6 10:19:30 2018 +0100

    UAPI: ndctl: Remove use of PAGE_SIZE
    
    The macro PAGE_SIZE isn't valid outside of the kernel, so it should not
    appear in UAPI headers.
    
    Furthermore, the actual machine page size could theoretically change from
    an application's point of view if it's running in a container that gets
    migrated to another machine (say 4K/ppc64 to 64K/ppc64).
    
    Fixes: f2ba5a5baecf ("libnvdimm, namespace: make min namespace size 4K")
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 2f2c43d633c5..f57c9e434d2d 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -202,10 +202,6 @@ enum nd_driver_flags {
 	ND_DRIVER_DAX_PMEM	  = 1 << ND_DEVICE_DAX_PMEM,
 };
 
-enum {
-	ND_MIN_NAMESPACE_SIZE = PAGE_SIZE,
-};
-
 enum ars_masks {
 	ARS_STATUS_MASK = 0x0000FFFF,
 	ARS_EXT_STATUS_SHIFT = 16,

commit 9607871f37dc3e717639694b8d0dc738f2a68efc
Author: David Howells <dhowells@redhat.com>
Date:   Thu Sep 6 10:19:24 2018 +0100

    UAPI: ndctl: Fix g++-unsupported initialisation in headers
    
    The following code in the linux/ndctl header file:
    
            static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
            {
                    static const char * const names[] = {
                            [ND_CMD_ARS_CAP] = "ars_cap",
                            [ND_CMD_ARS_START] = "ars_start",
                            [ND_CMD_ARS_STATUS] = "ars_status",
                            [ND_CMD_CLEAR_ERROR] = "clear_error",
                            [ND_CMD_CALL] = "cmd_call",
                    };
    
                    if (cmd < ARRAY_SIZE(names) && names[cmd])
                            return names[cmd];
                    return "unknown";
            }
    
    is broken in a number of ways:
    
     (1) ARRAY_SIZE() is not generally defined.
    
     (2) g++ does not support "non-trivial" array initialisers fully yet.
    
     (3) Every file that calls this function will acquire a copy of names[].
    
    The same goes for nvdimm_cmd_name().
    
    Fix all three by converting to a switch statement where each case returns a
    string.  That way if cmd is a constant, the compiler can trivially reduce it
    and, if not, the compiler can use a shared lookup table if it thinks that is
    more efficient.
    
    A better way would be to remove these functions and their arrays from the
    header entirely.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 7e27070b9440..2f2c43d633c5 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -128,37 +128,31 @@ enum {
 
 static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
 {
-	static const char * const names[] = {
-		[ND_CMD_ARS_CAP] = "ars_cap",
-		[ND_CMD_ARS_START] = "ars_start",
-		[ND_CMD_ARS_STATUS] = "ars_status",
-		[ND_CMD_CLEAR_ERROR] = "clear_error",
-		[ND_CMD_CALL] = "cmd_call",
-	};
-
-	if (cmd < ARRAY_SIZE(names) && names[cmd])
-		return names[cmd];
-	return "unknown";
+	switch (cmd) {
+	case ND_CMD_ARS_CAP:		return "ars_cap";
+	case ND_CMD_ARS_START:		return "ars_start";
+	case ND_CMD_ARS_STATUS:		return "ars_status";
+	case ND_CMD_CLEAR_ERROR:	return "clear_error";
+	case ND_CMD_CALL:		return "cmd_call";
+	default:			return "unknown";
+	}
 }
 
 static inline const char *nvdimm_cmd_name(unsigned cmd)
 {
-	static const char * const names[] = {
-		[ND_CMD_SMART] = "smart",
-		[ND_CMD_SMART_THRESHOLD] = "smart_thresh",
-		[ND_CMD_DIMM_FLAGS] = "flags",
-		[ND_CMD_GET_CONFIG_SIZE] = "get_size",
-		[ND_CMD_GET_CONFIG_DATA] = "get_data",
-		[ND_CMD_SET_CONFIG_DATA] = "set_data",
-		[ND_CMD_VENDOR_EFFECT_LOG_SIZE] = "effect_size",
-		[ND_CMD_VENDOR_EFFECT_LOG] = "effect_log",
-		[ND_CMD_VENDOR] = "vendor",
-		[ND_CMD_CALL] = "cmd_call",
-	};
-
-	if (cmd < ARRAY_SIZE(names) && names[cmd])
-		return names[cmd];
-	return "unknown";
+	switch (cmd) {
+	case ND_CMD_SMART:			return "smart";
+	case ND_CMD_SMART_THRESHOLD:		return "smart_thresh";
+	case ND_CMD_DIMM_FLAGS:			return "flags";
+	case ND_CMD_GET_CONFIG_SIZE:		return "get_size";
+	case ND_CMD_GET_CONFIG_DATA:		return "get_data";
+	case ND_CMD_SET_CONFIG_DATA:		return "set_data";
+	case ND_CMD_VENDOR_EFFECT_LOG_SIZE:	return "effect_size";
+	case ND_CMD_VENDOR_EFFECT_LOG:		return "effect_log";
+	case ND_CMD_VENDOR:			return "vendor";
+	case ND_CMD_CALL:			return "cmd_call";
+	default:				return "unknown";
+	}
 }
 
 #define ND_IOCTL 'N'

commit f2ba5a5baecf795c2150826bd0c95fc3f7f3d226
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Feb 1 21:27:22 2018 -0800

    libnvdimm, namespace: make min namespace size 4K
    
    The arbitrary 4MB minimum namespace size turns out to be too large for
    some environments. Quoting Cheng-mean Liu:
    
        In the case of emulated NVDIMM devices in the VM environment, there
        are scenarios that NVDIMM device with much smaller sizes are
        desired, for example, we might use a single enumerated NVDIMM DAX
        device for representing each container layer, which in some cases
        could be just a few KBs size.
    
    PAGE_SIZE is the minimum where we can still support DAX of at least
    a single page.
    
    Cc: Matthew Wilcox <willy@infradead.org>
    Reported-by: Cheng-mean Liu <soccerl@microsoft.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 30ef1236aafa..7e27070b9440 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -209,7 +209,7 @@ enum nd_driver_flags {
 };
 
 enum {
-	ND_MIN_NAMESPACE_SIZE = 0x00400000,
+	ND_MIN_NAMESPACE_SIZE = PAGE_SIZE,
 };
 
 enum ars_masks {

commit cdd77d3e193031cc67426cd671d8aa370f7dfee4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Nov 17 16:23:08 2017 -0800

    nfit, libnvdimm: deprecate the generic SMART ioctl
    
    The kernel's ND_IOCTL_SMART_THRESHOLD command is based on a payload
    definition that has become broken / out-of-sync with recent versions of
    the NVDIMM_FAMILY_INTEL definition. Deprecate the use of the
    ND_IOCTL_SMART_THRESHOLD command in favor of the ND_CMD_CALL approach
    taken by NVDIMM_FAMILY_{HPE,MSFT}, where we can manage the per-vendor
    variance in userspace.
    
    In a couple years, when the new scheme is widely deployed in userspace
    packages, the ND_IOCTL_SMART_THRESHOLD support can be removed. For now
    we prevent new binaries from compiling against the kernel header
    definitions, but kernel still compatible with old binaries. The
    libndctl.h [1] header is now the authoritative interface definition for
    NVDIMM SMART.
    
    [1]: https://github.com/pmem/ndctl
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 3f03567631cb..30ef1236aafa 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -15,54 +15,6 @@
 
 #include <linux/types.h>
 
-struct nd_cmd_smart {
-	__u32 status;
-	__u8 data[128];
-} __packed;
-
-#define ND_SMART_HEALTH_VALID	(1 << 0)
-#define ND_SMART_SPARES_VALID	(1 << 1)
-#define ND_SMART_USED_VALID	(1 << 2)
-#define ND_SMART_TEMP_VALID 	(1 << 3)
-#define ND_SMART_CTEMP_VALID 	(1 << 4)
-#define ND_SMART_ALARM_VALID	(1 << 9)
-#define ND_SMART_SHUTDOWN_VALID	(1 << 10)
-#define ND_SMART_VENDOR_VALID	(1 << 11)
-#define ND_SMART_SPARE_TRIP	(1 << 0)
-#define ND_SMART_TEMP_TRIP	(1 << 1)
-#define ND_SMART_CTEMP_TRIP	(1 << 2)
-#define ND_SMART_NON_CRITICAL_HEALTH	(1 << 0)
-#define ND_SMART_CRITICAL_HEALTH	(1 << 1)
-#define ND_SMART_FATAL_HEALTH		(1 << 2)
-
-struct nd_smart_payload {
-	__u32 flags;
-	__u8 reserved0[4];
-	__u8 health;
-	__u8 spares;
-	__u8 life_used;
-	__u8 alarm_flags;
-	__u16 temperature;
-	__u16 ctrl_temperature;
-	__u8 reserved1[15];
-	__u8 shutdown_state;
-	__u32 vendor_size;
-	__u8 vendor_data[92];
-} __packed;
-
-struct nd_cmd_smart_threshold {
-	__u32 status;
-	__u8 data[8];
-} __packed;
-
-struct nd_smart_threshold_payload {
-	__u8 alarm_control;
-	__u8 reserved0;
-	__u16 temperature;
-	__u8 spares;
-	__u8 reserved[3];
-} __packed;
-
 struct nd_cmd_dimm_flags {
 	__u32 status;
 	__u32 flags;
@@ -211,12 +163,6 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 
 #define ND_IOCTL 'N'
 
-#define ND_IOCTL_SMART			_IOWR(ND_IOCTL, ND_CMD_SMART,\
-					struct nd_cmd_smart)
-
-#define ND_IOCTL_SMART_THRESHOLD	_IOWR(ND_IOCTL, ND_CMD_SMART_THRESHOLD,\
-					struct nd_cmd_smart_threshold)
-
 #define ND_IOCTL_DIMM_FLAGS		_IOWR(ND_IOCTL, ND_CMD_DIMM_FLAGS,\
 					struct nd_cmd_dimm_flags)
 

commit 7a14724f54bf9889fcb1a9f1d4aa4e1d2e969d93
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 28 08:33:20 2017 -0700

    libnvdimm: clean up command definitions
    
    Remove the command payloads that do not have an associated libnvdimm
    ioctl. I.e. remove the payloads that would only ever be carried in the
    ND_CMD_CALL envelope. This prevents userspace from growing unnecessary
    dependencies on this kernel header when userspace already has everything
    it needs to craft and send these commands.
    
    Cc: Jerry Hoemann <jerry.hoemann@hpe.com>
    Reported-by: Yasunori Goto <y-goto@jp.fujitsu.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 6d3c54264d8e..3f03567631cb 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -145,43 +145,6 @@ struct nd_cmd_clear_error {
 	__u64 cleared;
 } __packed;
 
-struct nd_cmd_trans_spa {
-	__u64 spa;
-	__u32 status;
-	__u8  flags;
-	__u8  _reserved[3];
-	__u64 trans_length;
-	__u32 num_nvdimms;
-	struct nd_nvdimm_device {
-		__u32 nfit_device_handle;
-		__u32 _reserved;
-		__u64 dpa;
-	} __packed devices[0];
-
-} __packed;
-
-struct nd_cmd_ars_err_inj {
-	__u64 err_inj_spa_range_base;
-	__u64 err_inj_spa_range_length;
-	__u8  err_inj_options;
-	__u32 status;
-} __packed;
-
-struct nd_cmd_ars_err_inj_clr {
-	__u64 err_inj_clr_spa_range_base;
-	__u64 err_inj_clr_spa_range_length;
-	__u32 status;
-} __packed;
-
-struct nd_cmd_ars_err_inj_stat {
-	__u32 status;
-	__u32 inj_err_rec_count;
-	struct nd_error_stat_query_record {
-		__u64 err_inj_stat_spa_range_base;
-		__u64 err_inj_stat_spa_range_length;
-	} __packed record[0];
-} __packed;
-
 enum {
 	ND_CMD_IMPLEMENTED = 0,
 

commit 807900395efebf9276178eb6157959f2e81fe013
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Thu Jun 29 20:41:30 2017 -0600

    acpi/nfit: Issue Start ARS to retrieve existing records
    
    ACPI 6.2 defines in section 9.20.7.2 that the OSPM may call a Start
    ARS with Flags Bit [1] set upon receiving the 0x81 notification.
    
      Upon receiving the notification, the OSPM may decide to issue
      a Start ARS with Flags Bit [1] set to prepare for the retrieval
      of existing records and issue the Query ARS Status function to
      retrieve the records.
    
    Add support to call a Start ARS from acpi_nfit_uc_error_notify()
    with ND_ARS_RETURN_PREV_DATA set when HW_ERROR_SCRUB_ON is not set.
    
    Link: http://www.uefi.org/sites/default/files/resources/ACPI_6_2.pdf
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index e15768fb4b99..6d3c54264d8e 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -207,6 +207,7 @@ enum {
 enum {
 	ND_ARS_VOLATILE = 1,
 	ND_ARS_PERSISTENT = 2,
+	ND_ARS_RETURN_PREV_DATA = 1 << 1,
 	ND_CONFIG_LOCKED = 1,
 };
 

commit 759d6a9641d7f52f9311aae4f2d90058adad3ac2
Author: Jerry Hoemann <jerry.hoemann@hpe.com>
Date:   Fri Jun 30 20:41:29 2017 -0700

    libnvdimm: New ACPI 6.2 DSM functions
    
    ACPI 6.2 added new NVDIMM root DSM functions.  Define their
    data structures.
    
    Signed-off-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index e23c37fedade..e15768fb4b99 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -105,7 +105,8 @@ struct nd_cmd_ars_cap {
 	__u32 status;
 	__u32 max_ars_out;
 	__u32 clear_err_unit;
-	__u32 reserved;
+	__u16 flags;
+	__u16 reserved;
 } __packed;
 
 struct nd_cmd_ars_start {
@@ -144,6 +145,43 @@ struct nd_cmd_clear_error {
 	__u64 cleared;
 } __packed;
 
+struct nd_cmd_trans_spa {
+	__u64 spa;
+	__u32 status;
+	__u8  flags;
+	__u8  _reserved[3];
+	__u64 trans_length;
+	__u32 num_nvdimms;
+	struct nd_nvdimm_device {
+		__u32 nfit_device_handle;
+		__u32 _reserved;
+		__u64 dpa;
+	} __packed devices[0];
+
+} __packed;
+
+struct nd_cmd_ars_err_inj {
+	__u64 err_inj_spa_range_base;
+	__u64 err_inj_spa_range_length;
+	__u8  err_inj_options;
+	__u32 status;
+} __packed;
+
+struct nd_cmd_ars_err_inj_clr {
+	__u64 err_inj_clr_spa_range_base;
+	__u64 err_inj_clr_spa_range_length;
+	__u32 status;
+} __packed;
+
+struct nd_cmd_ars_err_inj_stat {
+	__u32 status;
+	__u32 inj_err_rec_count;
+	struct nd_error_stat_query_record {
+		__u64 err_inj_stat_spa_range_base;
+		__u64 err_inj_stat_spa_range_length;
+	} __packed record[0];
+} __packed;
+
 enum {
 	ND_CMD_IMPLEMENTED = 0,
 

commit 37d74841b9d42b105cba053e70e9db0e395949da
Author: Jerry Hoemann <jerry.hoemann@hpe.com>
Date:   Fri Jun 30 20:41:24 2017 -0700

    acpi, nfit: Enable DSM pass thru for root functions.
    
    Set ND_CMD_CALL in the cmd_mask to enable calling root
    functions via the pass thru mechanism.
    
    Signed-off-by: Jerry Hoemann <jerry.hoemann@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 7ad3863cb88b..e23c37fedade 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -179,6 +179,7 @@ static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
 		[ND_CMD_ARS_START] = "ars_start",
 		[ND_CMD_ARS_STATUS] = "ars_status",
 		[ND_CMD_CLEAR_ERROR] = "clear_error",
+		[ND_CMD_CALL] = "cmd_call",
 	};
 
 	if (cmd < ARRAY_SIZE(names) && names[cmd])

commit 9d62ed96511823fa9c2ac7a819d7b4be22a9a6de
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 4 11:47:22 2017 -0700

    libnvdimm: handle locked label storage areas
    
    Per the latest version of the "NVDIMM DSM Interface Example" [1], the
    label data retrieval routine can report a "locked" status. In this case
    all regions associated with that DIMM are disabled until the label area
    is unlocked. Provide generic libnvdimm enabling for NVDIMMs with label
    data area locking capabilities.
    
    [1]: http://pmem.io/documents/
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index ede5c6a62164..7ad3863cb88b 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -169,6 +169,7 @@ enum {
 enum {
 	ND_ARS_VOLATILE = 1,
 	ND_ARS_PERSISTENT = 2,
+	ND_CONFIG_LOCKED = 1,
 };
 
 static inline const char *nvdimm_bus_cmd_name(unsigned cmd)

commit 02486c2905a7caa50b0f508a86e03d12d8d24ac4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Aug 11 17:36:20 2016 -0700

    libnvdimm: fix SMART Health DSM payload definition
    
    "NVDIMM DSM Interface Example" v1.2 made an incompatible change to the
    layout of function1 "SMART and Health Info".  While the kernel does not
    directly consume this payload, it does define it in ndctl.h that
    userpace utilities consume.
    
    Reported-by: Brian Boylston <brian.boylston@hpe.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index ba5a8c79652a..ede5c6a62164 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -21,14 +21,16 @@ struct nd_cmd_smart {
 } __packed;
 
 #define ND_SMART_HEALTH_VALID	(1 << 0)
-#define ND_SMART_TEMP_VALID 	(1 << 1)
-#define ND_SMART_SPARES_VALID	(1 << 2)
-#define ND_SMART_ALARM_VALID	(1 << 3)
-#define ND_SMART_USED_VALID	(1 << 4)
-#define ND_SMART_SHUTDOWN_VALID	(1 << 5)
-#define ND_SMART_VENDOR_VALID	(1 << 6)
-#define ND_SMART_TEMP_TRIP	(1 << 0)
-#define ND_SMART_SPARE_TRIP	(1 << 1)
+#define ND_SMART_SPARES_VALID	(1 << 1)
+#define ND_SMART_USED_VALID	(1 << 2)
+#define ND_SMART_TEMP_VALID 	(1 << 3)
+#define ND_SMART_CTEMP_VALID 	(1 << 4)
+#define ND_SMART_ALARM_VALID	(1 << 9)
+#define ND_SMART_SHUTDOWN_VALID	(1 << 10)
+#define ND_SMART_VENDOR_VALID	(1 << 11)
+#define ND_SMART_SPARE_TRIP	(1 << 0)
+#define ND_SMART_TEMP_TRIP	(1 << 1)
+#define ND_SMART_CTEMP_TRIP	(1 << 2)
 #define ND_SMART_NON_CRITICAL_HEALTH	(1 << 0)
 #define ND_SMART_CRITICAL_HEALTH	(1 << 1)
 #define ND_SMART_FATAL_HEALTH		(1 << 2)
@@ -37,14 +39,15 @@ struct nd_smart_payload {
 	__u32 flags;
 	__u8 reserved0[4];
 	__u8 health;
-	__u16 temperature;
 	__u8 spares;
-	__u8 alarm_flags;
 	__u8 life_used;
+	__u8 alarm_flags;
+	__u16 temperature;
+	__u16 ctrl_temperature;
+	__u8 reserved1[15];
 	__u8 shutdown_state;
-	__u8 reserved1;
 	__u32 vendor_size;
-	__u8 vendor_data[108];
+	__u8 vendor_data[92];
 } __packed;
 
 struct nd_cmd_smart_threshold {
@@ -53,7 +56,8 @@ struct nd_cmd_smart_threshold {
 } __packed;
 
 struct nd_smart_threshold_payload {
-	__u16 alarm_control;
+	__u8 alarm_control;
+	__u8 reserved0;
 	__u16 temperature;
 	__u8 spares;
 	__u8 reserved[3];

commit e02fb7264d8a31dddb9a80fbde603feb502d6478
Author: stuart hayes <stuart.w.hayes@gmail.com>
Date:   Thu May 26 11:38:41 2016 -0500

    nfit: add Microsoft NVDIMM DSM command set to white list
    
    Add the Microsoft _DSM command set to the white list of NVDIMM command
    sets.
    
    This command set is documented at:
    
        https://msdn.microsoft.com/library/windows/hardware/mt604741
    
    Cc: Pavel Machek <pavel@ucw.cz>
    [pavel: fix up braces]
    Signed-off-by: Stuart Hayes <stuart.w.hayes@gmail.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 309915f74492..ba5a8c79652a 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -298,6 +298,7 @@ struct nd_cmd_pkg {
 #define NVDIMM_FAMILY_INTEL 0
 #define NVDIMM_FAMILY_HPE1 1
 #define NVDIMM_FAMILY_HPE2 2
+#define NVDIMM_FAMILY_MSFT 3
 
 #define ND_IOCTL_CALL			_IOWR(ND_IOCTL, ND_CMD_CALL,\
 					struct nd_cmd_pkg)

commit 1f716d05f8daee4f393dc568ea7a53c7ecfd0bfc
Merge: 2159669f5819 a94e3fbe4d53
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed May 18 10:06:59 2016 -0700

    Merge branch 'for-4.7/dsm' into libnvdimm-for-next

commit 2159669f581917c4d197d3ea183d3d85b47faf66
Merge: 594d6d96ea04 9dec4892ca9a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed May 18 10:06:48 2016 -0700

    Merge branch 'for-4.7/libnvdimm' into libnvdimm-for-next

commit cd03412a51ac4cb3001a8cdfae4560c9602f3387
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 11 10:15:36 2016 -0800

    libnvdimm, dax: introduce device-dax infrastructure
    
    Device DAX is the device-centric analogue of Filesystem DAX
    (CONFIG_FS_DAX).  It allows persistent memory ranges to be allocated and
    mapped without need of an intervening file system.  This initial
    infrastructure arranges for a libnvdimm pfn-device to be represented as
    a different device-type so that it can be attached to a driver other
    than the pmem driver.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 7cc28ab05b87..4f29d247f709 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -206,6 +206,7 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 #define ND_DEVICE_NAMESPACE_IO 4    /* legacy persistent memory */
 #define ND_DEVICE_NAMESPACE_PMEM 5  /* PMEM namespace (may alias with BLK) */
 #define ND_DEVICE_NAMESPACE_BLK 6   /* BLK namespace (may alias with PMEM) */
+#define ND_DEVICE_DAX_PMEM 7        /* Device DAX interface to pmem */
 
 enum nd_driver_flags {
 	ND_DRIVER_DIMM            = 1 << ND_DEVICE_DIMM,
@@ -214,6 +215,7 @@ enum nd_driver_flags {
 	ND_DRIVER_NAMESPACE_IO    = 1 << ND_DEVICE_NAMESPACE_IO,
 	ND_DRIVER_NAMESPACE_PMEM  = 1 << ND_DEVICE_NAMESPACE_PMEM,
 	ND_DRIVER_NAMESPACE_BLK   = 1 << ND_DEVICE_NAMESPACE_BLK,
+	ND_DRIVER_DAX_PMEM	  = 1 << ND_DEVICE_DAX_PMEM,
 };
 
 enum {

commit 31eca76ba2fc988bf88f16fcf763a0ec4068cd30
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 28 16:23:43 2016 -0700

    nfit, libnvdimm: limited/whitelisted dimm command marshaling mechanism
    
    There are currently 4 known similar but incompatible definitions of the
    command sets that can be sent to an NVDIMM through ACPI.  It is also
    clear that future platform generations (ACPI or not) will continue to
    revise and extend the DIMM command set as new devices and use cases
    arrive.
    
    It is obviously untenable to continue to proliferate divergence
    of these command definitions, and to that end a standardization process
    has begun to provide for a unified specification.  However, that leaves a
    problem about what to do with this first generation where vendors are
    already shipping divergence.
    
    The Linux kernel can support these initial diverged platforms without
    giving platform-firmware free reign to continue to diverge and compound
    kernel maintenance overhead.  The kernel implementation can encourage
    standardization in two ways:
    
    1/ Require that any function code that userspace wants to send be
       explicitly white-listed in the implementation.  For ACPI this means
       function codes marked as supported by acpi_check_dsm() may
       only be invoked if they appear in the white-list.  A function must be
       publicly documented before it is added to the white-list.
    
    2/ The above restrictions can be trivially bypassed by using the
       "vendor-specific" payload command.  However, since vendor-specific
       commands are by definition not publicly documented and have the
       potential to corrupt the kernel's view of the dimm state, we provide a
       toggle to disable vendor-specific operations.  Enabling undefined
       behavior is a policy decision that can be made by the platform owner
       and encourages firmware implementations to choose public over
       private command implementations.
    
    Based on an initial patch from Jerry Hoemann
    Cc: Jerry Hoemann <jerry.hoemann@hpe.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 7cc28ab05b87..45daa0be5ff9 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -125,6 +125,7 @@ enum {
 	ND_CMD_VENDOR_EFFECT_LOG_SIZE = 7,
 	ND_CMD_VENDOR_EFFECT_LOG = 8,
 	ND_CMD_VENDOR = 9,
+	ND_CMD_CALL = 10,
 };
 
 enum {
@@ -158,6 +159,7 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 		[ND_CMD_VENDOR_EFFECT_LOG_SIZE] = "effect_size",
 		[ND_CMD_VENDOR_EFFECT_LOG] = "effect_log",
 		[ND_CMD_VENDOR] = "vendor",
+		[ND_CMD_CALL] = "cmd_call",
 	};
 
 	if (cmd < ARRAY_SIZE(names) && names[cmd])
@@ -224,4 +226,44 @@ enum ars_masks {
 	ARS_STATUS_MASK = 0x0000FFFF,
 	ARS_EXT_STATUS_SHIFT = 16,
 };
+
+/*
+ * struct nd_cmd_pkg
+ *
+ * is a wrapper to a quasi pass thru interface for invoking firmware
+ * associated with nvdimms.
+ *
+ * INPUT PARAMETERS
+ *
+ * nd_family corresponds to the firmware (e.g. DSM) interface.
+ *
+ * nd_command are the function index advertised by the firmware.
+ *
+ * nd_size_in is the size of the input parameters being passed to firmware
+ *
+ * OUTPUT PARAMETERS
+ *
+ * nd_fw_size is the size of the data firmware wants to return for
+ * the call.  If nd_fw_size is greater than size of nd_size_out, only
+ * the first nd_size_out bytes are returned.
+ */
+
+struct nd_cmd_pkg {
+	__u64   nd_family;		/* family of commands */
+	__u64   nd_command;
+	__u32   nd_size_in;		/* INPUT: size of input args */
+	__u32   nd_size_out;		/* INPUT: size of payload */
+	__u32   nd_reserved2[9];	/* reserved must be zero */
+	__u32   nd_fw_size;		/* OUTPUT: size fw wants to return */
+	unsigned char nd_payload[];	/* Contents of call      */
+};
+
+/* These NVDIMM families represent pre-standardization command sets */
+#define NVDIMM_FAMILY_INTEL 0
+#define NVDIMM_FAMILY_HPE1 1
+#define NVDIMM_FAMILY_HPE2 2
+
+#define ND_IOCTL_CALL			_IOWR(ND_IOCTL, ND_CMD_CALL,\
+					struct nd_cmd_pkg)
+
 #endif /* __NDCTL_H__ */

commit baa51277cf5dc844089ea2f6e0f78b1c5ca665d8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 5 17:40:52 2016 -0700

    libnvdimm, test: add mock SMART data payload
    
    Provide simulated SMART data to enable the ndctl implementation of SMART
    data retrieval and parsing.
    
    The payload is defined here, "Section 4.1 SMART and Health Info
    (Function Index 1)":
    
        http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 7cc28ab05b87..59c61e018a86 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU Lesser General Public License,
@@ -20,11 +20,45 @@ struct nd_cmd_smart {
 	__u8 data[128];
 } __packed;
 
+#define ND_SMART_HEALTH_VALID	(1 << 0)
+#define ND_SMART_TEMP_VALID 	(1 << 1)
+#define ND_SMART_SPARES_VALID	(1 << 2)
+#define ND_SMART_ALARM_VALID	(1 << 3)
+#define ND_SMART_USED_VALID	(1 << 4)
+#define ND_SMART_SHUTDOWN_VALID	(1 << 5)
+#define ND_SMART_VENDOR_VALID	(1 << 6)
+#define ND_SMART_TEMP_TRIP	(1 << 0)
+#define ND_SMART_SPARE_TRIP	(1 << 1)
+#define ND_SMART_NON_CRITICAL_HEALTH	(1 << 0)
+#define ND_SMART_CRITICAL_HEALTH	(1 << 1)
+#define ND_SMART_FATAL_HEALTH		(1 << 2)
+
+struct nd_smart_payload {
+	__u32 flags;
+	__u8 reserved0[4];
+	__u8 health;
+	__u16 temperature;
+	__u8 spares;
+	__u8 alarm_flags;
+	__u8 life_used;
+	__u8 shutdown_state;
+	__u8 reserved1;
+	__u32 vendor_size;
+	__u8 vendor_data[108];
+} __packed;
+
 struct nd_cmd_smart_threshold {
 	__u32 status;
 	__u8 data[8];
 } __packed;
 
+struct nd_smart_threshold_payload {
+	__u16 alarm_control;
+	__u16 temperature;
+	__u8 spares;
+	__u8 reserved[3];
+} __packed;
+
 struct nd_cmd_dimm_flags {
 	__u32 status;
 	__u32 flags;

commit d4f323672aa63713b7ca26da418f66cc30d3a41a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 3 16:08:54 2016 -0800

    nfit, libnvdimm: clear poison command support
    
    Add the boiler-plate for a 'clear error' command based on section
    9.20.7.6 "Function Index 4 - Clear Uncorrectable Error" from the ACPI
    6.1 specification, and add a reference implementation in nfit_test.
    
    Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index cc68b92124d4..7cc28ab05b87 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -98,6 +98,14 @@ struct nd_cmd_ars_status {
 	} __packed records[0];
 } __packed;
 
+struct nd_cmd_clear_error {
+	__u64 address;
+	__u64 length;
+	__u32 status;
+	__u8 reserved[4];
+	__u64 cleared;
+} __packed;
+
 enum {
 	ND_CMD_IMPLEMENTED = 0,
 
@@ -105,6 +113,7 @@ enum {
 	ND_CMD_ARS_CAP = 1,
 	ND_CMD_ARS_START = 2,
 	ND_CMD_ARS_STATUS = 3,
+	ND_CMD_CLEAR_ERROR = 4,
 
 	/* per-dimm commands */
 	ND_CMD_SMART = 1,
@@ -129,6 +138,7 @@ static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
 		[ND_CMD_ARS_CAP] = "ars_cap",
 		[ND_CMD_ARS_START] = "ars_start",
 		[ND_CMD_ARS_STATUS] = "ars_status",
+		[ND_CMD_CLEAR_ERROR] = "clear_error",
 	};
 
 	if (cmd < ARRAY_SIZE(names) && names[cmd])
@@ -187,6 +197,9 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 #define ND_IOCTL_ARS_STATUS		_IOWR(ND_IOCTL, ND_CMD_ARS_STATUS,\
 					struct nd_cmd_ars_status)
 
+#define ND_IOCTL_CLEAR_ERROR		_IOWR(ND_IOCTL, ND_CMD_CLEAR_ERROR,\
+					struct nd_cmd_clear_error)
+
 #define ND_DEVICE_DIMM 1            /* nd_dimm: container for "config data" */
 #define ND_DEVICE_REGION_PMEM 2     /* nd_region: (parent of PMEM namespaces) */
 #define ND_DEVICE_REGION_BLK 3      /* nd_region: (parent of BLK namespaces) */

commit 4577b0665515e0abc7bc72562d6328d179598815
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 17 13:08:58 2016 -0800

    nfit: update address range scrub commands to the acpi 6.1 format
    
    The original format of these commands from the "NVDIMM DSM Interface
    Example" [1] are superseded by the ACPI 6.1 definition of the "NVDIMM Root
    Device _DSMs" [2].
    
    [1]: http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf
    [2]: http://www.uefi.org/sites/default/files/resources/ACPI_6_1.pdf
         "9.20.7 NVDIMM Root Device _DSMs"
    
    Changes include:
    1/ New 'restart' fields in ars_status, unfortunately these are
       implemented in the middle of the existing definition so this change
       is not backwards compatible.  The expectation is that shipping
       platforms will only ever support the ACPI 6.1 definition.
    
    2/ New status values for ars_start ('busy') and ars_status ('overflow').
    
    Cc: Vishal Verma <vishal.l.verma@intel.com>
    Cc: Linda Knippers <linda.knippers@hpe.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 5b4a4be06e2b..cc68b92124d4 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -66,14 +66,18 @@ struct nd_cmd_ars_cap {
 	__u64 length;
 	__u32 status;
 	__u32 max_ars_out;
+	__u32 clear_err_unit;
+	__u32 reserved;
 } __packed;
 
 struct nd_cmd_ars_start {
 	__u64 address;
 	__u64 length;
 	__u16 type;
-	__u8 reserved[6];
+	__u8 flags;
+	__u8 reserved[5];
 	__u32 status;
+	__u32 scrub_time;
 } __packed;
 
 struct nd_cmd_ars_status {
@@ -81,11 +85,14 @@ struct nd_cmd_ars_status {
 	__u32 out_length;
 	__u64 address;
 	__u64 length;
+	__u64 restart_address;
+	__u64 restart_length;
 	__u16 type;
+	__u16 flags;
 	__u32 num_records;
 	struct nd_ars_record {
 		__u32 handle;
-		__u32 flags;
+		__u32 reserved;
 		__u64 err_address;
 		__u64 length;
 	} __packed records[0];

commit 39c686b862cdb2049b90e095b6c6c727b2a7ab60
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Thu Jul 9 13:25:36 2015 -0600

    libnvdimm: Add DSM support for Address Range Scrub commands
    
    Add support for the three ARS DSM commands:
    - Query ARS Capabilities - Queries the firmware to check if a given
      range supports scrub, and if so, which type (persistent vs. volatile)
    - Start ARS - Starts a scrub for a given range/type
    - Query ARS Status - Checks status of a previously started scrub, and
      provides the error logs if any.
    
      The commands are described by the example DSM spec at:
      http://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf
    
    Also add these commands to the nfit_test test framework, and return
    canned data.
    
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index e94bc20016b2..5b4a4be06e2b 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -111,6 +111,11 @@ enum {
 	ND_CMD_VENDOR = 9,
 };
 
+enum {
+	ND_ARS_VOLATILE = 1,
+	ND_ARS_PERSISTENT = 2,
+};
+
 static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
 {
 	static const char * const names[] = {
@@ -194,4 +199,9 @@ enum nd_driver_flags {
 enum {
 	ND_MIN_NAMESPACE_SIZE = 0x00400000,
 };
+
+enum ars_masks {
+	ARS_STATUS_MASK = 0x0000FFFF,
+	ARS_EXT_STATUS_SHIFT = 16,
+};
 #endif /* __NDCTL_H__ */

commit ec92777f2ba93c00387b8fe53780c25adc57c744
Author: Vishal Verma <vishal.l.verma@intel.com>
Date:   Thu Jul 9 13:25:35 2015 -0600

    libnvdimm: Update name of the ars_status_record mask field
    
    The spec suggests that this is a simple 'length' field, not a mask.
    Update the name accordingly.
    
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 2b94ea2287bb..e94bc20016b2 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -87,7 +87,7 @@ struct nd_cmd_ars_status {
 		__u32 handle;
 		__u32 flags;
 		__u64 err_address;
-		__u64 mask;
+		__u64 length;
 	} __packed records[0];
 } __packed;
 

commit bf9bccc14c05dae8caba29df6187c731710f5380
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 17 17:14:46 2015 -0400

    libnvdimm: pmem label sets and namespace instantiation.
    
    A complete label set is a PMEM-label per-dimm per-interleave-set where
    all the UUIDs match and the interleave set cookie matches the hosting
    interleave set.
    
    Present sysfs attributes for manipulation of a PMEM-namespace's
    'alt_name', 'uuid', and 'size' attributes.  A later patch will make
    these settings persistent by writing back the label.
    
    Note that PMEM allocations grow forwards from the start of an interleave
    set (lowest dimm-physical-address (DPA)).  BLK-namespaces that alias
    with a PMEM interleave set will grow allocations backward from the
    highest DPA.
    
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: Neil Brown <neilb@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 1357a87b8714..2b94ea2287bb 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -190,4 +190,8 @@ enum nd_driver_flags {
 	ND_DRIVER_NAMESPACE_PMEM  = 1 << ND_DEVICE_NAMESPACE_PMEM,
 	ND_DRIVER_NAMESPACE_BLK   = 1 << ND_DEVICE_NAMESPACE_BLK,
 };
+
+enum {
+	ND_MIN_NAMESPACE_SIZE = 0x00400000,
+};
 #endif /* __NDCTL_H__ */

commit 4a826c83db4edc040da3a66dbefd53f0cfcf457d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 9 16:09:36 2015 -0400

    libnvdimm: namespace indices: read and validate
    
    This on media label format [1] consists of two index blocks followed by
    an array of labels.  None of these structures are ever updated in place.
    A sequence number tracks the current active index and the next one to
    write, while labels are written to free slots.
    
        +------------+
        |            |
        |  nsindex0  |
        |            |
        +------------+
        |            |
        |  nsindex1  |
        |            |
        +------------+
        |   label0   |
        +------------+
        |   label1   |
        +------------+
        |            |
         ....nslot...
        |            |
        +------------+
        |   labelN   |
        +------------+
    
    After reading valid labels, store the dpa ranges they claim into
    per-dimm resource trees.
    
    [1]: http://pmem.io/documents/NVDIMM_Namespace_Spec.pdf
    
    Cc: Neil Brown <neilb@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 174b6371dcc1..1357a87b8714 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -175,7 +175,6 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 #define ND_IOCTL_ARS_STATUS		_IOWR(ND_IOCTL, ND_CMD_ARS_STATUS,\
 					struct nd_cmd_ars_status)
 
-
 #define ND_DEVICE_DIMM 1            /* nd_dimm: container for "config data" */
 #define ND_DEVICE_REGION_PMEM 2     /* nd_region: (parent of PMEM namespaces) */
 #define ND_DEVICE_REGION_BLK 3      /* nd_region: (parent of BLK namespaces) */

commit 3d88002e4a7bd40f355550284c6cd140e6fe29dc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 31 15:02:11 2015 -0400

    libnvdimm: support for legacy (non-aliasing) nvdimms
    
    The libnvdimm region driver is an intermediary driver that translates
    non-volatile "region"s into "namespace" sub-devices that are surfaced by
    persistent memory block-device drivers (PMEM and BLK).
    
    ACPI 6 introduces the concept that a given nvdimm may simultaneously
    offer multiple access modes to its media through direct PMEM load/store
    access, or windowed BLK mode.  Existing nvdimms mostly implement a PMEM
    interface, some offer a BLK-like mode, but never both as ACPI 6 defines.
    If an nvdimm is single interfaced, then there is no need for dimm
    metadata labels.  For these devices we can take the region boundaries
    directly to create a child namespace device (nd_namespace_io).
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index 37640916d146..174b6371dcc1 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -177,8 +177,18 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 
 
 #define ND_DEVICE_DIMM 1            /* nd_dimm: container for "config data" */
+#define ND_DEVICE_REGION_PMEM 2     /* nd_region: (parent of PMEM namespaces) */
+#define ND_DEVICE_REGION_BLK 3      /* nd_region: (parent of BLK namespaces) */
+#define ND_DEVICE_NAMESPACE_IO 4    /* legacy persistent memory */
+#define ND_DEVICE_NAMESPACE_PMEM 5  /* PMEM namespace (may alias with BLK) */
+#define ND_DEVICE_NAMESPACE_BLK 6   /* BLK namespace (may alias with PMEM) */
 
 enum nd_driver_flags {
 	ND_DRIVER_DIMM            = 1 << ND_DEVICE_DIMM,
+	ND_DRIVER_REGION_PMEM     = 1 << ND_DEVICE_REGION_PMEM,
+	ND_DRIVER_REGION_BLK      = 1 << ND_DEVICE_REGION_BLK,
+	ND_DRIVER_NAMESPACE_IO    = 1 << ND_DEVICE_NAMESPACE_IO,
+	ND_DRIVER_NAMESPACE_PMEM  = 1 << ND_DEVICE_NAMESPACE_PMEM,
+	ND_DRIVER_NAMESPACE_BLK   = 1 << ND_DEVICE_NAMESPACE_BLK,
 };
 #endif /* __NDCTL_H__ */

commit 4d88a97aa9e8cfa6460aab119c5da60ad2267423
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 31 14:41:48 2015 -0400

    libnvdimm, nvdimm: dimm driver and base libnvdimm device-driver infrastructure
    
    * Implement the device-model infrastructure for loading modules and
      attaching drivers to nvdimm devices.  This is a simple association of a
      nd-device-type number with a driver that has a bitmask of supported
      device types.  To facilitate userspace bind/unbind operations 'modalias'
      and 'devtype', that also appear in the uevent, are added as generic
      sysfs attributes for all nvdimm devices.  The reason for the device-type
      number is to support sub-types within a given parent devtype, be it a
      vendor-specific sub-type or otherwise.
    
    * The first consumer of this infrastructure is the driver
      for dimm devices.  It simply uses control messages to retrieve and
      store the configuration-data image (label set) from each dimm.
    
    Note: nd_device_register() arranges for asynchronous registration of
          nvdimm bus devices by default.
    
    Cc: Greg KH <gregkh@linuxfoundation.org>
    Cc: Neil Brown <neilb@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
index ff13c23b26df..37640916d146 100644
--- a/include/uapi/linux/ndctl.h
+++ b/include/uapi/linux/ndctl.h
@@ -175,4 +175,10 @@ static inline const char *nvdimm_cmd_name(unsigned cmd)
 #define ND_IOCTL_ARS_STATUS		_IOWR(ND_IOCTL, ND_CMD_ARS_STATUS,\
 					struct nd_cmd_ars_status)
 
+
+#define ND_DEVICE_DIMM 1            /* nd_dimm: container for "config data" */
+
+enum nd_driver_flags {
+	ND_DRIVER_DIMM            = 1 << ND_DEVICE_DIMM,
+};
 #endif /* __NDCTL_H__ */

commit 62232e45f4a265abb43f0acf16e58f5d0b6e1ec9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 8 14:27:06 2015 -0400

    libnvdimm: control (ioctl) messages for nvdimm_bus and nvdimm devices
    
    Most discovery/configuration of the nvdimm-subsystem is done via sysfs
    attributes.  However, some nvdimm_bus instances, particularly the
    ACPI.NFIT bus, define a small set of messages that can be passed to the
    platform.  For convenience we derive the initial libnvdimm-ioctl command
    formats directly from the NFIT DSM Interface Example formats.
    
        ND_CMD_SMART: media health and diagnostics
        ND_CMD_GET_CONFIG_SIZE: size of the label space
        ND_CMD_GET_CONFIG_DATA: read label space
        ND_CMD_SET_CONFIG_DATA: write label space
        ND_CMD_VENDOR: vendor-specific command passthrough
        ND_CMD_ARS_CAP: report address-range-scrubbing capabilities
        ND_CMD_ARS_START: initiate scrubbing
        ND_CMD_ARS_STATUS: report on scrubbing state
        ND_CMD_SMART_THRESHOLD: configure alarm thresholds for smart events
    
    If a platform later defines different commands than this set it is
    straightforward to extend support to those formats.
    
    Most of the commands target a specific dimm.  However, the
    address-range-scrubbing commands target the bus.  The 'commands'
    attribute in sysfs of an nvdimm_bus, or nvdimm, enumerate the supported
    commands for that object.
    
    Cc: <linux-acpi@vger.kernel.org>
    Cc: Robert Moore <robert.moore@intel.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reported-by: Nicholas Moulin <nicholas.w.moulin@linux.intel.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/uapi/linux/ndctl.h b/include/uapi/linux/ndctl.h
new file mode 100644
index 000000000000..ff13c23b26df
--- /dev/null
+++ b/include/uapi/linux/ndctl.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU Lesser General Public License,
+ * version 2.1, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
+ * more details.
+ */
+#ifndef __NDCTL_H__
+#define __NDCTL_H__
+
+#include <linux/types.h>
+
+struct nd_cmd_smart {
+	__u32 status;
+	__u8 data[128];
+} __packed;
+
+struct nd_cmd_smart_threshold {
+	__u32 status;
+	__u8 data[8];
+} __packed;
+
+struct nd_cmd_dimm_flags {
+	__u32 status;
+	__u32 flags;
+} __packed;
+
+struct nd_cmd_get_config_size {
+	__u32 status;
+	__u32 config_size;
+	__u32 max_xfer;
+} __packed;
+
+struct nd_cmd_get_config_data_hdr {
+	__u32 in_offset;
+	__u32 in_length;
+	__u32 status;
+	__u8 out_buf[0];
+} __packed;
+
+struct nd_cmd_set_config_hdr {
+	__u32 in_offset;
+	__u32 in_length;
+	__u8 in_buf[0];
+} __packed;
+
+struct nd_cmd_vendor_hdr {
+	__u32 opcode;
+	__u32 in_length;
+	__u8 in_buf[0];
+} __packed;
+
+struct nd_cmd_vendor_tail {
+	__u32 status;
+	__u32 out_length;
+	__u8 out_buf[0];
+} __packed;
+
+struct nd_cmd_ars_cap {
+	__u64 address;
+	__u64 length;
+	__u32 status;
+	__u32 max_ars_out;
+} __packed;
+
+struct nd_cmd_ars_start {
+	__u64 address;
+	__u64 length;
+	__u16 type;
+	__u8 reserved[6];
+	__u32 status;
+} __packed;
+
+struct nd_cmd_ars_status {
+	__u32 status;
+	__u32 out_length;
+	__u64 address;
+	__u64 length;
+	__u16 type;
+	__u32 num_records;
+	struct nd_ars_record {
+		__u32 handle;
+		__u32 flags;
+		__u64 err_address;
+		__u64 mask;
+	} __packed records[0];
+} __packed;
+
+enum {
+	ND_CMD_IMPLEMENTED = 0,
+
+	/* bus commands */
+	ND_CMD_ARS_CAP = 1,
+	ND_CMD_ARS_START = 2,
+	ND_CMD_ARS_STATUS = 3,
+
+	/* per-dimm commands */
+	ND_CMD_SMART = 1,
+	ND_CMD_SMART_THRESHOLD = 2,
+	ND_CMD_DIMM_FLAGS = 3,
+	ND_CMD_GET_CONFIG_SIZE = 4,
+	ND_CMD_GET_CONFIG_DATA = 5,
+	ND_CMD_SET_CONFIG_DATA = 6,
+	ND_CMD_VENDOR_EFFECT_LOG_SIZE = 7,
+	ND_CMD_VENDOR_EFFECT_LOG = 8,
+	ND_CMD_VENDOR = 9,
+};
+
+static inline const char *nvdimm_bus_cmd_name(unsigned cmd)
+{
+	static const char * const names[] = {
+		[ND_CMD_ARS_CAP] = "ars_cap",
+		[ND_CMD_ARS_START] = "ars_start",
+		[ND_CMD_ARS_STATUS] = "ars_status",
+	};
+
+	if (cmd < ARRAY_SIZE(names) && names[cmd])
+		return names[cmd];
+	return "unknown";
+}
+
+static inline const char *nvdimm_cmd_name(unsigned cmd)
+{
+	static const char * const names[] = {
+		[ND_CMD_SMART] = "smart",
+		[ND_CMD_SMART_THRESHOLD] = "smart_thresh",
+		[ND_CMD_DIMM_FLAGS] = "flags",
+		[ND_CMD_GET_CONFIG_SIZE] = "get_size",
+		[ND_CMD_GET_CONFIG_DATA] = "get_data",
+		[ND_CMD_SET_CONFIG_DATA] = "set_data",
+		[ND_CMD_VENDOR_EFFECT_LOG_SIZE] = "effect_size",
+		[ND_CMD_VENDOR_EFFECT_LOG] = "effect_log",
+		[ND_CMD_VENDOR] = "vendor",
+	};
+
+	if (cmd < ARRAY_SIZE(names) && names[cmd])
+		return names[cmd];
+	return "unknown";
+}
+
+#define ND_IOCTL 'N'
+
+#define ND_IOCTL_SMART			_IOWR(ND_IOCTL, ND_CMD_SMART,\
+					struct nd_cmd_smart)
+
+#define ND_IOCTL_SMART_THRESHOLD	_IOWR(ND_IOCTL, ND_CMD_SMART_THRESHOLD,\
+					struct nd_cmd_smart_threshold)
+
+#define ND_IOCTL_DIMM_FLAGS		_IOWR(ND_IOCTL, ND_CMD_DIMM_FLAGS,\
+					struct nd_cmd_dimm_flags)
+
+#define ND_IOCTL_GET_CONFIG_SIZE	_IOWR(ND_IOCTL, ND_CMD_GET_CONFIG_SIZE,\
+					struct nd_cmd_get_config_size)
+
+#define ND_IOCTL_GET_CONFIG_DATA	_IOWR(ND_IOCTL, ND_CMD_GET_CONFIG_DATA,\
+					struct nd_cmd_get_config_data_hdr)
+
+#define ND_IOCTL_SET_CONFIG_DATA	_IOWR(ND_IOCTL, ND_CMD_SET_CONFIG_DATA,\
+					struct nd_cmd_set_config_hdr)
+
+#define ND_IOCTL_VENDOR			_IOWR(ND_IOCTL, ND_CMD_VENDOR,\
+					struct nd_cmd_vendor_hdr)
+
+#define ND_IOCTL_ARS_CAP		_IOWR(ND_IOCTL, ND_CMD_ARS_CAP,\
+					struct nd_cmd_ars_cap)
+
+#define ND_IOCTL_ARS_START		_IOWR(ND_IOCTL, ND_CMD_ARS_START,\
+					struct nd_cmd_ars_start)
+
+#define ND_IOCTL_ARS_STATUS		_IOWR(ND_IOCTL, ND_CMD_ARS_STATUS,\
+					struct nd_cmd_ars_status)
+
+#endif /* __NDCTL_H__ */
