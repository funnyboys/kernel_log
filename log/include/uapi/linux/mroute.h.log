commit ca8d4794f669e721fb5198f6d142e42dd8080239
Author: Callum Sinclair <callum.sinclair@alliedtelesis.co.nz>
Date:   Mon Feb 18 10:07:52 2019 +1300

    ipmr: ip6mr: Create new sockopt to clear mfc cache or vifs
    
    Currently the only way to clear the forwarding cache was to delete the
    entries one by one using the MRT_DEL_MFC socket option or to destroy and
    recreate the socket.
    
    Create a new socket option which with the use of optional flags can
    clear any combination of multicast entries (static or not static) and
    multicast vifs (static or not static).
    
    Calling the new socket option MRT_FLUSH with the flags MRT_FLUSH_MFC and
    MRT_FLUSH_VIFS will clear all entries and vifs on the socket except for
    static entries.
    
    Signed-off-by: Callum Sinclair <callum.sinclair@alliedtelesis.co.nz>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index 5d37a9ccce63..11c8c1fc1124 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -28,12 +28,19 @@
 #define MRT_TABLE	(MRT_BASE+9)	/* Specify mroute table ID		*/
 #define MRT_ADD_MFC_PROXY	(MRT_BASE+10)	/* Add a (*,*|G) mfc entry	*/
 #define MRT_DEL_MFC_PROXY	(MRT_BASE+11)	/* Del a (*,*|G) mfc entry	*/
-#define MRT_MAX		(MRT_BASE+11)
+#define MRT_FLUSH	(MRT_BASE+12)	/* Flush all mfc entries and/or vifs	*/
+#define MRT_MAX		(MRT_BASE+12)
 
 #define SIOCGETVIFCNT	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)
 #define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
 
+/* MRT_FLUSH optional flags */
+#define MRT_FLUSH_MFC	1	/* Flush multicast entries */
+#define MRT_FLUSH_MFC_STATIC	2	/* Flush static multicast entries */
+#define MRT_FLUSH_VIFS	4	/* Flush multicast vifs */
+#define MRT_FLUSH_VIFS_STATIC	8	/* Flush static multicast vifs */
+
 #define MAXVIFS		32
 typedef unsigned long vifbitmap_t;	/* User mode code depends on this lot */
 typedef unsigned short vifi_t;

commit c921c2077b32081617789a645120148bc8b60c98
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Jul 13 12:16:43 2018 +0300

    net: ipmr: add support for passing full packet on wrong vif
    
    This patch adds support for IGMPMSG_WRVIFWHOLE which is used to pass
    full packet and real vif id when the incoming interface is wrong.
    While the RP and FHR are setting up state we need to be sending the
    registers encapsulated with all the data inside otherwise we lose it.
    The RP then decapsulates it and forwards it to the interested parties.
    Currently with WRONGVIF we can only be sending empty register packets
    and will lose that data.
    This behaviour can be enabled by using MRT_PIM with
    val == IGMPMSG_WRVIFWHOLE. This doesn't prevent IGMPMSG_WRONGVIF from
    happening, it happens in addition to it, also it is controlled by the same
    throttling parameters as WRONGVIF (i.e. 1 packet per 3 seconds currently).
    Both messages are generated to keep backwards compatibily and avoid
    breaking someone who was enabling MRT_PIM with val == 4, since any
    positive val is accepted and treated the same.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index 10f9ff9426a2..5d37a9ccce63 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -120,6 +120,7 @@ enum {
 	IPMRA_TABLE_MROUTE_DO_ASSERT,
 	IPMRA_TABLE_MROUTE_DO_PIM,
 	IPMRA_TABLE_VIFS,
+	IPMRA_TABLE_MROUTE_DO_WRVIFWHOLE,
 	__IPMRA_TABLE_MAX
 };
 #define IPMRA_TABLE_MAX (__IPMRA_TABLE_MAX - 1)
@@ -173,5 +174,6 @@ enum {
 #define IGMPMSG_NOCACHE		1		/* Kern cache fill request to mrouted */
 #define IGMPMSG_WRONGVIF	2		/* For PIM assert processing (unused) */
 #define IGMPMSG_WHOLEPKT	3		/* For PIM Register processing */
+#define IGMPMSG_WRVIFWHOLE	4		/* For PIM Register and assert processing */
 
 #endif /* _UAPI__LINUX_MROUTE_H */

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index e8e5041dea8e..10f9ff9426a2 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI__LINUX_MROUTE_H
 #define _UAPI__LINUX_MROUTE_H
 

commit 5a645dd86c1be64728578bcb1bdfb96e21815acb
Author: Julien Gomes <julien@arista.com>
Date:   Tue Jun 20 13:54:17 2017 -0700

    ipmr: add netlink notifications on igmpmsg cache reports
    
    Add Netlink notifications on cache reports in ipmr, in addition to the
    existing igmpmsg sent to mroute_sk.
    Send RTM_NEWCACHEREPORT notifications to RTNLGRP_IPV4_MROUTE_R.
    
    MSGTYPE, VIF_ID, SRC_ADDR and DST_ADDR Netlink attributes contain the
    same data as their equivalent fields in the igmpmsg header.
    PKT attribute is the packet sent to mroute_sk, without the added igmpmsg
    header.
    
    Suggested-by: Ryan Halbrook <halbrook@arista.com>
    Signed-off-by: Julien Gomes <julien@arista.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index f904367c0cee..e8e5041dea8e 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -152,6 +152,18 @@ enum {
 };
 #define IPMRA_VIFA_MAX (__IPMRA_VIFA_MAX - 1)
 
+/* ipmr netlink cache report attributes */
+enum {
+	IPMRA_CREPORT_UNSPEC,
+	IPMRA_CREPORT_MSGTYPE,
+	IPMRA_CREPORT_VIF_ID,
+	IPMRA_CREPORT_SRC_ADDR,
+	IPMRA_CREPORT_DST_ADDR,
+	IPMRA_CREPORT_PKT,
+	__IPMRA_CREPORT_MAX
+};
+#define IPMRA_CREPORT_MAX (__IPMRA_CREPORT_MAX - 1)
+
 /* That's all usermode folks */
 
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */

commit 772c344dbb23b2ce4568ac30afae92a842fa6d8f
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Jun 7 18:02:32 2017 +0300

    net: ipmr: add getlink support
    
    Currently there's no way to dump the VIF table for an ipmr table other
    than the default (via proc). This is a major issue when debugging ipmr
    issues and in general it is good to know which interfaces are
    configured. This patch adds support for RTM_GETLINK for the ipmr family
    so we can dump the VIF table and the ipmr table's current config for
    each table. We're protected by rtnl so no need to acquire RCU or
    mrt_lock.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index 1fe4c1e7d66e..f904367c0cee 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -110,6 +110,48 @@ struct igmpmsg {
 	struct in_addr im_src,im_dst;
 };
 
+/* ipmr netlink table attributes */
+enum {
+	IPMRA_TABLE_UNSPEC,
+	IPMRA_TABLE_ID,
+	IPMRA_TABLE_CACHE_RES_QUEUE_LEN,
+	IPMRA_TABLE_MROUTE_REG_VIF_NUM,
+	IPMRA_TABLE_MROUTE_DO_ASSERT,
+	IPMRA_TABLE_MROUTE_DO_PIM,
+	IPMRA_TABLE_VIFS,
+	__IPMRA_TABLE_MAX
+};
+#define IPMRA_TABLE_MAX (__IPMRA_TABLE_MAX - 1)
+
+/* ipmr netlink vif attribute format
+ * [ IPMRA_TABLE_VIFS ] - nested attribute
+ *   [ IPMRA_VIF ] - nested attribute
+ *     [ IPMRA_VIFA_xxx ]
+ */
+enum {
+	IPMRA_VIF_UNSPEC,
+	IPMRA_VIF,
+	__IPMRA_VIF_MAX
+};
+#define IPMRA_VIF_MAX (__IPMRA_VIF_MAX - 1)
+
+/* vif-specific attributes */
+enum {
+	IPMRA_VIFA_UNSPEC,
+	IPMRA_VIFA_IFINDEX,
+	IPMRA_VIFA_VIF_ID,
+	IPMRA_VIFA_FLAGS,
+	IPMRA_VIFA_BYTES_IN,
+	IPMRA_VIFA_BYTES_OUT,
+	IPMRA_VIFA_PACKETS_IN,
+	IPMRA_VIFA_PACKETS_OUT,
+	IPMRA_VIFA_LOCAL_ADDR,
+	IPMRA_VIFA_REMOTE_ADDR,
+	IPMRA_VIFA_PAD,
+	__IPMRA_VIFA_MAX
+};
+#define IPMRA_VIFA_MAX (__IPMRA_VIFA_MAX - 1)
+
 /* That's all usermode folks */
 
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */

commit bcb41c6bced1ee778d23c53a6b4807fb08cf5540
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Thu Feb 16 18:04:46 2017 +0300

    uapi: fix linux/mroute.h userspace compilation errors
    
    Include <linux/in.h> to fix the following linux/mroute.h userspace
    compilation errors:
    
    /usr/include/linux/mroute.h:58:18: error: field 'vifc_lcl_addr' has incomplete type
      struct in_addr vifc_lcl_addr;     /* Local interface address */
    /usr/include/linux/mroute.h:61:17: error: field 'vifc_rmt_addr' has incomplete type
      struct in_addr vifc_rmt_addr; /* IPIP tunnel addr */
    /usr/include/linux/mroute.h:72:17: error: field 'mfcc_origin' has incomplete type
      struct in_addr mfcc_origin;  /* Origin of mcast */
    /usr/include/linux/mroute.h:73:17: error: field 'mfcc_mcastgrp' has incomplete type
      struct in_addr mfcc_mcastgrp;  /* Group in question */
    /usr/include/linux/mroute.h:84:17: error: field 'src' has incomplete type
      struct in_addr src;
    /usr/include/linux/mroute.h:85:17: error: field 'grp' has incomplete type
      struct in_addr grp;
    /usr/include/linux/mroute.h:109:17: error: field 'im_src' has incomplete type
      struct in_addr im_src,im_dst;
    /usr/include/linux/mroute.h:109:24: error: field 'im_dst' has incomplete type
      struct in_addr im_src,im_dst;
    
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index cf943016930f..1fe4c1e7d66e 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -3,6 +3,7 @@
 
 #include <linux/sockios.h>
 #include <linux/types.h>
+#include <linux/in.h>		/* For struct in_addr. */
 
 /* Based on the MROUTING 3.5 defines primarily to keep
  * source compatibility with BSD.

commit 7ef8f65df976369588fa1b6466668b1b6a26eb3c
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Nov 21 15:57:27 2015 +0100

    net: ipmr: fix code and comment style
    
    Trivial code and comment style fixes, also removed some extra newlines,
    spaces and tabs.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index a382d2c04a42..cf943016930f 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -4,15 +4,13 @@
 #include <linux/sockios.h>
 #include <linux/types.h>
 
-/*
- *	Based on the MROUTING 3.5 defines primarily to keep
- *	source compatibility with BSD.
+/* Based on the MROUTING 3.5 defines primarily to keep
+ * source compatibility with BSD.
  *
- *	See the mrouted code for the original history.
- *
- *      Protocol Independent Multicast (PIM) data structures included
- *      Carlos Picoto (cap@di.fc.ul.pt)
+ * See the mrouted code for the original history.
  *
+ * Protocol Independent Multicast (PIM) data structures included
+ * Carlos Picoto (cap@di.fc.ul.pt)
  */
 
 #define MRT_BASE	200
@@ -34,15 +32,13 @@
 #define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)
 #define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
 
-#define MAXVIFS		32	
+#define MAXVIFS		32
 typedef unsigned long vifbitmap_t;	/* User mode code depends on this lot */
 typedef unsigned short vifi_t;
 #define ALL_VIFS	((vifi_t)(-1))
 
-/*
- *	Same idea as select
- */
- 
+/* Same idea as select */
+
 #define VIFM_SET(n,m)	((m)|=(1<<(n)))
 #define VIFM_CLR(n,m)	((m)&=~(1<<(n)))
 #define VIFM_ISSET(n,m)	((m)&(1<<(n)))
@@ -50,11 +46,9 @@ typedef unsigned short vifi_t;
 #define VIFM_COPY(mfrom,mto)	((mto)=(mfrom))
 #define VIFM_SAME(m1,m2)	((m1)==(m2))
 
-/*
- *	Passed by mrouted for an MRT_ADD_VIF - again we use the
- *	mrouted 3.6 structures for compatibility
+/* Passed by mrouted for an MRT_ADD_VIF - again we use the
+ * mrouted 3.6 structures for compatibility
  */
- 
 struct vifctl {
 	vifi_t	vifc_vifi;		/* Index of VIF */
 	unsigned char vifc_flags;	/* VIFF_ flags */
@@ -73,10 +67,7 @@ struct vifctl {
 #define VIFF_USE_IFINDEX	0x8	/* use vifc_lcl_ifindex instead of
 					   vifc_lcl_addr to find an interface */
 
-/*
- *	Cache manipulation structures for mrouted and PIMd
- */
- 
+/* Cache manipulation structures for mrouted and PIMd */
 struct mfcctl {
 	struct in_addr mfcc_origin;		/* Origin of mcast	*/
 	struct in_addr mfcc_mcastgrp;		/* Group in question	*/
@@ -88,10 +79,7 @@ struct mfcctl {
 	int	     mfcc_expire;
 };
 
-/* 
- *	Group count retrieval for mrouted
- */
- 
+/*  Group count retrieval for mrouted */
 struct sioc_sg_req {
 	struct in_addr src;
 	struct in_addr grp;
@@ -100,10 +88,7 @@ struct sioc_sg_req {
 	unsigned long wrong_if;
 };
 
-/*
- *	To get vif packet counts
- */
-
+/* To get vif packet counts */
 struct sioc_vif_req {
 	vifi_t	vifi;		/* Which iface */
 	unsigned long icount;	/* In packets */
@@ -112,11 +97,9 @@ struct sioc_vif_req {
 	unsigned long obytes;	/* Out bytes */
 };
 
-/*
- *	This is the format the mroute daemon expects to see IGMP control
- *	data. Magically happens to be like an IP packet as per the original
+/* This is the format the mroute daemon expects to see IGMP control
+ * data. Magically happens to be like an IP packet as per the original
  */
- 
 struct igmpmsg {
 	__u32 unused1,unused2;
 	unsigned char im_msgtype;		/* What is this */
@@ -126,21 +109,13 @@ struct igmpmsg {
 	struct in_addr im_src,im_dst;
 };
 
-/*
- *	That's all usermode folks
- */
-
-
+/* That's all usermode folks */
 
 #define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
 
-/*
- *	Pseudo messages used by mrouted
- */
-
+/* Pseudo messages used by mrouted */
 #define IGMPMSG_NOCACHE		1		/* Kern cache fill request to mrouted */
 #define IGMPMSG_WRONGVIF	2		/* For PIM assert processing (unused) */
 #define IGMPMSG_WHOLEPKT	3		/* For PIM Register processing */
 
-
 #endif /* _UAPI__LINUX_MROUTE_H */

commit 660b26dc1a8aeb33c2a2246ebf1b3684449a74b7
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Mon Jan 21 06:00:26 2013 +0000

    mcast: add multicast proxy support (IPv4 and IPv6)
    
    This patch add the support of proxy multicast, ie being able to build a static
    multicast tree. It adds the support of (*,*) and (*,G) entries.
    
    The user should define an (*,*) entry which is not used for real forwarding.
    This entry defines the upstream in iif and contains all interfaces from the
    static tree in its oifs. It will be used to forward packet upstream when they
    come from an interface belonging to the static tree.
    Hence, the user should define (*,G) entries to build its static tree. Note that
    upstream interface must be part of oifs: packets are sent to all oifs
    interfaces except the input interface. This ensures to always join the whole
    static tree, even if the packet is not coming from the upstream interface.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index 1c11004af5db..a382d2c04a42 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -26,7 +26,9 @@
 #define MRT_ASSERT	(MRT_BASE+7)	/* Activate PIM assert mode		*/
 #define MRT_PIM		(MRT_BASE+8)	/* enable PIM code			*/
 #define MRT_TABLE	(MRT_BASE+9)	/* Specify mroute table ID		*/
-#define MRT_MAX		(MRT_BASE+9)
+#define MRT_ADD_MFC_PROXY	(MRT_BASE+10)	/* Add a (*,*|G) mfc entry	*/
+#define MRT_DEL_MFC_PROXY	(MRT_BASE+11)	/* Del a (*,*|G) mfc entry	*/
+#define MRT_MAX		(MRT_BASE+11)
 
 #define SIOCGETVIFCNT	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)

commit bbb923a4c2d17ebd5ec34755fe19a33914cbd86f
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Mon Jan 21 06:00:25 2013 +0000

    mcast: define and use MRT[6]_MAX in ip[6]_mroute_opt()
    
    This will ease further addition of new MRT[6]_* values and avoid to update
    in6.h each time.
    Note that we reduce the maximum value from 210 to 209, but 210 does not match
    any known value in ip[6]_mroute_setsockopt().
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: David L Stevens <dlstevens@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
index 16929993acc4..1c11004af5db 100644
--- a/include/uapi/linux/mroute.h
+++ b/include/uapi/linux/mroute.h
@@ -26,6 +26,7 @@
 #define MRT_ASSERT	(MRT_BASE+7)	/* Activate PIM assert mode		*/
 #define MRT_PIM		(MRT_BASE+8)	/* enable PIM code			*/
 #define MRT_TABLE	(MRT_BASE+9)	/* Specify mroute table ID		*/
+#define MRT_MAX		(MRT_BASE+9)
 
 #define SIOCGETVIFCNT	SIOCPROTOPRIVATE	/* IP protocol privates */
 #define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/mroute.h b/include/uapi/linux/mroute.h
new file mode 100644
index 000000000000..16929993acc4
--- /dev/null
+++ b/include/uapi/linux/mroute.h
@@ -0,0 +1,143 @@
+#ifndef _UAPI__LINUX_MROUTE_H
+#define _UAPI__LINUX_MROUTE_H
+
+#include <linux/sockios.h>
+#include <linux/types.h>
+
+/*
+ *	Based on the MROUTING 3.5 defines primarily to keep
+ *	source compatibility with BSD.
+ *
+ *	See the mrouted code for the original history.
+ *
+ *      Protocol Independent Multicast (PIM) data structures included
+ *      Carlos Picoto (cap@di.fc.ul.pt)
+ *
+ */
+
+#define MRT_BASE	200
+#define MRT_INIT	(MRT_BASE)	/* Activate the kernel mroute code 	*/
+#define MRT_DONE	(MRT_BASE+1)	/* Shutdown the kernel mroute		*/
+#define MRT_ADD_VIF	(MRT_BASE+2)	/* Add a virtual interface		*/
+#define MRT_DEL_VIF	(MRT_BASE+3)	/* Delete a virtual interface		*/
+#define MRT_ADD_MFC	(MRT_BASE+4)	/* Add a multicast forwarding entry	*/
+#define MRT_DEL_MFC	(MRT_BASE+5)	/* Delete a multicast forwarding entry	*/
+#define MRT_VERSION	(MRT_BASE+6)	/* Get the kernel multicast version	*/
+#define MRT_ASSERT	(MRT_BASE+7)	/* Activate PIM assert mode		*/
+#define MRT_PIM		(MRT_BASE+8)	/* enable PIM code			*/
+#define MRT_TABLE	(MRT_BASE+9)	/* Specify mroute table ID		*/
+
+#define SIOCGETVIFCNT	SIOCPROTOPRIVATE	/* IP protocol privates */
+#define SIOCGETSGCNT	(SIOCPROTOPRIVATE+1)
+#define SIOCGETRPF	(SIOCPROTOPRIVATE+2)
+
+#define MAXVIFS		32	
+typedef unsigned long vifbitmap_t;	/* User mode code depends on this lot */
+typedef unsigned short vifi_t;
+#define ALL_VIFS	((vifi_t)(-1))
+
+/*
+ *	Same idea as select
+ */
+ 
+#define VIFM_SET(n,m)	((m)|=(1<<(n)))
+#define VIFM_CLR(n,m)	((m)&=~(1<<(n)))
+#define VIFM_ISSET(n,m)	((m)&(1<<(n)))
+#define VIFM_CLRALL(m)	((m)=0)
+#define VIFM_COPY(mfrom,mto)	((mto)=(mfrom))
+#define VIFM_SAME(m1,m2)	((m1)==(m2))
+
+/*
+ *	Passed by mrouted for an MRT_ADD_VIF - again we use the
+ *	mrouted 3.6 structures for compatibility
+ */
+ 
+struct vifctl {
+	vifi_t	vifc_vifi;		/* Index of VIF */
+	unsigned char vifc_flags;	/* VIFF_ flags */
+	unsigned char vifc_threshold;	/* ttl limit */
+	unsigned int vifc_rate_limit;	/* Rate limiter values (NI) */
+	union {
+		struct in_addr vifc_lcl_addr;     /* Local interface address */
+		int            vifc_lcl_ifindex;  /* Local interface index   */
+	};
+	struct in_addr vifc_rmt_addr;	/* IPIP tunnel addr */
+};
+
+#define VIFF_TUNNEL		0x1	/* IPIP tunnel */
+#define VIFF_SRCRT		0x2	/* NI */
+#define VIFF_REGISTER		0x4	/* register vif	*/
+#define VIFF_USE_IFINDEX	0x8	/* use vifc_lcl_ifindex instead of
+					   vifc_lcl_addr to find an interface */
+
+/*
+ *	Cache manipulation structures for mrouted and PIMd
+ */
+ 
+struct mfcctl {
+	struct in_addr mfcc_origin;		/* Origin of mcast	*/
+	struct in_addr mfcc_mcastgrp;		/* Group in question	*/
+	vifi_t	mfcc_parent;			/* Where it arrived	*/
+	unsigned char mfcc_ttls[MAXVIFS];	/* Where it is going	*/
+	unsigned int mfcc_pkt_cnt;		/* pkt count for src-grp */
+	unsigned int mfcc_byte_cnt;
+	unsigned int mfcc_wrong_if;
+	int	     mfcc_expire;
+};
+
+/* 
+ *	Group count retrieval for mrouted
+ */
+ 
+struct sioc_sg_req {
+	struct in_addr src;
+	struct in_addr grp;
+	unsigned long pktcnt;
+	unsigned long bytecnt;
+	unsigned long wrong_if;
+};
+
+/*
+ *	To get vif packet counts
+ */
+
+struct sioc_vif_req {
+	vifi_t	vifi;		/* Which iface */
+	unsigned long icount;	/* In packets */
+	unsigned long ocount;	/* Out packets */
+	unsigned long ibytes;	/* In bytes */
+	unsigned long obytes;	/* Out bytes */
+};
+
+/*
+ *	This is the format the mroute daemon expects to see IGMP control
+ *	data. Magically happens to be like an IP packet as per the original
+ */
+ 
+struct igmpmsg {
+	__u32 unused1,unused2;
+	unsigned char im_msgtype;		/* What is this */
+	unsigned char im_mbz;			/* Must be zero */
+	unsigned char im_vif;			/* Interface (this ought to be a vifi_t!) */
+	unsigned char unused3;
+	struct in_addr im_src,im_dst;
+};
+
+/*
+ *	That's all usermode folks
+ */
+
+
+
+#define MFC_ASSERT_THRESH (3*HZ)		/* Maximal freq. of asserts */
+
+/*
+ *	Pseudo messages used by mrouted
+ */
+
+#define IGMPMSG_NOCACHE		1		/* Kern cache fill request to mrouted */
+#define IGMPMSG_WRONGVIF	2		/* For PIM assert processing (unused) */
+#define IGMPMSG_WHOLEPKT	3		/* For PIM Register processing */
+
+
+#endif /* _UAPI__LINUX_MROUTE_H */
