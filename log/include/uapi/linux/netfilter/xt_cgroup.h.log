commit 0d704967f4a49cc2212350b3e4a8231f8b4283ed
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue Sep 4 12:07:55 2018 +0200

    netfilter: xt_cgroup: shrink size of v2 path
    
    cgroup v2 path field is PATH_MAX which is too large, this is placing too
    much pressure on memory allocation for people with many rules doing
    cgroup v1 classid matching, side effects of this are bug reports like:
    
    https://bugzilla.kernel.org/show_bug.cgi?id=200639
    
    This patch registers a new revision that shrinks the cgroup path to 512
    bytes, which is the same approach we follow in similar extensions that
    have a path field.
    
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Acked-by: Tejun Heo <tj@kernel.org>

diff --git a/include/uapi/linux/netfilter/xt_cgroup.h b/include/uapi/linux/netfilter/xt_cgroup.h
index e96dfa1b34f7..b74e370d6133 100644
--- a/include/uapi/linux/netfilter/xt_cgroup.h
+++ b/include/uapi/linux/netfilter/xt_cgroup.h
@@ -22,4 +22,20 @@ struct xt_cgroup_info_v1 {
 	void		*priv __attribute__((aligned(8)));
 };
 
+#define XT_CGROUP_PATH_MAX	512
+
+struct xt_cgroup_info_v2 {
+	__u8		has_path;
+	__u8		has_classid;
+	__u8		invert_path;
+	__u8		invert_classid;
+	union {
+		char	path[XT_CGROUP_PATH_MAX];
+		__u32	classid;
+	};
+
+	/* kernel internal data */
+	void		*priv __attribute__((aligned(8)));
+};
+
 #endif /* _UAPI_XT_CGROUP_H */

commit 6f52b16c5b29b89d92c0e7236f4655dc8491ad70
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:08:43 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with no license
    
    Many user space API headers are missing licensing information, which
    makes it hard for compliance tools to determine the correct license.
    
    By default are files without license information under the default
    license of the kernel, which is GPLV2.  Marking them GPLV2 would exclude
    them from being included in non GPLV2 code, which is obviously not
    intended. The user space API headers fall under the syscall exception
    which is in the kernels COPYING file:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    otherwise syscall usage would not be possible.
    
    Update the files which contain no license information with an SPDX
    license identifier.  The chosen identifier is 'GPL-2.0 WITH
    Linux-syscall-note' which is the officially assigned identifier for the
    Linux syscall exception.  SPDX license identifiers are a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/netfilter/xt_cgroup.h b/include/uapi/linux/netfilter/xt_cgroup.h
index 1e4b37b93bef..e96dfa1b34f7 100644
--- a/include/uapi/linux/netfilter/xt_cgroup.h
+++ b/include/uapi/linux/netfilter/xt_cgroup.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 #ifndef _UAPI_XT_CGROUP_H
 #define _UAPI_XT_CGROUP_H
 

commit c38c4597e4bf3e99860eac98211748e1ecb0e139
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Dec 7 17:38:55 2015 -0500

    netfilter: implement xt_cgroup cgroup2 path match
    
    This patch implements xt_cgroup path match which matches cgroup2
    membership of the associated socket.  The match is recursive and
    invertible.
    
    For rationales on introducing another cgroup based match, please refer
    to a preceding commit "sock, cgroup: add sock->sk_cgroup".
    
    v3: Folded into xt_cgroup as a new revision interface as suggested by
        Pablo.
    
    v2: Included linux/limits.h from xt_cgroup2.h for PATH_MAX.  Added
        explicit alignment to the priv field.  Both suggested by Jan.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Daniel Wagner <daniel.wagner@bmw-carit.de>
    CC: Neil Horman <nhorman@tuxdriver.com>
    Cc: Jan Engelhardt <jengelh@inai.de>
    Cc: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/uapi/linux/netfilter/xt_cgroup.h b/include/uapi/linux/netfilter/xt_cgroup.h
index 577c9e0b9406..1e4b37b93bef 100644
--- a/include/uapi/linux/netfilter/xt_cgroup.h
+++ b/include/uapi/linux/netfilter/xt_cgroup.h
@@ -2,10 +2,23 @@
 #define _UAPI_XT_CGROUP_H
 
 #include <linux/types.h>
+#include <linux/limits.h>
 
 struct xt_cgroup_info_v0 {
 	__u32 id;
 	__u32 invert;
 };
 
+struct xt_cgroup_info_v1 {
+	__u8		has_path;
+	__u8		has_classid;
+	__u8		invert_path;
+	__u8		invert_classid;
+	char		path[PATH_MAX];
+	__u32		classid;
+
+	/* kernel internal data */
+	void		*priv __attribute__((aligned(8)));
+};
+
 #endif /* _UAPI_XT_CGROUP_H */

commit 4ec8ff0edccffe7a77f18e2a1e2ce86f03e08b5c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Dec 7 17:38:54 2015 -0500

    netfilter: prepare xt_cgroup for multi revisions
    
    xt_cgroup will grow cgroup2 path based match.  Postfix existing
    symbols with _v0 and prepare for multi revision registration.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Daniel Borkmann <daniel@iogearbox.net>
    Cc: Daniel Wagner <daniel.wagner@bmw-carit.de>
    CC: Neil Horman <nhorman@tuxdriver.com>
    Cc: Jan Engelhardt <jengelh@inai.de>
    Cc: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/uapi/linux/netfilter/xt_cgroup.h b/include/uapi/linux/netfilter/xt_cgroup.h
index 43acb7e175f6..577c9e0b9406 100644
--- a/include/uapi/linux/netfilter/xt_cgroup.h
+++ b/include/uapi/linux/netfilter/xt_cgroup.h
@@ -3,7 +3,7 @@
 
 #include <linux/types.h>
 
-struct xt_cgroup_info {
+struct xt_cgroup_info_v0 {
 	__u32 id;
 	__u32 invert;
 };

commit 82a37132f300ea53bdcd812917af5a6329ec80c3
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Sun Dec 29 18:27:12 2013 +0100

    netfilter: x_tables: lightweight process control group matching
    
    It would be useful e.g. in a server or desktop environment to have
    a facility in the notion of fine-grained "per application" or "per
    application group" firewall policies. Probably, users in the mobile,
    embedded area (e.g. Android based) with different security policy
    requirements for application groups could have great benefit from
    that as well. For example, with a little bit of configuration effort,
    an admin could whitelist well-known applications, and thus block
    otherwise unwanted "hard-to-track" applications like [1] from a
    user's machine. Blocking is just one example, but it is not limited
    to that, meaning we can have much different scenarios/policies that
    netfilter allows us than just blocking, e.g. fine grained settings
    where applications are allowed to connect/send traffic to, application
    traffic marking/conntracking, application-specific packet mangling,
    and so on.
    
    Implementation of PID-based matching would not be appropriate
    as they frequently change, and child tracking would make that
    even more complex and ugly. Cgroups would be a perfect candidate
    for accomplishing that as they associate a set of tasks with a
    set of parameters for one or more subsystems, in our case the
    netfilter subsystem, which, of course, can be combined with other
    cgroup subsystems into something more complex if needed.
    
    As mentioned, to overcome this constraint, such processes could
    be placed into one or multiple cgroups where different fine-grained
    rules can be defined depending on the application scenario, while
    e.g. everything else that is not part of that could be dropped (or
    vice versa), thus making life harder for unwanted processes to
    communicate to the outside world. So, we make use of cgroups here
    to track jobs and limit their resources in terms of iptables
    policies; in other words, limiting, tracking, etc what they are
    allowed to communicate.
    
    In our case we're working on outgoing traffic based on which local
    socket that originated from. Also, one doesn't even need to have
    an a-prio knowledge of the application internals regarding their
    particular use of ports or protocols. Matching is *extremly*
    lightweight as we just test for the sk_classid marker of sockets,
    originating from net_cls. net_cls and netfilter do not contradict
    each other; in fact, each construct can live as standalone or they
    can be used in combination with each other, which is perfectly fine,
    plus it serves Tejun's requirement to not introduce a new cgroups
    subsystem. Through this, we result in a very minimal and efficient
    module, and don't add anything except netfilter code.
    
    One possible, minimal usage example (many other iptables options
    can be applied obviously):
    
     1) Configuring cgroups if not already done, e.g.:
    
      mkdir /sys/fs/cgroup/net_cls
      mount -t cgroup -o net_cls net_cls /sys/fs/cgroup/net_cls
      mkdir /sys/fs/cgroup/net_cls/0
      echo 1 > /sys/fs/cgroup/net_cls/0/net_cls.classid
      (resp. a real flow handle id for tc)
    
     2) Configuring netfilter (iptables-nftables), e.g.:
    
      iptables -A OUTPUT -m cgroup ! --cgroup 1 -j DROP
    
     3) Running applications, e.g.:
    
      ping 208.67.222.222  <pid:1799>
      echo 1799 > /sys/fs/cgroup/net_cls/0/tasks
      64 bytes from 208.67.222.222: icmp_seq=44 ttl=49 time=11.9 ms
      [...]
      ping 208.67.220.220  <pid:1804>
      ping: sendmsg: Operation not permitted
      [...]
      echo 1804 > /sys/fs/cgroup/net_cls/0/tasks
      64 bytes from 208.67.220.220: icmp_seq=89 ttl=56 time=19.0 ms
      [...]
    
    Of course, real-world deployments would make use of cgroups user
    space toolsuite, or own custom policy daemons dynamically moving
    applications from/to various cgroups.
    
      [1] http://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-biondi/bh-eu-06-biondi-up.pdf
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: cgroups@vger.kernel.org
    Acked-by: Li Zefan <lizefan@huawei.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/uapi/linux/netfilter/xt_cgroup.h b/include/uapi/linux/netfilter/xt_cgroup.h
new file mode 100644
index 000000000000..43acb7e175f6
--- /dev/null
+++ b/include/uapi/linux/netfilter/xt_cgroup.h
@@ -0,0 +1,11 @@
+#ifndef _UAPI_XT_CGROUP_H
+#define _UAPI_XT_CGROUP_H
+
+#include <linux/types.h>
+
+struct xt_cgroup_info {
+	__u32 id;
+	__u32 invert;
+};
+
+#endif /* _UAPI_XT_CGROUP_H */
