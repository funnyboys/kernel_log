commit e2be04c7f9958dde770eeb8b30e829ca969b37bb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:09:13 2017 +0100

    License cleanup: add SPDX license identifier to uapi header files with a license
    
    Many user space API headers have licensing information, which is either
    incomplete, badly formatted or just a shorthand for referring to the
    license under which the file is supposed to be.  This makes it hard for
    compliance tools to determine the correct license.
    
    Update these files with an SPDX license identifier.  The identifier was
    chosen based on the license information in the file.
    
    GPL/LGPL licensed headers get the matching GPL/LGPL SPDX license
    identifier with the added 'WITH Linux-syscall-note' exception, which is
    the officially assigned exception identifier for the kernel syscall
    exception:
    
       NOTE! This copyright does *not* cover user programs that use kernel
       services by normal system calls - this is merely considered normal use
       of the kernel, and does *not* fall under the heading of "derived work".
    
    This exception makes it possible to include GPL headers into non GPL
    code, without confusing license compliance tools.
    
    Headers which have either explicit dual licensing or are just licensed
    under a non GPL license are updated with the corresponding SPDX
    identifier and the GPLv2 with syscall exception identifier.  The format
    is:
            ((GPL-2.0 WITH Linux-syscall-note) OR SPDX-ID-OF-OTHER-LICENSE)
    
    SPDX license identifiers are a legally binding shorthand, which can be
    used instead of the full boiler plate text.  The update does not remove
    existing license information as this has to be done on a case by case
    basis and the copyright holders might have to be consulted. This will
    happen in a separate step.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.  See the previous patch in this series for the
    methodology of how this patch was researched.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/uapi/linux/hiddev.h b/include/uapi/linux/hiddev.h
index 7df7884bf5c4..53d6cad7a999 100644
--- a/include/uapi/linux/hiddev.h
+++ b/include/uapi/linux/hiddev.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
 /*
  *  Copyright (c) 1999-2000 Vojtech Pavlik
  *

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/uapi/linux/hiddev.h b/include/uapi/linux/hiddev.h
new file mode 100644
index 000000000000..7df7884bf5c4
--- /dev/null
+++ b/include/uapi/linux/hiddev.h
@@ -0,0 +1,212 @@
+/*
+ *  Copyright (c) 1999-2000 Vojtech Pavlik
+ *
+ *  Sponsored by SuSE
+ */
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+#ifndef _UAPI_HIDDEV_H
+#define _UAPI_HIDDEV_H
+
+
+
+#include <linux/types.h>
+
+/*
+ * The event structure itself
+ */
+
+struct hiddev_event {
+	unsigned hid;
+	signed int value;
+};
+
+struct hiddev_devinfo {
+	__u32 bustype;
+	__u32 busnum;
+	__u32 devnum;
+	__u32 ifnum;
+	__s16 vendor;
+	__s16 product;
+	__s16 version;
+	__u32 num_applications;
+};
+
+struct hiddev_collection_info {
+	__u32 index;
+	__u32 type;
+	__u32 usage;
+	__u32 level;
+};
+
+#define HID_STRING_SIZE 256
+struct hiddev_string_descriptor {
+	__s32 index;
+	char value[HID_STRING_SIZE];
+};
+
+struct hiddev_report_info {
+	__u32 report_type;
+	__u32 report_id;
+	__u32 num_fields;
+};
+
+/* To do a GUSAGE/SUSAGE, fill in at least usage_code,  report_type and 
+ * report_id.  Set report_id to REPORT_ID_UNKNOWN if the rest of the fields 
+ * are unknown.  Otherwise use a usage_ref struct filled in from a previous 
+ * successful GUSAGE call to save time.  To actually send a value to the
+ * device, perform a SUSAGE first, followed by a SREPORT.  An INITREPORT or a
+ * GREPORT isn't necessary for a GUSAGE to return valid data.
+ */
+#define HID_REPORT_ID_UNKNOWN 0xffffffff
+#define HID_REPORT_ID_FIRST   0x00000100
+#define HID_REPORT_ID_NEXT    0x00000200
+#define HID_REPORT_ID_MASK    0x000000ff
+#define HID_REPORT_ID_MAX     0x000000ff
+
+#define HID_REPORT_TYPE_INPUT	1
+#define HID_REPORT_TYPE_OUTPUT	2
+#define HID_REPORT_TYPE_FEATURE	3
+#define HID_REPORT_TYPE_MIN     1
+#define HID_REPORT_TYPE_MAX     3
+
+struct hiddev_field_info {
+	__u32 report_type;
+	__u32 report_id;
+	__u32 field_index;
+	__u32 maxusage;
+	__u32 flags;
+	__u32 physical;		/* physical usage for this field */
+	__u32 logical;		/* logical usage for this field */
+	__u32 application;		/* application usage for this field */
+	__s32 logical_minimum;
+	__s32 logical_maximum;
+	__s32 physical_minimum;
+	__s32 physical_maximum;
+	__u32 unit_exponent;
+	__u32 unit;
+};
+
+/* Fill in report_type, report_id and field_index to get the information on a
+ * field.
+ */
+#define HID_FIELD_CONSTANT		0x001
+#define HID_FIELD_VARIABLE		0x002
+#define HID_FIELD_RELATIVE		0x004
+#define HID_FIELD_WRAP			0x008	
+#define HID_FIELD_NONLINEAR		0x010
+#define HID_FIELD_NO_PREFERRED		0x020
+#define HID_FIELD_NULL_STATE		0x040
+#define HID_FIELD_VOLATILE		0x080
+#define HID_FIELD_BUFFERED_BYTE		0x100
+
+struct hiddev_usage_ref {
+	__u32 report_type;
+	__u32 report_id;
+	__u32 field_index;
+	__u32 usage_index;
+	__u32 usage_code;
+	__s32 value;
+};
+
+/* hiddev_usage_ref_multi is used for sending multiple bytes to a control.
+ * It really manifests itself as setting the value of consecutive usages */
+#define HID_MAX_MULTI_USAGES 1024
+struct hiddev_usage_ref_multi {
+	struct hiddev_usage_ref uref;
+	__u32 num_values;
+	__s32 values[HID_MAX_MULTI_USAGES];
+};
+
+/* FIELD_INDEX_NONE is returned in read() data from the kernel when flags
+ * is set to (HIDDEV_FLAG_UREF | HIDDEV_FLAG_REPORT) and a new report has
+ * been sent by the device 
+ */
+#define HID_FIELD_INDEX_NONE 0xffffffff
+
+/*
+ * Protocol version.
+ */
+
+#define HID_VERSION		0x010004
+
+/*
+ * IOCTLs (0x00 - 0x7f)
+ */
+
+#define HIDIOCGVERSION		_IOR('H', 0x01, int)
+#define HIDIOCAPPLICATION	_IO('H', 0x02)
+#define HIDIOCGDEVINFO		_IOR('H', 0x03, struct hiddev_devinfo)
+#define HIDIOCGSTRING		_IOR('H', 0x04, struct hiddev_string_descriptor)
+#define HIDIOCINITREPORT	_IO('H', 0x05)
+#define HIDIOCGNAME(len)	_IOC(_IOC_READ, 'H', 0x06, len)
+#define HIDIOCGREPORT		_IOW('H', 0x07, struct hiddev_report_info)
+#define HIDIOCSREPORT		_IOW('H', 0x08, struct hiddev_report_info)
+#define HIDIOCGREPORTINFO	_IOWR('H', 0x09, struct hiddev_report_info)
+#define HIDIOCGFIELDINFO	_IOWR('H', 0x0A, struct hiddev_field_info)
+#define HIDIOCGUSAGE		_IOWR('H', 0x0B, struct hiddev_usage_ref)
+#define HIDIOCSUSAGE		_IOW('H', 0x0C, struct hiddev_usage_ref)
+#define HIDIOCGUCODE		_IOWR('H', 0x0D, struct hiddev_usage_ref)
+#define HIDIOCGFLAG		_IOR('H', 0x0E, int)
+#define HIDIOCSFLAG		_IOW('H', 0x0F, int)
+#define HIDIOCGCOLLECTIONINDEX	_IOW('H', 0x10, struct hiddev_usage_ref)
+#define HIDIOCGCOLLECTIONINFO	_IOWR('H', 0x11, struct hiddev_collection_info)
+#define HIDIOCGPHYS(len)	_IOC(_IOC_READ, 'H', 0x12, len)
+
+/* For writing/reading to multiple/consecutive usages */
+#define HIDIOCGUSAGES		_IOWR('H', 0x13, struct hiddev_usage_ref_multi)
+#define HIDIOCSUSAGES		_IOW('H', 0x14, struct hiddev_usage_ref_multi)
+
+/* 
+ * Flags to be used in HIDIOCSFLAG
+ */
+#define HIDDEV_FLAG_UREF	0x1
+#define HIDDEV_FLAG_REPORT	0x2
+#define HIDDEV_FLAGS		0x3
+
+/* To traverse the input report descriptor info for a HID device, perform the 
+ * following:
+ *
+ * rinfo.report_type = HID_REPORT_TYPE_INPUT;
+ * rinfo.report_id = HID_REPORT_ID_FIRST;
+ * ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
+ *
+ * while (ret >= 0) {
+ * 	for (i = 0; i < rinfo.num_fields; i++) {
+ * 		finfo.report_type = rinfo.report_type;
+ * 		finfo.report_id = rinfo.report_id;
+ * 		finfo.field_index = i;
+ * 		ioctl(fd, HIDIOCGFIELDINFO, &finfo);
+ * 		for (j = 0; j < finfo.maxusage; j++) {
+ * 			uref.report_type = rinfo.report_type;
+ * 			uref.report_id = rinfo.report_id;
+ * 			uref.field_index = i;
+ * 			uref.usage_index = j;
+ * 			ioctl(fd, HIDIOCGUCODE, &uref);
+ * 			ioctl(fd, HIDIOCGUSAGE, &uref);
+ * 		}
+ * 	}
+ * 	rinfo.report_id |= HID_REPORT_ID_NEXT;
+ * 	ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
+ * }
+ */
+
+
+#endif /* _UAPI_HIDDEV_H */
