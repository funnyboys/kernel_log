commit 7f17b4a121d0d50eca22cb1edebf0a157f3e43bf
Author: James Morse <james.morse@arm.com>
Date:   Fri May 1 17:45:42 2020 +0100

    ACPI: APEI: Kick the memory_failure() queue for synchronous errors
    
    memory_failure() offlines or repairs pages of memory that have been
    discovered to be corrupt. These may be detected by an external
    component, (e.g. the memory controller), and notified via an IRQ.
    In this case the work is queued as not all of memory_failure()s work
    can happen in IRQ context.
    
    If the error was detected as a result of user-space accessing a
    corrupt memory location the CPU may take an abort instead. On arm64
    this is a 'synchronous external abort', and on a firmware first
    system it is replayed using NOTIFY_SEA.
    
    This notification has NMI like properties, (it can interrupt
    IRQ-masked code), so the memory_failure() work is queued. If we
    return to user-space before the queued memory_failure() work is
    processed, we will take the fault again. This loop may cause platform
    firmware to exceed some threshold and reboot when Linux could have
    recovered from this error.
    
    For NMIlike notifications keep track of whether memory_failure() work
    was queued, and make task_work pending to flush out the queue.
    To save memory allocations, the task_work is allocated as part of
    the ghes_estatus_node, and free()ing it back to the pool is deferred.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Tested-by: Tyler Baicar <baicar@os.amperecomputing.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index e3f1cddb4ac8..517a5231cc1b 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -33,6 +33,9 @@ struct ghes_estatus_node {
 	struct llist_node llnode;
 	struct acpi_hest_generic *generic;
 	struct ghes *ghes;
+
+	int task_work_cpu;
+	struct callback_head task_work;
 };
 
 struct ghes_estatus_cache {

commit 5cc6c68287ae4be22c40b41cf6844746cddebbcc
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 29 18:48:44 2019 +0000

    ACPI / APEI: Don't update struct ghes' flags in read/clear estatus
    
    ghes_read_estatus() sets a flag in struct ghes if the buffer of
    CPER records needs to be cleared once the records have been
    processed. This flag value is a problem if a struct ghes can be
    processed concurrently, as happens at probe time if an NMI arrives
    for the same error source. The NMI clears the flag, meaning the
    interrupted handler may never do the ghes_estatus_clear() work.
    
    The GHES_TO_CLEAR flags is only set at the same time as
    buffer_paddr, which is now owned by the caller and passed to
    ghes_clear_estatus(). Use this value as the flag.
    
    A non-zero buf_paddr returned by ghes_read_estatus() means
    ghes_clear_estatus() should clear this address. ghes_read_estatus()
    already checks for a read of error_status_address being zero,
    so CPER records cannot be written here.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index f82f4a7ddd90..e3f1cddb4ac8 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -13,7 +13,6 @@
  * estatus: memory buffer for error status block, allocated during
  * HEST parsing.
  */
-#define GHES_TO_CLEAR		0x0001
 #define GHES_EXITING		0x0002
 
 struct ghes {

commit eeb2555779471abdbcc6289a52dc54ce513feaf2
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 29 18:48:42 2019 +0000

    ACPI / APEI: Don't store CPER records physical address in struct ghes
    
    When CPER records are found the address of the records is stashed
    in the struct ghes. Once the records have been processed, this
    address is overwritten with zero so that it won't be processed
    again without being re-populated by firmware.
    
    This goes wrong if a struct ghes can be processed concurrently,
    as can happen at probe time when an NMI occurs. If the NMI arrives
    on another CPU, the probing CPU may call ghes_clear_estatus() on the
    records before the handler had finished with them.
    Even on the same CPU, once the interrupted handler is resumed, it
    will call ghes_clear_estatus() on the NMIs records, this memory may
    have already been re-used by firmware.
    
    Avoid this stashing by letting the caller hold the address. A
    later patch will do away with the use of ghes->flags in the
    read/clear code too.
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index cd9ee507d860..f82f4a7ddd90 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -22,7 +22,6 @@ struct ghes {
 		struct acpi_hest_generic_v2 *generic_v2;
 	};
 	struct acpi_hest_generic_status *estatus;
-	u64 buffer_paddr;
 	unsigned long flags;
 	union {
 		struct list_head list;

commit fb7be08f1a091ec243780bfdad4bf0c492057808
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 29 18:48:41 2019 +0000

    ACPI / APEI: Make estatus pool allocation a static size
    
    Adding new NMI-like notifications duplicates the calls that grow
    and shrink the estatus pool. This is all pretty pointless, as the
    size is capped to 64K. Allocate this for each ghes and drop
    the code that grows and shrinks the pool.
    
    Suggested-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 46ef5566e052..cd9ee507d860 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -52,7 +52,7 @@ enum {
 	GHES_SEV_PANIC = 0x3,
 };
 
-int ghes_estatus_pool_init(void);
+int ghes_estatus_pool_init(int num_ghes);
 
 /* From drivers/edac/ghes_edac.c */
 

commit e147133a42cb9df6cbc99503fdf58d0e6388bf2a
Author: James Morse <james.morse@arm.com>
Date:   Tue Jan 29 18:48:40 2019 +0000

    ACPI / APEI: Make hest.c manage the estatus memory pool
    
    ghes.c has a memory pool it uses for the estatus cache and the estatus
    queue. The cache is initialised when registering the platform driver.
    For the queue, an NMI-like notification has to grow/shrink the pool
    as it is registered and unregistered.
    
    This is all pretty noisy when adding new NMI-like notifications, it
    would be better to replace this with a static pool size based on the
    number of users.
    
    As a precursor, move the call that creates the pool from ghes_init(),
    into hest.c. Later this will take the number of ghes entries and
    consolidate the queue allocations.
    Remove ghes_estatus_pool_exit() as hest.c doesn't have anywhere to put
    this.
    
    The pool is now initialised as part of ACPI's subsys_initcall():
    (acpi_init(), acpi_scan_init(), acpi_pci_root_init(), acpi_hest_init())
    Before this patch it happened later as a GHES specific device_initcall().
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 82cb4eb225a4..46ef5566e052 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -52,6 +52,8 @@ enum {
 	GHES_SEV_PANIC = 0x3,
 };
 
+int ghes_estatus_pool_init(void);
+
 /* From drivers/edac/ghes_edac.c */
 
 #ifdef CONFIG_EDAC_GHES

commit 1035a0783523d8c730c44944a71b254f3a649e25
Author: Dongjiu Geng <gengdongjiu@huawei.com>
Date:   Tue Aug 7 12:26:15 2018 -0400

    arm64 / ACPI: clean the additional checks before calling ghes_notify_sea()
    
    In order to remove the additional check before calling the
    ghes_notify_sea(), make stub definition when !CONFIG_ACPI_APEI_SEA.
    
    After this cleanup, we can simply call the ghes_notify_sea() to let
    APEI driver handle the SEA notification.
    
    Signed-off-by: Dongjiu Geng <gengdongjiu@huawei.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 1624e2be485c..82cb4eb225a4 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -118,6 +118,10 @@ static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
 	     (void *)section - (void *)(estatus + 1) < estatus->data_length; \
 	     section = acpi_hest_get_next(section))
 
+#ifdef CONFIG_ACPI_APEI_SEA
 int ghes_notify_sea(void);
+#else
+static inline int ghes_notify_sea(void) { return -ENOENT; }
+#endif
 
 #endif /* GHES_H */

commit 305d0e006a1736fbfec25e7a2d1e813694f82ed0
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Mon Apr 30 16:33:50 2018 -0500

    EDAC, ghes: Remove unused argument to ghes_edac_report_mem_error()
    
    The use of the @ghes argument was removed in a previous commit, but
    function signature was not updated to reflect this.
    
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Acked-by: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20180430213358.8319-1-mr.nuke.me@gmail.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 4fc92289f7f8..1624e2be485c 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -55,15 +55,14 @@ enum {
 /* From drivers/edac/ghes_edac.c */
 
 #ifdef CONFIG_EDAC_GHES
-void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
-				struct cper_sec_mem_err *mem_err);
+void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err);
 
 int ghes_edac_register(struct ghes *ghes, struct device *dev);
 
 void ghes_edac_unregister(struct ghes *ghes);
 
 #else
-static inline void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
+static inline void ghes_edac_report_mem_error(int sev,
 				       struct cper_sec_mem_err *mem_err)
 {
 }

commit cc7f3f132658289b6661ab8294ab08a9d32ea026
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Apr 23 14:16:46 2018 +0200

    ghes, EDAC: Fix ghes_edac registration
    
    Tony reported seeing
    
      "Internal error: Can't find EDAC structure"
    
    when injecting correctable errors due to the fact that ghes_edac would
    still load even if the whitelist won't hit. Drop the pr_err() in
    ghes_edac_report_mem_error() for now due to the hacky way how ghes_edac
    depends on ghes.c.
    
    While at it, make ghes_edac_register() return an error if it doesn't hit
    in the whitelist as it is the only sensible thing to do in that
    situation.
    
    Furthermore, move the call to it to happen last in ghes_probe() so that
    GHES initializing properly does not depend on ghes_edac init at all
    as latter is only reporting errors and not required for GHES's proper
    functioning.
    
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Tested-by: Sughosh Ganu <sughosh.ganu@arm.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20180420182015.zao3olss4tvvlxki@agluck-desk

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 8feb0c866ee0..4fc92289f7f8 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -70,7 +70,7 @@ static inline void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 
 static inline int ghes_edac_register(struct ghes *ghes, struct device *dev)
 {
-	return 0;
+	return -ENODEV;
 }
 
 static inline void ghes_edac_unregister(struct ghes *ghes)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 9061c5c743b3..8feb0c866ee0 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef GHES_H
 #define GHES_H
 

commit c4335fdd38227788178953c101b77180504d7ea0
Author: gengdongjiu <gengdongjiu@huawei.com>
Date:   Thu Aug 17 20:07:18 2017 +0800

    ACPI: APEI: fix the wrong iteration of generic error status block
    
    The revision 0x300 generic error data entry is different
    from the old version, but currently iterating through the
    GHES estatus blocks does not take into account this difference.
    This will lead to failure to get the right data entry if GHES
    has revision 0x300 error data entry.
    
    Update the GHES estatus iteration macro to properly increment using
    acpi_hest_get_next(), and correct the iteration termination condition
    because the status block data length only includes error data
    length.
    
    Convert the CPER estatus checking and printing iteration logic
    to use same macro.
    
    Signed-off-by: Dongjiu Geng <gengdongjiu@huawei.com>
    Tested-by: Tyler Baicar <tbaicar@codeaurora.org>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 9f26e01186ae..9061c5c743b3 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -113,6 +113,11 @@ static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
 	return (void *)(gdata) + acpi_hest_get_record_size(gdata);
 }
 
+#define apei_estatus_for_each_section(estatus, section)			\
+	for (section = (struct acpi_hest_generic_data *)(estatus + 1);	\
+	     (void *)section - (void *)(estatus + 1) < estatus->data_length; \
+	     section = acpi_hest_get_next(section))
+
 int ghes_notify_sea(void);
 
 #endif /* GHES_H */

commit 621f48e40ee9b0100a802531069166d7d94796e0
Author: Tyler Baicar <tbaicar@codeaurora.org>
Date:   Wed Jun 21 12:17:14 2017 -0600

    arm/arm64: KVM: add guest SEA support
    
    Currently external aborts are unsupported by the guest abort
    handling. Add handling for SEAs so that the host kernel reports
    SEAs which occur in the guest kernel.
    
    When an SEA occurs in the guest kernel, the guest exits and is
    routed to kvm_handle_guest_abort(). Prior to this patch, a print
    message of an unsupported FSC would be printed and nothing else
    would happen. With this patch, the code gets routed to the APEI
    handling of SEAs in the host kernel to report the SEA information.
    
    Signed-off-by: Tyler Baicar <tbaicar@codeaurora.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Christoffer Dall <cdall@linaro.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 95305aeb13ff..9f26e01186ae 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -113,6 +113,6 @@ static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
 	return (void *)(gdata) + acpi_hest_get_record_size(gdata);
 }
 
-void ghes_notify_sea(void);
+int ghes_notify_sea(void);
 
 #endif /* GHES_H */

commit 7edda0886bc3d1e5418951558a2555af1bc73b0a
Author: Tyler Baicar <tbaicar@codeaurora.org>
Date:   Wed Jun 21 12:17:09 2017 -0600

    acpi: apei: handle SEA notification type for ARMv8
    
    ARM APEI extension proposal added SEA (Synchronous External Abort)
    notification type for ARMv8.
    Add a new GHES error source handling function for SEA. If an error
    source's notification type is SEA, then this function can be registered
    into the SEA exception handler. That way GHES will parse and report
    SEA exceptions when they occur.
    An SEA can interrupt code that had interrupts masked and is treated as
    an NMI. To aid this the page of address space for mapping APEI buffers
    while in_nmi() is always reserved, and ghes_ioremap_pfn_nmi() is
    changed to use the helper methods to find the prot_t to map with in
    the same way as ghes_ioremap_pfn_irq().
    
    Signed-off-by: Tyler Baicar <tbaicar@codeaurora.org>
    CC: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Reviewed-by: James Morse <james.morse@arm.com>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 8f8fea004df5..95305aeb13ff 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -1,3 +1,6 @@
+#ifndef GHES_H
+#define GHES_H
+
 #include <acpi/apei.h>
 #include <acpi/hed.h>
 
@@ -109,3 +112,7 @@ static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
 {
 	return (void *)(gdata) + acpi_hest_get_record_size(gdata);
 }
+
+void ghes_notify_sea(void);
+
+#endif /* GHES_H */

commit bbcc2e7b642ed241651fee50ac6ed59643cb1736
Author: Tyler Baicar <tbaicar@codeaurora.org>
Date:   Wed Jun 21 12:17:05 2017 -0600

    ras: acpi/apei: cper: add support for generic data v3 structure
    
    The ACPI 6.1 spec adds a new revision of the generic error data
    entry structure. Add support to handle the new structure as well
    as properly verify and iterate through the generic data entries.
    
    Signed-off-by: Tyler Baicar <tbaicar@codeaurora.org>
    CC: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 68f088a92398..8f8fea004df5 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -73,3 +73,39 @@ static inline void ghes_edac_unregister(struct ghes *ghes)
 {
 }
 #endif
+
+static inline int acpi_hest_get_version(struct acpi_hest_generic_data *gdata)
+{
+	return gdata->revision >> 8;
+}
+
+static inline void *acpi_hest_get_payload(struct acpi_hest_generic_data *gdata)
+{
+	if (acpi_hest_get_version(gdata) >= 3)
+		return (void *)(((struct acpi_hest_generic_data_v300 *)(gdata)) + 1);
+
+	return gdata + 1;
+}
+
+static inline int acpi_hest_get_error_length(struct acpi_hest_generic_data *gdata)
+{
+	return ((struct acpi_hest_generic_data *)(gdata))->error_data_length;
+}
+
+static inline int acpi_hest_get_size(struct acpi_hest_generic_data *gdata)
+{
+	if (acpi_hest_get_version(gdata) >= 3)
+		return sizeof(struct acpi_hest_generic_data_v300);
+
+	return sizeof(struct acpi_hest_generic_data);
+}
+
+static inline int acpi_hest_get_record_size(struct acpi_hest_generic_data *gdata)
+{
+	return (acpi_hest_get_size(gdata) + acpi_hest_get_error_length(gdata));
+}
+
+static inline void *acpi_hest_get_next(struct acpi_hest_generic_data *gdata)
+{
+	return (void *)(gdata) + acpi_hest_get_record_size(gdata);
+}

commit 42aa560446622da6c33dce54fc8f4cd81516e906
Author: Tyler Baicar <tbaicar@codeaurora.org>
Date:   Wed Jun 21 12:17:04 2017 -0600

    acpi: apei: read ack upon ghes record consumption
    
    A RAS (Reliability, Availability, Serviceability) controller
    may be a separate processor running in parallel with OS
    execution, and may generate error records for consumption by
    the OS. If the RAS controller produces multiple error records,
    then they may be overwritten before the OS has consumed them.
    
    The Generic Hardware Error Source (GHES) v2 structure
    introduces the capability for the OS to acknowledge the
    consumption of the error record generated by the RAS
    controller. A RAS controller supporting GHESv2 shall wait for
    the acknowledgment before writing a new error record, thus
    eliminating the race condition.
    
    Add support for parsing of GHESv2 sub-tables as well.
    
    Signed-off-by: Tyler Baicar <tbaicar@codeaurora.org>
    CC: Jonathan (Zhixiong) Zhang <zjzhang@codeaurora.org>
    Reviewed-by: James Morse <james.morse@arm.com>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 720446cb243e..68f088a92398 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -13,7 +13,10 @@
 #define GHES_EXITING		0x0002
 
 struct ghes {
-	struct acpi_hest_generic *generic;
+	union {
+		struct acpi_hest_generic *generic;
+		struct acpi_hest_generic_v2 *generic_v2;
+	};
 	struct acpi_hest_generic_status *estatus;
 	u64 buffer_paddr;
 	unsigned long flags;

commit 0a00fd5e20fd5dc89e976e163588d7c54edaf745
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Jun 3 16:32:53 2014 +0800

    ACPICA: Restore error table definitions to reduce code differences between Linux and ACPICA upstream.
    
    The following commit has changed ACPICA table header definitions:
    
     Commit: 88f074f4871a8c212b212b725e4dcdcdb09613c1
     Subject: ACPI, CPER: Update cper info
    
    While such definitions are currently maintained in ACPICA. As the
    modifications applying to the table definitions affect other OSPMs'
    drivers, it is very difficult for ACPICA to initiate a process to
    complete the merge. Thus this commit finally only leaves us divergences.
    
    Revert such naming modifications to reduce the source code differecnes
    between Linux and ACPICA upstream. No functional changes.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Bob Moore <robert.moore@intel.com>
    Cc: Chen, Gong <gong.chen@linux.intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index dfd60d0bfd27..720446cb243e 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -14,7 +14,7 @@
 
 struct ghes {
 	struct acpi_hest_generic *generic;
-	struct acpi_generic_status *estatus;
+	struct acpi_hest_generic_status *estatus;
 	u64 buffer_paddr;
 	unsigned long flags;
 	union {

commit 88f074f4871a8c212b212b725e4dcdcdb09613c1
Author: Chen, Gong <gong.chen@linux.intel.com>
Date:   Fri Oct 18 14:28:59 2013 -0700

    ACPI, CPER: Update cper info
    
    We have a lot of confusing names of functions and data structures in
    amongs the the error reporting code.  In particular the "apei" prefix
    has been applied to many objects that are not part of APEI.  Since we
    will be using these routines for extended error log reporting it will
    be clearer if we fix up the names first.
    
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 720446cb243e..dfd60d0bfd27 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -14,7 +14,7 @@
 
 struct ghes {
 	struct acpi_hest_generic *generic;
-	struct acpi_hest_generic_status *estatus;
+	struct acpi_generic_status *estatus;
 	u64 buffer_paddr;
 	unsigned long flags;
 	union {

commit 21480547c8b85be6c08c4d77ed514673b73eda8a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Feb 15 06:10:39 2013 -0300

    ghes: add the needed hooks for EDAC error report
    
    In order to allow reporting errors via EDAC, add hooks for:
    
    1) register an EDAC driver;
    2) unregister an EDAC driver;
    3) report errors via EDAC.
    
    As the EDAC driver will need to access the ghes structure, adds it
    as one of the parameters for ghes_do_proc.
    
    Acked-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
index 3eb8dc483449..720446cb243e 100644
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@ -27,6 +27,7 @@ struct ghes {
 struct ghes_estatus_node {
 	struct llist_node llnode;
 	struct acpi_hest_generic *generic;
+	struct ghes *ghes;
 };
 
 struct ghes_estatus_cache {
@@ -43,3 +44,29 @@ enum {
 	GHES_SEV_RECOVERABLE = 0x2,
 	GHES_SEV_PANIC = 0x3,
 };
+
+/* From drivers/edac/ghes_edac.c */
+
+#ifdef CONFIG_EDAC_GHES
+void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
+				struct cper_sec_mem_err *mem_err);
+
+int ghes_edac_register(struct ghes *ghes, struct device *dev);
+
+void ghes_edac_unregister(struct ghes *ghes);
+
+#else
+static inline void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
+				       struct cper_sec_mem_err *mem_err)
+{
+}
+
+static inline int ghes_edac_register(struct ghes *ghes, struct device *dev)
+{
+	return 0;
+}
+
+static inline void ghes_edac_unregister(struct ghes *ghes)
+{
+}
+#endif

commit 40e064153814ce534a28714b25cb98259f107d96
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Feb 15 05:41:22 2013 -0300

    ghes: move structures/enum to a header file
    
    As a ghes_edac driver will need to access ghes structures, in order
    to properly handle the errors, move those structures to a separate
    header file. No functional changes.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/include/acpi/ghes.h b/include/acpi/ghes.h
new file mode 100644
index 000000000000..3eb8dc483449
--- /dev/null
+++ b/include/acpi/ghes.h
@@ -0,0 +1,45 @@
+#include <acpi/apei.h>
+#include <acpi/hed.h>
+
+/*
+ * One struct ghes is created for each generic hardware error source.
+ * It provides the context for APEI hardware error timer/IRQ/SCI/NMI
+ * handler.
+ *
+ * estatus: memory buffer for error status block, allocated during
+ * HEST parsing.
+ */
+#define GHES_TO_CLEAR		0x0001
+#define GHES_EXITING		0x0002
+
+struct ghes {
+	struct acpi_hest_generic *generic;
+	struct acpi_hest_generic_status *estatus;
+	u64 buffer_paddr;
+	unsigned long flags;
+	union {
+		struct list_head list;
+		struct timer_list timer;
+		unsigned int irq;
+	};
+};
+
+struct ghes_estatus_node {
+	struct llist_node llnode;
+	struct acpi_hest_generic *generic;
+};
+
+struct ghes_estatus_cache {
+	u32 estatus_len;
+	atomic_t count;
+	struct acpi_hest_generic *generic;
+	unsigned long long time_in;
+	struct rcu_head rcu;
+};
+
+enum {
+	GHES_SEV_NO = 0x0,
+	GHES_SEV_CORRECTED = 0x1,
+	GHES_SEV_RECOVERABLE = 0x2,
+	GHES_SEV_PANIC = 0x3,
+};
