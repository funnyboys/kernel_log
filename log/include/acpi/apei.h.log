commit 85595ada6c8f0c94d4d715db90c807d7baefb1c5
Merge: 60764eb379b3 e13452ac3790 c0041d40ba6a 1c3b44c0f40d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 13 01:37:17 2017 +0100

    Merge branches 'acpi-pmic', 'acpi-apei' and 'acpi-x86'
    
    * acpi-pmic:
      ACPI / PMIC: Add TI PMIC TPS68470 operation region driver
    
    * acpi-apei:
      APEI / ERST: use 64-bit timestamps
      ACPI / APEI: Remove arch_apei_flush_tlb_one()
      arm64: mm: Remove arch_apei_flush_tlb_one()
      ACPI / APEI: Remove ghes_ioremap_area
      ACPI / APEI: Replace ioremap_page_range() with fixmap
      ACPI / APEI: remove the unused dead-code for SEA/NMI notification type
      ACPI / APEI: adjust a local variable type in ghes_ioremap_pfn_irq()
    
    * acpi-x86:
      ACPI / x86: Extend KIOX000A quirk to cover all affected BIOS versions

commit 4a75aeacda3c2455954596593d89187df5420d0a
Author: James Morse <james.morse@arm.com>
Date:   Mon Nov 6 18:44:27 2017 +0000

    ACPI / APEI: Remove arch_apei_flush_tlb_one()
    
    Nothing calls arch_apei_flush_tlb_one() anymore, instead relying on
    __set_pte_vaddr() to do the invalidation when called from clear_fixmap()
    Remove arch_apei_flush_tlb_one().
    
    Signed-off-by: James Morse <james.morse@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: All applicable <stable@vger.kernel.org>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index c46694abea28..82c451698c98 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -50,7 +50,6 @@ int erst_clear(u64 record_id);
 
 int arch_apei_enable_cmcff(struct acpi_hest_header *hest_hdr, void *data);
 void arch_apei_report_mem_error(int sev, struct cper_sec_mem_err *mem_err);
-void arch_apei_flush_tlb_one(unsigned long addr);
 
 #endif
 #endif

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index c46694abea28..1797e81a3204 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * apei.h - ACPI Platform Error Interface
  */

commit e931d0dab4393f7195f84f42ed6fd973c26f62f1
Author: Punit Agrawal <punit.agrawal@arm.com>
Date:   Tue Aug 29 14:20:20 2017 +0100

    ACPI / APEI: Suppress message if HEST not present
    
    According to the ACPI specification, firmware is not required to provide
    the Hardware Error Source Table (HEST). When HEST is not present, the
    following superfluous message is printed to the kernel boot log -
    
    [    3.460067] GHES: HEST is not enabled!
    
    Extend hest_disable variable to track whether the firmware provides this
    table and if it is not present skip any log output. The existing
    behaviour is preserved in all other cases.
    
    Suggested-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Punit Agrawal <punit.agrawal@arm.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 76284bb560a6..c46694abea28 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -16,7 +16,13 @@
 
 #ifdef __KERNEL__
 
-extern bool hest_disable;
+enum hest_status {
+	HEST_ENABLED,
+	HEST_DISABLED,
+	HEST_NOT_FOUND,
+};
+
+extern int hest_disable;
 extern int erst_disable;
 #ifdef CONFIG_ACPI_APEI_GHES
 extern bool ghes_disable;

commit 594c7255dce7a13cac50cf2470cc56e2c3b0494e
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Tue Jul 22 11:20:13 2014 +0200

    acpi, apei, ghes: Factor out ioremap virtual memory for IRQ and NMI context.
    
    GHES currently maps two pages with atomic_ioremap.  From now
    on, NMI is architectural depended so there is no need to allocate
    an NMI page for platforms without NMI support.
    
    To make it possible to not use a second page, swap the existing
    page order so that the IRQ context page is first, and the optional
    NMI context page is second.  Then, use HAVE_ACPI_APEI_NMI to decide
    how many pages are to be allocated.
    
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 8a23c95109c6..76284bb560a6 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -44,6 +44,7 @@ int erst_clear(u64 record_id);
 
 int arch_apei_enable_cmcff(struct acpi_hest_header *hest_hdr, void *data);
 void arch_apei_report_mem_error(int sev, struct cper_sec_mem_err *mem_err);
+void arch_apei_flush_tlb_one(unsigned long addr);
 
 #endif
 #endif

commit 9dae3d0d9e64c3cb8bb172f041d4e66d4b92088a
Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date:   Tue Jul 22 11:20:11 2014 +0200

    apei, mce: Factor out APEI architecture specific MCE calls.
    
    This commit abstracts MCE calls and provides weak corresponding default
    implementation for those architectures which do not need arch specific
    actions. Each platform willing to do additional architectural actions
    should provides desired function definition. It allows us to avoid wrap
    code into #ifdef in generic code and prevent new platform from introducing
    dummy stub function too.
    
    Initially, there are two APEI arch-specific calls:
    - arch_apei_enable_cmcff()
    - arch_apei_report_mem_error()
    Both interact with MCE driver for X86 architecture.
    
    Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 04f349d8da73..8a23c95109c6 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -42,5 +42,8 @@ ssize_t erst_read(u64 record_id, struct cper_record_header *record,
 		  size_t buflen);
 int erst_clear(u64 record_id);
 
+int arch_apei_enable_cmcff(struct acpi_hest_header *hest_hdr, void *data);
+void arch_apei_report_mem_error(int sev, struct cper_sec_mem_err *mem_err);
+
 #endif
 #endif

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 51a527d24a8a..04f349d8da73 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -16,10 +16,10 @@
 
 #ifdef __KERNEL__
 
-extern int hest_disable;
+extern bool hest_disable;
 extern int erst_disable;
 #ifdef CONFIG_ACPI_APEI_GHES
-extern int ghes_disable;
+extern bool ghes_disable;
 #else
 #define ghes_disable 1
 #endif

commit a7e09d450b2e0b068e850d103b6ee1af537d1910
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 16 18:14:21 2011 -0400

    ACPI: APEI build fix
    
    as GHES is optional...
    
    When # CONFIG_ACPI_APEI_GHES is not set:
    
    (.init.text+0x4c22): undefined reference to `ghes_disable'
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index d40bc5521fcb..51a527d24a8a 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -18,7 +18,11 @@
 
 extern int hest_disable;
 extern int erst_disable;
+#ifdef CONFIG_ACPI_APEI_GHES
 extern int ghes_disable;
+#else
+#define ghes_disable 1
+#endif
 
 #ifdef CONFIG_ACPI_APEI
 void __init acpi_hest_init(void);

commit b6a9501658530d8b8374e37f1edb549039a8a260
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Jul 13 13:14:19 2011 +0800

    ACPI, APEI, GHES, Support disable GHES at boot time
    
    Some machine may have broken firmware so that GHES and firmware first
    mode should be disabled.  This patch adds support to that.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index e67b523a50e1..d40bc5521fcb 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -18,6 +18,7 @@
 
 extern int hest_disable;
 extern int erst_disable;
+extern int ghes_disable;
 
 #ifdef CONFIG_ACPI_APEI
 void __init acpi_hest_init(void);

commit 885b976fada5bc6595a9fd3e67e3cb1a3d11f50b
Author: Huang Ying <ying.huang@intel.com>
Date:   Mon Feb 21 13:54:41 2011 +0800

    ACPI, APEI, Add ERST record ID cache
    
    APEI ERST firmware interface and implementation has no multiple users
    in mind.  For example, if there is four records in storage with ID: 1,
    2, 3 and 4, if two ERST readers enumerate the records via
    GET_NEXT_RECORD_ID as follow,
    
    reader 1                reader 2
    1
                            2
    3
                            4
    -1
                            -1
    
    where -1 signals there is no more record ID.
    
    Reader 1 has no chance to check record 2 and 4, while reader 2 has no
    chance to check record 1 and 3.  And any other GET_NEXT_RECORD_ID will
    return -1, that is, other readers will has no chance to check any
    record even they are not cleared by anyone.
    
    This makes raw GET_NEXT_RECORD_ID not suitable for used by multiple
    users.
    
    To solve the issue, an in-memory ERST record ID cache is designed and
    implemented.  When enumerating record ID, the ID returned by
    GET_NEXT_RECORD_ID is added into cache in addition to be returned to
    caller.  So other readers can check the cache to get all record ID
    available.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Reviewed-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index c4dbb132d902..e67b523a50e1 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -30,10 +30,11 @@ int apei_hest_parse(apei_hest_func_t func, void *data);
 
 int erst_write(const struct cper_record_header *record);
 ssize_t erst_get_record_count(void);
-int erst_get_next_record_id(u64 *record_id);
+int erst_get_record_id_begin(int *pos);
+int erst_get_record_id_next(int *pos, u64 *record_id);
+void erst_get_record_id_end(void);
 ssize_t erst_read(u64 record_id, struct cper_record_header *record,
 		  size_t buflen);
-ssize_t erst_read_next(struct cper_record_header *record, size_t buflen);
 int erst_clear(u64 record_id);
 
 #endif

commit 415e12b2379239973feab91850b0dce985c6058a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 7 00:55:09 2011 +0100

    PCI/ACPI: Request _OSC control once for each root bridge (v3)
    
    Move the evaluation of acpi_pci_osc_control_set() (to request control of
    PCI Express native features) into acpi_pci_root_add() to avoid calling
    it many times for the same root complex with the same arguments.
    Additionally, check if all of the requisite _OSC support bits are set
    before calling acpi_pci_osc_control_set() for a given root complex.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=20232
    Reported-by: Ozan Caglayan <ozan@pardus.org.tr>
    Tested-by: Ozan Caglayan <ozan@pardus.org.tr>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index b3365025ff8d..c4dbb132d902 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -19,6 +19,12 @@
 extern int hest_disable;
 extern int erst_disable;
 
+#ifdef CONFIG_ACPI_APEI
+void __init acpi_hest_init(void);
+#else
+static inline void acpi_hest_init(void) { return; }
+#endif
+
 typedef int (*apei_hest_func_t)(struct acpi_hest_header *hest_hdr, void *data);
 int apei_hest_parse(apei_hest_func_t func, void *data);
 

commit a08f82d08053fb6e3aa3635c2c26456d96337c8b
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue May 18 14:35:21 2010 +0800

    ACPI, APEI, Error Record Serialization Table (ERST) support
    
    ERST is a way provided by APEI to save and retrieve hardware error
    record to and from some simple persistent storage (such as flash).
    
    The Linux kernel support implementation is quite simple and workable
    in NMI context. So it can be used to save hardware error record into
    flash in hardware error exception or NMI handler, where other more
    complex persistent storage such as disk is not usable. After saving
    hardware error records via ERST in hardware error exception or NMI
    handler, the error records can be retrieved and logged into disk or
    network after a clean reboot.
    
    For more information about ERST, please refer to ACPI Specification
    version 4.0, section 17.4.
    
    This patch incorporate fixes from Jin Dongming.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    CC: Jin Dongming <jin.dongming@np.css.fujitsu.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
index 631a1ad2d108..b3365025ff8d 100644
--- a/include/acpi/apei.h
+++ b/include/acpi/apei.h
@@ -5,9 +5,30 @@
 #ifndef ACPI_APEI_H
 #define ACPI_APEI_H
 
+#include <linux/acpi.h>
+#include <linux/cper.h>
+#include <asm/ioctls.h>
+
+#define APEI_ERST_INVALID_RECORD_ID	0xffffffffffffffffULL
+
+#define APEI_ERST_CLEAR_RECORD		_IOW('E', 1, u64)
+#define APEI_ERST_GET_RECORD_COUNT	_IOR('E', 2, u32)
+
+#ifdef __KERNEL__
+
 extern int hest_disable;
+extern int erst_disable;
 
 typedef int (*apei_hest_func_t)(struct acpi_hest_header *hest_hdr, void *data);
 int apei_hest_parse(apei_hest_func_t func, void *data);
 
+int erst_write(const struct cper_record_header *record);
+ssize_t erst_get_record_count(void);
+int erst_get_next_record_id(u64 *record_id);
+ssize_t erst_read(u64 record_id, struct cper_record_header *record,
+		  size_t buflen);
+ssize_t erst_read_next(struct cper_record_header *record, size_t buflen);
+int erst_clear(u64 record_id);
+
+#endif
 #endif

commit 9dc966641677795f4d6b0a9ba630d6a3a3e24a57
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue May 18 14:35:13 2010 +0800

    ACPI, APEI, HEST table parsing
    
    HEST describes error sources in detail; communicating operational
    parameters (i.e. severity levels, masking bits, and threshold values)
    to OS as necessary. It also allows the platform to report error
    sources for which OS would typically not implement support (for
    example, chipset-specific error registers).
    
    HEST information may be needed by other subsystems. For example, HEST
    PCIE AER error source information describes whether a PCIE root port
    works in "firmware first" mode, this is needed by general PCIE AER
    error subsystem. So a public HEST tabling parsing interface is
    provided.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/acpi/apei.h b/include/acpi/apei.h
new file mode 100644
index 000000000000..631a1ad2d108
--- /dev/null
+++ b/include/acpi/apei.h
@@ -0,0 +1,13 @@
+/*
+ * apei.h - ACPI Platform Error Interface
+ */
+
+#ifndef ACPI_APEI_H
+#define ACPI_APEI_H
+
+extern int hest_disable;
+
+typedef int (*apei_hest_func_t)(struct acpi_hest_header *hest_hdr, void *data);
+int apei_hest_parse(apei_hest_func_t func, void *data);
+
+#endif
