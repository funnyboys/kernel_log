commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index ba6fd7202775..a6a9373ab863 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -1,14 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * CPPC (Collaborative Processor Performance Control) methods used
  * by CPUfreq drivers.
  *
  * (C) Copyright 2014, 2015 Linaro Ltd.
  * Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; version 2
- * of the License.
  */
 
 #ifndef _CPPC_ACPI_H

commit 1757d05f3112acc5c0cdbcccad3afdee99655bf9
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Sun Feb 17 11:54:14 2019 +0800

    ACPI / CPPC: Add a helper to get desired performance
    
    This patch add a helper to get the value of desired performance
    register.
    
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    [ rjw: More white space ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 4f34734e7f36..ba6fd7202775 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -137,6 +137,7 @@ struct cppc_cpudata {
 	cpumask_var_t shared_cpu_map;
 };
 
+extern int cppc_get_desired_perf(int cpunum, u64 *desired_perf);
 extern int cppc_get_perf_ctrs(int cpu, struct cppc_perf_fb_ctrs *perf_fb_ctrs);
 extern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);
 extern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);

commit ad3bc25a320742f42b3015115384f5aec69c7ce2
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Dec 5 00:34:56 2018 +0100

    x86/kernel: Fix more -Wmissing-prototypes warnings
    
    ... with the goal of eventually enabling -Wmissing-prototypes by
    default. At least on x86.
    
    Make functions static where possible, otherwise add prototypes or make
    them visible through includes.
    
    asm/trace/ changes courtesy of Steven Rostedt <rostedt@goodmis.org>.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Masami Hiramatsu <mhiramat@kernel.org>
    Reviewed-by: Ingo Molnar <mingo@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> # ACPI + cpufreq bits
    Cc: Andrew Banman <andrew.banman@hpe.com>
    Cc: Dimitri Sivanich <dimitri.sivanich@hpe.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Masami Hiramatsu <mhiramat@kernel.org>
    Cc: Mike Travis <mike.travis@hpe.com>
    Cc: "Steven Rostedt (VMware)" <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Yi Wang <wang.yi59@zte.com.cn>
    Cc: linux-acpi@vger.kernel.org

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index cf59e6210d27..4f34734e7f36 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -142,5 +142,8 @@ extern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);
 extern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);
 extern int acpi_get_psd_map(struct cppc_cpudata **);
 extern unsigned int cppc_get_transition_latency(int cpu);
+extern bool cpc_ffh_supported(void);
+extern int cpc_read_ffh(int cpunum, struct cpc_reg *reg, u64 *val);
+extern int cpc_write_ffh(int cpunum, struct cpc_reg *reg, u64 val);
 
 #endif /* _CPPC_ACPI_H*/

commit 29523f095397637edca60c627bc3e5c25a02c40f
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Mon Oct 15 10:37:19 2018 -0700

    ACPI / CPPC: Add support for guaranteed performance
    
    The Continuous Performance Control package may contain an optional
    guaranteed performance field.
    
    Add support to read guaranteed performance from _CPC.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 8e0b8250a139..cf59e6210d27 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -104,6 +104,7 @@ enum cppc_regs {
  * today.
  */
 struct cppc_perf_caps {
+	u32 guaranteed_perf;
 	u32 highest_perf;
 	u32 nominal_perf;
 	u32 lowest_perf;

commit 4773e77cdc9b3af93ee1ae7bcf2acf94fde17166
Author: Prashanth Prakash <pprakash@codeaurora.org>
Date:   Wed Apr 4 12:14:50 2018 -0600

    ACPI / CPPC: Add support for CPPC v3
    
    CPPC V3 introduces two new entries to make it easier to convert between
    abstract processor performance and frequency. The two new entries are
    lowest frequency and nominal frequency. These are the frequencies
    corresponding to lowest and nominal abstract performance.
    
    Add support to read the new entries and populate them as part of the
    CPPC performance capabilities which can be used by cpufreq drivers
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 2010c0516f27..8e0b8250a139 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -20,14 +20,16 @@
 #include <acpi/pcc.h>
 #include <acpi/processor.h>
 
-/* Only support CPPCv2 for now. */
-#define CPPC_NUM_ENT	21
-#define CPPC_REV	2
+/* Support CPPCv2 and CPPCv3  */
+#define CPPC_V2_REV	2
+#define CPPC_V3_REV	3
+#define CPPC_V2_NUM_ENT	21
+#define CPPC_V3_NUM_ENT	23
 
 #define PCC_CMD_COMPLETE_MASK	(1 << 0)
 #define PCC_ERROR_MASK		(1 << 2)
 
-#define MAX_CPC_REG_ENT 19
+#define MAX_CPC_REG_ENT 21
 
 /* CPPC specific PCC commands. */
 #define	CMD_READ 0
@@ -91,6 +93,8 @@ enum cppc_regs {
 	AUTO_ACT_WINDOW,
 	ENERGY_PERF,
 	REFERENCE_PERF,
+	LOWEST_FREQ,
+	NOMINAL_FREQ,
 };
 
 /*
@@ -104,6 +108,8 @@ struct cppc_perf_caps {
 	u32 nominal_perf;
 	u32 lowest_perf;
 	u32 lowest_nonlinear_perf;
+	u32 lowest_freq;
+	u32 nominal_freq;
 };
 
 struct cppc_perf_ctrls {

commit 2c74d8473d19c159a3c3eabaa4819e110c97e8ec
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Wed Mar 29 13:50:00 2017 -0600

    ACPI / CPPC: add sysfs entries for CPPC perf capabilities
    
    Computed delivered performance using CPPC feedback counters are in the
    CPPC abstract scale, whereas cppc_cpufreq driver operates in KHz scale.
    Exposing the CPPC performance capabilities (highest,lowest, nominal,
    lowest non-linear) will allow userspace to figure out the conversion
    factor from CPPC abstract scale to KHz.
    
    Also rename ctr_wrap_time to wraparound_time so that show_cppc_data()
    macro will work with it.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 34e9680c55db..2010c0516f27 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -116,7 +116,7 @@ struct cppc_perf_fb_ctrs {
 	u64 reference;
 	u64 delivered;
 	u64 reference_perf;
-	u64 ctr_wrap_time;
+	u64 wraparound_time;
 };
 
 /* Per CPU container for runtime CPPC management. */

commit 368520a6b2dd232ea5743a6acd9f056bc30e05b4
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Wed Mar 29 13:49:59 2017 -0600

    ACPI / CPPC: Read lowest nonlinear perf in cppc_get_perf_caps()
    
    Read lowest non linear perf in cppc_get_perf_caps so that it can be exposed
    via sysfs to the usespace. Lowest non linear perf is the lowest performance
    level at which nonlinear power savings are achieved.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 427a7c3e6c75..34e9680c55db 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -103,6 +103,7 @@ struct cppc_perf_caps {
 	u32 highest_perf;
 	u32 nominal_perf;
 	u32 lowest_perf;
+	u32 lowest_nonlinear_perf;
 };
 
 struct cppc_perf_ctrls {

commit 41dd64038970139c562d07ee7ff4e41245611b4a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Sep 1 13:37:11 2016 -0700

    ACPI / CPPC: Add prefix cppc to cpudata structure name
    
    Since struct cpudata is defined in a header file, add prefix cppc_ to
    make it not a generic name. Otherwise it causes compile issue in locally
    define structure with the same name.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 0e83cc3009bc..427a7c3e6c75 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -119,7 +119,7 @@ struct cppc_perf_fb_ctrs {
 };
 
 /* Per CPU container for runtime CPPC management. */
-struct cpudata {
+struct cppc_cpudata {
 	int cpu;
 	struct cppc_perf_caps perf_caps;
 	struct cppc_perf_ctrls perf_ctrls;
@@ -132,7 +132,7 @@ struct cpudata {
 extern int cppc_get_perf_ctrs(int cpu, struct cppc_perf_fb_ctrs *perf_fb_ctrs);
 extern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);
 extern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);
-extern int acpi_get_psd_map(struct cpudata **);
+extern int acpi_get_psd_map(struct cppc_cpudata **);
 extern unsigned int cppc_get_transition_latency(int cpu);
 
 #endif /* _CPPC_ACPI_H*/

commit 139aee73f0c23b95a7e919b8f7e51ccf2d221181
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Tue Aug 16 14:39:44 2016 -0600

    ACPI / CPPC: check for error bit in PCC status field
    
    PCC status field exposes an error bit(2) to indicate any errors during
    the execution of last comamnd. This patch checks the error bit before
    notifying success/failure to the cpufreq driver.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index f50b5339b888..0e83cc3009bc 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -24,7 +24,9 @@
 #define CPPC_NUM_ENT	21
 #define CPPC_REV	2
 
-#define PCC_CMD_COMPLETE 1
+#define PCC_CMD_COMPLETE_MASK	(1 << 0)
+#define PCC_ERROR_MASK		(1 << 2)
+
 #define MAX_CPC_REG_ENT 19
 
 /* CPPC specific PCC commands. */

commit 158c998ea44ba30ae3d1bde535581c4436417530
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Tue Aug 16 14:39:42 2016 -0600

    ACPI / CPPC: add sysfs support to compute delivered performance
    
    The CPPC tables contain entries for per CPU feedback counters which
    allows us to compute the delivered performance over a given interval
    of time.
    
    The math for delivered performance per the CPPCv5.0+ spec is:
      reference perf * delta(delivered perf ctr)/delta(ref perf ctr)
    
    Maintaining deltas of the counters in the kernel is messy, as it
    depends on when the reads are triggered. (e.g. via the cpufreq
    ->get() interface). Also the ->get() interace only returns one
    value, so cant return raw values. So instead, leave it to userspace
    to keep track of raw values and do its math for CPUs it cares about.
    
    delivered and reference perf counters are exposed via the same
    sysfs file to avoid the potential "skid", if these values are read
    individually from userspace.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 42cbeb93ea32..f50b5339b888 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -65,6 +65,7 @@ struct cpc_desc {
 	int write_cmd_id;
 	struct cpc_register_resource cpc_regs[MAX_CPC_REG_ENT];
 	struct acpi_psd_package domain_info;
+	struct kobject kobj;
 };
 
 /* These are indexes into the per-cpu cpc_regs[]. Order is important. */
@@ -99,7 +100,6 @@ enum cppc_regs {
 struct cppc_perf_caps {
 	u32 highest_perf;
 	u32 nominal_perf;
-	u32 reference_perf;
 	u32 lowest_perf;
 };
 
@@ -111,9 +111,9 @@ struct cppc_perf_ctrls {
 
 struct cppc_perf_fb_ctrs {
 	u64 reference;
-	u64 prev_reference;
 	u64 delivered;
-	u64 prev_delivered;
+	u64 reference_perf;
+	u64 ctr_wrap_time;
 };
 
 /* Per CPU container for runtime CPPC management. */

commit be8b88d7d9877114172b32817d8eb3e85d3d8f99
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Tue Aug 16 14:39:41 2016 -0600

    ACPI / CPPC: set a non-zero value for transition_latency
    
    Compute the expected transition latency for frequency transitions
    using the values from the PCCT tables when the desired perf
    register is in PCC.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Reviewed-by: Alexey Klimov <alexey.klimov@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index d2101bcea013..42cbeb93ea32 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -131,5 +131,6 @@ extern int cppc_get_perf_ctrs(int cpu, struct cppc_perf_fb_ctrs *perf_fb_ctrs);
 extern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);
 extern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);
 extern int acpi_get_psd_map(struct cpudata **);
+extern unsigned int cppc_get_transition_latency(int cpu);
 
 #endif /* _CPPC_ACPI_H*/

commit 80b8286aeec056d21bffed2d1ece3904516e9c91
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Tue Aug 16 14:39:40 2016 -0600

    ACPI / CPPC: support for batching CPPC requests
    
    CPPC defined in section 8.4.7 of ACPI 6.0 specification suggests
    "To amortize the cost of PCC transactions, OSPM should read or write
    all PCC registers via a single read or write command when possible"
    This patch enables opportunistic batching of frequency transition
    requests whenever the request happen to overlap in time.
    
    Currently the access to pcc is serialized by a spin lock which does
    not scale well as we increase the number of cores in the system. This
    patch improves the scalability by allowing the differnt CPU cores to
    update PCC subspace in parallel and by batching requests which will
    reduce the certain types of operation(checking command completion bit,
    ringing doorbell) by a significant margin.
    
    Profiling shows significant improvement in the overall effeciency
    to service freq. transition requests. With this patch we observe close
    to 30% of the frequency transition requests being batched with other
    requests while running apache bench on a ARM platform with 6
    independent domains(or sets of related cpus).
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 36ff5c649f49..d2101bcea013 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -61,6 +61,8 @@ struct cpc_desc {
 	int num_entries;
 	int version;
 	int cpu_id;
+	int write_cmd_status;
+	int write_cmd_id;
 	struct cpc_register_resource cpc_regs[MAX_CPC_REG_ENT];
 	struct acpi_psd_package domain_info;
 };

commit 5bbb86aa4b8d84395e42cd05448820651d79f349
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Tue Aug 16 14:39:38 2016 -0600

    ACPI / CPPC: restructure read/writes for efficient sys mapped reg ops
    
    For cases where sys mapped CPC registers need to be accessed
    frequently, it helps immensly to pre-map them rather than map
    and unmap for each operation. e.g. case where feedback counters
    are sys mem map registers.
    
    Restructure cpc_read/write and the cpc_regs structure to allow
    pre-mapping the system addresses and unmap them when the CPU exits.
    
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 284965cbc9af..36ff5c649f49 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -49,6 +49,7 @@ struct cpc_reg {
  */
 struct cpc_register_resource {
 	acpi_object_type type;
+	u64 __iomem *sys_mem_vaddr;
 	union {
 		struct cpc_reg reg;
 		u64 int_value;

commit 866ae696e26ee2b1fa0d04e67d6dafc477543fd6
Author: Hoan Tran <hotran@apm.com>
Date:   Thu Jun 16 14:09:38 2016 -0700

    mailbox: pcc: Add PCC request and free channel declarations
    
    Exports pcc_mbox_request_channel() and pcc_mbox_free_channel()
    declarations into a pcc.h header file.
    
    Looks-good-to: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Hoan Tran <hotran@apm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index dad8af3ebeb5..284965cbc9af 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -15,10 +15,9 @@
 #define _CPPC_ACPI_H
 
 #include <linux/acpi.h>
-#include <linux/mailbox_controller.h>
-#include <linux/mailbox_client.h>
 #include <linux/types.h>
 
+#include <acpi/pcc.h>
 #include <acpi/processor.h>
 
 /* Only support CPPCv2 for now. */
@@ -130,8 +129,4 @@ extern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);
 extern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);
 extern int acpi_get_psd_map(struct cpudata **);
 
-/* Methods to interact with the PCC mailbox controller. */
-extern struct mbox_chan *
-	pcc_mbox_request_channel(struct mbox_client *, unsigned int);
-
 #endif /* _CPPC_ACPI_H*/

commit 2db8f9a1d86aa32a9cbf1a975882b4fa162f040f
Author: Timur Tabi <timur@codeaurora.org>
Date:   Tue Jan 26 12:43:00 2016 -0600

    ACPI / CPPC: remove redundant mbox_send_message() declaration
    
    Remove a redundant function declaration in cppc_acpi.h for
    mbox_send_message().  That function is defined in mailbox_client.h,
    which is already included.
    
    Signed-off-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
index 717a29810473..dad8af3ebeb5 100644
--- a/include/acpi/cppc_acpi.h
+++ b/include/acpi/cppc_acpi.h
@@ -133,6 +133,5 @@ extern int acpi_get_psd_map(struct cpudata **);
 /* Methods to interact with the PCC mailbox controller. */
 extern struct mbox_chan *
 	pcc_mbox_request_channel(struct mbox_client *, unsigned int);
-extern int mbox_send_message(struct mbox_chan *chan, void *mssg);
 
 #endif /* _CPPC_ACPI_H*/

commit 337aadff8e4567e39669e07d9a88b789d78458b5
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Fri Oct 2 10:01:19 2015 -0400

    ACPI: Introduce CPU performance controls using CPPC
    
    CPPC stands for Collaborative Processor Performance Controls
    and is defined in the ACPI v5.0+ spec. It describes CPU
    performance controls on an abstract and continuous scale
    allowing the platform (e.g. remote power processor) to flexibly
    optimize CPU performance with its knowledge of power budgets
    and other architecture specific knowledge.
    
    This patch adds a shim which exports commonly used functions
    to get and set CPPC specific controls for each CPU. This enables
    CPUFreq drivers to gather per CPU performance data and use
    with exisiting governors or even allows for customized governors
    which are implemented inside CPUFreq drivers.
    
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Reviewed-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/acpi/cppc_acpi.h b/include/acpi/cppc_acpi.h
new file mode 100644
index 000000000000..717a29810473
--- /dev/null
+++ b/include/acpi/cppc_acpi.h
@@ -0,0 +1,138 @@
+/*
+ * CPPC (Collaborative Processor Performance Control) methods used
+ * by CPUfreq drivers.
+ *
+ * (C) Copyright 2014, 2015 Linaro Ltd.
+ * Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#ifndef _CPPC_ACPI_H
+#define _CPPC_ACPI_H
+
+#include <linux/acpi.h>
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox_client.h>
+#include <linux/types.h>
+
+#include <acpi/processor.h>
+
+/* Only support CPPCv2 for now. */
+#define CPPC_NUM_ENT	21
+#define CPPC_REV	2
+
+#define PCC_CMD_COMPLETE 1
+#define MAX_CPC_REG_ENT 19
+
+/* CPPC specific PCC commands. */
+#define	CMD_READ 0
+#define	CMD_WRITE 1
+
+/* Each register has the folowing format. */
+struct cpc_reg {
+	u8 descriptor;
+	u16 length;
+	u8 space_id;
+	u8 bit_width;
+	u8 bit_offset;
+	u8 access_width;
+	u64 __iomem address;
+} __packed;
+
+/*
+ * Each entry in the CPC table is either
+ * of type ACPI_TYPE_BUFFER or
+ * ACPI_TYPE_INTEGER.
+ */
+struct cpc_register_resource {
+	acpi_object_type type;
+	union {
+		struct cpc_reg reg;
+		u64 int_value;
+	} cpc_entry;
+};
+
+/* Container to hold the CPC details for each CPU */
+struct cpc_desc {
+	int num_entries;
+	int version;
+	int cpu_id;
+	struct cpc_register_resource cpc_regs[MAX_CPC_REG_ENT];
+	struct acpi_psd_package domain_info;
+};
+
+/* These are indexes into the per-cpu cpc_regs[]. Order is important. */
+enum cppc_regs {
+	HIGHEST_PERF,
+	NOMINAL_PERF,
+	LOW_NON_LINEAR_PERF,
+	LOWEST_PERF,
+	GUARANTEED_PERF,
+	DESIRED_PERF,
+	MIN_PERF,
+	MAX_PERF,
+	PERF_REDUC_TOLERANCE,
+	TIME_WINDOW,
+	CTR_WRAP_TIME,
+	REFERENCE_CTR,
+	DELIVERED_CTR,
+	PERF_LIMITED,
+	ENABLE,
+	AUTO_SEL_ENABLE,
+	AUTO_ACT_WINDOW,
+	ENERGY_PERF,
+	REFERENCE_PERF,
+};
+
+/*
+ * Categorization of registers as described
+ * in the ACPI v.5.1 spec.
+ * XXX: Only filling up ones which are used by governors
+ * today.
+ */
+struct cppc_perf_caps {
+	u32 highest_perf;
+	u32 nominal_perf;
+	u32 reference_perf;
+	u32 lowest_perf;
+};
+
+struct cppc_perf_ctrls {
+	u32 max_perf;
+	u32 min_perf;
+	u32 desired_perf;
+};
+
+struct cppc_perf_fb_ctrs {
+	u64 reference;
+	u64 prev_reference;
+	u64 delivered;
+	u64 prev_delivered;
+};
+
+/* Per CPU container for runtime CPPC management. */
+struct cpudata {
+	int cpu;
+	struct cppc_perf_caps perf_caps;
+	struct cppc_perf_ctrls perf_ctrls;
+	struct cppc_perf_fb_ctrs perf_fb_ctrs;
+	struct cpufreq_policy *cur_policy;
+	unsigned int shared_type;
+	cpumask_var_t shared_cpu_map;
+};
+
+extern int cppc_get_perf_ctrs(int cpu, struct cppc_perf_fb_ctrs *perf_fb_ctrs);
+extern int cppc_set_perf(int cpu, struct cppc_perf_ctrls *perf_ctrls);
+extern int cppc_get_perf_caps(int cpu, struct cppc_perf_caps *caps);
+extern int acpi_get_psd_map(struct cpudata **);
+
+/* Methods to interact with the PCC mailbox controller. */
+extern struct mbox_chan *
+	pcc_mbox_request_channel(struct mbox_client *, unsigned int);
+extern int mbox_send_message(struct mbox_chan *chan, void *mssg);
+
+#endif /* _CPPC_ACPI_H*/
