commit def0aa218e6d42231540329e6f5741fdec9e7da4
Author: Vincent Chen <vincent.chen@sifive.com>
Date:   Tue Jun 23 13:37:25 2020 +0800

    kgdb: Move the extern declaration kgdb_has_hit_break() to generic kgdb.h
    
    Currently, only riscv kgdb.c uses the kgdb_has_hit_break() to identify
    the kgdb breakpoint. It causes other architectures will encounter the "no
    previous prototype" warnings if the compile option has W=1. Moving the
    declaration of extern kgdb_has_hit_break() from risc-v kgdb.h to generic
    kgdb.h to avoid generating these warnings.
    
    Signed-off-by: Vincent Chen <vincent.chen@sifive.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 0e4e3a80d58c..477b8b7c908f 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -325,6 +325,7 @@ extern int kgdb_hex2mem(char *buf, char *mem, int count);
 
 extern int kgdb_isremovedbreak(unsigned long addr);
 extern void kgdb_schedule_breakpoint(void);
+extern int kgdb_has_hit_break(unsigned long addr);
 
 extern int
 kgdb_handle_exception(int ex_vector, int signo, int err_code,

commit 8c080d3a974ad471d8324825851044284f1886c9
Author: Vincent Chen <vincent.chen@sifive.com>
Date:   Tue Jun 23 13:36:42 2020 +0800

    kgdb: enable arch to support XML packet.
    
    The XML packet could be supported by required architecture if the
    architecture defines CONFIG_HAVE_ARCH_KGDB_QXFER_PKT and implement its own
    kgdb_arch_handle_qxfer_pkt(). Except for the kgdb_arch_handle_qxfer_pkt(),
    the architecture also needs to record the feature supported by gdb stub
    into the kgdb_arch_gdb_stub_feature, and these features will be reported
    to host gdb when gdb stub receives the qSupported packet.
    
    Signed-off-by: Vincent Chen <vincent.chen@sifive.com>
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Palmer Dabbelt <palmerdabbelt@google.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 529116b0cabe..0e4e3a80d58c 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -176,6 +176,17 @@ kgdb_arch_handle_exception(int vector, int signo, int err_code,
 			   char *remcom_out_buffer,
 			   struct pt_regs *regs);
 
+/**
+ *	kgdb_arch_handle_qxfer_pkt - Handle architecture specific GDB XML
+ *				     packets.
+ *	@remcom_in_buffer: The buffer of the packet we have read.
+ *	@remcom_out_buffer: The buffer of %BUFMAX bytes to write a packet into.
+ */
+
+extern void
+kgdb_arch_handle_qxfer_pkt(char *remcom_in_buffer,
+			   char *remcom_out_buffer);
+
 /**
  *	kgdb_call_nmi_hook - Call kgdb_nmicallback() on the current CPU
  *	@ignored: This parameter is only here to match the prototype.

commit 5946d1f5b309381805bad3ddc3054c04f4ae9c24
Author: Sumit Garg <sumit.garg@linaro.org>
Date:   Thu Jun 4 15:31:19 2020 +0530

    kdb: Switch to use safer dbg_io_ops over console APIs
    
    In kgdb context, calling console handlers aren't safe due to locks used
    in those handlers which could in turn lead to a deadlock. Although, using
    oops_in_progress increases the chance to bypass locks in most console
    handlers but it might not be sufficient enough in case a console uses
    more locks (VT/TTY is good example).
    
    Currently when a driver provides both polling I/O and a console then kdb
    will output using the console. We can increase robustness by using the
    currently active polling I/O driver (which should be lockless) instead
    of the corresponding console. For several common cases (e.g. an
    embedded system with a single serial port that is used both for console
    output and debugger I/O) this will result in no console handler being
    used.
    
    In order to achieve this we need to reverse the order of preference to
    use dbg_io_ops (uses polling I/O mode) over console APIs. So we just
    store "struct console" that represents debugger I/O in dbg_io_ops and
    while emitting kdb messages, skip console that matches dbg_io_ops
    console in order to avoid duplicate messages. After this change,
    "is_console" param becomes redundant and hence removed.
    
    Suggested-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Sumit Garg <sumit.garg@linaro.org>
    Link: https://lore.kernel.org/r/1591264879-25920-5-git-send-email-sumit.garg@linaro.org
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index c62d76478adc..529116b0cabe 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -276,8 +276,7 @@ struct kgdb_arch {
  * the I/O driver.
  * @post_exception: Pointer to a function that will do any cleanup work
  * for the I/O driver.
- * @is_console: 1 if the end device is a console 0 if the I/O device is
- * not a console
+ * @cons: valid if the I/O device is a console; else NULL.
  */
 struct kgdb_io {
 	const char		*name;
@@ -288,7 +287,7 @@ struct kgdb_io {
 	void			(*deinit) (void);
 	void			(*pre_exception) (void);
 	void			(*post_exception) (void);
-	int			is_console;
+	struct console		*cons;
 };
 
 extern const struct kgdb_arch		arch_kgdb_ops;

commit 220995622da5317714b5fe659165735f7b44b87e
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu May 7 13:08:46 2020 -0700

    kgdboc: Add kgdboc_earlycon to support early kgdb using boot consoles
    
    We want to enable kgdb to debug the early parts of the kernel.
    Unfortunately kgdb normally is a client of the tty API in the kernel
    and serial drivers don't register to the tty layer until fairly late
    in the boot process.
    
    Serial drivers do, however, commonly register a boot console.  Let's
    enable the kgdboc driver to work with boot consoles to provide early
    debugging.
    
    This change co-opts the existing read() function pointer that's part
    of "struct console".  It's assumed that if a boot console (with the
    flag CON_BOOT) has implemented read() that both the read() and write()
    function are polling functions.  That means they work without
    interrupts and read() will return immediately (with 0 bytes read) if
    there's nothing to read.  This should be a safe assumption since it
    appears that no current boot consoles implement read() right now and
    there seems no reason to do so unless they wanted to support
    "kgdboc_earlycon".
    
    The normal/expected way to make all this work is to use
    "kgdboc_earlycon" and "kgdboc" together.  You should point them both
    to the same physical serial connection.  At boot time, as the system
    transitions from the boot console to the normal console (and registers
    a tty), kgdb will switch over.
    
    One awkward part of all this, though, is that there can be a window
    where the boot console goes away and we can't quite transtion over to
    the main kgdboc that uses the tty layer.  There are two main problems:
    
    1. The act of registering the tty doesn't cause any call into kgdboc
       so there is a window of time when the tty is there but kgdboc's
       init code hasn't been called so we can't transition to it.
    
    2. On some serial drivers the normal console inits (and replaces the
       boot console) quite early in the system.  Presumably these drivers
       were coded up before earlycon worked as well as it does today and
       probably they don't need to do this anymore, but it causes us
       problems nontheless.
    
    Problem #1 is not too big of a deal somewhat due to the luck of probe
    ordering.  kgdboc is last in the tty/serial/Makefile so its probe gets
    right after all other tty devices.  It's not fun to rely on this, but
    it does work for the most part.
    
    Problem #2 is a big deal, but only for some serial drivers.  Other
    serial drivers end up registering the console (which gets rid of the
    boot console) and tty at nearly the same time.
    
    The way we'll deal with the window when the system has stopped using
    the boot console and the time when we're setup using the tty is to
    keep using the boot console.  This may sound surprising, but it has
    been found to work well in practice.  If it doesn't work, it shouldn't
    be too hard for a given serial driver to make it keep working.
    Specifically, it's expected that the read()/write() function provided
    in the boot console should be the same (or nearly the same) as the
    normal kgdb polling functions.  That means continuing to use them
    should work just fine.  To make things even more likely to work work
    we'll also trap the recently added exit() function in the boot console
    we're using and delay any calls to it until we're all done with the
    boot console.
    
    NOTE: there could be ways to use all this in weird / unexpected ways.
    If you do something like this, it's a bit of a buyer beware situation.
    Specifically:
    - If you specify only "kgdboc_earlycon" but not "kgdboc" then
      (depending on your serial driver) things will probably work OK, but
      you'll get a warning printed the first time you use kgdb after the
      boot console is gone.  You'd only be able to do this, of course, if
      the serial driver you're running atop provided an early boot console.
    - If your "kgdboc_earlycon" and "kgdboc" devices are not the same
      device things should work OK, but it'll be your job to switch over
      which device you're monitoring (including figuring out how to switch
      over gdb in-flight if you're using it).
    
    When trying to enable "kgdboc_earlycon" it should be noted that the
    names that are registered through the boot console layer and the tty
    layer are not the same for the same port.  For example when debugging
    on one board I'd need to pass "kgdboc_earlycon=qcom_geni
    kgdboc=ttyMSM0" to enable things properly.  Since digging up the boot
    console name is a pain and there will rarely be more than one boot
    console enabled, you can provide the "kgdboc_earlycon" parameter
    without specifying the name of the boot console.  In this case we'll
    just pick the first boot that implements read() that we find.
    
    This new "kgdboc_earlycon" parameter should be contrasted to the
    existing "ekgdboc" parameter.  While both provide a way to debug very
    early, the usage and mechanisms are quite different.  Specifically
    "kgdboc_earlycon" is meant to be used in tandem with "kgdboc" and
    there is a transition from one to the other.  The "ekgdboc" parameter,
    on the other hand, replaces the "kgdboc" parameter.  It runs the same
    logic as the "kgdboc" parameter but just relies on your TTY driver
    being present super early.  The only known usage of the old "ekgdboc"
    parameter is documented as "ekgdboc=kbd earlyprintk=vga".  It should
    be noted that "kbd" has special treatment allowing it to init early as
    a tty device.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Sumit Garg <sumit.garg@linaro.org>
    Link: https://lore.kernel.org/r/20200507130644.v4.8.I8fba5961bf452ab92350654aa61957f23ecf0100@changeid
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index c2caee08e418..c62d76478adc 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -269,6 +269,9 @@ struct kgdb_arch {
  * @write_char: Pointer to a function that will write one char.
  * @flush: Pointer to a function that will flush any pending writes.
  * @init: Pointer to a function that will initialize the device.
+ * @deinit: Pointer to a function that will deinit the device. Implies that
+ * this I/O driver is temporary and expects to be replaced. Called when
+ * an I/O driver is replaced or explicitly unregistered.
  * @pre_exception: Pointer to a function that will do any prep work for
  * the I/O driver.
  * @post_exception: Pointer to a function that will do any cleanup work
@@ -282,6 +285,7 @@ struct kgdb_io {
 	void			(*write_char) (u8);
 	void			(*flush) (void);
 	int			(*init) (void);
+	void			(*deinit) (void);
 	void			(*pre_exception) (void);
 	void			(*post_exception) (void);
 	int			is_console;

commit 1137a96f9b5a8615296bd319151896c859ead292
Author: Jason Yan <yanaijie@huawei.com>
Date:   Thu May 7 19:06:49 2020 +0800

    kgdb: Return true in kgdb_nmi_poll_knock()
    
    Fix the following coccicheck warning:
    
    include/linux/kgdb.h:301:54-55: WARNING: return of 0/1 in function
    'kgdb_nmi_poll_knock' with return type bool
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Link: https://lore.kernel.org/r/20200507110649.37426-1-yanaijie@huawei.com
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 4d6fe87fd38f..c2caee08e418 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -298,7 +298,7 @@ extern bool kgdb_nmi_poll_knock(void);
 #else
 static inline int kgdb_register_nmi_console(void) { return 0; }
 static inline int kgdb_unregister_nmi_console(void) { return 0; }
-static inline bool kgdb_nmi_poll_knock(void) { return 1; }
+static inline bool kgdb_nmi_poll_knock(void) { return true; }
 #endif
 
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);

commit 3fec4aecb311995189217e64d725cfe84a568de3
Author: Daniel Thompson <daniel.thompson@linaro.org>
Date:   Wed May 6 17:42:23 2020 +0100

    kgdb: Fix spurious true from in_dbg_master()
    
    Currently there is a small window where a badly timed migration could
    cause in_dbg_master() to spuriously return true. Specifically if we
    migrate to a new core after reading the processor id and the previous
    core takes a breakpoint then we will evaluate true if we read
    kgdb_active before we get the IPI to bring us to halt.
    
    Fix this by checking irqs_disabled() first. Interrupts are always
    disabled when we are executing the kgdb trap so this is an acceptable
    prerequisite. This also allows us to replace raw_smp_processor_id()
    with smp_processor_id() since the short circuit logic will prevent
    warnings from PREEMPT_DEBUG.
    
    Fixes: dcc7871128e9 ("kgdb: core changes to support kdb")
    Suggested-by: Will Deacon <will@kernel.org>
    Link: https://lore.kernel.org/r/20200506164223.2875760-1-daniel.thompson@linaro.org
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index b072aeb1fd78..4d6fe87fd38f 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -323,7 +323,7 @@ extern void gdbstub_exit(int status);
 extern int			kgdb_single_step;
 extern atomic_t			kgdb_active;
 #define in_dbg_master() \
-	(raw_smp_processor_id() == atomic_read(&kgdb_active))
+	(irqs_disabled() && (smp_processor_id() == atomic_read(&kgdb_active)))
 extern bool dbg_is_early;
 extern void __init dbg_late_init(void);
 extern void kgdb_panic(const char *msg);

commit 7d92bda271ddcbb2d1be2f82733dcb9bf8378010
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed Sep 25 16:47:45 2019 -0700

    kgdb: don't use a notifier to enter kgdb at panic; call directly
    
    Right now kgdb/kdb hooks up to debug panics by registering for the panic
    notifier.  This works OK except that it means that kgdb/kdb gets called
    _after_ the CPUs in the system are taken offline.  That means that if
    anything important was happening on those CPUs (like something that might
    have contributed to the panic) you can't debug them.
    
    Specifically I ran into a case where I got a panic because a task was
    "blocked for more than 120 seconds" which was detected on CPU 2.  I nicely
    got shown stack traces in the kernel log for all CPUs including CPU 0,
    which was running 'PID: 111 Comm: kworker/0:1H' and was in the middle of
    __mmc_switch().
    
    I then ended up at the kdb prompt where switched over to kgdb to try to
    look at local variables of the process on CPU 0.  I found that I couldn't.
    Digging more, I found that I had no info on any tasks running on CPUs
    other than CPU 2 and that asking kdb for help showed me "Error: no saved
    data for this cpu".  This was because all the CPUs were offline.
    
    Let's move the entry of kdb/kgdb to a direct call from panic() and stop
    using the generic notifier.  Putting a direct call in allows us to order
    things more properly and it also doesn't seem like we're breaking any
    abstractions by calling into the debugger from the panic function.
    
    Daniel said:
    
    : This patch changes the way kdump and kgdb interact with each other.
    : However it would seem rather odd to have both tools simultaneously armed
    : and, even if they were, the user still has the option to use panic_timeout
    : to force a kdump to happen.  Thus I think the change of order is
    : acceptable.
    
    Link: http://lkml.kernel.org/r/20190703170354.217312-1-dianders@chromium.org
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Daniel Thompson <daniel.thompson@linaro.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Feng Tang <feng.tang@intel.com>
    Cc: YueHaibing <yuehaibing@huawei.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky.work@gmail.com>
    Cc: "Steven Rostedt (VMware)" <rostedt@goodmis.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index fbf144aaa749..b072aeb1fd78 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -326,8 +326,10 @@ extern atomic_t			kgdb_active;
 	(raw_smp_processor_id() == atomic_read(&kgdb_active))
 extern bool dbg_is_early;
 extern void __init dbg_late_init(void);
+extern void kgdb_panic(const char *msg);
 #else /* ! CONFIG_KGDB */
 #define in_dbg_master() (0)
 #define dbg_late_init()
+static inline void kgdb_panic(const char *msg) {}
 #endif /* ! CONFIG_KGDB */
 #endif /* _KGDB_H_ */

commit cc0282975b3f887005c380adcf0af95915f0c1bb
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Dec 6 20:07:40 2018 +0000

    kgdb/treewide: constify struct kgdb_arch arch_kgdb_ops
    
    checkpatch.pl reports the following:
    
      WARNING: struct kgdb_arch should normally be const
      #28: FILE: arch/mips/kernel/kgdb.c:397:
      +struct kgdb_arch arch_kgdb_ops = {
    
    This report makes sense, as all other ops struct, this
    one should also be const. This patch does the change.
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: x86@kernel.org
    Acked-by: Daniel Thompson <daniel.thompson@linaro.org>
    Acked-by: Paul Burton <paul.burton@mips.com>
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 24422865cd18..fbf144aaa749 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -287,7 +287,7 @@ struct kgdb_io {
 	int			is_console;
 };
 
-extern struct kgdb_arch		arch_kgdb_ops;
+extern const struct kgdb_arch		arch_kgdb_ops;
 
 extern unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs);
 

commit 3cd99ac3559855f69afbc1d5080e17eaa12394ff
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Dec 4 19:38:26 2018 -0800

    kgdb: Fix kgdb_roundup_cpus() for arches who used smp_call_function()
    
    When I had lockdep turned on and dropped into kgdb I got a nice splat
    on my system.  Specifically it hit:
      DEBUG_LOCKS_WARN_ON(current->hardirq_context)
    
    Specifically it looked like this:
      sysrq: SysRq : DEBUG
      ------------[ cut here ]------------
      DEBUG_LOCKS_WARN_ON(current->hardirq_context)
      WARNING: CPU: 0 PID: 0 at .../kernel/locking/lockdep.c:2875 lockdep_hardirqs_on+0xf0/0x160
      CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.19.0 #27
      pstate: 604003c9 (nZCv DAIF +PAN -UAO)
      pc : lockdep_hardirqs_on+0xf0/0x160
      ...
      Call trace:
       lockdep_hardirqs_on+0xf0/0x160
       trace_hardirqs_on+0x188/0x1ac
       kgdb_roundup_cpus+0x14/0x3c
       kgdb_cpu_enter+0x53c/0x5cc
       kgdb_handle_exception+0x180/0x1d4
       kgdb_compiled_brk_fn+0x30/0x3c
       brk_handler+0x134/0x178
       do_debug_exception+0xfc/0x178
       el1_dbg+0x18/0x78
       kgdb_breakpoint+0x34/0x58
       sysrq_handle_dbg+0x54/0x5c
       __handle_sysrq+0x114/0x21c
       handle_sysrq+0x30/0x3c
       qcom_geni_serial_isr+0x2dc/0x30c
      ...
      ...
      irq event stamp: ...45
      hardirqs last  enabled at (...44): [...] __do_softirq+0xd8/0x4e4
      hardirqs last disabled at (...45): [...] el1_irq+0x74/0x130
      softirqs last  enabled at (...42): [...] _local_bh_enable+0x2c/0x34
      softirqs last disabled at (...43): [...] irq_exit+0xa8/0x100
      ---[ end trace adf21f830c46e638 ]---
    
    Looking closely at it, it seems like a really bad idea to be calling
    local_irq_enable() in kgdb_roundup_cpus().  If nothing else that seems
    like it could violate spinlock semantics and cause a deadlock.
    
    Instead, let's use a private csd alongside
    smp_call_function_single_async() to round up the other CPUs.  Using
    smp_call_function_single_async() doesn't require interrupts to be
    enabled so we can remove the offending bit of code.
    
    In order to avoid duplicating this across all the architectures that
    use the default kgdb_roundup_cpus(), we'll add a "weak" implementation
    to debug_core.c.
    
    Looking at all the people who previously had copies of this code,
    there were a few variants.  I've attempted to keep the variants
    working like they used to.  Specifically:
    * For arch/arc we passed NULL to kgdb_nmicallback() instead of
      get_irq_regs().
    * For arch/mips there was a bit of extra code around
      kgdb_nmicallback()
    
    NOTE: In this patch we will still get into trouble if we try to round
    up a CPU that failed to round up before.  We'll try to round it up
    again and potentially hang when we try to grab the csd lock.  That's
    not new behavior but we'll still try to do better in a future patch.
    
    Suggested-by: Daniel Thompson <daniel.thompson@linaro.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 05e5b2eb0d32..24422865cd18 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -176,14 +176,25 @@ kgdb_arch_handle_exception(int vector, int signo, int err_code,
 			   char *remcom_out_buffer,
 			   struct pt_regs *regs);
 
+/**
+ *	kgdb_call_nmi_hook - Call kgdb_nmicallback() on the current CPU
+ *	@ignored: This parameter is only here to match the prototype.
+ *
+ *	If you're using the default implementation of kgdb_roundup_cpus()
+ *	this function will be called per CPU.  If you don't implement
+ *	kgdb_call_nmi_hook() a default will be used.
+ */
+
+extern void kgdb_call_nmi_hook(void *ignored);
+
 /**
  *	kgdb_roundup_cpus - Get other CPUs into a holding pattern
  *
  *	On SMP systems, we need to get the attention of the other CPUs
  *	and get them into a known state.  This should do what is needed
  *	to get the other CPUs to call kgdb_wait(). Note that on some arches,
- *	the NMI approach is not used for rounding up all the CPUs. For example,
- *	in case of MIPS, smp_call_function() is used to roundup CPUs.
+ *	the NMI approach is not used for rounding up all the CPUs.  Normally
+ *	those architectures can just not implement this and get the default.
  *
  *	On non-SMP systems, this is not called.
  */

commit 9ef7fa507d6b53a96de4da3298c5f01bde603c0a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Dec 4 19:38:25 2018 -0800

    kgdb: Remove irq flags from roundup
    
    The function kgdb_roundup_cpus() was passed a parameter that was
    documented as:
    
    > the flags that will be used when restoring the interrupts. There is
    > local_irq_save() call before kgdb_roundup_cpus().
    
    Nobody used those flags.  Anyone who wanted to temporarily turn on
    interrupts just did local_irq_enable() and local_irq_disable() without
    looking at them.  So we can definitely remove the flags.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index e465bb15912d..05e5b2eb0d32 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -178,21 +178,16 @@ kgdb_arch_handle_exception(int vector, int signo, int err_code,
 
 /**
  *	kgdb_roundup_cpus - Get other CPUs into a holding pattern
- *	@flags: Current IRQ state
  *
  *	On SMP systems, we need to get the attention of the other CPUs
  *	and get them into a known state.  This should do what is needed
  *	to get the other CPUs to call kgdb_wait(). Note that on some arches,
  *	the NMI approach is not used for rounding up all the CPUs. For example,
- *	in case of MIPS, smp_call_function() is used to roundup CPUs. In
- *	this case, we have to make sure that interrupts are enabled before
- *	calling smp_call_function(). The argument to this function is
- *	the flags that will be used when restoring the interrupts. There is
- *	local_irq_save() call before kgdb_roundup_cpus().
+ *	in case of MIPS, smp_call_function() is used to roundup CPUs.
  *
  *	On non-SMP systems, this is not called.
  */
-extern void kgdb_roundup_cpus(unsigned long flags);
+extern void kgdb_roundup_cpus(void);
 
 /**
  *	kgdb_arch_set_pc - Generic call back to the program counter

commit 107bcc6d566cb40184068d888637f9aefe6252dd
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 13 19:00:25 2014 -0600

    kgdb: Remove "weak" from kgdb_arch_pc() declaration
    
    kernel/debug/debug_core.c provides a default kgdb_arch_pc() definition
    explicitly marked "weak".  Several architectures provide their own
    definitions intended to override the default, but the "weak" attribute on
    the declaration applied to the arch definitions as well, so the linker
    chose one based on link order (see 10629d711ed7 ("PCI: Remove __weak
    annotation from pcibios_get_phb_of_node decl")).
    
    Remove the "weak" attribute from the declaration so we always prefer a
    non-weak definition over the weak one, independent of link order.
    
    Fixes: 688b744d8bc8 ("kgdb: fix signedness mixmatches, add statics, add declaration to header")
    Tested-by: Vineet Gupta <vgupta@synopsys.com>   # for ARC build
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Harvey Harrison <harvey.harrison@gmail.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 6b06d378f3df..e465bb15912d 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -283,7 +283,7 @@ struct kgdb_io {
 
 extern struct kgdb_arch		arch_kgdb_ops;
 
-extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
+extern unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs);
 
 #ifdef CONFIG_SERIAL_KGDB_NMI
 extern int kgdb_register_nmi_console(void);

commit fc8b13740b2978b34872650cc8e928392e3758aa
Author: Mike Travis <travis@sgi.com>
Date:   Tue Jan 14 10:25:52 2014 -0600

    kgdb/kdb: Fix no KDB config problem
    
    Some code added to the debug_core module had KDB dependencies
    that it shouldn't have.  Move the KDB dependent REASON back to
    the caller to remove the dependency in the debug core code.
    
    Update the call from the UV NMI handler to conform to the new
    interface.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Reviewed-by: Hedi Berriche <hedi@sgi.com>
    Cc: Russ Anderson <rja@sgi.com>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Link: http://lkml.kernel.org/r/20140114162551.318251993@asylum.americas.sgi.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index dfb4f2ffdaa2..6b06d378f3df 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -310,7 +310,8 @@ extern int
 kgdb_handle_exception(int ex_vector, int signo, int err_code,
 		      struct pt_regs *regs);
 extern int kgdb_nmicallback(int cpu, void *regs);
-extern int kgdb_nmicallin(int cpu, int trapnr, void *regs, atomic_t *snd_rdy);
+extern int kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,
+			  atomic_t *snd_rdy);
 extern void gdbstub_exit(int status);
 
 extern int			kgdb_single_step;

commit 8daaa5f8261bffd2f6217a960f9182d0503a5c44
Author: Mike Travis <travis@sgi.com>
Date:   Wed Oct 2 10:14:18 2013 -0500

    kdb: Add support for external NMI handler to call KGDB/KDB
    
    This patch adds a kgdb_nmicallin() interface that can be used by
    external NMI handlers to call the KGDB/KDB handler.  The primary
    need for this is for those types of NMI interrupts where all the
    CPUs have already received the NMI signal.  Therefore no
    send_IPI(NMI) is required, and in fact it will cause a 2nd
    unhandled NMI to occur. This generates the "Dazed and Confuzed"
    messages.
    
    Since all the CPUs are getting the NMI at roughly the same time,
    it's not guaranteed that the first CPU that hits the NMI handler
    will manage to enter KGDB and set the dbg_master_lock before the
    slaves start entering. The new argument "send_ready" was added
    for KGDB to signal the NMI handler to release the slave CPUs for
    entry into KGDB.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Reviewed-by: Dimitri Sivanich <sivanich@sgi.com>
    Reviewed-by: Hedi Berriche <hedi@sgi.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Link: http://lkml.kernel.org/r/20131002151417.928886849@asylum.americas.sgi.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index c6e091bf39a5..dfb4f2ffdaa2 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -310,6 +310,7 @@ extern int
 kgdb_handle_exception(int ex_vector, int signo, int err_code,
 		      struct pt_regs *regs);
 extern int kgdb_nmicallback(int cpu, void *regs);
+extern int kgdb_nmicallin(int cpu, int trapnr, void *regs, atomic_t *snd_rdy);
 extern void gdbstub_exit(int status);
 
 extern int			kgdb_single_step;

commit 16559ae48c76f1ceb970b9719dea62b77eb5d06b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 4 15:35:26 2013 -0800

    kgdb: remove #include <linux/serial_8250.h> from kgdb.h
    
    There's no reason kgdb.h itself needs to include the 8250 serial port
    header file.  So push it down to the _very_ limited number of individual
    drivers that need the values in that file, and fix up the places where
    people really wanted serial_core.h and platform_device.h.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 4dff0c6ed58f..c6e091bf39a5 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -13,7 +13,6 @@
 #ifndef _KGDB_H_
 #define _KGDB_H_
 
-#include <linux/serial_8250.h>
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <linux/atomic.h>

commit 0c57dfcc6c1d037243c2f8fbf62eab3633326ec0
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Sep 24 14:27:56 2012 -0700

    tty/serial: Add kgdb_nmi driver
    
    This special driver makes it possible to temporary use NMI debugger port
    as a normal console by issuing 'nmi_console' command (assuming that the
    port is attached to KGDB).
    
    Unlike KDB's disable_nmi command, with this driver you are always able
    to go back to the debugger using KGDB escape sequence ($3#33).  This is
    because this console driver processes the input in NMI context, and thus
    is able to intercept the magic sequence.
    
    Note that since the console interprets input and uses polling
    communication methods, for things like PPP it is still better to fully
    detach debugger port from the KGDB NMI (i.e. disable_nmi), and use raw
    console.
    
    Usually, to enter the debugger one have to type the magic sequence, so
    initially the kernel will print the following prompt on the NMI debugger
    console:
    
            Type $3#33 to enter the debugger>
    
    For convenience, there is a kgdb_fiq.knock kernel command line option,
    when set to 0, this turns the special command to just a return key
    press, so the kernel will be printing this:
    
            Hit <return> to enter the debugger>
    
    This is more convenient for long debugging sessions, although it makes
    nmi_console feature somewhat useless.
    
    And for the cases when NMI connected to a dedicated button, the knocking
    can be disabled altogether by setting kgdb_fiq.knock to -1.
    
    Suggested-by: Colin Cross <ccross@android.com>
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 7800cce284db..4dff0c6ed58f 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -286,6 +286,16 @@ extern struct kgdb_arch		arch_kgdb_ops;
 
 extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
 
+#ifdef CONFIG_SERIAL_KGDB_NMI
+extern int kgdb_register_nmi_console(void);
+extern int kgdb_unregister_nmi_console(void);
+extern bool kgdb_nmi_poll_knock(void);
+#else
+static inline int kgdb_register_nmi_console(void) { return 0; }
+static inline int kgdb_unregister_nmi_console(void) { return 0; }
+static inline bool kgdb_nmi_poll_knock(void) { return 1; }
+#endif
+
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern struct kgdb_io *dbg_io_ops;

commit 5a14fead07bcf4e0acc877a8d9e1d1f40a441153
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Sep 24 14:27:50 2012 -0700

    kernel/debug: Mask KGDB NMI upon entry
    
    The new arch callback should manage NMIs that usually cause KGDB to
    enter. That is, not all NMIs should be enabled/disabled, but only
    those that issue kgdb_handle_exception().
    
    We must mask it as serial-line interrupt can be used as an NMI, so
    if the original KGDB-entry cause was say a breakpoint, then every
    input to KDB console will cause KGDB to reenter, which we don't want.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index c4d2fc194ede..7800cce284db 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -240,6 +240,7 @@ extern void kgdb_arch_late(void);
  * hardware breakpoints.
  * @correct_hw_break: Allow an architecture to specify how to correct the
  * hardware debug registers.
+ * @enable_nmi: Manage NMI-triggered entry to KGDB
  */
 struct kgdb_arch {
 	unsigned char		gdb_bpt_instr[BREAK_INSTR_SIZE];
@@ -252,6 +253,8 @@ struct kgdb_arch {
 	void	(*disable_hw_break)(struct pt_regs *regs);
 	void	(*remove_all_hw_break)(void);
 	void	(*correct_hw_break)(void);
+
+	void	(*enable_nmi)(bool on);
 };
 
 /**

commit 3751d3e85cf693e10e2c47c03c8caa65e171099b
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri Mar 23 09:35:05 2012 -0500

    x86,kgdb: Fix DEBUG_RODATA limitation using text_poke()
    
    There has long been a limitation using software breakpoints with a
    kernel compiled with CONFIG_DEBUG_RODATA going back to 2.6.26. For
    this particular patch, it will apply cleanly and has been tested all
    the way back to 2.6.36.
    
    The kprobes code uses the text_poke() function which accommodates
    writing a breakpoint into a read-only page.  The x86 kgdb code can
    solve the problem similarly by overriding the default breakpoint
    set/remove routines and using text_poke() directly.
    
    The x86 kgdb code will first attempt to use the traditional
    probe_kernel_write(), and next try using a the text_poke() function.
    The break point install method is tracked such that the correct break
    point removal routine will get called later on.
    
    Cc: x86@kernel.org
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: stable@vger.kernel.org # >= 2.6.36
    Inspried-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index e5d689c1d774..c4d2fc194ede 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -63,7 +63,8 @@ enum kgdb_bptype {
 	BP_HARDWARE_BREAKPOINT,
 	BP_WRITE_WATCHPOINT,
 	BP_READ_WATCHPOINT,
-	BP_ACCESS_WATCHPOINT
+	BP_ACCESS_WATCHPOINT,
+	BP_POKE_BREAKPOINT,
 };
 
 enum kgdb_bpstate {

commit 98b54aa1a2241b59372468bd1e9c2d207bdba54b
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Wed Mar 21 10:17:03 2012 -0500

    kgdb,debug_core: pass the breakpoint struct instead of address and memory
    
    There is extra state information that needs to be exposed in the
    kgdb_bpt structure for tracking how a breakpoint was installed.  The
    debug_core only uses the the probe_kernel_write() to install
    breakpoints, but this is not enough for all the archs.  Some arch such
    as x86 need to use text_poke() in order to install a breakpoint into a
    read only page.
    
    Passing the kgdb_bpt structure to kgdb_arch_set_breakpoint() and
    kgdb_arch_remove_breakpoint() allows other archs to set the type
    variable which indicates how the breakpoint was installed.
    
    Cc: stable@vger.kernel.org # >= 2.6.36
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index fa391835508d..e5d689c1d774 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -207,8 +207,8 @@ extern void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc);
 
 /* Optional functions. */
 extern int kgdb_validate_break_address(unsigned long addr);
-extern int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr);
-extern int kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle);
+extern int kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt);
+extern int kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt);
 
 /**
  *	kgdb_arch_late - Perform any architecture specific initalization.

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 10ca03d0a250..fa391835508d 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -16,7 +16,7 @@
 #include <linux/serial_8250.h>
 #include <linux/linkage.h>
 #include <linux/init.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #ifdef CONFIG_HAVE_ARCH_KGDB
 #include <asm/kgdb.h>
 #endif

commit d57f078b193981d1b7d24193f3118c6b806db0ff
Author: David Howells <dhowells@redhat.com>
Date:   Fri Mar 18 16:54:31 2011 +0000

    KGDB: Notify GDB of machine halt, reboot or power off
    
    Notify GDB of the machine halting, rebooting or powering off by sending it an
    exited command (remote protocol command 'W').  This is done by calling:
    
            void gdbstub_exit(int status)
    
    from the arch's machine_{halt,restart,power_off}() functions with an
    appropriate exit status to be reported to GDB.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 092e4250a458..10ca03d0a250 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -297,6 +297,7 @@ extern int
 kgdb_handle_exception(int ex_vector, int signo, int err_code,
 		      struct pt_regs *regs);
 extern int kgdb_nmicallback(int cpu, void *regs);
+extern void gdbstub_exit(int status);
 
 extern int			kgdb_single_step;
 extern atomic_t			kgdb_active;

commit d7ba979d45272385ce0fdf141d922e61ff48e07b
Author: Dongdong Deng <dongdong.deng@windriver.com>
Date:   Wed Aug 18 06:02:00 2010 -0500

    debug_core,x86,blackfin: Clean up hw debug disable API
    
    The kgdb_disable_hw_debug() was an architecture specific function for
    disabling all hardware breakpoints on a per cpu basis when entering
    the debug core.
    
    This patch will remove the weak function kdbg_disable_hw_debug() and
    change it into a call back which lives with the rest of hw breakpoint
    call backs in struct kgdb_arch.
    
    Signed-off-by: Dongdong Deng <dongdong.deng@windriver.com>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index cc96f0f23e04..092e4250a458 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -35,16 +35,6 @@ struct pt_regs;
  */
 extern int kgdb_skipexception(int exception, struct pt_regs *regs);
 
-/**
- *	kgdb_disable_hw_debug - (optional) Disable hardware debugging hook
- *	@regs: Current &struct pt_regs.
- *
- *	This function will be called if the particular architecture must
- *	disable hardware debugging while it is processing gdb packets or
- *	handling exception.
- */
-extern void kgdb_disable_hw_debug(struct pt_regs *regs);
-
 struct tasklet_struct;
 struct task_struct;
 struct uart_port;
@@ -243,6 +233,8 @@ extern void kgdb_arch_late(void);
  * breakpoint.
  * @remove_hw_breakpoint: Allow an architecture to specify how to remove a
  * hardware breakpoint.
+ * @disable_hw_break: Allow an architecture to specify how to disable
+ * hardware breakpoints for a single cpu.
  * @remove_all_hw_break: Allow an architecture to specify how to remove all
  * hardware breakpoints.
  * @correct_hw_break: Allow an architecture to specify how to correct the
@@ -256,6 +248,7 @@ struct kgdb_arch {
 	int	(*remove_breakpoint)(unsigned long, char *);
 	int	(*set_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
 	int	(*remove_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
+	void	(*disable_hw_break)(struct pt_regs *regs);
 	void	(*remove_all_hw_break)(void);
 	void	(*correct_hw_break)(void);
 };

commit 55751145dc1e08e16df418cdd101661f5c6ac991
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Aug 5 09:22:21 2010 -0500

    gdbstub: Implement gdbserial 'p' and 'P' packets
    
    The gdbserial 'p' and 'P' packets allow gdb to individually get and
    set registers instead of querying for all the available registers.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index d5eb882e01f3..cc96f0f23e04 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -294,7 +294,7 @@ extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern struct kgdb_io *dbg_io_ops;
 
 extern int kgdb_hex2long(char **ptr, unsigned long *long_val);
-extern int kgdb_mem2hex(char *mem, char *buf, int count);
+extern char *kgdb_mem2hex(char *mem, char *buf, int count);
 extern int kgdb_hex2mem(char *buf, char *mem, int count);
 
 extern int kgdb_isremovedbreak(unsigned long addr);

commit 534af1082329392bc29f6badf815e69ae2ae0f4c
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Aug 5 09:22:20 2010 -0500

    kgdb,kdb: individual register set and and get API
    
    The kdb shell specification includes the ability to get and set
    architecture specific registers by name.
    
    For the time being individual register get and set will be implemented
    on a per architecture basis.  If an architecture defines
    DBG_MAX_REG_NUM > 0 then kdb and the gdbstub will use the capability
    for individually getting and setting architecture specific registers.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 9340f34d1bb5..d5eb882e01f3 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -90,6 +90,19 @@ struct kgdb_bkpt {
 	enum kgdb_bpstate	state;
 };
 
+struct dbg_reg_def_t {
+	char *name;
+	int size;
+	int offset;
+};
+
+#ifndef DBG_MAX_REG_NUM
+#define DBG_MAX_REG_NUM 0
+#else
+extern struct dbg_reg_def_t dbg_reg_def[];
+extern char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs);
+extern int dbg_set_reg(int regno, void *mem, struct pt_regs *regs);
+#endif
 #ifndef KGDB_MAX_BREAKPOINTS
 # define KGDB_MAX_BREAKPOINTS	1000
 #endif

commit 0b4b3827db386ec6034a5aba1261025b039440c2
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:29 2010 -0500

    x86, kgdb, init: Add early and late debug states
    
    The kernel debugger can operate well before mm_init(), but the x86
    hardware breakpoint code which uses the perf api requires that the
    kernel allocators are initialized.
    
    This means the kernel debug core needs to provide an optional arch
    specific call back to allow the initialization functions to run after
    the kernel has been further initialized.
    
    The kdb shell already had a similar restriction with an early
    initialization and late initialization.  The kdb_init() was moved into
    the debug core's version of the late init which is called
    dbg_late_init();
    
    CC: kgdb-bugreport@lists.sourceforge.net
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 6c784ab6856a..9340f34d1bb5 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -207,6 +207,17 @@ extern int kgdb_validate_break_address(unsigned long addr);
 extern int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr);
 extern int kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle);
 
+/**
+ *	kgdb_arch_late - Perform any architecture specific initalization.
+ *
+ *	This function will handle the late initalization of any
+ *	architecture specific callbacks.  This is an optional function for
+ *	handling things like late initialization of hw breakpoints.  The
+ *	default implementation does nothing.
+ */
+extern void kgdb_arch_late(void);
+
+
 /**
  * struct kgdb_arch - Describe architecture specific values.
  * @gdb_bpt_instr: The instruction to trigger a breakpoint.
@@ -285,7 +296,10 @@ extern int			kgdb_single_step;
 extern atomic_t			kgdb_active;
 #define in_dbg_master() \
 	(raw_smp_processor_id() == atomic_read(&kgdb_active))
+extern bool dbg_is_early;
+extern void __init dbg_late_init(void);
 #else /* ! CONFIG_KGDB */
 #define in_dbg_master() (0)
+#define dbg_late_init()
 #endif /* ! CONFIG_KGDB */
 #endif /* _KGDB_H_ */

commit efe2f29e324fd20e0449bcd6dc6dbe4734c2ba94
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:26 2010 -0500

    kgdboc,kdb: Allow kdb to work on a non open console port
    
    If kdb is open on a serial port that is not actually a console make
    sure to call the poll routines to emit and receive characters.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Martin Hicks <mort@sgi.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index ee007ea341b8..6c784ab6856a 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -247,6 +247,8 @@ struct kgdb_arch {
  * the I/O driver.
  * @post_exception: Pointer to a function that will do any cleanup work
  * for the I/O driver.
+ * @is_console: 1 if the end device is a console 0 if the I/O device is
+ * not a console
  */
 struct kgdb_io {
 	const char		*name;
@@ -256,6 +258,7 @@ struct kgdb_io {
 	int			(*init) (void);
 	void			(*pre_exception) (void);
 	void			(*post_exception) (void);
+	int			is_console;
 };
 
 extern struct kgdb_arch		arch_kgdb_ops;

commit 1cee5e35f15d0893be1ba944f1aec8676e43ab76
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Wed Jun 3 14:06:57 2009 -0500

    kgdb: Add the ability to schedule a breakpoint via a tasklet
    
    Some kgdb I/O modules require the ability to create a breakpoint
    tasklet, such as kgdboc and external modules such as kgdboe.  The
    breakpoint tasklet is used as an asynchronous entry point into the
    debugger which will have a different function scope than the current
    execution path where it might not be safe to have an inline
    breakpoint.  This is true of some of the kgdb I/O drivers which share
    code with kgdb and rest of the kernel users.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 19d1b29a2694..ee007ea341b8 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -271,6 +271,7 @@ extern int kgdb_mem2hex(char *mem, char *buf, int count);
 extern int kgdb_hex2mem(char *buf, char *mem, int count);
 
 extern int kgdb_isremovedbreak(unsigned long addr);
+extern void kgdb_schedule_breakpoint(void);
 
 extern int
 kgdb_handle_exception(int ex_vector, int signo, int err_code,

commit f503b5ae53cb557ac351a668fcac1baab1cef0db
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:25 2010 -0500

    x86,kgdb: Add low level debug hook
    
    The only way the debugger can handle a trap in inside rcu_lock,
    notify_die, or atomic_notifier_call_chain without a triple fault is
    to have a low level "first opportunity handler" in the int3 exception
    handler.
    
    Generally this will be something the vast majority of folks will not
    need, but for those who need it, it is added as a kernel .config
    option called KGDB_LOW_LEVEL_TRAP.
    
    CC: Ingo Molnar <mingo@elte.hu>
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: H. Peter Anvin <hpa@zytor.com>
    CC: x86@kernel.org
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 406f6f9286f3..19d1b29a2694 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -60,6 +60,7 @@ struct uart_port;
 void kgdb_breakpoint(void);
 
 extern int kgdb_connected;
+extern int kgdb_io_module_registered;
 
 extern atomic_t			kgdb_setting_breakpoint;
 extern atomic_t			kgdb_cpu_doing_single_step;

commit 98ec1878cacb393975cba64f7392eece81716cb4
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon Apr 27 10:58:06 2009 -0500

    kgdb: remove post_primary_code references
    
    Remove all the references to the kgdb_post_primary_code.  This
    function serves no useful purpose because you can obtain the same
    information from the "struct kgdb_state *ks" from with in the
    debugger, if for some reason you want the data.
    
    Also remove the unintentional duplicate assignment for ks->ex_vector.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 407edb1e0c4d..406f6f9286f3 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -35,20 +35,6 @@ struct pt_regs;
  */
 extern int kgdb_skipexception(int exception, struct pt_regs *regs);
 
-/**
- *	kgdb_post_primary_code - (optional) Save error vector/code numbers.
- *	@regs: Original pt_regs.
- *	@e_vector: Original error vector.
- *	@err_code: Original error code.
- *
- *	This is usually needed on architectures which support SMP and
- *	KGDB.  This function is called after all the secondary cpus have
- *	been put to a know spin state and the primary CPU has control over
- *	KGDB.
- */
-extern void kgdb_post_primary_code(struct pt_regs *regs, int e_vector,
-				  int err_code);
-
 /**
  *	kgdb_disable_hw_debug - (optional) Disable hardware debugging hook
  *	@regs: Current &struct pt_regs.

commit 84c08fd61e2d21702337e9fe366e97cdf09bf797
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:24 2010 -0500

    kgdb,docs: Update the kgdb docs to include kdb
    
    Update the kgdb docs to reflect the new directory structure and API.
    
    Merge in the kdb shell information.
    
    [Randy Dunlap <rdunlap@xenotime.net>: grammatical corrections]
    
    CC: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 5b37df00000d..407edb1e0c4d 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -204,6 +204,17 @@ kgdb_arch_handle_exception(int vector, int signo, int err_code,
  */
 extern void kgdb_roundup_cpus(unsigned long flags);
 
+/**
+ *	kgdb_arch_set_pc - Generic call back to the program counter
+ *	@regs: Current &struct pt_regs.
+ *  @pc: The new value for the program counter
+ *
+ *	This function handles updating the program counter and requires an
+ *	architecture specific implementation.
+ */
+extern void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc);
+
+
 /* Optional functions. */
 extern int kgdb_validate_break_address(unsigned long addr);
 extern int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr);
@@ -264,7 +275,6 @@ extern struct kgdb_arch		arch_kgdb_ops;
 
 extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
 
-extern void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc);
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern struct kgdb_io *dbg_io_ops;

commit dcc7871128e99458ca86186b7bc8bf27ff0c47b5
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:21 2010 -0500

    kgdb: core changes to support kdb
    
    These are the minimum changes to the kgdb core in order to enable an
    API to connect a new front end (kdb) to the debug core.
    
    This patch introduces the dbg_kdb_mode variable controls where the
    user level I/O is routed.  It will be routed to the gdbstub (kgdb) or
    to the kdb front end which is a simple shell available over the kgdboc
    connection.
    
    You can switch back and forth between kdb or the gdb stub mode of
    operation dynamically.  From gdb stub mode you can blindly type
    "$3#33", or from the kdb mode you can enter "kgdb" to switch to the
    gdb stub.
    
    The logic in the debug core depends on kdb to look for the typical gdb
    connection sequences and return immediately with KGDB_PASS_EVENT if a
    gdb serial command sequence is detected.  That should allow a
    reasonably seamless transition between kdb -> gdb without leaving the
    kernel exception state.  The two gdb serial queries that kdb is
    responsible for detecting are the "?" and "qSupported" packets.
    
    CC: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Martin Hicks <mort@sgi.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 4830142ec339..5b37df00000d 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -16,10 +16,12 @@
 #include <linux/serial_8250.h>
 #include <linux/linkage.h>
 #include <linux/init.h>
-
 #include <asm/atomic.h>
+#ifdef CONFIG_HAVE_ARCH_KGDB
 #include <asm/kgdb.h>
+#endif
 
+#ifdef CONFIG_KGDB
 struct pt_regs;
 
 /**
@@ -262,6 +264,7 @@ extern struct kgdb_arch		arch_kgdb_ops;
 
 extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
 
+extern void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc);
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern struct kgdb_io *dbg_io_ops;
@@ -279,5 +282,9 @@ extern int kgdb_nmicallback(int cpu, void *regs);
 
 extern int			kgdb_single_step;
 extern atomic_t			kgdb_active;
-
+#define in_dbg_master() \
+	(raw_smp_processor_id() == atomic_read(&kgdb_active))
+#else /* ! CONFIG_KGDB */
+#define in_dbg_master() (0)
+#endif /* ! CONFIG_KGDB */
 #endif /* _KGDB_H_ */

commit 53197fc49549240f6c6a963b2713a4cd9517964b
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri Apr 2 11:48:03 2010 -0500

    Separate the gdbstub from the debug core
    
    Split the former kernel/kgdb.c into debug_core.c which contains the
    kernel debugger exception logic and to the gdbstub.c which contains
    the logic for allowing gdb to talk to the debug core.
    
    This also created a private include file called debug_core.h which
    contains all the definitions to glue the debug_core to any other
    debugger connections.
    
    CC: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 19ec41a183f5..4830142ec339 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -264,6 +264,7 @@ extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
 
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
+extern struct kgdb_io *dbg_io_ops;
 
 extern int kgdb_hex2long(char **ptr, unsigned long *long_val);
 extern int kgdb_mem2hex(char *mem, char *buf, int count);

commit b11e1eca7ed9c0b5dab21a62c11acc711d9bdda0
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Jan 7 11:58:37 2010 -0600

    kgdb: Fix kernel-doc format error in kgdb.h
    
    linux-next-20081022//include/linux/kgdb.h:308): duplicate section name 'Description'
    
    and fix typos in that file's kernel-doc comments.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 6adcc297e354..19ec41a183f5 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -29,8 +29,7 @@ struct pt_regs;
  *
  *	On some architectures it is required to skip a breakpoint
  *	exception when it occurs after a breakpoint has been removed.
- *	This can be implemented in the architecture specific portion of
- *	for kgdb.
+ *	This can be implemented in the architecture specific portion of kgdb.
  */
 extern int kgdb_skipexception(int exception, struct pt_regs *regs);
 
@@ -65,7 +64,7 @@ struct uart_port;
 /**
  *	kgdb_breakpoint - compiled in breakpoint
  *
- *	This will be impelmented a static inline per architecture.  This
+ *	This will be implemented as a static inline per architecture.  This
  *	function is called by the kgdb core to execute an architecture
  *	specific trap to cause kgdb to enter the exception processing.
  *
@@ -190,7 +189,7 @@ kgdb_arch_handle_exception(int vector, int signo, int err_code,
  *	@flags: Current IRQ state
  *
  *	On SMP systems, we need to get the attention of the other CPUs
- *	and get them be in a known state.  This should do what is needed
+ *	and get them into a known state.  This should do what is needed
  *	to get the other CPUs to call kgdb_wait(). Note that on some arches,
  *	the NMI approach is not used for rounding up all the CPUs. For example,
  *	in case of MIPS, smp_call_function() is used to roundup CPUs. In

commit 688b744d8bc84dc5cc646e97509113dc5e8818ed
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Apr 24 16:57:23 2008 -0500

    kgdb: fix signedness mixmatches, add statics, add declaration to header
    
    Noticed by sparse:
    arch/x86/kernel/kgdb.c:556:15: warning: symbol 'kgdb_arch_pc' was not declared. Should it be static?
    kernel/kgdb.c:149:8: warning: symbol 'kgdb_do_roundup' was not declared. Should it be static?
    kernel/kgdb.c:193:22: warning: symbol 'kgdb_arch_pc' was not declared. Should it be static?
    kernel/kgdb.c:712:5: warning: symbol 'remove_all_break' was not declared. Should it be static?
    
    Related to kgdb_hex2long:
    arch/x86/kernel/kgdb.c:371:28: warning: incorrect type in argument 2 (different signedness)
    arch/x86/kernel/kgdb.c:371:28:    expected long *long_val
    arch/x86/kernel/kgdb.c:371:28:    got unsigned long *<noident>
    kernel/kgdb.c:469:27: warning: incorrect type in argument 2 (different signedness)
    kernel/kgdb.c:469:27:    expected long *long_val
    kernel/kgdb.c:469:27:    got unsigned long *<noident>
    kernel/kgdb.c:470:27: warning: incorrect type in argument 2 (different signedness)
    kernel/kgdb.c:470:27:    expected long *long_val
    kernel/kgdb.c:470:27:    got unsigned long *<noident>
    kernel/kgdb.c:894:27: warning: incorrect type in argument 2 (different signedness)
    kernel/kgdb.c:894:27:    expected long *long_val
    kernel/kgdb.c:894:27:    got unsigned long *<noident>
    kernel/kgdb.c:895:27: warning: incorrect type in argument 2 (different signedness)
    kernel/kgdb.c:895:27:    expected long *long_val
    kernel/kgdb.c:895:27:    got unsigned long *<noident>
    kernel/kgdb.c:1127:28: warning: incorrect type in argument 2 (different signedness)
    kernel/kgdb.c:1127:28:    expected long *long_val
    kernel/kgdb.c:1127:28:    got unsigned long *<noident>
    kernel/kgdb.c:1132:25: warning: incorrect type in argument 2 (different signedness)
    kernel/kgdb.c:1132:25:    expected long *long_val
    kernel/kgdb.c:1132:25:    got unsigned long *<noident>
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index 9757b1a6d9dc..6adcc297e354 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -261,10 +261,12 @@ struct kgdb_io {
 
 extern struct kgdb_arch		arch_kgdb_ops;
 
+extern unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs);
+
 extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
 extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
 
-extern int kgdb_hex2long(char **ptr, long *long_val);
+extern int kgdb_hex2long(char **ptr, unsigned long *long_val);
 extern int kgdb_mem2hex(char *mem, char *buf, int count);
 extern int kgdb_hex2mem(char *buf, char *mem, int count);
 

commit e3e2aaf7dc0d82a055e084cfd48b9257c0c66b68
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Mar 20 13:43:45 2008 -0500

    kgdb: add documentation
    
    Add in the kgdb documentation for kgdb.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
index b0985b79b638..9757b1a6d9dc 100644
--- a/include/linux/kgdb.h
+++ b/include/linux/kgdb.h
@@ -22,31 +22,34 @@
 
 struct pt_regs;
 
-/*
- *	kgdb_skipexception - Bail out of KGDB when we've been triggered.
+/**
+ *	kgdb_skipexception - (optional) exit kgdb_handle_exception early
  *	@exception: Exception vector number
  *	@regs: Current &struct pt_regs.
  *
- *	On some architectures we need to skip a breakpoint exception when
- *	it occurs after a breakpoint has been removed.
+ *	On some architectures it is required to skip a breakpoint
+ *	exception when it occurs after a breakpoint has been removed.
+ *	This can be implemented in the architecture specific portion of
+ *	for kgdb.
  */
 extern int kgdb_skipexception(int exception, struct pt_regs *regs);
 
-/*
- *	kgdb_post_primary_code - Save error vector/code numbers.
+/**
+ *	kgdb_post_primary_code - (optional) Save error vector/code numbers.
  *	@regs: Original pt_regs.
  *	@e_vector: Original error vector.
  *	@err_code: Original error code.
  *
- *	This is needed on architectures which support SMP and KGDB.
- *	This function is called after all the secondary cpus have been put
- *	to a know spin state and the primary CPU has control over KGDB.
+ *	This is usually needed on architectures which support SMP and
+ *	KGDB.  This function is called after all the secondary cpus have
+ *	been put to a know spin state and the primary CPU has control over
+ *	KGDB.
  */
 extern void kgdb_post_primary_code(struct pt_regs *regs, int e_vector,
 				  int err_code);
 
-/*
- *	kgdb_disable_hw_debug - Disable hardware debugging while we in kgdb.
+/**
+ *	kgdb_disable_hw_debug - (optional) Disable hardware debugging hook
  *	@regs: Current &struct pt_regs.
  *
  *	This function will be called if the particular architecture must
@@ -59,7 +62,14 @@ struct tasklet_struct;
 struct task_struct;
 struct uart_port;
 
-/* To enter the debugger explicitly. */
+/**
+ *	kgdb_breakpoint - compiled in breakpoint
+ *
+ *	This will be impelmented a static inline per architecture.  This
+ *	function is called by the kgdb core to execute an architecture
+ *	specific trap to cause kgdb to enter the exception processing.
+ *
+ */
 void kgdb_breakpoint(void);
 
 extern int kgdb_connected;
@@ -102,7 +112,7 @@ struct kgdb_bkpt {
  * Functions each KGDB-supporting architecture must provide:
  */
 
-/*
+/**
  *	kgdb_arch_init - Perform any architecture specific initalization.
  *
  *	This function will handle the initalization of any architecture
@@ -110,7 +120,7 @@ struct kgdb_bkpt {
  */
 extern int kgdb_arch_init(void);
 
-/*
+/**
  *	kgdb_arch_exit - Perform any architecture specific uninitalization.
  *
  *	This function will handle the uninitalization of any architecture
@@ -118,7 +128,7 @@ extern int kgdb_arch_init(void);
  */
 extern void kgdb_arch_exit(void);
 
-/*
+/**
  *	pt_regs_to_gdb_regs - Convert ptrace regs to GDB regs
  *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
  *	@regs: The &struct pt_regs of the current process.
@@ -128,7 +138,7 @@ extern void kgdb_arch_exit(void);
  */
 extern void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);
 
-/*
+/**
  *	sleeping_thread_to_gdb_regs - Convert ptrace regs to GDB regs
  *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
  *	@p: The &struct task_struct of the desired process.
@@ -143,7 +153,7 @@ extern void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);
 extern void
 sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p);
 
-/*
+/**
  *	gdb_regs_to_pt_regs - Convert GDB regs to ptrace regs.
  *	@gdb_regs: A pointer to hold the registers we've received from GDB.
  *	@regs: A pointer to a &struct pt_regs to hold these values in.
@@ -153,7 +163,7 @@ sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p);
  */
 extern void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs);
 
-/*
+/**
  *	kgdb_arch_handle_exception - Handle architecture specific GDB packets.
  *	@vector: The error vector of the exception that happened.
  *	@signo: The signal number of the exception that happened.
@@ -175,7 +185,7 @@ kgdb_arch_handle_exception(int vector, int signo, int err_code,
 			   char *remcom_out_buffer,
 			   struct pt_regs *regs);
 
-/*
+/**
  *	kgdb_roundup_cpus - Get other CPUs into a holding pattern
  *	@flags: Current IRQ state
  *
@@ -198,7 +208,7 @@ extern int kgdb_validate_break_address(unsigned long addr);
 extern int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr);
 extern int kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle);
 
-/*
+/**
  * struct kgdb_arch - Describe architecture specific values.
  * @gdb_bpt_instr: The instruction to trigger a breakpoint.
  * @flags: Flags for the breakpoint, currently just %KGDB_HW_BREAKPOINT.
@@ -227,7 +237,7 @@ struct kgdb_arch {
 	void	(*correct_hw_break)(void);
 };
 
-/*
+/**
  * struct kgdb_io - Describe the interface for an I/O driver to talk with KGDB.
  * @name: Name of the I/O driver.
  * @read_char: Pointer to a function that will return one char.

commit dc7d552705215ac50a0617fcf51bb9c736255b8e
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Apr 17 20:05:37 2008 +0200

    kgdb: core
    
    kgdb core code. Handles the protocol and the arch details.
    
    [ mingo@elte.hu: heavily modified, simplified and cleaned up. ]
    [ xemul@openvz.org: use find_task_by_pid_ns ]
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jan Kiszka <jan.kiszka@web.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/kgdb.h b/include/linux/kgdb.h
new file mode 100644
index 000000000000..b0985b79b638
--- /dev/null
+++ b/include/linux/kgdb.h
@@ -0,0 +1,271 @@
+/*
+ * This provides the callbacks and functions that KGDB needs to share between
+ * the core, I/O and arch-specific portions.
+ *
+ * Author: Amit Kale <amitkale@linsyssoft.com> and
+ *         Tom Rini <trini@kernel.crashing.org>
+ *
+ * 2001-2004 (c) Amit S. Kale and 2003-2005 (c) MontaVista Software, Inc.
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#ifndef _KGDB_H_
+#define _KGDB_H_
+
+#include <linux/serial_8250.h>
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+#include <asm/atomic.h>
+#include <asm/kgdb.h>
+
+struct pt_regs;
+
+/*
+ *	kgdb_skipexception - Bail out of KGDB when we've been triggered.
+ *	@exception: Exception vector number
+ *	@regs: Current &struct pt_regs.
+ *
+ *	On some architectures we need to skip a breakpoint exception when
+ *	it occurs after a breakpoint has been removed.
+ */
+extern int kgdb_skipexception(int exception, struct pt_regs *regs);
+
+/*
+ *	kgdb_post_primary_code - Save error vector/code numbers.
+ *	@regs: Original pt_regs.
+ *	@e_vector: Original error vector.
+ *	@err_code: Original error code.
+ *
+ *	This is needed on architectures which support SMP and KGDB.
+ *	This function is called after all the secondary cpus have been put
+ *	to a know spin state and the primary CPU has control over KGDB.
+ */
+extern void kgdb_post_primary_code(struct pt_regs *regs, int e_vector,
+				  int err_code);
+
+/*
+ *	kgdb_disable_hw_debug - Disable hardware debugging while we in kgdb.
+ *	@regs: Current &struct pt_regs.
+ *
+ *	This function will be called if the particular architecture must
+ *	disable hardware debugging while it is processing gdb packets or
+ *	handling exception.
+ */
+extern void kgdb_disable_hw_debug(struct pt_regs *regs);
+
+struct tasklet_struct;
+struct task_struct;
+struct uart_port;
+
+/* To enter the debugger explicitly. */
+void kgdb_breakpoint(void);
+
+extern int kgdb_connected;
+
+extern atomic_t			kgdb_setting_breakpoint;
+extern atomic_t			kgdb_cpu_doing_single_step;
+
+extern struct task_struct	*kgdb_usethread;
+extern struct task_struct	*kgdb_contthread;
+
+enum kgdb_bptype {
+	BP_BREAKPOINT = 0,
+	BP_HARDWARE_BREAKPOINT,
+	BP_WRITE_WATCHPOINT,
+	BP_READ_WATCHPOINT,
+	BP_ACCESS_WATCHPOINT
+};
+
+enum kgdb_bpstate {
+	BP_UNDEFINED = 0,
+	BP_REMOVED,
+	BP_SET,
+	BP_ACTIVE
+};
+
+struct kgdb_bkpt {
+	unsigned long		bpt_addr;
+	unsigned char		saved_instr[BREAK_INSTR_SIZE];
+	enum kgdb_bptype	type;
+	enum kgdb_bpstate	state;
+};
+
+#ifndef KGDB_MAX_BREAKPOINTS
+# define KGDB_MAX_BREAKPOINTS	1000
+#endif
+
+#define KGDB_HW_BREAKPOINT	1
+
+/*
+ * Functions each KGDB-supporting architecture must provide:
+ */
+
+/*
+ *	kgdb_arch_init - Perform any architecture specific initalization.
+ *
+ *	This function will handle the initalization of any architecture
+ *	specific callbacks.
+ */
+extern int kgdb_arch_init(void);
+
+/*
+ *	kgdb_arch_exit - Perform any architecture specific uninitalization.
+ *
+ *	This function will handle the uninitalization of any architecture
+ *	specific callbacks, for dynamic registration and unregistration.
+ */
+extern void kgdb_arch_exit(void);
+
+/*
+ *	pt_regs_to_gdb_regs - Convert ptrace regs to GDB regs
+ *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
+ *	@regs: The &struct pt_regs of the current process.
+ *
+ *	Convert the pt_regs in @regs into the format for registers that
+ *	GDB expects, stored in @gdb_regs.
+ */
+extern void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs);
+
+/*
+ *	sleeping_thread_to_gdb_regs - Convert ptrace regs to GDB regs
+ *	@gdb_regs: A pointer to hold the registers in the order GDB wants.
+ *	@p: The &struct task_struct of the desired process.
+ *
+ *	Convert the register values of the sleeping process in @p to
+ *	the format that GDB expects.
+ *	This function is called when kgdb does not have access to the
+ *	&struct pt_regs and therefore it should fill the gdb registers
+ *	@gdb_regs with what has	been saved in &struct thread_struct
+ *	thread field during switch_to.
+ */
+extern void
+sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p);
+
+/*
+ *	gdb_regs_to_pt_regs - Convert GDB regs to ptrace regs.
+ *	@gdb_regs: A pointer to hold the registers we've received from GDB.
+ *	@regs: A pointer to a &struct pt_regs to hold these values in.
+ *
+ *	Convert the GDB regs in @gdb_regs into the pt_regs, and store them
+ *	in @regs.
+ */
+extern void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs);
+
+/*
+ *	kgdb_arch_handle_exception - Handle architecture specific GDB packets.
+ *	@vector: The error vector of the exception that happened.
+ *	@signo: The signal number of the exception that happened.
+ *	@err_code: The error code of the exception that happened.
+ *	@remcom_in_buffer: The buffer of the packet we have read.
+ *	@remcom_out_buffer: The buffer of %BUFMAX bytes to write a packet into.
+ *	@regs: The &struct pt_regs of the current process.
+ *
+ *	This function MUST handle the 'c' and 's' command packets,
+ *	as well packets to set / remove a hardware breakpoint, if used.
+ *	If there are additional packets which the hardware needs to handle,
+ *	they are handled here.  The code should return -1 if it wants to
+ *	process more packets, and a %0 or %1 if it wants to exit from the
+ *	kgdb callback.
+ */
+extern int
+kgdb_arch_handle_exception(int vector, int signo, int err_code,
+			   char *remcom_in_buffer,
+			   char *remcom_out_buffer,
+			   struct pt_regs *regs);
+
+/*
+ *	kgdb_roundup_cpus - Get other CPUs into a holding pattern
+ *	@flags: Current IRQ state
+ *
+ *	On SMP systems, we need to get the attention of the other CPUs
+ *	and get them be in a known state.  This should do what is needed
+ *	to get the other CPUs to call kgdb_wait(). Note that on some arches,
+ *	the NMI approach is not used for rounding up all the CPUs. For example,
+ *	in case of MIPS, smp_call_function() is used to roundup CPUs. In
+ *	this case, we have to make sure that interrupts are enabled before
+ *	calling smp_call_function(). The argument to this function is
+ *	the flags that will be used when restoring the interrupts. There is
+ *	local_irq_save() call before kgdb_roundup_cpus().
+ *
+ *	On non-SMP systems, this is not called.
+ */
+extern void kgdb_roundup_cpus(unsigned long flags);
+
+/* Optional functions. */
+extern int kgdb_validate_break_address(unsigned long addr);
+extern int kgdb_arch_set_breakpoint(unsigned long addr, char *saved_instr);
+extern int kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle);
+
+/*
+ * struct kgdb_arch - Describe architecture specific values.
+ * @gdb_bpt_instr: The instruction to trigger a breakpoint.
+ * @flags: Flags for the breakpoint, currently just %KGDB_HW_BREAKPOINT.
+ * @set_breakpoint: Allow an architecture to specify how to set a software
+ * breakpoint.
+ * @remove_breakpoint: Allow an architecture to specify how to remove a
+ * software breakpoint.
+ * @set_hw_breakpoint: Allow an architecture to specify how to set a hardware
+ * breakpoint.
+ * @remove_hw_breakpoint: Allow an architecture to specify how to remove a
+ * hardware breakpoint.
+ * @remove_all_hw_break: Allow an architecture to specify how to remove all
+ * hardware breakpoints.
+ * @correct_hw_break: Allow an architecture to specify how to correct the
+ * hardware debug registers.
+ */
+struct kgdb_arch {
+	unsigned char		gdb_bpt_instr[BREAK_INSTR_SIZE];
+	unsigned long		flags;
+
+	int	(*set_breakpoint)(unsigned long, char *);
+	int	(*remove_breakpoint)(unsigned long, char *);
+	int	(*set_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
+	int	(*remove_hw_breakpoint)(unsigned long, int, enum kgdb_bptype);
+	void	(*remove_all_hw_break)(void);
+	void	(*correct_hw_break)(void);
+};
+
+/*
+ * struct kgdb_io - Describe the interface for an I/O driver to talk with KGDB.
+ * @name: Name of the I/O driver.
+ * @read_char: Pointer to a function that will return one char.
+ * @write_char: Pointer to a function that will write one char.
+ * @flush: Pointer to a function that will flush any pending writes.
+ * @init: Pointer to a function that will initialize the device.
+ * @pre_exception: Pointer to a function that will do any prep work for
+ * the I/O driver.
+ * @post_exception: Pointer to a function that will do any cleanup work
+ * for the I/O driver.
+ */
+struct kgdb_io {
+	const char		*name;
+	int			(*read_char) (void);
+	void			(*write_char) (u8);
+	void			(*flush) (void);
+	int			(*init) (void);
+	void			(*pre_exception) (void);
+	void			(*post_exception) (void);
+};
+
+extern struct kgdb_arch		arch_kgdb_ops;
+
+extern int kgdb_register_io_module(struct kgdb_io *local_kgdb_io_ops);
+extern void kgdb_unregister_io_module(struct kgdb_io *local_kgdb_io_ops);
+
+extern int kgdb_hex2long(char **ptr, long *long_val);
+extern int kgdb_mem2hex(char *mem, char *buf, int count);
+extern int kgdb_hex2mem(char *buf, char *mem, int count);
+
+extern int kgdb_isremovedbreak(unsigned long addr);
+
+extern int
+kgdb_handle_exception(int ex_vector, int signo, int err_code,
+		      struct pt_regs *regs);
+extern int kgdb_nmicallback(int cpu, void *regs);
+
+extern int			kgdb_single_step;
+extern atomic_t			kgdb_active;
+
+#endif /* _KGDB_H_ */
