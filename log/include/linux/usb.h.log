commit 6bc3f3979edce0b11deb685a4c817abb7d74b227
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 20 07:20:17 2020 -0600

    USB: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200220132017.GA29262@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index ca1a5f1e1c5e..9f3c721c70dc 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -325,7 +325,7 @@ struct usb_interface_cache {
 
 	/* variable-length array of alternate settings for this interface,
 	 * stored in no particular order */
-	struct usb_host_interface altsetting[0];
+	struct usb_host_interface altsetting[];
 };
 #define	ref_to_usb_interface_cache(r) \
 		container_of(r, struct usb_interface_cache, ref)
@@ -1589,7 +1589,7 @@ struct urb {
 	int error_count;		/* (return) number of ISO errors */
 	void *context;			/* (in) context for completion */
 	usb_complete_t complete;	/* (in) completion routine */
-	struct usb_iso_packet_descriptor iso_frame_desc[0];
+	struct usb_iso_packet_descriptor iso_frame_desc[];
 					/* (in) ISO ONLY */
 };
 

commit 77419aa403ca1395f66e1e3de87743f54ba144b6
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:32 2019 +0200

    USB: Fallback to generic driver when specific driver fails
    
    If ->probe fails for a device specific driver, ask the driver core to
    reprobe us, after having flagged the device for the generic driver to be
    forced.
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-6-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3663bd7b1fa4..ca1a5f1e1c5e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -708,6 +708,7 @@ struct usb_device {
 	unsigned lpm_disable_count;
 
 	u16 hub_delay;
+	unsigned use_generic_driver:1;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit 88b7381a939de0fa1f1b1629c56b03dca7077309
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:31 2019 +0200

    USB: Select better matching USB drivers when available
    
    Now that USB device drivers can reuse code from the generic USB device
    driver, we need to make sure that they get selected rather than the
    generic driver. Add an id_table and match vfunc to the usb_device_driver
    struct, which will get used to select a better matching driver at
    ->probe time.
    
    This is a similar mechanism to that used in the HID drivers, with the
    generic driver being selected unless there's a better matching one found
    in the registered drivers (see hid_generic_match() in
    drivers/hid/hid-generic.c).
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-5-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 94bd3b48a485..3663bd7b1fa4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1237,6 +1237,7 @@ struct usb_driver {
 struct usb_device_driver {
 	const char *name;
 
+	bool (*match) (struct usb_device *udev);
 	int (*probe) (struct usb_device *udev);
 	void (*disconnect) (struct usb_device *udev);
 
@@ -1244,6 +1245,7 @@ struct usb_device_driver {
 	int (*resume) (struct usb_device *udev, pm_message_t message);
 	const struct attribute_group **dev_groups;
 	struct usbdrv_wrap drvwrap;
+	const struct usb_device_id *id_table;
 	unsigned int supports_autosuspend:1;
 	unsigned int generic_subclass:1;
 };

commit c9d503370f240934f3c1c5da4c6c2452a7d05db2
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:29 2019 +0200

    USB: Make it possible to "subclass" usb_device_driver
    
    The kernel currenly has only 2 usb_device_drivers, one generic one, one
    that completely replaces the generic one to make USB devices usable over
    a network.
    
    Use the newly exported generic driver functions when a driver declares
    to want them run, in addition to its own code. This makes it possible to
    write drivers that extend the generic USB driver.
    
    Note that this patch is not enough for another driver to automatically
    get selected.
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-3-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e656e7b4b1e4..94bd3b48a485 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1228,6 +1228,9 @@ struct usb_driver {
  * @drvwrap: Driver-model core structure wrapper.
  * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
  *	for devices bound to this driver.
+ * @generic_subclass: if set to 1, the generic USB driver's probe, disconnect,
+ *	resume and suspend functions will be called in addition to the driver's
+ *	own, so this part of the setup does not need to be replicated.
  *
  * USB drivers must provide all the fields listed above except drvwrap.
  */
@@ -1242,6 +1245,7 @@ struct usb_device_driver {
 	const struct attribute_group **dev_groups;
 	struct usbdrv_wrap drvwrap;
 	unsigned int supports_autosuspend:1;
+	unsigned int generic_subclass:1;
 };
 #define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
 		drvwrap.driver)

commit 7b81cb6bddd2c4f2489506771070924bd0ae9902
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 16 08:24:32 2019 +0200

    usb: add a HCD_DMA flag instead of guestimating DMA capabilities
    
    The usb core is the only major place in the kernel that checks for
    a non-NULL device dma_mask to see if a device is DMA capable.  This
    is generally a bad idea, as all major busses always set up a DMA mask,
    even if the device is not DMA capable - in fact bus layers like PCI
    can't even know if a device is DMA capable at enumeration time.  This
    leads to lots of workaround in HCD drivers, and also prevented us from
    setting up a DMA mask for platform devices by default last time we
    tried.
    
    Replace this guess with an explicit HCD_DMA that is set by drivers that
    appear to have DMA support.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190816062435.881-4-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b548c530f988..e656e7b4b1e4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -426,7 +426,6 @@ struct usb_bus {
 	struct device *sysdev;		/* as seen from firmware or bus */
 	int busnum;			/* Bus number (in order of reg) */
 	const char *bus_name;		/* stable id (PCI slot_name etc) */
-	u8 uses_dma;			/* Does the host controller use DMA? */
 	u8 uses_pio_for_control;	/*
 					 * Does the host controller use PIO
 					 * for control transfers?

commit 7ffc95e90e305c6803991ec2a2f4e442236efc77
Merge: 1e296b5be40d d1abaeb3be7b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 19 07:15:42 2019 +0200

    Merge 5.3-rc5 into usb-next
    
    We need the usb fixes in here as well for other patches to build on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit edfbcb321faf07ca970e4191abe061deeb7d3788
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Aug 11 10:05:16 2019 +0200

    usb: add a hcd_uses_dma helper
    
    The USB buffer allocation code is the only place in the usb core (and in
    fact the whole kernel) that uses is_device_dma_capable, while the URB
    mapping code uses the uses_dma flag in struct usb_bus.  Switch the buffer
    allocation to use the uses_dma flag used by the rest of the USB code,
    and create a helper in hcd.h that checks this flag as well as the
    CONFIG_HAS_DMA to simplify the caller a bit.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20190811080520.21712-3-hch@lst.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 83d35d993e8c..e87826e23d59 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1457,7 +1457,7 @@ typedef void (*usb_complete_t)(struct urb *);
  * field rather than determining a dma address themselves.
  *
  * Note that transfer_buffer must still be set if the controller
- * does not support DMA (as indicated by bus.uses_dma) and when talking
+ * does not support DMA (as indicated by hcd_uses_dma()) and when talking
  * to root hub. If you have to trasfer between highmem zone and the device
  * on such controller, create a bounce buffer or bail out with an error.
  * If transfer_buffer cannot be set (is in highmem) and the controller is DMA

commit 7d9c1d2f7aca2651b3821947bf928ee131df102a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 6 16:44:52 2019 +0200

    USB: add support for dev_groups to struct usb_device_driver
    
    Now that the driver core supports dev_groups for individual drivers,
    expose that pointer to struct usb_device_driver to make it easier for USB
    drivers to also use it.
    
    Yes, users of usb_device_driver are much rare, but there are instances
    already that use custom sysfs files, so adding this support will make
    things easier for those drivers.  usbip is one example, hubs might be
    another one.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190806144502.17792-3-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index af4eb6419ae8..57f667cad3ec 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1224,6 +1224,8 @@ struct usb_driver {
  *	module is being unloaded.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @dev_groups: Attributes attached to the device that will be created once it
+ *	is bound to the driver.
  * @drvwrap: Driver-model core structure wrapper.
  * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
  *	for devices bound to this driver.
@@ -1238,6 +1240,7 @@ struct usb_device_driver {
 
 	int (*suspend) (struct usb_device *udev, pm_message_t message);
 	int (*resume) (struct usb_device *udev, pm_message_t message);
+	const struct attribute_group **dev_groups;
 	struct usbdrv_wrap drvwrap;
 	unsigned int supports_autosuspend:1;
 };

commit b71b283e3d6df40cef03b5ce882b2385971f58a3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Aug 6 16:44:51 2019 +0200

    USB: add support for dev_groups to struct usb_driver
    
    Now that the driver core supports dev_groups for individual drivers,
    expose that pointer to struct usb_driver to make it easier for USB
    drivers to also use it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190806144502.17792-2-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 83d35d993e8c..af4eb6419ae8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1151,6 +1151,8 @@ struct usbdrv_wrap {
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
+ * @dev_groups: Attributes attached to the device that will be created once it
+ *	is bound to the driver.
  * @dynids: used internally to hold the list of dynamically added device
  *	ids for this driver.
  * @drvwrap: Driver-model core structure wrapper.
@@ -1198,6 +1200,7 @@ struct usb_driver {
 	int (*post_reset)(struct usb_interface *intf);
 
 	const struct usb_device_id *id_table;
+	const struct attribute_group **dev_groups;
 
 	struct usb_dynids dynids;
 	struct usbdrv_wrap drvwrap;

commit 4998f1efd1904dd21697aeeead270e3eb97691dd
Author: Jim Lin <jilin@nvidia.com>
Date:   Mon Jun 3 18:53:43 2019 +0800

    usb: Add devaddr in struct usb_device
    
    The Clear_TT_Buffer request sent to the hub includes the address of
    the LS/FS child device in wValue field. usb_hub_clear_tt_buffer()
    uses udev->devnum to set the address wValue. This won't work for
    devices connected to xHC.
    
    For other host controllers udev->devnum is the same as the address of
    the usb device, chosen and set by usb core. With xHC the controller
    hardware assigns the address, and won't be the same as devnum.
    
    Here we add devaddr in "struct usb_device" for
    usb_hub_clear_tt_buffer() to use.
    
    Signed-off-by: Jim Lin <jilin@nvidia.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index ae82d9d1112b..83d35d993e8c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -578,6 +578,7 @@ struct usb3_lpm_parameters {
  * @bus_mA: Current available from the bus
  * @portnum: parent port number (origin 1)
  * @level: number of USB hub ancestors
+ * @devaddr: device address, XHCI: assigned by HW, others: same as devnum
  * @can_submit: URBs may be submitted
  * @persist_enabled:  USB_PERSIST enabled for this device
  * @have_langid: whether string_langid is valid
@@ -661,6 +662,7 @@ struct usb_device {
 	unsigned short bus_mA;
 	u8 portnum;
 	u8 level;
+	u8 devaddr;
 
 	unsigned can_submit:1;
 	unsigned persist_enabled:1;

commit 132d68d37d33f1d0b9c1f507c8b4d64c27ecec8a
Merge: 80f232121b69 3515468a87a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 8 10:03:52 2019 -0700

    Merge tag 'usb-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB/PHY updates from Greg KH:
     "Here is the big set of USB and PHY driver patches for 5.2-rc1
    
      There is the usual set of:
    
       - USB gadget updates
    
       - PHY driver updates and additions
    
       - USB serial driver updates and fixes
    
       - typec updates and new chips supported
    
       - mtu3 driver updates
    
       - xhci driver updates
    
       - other tiny driver updates
    
      Nothing really interesting, just constant forward progress.
    
      All of these have been in linux-next for a while with no reported
      issues. The usb-gadget and usb-serial trees were merged a bit "late",
      but both of them had been in linux-next before they got merged here
      last Friday"
    
    * tag 'usb-5.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (206 commits)
      USB: serial: f81232: implement break control
      USB: serial: f81232: add high baud rate support
      USB: serial: f81232: clear overrun flag
      USB: serial: f81232: fix interrupt worker not stop
      usb: dwc3: Rename DWC3_DCTL_LPM_ERRATA
      usb: dwc3: Fix default lpm_nyet_threshold value
      usb: dwc3: debug: Print GET_STATUS(device) tracepoint
      usb: dwc3: Do core validation early on probe
      usb: dwc3: gadget: Set lpm_capable
      usb: gadget: atmel: tie wake lock to running clock
      usb: gadget: atmel: support USB suspend
      usb: gadget: atmel_usba_udc: simplify setting of interrupt-enabled mask
      dwc2: gadget: Fix completed transfer size calculation in DDMA
      usb: dwc2: Set lpm mode parameters depend on HW configuration
      usb: dwc2: Fix channel disable flow
      usb: dwc2: Set actual frame number for completed ISOC transfer
      usb: gadget: do not use __constant_cpu_to_le16
      usb: dwc2: gadget: Increase descriptors count for ISOC's
      usb: introduce usb_ep_type_string() function
      usb: dwc3: move synchronize_irq() out of the spinlock protected block
      ...

commit c2b71462d294cf517a0bc6e4fd6424d7cee5596f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 19 13:52:38 2019 -0400

    USB: core: Fix bug caused by duplicate interface PM usage counter
    
    The syzkaller fuzzer reported a bug in the USB hub driver which turned
    out to be caused by a negative runtime-PM usage counter.  This allowed
    a hub to be runtime suspended at a time when the driver did not expect
    it.  The symptom is a WARNING issued because the hub's status URB is
    submitted while it is already active:
    
            URB 0000000031fb463e submitted while active
            WARNING: CPU: 0 PID: 2917 at drivers/usb/core/urb.c:363
    
    The negative runtime-PM usage count was caused by an unfortunate
    design decision made when runtime PM was first implemented for USB.
    At that time, USB class drivers were allowed to unbind from their
    interfaces without balancing the usage counter (i.e., leaving it with
    a positive count).  The core code would take care of setting the
    counter back to 0 before allowing another driver to bind to the
    interface.
    
    Later on when runtime PM was implemented for the entire kernel, the
    opposite decision was made: Drivers were required to balance their
    runtime-PM get and put calls.  In order to maintain backward
    compatibility, however, the USB subsystem adapted to the new
    implementation by keeping an independent usage counter for each
    interface and using it to automatically adjust the normal usage
    counter back to 0 whenever a driver was unbound.
    
    This approach involves duplicating information, but what is worse, it
    doesn't work properly in cases where a USB class driver delays
    decrementing the usage counter until after the driver's disconnect()
    routine has returned and the counter has been adjusted back to 0.
    Doing so would cause the usage counter to become negative.  There's
    even a warning about this in the USB power management documentation!
    
    As it happens, this is exactly what the hub driver does.  The
    kick_hub_wq() routine increments the runtime-PM usage counter, and the
    corresponding decrement is carried out by hub_event() in the context
    of the hub_wq work-queue thread.  This work routine may sometimes run
    after the driver has been unbound from its interface, and when it does
    it causes the usage counter to go negative.
    
    It is not possible for hub_disconnect() to wait for a pending
    hub_event() call to finish, because hub_disconnect() is called with
    the device lock held and hub_event() acquires that lock.  The only
    feasible fix is to reverse the original design decision: remove the
    duplicate interface-specific usage counter and require USB drivers to
    balance their runtime PM gets and puts.  As far as I know, all
    existing drivers currently do this.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: syzbot+7634edaea4d0b341c625@syzkaller.appspotmail.com
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5e49e82c4368..ff010d1fd1c7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -200,7 +200,6 @@ usb_find_last_int_out_endpoint(struct usb_host_interface *alt,
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.
- * @pm_usage_cnt: PM usage counter for this interface
  * @reset_ws: Used for scheduling resets from atomic context.
  * @resetting_device: USB core reset the device, so use alt setting 0 as
  *	current; needs bandwidth alloc after reset.
@@ -257,7 +256,6 @@ struct usb_interface {
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
-	atomic_t pm_usage_cnt;		/* usage counter for autosuspend */
 	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)

commit 8e6b85945155da5af95dc0fa58ae38b86428deea
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Mar 1 18:22:38 2019 +0100

    USB: usb.h: tweak struct urb to remove wasted space
    
    By moving one field around in 'struct urb' we reduce the size of the
    structure by 8 bytes.
    
    Before the patch on x86_64 the overall size of the structure as reported
    by pahole was:
            /* size: 192, cachelines: 3, members: 30 */
            /* sum members: 184, holes: 2, sum holes: 8 */
    After the patch we now have:
            /* size: 184, cachelines: 3, members: 30 */
            /* last cacheline: 56 bytes */
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5e49e82c4368..4229eb74bd2c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1545,10 +1545,10 @@ typedef void (*usb_complete_t)(struct urb *);
 struct urb {
 	/* private: usb core and host controller only fields in the urb */
 	struct kref kref;		/* reference count of the URB */
+	int unlinked;			/* unlink error code */
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	atomic_t reject;		/* submissions will fail */
-	int unlinked;			/* unlink error code */
 
 	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's

commit 704620afc70cf47abb9d6a1a57f3825d2bca49cf
Author: Mathias Payer <mathias.payer@nebelwelt.net>
Date:   Wed Dec 5 21:19:59 2018 +0100

    USB: check usb_get_extra_descriptor for proper size
    
    When reading an extra descriptor, we need to properly check the minimum
    and maximum size allowed, to prevent from invalid data being sent by a
    device.
    
    Reported-by: Hui Peng <benquike@gmail.com>
    Reported-by: Mathias Payer <mathias.payer@nebelwelt.net>
    Co-developed-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Hui Peng <benquike@gmail.com>
    Signed-off-by: Mathias Payer <mathias.payer@nebelwelt.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4cdd515a4385..5e49e82c4368 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -407,11 +407,11 @@ struct usb_host_bos {
 };
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
-	unsigned char type, void **ptr);
+	unsigned char type, void **ptr, size_t min);
 #define usb_get_extra_descriptor(ifpoint, type, ptr) \
 				__usb_get_extra_descriptor((ifpoint)->extra, \
 				(ifpoint)->extralen, \
-				type, (void **)ptr)
+				type, (void **)ptr, sizeof(**(ptr)))
 
 /* ----------------------------------------------------------------------- */
 

commit aa071a92bbf09d993ff0dbf3b1f2b53ac93ad654
Author: Nicolas Boichat <drinkcat@chromium.org>
Date:   Mon May 28 14:32:19 2018 +0800

    usb: hub: Per-port setting to reduce TRSTRCY to 10 ms
    
    Currently, the USB hub core waits for 50 ms after enumerating the
    device. This was added to help "some high speed devices" to
    enumerate (b789696af8 "[PATCH] USB: relax usbcore reset timings").
    
    On some devices, the time-to-active is important, so we provide
    a per-port option to reduce the time to what the USB specification
    requires: 10 ms.
    
    Signed-off-by: Nicolas Boichat <drinkcat@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2ade17992ed6..4cdd515a4385 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -496,6 +496,9 @@ enum usb_port_connect_type {
 /* For the given port, prefer the old (faster) enumeration scheme. */
 #define USB_PORT_QUIRK_OLD_SCHEME	BIT(0)
 
+/* Decrease TRSTRCY to 10ms during device enumeration. */
+#define USB_PORT_QUIRK_FAST_ENUM	BIT(1)
+
 /*
  * USB 2.0 Link Power Management (LPM) parameters.
  */

commit 25244227158e1502062041365a439a54cb8fe673
Author: Nicolas Boichat <drinkcat@chromium.org>
Date:   Mon May 28 14:32:18 2018 +0800

    usb: hub: Per-port setting to use old enumeration scheme
    
    The "old" enumeration scheme is considerably faster (it takes
    ~244ms instead of ~356ms to get the descriptor).
    
    It is currently only possible to use the old scheme globally
    (/sys/module/usbcore/parameters/old_scheme_first), which is not
    desirable as the new scheme was introduced to increase compatibility
    with more devices.
    
    However, in our case, we care about time-to-active for a specific
    USB device (which we make the firmware for), on a specific port
    (that is pogo-pin based: not a standard USB port). This new
    sysfs option makes it possible to use the old scheme on a single
    port only.
    
    Signed-off-by: Nicolas Boichat <drinkcat@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index beffceec4915..2ade17992ed6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -489,6 +489,13 @@ enum usb_port_connect_type {
 	USB_PORT_NOT_USED,
 };
 
+/*
+ * USB port quirks.
+ */
+
+/* For the given port, prefer the old (faster) enumeration scheme. */
+#define USB_PORT_QUIRK_OLD_SCHEME	BIT(0)
+
 /*
  * USB 2.0 Link Power Management (LPM) parameters.
  */

commit 013eedb8c56e55549c45df19ca56a029cc804028
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Apr 19 19:05:51 2018 +0300

    USB: Add support to store lane count used by USB 3.2
    
    USB 3.2 specification adds Dual-lane support, doubling the maximum
    SuperSpeedPlus data rate from 10Gbps to 20Gbps.
    
    Dual-lane takes into use a second set of rx and tx wires/pins in the
    Type-C cable and connector.
    
    Add "rx_lanes" and "tx_lanes" variables to struct usb_device to store
    the numer of lanes in use. Number of lanes can be read using the extended
    port status hub request that was introduced in USB 3.1.
    
    Extended port status rx and tx lane count are zero based, maximum
    lanes supported by non inter-chip (SSIC) USB 3.2 is 2 (dual lane) with
    rx and tx lane count symmetric. SSIC devices support asymmetric lanes
    up to 4 lanes per direction.
    
    If extended port status is not available then default to one lane.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0173597e59aa..beffceec4915 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -551,6 +551,8 @@ struct usb3_lpm_parameters {
  * @route: tree topology hex string for use with xHCI
  * @state: device state: configured, not attached, etc.
  * @speed: device speed: high/full/low (or error)
+ * @rx_lanes: number of rx lanes in use, USB 3.2 adds dual-lane support
+ * @tx_lanes: number of tx lanes in use, USB 3.2 adds dual-lane support
  * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub
  * @ttport: device port on that tt hub
  * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints
@@ -624,6 +626,8 @@ struct usb_device {
 	u32		route;
 	enum usb_device_state	state;
 	enum usb_device_speed	speed;
+	unsigned int		rx_lanes;
+	unsigned int		tx_lanes;
 
 	struct usb_tt	*tt;
 	int		ttport;

commit 886ee36e7205a7b850e2e5c2298a479f581f9b3b
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Dec 14 09:50:39 2017 +0200

    usb: core: add support for USB_REQ_SET_ISOCH_DELAY
    
    USB SS and SSP hubs provide wHubDelay values on their hub descriptor
    which we should inform the USB Device about.
    
    The USB Specification 3.0 explains, on section 9.4.11, how to
    calculate the value and how to issue the request. Note that a
    USB_REQ_SET_ISOCH_DELAY is valid on all device states (Default,
    Address, Configured), we just *chose* to issue it from Address state
    right after successfully fetching the USB Device Descriptor.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index fe665a0d5bce..0173597e59aa 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -609,6 +609,10 @@ struct usb3_lpm_parameters {
  *	to keep track of the number of functions that require USB 3.0 Link Power
  *	Management to be disabled for this usb_device.  This count should only
  *	be manipulated by those functions, with the bandwidth_mutex is held.
+ * @hub_delay: cached value consisting of:
+ *		parent->hub_delay + wHubDelay + tTPTransmissionDelay (40ns)
+ *
+ *	Will be used as wValue for SetIsochDelay requests.
  *
  * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use
@@ -689,6 +693,8 @@ struct usb_device {
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
 	unsigned lpm_disable_count;
+
+	u16 hub_delay;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit aa15d3d257f9edcb8d15ed27e228d1c0080cb919
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Dec 11 11:58:21 2017 -0500

    USB: remove the URB_NO_FSBR flag
    
    The URB_NO_FSBR flag has never really been used.  It was introduced as
    a potential way for UHCI to minimize PCI bus usage (by not attempting
    full-speed bulk and control transfers more than once per frame), but
    the flag was not set by any drivers.
    
    There's no point in keeping it around.  This patch simplifies the API
    by removing it.  Unfortunately, it does have to be kept as part of the
    usbfs ABI, but at least we can document in
    include/uapi/linux/usbdevice_fs.h that it doesn't do anything.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index fbbe974661f2..fe665a0d5bce 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1293,7 +1293,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only; use the first unexpired
 					 * slot in the schedule */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb->transfer_dma valid on submit */
-#define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
 					 * needed */

commit 4e4510fec4af08ead21f6934c1410af1f19a8cad
Merge: 4008e6a9bcee 7087cb8fad5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 18:01:46 2017 -0800

    Merge tag 'sound-4.15-rc1' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "There are no big surprising changes in this cycle, yet not too boring,
      either. The biggest change from diffstat POV is the removal of the
      legacy OSS driver codes that have been already disabled for a long
      time. This will bring a few trivial merge conflicts.
    
      As new features in ASoC side, there are two things: a new AC97 bus
      implementation and AMD Stony platform support. Both include the
      relevant changes shared with other subsystems, e.g. AC97 MFD changes
      and DRM AMD changes.
    
      Some other highlighted topics are:
    
       - A bunch of USB-audio drivers got the hardening against the
         malicious device accesses with a new helper code for endpoint
         sanity check
    
       - Lots of cleanups for ASoC Intel platform code, including support
         for their open source audio firmware
    
       - Continued ASoC core componentization works
    
       - Support for scaling MCLK with sample rate in ASoC simple-card
    
       - Stabler PCM hot-unplug capability, especially for ASoC usages"
    
    * tag 'sound-4.15-rc1' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (302 commits)
      Documentation: sound: hd-audio: notes.rst
      ASoC: bcm2835: Support left/right justified and DSP modes
      ASoC: bcm2835: Enforce full symmetry
      ASoC: bcm2835: Support additional samplerates up to 384kHz
      ASoC: bcm2835: Add support for TDM modes
      ASoC: add mclk-fs support to audio graph card
      ASoC: add mclk-fs to audio graph card binding
      ASoC: rt5514: work around link error
      ASoC: rt5514: mark PM functions as __maybe_unused
      ASoC: rt5663: Check the JD status in the button pushing
      ASoC: amd: Modified DMA transfer Mechanism for Playback
      ASoC: rt5645: Wait for 400msec before concluding on value of RT5645_VENDOR_ID2
      ASoC: sun4i-codec: fixed 32bit audio capture support for H3/H2+
      ASoC: da7213: add support for DSP modes
      ASoC: sun8i-codec: Add a comment on the LRCK inversion
      ASoC: sun8i-codec: Set the BCLK divider
      ASoC: rt5663: Delay and retry reading rt5663 ID register
      ASoC: amd: use do_div rather than 64 bit division to fix 32 bit builds
      ASoC: cs42l56: Fix reset GPIO name in example DT binding
      ASoC: rt5514-spi: check irq status to schedule data copy in resume function
      ...

commit 894025f24bd028942da3e602b87d9f7223109b14
Merge: fb0255fb2941 cdafb6d8b8da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 21:14:07 2017 -0800

    Merge tag 'usb-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB/PHY updates from Greg KH:
     "Here is the big set of USB and PHY driver updates for 4.15-rc1.
    
      There is the usual amount of gadget and xhci driver updates, along
      with phy and chipidea enhancements. There's also a lot of SPDX tags
      and license boilerplate cleanups as well, which provide some churn in
      the diffstat.
    
      Other major thing is the typec code that moved out of staging and into
      the "real" part of the drivers/usb/ tree, which was nice to see
      happen.
    
      All of these have been in linux-next with no reported issues for a
      while"
    
    * tag 'usb-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (263 commits)
      usb: gadget: f_fs: Fix use-after-free in ffs_free_inst
      USB: usbfs: compute urb->actual_length for isochronous
      usb: core: message: remember to reset 'ret' to 0 when necessary
      USB: typec: Remove remaining redundant license text
      USB: typec: add SPDX identifiers to some files
      USB: renesas_usbhs: rcar?.h: add SPDX tags
      USB: chipidea: ci_hdrc_tegra.c: add SPDX line
      USB: host: xhci-debugfs: add SPDX lines
      USB: add SPDX identifiers to all remaining Makefiles
      usb: host: isp1362-hcd: remove a couple of redundant assignments
      USB: adutux: remove redundant variable minor
      usb: core: add a new usb_get_ptm_status() helper
      usb: core: add a 'type' parameter to usb_get_status()
      usb: core: introduce a new usb_get_std_status() helper
      usb: core: rename usb_get_status() 'type' argument to 'recip'
      usb: core: add Status Type definitions
      USB: gadget: Remove redundant license text
      USB: gadget: function: Remove redundant license text
      USB: gadget: udc: Remove redundant license text
      USB: gadget: legacy: Remove redundant license text
      ...

commit 76727c2c3bf4a5e58dff8cca23d0147ba08fb2c8
Merge: c429bda21ffa df6a3e245541
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 13 15:45:57 2017 +0100

    Merge tag 'asoc-v4.15' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: Updates for v4.15
    
    The biggest thing this release has been the conversion of the AC98 bus
    to the driver model, that's been a long time coming so thanks to Robert
    Jarzmik for his dedication there.  Due to there being some AC97 MFD
    there's a few fairly large changes in input and the MFD layer, mainly to
    the wm97xx driver.
    
    There's also some drivers/drm changes to support the new AMD Stoney
    platform, these are shared with the DRM subsystem and should be being
    merged via both.
    
    Within the subsystem the overwhelming bulk of the changes is in the
    Intel drivers which continue to need lots of cleanups and fixes, this
    release they've also gained support for their open source firmware.
    There's also some large changs in the core as Morimoto-san continues to
    mirror operations into the component level in preparation for conversion
    of drivers to that.
    
     - The AC97 bus has finally caught up with the driver model thanks to
       some dedicated and persistent work from Robert Jarzmik.
     - Continued work from Morimoto-san on moving us towards being able to
       use components for everything.
     - Lots of cleanups for the Intel platform code, including support for
       their open source audio firmware.
     - Support for scaling MCLK with sample rate in simple-card.
     - Support for AMD Stoney platform.

commit f8f3e4acbde3dff2e433d02476034606e07ac742
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Nov 2 10:57:42 2017 +0200

    usb: core: add a new usb_get_ptm_status() helper
    
    Drivers who are interested in the PTM status stype, should use this
    new helper to make sure they issue the correct GetStatus message.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6228d8177bfe..3555936025ec 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1775,6 +1775,12 @@ static inline int usb_get_std_status(struct usb_device *dev,
 		data);
 }
 
+static inline int usb_get_ptm_status(struct usb_device *dev, void *data)
+{
+	return usb_get_status(dev, USB_RECIP_DEVICE, USB_STATUS_TYPE_PTM,
+		0, data);
+}
+
 extern int usb_string(struct usb_device *dev, int index,
 	char *buf, size_t size);
 

commit 2e43f0fe379c317d1ca27a69d860e397682ce957
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Nov 2 10:57:41 2017 +0200

    usb: core: add a 'type' parameter to usb_get_status()
    
    This new 'type' parameter will allows interested drivers to request
    for PTM status or Standard status.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e86b6a2a35e4..6228d8177bfe 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1766,12 +1766,13 @@ extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
 	unsigned char descindex, void *buf, int size);
 extern int usb_get_status(struct usb_device *dev,
-	int recip, int target, void *data);
+	int recip, int type, int target, void *data);
 
 static inline int usb_get_std_status(struct usb_device *dev,
 	int recip, int target, void *data)
 {
-	return usb_get_status(dev, recip, target, data);
+	return usb_get_status(dev, recip, USB_STATUS_TYPE_STANDARD, target,
+		data);
 }
 
 extern int usb_string(struct usb_device *dev, int index,

commit d9e1e1484ade396b3a979ba6c68798dbaceed1b9
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Nov 2 10:57:40 2017 +0200

    usb: core: introduce a new usb_get_std_status() helper
    
    This new helper is a simple wrapper around usb_get_status(). This
    patch is in preparation to adding support for fetching PTM_STATUS
    types. No functional changes.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2e2c1d40081b..e86b6a2a35e4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1767,6 +1767,13 @@ extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
 	unsigned char descindex, void *buf, int size);
 extern int usb_get_status(struct usb_device *dev,
 	int recip, int target, void *data);
+
+static inline int usb_get_std_status(struct usb_device *dev,
+	int recip, int target, void *data)
+{
+	return usb_get_status(dev, recip, target, data);
+}
+
 extern int usb_string(struct usb_device *dev, int index,
 	char *buf, size_t size);
 

commit 3c377ef1000d57cb1faf8b86ea77cfa47141db33
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Nov 2 10:57:39 2017 +0200

    usb: core: rename usb_get_status() 'type' argument to 'recip'
    
    This makes it a lot clearer that we're expecting a recipient as the
    argument. A follow-up patch will use the argument 'type' as the status
    type selector (standard or ptm).
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cb9fbd54386e..2e2c1d40081b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1766,7 +1766,7 @@ extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
 	unsigned char descindex, void *buf, int size);
 extern int usb_get_status(struct usb_device *dev,
-	int type, int target, void *data);
+	int recip, int target, void *data);
 extern int usb_string(struct usb_device *dev, int index,
 	char *buf, size_t size);
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cb9fbd54386e..9c63792a8134 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __LINUX_USB_H
 #define __LINUX_USB_H
 

commit e901b9873876ca30a09253731bd3a6b00c44b5b0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 4 16:15:59 2017 +0200

    usb: core: Add a helper function to check the validity of EP type in URB
    
    This patch adds a new helper function to perform a sanity check of the
    given URB to see whether it contains a valid endpoint.  It's a light-
    weight version of what usb_submit_urb() does, but without the kernel
    warning followed by the stack trace, just returns an error code.
    
    Especially for a driver that doesn't parse the descriptor but fills
    the URB with the fixed endpoint (e.g. some quirks for non-compliant
    devices), this kind of check is preferable at the probe phase before
    actually submitting the urb.
    
    Tested-by: Andrey Konovalov <andreyknvl@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cb9fbd54386e..2b861804fffa 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1728,6 +1728,8 @@ static inline int usb_urb_dir_out(struct urb *urb)
 	return (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;
 }
 
+int usb_urb_ep_type_check(const struct urb *urb);
+
 void *usb_alloc_coherent(struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_free_coherent(struct usb_device *dev, size_t size,

commit 21470e32ca7f976bf131aa3c7b54019d07f7d821
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun Apr 16 21:51:07 2017 -0300

    usb: fix some references for /proc/bus/usb
    
    Since when we got rid of usbfs, the /proc/bus/usb is now
    elsewhere. Fix references for it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 226557362d36..cb9fbd54386e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -318,7 +318,7 @@ void usb_put_intf(struct usb_interface *intf);
  * struct usb_interface (which persists only as long as its configuration
  * is installed).  The altsetting arrays can be accessed through these
  * structures at any time, permitting comparison of configurations and
- * providing support for the /proc/bus/usb/devices pseudo-file.
+ * providing support for the /sys/kernel/debug/usb/devices pseudo-file.
  */
 struct usb_interface_cache {
 	unsigned num_altsetting;	/* number of alternate settings */

commit 279daf4e053470f22c9421a4ab05f8e5a9e9eeec
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Mar 17 11:35:31 2017 +0100

    USB: core: add helpers to retrieve endpoints in reverse order
    
    Several drivers have implemented their endpoint look-up loops in such a
    way that they have picked the last endpoint descriptor of the specified
    type should more than one such descriptor exist.
    
    To avoid any regressions, add corresponding helpers to lookup endpoints
    by searching the endpoint descriptors in reverse order.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7041cc950737..226557362d36 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -106,6 +106,13 @@ usb_find_common_endpoints(struct usb_host_interface *alt,
 		struct usb_endpoint_descriptor **int_in,
 		struct usb_endpoint_descriptor **int_out);
 
+int __must_check
+usb_find_common_endpoints_reverse(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **bulk_in,
+		struct usb_endpoint_descriptor **bulk_out,
+		struct usb_endpoint_descriptor **int_in,
+		struct usb_endpoint_descriptor **int_out);
+
 static inline int __must_check
 usb_find_bulk_in_endpoint(struct usb_host_interface *alt,
 		struct usb_endpoint_descriptor **bulk_in)
@@ -134,6 +141,34 @@ usb_find_int_out_endpoint(struct usb_host_interface *alt,
 	return usb_find_common_endpoints(alt, NULL, NULL, NULL, int_out);
 }
 
+static inline int __must_check
+usb_find_last_bulk_in_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **bulk_in)
+{
+	return usb_find_common_endpoints_reverse(alt, bulk_in, NULL, NULL, NULL);
+}
+
+static inline int __must_check
+usb_find_last_bulk_out_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **bulk_out)
+{
+	return usb_find_common_endpoints_reverse(alt, NULL, bulk_out, NULL, NULL);
+}
+
+static inline int __must_check
+usb_find_last_int_in_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **int_in)
+{
+	return usb_find_common_endpoints_reverse(alt, NULL, NULL, int_in, NULL);
+}
+
+static inline int __must_check
+usb_find_last_int_out_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **int_out)
+{
+	return usb_find_common_endpoints_reverse(alt, NULL, NULL, NULL, int_out);
+}
+
 /**
  * struct usb_interface - what usb device drivers talk to
  * @altsetting: array of interface structures, one for each alternate

commit 66a359390e7e34f9a4c489467234b107b3d76169
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Mar 17 11:35:30 2017 +0100

    USB: core: add helpers to retrieve endpoints
    
    Many USB drivers iterate over the available endpoints to find required
    endpoints of a specific type and direction. Typically the endpoints are
    required for proper function and a missing endpoint should abort probe.
    
    To facilitate code reuse, add a helper to retrieve common endpoints
    (bulk or interrupt, in or out) and four wrappers to find a single
    endpoint.
    
    Note that the helpers are marked as __must_check to serve as a reminder
    to always verify that all expected endpoints are indeed present. This
    also means that any optional endpoints, typically need to be looked up
    through separate calls.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 148752640693..7041cc950737 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -99,6 +99,41 @@ enum usb_interface_condition {
 	USB_INTERFACE_UNBINDING,
 };
 
+int __must_check
+usb_find_common_endpoints(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **bulk_in,
+		struct usb_endpoint_descriptor **bulk_out,
+		struct usb_endpoint_descriptor **int_in,
+		struct usb_endpoint_descriptor **int_out);
+
+static inline int __must_check
+usb_find_bulk_in_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **bulk_in)
+{
+	return usb_find_common_endpoints(alt, bulk_in, NULL, NULL, NULL);
+}
+
+static inline int __must_check
+usb_find_bulk_out_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **bulk_out)
+{
+	return usb_find_common_endpoints(alt, NULL, bulk_out, NULL, NULL);
+}
+
+static inline int __must_check
+usb_find_int_in_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **int_in)
+{
+	return usb_find_common_endpoints(alt, NULL, NULL, int_in, NULL);
+}
+
+static inline int __must_check
+usb_find_int_out_endpoint(struct usb_host_interface *alt,
+		struct usb_endpoint_descriptor **int_out)
+{
+	return usb_find_common_endpoints(alt, NULL, NULL, NULL, int_out);
+}
+
 /**
  * struct usb_interface - what usb device drivers talk to
  * @altsetting: array of interface structures, one for each alternate

commit a8c06e407ef969461b7f51ec72839fe382dd3c29
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 13 10:18:41 2017 +0800

    usb: separate out sysdev pointer from usb_bus
    
    For xhci-hcd platform device, all the DMA parameters are not
    configured properly, notably dma ops for dwc3 devices.
    
    The idea here is that you pass in the parent of_node along with
    the child device pointer, so it would behave exactly like the
    parent already does. The difference is that it also handles all
    the other attributes besides the mask.
    
    sysdev will represent the physical device, as seen from firmware
    or bus.Splitting the usb_bus->controller field into the
    Linux-internal device (used for the sysfs hierarchy, for printks
    and for power management) and a new pointer (used for DMA,
    DT enumeration and phy lookup) probably covers all that we really
    need.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sriram Dash <sriram.dash@nxp.com>
    Tested-by: Baolin Wang <baolin.wang@linaro.org>
    Tested-by: Brian Norris <briannorris@chromium.org>
    Tested-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Tested-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Cc: Felipe Balbi <felipe.balbi@linux.intel.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Sinjan Kumar <sinjank@codeaurora.org>
    Cc: David Fisher <david.fisher1@synopsys.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: "Thang Q. Nguyen" <tqnguyen@apm.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Jon Masters <jcm@redhat.com>
    Cc: Dann Frazier <dann.frazier@canonical.com>
    Cc: Peter Chen <peter.chen@nxp.com>
    Cc: Leo Li <pku.leo@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7e68259360de..148752640693 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -354,6 +354,7 @@ struct usb_devmap {
  */
 struct usb_bus {
 	struct device *controller;	/* host/master side hardware */
+	struct device *sysdev;		/* as seen from firmware or bus */
 	int busnum;			/* Bus number (in order of reg) */
 	const char *bus_name;		/* stable id (PCI slot_name etc) */
 	u8 uses_dma;			/* Does the host controller use DMA? */

commit 864e2fe935228c5c551da8638b5fdd07f82d04a7
Author: Amitesh Singh <singh.amitesh@gmail.com>
Date:   Fri Sep 30 22:40:57 2016 +0530

    usb: fix a typo in usb_class_driver documentation
    
    replace usb_unregister_dev by usb_deregister_dev
    
    Signed-off-by: Amitesh Singh <singh.amitesh@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index eba1f10e8cfd..7e68259360de 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1160,7 +1160,7 @@ extern struct bus_type usb_bus_type;
  * @minor_base: the start of the minor range for this driver.
  *
  * This structure is used for the usb_register_dev() and
- * usb_unregister_dev() functions, to consolidate a number of the
+ * usb_deregister_dev() functions, to consolidate a number of the
  * parameters used for them.
  */
 struct usb_class_driver {

commit 6fb650d43da3e7054984dc548eaa88765a94d49f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 29 15:25:17 2016 -0400

    USB: leave LPM alone if possible when binding/unbinding interface drivers
    
    When a USB driver is bound to an interface (either through probing or
    by claiming it) or is unbound from an interface, the USB core always
    disables Link Power Management during the transition and then
    re-enables it afterward.  The reason is because the driver might want
    to prevent hub-initiated link power transitions, in which case the HCD
    would have to recalculate the various LPM parameters.  This
    recalculation takes place when LPM is re-enabled and the new
    parameters are sent to the device and its parent hub.
    
    However, if the driver does not want to prevent hub-initiated link
    power transitions then none of this work is necessary.  The parameters
    don't need to be recalculated, and LPM doesn't need to be disabled and
    re-enabled.
    
    It turns out that disabling and enabling LPM can be time-consuming,
    enough so that it interferes with user programs that want to claim and
    release interfaces rapidly via usbfs.  Since the usbfs kernel driver
    doesn't set the disable_hub_initiated_lpm flag, we can speed things up
    and get the user programs to work by leaving LPM alone whenever the
    flag isn't set.
    
    And while we're improving the way disable_hub_initiated_lpm gets used,
    let's also fix its kerneldoc.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Matthew Giassa <matthew@giassa.net>
    CC: Mathias Nyman <mathias.nyman@intel.com>
    CC: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 01b6c61cf9bb..eba1f10e8cfd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1068,7 +1068,7 @@ struct usbdrv_wrap {
  *	for interfaces bound to this driver.
  * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
  *	endpoints before calling the driver's disconnect method.
- * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs
+ * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs
  *	to initiate lower power link state transitions when an idle timeout
  *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.
  *

commit feb26ac31a2a5cb88d86680d9a94916a6343e9e6
Author: Chris Bainbridge <chris.bainbridge@gmail.com>
Date:   Mon Apr 25 13:48:38 2016 +0100

    usb: core: hub: hub_port_init lock controller instead of bus
    
    The XHCI controller presents two USB buses to the system - one for USB2
    and one for USB3. The hub init code (hub_port_init) is reentrant but
    only locks one bus per thread, leading to a race condition failure when
    two threads attempt to simultaneously initialise a USB2 and USB3 device:
    
    [    8.034843] xhci_hcd 0000:00:14.0: Timeout while waiting for setup device command
    [   13.183701] usb 3-3: device descriptor read/all, error -110
    
    On a test system this failure occurred on 6% of all boots.
    
    The call traces at the point of failure are:
    
    Call Trace:
     [<ffffffff81b9bab7>] schedule+0x37/0x90
     [<ffffffff817da7cd>] usb_kill_urb+0x8d/0xd0
     [<ffffffff8111e5e0>] ? wake_up_atomic_t+0x30/0x30
     [<ffffffff817dafbe>] usb_start_wait_urb+0xbe/0x150
     [<ffffffff817db10c>] usb_control_msg+0xbc/0xf0
     [<ffffffff817d07de>] hub_port_init+0x51e/0xb70
     [<ffffffff817d4697>] hub_event+0x817/0x1570
     [<ffffffff810f3e6f>] process_one_work+0x1ff/0x620
     [<ffffffff810f3dcf>] ? process_one_work+0x15f/0x620
     [<ffffffff810f4684>] worker_thread+0x64/0x4b0
     [<ffffffff810f4620>] ? rescuer_thread+0x390/0x390
     [<ffffffff810fa7f5>] kthread+0x105/0x120
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
     [<ffffffff81ba183f>] ret_from_fork+0x3f/0x70
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
    
    Call Trace:
     [<ffffffff817fd36d>] xhci_setup_device+0x53d/0xa40
     [<ffffffff817fd87e>] xhci_address_device+0xe/0x10
     [<ffffffff817d047f>] hub_port_init+0x1bf/0xb70
     [<ffffffff811247ed>] ? trace_hardirqs_on+0xd/0x10
     [<ffffffff817d4697>] hub_event+0x817/0x1570
     [<ffffffff810f3e6f>] process_one_work+0x1ff/0x620
     [<ffffffff810f3dcf>] ? process_one_work+0x15f/0x620
     [<ffffffff810f4684>] worker_thread+0x64/0x4b0
     [<ffffffff810f4620>] ? rescuer_thread+0x390/0x390
     [<ffffffff810fa7f5>] kthread+0x105/0x120
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
     [<ffffffff81ba183f>] ret_from_fork+0x3f/0x70
     [<ffffffff810fa6f0>] ? kthread_create_on_node+0x200/0x200
    
    Which results from the two call chains:
    
    hub_port_init
     usb_get_device_descriptor
      usb_get_descriptor
       usb_control_msg
        usb_internal_control_msg
         usb_start_wait_urb
          usb_submit_urb / wait_for_completion_timeout / usb_kill_urb
    
    hub_port_init
     hub_set_address
      xhci_address_device
       xhci_setup_device
    
    Mathias Nyman explains the current behaviour violates the XHCI spec:
    
     hub_port_reset() will end up moving the corresponding xhci device slot
     to default state.
    
     As hub_port_reset() is called several times in hub_port_init() it
     sounds reasonable that we could end up with two threads having their
     xhci device slots in default state at the same time, which according to
     xhci 4.5.3 specs still is a big no no:
    
     "Note: Software shall not transition more than one Device Slot to the
      Default State at a time"
    
     So both threads fail at their next task after this.
     One fails to read the descriptor, and the other fails addressing the
     device.
    
    Fix this in hub_port_init by locking the USB controller (instead of an
    individual bus) to prevent simultaneous initialisation of both buses.
    
    Fixes: 638139eb95d2 ("usb: hub: allow to process more usb hub events in parallel")
    Link: https://lkml.org/lkml/2016/2/8/312
    Link: https://lkml.org/lkml/2016/2/4/748
    Signed-off-by: Chris Bainbridge <chris.bainbridge@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7824f4557d50..01b6c61cf9bb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -374,13 +374,12 @@ struct usb_bus {
 
 	int devnum_next;		/* Next open device number in
 					 * round-robin allocation */
+	struct mutex devnum_next_mutex; /* devnum_next mutex */
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
 	struct usb_bus *hs_companion;	/* Companion EHCI bus, if any */
 
-	struct mutex usb_address0_mutex; /* unaddressed device mutex */
-
 	int bandwidth_allocated;	/* on this bus: how much of the time
 					 * reserved for periodic (intr/iso)
 					 * requests is used, on average?

commit fca504f6054f2a62d966afde23a0cfbf9e3dc32f
Author: Oliver Neukum <oneukum@suse.com>
Date:   Wed Apr 20 15:39:12 2016 +0200

    USB: correct intervals for SS+
    
    SS+ also expresses intervals in units of 125ms. Testing must
    be for SS or faster, not SS exactly.
    
    Signed-off-by: Oliver neukum <oneukum@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 29aba76017ee..7824f4557d50 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1569,7 +1569,7 @@ static inline void usb_fill_bulk_urb(struct urb *urb,
  * Initializes a interrupt urb with the proper information needed to submit
  * it to a device.
  *
- * Note that High Speed and SuperSpeed interrupt endpoints use a logarithmic
+ * Note that High Speed and SuperSpeed(+) interrupt endpoints use a logarithmic
  * encoding of the endpoint interval, and express polling intervals in
  * microframes (eight per millisecond) rather than in frames (one per
  * millisecond).
@@ -1595,7 +1595,7 @@ static inline void usb_fill_int_urb(struct urb *urb,
 	urb->complete = complete_fn;
 	urb->context = context;
 
-	if (dev->speed == USB_SPEED_HIGH || dev->speed == USB_SPEED_SUPER) {
+	if (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {
 		/* make sure interval is within allowed range */
 		interval = clamp(interval, 1, 16);
 

commit dd80b54b18db3d76a43558daaa6ea3aa67f5aacd
Author: Oliver Neukum <oneukum@suse.com>
Date:   Wed Apr 20 15:39:11 2016 +0200

    USB: LTM also for USB 3.1
    
    LTM is also defined for SS+. The correct test is to check for anything
    slower than SS not exactly SS.
    
    Signed-off-by: Oliver Neukum <ONeukum@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6a9a0c28415d..29aba76017ee 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -720,7 +720,7 @@ extern void usb_enable_ltm(struct usb_device *udev);
 
 static inline bool usb_device_supports_ltm(struct usb_device *udev)
 {
-	if (udev->speed != USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)
+	if (udev->speed < USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)
 		return false;
 	return udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;
 }

commit faee822c5a7ab99de25cd34fcde3f8d37b6b9923
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Feb 12 16:40:14 2016 +0200

    usb: Add USB 3.1 Precision time measurement capability descriptor support
    
    USB 3.1 devices that support precision time measurement have an
    additional PTM cabaility descriptor as part of the full BOS descriptor
    
    Look for this descriptor while parsing the BOS descriptor, and store it in
    struct usb_hub_bos if it exists.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8fc881af8735..6a9a0c28415d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -332,6 +332,7 @@ struct usb_host_bos {
 	struct usb_ss_cap_descriptor	*ss_cap;
 	struct usb_ssp_cap_descriptor	*ssp_cap;
 	struct usb_ss_container_id_descriptor	*ss_id;
+	struct usb_ptm_cap_descriptor	*ptm_cap;
 };
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,

commit b37d83a6a41499d582b8faedff1913ec75d9e70b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Fri Feb 12 16:40:13 2016 +0200

    usb: Parse the new USB 3.1 SuperSpeedPlus Isoc endpoint companion descriptor
    
    USB 3.1 devices can return a new SuperSpeedPlus isoc endpoint companion
    descriptor for a isochronous endpoint that requires more than 48K bytes
    per Service Interval.
    
    The new descriptor immediately follows the old USB 3.0 SuperSpeed Endpoint
    Companion and will provide a new BytesPerInterval value.
    
    It is parsed and stored in struct usb_host_endpoint with the other endpoint
    related descriptors, and should be used by USB3.1 capable hosts to reserve
    bus time in the schedule.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index dc0ea0de8a81..8fc881af8735 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -50,6 +50,7 @@ struct ep_device;
  * struct usb_host_endpoint - host-side endpoint descriptor and queue
  * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
  * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint
+ * @ssp_isoc_ep_comp: SuperSpeedPlus isoc companion descriptor for this endpoint
  * @urb_list: urbs queued to this endpoint; maintained by usbcore
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
@@ -65,6 +66,7 @@ struct ep_device;
 struct usb_host_endpoint {
 	struct usb_endpoint_descriptor		desc;
 	struct usb_ss_ep_comp_descriptor	ss_ep_comp;
+	struct usb_ssp_isoc_ep_comp_descriptor	ssp_isoc_ep_comp;
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device		*ep_dev;	/* For sysfs info */

commit 7dd9cba5bb90ffa9c60c1533b715dc91c5082cd9
Author: Oliver Neukum <oneukum@suse.com>
Date:   Thu Jan 21 15:18:47 2016 +0100

    usb: sysfs: make locking interruptible
    
    232275a USB: fix substandard locking for the sysfs files
    introduced needed locking into sysfs operations on USB devices
    It, however, uses uninterruptible sleep and if the error
    handling is on extreme cases of sleep lengths of 10s of seconds
    are possible. Unless we are removing the device we should use
    interruptible sleep.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0d348fa84a66..dc0ea0de8a81 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -641,9 +641,10 @@ extern struct usb_device *usb_hub_find_child(struct usb_device *hdev,
 		if (!child) continue; else
 
 /* USB device locking */
-#define usb_lock_device(udev)		device_lock(&(udev)->dev)
-#define usb_unlock_device(udev)		device_unlock(&(udev)->dev)
-#define usb_trylock_device(udev)	device_trylock(&(udev)->dev)
+#define usb_lock_device(udev)			device_lock(&(udev)->dev)
+#define usb_unlock_device(udev)			device_unlock(&(udev)->dev)
+#define usb_lock_device_interruptible(udev)	device_lock_interruptible(&(udev)->dev)
+#define usb_trylock_device(udev)		device_trylock(&(udev)->dev)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
 				     const struct usb_interface *iface);
 

commit 5363de75307e333d89df7531f9dd8310d973ecdb
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Mon Jan 25 20:30:30 2016 +0100

    usb: core: switch bus numbering to using idr
    
    USB bus numbering is based on directly dealing with bitmaps and
    defines a separate list of busses.
    This can be simplified and unified by using existing idr functionality.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 89533ba38691..0d348fa84a66 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -375,7 +375,6 @@ struct usb_bus {
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
 	struct usb_bus *hs_companion;	/* Companion EHCI bus, if any */
-	struct list_head bus_list;	/* list of busses */
 
 	struct mutex usb_address0_mutex; /* unaddressed device mutex */
 

commit 498378d9d2c12d97318028f1a648d98ee7568430
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Sat Nov 14 16:26:34 2015 +0800

    usb: core: lpm: remove usb3_lpm_enabled in usb_device
    
    Commit 8306095fd2c1 ("USB: Disable USB 3.0 LPM in critical sections.")
    adds usb3_lpm_enabled member to struct usb_device. There is no reference
    to this member now. Hence, it could be removed.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b79925dd2b41..89533ba38691 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -510,7 +510,6 @@ struct usb3_lpm_parameters {
  * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM
  * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled
  * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled
- * @usb3_lpm_enabled: USB3 hardware LPM enabled
  * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled
  * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled
  * @string_langid: language ID for strings
@@ -585,7 +584,6 @@ struct usb_device {
 	unsigned usb2_hw_lpm_besl_capable:1;
 	unsigned usb2_hw_lpm_enabled:1;
 	unsigned usb2_hw_lpm_allowed:1;
-	unsigned usb3_lpm_enabled:1;
 	unsigned usb3_lpm_u1_enabled:1;
 	unsigned usb3_lpm_u2_enabled:1;
 	int string_langid;

commit bf5ce5bf3cc7136fd7fe5e8999a580bc93a9c8f6
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Sat Nov 14 16:26:32 2015 +0800

    usb: core: lpm: fix usb3_hardware_lpm sysfs node
    
    Commit 655fe4effe0f ("usbcore: add sysfs support to xHCI usb3
    hardware LPM") introduced usb3_hardware_lpm sysfs node. This
    doesn't show the correct status of USB3 U1 and U2 LPM status.
    
    This patch fixes this by replacing usb3_hardware_lpm with two
    nodes, usb3_hardware_lpm_u1 (for U1) and usb3_hardware_lpm_u2
    (for U2), and recording the U1/U2 LPM status in right places.
    
    This patch should be back-ported to kernels as old as 4.3,
    that contains Commit 655fe4effe0f ("usbcore: add sysfs support
    to xHCI usb3 hardware LPM").
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b9a28074210f..b79925dd2b41 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -511,6 +511,8 @@ struct usb3_lpm_parameters {
  * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled
  * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled
  * @usb3_lpm_enabled: USB3 hardware LPM enabled
+ * @usb3_lpm_u1_enabled: USB3 hardware U1 LPM enabled
+ * @usb3_lpm_u2_enabled: USB3 hardware U2 LPM enabled
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
  * @manufacturer: iManufacturer string, if present (static)
@@ -584,6 +586,8 @@ struct usb_device {
 	unsigned usb2_hw_lpm_enabled:1;
 	unsigned usb2_hw_lpm_allowed:1;
 	unsigned usb3_lpm_enabled:1;
+	unsigned usb3_lpm_u1_enabled:1;
+	unsigned usb3_lpm_u2_enabled:1;
 	int string_langid;
 
 	/* static strings from the device */

commit 3220befddc0da1f4e09fc790a32a9bd8427e8889
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Oct 1 18:40:33 2015 +0300

    usb: store the new usb 3.1 SuperSpeedPlus device capability descriptor
    
    If a device supports usb 3.1 SupeerSpeedPlus Gen2 speeds it povides
    a SuperSpeedPlus device capability descriptor as a part of its
    BOS descriptor. If we find one while parsing the BOS then save it
    togeter with the other device capabilities found in the BOS
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2cbcf8db517a..b9a28074210f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -328,6 +328,7 @@ struct usb_host_bos {
 	/* wireless cap descriptor is handled by wusb */
 	struct usb_ext_cap_descriptor	*ext_cap;
 	struct usb_ss_cap_descriptor	*ss_cap;
+	struct usb_ssp_cap_descriptor	*ssp_cap;
 	struct usb_ss_container_id_descriptor	*ss_id;
 };
 

commit 07294cc2ea3000da706fd88c8ec7dcfadc715e14
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Mon Sep 28 23:59:52 2015 +0200

    USB: Added forgotten parameter description for authorized attribute in usb.h
    
    Signed-off-by: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3deccab2ce0a..2cbcf8db517a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -122,6 +122,8 @@ enum usb_interface_condition {
  *	has been deferred.
  * @needs_binding: flag set when the driver should be re-probed or unbound
  *	following a reset or suspend operation it doesn't support.
+ * @authorized: This allows to (de)authorize individual interfaces instead
+ *	a whole device in contrast to the device authorization.
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.

commit 4ad2ddce1a096dea71d42969515d3a64f0d9246f
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Tue Aug 25 21:10:05 2015 +0200

    usb: interface authorization: Declare authorized attribute
    
    The attribute authorized shows the authorization state for an interface.
    
    Signed-off-by: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 447fe29b55b4..3deccab2ce0a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -178,6 +178,7 @@ struct usb_interface {
 	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */
 	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
 	unsigned resetting_device:1;	/* true: bandwidth alloc after reset */
+	unsigned authorized:1;		/* used for interface authorization */
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;

commit 62f0342de1f012f3e90607d39e20fce811391169
Author: Felipe Balbi <balbi@ti.com>
Date:   Fri Feb 13 14:34:25 2015 -0600

    usb: define a generic USB_RESUME_TIMEOUT macro
    
    Every USB Host controller should use this new
    macro to define for how long resume signalling
    should be driven on the bus.
    
    Currently, almost every single USB controller
    is using a 20ms timeout for resume signalling.
    
    That's problematic for two reasons:
    
    a) sometimes that 20ms timer expires a little
    before 20ms, which makes us fail certification
    
    b) some (many) devices actually need more than
    20ms resume signalling.
    
    Sure, in case of (b) we can state that the device
    is against the USB spec, but the fact is that
    we have no control over which device the certification
    lab will use. We also have no control over which host
    they will use. Most likely they'll be using a Windows
    PC which, again, we have no control over how that
    USB stack is written and how long resume signalling
    they are using.
    
    At the end of the day, we must make sure Linux passes
    electrical compliance when working as Host or as Device
    and currently we don't pass compliance as host because
    we're driving resume signallig for exactly 20ms and
    that confuses certification test setup resulting in
    Certification failure.
    
    Cc: <stable@vger.kernel.org> # v3.10+
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7ee1b5c3b4cb..447fe29b55b4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -205,6 +205,32 @@ void usb_put_intf(struct usb_interface *intf);
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
+/*
+ * USB Resume Timer: Every Host controller driver should drive the resume
+ * signalling on the bus for the amount of time defined by this macro.
+ *
+ * That way we will have a 'stable' behavior among all HCDs supported by Linux.
+ *
+ * Note that the USB Specification states we should drive resume for *at least*
+ * 20 ms, but it doesn't give an upper bound. This creates two possible
+ * situations which we want to avoid:
+ *
+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes
+ * us to fail USB Electrical Tests, thus failing Certification
+ *
+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,
+ * and while we can argue that's against the USB Specification, we don't have
+ * control over which devices a certification laboratory will be using for
+ * certification. If CertLab uses a device which was tested against Windows and
+ * that happens to have relaxed resume signalling rules, we might fall into
+ * situations where we fail interoperability and electrical tests.
+ *
+ * In order to avoid both conditions, we're using a 40 ms resume timeout, which
+ * should cope with both LPJ calibration errors and devices not following every
+ * detail of the USB Specification.
+ */
+#define USB_RESUME_TIMEOUT	40 /* ms */
+
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.

commit 524134d422316a59d5464ccbc12036bbe90c5563
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jan 21 14:02:43 2015 -0500

    USB: don't cancel queued resets when unbinding drivers
    
    The USB stack provides a mechanism for drivers to request an
    asynchronous device reset (usb_queue_reset_device()).  The mechanism
    uses a work item (reset_ws) embedded in the usb_interface structure
    used by the driver, and the reset is carried out by a work queue
    routine.
    
    The asynchronous reset can race with driver unbinding.  When this
    happens, we try to cancel the queued reset before unbinding the
    driver, on the theory that the driver won't care about any resets once
    it is unbound.
    
    However, thanks to the fact that lockdep now tracks work queue
    accesses, this can provoke a lockdep warning in situations where the
    device reset causes another interface's driver to be unbound; see
    
            http://marc.info/?l=linux-usb&m=141893165203776&w=2
    
    for an example.  The reason is that the work routine for reset_ws in
    one interface calls cancel_queued_work() for the reset_ws in another
    interface.  Lockdep thinks this might lead to a work routine trying to
    cancel itself.  The simplest solution is not to cancel queued resets
    when unbinding drivers.
    
    This means we now need to acquire a reference to the usb_interface
    when queuing a reset_ws work item and to drop the reference when the
    work routine finishes.  We also need to make sure that the
    usb_interface structure doesn't outlive its parent usb_device; this
    means acquiring and dropping a reference when the interface is created
    and destroyed.
    
    In addition, cancelling a queued reset can fail (if the device is in
    the middle of an earlier reset), and this can cause usb_reset_device()
    to try to rebind an interface that has been deallocated (see
    http://marc.info/?l=linux-usb&m=142175717016628&w=2 for details).
    Acquiring the extra references prevents this failure.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Russell King - ARM Linux <linux@arm.linux.org.uk>
    Reported-by: Olivier Sobrie <olivier@sobrie.be>
    Tested-by: Olivier Sobrie <olivier@sobrie.be>
    Cc: stable <stable@vger.kernel.org> # 3.19
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4add5661080a..7ee1b5c3b4cb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -127,10 +127,6 @@ enum usb_interface_condition {
  *	to the sysfs representation for that device.
  * @pm_usage_cnt: PM usage counter for this interface
  * @reset_ws: Used for scheduling resets from atomic context.
- * @reset_running: set to 1 if the interface is currently running a
- *      queued reset so that usb_cancel_queued_reset() doesn't try to
- *      remove from the workqueue when running inside the worker
- *      thread. See __usb_queue_reset_device().
  * @resetting_device: USB core reset the device, so use alt setting 0 as
  *	current; needs bandwidth alloc after reset.
  *
@@ -181,7 +177,6 @@ struct usb_interface {
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */
 	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
-	unsigned reset_running:1;
 	unsigned resetting_device:1;	/* true: bandwidth alloc after reset */
 
 	struct device dev;		/* interface specific device info */

commit 9636c37843c9355c1ab6adcd8491186cbdc3b950
Author: Chris Rorvick <chris@rorvick.com>
Date:   Wed Jan 14 21:52:28 2015 -0600

    usb: Fix typo in `struct usb_host_interface' comment
    
    The descriptor member `bNumEndpoints' is plural.
    
    Signed-off-by: Chris Rorvick <chris@rorvick.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f89c24a03bd9..4add5661080a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -82,7 +82,7 @@ struct usb_host_interface {
 	int extralen;
 	unsigned char *extra;   /* Extra descriptors */
 
-	/* array of desc.bNumEndpoint endpoints associated with this
+	/* array of desc.bNumEndpoints endpoints associated with this
 	 * interface setting.  these will be in no particular order.
 	 */
 	struct usb_host_endpoint *endpoint;

commit ceb6c9c862c86423f41c1e20ecf8d454f837f519
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 29 23:47:05 2014 +0100

    USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM (or even dropped in some cases).
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the USB core code
    and documentation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 447a7e2fc19b..f89c24a03bd9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -637,7 +637,7 @@ static inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)
 #endif
 
 /* USB autosuspend and autoresume */
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 extern void usb_enable_autosuspend(struct usb_device *udev);
 extern void usb_disable_autosuspend(struct usb_device *udev);
 

commit 0cfbd328d60f85b0dcf66df61a3615e9a8e5d4e4
Author: Michal Sojka <sojka@merica.cz>
Date:   Wed Sep 24 22:43:21 2014 +0200

    usb: Add LED triggers for USB activity
    
    With this patch, USB activity can be signaled by blinking a LED. There
    are two triggers, one for activity on USB host and one for USB gadget.
    
    Both triggers should work with all host/device controllers. Tested only
    with musb.
    
    Performace: I measured performance overheads on ARM Cortex-A8 (TI
    AM335x) running on 600 MHz.
    
    Duration of usb_led_activity():
    - with no LED attached to the trigger:        2  1 s
    - with one GPIO LED attached to the trigger:  2  1 s or 8  2 s (two peaks in histogram)
    
    Duration of functions calling usb_led_activity() (with this patch
    applied and no LED attached to the trigger):
    - __usb_hcd_giveback_urb():    10 - 25 s
    - usb_gadget_giveback_request(): 2 - 6 s
    
    Signed-off-by: Michal Sojka <sojka@merica.cz>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Tested-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d2465bc0e73c..447a7e2fc19b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1862,6 +1862,18 @@ extern void usb_unregister_notify(struct notifier_block *nb);
 /* debugfs stuff */
 extern struct dentry *usb_debug_root;
 
+/* LED triggers */
+enum usb_led_event {
+	USB_LED_EVENT_HOST = 0,
+	USB_LED_EVENT_GADGET = 1,
+};
+
+#ifdef CONFIG_USB_LED_TRIG
+extern void usb_led_activity(enum usb_led_event ev);
+#else
+static inline void usb_led_activity(enum usb_led_event ev) {}
+#endif
+
 #endif  /* __KERNEL__ */
 
 #endif

commit 6fecd4f2a58c60028b1a75deefcf111516d3f836
Author: Todd E Brandt <todd.e.brandt@linux.intel.com>
Date:   Mon May 19 10:55:32 2014 -0700

    USB: separate usb_address0 mutexes for each bus
    
    This patch creates a separate instance of the usb_address0 mutex for each USB
    bus, and attaches it to the usb_bus device struct. This allows devices on
    separate buses to be enumerated in parallel; saving time.
    
    In the current code, there is a single, global instance of the usb_address0
    mutex which is used for all devices on all buses. This isn't completely
    necessary, as this mutex is only needed to prevent address0 collisions for
    devices on the *same* bus (usb 2.0 spec, sec 4.6.1). This superfluous coverage
    can cause additional delay in system resume on systems with multiple hosts
    (up to several seconds depending on what devices are attached).
    
    Signed-off-by: Todd Brandt <todd.e.brandt@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6b7ec376fb4d..d2465bc0e73c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -352,6 +352,8 @@ struct usb_bus {
 	struct usb_bus *hs_companion;	/* Companion EHCI bus, if any */
 	struct list_head bus_list;	/* list of busses */
 
+	struct mutex usb_address0_mutex; /* unaddressed device mutex */
+
 	int bandwidth_allocated;	/* on this bus: how much of the time
 					 * reserved for periodic (intr/iso)
 					 * requests is used, on average?

commit 3e75c6de1ac33fe3500f44573d9212dc82c99f59
Merge: cb1595563880 940ab8f1ef93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 1 17:06:09 2014 -0700

    Merge tag 'usb-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB patches from Greg KH:
     "Here's the big USB pull request for 3.15-rc1.
    
      The normal set of patches, lots of controller driver updates, and a
      smattering of individual USB driver updates as well.
    
      All have been in linux-next for a while"
    
    * tag 'usb-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (249 commits)
      xhci: Transition maintainership to Mathias Nyman.
      USB: disable reset-resume when USB_QUIRK_RESET is set
      USB: unbind all interfaces before rebinding any
      usb: phy: Add ulpi IDs for SMSC USB3320 and TI TUSB1210
      usb: gadget: tcm_usb_gadget: stop format strings
      usb: gadget: f_fs: add missing spinlock and mutex unlock
      usb: gadget: composite: switch over to ERR_CAST()
      usb: gadget: inode: switch over to memdup_user()
      usb: gadget: f_subset: switch over to PTR_RET
      usb: gadget: lpc32xx_udc: fix wrong clk_put() sequence
      USB: keyspan: remove dead debugging code
      USB: serial: add missing newlines to dev_<level> messages.
      USB: serial: add missing braces
      USB: serial: continue to write on errors
      USB: serial: continue to read on errors
      USB: serial: make bulk_out_size a lower limit
      USB: cypress_m8: fix potential scheduling while atomic
      devicetree: bindings: document lsi,zevio-usb
      usb: chipidea: add support for USB OTG controller on LSI Zevio SoCs
      usb: chipidea: imx: Use dev_name() for ci_hdrc name to distinguish USBs
      ...

commit 9b6f0c4b98171f2a354e1e461fefa90ec2baafa6
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Mon Mar 10 10:36:40 2014 +0200

    usbcore: rename struct dev_state to struct usb_dev_state
    
    Since it is needed outside usbcore and exposed in include/linux/usb.h,
    it conflicts with enum dev_state in rt2x00 wireless driver.
    
    Mark it as usb specific to avoid conflicts in the future.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 140a6a3e7d56..b55600a1edc3 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -366,7 +366,7 @@ struct usb_bus {
 #endif
 };
 
-struct dev_state;
+struct usb_dev_state;
 
 /* ----------------------------------------------------------------------- */
 
@@ -753,9 +753,9 @@ extern struct usb_host_interface *usb_find_alt_setting(
 
 /* port claiming functions */
 int usb_hub_claim_port(struct usb_device *hdev, unsigned port1,
-		struct dev_state *owner);
+		struct usb_dev_state *owner);
 int usb_hub_release_port(struct usb_device *hdev, unsigned port1,
-		struct dev_state *owner);
+		struct usb_dev_state *owner);
 
 /**
  * usb_make_path - returns stable device path in the usb tree

commit 6080cd0e9239469524d2aa07250ad4b9f383960d
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Sat Mar 8 14:53:34 2014 +0200

    staging: usbip: claim ports used by shared devices
    
    A device should not be able to be used concurrently both by
    the server and the client. Claiming the port used by the
    shared device ensures no interface drivers bind to it and
    that it is not usable from the server.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 22de4affe9c8..140a6a3e7d56 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -366,6 +366,8 @@ struct usb_bus {
 #endif
 };
 
+struct dev_state;
+
 /* ----------------------------------------------------------------------- */
 
 struct usb_tt;
@@ -749,6 +751,11 @@ extern struct usb_host_interface *usb_find_alt_setting(
 		unsigned int iface_num,
 		unsigned int alt_num);
 
+/* port claiming functions */
+int usb_hub_claim_port(struct usb_device *hdev, unsigned port1,
+		struct dev_state *owner);
+int usb_hub_release_port(struct usb_device *hdev, unsigned port1,
+		struct dev_state *owner);
 
 /**
  * usb_make_path - returns stable device path in the usb tree

commit 8d4f70b2fa52ca80f74faebc2471f74ee374cf61
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:19:25 2013 +0200

    usb-core: Track if an endpoint has streams
    
    This is a preparation patch for adding support for bulk streams to usbfs.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 9b73dd782c09..f1015cee5944 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -57,6 +57,7 @@ struct ep_device;
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
+ * @streams: number of USB-3 streams allocated on the endpoint
  *
  * USB requests are always queued to a given endpoint, identified by a
  * descriptor within an active interface in a given USB configuration.
@@ -71,6 +72,7 @@ struct usb_host_endpoint {
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
 	int enabled;
+	int streams;
 };
 
 /* host-side wrapper for one interface setting's parsed descriptors */

commit 8f5d35441ff26b31e3812556ce468c76f1eb216b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:19:24 2013 +0200

    usb-core: Move USB_MAXENDPOINTS definitions to usb.h
    
    So that it can be used in other places too.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7f6eb859873e..9b73dd782c09 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -202,6 +202,8 @@ static inline void usb_set_intfdata(struct usb_interface *intf, void *data)
 struct usb_interface *usb_get_intf(struct usb_interface *intf);
 void usb_put_intf(struct usb_interface *intf);
 
+/* Hard limit */
+#define USB_MAXENDPOINTS	30
 /* this maximum is arbitrary */
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)

commit 6e9c6e87a662c6665053fc3cc7840ed6fa80414e
Merge: e6bed035ca65 6d0abeca3242
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 17 14:45:02 2014 -0800

    Merge 3.14-rc3 into staging-next
    
    We want the fixes in this branch to make testing and future work easier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3d4b81eda2211f32886e2978daf6f39885042fc4
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Jan 31 11:52:57 2014 -0800

    Revert "usb: xhci: Link TRB must not occur within a USB payload burst"
    
    This reverts commit 35773dac5f862cb1c82ea151eba3e2f6de51ec3e.  It's a
    hack that caused regressions in the usb-storage and userspace USB
    drivers that use usbfs and libusb.  Commit 70cabb7d992f "xhci 1.0: Limit
    arbitrarily-aligned scatter gather." should fix the issues seen with the
    ax88179_178a driver on xHCI 1.0 hosts, without causing regressions.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org # 3.12

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c716da18c668..7f6eb859873e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1265,8 +1265,6 @@ typedef void (*usb_complete_t)(struct urb *);
  * @sg: scatter gather buffer list, the buffer size of each element in
  * 	the list (except the last) must be divisible by the endpoint's
  * 	max packet size if no_sg_constraint isn't set in 'struct usb_bus'
- * 	(FIXME: scatter-gather under xHCI is broken for periodic transfers.
- * 	Do not use urb->sg for interrupt endpoints for now, only bulk.)
  * @num_mapped_sgs: (internal) number of mapped sg entries
  * @num_sgs: number of entries in the sg list
  * @transfer_buffer_length: How big is transfer_buffer.  The transfer may

commit b7945b77cd03094458f3624bc82a27e0d36e75d0
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Thu Jan 23 23:12:29 2014 +0200

    staging: usbip: convert usbip-host driver to usb_device_driver
    
    This driver was previously an interface driver. Since USB/IP
    exports a whole device, not just an interface, it would make
    sense to be a device driver.
    
    This patch also modifies the way userspace sees and uses a
    shared device:
    
    * the usbip_status file is no longer created for interface 0, but for
    the whole device (such as
    /sys/devices/pci0000:00/0000:00:01.2/usb1/1-1/usbip_status).
    * per interface information, such as interface class or protocol, is
    no longer sent/received; only device specific information is
    transmitted.
    * since the driver was moved one level below in the USB architecture,
    there is no need to bind/unbind each interface, just the device as a
    whole.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c716da18c668..f434619f3975 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1668,6 +1668,10 @@ extern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);
 /* this request isn't really synchronous, but it belongs with the others */
 extern int usb_driver_set_configuration(struct usb_device *udev, int config);
 
+/* choose and set configuration for device */
+extern int usb_choose_configuration(struct usb_device *udev);
+extern int usb_set_configuration(struct usb_device *dev, int configuration);
+
 /*
  * timeouts, in milliseconds, used for sending/receiving control messages
  * they typically complete within a few frames (msec) after they're issued

commit 2fc82c2de604deabb86b0558be0a301bb2209a19
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri Jan 10 19:36:42 2014 +0100

    usb: core: allow a reference device for new_id
    
    Often, usb drivers need some driver_info to get a device to work. To
    have access to driver_info when using new_id, allow to pass a reference
    vendor:product tuple from which new_id will inherit driver_info.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 512ab162832c..c716da18c668 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -965,6 +965,7 @@ struct usb_dynid {
 };
 
 extern ssize_t usb_store_new_id(struct usb_dynids *dynids,
+				const struct usb_device_id *id_table,
 				struct device_driver *driver,
 				const char *buf, size_t count);
 

commit 35773dac5f862cb1c82ea151eba3e2f6de51ec3e
Author: David Laight <David.Laight@ACULAB.COM>
Date:   Mon Nov 11 12:26:54 2013 +0000

    usb: xhci: Link TRB must not occur within a USB payload burst
    
    Section 4.11.7.1 of rev 1.0 of the xhci specification states that a link TRB
    can only occur at a boundary between underlying USB frames (512 bytes for
    high speed devices).
    
    If this isn't done the USB frames aren't formatted correctly and, for example,
    the USB3 ethernet ax88179_178a card will stop sending (while still receiving)
    when running a netperf tcp transmit test with (say) and 8k buffer.
    
    This should be a candidate for stable, the ax88179_178a driver defaults to
    gso and tso enabled so it passes a lot of fragmented skb to the USB stack.
    
    Notes from Sarah:
    
    Discussion: http://marc.info/?l=linux-usb&m=138384509604981&w=2
    
    This patch fixes a long-standing xHCI driver bug that was revealed by a
    change in 3.12 in the usb-net driver.  Commit
    638c5115a794981441246fa8fa5d95c1875af5ba "USBNET: support DMA SG" added
    support to use bulk endpoint scatter-gather (urb->sg).  Only the USB
    ethernet drivers trigger this bug, because the mass storage driver sends
    sg list entries in page-sized chunks.
    
    This patch only fixes the issue for bulk endpoint scatter-gather.  The
    problem will still occur for periodic endpoints, because hosts will
    interpret no-op transfers as a request to skip a service interval, which
    is not what we want.
    
    Luckily, the USB core isn't set up for scatter-gather on isochronous
    endpoints, and no USB drivers use scatter-gather for interrupt
    endpoints.  Document this known limitation so that developers won't try
    to use urb->sg for interrupt endpoints until this issue is fixed.  The
    more comprehensive fix would be to allow link TRBs in the middle of the
    endpoint ring and revert this patch, but that fix would touch too much
    code to be allowed in for stable.
    
    This patch should be backported to kernels as old as 3.12, that contain
    the commit 638c5115a794981441246fa8fa5d95c1875af5ba "USBNET: support DMA
    SG".  Without this patch, the USB network device gets wedged, and stops
    sending packets.  Mark Lord confirms this patch fixes the regression:
    
    http://marc.info/?l=linux-netdev&m=138487107625966&w=2
    
    Signed-off-by: David Laight <david.laight@aculab.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Mark Lord <mlord@pobox.com>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7454865ad148..512ab162832c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1264,6 +1264,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @sg: scatter gather buffer list, the buffer size of each element in
  * 	the list (except the last) must be divisible by the endpoint's
  * 	max packet size if no_sg_constraint isn't set in 'struct usb_bus'
+ * 	(FIXME: scatter-gather under xHCI is broken for periodic transfers.
+ * 	Do not use urb->sg for interrupt endpoints for now, only bulk.)
  * @num_mapped_sgs: (internal) number of mapped sg entries
  * @num_sgs: number of entries in the sg list
  * @transfer_buffer_length: How big is transfer_buffer.  The transfer may

commit de68bab4fa96014cfaa6fcbcdb9750e32969fb86
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Sep 30 17:26:28 2013 +0300

    usb: Don't enable USB 2.0 Link PM by default.
    
    How it's supposed to work:
    --------------------------
    
    USB 2.0 Link PM is a lower power state that some newer USB 2.0 devices
    support.  USB 3.0 devices certified by the USB-IF are required to
    support it if they are plugged into a USB 2.0 only port, or a USB 2.0
    cable is used.  USB 2.0 Link PM requires both a USB device and a host
    controller that supports USB 2.0 hardware-enabled LPM.
    
    USB 2.0 Link PM is designed to be enabled once by software, and the host
    hardware handles transitions to the L1 state automatically.  The premise
    of USB 2.0 Link PM is to be able to put the device into a lower power
    link state when the bus is idle or the device NAKs USB IN transfers for
    a specified amount of time.
    
    ...but hardware is broken:
    --------------------------
    
    It turns out many USB 3.0 devices claim to support USB 2.0 Link PM (by
    setting the LPM bit in their USB 2.0 BOS descriptor), but they don't
    actually implement it correctly.  This manifests as the USB device
    refusing to respond to transfers when it is plugged into a USB 2.0 only
    port under the Haswell-ULT/Lynx Point LP xHCI host.
    
    These devices pass the xHCI driver's simple test to enable USB 2.0 Link
    PM, wait for the port to enter L1, and then bring it back into L0.  They
    only start to break when L1 entry is interleaved with transfers.
    
    Some devices then fail to respond to the next control transfer (usually
    a Set Configuration).  This results in devices never enumerating.
    
    Other mass storage devices (such as a later model Western Digital My
    Passport USB 3.0 hard drive) respond fine to going into L1 between
    control transfers.  They ACK the entry, come out of L1 when the host
    needs to send a control transfer, and respond properly to those control
    transfers.  However, when the first READ10 SCSI command is sent, the
    device NAKs the data phase while it's reading from the spinning disk.
    Eventually, the host requests to put the link into L1, and the device
    ACKs that request.  Then it never responds to the data phase of the
    READ10 command.  This results in not being able to read from the drive.
    
    Some mass storage devices (like the Corsair Survivor USB 3.0 flash
    drive) are well behaved.  They ACK the entry into L1 during control
    transfers, and when SCSI commands start coming in, they NAK the requests
    to go into L1, because they need to be at full power.
    
    Not all USB 3.0 devices advertise USB 2.0 link PM support.  My Point
    Grey USB 3.0 webcam advertises itself as a USB 2.1 device, but doesn't
    have a USB 2.0 BOS descriptor, so we don't enable USB 2.0 Link PM.  I
    suspect that means the device isn't certified.
    
    What do we do about it?
    -----------------------
    
    There's really no good way for the kernel to test these devices.
    Therefore, the kernel needs to disable USB 2.0 Link PM by default, and
    distros will have to enable it by writing 1 to the sysfs file
    /sys/bus/usb/devices/../power/usb2_hardware_lpm.  Rip out the xHCI Link
    PM test, since it's not sufficient to detect these buggy devices, and
    don't automatically enable LPM after the device is addressed.
    
    This patch should be backported to kernels as old as 3.11, that
    contain the commit a558ccdcc71c7770c5e80c926a31cfe8a3892a09 "usb: xhci:
    add USB2 Link power management BESL support".  Without this fix, some
    USB 3.0 devices will not enumerate or work properly under USB 2.0 ports
    on Haswell-ULT systems.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 055ba74bee80..7454865ad148 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -475,7 +475,8 @@ struct usb3_lpm_parameters {
  * @lpm_capable: device supports LPM
  * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM
  * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM
- * @usb2_hw_lpm_enabled: USB2 hardware LPM enabled
+ * @usb2_hw_lpm_enabled: USB2 hardware LPM is enabled
+ * @usb2_hw_lpm_allowed: Userspace allows USB 2.0 LPM to be enabled
  * @usb3_lpm_enabled: USB3 hardware LPM enabled
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
@@ -548,6 +549,7 @@ struct usb_device {
 	unsigned usb2_hw_lpm_capable:1;
 	unsigned usb2_hw_lpm_besl_capable:1;
 	unsigned usb2_hw_lpm_enabled:1;
+	unsigned usb2_hw_lpm_allowed:1;
 	unsigned usb3_lpm_enabled:1;
 	int string_langid;
 

commit 6ec4147e7bdbde168f5bce30de5984aa4f971b22
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:01:41 2013 +0200

    usb-anchor: Delay usb_wait_anchor_empty_timeout wake up till completion is done
    
    usb_wait_anchor_empty_timeout() should wait till the completion handler
    has run. Both the zd1211rw driver and the uas driver (in its task mgmt) depend
    on the completion handler having completed when usb_wait_anchor_empty_timeout()
    returns, as they read state set by the completion handler after an
    usb_wait_anchor_empty_timeout() call.
    
    But __usb_hcd_giveback_urb() calls usb_unanchor_urb before calling the
    completion handler. This is necessary as the completion handler may
    re-submit and re-anchor the urb. But this introduces a race where the state
    these drivers want to read has not been set yet by the completion handler
    (this race is easily triggered with the uas task mgmt code).
    
    I've considered adding an anchor_count to struct urb, which would be
    incremented on anchor and decremented on unanchor, and then only actually
    do the anchor / unanchor on 0 -> 1 and 1 -> 0 transtions, combined with
    moving the unanchor call in hcd_giveback_urb to after calling the completion
    handler. But this will only work if urb's are only re-anchored to the same
    anchor as they were anchored to before the completion handler ran.
    
    And at least one driver re-anchors to another anchor from the completion
    handler (rtlwifi).
    
    So I have come up with this patch instead, which adds the ability to
    suspend wakeups of usb_wait_anchor_empty_timeout() waiters to the usb_anchor
    functionality, and uses this in __usb_hcd_giveback_urb() to delay wake-ups
    until the completion handler has run.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index fa8bedf06c6e..055ba74bee80 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1209,6 +1209,7 @@ struct usb_anchor {
 	struct list_head urb_list;
 	wait_queue_head_t wait;
 	spinlock_t lock;
+	atomic_t suspend_wakeups;
 	unsigned int poisoned:1;
 };
 
@@ -1575,6 +1576,8 @@ extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_poison_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);
+extern void usb_anchor_suspend_wakeups(struct usb_anchor *anchor);
+extern void usb_anchor_resume_wakeups(struct usb_anchor *anchor);
 extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);
 extern void usb_unanchor_urb(struct urb *urb);
 extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,

commit 9ef73dbdd0fc292d183e93cd1d4b21d1a66040d7
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:01:40 2013 +0200

    usb-anchor: Ensure poisened gets initialized to 0
    
    And do so in a way which ensures that any fields added in the future will
    also get properly zero-ed.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f726c39097e0..fa8bedf06c6e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1214,6 +1214,7 @@ struct usb_anchor {
 
 static inline void init_usb_anchor(struct usb_anchor *anchor)
 {
+	memset(anchor, 0, sizeof(*anchor));
 	INIT_LIST_HEAD(&anchor->urb_list);
 	init_waitqueue_head(&anchor->wait);
 	spin_lock_init(&anchor->lock);

commit 6c74dada4f5a37037dee1da6a8a7aeb56c558bca
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Aug 30 14:03:59 2013 +0200

    usb-core: Make usb_free_streams return an error
    
    The hcd-driver free_streams method can return an error, so lets properly
    propagate that.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 001629cd1a97..f726c39097e0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -702,7 +702,7 @@ extern int usb_alloc_streams(struct usb_interface *interface,
 		unsigned int num_streams, gfp_t mem_flags);
 
 /* Reverts a group of bulk endpoints back to not using stream IDs. */
-extern void usb_free_streams(struct usb_interface *interface,
+extern int usb_free_streams(struct usb_interface *interface,
 		struct usb_host_endpoint **eps, unsigned int num_eps,
 		gfp_t mem_flags);
 

commit bcc48f1a7a0d40ae2e5a26aff72c2b674fd8b596
Author: Ming Lei <ming.lei@canonical.com>
Date:   Thu Aug 8 21:48:22 2013 +0800

    USB: introduce usb_device_no_sg_constraint() helper
    
    Some host controllers(such as xHCI) can support building
    packet from discontinuous buffers, so introduce one flag
    and helper for this kind of host controllers, then the
    feature can help some applications(such as usbnet) by
    supporting arbitrary length of sg buffers.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index acb1b0aa77d8..001629cd1a97 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -337,6 +337,7 @@ struct usb_bus {
 					 * the ep queue on a short transfer
 					 * with the URB_SHORT_NOT_OK flag set.
 					 */
+	unsigned no_sg_constraint:1;	/* no sg constraint */
 	unsigned sg_tablesize;		/* 0 or largest number of sg list entries */
 
 	int devnum_next;		/* Next open device number in
@@ -684,6 +685,11 @@ static inline bool usb_device_supports_ltm(struct usb_device *udev)
 	return udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;
 }
 
+static inline bool usb_device_no_sg_constraint(struct usb_device *udev)
+{
+	return udev && udev->bus && udev->bus->no_sg_constraint;
+}
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -1253,7 +1259,7 @@ typedef void (*usb_complete_t)(struct urb *);
  *	transfer_buffer.
  * @sg: scatter gather buffer list, the buffer size of each element in
  * 	the list (except the last) must be divisible by the endpoint's
- * 	max packet size
+ * 	max packet size if no_sg_constraint isn't set in 'struct usb_bus'
  * @num_mapped_sgs: (internal) number of mapped sg entries
  * @num_sgs: number of entries in the sg list
  * @transfer_buffer_length: How big is transfer_buffer.  The transfer may

commit 626f090c5cbbe557379978c7a9525011ad7fbbf6
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Fri Aug 2 20:10:04 2013 +0200

    usb: fix some scripts/kernel-doc warnings
    
    When building the htmldocs (in verbose mode), scripts/kernel-doc reports the
    following type of warnings:
    
    Warning(drivers/usb/core/usb.c:76): No description found for return value of
    'usb_find_alt_setting'
    
    Fix them by:
    - adding some missing descriptions of return values
    - using "Return" sections for those descriptions
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6efdab089014..acb1b0aa77d8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -708,7 +708,10 @@ extern int usb_driver_claim_interface(struct usb_driver *driver,
  * usb_interface_claimed - returns true iff an interface is claimed
  * @iface: the interface being checked
  *
- * Returns true (nonzero) iff the interface is claimed, else false (zero).
+ * Return: %true (nonzero) iff the interface is claimed, else %false
+ * (zero).
+ *
+ * Note:
  * Callers must own the driver model's usb bus readlock.  So driver
  * probe() entries don't need extra locking, but other call contexts
  * may need to explicitly claim that lock.
@@ -745,8 +748,9 @@ extern struct usb_host_interface *usb_find_alt_setting(
  * @buf: where to put the string
  * @size: how big is "buf"?
  *
- * Returns length of the string (> 0) or negative if size was too small.
+ * Return: Length of the string (> 0) or negative if size was too small.
  *
+ * Note:
  * This identifier is intended to be "stable", reflecting physical paths in
  * hardware such as physical bus addresses for host controllers or ports on
  * USB hubs.  That makes it stay the same until systems are physically
@@ -1578,7 +1582,7 @@ extern int usb_anchor_empty(struct usb_anchor *anchor);
  * usb_urb_dir_in - check if an URB describes an IN transfer
  * @urb: URB to be checked
  *
- * Returns 1 if @urb describes an IN transfer (device-to-host),
+ * Return: 1 if @urb describes an IN transfer (device-to-host),
  * otherwise 0.
  */
 static inline int usb_urb_dir_in(struct urb *urb)
@@ -1590,7 +1594,7 @@ static inline int usb_urb_dir_in(struct urb *urb)
  * usb_urb_dir_out - check if an URB describes an OUT transfer
  * @urb: URB to be checked
  *
- * Returns 1 if @urb describes an OUT transfer (host-to-device),
+ * Return: 1 if @urb describes an OUT transfer (host-to-device),
  * otherwise 0.
  */
 static inline int usb_urb_dir_out(struct urb *urb)

commit 78283dd29e647775cb1e63a4d6554b3090b9a9ff
Merge: 435932f2c75e 5ae90d8e467e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 29 07:43:16 2013 -0700

    Merge 3.11-rc3 into usb-next

commit 42189d854f174e7b29e0fdb4da9984ba63126a92
Author: Felipe Balbi <balbi@ti.com>
Date:   Tue Jul 2 10:50:15 2013 +0300

    usb: clamp bInterval to allowed range
    
    bInterval must be within the range 1 - 16
    when running at High/Super speed, and within
    the range 1 - 255 when running at Full/Low speed.
    
    In order to catch drivers passing a too
    large bInterval on Super/High speed scenarios
    (thus overflowing urb->interval), let's clamp()
    the argument to the allowed ranges.
    
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e99b2a114af4..eb4252a0da7e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1547,10 +1547,16 @@ static inline void usb_fill_int_urb(struct urb *urb,
 	urb->transfer_buffer_length = buffer_length;
 	urb->complete = complete_fn;
 	urb->context = context;
-	if (dev->speed == USB_SPEED_HIGH || dev->speed == USB_SPEED_SUPER)
+
+	if (dev->speed == USB_SPEED_HIGH || dev->speed == USB_SPEED_SUPER) {
+		/* make sure interval is within allowed range */
+		interval = clamp(interval, 1, 16);
+
 		urb->interval = 1 << (interval - 1);
-	else
+	} else {
 		urb->interval = interval;
+	}
+
 	urb->start_frame = -1;
 }
 

commit 10e232c597ac757e7f8600649f7e872e86de190f
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Jun 28 09:38:12 2013 +0800

    USB: check sg buffer size in usb_submit_urb
    
    USB spec stats that short packet can only appear at the end
    of transfer. Because lost of HC(EHCI/UHCI/OHCI/...) can't
    build a full packet from discontinuous buffers, we introduce
    the limit in usb_submit_urb() to avoid such kind of bad sg buffers
    coming from driver.
    
    The limit might be a bit strict:
            - platform has iommu to do sg list mapping
            - some host controllers may support to build full packet from
            discontinuous buffers.
    
    But considered that most of HCs don't support that, and driver
    need work well or keep consistent on different HCs and ARCHs, we
    have to introduce the limit.
    
    Currently, only usbtest is reported to pass such sg buffers to HC,
    and other users(mass storage, usbfs) don't have the problem.
    
    We don't check it on USB wireless device, because:
            - wireless devices can't be attached to common USB
              bus(EHCI/UHCI/OHCI/...)
            - the max packet size of endpoint may be odd, and often can't
            devide 4KB which is a typical usage in usb mass storage application
    
    Reported-by: Konstantin Filatov <kfilatov@parallels.com>
    Reported-by: Denis V. Lunev <den@openvz.org>
    Cc: Felipe Balbi <balbi@ti.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a232b7ece1f6..e99b2a114af4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1258,7 +1258,9 @@ typedef void (*usb_complete_t)(struct urb *);
  *	the device driver is saying that it provided this DMA address,
  *	which the host controller driver should use in preference to the
  *	transfer_buffer.
- * @sg: scatter gather buffer list
+ * @sg: scatter gather buffer list, the buffer size of each element in
+ * 	the list (except the last) must be divisible by the endpoint's
+ * 	max packet size
  * @num_mapped_sgs: (internal) number of mapped sg entries
  * @num_sgs: number of entries in the sg list
  * @transfer_buffer_length: How big is transfer_buffer.  The transfer may

commit 36ff66db3fb5642906e46e73ca9cf92f1c5974ff
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 27 15:27:07 2013 -0400

    USB: move the definition of USB_MAXCHILDREN
    
    The USB_MAXCHILDREN symbol is used in include/uapi/linux/usb/ch11.h, a
    user-mode header, even though it is defined in include/linux/usb.h,
    which is kernel-only.  This causes compile-time errors when user
    programs try to #include linux/usb/ch11.h.
    
    This patch fixes the problem by moving the definition of USB_MAXCHILDREN
    into ch11.h.  It also gets rid of unneeded parentheses.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a232b7ece1f6..0eec2689b955 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -367,17 +367,6 @@ struct usb_bus {
 
 /* ----------------------------------------------------------------------- */
 
-/* This is arbitrary.
- * From USB 2.0 spec Table 11-13, offset 7, a hub can
- * have up to 255 ports. The most yet reported is 10.
- *
- * Current Wireless USB host hardware (Intel i1480 for example) allows
- * up to 22 devices to connect. Upcoming hardware might raise that
- * limit. Because the arrays need to add a bit for hub status data, we
- * do 31, so plus one evens out to four bytes.
- */
-#define USB_MAXCHILDREN		(31)
-
 struct usb_tt;
 
 enum usb_device_removable {

commit 17f34867e98d2fb0c03918faab79efb989fa134b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 23 17:14:31 2013 +0300

    usb: add usb2 Link PM variables to sysfs and usb_device
    
    Adds abitilty to tune L1 timeout (inactivity timer for usb2 link sleep)
    and BESL (best effort service latency)via sysfs.
    
    This also adds a new usb2_lpm_parameters structure with those variables to
    struct usb_device.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index fe444989668a..a232b7ece1f6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -393,6 +393,22 @@ enum usb_port_connect_type {
 	USB_PORT_NOT_USED,
 };
 
+/*
+ * USB 2.0 Link Power Management (LPM) parameters.
+ */
+struct usb2_lpm_parameters {
+	/* Best effort service latency indicate how long the host will drive
+	 * resume on an exit from L1.
+	 */
+	unsigned int besl;
+
+	/* Timeout value in microseconds for the L1 inactivity (LPM) timer.
+	 * When the timer counts to zero, the parent hub will initiate a LPM
+	 * transition to L1.
+	 */
+	int timeout;
+};
+
 /*
  * USB 3.0 Link Power Management (LPM) parameters.
  *
@@ -488,6 +504,7 @@ struct usb3_lpm_parameters {
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
  * @removable: Device can be physically removed from this port
+ * @l1_params: best effor service latency for USB2 L1 LPM state, and L1 timeout.
  * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.
  * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.
  * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()
@@ -568,6 +585,7 @@ struct usb_device {
 	struct wusb_dev *wusb_dev;
 	int slot_id;
 	enum usb_device_removable removable;
+	struct usb2_lpm_parameters l1_params;
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
 	unsigned lpm_disable_count;

commit a558ccdcc71c7770c5e80c926a31cfe8a3892a09
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu May 23 17:14:30 2013 +0300

    usb: xhci: add USB2 Link power management BESL support
    
    usb 2.0 devices with link power managment (LPM) can describe their idle link
    timeouts either in BESL or HIRD format, so far xHCI has only supported HIRD but
    later xHCI errata add BESL support as well
    
    BESL timeouts need to inform exit latency changes with an evaluate
    context command the same way USB 3.0 link PM code does.
    The same xhci_change_max_exit_latency() function is used as with USB3
    but code is pulled out from #ifdef CONFIG_PM as USB2.0 BESL LPM
    funcionality does not depend on CONFIG_PM.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b424e5318f20..fe444989668a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -468,6 +468,7 @@ struct usb3_lpm_parameters {
  * @wusb: device is Wireless USB
  * @lpm_capable: device supports LPM
  * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM
+ * @usb2_hw_lpm_besl_capable: device can perform USB2 hardware BESL LPM
  * @usb2_hw_lpm_enabled: USB2 hardware LPM enabled
  * @usb3_lpm_enabled: USB3 hardware LPM enabled
  * @string_langid: language ID for strings
@@ -538,6 +539,7 @@ struct usb_device {
 	unsigned wusb:1;
 	unsigned lpm_capable:1;
 	unsigned usb2_hw_lpm_capable:1;
+	unsigned usb2_hw_lpm_besl_capable:1;
 	unsigned usb2_hw_lpm_enabled:1;
 	unsigned usb3_lpm_enabled:1;
 	int string_langid;

commit 9b790915450e2e2eb9a8df7fe32f41e895de9da1
Author: Julius Werner <jwerner@chromium.org>
Date:   Fri May 17 12:08:51 2013 -0700

    usb: ehci: Only sleep for post-resume handover if devices use persist
    
    The current EHCI code sleeps a flat 110ms in the resume path if there
    was a USB 1.1 device connected to its companion controller during
    suspend, waiting for the device to reappear and reset so that it can be
    handed back to the companion. This is necessary if the device uses
    persist, so that the companion controller can actually see it during its
    own resume path.
    
    However, if the device doesn't use persist, this is entirely
    unnecessary. We might just as well ignore it and have the normal device
    detection/reset/handoff code handle it asynchronously when it eventually
    shows up. As USB 1.1 devices are almost exclusively HIDs these days (for
    which persist has no value), this can allow distros to shave another
    tenth of a second off their resume time.
    
    In order to enable this optimization, the patch also adds a new
    usb_for_each_dev() iterator that is exported by the USB core and wraps
    bus_for_each_dev() with the logic to differentiate between struct
    usb_device and struct usb_interface on the usb_bus_type bus.
    
    Signed-off-by: Julius Werner <jwerner@chromium.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a0bee5a28d1a..b424e5318f20 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -717,6 +717,7 @@ const struct usb_device_id *usb_match_id(struct usb_interface *interface,
 extern int usb_match_one_id(struct usb_interface *interface,
 			    const struct usb_device_id *id);
 
+extern int usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *));
 extern struct usb_interface *usb_find_interface(struct usb_driver *drv,
 		int minor);
 extern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,

commit 84ebc10294a3d7be4c66f51070b7aedbaa24de9b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 27 16:14:46 2013 -0400

    USB: remove CONFIG_USB_SUSPEND option
    
    This patch (as1675) removes the CONFIG_USB_SUSPEND option, essentially
    replacing it everywhere with CONFIG_PM_RUNTIME (except for one place
    in hub.c, where it is replaced with CONFIG_PM because the code needs
    to be used in both runtime and system PM).  The net result is code
    shrinkage and simplification.
    
    There's very little point in keeping CONFIG_USB_SUSPEND because almost
    everybody enables it.  The few that don't will find that the usbcore
    module has gotten somewhat bigger and they will have to take active
    measures if they want to prevent hubs from being runtime suspended.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8d4bc173d66a..a0bee5a28d1a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -617,7 +617,7 @@ static inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)
 #endif
 
 /* USB autosuspend and autoresume */
-#ifdef CONFIG_USB_SUSPEND
+#ifdef CONFIG_PM_RUNTIME
 extern void usb_enable_autosuspend(struct usb_device *udev);
 extern void usb_disable_autosuspend(struct usb_device *udev);
 

commit 303f0847925ece27129487a2bfc05199ab2a0b51
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Mar 15 12:08:53 2013 +0800

    USB: adds comment on suspend callback
    
    This patch adds comments on interface driver suspend callback
    to emphasize that the failure return value is ignored by
    USB core in system sleep context, so do not try to recover
    device for this case and let resume/reset_resume callback
    handle the suspend failure if needed.
    
    Also kerneldoc for usb_suspend_both() is updated with the
    fact.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 52464fb2389b..8d4bc173d66a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -976,7 +976,12 @@ struct usbdrv_wrap {
  *	the "usbfs" filesystem.  This lets devices provide ways to
  *	expose information to user space regardless of where they
  *	do (or don't) show up otherwise in the filesystem.
- * @suspend: Called when the device is going to be suspended by the system.
+ * @suspend: Called when the device is going to be suspended by the
+ *	system either from system sleep or runtime suspend context. The
+ *	return value will be ignored in system sleep context, so do NOT
+ *	try to continue using the device if suspend fails in this case.
+ *	Instead, let the resume or reset-resume routine recover from
+ *	the failure.
  * @resume: Called when the device is being resumed by the system.
  * @reset_resume: Called when the suspended device has been reset instead
  *	of being resumed.

commit dad3cab3e063110b3ae3dc82a00e7aacd09b91ec
Author: Nishanth Menon <nm@ti.com>
Date:   Mon Mar 4 16:52:49 2013 -0600

    USB: fix trivial usb_device kernel-doc errors
    
    Fix trivial kernel-doc warnings:
    Warning(include/linux/usb.h:574): No description found for parameter 'usb3_lpm_enabled'
    Warning(include/linux/usb.h:574): Excess struct/union/enum/typedef member 'usb_classdev' description in 'usb_device'
    Warning(include/linux/usb.h:574): Excess struct/union/enum/typedef member 'usbfs_dentry' description in 'usb_device'
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Kosina <trivial@kernel.org>
    Cc: linux-usb@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4d22d0f6167a..52464fb2389b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -469,14 +469,12 @@ struct usb3_lpm_parameters {
  * @lpm_capable: device supports LPM
  * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM
  * @usb2_hw_lpm_enabled: USB2 hardware LPM enabled
+ * @usb3_lpm_enabled: USB3 hardware LPM enabled
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
  * @manufacturer: iManufacturer string, if present (static)
  * @serial: iSerialNumber string, if present (static)
  * @filelist: usbfs files that are open to this device
- * @usb_classdev: USB class device that was created for usbfs device
- *	access from userspace
- * @usbfs_dentry: usbfs dentry entry for the device
  * @maxchild: number of ports if hub
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device

commit da0aa7169b97d90f4af39a9dc84d58bbe19d7e78
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 25 17:09:42 2013 -0500

    USB: add usb_hcd_{start,end}_port_resume
    
    This patch (as1649) adds a mechanism for host controller drivers to
    inform usbcore when they have begun or ended resume signalling on a
    particular root-hub port.  The core will then make sure that the root
    hub does not get runtime-suspended while the port resume is going on.
    
    Since commit 596d789a211d134dc5f94d1e5957248c204ef850 (USB: set hub's
    default autosuspend delay as 0), the system tries to suspend hubs
    whenever they aren't in use.  While a root-hub port is being resumed,
    the root hub does not appear to be in use.  Attempted runtime suspends
    fail because of the ongoing port resume, but the PM core just keeps on
    trying over and over again.  We want to prevent this wasteful effort.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 689b14b26c8d..4d22d0f6167a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -357,6 +357,8 @@ struct usb_bus {
 	int bandwidth_int_reqs;		/* number of Interrupt requests */
 	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
 
+	unsigned resuming_ports;	/* bit array: resuming root-hub ports */
+
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */

commit 17b72feb2be14e6d37023267dc0e199e8e0e3fdc
Author: Bjrn Mork <bjorn@mork.no>
Date:   Wed Oct 31 06:08:39 2012 +0100

    USB: add USB_DEVICE_INTERFACE_CLASS macro
    
    Matching on device and interface class with with unspecified
    subclass and protocol is sometimes useful.  This is slightly
    different from USB_DEVICE_AND_INTERFACE_INFO which requires
    the full interface class/subclass/protocol triplet.
    
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f51f9981de1e..689b14b26c8d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -807,6 +807,22 @@ static inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)
 	.bcdDevice_lo = (lo), \
 	.bcdDevice_hi = (hi)
 
+/**
+ * USB_DEVICE_INTERFACE_CLASS - describe a usb device with a specific interface class
+ * @vend: the 16 bit USB Vendor ID
+ * @prod: the 16 bit USB Product ID
+ * @cl: bInterfaceClass value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific interface class of devices.
+ */
+#define USB_DEVICE_INTERFACE_CLASS(vend, prod, cl) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+		       USB_DEVICE_ID_MATCH_INT_CLASS, \
+	.idVendor = (vend), \
+	.idProduct = (prod), \
+	.bInterfaceClass = (cl)
+
 /**
  * USB_DEVICE_INTERFACE_PROTOCOL - describe a usb device with a specific interface protocol
  * @vend: the 16 bit USB Vendor ID

commit bfd1e910139be73fb0783a0b3171fc79e6afa031
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 19 11:03:39 2012 -0400

    USB: speed up usb_bus_resume()
    
    This patch (as1620) speeds up USB root-hub resumes in the common case
    where every enabled port has its suspend feature set (which currently
    will be true for every runtime resume of the root hub).  If all the
    enabled ports are suspended then resuming the root hub won't resume
    any of the downstream devices.  In this case there's no need for a
    Resume Recovery delay, because that delay is meant to give devices a
    chance to get ready for active use.
    
    To keep track of the port suspend features, the patch adds a
    "port_is_suspended" flag to struct usb_device.  This has to be tracked
    separately from the device's state; it's entirely possible for a USB-2
    device to be suspended while the suspend feature on its parent port is
    clear.  The reason is that devices will go into suspend whenever their
    parent hub does.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reviewed-by: Peter Chen <peter.chen@freescale.com>
    Tested-by: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5df7c87b277f..f51f9981de1e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -482,6 +482,7 @@ struct usb3_lpm_parameters {
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
+ * @port_is_suspended: the upstream port is suspended (L2 or U3)
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
@@ -560,6 +561,7 @@ struct usb_device {
 
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
+	unsigned port_is_suspended:1;
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;

commit 969ddcfc95c9a1849114fb72466d2fdea70f1d48
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 19 11:03:02 2012 -0400

    USB: hub_for_each_child should skip unconnected ports
    
    This patch (as1619) improves the interface to the "hub_for_each_child"
    macro.  The name clearly suggests that the macro iterates over child
    devices; it does not suggest that the loop will also iterate over
    unnconnected ports.
    
    The patch changes the macro so that it will skip over unconnected
    ports and iterate only the actual child devices.  The two existing
    call sites are updated to avoid testing for a NULL child pointer,
    which is now unnecessary.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f92cdf0c1457..5df7c87b277f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -588,8 +588,9 @@ extern struct usb_device *usb_hub_find_child(struct usb_device *hdev,
  */
 #define usb_hub_for_each_child(hdev, port1, child) \
 	for (port1 = 1,	child =	usb_hub_find_child(hdev, port1); \
-		port1 <= hdev->maxchild; \
-		child = usb_hub_find_child(hdev, ++port1))
+			port1 <= hdev->maxchild; \
+			child = usb_hub_find_child(hdev, ++port1)) \
+		if (!child) continue; else
 
 /* USB device locking */
 #define usb_lock_device(udev)		device_lock(&(udev)->dev)

commit a03bede5c73a6876fa891cfe82a65460dc9f4698
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 1 10:31:53 2012 -0400

    USB: update documentation for URB_ISO_ASAP
    
    This patch (as1611) updates the USB documentation and kerneldoc to
    give a more precise meaning for the URB_ISO_ASAP flag and to explain
    more of the details of scheduling for isochronous URBs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 10278d18709c..f92cdf0c1457 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1129,8 +1129,8 @@ extern int usb_disabled(void);
  * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
-#define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame
-					 * ignored */
+#define URB_ISO_ASAP		0x0002	/* iso-only; use the first unexpired
+					 * slot in the schedule */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb->transfer_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
@@ -1309,15 +1309,20 @@ typedef void (*usb_complete_t)(struct urb *);
  * the transfer interval in the endpoint descriptor is logarithmic.
  * Device drivers must convert that value to linear units themselves.)
  *
- * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling
- * the host controller to schedule the transfer as soon as bandwidth
- * utilization allows, and then set start_frame to reflect the actual frame
- * selected during submission.  Otherwise drivers must specify the start_frame
- * and handle the case where the transfer can't begin then.  However, drivers
- * won't know how bandwidth is currently allocated, and while they can
- * find the current frame using usb_get_current_frame_number () they can't
- * know the range for that frame number.  (Ranges for frame counter values
- * are HC-specific, and can go from 256 to 65536 frames from "now".)
+ * If an isochronous endpoint queue isn't already running, the host
+ * controller will schedule a new URB to start as soon as bandwidth
+ * utilization allows.  If the queue is running then a new URB will be
+ * scheduled to start in the first transfer slot following the end of the
+ * preceding URB, if that slot has not already expired.  If the slot has
+ * expired (which can happen when IRQ delivery is delayed for a long time),
+ * the scheduling behavior depends on the URB_ISO_ASAP flag.  If the flag
+ * is clear then the URB will be scheduled to start in the expired slot,
+ * implying that some of its packets will not be transferred; if the flag
+ * is set then the URB will be scheduled in the first unexpired slot,
+ * breaking the queue's synchronization.  Upon URB completion, the
+ * start_frame field will be set to the (micro)frame number in which the
+ * transfer was scheduled.  Ranges for frame counter values are HC-specific
+ * and can go from as low as 256 to as high as 65536 frames.
  *
  * Isochronous URBs have a different data transfer model, in part because
  * the quality of service is only "best effort".  Callers provide specially

commit 2c78040c3e2735b8286bbb848db0372b8d408e2d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Oct 5 15:09:38 2012 -0700

    USB: usb.h: remove dbg() macro
    
    There are no users of this macro anymore in the kernel tree, so finally
    delete it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 07915a32fb9d..10278d18709c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1778,17 +1778,6 @@ static inline int usb_translate_errors(int error_code)
 extern void usb_register_notify(struct notifier_block *nb);
 extern void usb_unregister_notify(struct notifier_block *nb);
 
-#ifdef DEBUG
-#define dbg(format, arg...)						\
-	printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg)
-#else
-#define dbg(format, arg...)						\
-do {									\
-	if (0)								\
-		printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg); \
-} while (0)
-#endif
-
 /* debugfs stuff */
 extern struct dentry *usb_debug_root;
 

commit f7ac7787ad361e31a7972e2854ed8dc2eedfac3b
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Sep 5 13:44:36 2012 +0800

    usb/acpi: Use ACPI methods to power off ports.
    
    Upcoming Intel systems will have an ACPI method to control whether a USB
    port can be completely powered off.  The implication of powering off a
    USB port is that the device and host sees a physical disconnect, and
    subsequent port connections and remote wakeups will be lost.
    
    Add a new function, usb_acpi_power_manageable(), that can be used to
    find whether the usb port has ACPI power resources that can be used to
    power on and off the port on these machines. Also add a new function
    called usb_acpi_set_power_state() that controls the port power via these
    ACPI methods.
    
    When the USB core calls into the xHCI hub driver to power off a port,
    check whether the port can be completely powered off via this new ACPI
    mechanism.  If so, call into these new ACPI methods.  Also use the ACPI
    methods when the USB core asks to power on a port.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e0084a1fa37f..07915a32fb9d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -602,6 +602,16 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 extern int usb_reset_device(struct usb_device *dev);
 extern void usb_queue_reset_device(struct usb_interface *dev);
 
+#ifdef CONFIG_ACPI
+extern int usb_acpi_set_power_state(struct usb_device *hdev, int index,
+	bool enable);
+extern bool usb_acpi_power_manageable(struct usb_device *hdev, int index);
+#else
+static inline int usb_acpi_set_power_state(struct usb_device *hdev, int index,
+	bool enable) { return 0; }
+static inline bool usb_acpi_power_manageable(struct usb_device *hdev, int index)
+	{ return true; }
+#endif
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND

commit 05f916894a692f0cc0973aef21521133623b21c0
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Sep 5 13:44:34 2012 +0800

    usb/acpi: Store info on device removability.
    
    In the upcoming USB port power off patches, we need to know whether a
    USB port can ever see a disconnect event.  Often USB ports are internal
    to a system, and users can't disconnect USB devices from that port.
    Sometimes those ports will remain empty, because the OEM chose not to
    connect an internal USB device to that port.
    
    According to ACPI Spec 9.13, PLD indicates whether USB port is
    user visible and _UPC indicates whether a USB device can be connected to
    the USB port (we'll call this "connectible").  Here's a matrix of the
    possible combinations:
    
    Visible Connectible
                    Name            Example
    -------------------------------------------------------------------------
    
    Yes     No      Unknown         (Invalid state.)
    
    Yes     Yes     Hot-plug        USB ports on the outside of a laptop.
                                    A user could freely connect and disconnect
                                    USB devices.
    
    No      Yes     Hard-wired      A USB modem hard-wired to a port on the
                                    inside of a laptop.
    
    No      No      Not used        The port is internal to the system and
                                    will remain empty.
    
    Represent each of these four states with an enum usb_port_connect_type.
    The four states are USB_PORT_CONNECT_TYPE_UNKNOWN,
    USB_PORT_CONNECT_TYPE_HOT_PLUG, USB_PORT_CONNECT_TYPE_HARD_WIRED, and
    USB_PORT_NOT_USED.  When we get the USB port's acpi_handle, store the
    state in connect_type in struct usb_port.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index ff8ef2d28589..e0084a1fa37f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -384,6 +384,13 @@ enum usb_device_removable {
 	USB_DEVICE_FIXED,
 };
 
+enum usb_port_connect_type {
+	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
+	USB_PORT_CONNECT_TYPE_HOT_PLUG,
+	USB_PORT_CONNECT_TYPE_HARD_WIRED,
+	USB_PORT_NOT_USED,
+};
+
 /*
  * USB 3.0 Link Power Management (LPM) parameters.
  *

commit ff823c79a5c33194c2e5594f7c4686ea3547910c
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Sep 5 13:44:32 2012 +0800

    usb: move children to struct usb_port
    
    The usb_device structure contains an array of usb_device "children".
    This array is only valid if the usb_device is a hub, so it makes no
    sense to store it there.  Instead, store the usb_device child
    in its parent usb_port structure.
    
    Since usb_port is an internal USB core structure, add a new function to
    get the USB device child, usb_hub_find_child().  Add a new macro,
    usb_hub_get_each_child(), to iterate over all the children attached to a
    particular USB hub.
    
    Remove the printing the USB children array pointer from the usb-ip
    driver, since it's really not necessary.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 30d1ae38eab1..ff8ef2d28589 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -469,7 +469,6 @@ struct usb3_lpm_parameters {
  *	access from userspace
  * @usbfs_dentry: usbfs dentry entry for the device
  * @maxchild: number of ports if hub
- * @children: child devices - USB devices that are attached to this hub
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
@@ -543,7 +542,6 @@ struct usb_device {
 	struct list_head filelist;
 
 	int maxchild;
-	struct usb_device **children;
 
 	u32 quirks;
 	atomic_t urbnum;
@@ -572,6 +570,19 @@ static inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)
 
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
+extern struct usb_device *usb_hub_find_child(struct usb_device *hdev,
+	int port1);
+
+/**
+ * usb_hub_for_each_child - iterate over all child devices on the hub
+ * @hdev:  USB device belonging to the usb hub
+ * @port1: portnum associated with child device
+ * @child: child device pointer
+ */
+#define usb_hub_for_each_child(hdev, port1, child) \
+	for (port1 = 1,	child =	usb_hub_find_child(hdev, port1); \
+		port1 <= hdev->maxchild; \
+		child = usb_hub_find_child(hdev, ++port1))
 
 /* USB device locking */
 #define usb_lock_device(udev)		device_lock(&(udev)->dev)

commit d81a5d1956731c453b85c141458d4ff5d6cc5366
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Tue Jul 10 19:10:06 2012 -0300

    USB: add USB_VENDOR_AND_INTERFACE_INFO() macro
    
    A lot of Broadcom Bluetooth devices provides vendor specific interface
    class and we are getting flooded by patches adding new device support.
    This change will help us enable support for any other Broadcom with vendor
    specific device that arrives in the future.
    
    Only the product id changes for those devices, so this macro would be
    perfect for us:
    
    { USB_VENDOR_AND_INTERFACE_INFO(0x0a5c, 0xff, 0x01, 0x01) }
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Acked-by: Henrik Rydberg <rydberg@bitmath.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 873956bec25e..30d1ae38eab1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -861,6 +861,27 @@ static inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)
 	.bInterfaceSubClass = (sc), \
 	.bInterfaceProtocol = (pr)
 
+/**
+ * USB_VENDOR_AND_INTERFACE_INFO - describe a specific usb vendor with a class of usb interfaces
+ * @vend: the 16 bit USB Vendor ID
+ * @cl: bInterfaceClass value
+ * @sc: bInterfaceSubClass value
+ * @pr: bInterfaceProtocol value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific vendor with a specific class of interfaces.
+ *
+ * This is especially useful when explicitly matching devices that have
+ * vendor specific bDeviceClass values, but standards-compliant interfaces.
+ */
+#define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+		| USB_DEVICE_ID_MATCH_VENDOR, \
+	.idVendor = (vend), \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), \
+	.bInterfaceProtocol = (pr)
+
 /* ----------------------------------------------------------------------- */
 
 /* Stuff for dynamic usb ids */

commit 0d5ff306582834e3172365d619ec0cfe7a4f79ba
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Tue Jul 10 17:19:25 2012 +0100

    USB: remove 8 bytes of padding from usb_host_interface on 64 bit builds
    
    Reorder elements in the usb_host_interface structure to remove 8 bytes
    of padding on 64 bit builds , and so shrink it's size to 40 bytes.
    
    usb_interface_descriptor is a odd size which leaves a gap that is not
    big enough to hold a pointer, so moving extralen into that gap removes
    the need for more padding.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f8506ed0f97b..873956bec25e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -77,14 +77,15 @@ struct usb_host_endpoint {
 struct usb_host_interface {
 	struct usb_interface_descriptor	desc;
 
+	int extralen;
+	unsigned char *extra;   /* Extra descriptors */
+
 	/* array of desc.bNumEndpoint endpoints associated with this
 	 * interface setting.  these will be in no particular order.
 	 */
 	struct usb_host_endpoint *endpoint;
 
 	char *string;		/* iInterface string, if present */
-	unsigned char *extra;   /* Extra descriptors */
-	int extralen;
 };
 
 enum usb_interface_condition {

commit 024f117c2f3c4bb5df6e6696b709e0f3ed7e5dbb
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 5 17:17:24 2012 -0700

    USB: Add a sysfs file to show LTM capabilities.
    
    USB 3.0 devices can optionally support Latency Tolerance Messaging
    (LTM).  Add a new sysfs file in the device directory to show whether a
    device is LTM capable.  This file will be present for both USB 2.0 and
    USB 3.0 devices.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f29831bad235..f8506ed0f97b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -636,6 +636,14 @@ extern void usb_unlocked_enable_lpm(struct usb_device *udev);
 extern int usb_disable_ltm(struct usb_device *udev);
 extern void usb_enable_ltm(struct usb_device *udev);
 
+static inline bool usb_device_supports_ltm(struct usb_device *udev)
+{
+	if (udev->speed != USB_SPEED_SUPER || !udev->bos || !udev->bos->ss_cap)
+		return false;
+	return udev->bos->ss_cap->bmAttributes & USB_LTM_SUPPORT;
+}
+
+
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */

commit f74631e3426474183389e55f703797bd965cd356
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Jun 25 12:08:08 2012 -0700

    USB: Enable Latency Tolerance Messaging (LTM).
    
    USB 3.0 devices may optionally support a new feature called Latency
    Tolerance Messaging.  If both the xHCI host controller and the device
    support LTM, it should be turned on in order to give the system hardware
    a better clue about the latency tolerance values of its PCI devices.
    
    Once a Set Feature request to enable LTM is received, the USB 3.0 device
    will begin to send LTM updates as its buffers fill or empty, and it can
    tolerate more or less latency.
    
    The USB 3.0 spec, section C.4.2 says that LTM should be disabled just
    before the device is placed into suspend.  Then the device will send an
    updated LTM notification, so that the system doesn't think it should
    remain in an active state in order to satisfy the latency requirements
    of the suspended device.
    
    The Set and Clear Feature LTM enable command can only be sent to a
    configured device.  The device will respond with an error if that
    command is sent while it is in the Default or Addressed state.  Make
    sure to check udev->actconfig in usb_enable_ltm() and usb_disable_ltm(),
    and don't send those commands when the device is unconfigured.
    
    LTM should be enabled once a new configuration is installed in
    usb_set_configuration().  If we end up sending duplicate Set Feature LTM
    Enable commands on a switch from one installed configuration to another
    configuration, that should be harmless.
    
    Make sure that LTM is disabled before the device is unconfigured in
    usb_disable_device().  If no drivers are bound to the device, it doesn't
    make sense to allow the device to control the latency tolerance of the
    xHCI host controller.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index dea2f0de063e..f29831bad235 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -633,6 +633,9 @@ extern void usb_enable_lpm(struct usb_device *udev);
 extern int usb_unlocked_disable_lpm(struct usb_device *udev);
 extern void usb_unlocked_enable_lpm(struct usb_device *udev);
 
+extern int usb_disable_ltm(struct usb_device *udev);
+extern void usb_enable_ltm(struct usb_device *udev);
+
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */

commit c5c4bdf02e518a281b229ae0891b346919e2d291
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Jul 5 09:41:22 2012 -0700

    USB: Remove unused LPM variable.
    
    hub_initiated_lpm_disable_count is not used by any code, so remove it.
    
    This commit should be backported to kernels as old as 3.5, that contain
    the commit 8306095fd2c1100e8244c09bf560f97aca5a311d "USB: Disable USB
    3.0 LPM in critical sections."
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d4f9de1acd45..dea2f0de063e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -561,7 +561,6 @@ struct usb_device {
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
 	unsigned lpm_disable_count;
-	unsigned hub_initiated_lpm_disable_count;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit 19181bc50e1b8e92a7a3b3d78637c6dc5c0b5a1b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jul 4 09:18:02 2012 +0200

    usbdevfs: Add a USBDEVFS_GET_CAPABILITIES ioctl
    
    There are a few (new) usbdevfs capabilities which an application cannot
    discover in any other way then checking the kernel version. There are 3
    problems with this:
    1) It is just not very pretty.
    2) Given the tendency of enterprise distros to backport stuff it is not
    reliable.
    3) As discussed in length on the mailinglist, USBDEVFS_URB_BULK_CONTINUATION
    does not work as it should when combined with USBDEVFS_URB_SHORT_NOT_OK
    (which is its intended use) on devices attached to an XHCI controller.
    So the availability of these features can be host controller dependent,
    making depending on them based on the kernel version not a good idea.
    
    This patch besides adding the new ioctl also adds flags for the following
    existing capabilities:
    
    USBDEVFS_CAP_ZERO_PACKET,        available since 2.6.31
    USBDEVFS_CAP_BULK_CONTINUATION,  available since 2.6.32, except for XHCI
    USBDEVFS_CAP_NO_PACKET_SIZE_LIM, available since 3.3
    
    Note that this patch only does not advertise the USBDEVFS_URB_BULK_CONTINUATION
    cap for XHCI controllers, bulk transfers with this flag set will still be
    accepted when submitted to XHCI controllers.
    
    Returning -EINVAL for them would break existing apps, and in most cases the
    troublesome scenario wrt USBDEVFS_URB_SHORT_NOT_OK urbs on XHCI controllers
    will never get hit, so this would break working use cases.
    
    The disadvantage of not returning -EINVAL is that cases were it is causing
    real trouble may go undetected / the cause of the trouble may be unclear,
    but this is the best we can do.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f717fbdaee8e..d4f9de1acd45 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -331,6 +331,11 @@ struct usb_bus {
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
+	unsigned no_stop_on_short:1;    /*
+					 * Quirk: some controllers don't stop
+					 * the ep queue on a short transfer
+					 * with the URB_SHORT_NOT_OK flag set.
+					 */
 	unsigned sg_tablesize;		/* 0 or largest number of sg list entries */
 
 	int devnum_next;		/* Next open device number in

commit 81df2d594340dcb6d1a02191976be88a1ca8120c
Author: Bjrn Mork <bjorn@mork.no>
Date:   Fri May 18 21:27:43 2012 +0200

    USB: allow match on bInterfaceNumber
    
    Some composite USB devices provide multiple interfaces
    with different functions, all using "vendor-specific"
    for class/subclass/protocol.  Another OS use interface
    numbers to match the driver and interface. It seems
    these devices are designed with that in mind - using
    static interface numbers for the different functions.
    
    This adds support for matching against the
    bInterfaceNumber, allowing such devices to be supported
    without having to resort to testing against interface
    number whitelists and/or blacklists in the probe.
    
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index dea39dc551d4..f717fbdaee8e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -776,6 +776,22 @@ static inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)
 	.idProduct = (prod), \
 	.bInterfaceProtocol = (pr)
 
+/**
+ * USB_DEVICE_INTERFACE_NUMBER - describe a usb device with a specific interface number
+ * @vend: the 16 bit USB Vendor ID
+ * @prod: the 16 bit USB Product ID
+ * @num: bInterfaceNumber value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific interface number of devices.
+ */
+#define USB_DEVICE_INTERFACE_NUMBER(vend, prod, num) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+		       USB_DEVICE_ID_MATCH_INT_NUMBER, \
+	.idVendor = (vend), \
+	.idProduct = (prod), \
+	.bInterfaceNumber = (num)
+
 /**
  * USB_DEVICE_INFO - macro used to describe a class of usb devices
  * @cl: bDeviceClass value

commit e9261fb62a8b6a79a58c57cc6f4a40530b040b61
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon May 21 08:29:01 2012 -0700

    USB: Fix core compile with CONFIG_USB_SUSPEND=n
    
    When CONFIG_PM=n, make sure that the usb_[unlocked_][en/dis]able_lpm
    declarations are visible in include/linux/usb.h, and exported from
    drivers/usb/core/hub.c.
    
    Before this patch, if CONFIG_USB_SUSPEND was turned off, it would cause
    build errors:
    
    drivers/usb/core/hub.c: In function 'usb_disable_lpm':
    drivers/usb/core/hub.c:3394:2: error: implicit declaration of function 'usb_enable_lpm' [-Werror=implicit-function-declaration]
    drivers/usb/core/hub.c: At top level:
    drivers/usb/core/hub.c:3424:6: warning: conflicting types for 'usb_enable_lpm' [enabled by default]
    drivers/usb/core/hub.c:3394:2: note: previous implicit declaration of 'usb_enable_lpm' was here
    drivers/usb/core/driver.c: In function 'usb_probe_interface':
    drivers/usb/core/driver.c:339:2: error: implicit declaration of function 'usb_unlocked_disable_lpm' [-Werror=implicit-function-declaration]
    drivers/usb/core/driver.c:364:3: error: implicit declaration of function 'usb_unlocked_enable_lpm' [-Werror=implicit-function-declaration]
    drivers/usb/core/message.c: In function 'usb_set_interface':
    drivers/usb/core/message.c:1314:2: error: implicit declaration of function 'usb_disable_lpm' [-Werror=implicit-function-declaration]
    drivers/usb/core/message.c:1323:3: error: implicit declaration of function 'usb_enable_lpm' [-Werror=implicit-function-declaration]
    drivers/usb/core/message.c:1368:2: error: implicit declaration of function 'usb_unlocked_enable_lpm' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Reported-by: Chen Peter-B29397 <B29397@freescale.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c19297a8779c..dea39dc551d4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -592,12 +592,6 @@ extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 extern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
 extern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
-extern int usb_disable_lpm(struct usb_device *udev);
-extern void usb_enable_lpm(struct usb_device *udev);
-/* Same as above, but these functions lock/unlock the bandwidth_mutex. */
-extern int usb_unlocked_disable_lpm(struct usb_device *udev);
-extern void usb_unlocked_enable_lpm(struct usb_device *udev);
-
 static inline void usb_mark_last_busy(struct usb_device *udev)
 {
 	pm_runtime_mark_last_busy(&udev->dev);
@@ -629,6 +623,12 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 { }
 #endif
 
+extern int usb_disable_lpm(struct usb_device *udev);
+extern void usb_enable_lpm(struct usb_device *udev);
+/* Same as above, but these functions lock/unlock the bandwidth_mutex. */
+extern int usb_unlocked_disable_lpm(struct usb_device *udev);
+extern void usb_unlocked_enable_lpm(struct usb_device *udev);
+
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */

commit 8306095fd2c1100e8244c09bf560f97aca5a311d
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed May 2 14:25:52 2012 -0700

    USB: Disable USB 3.0 LPM in critical sections.
    
    There are several places where the USB core needs to disable USB 3.0
    Link PM:
     - usb_bind_interface
     - usb_unbind_interface
     - usb_driver_claim_interface
     - usb_port_suspend/usb_port_resume
     - usb_reset_and_verify_device
     - usb_set_interface
     - usb_reset_configuration
     - usb_set_configuration
    
    Use the new LPM disable/enable functions to temporarily disable LPM
    around these critical sections.
    
    We need to protect the critical section around binding and unbinding USB
    interface drivers.  USB drivers may want to disable hub-initiated USB
    3.0 LPM, which will change the value of the U1/U2 timeouts that the xHCI
    driver will install.  We need to disable LPM completely until the driver
    is bound to the interface, and the driver has a chance to enable
    whatever alternate interface setting it needs in its probe routine.
    Then re-enable USB3 LPM, and recalculate the U1/U2 timeout values.
    
    We also need to disable LPM in usb_driver_claim_interface,
    because drivers like usbfs can bind to an interface through that
    function.  Note, there is no way currently for userspace drivers to
    disable hub-initiated USB 3.0 LPM.  Revisit this later.
    
    When a driver is unbound, the U1/U2 timeouts may change because we are
    unbinding the last driver that needed hub-initiated USB 3.0 LPM to be
    disabled.
    
    USB LPM must be disabled when a USB device is going to be suspended.
    The USB 3.0 spec does not define a state transition from U1 or U2 into
    U3, so we need to bring the device into U0 by disabling LPM before we
    can place it into U3.  Therefore, call usb_unlocked_disable_lpm() in
    usb_port_suspend(), and call usb_unlocked_enable_lpm() in
    usb_port_resume().  If the port suspend fails, make sure to re-enable
    LPM by calling usb_unlocked_enable_lpm(), since usb_port_resume() will
    not be called on a failed port suspend.
    
    USB 3.0 devices lose their USB 3.0 LPM settings (including whether USB
    device-initiated LPM is enabled) across device suspend.  Therefore,
    disable LPM before the device will be reset in
    usb_reset_and_verify_device(), and re-enable LPM after the reset is
    complete and the configuration/alt settings are re-installed.
    
    The calculated U1/U2 timeout values are heavily dependent on what USB
    device endpoints are currently enabled.  When any of the enabled
    endpoints on the device might change, due to a new configuration, or new
    alternate interface setting, we need to first disable USB 3.0 LPM, add
    or delete endpoints from the xHCI schedule, install the new interfaces
    and alt settings, and then re-enable LPM.  Do this in usb_set_interface,
    usb_reset_configuration, and usb_set_configuration.
    
    Basically, there is a call to disable and then enable LPM in all
    functions that lock the bandwidth_mutex.  One exception is
    usb_disable_device, because the device is disconnecting or otherwise
    going away, and we should not care about whether USB 3.0 LPM is enabled.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 40439dfd81a7..c19297a8779c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -526,6 +526,7 @@ struct usb_device {
 	unsigned lpm_capable:1;
 	unsigned usb2_hw_lpm_capable:1;
 	unsigned usb2_hw_lpm_enabled:1;
+	unsigned usb3_lpm_enabled:1;
 	int string_langid;
 
 	/* static strings from the device */
@@ -555,6 +556,7 @@ struct usb_device {
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
 	unsigned lpm_disable_count;
+	unsigned hub_initiated_lpm_disable_count;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit 1ea7e0e8e3d0f50901d335ea4178ab2aa8c88201
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Tue Apr 24 17:21:50 2012 -0700

    USB: Add support to enable/disable USB3 link states.
    
    There are various functions within the USB core that will need to
    disable USB 3.0 link power states.  For example, when a USB device
    driver is being bound to an interface, we need to disable USB 3.0 LPM
    until we know if the driver will allow hub-initiated LPM transitions.
    Another example is when the USB core is switching alternate interface
    settings.  The USB 3.0 timeout values are dependent on what endpoints
    are enabled, so we want to ensure that LPM is disabled until the new alt
    setting is fully installed.
    
    Multiple functions need to disable LPM, and those functions can even be
    nested.  For example, usb_bind_interface() could disable LPM, and then
    call into the driver probe function, which may attempt to switch to a
    different alt setting.  Therefore, we need to keep a count of the number
    of functions that require LPM to be disabled at any point in time.
    
    Introduce two new USB core API calls, usb_disable_lpm() and
    usb_enable_lpm().  These functions increment and decrement a new
    variable in the usb_device, lpm_disable_count.  If usb_disable_lpm()
    fails, it will call usb_enable_lpm() in order to balance the
    lpm_disable_count.
    
    These two new functions must be called with the bandwidth_mutex locked.
    If the bandwidth_mutex is not already held by the caller, it should
    instead call usb_unlocked_disable_lpm() and usb_enable_lpm(), which take
    the bandwidth_mutex before calling usb_disable_lpm() and
    usb_enable_lpm(), respectively.
    
    Introduce a new variable (timeout) in the usb3_lpm_params structure to
    keep track of the currently enabled U1/U2 timeout values.  When
    usb_disable_lpm() is called, and the USB device has the U1 or U2
    timeouts set to a non-zero value (meaning either device-initiated or
    hub-initiated LPM is enabled), attempt to disable LPM, regardless of the
    state of the lpm_disable_count.  We want to ensure that all callers can
    be guaranteed that LPM is disabled if usb_disable_lpm() returns zero.
    
    Otherwise the following scenario could occur:
    
    1. Driver A is being bound to interface 1.  usb_probe_interface()
    disables LPM.  Driver A doesn't care if hub-initiated LPM is enabled, so
    even though usb_disable_lpm() fails, the probe of the driver continues,
    and the bandwidth mutex is dropped.
    
    2. Meanwhile, Driver B is being bound to interface 2.
    usb_probe_interface() grabs the bandwidth mutex and calls
    usb_disable_lpm().  That call should attempt to disable LPM, even
    though the lpm_disable_count is set to 1 by Driver A.
    
    For usb_enable_lpm(), we attempt to enable LPM only when the
    lpm_disable_count is zero.  If some step in enabling LPM fails, it will
    only have a minimal impact on power consumption, and all USB device
    drivers should still work properly.  Therefore don't bother to return
    any error codes.
    
    Don't enable device-initiated LPM if the device is unconfigured.  The
    USB device will only accept the U1/U2_ENABLE control transfers in the
    configured state.  Do enable hub-initiated LPM in that case, since
    devices are allowed to accept the LGO_Ux link commands in any state.
    
    Don't enable or disable LPM if the device is marked as not being LPM
    capable.  This can happen if:
     - the USB device doesn't have a SS BOS descriptor,
     - the device's parent hub has a zeroed bHeaderDecodeLatency value, or
     - the xHCI host doesn't support LPM.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Andiry Xu <andiry.xu@amd.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 22e7b53123ef..40439dfd81a7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -409,6 +409,12 @@ struct usb3_lpm_parameters {
 	 * it will get data.
 	 */
 	unsigned int sel;
+	/*
+	 * The idle timeout value that is currently programmed into the parent
+	 * hub for this device.  When the timer counts to zero, the parent hub
+	 * will initiate an LPM transition to either U1 or U2.
+	 */
+	int timeout;
 };
 
 /**
@@ -468,8 +474,12 @@ struct usb3_lpm_parameters {
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
  * @removable: Device can be physically removed from this port
- * @u1_params: exit latencies for U1 (USB 3.0 LPM).
- * @u2_params: exit latencies for U2 (USB 3.0 LPM).
+ * @u1_params: exit latencies for USB3 U1 LPM state, and hub-initiated timeout.
+ * @u2_params: exit latencies for USB3 U2 LPM state, and hub-initiated timeout.
+ * @lpm_disable_count: Ref count used by usb_disable_lpm() and usb_enable_lpm()
+ *	to keep track of the number of functions that require USB 3.0 Link Power
+ *	Management to be disabled for this usb_device.  This count should only
+ *	be manipulated by those functions, with the bandwidth_mutex is held.
  *
  * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use
@@ -544,6 +554,7 @@ struct usb_device {
 	enum usb_device_removable removable;
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
+	unsigned lpm_disable_count;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
@@ -579,6 +590,12 @@ extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 extern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
 extern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
+extern int usb_disable_lpm(struct usb_device *udev);
+extern void usb_enable_lpm(struct usb_device *udev);
+/* Same as above, but these functions lock/unlock the bandwidth_mutex. */
+extern int usb_unlocked_disable_lpm(struct usb_device *udev);
+extern void usb_unlocked_enable_lpm(struct usb_device *udev);
+
 static inline void usb_mark_last_busy(struct usb_device *udev)
 {
 	pm_runtime_mark_last_busy(&udev->dev);

commit 8afa408cba5c474696df6307a64b1c612bbcadbc
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 23 10:08:51 2012 -0700

    USB: Allow drivers to disable hub-initiated LPM.
    
    USB 3.0 Link Power Management (LPM) is designed to allow individual
    links in the bus to go into lower power states.  There are two ways a
    link can enter a lower power state:
    
    1. Device-initiated LPM.  When a USB device decides it can go into a
    lower power link state, it sends a message to the parent hub, telling it
    to go into either U1 or U2.  Device-initiated LPM is good for devices
    that send data to the host, like communications devices.
    
    2. Hub-initiated LPM.  After the link has been idle for a specific
    amount of time, the parent hub will request that the child go into a
    lower power state.  The child can refuse that request.  For example, a
    USB modem may want to refuse the LPM request if it is in the middle of
    receiving a text message.  Hub-initiated LPM is good for devices where
    only the host initiates the data transfer, like USB printers or USB mass
    storage devices.
    
    Links will be automatically placed into higher power states by the USB
    hubs and roothubs whenever the host starts a USB transmission.
    
    Introduce a new usb_driver flag, disable_hub_initiated_lpm, that allows
    drivers to disable hub-initiated LPM.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Johan Hedberg <johan.hedberg@gmail.com>
    Cc: Hansjoerg Lipp <hjlipp@web.de>
    Cc: Tilman Schmidt <tilman@imap.cc>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Peter Korsgaard <jacmet@sunsite.dk>
    Cc: Jan Dumon <j.dumon@option.com>
    Cc: Petko Manolov <petkan@users.sourceforge.net>
    Cc: Steve Glendinning <steve.glendinning@smsc.com>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: "Luis R. Rodriguez" <mcgrof@qca.qualcomm.com>
    Cc: Jouni Malinen <jouni@qca.qualcomm.com>
    Cc: Vasanthakumar Thiagarajan <vthiagar@qca.qualcomm.com>
    Cc: Senthil Balasubramanian <senthilb@qca.qualcomm.com>
    Cc: Christian Lamparter <chunkeey@googlemail.com>
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Roland Vossen <rvossen@broadcom.com>
    Cc: Arend van Spriel <arend@broadcom.com>
    Cc: "Franky (Zhenhui) Lin" <frankyl@broadcom.com>
    Cc: Kan Yan <kanyan@broadcom.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Jussi Kivilinna <jussi.kivilinna@mbnet.fi>
    Cc: Ivo van Doorn <IvDoorn@gmail.com>
    Cc: Gertjan van Wingerde <gwingerde@gmail.com>
    Cc: Helmut Schaa <helmut.schaa@googlemail.com>
    Cc: Herton Ronaldo Krzesinski <herton@canonical.com>
    Cc: Hin-Tak Leung <htl10@users.sourceforge.net>
    Cc: Larry Finger <Larry.Finger@lwfinger.net>
    Cc: Chaoming Li <chaoming_li@realsil.com.cn>
    Cc: Daniel Drake <dsd@gentoo.org>
    Cc: Ulrich Kunitz <kune@deine-taler.de>
    Cc: linux-bluetooth@vger.kernel.org
    Cc: gigaset307x-common@lists.sourceforge.net
    Cc: netdev@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: ath9k-devel@lists.ath9k.org
    Cc: libertas-dev@lists.infradead.org
    Cc: users@rt2x00.serialmonkey.com

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e6c815590fdd..22e7b53123ef 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -879,6 +879,9 @@ struct usbdrv_wrap {
  *	for interfaces bound to this driver.
  * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
  *	endpoints before calling the driver's disconnect method.
+ * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs
+ *	to initiate lower power link state transitions when an idle timeout
+ *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.
  *
  * USB interface drivers must provide a name, probe() and disconnect()
  * methods, and an id_table.  Other driver fields are optional.
@@ -919,6 +922,7 @@ struct usb_driver {
 	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
 	unsigned int supports_autosuspend:1;
+	unsigned int disable_hub_initiated_lpm:1;
 	unsigned int soft_unbind:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)

commit 51e0a01206613ad80a3841388ecfa46476dabdf5
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Feb 20 12:02:19 2012 -0800

    USB: Calculate USB 3.0 exit latencies for LPM.
    
    There are several different exit latencies associated with coming out of
    the U1 or U2 lower power link state.
    
    Device Exit Latency (DEL) is the maximum time it takes for the USB
    device to bring its upstream link into U0.  That can be found in the
    SuperSpeed Extended Capabilities BOS descriptor for the device.  The
    time it takes for a particular link in the tree to exit to U0 is the
    maximum of either the parent hub's U1/U2 DEL, or the child's U1/U2 DEL.
    
    Hubs introduce a further delay that effects how long it takes a child
    device to transition to U0.  When a USB 3.0 hub receives a header
    packet, it takes some time to decode that header and figure out which
    downstream port the packet was destined for.  If the port is not in U0,
    this hub header decode latency will cause an additional delay for
    bringing the child device to U0.  This Hub Header Decode Latency is
    found in the USB 3.0 hub descriptor.
    
    We can use DEL and the header decode latency, along with additional
    latencies imposed by each additional hub tier, to figure out the exit
    latencies for both host-initiated and device-initiated exit to U0.
    
    The Max Exit Latency (MEL) is the worst-case time it will take for a
    host-initiated exit to U0, based on whether U1 or U2 link states are
    enabled.  The ping or packet must traverse the path to the device, and
    each hub along the way incurs the hub header decode latency in order to
    figure out which device the transfer was bound for.  We say worst-case,
    because some hubs may not be in the lowest link state that is enabled.
    See the examples in section C.2.2.1.
    
    Note that "HSD" is a "host specific delay" that the power appendix
    architect has not been able to tell me how to calculate.  There's no way
    to get HSD from the xHCI registers either, so I'm simply ignoring it.
    
    The Path Exit Latency (PEL) is the worst-case time it will take for a
    device-initiate exit to U0 to place all the links from the device to the
    host into U0.
    
    The System Exit Latency (SEL) is another device-initiated exit latency.
    SEL is useful for USB 3.0 devices that need to send data to the host at
    specific intervals.  The device may send an NRDY to indicate it isn't
    ready to send data, then put its link into a lower power state.  If it
    needs to have that data transmitted at a specific time, it can use SEL
    to back calculate when it will need to bring the link back into U0 to
    meet its deadlines.
    
    SEL is the worst-case time from the device-initiated exit to U0, to when
    the device will receive a packet from the host controller.  It includes
    PEL, the time it takes for an ERDY to get to the host, a host-specific
    delay for the host to process that ERDY, and the time it takes for the
    packet to traverse the path to the device.  See Figure C-2 in the USB
    3.0 bus specification.
    
    Note: I have not been able to get good answers about what the
    host-specific delay to process the ERDY should be.  The Intel HW
    developers say it will be specific to the platform the xHCI host is
    integrated into, and they say it's negligible.  Ignore this too.
    
    Separate from these four exit latencies are the U1/U2 timeout values we
    program into the parent hubs.  These timeouts tell the hub to attempt to
    place the device into a lower power link state after the link has been
    idle for that amount of time.
    
    Create two arrays (one for U1 and one for U2) to store mel, pel, sel,
    and the timeout values.  Store the exit latency values in nanosecond
    units, since that's the smallest units used (DEL is in us, but the Hub
    Header Decode Latency is in ns).
    
    If a USB 3.0 device doesn't have a SuperSpeed Extended Capabilities BOS
    descriptor, it's highly unlikely it will be able to handle LPM requests
    properly.  So it's best to disable LPM for devices that don't have this
    descriptor, and any children beneath it, if it's a USB 3.0 hub.  Warn
    users when that happens, since it means they have a non-compliant USB
    3.0 device or hub.
    
    This patch assumes a simplified design where links deep in the tree will
    not have U1 or U2 enabled unless all their parent links have the
    corresponding LPM state enabled.  Eventually, we might want to allow a
    different policy, and we can revisit this patch when that happens.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 14933451d21d..e6c815590fdd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -378,6 +378,39 @@ enum usb_device_removable {
 	USB_DEVICE_FIXED,
 };
 
+/*
+ * USB 3.0 Link Power Management (LPM) parameters.
+ *
+ * PEL and SEL are USB 3.0 Link PM latencies for device-initiated LPM exit.
+ * MEL is the USB 3.0 Link PM latency for host-initiated LPM exit.
+ * All three are stored in nanoseconds.
+ */
+struct usb3_lpm_parameters {
+	/*
+	 * Maximum exit latency (MEL) for the host to send a packet to the
+	 * device (either a Ping for isoc endpoints, or a data packet for
+	 * interrupt endpoints), the hubs to decode the packet, and for all hubs
+	 * in the path to transition the links to U0.
+	 */
+	unsigned int mel;
+	/*
+	 * Maximum exit latency for a device-initiated LPM transition to bring
+	 * all links into U0.  Abbreviated as "PEL" in section 9.4.12 of the USB
+	 * 3.0 spec, with no explanation of what "P" stands for.  "Path"?
+	 */
+	unsigned int pel;
+
+	/*
+	 * The System Exit Latency (SEL) includes PEL, and three other
+	 * latencies.  After a device initiates a U0 transition, it will take
+	 * some time from when the device sends the ERDY to when it will finally
+	 * receive the data packet.  Basically, SEL should be the worse-case
+	 * latency from when a device starts initiating a U0 transition to when
+	 * it will get data.
+	 */
+	unsigned int sel;
+};
+
 /**
  * struct usb_device - kernel's representation of a USB device
  * @devnum: device number; address on a USB bus
@@ -435,6 +468,8 @@ enum usb_device_removable {
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
  * @removable: Device can be physically removed from this port
+ * @u1_params: exit latencies for U1 (USB 3.0 LPM).
+ * @u2_params: exit latencies for U2 (USB 3.0 LPM).
  *
  * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use
@@ -507,6 +542,8 @@ struct usb_device {
 	struct wusb_dev *wusb_dev;
 	int slot_id;
 	enum usb_device_removable removable;
+	struct usb3_lpm_parameters u1_params;
+	struct usb3_lpm_parameters u2_params;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit ef206f3f01d8cc0d363cfce7dc9ca11db429faa3
Author: Bjrn Mork <bjorn@mork.no>
Date:   Sun May 13 12:35:00 2012 +0200

    USB: add read support to usb-serial/../new_id
    
    Keep the usb-serial support for dynamic IDs in sync with the usb
    support.  This enables readout of dynamic device IDs for
    usb-serial drivers.  Common code is exported from the usb core
    system and reused by the usb-serial bus driver.
    
    Signed-off-by: Bjrn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5483cd70390b..14933451d21d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -790,6 +790,8 @@ extern ssize_t usb_store_new_id(struct usb_dynids *dynids,
 				struct device_driver *driver,
 				const char *buf, size_t count);
 
+extern ssize_t usb_show_dynids(struct usb_dynids *dynids, char *buf);
+
 /**
  * struct usbdrv_wrap - wrapper for driver-model structure
  * @driver: The driver-model core driver structure.

commit fa286188ce0fce994c3fc2bddcafeb948834591f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 14 09:20:37 2012 -0700

    Revert "usb: move struct usb_device->children to struct usb_hub_port->child"
    
    This reverts commit bebc56d58dc780539777d2b1ca80df5566e2ad87.
    
    The call here is fragile and not well thought out, so revert it, it's
    not fully baked yet and I don't want this to go into 3.5.
    
    Cc: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 69163a0abe91..5483cd70390b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -424,6 +424,7 @@ enum usb_device_removable {
  *	access from userspace
  * @usbfs_dentry: usbfs dentry entry for the device
  * @maxchild: number of ports if hub
+ * @children: child devices - USB devices that are attached to this hub
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
@@ -490,6 +491,7 @@ struct usb_device {
 	struct list_head filelist;
 
 	int maxchild;
+	struct usb_device **children;
 
 	u32 quirks;
 	atomic_t urbnum;
@@ -515,8 +517,6 @@ static inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)
 
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
-extern struct usb_device *usb_get_hub_child_device(struct usb_device *hdev,
-	int port1);
 
 /* USB device locking */
 #define usb_lock_device(udev)		device_lock(&(udev)->dev)

commit bebc56d58dc780539777d2b1ca80df5566e2ad87
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri May 11 16:08:30 2012 +0800

    usb: move struct usb_device->children to struct usb_hub_port->child
    
    Move child's pointer to the struct usb_hub_port since the child device
    is directly associated with the port. Provide usb_get_hub_child_device()
    to get child's pointer.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5483cd70390b..69163a0abe91 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -424,7 +424,6 @@ enum usb_device_removable {
  *	access from userspace
  * @usbfs_dentry: usbfs dentry entry for the device
  * @maxchild: number of ports if hub
- * @children: child devices - USB devices that are attached to this hub
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
@@ -491,7 +490,6 @@ struct usb_device {
 	struct list_head filelist;
 
 	int maxchild;
-	struct usb_device **children;
 
 	u32 quirks;
 	atomic_t urbnum;
@@ -517,6 +515,8 @@ static inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)
 
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
+extern struct usb_device *usb_get_hub_child_device(struct usb_device *hdev,
+	int port1);
 
 /* USB device locking */
 #define usb_lock_device(udev)		device_lock(&(udev)->dev)

commit 8815bb09af21316aeb5f8948b24ac62181670db2
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Apr 30 09:13:46 2012 +0200

    usbhid: prevent deadlock during timeout
    
    On some HCDs usb_unlink_urb() can directly call the
    completion handler. That limits the spinlocks that can
    be taken in the handler to locks not held while calling
    usb_unlink_urb()
    To prevent a race with resubmission, this patch exposes
    usbcore's infrastructure for blocking submission, uses it
    and so drops the lock without causing a race in usbhid.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8fa9a93a4ec4..5483cd70390b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1369,6 +1369,7 @@ extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 extern void usb_poison_urb(struct urb *urb);
 extern void usb_unpoison_urb(struct urb *urb);
+extern void usb_block_urb(struct urb *urb);
 extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_poison_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);
@@ -1381,6 +1382,8 @@ extern struct urb *usb_get_from_anchor(struct usb_anchor *anchor);
 extern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor);
 extern int usb_anchor_empty(struct usb_anchor *anchor);
 
+#define usb_unblock_urb	usb_unpoison_urb
+
 /**
  * usb_urb_dir_in - check if an URB describes an IN transfer
  * @urb: URB to be checked

commit 007bab91324e6337bb150ffc17b20cf829686370
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 15:26:54 2012 -0700

    USB: remove CONFIG_USB_DEVICE_CLASS
    
    This option has been deprecated for many years now, and no userspace
    tools use it anymore, so it should be safe to finally remove it.
    
    Reported-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a63c5baa9f65..8fa9a93a4ec4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -489,9 +489,6 @@ struct usb_device {
 	char *serial;
 
 	struct list_head filelist;
-#ifdef CONFIG_USB_DEVICE_CLASS
-	struct device *usb_classdev;
-#endif
 
 	int maxchild;
 	struct usb_device **children;

commit fb28d58b72aa9215b26f1d5478462af394a4d253
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 17:15:29 2012 -0700

    USB: remove CONFIG_USB_DEVICEFS
    
    This option has been deprecated for many years now, and no userspace
    tools use it anymore, so it should be safe to finally remove it.
    
    Reported-by: Kay Sievers <kay@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 45bc7a5225ab..a63c5baa9f65 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -351,10 +351,6 @@ struct usb_bus {
 	int bandwidth_int_reqs;		/* number of Interrupt requests */
 	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
 
-#ifdef CONFIG_USB_DEVICEFS
-	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
-#endif
-
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
@@ -496,9 +492,6 @@ struct usb_device {
 #ifdef CONFIG_USB_DEVICE_CLASS
 	struct device *usb_classdev;
 #endif
-#ifdef CONFIG_USB_DEVICEFS
-	struct dentry *usbfs_dentry;
-#endif
 
 	int maxchild;
 	struct usb_device **children;

commit af4e1ee04026908086d7ed252db2619a8ceaa333
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 14:55:16 2012 -0700

    USB: remove err() macro
    
    I thought this had been removed years ago.  All in-kernel users of this
    call have now been cleaned up and converted over to use dev_err()
    instead, which is the correct thing to do.  Now that there are no users,
    the macro can be removed so no one else accidentally starts to use it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 22e9b328975b..45bc7a5225ab 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1653,9 +1653,6 @@ do {									\
 } while (0)
 #endif
 
-#define err(format, arg...)					\
-	printk(KERN_ERR KBUILD_MODNAME ": " format "\n", ##arg)
-
 /* debugfs stuff */
 extern struct dentry *usb_debug_root;
 

commit 67c88382e0bf92d7e09536ac47674c9fc9398b98
Author: Johan Hovold <jhovold@gmail.com>
Date:   Mon Mar 26 21:01:50 2012 +0200

    USB: add EOPNOTSUPP to usb_translate_errors
    
    Allow drivers to return EOPNOTSUPP to user space even when filtered
    through usb_translate_errors.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 73b68d1f2cb0..22e9b328975b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1627,6 +1627,7 @@ static inline int usb_translate_errors(int error_code)
 	case 0:
 	case -ENOMEM:
 	case -ENODEV:
+	case -EOPNOTSUPP:
 		return error_code;
 	default:
 		return -EIO;

commit 8816230e13d0c3c6ba51916d20e6d204646abf03
Author: Huajun Li <huajun.li.lee@gmail.com>
Date:   Mon Mar 12 21:00:19 2012 +0800

    USB: dynamically allocate usb_device children pointers instead of using a fix array
    
    Non-hub device has no child, and even a real USB hub has ports far
    less than USB_MAXCHILDREN, so there is no need using a fix array for
    child devices, just allocate it dynamically according real port
    number.
    
    Signed-off-by: Huajun Li <huajun.li.lee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0c51663f2733..73b68d1f2cb0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -501,7 +501,7 @@ struct usb_device {
 #endif
 
 	int maxchild;
-	struct usb_device *children[USB_MAXCHILDREN];
+	struct usb_device **children;
 
 	u32 quirks;
 	atomic_t urbnum;

commit 7483948fdd31a8642ef0288aab6f368b98d53c29
Merge: 22a416c4e0f2 fe250923bbbb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Feb 10 11:12:55 2012 -0800

    Merge tag 'usb-3.3-rc3' into usb-next
    
    This is done to resolve a merge conflict with:
            drivers/usb/class/cdc-wdm.c
    and to better handle future patches for this driver as it is under
    active development at the moment.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0846e7e9856c0928223447d9349a877202a63f24
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri Feb 3 17:11:54 2012 -0500

    usb: Add support for indicating whether a port is removable
    
    Userspace may want to make policy decisions based on whether or not a
    given USB device is removable. Add a per-device member and support
    for exposing it in sysfs. Information sources to populate it will be
    added later.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 27a4e16d2bf1..b2eb3a47caf5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -376,6 +376,12 @@ struct usb_bus {
 
 struct usb_tt;
 
+enum usb_device_removable {
+	USB_DEVICE_REMOVABLE_UNKNOWN = 0,
+	USB_DEVICE_REMOVABLE,
+	USB_DEVICE_FIXED,
+};
+
 /**
  * struct usb_device - kernel's representation of a USB device
  * @devnum: device number; address on a USB bus
@@ -432,6 +438,7 @@ struct usb_tt;
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
+ * @removable: Device can be physically removed from this port
  *
  * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use
@@ -509,6 +516,7 @@ struct usb_device {
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;
+	enum usb_device_removable removable;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit 4d922612df8bd1202a1f51d95b78aca3d67302cd
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Jan 21 11:02:56 2012 -0800

    kernel-doc: fix new warning in usb.h
    
    Fix new kernel-doc warning:
    
    Warning(include/linux/usb.h:1251): No description found for parameter 'num_mapped_sgs'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 27a4e16d2bf1..69d845739bc2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1073,6 +1073,7 @@ typedef void (*usb_complete_t)(struct urb *);
  *	which the host controller driver should use in preference to the
  *	transfer_buffer.
  * @sg: scatter gather buffer list
+ * @num_mapped_sgs: (internal) number of mapped sg entries
  * @num_sgs: number of entries in the sg list
  * @transfer_buffer_length: How big is transfer_buffer.  The transfer may
  *	be broken up into chunks according to the current maximum packet

commit 55b81e6f2795484ea8edf5805c95c007cacfa736
Merge: 5983faf942f2 08e87d0d773d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 12:09:47 2012 -0800

    Merge branch 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    * 'usb-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (232 commits)
      USB: Add USB-ID for Multiplex RC serial adapter to cp210x.c
      xhci: Clean up 32-bit build warnings.
      USB: update documentation for usbmon
      usb: usb-storage doesn't support dynamic id currently, the patch disables the feature to fix an oops
      drivers/usb/class/cdc-acm.c: clear dangling pointer
      drivers/usb/dwc3/dwc3-pci.c: introduce missing kfree
      drivers/usb/host/isp1760-if.c: introduce missing kfree
      usb: option: add ZD Incorporated HSPA modem
      usb: ch9: fix up MaxStreams helper
      USB: usb-skeleton.c: cleanup open_count
      USB: usb-skeleton.c: fix open/disconnect race
      xhci: Properly handle COMP_2ND_BW_ERR
      USB: remove dead code from suspend/resume path
      USB: add quirk for another camera
      drivers: usb: wusbcore: Fix dependency for USB_WUSB
      xhci: Better debugging for critical host errors.
      xhci: Be less verbose during URB cancellation.
      xhci: Remove debugging about ring structure allocation.
      xhci: Remove debugging about toggling cycle bits.
      xhci: Remove debugging for individual transfers.
      ...

commit 972b2c719990f91eb3b2310d44ef8a2d38955a14
Merge: 02550d61f492 c3aa077648e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 8 12:19:57 2012 -0800

    Merge branch 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    * 'for-linus2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (165 commits)
      reiserfs: Properly display mount options in /proc/mounts
      vfs: prevent remount read-only if pending removes
      vfs: count unlinked inodes
      vfs: protect remounting superblock read-only
      vfs: keep list of mounts for each superblock
      vfs: switch ->show_options() to struct dentry *
      vfs: switch ->show_path() to struct dentry *
      vfs: switch ->show_devname() to struct dentry *
      vfs: switch ->show_stats to struct dentry *
      switch security_path_chmod() to struct path *
      vfs: prefer ->dentry->d_sb to ->mnt->mnt_sb
      vfs: trim includes a bit
      switch mnt_namespace ->root to struct mount
      vfs: take /proc/*/mounts and friends to fs/proc_namespace.c
      vfs: opencode mntget() mnt_set_mountpoint()
      vfs: spread struct mount - remaining argument of next_mnt()
      vfs: move fsnotify junk to struct mount
      vfs: move mnt_devname
      vfs: move mnt_list to struct mount
      vfs: switch pnode.h macros to struct mount *
      ...

commit 2c9ede55ecec58099b72e4bb8eab719f32f72c31
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 23 20:24:48 2011 -0400

    switch device_get_devnode() and ->devnode() to umode_t *
    
    both callers of device_get_devnode() are only interested in lower 16bits
    and nobody tries to return anything wider than 16bit anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d3d0c1374334..a59321779f8b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -935,7 +935,7 @@ extern struct bus_type usb_bus_type;
  */
 struct usb_class_driver {
 	char *name;
-	char *(*devnode)(struct device *dev, mode_t *mode);
+	char *(*devnode)(struct device *dev, umode_t *mode);
 	const struct file_operations *fops;
 	int minor_base;
 };

commit bc677d5b64644c399cd3db6a905453e611f402ab
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sat Dec 3 23:41:31 2011 +0100

    usb: fix number of mapped SG DMA entries
    
    Add a new field num_mapped_sgs to struct urb so that we have a place to
    store the number of mapped entries and can also retain the original
    value of entries in num_sgs.  Previously, usb_hcd_map_urb_for_dma()
    would overwrite this with the number of mapped entries, which would
    break dma_unmap_sg() because it requires the original number of entries.
    
    This fixes warnings like the following when using USB storage devices:
     ------------[ cut here ]------------
     WARNING: at lib/dma-debug.c:902 check_unmap+0x4e4/0x695()
     ehci_hcd 0000:00:12.2: DMA-API: device driver frees DMA sg list with different entry count [map count=4] [unmap count=1]
     Modules linked in: ohci_hcd ehci_hcd
     Pid: 0, comm: kworker/0:1 Not tainted 3.2.0-rc2+ #319
     Call Trace:
      <IRQ>  [<ffffffff81036d3b>] warn_slowpath_common+0x80/0x98
      [<ffffffff81036de7>] warn_slowpath_fmt+0x41/0x43
      [<ffffffff811fa5ae>] check_unmap+0x4e4/0x695
      [<ffffffff8105e92c>] ? trace_hardirqs_off+0xd/0xf
      [<ffffffff8147208b>] ? _raw_spin_unlock_irqrestore+0x33/0x50
      [<ffffffff811fa84a>] debug_dma_unmap_sg+0xeb/0x117
      [<ffffffff8137b02f>] usb_hcd_unmap_urb_for_dma+0x71/0x188
      [<ffffffff8137b166>] unmap_urb_for_dma+0x20/0x22
      [<ffffffff8137b1c5>] usb_hcd_giveback_urb+0x5d/0xc0
      [<ffffffffa0000d02>] ehci_urb_done+0xf7/0x10c [ehci_hcd]
      [<ffffffffa0001140>] qh_completions+0x429/0x4bd [ehci_hcd]
      [<ffffffffa000340a>] ehci_work+0x95/0x9c0 [ehci_hcd]
      ...
     ---[ end trace f29ac88a5a48c580 ]---
     Mapped at:
      [<ffffffff811faac4>] debug_dma_map_sg+0x45/0x139
      [<ffffffff8137bc0b>] usb_hcd_map_urb_for_dma+0x22e/0x478
      [<ffffffff8137c494>] usb_hcd_submit_urb+0x63f/0x6fa
      [<ffffffff8137d01c>] usb_submit_urb+0x2c7/0x2de
      [<ffffffff8137dcd4>] usb_sg_wait+0x55/0x161
    
    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2f05a7fa1ecf..4269c3f88148 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1221,6 +1221,7 @@ struct urb {
 	void *transfer_buffer;		/* (in) associated data buffer */
 	dma_addr_t transfer_dma;	/* (in) dma addr for transfer_buffer */
 	struct scatterlist *sg;		/* (in) scatter gather buffer list */
+	int num_mapped_sgs;		/* (internal) mapped sg entries */
 	int num_sgs;			/* (in) number of entries in the sg list */
 	u32 transfer_buffer_length;	/* (in) data buffer length */
 	u32 actual_length;		/* (return) actual transfer length */

commit f3a6a4b6cfc80e57bf16bb12f9425bec1a5731a9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 17 14:38:33 2011 -0800

    USB: Add helper macro for usb_driver boilerplate
    
    This patch introduces the module_usb_driver macro which is a convenience
    macro for USB driver modules similar to module_platform_driver. It is
    intended to be used by drivers which init/exit section does nothing but
    register/unregister the USB driver. By using this macro it is possible
    to eliminate a few lines of boilerplate code per USB driver.
    
    Based on work done by Lars-Peter Clausen <lars@metafoo.de> for other
    busses (i2c and spi).
    
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d3d0c1374334..5d258c3180ae 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -953,6 +953,18 @@ extern int usb_register_driver(struct usb_driver *, struct module *,
 
 extern void usb_deregister(struct usb_driver *);
 
+/**
+ * module_usb_driver() - Helper macro for registering a USB driver
+ * @__usb_driver: usb_driver struct
+ *
+ * Helper macro for USB drivers which do not do anything special in module
+ * init/exit. This eliminates a lot of boilerplate. Each module may only
+ * use this macro once, and calling it replaces module_init() and module_exit()
+ */
+#define module_usb_driver(__usb_driver) \
+	module_driver(__usb_driver, usb_register, \
+		       usb_deregister)
+
 extern int usb_register_device_driver(struct usb_device_driver *,
 			struct module *);
 extern void usb_deregister_device_driver(struct usb_device_driver *);

commit 2c4d6bf295ae10ffcd84f0df6cb642598eb66603
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Nov 10 14:58:26 2011 +0100

    USB: move usb_translate_errors to linux/usb.h
    
    Move usb_translate_errors from usb core to linux/usb.h as it is meant to
    be accessed from drivers.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d3d0c1374334..2f05a7fa1ecf 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1598,6 +1598,19 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 
 /* ----------------------------------------------------------------------- */
 
+/* translate USB error codes to codes user space understands */
+static inline int usb_translate_errors(int error_code)
+{
+	switch (error_code) {
+	case 0:
+	case -ENOMEM:
+	case -ENODEV:
+		return error_code;
+	default:
+		return -EIO;
+	}
+}
+
 /* Events from the usb core */
 #define USB_DEVICE_ADD		0x0001
 #define USB_DEVICE_REMOVE	0x0002

commit eb5589a8f0dab7e29021344228856339e6a1249c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 09:02:11 2011 -0400

    include: convert various register fcns to macros to avoid include chaining
    
    The original implementations reference THIS_MODULE in an inline.
    We could include <linux/export.h>, but it is better to avoid chaining.
    
    Fortunately someone else already thought of this, and made a similar
    inline into a #define in <linux/device.h> for device_schedule_callback(),
    [see commit 523ded71de0] so follow that precedent here.
    
    Also bubble up any __must_check that were used on the prev. wrapper inline
    functions up one to the real __register functions, to preserve any prev.
    sanity checks that were used in those instances.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6f49a1b39fa6..d3d0c1374334 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -946,10 +946,11 @@ struct usb_class_driver {
  */
 extern int usb_register_driver(struct usb_driver *, struct module *,
 			       const char *);
-static inline int usb_register(struct usb_driver *driver)
-{
-	return usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME);
-}
+
+/* use a define to avoid include chaining to get THIS_MODULE & friends */
+#define usb_register(driver) \
+	usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)
+
 extern void usb_deregister(struct usb_driver *);
 
 extern int usb_register_device_driver(struct usb_device_driver *,

commit 65580b4321eb36f16ae8b5987bfa1bb948fc5112
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:52 2011 -0700

    xHCI: set USB2 hardware LPM
    
    If the device pass the USB2 software LPM and the host supports hardware
    LPM, enable hardware LPM for the device to let the host decide when to
    put the link into lower power state.
    
    If hardware LPM is enabled for a port and driver wants to put it into
    suspend, it must first disable hardware LPM, resume the port into U0,
    and then suspend the port.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1d00d9bc5d65..6f49a1b39fa6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -411,6 +411,8 @@ struct usb_tt;
  * @authenticated: Crypto authentication passed
  * @wusb: device is Wireless USB
  * @lpm_capable: device supports LPM
+ * @usb2_hw_lpm_capable: device can perform USB2 hardware LPM
+ * @usb2_hw_lpm_enabled: USB2 hardware LPM enabled
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
  * @manufacturer: iManufacturer string, if present (static)
@@ -474,6 +476,8 @@ struct usb_device {
 	unsigned authenticated:1;
 	unsigned wusb:1;
 	unsigned lpm_capable:1;
+	unsigned usb2_hw_lpm_capable:1;
+	unsigned usb2_hw_lpm_enabled:1;
 	int string_langid;
 
 	/* static strings from the device */

commit 1ff4df56846d10379939166713bb2908e6a5ee0e
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:48 2011 -0700

    usbcore: check device's LPM capability
    
    Check device's LPM capability by examining the bmAttibutes field of the
    USB2.0 Extension Descriptor.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 90ab9dc1f080..1d00d9bc5d65 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -410,6 +410,7 @@ struct usb_tt;
  *	FIXME -- complete doc
  * @authenticated: Crypto authentication passed
  * @wusb: device is Wireless USB
+ * @lpm_capable: device supports LPM
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
  * @manufacturer: iManufacturer string, if present (static)
@@ -472,6 +473,7 @@ struct usb_device {
 	unsigned authorized:1;
 	unsigned authenticated:1;
 	unsigned wusb:1;
+	unsigned lpm_capable:1;
 	int string_langid;
 
 	/* static strings from the device */

commit 3148bf041d169a083aa31bd69bedd5bfb7ffe215
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:47 2011 -0700

    usbcore: get BOS descriptor set
    
    This commit gets BOS(Binary Device Object Store) descriptor set for Super
    Speed devices and High Speed devices which support BOS descriptor.
    
    BOS descriptor is used to report additional USB device-level capabilities
    that are not reported via the Device descriptor. By getting BOS descriptor
    set, driver can check device's device-level capability such as LPM
    capability.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c19f9100c307..90ab9dc1f080 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -292,6 +292,16 @@ struct usb_host_config {
 	int extralen;
 };
 
+/* USB2.0 and USB3.0 device BOS descriptor set */
+struct usb_host_bos {
+	struct usb_bos_descriptor	*desc;
+
+	/* wireless cap descriptor is handled by wusb */
+	struct usb_ext_cap_descriptor	*ext_cap;
+	struct usb_ss_cap_descriptor	*ss_cap;
+	struct usb_ss_container_id_descriptor	*ss_id;
+};
+
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	unsigned char type, void **ptr);
 #define usb_get_extra_descriptor(ifpoint, type, ptr) \
@@ -381,6 +391,7 @@ struct usb_tt;
  * @ep0: endpoint 0 data (default control pipe)
  * @dev: generic device interface
  * @descriptor: USB device descriptor
+ * @bos: USB device BOS descriptor set
  * @config: all of the device's configs
  * @actconfig: the active configuration
  * @ep_in: array of IN endpoints
@@ -442,6 +453,7 @@ struct usb_device {
 	struct device dev;
 
 	struct usb_device_descriptor descriptor;
+	struct usb_host_bos *bos;
 	struct usb_host_config *config;
 
 	struct usb_host_config *actconfig;

commit 29cc88979a8818cd8c5019426e945aed118b400e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 23 03:12:03 2011 -0700

    USB: use usb_endpoint_maxp() instead of le16_to_cpu()
    
    Now ${LINUX}/drivers/usb/* can use usb_endpoint_maxp(desc) to get maximum packet size
    instead of le16_to_cpu(desc->wMaxPacketSize).
    This patch fix it up
    
    Cc: Armin Fuerst <fuerst@in.tum.de>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Erdfelt <johannes@erdfelt.com>
    Cc: Vojtech Pavlik <vojtech@suse.cz>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: David Kubicek <dave@awk.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Brad Hards <bhards@bigpond.net.au>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Dahlmann <dahlmann.thomas@arcor.de>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: David Lopo <dlopo@chipidea.mips.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Xie Xiaobo <X.Xie@freescale.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Jiang Bo <tanya.jiang@freescale.com>
    Cc: Yuan-hsin Chen <yhchen@faraday-tech.com>
    Cc: Darius Augulis <augulis.darius@gmail.com>
    Cc: Xiaochen Shen <xiaochen.shen@intel.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: OKI SEMICONDUCTOR, <toshiharu-linux@dsn.okisemi.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Ben Dooks <ben@simtec.co.uk>
    Cc: Thomas Abraham <thomas.ab@samsung.com>
    Cc: Herbert Ptzl <herbert@13thfloor.at>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Roman Weissgaerber <weissg@vienna.at>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Tony Olech <tony.olech@elandigitalsystems.com>
    Cc: Florian Floe Echtler <echtler@fs.tum.de>
    Cc: Christian Lucht <lucht@codemercs.com>
    Cc: Juergen Stuber <starblue@sourceforge.net>
    Cc: Georges Toth <g.toth@e-biz.lu>
    Cc: Bill Ryder <bryder@sgi.com>
    Cc: Kuba Ober <kuba@mareimbrium.org>
    Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 73c7df489607..c19f9100c307 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1574,7 +1574,7 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 		return 0;
 
 	/* NOTE:  only 0x07ff bits are for packet size... */
-	return le16_to_cpu(ep->desc.wMaxPacketSize);
+	return usb_endpoint_maxp(&ep->desc);
 }
 
 /* ----------------------------------------------------------------------- */

commit 6498d9db6d2dad4cf5deb2dd09e0816904f41ca5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Apr 28 10:45:24 2011 -0400

    USB: documentation update for the pre_reset method
    
    This patch (as1459) updates the documentation for the pre_reset method
    in struct usb_driver.  When a driver is notified of an impending
    reset, it must cancel all outstanding I/O and not start any new I/O
    until it has been notified that the reset is complete.
    
    As far as I know, most existing drivers that implement pre_reset do
    this now.  The major exceptions appear to be the SpeedTouch and
    CDC-WDM drivers.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 65f78ca5d88e..73c7df489607 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -806,8 +806,10 @@ struct usbdrv_wrap {
  * @resume: Called when the device is being resumed by the system.
  * @reset_resume: Called when the suspended device has been reset instead
  *	of being resumed.
- * @pre_reset: Called by usb_reset_device() when the device
- *	is about to be reset.
+ * @pre_reset: Called by usb_reset_device() when the device is about to be
+ *	reset.  This routine must not return until the driver has no active
+ *	URBs for the device, and no more URBs may be submitted until the
+ *	post_reset method is called.
  * @post_reset: Called by usb_reset_device() after the device
  *	has been reset
  * @id_table: USB drivers use ID table to support hotplugging.

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e63efeb378e3..65f78ca5d88e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -623,7 +623,7 @@ extern struct usb_host_interface *usb_find_alt_setting(
  * USB hubs.  That makes it stay the same until systems are physically
  * reconfigured, by re-cabling a tree of USB devices or by moving USB host
  * controllers.  Adding and removing devices, including virtual root hubs
- * in host controller driver modules, does not change these path identifers;
+ * in host controller driver modules, does not change these path identifiers;
  * neither does rebooting or re-enumerating.  These are more useful identifiers
  * than changeable ("unstable") ones like bus numbers or device addresses.
  *
@@ -793,7 +793,7 @@ struct usbdrv_wrap {
  *	usb_set_intfdata() to associate driver-specific data with the
  *	interface.  It may also use usb_set_interface() to specify the
  *	appropriate altsetting.  If unwilling to manage the interface,
- *	return -ENODEV, if genuine IO errors occured, an appropriate
+ *	return -ENODEV, if genuine IO errors occurred, an appropriate
  *	negative errno value.
  * @disconnect: Called when the interface is no longer accessible, usually
  *	because its device has been (or is being) disconnected or the

commit 2694a48d9007a8bdf1731c1b97d4942c9cc49296
Author: Robert Morell <rmorell@nvidia.com>
Date:   Wed Jan 26 19:06:48 2011 -0800

    USB: HCD: Add driver hooks for (un)?map_urb_for_dma
    
    Provide optional hooks for the host controller driver to override the
    default DMA mapping and unmapping routines.  In general, these shouldn't
    be necessary unless the host controller has special DMA requirements,
    such as alignment contraints.  If these are not specified, the
    general usb_hcd_(un)?map_urb_for_dma functions will be used instead.
    Also, pass the status to unmap_urb_for_dma so it can know whether the
    DMA buffer has been overwritten.
    
    Finally, add a flag to be used by these implementations if they
    allocated a temporary buffer so it can be freed properly when unmapping.
    
    Signed-off-by: Robert Morell <rmorell@nvidia.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index bd69b65f3356..e63efeb378e3 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -976,6 +976,7 @@ extern int usb_disabled(void);
 #define URB_SETUP_MAP_SINGLE	0x00100000	/* Setup packet DMA mapped */
 #define URB_SETUP_MAP_LOCAL	0x00200000	/* HCD-local setup packet */
 #define URB_DMA_SG_COMBINED	0x00400000	/* S-G entries were combined */
+#define URB_ALIGNED_TEMP_BUFFER	0x00800000	/* Temp buffer was alloc'd */
 
 struct usb_iso_packet_descriptor {
 	unsigned int offset;

commit 36facadd9ea98f8415d0dbb63e0763b7ee9d3911
Merge: 2faa83e2a519 0b83ae960cd7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 16 10:05:06 2010 -0800

    Merge branch 'usb-next' into musb-merge
    
    * usb-next: (132 commits)
      USB: uas: Use GFP_NOIO instead of GFP_KERNEL in I/O submission path
      USB: uas: Ensure we only bind to a UAS interface
      USB: uas: Rename sense pipe and sense urb to status pipe and status urb
      USB: uas: Use kzalloc instead of kmalloc
      USB: uas: Fix up the Sense IU
      usb: musb: core: kill unneeded #include's
      DA8xx: assign name to MUSB IRQ resource
      usb: gadget: g_ncm added
      usb: gadget: f_ncm.c added
      usb: gadget: u_ether: prepare for NCM
      usb: pch_udc: Fix setup transfers with data out
      usb: pch_udc: Fix compile error, warnings and checkpatch warnings
      usb: add ab8500 usb transceiver driver
      USB: gadget: Implement runtime PM for MSM bus glue driver
      USB: gadget: Implement runtime PM for ci13xxx gadget
      USB: gadget: Add USB controller driver for MSM SoC
      USB: gadget: Introduce ci13xxx_udc_driver struct
      USB: gadget: Initialize ci13xxx gadget device's coherent DMA mask
      USB: gadget: Fix "scheduling while atomic" bugs in ci13xxx_udc
      USB: gadget: Separate out PCI bus code from ci13xxx_udc
      ...

commit 07a8cdd2bb17a4da68136d963b8bc71959bd31a5
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Thu Nov 18 18:54:17 2010 +0530

    usb: musb: do not use dma for control transfers
    
    The Inventra DMA engine used with the MUSB controller in many
    SoCs cannot use DMA for control transfers on EP0, but can use
    DMA for all other transfers.
    
    The USB core maps urbs for DMA if hcd->self.uses_dma is true.
    (hcd->self.uses_dma is true for MUSB as well).
    
    Split the uses_dma flag into two - one that says if the
    controller needs to use PIO for control transfers, and
    another which says if the controller uses DMA (for all
    other transfers).
    
    Also, populate this flag for all MUSB by default.
    
    (Tested on OMAP3 and OMAP4 boards, with EHCI and MUSB HCDs
    simultaneously in use).
    
    Signed-off-by: Maulik Mankad <x0082077@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Praveena NADAHALLY <praveen.nadahally@stericsson.com>
    Cc: Ajay Kumar Gupta <ajay.gupta@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 24300d8a1bc1..a28eb2592577 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -313,6 +313,10 @@ struct usb_bus {
 	int busnum;			/* Bus number (in order of reg) */
 	const char *bus_name;		/* stable id (PCI slot_name etc) */
 	u8 uses_dma;			/* Does the host controller use DMA? */
+	u8 uses_pio_for_control;	/*
+					 * Does the host controller use PIO
+					 * for control transfers?
+					 */
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */

commit fcc4a01eb8661226e80632327673f67bf6a5840b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 15 15:57:51 2010 -0500

    USB: use the runtime-PM autosuspend implementation
    
    This patch (as1428) converts USB over to the new runtime-PM core
    autosuspend framework.  One slightly awkward aspect of the conversion
    is that USB devices will now have two suspend-delay attributes: the
    old power/autosuspend file and the new power/autosuspend_delay_ms
    file.  One expresses the delay time in seconds and the other in
    milliseconds, but otherwise they do the same thing.  The old attribute
    can be deprecated and then removed eventually.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7d22b3340a7f..5ee2223af08c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -408,7 +408,6 @@ struct usb_tt;
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
- * @autosuspend_delay: in jiffies
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
@@ -481,7 +480,6 @@ struct usb_device {
 	unsigned long active_duration;
 
 #ifdef CONFIG_PM
-	int autosuspend_delay;
 	unsigned long connect_time;
 
 	unsigned do_remote_wakeup:1;

commit 6ddf27cdbc218a412d7e993fdc08e30eec2042ce
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Mon Nov 15 15:57:30 2010 -0500

    USB: make usb_mark_last_busy use pm_runtime_mark_last_busy
    
    Since the runtime-PM core already defines a .last_busy field in
    device.power, this patch uses it to replace the .last_busy field
    defined in usb_device and uses pm_runtime_mark_last_busy to implement
    usb_mark_last_busy.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 35fe6ab222bb..7d22b3340a7f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -20,6 +20,7 @@
 #include <linux/completion.h>	/* for struct completion */
 #include <linux/sched.h>	/* for current && schedule_timeout */
 #include <linux/mutex.h>	/* for struct mutex */
+#include <linux/pm_runtime.h>	/* for runtime PM */
 
 struct usb_device;
 struct usb_driver;
@@ -407,7 +408,6 @@ struct usb_tt;
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
- * @last_busy: time of last use
  * @autosuspend_delay: in jiffies
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
@@ -481,7 +481,6 @@ struct usb_device {
 	unsigned long active_duration;
 
 #ifdef CONFIG_PM
-	unsigned long last_busy;
 	int autosuspend_delay;
 	unsigned long connect_time;
 
@@ -527,7 +526,7 @@ extern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
 static inline void usb_mark_last_busy(struct usb_device *udev)
 {
-	udev->last_busy = jiffies;
+	pm_runtime_mark_last_busy(&udev->dev);
 }
 
 #else

commit a91be2acc648f18d39b15c6eb7136b0c208e2cab
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Oct 25 15:04:13 2010 -0700

    usb.h: fix ioctl kernel-doc info
    
    Fix struct field name, prevent kernel-doc warnings.
    
    Warning(include/linux/usb.h:865): No description found for parameter 'unlocked_ioctl'
    Warning(include/linux/usb.h:865): Excess struct/union/enum/typedef member 'ioctl' description in 'usb_driver'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 35fe6ab222bb..24300d8a1bc1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -797,7 +797,7 @@ struct usbdrv_wrap {
  * @disconnect: Called when the interface is no longer accessible, usually
  *	because its device has been (or is being) disconnected or the
  *	driver module is being unloaded.
- * @ioctl: Used for drivers that want to talk to userspace through
+ * @unlocked_ioctl: Used for drivers that want to talk to userspace through
  *	the "usbfs" filesystem.  This lets devices provide ways to
  *	expose information to user space regardless of where they
  *	do (or don't) show up otherwise in the filesystem.

commit c6ba1c2af2da31ffb57949edbd1dba34f97d1d4b
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Jul 29 15:54:38 2010 -0700

    USB:: fix linux/usb.h kernel-doc warnings
    
    Fix kernel-doc warnings in linux/usb.h:
    
    Warning(include/linux/usb.h:185): No description found for parameter 'resetting_device'
    Warning(include/linux/usb.h:1212): No description found for parameter 'stream_id'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e6cbc34901f4..35fe6ab222bb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -127,6 +127,8 @@ enum usb_interface_condition {
  *      queued reset so that usb_cancel_queued_reset() doesn't try to
  *      remove from the workqueue when running inside the worker
  *      thread. See __usb_queue_reset_device().
+ * @resetting_device: USB core reset the device, so use alt setting 0 as
+ *	current; needs bandwidth alloc after reset.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -1015,6 +1017,7 @@ typedef void (*usb_complete_t)(struct urb *);
  *	is a different endpoint (and pipe) from "out" endpoint two.
  *	The current configuration controls the existence, type, and
  *	maximum packet size of any given endpoint.
+ * @stream_id: the endpoint's stream ID for bulk streams
  * @dev: Identifies the USB device to perform the request.
  * @status: This is read in non-iso completion functions to get the
  *	status of the particular request.  ISO requests only use it

commit c532b29a6f6d31e84a7c88f995eebdc75ebd4248
Author: Andi Kleen <ak@linux.intel.com>
Date:   Tue Jun 1 23:04:41 2010 +0200

    USB-BKL: Convert usb_driver ioctl to unlocked_ioctl
    
    And audit all the users. None needed the BKL.  That was easy
    because there was only very few around.
    
    Tested with allmodconfig build on x86-64
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    From: Andi Kleen <ak@linux.intel.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d5922a877994..e6cbc34901f4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -843,7 +843,7 @@ struct usb_driver {
 
 	void (*disconnect) (struct usb_interface *intf);
 
-	int (*ioctl) (struct usb_interface *intf, unsigned int code,
+	int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,
 			void *buf);
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);

commit e26bcf37234c67624f62d9fc95f922b8dbda1363
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Apr 29 15:46:07 2010 -0700

    USB: remove unused usb_buffer_alloc and usb_buffer_free macros
    
    Now that all callers are converted over, remove the compatibility
    functions and all is good.
    
    Cc: Daniel Mack <daniel@caiaq.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 88e854cd6b32..d5922a877994 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1372,18 +1372,6 @@ void *usb_alloc_coherent(struct usb_device *dev, size_t size,
 void usb_free_coherent(struct usb_device *dev, size_t size,
 	void *addr, dma_addr_t dma);
 
-/* Compatible macros while we switch over */
-static inline void *usb_buffer_alloc(struct usb_device *dev, size_t size,
-				     gfp_t mem_flags, dma_addr_t *dma)
-{
-	return usb_alloc_coherent(dev, size, mem_flags, dma);
-}
-static inline void usb_buffer_free(struct usb_device *dev, size_t size,
-				   void *addr, dma_addr_t dma)
-{
-	return usb_free_coherent(dev, size, addr, dma);
-}
-
 #if 0
 struct urb *usb_buffer_map(struct urb *urb);
 void usb_buffer_dmasync(struct urb *urb);

commit 812219ab8facf07b94e4b3fe81e9cd3fe4129777
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon May 17 10:40:55 2010 -0700

    USB: usb.h: checkpatch cleanups
    
    Minor formatting changes to clean up the file.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3185eb46d85a..88e854cd6b32 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -65,7 +65,7 @@ struct usb_host_endpoint {
 	struct usb_ss_ep_comp_descriptor	ss_ep_comp;
 	struct list_head		urb_list;
 	void				*hcpriv;
-	struct ep_device 		*ep_dev;	/* For sysfs info */
+	struct ep_device		*ep_dev;	/* For sysfs info */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
@@ -96,8 +96,8 @@ enum usb_interface_condition {
 /**
  * struct usb_interface - what usb device drivers talk to
  * @altsetting: array of interface structures, one for each alternate
- * 	setting that may be selected.  Each one includes a set of
- * 	endpoint configurations.  They will be in no particular order.
+ *	setting that may be selected.  Each one includes a set of
+ *	endpoint configurations.  They will be in no particular order.
  * @cur_altsetting: the current altsetting.
  * @num_altsetting: number of altsettings defined.
  * @intf_assoc: interface association descriptor
@@ -200,7 +200,7 @@ void usb_put_intf(struct usb_interface *intf);
 
 /* this maximum is arbitrary */
 #define USB_MAXINTERFACES	32
-#define USB_MAXIADS		USB_MAXINTERFACES/2
+#define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
 /**
  * struct usb_interface_cache - long-term representation of a device interface
@@ -420,7 +420,7 @@ struct usb_tt;
  */
 struct usb_device {
 	int		devnum;
-	char		devpath [16];
+	char		devpath[16];
 	u32		route;
 	enum usb_device_state	state;
 	enum usb_device_speed	speed;
@@ -453,7 +453,7 @@ struct usb_device {
 	unsigned persist_enabled:1;
 	unsigned have_langid:1;
 	unsigned authorized:1;
- 	unsigned authenticated:1;
+	unsigned authenticated:1;
 	unsigned wusb:1;
 	int string_langid;
 
@@ -664,7 +664,7 @@ static inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)
  * This macro is used to create a struct usb_device_id that matches a
  * specific device.
  */
-#define USB_DEVICE(vend,prod) \
+#define USB_DEVICE(vend, prod) \
 	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \
 	.idVendor = (vend), \
 	.idProduct = (prod)
@@ -1186,7 +1186,7 @@ struct urb {
 					 * current owner */
 	struct list_head anchor_list;	/* the URB may be anchored */
 	struct usb_anchor *anchor;
-	struct usb_device *dev; 	/* (in) pointer to associated device */
+	struct usb_device *dev;		/* (in) pointer to associated device */
 	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint */
 	unsigned int pipe;		/* (in) pipe information */
 	unsigned int stream_id;		/* (in) stream ID */
@@ -1535,21 +1535,21 @@ static inline unsigned int __create_pipe(struct usb_device *dev,
 }
 
 /* Create various pipes... */
-#define usb_sndctrlpipe(dev,endpoint)	\
+#define usb_sndctrlpipe(dev, endpoint)	\
 	((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint))
-#define usb_rcvctrlpipe(dev,endpoint)	\
+#define usb_rcvctrlpipe(dev, endpoint)	\
 	((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
-#define usb_sndisocpipe(dev,endpoint)	\
+#define usb_sndisocpipe(dev, endpoint)	\
 	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint))
-#define usb_rcvisocpipe(dev,endpoint)	\
+#define usb_rcvisocpipe(dev, endpoint)	\
 	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
-#define usb_sndbulkpipe(dev,endpoint)	\
+#define usb_sndbulkpipe(dev, endpoint)	\
 	((PIPE_BULK << 30) | __create_pipe(dev, endpoint))
-#define usb_rcvbulkpipe(dev,endpoint)	\
+#define usb_rcvbulkpipe(dev, endpoint)	\
 	((PIPE_BULK << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
-#define usb_sndintpipe(dev,endpoint)	\
+#define usb_sndintpipe(dev, endpoint)	\
 	((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint))
-#define usb_rcvintpipe(dev,endpoint)	\
+#define usb_rcvintpipe(dev, endpoint)	\
 	((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
 
 static inline struct usb_host_endpoint *

commit 22b4b6113ec5d0ff2a9175bc611f3f3f61e4e172
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed May 12 23:38:46 2010 +0800

    USB: remove usb_find_device
    
    Now on one uses this function and it seems useless,
    so remove usb_find_device.
    
    [tom@tom linux-2.6-next]$ grep -r -n -I usb_find_device ./
    drivers/media/dvb/dvb-usb/dvb-usb-init.c:160:static struct
    dvb_usb_device_description * dvb_usb_find_device(struct usb_device
    *udev,struct dvb_usb_device_properties *props, int *cold)
    
    drivers/media/dvb/dvb-usb/dvb-usb-init.c:230:   if ((desc =
    dvb_usb_find_device(udev,props,&cold)) == NULL) {
    
    drivers/usb/core/usb.c:630: * usb_find_device - find a specific usb device in the system
    drivers/usb/core/usb.c:642:struct usb_device *usb_find_device(u16 vendor_id, u16 product_id)
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index ce07062ebc28..3185eb46d85a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -510,7 +510,6 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 extern int usb_reset_device(struct usb_device *dev);
 extern void usb_queue_reset_device(struct usb_interface *dev);
 
-extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND

commit 0ba169aff9181389f30f225ad92e113eeb2290b9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 5 15:26:17 2010 -0400

    USB: simplify usb_sg_init()
    
    This patch (as1377) simplifies the code in usb_sg_init(), without
    changing its functionality.  It also removes a couple of unused fields
    from the usb_sg_request structure.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index eec9e74f332f..ce07062ebc28 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1469,8 +1469,6 @@ struct usb_sg_request {
 
 	struct usb_device	*dev;
 	int			pipe;
-	struct scatterlist	*sg;
-	int			nents;
 
 	int			entries;
 	struct urb		**urbs;

commit 910f8d0cede74beff1eee93cf9cf2a28d7600e66
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sat May 1 12:20:01 2010 -0600

    USB: Change the scatterlist type in struct urb
    
    Change the type of the URB's 'sg' pointer from a usb_sg_request to
    a scatterlist.  This allows drivers to submit scatter-gather lists
    without using the usb_sg_wait() interface.  It has the added benefit
    of removing the typecasts that were added as part of patch as1368 (and
    slightly decreasing the number of pointer dereferences).
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cf3b289a87a2..eec9e74f332f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1195,7 +1195,7 @@ struct urb {
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/
 	void *transfer_buffer;		/* (in) associated data buffer */
 	dma_addr_t transfer_dma;	/* (in) dma addr for transfer_buffer */
-	struct usb_sg_request *sg;	/* (in) scatter gather buffer list */
+	struct scatterlist *sg;		/* (in) scatter gather buffer list */
 	int num_sgs;			/* (in) number of entries in the sg list */
 	u32 transfer_buffer_length;	/* (in) data buffer length */
 	u32 actual_length;		/* (return) actual transfer length */

commit 1e429018b646bdf903554e92ead1cda96cc552dc
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Apr 30 13:11:30 2010 -0600

    USB: Turn interface_to_usbdev into an inline function
    
    The stronger type-checking would have prevented a bug I had.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index fd7d61e58198..cf3b289a87a2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -184,8 +184,6 @@ struct usb_interface {
 	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
-#define	interface_to_usbdev(intf) \
-	container_of(intf->dev.parent, struct usb_device, dev)
 
 static inline void *usb_get_intfdata(struct usb_interface *intf)
 {
@@ -493,6 +491,11 @@ struct usb_device {
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
+static inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)
+{
+	return to_usb_device(intf->dev.parent);
+}
+
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
 

commit fe54b058de9d1df5fef9e2a559651f4b7c9f04b1
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Apr 30 13:11:29 2010 -0600

    USB: Add a usb_pipe_endpoint() convenience function
    
    Converting a pipe number to a struct usb_host_endpoint pointer is a little
    messy.  Introduce a new convenience function to hide the mess.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1eb4762d9ea8..fd7d61e58198 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1552,6 +1552,14 @@ static inline unsigned int __create_pipe(struct usb_device *dev,
 #define usb_rcvintpipe(dev,endpoint)	\
 	((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
 
+static inline struct usb_host_endpoint *
+usb_pipe_endpoint(struct usb_device *dev, unsigned int pipe)
+{
+	struct usb_host_endpoint **eps;
+	eps = usb_pipein(pipe) ? dev->ep_in : dev->ep_out;
+	return eps[usb_pipeendpoint(pipe)];
+}
+
 /*-------------------------------------------------------------------------*/
 
 static inline __u16

commit 85bcb5ee889e0ebb9154718939e049de265fcdfb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 30 16:35:37 2010 -0400

    USB: remove URB_NO_SETUP_DMA_MAP
    
    Now that URB_NO_SETUP_DMA_MAP is no longer in use, this patch (as1376)
    removes all references to it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a748815ee629..1eb4762d9ea8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -953,7 +953,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame
 					 * ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb->transfer_dma valid on submit */
-#define URB_NO_SETUP_DMA_MAP	0x0008	/* urb->setup_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
@@ -1049,12 +1048,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @setup_packet: Only used for control transfers, this points to eight bytes
  *	of setup data.  Control transfers always start by sending this data
  *	to the device.  Then transfer_buffer is read or written, if needed.
- * @setup_dma: For control transfers with URB_NO_SETUP_DMA_MAP set, the
- *	device driver has provided this DMA address for the setup packet.
- *	The host controller driver should use this in preference to
- *	setup_packet, but the HCD may chose to ignore the address if it must
- *	copy the setup packet into internal structures.  Therefore, setup_packet
- *	must always point to a valid buffer.
+ * @setup_dma: DMA pointer for the setup packet.  The caller must not use
+ *	this field; setup_packet must point to a valid buffer.
  * @start_frame: Returns the initial frame for isochronous transfers.
  * @number_of_packets: Lists the number of ISO transfer buffers.
  * @interval: Specifies the polling interval for interrupt or isochronous
@@ -1086,13 +1081,14 @@ typedef void (*usb_complete_t)(struct urb *);
  * bounce buffer or talking to an IOMMU),
  * although they're cheap on commodity x86 and ppc hardware.
  *
- * Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,
- * which tell the host controller driver that no such mapping is needed since
+ * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,
+ * which tells the host controller driver that no such mapping is needed for
+ * the transfer_buffer since
  * the device driver is DMA-aware.  For example, a device driver might
  * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().
- * When these transfer flags are provided, host controller drivers will
- * attempt to use the dma addresses found in the transfer_dma and/or
- * setup_dma fields rather than determining a dma address themselves.
+ * When this transfer flag is provided, host controller drivers will
+ * attempt to use the dma address found in the transfer_dma
+ * field rather than determining a dma address themselves.
  *
  * Note that transfer_buffer must still be set if the controller
  * does not support DMA (as indicated by bus.uses_dma) and when talking
@@ -1115,11 +1111,9 @@ typedef void (*usb_complete_t)(struct urb *);
  * should always terminate with a short packet, even if it means adding an
  * extra zero length packet.
  *
- * Control URBs must provide a setup_packet.  The setup_packet and
- * transfer_buffer may each be mapped for DMA or not, independently of
- * the other.  The transfer_flags bits URB_NO_TRANSFER_DMA_MAP and
- * URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.
- * URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.
+ * Control URBs must provide a valid pointer in the setup_packet field.
+ * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA
+ * beforehand.
  *
  * Interrupt URBs must provide an interval, saying how often (in milliseconds
  * or, for highspeed devices, 125 microsecond units)

commit 842f16905dfc6743c1dd80c3d29b49ba3ab7f7c8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 30 12:44:46 2010 -0400

    USB: remove the usb_host_ss_ep_comp structure
    
    This patch (as1375) eliminates the usb_host_ss_ep_comp structure used
    for storing a dynamically-allocated copy of the SuperSpeed endpoint
    companion descriptor.  The SuperSpeed descriptor is placed directly in
    the usb_host_endpoint structure, alongside the standard endpoint
    descriptor.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1ea25377ca0d..a748815ee629 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -45,27 +45,14 @@ struct wusb_dev;
 
 struct ep_device;
 
-/* For SS devices */
-/**
- * struct usb_host_ss_ep_comp - Valid for SuperSpeed devices only
- * @desc: endpoint companion descriptor, wMaxPacketSize in native byteorder
- * @extra: descriptors following this endpoint companion descriptor
- * @extralen: how many bytes of "extra" are valid
- */
-struct usb_host_ss_ep_comp {
-	struct usb_ss_ep_comp_descriptor	desc;
-	unsigned char				*extra;   /* Extra descriptors */
-	int					extralen;
-};
-
 /**
  * struct usb_host_endpoint - host-side endpoint descriptor and queue
  * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
+ * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint
  * @urb_list: urbs queued to this endpoint; maintained by usbcore
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
  * @ep_dev: ep_device for sysfs info
- * @ss_ep_comp: companion descriptor information for this endpoint
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
@@ -74,11 +61,11 @@ struct usb_host_ss_ep_comp {
  * descriptor within an active interface in a given USB configuration.
  */
 struct usb_host_endpoint {
-	struct usb_endpoint_descriptor	desc;
+	struct usb_endpoint_descriptor		desc;
+	struct usb_ss_ep_comp_descriptor	ss_ep_comp;
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device 		*ep_dev;	/* For sysfs info */
-	struct usb_host_ss_ep_comp	*ss_ep_comp;	/* For SS devices */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;

commit eab1cafc3b524b714b0567ab98fc75ace09db98c
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 5 10:55:58 2010 -0700

    USB: Support for allocating USB 3.0 streams.
    
    Bulk endpoint streams were added in the USB 3.0 specification.  Streams
    allow a device driver to overload a bulk endpoint so that multiple
    transfers can be queued at once.
    
    The device then decides which transfer it wants to work on first, and can
    queue part of a transfer before it switches to a new stream.  All this
    switching is invisible to the device driver, which just gets a completion
    for the URB.  Drivers that use streams must be able to handle URBs
    completing in a different order than they were submitted to the endpoint.
    
    This requires adding new API to set up xHCI data structures to support
    multiple queues ("stream rings") per endpoint.  Drivers will allocate a
    number of stream IDs before enqueueing URBs to the bulk endpoints of the
    device, and free the stream IDs in their disconnect function.  See
    Documentation/usb/bulk-streams.txt for details.
    
    The new mass storage device class, USB Attached SCSI Protocol (UASP), uses
    these streams API.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 191af498c4f5..1ea25377ca0d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -570,6 +570,16 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 /* for drivers using iso endpoints */
 extern int usb_get_current_frame_number(struct usb_device *usb_dev);
 
+/* Sets up a group of bulk endpoints to support multiple stream IDs. */
+extern int usb_alloc_streams(struct usb_interface *interface,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		unsigned int num_streams, gfp_t mem_flags);
+
+/* Reverts a group of bulk endpoints back to not using stream IDs. */
+extern void usb_free_streams(struct usb_interface *interface,
+		struct usb_host_endpoint **eps, unsigned int num_eps,
+		gfp_t mem_flags);
+
 /* used these for multi-interface device registration */
 extern int usb_driver_claim_interface(struct usb_driver *driver,
 			struct usb_interface *iface, void *priv);

commit 94af1220985c71cd80d6c161b7a42c51ef08b923
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Fri Apr 2 15:34:10 2010 -0700

    USB: Add stream ID field to struct urb.
    
    Bulk endpoint streams were added in the USB 3.0 specification.  Streams
    allow a device driver to overload a bulk endpoint so that multiple
    transfers can be queued at once.
    
    Add a new field, stream_id, to struct urb so that USB 3.0 drivers can
    specify which stream they want the URB to be queued to.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e32a849f81ce..191af498c4f5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1196,6 +1196,7 @@ struct urb {
 	struct usb_device *dev; 	/* (in) pointer to associated device */
 	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint */
 	unsigned int pipe;		/* (in) pipe information */
+	unsigned int stream_id;		/* (in) stream ID */
 	int status;			/* (return) non-ISO status */
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/
 	void *transfer_buffer;		/* (in) associated data buffer */

commit 9e18c821659d836bd63f88df3c19729327728496
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 2 13:22:09 2010 -0400

    USB: use PM core routines to enable/disable autosuspend
    
    This patch (as1366) replaces the private routines
    usb_enable_autosuspend() and usb_disable_autosuspend() with calls to
    the standard pm_runtime_allow() and pm_runtime_forbid() functions in
    the runtime PM framework.  They do the same thing.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 99833029e5a8..e32a849f81ce 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -425,7 +425,6 @@ struct usb_tt;
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
- * @autosuspend_disabled: autosuspend disabled by the user
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
@@ -501,7 +500,6 @@ struct usb_device {
 
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
-	unsigned autosuspend_disabled:1;
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;
@@ -526,8 +524,8 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
-extern int usb_enable_autosuspend(struct usb_device *udev);
-extern int usb_disable_autosuspend(struct usb_device *udev);
+extern void usb_enable_autosuspend(struct usb_device *udev);
+extern void usb_disable_autosuspend(struct usb_device *udev);
 
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);

commit ff9c895f07d36193c75533bda8193bde8ca99d02
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 2 13:27:28 2010 -0400

    USB: fix usbmon and DMA mapping for scatter-gather URBs
    
    This patch (as1368) fixes a rather obscure bug in usbmon: When tracing
    URBs sent by the scatter-gather library, it accesses the data buffers
    while they are still mapped for DMA.
    
    The solution is to move the mapping and unmapping out of the s-g
    library and into the usual place in hcd.c.  This requires the addition
    of new URB flag bits to describe the kind of mapping needed, since we
    have to call dma_map_sg() if the HCD supports native scatter-gather
    operation and dma_map_page() if it doesn't.  The nice thing about
    having the new flags is that they simplify the testing for unmapping.
    
    The patch removes the only caller of usb_buffer_[un]map_sg(), so those
    functions are #if'ed out.  A later patch will remove them entirely.
    
    As a result of this change, urb->sg will be set in situations where
    it wasn't set previously.  Hence the xhci and whci drivers are
    adjusted to test urb->num_sgs instead, which retains its original
    meaning and is nonzero only when the HCD has to handle a scatterlist.
    
    Finally, even when a submission error occurs we don't want to hand
    URBs to usbmon before they are unmapped.  The submission path is
    rearranged so that map_urb_for_dma() is called only for non-root-hub
    URBs and unmap_urb_for_dma() is called immediately after a submission
    error.  This simplifies the error handling.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 739f1fd1cc15..99833029e5a8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -965,10 +965,19 @@ extern int usb_disabled(void);
 					 * needed */
 #define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
 
+/* The following flags are used internally by usbcore and HCDs */
 #define URB_DIR_IN		0x0200	/* Transfer from device to host */
 #define URB_DIR_OUT		0
 #define URB_DIR_MASK		URB_DIR_IN
 
+#define URB_DMA_MAP_SINGLE	0x00010000	/* Non-scatter-gather mapping */
+#define URB_DMA_MAP_PAGE	0x00020000	/* HCD-unsupported S-G */
+#define URB_DMA_MAP_SG		0x00040000	/* HCD-supported S-G */
+#define URB_MAP_LOCAL		0x00080000	/* HCD-local-memory mapping */
+#define URB_SETUP_MAP_SINGLE	0x00100000	/* Setup packet DMA mapped */
+#define URB_SETUP_MAP_LOCAL	0x00200000	/* HCD-local setup packet */
+#define URB_DMA_SG_COMBINED	0x00400000	/* S-G entries were combined */
+
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
 	unsigned int length;		/* expected length */

commit 073900a28d95c75a706bf40ebf092ea048c7b236
Author: Daniel Mack <daniel@caiaq.de>
Date:   Mon Apr 12 13:17:25 2010 +0200

    USB: rename usb_buffer_alloc() and usb_buffer_free()
    
    For more clearance what the functions actually do,
    
      usb_buffer_alloc() is renamed to usb_alloc_coherent()
      usb_buffer_free()  is renamed to usb_free_coherent()
    
    They should only be used in code which really needs DMA coherency.
    
    [added compatibility macros so we can convert things easier - gregkh]
    
    Signed-off-by: Daniel Mack <daniel@caiaq.de>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Pedro Ribeiro <pedrib@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index ce1323c4e47c..739f1fd1cc15 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1085,7 +1085,7 @@ typedef void (*usb_complete_t)(struct urb *);
  * Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,
  * which tell the host controller driver that no such mapping is needed since
  * the device driver is DMA-aware.  For example, a device driver might
- * allocate a DMA buffer with usb_buffer_alloc() or call usb_buffer_map().
+ * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().
  * When these transfer flags are provided, host controller drivers will
  * attempt to use the dma addresses found in the transfer_dma and/or
  * setup_dma fields rather than determining a dma address themselves.
@@ -1366,11 +1366,23 @@ static inline int usb_urb_dir_out(struct urb *urb)
 	return (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;
 }
 
-void *usb_buffer_alloc(struct usb_device *dev, size_t size,
+void *usb_alloc_coherent(struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
-void usb_buffer_free(struct usb_device *dev, size_t size,
+void usb_free_coherent(struct usb_device *dev, size_t size,
 	void *addr, dma_addr_t dma);
 
+/* Compatible macros while we switch over */
+static inline void *usb_buffer_alloc(struct usb_device *dev, size_t size,
+				     gfp_t mem_flags, dma_addr_t *dma)
+{
+	return usb_alloc_coherent(dev, size, mem_flags, dma);
+}
+static inline void usb_buffer_free(struct usb_device *dev, size_t size,
+				   void *addr, dma_addr_t dma)
+{
+	return usb_free_coherent(dev, size, addr, dma);
+}
+
 #if 0
 struct urb *usb_buffer_map(struct urb *urb);
 void usb_buffer_dmasync(struct urb *urb);

commit f09a15e6e69884cedec4d1c022089a973aa01f1e
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Tue Mar 16 12:55:44 2010 -0700

    USB: Fix usb_fill_int_urb for SuperSpeed devices
    
    USB 3 and Wireless USB specify a logarithmic encoding of the endpoint
    interval that matches the USB 2 specification.  usb_fill_int_urb() didn't
    know that and was filling in the interval as if it was USB 1.1.  Fix
    usb_fill_int_urb() for SuperSpeed devices, but leave the wireless case
    alone, because David Vrabel wants to keep the old encoding.
    
    Update the struct urb kernel doc to note that SuperSpeed URBs must have
    urb->interval specified in microframes.
    
    Add a missing break statement in the usb_submit_urb() interrupt URB
    checking, since wireless USB and SuperSpeed USB encode urb->interval
    differently.  This allows xHCI roothubs to actually register with khubd.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8c9f053111bb..ce1323c4e47c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1055,7 +1055,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @number_of_packets: Lists the number of ISO transfer buffers.
  * @interval: Specifies the polling interval for interrupt or isochronous
  *	transfers.  The units are frames (milliseconds) for full and low
- *	speed devices, and microframes (1/8 millisecond) for highspeed ones.
+ *	speed devices, and microframes (1/8 millisecond) for highspeed
+ *	and SuperSpeed devices.
  * @error_count: Returns the number of ISO transfers that reported errors.
  * @context: For use in completion functions.  This normally points to
  *	request-specific driver context.
@@ -1286,9 +1287,16 @@ static inline void usb_fill_bulk_urb(struct urb *urb,
  *
  * Initializes a interrupt urb with the proper information needed to submit
  * it to a device.
- * Note that high speed interrupt endpoints use a logarithmic encoding of
- * the endpoint interval, and express polling intervals in microframes
- * (eight per millisecond) rather than in frames (one per millisecond).
+ *
+ * Note that High Speed and SuperSpeed interrupt endpoints use a logarithmic
+ * encoding of the endpoint interval, and express polling intervals in
+ * microframes (eight per millisecond) rather than in frames (one per
+ * millisecond).
+ *
+ * Wireless USB also uses the logarithmic encoding, but specifies it in units of
+ * 128us instead of 125us.  For Wireless USB devices, the interval is passed
+ * through to the host controller, rather than being translated into microframe
+ * units.
  */
 static inline void usb_fill_int_urb(struct urb *urb,
 				    struct usb_device *dev,
@@ -1305,7 +1313,7 @@ static inline void usb_fill_int_urb(struct urb *urb,
 	urb->transfer_buffer_length = buffer_length;
 	urb->complete = complete_fn;
 	urb->context = context;
-	if (dev->speed == USB_SPEED_HIGH)
+	if (dev->speed == USB_SPEED_HIGH || dev->speed == USB_SPEED_SUPER)
 		urb->interval = 1 << (interval - 1);
 	else
 		urb->interval = interval;

commit 8e9394ce2412254ec69fd2a4f3e44a66eade2297
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 17 10:57:05 2010 -0800

    Driver core: create lock/unlock functions for struct device
    
    In the future, we are going to be changing the lock type for struct
    device (once we get the lockdep infrastructure properly worked out)  To
    make that changeover easier, and to possibly burry the lock in a
    different part of struct device, let's create some functions to lock and
    unlock a device so that no out-of-core code needs to be changed in the
    future.
    
    This patch creates the device_lock/unlock/trylock() functions, and
    converts all in-tree users to them.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Magnus Damm <damm@igel.co.jp>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Vegard Nossum <vegard.nossum@gmail.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Alex Chiang <achiang@hp.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Yu Zhao <yu.zhao@intel.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Cc: CHENG Renquan <rqcheng@smu.edu.sg>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: Frans Pop <elendil@planet.nl>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3492abf82e75..8c9f053111bb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -512,9 +512,9 @@ extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
 
 /* USB device locking */
-#define usb_lock_device(udev)		down(&(udev)->dev.sem)
-#define usb_unlock_device(udev)		up(&(udev)->dev.sem)
-#define usb_trylock_device(udev)	down_trylock(&(udev)->dev.sem)
+#define usb_lock_device(udev)		device_lock(&(udev)->dev)
+#define usb_unlock_device(udev)		device_unlock(&(udev)->dev)
+#define usb_trylock_device(udev)	device_trylock(&(udev)->dev)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
 				     const struct usb_interface *iface);
 

commit efcbd3df079a6f8a8a2d5207c4e8429e02356c79
Author: Joe Perches <joe@perches.com>
Date:   Fri Feb 5 18:09:49 2010 -0800

    USB: Extend and neaten dbg macros
    
    Add format/argument validation for #ifndef DEBUG dbg macro
    Neaten dbg macro definitions
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index ad50fc8a7ad3..3492abf82e75 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1566,14 +1566,18 @@ extern void usb_register_notify(struct notifier_block *nb);
 extern void usb_unregister_notify(struct notifier_block *nb);
 
 #ifdef DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , \
-	__FILE__ , ## arg)
+#define dbg(format, arg...)						\
+	printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg)
 #else
-#define dbg(format, arg...) do {} while (0)
+#define dbg(format, arg...)						\
+do {									\
+	if (0)								\
+		printk(KERN_DEBUG "%s: " format "\n", __FILE__, ##arg); \
+} while (0)
 #endif
 
-#define err(format, arg...) printk(KERN_ERR KBUILD_MODNAME ": " \
-	format "\n" , ## arg)
+#define err(format, arg...)					\
+	printk(KERN_ERR KBUILD_MODNAME ": " format "\n", ##arg)
 
 /* debugfs stuff */
 extern struct dentry *usb_debug_root;

commit 9bbdf1e0afe771ca7650f9f476769310bee9d8f3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 8 12:57:28 2010 -0500

    USB: convert to the runtime PM framework
    
    This patch (as1329) converts the USB stack over to the PM core's
    runtime PM framework.  This involves numerous changes throughout
    usbcore, especially to hub.c and driver.c.  Perhaps the most notable
    change is that CONFIG_USB_SUSPEND now depends on CONFIG_PM_RUNTIME
    instead of CONFIG_PM.
    
    Several fields in the usb_device and usb_interface structures are no
    longer needed.  Some code which used to depend on CONFIG_USB_PM now
    depends on CONFIG_USB_SUSPEND (requiring some rearrangement of header
    files).
    
    The only visible change in behavior should be that following a system
    sleep (resume from RAM or resume from hibernation), autosuspended USB
    devices will be resumed just like everything else.  They won't remain
    suspended.  But if they aren't in use then they will naturally
    autosuspend again in a few seconds.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e6419ac89ea2..ad50fc8a7ad3 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -122,7 +122,6 @@ enum usb_interface_condition {
  *	number from the USB core by calling usb_register_dev().
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
- * @is_active: flag set when the interface is bound and not suspended.
  * @sysfs_files_created: sysfs attributes exist
  * @ep_devs_created: endpoint child pseudo-devices exist
  * @unregistering: flag set when the interface is being unregistered
@@ -135,8 +134,7 @@ enum usb_interface_condition {
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.
- * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
- *	allowed unless the counter is 0.
+ * @pm_usage_cnt: PM usage counter for this interface
  * @reset_ws: Used for scheduling resets from atomic context.
  * @reset_running: set to 1 if the interface is currently running a
  *      queued reset so that usb_cancel_queued_reset() doesn't try to
@@ -184,7 +182,6 @@ struct usb_interface {
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
-	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned ep_devs_created:1;	/* endpoint "devices" exist */
 	unsigned unregistering:1;	/* unregistration is in progress */
@@ -401,7 +398,6 @@ struct usb_tt;
  * @portnum: parent port number (origin 1)
  * @level: number of USB hub ancestors
  * @can_submit: URBs may be submitted
- * @discon_suspended: disconnected while suspended
  * @persist_enabled:  USB_PERSIST enabled for this device
  * @have_langid: whether string_langid is valid
  * @authorized: policy has said we can use it;
@@ -421,20 +417,15 @@ struct usb_tt;
  * @usbfs_dentry: usbfs dentry entry for the device
  * @maxchild: number of ports if hub
  * @children: child devices - USB devices that are attached to this hub
- * @pm_usage_cnt: usage counter for autosuspend
  * @quirks: quirks of the whole device
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
- * @autosuspend: for delayed autosuspends
- * @autoresume: for autoresumes requested while in_interrupt
- * @pm_mutex: protects PM operations
  * @last_busy: time of last use
  * @autosuspend_delay: in jiffies
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
  * @autosuspend_disabled: autosuspend disabled by the user
- * @skip_sys_resume: skip the next system resume
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
@@ -475,7 +466,6 @@ struct usb_device {
 	u8 level;
 
 	unsigned can_submit:1;
-	unsigned discon_suspended:1;
 	unsigned persist_enabled:1;
 	unsigned have_langid:1;
 	unsigned authorized:1;
@@ -499,17 +489,12 @@ struct usb_device {
 	int maxchild;
 	struct usb_device *children[USB_MAXCHILDREN];
 
-	int pm_usage_cnt;
 	u32 quirks;
 	atomic_t urbnum;
 
 	unsigned long active_duration;
 
 #ifdef CONFIG_PM
-	struct delayed_work autosuspend;
-	struct work_struct autoresume;
-	struct mutex pm_mutex;
-
 	unsigned long last_busy;
 	int autosuspend_delay;
 	unsigned long connect_time;
@@ -517,7 +502,6 @@ struct usb_device {
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
 	unsigned autosuspend_disabled:1;
-	unsigned skip_sys_resume:1;
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;
@@ -549,17 +533,8 @@ extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface_async(struct usb_interface *intf);
 extern void usb_autopm_put_interface_async(struct usb_interface *intf);
-
-static inline void usb_autopm_get_interface_no_resume(
-		struct usb_interface *intf)
-{
-	atomic_inc(&intf->pm_usage_cnt);
-}
-static inline void usb_autopm_put_interface_no_suspend(
-		struct usb_interface *intf)
-{
-	atomic_dec(&intf->pm_usage_cnt);
-}
+extern void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
+extern void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
 static inline void usb_mark_last_busy(struct usb_device *udev)
 {

commit 088f7fec8a0e683db72fd8826c5d3ab914e197b1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 8 12:56:54 2010 -0500

    USB: implement usb_enable_autosuspend
    
    This patch (as1326) adds usb_enable_autosuspend() and
    usb_disable_autosuspend() routines for use by drivers.  If a driver
    knows that its device can handle suspends and resumes correctly, it
    can enable autosuspend all by itself.  This is equivalent to the user
    writing "auto" to the device's power/level attribute.
    
    The implementation differs slightly from what it used to be.  Now
    autosuspend is disabled simply by doing usb_autoresume_device() (to
    increment the usage counter) and enabled by doing
    usb_autosuspend_device() (to decrement the usage counter).
    
    The set_level() attribute method is updated to use the new routines,
    and the USB Power-Management documentation is updated.
    
    The patch adds a usb_enable_autosuspend() call to the hub driver's
    probe routine, allowing the special-case code for hubs in quirks.c to
    be removed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 332eaea61021..e6419ac89ea2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -542,6 +542,9 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
+extern int usb_enable_autosuspend(struct usb_device *udev);
+extern int usb_disable_autosuspend(struct usb_device *udev);
+
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface_async(struct usb_interface *intf);
@@ -565,6 +568,11 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 
 #else
 
+static inline int usb_enable_autosuspend(struct usb_device *udev)
+{ return 0; }
+static inline int usb_disable_autosuspend(struct usb_device *udev)
+{ return 0; }
+
 static inline int usb_autopm_get_interface(struct usb_interface *intf)
 { return 0; }
 static inline int usb_autopm_get_interface_async(struct usb_interface *intf)

commit 6d19c009cc780c63de25a046509ebc9473809fd6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Feb 12 12:21:11 2010 +0100

    USB: implement non-tree resume ordering constraints for PCI host controllers
    
    This patch (as1331) adds non-tree ordering constraints needed for
    proper resume of PCI USB host controllers from hibernation.  The main
    issue is that non-high-speed devices must not be resumed before the
    high-speed root hub, because it is the ehci_bus_resume() routine which
    takes care of handing the device connection over to the companion
    controller.  If the device resume is attempted before the handover
    then the device won't be found and it will be treated as though it had
    disconnected.
    
    The patch adds a new field to the usb_bus structure; for each
    full/low-speed bus this field will contain a pointer to the companion
    high-speed bus (if one exists).  It is used during normal device
    resume; if the hs_companion pointer isn't NULL then we wait for the
    root-hub device on the hs_companion bus.
    
    A secondary issue is that an EHCI controlller shouldn't be resumed
    before any of its companions.  On some machines I have observed
    handovers failing if the companion controller is reinitialized after
    the handover.  Thus, the EHCI resume routine must wait for the
    companion controllers to be resumed.
    
    The patch also fixes a small bug in usb_hcd_pci_probe(); an error path
    jumps to the wrong label, causing a memory leak.
    
    [rjw: Fixed compilation for CONFIG_PM_SLEEP unset.]
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d7ace1b80f09..332eaea61021 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -339,6 +339,7 @@ struct usb_bus {
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
+	struct usb_bus *hs_companion;	/* Companion EHCI bus, if any */
 	struct list_head bus_list;	/* list of busses */
 
 	int bandwidth_allocated;	/* on this bus: how much of the time

commit 04a723ea9c53ba608b0411aa36948bb57c51a08e
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Jan 6 10:16:51 2010 -0800

    USB: Fix duplicate sysfs problem after device reset.
    
    Borislav Petkov reports issues with duplicate sysfs endpoint files after a
    resume from a hibernate.  It turns out that the code to support alternate
    settings under xHCI has issues when a device with a non-default alternate
    setting is reset during the hibernate:
    
    [  427.681810] Restarting tasks ...
    [  427.681995] hub 1-0:1.0: state 7 ports 6 chg 0004 evt 0000
    [  427.682019] usb usb3: usb resume
    [  427.682030] ohci_hcd 0000:00:12.0: wakeup root hub
    [  427.682191] hub 1-0:1.0: port 2, status 0501, change 0000, 480 Mb/s
    [  427.682205] usb 1-2: usb wakeup-resume
    [  427.682226] usb 1-2: finish reset-resume
    [  427.682886] done.
    [  427.734658] ehci_hcd 0000:00:12.2: port 2 high speed
    [  427.734663] ehci_hcd 0000:00:12.2: GetStatus port 2 status 001005 POWER sig=se0 PE CONNECT
    [  427.746682] hub 3-0:1.0: hub_reset_resume
    [  427.746693] hub 3-0:1.0: trying to enable port power on non-switchable hub
    [  427.786715] usb 1-2: reset high speed USB device using ehci_hcd and address 2
    [  427.839653] ehci_hcd 0000:00:12.2: port 2 high speed
    [  427.839666] ehci_hcd 0000:00:12.2: GetStatus port 2 status 001005 POWER sig=se0 PE CONNECT
    [  427.847717] ohci_hcd 0000:00:12.0: GetStatus roothub.portstatus [1] = 0x00010100 CSC PPS
    [  427.915497] hub 1-2:1.0: remove_intf_ep_devs: if: ffff88022f9e8800 ->ep_devs_created: 1
    [  427.915774] hub 1-2:1.0: remove_intf_ep_devs: bNumEndpoints: 1
    [  427.915934] hub 1-2:1.0: if: ffff88022f9e8800: endpoint devs removed.
    [  427.916158] hub 1-2:1.0: create_intf_ep_devs: if: ffff88022f9e8800 ->ep_devs_created: 0, ->unregistering: 0
    [  427.916434] hub 1-2:1.0: create_intf_ep_devs: bNumEndpoints: 1
    [  427.916609]  ep_81: create, parent hub
    [  427.916632] ------------[ cut here ]------------
    [  427.916644] WARNING: at fs/sysfs/dir.c:477 sysfs_add_one+0x82/0x96()
    [  427.916649] Hardware name: System Product Name
    [  427.916653] sysfs: cannot create duplicate filename '/devices/pci0000:00/0000:00:12.2/usb1/1-2/1-2:1.0/ep_81'
    [  427.916658] Modules linked in: binfmt_misc kvm_amd kvm powernow_k8 cpufreq_ondemand cpufreq_powersave cpufreq_userspace freq_table cpufreq_conservative ipv6 vfat fat
    +8250_pnp 8250 pcspkr ohci_hcd serial_core k10temp edac_core
    [  427.916694] Pid: 278, comm: khubd Not tainted 2.6.33-rc2-00187-g08d869a-dirty #13
    [  427.916699] Call Trace:
    
    The problem is caused by a mismatch between the USB core's view of the
    device state and the USB device and xHCI host's view of the device state.
    
    After the device reset and re-configuration, the device and the xHCI host
    think they are using alternate setting 0 of all interfaces.  However, the
    USB core keeps track of the old state, which may include non-zero
    alternate settings.  It uses intf->cur_altsetting to keep the endpoint
    sysfs files for the old state across the reset.
    
    The bandwidth allocation functions need to know what the xHCI host thinks
    the current alternate settings are, so original patch set
    intf->cur_altsetting to the alternate setting 0.  This caused duplicate
    endpoint files to be created.
    
    The solution is to not set intf->cur_altsetting before calling
    usb_set_interface() in usb_reset_and_verify_device().  Instead, we add a
    new flag to struct usb_interface to tell usb_hcd_alloc_bandwidth() to use
    alternate setting 0 as the currently installed alternate setting.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Tested-by: Borislav Petkov <petkovbb@googlemail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e101a2d04d75..d7ace1b80f09 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -192,6 +192,7 @@ struct usb_interface {
 	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */
 	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
 	unsigned reset_running:1;
+	unsigned resetting_device:1;	/* true: bandwidth alloc after reset */
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;

commit 91017f9cf5fcfb601b8d583c896ac7de7d200c57
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Thu Dec 3 09:44:34 2009 -0800

    USB: Refactor code to find alternate interface settings.
    
    Refactor out the code to find alternate interface settings into
    usb_find_alt_setting().  Print a debugging message and return null if the
    alt setting is not found.
    
    While we're at it, correct a bug in the refactored code.  The interfaces
    in the configuration's interface cache are not necessarily in numerical
    order, so we can't just use the interface number as an array index.  Loop
    through the interface caches, looking for the correct interface.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6af3581e1114..e101a2d04d75 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -619,6 +619,10 @@ extern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,
 		unsigned ifnum);
 extern struct usb_host_interface *usb_altnum_to_altsetting(
 		const struct usb_interface *intf, unsigned int altnum);
+extern struct usb_host_interface *usb_find_alt_setting(
+		struct usb_host_config *config,
+		unsigned int iface_num,
+		unsigned int alt_num);
 
 
 /**

commit 8e4ceb38eb5bbaef22fc00abe9bc11e26bea2ab5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Dec 7 13:01:37 2009 -0500

    USB: prepare for changover to Runtime PM framework
    
    This patch (as1303) revises the USB Power Management infrastructure to
    make it compatible with the new driver-model Runtime PM framework:
    
            Drivers are no longer allowed to access intf->pm_usage_cnt
            directly; the PM framework manages its own usage counters.
    
            usb_autopm_set_interface() is eliminated, because it directly
            sets intf->pm_usage_cnt.
    
            usb_autopm_enable() and usb_autopm_disable() are eliminated,
            because they call usb_autopm_set_interface().
    
            usb_autopm_get_interface_no_resume() and
            usb_autopm_put_interface_no_suspend() are added.  They
            correspond to pm_runtime_get_noresume() and
            pm_runtime_put_noidle() in the PM framework.
    
            The power/level attribute no longer accepts "suspend", only
            "on" and "auto".  The PM framework doesn't allow devices to be
            forced into a suspended mode.
    
    The hub driver contains the only code that violates the new
    guidelines.  It is updated to use the new interface routines instead.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4b6f6db544ee..6af3581e1114 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -432,7 +432,6 @@ struct usb_tt;
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
  * @autosuspend_disabled: autosuspend disabled by the user
- * @autoresume_disabled: autoresume disabled by the user
  * @skip_sys_resume: skip the next system resume
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
@@ -516,7 +515,6 @@ struct usb_device {
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
 	unsigned autosuspend_disabled:1;
-	unsigned autoresume_disabled:1;
 	unsigned skip_sys_resume:1;
 #endif
 	struct wusb_dev *wusb_dev;
@@ -542,22 +540,20 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
-extern int usb_autopm_set_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface_async(struct usb_interface *intf);
 extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 
-static inline void usb_autopm_enable(struct usb_interface *intf)
+static inline void usb_autopm_get_interface_no_resume(
+		struct usb_interface *intf)
 {
-	atomic_set(&intf->pm_usage_cnt, 0);
-	usb_autopm_set_interface(intf);
+	atomic_inc(&intf->pm_usage_cnt);
 }
-
-static inline void usb_autopm_disable(struct usb_interface *intf)
+static inline void usb_autopm_put_interface_no_suspend(
+		struct usb_interface *intf)
 {
-	atomic_set(&intf->pm_usage_cnt, 1);
-	usb_autopm_set_interface(intf);
+	atomic_dec(&intf->pm_usage_cnt);
 }
 
 static inline void usb_mark_last_busy(struct usb_device *udev)
@@ -567,12 +563,8 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 
 #else
 
-static inline int usb_autopm_set_interface(struct usb_interface *intf)
-{ return 0; }
-
 static inline int usb_autopm_get_interface(struct usb_interface *intf)
 { return 0; }
-
 static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
 { return 0; }
 
@@ -580,9 +572,11 @@ static inline void usb_autopm_put_interface(struct usb_interface *intf)
 { }
 static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
 { }
-static inline void usb_autopm_enable(struct usb_interface *intf)
+static inline void usb_autopm_get_interface_no_resume(
+		struct usb_interface *intf)
 { }
-static inline void usb_autopm_disable(struct usb_interface *intf)
+static inline void usb_autopm_put_interface_no_suspend(
+		struct usb_interface *intf)
 { }
 static inline void usb_mark_last_busy(struct usb_device *udev)
 { }

commit fb34d53752d5bec5acc73422e462a9c68aeeaa2a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Nov 13 11:53:59 2009 -0500

    USB: remove the auto_pm flag
    
    This patch (as1302) removes the auto_pm flag from struct usb_device.
    The flag's only purpose was to distinguish between autosuspends and
    external suspends, but that information is now available in the
    pm_message_t argument passed to suspend methods.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6e91ee4f5b81..4b6f6db544ee 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -429,7 +429,6 @@ struct usb_tt;
  * @last_busy: time of last use
  * @autosuspend_delay: in jiffies
  * @connect_time: time device was first connected
- * @auto_pm: autosuspend/resume in progress
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
  * @autosuspend_disabled: autosuspend disabled by the user
@@ -514,7 +513,6 @@ struct usb_device {
 	int autosuspend_delay;
 	unsigned long connect_time;
 
-	unsigned auto_pm:1;
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
 	unsigned autosuspend_disabled:1;

commit 4c1bd3d7a7d114dabd58f62f386ac4bfd268be1f
Author: David Vrabel <david.vrabel@csr.com>
Date:   Mon Aug 24 14:44:30 2009 +0100

    USB: make urb scatter-gather support more generic
    
    The WHCI HCD will also support urbs with scatter-gather lists.  Add a
    usb_bus field to indicated how many sg list elements are supported by
    the HCD.  Use this to decide whether to pass the scatter-list to the HCD
    or not.
    
    Make the usb-storage driver use this new field.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a34fa89f1474..6e91ee4f5b81 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -331,6 +331,7 @@ struct usb_bus {
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
+	unsigned sg_tablesize;		/* 0 or largest number of sg list entries */
 
 	int devnum_next;		/* Next open device number in
 					 * round-robin allocation */

commit ccf5b801cef4f9e2d708d3b87e91e2bc6abd5206
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 11:00:01 2009 -0400

    USB: make intf.pm_usage an atomic_t
    
    This patch (as1260) changes the pm_usage_cnt field in struct
    usb_interface from an int to an atomic_t.  This is so that drivers can
    invoke the usb_autopm_get_interface_async() and
    usb_autopm_put_interface_async() routines without locking and without
    fear of corrupting the pm_usage_cnt value.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3b45a0d27b80..a34fa89f1474 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -195,7 +195,7 @@ struct usb_interface {
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
-	int pm_usage_cnt;		/* usage counter for autosuspend */
+	atomic_t pm_usage_cnt;		/* usage counter for autosuspend */
 	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
@@ -551,13 +551,13 @@ extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 
 static inline void usb_autopm_enable(struct usb_interface *intf)
 {
-	intf->pm_usage_cnt = 0;
+	atomic_set(&intf->pm_usage_cnt, 0);
 	usb_autopm_set_interface(intf);
 }
 
 static inline void usb_autopm_disable(struct usb_interface *intf)
 {
-	intf->pm_usage_cnt = 1;
+	atomic_set(&intf->pm_usage_cnt, 1);
 	usb_autopm_set_interface(intf);
 }
 

commit 4e9e92003529e5c7bb11281f7c2c9b3fe8858403
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Thu Jun 11 08:53:20 2009 -0600

    USB: usbmon: end ugly tricks with DMA peeking
    
    This patch fixes crashes when usbmon attempts to access GART aperture.
    The old code attempted to take a bus address and convert it into a
    virtual address, which clearly was impossible on systems with actual
    IOMMUs. Let us not persist in this foolishness, and use transfer_buffer
    in all cases instead.
    
    I think downsides are negligible. The ones I see are:
     - A driver may pass an address of one buffer down as transfer_buffer,
       and entirely different entity mapped for DMA, resulting in misleading
       output of usbmon. Note, however, that PIO based controllers would
       do transfer the same data that usbmon sees here.
     - Out of tree drivers may crash usbmon if they store garbage in
       transfer_buffer. I inspected the in-tree drivers, and clarified
       the documentation in comments.
     - Drivers that use get_user_pages will not be possible to monitor.
       I only found one driver with this problem (drivers/staging/rspiusb).
     - Same happens with with usb_storage transferring from highmem, but
       it works fine on 64-bit systems, so I think it's not a concern.
       At least we don't crash anymore.
    
    Why didn't we do this in 2.6.10? That's because back in those days
    it was popular not to fill in transfer_buffer, so almost all
    traffic would be invisible (e.g. all of HID was like that).
    But now, the tree is almost 100% PIO friendly, so we can do the
    right thing at last.
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 19fabc487beb..3b45a0d27b80 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1036,9 +1036,10 @@ typedef void (*usb_complete_t)(struct urb *);
  * @transfer_flags: A variety of flags may be used to affect how URB
  *	submission, unlinking, or operation are handled.  Different
  *	kinds of URB can use different flags.
- * @transfer_buffer:  This identifies the buffer to (or from) which
- * 	the I/O request will be performed (unless URB_NO_TRANSFER_DMA_MAP
- *	is set).  This buffer must be suitable for DMA; allocate it with
+ * @transfer_buffer:  This identifies the buffer to (or from) which the I/O
+ *	request will be performed unless URB_NO_TRANSFER_DMA_MAP is set
+ *	(however, do not leave garbage in transfer_buffer even then).
+ *	This buffer must be suitable for DMA; allocate it with
  *	kmalloc() or equivalent.  For transfers to "in" endpoints, contents
  *	of this buffer will be modified.  This buffer is used for the data
  *	stage of control transfers.
@@ -1104,9 +1105,15 @@ typedef void (*usb_complete_t)(struct urb *);
  * allocate a DMA buffer with usb_buffer_alloc() or call usb_buffer_map().
  * When these transfer flags are provided, host controller drivers will
  * attempt to use the dma addresses found in the transfer_dma and/or
- * setup_dma fields rather than determining a dma address themselves.  (Note
- * that transfer_buffer and setup_packet must still be set because not all
- * host controllers use DMA, nor do virtual root hubs).
+ * setup_dma fields rather than determining a dma address themselves.
+ *
+ * Note that transfer_buffer must still be set if the controller
+ * does not support DMA (as indicated by bus.uses_dma) and when talking
+ * to root hub. If you have to trasfer between highmem zone and the device
+ * on such controller, create a bounce buffer or bail out with an error.
+ * If transfer_buffer cannot be set (is in highmem) and the controller is DMA
+ * capable, assign NULL to it, so that usbmon knows not to use the value.
+ * The setup_packet must always be set, so it cannot be located in highmem.
  *
  * Initialization:
  *

commit 411c94038594b2a3fd123d09bdec3fe2500e383d
Author: Anand Gadiyar <gadiyar@ti.com>
Date:   Tue Jul 7 15:24:23 2009 +0530

    trivial: fix typo "for for" in multiple files
    
    trivial: fix typo "for for" in multiple files
    
    Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a8fe05f224e5..19fabc487beb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1071,7 +1071,7 @@ typedef void (*usb_complete_t)(struct urb *);
  * @start_frame: Returns the initial frame for isochronous transfers.
  * @number_of_packets: Lists the number of ISO transfer buffers.
  * @interval: Specifies the polling interval for interrupt or isochronous
- *	transfers.  The units are frames (milliseconds) for for full and low
+ *	transfers.  The units are frames (milliseconds) for full and low
  *	speed devices, and microframes (1/8 millisecond) for highspeed ones.
  * @error_count: Returns the number of ISO transfers that reported errors.
  * @context: For use in completion functions.  This normally points to

commit e454cea20bdcff10ee698d11b8882662a0153a47
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Sep 18 23:01:12 2009 +0200

    Driver-Core: extend devnode callbacks to provide permissions
    
    This allows subsytems to provide devtmpfs with non-default permissions
    for the device node. Instead of the default mode of 0600, null, zero,
    random, urandom, full, tty, ptmx now have a mode of 0666, which allows
    non-privileged processes to access standard device nodes in case no
    other userspace process applies the expected permissions.
    
    This also fixes a wrong assignment in pktcdvd and a checkpatch.pl complain.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b1e3c2fbfe11..a8fe05f224e5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -922,7 +922,7 @@ extern struct bus_type usb_bus_type;
 /**
  * struct usb_class_driver - identifies a USB driver that wants to use the USB major number
  * @name: the usb class device name for this driver.  Will show up in sysfs.
- * @nodename: Callback to provide a naming hint for a possible
+ * @devnode: Callback to provide a naming hint for a possible
  *	device node to create.
  * @fops: pointer to the struct file_operations of this driver.
  * @minor_base: the start of the minor range for this driver.
@@ -933,7 +933,7 @@ extern struct bus_type usb_bus_type;
  */
 struct usb_class_driver {
 	char *name;
-	char *(*nodename)(struct device *dev);
+	char *(*devnode)(struct device *dev, mode_t *mode);
 	const struct file_operations *fops;
 	int minor_base;
 };

commit e376bbbb6a82cf119c93bde66937f66c72cba27b
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Jun 18 10:39:11 2009 -0700

    USB: usb.h: fix kernel-doc notation
    
    Fix usb.h kernel-doc warnings:
    
    Warning(include/linux/usb.h:918): Excess struct/union/enum/typedef member 'nodename' description in 'usb_device_driver'
    Warning(include/linux/usb.h:939): No description found for parameter 'nodename'
    Warning(include/linux/usb.h:1219): No description found for parameter 'sg'
    Warning(include/linux/usb.h:1219): No description found for parameter 'num_sgs'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 84929e914034..b1e3c2fbfe11 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -888,8 +888,6 @@ struct usb_driver {
  * struct usb_device_driver - identifies USB device driver to usbcore
  * @name: The driver name should be unique among USB drivers,
  *	and should normally be the same as the module name.
- * @nodename: Callback to provide a naming hint for a possible
- *	device node to create.
  * @probe: Called to see if the driver is willing to manage a particular
  *	device.  If it is, probe returns zero and uses dev_set_drvdata()
  *	to associate driver-specific data with the device.  If unwilling
@@ -924,6 +922,8 @@ extern struct bus_type usb_bus_type;
 /**
  * struct usb_class_driver - identifies a USB driver that wants to use the USB major number
  * @name: the usb class device name for this driver.  Will show up in sysfs.
+ * @nodename: Callback to provide a naming hint for a possible
+ *	device node to create.
  * @fops: pointer to the struct file_operations of this driver.
  * @minor_base: the start of the minor range for this driver.
  *
@@ -1046,6 +1046,8 @@ typedef void (*usb_complete_t)(struct urb *);
  *	the device driver is saying that it provided this DMA address,
  *	which the host controller driver should use in preference to the
  *	transfer_buffer.
+ * @sg: scatter gather buffer list
+ * @num_sgs: number of entries in the sg list
  * @transfer_buffer_length: How big is transfer_buffer.  The transfer may
  *	be broken up into chunks according to the current maximum packet
  *	size for the endpoint, which is a function of the configuration

commit e1f5b94fd0c93c3e27ede88b7ab652d086dc960f
Merge: 6fd03301d76b 1b6ed69f974f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 16 13:06:10 2009 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb-2.6: (143 commits)
      USB: xhci depends on PCI.
      USB: xhci: Add Makefile, MAINTAINERS, and Kconfig entries.
      USB: xhci: Respect critical sections.
      USB: xHCI: Fix interrupt moderation.
      USB: xhci: Remove packed attribute from structures.
      usb; xhci: Fix TRB offset calculations.
      USB: xhci: replace if-elseif-else with switch-case
      USB: xhci: Make xhci-mem.c include linux/dmapool.h
      USB: xhci: drop spinlock in xhci_urb_enqueue() error path.
      USB: Change names of SuperSpeed ep companion descriptor structs.
      USB: xhci: Avoid compiler reordering in Link TRB giveback.
      USB: xhci: Clean up xhci_irq() function.
      USB: xhci: Avoid global namespace pollution.
      USB: xhci: Fix Link TRB handoff bit twiddling.
      USB: xhci: Fix register write order.
      USB: xhci: fix some compiler warnings in xhci.h
      USB: xhci: fix lots of compiler warnings.
      USB: xhci: use xhci_handle_event instead of handle_event
      USB: xhci: URB cancellation support.
      USB: xhci: Scatter gather list support for bulk transfers.
      ...

commit f0058c627855ecb3b6c7185b7ad1910463c24c42
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Apr 29 19:06:20 2009 -0700

    USB: Change names of SuperSpeed ep companion descriptor structs.
    
    Differentiate between SuperSpeed endpoint companion descriptor and the
    wireless USB endpoint companion descriptor.  Make all structure names for
    this descriptor have "ss" (SuperSpeed) in them.  David Vrabel asked for
    this change in http://marc.info/?l=linux-usb&m=124091465109367&w=2
    
    Reported-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0a1819a64974..7e6b5259ea35 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -47,15 +47,15 @@ struct ep_device;
 
 /* For SS devices */
 /**
- * struct usb_host_ep_comp - Valid for SuperSpeed devices only
+ * struct usb_host_ss_ep_comp - Valid for SuperSpeed devices only
  * @desc: endpoint companion descriptor, wMaxPacketSize in native byteorder
  * @extra: descriptors following this endpoint companion descriptor
  * @extralen: how many bytes of "extra" are valid
  */
-struct usb_host_ep_comp {
-	struct usb_ep_comp_descriptor	desc;
-	unsigned char			*extra;   /* Extra descriptors */
-	int				extralen;
+struct usb_host_ss_ep_comp {
+	struct usb_ss_ep_comp_descriptor	desc;
+	unsigned char				*extra;   /* Extra descriptors */
+	int					extralen;
 };
 
 /**
@@ -65,7 +65,7 @@ struct usb_host_ep_comp {
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
  * @ep_dev: ep_device for sysfs info
- * @ep_comp: companion descriptor information for this endpoint
+ * @ss_ep_comp: companion descriptor information for this endpoint
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
@@ -78,7 +78,7 @@ struct usb_host_endpoint {
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device 		*ep_dev;	/* For sysfs info */
-	struct usb_host_ep_comp		*ep_comp;	/* For SS devices */
+	struct usb_host_ss_ep_comp	*ss_ep_comp;	/* For SS devices */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;

commit e04748e3a87271fcf30d383e3780c5d3ee1c1618
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:59:01 2009 -0700

    USB: Push scatter gather lists down to host controller drivers.
    
    This is the original patch I created before David Vrabel posted a better
    patch (http://marc.info/?l=linux-usb&m=123377477209109&w=2) that does
    basically the same thing.  This patch will get replaced with his
    (modified) patch later.
    
    Allow USB device drivers that use usb_sg_init() and usb_sg_wait() to push
    bulk endpoint scatter gather lists down to the host controller drivers.
    This allows host controller drivers to more efficiently enqueue these
    transfers, and allows the xHCI host controller to better take advantage of
    USB 3.0 "bursts" for bulk endpoints.
    
    This patch currently only enables scatter gather lists for bulk endpoints.
    Other endpoint types that use the usb_sg_* functions will not have their
    scatter gather lists pushed down to the host controller.  For periodic
    endpoints, we want each scatterlist entry to be a separate transfer.
    Eventually, HCDs could parse these scatter-gather lists for periodic
    endpoints also.  For now, we use the old code and call usb_submit_urb()
    for each scatterlist entry.
    
    The caller of usb_sg_init() can request that all bytes in the scatter
    gather list be transferred by passing in a length of zero.  Handle that
    request for a bulk endpoint under xHCI by walking the scatter gather list
    and calculating the length.  We could let the HCD handle a zero length in
    this case, but I'm not sure if the core layers in between will get
    confused by this.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 13bced521b83..0a1819a64974 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1198,6 +1198,8 @@ struct urb {
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/
 	void *transfer_buffer;		/* (in) associated data buffer */
 	dma_addr_t transfer_dma;	/* (in) dma addr for transfer_buffer */
+	struct usb_sg_request *sg;	/* (in) scatter gather buffer list */
+	int num_sgs;			/* (in) number of entries in the sg list */
 	u32 transfer_buffer_length;	/* (in) data buffer length */
 	u32 actual_length;		/* (return) actual transfer length */
 	unsigned char *setup_packet;	/* (in) setup packet (control only) */

commit 663c30d0829d556efabd5fbd98fb8473da7fe694
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:14 2009 -0700

    USB: Parse and store the SuperSpeed endpoint companion descriptors.
    
    The USB 3.0 bus specification added an "Endpoint Companion" descriptor that is
    supposed to follow all SuperSpeed Endpoint descriptors.  This descriptor is used
    to extend the bus protocol to allow more packets to be sent to an endpoint per
    "microframe".  The word microframe was removed from the USB 3.0 specification
    because the host controller does not send Start Of Frame (SOF) symbols down the
    USB 3.0 wires.
    
    The descriptor defines a bMaxBurst field, which indicates the number of packets
    of wMaxPacketSize that a SuperSpeed device can send or recieve in a service
    interval.  All non-control endpoints may set this value as high as 16 packets
    (bMaxBurst = 15).
    
    The descriptor also allows isochronous endpoints to further specify that they
    can send and receive multiple bursts per service interval.  The bmAttributes
    allows them to specify a "Mult" of up to 3 (bmAttributes = 2).
    
    Bulk endpoints use bmAttributes to report the number of "Streams" they support.
    This was an extension of the endpoint pipe concept to allow multiple mass
    storage device commands to be outstanding for one bulk endpoint at a time.  This
    should allow USB 3.0 mass storage devices to support SCSI command queueing.
    Bulk endpoints can say they support up to 2^16 (65,536) streams.
    
    The information in the endpoint companion descriptor must be stored with the
    other device, config, interface, and endpoint descriptors because the host
    controller needs to access them quickly, and we need to install some default
    values if a SuperSpeed device doesn't provide an endpoint companion descriptor.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 112a2d6e922f..13bced521b83 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -36,6 +36,7 @@ struct wusb_dev;
  *  - configs have one (often) or more interfaces;
  *  - interfaces have one (usually) or more settings;
  *  - each interface setting has zero or (usually) more endpoints.
+ *  - a SuperSpeed endpoint has a companion descriptor
  *
  * And there might be other descriptors mixed in with those.
  *
@@ -44,6 +45,19 @@ struct wusb_dev;
 
 struct ep_device;
 
+/* For SS devices */
+/**
+ * struct usb_host_ep_comp - Valid for SuperSpeed devices only
+ * @desc: endpoint companion descriptor, wMaxPacketSize in native byteorder
+ * @extra: descriptors following this endpoint companion descriptor
+ * @extralen: how many bytes of "extra" are valid
+ */
+struct usb_host_ep_comp {
+	struct usb_ep_comp_descriptor	desc;
+	unsigned char			*extra;   /* Extra descriptors */
+	int				extralen;
+};
+
 /**
  * struct usb_host_endpoint - host-side endpoint descriptor and queue
  * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
@@ -51,6 +65,7 @@ struct ep_device;
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
  * @ep_dev: ep_device for sysfs info
+ * @ep_comp: companion descriptor information for this endpoint
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
@@ -63,6 +78,7 @@ struct usb_host_endpoint {
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device 		*ep_dev;	/* For sysfs info */
+	struct usb_host_ep_comp		*ep_comp;	/* For SS devices */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;

commit 6d65b78a093552fb42448480d4c66bf093a6d4cf
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:57:50 2009 -0700

    USB: Support for submitting control URBs under xHCI.
    
    Warn users of URB_NO_SETUP_DMA_MAP about xHCI behavior.
    
    Device drivers can choose to DMA map the setup packet of a control transfer
    before submitting the URB to the USB core.  Drivers then set the
    URB_NO_SETUP_DMA_MAP and pass in the DMA memory address in setup_dma, instead of
    providing a kernel address for setup_packet.  However, xHCI requires that the
    setup packet be copied into an internal data structure, and we need a kernel
    memory address pointer for that.  Warn users of URB_NO_SETUP_DMA_MAP that they
    should provide a valid pointer for setup_packet, along with the DMA address.
    
    FIXME:  I'm not entirely sure how to work around this in the xHCI driver
    or USB core.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 475cb75cc378..112a2d6e922f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1044,7 +1044,9 @@ typedef void (*usb_complete_t)(struct urb *);
  * @setup_dma: For control transfers with URB_NO_SETUP_DMA_MAP set, the
  *	device driver has provided this DMA address for the setup packet.
  *	The host controller driver should use this in preference to
- *	setup_packet.
+ *	setup_packet, but the HCD may chose to ignore the address if it must
+ *	copy the setup packet into internal structures.  Therefore, setup_packet
+ *	must always point to a valid buffer.
  * @start_frame: Returns the initial frame for isochronous transfers.
  * @number_of_packets: Lists the number of ISO transfer buffers.
  * @interval: Specifies the polling interval for interrupt or isochronous

commit c6515272b858742962c1de0f3bf497a048b9abd7
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:57:26 2009 -0700

    USB: Support for addressing a USB device under xHCI
    
    Add host controller driver API and a slot_id variable to struct
    usb_device.  This allows the xHCI host controller driver to ask the
    hardware to allocate a slot for the device when a struct usb_device is
    allocated.  The slot needs to be allocated at that point because the
    hardware can run out of internal resources, and we want to know that very
    early in the device connection process.  Don't call this new API for root
    hubs, since they aren't real devices.
    
    Add HCD API to let the host controller choose the device address.  This is
    especially important for xHCI hardware running in a virtualized
    environment.  The guests running under the VM don't need to know which
    addresses on the bus are taken, because the hardware picks the address for
    them.  Announce SuperSpeed USB devices after the address has been assigned
    by the hardware.
    
    Don't use the new get descriptor/set address scheme with xHCI.  Unless
    special handling is done in the host controller driver, the xHC can't
    issue control transfers before you set the device address.  Support for
    the older addressing scheme will be added when the xHCI driver supports
    the Block Set Address Request (BSR) flag in the Address Device command.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2b380a16c62f..475cb75cc378 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -420,6 +420,7 @@ struct usb_tt;
  * @skip_sys_resume: skip the next system resume
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
+ * @slot_id: Slot ID assigned by xHCI
  *
  * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use
@@ -504,6 +505,7 @@ struct usb_device {
 	unsigned skip_sys_resume:1;
 #endif
 	struct wusb_dev *wusb_dev;
+	int slot_id;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit 7206b00164a1c3ca533e01db285955617e1019f8
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:54:49 2009 -0700

    USB: Add route string to struct usb_device.
    
    This patch adds a hex route string to each USB device.  The route string is used
    by the USB 3.0 host controller to send packets through the device tree.  USB 3.0
    hubs use this string to route packets to the correct port.  This is fundamental
    bus change from USB 2.0, where all packets were broadcast across the bus.
    
    Devices (including hubs) under a root port receive the route string 0x0.  Every
    four bits in the route string represent a port on a hub.  This length works
    because USB 3.0 hubs are limited to 15 ports, and USB 2.0 hubs (with potentially
    more ports) will never see packets with a route string.  A port number of 0
    means the packet is destined for that hub.
    
    For example, a peripheral device might have a route string of 0x00097.
    This means the device is connected to port 9 of the hub at depth 1.
    The hub at depth 1 is connected to port 7 of a hub at depth 0.
    The hub at depth 0 is connected to a root port.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index fb1f2a32ae05..2b380a16c62f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,6 +362,7 @@ struct usb_tt;
  * struct usb_device - kernel's representation of a USB device
  * @devnum: device number; address on a USB bus
  * @devpath: device ID string for use in messages (e.g., /port/...)
+ * @route: tree topology hex string for use with xHCI
  * @state: device state: configured, not attached, etc.
  * @speed: device speed: high/full/low (or error)
  * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub
@@ -427,6 +428,7 @@ struct usb_tt;
 struct usb_device {
 	int		devnum;
 	char		devpath [16];
+	u32		route;
 	enum usb_device_state	state;
 	enum usb_device_speed	speed;
 

commit bf92c1906e4f294a48fafc15755c65af636195e0
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Apr 29 21:02:49 2009 -0700

    USB: usb.h: change private: kernel-doc for new format requirement
    
    Use "/* private:" to mark struct members as private so that
    scripts/kernel-doc will handle them correctly.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 606e0aa5bbe6..fb1f2a32ae05 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1421,8 +1421,8 @@ struct usb_sg_request {
 	int			status;
 	size_t			bytes;
 
-	/*
-	 * members below are private: to usbcore,
+	/* private:
+	 * members below are private to usbcore,
 	 * and are not provided for driver access!
 	 */
 	spinlock_t		lock;

commit 820d7a253c5e59a786d5b608f6e8d0419fdc2f6e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 13:17:21 2009 -0700

    USB: remove unused usb_host class
    
    The usb_host class isn't used for anything anymore (it was used for
    debug files, but they have moved to debugfs a few kernel releases ago),
    so let's delete it before someone accidentally puts a file in it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 29060dad81e6..606e0aa5bbe6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -336,7 +336,6 @@ struct usb_bus {
 #ifdef CONFIG_USB_DEVICEFS
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 #endif
-	struct device *dev;		/* device for this bus */
 
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */

commit 00048b8bde5a6cbd9c3a76f272cc9ddb55705e37
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 24 14:56:26 2009 -0700

    USB: add usb debugfs directory
    
    Add a common usb directory in debugfs that the usb subsystem can use.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3aa2cd1f8d08..29060dad81e6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1558,6 +1558,9 @@ extern void usb_unregister_notify(struct notifier_block *nb);
 #define err(format, arg...) printk(KERN_ERR KBUILD_MODNAME ": " \
 	format "\n" , ## arg)
 
+/* debugfs stuff */
+extern struct dentry *usb_debug_root;
+
 #endif  /* __KERNEL__ */
 
 #endif

commit f7a386c5b8ff34cd84ae922603d1c6f9d234edee
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: usb: add nodename support for usb drivers.
    
    This adds support for USB drivers to report their requested nodename to
    userspace.  It also updates a number of USB drivers to provide the
    needed subdirectory and device name to be used for them.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3aa2cd1f8d08..34cdfcac4555 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -869,6 +869,8 @@ struct usb_driver {
  * struct usb_device_driver - identifies USB device driver to usbcore
  * @name: The driver name should be unique among USB drivers,
  *	and should normally be the same as the module name.
+ * @nodename: Callback to provide a naming hint for a possible
+ *	device node to create.
  * @probe: Called to see if the driver is willing to manage a particular
  *	device.  If it is, probe returns zero and uses dev_set_drvdata()
  *	to associate driver-specific data with the device.  If unwilling
@@ -912,6 +914,7 @@ extern struct bus_type usb_bus_type;
  */
 struct usb_class_driver {
 	char *name;
+	char *(*nodename)(struct device *dev);
 	const struct file_operations *fops;
 	int minor_base;
 };

commit 3444b26afa145148951112534f298bdc554ec789
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Apr 8 17:36:28 2009 +0000

    USB: add reset endpoint operations
    
    Wireless USB endpoint state has a sequence number and a current
    window and not just a single toggle bit.  So allow HCDs to provide a
    endpoint_reset method and call this or clear the software toggles as
    required (after a clear halt, set configuration etc.).
    
    usb_settoggle() and friends are then HCD internal and are moved into
    core/hcd.h and all device drivers call usb_reset_endpoint() instead.
    
    If the device endpoint state has been reset (with a clear halt) but
    the host endpoint state has not then subsequent data transfers will
    not complete. The device will only work again after it is reset or
    disconnected.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c6b2ab41b908..3aa2cd1f8d08 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1387,6 +1387,7 @@ extern int usb_string(struct usb_device *dev, int index,
 extern int usb_clear_halt(struct usb_device *dev, int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
+extern void usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr);
 
 /* this request isn't really synchronous, but it belongs with the others */
 extern int usb_driver_set_configuration(struct usb_device *udev, int config);
@@ -1491,14 +1492,6 @@ void usb_sg_wait(struct usb_sg_request *io);
 #define usb_pipecontrol(pipe)	(usb_pipetype((pipe)) == PIPE_CONTROL)
 #define usb_pipebulk(pipe)	(usb_pipetype((pipe)) == PIPE_BULK)
 
-/* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
-#define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
-#define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
-#define usb_settoggle(dev, ep, out, bit) \
-		((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | \
-		 ((bit) << (ep)))
-
-
 static inline unsigned int __create_pipe(struct usb_device *dev,
 		unsigned int endpoint)
 {

commit 8c209e6782ca0e3046803fc04a5ac01c8c10437a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Mar 6 21:31:03 2009 -0800

    USB: make actual_length in struct urb field u32
    
    actual_length should also be a u32 and not a signed value.  This patch
    changes this field to be 'u32' to prevent any potential negative
    conversion and comparison errors.
    
    This triggered a few compiler warning messages when these fields were
    being used with the min macro, so they have also been fixed up in this
    patch.
    
    Cc: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index db8808e05a2a..c6b2ab41b908 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1178,7 +1178,7 @@ struct urb {
 	void *transfer_buffer;		/* (in) associated data buffer */
 	dma_addr_t transfer_dma;	/* (in) dma addr for transfer_buffer */
 	u32 transfer_buffer_length;	/* (in) data buffer length */
-	int actual_length;		/* (return) actual transfer length */
+	u32 actual_length;		/* (return) actual transfer length */
 	unsigned char *setup_packet;	/* (in) setup packet (control only) */
 	dma_addr_t setup_dma;		/* (in) dma addr for setup_packet */
 	int start_frame;		/* (modify) start frame (ISO) */

commit 16e2e5f634f86ccda18366967c4e592eb61bc9cc
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Mar 3 16:44:13 2009 -0800

    USB: make transfer_buffer_lengths in struct urb field u32
    
    Roel Kluin pointed out that transfer_buffer_lengths in struct urb was
    declared as an 'int'.  This patch changes this field to be 'u32' to
    prevent any potential negative conversion and comparison errors.
    
    This triggered a few compiler warning messages when these fields were
    being used with the min macro, so they have also been fixed up in this
    patch.
    
    Cc: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0c05ff621192..db8808e05a2a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1177,7 +1177,7 @@ struct urb {
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/
 	void *transfer_buffer;		/* (in) associated data buffer */
 	dma_addr_t transfer_dma;	/* (in) dma addr for transfer_buffer */
-	int transfer_buffer_length;	/* (in) data buffer length */
+	u32 transfer_buffer_length;	/* (in) data buffer length */
 	int actual_length;		/* (return) actual transfer length */
 	unsigned char *setup_packet;	/* (in) setup packet (control only) */
 	dma_addr_t setup_dma;		/* (in) dma addr for setup_packet */

commit 4d6914b72966862f37de634299a80ca2a4b1829f
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Dec 29 22:48:19 2008 +0100

    USB: Move definitions from usb.h to usb/ch9.h
    
    The functions:
    
    usb_endpoint_dir_in(epd)
    usb_endpoint_dir_out(epd)
    usb_endpoint_is_bulk_in(epd)
    usb_endpoint_is_bulk_out(epd)
    usb_endpoint_is_int_in(epd)
    usb_endpoint_is_int_out(epd)
    usb_endpoint_is_isoc_in(epd)
    usb_endpoint_is_isoc_out(epd)
    usb_endpoint_num(epd)
    usb_endpoint_type(epd)
    usb_endpoint_xfer_bulk(epd)
    usb_endpoint_xfer_control(epd)
    usb_endpoint_xfer_int(epd)
    usb_endpoint_xfer_isoc(epd)
    
    are moved from include/linux/usb.h to include/linux/usb/ch9.h.
    include/linux/usb/ch9.h makes more sense for these functions because they
    only depend on constants that are defined in this file.
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 88079fd60235..0c05ff621192 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -643,186 +643,6 @@ static inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)
 
 /*-------------------------------------------------------------------------*/
 
-/**
- * usb_endpoint_num - get the endpoint's number
- * @epd: endpoint to be checked
- *
- * Returns @epd's number: 0 to 15.
- */
-static inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
-{
-	return epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
-}
-
-/**
- * usb_endpoint_type - get the endpoint's transfer type
- * @epd: endpoint to be checked
- *
- * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
- * to @epd's transfer type.
- */
-static inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)
-{
-	return epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
-}
-
-/**
- * usb_endpoint_dir_in - check if the endpoint has IN direction
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint is of type IN, otherwise it returns false.
- */
-static inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
-{
-	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);
-}
-
-/**
- * usb_endpoint_dir_out - check if the endpoint has OUT direction
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint is of type OUT, otherwise it returns false.
- */
-static inline int usb_endpoint_dir_out(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
-}
-
-/**
- * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint is of type bulk, otherwise it returns false.
- */
-static inline int usb_endpoint_xfer_bulk(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		USB_ENDPOINT_XFER_BULK);
-}
-
-/**
- * usb_endpoint_xfer_control - check if the endpoint has control transfer type
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint is of type control, otherwise it returns false.
- */
-static inline int usb_endpoint_xfer_control(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		USB_ENDPOINT_XFER_CONTROL);
-}
-
-/**
- * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint is of type interrupt, otherwise it returns
- * false.
- */
-static inline int usb_endpoint_xfer_int(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		USB_ENDPOINT_XFER_INT);
-}
-
-/**
- * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint is of type isochronous, otherwise it returns
- * false.
- */
-static inline int usb_endpoint_xfer_isoc(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
-		USB_ENDPOINT_XFER_ISOC);
-}
-
-/**
- * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint has bulk transfer type and IN direction,
- * otherwise it returns false.
- */
-static inline int usb_endpoint_is_bulk_in(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd));
-}
-
-/**
- * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint has bulk transfer type and OUT direction,
- * otherwise it returns false.
- */
-static inline int usb_endpoint_is_bulk_out(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd));
-}
-
-/**
- * usb_endpoint_is_int_in - check if the endpoint is interrupt IN
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint has interrupt transfer type and IN direction,
- * otherwise it returns false.
- */
-static inline int usb_endpoint_is_int_in(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd));
-}
-
-/**
- * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint has interrupt transfer type and OUT direction,
- * otherwise it returns false.
- */
-static inline int usb_endpoint_is_int_out(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd));
-}
-
-/**
- * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint has isochronous transfer type and IN direction,
- * otherwise it returns false.
- */
-static inline int usb_endpoint_is_isoc_in(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd));
-}
-
-/**
- * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT
- * @epd: endpoint to be checked
- *
- * Returns true if the endpoint has isochronous transfer type and OUT direction,
- * otherwise it returns false.
- */
-static inline int usb_endpoint_is_isoc_out(
-				const struct usb_endpoint_descriptor *epd)
-{
-	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd));
-}
-
-/*-------------------------------------------------------------------------*/
-
 #define USB_DEVICE_ID_MATCH_DEVICE \
 		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
 #define USB_DEVICE_ID_MATCH_DEV_RANGE \

commit 11e76ae0f3a82bbb6c06df8af2167af8b96a0584
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Thu Jan 8 12:52:19 2009 -0800

    USB: add kernel-doc for wusb_dev in struct usb_device
    
    Reported by Randy Dunlap from a warning on the v2.6.29 merge window.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 85ee9be9361e..88079fd60235 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -418,6 +418,8 @@ struct usb_tt;
  * @autosuspend_disabled: autosuspend disabled by the user
  * @autoresume_disabled: autoresume disabled by the user
  * @skip_sys_resume: skip the next system resume
+ * @wusb_dev: if this is a Wireless USB device, link to the WUSB
+ *	specific data for the device.
  *
  * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use

commit 34c65d82e02147331701c7795e3144d511adf4e9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb.h
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    No one in the tree is using the macro, so it can now be removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 28f68f587793..85ee9be9361e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1742,8 +1742,6 @@ extern void usb_unregister_notify(struct notifier_block *nb);
 
 #define err(format, arg...) printk(KERN_ERR KBUILD_MODNAME ": " \
 	format "\n" , ## arg)
-#define info(format, arg...) printk(KERN_INFO KBUILD_MODNAME ": " \
-	format "\n" , ## arg)
 
 #endif  /* __KERNEL__ */
 

commit 338b67b0c1a97ca705023a8189cf41aa0828d294
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 14 09:37:34 2008 -0700

    USB: remove warn() macro from usb.h
    
    USB should not be having it's own printk macros, so remove warn() and
    use the system-wide standard of dev_warn() wherever possible.  In the
    few places that will not work out, use a basic printk().
    
    Now that all in-tree users are gone, remove the macro.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e89639896508..28f68f587793 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1744,8 +1744,6 @@ extern void usb_unregister_notify(struct notifier_block *nb);
 	format "\n" , ## arg)
 #define info(format, arg...) printk(KERN_INFO KBUILD_MODNAME ": " \
 	format "\n" , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING KBUILD_MODNAME ": " \
-	format "\n" , ## arg)
 
 #endif  /* __KERNEL__ */
 

commit 856395d6e137b4e7194972cb7765f3de6a72ba61
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Dec 18 09:17:49 2008 +0100

    USB: extension of anchor API to unpoison an anchor
    
    This extension allows unpoisoning an anchor allowing drivers that
    resubmit URBs to reuse an anchor for methods like resume()
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4e8654a18250..e89639896508 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1485,6 +1485,7 @@ extern void usb_poison_urb(struct urb *urb);
 extern void usb_unpoison_urb(struct urb *urb);
 extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_poison_anchored_urbs(struct usb_anchor *anchor);
+extern void usb_unpoison_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);
 extern void usb_unanchor_urb(struct urb *urb);

commit 49367d8f1d9f26482cf7089489e90f0afd0a942c
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Dec 12 21:38:45 2008 +0800

    USB: mark "reject" field of struct urb as atomic_t
    
    It is enough to protect accesses to reject field of urb
    by marking it as atomic_t,also it is the only reason of
    existence of usb_reject_lock,so remove the lock to make
    code more clean.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e9d63562325a..4e8654a18250 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1340,7 +1340,7 @@ struct urb {
 	struct kref kref;		/* reference count of the URB */
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
-	u8 reject;			/* submissions will fail */
+	atomic_t reject;		/* submissions will fail */
 	int unlinked;			/* unlink error code */
 
 	/* public: documented fields in the urb that can be used by drivers */

commit 3b23dd6f8a718e5339de4f7d86ce76a078b5f771
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Dec 5 14:10:34 2008 -0500

    USB: utilize the bus notifiers
    
    This patch (as1185) makes usbcore take advantage of the bus
    notifications sent out by the driver core.  Now we can create all our
    device and interface attribute files before the device or interface
    uevent is broadcast.
    
    A side effect is that we no longer create the endpoint "pseudo"
    devices at the same time as a device or interface is registered -- it
    seems like a bad idea to try registering an endpoint before the
    registration of its parent is complete.  So the routines for creating
    and removing endpoint devices have been split out and renamed, and
    they are called explicitly when needed.  A new bitflag is used for
    keeping track of whether or not the interface's endpoint devices have
    been created, since (just as with the interface attributes) they vary
    with the altsetting and hence can be changed at random times.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 74d0b9990c73..e9d63562325a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -108,6 +108,7 @@ enum usb_interface_condition {
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @is_active: flag set when the interface is bound and not suspended.
  * @sysfs_files_created: sysfs attributes exist
+ * @ep_devs_created: endpoint child pseudo-devices exist
  * @unregistering: flag set when the interface is being unregistered
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
@@ -169,6 +170,7 @@ struct usb_interface {
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
+	unsigned ep_devs_created:1;	/* endpoint "devices" exist */
 	unsigned unregistering:1;	/* unregistration is in progress */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */

commit 65bfd2967c906ca322a4bb69a285fe0de8916ac6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Nov 25 16:39:18 2008 -0500

    USB: Enhance usage of pm_message_t
    
    This patch (as1177) modifies the USB core suspend and resume
    routines.  The resume functions now will take a pm_message_t argument,
    so they will know what sort of resume is occurring.  The new argument
    is also passed to the port suspend/resume and bus suspend/resume
    routines (although they don't use it for anything but debugging).
    
    In addition, special pm_message_t values are used for user-initiated,
    device-initiated (i.e., remote wakeup), and automatic suspend/resume.
    By testing these values, drivers can tell whether or not a particular
    suspend was an autosuspend.  Unfortunately, they can't do the same for
    resumes -- not until the pm_message_t argument is also passed to the
    drivers' resume methods.  That will require a bigger change.
    
    IMO, the whole Power Management framework should have been set up this
    way in the first place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8bc81bffc195..74d0b9990c73 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1067,7 +1067,7 @@ struct usb_device_driver {
 	void (*disconnect) (struct usb_device *udev);
 
 	int (*suspend) (struct usb_device *udev, pm_message_t message);
-	int (*resume) (struct usb_device *udev);
+	int (*resume) (struct usb_device *udev, pm_message_t message);
 	struct usbdrv_wrap drvwrap;
 	unsigned int supports_autosuspend:1;
 };

commit f150fa1afbf69a87f54752579ff2bb769aad88b3
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Thu Nov 13 21:31:21 2008 -0700

    USB: Allow usbmon as a module even if usbcore is builtin
    
    usbmon can only be built as a module if usbcore is a module too. Trivial
    changes to the relevant Kconfig and Makefile (and a few trivial changes
    elsewhere) allow usbmon to be built as a module even if usbcore is
    builtin.
    
    This is verified to work in all 9 permutations (3 correctly prohibited
    by Kconfig, 6 build a suitable result).
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c8e55aa979de..8bc81bffc195 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -336,7 +336,7 @@ struct usb_bus {
 #endif
 	struct device *dev;		/* device for this bus */
 
-#if defined(CONFIG_USB_MON)
+#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif

commit dc023dceec861c60bc1d1a17a2c6496ddac26ee7
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Thu Nov 13 10:31:35 2008 -0800

    USB: Introduce usb_queue_reset() to do resets from atomic contexts
    
    This patch introduces a new call to be able to do a USB reset from an
    atomic contect. This is quite helpful in USB callbacks to handle
    errors (when the only thing that can be done is to do a device
    reset).
    
    It is done queuing a work struct that will do the actual reset. The
    struct is "attached" to an interface so pending requests from an
    interface are removed when said interface is unbound from the driver.
    
    The call flow then becomes:
    
    usb_queue_reset_device()
      __usb_queue_reset_device() [workqueue]
        usb_reset_device()
    
    usb_probe_interface()
      usb_cancel_queue_reset()      [error path]
    
    usb_unbind_interface()
      usb_cancel_queue_reset()
    
    usb_driver_release_interface()
      usb_cancel_queue_reset()
    
    Note usb_cancel_queue_reset() needs smarts to try not to unqueue when
    it is actually being executed. This happens when we run the reset from
    the workqueue: usb_reset_device() is called and on interface unbind
    time, usb_cancel_queue_reset() would be called. That would deadlock on
    cancel_work_sync(). To avoid that, we set (before running
    usb_reset_device()) usb_intf->reset_running and clear it inmediately
    after returning.
    
    Patch is against 2.6.28-rc2 and depends on
    http://marc.info/?l=linux-usb&m=122581634925308&w=2 (as submitted by
    Alan Stern).
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 859a88e6ce9c..c8e55aa979de 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -120,6 +120,11 @@ enum usb_interface_condition {
  *	to the sysfs representation for that device.
  * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
  *	allowed unless the counter is 0.
+ * @reset_ws: Used for scheduling resets from atomic context.
+ * @reset_running: set to 1 if the interface is currently running a
+ *      queued reset so that usb_cancel_queued_reset() doesn't try to
+ *      remove from the workqueue when running inside the worker
+ *      thread. See __usb_queue_reset_device().
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -168,10 +173,12 @@ struct usb_interface {
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */
 	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
+	unsigned reset_running:1;
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
 	int pm_usage_cnt;		/* usage counter for autosuspend */
+	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \
@@ -507,6 +514,7 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
+extern void usb_queue_reset_device(struct usb_interface *dev);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 

commit 9ac39f28b5237a629e41ccfc1f73d3a55723045c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 12 16:19:49 2008 -0500

    USB: add asynchronous autosuspend/autoresume support
    
    This patch (as1160b) adds support routines for asynchronous autosuspend
    and autoresume, with accompanying documentation updates.  There
    already are several potential users of this interface, and others are
    likely to arise as autosuspend support becomes more widespread.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f72aa51f7bcd..859a88e6ce9c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -398,6 +398,7 @@ struct usb_tt;
  * @urbnum: number of URBs submitted for the whole device
  * @active_duration: total time device is not suspended
  * @autosuspend: for delayed autosuspends
+ * @autoresume: for autoresumes requested while in_interrupt
  * @pm_mutex: protects PM operations
  * @last_busy: time of last use
  * @autosuspend_delay: in jiffies
@@ -476,6 +477,7 @@ struct usb_device {
 
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend;
+	struct work_struct autoresume;
 	struct mutex pm_mutex;
 
 	unsigned long last_busy;
@@ -513,6 +515,8 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 extern int usb_autopm_set_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
+extern int usb_autopm_get_interface_async(struct usb_interface *intf);
+extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 
 static inline void usb_autopm_enable(struct usb_interface *intf)
 {
@@ -539,8 +543,13 @@ static inline int usb_autopm_set_interface(struct usb_interface *intf)
 static inline int usb_autopm_get_interface(struct usb_interface *intf)
 { return 0; }
 
+static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
+{ return 0; }
+
 static inline void usb_autopm_put_interface(struct usb_interface *intf)
 { }
+static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
+{ }
 static inline void usb_autopm_enable(struct usb_interface *intf)
 { }
 static inline void usb_autopm_disable(struct usb_interface *intf)

commit 352d026338378b1f13f044e33c1047da6e470056
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 29 15:16:58 2008 -0400

    USB: don't register endpoints for interfaces that are going away
    
    This patch (as1155) fixes a bug in usbcore.  When interfaces are
    deleted, either because the device was disconnected or because of a
    configuration change, the extra attribute files and child endpoint
    devices may get left behind.  This is because the core removes them
    before calling device_del().  But during device_del(), after the
    driver is unbound the core will reinstall altsetting 0 and recreate
    those extra attributes and children.
    
    The patch prevents this by adding a flag to record when the interface
    is in the midst of being unregistered.  When the flag is set, the
    attribute files and child devices will not be created.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org> [2.6.27, 2.6.26, 2.6.25]
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8fa973bede5e..f72aa51f7bcd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -108,6 +108,7 @@ enum usb_interface_condition {
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @is_active: flag set when the interface is bound and not suspended.
  * @sysfs_files_created: sysfs attributes exist
+ * @unregistering: flag set when the interface is being unregistered
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
  * @needs_altsetting0: flag set when a set-interface request for altsetting 0
@@ -163,6 +164,7 @@ struct usb_interface {
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
+	unsigned unregistering:1;	/* unregistration is in progress */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */
 	unsigned needs_binding:1;	/* needs delayed unbind/rebind */

commit 1987625226a918cd20c334ffce5e2a224cba0718
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Aug 25 22:40:25 2008 +0200

    USB: anchor API changes needed for btusb
    
    This extends the anchor API as btusb needs for autosuspend.
    
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d97927970f54..8fa973bede5e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1469,6 +1469,9 @@ extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);
 extern void usb_unanchor_urb(struct urb *urb);
 extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 					 unsigned int timeout);
+extern struct urb *usb_get_from_anchor(struct usb_anchor *anchor);
+extern void usb_scuttle_anchored_urbs(struct usb_anchor *anchor);
+extern int usb_anchor_empty(struct usb_anchor *anchor);
 
 /**
  * usb_urb_dir_in - check if an URB describes an IN transfer

commit 6a2839bedc1502b3f0366cc3ad1099a1d92cf8fb
Author: Oliver Neukum <oliver@neukum.org>
Date:   Tue Jul 29 16:18:47 2008 +0200

    USB: extend poisoning to anchors
    
    this extends the poisoning concept to anchors. This way poisoning
    will work with fire and forget drivers.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3371c91e7ff4..d97927970f54 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1135,6 +1135,7 @@ struct usb_anchor {
 	struct list_head urb_list;
 	wait_queue_head_t wait;
 	spinlock_t lock;
+	unsigned int poisoned:1;
 };
 
 static inline void init_usb_anchor(struct usb_anchor *anchor)
@@ -1462,6 +1463,7 @@ extern void usb_kill_urb(struct urb *urb);
 extern void usb_poison_urb(struct urb *urb);
 extern void usb_unpoison_urb(struct urb *urb);
 extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
+extern void usb_poison_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);
 extern void usb_unanchor_urb(struct urb *urb);

commit 55b447bf79ad25591437d24b78caa9d0ae4fec82
Author: Oliver Neukum <oliver@neukum.org>
Date:   Tue Jul 29 15:26:15 2008 +0200

    USB: kill URBs permanently
    
    looking at usb_kill_urb() it seems to me that it is unnecessarily lenient.
    In the use case of disconnect() you never want to use the URB again
    (for the same device) But leaving urb->reject elevated will make it easier
    to avoid races between read/write and disconnect.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 94ac74aba6b6..3371c91e7ff4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1459,6 +1459,8 @@ extern struct urb *usb_get_urb(struct urb *urb);
 extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
+extern void usb_poison_urb(struct urb *urb);
+extern void usb_unpoison_urb(struct urb *urb);
 extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);

commit 55151d7daba185f94e9dc561a5a2ba36b5f647dd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Aug 12 14:33:59 2008 -0400

    USB: Defer Set-Interface for suspended devices
    
    This patch (as1128) fixes one of the problems related to the new PM
    infrastructure.  We are not allowed to register new child devices
    during the middle of a system sleep transition, but unbinding a USB
    driver causes the core to automatically install altsetting 0 and
    thereby create new endpoint pseudo-devices.
    
    The patch fixes this problem (and the related problem that installing
    altsetting 0 will fail if the device is suspended) by deferring the
    Set-Interface call until some later time when it is legal and can
    succeed.  Possible later times are: when a new driver is being probed
    for the interface, and when the interface is being resumed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0924cd9c30f6..94ac74aba6b6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -110,6 +110,8 @@ enum usb_interface_condition {
  * @sysfs_files_created: sysfs attributes exist
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
+ * @needs_altsetting0: flag set when a set-interface request for altsetting 0
+ *	has been deferred.
  * @needs_binding: flag set when the driver should be re-probed or unbound
  *	following a reset or suspend operation it doesn't support.
  * @dev: driver model's view of this device
@@ -162,6 +164,7 @@ struct usb_interface {
 	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
+	unsigned needs_altsetting0:1;	/* switch to altsetting 0 is pending */
 	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
 
 	struct device dev;		/* interface specific device info */

commit f4f4d58734916e816d4b4a7cf61b3fc22ce02683
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 28 10:39:28 2008 -0400

    USB: add missing kerneldoc line for "needs_binding"
    
    This patch (as1117) adds a kerneldoc line for the "needs_binding"
    field in struct usb_interface.  It was accidentally omitted when the
    field was added.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5811c5da69f9..0924cd9c30f6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -110,6 +110,8 @@ enum usb_interface_condition {
  * @sysfs_files_created: sysfs attributes exist
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
+ * @needs_binding: flag set when the driver should be re-probed or unbound
+ *	following a reset or suspend operation it doesn't support.
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.

commit 78d9a487ee961c356e1a934d9a92eca38ffb3a70
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 23 16:00:40 2008 -0400

    USB: Force unbinding of drivers lacking reset_resume or other methods
    
    This patch (as1024) takes care of a FIXME issue: Drivers that don't
    have the necessary suspend, resume, reset_resume, pre_reset, or
    post_reset methods will be unbound and their interface reprobed when
    one of the unsupported events occurs.
    
    This is made slightly more difficult by the fact that bind operations
    won't work during a system sleep transition.  So instead the code has
    to defer the operation until the transition ends.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3cc8db5254d1..5811c5da69f9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -160,6 +160,7 @@ struct usb_interface {
 	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
+	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;

commit 742120c63138651c898614001cb58cd607401eac
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Wed Jun 18 22:00:29 2008 +0800

    USB: fix usb_reset_device and usb_reset_composite_device(take 3)
    
    This patch renames the existing usb_reset_device in hub.c to
    usb_reset_and_verify_device and renames the existing
    usb_reset_composite_device to usb_reset_device. Also the new
    usb_reset_and_verify_device does't need to be EXPORTED .
    
    The idea of the patch is that external interface driver
    should warn the other interfaces' driver of the same
    device before and after reseting the usb device. One interface
    driver shoud call _old_ usb_reset_composite_device instead of
    _old_ usb_reset_device since it can't assume the device contains
    only one interface. The _old_ usb_reset_composite_device
    is safe for single interface device also. we rename the two
    functions to make the change easily.
    
    This patch is under guideline from Alan Stern.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c74cc64bddc8..3cc8db5254d1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -497,7 +497,6 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
-extern int usb_reset_composite_device(struct usb_device *dev);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
@@ -957,9 +956,9 @@ struct usbdrv_wrap {
  * @resume: Called when the device is being resumed by the system.
  * @reset_resume: Called when the suspended device has been reset instead
  *	of being resumed.
- * @pre_reset: Called by usb_reset_composite_device() when the device
+ * @pre_reset: Called by usb_reset_device() when the device
  *	is about to be reset.
- * @post_reset: Called by usb_reset_composite_device() after the device
+ * @post_reset: Called by usb_reset_device() after the device
  *	has been reset
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set

commit 625f694936cbbdee98e6cc65f72724a7660e7946
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Jun 15 09:42:02 2008 +0800

    USB: remove interface parameter of usb_reset_composite_device
    
    From the current implementation of usb_reset_composite_device
    function, the iface parameter is no longer useful. This function
    doesn't do something special for the iface usb_interface,compared
    with other interfaces in the usb_device. So remove the parameter
    and fix the related caller.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8429d08bd2fd..c74cc64bddc8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -497,8 +497,7 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
-extern int usb_reset_composite_device(struct usb_device *dev,
-		struct usb_interface *iface);
+extern int usb_reset_composite_device(struct usb_device *dev);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 

commit 9da82bd4649334817ef0e752a69eb99051645dad
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu May 8 11:54:37 2008 -0400

    USB: implement "soft" unbinding
    
    This patch (as1091) changes the way usbcore handles interface
    unbinding.  If the interface's driver supports "soft" unbinding (a new
    flag in the driver structure) then in-flight URBs are not cancelled
    and endpoints are not disabled.  Instead the driver is allowed to
    continue communicating with the device (although of course it should
    stop before its disconnect routine returns).
    
    The purpose of this change is to allow drivers to do a clean shutdown
    when they get unbound from a device that is still plugged in.  Killing
    all the URBs and disabling the endpoints before calling the driver's
    disconnect method doesn't give the driver any control over what
    happens, and it can leave devices in indeterminate states.  For
    example, when usb-storage unbinds it doesn't want to stop while in the
    middle of transmitting a SCSI command.
    
    The soft_unbind flag is added because in the past, a number of drivers
    have experienced problems related to ongoing I/O after their disconnect
    routine returned.  Hence "soft" unbinding is made available only to
    drivers that claim to support it.
    
    The patch also replaces "interface_to_usbdev(intf)" with "udev" in a
    couple of places, a minor simplification.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cee7fbb2b605..8429d08bd2fd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -972,6 +972,8 @@ struct usbdrv_wrap {
  *	added to this driver by preventing the sysfs file from being created.
  * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
  *	for interfaces bound to this driver.
+ * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
+ *	endpoints before calling the driver's disconnect method.
  *
  * USB interface drivers must provide a name, probe() and disconnect()
  * methods, and an id_table.  Other driver fields are optional.
@@ -1012,6 +1014,7 @@ struct usb_driver {
 	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
 	unsigned int supports_autosuspend:1;
+	unsigned int soft_unbind:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
 

commit 1b26da1510c02a2dac33c0ea48904256dcec4617
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jul 2 12:46:22 2008 -0700

    USB: handle pci_name() being const
    
    This changes usb_create_hcd() to be able to handle the fact that
    pci_name() has changed to a constant string.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c08689ea9b4b..cee7fbb2b605 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -293,7 +293,7 @@ struct usb_devmap {
 struct usb_bus {
 	struct device *controller;	/* host/master side hardware */
 	int busnum;			/* Bus number (in order of reg) */
-	char *bus_name;			/* stable id (PCI slot_name etc) */
+	const char *bus_name;		/* stable id (PCI slot_name etc) */
 	u8 uses_dma;			/* Does the host controller use DMA? */
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */

commit b1d8dfb0e548543b1645362e80e1fff522645299
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Apr 8 13:24:46 2008 -0700

    wusb: add link wusb-usb device
    
    We need to tie the WUSB and USB devices; the USB stack doesn't need to
    know the details about the WUSB device, but needs to have a link to
    it. This is needed so that the notify call back for Remove Device can
    tie both and undo the device setup (sysfs files).
    
    We connect the devices together at the Add Device notifier callback
    (the wusb_dev references the usb_dev and stores it, the usb_dev
    references the wusb_dev and stores it); then we do create the WUSB
    sysfs files at the usb_dev sysfs directory. At Remove Device, we undo
    that (thus we need the usb_dev reference).
    
    Cross reference to functions in the WUSB substack:
    wusb_dev_{add,rm}_ncb().
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c5af7633c449..c08689ea9b4b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -23,6 +23,7 @@
 
 struct usb_device;
 struct usb_driver;
+struct wusb_dev;
 
 /*-------------------------------------------------------------------------*/
 
@@ -480,6 +481,7 @@ struct usb_device {
 	unsigned autoresume_disabled:1;
 	unsigned skip_sys_resume:1;
 #endif
+	struct wusb_dev *wusb_dev;
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 

commit 3b52f128aeacc4b9e5992012c39ffc9508513bcd
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Apr 8 13:24:46 2008 -0700

    wusb: add authenticathed bit to usb_dev
    
    This bit indicates the system that the WUSB device has been crypto
    authenticated and thus can operate as normal.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4a91181629d9..c5af7633c449 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -372,6 +372,7 @@ struct usb_tt;
  *	used or not. By default, wired USB devices are authorized.
  *	WUSB devices are not, until we authorize them from user space.
  *	FIXME -- complete doc
+ * @authenticated: Crypto authentication passed
  * @wusb: device is Wireless USB
  * @string_langid: language ID for strings
  * @product: iProduct string, if present (static)
@@ -438,6 +439,7 @@ struct usb_device {
 	unsigned persist_enabled:1;
 	unsigned have_langid:1;
 	unsigned authorized:1;
+ 	unsigned authenticated:1;
 	unsigned wusb:1;
 	int string_langid;
 

commit 7ef4f0600df3dc2beff838b3f03652677ed28311
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Apr 10 15:15:37 2008 +0200

    USB: update comments about usb driver's header
    
    Comments here are so outdated that they are plain wrong. We cannot expect
    people to write correct drivers if the headers have incorrect comments.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 52c449e4bdcd..4a91181629d9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -938,10 +938,11 @@ struct usbdrv_wrap {
  *	and should normally be the same as the module name.
  * @probe: Called to see if the driver is willing to manage a particular
  *	interface on a device.  If it is, probe returns zero and uses
- *	dev_set_drvdata() to associate driver-specific data with the
+ *	usb_set_intfdata() to associate driver-specific data with the
  *	interface.  It may also use usb_set_interface() to specify the
  *	appropriate altsetting.  If unwilling to manage the interface,
- *	return a negative errno value.
+ *	return -ENODEV, if genuine IO errors occured, an appropriate
+ *	negative errno value.
  * @disconnect: Called when the interface is no longer accessible, usually
  *	because its device has been (or is being) disconnected or the
  *	driver module is being unloaded.
@@ -956,10 +957,7 @@ struct usbdrv_wrap {
  * @pre_reset: Called by usb_reset_composite_device() when the device
  *	is about to be reset.
  * @post_reset: Called by usb_reset_composite_device() after the device
- *	has been reset, or in lieu of @resume following a reset-resume
- *	(i.e., the device is reset instead of being resumed, as might
- *	happen if power was lost).  The second argument tells which is
- *	the reason.
+ *	has been reset
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.

commit eda769593bbae8aee4e336b0732f6016353301a3
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Apr 10 14:07:37 2008 +0200

    USB: add extension of anchor API, usb_unlink_anchored_urbs
    
    This adds the ability to trigger asynchronous unlinks of anchored URBs. This
    is needed for error handling in the comntext of completion handlers, which
    cannot sleep.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index dd9733cc0ac2..52c449e4bdcd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1451,6 +1451,7 @@ extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
+extern void usb_unlink_anchored_urbs(struct usb_anchor *anchor);
 extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);
 extern void usb_unanchor_urb(struct urb *urb);
 extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,

commit f66396b55d4016bdc7a5298db7a681c63b649bf4
Author: Tilman Schmidt <tilman@imap.cc>
Date:   Thu Mar 13 19:51:42 2008 +0100

    USB: usb.h: reduce syslog clutter [v3]
    
    The the err() / info() / warn() macros in usb.h inserted __FILE__ at
    the beginning of the message, which expands to the complete pathname
    of the source file within the kernel tree, frequently taking up half
    of an 80 character screen line before the actual message even begins.
    Use the module name instead.
    
    Signed-off-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 285011d9af17..dd9733cc0ac2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1701,13 +1701,12 @@ extern void usb_unregister_notify(struct notifier_block *nb);
 #define dbg(format, arg...) do {} while (0)
 #endif
 
-#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , \
-	__FILE__ , ## arg)
-#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , \
-	__FILE__ , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , \
-	__FILE__ , ## arg)
-
+#define err(format, arg...) printk(KERN_ERR KBUILD_MODNAME ": " \
+	format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO KBUILD_MODNAME ": " \
+	format "\n" , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING KBUILD_MODNAME ": " \
+	format "\n" , ## arg)
 
 #endif  /* __KERNEL__ */
 

commit f476fbaba7b2051bafdb527eea1a8bed649187d4
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Feb 13 18:33:15 2008 -0800

    USB: convert usb.h struct usb_device to kernel-doc
    
    Convert struct usb_device to use kernel-doc notation.
    Please especially check the @filelist and @usb_classdev descriptions.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7e31cacfe69c..285011d9af17 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -341,102 +341,142 @@ struct usb_bus {
 
 struct usb_tt;
 
-/*
+/**
  * struct usb_device - kernel's representation of a USB device
- *
- * FIXME: Write the kerneldoc!
- *
+ * @devnum: device number; address on a USB bus
+ * @devpath: device ID string for use in messages (e.g., /port/...)
+ * @state: device state: configured, not attached, etc.
+ * @speed: device speed: high/full/low (or error)
+ * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub
+ * @ttport: device port on that tt hub
+ * @toggle: one bit for each endpoint, with ([0] = IN, [1] = OUT) endpoints
+ * @parent: our hub, unless we're the root
+ * @bus: bus we're part of
+ * @ep0: endpoint 0 data (default control pipe)
+ * @dev: generic device interface
+ * @descriptor: USB device descriptor
+ * @config: all of the device's configs
+ * @actconfig: the active configuration
+ * @ep_in: array of IN endpoints
+ * @ep_out: array of OUT endpoints
+ * @rawdescriptors: raw descriptors for each config
+ * @bus_mA: Current available from the bus
+ * @portnum: parent port number (origin 1)
+ * @level: number of USB hub ancestors
+ * @can_submit: URBs may be submitted
+ * @discon_suspended: disconnected while suspended
+ * @persist_enabled:  USB_PERSIST enabled for this device
+ * @have_langid: whether string_langid is valid
+ * @authorized: policy has said we can use it;
+ *	(user space) policy determines if we authorize this device to be
+ *	used or not. By default, wired USB devices are authorized.
+ *	WUSB devices are not, until we authorize them from user space.
+ *	FIXME -- complete doc
+ * @wusb: device is Wireless USB
+ * @string_langid: language ID for strings
+ * @product: iProduct string, if present (static)
+ * @manufacturer: iManufacturer string, if present (static)
+ * @serial: iSerialNumber string, if present (static)
+ * @filelist: usbfs files that are open to this device
+ * @usb_classdev: USB class device that was created for usbfs device
+ *	access from userspace
+ * @usbfs_dentry: usbfs dentry entry for the device
+ * @maxchild: number of ports if hub
+ * @children: child devices - USB devices that are attached to this hub
+ * @pm_usage_cnt: usage counter for autosuspend
+ * @quirks: quirks of the whole device
+ * @urbnum: number of URBs submitted for the whole device
+ * @active_duration: total time device is not suspended
+ * @autosuspend: for delayed autosuspends
+ * @pm_mutex: protects PM operations
+ * @last_busy: time of last use
+ * @autosuspend_delay: in jiffies
+ * @connect_time: time device was first connected
+ * @auto_pm: autosuspend/resume in progress
+ * @do_remote_wakeup:  remote wakeup should be enabled
+ * @reset_resume: needs reset instead of resume
+ * @autosuspend_disabled: autosuspend disabled by the user
+ * @autoresume_disabled: autoresume disabled by the user
+ * @skip_sys_resume: skip the next system resume
+ *
+ * Notes:
  * Usbcore drivers should not set usbdev->state directly.  Instead use
  * usb_set_device_state().
- *
- * @authorized: (user space) policy determines if we authorize this
- *              device to be used or not. By default, wired USB
- *              devices are authorized. WUSB devices are not, until we
- *              authorize them from user space. FIXME -- complete doc
  */
 struct usb_device {
-	int		devnum;		/* Address on USB bus */
-	char		devpath [16];	/* Use in messages: /port/port/... */
-	enum usb_device_state	state;	/* configured, not attached, etc */
-	enum usb_device_speed	speed;	/* high/full/low (or error) */
+	int		devnum;
+	char		devpath [16];
+	enum usb_device_state	state;
+	enum usb_device_speed	speed;
 
-	struct usb_tt	*tt; 		/* low/full speed dev, highspeed hub */
-	int		ttport;		/* device port on that tt hub */
+	struct usb_tt	*tt;
+	int		ttport;
 
-	unsigned int toggle[2];		/* one bit for each endpoint
-					 * ([0] = IN, [1] = OUT) */
+	unsigned int toggle[2];
 
-	struct usb_device *parent;	/* our hub, unless we're the root */
-	struct usb_bus *bus;		/* Bus we're part of */
+	struct usb_device *parent;
+	struct usb_bus *bus;
 	struct usb_host_endpoint ep0;
 
-	struct device dev;		/* Generic device interface */
+	struct device dev;
 
-	struct usb_device_descriptor descriptor;/* Descriptor */
-	struct usb_host_config *config;	/* All of the configs */
+	struct usb_device_descriptor descriptor;
+	struct usb_host_config *config;
 
-	struct usb_host_config *actconfig;/* the active configuration */
+	struct usb_host_config *actconfig;
 	struct usb_host_endpoint *ep_in[16];
 	struct usb_host_endpoint *ep_out[16];
 
-	char **rawdescriptors;		/* Raw descriptors for each config */
+	char **rawdescriptors;
 
-	unsigned short bus_mA;		/* Current available from the bus */
-	u8 portnum;			/* Parent port number (origin 1) */
-	u8 level;			/* Number of USB hub ancestors */
+	unsigned short bus_mA;
+	u8 portnum;
+	u8 level;
 
-	unsigned can_submit:1;		/* URBs may be submitted */
-	unsigned discon_suspended:1;	/* Disconnected while suspended */
-	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
-	unsigned have_langid:1;		/* whether string_langid is valid */
-	unsigned authorized:1;		/* Policy has said we can use it */
-	unsigned wusb:1;		/* Device is Wireless USB */
-	int string_langid;		/* language ID for strings */
+	unsigned can_submit:1;
+	unsigned discon_suspended:1;
+	unsigned persist_enabled:1;
+	unsigned have_langid:1;
+	unsigned authorized:1;
+	unsigned wusb:1;
+	int string_langid;
 
 	/* static strings from the device */
-	char *product;			/* iProduct string, if present */
-	char *manufacturer;		/* iManufacturer string, if present */
-	char *serial;			/* iSerialNumber string, if present */
+	char *product;
+	char *manufacturer;
+	char *serial;
 
 	struct list_head filelist;
 #ifdef CONFIG_USB_DEVICE_CLASS
 	struct device *usb_classdev;
 #endif
 #ifdef CONFIG_USB_DEVICEFS
-	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
+	struct dentry *usbfs_dentry;
 #endif
-	/*
-	 * Child devices - these can be either new devices
-	 * (if this is a hub device), or different instances
-	 * of this same device.
-	 *
-	 * Each instance needs its own set of data structures.
-	 */
 
-	int maxchild;			/* Number of ports if hub */
+	int maxchild;
 	struct usb_device *children[USB_MAXCHILDREN];
 
-	int pm_usage_cnt;		/* usage counter for autosuspend */
-	u32 quirks;			/* quirks of the whole device */
-	atomic_t urbnum;		/* number of URBs submitted for
-					   the whole device */
+	int pm_usage_cnt;
+	u32 quirks;
+	atomic_t urbnum;
 
-	unsigned long active_duration;	/* total time device is not suspended */
+	unsigned long active_duration;
 
 #ifdef CONFIG_PM
-	struct delayed_work autosuspend; /* for delayed autosuspends */
-	struct mutex pm_mutex;		/* protects PM operations */
-
-	unsigned long last_busy;	/* time of last use */
-	int autosuspend_delay;		/* in jiffies */
-	unsigned long connect_time;	/* time device was first connected */
-
-	unsigned auto_pm:1;		/* autosuspend/resume in progress */
-	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
-	unsigned reset_resume:1;	/* needs reset instead of resume */
-	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
-	unsigned autoresume_disabled:1;  /*  disabled by the user */
-	unsigned skip_sys_resume:1;	/* skip the next system resume */
+	struct delayed_work autosuspend;
+	struct mutex pm_mutex;
+
+	unsigned long last_busy;
+	int autosuspend_delay;
+	unsigned long connect_time;
+
+	unsigned auto_pm:1;
+	unsigned do_remote_wakeup:1;
+	unsigned reset_resume:1;
+	unsigned autosuspend_disabled:1;
+	unsigned autoresume_disabled:1;
+	unsigned skip_sys_resume:1;
 #endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)

commit feccc30d90155bcbc937f87643182a43d25873eb
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 3 15:15:59 2008 -0500

    USB: remove CONFIG_USB_PERSIST setting
    
    This patch (as1047) removes the USB_PERSIST Kconfig option, enabling
    it permanently.  It also prevents the power/persist attribute from
    being created for hub devices; there's no point in having it since
    USB-PERSIST is always turned on for hubs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 583e0481dfa0..7e31cacfe69c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -387,6 +387,7 @@ struct usb_device {
 
 	unsigned can_submit:1;		/* URBs may be submitted */
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
+	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	unsigned authorized:1;		/* Policy has said we can use it */
 	unsigned wusb:1;		/* Device is Wireless USB */
@@ -433,7 +434,6 @@ struct usb_device {
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 	unsigned reset_resume:1;	/* needs reset instead of resume */
-	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 	unsigned skip_sys_resume:1;	/* skip the next system resume */

commit d6d914f52b15d5a8e81ad481e02d9ab30d412a29
Author: Lei Ming <tom.leiming@gmail.com>
Date:   Mon Feb 25 18:07:28 2008 +0800

    USB: fix comment of struct usb_interface
    
    update the comment for the removed "driver" field  and  being
    out-of-order of  @cur_altsetting and @num_altsetting.
    
    Signed-off-by: Lei Ming <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5bd3ae8aaaf4..583e0481dfa0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -94,10 +94,9 @@ enum usb_interface_condition {
  * @altsetting: array of interface structures, one for each alternate
  * 	setting that may be selected.  Each one includes a set of
  * 	endpoint configurations.  They will be in no particular order.
- * @num_altsetting: number of altsettings defined.
  * @cur_altsetting: the current altsetting.
+ * @num_altsetting: number of altsettings defined.
  * @intf_assoc: interface association descriptor
- * @driver: the USB driver that is bound to this interface.
  * @minor: the minor number assigned to this interface, if this
  *	interface is bound to a driver that uses the USB major number.
  *	If this interface does not use the USB major, this field should

commit d0bcabcd72dda5f553322a1ca92ae31c15b408b6
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Feb 29 22:03:07 2008 -0800

    docbook: fix usb source files
    
    Fix docbook problems in USB source files.
    These cause the generated docbook to be incorrect.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2372e2e6b527..5bd3ae8aaaf4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -781,8 +781,7 @@ static inline int usb_endpoint_is_isoc_out(
 	.idVendor = (vend), \
 	.idProduct = (prod)
 /**
- * USB_DEVICE_VER - macro used to describe a specific usb device with a
- *		version range
+ * USB_DEVICE_VER - describe a specific usb device with a version range
  * @vend: the 16 bit USB Vendor ID
  * @prod: the 16 bit USB Product ID
  * @lo: the bcdDevice_lo value
@@ -799,8 +798,7 @@ static inline int usb_endpoint_is_isoc_out(
 	.bcdDevice_hi = (hi)
 
 /**
- * USB_DEVICE_INTERFACE_PROTOCOL - macro used to describe a usb
- *		device with a specific interface protocol
+ * USB_DEVICE_INTERFACE_PROTOCOL - describe a usb device with a specific interface protocol
  * @vend: the 16 bit USB Vendor ID
  * @prod: the 16 bit USB Product ID
  * @pr: bInterfaceProtocol value
@@ -846,8 +844,7 @@ static inline int usb_endpoint_is_isoc_out(
 	.bInterfaceProtocol = (pr)
 
 /**
- * USB_DEVICE_AND_INTERFACE_INFO - macro used to describe a specific usb device
- * 		with a class of usb interfaces
+ * USB_DEVICE_AND_INTERFACE_INFO - describe a specific usb device with a class of usb interfaces
  * @vend: the 16 bit USB Vendor ID
  * @prod: the 16 bit USB Product ID
  * @cl: bInterfaceClass value

commit 969ab2ee9d68bd037e2db7ea12ff78baae5d2f94
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jan 30 15:20:32 2008 -0800

    USB: fix codingstyle issues in include/linux/usb.h
    
    No logical code changes were made, but checkpatch.pl is much happier now.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f8a60756fe2a..2372e2e6b527 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -162,19 +162,19 @@ struct usb_interface {
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */
-	struct device *usb_dev;		/* pointer to the usb class's device, if any */
+	struct device *usb_dev;
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \
 	container_of(intf->dev.parent, struct usb_device, dev)
 
-static inline void *usb_get_intfdata (struct usb_interface *intf)
+static inline void *usb_get_intfdata(struct usb_interface *intf)
 {
-	return dev_get_drvdata (&intf->dev);
+	return dev_get_drvdata(&intf->dev);
 }
 
-static inline void usb_set_intfdata (struct usb_interface *intf, void *data)
+static inline void usb_set_intfdata(struct usb_interface *intf, void *data)
 {
 	dev_set_drvdata(&intf->dev, data);
 }
@@ -275,9 +275,10 @@ struct usb_host_config {
 
 int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	unsigned char type, void **ptr);
-#define usb_get_extra_descriptor(ifpoint,type,ptr)\
-	__usb_get_extra_descriptor((ifpoint)->extra,(ifpoint)->extralen,\
-		type,(void**)ptr)
+#define usb_get_extra_descriptor(ifpoint, type, ptr) \
+				__usb_get_extra_descriptor((ifpoint)->extra, \
+				(ifpoint)->extralen, \
+				type, (void **)ptr)
 
 /* ----------------------------------------------------------------------- */
 
@@ -388,7 +389,7 @@ struct usb_device {
 	unsigned can_submit:1;		/* URBs may be submitted */
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
-	unsigned authorized:1;		/* Policy has determined we can use it */
+	unsigned authorized:1;		/* Policy has said we can use it */
 	unsigned wusb:1;		/* Device is Wireless USB */
 	int string_langid;		/* language ID for strings */
 
@@ -417,7 +418,8 @@ struct usb_device {
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 	u32 quirks;			/* quirks of the whole device */
-	atomic_t urbnum;		/* number of URBs submitted for the whole device */
+	atomic_t urbnum;		/* number of URBs submitted for
+					   the whole device */
 
 	unsigned long active_duration;	/* total time device is not suspended */
 
@@ -501,11 +503,11 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */
-extern int usb_get_current_frame_number (struct usb_device *usb_dev);
+extern int usb_get_current_frame_number(struct usb_device *usb_dev);
 
 /* used these for multi-interface device registration */
 extern int usb_driver_claim_interface(struct usb_driver *driver,
-			struct usb_interface *iface, void* priv);
+			struct usb_interface *iface, void *priv);
 
 /**
  * usb_interface_claimed - returns true iff an interface is claimed
@@ -517,7 +519,8 @@ extern int usb_driver_claim_interface(struct usb_driver *driver,
  * may need to explicitly claim that lock.
  *
  */
-static inline int usb_interface_claimed(struct usb_interface *iface) {
+static inline int usb_interface_claimed(struct usb_interface *iface)
+{
 	return (iface->dev.driver != NULL);
 }
 
@@ -560,12 +563,11 @@ extern struct usb_host_interface *usb_altnum_to_altsetting(
  * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
  * high speed, and a different one if they are full or low speed.
  */
-static inline int usb_make_path (struct usb_device *dev, char *buf,
-		size_t size)
+static inline int usb_make_path(struct usb_device *dev, char *buf, size_t size)
 {
 	int actual;
-	actual = snprintf (buf, size, "usb-%s-%s", dev->bus->bus_name,
-			dev->devpath);
+	actual = snprintf(buf, size, "usb-%s-%s", dev->bus->bus_name,
+			  dev->devpath);
 	return (actual >= (int)size) ? -1 : actual;
 }
 
@@ -611,7 +613,8 @@ static inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
  *
  * Returns true if the endpoint is of type OUT, otherwise it returns false.
  */
-static inline int usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_dir_out(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
 }
@@ -622,7 +625,8 @@ static inline int usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd
  *
  * Returns true if the endpoint is of type bulk, otherwise it returns false.
  */
-static inline int usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_xfer_bulk(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 		USB_ENDPOINT_XFER_BULK);
@@ -634,7 +638,8 @@ static inline int usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *e
  *
  * Returns true if the endpoint is of type control, otherwise it returns false.
  */
-static inline int usb_endpoint_xfer_control(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_xfer_control(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 		USB_ENDPOINT_XFER_CONTROL);
@@ -647,7 +652,8 @@ static inline int usb_endpoint_xfer_control(const struct usb_endpoint_descriptor
  * Returns true if the endpoint is of type interrupt, otherwise it returns
  * false.
  */
-static inline int usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_xfer_int(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 		USB_ENDPOINT_XFER_INT);
@@ -660,7 +666,8 @@ static inline int usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *ep
  * Returns true if the endpoint is of type isochronous, otherwise it returns
  * false.
  */
-static inline int usb_endpoint_xfer_isoc(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_xfer_isoc(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
 		USB_ENDPOINT_XFER_ISOC);
@@ -673,7 +680,8 @@ static inline int usb_endpoint_xfer_isoc(const struct usb_endpoint_descriptor *e
  * Returns true if the endpoint has bulk transfer type and IN direction,
  * otherwise it returns false.
  */
-static inline int usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_is_bulk_in(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd));
 }
@@ -685,7 +693,8 @@ static inline int usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *
  * Returns true if the endpoint has bulk transfer type and OUT direction,
  * otherwise it returns false.
  */
-static inline int usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_is_bulk_out(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd));
 }
@@ -697,7 +706,8 @@ static inline int usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor
  * Returns true if the endpoint has interrupt transfer type and IN direction,
  * otherwise it returns false.
  */
-static inline int usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_is_int_in(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd));
 }
@@ -709,7 +719,8 @@ static inline int usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *e
  * Returns true if the endpoint has interrupt transfer type and OUT direction,
  * otherwise it returns false.
  */
-static inline int usb_endpoint_is_int_out(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_is_int_out(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd));
 }
@@ -721,7 +732,8 @@ static inline int usb_endpoint_is_int_out(const struct usb_endpoint_descriptor *
  * Returns true if the endpoint has isochronous transfer type and IN direction,
  * otherwise it returns false.
  */
-static inline int usb_endpoint_is_isoc_in(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_is_isoc_in(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd));
 }
@@ -733,7 +745,8 @@ static inline int usb_endpoint_is_isoc_in(const struct usb_endpoint_descriptor *
  * Returns true if the endpoint has isochronous transfer type and OUT direction,
  * otherwise it returns false.
  */
-static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor *epd)
+static inline int usb_endpoint_is_isoc_out(
+				const struct usb_endpoint_descriptor *epd)
 {
 	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd));
 }
@@ -764,8 +777,9 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
  * specific device.
  */
 #define USB_DEVICE(vend,prod) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), \
-			.idProduct = (prod)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, \
+	.idVendor = (vend), \
+	.idProduct = (prod)
 /**
  * USB_DEVICE_VER - macro used to describe a specific usb device with a
  *		version range
@@ -777,10 +791,12 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
  * This macro is used to create a struct usb_device_id that matches a
  * specific device, with a version range.
  */
-#define USB_DEVICE_VER(vend,prod,lo,hi) \
+#define USB_DEVICE_VER(vend, prod, lo, hi) \
 	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \
-	.idVendor = (vend), .idProduct = (prod), \
-	.bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
+	.idVendor = (vend), \
+	.idProduct = (prod), \
+	.bcdDevice_lo = (lo), \
+	.bcdDevice_hi = (hi)
 
 /**
  * USB_DEVICE_INTERFACE_PROTOCOL - macro used to describe a usb
@@ -792,8 +808,9 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
  * This macro is used to create a struct usb_device_id that matches a
  * specific interface protocol of devices.
  */
-#define USB_DEVICE_INTERFACE_PROTOCOL(vend,prod,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_PROTOCOL, \
+#define USB_DEVICE_INTERFACE_PROTOCOL(vend, prod, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+		       USB_DEVICE_ID_MATCH_INT_PROTOCOL, \
 	.idVendor = (vend), \
 	.idProduct = (prod), \
 	.bInterfaceProtocol = (pr)
@@ -807,12 +824,14 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
  * This macro is used to create a struct usb_device_id that matches a
  * specific class of devices.
  */
-#define USB_DEVICE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), \
-	.bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
+#define USB_DEVICE_INFO(cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, \
+	.bDeviceClass = (cl), \
+	.bDeviceSubClass = (sc), \
+	.bDeviceProtocol = (pr)
 
 /**
- * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces 
+ * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces
  * @cl: bInterfaceClass value
  * @sc: bInterfaceSubClass value
  * @pr: bInterfaceProtocol value
@@ -820,9 +839,11 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
  * This macro is used to create a struct usb_device_id that matches a
  * specific class of interfaces.
  */
-#define USB_INTERFACE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), \
-	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+#define USB_INTERFACE_INFO(cl, sc, pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), \
+	.bInterfaceProtocol = (pr)
 
 /**
  * USB_DEVICE_AND_INTERFACE_INFO - macro used to describe a specific usb device
@@ -839,12 +860,14 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
  * This is especially useful when explicitly matching devices that have
  * vendor specific bDeviceClass values, but standards-compliant interfaces.
  */
-#define USB_DEVICE_AND_INTERFACE_INFO(vend,prod,cl,sc,pr) \
+#define USB_DEVICE_AND_INTERFACE_INFO(vend, prod, cl, sc, pr) \
 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
 		| USB_DEVICE_ID_MATCH_DEVICE, \
-	.idVendor = (vend), .idProduct = (prod), \
+	.idVendor = (vend), \
+	.idProduct = (prod), \
 	.bInterfaceClass = (cl), \
-	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+	.bInterfaceSubClass = (sc), \
+	.bInterfaceProtocol = (pr)
 
 /* ----------------------------------------------------------------------- */
 
@@ -1122,7 +1145,7 @@ typedef void (*usb_complete_t)(struct urb *);
  *	transferred.  It will normally be the same as requested, unless
  *	either an error was reported or a short read was performed.
  *	The URB_SHORT_NOT_OK transfer flag may be used to make such
- *	short reads be reported as errors. 
+ *	short reads be reported as errors.
  * @setup_packet: Only used for control transfers, this points to eight bytes
  *	of setup data.  Control transfers always start by sending this data
  *	to the device.  Then transfer_buffer is read or written, if needed.
@@ -1141,7 +1164,7 @@ typedef void (*usb_complete_t)(struct urb *);
  * @complete: Completion handler. This URB is passed as the parameter to the
  *	completion function.  The completion function may then do what
  *	it likes with the URB, including resubmitting or freeing it.
- * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to 
+ * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to
  *	collect the transfer status for each buffer.
  *
  * This structure identifies USB transfer requests.  URBs must be allocated by
@@ -1245,8 +1268,7 @@ typedef void (*usb_complete_t)(struct urb *);
  * when the urb is owned by the hcd, that is, since the call to
  * usb_submit_urb() till the entry into the completion routine.
  */
-struct urb
-{
+struct urb {
 	/* private: usb core and host controller only fields in the urb */
 	struct kref kref;		/* reference count of the URB */
 	void *hcpriv;			/* private data for host controller */
@@ -1257,10 +1279,10 @@ struct urb
 	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's
 					 * current owner */
-	struct list_head anchor_list;	/* the URB may be anchored by the driver */
+	struct list_head anchor_list;	/* the URB may be anchored */
 	struct usb_anchor *anchor;
 	struct usb_device *dev; 	/* (in) pointer to associated device */
-	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint struct */
+	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/
@@ -1297,14 +1319,14 @@ struct urb
  * Initializes a control urb with the proper information needed to submit
  * it to a device.
  */
-static inline void usb_fill_control_urb (struct urb *urb,
-					 struct usb_device *dev,
-					 unsigned int pipe,
-					 unsigned char *setup_packet,
-					 void *transfer_buffer,
-					 int buffer_length,
-					 usb_complete_t complete_fn,
-					 void *context)
+static inline void usb_fill_control_urb(struct urb *urb,
+					struct usb_device *dev,
+					unsigned int pipe,
+					unsigned char *setup_packet,
+					void *transfer_buffer,
+					int buffer_length,
+					usb_complete_t complete_fn,
+					void *context)
 {
 	urb->dev = dev;
 	urb->pipe = pipe;
@@ -1328,13 +1350,13 @@ static inline void usb_fill_control_urb (struct urb *urb,
  * Initializes a bulk urb with the proper information needed to submit it
  * to a device.
  */
-static inline void usb_fill_bulk_urb (struct urb *urb,
-				      struct usb_device *dev,
-				      unsigned int pipe,
-				      void *transfer_buffer,
-				      int buffer_length,
-				      usb_complete_t complete_fn,
-				      void *context)
+static inline void usb_fill_bulk_urb(struct urb *urb,
+				     struct usb_device *dev,
+				     unsigned int pipe,
+				     void *transfer_buffer,
+				     int buffer_length,
+				     usb_complete_t complete_fn,
+				     void *context)
 {
 	urb->dev = dev;
 	urb->pipe = pipe;
@@ -1362,14 +1384,14 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
  * the endpoint interval, and express polling intervals in microframes
  * (eight per millisecond) rather than in frames (one per millisecond).
  */
-static inline void usb_fill_int_urb (struct urb *urb,
-				     struct usb_device *dev,
-				     unsigned int pipe,
-				     void *transfer_buffer,
-				     int buffer_length,
-				     usb_complete_t complete_fn,
-				     void *context,
-				     int interval)
+static inline void usb_fill_int_urb(struct urb *urb,
+				    struct usb_device *dev,
+				    unsigned int pipe,
+				    void *transfer_buffer,
+				    int buffer_length,
+				    usb_complete_t complete_fn,
+				    void *context,
+				    int interval)
 {
 	urb->dev = dev;
 	urb->pipe = pipe;
@@ -1422,15 +1444,15 @@ static inline int usb_urb_dir_out(struct urb *urb)
 	return (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;
 }
 
-void *usb_buffer_alloc (struct usb_device *dev, size_t size,
+void *usb_buffer_alloc(struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
-void usb_buffer_free (struct usb_device *dev, size_t size,
+void usb_buffer_free(struct usb_device *dev, size_t size,
 	void *addr, dma_addr_t dma);
 
 #if 0
-struct urb *usb_buffer_map (struct urb *urb);
-void usb_buffer_dmasync (struct urb *urb);
-void usb_buffer_unmap (struct urb *urb);
+struct urb *usb_buffer_map(struct urb *urb);
+void usb_buffer_dmasync(struct urb *urb);
+void usb_buffer_unmap(struct urb *urb);
 #endif
 
 struct scatterlist;
@@ -1502,7 +1524,7 @@ struct usb_sg_request {
 	int			status;
 	size_t			bytes;
 
-	/* 
+	/*
 	 * members below are private: to usbcore,
 	 * and are not provided for driver access!
 	 */
@@ -1520,18 +1542,18 @@ struct usb_sg_request {
 	struct completion	complete;
 };
 
-int usb_sg_init (
+int usb_sg_init(
 	struct usb_sg_request	*io,
 	struct usb_device	*dev,
-	unsigned		pipe, 
+	unsigned		pipe,
 	unsigned		period,
 	struct scatterlist	*sg,
 	int			nents,
 	size_t			length,
 	gfp_t			mem_flags
 );
-void usb_sg_cancel (struct usb_sg_request *io);
-void usb_sg_wait (struct usb_sg_request *io);
+void usb_sg_cancel(struct usb_sg_request *io);
+void usb_sg_wait(struct usb_sg_request *io);
 
 
 /* ----------------------------------------------------------------------- */
@@ -1588,21 +1610,21 @@ static inline unsigned int __create_pipe(struct usb_device *dev,
 
 /* Create various pipes... */
 #define usb_sndctrlpipe(dev,endpoint)	\
-	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint))
+	((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint))
 #define usb_rcvctrlpipe(dev,endpoint)	\
-	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+	((PIPE_CONTROL << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
 #define usb_sndisocpipe(dev,endpoint)	\
-	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint))
+	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint))
 #define usb_rcvisocpipe(dev,endpoint)	\
-	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
 #define usb_sndbulkpipe(dev,endpoint)	\
-	((PIPE_BULK << 30) | __create_pipe(dev,endpoint))
+	((PIPE_BULK << 30) | __create_pipe(dev, endpoint))
 #define usb_rcvbulkpipe(dev,endpoint)	\
-	((PIPE_BULK << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+	((PIPE_BULK << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
 #define usb_sndintpipe(dev,endpoint)	\
-	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint))
+	((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint))
 #define usb_rcvintpipe(dev,endpoint)	\
-	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+	((PIPE_INTERRUPT << 30) | __create_pipe(dev, endpoint) | USB_DIR_IN)
 
 /*-------------------------------------------------------------------------*/
 

commit 1512300689426cb98bfd7e567ee9fdfaaf61b7c7
Author: Sarah Sharp <saharabeara@gmail.com>
Date:   Fri Dec 21 16:54:15 2007 -0800

    USB: Export suspend statistics
    
    This patch exports two statistics to userspace:
    /sys/bus/usb/device/.../power/connected_duration
    /sys/bus/usb/device/.../power/active_duration
    
    connected_duration is the total time (in msec) that the device has
    been connected.  active_duration is the total time the device has not
    been suspended.  With these two statistics, tools like PowerTOP can
    calculate the percentage time that a device is active, i.e. not
    suspended or auto-suspended.
    
    Users can also use the active_duration to check if a device is actually
    autosuspended.  Currently, they can set power/level to auto and
    power/autosuspend to a positive timeout, but there's no way to know from
    userspace if a device was actually autosuspended without looking at the
    dmesg output.  These statistics will be useful in creating an automated
    userspace script to test autosuspend for USB devices.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8aae045e9a2e..f8a60756fe2a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -419,12 +419,15 @@ struct usb_device {
 	u32 quirks;			/* quirks of the whole device */
 	atomic_t urbnum;		/* number of URBs submitted for the whole device */
 
+	unsigned long active_duration;	/* total time device is not suspended */
+
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
 	unsigned long last_busy;	/* time of last use */
 	int autosuspend_delay;		/* in jiffies */
+	unsigned long connect_time;	/* time device was first connected */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */

commit 5a3201b2809a9f7bcda8413c445483f5b5e490a3
Author: Tony Jones <tonyj@suse.de>
Date:   Tue Sep 11 14:07:31 2007 -0700

    USB: Convert from class_device to device for USB core
    
    Convert from class_device to device for drivers/usb/core.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5fc8ff73b7bb..8aae045e9a2e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -318,7 +318,7 @@ struct usb_bus {
 #ifdef CONFIG_USB_DEVICEFS
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 #endif
-	struct class_device *class_dev;	/* class device for this bus */
+	struct device *dev;		/* device for this bus */
 
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */

commit f88ed90d8627d0d3d93b330d6d2012c2934fb54e
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Dec 3 14:14:16 2007 -0800

    usb.h: fix kernel-doc warning
    
    Fix kernel-doc warning in usb.h:
    Warning(linux-2.6.24-rc3-git7//include/linux/usb.h:166): No description found for parameter 'sysfs_files_created'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 416ee7617d9e..5fc8ff73b7bb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -107,6 +107,7 @@ enum usb_interface_condition {
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @is_active: flag set when the interface is bound and not suspended.
+ * @sysfs_files_created: sysfs attributes exist
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
  * @dev: driver model's view of this device

commit 7e61559f6199bb387037abfc7d10a893973561fc
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Nov 6 11:43:42 2007 -0500

    USB: keep track of whether interface sysfs files exist
    
    This patch (as1009) solves the problem of multiple registrations for
    USB sysfs files in a more satisfying way than the existing code.  It
    simply adds a flag to keep track of whether or not the files have been
    created; that way the files can be created or removed as needed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c5c8f169d3cf..416ee7617d9e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -157,6 +157,7 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
+	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */

commit 271f9e68f3450ac8d1ff3bda36581f1ec0d0cc1f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Oct 10 16:30:12 2007 -0400

    USB: skip autosuspended devices during system resume
    
    System suspends and hibernation are supposed to be as transparent as
    possible.  By this reasoning, if a USB device is already autosuspended
    before the system sleep begins then it should remain autosuspended
    after the system wakes up.
    
    This patch (as1001) adds a skip_sys_resume flag to the usb_device
    structure and uses it to avoid waking up devices which were suspended
    when a system sleep began.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c10935fdc03a..c5c8f169d3cf 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -430,6 +430,7 @@ struct usb_device {
 	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
+	unsigned skip_sys_resume:1;	/* skip the next system resume */
 #endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)

commit 4d59d8a11383ebf0e0260ee481a4e766959fd7d9
Author: Sarah Sharp <sarah.a.sharp@intel.com>
Date:   Wed Oct 3 14:56:03 2007 -0700

    USB: Export URB statistics for powertop
    
    powertop currently tracks interrupts generated by uhci, ehci, and ohci,
    but it has no way of telling which USB device to blame USB bus activity on.
    This patch exports the number of URBs that are submitted for a given device.
    Cat the file 'urbnum' in /sys/bus/usb/devices/.../
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e5b35e0dca23..c10935fdc03a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -415,6 +415,7 @@ struct usb_device {
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 	u32 quirks;			/* quirks of the whole device */
+	atomic_t urbnum;		/* number of URBs submitted for the whole device */
 
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend; /* for delayed autosuspends */

commit 6840d2555afd66290be7a39b400b5e66a840b82d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 10 11:34:26 2007 -0400

    USB: flush outstanding URBs when suspending
    
    This patch (as989) makes usbcore flush all outstanding URBs for each
    device as the device is suspended.  This will be true even when
    CONFIG_USB_SUSPEND is not enabled.
    
    In addition, an extra can_submit flag is added to the usb_device
    structure.  That flag will be turned off whenever a suspend request
    has been received for the device, even if the device isn't actually
    suspended because CONFIG_USB_SUSPEND isn't set.
    
    It's no longer necessary to check for the device state being equal to
    USB_STATE_SUSPENDED during URB submission; that check can be replaced
    by a check of the can_submit flag.  This also permits us to remove
    some questionable references to the deprecated power.power_state field.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5b14b4c81fd6..e5b35e0dca23 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -383,6 +383,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
+	unsigned can_submit:1;		/* URBs may be submitted */
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	unsigned authorized:1;		/* Policy has determined we can use it */

commit 1431d2a44ccf68a547094976f363f94177ab00c6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Aug 24 15:42:39 2007 -0400

    USB: get rid of urb->lock
    
    Now that urb->status isn't used, urb->lock doesn't protect anything.
    This patch (as980) removes it and replaces it with a private mutex in
    the one remaining place it was still used: usb_kill_urb.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5c7b79088add..5b14b4c81fd6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1241,7 +1241,6 @@ struct urb
 {
 	/* private: usb core and host controller only fields in the urb */
 	struct kref kref;		/* reference count of the URB */
-	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
@@ -1299,7 +1298,6 @@ static inline void usb_fill_control_urb (struct urb *urb,
 					 usb_complete_t complete_fn,
 					 void *context)
 {
-	spin_lock_init(&urb->lock);
 	urb->dev = dev;
 	urb->pipe = pipe;
 	urb->setup_packet = setup_packet;
@@ -1330,7 +1328,6 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
 				      usb_complete_t complete_fn,
 				      void *context)
 {
-	spin_lock_init(&urb->lock);
 	urb->dev = dev;
 	urb->pipe = pipe;
 	urb->transfer_buffer = transfer_buffer;
@@ -1366,7 +1363,6 @@ static inline void usb_fill_int_urb (struct urb *urb,
 				     void *context,
 				     int interval)
 {
-	spin_lock_init(&urb->lock);
 	urb->dev = dev;
 	urb->pipe = pipe;
 	urb->transfer_buffer = transfer_buffer;

commit eb23105462304fd35571fd0cab1de7aec79a9ec5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Aug 21 15:40:36 2007 -0400

    USB: add urb->unlinked field
    
    This patch (as970) adds a new urb->unlinked field, which is used to
    store the status of unlinked URBs since we can't use urb->status for
    that purpose any more.  To help simplify the HCDs, usbcore will check
    urb->unlinked before calling the completion handler; if the value is
    set it will automatically override the status reported by the HCD.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: David Brownell <david-b@pacbell.net>
    CC: Olav Kongas <ok@artecdesign.ee>
    CC: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    CC: Tony Olech <tony.olech@elandigitalsystems.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 92d63c6b6fc6..5c7b79088add 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1245,6 +1245,7 @@ struct urb
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
+	int unlinked;			/* unlink error code */
 
 	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's

commit da04b7a42711c1d1d8d9fbc2565cdd83efcfee40
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Jul 31 20:33:57 2007 -0700

    usb: introduce usb_device authorization bits
    
    This just modifies 'struct usb_device' to contain the 'authorized'
    bit. It also adds a 'wusb' bit. This is needed because nonauthorized
    (and thus non-authenticated) wusb devices will fail certain kind of
    simple requests (such as string descriptors). By knowing the device is
    WUSB, we just avoid them.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a51f34e80572..92d63c6b6fc6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -346,6 +346,11 @@ struct usb_tt;
  *
  * Usbcore drivers should not set usbdev->state directly.  Instead use
  * usb_set_device_state().
+ *
+ * @authorized: (user space) policy determines if we authorize this
+ *              device to be used or not. By default, wired USB
+ *              devices are authorized. WUSB devices are not, until we
+ *              authorize them from user space. FIXME -- complete doc
  */
 struct usb_device {
 	int		devnum;		/* Address on USB bus */
@@ -380,6 +385,8 @@ struct usb_device {
 
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
+	unsigned authorized:1;		/* Policy has determined we can use it */
+	unsigned wusb:1;		/* Device is Wireless USB */
 	int string_langid;		/* language ID for strings */
 
 	/* static strings from the device */

commit d617bc83ff48ebf0df253605529d8b3bef15773a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Aug 2 15:04:52 2007 -0400

    USB: cleanup for previous patches
    
    This patch (as951) cleans up a few loose ends from earlier patches.
    Redundant checks for non-NULL urb->dev are removed, as are checks of
    urb->dev->bus (which can never be NULL).  Conversely, a check for
    non-NULL urb->ep is added to the unlink paths.
    
    A homegrown round-down-to-power-of-2 loop is simplified by using the
    ilog2 routine.  The comparison in usb_urb_dir_in() is made more
    transparent.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 019ae963a9fe..a51f34e80572 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1395,7 +1395,7 @@ extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
  */
 static inline int usb_urb_dir_in(struct urb *urb)
 {
-	return (urb->transfer_flags & URB_DIR_MASK) != URB_DIR_OUT;
+	return (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_IN;
 }
 
 /**

commit 5e60a16139c2a48b9876b0ff910671eee5fb32ec
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:07:21 2007 -0400

    USB: avoid using urb->pipe in usbcore
    
    This patch (as946) eliminates many of the uses of urb->pipe in
    usbcore.  Unfortunately there will have to be a significant API
    change, affecting all USB drivers, before we can remove it entirely.
    This patch contents itself with changing only the interface to
    usb_buffer_map_sg() and friends: The pipe argument is replaced with a
    direction flag.  That can be done easily because those routines get
    used in only one place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 9d08f5a5ba76..019ae963a9fe 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1422,13 +1422,13 @@ void usb_buffer_unmap (struct urb *urb);
 #endif
 
 struct scatterlist;
-int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
+int usb_buffer_map_sg(const struct usb_device *dev, int is_in,
 		      struct scatterlist *sg, int nents);
 #if 0
-void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,
 			   struct scatterlist *sg, int n_hw_ents);
 #endif
-void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,
 			 struct scatterlist *sg, int n_hw_ents);
 
 /*-------------------------------------------------------------------*

commit fea3409112a93581db18da4c4332c8bf8d68af6b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:06:16 2007 -0400

    USB: add direction bit to urb->transfer_flags
    
    This patch (as945) adds a bit to urb->transfer_flags for recording the
    direction of the URB.  The bit is set/cleared automatically in
    usb_submit_urb() so drivers don't have to worry about it (although as
    a result, it isn't valid until the URB has been submitted).  Inline
    routines are added for easily checking an URB's direction.  They
    replace calls to usb_pipein in the DMA-mapping parts of hcd.c.
    
    For non-control endpoints, the direction is determined directly from
    the endpoint descriptor.  However control endpoints are
    bi-directional; for them the direction is determined from the
    bRequestType byte and the wLength value in the setup packet.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 818a1b4f737a..9d08f5a5ba76 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1021,6 +1021,8 @@ extern int usb_disabled(void);
 
 /*
  * urb->transfer_flags:
+ *
+ * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame
@@ -1033,6 +1035,10 @@ extern int usb_disabled(void);
 					 * needed */
 #define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
 
+#define URB_DIR_IN		0x0200	/* Transfer from device to host */
+#define URB_DIR_OUT		0
+#define URB_DIR_MASK		URB_DIR_IN
+
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
 	unsigned int length;		/* expected length */
@@ -1380,6 +1386,30 @@ extern void usb_unanchor_urb(struct urb *urb);
 extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 					 unsigned int timeout);
 
+/**
+ * usb_urb_dir_in - check if an URB describes an IN transfer
+ * @urb: URB to be checked
+ *
+ * Returns 1 if @urb describes an IN transfer (device-to-host),
+ * otherwise 0.
+ */
+static inline int usb_urb_dir_in(struct urb *urb)
+{
+	return (urb->transfer_flags & URB_DIR_MASK) != URB_DIR_OUT;
+}
+
+/**
+ * usb_urb_dir_out - check if an URB describes an OUT transfer
+ * @urb: URB to be checked
+ *
+ * Returns 1 if @urb describes an OUT transfer (host-to-device),
+ * otherwise 0.
+ */
+static inline int usb_urb_dir_out(struct urb *urb)
+{
+	return (urb->transfer_flags & URB_DIR_MASK) == URB_DIR_OUT;
+}
+
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,

commit bdd016ba64d909329cb4bacacc8443901c00e112
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:05:22 2007 -0400

    USB: add ep->enable
    
    This patch (as944) adds an explicit "enabled" field to the
    usb_host_endpoint structure and uses it in place of the current
    mechanism.  This is merely a time-space tradeoff; it makes checking
    whether URBs may be submitted to an endpoint simpler.  The existing
    mechanism is efficient when converting urb->pipe to an endpoint
    pointer, but it's not so efficient when urb->ep is used instead.
    
    As a side effect, the procedure for enabling an endpoint is now a
    little more complicated.  The ad-hoc inline code in usb.c and hub.c
    for enabling ep0 is now replaced with calls to usb_enable_endpoint,
    which is no longer static.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 105e3e9362d0..818a1b4f737a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -52,6 +52,7 @@ struct ep_device;
  * @ep_dev: ep_device for sysfs info
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
+ * @enabled: URBs may be submitted to this endpoint
  *
  * USB requests are always queued to a given endpoint, identified by a
  * descriptor within an active interface in a given USB configuration.
@@ -64,6 +65,7 @@ struct usb_host_endpoint {
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
+	int enabled;
 };
 
 /* host-side wrapper for one interface setting's parsed descriptors */

commit 5b653c79c04c6b152b8dc7d18f8c8a7f77f4b235
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:04:37 2007 -0400

    USB: add urb->ep
    
    This patch (as943) prepares the way for eliminating urb->pipe by
    introducing an endpoint pointer into struct urb.  For now urb->ep
    is set by usb_submit_urb() from the pipe value; eventually drivers
    will set it themselves and we will remove urb->pipe completely.
    
    The patch also adds new inline routines to retrieve an endpoint
    descriptor's number and transfer type, essentially as replacements for
    usb_pipeendpoint and usb_pipetype.
    
    usb_submit_urb(), usb_hcd_submit_urb(), and usb_hcd_unlink_urb() are
    converted to use the new field and new routines.  Other parts of
    usbcore will be converted in later patches.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4f33a58fa9d1..105e3e9362d0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -554,6 +554,29 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
 
 /*-------------------------------------------------------------------------*/
 
+/**
+ * usb_endpoint_num - get the endpoint's number
+ * @epd: endpoint to be checked
+ *
+ * Returns @epd's number: 0 to 15.
+ */
+static inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+}
+
+/**
+ * usb_endpoint_type - get the endpoint's transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
+ * to @epd's transfer type.
+ */
+static inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+}
+
 /**
  * usb_endpoint_dir_in - check if the endpoint has IN direction
  * @epd: endpoint to be checked
@@ -1037,6 +1060,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @urb_list: For use by current owner of the URB.
  * @anchor_list: membership in the list of an anchor
  * @anchor: to anchor URBs to a common mooring
+ * @ep: Points to the endpoint's data structure.  Will eventually
+ *	replace @pipe.
  * @pipe: Holds endpoint number, direction, type, and more.
  *	Create these values with the eight macros available;
  *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is "ctrl"
@@ -1212,6 +1237,7 @@ struct urb
 	struct list_head anchor_list;	/* the URB may be anchored by the driver */
 	struct usb_anchor *anchor;
 	struct usb_device *dev; 	/* (in) pointer to associated device */
+	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint struct */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/

commit 3f423787ec87bbe601cb3242d6065616098c6cfb
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Jul 19 10:21:37 2007 -0700

    USB: usb.h kernel-doc additions
    
    Add kernel-doc entries in <linux/usb.h> for:
    
    Warning(linux-2.6.22-git12//include/linux/usb.h:162): No description found for parameter 'intf_assoc'
    Warning(linux-2.6.22-git12//include/linux/usb.h:268): No description found for parameter 'intf_assoc[USB_MAXIADS]'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 7a60946df3b6..4f33a58fa9d1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -94,6 +94,7 @@ enum usb_interface_condition {
  * 	endpoint configurations.  They will be in no particular order.
  * @num_altsetting: number of altsettings defined.
  * @cur_altsetting: the current altsetting.
+ * @intf_assoc: interface association descriptor
  * @driver: the USB driver that is bound to this interface.
  * @minor: the minor number assigned to this interface, if this
  *	interface is bound to a driver that uses the USB major number.
@@ -213,6 +214,7 @@ struct usb_interface_cache {
  * @desc: the device's configuration descriptor.
  * @string: pointer to the cached version of the iConfiguration string, if
  *	present for this configuration.
+ * @intf_assoc: list of any interface association descriptors in this config
  * @interface: array of pointers to usb_interface structures, one for each
  *	interface in the configuration.  The number of interfaces is stored
  *	in desc.bNumInterfaces.  These pointers are valid only while the

commit 165fe97ed6107d3cde63592d5ac36400a5eb9f6f
Author: Craig W. Nadler <craig@nadler.us>
Date:   Fri Jun 15 23:14:35 2007 -0400

    USB: add IAD support to usbfs and sysfs
    
    USB_IAD: Adds support for USB Interface Association Descriptors.
    
    This patch adds support to the USB host stack for parsing, storing, and
    displaying Interface Association Descriptors. In /proc/bus/usb/devices
    lines starting with A: show the fields in an IAD. In sysfs if an
    interface on a USB device is referenced by an IAD the following files
    will be added to the sysfs directory for that interface:
    iad_bFirstInterface, iad_bInterfaceCount, iad_bFunctionClass, and
    iad_bFunctionSubClass, iad_bFunctionProtocol
    
    Signed-off-by: Craig W. Nadler <craig@nadler.us>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 533c32374e01..7a60946df3b6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -146,6 +146,10 @@ struct usb_interface {
 					 * active alternate setting */
 	unsigned num_altsetting;	/* number of alternate settings */
 
+	/* If there is an interface association descriptor then it will list
+	 * the associated interfaces */
+	struct usb_interface_assoc_descriptor *intf_assoc;
+
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
@@ -175,6 +179,7 @@ void usb_put_intf(struct usb_interface *intf);
 
 /* this maximum is arbitrary */
 #define USB_MAXINTERFACES	32
+#define USB_MAXIADS		USB_MAXINTERFACES/2
 
 /**
  * struct usb_interface_cache - long-term representation of a device interface
@@ -245,6 +250,11 @@ struct usb_host_config {
 	struct usb_config_descriptor	desc;
 
 	char *string;		/* iConfiguration string, if present */
+
+	/* List of any Interface Association Descriptors in this
+	 * configuration. */
+	struct usb_interface_assoc_descriptor *intf_assoc[USB_MAXIADS];
+
 	/* the interfaces associated with this configuration,
 	 * stored in no particular order */
 	struct usb_interface *interface[USB_MAXINTERFACES];

commit 8b3b01c898a44c2fc7217eb579982b9d132113f5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jun 13 08:02:11 2007 +0200

    USB: Add URB_FREE_BUFFER flag and the logic behind it
    
    USB: Add URB_FREE_BUFFER flag for freeing the transfer buffer
    
    In some cases it is not needed that the driver keeps track of the
    transfer buffer of an URB. It can be simply freed along with the
    URB itself when the reference count goes down to zero. The new
    flag URB_FREE_BUFFER enables this behavior.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index efce9a4c511c..533c32374e01 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -994,6 +994,7 @@ extern int usb_disabled(void);
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
 					 * needed */
+#define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
 
 struct usb_iso_packet_descriptor {
 	unsigned int offset;

commit b41a60eca833d76593d4dac8a59f5c38714194ee
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 15:39:33 2007 -0400

    USB: add power/persist device attribute
    
    This patch (as920) adds an extra level of protection to the
    USB-Persist facility.  Now it will apply by default only to hubs; for
    all other devices the user must enable it explicitly by setting the
    power/persist device attribute.
    
    The disconnect_all_children() routine in hub.c has been removed and
    its code placed inline.  This is the way it was originally as part of
    hub_pre_reset(); the revised usage in hub_reset_resume() is
    sufficiently different that the code can no longer be shared.
    Likewise, mark_children_for_reset() is now inline as part of
    hub_reset_resume().  The end result looks much cleaner than before.
    
    The sysfs interface is updated to add the new attribute file, and
    there are corresponding documentation updates.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index bde8c65e2bfc..efce9a4c511c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -404,6 +404,7 @@ struct usb_device {
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 	unsigned reset_resume:1;	/* needs reset instead of resume */
+	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 #endif

commit f07600cf9eb3ee92777b2001e564faa413144a99
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 15:38:16 2007 -0400

    USB: add reset_resume method
    
    This patch (as918) introduces a new USB driver method: reset_resume.
    It is called when a device needs to be reset as part of a resume
    procedure (whether because of a device quirk or because of the
    USB-Persist facility), thereby taking over a role formerly assigned to
    the post_reset method.  As a consequence, post_reset no longer needs
    an argument indicating whether it is being called as part of a
    reset-resume.  This separation of functions makes the code clearer.
    
    In addition, the pre_reset and post_reset method return types are
    changed; they now must return an error code.  The return value is
    unused at present, but at some later time we may unbind drivers and
    re-probe if they encounter an error during reset handling.
    
    The existing pre_reset and post_reset methods in the usbhid,
    usb-storage, and hub drivers are updated to match the new
    requirements.  For usbhid the post_reset routine is also used for
    reset_resume (duplicate method pointers); for the other drivers a new
    reset_resume routine is added.  The change to hub.c looks bigger than
    it really is, because mark_children_for_reset_resume() gets moved down
    next to the new hub_reset_resume() routine.
    
    A minor change to usb-storage makes the usb_stor_report_bus_reset()
    routine acquire the host lock instead of requiring the caller to hold
    it already.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    CC: Matthew Dharm <mdharm-usb@one-eyed-alien.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0873c6219efc..bde8c65e2bfc 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -839,6 +839,8 @@ struct usbdrv_wrap {
  *	do (or don't) show up otherwise in the filesystem.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @reset_resume: Called when the suspended device has been reset instead
+ *	of being resumed.
  * @pre_reset: Called by usb_reset_composite_device() when the device
  *	is about to be reset.
  * @post_reset: Called by usb_reset_composite_device() after the device
@@ -885,9 +887,10 @@ struct usb_driver {
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
+	int (*reset_resume)(struct usb_interface *intf);
 
-	void (*pre_reset) (struct usb_interface *intf);
-	void (*post_reset) (struct usb_interface *intf, int reset_resume);
+	int (*pre_reset)(struct usb_interface *intf);
+	int (*post_reset)(struct usb_interface *intf);
 
 	const struct usb_device_id *id_table;
 

commit 51a2f077c44e559841b09de6da605b4d3ae40dad
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri May 25 13:40:56 2007 +0200

    USB: introduce usb_anchor
    
    - introduction of usb_anchor and its methods
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 98e0338664fb..0873c6219efc 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1000,11 +1000,26 @@ struct usb_iso_packet_descriptor {
 
 struct urb;
 
+struct usb_anchor {
+	struct list_head urb_list;
+	wait_queue_head_t wait;
+	spinlock_t lock;
+};
+
+static inline void init_usb_anchor(struct usb_anchor *anchor)
+{
+	INIT_LIST_HEAD(&anchor->urb_list);
+	init_waitqueue_head(&anchor->wait);
+	spin_lock_init(&anchor->lock);
+}
+
 typedef void (*usb_complete_t)(struct urb *);
 
 /**
  * struct urb - USB Request Block
  * @urb_list: For use by current owner of the URB.
+ * @anchor_list: membership in the list of an anchor
+ * @anchor: to anchor URBs to a common mooring
  * @pipe: Holds endpoint number, direction, type, and more.
  *	Create these values with the eight macros available;
  *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is "ctrl"
@@ -1177,6 +1192,8 @@ struct urb
 	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's
 					 * current owner */
+	struct list_head anchor_list;	/* the URB may be anchored by the driver */
+	struct usb_anchor *anchor;
 	struct usb_device *dev; 	/* (in) pointer to associated device */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
@@ -1312,6 +1329,11 @@ extern struct urb *usb_get_urb(struct urb *urb);
 extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
+extern void usb_kill_anchored_urbs(struct usb_anchor *anchor);
+extern void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor);
+extern void usb_unanchor_urb(struct urb *urb);
+extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
+					 unsigned int timeout);
 
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);

commit 8538f96ae5aada1c04d69a993b20ad160b191d47
Author: Daniel Drake <dsd@gentoo.org>
Date:   Thu May 10 00:32:24 2007 +0100

    USB: add USB_DEVICE_AND_INTERFACE_INFO for device matching
    
    Recently, the USB device matching code stopped matching generic interface
    matches against devices with vendor-specific device class values.
    
    Some drivers now need to explicitly match USB device ID's (in addition to
    generic interface info) to retain the same behaviour as before. This new macro,
    suggested by Alan Stern, makes the explicit device/interface matching a little
    simpler for those users.
    
    Signed-off-by: Daniel Drake <dsd@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3d63e0c2dd70..98e0338664fb 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -771,6 +771,28 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), \
 	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
 
+/**
+ * USB_DEVICE_AND_INTERFACE_INFO - macro used to describe a specific usb device
+ * 		with a class of usb interfaces
+ * @vend: the 16 bit USB Vendor ID
+ * @prod: the 16 bit USB Product ID
+ * @cl: bInterfaceClass value
+ * @sc: bInterfaceSubClass value
+ * @pr: bInterfaceProtocol value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific device with a specific class of interfaces.
+ *
+ * This is especially useful when explicitly matching devices that have
+ * vendor specific bDeviceClass values, but standards-compliant interfaces.
+ */
+#define USB_DEVICE_AND_INTERFACE_INFO(vend,prod,cl,sc,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
+		| USB_DEVICE_ID_MATCH_DEVICE, \
+	.idVendor = (vend), .idProduct = (prod), \
+	.bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+
 /* ----------------------------------------------------------------------- */
 
 /* Stuff for dynamic usb ids */

commit 0458d5b4c9cc4ca0f62625d0144ddc4b4bc97a3c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:52:20 2007 -0400

    USB: add USB-Persist facility
    
    This patch (as886) adds the controversial USB-persist facility,
    allowing USB devices to persist across a power loss during system
    suspend.
    
    The facility is controlled by a new Kconfig option (with appropriate
    warnings about the potential dangers); when the option is off the
    behavior will remain the same as it is now.  But when the option is
    on, people will be able to use suspend-to-disk and keep their USB
    filesystems intact -- something particularly valuable for small
    machines where the root filesystem is on a USB device!
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 56aa2ee21f1b..3d63e0c2dd70 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -403,6 +403,7 @@ struct usb_device {
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+	unsigned reset_resume:1;	/* needs reset instead of resume */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 #endif
@@ -819,7 +820,10 @@ struct usbdrv_wrap {
  * @pre_reset: Called by usb_reset_composite_device() when the device
  *	is about to be reset.
  * @post_reset: Called by usb_reset_composite_device() after the device
- *	has been reset.
+ *	has been reset, or in lieu of @resume following a reset-resume
+ *	(i.e., the device is reset instead of being resumed, as might
+ *	happen if power was lost).  The second argument tells which is
+ *	the reason.
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
@@ -861,7 +865,7 @@ struct usb_driver {
 	int (*resume) (struct usb_interface *intf);
 
 	void (*pre_reset) (struct usb_interface *intf);
-	void (*post_reset) (struct usb_interface *intf);
+	void (*post_reset) (struct usb_interface *intf, int reset_resume);
 
 	const struct usb_device_id *id_table;
 

commit f836ac808f031e84d7d73a3540f30f38036bb41e
Author: Jan Kratochvil <honza@jikos.cz>
Date:   Wed May 9 00:26:15 2007 -0400

    USB: Add USB_DEVICE_INTERFACE_PROTOCOL macro
    
    The USB_DEVICE_INTERFACE_PROTOCOL will allow to match one interface
    protocol of vendor specific device. This macro is used in patch adding
    support for xbox360 to xpad.c
    
    Signed-off-by: Jan Kratochvil <honza@jikos.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 94bd38a6d947..56aa2ee21f1b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -728,6 +728,22 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
 	.idVendor = (vend), .idProduct = (prod), \
 	.bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
 
+/**
+ * USB_DEVICE_INTERFACE_PROTOCOL - macro used to describe a usb
+ *		device with a specific interface protocol
+ * @vend: the 16 bit USB Vendor ID
+ * @prod: the 16 bit USB Product ID
+ * @pr: bInterfaceProtocol value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific interface protocol of devices.
+ */
+#define USB_DEVICE_INTERFACE_PROTOCOL(vend,prod,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_INT_PROTOCOL, \
+	.idVendor = (vend), \
+	.idProduct = (prod), \
+	.bInterfaceProtocol = (pr)
+
 /**
  * USB_DEVICE_INFO - macro used to describe a class of usb devices
  * @cl: bDeviceClass value

commit 59c51591a0ac7568824f541f57de967e88adaa07
Author: Michael Opdenacker <michael@free-electrons.com>
Date:   Wed May 9 08:57:56 2007 +0200

    Fix occurrences of "the the "
    
    Signed-off-by: Michael Opdenacker <michael@free-electrons.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cfbd2bb8fa2c..94bd38a6d947 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -126,7 +126,7 @@ enum usb_interface_condition {
  * Each interface may have alternate settings.  The initial configuration
  * of a device sets altsetting 0, but the device driver can change
  * that setting using usb_set_interface().  Alternate settings are often
- * used to control the the use of periodic endpoints, such as by having
+ * used to control the use of periodic endpoints, such as by having
  * different endpoints use different amounts of reserved USB bandwidth.
  * All standards-conformant USB devices that use isochronous endpoints
  * will use them in non-default settings.

commit 1941044aa9632aa8debbb94a3c8a5ed0ebddade8
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Mar 27 13:33:59 2007 -0400

    USB: add "last_busy" field for use in autosuspend
    
    This patch (as877) adds a "last_busy" field to struct usb_device, for
    use by the autosuspend framework.  Now if an autosuspend call comes at
    a time when the device isn't busy but hasn't yet been idle for long
    enough, the timer can be set to exactly the desired value.  And we
    will be ready to handle things like HID drivers, which can't maintain
    a useful usage count and must rely on the time-of-last-use to decide
    when to autosuspend.
    
    The patch also makes some related minor improvements:
    
            Move the calls to the autosuspend condition-checking routine
            into usb_suspend_both(), which is the only place where it
            really matters.
    
            If the autosuspend timer is already running, don't stop
            and restart it.
    
            Replace immediate returns with gotos so that the optional
            debugging ouput won't be bypassed.
    
            If autoresume is disabled but the device is already awake,
            don't return an error for an autoresume call.
    
            Don't try to autoresume a device if it isn't suspended.
            (Yes, this undercuts the previous change -- so sue me.)
    
            Don't duplicate existing code in the autosuspend work routine.
    
            Fix the kerneldoc in usb_autopm_put_interface(): If an
            autoresume call fails, the usage counter is left unchanged.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f9e4445d5b53..cfbd2bb8fa2c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -398,6 +398,7 @@ struct usb_device {
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
+	unsigned long last_busy;	/* time of last use */
 	int autosuspend_delay;		/* in jiffies */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
@@ -443,6 +444,11 @@ static inline void usb_autopm_disable(struct usb_interface *intf)
 	usb_autopm_set_interface(intf);
 }
 
+static inline void usb_mark_last_busy(struct usb_device *udev)
+{
+	udev->last_busy = jiffies;
+}
+
 #else
 
 static inline int usb_autopm_set_interface(struct usb_interface *intf)
@@ -457,6 +463,8 @@ static inline void usb_autopm_enable(struct usb_interface *intf)
 { }
 static inline void usb_autopm_disable(struct usb_interface *intf)
 { }
+static inline void usb_mark_last_busy(struct usb_device *udev)
+{ }
 #endif
 
 /*-------------------------------------------------------------------------*/

commit 9f8b17e643fe6aa505629658445849397bda4e4f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Mar 13 15:59:31 2007 +0100

    USB: make usbdevices export their device nodes instead of using a separate class
    
    o The "real" usb-devices export now a device node which can
      populate /dev/bus/usb.
    
    o The usb_device class is optional now and can be disabled in the
      kernel config. Major/minor of the "real" devices and class devices
      are the same.
    
    o The environment of the usb-device event contains DEVNUM and BUSNUM to
      help udev and get rid of the ugly udev rule we need for the class
      devices.
    
    o The usb-devices and usb-interfaces share the same bus, so I used
      the new "struct device_type" to let these devices identify
      themselves. This also removes the current logic of using a magic
      platform-pointer.
      The name of the device_type is also added to the environment
      which makes it easier to distinguish the different kinds of devices
      on the same subsystem.
    
      It looks like this:
        add@/devices/pci0000:00/0000:00:1d.1/usb2/2-1
        ACTION=add
        DEVPATH=/devices/pci0000:00/0000:00:1d.1/usb2/2-1
        SUBSYSTEM=usb
        SEQNUM=1533
        MAJOR=189
        MINOR=131
        DEVTYPE=usb_device
        PRODUCT=46d/c03e/2000
        TYPE=0/0/0
        BUSNUM=002
        DEVNUM=004
    
    This udev rule works as a replacement for usb_device class devices:
      SUBSYSTEM=="usb", ACTION=="add", ENV{DEVTYPE}=="usb_device", \
        NAME="bus/usb/$env{BUSNUM}/$env{DEVNUM}", MODE="0644"
    
    Updated patch, which needs the device_type patches in Greg's tree.
    
    I also got a bugzilla assigned for this. :)
      https://bugzilla.novell.com/show_bug.cgi?id=250659
    
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5e8e144afbae..f9e4445d5b53 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -299,8 +299,9 @@ struct usb_bus {
 	int bandwidth_int_reqs;		/* number of Interrupt requests */
 	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
 
+#ifdef CONFIG_USB_DEVICEFS
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
-
+#endif
 	struct class_device *class_dev;	/* class device for this bus */
 
 #if defined(CONFIG_USB_MON)
@@ -373,9 +374,12 @@ struct usb_device {
 	char *serial;			/* iSerialNumber string, if present */
 
 	struct list_head filelist;
-	struct device *usbfs_dev;
+#ifdef CONFIG_USB_DEVICE_CLASS
+	struct device *usb_classdev;
+#endif
+#ifdef CONFIG_USB_DEVICEFS
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
-
+#endif
 	/*
 	 * Child devices - these can be either new devices
 	 * (if this is a hub device), or different instances

commit 2add5229d77a3de08015feef437653e02372162f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Mar 20 14:59:39 2007 -0400

    USB: add power/level sysfs attribute
    
    This patch (as874) adds another piece to the user-visible part of the
    USB autosuspend interface.  The new power/level sysfs attribute allows
    users to force the device on (with autosuspend off), force the device
    to sleep (with autoresume off), or return to normal automatic operation.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index cc24d089faa0..5e8e144afbae 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -398,6 +398,8 @@ struct usb_device {
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
+	unsigned autoresume_disabled:1;  /*  disabled by the user */
 #endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)

commit eaafbc3a8adab16babe2c20e54ad3ba40d1fbbc9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Mar 13 16:39:15 2007 -0400

    USB: Allow autosuspend delay to equal 0
    
    This patch (as867) adds an entry for the new power/autosuspend
    attribute in Documentation/ABI/testing, and it changes the behavior of
    the delay value.  Now a delay of 0 means to autosuspend as soon as
    possible, and negative values will prevent autosuspend.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 87dc75a6cee1..cc24d089faa0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -394,7 +394,7 @@ struct usb_device {
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
-	unsigned autosuspend_delay;	/* in jiffies */
+	int autosuspend_delay;		/* in jiffies */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */

commit b5e795f8df42936590ba9c606edc715fe3593284
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Feb 20 15:00:53 2007 -0500

    USB: make autosuspend delay a module parameter
    
    This patch (as859) makes the default USB autosuspend delay a module
    parameter of usbcore.  By setting the delay value at boot time, users
    will be able to prevent the system from autosuspending devices which
    for some reason can't handle it.
    
    The patch also stores the autosuspend delay as a per-device value.  A
    later patch will allow the user to change the value, tailoring the
    delay for each individual device.  A delay value of 0 will prevent
    autosuspend.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 37e522eba47f..87dc75a6cee1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -389,10 +389,13 @@ struct usb_device {
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 	u32 quirks;			/* quirks of the whole device */
+
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
+	unsigned autosuspend_delay;	/* in jiffies */
+
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 #endif

commit 7ceec1f1d26f966c0816b86a1aab1e0b3b208757
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Jan 26 14:26:21 2007 +0100

    USB: add a blacklist for devices that can't handle some things we throw at them.
    
    This adds a blacklist to the USB core to handle some autosuspend and
    string issues that devices have.
    
    Originally written by Oliver, but hacked up a lot by Greg.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a8e8d1ecebb1..37e522eba47f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -388,6 +388,7 @@ struct usb_device {
 	struct usb_device *children[USB_MAXCHILDREN];
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
+	u32 quirks;			/* quirks of the whole device */
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */

commit d1bbb60007597b920beca72cd0b413d10290310a
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Sun Feb 11 13:56:13 2007 -0800

    USB: make usb_iso_packet_descriptor.status signed
    
    The status in usb_iso_packet_descriptor should be signed, for the benefit
    of someone who casts to a long or makes other benign misstep (the principle
    of least surprise).
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b5c226a87ed8..a8e8d1ecebb1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -935,7 +935,7 @@ struct usb_iso_packet_descriptor {
 	unsigned int offset;
 	unsigned int length;		/* expected length */
 	unsigned int actual_length;
-	unsigned int status;
+	int status;
 };
 
 struct urb;

commit c96e2c92072d3e78954c961f53d8c7352f7abbd7
Merge: f2aca47dc3c2 64358164f5bf
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Feb 7 19:23:21 2007 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/usb-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/usb-2.6: (70 commits)
      USB: remove duplicate device id from zc0301
      USB: remove duplicate device id from usb_storage
      USB: remove duplicate device id from keyspan
      USB: remove duplicate device id from ftdi_sio
      USB: remove duplicate device id from visor
      USB: a bit more coding style cleanup
      usbcore: trivial whitespace fixes
      usb-storage: use first bulk endpoints, not last
      EHCI: fix interrupt-driven remote wakeup
      USB: switch ehci-hcd to new polling scheme
      USB: autosuspend for usb printer driver
      USB Input: Added kernel module to support all GTCO CalComp USB InterWrite School products
      USB: Sierra Wireless auto set D0
      USB: usb ethernet gadget recognizes HUSB2DEV
      USB: list atmel husb2_udc gadget controller
      USB: gadgetfs AIO tweaks
      USB: gadgetfs behaves better on userspace init bug
      USB: gadgetfs race fix
      USB: gadgetfs simplifications
      USB: gadgetfs cleanups
      ...

commit 896fbd7199035958013d106329843d8ae9618753
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 16 11:57:13 2007 -0500

    usbcore: remove unused bandwith-related code
    
    This patch (as841) removes from usbcore a couple of support routines
    meant to help with bandwidth allocation.  With the changes to uhci-hcd
    in the previous patch, these routines are no longer used anywhere.
    Also removed is the CONFIG_USB_BANDWIDTH option; it no longer does
    anything and is no longer needed since the HCDs now handle bandwidth
    issues correctly.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1c56386de709..3b08ab39550f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1110,7 +1110,6 @@ struct urb
 	struct kref kref;		/* reference count of the URB */
 	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
-	int bandwidth;			/* bandwidth for INT/ISO request */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
 

commit a8ef36bc0a5fe973bddaa54a5a07cda29e04a602
Author: Sarah Bailey <saharabeara@gmail.com>
Date:   Sat Dec 23 23:14:58 2006 -0800

    USB: Add usb_endpoint_xfer_control to usb.h
    
    Added a function to check if an endpoint is a control endpoint.
    There were similar functions for bulk, interrupt, and isoc,
    but not for control endpoints.
    
    Signed-off-by: Sarah Bailey <saharabeara@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3cb9285df2d1..1c56386de709 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -556,6 +556,18 @@ static inline int usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *e
 		USB_ENDPOINT_XFER_BULK);
 }
 
+/**
+ * usb_endpoint_xfer_control - check if the endpoint has control transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type control, otherwise it returns false.
+ */
+static inline int usb_endpoint_xfer_control(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_CONTROL);
+}
+
 /**
  * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type
  * @epd: endpoint to be checked

commit 93bacefc4cc0b53e1cb6a336d43847154fdf6886
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sun Dec 17 21:50:23 2006 +0100

    USB serial: add dynamic id support to usb-serial core
    
    Thanks to Johannes Hlzl <johannes.hoelzl@gmx.de> for fixing a few
    things and getting it all working properly.
    
    This adds support for dynamic usb ids to the usb serial core.  The file
    "new_id" will show up under the usb serial driver, not the usb driver
    associated with the usb-serial driver (yeah, it can be a bit confusing
    at first glance...)
    
    This patch also modifies the USB core to allow the usb-serial core to
    reuse much of the dynamic id logic.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Johannes Hlzl <johannes.hoelzl@gmx.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f3b21636c9df..3cb9285df2d1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -476,6 +476,8 @@ extern void usb_driver_release_interface(struct usb_driver *driver,
 			struct usb_interface *iface);
 const struct usb_device_id *usb_match_id(struct usb_interface *interface,
 					 const struct usb_device_id *id);
+extern int usb_match_one_id(struct usb_interface *interface,
+			    const struct usb_device_id *id);
 
 extern struct usb_interface *usb_find_interface(struct usb_driver *drv,
 		int minor);
@@ -724,11 +726,21 @@ static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor
 
 /* ----------------------------------------------------------------------- */
 
+/* Stuff for dynamic usb ids */
 struct usb_dynids {
 	spinlock_t lock;
 	struct list_head list;
 };
 
+struct usb_dynid {
+	struct list_head node;
+	struct usb_device_id id;
+};
+
+extern ssize_t usb_store_new_id(struct usb_dynids *dynids,
+				struct device_driver *driver,
+				const char *buf, size_t count);
+
 /**
  * struct usbdrv_wrap - wrapper for driver-model structure
  * @driver: The driver-model core driver structure.

commit 5f848137744106ee737f559454ce5adfceb38347
Author: David Brownell <david-b@pacbell.net>
Date:   Sat Dec 16 15:34:53 2006 -0800

    USB: <linux/usb_ch9.h> becomes <linux/usb/ch9.h>
    
    This moves <linux/usb_ch9.h> to <linux/usb/ch9.h> to reduce some of the
    clutter of usb header files.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d6bf1297d886..f3b21636c9df 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -2,7 +2,7 @@
 #define __LINUX_USB_H
 
 #include <linux/mod_devicetable.h>
-#include <linux/usb_ch9.h>
+#include <linux/usb/ch9.h>
 
 #define USB_MAJOR			180
 #define USB_DEVICE_MAJOR		189

commit 0873c76485c126a4df70a6961fd354b21b7987f7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 20 13:09:50 2006 -0700

    USB: convert usb class devices to real devices
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f18ced001924..d6bf1297d886 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -107,7 +107,8 @@ enum usb_interface_condition {
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
  * @dev: driver model's view of this device
- * @class_dev: driver model's class view of this device.
+ * @usb_dev: if an interface is bound to the USB major, this will point
+ *	to the sysfs representation for that device.
  * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
  *	allowed unless the counter is 0.
  *
@@ -152,7 +153,7 @@ struct usb_interface {
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */
-	struct class_device *class_dev;
+	struct device *usb_dev;		/* pointer to the usb class's device, if any */
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)

commit 7bc3d635628db100c024aca7f836a18188e9bb62
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 19 23:59:31 2006 -0700

    USB: move usb_device_class class devices to be real devices
    
    This moves the usb class devices that control the usbfs nodes to show up
    in the proper place in the larger device tree.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index aab5b1b72021..f18ced001924 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -372,7 +372,7 @@ struct usb_device {
 	char *serial;			/* iSerialNumber string, if present */
 
 	struct list_head filelist;
-	struct class_device *class_dev;
+	struct device *usbfs_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
 
 	/*

commit 80f745fb1b0fb11383cbb8df2c36aaaa0399b6e6
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jan 15 11:50:02 2007 -0800

    USB: add the sysfs driver name to all modules
    
    This adds the module name to all USB drivers, if they are built into the
    kernel or not.  It will show up in /sys/modules/MODULE_NAME/drivers/
    
    Cc: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index aab5b1b72021..733f38de4978 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -868,10 +868,11 @@ struct usb_class_driver {
  * use these in module_init()/module_exit()
  * and don't forget MODULE_DEVICE_TABLE(usb, ...)
  */
-extern int usb_register_driver(struct usb_driver *, struct module *);
+extern int usb_register_driver(struct usb_driver *, struct module *,
+			       const char *);
 static inline int usb_register(struct usb_driver *driver)
 {
-	return usb_register_driver(driver, THIS_MODULE);
+	return usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME);
 }
 extern void usb_deregister(struct usb_driver *);
 

commit 4c1ac1b49122b805adfa4efc620592f68dccf5db
Merge: c4028958b6ec d916faace3ef
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 14:37:56 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/infiniband/core/iwcm.c
            drivers/net/chelsio/cxgb2.c
            drivers/net/wireless/bcm43xx/bcm43xx_main.c
            drivers/net/wireless/prism54/islpci_eth.c
            drivers/usb/core/hub.h
            drivers/usb/input/hid-core.c
            net/core/netpoll.c
    
    Fix up merge failures with Linus's head and fix new compilation failures.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit ee49fb5dc89d34f1794ac9362fa97c1a640f7ddd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 22 16:55:54 2006 -0500

    USB: keep count of unsuspended children
    
    This patch (as818b) simplifies autosuspend processing by keeping track
    of the number of unsuspended children of each USB hub.  This will
    permit us to avoid a good deal of unnecessary work all the time; we
    will no longer have to create a bunch of workqueue entries to carry
    out autosuspend requests, only to have them fail because one of the
    hub's children isn't suspended.
    
    The basic idea is simple.  There already is a usage counter in the
    usb_device structure for preventing autosuspends.  The patch just
    increments that counter for every unsuspended child.  There's only one
    tricky part: When a device disconnects we need to remember whether it
    was suspended at the time (leave the counter alone) or not (decrement
    the counter).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5634a2d91ec0..0cd73edeef13 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,6 +362,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
+	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 

commit ce3615879ae85373c03744b45b7c2d7ae5e29b2a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 20 11:12:22 2006 -0500

    USB: struct usb_device: change flag to bitflag
    
    This patch (as816) changes an existing flag in the usb_device
    structure to a bitflag, preparing the way for more bitflags to come
    in the future.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 864c6c21c21e..5634a2d91ec0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,7 +362,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
-	int have_langid;		/* whether string_langid is valid */
+	unsigned have_langid:1;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
 	/* static strings from the device */

commit 692a186c9d5f12d43cef28d40c25247dc4f302f0
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 30 17:07:51 2006 -0500

    USB: expand autosuspend/autoresume API
    
    This patch (as814) adds usb_autopm_set_interface() to the autosuspend
    API.  It also provides convenient wrapper routines,
    usb_autopm_enable() and usb_autopm_disable(), for drivers that want
    to specify directly whether autosuspend should be allowed.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e732e024a141..864c6c21c21e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -415,14 +415,37 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
+extern int usb_autopm_set_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 
+static inline void usb_autopm_enable(struct usb_interface *intf)
+{
+	intf->pm_usage_cnt = 0;
+	usb_autopm_set_interface(intf);
+}
+
+static inline void usb_autopm_disable(struct usb_interface *intf)
+{
+	intf->pm_usage_cnt = 1;
+	usb_autopm_set_interface(intf);
+}
+
 #else
-#define usb_autopm_get_interface(intf)		0
-#define usb_autopm_put_interface(intf)		do {} while (0)
-#endif
 
+static inline int usb_autopm_set_interface(struct usb_interface *intf)
+{ return 0; }
+
+static inline int usb_autopm_get_interface(struct usb_interface *intf)
+{ return 0; }
+
+static inline void usb_autopm_put_interface(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_enable(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_disable(struct usb_interface *intf)
+{ }
+#endif
 
 /*-------------------------------------------------------------------------*/
 

commit 0c1ac4f25f894f9df0ffe9b912c165fb6a185a3c
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Mon Oct 30 14:53:03 2006 -0300

    USB: makes usb_endpoint_* functions inline.
    
    We have no benefits of having the usb_endpoint_* functions as functions,
    but making them inline saves text and data segment sizes:
    
    text       data     bss     dec     hex filename
    14893634        3108770 1108840 19111244        1239d4c vmlinux.func
    14893185        3108566 1108840 19110591        1239abf vmlinux.inline
    
     This is the result of a 2.6.19-rc3 kernel compiled with GCC 4.1.1 without
    CONFIG_MODULES, CONFIG_CC_OPTIMIZE_FOR_SIZE, CONFIG_REGPARM options set.
    USB support is fully enabled (while most of the other drivers are not),
    and that kernel has most of the USB code ported to use the endpoint
    functions.
    
    That happens because a call to those functions are expensive (in terms
    of bytes), while the function's size is smaller or have the same 'size' of
    the call.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e5cb1690975a..e732e024a141 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -495,17 +495,137 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
 
 /*-------------------------------------------------------------------------*/
 
-extern int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_xfer_isoc(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_is_int_out(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_is_isoc_in(const struct usb_endpoint_descriptor *epd);
-extern int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor *epd);
+/**
+ * usb_endpoint_dir_in - check if the endpoint has IN direction
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type IN, otherwise it returns false.
+ */
+static inline int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);
+}
+
+/**
+ * usb_endpoint_dir_out - check if the endpoint has OUT direction
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type OUT, otherwise it returns false.
+ */
+static inline int usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
+}
+
+/**
+ * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type bulk, otherwise it returns false.
+ */
+static inline int usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_BULK);
+}
+
+/**
+ * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type interrupt, otherwise it returns
+ * false.
+ */
+static inline int usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_INT);
+}
+
+/**
+ * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint is of type isochronous, otherwise it returns
+ * false.
+ */
+static inline int usb_endpoint_xfer_isoc(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==
+		USB_ENDPOINT_XFER_ISOC);
+}
+
+/**
+ * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has bulk transfer type and IN direction,
+ * otherwise it returns false.
+ */
+static inline int usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_in(epd));
+}
+
+/**
+ * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has bulk transfer type and OUT direction,
+ * otherwise it returns false.
+ */
+static inline int usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_bulk(epd) && usb_endpoint_dir_out(epd));
+}
+
+/**
+ * usb_endpoint_is_int_in - check if the endpoint is interrupt IN
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has interrupt transfer type and IN direction,
+ * otherwise it returns false.
+ */
+static inline int usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_in(epd));
+}
+
+/**
+ * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has interrupt transfer type and OUT direction,
+ * otherwise it returns false.
+ */
+static inline int usb_endpoint_is_int_out(const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_int(epd) && usb_endpoint_dir_out(epd));
+}
+
+/**
+ * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has isochronous transfer type and IN direction,
+ * otherwise it returns false.
+ */
+static inline int usb_endpoint_is_isoc_in(const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_in(epd));
+}
+
+/**
+ * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT
+ * @epd: endpoint to be checked
+ *
+ * Returns true if the endpoint has isochronous transfer type and OUT direction,
+ * otherwise it returns false.
+ */
+static inline int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor *epd)
+{
+	return (usb_endpoint_xfer_isoc(epd) && usb_endpoint_dir_out(epd));
+}
 
 /*-------------------------------------------------------------------------*/
 

commit 437052516779fea608261a50682b124315f48f01
Author: inaky@linux.intel.com <inaky@linux.intel.com>
Date:   Wed Oct 11 20:05:58 2006 -0700

    usb/hub: allow hubs up to 31 children
    
    Current Wireless USB host hardware (Intel i1480 for example) allows up
    to 22 devices to connect, thus bringing up the max number of children
    in the WUSB Host Controller to 22 'fake' ports. Upcoming hardware
    might raise that limit.
    
    Makes almost no difference to go to 31, as the bit arrays are
    byte-aligned (plus an extra bit in general), so 22 bits fit in 4 bytes
    as 31 do.
    
    As well, the only other array that depends on USB_MAXCHILDREN is
    'struct usb_hub->indicator'. By declaring it 'u8' instead of 'enum
    hub_led_mode', we reduce the size of each entry from 4 bytes (in i386)
    to 1, which will add as we when are doubling USB_MAXCHILDREN
    (with 16 the size of that array is 64 bytes, with 31 would be 128; by
    using u8 that goes down to 31 bytes).
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5482bfb3303d..e5cb1690975a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -313,8 +313,13 @@ struct usb_bus {
 /* This is arbitrary.
  * From USB 2.0 spec Table 11-13, offset 7, a hub can
  * have up to 255 ports. The most yet reported is 10.
+ *
+ * Current Wireless USB host hardware (Intel i1480 for example) allows
+ * up to 22 devices to connect. Upcoming hardware might raise that
+ * limit. Because the arrays need to add a bit for hub status data, we
+ * do 31, so plus one evens out to four bytes.
  */
-#define USB_MAXCHILDREN		(16)
+#define USB_MAXCHILDREN		(31)
 
 struct usb_tt;
 

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5482bfb3303d..06ce7a626040 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -382,7 +382,7 @@ struct usb_device {
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 #ifdef CONFIG_PM
-	struct work_struct autosuspend;	/* for delayed autosuspends */
+	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 190cc1b78fe2..5482bfb3303d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -764,9 +764,8 @@ struct usb_iso_packet_descriptor {
 };
 
 struct urb;
-struct pt_regs;
 
-typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
+typedef void (*usb_complete_t)(struct urb *);
 
 /**
  * struct urb - USB Request Block

commit e0318ebff4d96131bb3524308b845f642e64df81
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 26 14:50:20 2006 -0400

    USB: fix autosuspend when CONFIG_PM isn't set
    
    This patch (as791b) fixes things up to avoid compiler warnings or
    errors when CONFIG_USB_SUSPEND or CONFIG_PM isn't set.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0da15b0b02be..190cc1b78fe2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -380,10 +380,10 @@ struct usb_device {
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
 
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 #ifdef CONFIG_PM
 	struct work_struct autosuspend;	/* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
-	int pm_usage_cnt;		/* usage counter for autosuspend */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */

commit 645daaab0b6adc35c1838df2a82f9d729fdb1767
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 15:47:02 2006 -0400

    usbcore: add autosuspend/autoresume infrastructure
    
    This patch (as739) adds the basic infrastructure for USB autosuspend
    and autoresume.  The main features are:
    
            PM usage counters added to struct usb_device and struct
            usb_interface, indicating whether it's okay to autosuspend
            them or they are currently in use.
    
            Flag added to usb_device indicating whether the current
            suspend/resume operation originated from outside or as an
            autosuspend/autoresume.
    
            Flag added to usb_driver indicating whether the driver
            supports autosuspend.  If not, no device bound to the driver
            will be autosuspended.
    
            Mutex added to usb_device for protecting PM operations.
            Unlike the device semaphore, the locking rule for the pm_mutex
            is that you must acquire the locks going _up_ the device tree.
    
            New routines handling autosuspend/autoresume requests for
            interfaces and devices.
    
            Suspend and resume requests are propagated up the device tree
            (but not outside the USB subsystem).
    
            work_struct added to usb_device, for carrying out delayed
            autosuspend requests.
    
            Autoresume added (and autosuspend prevented) during probe and
            disconnect.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index df5c93eb3ce9..0da15b0b02be 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -19,6 +19,7 @@
 #include <linux/fs.h>		/* for struct file_operations */
 #include <linux/completion.h>	/* for struct completion */
 #include <linux/sched.h>	/* for current && schedule_timeout */
+#include <linux/mutex.h>	/* for struct mutex */
 
 struct usb_device;
 struct usb_driver;
@@ -103,8 +104,12 @@ enum usb_interface_condition {
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @is_active: flag set when the interface is bound and not suspended.
+ * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
+ *	capability during autosuspend.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
+ * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
+ *	allowed unless the counter is 0.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -144,9 +149,11 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
+	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \
@@ -372,6 +379,15 @@ struct usb_device {
 
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
+
+#ifdef CONFIG_PM
+	struct work_struct autosuspend;	/* for delayed autosuspends */
+	struct mutex pm_mutex;		/* protects PM operations */
+	int pm_usage_cnt;		/* usage counter for autosuspend */
+
+	unsigned auto_pm:1;		/* autosuspend/resume in progress */
+	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+#endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
@@ -392,6 +408,17 @@ extern int usb_reset_composite_device(struct usb_device *dev,
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
+/* USB autosuspend and autoresume */
+#ifdef CONFIG_USB_SUSPEND
+extern int usb_autopm_get_interface(struct usb_interface *intf);
+extern void usb_autopm_put_interface(struct usb_interface *intf);
+
+#else
+#define usb_autopm_get_interface(intf)		0
+#define usb_autopm_put_interface(intf)		do {} while (0)
+#endif
+
+
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */
@@ -593,6 +620,8 @@ struct usbdrv_wrap {
  * @drvwrap: Driver-model core structure wrapper.
  * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
  *	added to this driver by preventing the sysfs file from being created.
+ * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
+ *	for interfaces bound to this driver.
  *
  * USB interface drivers must provide a name, probe() and disconnect()
  * methods, and an id_table.  Other driver fields are optional.
@@ -631,6 +660,7 @@ struct usb_driver {
 	struct usb_dynids dynids;
 	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
+	unsigned int supports_autosuspend:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
 
@@ -648,6 +678,8 @@ struct usb_driver {
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
  * @drvwrap: Driver-model core structure wrapper.
+ * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
+ *	for devices bound to this driver.
  *
  * USB drivers must provide all the fields listed above except drvwrap.
  */
@@ -660,6 +692,7 @@ struct usb_device_driver {
 	int (*suspend) (struct usb_device *udev, pm_message_t message);
 	int (*resume) (struct usb_device *udev);
 	struct usbdrv_wrap drvwrap;
+	unsigned int supports_autosuspend:1;
 };
 #define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
 		drvwrap.driver)

commit b6956ffa595db97656d5901ca8fec77ef272d41a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 15:46:48 2006 -0400

    usbcore: store each usb_device's level in the tree
    
    This patch (as778) adds a field to struct usb_device to store the
    device's level in the USB tree.  In itself this number isn't really
    important.  But the overhead is very low, and in a later patch it will
    be used for preventing bogus warnings from the lockdep checker.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c66303285a45..df5c93eb3ce9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -348,6 +348,7 @@ struct usb_device {
 
 	unsigned short bus_mA;		/* Current available from the bus */
 	u8 portnum;			/* Parent port number (origin 1) */
+	u8 level;			/* Number of USB hub ancestors */
 
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */

commit 1720058343fa43a1a25bfad9e62ea06e7e9743b6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 11:32:52 2006 -0400

    usbcore: trim down usb_bus structure
    
    As part of the ongoing program to flatten out the HCD bus-glue layer,
    this patch (as771b) eliminates the hcpriv, release, and kref fields
    from struct usb_bus.  hcpriv and release were not being used for
    anything worthwhile, and kref has been moved into the enclosing
    usb_hcd structure.
    
    Along with those changes, the patch gets rid of usb_bus_get and
    usb_bus_put, replacing them with usb_get_hcd and usb_put_hcd.
    
    The one interesting aspect is that the dev_set_drvdata call was
    removed from usb_put_hcd, where it clearly doesn't belong.  This means
    the driver private data won't get reset to NULL.  It shouldn't cause
    any problems, since the private data is undefined when no driver is
    bound.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 09661759621f..c66303285a45 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -280,7 +280,6 @@ struct usb_bus {
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
 	struct list_head bus_list;	/* list of busses */
-	void *hcpriv;                   /* Host Controller private data */
 
 	int bandwidth_allocated;	/* on this bus: how much of the time
 					 * reserved for periodic (intr/iso)
@@ -295,8 +294,6 @@ struct usb_bus {
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
 	struct class_device *class_dev;	/* class device for this bus */
-	struct kref kref;		/* reference counting for this bus */
-	void (*release)(struct usb_bus *bus);
 
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */

commit dd990f16a39d4e615c0b70a0ab50b79b32bfb16d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 11:29:56 2006 -0400

    usbcore: Add flag for whether a host controller uses DMA
    
    This patch (as770b) introduces a new field to usb_bus: a flag
    indicating whether or not the host controller uses DMA.  This serves
    to encapsulate the computation.  It also means we will have only one
    spot to update if the DMA API changes.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4709033f8fa7..09661759621f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -269,6 +269,7 @@ struct usb_bus {
 	struct device *controller;	/* host/master side hardware */
 	int busnum;			/* Bus number (in order of reg) */
 	char *bus_name;			/* stable id (PCI slot_name etc) */
+	u8 uses_dma;			/* Does the host controller use DMA? */
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */

commit a6d2bb9ff919b4685bd684620ec7a1ffa8bf2349
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 11:27:36 2006 -0400

    USB: remove struct usb_operations
    
    All of the currently-supported USB host controller drivers use the HCD
    bus-glue framework.  As part of the program for flattening out the glue
    layer, this patch (as769) removes the usb_operations structure.  All
    function calls now go directly to the HCD routines (slightly renamed
    to remain within the "usb_" namespace).
    
    The patch also removes usb_alloc_bus(), because it's not useful in the
    HCD framework and it wasn't referenced anywhere.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f104efa04d79..4709033f8fa7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -257,8 +257,6 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 
 /* ----------------------------------------------------------------------- */
 
-struct usb_operations;
-
 /* USB device number allocation bitmap */
 struct usb_devmap {
 	unsigned long devicemap[128 / (8*sizeof(unsigned long))];
@@ -279,7 +277,6 @@ struct usb_bus {
 					 * round-robin allocation */
 
 	struct usb_devmap devmap;	/* device address allocation map */
-	struct usb_operations *op;	/* Operations (specific to the HC) */
 	struct usb_device *root_hub;	/* Root hub */
 	struct list_head bus_list;	/* list of busses */
 	void *hcpriv;                   /* Host Controller private data */
@@ -1051,7 +1048,6 @@ extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 
-#define HAVE_USB_BUFFERS
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,

commit 088dc270e1da03744d977cbd9edd4311af142348
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Aug 21 12:08:19 2006 -0400

    usbcore: help drivers to change device configs
    
    It's generally a bad idea for USB interface drivers to try to change a
    device's configuration, and usbcore doesn't provide any way for them
    to do it.  However in a few exceptional circumstances it can make
    sense.  This patch (as767) adds a roundabout mechanism to help drivers
    that may need it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 26d8a5f36896..f104efa04d79 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1099,6 +1099,9 @@ extern int usb_clear_halt(struct usb_device *dev, int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
 
+/* this request isn't really synchronous, but it belongs with the others */
+extern int usb_driver_set_configuration(struct usb_device *udev, int config);
+
 /*
  * timeouts, in milliseconds, used for sending/receiving control messages
  * they typically complete within a few frames (msec) after they're issued

commit 095bc335360a51623dd8571839bbf465851a7f4b
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Sat Aug 26 23:48:11 2006 -0300

    USB core: Use const where possible.
    
    This patch marks some USB core's functions parameters as const. This
    improves the design (we're saying to the caller that its parameter is
    not going to be modified) and may help in compiler's optimisation work.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index f807479ef65b..26d8a5f36896 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -387,7 +387,7 @@ extern void usb_put_dev(struct usb_device *dev);
 #define usb_unlock_device(udev)		up(&(udev)->dev.sem)
 #define usb_trylock_device(udev)	down_trylock(&(udev)->dev.sem)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
-		struct usb_interface *iface);
+				     const struct usb_interface *iface);
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
@@ -426,10 +426,10 @@ const struct usb_device_id *usb_match_id(struct usb_interface *interface,
 
 extern struct usb_interface *usb_find_interface(struct usb_driver *drv,
 		int minor);
-extern struct usb_interface *usb_ifnum_to_if(struct usb_device *dev,
+extern struct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,
 		unsigned ifnum);
 extern struct usb_host_interface *usb_altnum_to_altsetting(
-		struct usb_interface *intf, unsigned int altnum);
+		const struct usb_interface *intf, unsigned int altnum);
 
 
 /**
@@ -1064,14 +1064,14 @@ void usb_buffer_unmap (struct urb *urb);
 #endif
 
 struct scatterlist;
-int usb_buffer_map_sg (struct usb_device *dev, unsigned pipe,
-		struct scatterlist *sg, int nents);
+int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
+		      struct scatterlist *sg, int nents);
 #if 0
-void usb_buffer_dmasync_sg (struct usb_device *dev, unsigned pipe,
-		struct scatterlist *sg, int n_hw_ents);
+void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
+			   struct scatterlist *sg, int n_hw_ents);
 #endif
-void usb_buffer_unmap_sg (struct usb_device *dev, unsigned pipe,
-		struct scatterlist *sg, int n_hw_ents);
+void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
+			 struct scatterlist *sg, int n_hw_ents);
 
 /*-------------------------------------------------------------------*
  *                         SYNCHRONOUS CALL SUPPORT                  *

commit b7cfaaaf86571732c7728e95a2231a860385463c
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Wed Sep 27 11:58:53 2006 -0700

    USB: New functions to check endpoints info.
    
    These functions makes USB driver's code simpler when dealing with endpoints
    by avoiding them from accessing the endpoint's descriptor structure directly
    when they only need to know the endpoint's transfer type and/or
    direction.
    
    Please, read each functions' documentation in order to know how to use
    them.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3d5cfa731680..f807479ef65b 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -467,6 +467,20 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
 
 /*-------------------------------------------------------------------------*/
 
+extern int usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_xfer_isoc(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_is_int_out(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_is_isoc_in(const struct usb_endpoint_descriptor *epd);
+extern int usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor *epd);
+
+/*-------------------------------------------------------------------------*/
+
 #define USB_DEVICE_ID_MATCH_DEVICE \
 		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
 #define USB_DEVICE_ID_MATCH_DEV_RANGE \

commit 3d5b2510f6e361e2203e163c03b93d0026de5629
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Sun Jul 30 18:43:43 2006 +0200

    USB: making the kernel -Wshadow clean - USB & completion
    
    include/linux/usb.h causes a lot of -Wshadow warnings - fix them.
    
      include/linux/usb.h:901: warning: declaration of 'complete' shadows a global declaration
      include/linux/completion.h:52: warning: shadowed declaration is here
      include/linux/usb.h:932: warning: declaration of 'complete' shadows a global declaration
      include/linux/completion.h:52: warning: shadowed declaration is here
      include/linux/usb.h:967: warning: declaration of 'complete' shadows a global declaration
      include/linux/completion.h:52: warning: shadowed declaration is here
    
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e22f4b386605..3d5cfa731680 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -932,7 +932,7 @@ struct urb
  * @setup_packet: pointer to the setup_packet buffer
  * @transfer_buffer: pointer to the transfer buffer
  * @buffer_length: length of the transfer buffer
- * @complete: pointer to the usb_complete_t function
+ * @complete_fn: pointer to the usb_complete_t function
  * @context: what to set the urb context to.
  *
  * Initializes a control urb with the proper information needed to submit
@@ -944,7 +944,7 @@ static inline void usb_fill_control_urb (struct urb *urb,
 					 unsigned char *setup_packet,
 					 void *transfer_buffer,
 					 int buffer_length,
-					 usb_complete_t complete,
+					 usb_complete_t complete_fn,
 					 void *context)
 {
 	spin_lock_init(&urb->lock);
@@ -953,7 +953,7 @@ static inline void usb_fill_control_urb (struct urb *urb,
 	urb->setup_packet = setup_packet;
 	urb->transfer_buffer = transfer_buffer;
 	urb->transfer_buffer_length = buffer_length;
-	urb->complete = complete;
+	urb->complete = complete_fn;
 	urb->context = context;
 }
 
@@ -964,7 +964,7 @@ static inline void usb_fill_control_urb (struct urb *urb,
  * @pipe: the endpoint pipe
  * @transfer_buffer: pointer to the transfer buffer
  * @buffer_length: length of the transfer buffer
- * @complete: pointer to the usb_complete_t function
+ * @complete_fn: pointer to the usb_complete_t function
  * @context: what to set the urb context to.
  *
  * Initializes a bulk urb with the proper information needed to submit it
@@ -975,7 +975,7 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
 				      unsigned int pipe,
 				      void *transfer_buffer,
 				      int buffer_length,
-				      usb_complete_t complete,
+				      usb_complete_t complete_fn,
 				      void *context)
 {
 	spin_lock_init(&urb->lock);
@@ -983,7 +983,7 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
 	urb->pipe = pipe;
 	urb->transfer_buffer = transfer_buffer;
 	urb->transfer_buffer_length = buffer_length;
-	urb->complete = complete;
+	urb->complete = complete_fn;
 	urb->context = context;
 }
 
@@ -994,7 +994,7 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
  * @pipe: the endpoint pipe
  * @transfer_buffer: pointer to the transfer buffer
  * @buffer_length: length of the transfer buffer
- * @complete: pointer to the usb_complete_t function
+ * @complete_fn: pointer to the usb_complete_t function
  * @context: what to set the urb context to.
  * @interval: what to set the urb interval to, encoded like
  *	the endpoint descriptor's bInterval value.
@@ -1010,7 +1010,7 @@ static inline void usb_fill_int_urb (struct urb *urb,
 				     unsigned int pipe,
 				     void *transfer_buffer,
 				     int buffer_length,
-				     usb_complete_t complete,
+				     usb_complete_t complete_fn,
 				     void *context,
 				     int interval)
 {
@@ -1019,7 +1019,7 @@ static inline void usb_fill_int_urb (struct urb *urb,
 	urb->pipe = pipe;
 	urb->transfer_buffer = transfer_buffer;
 	urb->transfer_buffer_length = buffer_length;
-	urb->complete = complete;
+	urb->complete = complete_fn;
 	urb->context = context;
 	if (dev->speed == USB_SPEED_HIGH)
 		urb->interval = 1 << (interval - 1);

commit 4d064c080265a41324d108fccc26b72106d43db3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:11:44 2006 -0400

    usbcore: track whether interfaces are suspended
    
    Currently we rely on intf->dev.power.power_state.event for tracking
    whether intf is suspended.  This is not a reliable technique because
    that value is owned by the PM core, not by usbcore.  This patch (as718b)
    adds a new flag so that we can accurately tell which interfaces are
    suspended and which aren't.
    
    At first one might think these flags aren't needed, since interfaces
    will be suspended along with their devices.  It turns out there are a
    couple of intermediate situations where that's not quite true, such as
    while processing a remote-wakeup request.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b4ccce6d0982..e22f4b386605 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -102,6 +102,7 @@ enum usb_interface_condition {
  *	number from the USB core by calling usb_register_dev().
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
+ * @is_active: flag set when the interface is bound and not suspended.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
  *
@@ -142,6 +143,8 @@ struct usb_interface {
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
+	unsigned is_active:1;		/* the interface is not suspended */
+
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
 };

commit 8bb54ab573ecd1b4fe2ed66416a8d99a86e65316
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:08:49 2006 -0400

    usbcore: add usb_device_driver definition
    
    This patch (as732) adds a usb_device_driver structure, for representing
    drivers that manage an entire USB device as opposed to just an
    interface.  Support routines like usb_register_device_driver,
    usb_deregister_device_driver, usb_probe_device, and usb_unbind_device
    are also added.
    
    Unlike an earlier version of this patch, the new code is type-safe.  To
    accomplish this, the existing struct driver embedded in struct
    usb_driver had to be wrapped in an intermediate wrapper.  This enables
    the core to tell at runtime whether a particular struct driver belongs
    to a device driver or to an interface driver.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d2bd0c8e0154..b4ccce6d0982 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -540,7 +540,17 @@ struct usb_dynids {
 };
 
 /**
- * struct usb_driver - identifies USB driver to usbcore
+ * struct usbdrv_wrap - wrapper for driver-model structure
+ * @driver: The driver-model core driver structure.
+ * @for_devices: Non-zero for device drivers, 0 for interface drivers.
+ */
+struct usbdrv_wrap {
+	struct device_driver driver;
+	int for_devices;
+};
+
+/**
+ * struct usb_driver - identifies USB interface driver to usbcore
  * @name: The driver name should be unique among USB drivers,
  *	and should normally be the same as the module name.
  * @probe: Called to see if the driver is willing to manage a particular
@@ -567,12 +577,12 @@ struct usb_dynids {
  *	or your driver's probe function will never get called.
  * @dynids: used internally to hold the list of dynamically added device
  *	ids for this driver.
- * @driver: the driver model core driver structure.
+ * @drvwrap: Driver-model core structure wrapper.
  * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
  *	added to this driver by preventing the sysfs file from being created.
  *
- * USB drivers must provide a name, probe() and disconnect() methods,
- * and an id_table.  Other driver fields are optional.
+ * USB interface drivers must provide a name, probe() and disconnect()
+ * methods, and an id_table.  Other driver fields are optional.
  *
  * The id_table is used in hotplugging.  It holds a set of descriptors,
  * and specialized data may be associated with each entry.  That table
@@ -606,10 +616,40 @@ struct usb_driver {
 	const struct usb_device_id *id_table;
 
 	struct usb_dynids dynids;
-	struct device_driver driver;
+	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
 };
-#define	to_usb_driver(d) container_of(d, struct usb_driver, driver)
+#define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
+
+/**
+ * struct usb_device_driver - identifies USB device driver to usbcore
+ * @name: The driver name should be unique among USB drivers,
+ *	and should normally be the same as the module name.
+ * @probe: Called to see if the driver is willing to manage a particular
+ *	device.  If it is, probe returns zero and uses dev_set_drvdata()
+ *	to associate driver-specific data with the device.  If unwilling
+ *	to manage the device, return a negative errno value.
+ * @disconnect: Called when the device is no longer accessible, usually
+ *	because it has been (or is being) disconnected or the driver's
+ *	module is being unloaded.
+ * @suspend: Called when the device is going to be suspended by the system.
+ * @resume: Called when the device is being resumed by the system.
+ * @drvwrap: Driver-model core structure wrapper.
+ *
+ * USB drivers must provide all the fields listed above except drvwrap.
+ */
+struct usb_device_driver {
+	const char *name;
+
+	int (*probe) (struct usb_device *udev);
+	void (*disconnect) (struct usb_device *udev);
+
+	int (*suspend) (struct usb_device *udev, pm_message_t message);
+	int (*resume) (struct usb_device *udev);
+	struct usbdrv_wrap drvwrap;
+};
+#define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
+		drvwrap.driver)
 
 extern struct bus_type usb_bus_type;
 
@@ -633,13 +673,17 @@ struct usb_class_driver {
  * use these in module_init()/module_exit()
  * and don't forget MODULE_DEVICE_TABLE(usb, ...)
  */
-int usb_register_driver(struct usb_driver *, struct module *);
+extern int usb_register_driver(struct usb_driver *, struct module *);
 static inline int usb_register(struct usb_driver *driver)
 {
 	return usb_register_driver(driver, THIS_MODULE);
 }
 extern void usb_deregister(struct usb_driver *);
 
+extern int usb_register_device_driver(struct usb_device_driver *,
+			struct module *);
+extern void usb_deregister_device_driver(struct usb_device_driver *);
+
 extern int usb_register_dev(struct usb_interface *intf,
 			    struct usb_class_driver *class_driver);
 extern void usb_deregister_dev(struct usb_interface *intf,

commit cae74b30dd98c10baa5b47b4698bf67e5eb15687
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Aug 2 16:52:10 2006 -0700

    Revert "[PATCH] USB: move usb_device_class class devices to be real devices"
    
    This reverts c182274ffe1277f4e7c564719a696a37cacf74ea commit because it
    required a newer version of udev to work properly than what is currently
    documented in Documentation/Changes.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 398c52f37679..d2bd0c8e0154 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -360,7 +360,7 @@ struct usb_device {
 	char *serial;			/* iSerialNumber string, if present */
 
 	struct list_head filelist;
-	struct device *usbfs_dev;
+	struct class_device *class_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
 
 	/*

commit 27fb4f0a7f00fda4044de44dcbe4d65b8359cc38
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Aug 2 16:49:37 2006 -0700

    Revert "[PATCH] USB: convert usb class devices to real devices"
    
    This reverts bd00949647ddcea47ce4ea8bb2cfcfc98ebf9f2a commit because it
    required a newer version of udev to work properly than what is currently
    documented in Documentation/Changes.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c944e8f06a4a..398c52f37679 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -103,8 +103,7 @@ enum usb_interface_condition {
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @dev: driver model's view of this device
- * @usb_dev: if an interface is bound to the USB major, this will point
- *	to the sysfs representation for that device.
+ * @class_dev: driver model's class view of this device.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -144,7 +143,7 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	struct device dev;		/* interface specific device info */
-	struct device *usb_dev;		/* pointer to the usb class's device, if any */
+	struct class_device *class_dev;
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \

commit 7fac9a3348921e0fc626c7856ce3d1a9746b2b39
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Jun 22 15:12:41 2006 -0700

    [PATCH] USB: fix usb kernel-doc
    
    Warning(/var/linsrc/linux-2617-g4//include/linux/usb.h:66): No description found for parameter 'ep_dev'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8dead32e7ebf..c944e8f06a4a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -48,7 +48,7 @@ struct ep_device;
  * @urb_list: urbs queued to this endpoint; maintained by usbcore
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
- * @kobj: kobject for sysfs info
+ * @ep_dev: ep_device for sysfs info
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  *

commit bd00949647ddcea47ce4ea8bb2cfcfc98ebf9f2a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 20 13:09:50 2006 -0700

    [PATCH] USB: convert usb class devices to real devices
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index b69b6cfb0bd7..8dead32e7ebf 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -103,7 +103,8 @@ enum usb_interface_condition {
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @dev: driver model's view of this device
- * @class_dev: driver model's class view of this device.
+ * @usb_dev: if an interface is bound to the USB major, this will point
+ *	to the sysfs representation for that device.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -143,7 +144,7 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	struct device dev;		/* interface specific device info */
-	struct class_device *class_dev;
+	struct device *usb_dev;		/* pointer to the usb class's device, if any */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \

commit c182274ffe1277f4e7c564719a696a37cacf74ea
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 19 23:59:31 2006 -0700

    [PATCH] USB: move usb_device_class class devices to be real devices
    
    This moves the usb class devices that control the usbfs nodes to show up
    in the proper place in the larger device tree.
    
    No userspace changes is needed, this is compatible due to the symlinks
    generated by the driver core.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 46956a72de5d..b69b6cfb0bd7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -360,7 +360,7 @@ struct usb_device {
 	char *serial;			/* iSerialNumber string, if present */
 
 	struct list_head filelist;
-	struct class_device *class_dev;
+	struct device *usbfs_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
 
 	/*

commit 9bde7497e0b54178c317fac47a18be7f948dd471
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 14 12:14:34 2006 -0700

    [PATCH] USB: make endpoints real struct devices
    
    This will allow for us to give endpoints a major/minor to create a
    "usbfs2-like" way to access endpoints directly from userspace in an
    easier manner than the current usbfs provides us.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5ad30cefe7b2..46956a72de5d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -40,6 +40,8 @@ struct usb_driver;
  * Devices may also have class-specific or vendor-specific descriptors.
  */
 
+struct ep_device;
+
 /**
  * struct usb_host_endpoint - host-side endpoint descriptor and queue
  * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
@@ -57,7 +59,7 @@ struct usb_host_endpoint {
 	struct usb_endpoint_descriptor	desc;
 	struct list_head		urb_list;
 	void				*hcpriv;
-	struct kobject			*kobj;	/* For sysfs info */
+	struct ep_device 		*ep_dev;	/* For sysfs info */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;

commit 79efa097e75018a2918155f343f0e08e61ee8a8c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 1 13:33:42 2006 -0400

    [PATCH] usbcore: port reset for composite devices
    
    This patch (as699) adds usb_reset_composite_device(), a routine for
    sending a USB port reset to a device with multiple interfaces owned by
    different drivers.  Drivers are notified about impending and completed
    resets through two new methods in the usb_driver structure.
    
    The patch modifieds the usbfs ioctl code to make it use the new routine
    instead of usb_reset_device().  Follow-up patches will modify the hub,
    usb-storage, and usbhid drivers so they can utilize this new API.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 317ec9f28bce..5ad30cefe7b2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -386,6 +386,8 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
+extern int usb_reset_composite_device(struct usb_device *dev,
+		struct usb_interface *iface);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
@@ -554,6 +556,10 @@ struct usb_dynids {
  *	do (or don't) show up otherwise in the filesystem.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @pre_reset: Called by usb_reset_composite_device() when the device
+ *	is about to be reset.
+ * @post_reset: Called by usb_reset_composite_device() after the device
+ *	has been reset.
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
@@ -592,6 +598,9 @@ struct usb_driver {
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
 
+	void (*pre_reset) (struct usb_interface *intf);
+	void (*post_reset) (struct usb_interface *intf);
+
 	const struct usb_device_id *id_table;
 
 	struct usb_dynids dynids;

commit 782a7a632e4b0581ade665e3d89ee97c8db0f441
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri May 19 13:20:20 2006 -0700

    [PATCH] USB: add usb_interrupt_msg() function for api completeness.
    
    Really just a wrapper around usb_bulk_msg() but now it's documented
    much better.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1f492c0c7047..317ec9f28bce 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1008,6 +1008,8 @@ void usb_buffer_unmap_sg (struct usb_device *dev, unsigned pipe,
 extern int usb_control_msg(struct usb_device *dev, unsigned int pipe,
 	__u8 request, __u8 requesttype, __u16 value, __u16 index,
 	void *data, __u16 size, int timeout);
+extern int usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,
+	void *data, int len, int *actual_length, int timeout);
 extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 	void *data, int len, int *actual_length,
 	int timeout);

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index e34e5e3dce52..1f492c0c7047 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -10,7 +10,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/errno.h>        /* for -ENODEV */
 #include <linux/delay.h>	/* for mdelay() */
 #include <linux/interrupt.h>	/* for in_interrupt() */

commit 99ac48f54a91d02140c497edc31dc57d4bc5c85d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:41 2006 -0800

    [PATCH] mark f_ops const in the inode
    
    Mark the f_ops members of inodes as const, as well as fix the
    ripple-through this causes by places that copy this f_ops and then "do
    stuff" with it.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 130d125fda12..e34e5e3dce52 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -615,7 +615,7 @@ extern struct bus_type usb_bus_type;
  */
 struct usb_class_driver {
 	char *name;
-	struct file_operations *fops;
+	const struct file_operations *fops;
 	int minor_base;
 };
 

commit e266a12492f7ca9142882710bff92e902b7c95c8
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Nov 8 21:05:43 2005 +0100

    [PATCH] USB: drivers/usb/core/message.c: make usb_get_string() static
    
    After the removal of usb-midi.c, there's no longer any external user of
    usb_get_string().
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 827cc6de5f5c..130d125fda12 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1018,8 +1018,6 @@ extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
 	unsigned char descindex, void *buf, int size);
 extern int usb_get_status(struct usb_device *dev,
 	int type, int target, void *data);
-extern int usb_get_string(struct usb_device *dev,
-	unsigned short langid, unsigned char index, void *buf, int size);
 extern int usb_string(struct usb_device *dev, int index,
 	char *buf, size_t size);
 

commit db9edfd7e339ca4113153d887e782dd05be5a9eb
Merge: 631b03472436 fd586bacf439
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Jan 4 18:44:12 2006 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-2.6
    
    Trivial manual merge fixup for usb_find_interface clashes.

commit 312c004d36ce6c739512bac83b452f4c20ab1f62
Author: Kay Sievers <kay.sievers@suse.de>
Date:   Wed Nov 16 09:00:00 2005 +0100

    [PATCH] driver core: replace "hotplug" by "uevent"
    
    Leave the overloaded "hotplug" word to susbsystems which are handling
    real devices. The driver core does not "plug" anything, it just exports
    the state to userspace and generates events.
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d81b050e5955..7a20997e8071 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -225,7 +225,7 @@ struct usb_interface_cache {
  * Device drivers should not attempt to activate configurations.  The choice
  * of which configuration to install is a policy decision based on such
  * considerations as available power, functionality provided, and the user's
- * desires (expressed through hotplug scripts).  However, drivers can call
+ * desires (expressed through userspace tools).  However, drivers can call
  * usb_reset_configuration() to reinitialize the current configuration and
  * all its interfaces.
  */

commit 12c3da346eb81b6a281031f62eda3bca993dff5a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 23 12:09:52 2005 -0500

    [PATCH] USB: Store port number in usb_device
    
    This patch (as610) adds a field to struct usb_device to store the device's
    port number.  This allows us to remove several loops in the hub driver
    (searching for a particular device among all the entries in the parent's
    array of children).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 27575e678a7c..e59d1bd52d4f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -348,6 +348,7 @@ struct usb_device {
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
 	unsigned short bus_mA;		/* Current available from the bus */
+	u8 portnum;			/* Parent port number (origin 1) */
 
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */

commit 55c527187c9d78f840b284d596a0b298bc1493af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 23 12:03:12 2005 -0500

    [PATCH] USB: Consider power budget when choosing configuration
    
    This patch (as609) changes the way we keep track of power budgeting for
    USB hubs and devices, and it updates the choose_configuration routine to
    take this information into account.  (This is something we should have
    been doing all along.)  A new field in struct usb_device holds the amount
    of bus current available from the upstream port, and the usb_hub structure
    keeps track of the current available for each downstream port.
    
    Two new rules for configuration selection are added:
    
            Don't select a self-powered configuration when only bus power
            is available.
    
            Don't select a configuration requiring more bus power than is
            available.
    
    However the first rule is #if-ed out, because I found that the internal
    hub in my HP USB keyboard claims that its only configuration is
    self-powered.  The rule would prevent the configuration from being chosen,
    leaving the hub & keyboard unconfigured.  Since similar descriptor errors
    may turn out to be fairly common, it seemed wise not to include a rule
    that would break automatic configuration unnecessarily for such devices.
    
    The second rule may also trigger unnecessarily, although this should be
    less common.  More likely it will annoy people by sometimes failing to
    accept configurations that should never have been chosen in the first
    place.
    
    The patch also changes usbcore's reaction when no configuration is
    suitable.  Instead of raising an error and rejecting the device, now
    the core will simply leave the device unconfigured.  People can always
    work around such problems by installing configurations manually through
    sysfs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 46dc0421d19e..27575e678a7c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -347,6 +347,8 @@ struct usb_device {
 
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
+	unsigned short bus_mA;		/* Current available from the bus */
+
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 

commit 9ad3d6ccf5eee285e233dbaf186369b8d477a666
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 17 17:10:32 2005 -0500

    [PATCH] USB: Remove USB private semaphore
    
    This patch (as605) removes the private udev->serialize semaphore,
    relying instead on the locking provided by the embedded struct device's
    semaphore.  The changes are confined to the core, except that the
    usb_trylock_device routine now uses the return convention of
    down_trylock rather than down_read_trylock (they return opposite values
    for no good reason).
    
    A couple of other associated changes are included as well:
    
            Now that we aren't concerned about HCDs that avoid using the
            hcd glue layer, usb_disconnect no longer needs to acquire the
            usb_bus_lock -- that can be done by usb_remove_hcd where it
            belongs.
    
            Devices aren't locked over the same scope of code in
            usb_new_device and hub_port_connect_change as they used to be.
            This shouldn't cause any trouble.
    
    Along with the preceding driver core patch, this needs a lot of testing.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2714814ab66c..46dc0421d19e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -329,8 +329,6 @@ struct usb_device {
 	struct usb_tt	*tt; 		/* low/full speed dev, highspeed hub */
 	int		ttport;		/* device port on that tt hub */
 
-	struct semaphore serialize;
-
 	unsigned int toggle[2];		/* one bit for each endpoint
 					 * ([0] = IN, [1] = OUT) */
 
@@ -377,11 +375,12 @@ struct usb_device {
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
 
-extern void usb_lock_device(struct usb_device *udev);
-extern int usb_trylock_device(struct usb_device *udev);
+/* USB device locking */
+#define usb_lock_device(udev)		down(&(udev)->dev.sem)
+#define usb_unlock_device(udev)		up(&(udev)->dev.sem)
+#define usb_trylock_device(udev)	down_trylock(&(udev)->dev.sem)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
 		struct usb_interface *iface);
-extern void usb_unlock_device(struct usb_device *udev);
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3d05c63451a8..2714814ab66c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -536,8 +536,6 @@ struct usb_dynids {
 
 /**
  * struct usb_driver - identifies USB driver to usbcore
- * @owner: Pointer to the module owner of this driver; initialize
- *	it using THIS_MODULE.
  * @name: The driver name should be unique among USB drivers,
  *	and should normally be the same as the module name.
  * @probe: Called to see if the driver is willing to manage a particular
@@ -580,8 +578,6 @@ struct usb_dynids {
  * them as necessary, and blocking until the unlinks complete).
  */
 struct usb_driver {
-	struct module *owner;
-
 	const char *name;
 
 	int (*probe) (struct usb_interface *intf,

commit 2143acc6dc79bdbff812f02a7dc5ab9d4fc81fc8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: make registering a usb driver automatically set the module owner
    
    This fixes the driver that forgot to set the module owner up.  Now we
    can remove the unneeded pointer from the usb driver structure.  The idea
    for how to do this was from Al Viro, who did this for the PCI drivers.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8d5829936bc4..3d05c63451a8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -625,7 +625,11 @@ struct usb_class_driver {
  * use these in module_init()/module_exit()
  * and don't forget MODULE_DEVICE_TABLE(usb, ...)
  */
-extern int usb_register(struct usb_driver *);
+int usb_register_driver(struct usb_driver *, struct module *);
+static inline int usb_register(struct usb_driver *driver)
+{
+	return usb_register_driver(driver, THIS_MODULE);
+}
 extern void usb_deregister(struct usb_driver *);
 
 extern int usb_register_dev(struct usb_interface *intf,

commit ba9dc657af86d05d2971633e57d1f6f94ed60472
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: allow usb drivers to disable dynamic ids
    
    This lets drivers, like the usb-serial ones, disable the ability to add
    ids from sysfs.
    
    The usb-serial drivers are "odd" in that they are really usb-serial bus
    drivers, not usb bus drivers, so the dynamic id logic will have to go
    into the usb-serial bus core for those drivers to get that ability.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0dd96ef78c13..8d5829936bc4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -561,6 +561,8 @@ struct usb_dynids {
  * @dynids: used internally to hold the list of dynamically added device
  *	ids for this driver.
  * @driver: the driver model core driver structure.
+ * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
+ *	added to this driver by preventing the sysfs file from being created.
  *
  * USB drivers must provide a name, probe() and disconnect() methods,
  * and an id_table.  Other driver fields are optional.
@@ -597,6 +599,7 @@ struct usb_driver {
 
 	struct usb_dynids dynids;
 	struct device_driver driver;
+	unsigned int no_dynamic_id:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, driver)
 

commit 733260ff9c45bd4db60f45d17e8560a4a68dff4d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: add dynamic id functionality to USB core
    
    Echo the usb vendor and product id to the "new_id" file in the driver's
    sysfs directory, and then that driver will be able to bind to a device
    with those ids if it is present.
    
    Example:
            echo 0557 2008 > /sys/bus/usb/drivers/foo_driver/new_id
    adds the hex values 0557 and 2008 to the device id table for the foo_driver.
    
    Note, usb-serial drivers do not currently work with this capability yet.
    usb-storage also might have some oddities.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index d81b050e5955..0dd96ef78c13 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -529,6 +529,11 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
 
 /* ----------------------------------------------------------------------- */
 
+struct usb_dynids {
+	spinlock_t lock;
+	struct list_head list;
+};
+
 /**
  * struct usb_driver - identifies USB driver to usbcore
  * @owner: Pointer to the module owner of this driver; initialize
@@ -553,6 +558,8 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
+ * @dynids: used internally to hold the list of dynamically added device
+ *	ids for this driver.
  * @driver: the driver model core driver structure.
  *
  * USB drivers must provide a name, probe() and disconnect() methods,
@@ -588,6 +595,7 @@ struct usb_driver {
 
 	const struct usb_device_id *id_table;
 
+	struct usb_dynids dynids;
 	struct device_driver driver;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, driver)

commit 8dd396ec7bf706fe85d8c6792b478ee6f09e8de6
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Nov 23 15:45:53 2005 -0800

    [PATCH] USB: kernel-doc for linux/usb.h
    
    Fix kernel-doc warning in linux/usb.h.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 856d232c7562..d81b050e5955 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -47,6 +47,7 @@ struct usb_driver;
  * @urb_list: urbs queued to this endpoint; maintained by usbcore
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
+ * @kobj: kobject for sysfs info
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  *

commit aeec46b97a7975fd983219177980c58ed4fd607c
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun Nov 13 16:08:13 2005 -0800

    [PATCH] DocBook: allow to mark structure members private
    
    Many structures contain both an internal part and one which is part of the API
    to other modules.  With this patch it is possible to only include these public
    members in the kernel documentation.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 748d04385256..856d232c7562 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -819,7 +819,7 @@ typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
  */
 struct urb
 {
-	/* private, usb core and host controller only fields in the urb */
+	/* private: usb core and host controller only fields in the urb */
 	struct kref kref;		/* reference count of the URB */
 	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
@@ -827,7 +827,7 @@ struct urb
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
 
-	/* public, documented fields in the urb that can be used by drivers */
+	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's
 					 * current owner */
 	struct usb_device *dev; 	/* (in) pointer to associated device */
@@ -1045,7 +1045,7 @@ struct usb_sg_request {
 	size_t			bytes;
 
 	/* 
-	 * members below are private to usbcore,
+	 * members below are private: to usbcore,
 	 * and are not provided for driver access!
 	 */
 	spinlock_t		lock;

commit 4f62efe67f077db17dad03a1d4c9665000a3eb45
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 24 16:24:14 2005 -0400

    [PATCH] usbcore: Fix handling of sysfs strings and other attributes
    
    This patch (as592) makes a few small improvements to the way device
    strings are handled, and it fixes some bugs in a couple of other sysfs
    attribute routines.  (Look at show_configuration_string() to see what I
    mean.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c500d6b5a16d..748d04385256 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -231,7 +231,7 @@ struct usb_interface_cache {
 struct usb_host_config {
 	struct usb_config_descriptor	desc;
 
-	char *string;
+	char *string;		/* iConfiguration string, if present */
 	/* the interfaces associated with this configuration,
 	 * stored in no particular order */
 	struct usb_interface *interface[USB_MAXINTERFACES];
@@ -351,9 +351,11 @@ struct usb_device {
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
-	char *product;
-	char *manufacturer;
-	char *serial;			/* static strings from the device */
+	/* static strings from the device */
+	char *product;			/* iProduct string, if present */
+	char *manufacturer;		/* iManufacturer string, if present */
+	char *serial;			/* iSerialNumber string, if present */
+
 	struct list_head filelist;
 	struct class_device *class_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */

commit b724ae77969fd832be71419dca74bece9af287ff
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 24 15:36:00 2005 -0400

    [PATCH] usbcore: Wrap lines before column 80
    
    I can't stand text lines that wrap-around in my 80-column windows.  This
    patch (as589) makes cosmetic changes to a couple of source files.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 465ff4585ca5..c500d6b5a16d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -137,7 +137,8 @@ struct usb_interface {
 					 * active alternate setting */
 	unsigned num_altsetting;	/* number of alternate settings */
 
-	int minor;			/* minor number this interface is bound to */
+	int minor;			/* minor number this interface is
+					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
@@ -249,7 +250,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	__usb_get_extra_descriptor((ifpoint)->extra,(ifpoint)->extralen,\
 		type,(void**)ptr)
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 struct usb_operations;
 
@@ -269,7 +270,8 @@ struct usb_bus {
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
 
-	int devnum_next;		/* Next open device number in round-robin allocation */
+	int devnum_next;		/* Next open device number in
+					 * round-robin allocation */
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_operations *op;	/* Operations (specific to the HC) */
@@ -290,15 +292,16 @@ struct usb_bus {
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
 	struct class_device *class_dev;	/* class device for this bus */
-	struct kref kref;		/* handles reference counting this bus */
-	void (*release)(struct usb_bus *bus);	/* function to destroy this bus's memory */
+	struct kref kref;		/* reference counting for this bus */
+	void (*release)(struct usb_bus *bus);
+
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif
 };
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /* This is arbitrary.
  * From USB 2.0 spec Table 11-13, offset 7, a hub can
@@ -327,7 +330,8 @@ struct usb_device {
 
 	struct semaphore serialize;
 
-	unsigned int toggle[2];		/* one bit for each endpoint ([0] = IN, [1] = OUT) */
+	unsigned int toggle[2];		/* one bit for each endpoint
+					 * ([0] = IN, [1] = OUT) */
 
 	struct usb_device *parent;	/* our hub, unless we're the root */
 	struct usb_bus *bus;		/* Bus we're part of */
@@ -344,7 +348,7 @@ struct usb_device {
 
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
-	int have_langid;		/* whether string_langid is valid yet */
+	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
 	char *product;
@@ -441,22 +445,31 @@ extern struct usb_host_interface *usb_altnum_to_altsetting(
  * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
  * high speed, and a different one if they are full or low speed.
  */
-static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
+static inline int usb_make_path (struct usb_device *dev, char *buf,
+		size_t size)
 {
 	int actual;
-	actual = snprintf (buf, size, "usb-%s-%s", dev->bus->bus_name, dev->devpath);
+	actual = snprintf (buf, size, "usb-%s-%s", dev->bus->bus_name,
+			dev->devpath);
 	return (actual >= (int)size) ? -1 : actual;
 }
 
 /*-------------------------------------------------------------------------*/
 
-#define USB_DEVICE_ID_MATCH_DEVICE		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
-#define USB_DEVICE_ID_MATCH_DEV_RANGE		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
-#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION	(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
+#define USB_DEVICE_ID_MATCH_DEVICE \
+		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
+#define USB_DEVICE_ID_MATCH_DEV_RANGE \
+		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
+#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \
+		(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
 #define USB_DEVICE_ID_MATCH_DEV_INFO \
-	(USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
+		(USB_DEVICE_ID_MATCH_DEV_CLASS | \
+		USB_DEVICE_ID_MATCH_DEV_SUBCLASS | \
+		USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
 #define USB_DEVICE_ID_MATCH_INT_INFO \
-	(USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
+		(USB_DEVICE_ID_MATCH_INT_CLASS | \
+		USB_DEVICE_ID_MATCH_INT_SUBCLASS | \
+		USB_DEVICE_ID_MATCH_INT_PROTOCOL)
 
 /**
  * USB_DEVICE - macro used to describe a specific usb device
@@ -467,9 +480,11 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific device.
  */
 #define USB_DEVICE(vend,prod) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), \
+			.idProduct = (prod)
 /**
- * USB_DEVICE_VER - macro used to describe a specific usb device with a version range
+ * USB_DEVICE_VER - macro used to describe a specific usb device with a
+ *		version range
  * @vend: the 16 bit USB Vendor ID
  * @prod: the 16 bit USB Product ID
  * @lo: the bcdDevice_lo value
@@ -479,7 +494,9 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific device, with a version range.
  */
 #define USB_DEVICE_VER(vend,prod,lo,hi) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (vend), .idProduct = (prod), .bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \
+	.idVendor = (vend), .idProduct = (prod), \
+	.bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
 
 /**
  * USB_DEVICE_INFO - macro used to describe a class of usb devices
@@ -491,7 +508,8 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific class of devices.
  */
 #define USB_DEVICE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), .bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
+	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), \
+	.bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
 
 /**
  * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces 
@@ -503,9 +521,10 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific class of interfaces.
  */
 #define USB_INTERFACE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), .bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /**
  * struct usb_driver - identifies USB driver to usbcore
@@ -558,7 +577,8 @@ struct usb_driver {
 
 	void (*disconnect) (struct usb_interface *intf);
 
-	int (*ioctl) (struct usb_interface *intf, unsigned int code, void *buf);
+	int (*ioctl) (struct usb_interface *intf, unsigned int code,
+			void *buf);
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
@@ -601,7 +621,7 @@ extern void usb_deregister_dev(struct usb_interface *intf,
 
 extern int usb_disabled(void);
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /*
  * URB support, for asynchronous request completions
@@ -611,12 +631,14 @@ extern int usb_disabled(void);
  * urb->transfer_flags:
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
-#define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame ignored */
+#define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame
+					 * ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb->transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0008	/* urb->setup_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
-#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
-#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
+#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
+#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
+					 * needed */
 
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
@@ -804,7 +826,8 @@ struct urb
 	u8 reject;			/* submissions will fail */
 
 	/* public, documented fields in the urb that can be used by drivers */
-	struct list_head urb_list;	/* list head for use by the urb owner */
+	struct list_head urb_list;	/* list head for use by the urb's
+					 * current owner */
 	struct usb_device *dev; 	/* (in) pointer to associated device */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
@@ -817,14 +840,16 @@ struct urb
 	dma_addr_t setup_dma;		/* (in) dma addr for setup_packet */
 	int start_frame;		/* (modify) start frame (ISO) */
 	int number_of_packets;		/* (in) number of ISO packets */
-	int interval;			/* (modify) transfer interval (INT/ISO) */
+	int interval;			/* (modify) transfer interval
+					 * (INT/ISO) */
 	int error_count;		/* (return) number of ISO errors */
 	void *context;			/* (in) context for completion */
 	usb_complete_t complete;	/* (in) completion routine */
-	struct usb_iso_packet_descriptor iso_frame_desc[0];	/* (in) ISO ONLY */
+	struct usb_iso_packet_descriptor iso_frame_desc[0];
+					/* (in) ISO ONLY */
 };
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /**
  * usb_fill_control_urb - initializes a control urb
@@ -1049,7 +1074,7 @@ void usb_sg_cancel (struct usb_sg_request *io);
 void usb_sg_wait (struct usb_sg_request *io);
 
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /*
  * For various legacy reasons, Linux has a small cookie that's paired with
@@ -1090,23 +1115,34 @@ void usb_sg_wait (struct usb_sg_request *io);
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
 #define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
-#define usb_settoggle(dev, ep, out, bit) ((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | ((bit) << (ep)))
+#define usb_settoggle(dev, ep, out, bit) \
+		((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | \
+		 ((bit) << (ep)))
 
 
-static inline unsigned int __create_pipe(struct usb_device *dev, unsigned int endpoint)
+static inline unsigned int __create_pipe(struct usb_device *dev,
+		unsigned int endpoint)
 {
 	return (dev->devnum << 8) | (endpoint << 15);
 }
 
 /* Create various pipes... */
-#define usb_sndctrlpipe(dev,endpoint)	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint))
-#define usb_rcvctrlpipe(dev,endpoint)	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint))
-#define usb_rcvisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndbulkpipe(dev,endpoint)	((PIPE_BULK << 30) | __create_pipe(dev,endpoint))
-#define usb_rcvbulkpipe(dev,endpoint)	((PIPE_BULK << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndintpipe(dev,endpoint)	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint))
-#define usb_rcvintpipe(dev,endpoint)	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndctrlpipe(dev,endpoint)	\
+	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvctrlpipe(dev,endpoint)	\
+	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndisocpipe(dev,endpoint)	\
+	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvisocpipe(dev,endpoint)	\
+	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndbulkpipe(dev,endpoint)	\
+	((PIPE_BULK << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvbulkpipe(dev,endpoint)	\
+	((PIPE_BULK << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndintpipe(dev,endpoint)	\
+	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvintpipe(dev,endpoint)	\
+	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
 
 /*-------------------------------------------------------------------------*/
 
@@ -1130,7 +1166,7 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 	return le16_to_cpu(ep->desc.wMaxPacketSize);
 }
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /* Events from the usb core */
 #define USB_DEVICE_ADD		0x0001
@@ -1141,14 +1177,18 @@ extern void usb_register_notify(struct notifier_block *nb);
 extern void usb_unregister_notify(struct notifier_block *nb);
 
 #ifdef DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg)
+#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , \
+	__FILE__ , ## arg)
 #else
 #define dbg(format, arg...) do {} while (0)
 #endif
 
-#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , __FILE__ , ## arg)
-#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , __FILE__ , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , __FILE__ , ## arg)
+#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , \
+	__FILE__ , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , \
+	__FILE__ , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , \
+	__FILE__ , ## arg)
 
 
 #endif  /* __KERNEL__ */

commit be69e5b1900a19a545becda822b18d6f09168ba5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Oct 25 15:56:06 2005 -0400

    [PATCH] usbcore: Improve endpoint sysfs file handling
    
    This revised patch (as587b) improves the implementation of USB endpoint
    sysfs files.  Instead of storing a whole bunch of attributes for every
    single endpoint, each endpoint now gets its own kobject and they can
    share a static list of attributes.  The number of extra fields added to
    struct usb_host_endpoint has been reduced from 4 to 1.
    
    The bEndpointAddress field is retained even though it is redundant (it
    repeats the same information as the attributes' directory name).  The
    code avoids calling kobject_register, to prevent generating unwanted
    hotplug events.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a2d923fd54f9..465ff4585ca5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -57,10 +57,7 @@ struct usb_host_endpoint {
 	struct usb_endpoint_descriptor	desc;
 	struct list_head		urb_list;
 	void				*hcpriv;
-	char 				*attr_name;
-	struct attribute_group		*attr_group;
-	struct attribute 		**attrs;
-	int				num_attrs;
+	struct kobject			*kobj;	/* For sysfs info */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;

commit 3099e75a7ccc3c5b0a4cf988a76d9c4a7fa5e91a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB: add notifier functions to the USB core for devices and busses
    
    This should let us get rid of all of the different hooks in the USB core for
    when something has changed.
    
    Also, some other parts of the kernel have wanted to know this kind of
    information at times.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 207b1ad9d990..a2d923fd54f9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1135,6 +1135,14 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 
 /* -------------------------------------------------------------------------- */
 
+/* Events from the usb core */
+#define USB_DEVICE_ADD		0x0001
+#define USB_DEVICE_REMOVE	0x0002
+#define USB_BUS_ADD		0x0003
+#define USB_BUS_REMOVE		0x0004
+extern void usb_register_notify(struct notifier_block *nb);
+extern void usb_unregister_notify(struct notifier_block *nb);
+
 #ifdef DEBUG
 #define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg)
 #else

commit 5edbfb7c8af0577097dae87cdd4dfdba82bb9579
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Sep 22 22:45:26 2005 -0700

    [PATCH] stop exporting two functions
    
    The way we're looking at USB suspend lately doesn't expect drivers to
    call usb_suspend_device() or usb_resume_device() directly; that'll
    be implicit when no interfaces are in use.
    
    This patch removes those APIs from visibility outside usbcore.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    
     drivers/usb/core/hub.c |   12 ++++--------
     drivers/usb/core/usb.h |    4 ++++
     include/linux/usb.h    |    5 -----
     3 files changed, 8 insertions(+), 13 deletions(-)

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 25ec91ddcd04..207b1ad9d990 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -975,11 +975,6 @@ extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 	void *data, int len, int *actual_length,
 	int timeout);
 
-/* selective suspend/resume */
-extern int usb_suspend_device(struct usb_device *dev);
-extern int usb_resume_device(struct usb_device *dev);
-
-
 /* wrappers around usb_control_msg() for the most common standard requests */
 extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
 	unsigned char descindex, void *buf, int size);

commit 390a8c345e6415cbf811232feedac70b56c9fc8d
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 13 19:57:27 2005 -0700

    [PATCH] remove usb_suspend_device() parameter
    
    This patch removes the extra usb_suspend_device() parameter.  The original
    reason to pass that parameter was so that this routine could suspend any
    active children.  A previous patch removed that functionality ... leaving
    no reason to pass the parameter.  A close analogy is pci_set_power_state,
    which doesn't need a pm_message_t either.
    
    On the internal code path that comes through the driver model, the parameter
    is now used to distinguish cases where USB devices need to "freeze" but not
    suspend.   It also checks for an error case that's accessible through sysfs:
    attempting to suspend a device before its interfaces (or for hubs, ports).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hub.c         |   34 +++++++++++++++++++++-------------
     drivers/usb/core/usb.c         |   23 +++++++++++++++++++++--
     drivers/usb/host/ehci-hcd.c    |    2 +-
     drivers/usb/host/isp116x-hcd.c |    2 +-
     drivers/usb/host/ohci-pci.c    |    2 +-
     include/linux/usb.h            |    2 +-
     6 files changed, 46 insertions(+), 19 deletions(-)

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 04502e183dd1..25ec91ddcd04 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -976,7 +976,7 @@ extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 	int timeout);
 
 /* selective suspend/resume */
-extern int usb_suspend_device(struct usb_device *dev, pm_message_t message);
+extern int usb_suspend_device(struct usb_device *dev);
 extern int usb_resume_device(struct usb_device *dev);
 
 

commit d6e5bcf4a7ebbe258124a931f1449338340a99b5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove the mode field from usb_class_driver as it's no longer needed
    
    Also fixes all drivers that set this field, and removes some other devfs
    specfic USB logic.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/class/usblp.c           |    3 +--
     drivers/usb/core/file.c             |   19 ++++---------------
     drivers/usb/image/mdc800.c          |    3 +--
     drivers/usb/input/aiptek.c          |    2 +-
     drivers/usb/input/hiddev.c          |    3 +--
     drivers/usb/media/dabusb.c          |    3 +--
     drivers/usb/misc/auerswald.c        |    3 +--
     drivers/usb/misc/idmouse.c          |    5 ++---
     drivers/usb/misc/legousbtower.c     |    5 ++---
     drivers/usb/misc/rio500.c           |    3 +--
     drivers/usb/misc/sisusbvga/sisusb.c |    5 -----
     drivers/usb/misc/usblcd.c           |    9 ++++-----
     drivers/usb/usb-skeleton.c          |    3 +--
     include/linux/usb.h                 |    7 ++-----
     14 files changed, 22 insertions(+), 51 deletions(-)

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4512210e97e7..04502e183dd1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -576,10 +576,8 @@ extern struct bus_type usb_bus_type;
 
 /**
  * struct usb_class_driver - identifies a USB driver that wants to use the USB major number
- * @name: devfs name for this driver.  Will also be used by the driver
- *	class code to create a usb class device.
+ * @name: the usb class device name for this driver.  Will show up in sysfs.
  * @fops: pointer to the struct file_operations of this driver.
- * @mode: the mode for the devfs file to be created for this driver.
  * @minor_base: the start of the minor range for this driver.
  *
  * This structure is used for the usb_register_dev() and
@@ -589,8 +587,7 @@ extern struct bus_type usb_bus_type;
 struct usb_class_driver {
 	char *name;
 	struct file_operations *fops;
-	mode_t mode;
-	int minor_base;	
+	int minor_base;
 };
 
 /*

commit 094f1649577dfc7f2c7407a8380e05a506b31f7f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB: add endpoint information to sysfs
    
    This patch adds endpoint information for both devices and interfaces to
    sysfs.  Previously it was only possible to get the endpoint information
    from usbfs, and never possible to get any information on endpoint 0.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/sysfs.c |  195 ++++++++++++++++++++++++++++++++++++++++++++++-
     include/linux/usb.h      |    4
     2 files changed, 197 insertions(+), 2 deletions(-)

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 8f731e8f2821..4512210e97e7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -57,6 +57,10 @@ struct usb_host_endpoint {
 	struct usb_endpoint_descriptor	desc;
 	struct list_head		urb_list;
 	void				*hcpriv;
+	char 				*attr_name;
+	struct attribute_group		*attr_group;
+	struct attribute 		**attrs;
+	int				num_attrs;
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;

commit 55016f10e31bb15b85d8c500f979dfdceb37d548
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:21:58 2005 -0400

    [PATCH] gfp_t: drivers/usb
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4dbe580f9335..8f731e8f2821 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -933,17 +933,17 @@ static inline void usb_fill_int_urb (struct urb *urb,
 }
 
 extern void usb_init_urb(struct urb *urb);
-extern struct urb *usb_alloc_urb(int iso_packets, unsigned mem_flags);
+extern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);
 extern void usb_free_urb(struct urb *urb);
 #define usb_put_urb usb_free_urb
 extern struct urb *usb_get_urb(struct urb *urb);
-extern int usb_submit_urb(struct urb *urb, unsigned mem_flags);
+extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 
 #define HAVE_USB_BUFFERS
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
-	unsigned mem_flags, dma_addr_t *dma);
+	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,
 	void *addr, dma_addr_t dma);
 
@@ -1050,7 +1050,7 @@ int usb_sg_init (
 	struct scatterlist	*sg,
 	int			nents,
 	size_t			length,
-	unsigned		mem_flags
+	gfp_t			mem_flags
 );
 void usb_sg_cancel (struct usb_sg_request *io);
 void usb_sg_wait (struct usb_sg_request *io);

commit b375a0495fd622037560c73c05f23ae6f127bb0c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jul 29 16:11:07 2005 -0400

    [PATCH] USB: URB_ASYNC_UNLINK flag removed from the kernel
    
    29 July 2005, Cambridge, MA:
    
    This afternoon Alan Stern submitted a patch to remove the URB_ASYNC_UNLINK
    flag from the Linux kernel.  Mr. Stern explained, "This flag is a relic
    from an earlier, less-well-designed system.  For over a year it hasn't
    been used for anything other than printing warning messages."
    
    An anonymous spokesman for the Linux kernel development community
    commented, "This is exactly the sort of thing we see happening all the
    time.  As the kernel evolves, support for old techniques and old code can
    be jettisoned and replaced by newer, better approaches.  Proprietary
    operating systems do not have the freedom or flexibility to change so
    quickly."
    
    Mr. Stern, a staff member at Harvard University's Rowland Institute who
    works on Linux only as a hobby, noted that the patch (labelled as548) did
    not update two files, keyspan.c and option.c, in the USB drivers' "serial"
    subdirectory.  "Those files need more extensive changes," he remarked.
    "They examine the status field of several URBs at times when they're not
    supposed to.  That will need to be fixed before the URB_ASYNC_UNLINK flag
    is removed."
    
    Greg Kroah-Hartman, the kernel maintainer responsible for overseeing all
    of Linux's USB drivers, did not respond to our inquiries or return our
    calls.  His only comment was "Applied, thanks."
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 434e35120c65..4dbe580f9335 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -616,7 +616,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb->transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0008	/* urb->setup_dma valid on submit */
-#define URB_ASYNC_UNLINK	0x0010	/* usb_unlink_urb() returns asap */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
@@ -724,13 +723,7 @@ typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
  * Initialization:
  *
  * All URBs submitted must initialize the dev, pipe, transfer_flags (may be
- * zero), and complete fields.
- * The URB_ASYNC_UNLINK transfer flag affects later invocations of
- * the usb_unlink_urb() routine.  Note: Failure to set URB_ASYNC_UNLINK
- * with usb_unlink_urb() is deprecated.  For synchronous unlinks use
- * usb_kill_urb() instead.
- *
- * All URBs must also initialize 
+ * zero), and complete fields.  All URBs must also initialize
  * transfer_buffer and transfer_buffer_length.  They may provide the
  * URB_SHORT_NOT_OK transfer flag, indicating that short reads are
  * to be treated as errors; that flag is invalid for write requests.

commit fbf82fd2e1f4e679c60516d772d1862c941ca845
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Jul 31 01:05:53 2005 +0200

    [PATCH] USB: real nodes instead of usbfs
    
    This patch introduces a /sys/class/usb_device/ class
    where every connected usb-device will show up:
    
      tree /sys/class/usb_device/
      /sys/class/usb_device/
      |-- usb1.1
      |   |-- dev
      |   `-- device -> ../../../devices/pci0000:00/0000:00:1d.0/usb1
      |-- usb2.1
      |   |-- dev
      |   `-- device -> ../../../devices/pci0000:00/0000:00:1d.1/usb2
      ...
    
    The presence of the "dev" file lets udev create real device nodes.
      kay@pim:~/src/linux-2.6> tree /dev/bus/usb/
      /dev/bus/usb/
      |-- 1
      |   `-- 1
      |-- 2
      |   `-- 1
      ...
    
    udev rule:
      SUBSYSTEM="usb_device", PROGRAM="/sbin/usb_device %k", NAME="%c"
      (echo $1 | /bin/sed 's/usb\([0-9]*\)\.\([0-9]*\)/bus\/usb\/\1\/\2/')
    
    This makes libusb pick up the real nodes instead of the mounted usbfs:
      export USB_DEVFS_PATH=/dev/bus/usb
    
    Background:
      All this makes it possible to manage usb devices with udev instead of
      the devfs solution. We are currently working on a pam_console/resmgr
      replacement driven by udev and a pam-helper. It applies ACL's to device
      nodes, which is required for modern desktop functionalty like
      "Fast User Switching" or multiple local login support.
    
    New patch with its own major. I've succesfully disabled usbfs and use real
    nodes only on my box. With: "export USB_DEVFS_PATH=/dev/bus/usb" libusb picks
    up the udev managed nodes instead of reading usbfs files.
    
    This makes udev to provide symlinks for libusb to pick up:
      SUBSYSTEM="usb_device", PROGRAM="/sbin/usbdevice %k", SYMLINK="%c"
    
    /sbin/usbdevice:
      #!/bin/sh
      echo $1 | /bin/sed 's/usbdev\([0-9]*\)\.\([0-9]*\)/bus\/usb\/\1\/\2/'
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 724637792996..434e35120c65 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -5,6 +5,7 @@
 #include <linux/usb_ch9.h>
 
 #define USB_MAJOR			180
+#define USB_DEVICE_MAJOR		189
 
 
 #ifdef __KERNEL__
@@ -349,6 +350,7 @@ struct usb_device {
 	char *manufacturer;
 	char *serial;			/* static strings from the device */
 	struct list_head filelist;
+	struct class_device *class_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
 
 	/*

commit 5db539e49fc7471e23bf3c94ca304f008cb7b7f3
Author: Olav Kongas <ok@artecdesign.ee>
Date:   Thu Jun 23 20:25:36 2005 +0300

    [PATCH] USB: Fix kmalloc's flags type in USB
    
    Greg,
    
    This patch fixes the kmalloc() flags argument type in USB
    subsystem; hopefully all of its occurences. The patch was
    made against patch-2.6.12-git2 from Jun 20.
    
    Cleanup of flags for kmalloc() in USB subsystem.
    
    Signed-off-by: Olav Kongas <ok@artecdesign.ee>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index eb282b581546..724637792996 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -938,17 +938,17 @@ static inline void usb_fill_int_urb (struct urb *urb,
 }
 
 extern void usb_init_urb(struct urb *urb);
-extern struct urb *usb_alloc_urb(int iso_packets, int mem_flags);
+extern struct urb *usb_alloc_urb(int iso_packets, unsigned mem_flags);
 extern void usb_free_urb(struct urb *urb);
 #define usb_put_urb usb_free_urb
 extern struct urb *usb_get_urb(struct urb *urb);
-extern int usb_submit_urb(struct urb *urb, int mem_flags);
+extern int usb_submit_urb(struct urb *urb, unsigned mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 
 #define HAVE_USB_BUFFERS
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
-	int mem_flags, dma_addr_t *dma);
+	unsigned mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,
 	void *addr, dma_addr_t dma);
 
@@ -1055,7 +1055,7 @@ int usb_sg_init (
 	struct scatterlist	*sg,
 	int			nents,
 	size_t			length,
-	int			mem_flags
+	unsigned		mem_flags
 );
 void usb_sg_cancel (struct usb_sg_request *io);
 void usb_sg_wait (struct usb_sg_request *io);

commit 4749f32da939d4e4160541b2cadc22492bb507ec
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jun 23 11:36:56 2005 +0200

    [PATCH] better USB_MON dependencies
    
    This makes the USB_MON less confusing.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3d508bf08402..eb282b581546 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -290,7 +290,7 @@ struct usb_bus {
 	struct class_device *class_dev;	/* class device for this bus */
 	struct kref kref;		/* handles reference counting this bus */
 	void (*release)(struct usb_bus *bus);	/* function to destroy this bus's memory */
-#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
+#if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif

commit 8561b10f6e7ef0a085709ffc844f74130a067abe
Author: gregkh@suse.de <gregkh@suse.de>
Date:   Tue Mar 15 15:10:13 2005 -0800

    [PATCH] USB: move the usb hcd code to use the new class code.
    
    This moves a kref into the main hcd structure, which detaches it from
    the class device structure.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2d1ac5058534..3d508bf08402 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -287,15 +287,14 @@ struct usb_bus {
 
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
-	struct class_device class_dev;	/* class device for this bus */
+	struct class_device *class_dev;	/* class device for this bus */
+	struct kref kref;		/* handles reference counting this bus */
 	void (*release)(struct usb_bus *bus);	/* function to destroy this bus's memory */
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif
 };
-#define	to_usb_bus(d) container_of(d, struct usb_bus, class_dev)
-
 
 /* -------------------------------------------------------------------------- */
 

commit 719df469cb51199316ae2a11c75a8046be34b899
Author: Roman Kagan <rkagan@mail.ru>
Date:   Fri May 6 00:55:56 2005 +0400

    [PATCH] USB: update urb documentation
    
    On Wed, May 04, 2005 at 01:37:30PM -0700, David Brownell wrote:
    > On Wednesday 04 May 2005 12:19 pm, Roman Kagan wrote:
    > > struct urb {
    > >     /* private, usb core and host controller only fields in the urb */
    > >     ...
    > >     struct list_head urb_list;      /* list pointer to all active urbs */
    > >     ...
    > > };
    > >
    > > Is it safe to use it for driver's purposes when the driver owns the urb,
    > > that is, starting from the completion routine until the urb is submitted
    > > with usb_submit_urb()?
    >
    > Right now, it should be.
    
    Great!  FWIW I've briefly tested a modified version of usbatm using
    the list head in struct urb instead of creating a wrapper struct, and I
    haven't seen any failures yet.  So I tend to believe that your "should
    be" actually means "is" :)
    
    > > If it is, can it be guaranteed in future, e.g.
    > > by moving the list head into the public section of struct urb?
    >
    > In fact I'm not sure why it ever got called "private" to usbcore/hcds.
    > I thought the idea was that it should be like urb->status, reserved for
    > whoever controls the URB.
    
    OK then how about the following (essentially documentation) patch?
    
    Signed-off-by: Roman Kagan <rkagan@mail.ru>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 41d1a644c9d4..2d1ac5058534 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -796,6 +796,10 @@ typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
  * of the iso_frame_desc array, and the number of errors is reported in
  * error_count.  Completion callbacks for ISO transfers will normally
  * (re)submit URBs to ensure a constant transfer rate.
+ *
+ * Note that even fields marked "public" should not be touched by the driver
+ * when the urb is owned by the hcd, that is, since the call to
+ * usb_submit_urb() till the entry into the completion routine.
  */
 struct urb
 {
@@ -803,12 +807,12 @@ struct urb
 	struct kref kref;		/* reference count of the URB */
 	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
-	struct list_head urb_list;	/* list pointer to all active urbs */
 	int bandwidth;			/* bandwidth for INT/ISO request */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
 
 	/* public, documented fields in the urb that can be used by drivers */
+	struct list_head urb_list;	/* list head for use by the urb owner */
 	struct usb_device *dev; 	/* (in) pointer to associated device */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */

commit 27d72e8572336d9f4e17a12ac924cb5223a5758d
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 18 17:39:22 2005 -0700

    [PATCH] usb suspend updates (interface suspend)
    
    This is the first of a few installments of PM API updates to match the
    recent switch to "pm_message_t".  This installment primarily affects
    USB device drivers (for USB interfaces), and it changes the handful of
    drivers which currently implement suspend methods:
    
        - <linux/usb.h> and usbcore, signature change
    
        - Some drivers only changed the signature, net effect this just
          shuts up "sparse -Wbitwise":
            * hid-core
            * stir4200
    
        - Two network drivers did that, and also grew slightly more
          featureful suspend code ... they now properly shut down
          their activities.  (As should stir4200...)
            * pegasus
            * usbnet
    
    Note that the Wake-On-Lan (WOL) support in pegasus doesn't yet work; looks
    to me like it's missing a request to turn it on, vs just configuring it.
    The ASIX code in usbnet also has WOL hooks that are ready to use; untested.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    Index: gregkh-2.6/drivers/net/irda/stir4200.c
    ===================================================================

diff --git a/include/linux/usb.h b/include/linux/usb.h
index c96728435935..41d1a644c9d4 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -558,7 +558,7 @@ struct usb_driver {
 
 	int (*ioctl) (struct usb_interface *intf, unsigned int code, void *buf);
 
-	int (*suspend) (struct usb_interface *intf, u32 state);
+	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
 
 	const struct usb_device_id *id_table;
@@ -977,7 +977,7 @@ extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 	int timeout);
 
 /* selective suspend/resume */
-extern int usb_suspend_device(struct usb_device *dev, u32 state);
+extern int usb_suspend_device(struct usb_device *dev, pm_message_t message);
 extern int usb_resume_device(struct usb_device *dev);
 
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/usb.h b/include/linux/usb.h
new file mode 100644
index 000000000000..c96728435935
--- /dev/null
+++ b/include/linux/usb.h
@@ -0,0 +1,1157 @@
+#ifndef __LINUX_USB_H
+#define __LINUX_USB_H
+
+#include <linux/mod_devicetable.h>
+#include <linux/usb_ch9.h>
+
+#define USB_MAJOR			180
+
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/errno.h>        /* for -ENODEV */
+#include <linux/delay.h>	/* for mdelay() */
+#include <linux/interrupt.h>	/* for in_interrupt() */
+#include <linux/list.h>		/* for struct list_head */
+#include <linux/kref.h>		/* for struct kref */
+#include <linux/device.h>	/* for struct device */
+#include <linux/fs.h>		/* for struct file_operations */
+#include <linux/completion.h>	/* for struct completion */
+#include <linux/sched.h>	/* for current && schedule_timeout */
+
+struct usb_device;
+struct usb_driver;
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Host-side wrappers for standard USB descriptors ... these are parsed
+ * from the data provided by devices.  Parsing turns them from a flat
+ * sequence of descriptors into a hierarchy:
+ *
+ *  - devices have one (usually) or more configs;
+ *  - configs have one (often) or more interfaces;
+ *  - interfaces have one (usually) or more settings;
+ *  - each interface setting has zero or (usually) more endpoints.
+ *
+ * And there might be other descriptors mixed in with those.
+ *
+ * Devices may also have class-specific or vendor-specific descriptors.
+ */
+
+/**
+ * struct usb_host_endpoint - host-side endpoint descriptor and queue
+ * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
+ * @urb_list: urbs queued to this endpoint; maintained by usbcore
+ * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
+ *	with one or more transfer descriptors (TDs) per urb
+ * @extra: descriptors following this endpoint in the configuration
+ * @extralen: how many bytes of "extra" are valid
+ *
+ * USB requests are always queued to a given endpoint, identified by a
+ * descriptor within an active interface in a given USB configuration.
+ */
+struct usb_host_endpoint {
+	struct usb_endpoint_descriptor	desc;
+	struct list_head		urb_list;
+	void				*hcpriv;
+
+	unsigned char *extra;   /* Extra descriptors */
+	int extralen;
+};
+
+/* host-side wrapper for one interface setting's parsed descriptors */
+struct usb_host_interface {
+	struct usb_interface_descriptor	desc;
+
+	/* array of desc.bNumEndpoint endpoints associated with this
+	 * interface setting.  these will be in no particular order.
+	 */
+	struct usb_host_endpoint *endpoint;
+
+	char *string;		/* iInterface string, if present */
+	unsigned char *extra;   /* Extra descriptors */
+	int extralen;
+};
+
+enum usb_interface_condition {
+	USB_INTERFACE_UNBOUND = 0,
+	USB_INTERFACE_BINDING,
+	USB_INTERFACE_BOUND,
+	USB_INTERFACE_UNBINDING,
+};
+
+/**
+ * struct usb_interface - what usb device drivers talk to
+ * @altsetting: array of interface structures, one for each alternate
+ * 	setting that may be selected.  Each one includes a set of
+ * 	endpoint configurations.  They will be in no particular order.
+ * @num_altsetting: number of altsettings defined.
+ * @cur_altsetting: the current altsetting.
+ * @driver: the USB driver that is bound to this interface.
+ * @minor: the minor number assigned to this interface, if this
+ *	interface is bound to a driver that uses the USB major number.
+ *	If this interface does not use the USB major, this field should
+ *	be unused.  The driver should set this value in the probe()
+ *	function of the driver, after it has been assigned a minor
+ *	number from the USB core by calling usb_register_dev().
+ * @condition: binding state of the interface: not bound, binding
+ *	(in probe()), bound to a driver, or unbinding (in disconnect())
+ * @dev: driver model's view of this device
+ * @class_dev: driver model's class view of this device.
+ *
+ * USB device drivers attach to interfaces on a physical device.  Each
+ * interface encapsulates a single high level function, such as feeding
+ * an audio stream to a speaker or reporting a change in a volume control.
+ * Many USB devices only have one interface.  The protocol used to talk to
+ * an interface's endpoints can be defined in a usb "class" specification,
+ * or by a product's vendor.  The (default) control endpoint is part of
+ * every interface, but is never listed among the interface's descriptors.
+ *
+ * The driver that is bound to the interface can use standard driver model
+ * calls such as dev_get_drvdata() on the dev member of this structure.
+ *
+ * Each interface may have alternate settings.  The initial configuration
+ * of a device sets altsetting 0, but the device driver can change
+ * that setting using usb_set_interface().  Alternate settings are often
+ * used to control the the use of periodic endpoints, such as by having
+ * different endpoints use different amounts of reserved USB bandwidth.
+ * All standards-conformant USB devices that use isochronous endpoints
+ * will use them in non-default settings.
+ *
+ * The USB specification says that alternate setting numbers must run from
+ * 0 to one less than the total number of alternate settings.  But some
+ * devices manage to mess this up, and the structures aren't necessarily
+ * stored in numerical order anyhow.  Use usb_altnum_to_altsetting() to
+ * look up an alternate setting in the altsetting array based on its number.
+ */
+struct usb_interface {
+	/* array of alternate settings for this interface,
+	 * stored in no particular order */
+	struct usb_host_interface *altsetting;
+
+	struct usb_host_interface *cur_altsetting;	/* the currently
+					 * active alternate setting */
+	unsigned num_altsetting;	/* number of alternate settings */
+
+	int minor;			/* minor number this interface is bound to */
+	enum usb_interface_condition condition;		/* state of binding */
+	struct device dev;		/* interface specific device info */
+	struct class_device *class_dev;
+};
+#define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
+#define	interface_to_usbdev(intf) \
+	container_of(intf->dev.parent, struct usb_device, dev)
+
+static inline void *usb_get_intfdata (struct usb_interface *intf)
+{
+	return dev_get_drvdata (&intf->dev);
+}
+
+static inline void usb_set_intfdata (struct usb_interface *intf, void *data)
+{
+	dev_set_drvdata(&intf->dev, data);
+}
+
+struct usb_interface *usb_get_intf(struct usb_interface *intf);
+void usb_put_intf(struct usb_interface *intf);
+
+/* this maximum is arbitrary */
+#define USB_MAXINTERFACES	32
+
+/**
+ * struct usb_interface_cache - long-term representation of a device interface
+ * @num_altsetting: number of altsettings defined.
+ * @ref: reference counter.
+ * @altsetting: variable-length array of interface structures, one for
+ *	each alternate setting that may be selected.  Each one includes a
+ *	set of endpoint configurations.  They will be in no particular order.
+ *
+ * These structures persist for the lifetime of a usb_device, unlike
+ * struct usb_interface (which persists only as long as its configuration
+ * is installed).  The altsetting arrays can be accessed through these
+ * structures at any time, permitting comparison of configurations and
+ * providing support for the /proc/bus/usb/devices pseudo-file.
+ */
+struct usb_interface_cache {
+	unsigned num_altsetting;	/* number of alternate settings */
+	struct kref ref;		/* reference counter */
+
+	/* variable-length array of alternate settings for this interface,
+	 * stored in no particular order */
+	struct usb_host_interface altsetting[0];
+};
+#define	ref_to_usb_interface_cache(r) \
+		container_of(r, struct usb_interface_cache, ref)
+#define	altsetting_to_usb_interface_cache(a) \
+		container_of(a, struct usb_interface_cache, altsetting[0])
+
+/**
+ * struct usb_host_config - representation of a device's configuration
+ * @desc: the device's configuration descriptor.
+ * @string: pointer to the cached version of the iConfiguration string, if
+ *	present for this configuration.
+ * @interface: array of pointers to usb_interface structures, one for each
+ *	interface in the configuration.  The number of interfaces is stored
+ *	in desc.bNumInterfaces.  These pointers are valid only while the
+ *	the configuration is active.
+ * @intf_cache: array of pointers to usb_interface_cache structures, one
+ *	for each interface in the configuration.  These structures exist
+ *	for the entire life of the device.
+ * @extra: pointer to buffer containing all extra descriptors associated
+ *	with this configuration (those preceding the first interface
+ *	descriptor).
+ * @extralen: length of the extra descriptors buffer.
+ *
+ * USB devices may have multiple configurations, but only one can be active
+ * at any time.  Each encapsulates a different operational environment;
+ * for example, a dual-speed device would have separate configurations for
+ * full-speed and high-speed operation.  The number of configurations
+ * available is stored in the device descriptor as bNumConfigurations.
+ *
+ * A configuration can contain multiple interfaces.  Each corresponds to
+ * a different function of the USB device, and all are available whenever
+ * the configuration is active.  The USB standard says that interfaces
+ * are supposed to be numbered from 0 to desc.bNumInterfaces-1, but a lot
+ * of devices get this wrong.  In addition, the interface array is not
+ * guaranteed to be sorted in numerical order.  Use usb_ifnum_to_if() to
+ * look up an interface entry based on its number.
+ *
+ * Device drivers should not attempt to activate configurations.  The choice
+ * of which configuration to install is a policy decision based on such
+ * considerations as available power, functionality provided, and the user's
+ * desires (expressed through hotplug scripts).  However, drivers can call
+ * usb_reset_configuration() to reinitialize the current configuration and
+ * all its interfaces.
+ */
+struct usb_host_config {
+	struct usb_config_descriptor	desc;
+
+	char *string;
+	/* the interfaces associated with this configuration,
+	 * stored in no particular order */
+	struct usb_interface *interface[USB_MAXINTERFACES];
+
+	/* Interface information available even when this is not the
+	 * active configuration */
+	struct usb_interface_cache *intf_cache[USB_MAXINTERFACES];
+
+	unsigned char *extra;   /* Extra descriptors */
+	int extralen;
+};
+
+int __usb_get_extra_descriptor(char *buffer, unsigned size,
+	unsigned char type, void **ptr);
+#define usb_get_extra_descriptor(ifpoint,type,ptr)\
+	__usb_get_extra_descriptor((ifpoint)->extra,(ifpoint)->extralen,\
+		type,(void**)ptr)
+
+/* -------------------------------------------------------------------------- */
+
+struct usb_operations;
+
+/* USB device number allocation bitmap */
+struct usb_devmap {
+	unsigned long devicemap[128 / (8*sizeof(unsigned long))];
+};
+
+/*
+ * Allocated per bus (tree of devices) we have:
+ */
+struct usb_bus {
+	struct device *controller;	/* host/master side hardware */
+	int busnum;			/* Bus number (in order of reg) */
+	char *bus_name;			/* stable id (PCI slot_name etc) */
+	u8 otg_port;			/* 0, or number of OTG/HNP port */
+	unsigned is_b_host:1;		/* true during some HNP roleswitches */
+	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
+
+	int devnum_next;		/* Next open device number in round-robin allocation */
+
+	struct usb_devmap devmap;	/* device address allocation map */
+	struct usb_operations *op;	/* Operations (specific to the HC) */
+	struct usb_device *root_hub;	/* Root hub */
+	struct list_head bus_list;	/* list of busses */
+	void *hcpriv;                   /* Host Controller private data */
+
+	int bandwidth_allocated;	/* on this bus: how much of the time
+					 * reserved for periodic (intr/iso)
+					 * requests is used, on average?
+					 * Units: microseconds/frame.
+					 * Limits: Full/low speed reserve 90%,
+					 * while high speed reserves 80%.
+					 */
+	int bandwidth_int_reqs;		/* number of Interrupt requests */
+	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
+
+	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
+
+	struct class_device class_dev;	/* class device for this bus */
+	void (*release)(struct usb_bus *bus);	/* function to destroy this bus's memory */
+#if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
+	struct mon_bus *mon_bus;	/* non-null when associated */
+	int monitored;			/* non-zero when monitored */
+#endif
+};
+#define	to_usb_bus(d) container_of(d, struct usb_bus, class_dev)
+
+
+/* -------------------------------------------------------------------------- */
+
+/* This is arbitrary.
+ * From USB 2.0 spec Table 11-13, offset 7, a hub can
+ * have up to 255 ports. The most yet reported is 10.
+ */
+#define USB_MAXCHILDREN		(16)
+
+struct usb_tt;
+
+/*
+ * struct usb_device - kernel's representation of a USB device
+ *
+ * FIXME: Write the kerneldoc!
+ *
+ * Usbcore drivers should not set usbdev->state directly.  Instead use
+ * usb_set_device_state().
+ */
+struct usb_device {
+	int		devnum;		/* Address on USB bus */
+	char		devpath [16];	/* Use in messages: /port/port/... */
+	enum usb_device_state	state;	/* configured, not attached, etc */
+	enum usb_device_speed	speed;	/* high/full/low (or error) */
+
+	struct usb_tt	*tt; 		/* low/full speed dev, highspeed hub */
+	int		ttport;		/* device port on that tt hub */
+
+	struct semaphore serialize;
+
+	unsigned int toggle[2];		/* one bit for each endpoint ([0] = IN, [1] = OUT) */
+
+	struct usb_device *parent;	/* our hub, unless we're the root */
+	struct usb_bus *bus;		/* Bus we're part of */
+	struct usb_host_endpoint ep0;
+
+	struct device dev;		/* Generic device interface */
+
+	struct usb_device_descriptor descriptor;/* Descriptor */
+	struct usb_host_config *config;	/* All of the configs */
+
+	struct usb_host_config *actconfig;/* the active configuration */
+	struct usb_host_endpoint *ep_in[16];
+	struct usb_host_endpoint *ep_out[16];
+
+	char **rawdescriptors;		/* Raw descriptors for each config */
+
+	int have_langid;		/* whether string_langid is valid yet */
+	int string_langid;		/* language ID for strings */
+
+	char *product;
+	char *manufacturer;
+	char *serial;			/* static strings from the device */
+	struct list_head filelist;
+	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */
+
+	/*
+	 * Child devices - these can be either new devices
+	 * (if this is a hub device), or different instances
+	 * of this same device.
+	 *
+	 * Each instance needs its own set of data structures.
+	 */
+
+	int maxchild;			/* Number of ports if hub */
+	struct usb_device *children[USB_MAXCHILDREN];
+};
+#define	to_usb_device(d) container_of(d, struct usb_device, dev)
+
+extern struct usb_device *usb_get_dev(struct usb_device *dev);
+extern void usb_put_dev(struct usb_device *dev);
+
+extern void usb_lock_device(struct usb_device *udev);
+extern int usb_trylock_device(struct usb_device *udev);
+extern int usb_lock_device_for_reset(struct usb_device *udev,
+		struct usb_interface *iface);
+extern void usb_unlock_device(struct usb_device *udev);
+
+/* USB port reset for device reinitialization */
+extern int usb_reset_device(struct usb_device *dev);
+
+extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
+
+/*-------------------------------------------------------------------------*/
+
+/* for drivers using iso endpoints */
+extern int usb_get_current_frame_number (struct usb_device *usb_dev);
+
+/* used these for multi-interface device registration */
+extern int usb_driver_claim_interface(struct usb_driver *driver,
+			struct usb_interface *iface, void* priv);
+
+/**
+ * usb_interface_claimed - returns true iff an interface is claimed
+ * @iface: the interface being checked
+ *
+ * Returns true (nonzero) iff the interface is claimed, else false (zero).
+ * Callers must own the driver model's usb bus readlock.  So driver
+ * probe() entries don't need extra locking, but other call contexts
+ * may need to explicitly claim that lock.
+ *
+ */
+static inline int usb_interface_claimed(struct usb_interface *iface) {
+	return (iface->dev.driver != NULL);
+}
+
+extern void usb_driver_release_interface(struct usb_driver *driver,
+			struct usb_interface *iface);
+const struct usb_device_id *usb_match_id(struct usb_interface *interface,
+					 const struct usb_device_id *id);
+
+extern struct usb_interface *usb_find_interface(struct usb_driver *drv,
+		int minor);
+extern struct usb_interface *usb_ifnum_to_if(struct usb_device *dev,
+		unsigned ifnum);
+extern struct usb_host_interface *usb_altnum_to_altsetting(
+		struct usb_interface *intf, unsigned int altnum);
+
+
+/**
+ * usb_make_path - returns stable device path in the usb tree
+ * @dev: the device whose path is being constructed
+ * @buf: where to put the string
+ * @size: how big is "buf"?
+ *
+ * Returns length of the string (> 0) or negative if size was too small.
+ *
+ * This identifier is intended to be "stable", reflecting physical paths in
+ * hardware such as physical bus addresses for host controllers or ports on
+ * USB hubs.  That makes it stay the same until systems are physically
+ * reconfigured, by re-cabling a tree of USB devices or by moving USB host
+ * controllers.  Adding and removing devices, including virtual root hubs
+ * in host controller driver modules, does not change these path identifers;
+ * neither does rebooting or re-enumerating.  These are more useful identifiers
+ * than changeable ("unstable") ones like bus numbers or device addresses.
+ *
+ * With a partial exception for devices connected to USB 2.0 root hubs, these
+ * identifiers are also predictable.  So long as the device tree isn't changed,
+ * plugging any USB device into a given hub port always gives it the same path.
+ * Because of the use of "companion" controllers, devices connected to ports on
+ * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
+ * high speed, and a different one if they are full or low speed.
+ */
+static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
+{
+	int actual;
+	actual = snprintf (buf, size, "usb-%s-%s", dev->bus->bus_name, dev->devpath);
+	return (actual >= (int)size) ? -1 : actual;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#define USB_DEVICE_ID_MATCH_DEVICE		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
+#define USB_DEVICE_ID_MATCH_DEV_RANGE		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
+#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION	(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
+#define USB_DEVICE_ID_MATCH_DEV_INFO \
+	(USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
+#define USB_DEVICE_ID_MATCH_INT_INFO \
+	(USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
+
+/**
+ * USB_DEVICE - macro used to describe a specific usb device
+ * @vend: the 16 bit USB Vendor ID
+ * @prod: the 16 bit USB Product ID
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific device.
+ */
+#define USB_DEVICE(vend,prod) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)
+/**
+ * USB_DEVICE_VER - macro used to describe a specific usb device with a version range
+ * @vend: the 16 bit USB Vendor ID
+ * @prod: the 16 bit USB Product ID
+ * @lo: the bcdDevice_lo value
+ * @hi: the bcdDevice_hi value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific device, with a version range.
+ */
+#define USB_DEVICE_VER(vend,prod,lo,hi) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (vend), .idProduct = (prod), .bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
+
+/**
+ * USB_DEVICE_INFO - macro used to describe a class of usb devices
+ * @cl: bDeviceClass value
+ * @sc: bDeviceSubClass value
+ * @pr: bDeviceProtocol value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific class of devices.
+ */
+#define USB_DEVICE_INFO(cl,sc,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), .bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
+
+/**
+ * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces 
+ * @cl: bInterfaceClass value
+ * @sc: bInterfaceSubClass value
+ * @pr: bInterfaceProtocol value
+ *
+ * This macro is used to create a struct usb_device_id that matches a
+ * specific class of interfaces.
+ */
+#define USB_INTERFACE_INFO(cl,sc,pr) \
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), .bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+
+/* -------------------------------------------------------------------------- */
+
+/**
+ * struct usb_driver - identifies USB driver to usbcore
+ * @owner: Pointer to the module owner of this driver; initialize
+ *	it using THIS_MODULE.
+ * @name: The driver name should be unique among USB drivers,
+ *	and should normally be the same as the module name.
+ * @probe: Called to see if the driver is willing to manage a particular
+ *	interface on a device.  If it is, probe returns zero and uses
+ *	dev_set_drvdata() to associate driver-specific data with the
+ *	interface.  It may also use usb_set_interface() to specify the
+ *	appropriate altsetting.  If unwilling to manage the interface,
+ *	return a negative errno value.
+ * @disconnect: Called when the interface is no longer accessible, usually
+ *	because its device has been (or is being) disconnected or the
+ *	driver module is being unloaded.
+ * @ioctl: Used for drivers that want to talk to userspace through
+ *	the "usbfs" filesystem.  This lets devices provide ways to
+ *	expose information to user space regardless of where they
+ *	do (or don't) show up otherwise in the filesystem.
+ * @suspend: Called when the device is going to be suspended by the system.
+ * @resume: Called when the device is being resumed by the system.
+ * @id_table: USB drivers use ID table to support hotplugging.
+ *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
+ *	or your driver's probe function will never get called.
+ * @driver: the driver model core driver structure.
+ *
+ * USB drivers must provide a name, probe() and disconnect() methods,
+ * and an id_table.  Other driver fields are optional.
+ *
+ * The id_table is used in hotplugging.  It holds a set of descriptors,
+ * and specialized data may be associated with each entry.  That table
+ * is used by both user and kernel mode hotplugging support.
+ *
+ * The probe() and disconnect() methods are called in a context where
+ * they can sleep, but they should avoid abusing the privilege.  Most
+ * work to connect to a device should be done when the device is opened,
+ * and undone at the last close.  The disconnect code needs to address
+ * concurrency issues with respect to open() and close() methods, as
+ * well as forcing all pending I/O requests to complete (by unlinking
+ * them as necessary, and blocking until the unlinks complete).
+ */
+struct usb_driver {
+	struct module *owner;
+
+	const char *name;
+
+	int (*probe) (struct usb_interface *intf,
+		      const struct usb_device_id *id);
+
+	void (*disconnect) (struct usb_interface *intf);
+
+	int (*ioctl) (struct usb_interface *intf, unsigned int code, void *buf);
+
+	int (*suspend) (struct usb_interface *intf, u32 state);
+	int (*resume) (struct usb_interface *intf);
+
+	const struct usb_device_id *id_table;
+
+	struct device_driver driver;
+};
+#define	to_usb_driver(d) container_of(d, struct usb_driver, driver)
+
+extern struct bus_type usb_bus_type;
+
+/**
+ * struct usb_class_driver - identifies a USB driver that wants to use the USB major number
+ * @name: devfs name for this driver.  Will also be used by the driver
+ *	class code to create a usb class device.
+ * @fops: pointer to the struct file_operations of this driver.
+ * @mode: the mode for the devfs file to be created for this driver.
+ * @minor_base: the start of the minor range for this driver.
+ *
+ * This structure is used for the usb_register_dev() and
+ * usb_unregister_dev() functions, to consolidate a number of the
+ * parameters used for them.
+ */
+struct usb_class_driver {
+	char *name;
+	struct file_operations *fops;
+	mode_t mode;
+	int minor_base;	
+};
+
+/*
+ * use these in module_init()/module_exit()
+ * and don't forget MODULE_DEVICE_TABLE(usb, ...)
+ */
+extern int usb_register(struct usb_driver *);
+extern void usb_deregister(struct usb_driver *);
+
+extern int usb_register_dev(struct usb_interface *intf,
+			    struct usb_class_driver *class_driver);
+extern void usb_deregister_dev(struct usb_interface *intf,
+			       struct usb_class_driver *class_driver);
+
+extern int usb_disabled(void);
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * URB support, for asynchronous request completions
+ */
+
+/*
+ * urb->transfer_flags:
+ */
+#define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
+#define URB_ISO_ASAP		0x0002	/* iso-only, urb->start_frame ignored */
+#define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb->transfer_dma valid on submit */
+#define URB_NO_SETUP_DMA_MAP	0x0008	/* urb->setup_dma valid on submit */
+#define URB_ASYNC_UNLINK	0x0010	/* usb_unlink_urb() returns asap */
+#define URB_NO_FSBR		0x0020	/* UHCI-specific */
+#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
+#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
+
+struct usb_iso_packet_descriptor {
+	unsigned int offset;
+	unsigned int length;		/* expected length */
+	unsigned int actual_length;
+	unsigned int status;
+};
+
+struct urb;
+struct pt_regs;
+
+typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
+
+/**
+ * struct urb - USB Request Block
+ * @urb_list: For use by current owner of the URB.
+ * @pipe: Holds endpoint number, direction, type, and more.
+ *	Create these values with the eight macros available;
+ *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is "ctrl"
+ *	(control), "bulk", "int" (interrupt), or "iso" (isochronous).
+ *	For example usb_sndbulkpipe() or usb_rcvintpipe().  Endpoint
+ *	numbers range from zero to fifteen.  Note that "in" endpoint two
+ *	is a different endpoint (and pipe) from "out" endpoint two.
+ *	The current configuration controls the existence, type, and
+ *	maximum packet size of any given endpoint.
+ * @dev: Identifies the USB device to perform the request.
+ * @status: This is read in non-iso completion functions to get the
+ *	status of the particular request.  ISO requests only use it
+ *	to tell whether the URB was unlinked; detailed status for
+ *	each frame is in the fields of the iso_frame-desc.
+ * @transfer_flags: A variety of flags may be used to affect how URB
+ *	submission, unlinking, or operation are handled.  Different
+ *	kinds of URB can use different flags.
+ * @transfer_buffer:  This identifies the buffer to (or from) which
+ * 	the I/O request will be performed (unless URB_NO_TRANSFER_DMA_MAP
+ *	is set).  This buffer must be suitable for DMA; allocate it with
+ *	kmalloc() or equivalent.  For transfers to "in" endpoints, contents
+ *	of this buffer will be modified.  This buffer is used for the data
+ *	stage of control transfers.
+ * @transfer_dma: When transfer_flags includes URB_NO_TRANSFER_DMA_MAP,
+ *	the device driver is saying that it provided this DMA address,
+ *	which the host controller driver should use in preference to the
+ *	transfer_buffer.
+ * @transfer_buffer_length: How big is transfer_buffer.  The transfer may
+ *	be broken up into chunks according to the current maximum packet
+ *	size for the endpoint, which is a function of the configuration
+ *	and is encoded in the pipe.  When the length is zero, neither
+ *	transfer_buffer nor transfer_dma is used.
+ * @actual_length: This is read in non-iso completion functions, and
+ *	it tells how many bytes (out of transfer_buffer_length) were
+ *	transferred.  It will normally be the same as requested, unless
+ *	either an error was reported or a short read was performed.
+ *	The URB_SHORT_NOT_OK transfer flag may be used to make such
+ *	short reads be reported as errors. 
+ * @setup_packet: Only used for control transfers, this points to eight bytes
+ *	of setup data.  Control transfers always start by sending this data
+ *	to the device.  Then transfer_buffer is read or written, if needed.
+ * @setup_dma: For control transfers with URB_NO_SETUP_DMA_MAP set, the
+ *	device driver has provided this DMA address for the setup packet.
+ *	The host controller driver should use this in preference to
+ *	setup_packet.
+ * @start_frame: Returns the initial frame for isochronous transfers.
+ * @number_of_packets: Lists the number of ISO transfer buffers.
+ * @interval: Specifies the polling interval for interrupt or isochronous
+ *	transfers.  The units are frames (milliseconds) for for full and low
+ *	speed devices, and microframes (1/8 millisecond) for highspeed ones.
+ * @error_count: Returns the number of ISO transfers that reported errors.
+ * @context: For use in completion functions.  This normally points to
+ *	request-specific driver context.
+ * @complete: Completion handler. This URB is passed as the parameter to the
+ *	completion function.  The completion function may then do what
+ *	it likes with the URB, including resubmitting or freeing it.
+ * @iso_frame_desc: Used to provide arrays of ISO transfer buffers and to 
+ *	collect the transfer status for each buffer.
+ *
+ * This structure identifies USB transfer requests.  URBs must be allocated by
+ * calling usb_alloc_urb() and freed with a call to usb_free_urb().
+ * Initialization may be done using various usb_fill_*_urb() functions.  URBs
+ * are submitted using usb_submit_urb(), and pending requests may be canceled
+ * using usb_unlink_urb() or usb_kill_urb().
+ *
+ * Data Transfer Buffers:
+ *
+ * Normally drivers provide I/O buffers allocated with kmalloc() or otherwise
+ * taken from the general page pool.  That is provided by transfer_buffer
+ * (control requests also use setup_packet), and host controller drivers
+ * perform a dma mapping (and unmapping) for each buffer transferred.  Those
+ * mapping operations can be expensive on some platforms (perhaps using a dma
+ * bounce buffer or talking to an IOMMU),
+ * although they're cheap on commodity x86 and ppc hardware.
+ *
+ * Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,
+ * which tell the host controller driver that no such mapping is needed since
+ * the device driver is DMA-aware.  For example, a device driver might
+ * allocate a DMA buffer with usb_buffer_alloc() or call usb_buffer_map().
+ * When these transfer flags are provided, host controller drivers will
+ * attempt to use the dma addresses found in the transfer_dma and/or
+ * setup_dma fields rather than determining a dma address themselves.  (Note
+ * that transfer_buffer and setup_packet must still be set because not all
+ * host controllers use DMA, nor do virtual root hubs).
+ *
+ * Initialization:
+ *
+ * All URBs submitted must initialize the dev, pipe, transfer_flags (may be
+ * zero), and complete fields.
+ * The URB_ASYNC_UNLINK transfer flag affects later invocations of
+ * the usb_unlink_urb() routine.  Note: Failure to set URB_ASYNC_UNLINK
+ * with usb_unlink_urb() is deprecated.  For synchronous unlinks use
+ * usb_kill_urb() instead.
+ *
+ * All URBs must also initialize 
+ * transfer_buffer and transfer_buffer_length.  They may provide the
+ * URB_SHORT_NOT_OK transfer flag, indicating that short reads are
+ * to be treated as errors; that flag is invalid for write requests.
+ *
+ * Bulk URBs may
+ * use the URB_ZERO_PACKET transfer flag, indicating that bulk OUT transfers
+ * should always terminate with a short packet, even if it means adding an
+ * extra zero length packet.
+ *
+ * Control URBs must provide a setup_packet.  The setup_packet and
+ * transfer_buffer may each be mapped for DMA or not, independently of
+ * the other.  The transfer_flags bits URB_NO_TRANSFER_DMA_MAP and
+ * URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.
+ * URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.
+ *
+ * Interrupt URBs must provide an interval, saying how often (in milliseconds
+ * or, for highspeed devices, 125 microsecond units)
+ * to poll for transfers.  After the URB has been submitted, the interval
+ * field reflects how the transfer was actually scheduled.
+ * The polling interval may be more frequent than requested.
+ * For example, some controllers have a maximum interval of 32 milliseconds,
+ * while others support intervals of up to 1024 milliseconds.
+ * Isochronous URBs also have transfer intervals.  (Note that for isochronous
+ * endpoints, as well as high speed interrupt endpoints, the encoding of
+ * the transfer interval in the endpoint descriptor is logarithmic.
+ * Device drivers must convert that value to linear units themselves.)
+ *
+ * Isochronous URBs normally use the URB_ISO_ASAP transfer flag, telling
+ * the host controller to schedule the transfer as soon as bandwidth
+ * utilization allows, and then set start_frame to reflect the actual frame
+ * selected during submission.  Otherwise drivers must specify the start_frame
+ * and handle the case where the transfer can't begin then.  However, drivers
+ * won't know how bandwidth is currently allocated, and while they can
+ * find the current frame using usb_get_current_frame_number () they can't
+ * know the range for that frame number.  (Ranges for frame counter values
+ * are HC-specific, and can go from 256 to 65536 frames from "now".)
+ *
+ * Isochronous URBs have a different data transfer model, in part because
+ * the quality of service is only "best effort".  Callers provide specially
+ * allocated URBs, with number_of_packets worth of iso_frame_desc structures
+ * at the end.  Each such packet is an individual ISO transfer.  Isochronous
+ * URBs are normally queued, submitted by drivers to arrange that
+ * transfers are at least double buffered, and then explicitly resubmitted
+ * in completion handlers, so
+ * that data (such as audio or video) streams at as constant a rate as the
+ * host controller scheduler can support.
+ *
+ * Completion Callbacks:
+ *
+ * The completion callback is made in_interrupt(), and one of the first
+ * things that a completion handler should do is check the status field.
+ * The status field is provided for all URBs.  It is used to report
+ * unlinked URBs, and status for all non-ISO transfers.  It should not
+ * be examined before the URB is returned to the completion handler.
+ *
+ * The context field is normally used to link URBs back to the relevant
+ * driver or request state.
+ *
+ * When the completion callback is invoked for non-isochronous URBs, the
+ * actual_length field tells how many bytes were transferred.  This field
+ * is updated even when the URB terminated with an error or was unlinked.
+ *
+ * ISO transfer status is reported in the status and actual_length fields
+ * of the iso_frame_desc array, and the number of errors is reported in
+ * error_count.  Completion callbacks for ISO transfers will normally
+ * (re)submit URBs to ensure a constant transfer rate.
+ */
+struct urb
+{
+	/* private, usb core and host controller only fields in the urb */
+	struct kref kref;		/* reference count of the URB */
+	spinlock_t lock;		/* lock for the URB */
+	void *hcpriv;			/* private data for host controller */
+	struct list_head urb_list;	/* list pointer to all active urbs */
+	int bandwidth;			/* bandwidth for INT/ISO request */
+	atomic_t use_count;		/* concurrent submissions counter */
+	u8 reject;			/* submissions will fail */
+
+	/* public, documented fields in the urb that can be used by drivers */
+	struct usb_device *dev; 	/* (in) pointer to associated device */
+	unsigned int pipe;		/* (in) pipe information */
+	int status;			/* (return) non-ISO status */
+	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/
+	void *transfer_buffer;		/* (in) associated data buffer */
+	dma_addr_t transfer_dma;	/* (in) dma addr for transfer_buffer */
+	int transfer_buffer_length;	/* (in) data buffer length */
+	int actual_length;		/* (return) actual transfer length */
+	unsigned char *setup_packet;	/* (in) setup packet (control only) */
+	dma_addr_t setup_dma;		/* (in) dma addr for setup_packet */
+	int start_frame;		/* (modify) start frame (ISO) */
+	int number_of_packets;		/* (in) number of ISO packets */
+	int interval;			/* (modify) transfer interval (INT/ISO) */
+	int error_count;		/* (return) number of ISO errors */
+	void *context;			/* (in) context for completion */
+	usb_complete_t complete;	/* (in) completion routine */
+	struct usb_iso_packet_descriptor iso_frame_desc[0];	/* (in) ISO ONLY */
+};
+
+/* -------------------------------------------------------------------------- */
+
+/**
+ * usb_fill_control_urb - initializes a control urb
+ * @urb: pointer to the urb to initialize.
+ * @dev: pointer to the struct usb_device for this urb.
+ * @pipe: the endpoint pipe
+ * @setup_packet: pointer to the setup_packet buffer
+ * @transfer_buffer: pointer to the transfer buffer
+ * @buffer_length: length of the transfer buffer
+ * @complete: pointer to the usb_complete_t function
+ * @context: what to set the urb context to.
+ *
+ * Initializes a control urb with the proper information needed to submit
+ * it to a device.
+ */
+static inline void usb_fill_control_urb (struct urb *urb,
+					 struct usb_device *dev,
+					 unsigned int pipe,
+					 unsigned char *setup_packet,
+					 void *transfer_buffer,
+					 int buffer_length,
+					 usb_complete_t complete,
+					 void *context)
+{
+	spin_lock_init(&urb->lock);
+	urb->dev = dev;
+	urb->pipe = pipe;
+	urb->setup_packet = setup_packet;
+	urb->transfer_buffer = transfer_buffer;
+	urb->transfer_buffer_length = buffer_length;
+	urb->complete = complete;
+	urb->context = context;
+}
+
+/**
+ * usb_fill_bulk_urb - macro to help initialize a bulk urb
+ * @urb: pointer to the urb to initialize.
+ * @dev: pointer to the struct usb_device for this urb.
+ * @pipe: the endpoint pipe
+ * @transfer_buffer: pointer to the transfer buffer
+ * @buffer_length: length of the transfer buffer
+ * @complete: pointer to the usb_complete_t function
+ * @context: what to set the urb context to.
+ *
+ * Initializes a bulk urb with the proper information needed to submit it
+ * to a device.
+ */
+static inline void usb_fill_bulk_urb (struct urb *urb,
+				      struct usb_device *dev,
+				      unsigned int pipe,
+				      void *transfer_buffer,
+				      int buffer_length,
+				      usb_complete_t complete,
+				      void *context)
+{
+	spin_lock_init(&urb->lock);
+	urb->dev = dev;
+	urb->pipe = pipe;
+	urb->transfer_buffer = transfer_buffer;
+	urb->transfer_buffer_length = buffer_length;
+	urb->complete = complete;
+	urb->context = context;
+}
+
+/**
+ * usb_fill_int_urb - macro to help initialize a interrupt urb
+ * @urb: pointer to the urb to initialize.
+ * @dev: pointer to the struct usb_device for this urb.
+ * @pipe: the endpoint pipe
+ * @transfer_buffer: pointer to the transfer buffer
+ * @buffer_length: length of the transfer buffer
+ * @complete: pointer to the usb_complete_t function
+ * @context: what to set the urb context to.
+ * @interval: what to set the urb interval to, encoded like
+ *	the endpoint descriptor's bInterval value.
+ *
+ * Initializes a interrupt urb with the proper information needed to submit
+ * it to a device.
+ * Note that high speed interrupt endpoints use a logarithmic encoding of
+ * the endpoint interval, and express polling intervals in microframes
+ * (eight per millisecond) rather than in frames (one per millisecond).
+ */
+static inline void usb_fill_int_urb (struct urb *urb,
+				     struct usb_device *dev,
+				     unsigned int pipe,
+				     void *transfer_buffer,
+				     int buffer_length,
+				     usb_complete_t complete,
+				     void *context,
+				     int interval)
+{
+	spin_lock_init(&urb->lock);
+	urb->dev = dev;
+	urb->pipe = pipe;
+	urb->transfer_buffer = transfer_buffer;
+	urb->transfer_buffer_length = buffer_length;
+	urb->complete = complete;
+	urb->context = context;
+	if (dev->speed == USB_SPEED_HIGH)
+		urb->interval = 1 << (interval - 1);
+	else
+		urb->interval = interval;
+	urb->start_frame = -1;
+}
+
+extern void usb_init_urb(struct urb *urb);
+extern struct urb *usb_alloc_urb(int iso_packets, int mem_flags);
+extern void usb_free_urb(struct urb *urb);
+#define usb_put_urb usb_free_urb
+extern struct urb *usb_get_urb(struct urb *urb);
+extern int usb_submit_urb(struct urb *urb, int mem_flags);
+extern int usb_unlink_urb(struct urb *urb);
+extern void usb_kill_urb(struct urb *urb);
+
+#define HAVE_USB_BUFFERS
+void *usb_buffer_alloc (struct usb_device *dev, size_t size,
+	int mem_flags, dma_addr_t *dma);
+void usb_buffer_free (struct usb_device *dev, size_t size,
+	void *addr, dma_addr_t dma);
+
+#if 0
+struct urb *usb_buffer_map (struct urb *urb);
+void usb_buffer_dmasync (struct urb *urb);
+void usb_buffer_unmap (struct urb *urb);
+#endif
+
+struct scatterlist;
+int usb_buffer_map_sg (struct usb_device *dev, unsigned pipe,
+		struct scatterlist *sg, int nents);
+#if 0
+void usb_buffer_dmasync_sg (struct usb_device *dev, unsigned pipe,
+		struct scatterlist *sg, int n_hw_ents);
+#endif
+void usb_buffer_unmap_sg (struct usb_device *dev, unsigned pipe,
+		struct scatterlist *sg, int n_hw_ents);
+
+/*-------------------------------------------------------------------*
+ *                         SYNCHRONOUS CALL SUPPORT                  *
+ *-------------------------------------------------------------------*/
+
+extern int usb_control_msg(struct usb_device *dev, unsigned int pipe,
+	__u8 request, __u8 requesttype, __u16 value, __u16 index,
+	void *data, __u16 size, int timeout);
+extern int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
+	void *data, int len, int *actual_length,
+	int timeout);
+
+/* selective suspend/resume */
+extern int usb_suspend_device(struct usb_device *dev, u32 state);
+extern int usb_resume_device(struct usb_device *dev);
+
+
+/* wrappers around usb_control_msg() for the most common standard requests */
+extern int usb_get_descriptor(struct usb_device *dev, unsigned char desctype,
+	unsigned char descindex, void *buf, int size);
+extern int usb_get_status(struct usb_device *dev,
+	int type, int target, void *data);
+extern int usb_get_string(struct usb_device *dev,
+	unsigned short langid, unsigned char index, void *buf, int size);
+extern int usb_string(struct usb_device *dev, int index,
+	char *buf, size_t size);
+
+/* wrappers that also update important state inside usbcore */
+extern int usb_clear_halt(struct usb_device *dev, int pipe);
+extern int usb_reset_configuration(struct usb_device *dev);
+extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
+
+/*
+ * timeouts, in milliseconds, used for sending/receiving control messages
+ * they typically complete within a few frames (msec) after they're issued
+ * USB identifies 5 second timeouts, maybe more in a few cases, and a few
+ * slow devices (like some MGE Ellipse UPSes) actually push that limit.
+ */
+#define USB_CTRL_GET_TIMEOUT	5000
+#define USB_CTRL_SET_TIMEOUT	5000
+
+
+/**
+ * struct usb_sg_request - support for scatter/gather I/O
+ * @status: zero indicates success, else negative errno
+ * @bytes: counts bytes transferred.
+ *
+ * These requests are initialized using usb_sg_init(), and then are used
+ * as request handles passed to usb_sg_wait() or usb_sg_cancel().  Most
+ * members of the request object aren't for driver access.
+ *
+ * The status and bytecount values are valid only after usb_sg_wait()
+ * returns.  If the status is zero, then the bytecount matches the total
+ * from the request.
+ *
+ * After an error completion, drivers may need to clear a halt condition
+ * on the endpoint.
+ */
+struct usb_sg_request {
+	int			status;
+	size_t			bytes;
+
+	/* 
+	 * members below are private to usbcore,
+	 * and are not provided for driver access!
+	 */
+	spinlock_t		lock;
+
+	struct usb_device	*dev;
+	int			pipe;
+	struct scatterlist	*sg;
+	int			nents;
+
+	int			entries;
+	struct urb		**urbs;
+
+	int			count;
+	struct completion	complete;
+};
+
+int usb_sg_init (
+	struct usb_sg_request	*io,
+	struct usb_device	*dev,
+	unsigned		pipe, 
+	unsigned		period,
+	struct scatterlist	*sg,
+	int			nents,
+	size_t			length,
+	int			mem_flags
+);
+void usb_sg_cancel (struct usb_sg_request *io);
+void usb_sg_wait (struct usb_sg_request *io);
+
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * For various legacy reasons, Linux has a small cookie that's paired with
+ * a struct usb_device to identify an endpoint queue.  Queue characteristics
+ * are defined by the endpoint's descriptor.  This cookie is called a "pipe",
+ * an unsigned int encoded as:
+ *
+ *  - direction:	bit 7		(0 = Host-to-Device [Out],
+ *					 1 = Device-to-Host [In] ...
+ *					like endpoint bEndpointAddress)
+ *  - device address:	bits 8-14       ... bit positions known to uhci-hcd
+ *  - endpoint:		bits 15-18      ... bit positions known to uhci-hcd
+ *  - pipe type:	bits 30-31	(00 = isochronous, 01 = interrupt,
+ *					 10 = control, 11 = bulk)
+ *
+ * Given the device address and endpoint descriptor, pipes are redundant.
+ */
+
+/* NOTE:  these are not the standard USB_ENDPOINT_XFER_* values!! */
+/* (yet ... they're the values used by usbfs) */
+#define PIPE_ISOCHRONOUS		0
+#define PIPE_INTERRUPT			1
+#define PIPE_CONTROL			2
+#define PIPE_BULK			3
+
+#define usb_pipein(pipe)	((pipe) & USB_DIR_IN)
+#define usb_pipeout(pipe)	(!usb_pipein(pipe))
+
+#define usb_pipedevice(pipe)	(((pipe) >> 8) & 0x7f)
+#define usb_pipeendpoint(pipe)	(((pipe) >> 15) & 0xf)
+
+#define usb_pipetype(pipe)	(((pipe) >> 30) & 3)
+#define usb_pipeisoc(pipe)	(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)
+#define usb_pipeint(pipe)	(usb_pipetype((pipe)) == PIPE_INTERRUPT)
+#define usb_pipecontrol(pipe)	(usb_pipetype((pipe)) == PIPE_CONTROL)
+#define usb_pipebulk(pipe)	(usb_pipetype((pipe)) == PIPE_BULK)
+
+/* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
+#define usb_gettoggle(dev, ep, out) (((dev)->toggle[out] >> (ep)) & 1)
+#define	usb_dotoggle(dev, ep, out)  ((dev)->toggle[out] ^= (1 << (ep)))
+#define usb_settoggle(dev, ep, out, bit) ((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << (ep))) | ((bit) << (ep)))
+
+
+static inline unsigned int __create_pipe(struct usb_device *dev, unsigned int endpoint)
+{
+	return (dev->devnum << 8) | (endpoint << 15);
+}
+
+/* Create various pipes... */
+#define usb_sndctrlpipe(dev,endpoint)	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvctrlpipe(dev,endpoint)	((PIPE_CONTROL << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndbulkpipe(dev,endpoint)	((PIPE_BULK << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvbulkpipe(dev,endpoint)	((PIPE_BULK << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndintpipe(dev,endpoint)	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint))
+#define usb_rcvintpipe(dev,endpoint)	((PIPE_INTERRUPT << 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+
+/*-------------------------------------------------------------------------*/
+
+static inline __u16
+usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
+{
+	struct usb_host_endpoint	*ep;
+	unsigned			epnum = usb_pipeendpoint(pipe);
+
+	if (is_out) {
+		WARN_ON(usb_pipein(pipe));
+		ep = udev->ep_out[epnum];
+	} else {
+		WARN_ON(usb_pipeout(pipe));
+		ep = udev->ep_in[epnum];
+	}
+	if (!ep)
+		return 0;
+
+	/* NOTE:  only 0x07ff bits are for packet size... */
+	return le16_to_cpu(ep->desc.wMaxPacketSize);
+}
+
+/* -------------------------------------------------------------------------- */
+
+#ifdef DEBUG
+#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+
+#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , __FILE__ , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , __FILE__ , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , __FILE__ , ## arg)
+
+
+#endif  /* __KERNEL__ */
+
+#endif
