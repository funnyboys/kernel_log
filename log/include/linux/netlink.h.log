commit 9fb16955fb661945ddffce4504dcffbe55cd518a
Merge: 1f074e677a34 1b649e0bcae7
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Mar 25 18:58:11 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Overlapping header include additions in macsec.c
    
    A bug fix in 'net' overlapping with the removal of 'version'
    string in ena_netdev.c
    
    Overlapping test additions in selftests Makefile
    
    Overlapping PCI ID table adjustments in iwlwifi driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 55b474c41e586a5c21c7ab81ff474eb6bacb4322
Author: Michal Kubecek <mkubecek@suse.cz>
Date:   Sat Mar 21 00:46:50 2020 +0100

    netlink: check for null extack in cookie helpers
    
    Unlike NL_SET_ERR_* macros, nl_set_extack_cookie_u64() and
    nl_set_extack_cookie_u32() helpers do not check extack argument for null
    and neither do their callers, as syzbot recently discovered for
    ethnl_parse_header().
    
    Instead of fixing the callers and leaving the trap in place, add check of
    null extack to both helpers to make them consistent with NL_SET_ERR_*
    macros.
    
    v2: drop incorrect second Fixes tag
    
    Fixes: 2363d73a2f3e ("ethtool: reject unrecognized request flags")
    Reported-by: syzbot+258a9089477493cea67b@syzkaller.appspotmail.com
    Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 4090524c3462..60739d0cbf93 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -115,6 +115,8 @@ static inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,
 {
 	u64 __cookie = cookie;
 
+	if (!extack)
+		return;
 	memcpy(extack->cookie, &__cookie, sizeof(__cookie));
 	extack->cookie_len = sizeof(__cookie);
 }
@@ -124,6 +126,8 @@ static inline void nl_set_extack_cookie_u32(struct netlink_ext_ack *extack,
 {
 	u32 __cookie = cookie;
 
+	if (!extack)
+		return;
 	memcpy(extack->cookie, &__cookie, sizeof(__cookie));
 	extack->cookie_len = sizeof(__cookie);
 }

commit f1388ec4a144f40348321a0915c5535d623e165c
Author: Michal Kubecek <mkubecek@suse.cz>
Date:   Sun Mar 15 18:17:48 2020 +0100

    netlink: add nl_set_extack_cookie_u32()
    
    Similar to existing nl_set_extack_cookie_u64(), add new helper
    nl_set_extack_cookie_u32() which sets extack cookie to a u32 value.
    
    Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 205fa7b1f07a..4090524c3462 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -119,6 +119,15 @@ static inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,
 	extack->cookie_len = sizeof(__cookie);
 }
 
+static inline void nl_set_extack_cookie_u32(struct netlink_ext_ack *extack,
+					    u32 cookie)
+{
+	u32 __cookie = cookie;
+
+	memcpy(extack->cookie, &__cookie, sizeof(__cookie));
+	extack->cookie_len = sizeof(__cookie);
+}
+
 void netlink_kernel_release(struct sock *sk);
 int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit 085c20cacf2b72991ce1c9d99a5e2f1d9e73bb68
Author: Martin KaFai Lau <kafai@fb.com>
Date:   Tue Feb 25 15:04:27 2020 -0800

    bpf: inet_diag: Dump bpf_sk_storages in inet_diag_dump()
    
    This patch will dump out the bpf_sk_storages of a sk
    if the request has the INET_DIAG_REQ_SK_BPF_STORAGES nlattr.
    
    An array of SK_DIAG_BPF_STORAGE_REQ_MAP_FD can be specified in
    INET_DIAG_REQ_SK_BPF_STORAGES to select which bpf_sk_storage to dump.
    If no map_fd is specified, all bpf_sk_storages of a sk will be dumped.
    
    bpf_sk_storages can be added to the system at runtime.  It is difficult
    to find a proper static value for cb->min_dump_alloc.
    
    This patch learns the nlattr size required to dump the bpf_sk_storages
    of a sk.  If it happens to be the very first nlmsg of a dump and it
    cannot fit the needed bpf_sk_storages,  it will try to expand the
    skb by "pskb_expand_head()".
    
    Instead of expanding it in inet_sk_diag_fill(), it is expanded at a
    sleepable context in __inet_diag_dump() so __GFP_DIRECT_RECLAIM can
    be used.  In __inet_diag_dump(), it will retry as long as the
    skb is empty and the cb->min_dump_alloc becomes larger than before.
    cb->min_dump_alloc is bounded by KMALLOC_MAX_SIZE.  The min_dump_alloc
    is also changed from 'u16' to 'u32' to accommodate a sk that may have
    a few large bpf_sk_storages.
    
    The updated cb->min_dump_alloc will also be used to allocate the skb in
    the next dump.  This logic already exists in netlink_dump().
    
    Here is the sample output of a locally modified 'ss' and it could be made
    more readable by using BTF later:
    [root@arch-fb-vm1 ~]# ss --bpf-map-id 14 --bpf-map-id 13 -t6an 'dst [::1]:8989'
    State Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess
    ESTAB 0      0              [::1]:51072        [::1]:8989
             bpf_map_id:14 value:[ 3feb ]
             bpf_map_id:13 value:[ 3f ]
    ESTAB 0      0              [::1]:51070        [::1]:8989
             bpf_map_id:14 value:[ 3feb ]
             bpf_map_id:13 value:[ 3f ]
    
    [root@arch-fb-vm1 ~]# ~/devshare/github/iproute2/misc/ss --bpf-maps -t6an 'dst [::1]:8989'
    State         Recv-Q         Send-Q                   Local Address:Port                    Peer Address:Port         Process
    ESTAB         0              0                                [::1]:51072                          [::1]:8989
             bpf_map_id:14 value:[ 3feb ]
             bpf_map_id:13 value:[ 3f ]
             bpf_map_id:12 value:[ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000... total:65407 ]
    ESTAB         0              0                                [::1]:51070                          [::1]:8989
             bpf_map_id:14 value:[ 3feb ]
             bpf_map_id:13 value:[ 3f ]
             bpf_map_id:12 value:[ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000... total:65407 ]
    
    Signed-off-by: Martin KaFai Lau <kafai@fb.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Acked-by: Song Liu <songliubraving@fb.com>
    Link: https://lore.kernel.org/bpf/20200225230427.1976129-1-kafai@fb.com

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 205fa7b1f07a..788969ccbbde 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -188,10 +188,10 @@ struct netlink_callback {
 	struct module		*module;
 	struct netlink_ext_ack	*extack;
 	u16			family;
-	u16			min_dump_alloc;
-	bool			strict_check;
 	u16			answer_flags;
+	u32			min_dump_alloc;
 	unsigned int		prev_seq, seq;
+	bool			strict_check;
 	union {
 		u8		ctx[48];
 

commit 362b87f5b1c6603b72699e8bb18661ecc4efc0bb
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 28 16:40:21 2019 +0200

    netlink: use 48 byte ctx instead of 6 signed longs for callback
    
    People are inclined to stuff random things into cb->args[n] because it
    looks like an array of integers. Sometimes people even put u64s in there
    with comments noting that a certain member takes up two slots. The
    horror! Really this should mirror the usage of skb->cb, which are just
    48 opaque bytes suitable for casting a struct. Then people can create
    their usual casting macros for accessing strongly typed members of a
    struct.
    
    As a plus, this also gives us the same amount of space on 32bit and 64bit.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 593d1b9c33a8..205fa7b1f07a 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -192,7 +192,14 @@ struct netlink_callback {
 	bool			strict_check;
 	u16			answer_flags;
 	unsigned int		prev_seq, seq;
-	long			args[6];
+	union {
+		u8		ctx[48];
+
+		/* args is deprecated. Cast a struct over ctx instead
+		 * for proper type safety.
+		 */
+		long		args[6];
+	};
 };
 
 struct netlink_notify {

commit 59c28058fa7bb1cc7ab8b2c5607093cbbefafeb4
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Fri Jan 18 10:46:13 2019 -0800

    net: netlink: add helper to retrieve NETLINK_F_STRICT_CHK
    
    Dumps can read state of the NETLINK_F_STRICT_CHK flag from
    a field in the callback structure.  For non-dump GET requests
    we need a way to access the state of that flag from a socket.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 4e8add270200..593d1b9c33a8 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -126,6 +126,7 @@ void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
 		 const struct netlink_ext_ack *extack);
 int netlink_has_listeners(struct sock *sk, unsigned int group);
+bool netlink_strict_get_check(struct sk_buff *skb);
 
 int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
 int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,

commit aa9d6e0f33aea8a1879e7e53fe0e436943f9ce0c
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Thu Dec 20 09:52:28 2018 -0800

    linux/netlink.h: drop unnecessary extern prefix
    
    Don't need extern prefix before function prototypes.
    Checkpatch has complained about this for a couple of years.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 0b83dbae0a57..4e8add270200 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -34,8 +34,8 @@ struct netlink_skb_parms {
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
-extern void netlink_table_grab(void);
-extern void netlink_table_ungrab(void);
+void netlink_table_grab(void);
+void netlink_table_ungrab(void);
 
 #define NL_CFG_F_NONROOT_RECV	(1 << 0)
 #define NL_CFG_F_NONROOT_SEND	(1 << 1)
@@ -51,7 +51,7 @@ struct netlink_kernel_cfg {
 	bool		(*compare)(struct net *net, struct sock *sk);
 };
 
-extern struct sock *__netlink_kernel_create(struct net *net, int unit,
+struct sock *__netlink_kernel_create(struct net *net, int unit,
 					    struct module *module,
 					    struct netlink_kernel_cfg *cfg);
 static inline struct sock *
@@ -119,24 +119,24 @@ static inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,
 	extack->cookie_len = sizeof(__cookie);
 }
 
-extern void netlink_kernel_release(struct sock *sk);
-extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
-extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
-extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
-extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
-			const struct netlink_ext_ack *extack);
-extern int netlink_has_listeners(struct sock *sk, unsigned int group);
-
-extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
-extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
-			     __u32 group, gfp_t allocation);
-extern int netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,
-	__u32 portid, __u32 group, gfp_t allocation,
-	int (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),
-	void *filter_data);
-extern int netlink_set_err(struct sock *ssk, __u32 portid, __u32 group, int code);
-extern int netlink_register_notifier(struct notifier_block *nb);
-extern int netlink_unregister_notifier(struct notifier_block *nb);
+void netlink_kernel_release(struct sock *sk);
+int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
+int netlink_change_ngroups(struct sock *sk, unsigned int groups);
+void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
+void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
+		 const struct netlink_ext_ack *extack);
+int netlink_has_listeners(struct sock *sk, unsigned int group);
+
+int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
+int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
+		      __u32 group, gfp_t allocation);
+int netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,
+			       __u32 portid, __u32 group, gfp_t allocation,
+			       int (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),
+			       void *filter_data);
+int netlink_set_err(struct sock *ssk, __u32 portid, __u32 group, int code);
+int netlink_register_notifier(struct notifier_block *nb);
+int netlink_unregister_notifier(struct notifier_block *nb);
 
 /* finegrained unicast helpers: */
 struct sock *netlink_getsockbyfilp(struct file *filp);
@@ -212,7 +212,7 @@ struct netlink_dump_control {
 	u16 min_dump_alloc;
 };
 
-extern int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
+int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 				const struct nlmsghdr *nlh,
 				struct netlink_dump_control *control);
 static inline int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
@@ -231,8 +231,8 @@ struct netlink_tap {
 	struct list_head list;
 };
 
-extern int netlink_add_tap(struct netlink_tap *nt);
-extern int netlink_remove_tap(struct netlink_tap *nt);
+int netlink_add_tap(struct netlink_tap *nt);
+int netlink_remove_tap(struct netlink_tap *nt);
 
 bool __netlink_ns_capable(const struct netlink_skb_parms *nsp,
 			  struct user_namespace *ns, int cap);

commit 801f87469ee8d97af5997ef52188bb0e1908b110
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Aug 23 10:48:13 2018 +0200

    netlink: add nl_set_extack_cookie_u64()
    
    Add a helper function nl_set_extack_cookie_u64() to use a u64 as
    the netlink extended ACK cookie, to avoid having to open-code it
    in any users of the cookie.
    
    A u64 should be sufficient for most subsystems though we allow
    for up to 20 bytes right now. This also matches the cookies in
    nl80211 where I intend to use this.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 4da90a6ab536..0b83dbae0a57 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -110,6 +110,15 @@ struct netlink_ext_ack {
 	}						\
 } while (0)
 
+static inline void nl_set_extack_cookie_u64(struct netlink_ext_ack *extack,
+					    u64 cookie)
+{
+	u64 __cookie = cookie;
+
+	memcpy(extack->cookie, &__cookie, sizeof(__cookie));
+	extack->cookie_len = sizeof(__cookie);
+}
+
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit 22e6c58b8c2843337ec4e8464b1ce6e869ca5bf4
Author: David Ahern <dsahern@gmail.com>
Date:   Mon Oct 15 18:56:41 2018 -0700

    netlink: Add answer_flags to netlink_callback
    
    With dump filtering we need a way to ensure the NLM_F_DUMP_FILTERED
    flag is set on a message back to the user if the data returned is
    influenced by some input attributes. Normally this can be done as
    messages are added to the skb, but if the filter results in no data
    being returned, the user could be confused as to why.
    
    This patch adds answer_flags to the netlink_callback allowing dump
    handlers to set the NLM_F_DUMP_FILTERED at a minimum in the
    NLMSG_DONE message ensuring the flag gets back to the user.
    
    The netlink_callback space is initialized to 0 via a memset in
    __netlink_dump_start, so init of the new answer_flags is covered.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 72580f1a72a2..4da90a6ab536 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -180,6 +180,7 @@ struct netlink_callback {
 	u16			family;
 	u16			min_dump_alloc;
 	bool			strict_check;
+	u16			answer_flags;
 	unsigned int		prev_seq, seq;
 	long			args[6];
 };

commit 89d35528d17d25819a755a2b52931e911baebc66
Author: David Ahern <dsahern@gmail.com>
Date:   Sun Oct 7 20:16:27 2018 -0700

    netlink: Add new socket option to enable strict checking on dumps
    
    Add a new socket option, NETLINK_DUMP_STRICT_CHK, that userspace
    can use via setsockopt to request strict checking of headers and
    attributes on dump requests.
    
    To get dump features such as kernel side filtering based on data in
    the header or attributes appended to the dump request, userspace
    must call setsockopt() for NETLINK_DUMP_STRICT_CHK and a non-zero
    value. Since the netlink sock and its flags are private to the
    af_netlink code, the strict checking flag is passed to dump handlers
    via a flag in the netlink_callback struct.
    
    For old userspace on new kernel there is no impact as all of the data
    checks in later patches are wrapped in a check on the new strict flag.
    
    For new userspace on old kernel, the setsockopt will fail and even if
    new userspace sets data in the headers and appended attributes the
    kernel will silently ignore it. Moving forward when the setsockopt
    succeeds, the new userspace on old kernel means the dump request can
    pass an attribute the kernel does not understand. The dump will then
    fail as the older kernel does not understand it.
    
    New userspace on new kernel setting the socket option gets the benefit
    of the improved data dump.
    
    Kernel side the NETLINK_DUMP_STRICT_CHK uapi is converted to a generic
    NETLINK_F_STRICT_CHK flag which can potentially be leveraged for tighter
    checking on the NEW, DEL, and SET commands.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Christian Brauner <christian@brauner.io>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 88c8a2d83eb3..72580f1a72a2 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -179,6 +179,7 @@ struct netlink_callback {
 	struct netlink_ext_ack	*extack;
 	u16			family;
 	u16			min_dump_alloc;
+	bool			strict_check;
 	unsigned int		prev_seq, seq;
 	long			args[6];
 };

commit 4a19edb60d0203cd5bf95a8b46ea8f63fd41194c
Author: David Ahern <dsahern@gmail.com>
Date:   Sun Oct 7 20:16:22 2018 -0700

    netlink: Pass extack to dump handlers
    
    Declare extack in netlink_dump and pass to dump handlers via
    netlink_callback. Add any extack message after the dump_done_errno
    allowing error messages to be returned. This will be useful when
    strict checking is done on dump requests, returning why the dump
    fails EINVAL.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Christian Brauner <christian@brauner.io>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 71f121b66ca8..88c8a2d83eb3 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -176,6 +176,7 @@ struct netlink_callback {
 	void			*data;
 	/* the module that dump function belong to */
 	struct module		*module;
+	struct netlink_ext_ack	*extack;
 	u16			family;
 	u16			min_dump_alloc;
 	unsigned int		prev_seq, seq;

commit 3730cf4dd70b6a36e48d58a862120311411b77f5
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Jul 24 12:47:56 2018 +0200

    netlink: do not store start function in netlink_cb
    
    ->start() is called once when dump is being initialized, there is no
    need to store it in netlink_cb.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f3075d6c7e82..71f121b66ca8 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -170,7 +170,6 @@ netlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
 struct netlink_callback {
 	struct sk_buff		*skb;
 	const struct nlmsghdr	*nlh;
-	int			(*start)(struct netlink_callback *);
 	int			(*dump)(struct sk_buff * skb,
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);

commit 6311b7ce42e0c1d6d944bc099dc47e936c20cf11
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jan 15 12:42:25 2018 +0100

    netlink: extack: avoid parenthesized string constant warning
    
    NL_SET_ERR_MSG() and NL_SET_ERR_MSG_ATTR() lead to the following warning
    in newer versions of gcc:
      warning: array initialized from parenthesized string constant
    
    Just remove the parentheses, they're not needed in this context since
    anyway since there can be no operator precendence issues or similar.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 49b4257ce1ea..f3075d6c7e82 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -85,7 +85,7 @@ struct netlink_ext_ack {
  * to the lack of an output buffer.)
  */
 #define NL_SET_ERR_MSG(extack, msg) do {		\
-	static const char __msg[] = (msg);		\
+	static const char __msg[] = msg;		\
 	struct netlink_ext_ack *__extack = (extack);	\
 							\
 	if (__extack)					\
@@ -101,7 +101,7 @@ struct netlink_ext_ack {
 } while (0)
 
 #define NL_SET_ERR_MSG_ATTR(extack, attr, msg) do {	\
-	static const char __msg[] = (msg);		\
+	static const char __msg[] = msg;		\
 	struct netlink_ext_ack *__extack = (extack);	\
 							\
 	if (__extack) {					\

commit 096d1dd0f03211fb42d6c2457f248827604b7f0e
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Nov 13 16:19:46 2017 +0100

    netlink: remove unused NETLINK SKB flags
    
    These flags are unused, remove them to be less confusing.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6ddb4a5da371..49b4257ce1ea 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -17,9 +17,6 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 }
 
 enum netlink_skb_flags {
-	NETLINK_SKB_MMAPED	= 0x1,	/* Packet data is mmaped */
-	NETLINK_SKB_TX		= 0x2,	/* Packet was sent by userspace */
-	NETLINK_SKB_DELIVERED	= 0x4,	/* Packet was delivered */
 	NETLINK_SKB_DST		= 0x8,	/* Dst set in sendto or sendmsg */
 };
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 8664fd26eb5d..6ddb4a5da371 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __LINUX_NETLINK_H
 #define __LINUX_NETLINK_H
 

commit 9ae287274817c032a4428fde84d1ab26d6b96761
Author: David Ahern <dsahern@gmail.com>
Date:   Sat May 27 16:19:28 2017 -0600

    net: add extack arg to lwtunnel build state
    
    Pass extack arg down to lwtunnel_build_state and the build_state callbacks.
    Add messages for failures in lwtunnel_build_state, and add the extarg to
    nla_parse where possible in the build_state callbacks.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index a68aad484c69..8664fd26eb5d 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -102,6 +102,16 @@ struct netlink_ext_ack {
 		(extack)->bad_attr = (attr);		\
 } while (0)
 
+#define NL_SET_ERR_MSG_ATTR(extack, attr, msg) do {	\
+	static const char __msg[] = (msg);		\
+	struct netlink_ext_ack *__extack = (extack);	\
+							\
+	if (__extack) {					\
+		__extack->_msg = __msg;			\
+		__extack->bad_attr = (attr);		\
+	}						\
+} while (0)
+
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit c3ab2b4ec8f7c0700bf10957171c479bf3dbca52
Author: David Ahern <dsahern@gmail.com>
Date:   Sun May 21 10:12:03 2017 -0600

    net: ipv4: Add extack messages for route add failures
    
    Add messages for non-obvious errors (e.g, no need to add text for malloc
    failures or ENODEV failures). This mostly covers the annoying EINVAL errors
    Some message strings violate the 80-columns but searchable strings need to
    trump that rule.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 5fff5ba5964e..a68aad484c69 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -97,6 +97,11 @@ struct netlink_ext_ack {
 #define NL_SET_ERR_MSG_MOD(extack, msg)			\
 	NL_SET_ERR_MSG((extack), KBUILD_MODNAME ": " msg)
 
+#define NL_SET_BAD_ATTR(extack, attr) do {		\
+	if ((extack))					\
+		(extack)->bad_attr = (attr);		\
+} while (0)
+
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit 4d463c4dbc5c1c5d73e488d52faeec05570443a0
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Wed May 3 00:39:17 2017 +0200

    xdp: use common helper for netlink extended ack reporting
    
    Small follow-up to d74a32acd59a ("xdp: use netlink extended ACK reporting")
    in order to let drivers all use the same NL_SET_ERR_MSG_MOD() helper macro
    for reporting. This also ensures that we consistently add the driver's
    prefix for dumping the report in user space to indicate that the error
    message is driver specific and not coming from core code. Furthermore,
    NL_SET_ERR_MSG_MOD() now reuses NL_SET_ERR_MSG() and thus makes all macros
    check the pointer as suggested.
    
    References: https://www.spinics.net/lists/netdev/msg433267.html
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index c20395edf2de..5fff5ba5964e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -86,19 +86,16 @@ struct netlink_ext_ack {
  * Currently string formatting is not supported (due
  * to the lack of an output buffer.)
  */
-#define NL_SET_ERR_MSG(extack, msg) do {	\
-	static const char _msg[] = (msg);	\
-						\
-	(extack)->_msg = _msg;			\
+#define NL_SET_ERR_MSG(extack, msg) do {		\
+	static const char __msg[] = (msg);		\
+	struct netlink_ext_ack *__extack = (extack);	\
+							\
+	if (__extack)					\
+		__extack->_msg = __msg;			\
 } while (0)
 
-#define NL_MOD_TRY_SET_ERR_MSG(extack, msg) do {		\
-	static const char _msg[] = KBUILD_MODNAME ": " msg;	\
-	struct netlink_ext_ack *_extack = (extack);		\
-								\
-	if (_extack)						\
-		_extack->_msg = _msg;				\
-} while (0)
+#define NL_SET_ERR_MSG_MOD(extack, msg)			\
+	NL_SET_ERR_MSG((extack), KBUILD_MODNAME ": " msg)
 
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit 45d9b378e85f1b00ac047626827c68589168936c
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Sun Apr 30 21:46:45 2017 -0700

    netlink: add NULL-friendly helper for setting extended ACK message
    
    As we propagate extended ack reporting throughout various paths in
    the kernel it may be that the same function is called with the
    extended ack parameter passed as NULL.  One place where that happens
    is in drivers which have a centralized reconfiguration function
    called both from ndos and from ethtool_ops.  Add a new helper for
    setting the error message in such conditions.
    
    Existing helper is left as is to encourage propagating the ext act
    fully wherever possible.  It also makes it clear in the code which
    messages may be lost due to ext ack being NULL.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 8d2a8924705c..c20395edf2de 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -92,6 +92,14 @@ struct netlink_ext_ack {
 	(extack)->_msg = _msg;			\
 } while (0)
 
+#define NL_MOD_TRY_SET_ERR_MSG(extack, msg) do {		\
+	static const char _msg[] = KBUILD_MODNAME ": " msg;	\
+	struct netlink_ext_ack *_extack = (extack);		\
+								\
+	if (_extack)						\
+		_extack->_msg = _msg;				\
+} while (0)
+
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit ba0dc5f6e0ba5a5d2f575bcdb35e5d1960cf7c04
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 12 14:34:06 2017 +0200

    netlink: allow sending extended ACK with cookie on success
    
    Now that we have extended error reporting and a new message format for
    netlink ACK messages, also extend this to be able to return arbitrary
    cookie data on success.
    
    This will allow, for example, nl80211 to not send an extra message for
    cookies identifying newly created objects, but return those directly
    in the ACK message.
    
    The cookie data size is currently limited to 20 bytes (since Jamal
    talked about using SHA1 for identifiers.)
    
    Thanks to Jamal Hadi Salim for bringing up this idea during the
    discussions.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Reviewed-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 60e7137f840d..8d2a8924705c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -62,15 +62,22 @@ netlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg)
 	return __netlink_kernel_create(net, unit, THIS_MODULE, cfg);
 }
 
+/* this can be increased when necessary - don't expose to userland */
+#define NETLINK_MAX_COOKIE_LEN	20
+
 /**
  * struct netlink_ext_ack - netlink extended ACK report struct
  * @_msg: message string to report - don't access directly, use
  *	%NL_SET_ERR_MSG
  * @bad_attr: attribute with error
+ * @cookie: cookie data to return to userspace (for success)
+ * @cookie_len: actual cookie data length
  */
 struct netlink_ext_ack {
 	const char *_msg;
 	const struct nlattr *bad_attr;
+	u8 cookie[NETLINK_MAX_COOKIE_LEN];
+	u8 cookie_len;
 };
 
 /* Always use this macro, this allows later putting the

commit 2d4bc93368f5a0ddb57c8c885cdad9c9b7a10ed5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Apr 12 14:34:04 2017 +0200

    netlink: extended ACK reporting
    
    Add the base infrastructure and UAPI for netlink extended ACK
    reporting. All "manual" calls to netlink_ack() pass NULL for now and
    thus don't get extended ACK reporting.
    
    Big thanks goes to Pablo Neira Ayuso for not only bringing up the
    whole topic at netconf (again) but also coming up with the nlattr
    passing trick and various other ideas.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Reviewed-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index da14ab61f363..60e7137f840d 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -62,11 +62,35 @@ netlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg)
 	return __netlink_kernel_create(net, unit, THIS_MODULE, cfg);
 }
 
+/**
+ * struct netlink_ext_ack - netlink extended ACK report struct
+ * @_msg: message string to report - don't access directly, use
+ *	%NL_SET_ERR_MSG
+ * @bad_attr: attribute with error
+ */
+struct netlink_ext_ack {
+	const char *_msg;
+	const struct nlattr *bad_attr;
+};
+
+/* Always use this macro, this allows later putting the
+ * message into a separate section or such for things
+ * like translation or listing all possible messages.
+ * Currently string formatting is not supported (due
+ * to the lack of an output buffer.)
+ */
+#define NL_SET_ERR_MSG(extack, msg) do {	\
+	static const char _msg[] = (msg);	\
+						\
+	(extack)->_msg = _msg;			\
+} while (0)
+
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
-extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
+extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err,
+			const struct netlink_ext_ack *extack);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);

commit c5b0db3263b92526bc0c1b6380c0c99f91f069fc
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Feb 18 15:03:28 2016 +0100

    nfnetlink: Revert "nfnetlink: add support for memory mapped netlink"
    
    reverts commit 3ab1f683bf8b ("nfnetlink: add support for memory mapped
    netlink")'
    
    Like previous commits in the series, remove wrappers that are not needed
    after mmapped netlink removal.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 0b41959aab9f..da14ab61f363 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -69,16 +69,6 @@ extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group)
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 
-extern struct sk_buff *__netlink_alloc_skb(struct sock *ssk, unsigned int size,
-					   unsigned int ldiff, u32 dst_portid,
-					   gfp_t gfp_mask);
-static inline struct sk_buff *
-netlink_alloc_skb(struct sock *ssk, unsigned int size, u32 dst_portid,
-		  gfp_t gfp_mask)
-{
-	return __netlink_alloc_skb(ssk, size, 0, dst_portid, gfp_mask);
-}
-
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
 			     __u32 group, gfp_t allocation);

commit fc9e50f5a5a4e1fa9ba2756f745a13e693cf6a06
Author: Tom Herbert <tom@herbertland.com>
Date:   Tue Dec 15 15:41:37 2015 -0800

    netlink: add a start callback for starting a netlink dump
    
    The start callback allows the caller to set up a context for the
    dump callbacks. Presumably, the context can then be destroyed in
    the done callback.
    
    Signed-off-by: Tom Herbert <tom@herbertland.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 639e9b8b0e4d..0b41959aab9f 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -131,6 +131,7 @@ netlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
 struct netlink_callback {
 	struct sk_buff		*skb;
 	const struct nlmsghdr	*nlh;
+	int			(*start)(struct netlink_callback *);
 	int			(*dump)(struct sk_buff * skb,
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);
@@ -153,6 +154,7 @@ struct nlmsghdr *
 __nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags);
 
 struct netlink_dump_control {
+	int (*start)(struct netlink_callback *);
 	int (*dump)(struct sk_buff *skb, struct netlink_callback *);
 	int (*done)(struct netlink_callback *);
 	void *data;

commit 6bb0fef489f667cf701853054f44579754f00a06
Author: Daniel Borkmann <daniel@iogearbox.net>
Date:   Thu Sep 10 02:10:57 2015 +0200

    netlink, mmap: fix edge-case leakages in nf queue zero-copy
    
    When netlink mmap on receive side is the consumer of nf queue data,
    it can happen that in some edge cases, we write skb shared info into
    the user space mmap buffer:
    
    Assume a possible rx ring frame size of only 4096, and the network skb,
    which is being zero-copied into the netlink skb, contains page frags
    with an overall skb->len larger than the linear part of the netlink
    skb.
    
    skb_zerocopy(), which is generic and thus not aware of the fact that
    shared info cannot be accessed for such skbs then tries to write and
    fill frags, thus leaking kernel data/pointers and in some corner cases
    possibly writing out of bounds of the mmap area (when filling the
    last slot in the ring buffer this way).
    
    I.e. the ring buffer slot is then of status NL_MMAP_STATUS_VALID, has
    an advertised length larger than 4096, where the linear part is visible
    at the slot beginning, and the leaked sizeof(struct skb_shared_info)
    has been written to the beginning of the next slot (also corrupting
    the struct nl_mmap_hdr slot header incl. status etc), since skb->end
    points to skb->data + ring->frame_size - NL_MMAP_HDRLEN.
    
    The fix adds and lets __netlink_alloc_skb() take the actual needed
    linear room for the network skb + meta data into account. It's completely
    irrelevant for non-mmaped netlink sockets, but in case mmap sockets
    are used, it can be decided whether the available skb_tailroom() is
    really large enough for the buffer, or whether it needs to internally
    fallback to a normal alloc_skb().
    
    >From nf queue side, the information whether the destination port is
    an mmap RX ring is not really available without extra port-to-socket
    lookup, thus it can only be determined in lower layers i.e. when
    __netlink_alloc_skb() is called that checks internally for this. I
    chose to add the extra ldiff parameter as mmap will then still work:
    We have data_len and hlen in nfqnl_build_packet_message(), data_len
    is the full length (capped at queue->copy_range) for skb_zerocopy()
    and hlen some possible part of data_len that needs to be copied; the
    rem_len variable indicates the needed remaining linear mmap space.
    
    The only other workaround in nf queue internally would be after
    allocation time by f.e. cap'ing the data_len to the skb_tailroom()
    iff we deal with an mmap skb, but that would 1) expose the fact that
    we use a mmap skb to upper layers, and 2) trim the skb where we
    otherwise could just have moved the full skb into the normal receive
    queue.
    
    After the patch, in my test case the ring slot doesn't fit and therefore
    shows NL_MMAP_STATUS_COPY, where a full skb carries all the data and
    thus needs to be picked up via recv().
    
    Fixes: 3ab1f683bf8b ("nfnetlink: add support for memory mapped netlink")
    Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 9120edb650a0..639e9b8b0e4d 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -68,8 +68,17 @@ extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
-extern struct sk_buff *netlink_alloc_skb(struct sock *ssk, unsigned int size,
-					 u32 dst_portid, gfp_t gfp_mask);
+
+extern struct sk_buff *__netlink_alloc_skb(struct sock *ssk, unsigned int size,
+					   unsigned int ldiff, u32 dst_portid,
+					   gfp_t gfp_mask);
+static inline struct sk_buff *
+netlink_alloc_skb(struct sock *ssk, unsigned int size, u32 dst_portid,
+		  gfp_t gfp_mask)
+{
+	return __netlink_alloc_skb(ssk, size, 0, dst_portid, gfp_mask);
+}
+
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
 			     __u32 group, gfp_t allocation);

commit 59324cf35aba5336b611074028777838a963d03b
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Thu May 7 11:02:53 2015 +0200

    netlink: allow to listen "all" netns
    
    More accurately, listen all netns that have a nsid assigned into the netns
    where the netlink socket is opened.
    For this purpose, a netlink socket option is added:
    NETLINK_LISTEN_ALL_NSID. When this option is set on a netlink socket, this
    socket will receive netlink notifications from all netns that have a nsid
    assigned into the netns where the socket has been opened. The nsid is sent
    to userland via an anscillary data.
    
    With this patch, a daemon needs only one socket to listen many netns. This
    is useful when the number of netns is high.
    
    Because 0 is a valid value for a nsid, the field nsid_is_set indicates if
    the field nsid is valid or not. skb->cb is initialized to 0 on skb
    allocation, thus we are sure that we will never send a nsid 0 by error to
    the userland.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6835c1279df7..9120edb650a0 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -28,6 +28,8 @@ struct netlink_skb_parms {
 	__u32			dst_group;
 	__u32			flags;
 	struct sock		*sk;
+	bool			nsid_is_set;
+	int			nsid;
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit 0392d099ab29767b8d7d4d1d29e8020f8abe943f
Author: Richard Weinberger <richard@nod.at>
Date:   Mon Apr 13 00:52:35 2015 +0200

    netlink: Fix portid type in netlink_notify
    
    portid is an unsigned integer. Fix netlink_notify to
    match all other portid user in the kernel.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 02fc86d2348e..6835c1279df7 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -134,7 +134,7 @@ struct netlink_callback {
 
 struct netlink_notify {
 	struct net *net;
-	int portid;
+	u32 portid;
 	int protocol;
 };
 

commit 023e2cfa36c31b0ad28c159a1bb0d61ff57334c8
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Dec 23 21:00:06 2014 +0100

    netlink/genetlink: pass network namespace to bind/unbind
    
    Netlink families can exist in multiple namespaces, and for the most
    part multicast subscriptions are per network namespace. Thus it only
    makes sense to have bind/unbind notifications per network namespace.
    
    To achieve this, pass the network namespace of a given client socket
    to the bind/unbind functions.
    
    Also do this in generic netlink, and there also make sure that any
    bind for multicast groups that only exist in init_net is rejected.
    This isn't really a problem if it is accepted since a client in a
    different namespace will never receive any notifications from such
    a group, but it can confuse the family if not rejected (it's also
    possible to silently (without telling the family) accept it, but it
    would also have to be ignored on unbind so families that take any
    kind of action on bind/unbind won't do unnecessary work for invalid
    clients like that.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 9e572daa15d5..02fc86d2348e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -46,8 +46,8 @@ struct netlink_kernel_cfg {
 	unsigned int	flags;
 	void		(*input)(struct sk_buff *skb);
 	struct mutex	*cb_mutex;
-	int		(*bind)(int group);
-	void		(*unbind)(int group);
+	int		(*bind)(struct net *net, int group);
+	void		(*unbind)(struct net *net, int group);
 	bool		(*compare)(struct net *net, struct sock *sk);
 };
 

commit c99f7abf0e69987e4add567e155e042cb1f2a20b
Merge: 92ff71b8fe9c d8b0426af5b6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 3 23:32:12 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            include/net/inetpeer.h
            net/ipv6/output_core.c
    
    Changes in net were fixing bugs in code removed in net-next.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2d7a85f4b06e9c27ff629f07a524c48074f07f81
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 30 11:04:00 2014 -0700

    netlink: Only check file credentials for implicit destinations
    
    It was possible to get a setuid root or setcap executable to write to
    it's stdout or stderr (which has been set made a netlink socket) and
    inadvertently reconfigure the networking stack.
    
    To prevent this we check that both the creator of the socket and
    the currentl applications has permission to reconfigure the network
    stack.
    
    Unfortunately this breaks Zebra which always uses sendto/sendmsg
    and creates it's socket without any privileges.
    
    To keep Zebra working don't bother checking if the creator of the
    socket has privilege when a destination address is specified.  Instead
    rely exclusively on the privileges of the sender of the socket.
    
    Note from Andy: This is exactly Eric's code except for some comment
    clarifications and formatting fixes.  Neither I nor, I think, anyone
    else is thrilled with this approach, but I'm hesitant to wait on a
    better fix since 3.15 is almost here.
    
    Note to stable maintainers: This is a mess.  An earlier series of
    patches in 3.15 fix a rather serious security issue (CVE-2014-0181),
    but they did so in a way that breaks Zebra.  The offending series
    includes:
    
        commit aa4cf9452f469f16cea8c96283b641b4576d4a7b
        Author: Eric W. Biederman <ebiederm@xmission.com>
        Date:   Wed Apr 23 14:28:03 2014 -0700
    
            net: Add variants of capable for use on netlink messages
    
    If a given kernel version is missing that series of fixes, it's
    probably worth backporting it and this patch.  if that series is
    present, then this fix is critical if you care about Zebra.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f64b01787ddc..034cda789a15 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -16,9 +16,10 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 }
 
 enum netlink_skb_flags {
-	NETLINK_SKB_MMAPED	= 0x1,		/* Packet data is mmaped */
-	NETLINK_SKB_TX		= 0x2,		/* Packet was sent by userspace */
-	NETLINK_SKB_DELIVERED	= 0x4,		/* Packet was delivered */
+	NETLINK_SKB_MMAPED	= 0x1,	/* Packet data is mmaped */
+	NETLINK_SKB_TX		= 0x2,	/* Packet was sent by userspace */
+	NETLINK_SKB_DELIVERED	= 0x4,	/* Packet was delivered */
+	NETLINK_SKB_DST		= 0x8,	/* Dst set in sendto or sendmsg */
 };
 
 struct netlink_skb_parms {

commit 5f013c9bc70214dcacd5fbed5a06c217d6ff9c59
Merge: 51ee42efa082 1a466ae96e9f
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 12 13:19:14 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/altera/altera_sgdma.c
            net/netlink/af_netlink.c
            net/sched/cls_api.c
            net/sched/sch_api.c
    
    The netlink conflict dealt with moving to netlink_capable() and
    netlink_ns_capable() in the 'net' tree vs. supporting 'tc' operations
    in non-init namespaces.  These were simple transformations from
    netlink_capable to netlink_ns_capable.
    
    The Altera driver conflict was simply code removal overlapping some
    void pointer cast cleanups in net-next.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit aa4cf9452f469f16cea8c96283b641b4576d4a7b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Apr 23 14:28:03 2014 -0700

    net: Add variants of capable for use on netlink messages
    
    netlink_net_capable - The common case use, for operations that are safe on a network namespace
    netlink_capable - For operations that are only known to be safe for the global root
    netlink_ns_capable - The general case of capable used to handle special cases
    
    __netlink_ns_capable - Same as netlink_ns_capable except taking a netlink_skb_parms instead of
                           the skbuff of a netlink message.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index aad8eeaf416d..f64b01787ddc 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -169,4 +169,11 @@ struct netlink_tap {
 extern int netlink_add_tap(struct netlink_tap *nt);
 extern int netlink_remove_tap(struct netlink_tap *nt);
 
+bool __netlink_ns_capable(const struct netlink_skb_parms *nsp,
+			  struct user_namespace *ns, int cap);
+bool netlink_ns_capable(const struct sk_buff *skb,
+			struct user_namespace *ns, int cap);
+bool netlink_capable(const struct sk_buff *skb, int cap);
+bool netlink_net_capable(const struct sk_buff *skb, int cap);
+
 #endif	/* __LINUX_NETLINK_H */

commit 4f520900522fd596e336c07e9aafd5b7a9564235
Author: Richard Guy Briggs <rgb@redhat.com>
Date:   Tue Apr 22 21:31:54 2014 -0400

    netlink: have netlink per-protocol bind function return an error code.
    
    Have the netlink per-protocol optional bind function return an int error code
    rather than void to signal a failure.
    
    This will enable netlink protocols to perform extra checks including
    capabilities and permissions verifications when updating memberships in
    multicast groups.
    
    In netlink_bind() and netlink_setsockopt() the call to the per-protocol bind
    function was moved above the multicast group update to prevent any access to
    the multicast socket groups before checking with the per-protocol bind
    function.  This will enable the per-protocol bind function to be used to check
    permissions which could be denied before making them available, and to avoid
    the messy job of undoing the addition should the per-protocol bind function
    fail.
    
    The netfilter subsystem seems to be the only one currently using the
    per-protocol bind function.
    
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index aad8eeaf416d..5146ce066498 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -45,7 +45,8 @@ struct netlink_kernel_cfg {
 	unsigned int	flags;
 	void		(*input)(struct sk_buff *skb);
 	struct mutex	*cb_mutex;
-	void		(*bind)(int group);
+	int		(*bind)(int group);
+	void		(*unbind)(int group);
 	bool		(*compare)(struct net *net, struct sock *sk);
 };
 

commit 2173f8d953e76026bf6ede8ec81ad35ec158dae9
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Mon Dec 30 10:49:22 2013 -0800

    netlink: cleanup tap related functions
    
    Cleanups in netlink_tap code
     * remove unused function netlink_clear_multicast_users
     * make local function static
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 7a6c396a263b..aad8eeaf416d 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -62,7 +62,6 @@ extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
-extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern struct sk_buff *netlink_alloc_skb(struct sock *ssk, unsigned int size,
@@ -168,7 +167,6 @@ struct netlink_tap {
 };
 
 extern int netlink_add_tap(struct netlink_tap *nt);
-extern int __netlink_remove_tap(struct netlink_tap *nt);
 extern int netlink_remove_tap(struct netlink_tap *nt);
 
 #endif	/* __LINUX_NETLINK_H */

commit 3a36515f729458c8efa0c124c7262d5843ad5c37
Author: Pablo Neira <pablo@netfilter.org>
Date:   Fri Jun 28 03:04:23 2013 +0200

    netlink: fix splat in skb_clone with large messages
    
    Since (c05cdb1 netlink: allow large data transfers from user-space),
    netlink splats if it invokes skb_clone on large netlink skbs since:
    
    * skb_shared_info was not correctly initialized.
    * skb->destructor is not set in the cloned skb.
    
    This was spotted by trinity:
    
    [  894.990671] BUG: unable to handle kernel paging request at ffffc9000047b001
    [  894.991034] IP: [<ffffffff81a212c4>] skb_clone+0x24/0xc0
    [...]
    [  894.991034] Call Trace:
    [  894.991034]  [<ffffffff81ad299a>] nl_fib_input+0x6a/0x240
    [  894.991034]  [<ffffffff81c3b7e6>] ? _raw_read_unlock+0x26/0x40
    [  894.991034]  [<ffffffff81a5f189>] netlink_unicast+0x169/0x1e0
    [  894.991034]  [<ffffffff81a601e1>] netlink_sendmsg+0x251/0x3d0
    
    Fix it by:
    
    1) introducing a new netlink_skb_clone function that is used in nl_fib_input,
       that sets our special skb->destructor in the cloned skb. Moreover, handle
       the release of the large cloned skb head area in the destructor path.
    
    2) not allowing large skbuffs in the netlink broadcast path. I cannot find
       any reasonable use of the large data transfer using netlink in that path,
       moreover this helps to skip extra skb_clone handling.
    
    I found two more netlink clients that are cloning the skbs, but they are
    not in the sendmsg path. Therefore, the sole client cloning that I found
    seems to be the fib frontend.
    
    Thanks to Eric Dumazet for helping to address this issue.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 86fde81ac2e6..7a6c396a263b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -85,6 +85,22 @@ int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
 void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
 int netlink_sendskb(struct sock *sk, struct sk_buff *skb);
 
+static inline struct sk_buff *
+netlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)
+{
+	struct sk_buff *nskb;
+
+	nskb = skb_clone(skb, gfp_mask);
+	if (!nskb)
+		return NULL;
+
+	/* This is a large skb, set destructor callback to release head */
+	if (is_vmalloc_addr(skb->head))
+		nskb->destructor = skb->destructor;
+
+	return nskb;
+}
+
 /*
  *	skb should fit one page. This choice is good for headerless malloc.
  *	But we should limit to 8K so that userspace does not have to

commit bcbde0d449eda7afa8f63280b165c8300dbd00e2
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Jun 21 19:38:07 2013 +0200

    net: netlink: virtual tap device management
    
    Similarly to the networking receive path with ptype_all taps, we add
    the possibility to register netdevices that are for ARPHRD_NETLINK to
    the netlink subsystem, so that those can be used for netlink analyzers
    resp. debuggers. We do not offer a direct callback function as out-of-tree
    modules could do crap with it. Instead, a netdevice must be registered
    properly and only receives a clone, managed by the netlink layer. Symbols
    are exported as GPL-only.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f78b430f4af5..86fde81ac2e6 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -145,4 +145,14 @@ static inline int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 	return __netlink_dump_start(ssk, skb, nlh, control);
 }
 
+struct netlink_tap {
+	struct net_device *dev;
+	struct module *module;
+	struct list_head list;
+};
+
+extern int netlink_add_tap(struct netlink_tap *nt);
+extern int __netlink_remove_tap(struct netlink_tap *nt);
+extern int netlink_remove_tap(struct netlink_tap *nt);
+
 #endif	/* __LINUX_NETLINK_H */

commit da12c90e099789a63073fc82a19542ce54d4efb9
Author: Gao feng <gaofeng@cn.fujitsu.com>
Date:   Thu Jun 6 14:49:11 2013 +0800

    netlink: Add compare function for netlink_table
    
    As we know, netlink sockets are private resource of
    net namespace, they can communicate with each other
    only when they in the same net namespace. this works
    well until we try to add namespace support for other
    subsystems which use netlink.
    
    Don't like ipv4 and route table.., it is not suited to
    make these subsytems belong to net namespace, Such as
    audit and crypto subsystems,they are more suitable to
    user namespace.
    
    So we must have the ability to make the netlink sockets
    in same user namespace can communicate with each other.
    
    This patch adds a new function pointer "compare" for
    netlink_table, we can decide if the netlink sockets can
    communicate with each other through this netlink_table
    self-defined compare function.
    
    The behavior isn't changed if we don't provide the compare
    function for netlink_table.
    
    Signed-off-by: Gao feng <gaofeng@cn.fujitsu.com>
    Acked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6358da5eeee8..f78b430f4af5 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -46,6 +46,7 @@ struct netlink_kernel_cfg {
 	void		(*input)(struct sk_buff *skb);
 	struct mutex	*cb_mutex;
 	void		(*bind)(int group);
+	bool		(*compare)(struct net *net, struct sock *sk);
 };
 
 extern struct sock *__netlink_kernel_create(struct net *net, int unit,

commit f9c2288837ba072b21dba955f04a4c97eaa77b1e
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Apr 17 06:47:04 2013 +0000

    netlink: implement memory mapped recvmsg()
    
    Add support for mmap'ed recvmsg(). To allow the kernel to construct messages
    into the mapped area, a dataless skb is allocated and the data pointer is
    set to point into the ring frame. This means frames will be delivered to
    userspace in order of allocation instead of order of transmission. This
    usually doesn't matter since the order is either not determinable by
    userspace or message creation/transmission is serialized. The only case
    where this can have a visible difference is nfnetlink_queue. Userspace
    can't assume mmap'ed messages have ordered IDs anymore and needs to check
    this if using batched verdicts.
    
    For non-mapped sockets, nothing changes.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 07c473848dbd..6358da5eeee8 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -64,6 +64,8 @@ extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group)
 extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
+extern struct sk_buff *netlink_alloc_skb(struct sock *ssk, unsigned int size,
+					 u32 dst_portid, gfp_t gfp_mask);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
 			     __u32 group, gfp_t allocation);

commit 9652e931e73be7e54a9c40e9bcd4bbdafe92a406
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Apr 17 06:47:02 2013 +0000

    netlink: add mmap'ed netlink helper functions
    
    Add helper functions for looking up mmap'ed frame headers, reading and
    writing their status, allocating skbs with mmap'ed data areas and a poll
    function.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index d8e9264ae04a..07c473848dbd 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -15,10 +15,17 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 	return (struct nlmsghdr *)skb->data;
 }
 
+enum netlink_skb_flags {
+	NETLINK_SKB_MMAPED	= 0x1,		/* Packet data is mmaped */
+	NETLINK_SKB_TX		= 0x2,		/* Packet was sent by userspace */
+	NETLINK_SKB_DELIVERED	= 0x4,		/* Packet was delivered */
+};
+
 struct netlink_skb_parms {
 	struct scm_creds	creds;		/* Skb credentials	*/
 	__u32			portid;
 	__u32			dst_group;
+	__u32			flags;
 	struct sock		*sk;
 };
 

commit e32123e59871b9389d5b3fe9318611c7f1d1307a
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Apr 17 06:46:57 2013 +0000

    netlink: rename ssk to sk in struct netlink_skb_params
    
    Memory mapped netlink needs to store the receiving userspace socket
    when sending from the kernel to userspace. Rename 'ssk' to 'sk' to
    avoid confusion.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index e0f746b7b95c..d8e9264ae04a 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -19,7 +19,7 @@ struct netlink_skb_parms {
 	struct scm_creds	creds;		/* Skb credentials	*/
 	__u32			portid;
 	__u32			dst_group;
-	struct sock		*ssk;
+	struct sock		*sk;
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6d3af05c107c..e0f746b7b95c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -1,160 +1,12 @@
 #ifndef __LINUX_NETLINK_H
 #define __LINUX_NETLINK_H
 
-#include <linux/socket.h> /* for __kernel_sa_family_t */
-#include <linux/types.h>
-
-#define NETLINK_ROUTE		0	/* Routing/device hook				*/
-#define NETLINK_UNUSED		1	/* Unused number				*/
-#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
-#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
-#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
-#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
-#define NETLINK_XFRM		6	/* ipsec */
-#define NETLINK_SELINUX		7	/* SELinux event notifications */
-#define NETLINK_ISCSI		8	/* Open-iSCSI */
-#define NETLINK_AUDIT		9	/* auditing */
-#define NETLINK_FIB_LOOKUP	10	
-#define NETLINK_CONNECTOR	11
-#define NETLINK_NETFILTER	12	/* netfilter subsystem */
-#define NETLINK_IP6_FW		13
-#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
-#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
-#define NETLINK_GENERIC		16
-/* leave room for NETLINK_DM (DM Events) */
-#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
-#define NETLINK_ECRYPTFS	19
-#define NETLINK_RDMA		20
-#define NETLINK_CRYPTO		21	/* Crypto layer */
-
-#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
-
-#define MAX_LINKS 32		
-
-struct sockaddr_nl {
-	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
-	unsigned short	nl_pad;		/* zero		*/
-	__u32		nl_pid;		/* port ID	*/
-       	__u32		nl_groups;	/* multicast groups mask */
-};
-
-struct nlmsghdr {
-	__u32		nlmsg_len;	/* Length of message including header */
-	__u16		nlmsg_type;	/* Message content */
-	__u16		nlmsg_flags;	/* Additional flags */
-	__u32		nlmsg_seq;	/* Sequence number */
-	__u32		nlmsg_pid;	/* Sending process port ID */
-};
-
-/* Flags values */
-
-#define NLM_F_REQUEST		1	/* It is request message. 	*/
-#define NLM_F_MULTI		2	/* Multipart message, terminated by NLMSG_DONE */
-#define NLM_F_ACK		4	/* Reply with ack, with zero or error code */
-#define NLM_F_ECHO		8	/* Echo this request 		*/
-#define NLM_F_DUMP_INTR		16	/* Dump was inconsistent due to sequence change */
-
-/* Modifiers to GET request */
-#define NLM_F_ROOT	0x100	/* specify tree	root	*/
-#define NLM_F_MATCH	0x200	/* return all matching	*/
-#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
-#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
-
-/* Modifiers to NEW request */
-#define NLM_F_REPLACE	0x100	/* Override existing		*/
-#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
-#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
-#define NLM_F_APPEND	0x800	/* Add to end of list		*/
-
-/*
-   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
-   4.4BSD CHANGE	NLM_F_REPLACE
-
-   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
-   Append		NLM_F_CREATE
-   Check		NLM_F_EXCL
- */
-
-#define NLMSG_ALIGNTO	4U
-#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
-#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
-#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))
-#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
-#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
-#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
-				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
-#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
-			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
-			   (nlh)->nlmsg_len <= (len))
-#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
-
-#define NLMSG_NOOP		0x1	/* Nothing.		*/
-#define NLMSG_ERROR		0x2	/* Error		*/
-#define NLMSG_DONE		0x3	/* End of a dump	*/
-#define NLMSG_OVERRUN		0x4	/* Data lost		*/
-
-#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
-
-struct nlmsgerr {
-	int		error;
-	struct nlmsghdr msg;
-};
-
-#define NETLINK_ADD_MEMBERSHIP	1
-#define NETLINK_DROP_MEMBERSHIP	2
-#define NETLINK_PKTINFO		3
-#define NETLINK_BROADCAST_ERROR	4
-#define NETLINK_NO_ENOBUFS	5
-
-struct nl_pktinfo {
-	__u32	group;
-};
-
-#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
-
-enum {
-	NETLINK_UNCONNECTED = 0,
-	NETLINK_CONNECTED,
-};
-
-/*
- *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
- * +---------------------+- - -+- - - - - - - - - -+- - -+
- * |        Header       | Pad |     Payload       | Pad |
- * |   (struct nlattr)   | ing |                   | ing |
- * +---------------------+- - -+- - - - - - - - - -+- - -+
- *  <-------------- nlattr->nla_len -------------->
- */
-
-struct nlattr {
-	__u16           nla_len;
-	__u16           nla_type;
-};
-
-/*
- * nla_type (16 bits)
- * +---+---+-------------------------------+
- * | N | O | Attribute Type                |
- * +---+---+-------------------------------+
- * N := Carries nested attributes
- * O := Payload stored in network byte order
- *
- * Note: The N and O flag are mutually exclusive.
- */
-#define NLA_F_NESTED		(1 << 15)
-#define NLA_F_NET_BYTEORDER	(1 << 14)
-#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
-
-#define NLA_ALIGNTO		4
-#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
-#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
-
-#ifdef __KERNEL__
 
 #include <linux/capability.h>
 #include <linux/skbuff.h>
 #include <linux/export.h>
 #include <net/scm.h>
+#include <uapi/linux/netlink.h>
 
 struct net;
 
@@ -283,6 +135,4 @@ static inline int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 	return __netlink_dump_start(ssk, skb, nlh, control);
 }
 
-#endif /* __KERNEL__ */
-
 #endif	/* __LINUX_NETLINK_H */

commit 6dc878a8ca39e93f70c42f3dd7260bde10c1e0f1
Author: Gao feng <gaofeng@cn.fujitsu.com>
Date:   Thu Oct 4 20:15:48 2012 +0000

    netlink: add reference of module in netlink_dump_start
    
    I get a panic when I use ss -a and rmmod inet_diag at the
    same time.
    
    It's because netlink_dump uses inet_diag_dump which belongs to module
    inet_diag.
    
    I search the codes and find many modules have the same problem.  We
    need to add a reference to the module which the cb->dump belongs to.
    
    Thanks for all help from Stephen,Jan,Eric,Steffen and Pablo.
    
    Change From v3:
    change netlink_dump_start to inline,suggestion from Pablo and
    Eric.
    
    Change From v2:
    delete netlink_dump_done,and call module_put in netlink_dump
    and netlink_sock_destruct.
    
    Signed-off-by: Gao feng <gaofeng@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f80c56ac4d82..6d3af05c107c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -245,6 +245,8 @@ struct netlink_callback {
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);
 	void			*data;
+	/* the module that dump function belong to */
+	struct module		*module;
 	u16			family;
 	u16			min_dump_alloc;
 	unsigned int		prev_seq, seq;
@@ -262,14 +264,24 @@ __nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int fla
 
 struct netlink_dump_control {
 	int (*dump)(struct sk_buff *skb, struct netlink_callback *);
-	int (*done)(struct netlink_callback*);
+	int (*done)(struct netlink_callback *);
 	void *data;
+	struct module *module;
 	u16 min_dump_alloc;
 };
 
-extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
-			      const struct nlmsghdr *nlh,
-			      struct netlink_dump_control *control);
+extern int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
+				const struct nlmsghdr *nlh,
+				struct netlink_dump_control *control);
+static inline int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
+				     const struct nlmsghdr *nlh,
+				     struct netlink_dump_control *control)
+{
+	if (!control->module)
+		control->module = THIS_MODULE;
+
+	return __netlink_dump_start(ssk, skb, nlh, control);
+}
 
 #endif /* __KERNEL__ */
 

commit c9d2ea96ca3bbc85264803ff6bd66eb3bbefdb77
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Sep 23 02:09:23 2012 -0400

    netlink: Rearrange netlink_kernel_cfg to save space on 64-bit.
    
    Suggested by Jan Engelhardt.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index b3dc992fb25b..f80c56ac4d82 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -183,10 +183,10 @@ extern void netlink_table_ungrab(void);
 /* optional Netlink kernel configuration parameters */
 struct netlink_kernel_cfg {
 	unsigned int	groups;
+	unsigned int	flags;
 	void		(*input)(struct sk_buff *skb);
 	struct mutex	*cb_mutex;
 	void		(*bind)(int group);
-	unsigned int	flags;
 };
 
 extern struct sock *__netlink_kernel_create(struct net *net, int unit,

commit abb17e6c0c7b27693201dc85f75dbb184279fd10
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Sep 21 09:35:38 2012 +0000

    netlink: use <linux/export.h> instead of <linux/module.h>
    
    Since (9f00d97 netlink: hide struct module parameter in netlink_kernel_create),
    linux/netlink.h includes linux/module.h because of the use of THIS_MODULE.
    
    Use linux/export.h instead, as suggested by Stephen Rothwell, which is
    significantly smaller and defines THIS_MODULES.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 73ade5fbc856..b3dc992fb25b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -153,7 +153,7 @@ struct nlattr {
 
 #include <linux/capability.h>
 #include <linux/skbuff.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <net/scm.h>
 
 struct net;

commit 15e473046cb6e5d18a4d0057e61d76315230382b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Sep 7 20:12:54 2012 +0000

    netlink: Rename pid to portid to avoid confusion
    
    It is a frequent mistake to confuse the netlink port identifier with a
    process identifier.  Try to reduce this confusion by renaming fields
    that hold port identifiers portid instead of pid.
    
    I have carefully avoided changing the structures exported to
    userspace to avoid changing the userspace API.
    
    I have successfully built an allyesconfig kernel with this change.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index cd17dda5a987..73ade5fbc856 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -165,7 +165,7 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 
 struct netlink_skb_parms {
 	struct scm_creds	creds;		/* Skb credentials	*/
-	__u32			pid;
+	__u32			portid;
 	__u32			dst_group;
 	struct sock		*ssk;
 };
@@ -205,14 +205,14 @@ extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group)
 extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
-extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
-extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
+extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
+extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
 			     __u32 group, gfp_t allocation);
 extern int netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,
-	__u32 pid, __u32 group, gfp_t allocation,
+	__u32 portid, __u32 group, gfp_t allocation,
 	int (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),
 	void *filter_data);
-extern int netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
+extern int netlink_set_err(struct sock *ssk, __u32 portid, __u32 group, int code);
 extern int netlink_register_notifier(struct notifier_block *nb);
 extern int netlink_unregister_notifier(struct notifier_block *nb);
 
@@ -253,12 +253,12 @@ struct netlink_callback {
 
 struct netlink_notify {
 	struct net *net;
-	int pid;
+	int portid;
 	int protocol;
 };
 
 struct nlmsghdr *
-__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags);
+__nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags);
 
 struct netlink_dump_control {
 	int (*dump)(struct sk_buff *skb, struct netlink_callback *);

commit 9f00d9776bc5beb92e8bfc884a7e96ddc5589e2e
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Sat Sep 8 02:53:54 2012 +0000

    netlink: hide struct module parameter in netlink_kernel_create
    
    This patch defines netlink_kernel_create as a wrapper function of
    __netlink_kernel_create to hide the struct module *me parameter
    (which seems to be THIS_MODULE in all existing netlink subsystems).
    
    Suggested by David S. Miller.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 8719a4e235a5..cd17dda5a987 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -153,6 +153,7 @@ struct nlattr {
 
 #include <linux/capability.h>
 #include <linux/skbuff.h>
+#include <linux/module.h>
 #include <net/scm.h>
 
 struct net;
@@ -188,9 +189,15 @@ struct netlink_kernel_cfg {
 	unsigned int	flags;
 };
 
-extern struct sock *netlink_kernel_create(struct net *net, int unit,
-					  struct module *module,
-					  struct netlink_kernel_cfg *cfg);
+extern struct sock *__netlink_kernel_create(struct net *net, int unit,
+					    struct module *module,
+					    struct netlink_kernel_cfg *cfg);
+static inline struct sock *
+netlink_kernel_create(struct net *net, int unit, struct netlink_kernel_cfg *cfg)
+{
+	return __netlink_kernel_create(net, unit, THIS_MODULE, cfg);
+}
+
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit 9785e10aedfa0fad5c1aac709dce5ada1b123783
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Sat Sep 8 02:53:53 2012 +0000

    netlink: kill netlink_set_nonroot
    
    Replace netlink_set_nonroot by one new field `flags' in
    struct netlink_kernel_cfg that is passed to netlink_kernel_create.
    
    This patch also renames NL_NONROOT_* to NL_CFG_F_NONROOT_* since
    now the flags field in nl_table is generic (so we can add more
    flags if needed in the future).
    
    Also adjust all callers in the net-next tree to use these flags
    instead of netlink_set_nonroot.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index df73cf4b0290..8719a4e235a5 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -176,12 +176,16 @@ struct netlink_skb_parms {
 extern void netlink_table_grab(void);
 extern void netlink_table_ungrab(void);
 
+#define NL_CFG_F_NONROOT_RECV	(1 << 0)
+#define NL_CFG_F_NONROOT_SEND	(1 << 1)
+
 /* optional Netlink kernel configuration parameters */
 struct netlink_kernel_cfg {
 	unsigned int	groups;
 	void		(*input)(struct sk_buff *skb);
 	struct mutex	*cb_mutex;
 	void		(*bind)(int group);
+	unsigned int	flags;
 };
 
 extern struct sock *netlink_kernel_create(struct net *net, int unit,
@@ -260,11 +264,6 @@ extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 			      const struct nlmsghdr *nlh,
 			      struct netlink_dump_control *control);
 
-
-#define NL_NONROOT_RECV 0x1
-#define NL_NONROOT_SEND 0x2
-extern void netlink_set_nonroot(int protocol, unsigned flag);
-
 #endif /* __KERNEL__ */
 
 #endif	/* __LINUX_NETLINK_H */

commit dbe9a4173ea53b72b2c35d19f676a85b69f1c9fe
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Sep 6 18:20:01 2012 +0000

    scm: Don't use struct ucred in NETLINK_CB and struct scm_cookie.
    
    Passing uids and gids on NETLINK_CB from a process in one user
    namespace to a process in another user namespace can result in the
    wrong uid or gid being presented to userspace.  Avoid that problem by
    passing kuids and kgids instead.
    
    - define struct scm_creds for use in scm_cookie and netlink_skb_parms
      that holds uid and gid information in kuid_t and kgid_t.
    
    - Modify scm_set_cred to fill out scm_creds by heand instead of using
      cred_to_ucred to fill out struct ucred.  This conversion ensures
      userspace does not get incorrect uid or gid values to look at.
    
    - Modify scm_recv to convert from struct scm_creds to struct ucred
      before copying credential values to userspace.
    
    - Modify __scm_send to populate struct scm_creds on in the scm_cookie,
      instead of just copying struct ucred from userspace.
    
    - Modify netlink_sendmsg to copy scm_creds instead of struct ucred
      into the NETLINK_CB.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index c9fdde2bc73f..df73cf4b0290 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -153,6 +153,7 @@ struct nlattr {
 
 #include <linux/capability.h>
 #include <linux/skbuff.h>
+#include <net/scm.h>
 
 struct net;
 
@@ -162,7 +163,7 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 }
 
 struct netlink_skb_parms {
-	struct ucred		creds;		/* Skb credentials	*/
+	struct scm_creds	creds;		/* Skb credentials	*/
 	__u32			pid;
 	__u32			dst_group;
 	struct sock		*ssk;

commit 3fbc290540a1ed1a8a076ed8f53bee7a38a9f408
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu May 24 17:21:27 2012 -0600

    netlink: Make the sending netlink socket availabe in NETLINK_CB
    
    The sending socket of an skb is already available by it's port id
    in the NETLINK_CB.  If you want to know more like to examine the
    credentials on the sending socket you have to look up the sending
    socket by it's port id and all of the needed functions and data
    structures are static inside of af_netlink.c.  So do the simple
    thing and pass the sending socket to the receivers in the NETLINK_CB.
    
    I intend to use this to get the user namespace of the sending socket
    in inet_diag so that I can report uids in the context of the process
    who opened the socket, the same way I report uids in the contect
    of the process who opens files.
    
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f74dd133788f..c9fdde2bc73f 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -165,6 +165,7 @@ struct netlink_skb_parms {
 	struct ucred		creds;		/* Skb credentials	*/
 	__u32			pid;
 	__u32			dst_group;
+	struct sock		*ssk;
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit 03292745b02d1166e2a215504407e096b8427be5
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Jun 29 06:15:22 2012 +0000

    netlink: add nlk->netlink_bind hook for module auto-loading
    
    This patch adds a hook in the binding path of netlink.
    
    This is used by ctnetlink to allow module autoloading for the case
    in which one user executes:
    
     conntrack -E
    
    So far, this resulted in nfnetlink loaded, but not
    nf_conntrack_netlink.
    
    I have received in the past many complains on this behaviour.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6085e4919cb3..f74dd133788f 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -179,6 +179,7 @@ struct netlink_kernel_cfg {
 	unsigned int	groups;
 	void		(*input)(struct sk_buff *skb);
 	struct mutex	*cb_mutex;
+	void		(*bind)(int group);
 };
 
 extern struct sock *netlink_kernel_create(struct net *net, int unit,

commit a31f2d17b331db970259e875b7223d3aba7e3821
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Jun 29 06:15:21 2012 +0000

    netlink: add netlink_kernel_cfg parameter to netlink_kernel_create
    
    This patch adds the following structure:
    
    struct netlink_kernel_cfg {
            unsigned int    groups;
            void            (*input)(struct sk_buff *skb);
            struct mutex    *cb_mutex;
    };
    
    That can be passed to netlink_kernel_create to set optional configurations
    for netlink kernel sockets.
    
    I've populated this structure by looking for NULL and zero parameters at the
    existing code. The remaining parameters that always need to be set are still
    left in the original interface.
    
    That includes optional parameters for the netlink socket creation. This allows
    easy extensibility of this interface in the future.
    
    This patch also adapts all callers to use this new interface.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index ed33f0901bc2..6085e4919cb3 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -174,11 +174,16 @@ struct netlink_skb_parms {
 extern void netlink_table_grab(void);
 extern void netlink_table_ungrab(void);
 
-extern struct sock *netlink_kernel_create(struct net *net,
-					  int unit,unsigned int groups,
-					  void (*input)(struct sk_buff *skb),
-					  struct mutex *cb_mutex,
-					  struct module *module);
+/* optional Netlink kernel configuration parameters */
+struct netlink_kernel_cfg {
+	unsigned int	groups;
+	void		(*input)(struct sk_buff *skb);
+	struct mutex	*cb_mutex;
+};
+
+extern struct sock *netlink_kernel_create(struct net *net, int unit,
+					  struct module *module,
+					  struct netlink_kernel_cfg *cfg);
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit c3deafc5261a9421b315ee0d0e8e36ba7857128c
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 26 21:51:35 2012 -0700

    netlink: Delete NLMSG_PUT and NLMSG_NEW.
    
    No longer used and a poor interface as they were macros
    with embedded gotos.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 0f628ffa420c..ed33f0901bc2 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -241,14 +241,6 @@ struct netlink_notify {
 struct nlmsghdr *
 __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags);
 
-#define NLMSG_NEW(skb, pid, seq, type, len, flags) \
-({	if (unlikely(skb_tailroom(skb) < (int)NLMSG_SPACE(len))) \
-		goto nlmsg_failure; \
-	__nlmsg_put(skb, pid, seq, type, len, flags); })
-
-#define NLMSG_PUT(skb, pid, seq, type, len) \
-	NLMSG_NEW(skb, pid, seq, type, len, 0)
-
 struct netlink_dump_control {
 	int (*dump)(struct sk_buff *skb, struct netlink_callback *);
 	int (*done)(struct netlink_callback*);

commit d16cf20e2f2f13411eece7f7fb72c17d141c4a84
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue May 8 19:45:28 2012 +0200

    netfilter: remove ip_queue support
    
    This patch removes ip_queue support which was marked as obsolete
    years ago. The nfnetlink_queue modules provides more advanced
    user-space packet queueing mechanism.
    
    This patch also removes capability code included in SELinux that
    refers to ip_queue. Otherwise, we break compilation.
    
    Several warning has been sent regarding this to the mailing list
    in the past month without anyone rising the hand to stop this
    with some strong argument.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index a2092f582a78..0f628ffa420c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -7,7 +7,7 @@
 #define NETLINK_ROUTE		0	/* Routing/device hook				*/
 #define NETLINK_UNUSED		1	/* Unused number				*/
 #define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
-#define NETLINK_FIREWALL	3	/* Firewalling hook				*/
+#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
 #define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
 #define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
 #define NETLINK_XFRM		6	/* ipsec */

commit 7175c883071515f0d4c1cece2646203b8a5a7415
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Feb 24 14:30:16 2012 +0000

    netlink: allow to pass data pointer to netlink_dump_start() callback
    
    This patch allows you to pass a data pointer that can be
    accessed from the dump callback.
    
    Netfilter is going to use this patch to provide filtered dumps
    to user-space. This is specifically interesting in ctnetlink that
    may handle lots of conntrack entries. We can save precious
    cycles by skipping the conversion to TLV format of conntrack
    entries that are not interesting for user-space.
    
    More specifically, ctnetlink will include one operation to allow
    to filter the dumping of conntrack entries by ctmark values.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 1f8c1a95f57c..a2092f582a78 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -225,6 +225,7 @@ struct netlink_callback {
 	int			(*dump)(struct sk_buff * skb,
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);
+	void			*data;
 	u16			family;
 	u16			min_dump_alloc;
 	unsigned int		prev_seq, seq;
@@ -251,6 +252,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 struct netlink_dump_control {
 	int (*dump)(struct sk_buff *skb, struct netlink_callback *);
 	int (*done)(struct netlink_callback*);
+	void *data;
 	u16 min_dump_alloc;
 };
 

commit 80d326fab534a5380e8f6e509a0b9076655a9670
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Fri Feb 24 14:30:15 2012 +0000

    netlink: add netlink_dump_control structure for netlink_dump_start()
    
    Davem considers that the argument list of this interface is getting
    out of control. This patch tries to address this issue following
    his proposal:
    
    struct netlink_dump_control c = { .dump = dump, .done = done, ... };
    
    netlink_dump_start(..., &c);
    
    Suggested by David S. Miller.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index a390e9d54827..1f8c1a95f57c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -248,11 +248,15 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 #define NLMSG_PUT(skb, pid, seq, type, len) \
 	NLMSG_NEW(skb, pid, seq, type, len, 0)
 
+struct netlink_dump_control {
+	int (*dump)(struct sk_buff *skb, struct netlink_callback *);
+	int (*done)(struct netlink_callback*);
+	u16 min_dump_alloc;
+};
+
 extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 			      const struct nlmsghdr *nlh,
-			      int (*dump)(struct sk_buff *skb, struct netlink_callback*),
-			      int (*done)(struct netlink_callback*),
-			      u16 min_dump_alloc);
+			      struct netlink_dump_control *control);
 
 
 #define NL_NONROOT_RECV 0x1

commit a46621a3a8f24557201a7ef62de151c812f8985c
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Mon Jan 30 15:22:06 2012 -0500

    net: Deinline __nlmsg_put and genlmsg_put. -7k code on i386 defconfig.
    
       text    data     bss     dec     hex filename
    8455963  532732 1810804 10799499 a4c98b vmlinux.o.before
    8448899  532732 1810804 10792435 a4adf3 vmlinux.o
    
    This change also removes commented-out copy of __nlmsg_put
    which was last touched in 2005 with "Enable once all users
    have been converted" comment on top.
    
    Changes in v2: rediffed against net-next.
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 52e48959cfa1..a390e9d54827 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -237,22 +237,8 @@ struct netlink_notify {
 	int protocol;
 };
 
-static __inline__ struct nlmsghdr *
-__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
-{
-	struct nlmsghdr *nlh;
-	int size = NLMSG_LENGTH(len);
-
-	nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_len = size;
-	nlh->nlmsg_flags = flags;
-	nlh->nlmsg_pid = pid;
-	nlh->nlmsg_seq = seq;
-	if (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)
-		memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
-	return nlh;
-}
+struct nlmsghdr *
+__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags);
 
 #define NLMSG_NEW(skb, pid, seq, type, len, flags) \
 ({	if (unlikely(skb_tailroom(skb) < (int)NLMSG_SPACE(len))) \

commit 7f1fb60c4fc9fb29fbb406ac8c4cfb4e59e168d6
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Tue Dec 6 07:56:43 2011 +0000

    inet_diag: Partly rename inet_ to sock_
    
    The ultimate goal is to get the sock_diag module, that works in
    family+protocol terms. Currently this is suitable to do on the
    inet_diag basis, so rename parts of the code. It will be moved
    to sock_diag.c later.
    
    Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 8374d2967362..52e48959cfa1 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -8,7 +8,7 @@
 #define NETLINK_UNUSED		1	/* Unused number				*/
 #define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
 #define NETLINK_FIREWALL	3	/* Firewalling hook				*/
-#define NETLINK_INET_DIAG	4	/* INET socket monitoring			*/
+#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
 #define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
 #define NETLINK_XFRM		6	/* ipsec */
 #define NETLINK_SELINUX		7	/* SELinux event notifications */
@@ -27,6 +27,8 @@
 #define NETLINK_RDMA		20
 #define NETLINK_CRYPTO		21	/* Crypto layer */
 
+#define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
+
 #define MAX_LINKS 32		
 
 struct sockaddr_nl {

commit dc47d3810cdcb4f32bfa31d50f26af97aced0638
Merge: f6d90b4f9ce0 5db017aa2809
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 09:24:41 2011 -0700

    Merge git://github.com/herbertx/crypto
    
    * git://github.com/herbertx/crypto: (48 commits)
      crypto: user - Depend on NET instead of selecting it
      crypto: user - Add dependency on NET
      crypto: talitos - handle descriptor not found in error path
      crypto: user - Initialise match in crypto_alg_match
      crypto: testmgr - add twofish tests
      crypto: testmgr - add blowfish test-vectors
      crypto: Make hifn_795x build depend on !ARCH_DMA_ADDR_T_64BIT
      crypto: twofish-x86_64-3way - fix ctr blocksize to 1
      crypto: blowfish-x86_64 - fix ctr blocksize to 1
      crypto: whirlpool - count rounds from 0
      crypto: Add userspace report for compress type algorithms
      crypto: Add userspace report for cipher type algorithms
      crypto: Add userspace report for rng type algorithms
      crypto: Add userspace report for pcompress type algorithms
      crypto: Add userspace report for nivaead type algorithms
      crypto: Add userspace report for aead type algorithms
      crypto: Add userspace report for givcipher type algorithms
      crypto: Add userspace report for ablkcipher type algorithms
      crypto: Add userspace report for blkcipher type algorithms
      crypto: Add userspace report for ahash type algorithms
      ...

commit a38f7907b926e4c6c7d389ad96cc38cec2e5a9e9
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Tue Sep 27 07:23:50 2011 +0200

    crypto: Add userspace configuration API
    
    This patch adds a basic userspace configuration API for the crypto layer.
    With this it is possible to instantiate, remove and to show crypto
    algorithms from userspace.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2e17c5dbdcb8..464ace04283b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -25,6 +25,7 @@
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
 #define NETLINK_RDMA		20
+#define NETLINK_CRYPTO		21	/* Crypto layer */
 
 #define MAX_LINKS 32		
 

commit bcb949b8847655516ba499ca75cd8529f167e360
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Wed Aug 24 18:43:55 2011 +0000

    headers, net: Use __kernel_sa_family_t in more definitions shared with userland
    
    Complete the work started with commit
    6602a4baf4d1a73cc4685a39ef859e1c5ddf654c ('net: Make userland include
    of netlink.h more sane').
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 180540a84d37..8180cd9d73d5 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -1,7 +1,7 @@
 #ifndef __LINUX_NETLINK_H
 #define __LINUX_NETLINK_H
 
-#include <linux/socket.h> /* for sa_family_t */
+#include <linux/socket.h> /* for __kernel_sa_family_t */
 #include <linux/types.h>
 
 #define NETLINK_ROUTE		0	/* Routing/device hook				*/

commit 6602a4baf4d1a73cc4685a39ef859e1c5ddf654c
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 7 22:48:07 2011 -0700

    net: Make userland include of netlink.h more sane.
    
    Currently userland will barf when including linux/netlink.h unless it
    precisely includes sys/socket.h first.  The issue is where the
    definition of "sa_family_t" comes from.
    
    We've been back and forth on how to fix this issue in the past, see:
    
    http://thread.gmane.org/gmane.linux.debian.devel.bugs.general/622621
    http://thread.gmane.org/gmane.linux.network/143380
    
    Ben Hutchings suggested we take a hint from how we handle the
    sockaddr_storage type.  First we define a "__kernel_sa_family_t"
    to linux/socket.h that is always defined.
    
    Then if __KERNEL__ is defined, we also define "sa_family_t" as
    equal to "__kernel_sa_family_t".
    
    Then in places like linux/netlink.h we use __kernel_sa_family_t
    in user visible datastructures.
    
    Reported-by: Michel Machado <michel@digirati.com.br>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2e17c5dbdcb8..180540a84d37 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -29,7 +29,7 @@
 #define MAX_LINKS 32		
 
 struct sockaddr_nl {
-	sa_family_t	nl_family;	/* AF_NETLINK	*/
+	__kernel_sa_family_t	nl_family;	/* AF_NETLINK	*/
 	unsigned short	nl_pad;		/* zero		*/
 	__u32		nl_pid;		/* port ID	*/
        	__u32		nl_groups;	/* multicast groups mask */

commit 36099365c7cc64e5184b66b6eb094950a13f540c
Merge: 22c8c9343258 f70490e6078a
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Jun 24 15:25:51 2011 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            drivers/net/wireless/rtlwifi/pci.c
            include/linux/netlink.h

commit 670dc2833d144375eac36ad74111495a825a9288
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jun 20 13:40:46 2011 +0200

    netlink: advertise incomplete dumps
    
    Consider the following situation:
     * a dump that would show 8 entries, four in the first
       round, and four in the second
     * between the first and second rounds, 6 entries are
       removed
     * now the second round will not show any entry, and
       even if there is a sequence/generation counter the
       application will not know
    
    To solve this problem, add a new flag NLM_F_DUMP_INTR
    to the netlink header that indicates the dump wasn't
    consistent, this flag can also be set on the MSG_DONE
    message that terminates the dump, and as such above
    situation can be detected.
    
    To achieve this, add a sequence counter to the netlink
    callback struct. Of course, netlink code still needs
    to use this new functionality. The correct way to do
    that is to always set cb->seq when a dumpit callback
    is invoked and call nl_dump_check_consistent() for
    each new message. The core code will also call this
    function for the final MSG_DONE message.
    
    To make it usable with generic netlink, a new function
    genlmsg_nlhdr() is needed to obtain the netlink header
    from the genetlink user header.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 4c4ac3f3ce5a..8d1bcec5cc06 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -48,6 +48,7 @@ struct nlmsghdr {
 #define NLM_F_MULTI		2	/* Multipart message, terminated by NLMSG_DONE */
 #define NLM_F_ACK		4	/* Reply with ack, with zero or error code */
 #define NLM_F_ECHO		8	/* Echo this request 		*/
+#define NLM_F_DUMP_INTR		16	/* Dump was inconsistent due to sequence change */
 
 /* Modifiers to GET request */
 #define NLM_F_ROOT	0x100	/* specify tree	root	*/
@@ -221,6 +222,7 @@ struct netlink_callback {
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);
 	int			family;
+	unsigned int		prev_seq, seq;
 	long			args[6];
 };
 

commit c7ac8679bec9397afe8918f788cbcef88c38da54
Author: Greg Rose <gregory.v.rose@intel.com>
Date:   Fri Jun 10 01:27:09 2011 +0000

    rtnetlink: Compute and store minimum ifinfo dump size
    
    The message size allocated for rtnl ifinfo dumps was limited to
    a single page.  This is not enough for additional interface info
    available with devices that support SR-IOV and caused a bug in
    which VF info would not be displayed if more than approximately
    40 VFs were created per interface.
    
    Implement a new function pointer for the rtnl_register service that will
    calculate the amount of data required for the ifinfo dump and allocate
    enough data to satisfy the request.
    
    Signed-off-by: Greg Rose <gregory.v.rose@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index a9dd89552f9c..fdd0188a167e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -221,7 +221,8 @@ struct netlink_callback {
 	int			(*dump)(struct sk_buff * skb,
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);
-	int			family;
+	u16			family;
+	u16			min_dump_alloc;
 	long			args[6];
 };
 
@@ -259,7 +260,8 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 			      const struct nlmsghdr *nlh,
 			      int (*dump)(struct sk_buff *skb, struct netlink_callback*),
-			      int (*done)(struct netlink_callback*));
+			      int (*done)(struct netlink_callback*),
+			      u16 min_dump_alloc);
 
 
 #define NL_NONROOT_RECV 0x1

commit b2cbae2c248776d81cc265ff7d48405b6a4cc463
Author: Roland Dreier <roland@purestorage.com>
Date:   Fri May 20 11:46:11 2011 -0700

    RDMA: Add netlink infrastructure
    
    Add basic RDMA netlink infrastructure that allows for registration of
    RDMA clients for which data is to be exported and supplies message
    construction callbacks.
    
    Signed-off-by: Nir Muchtar <nirm@voltaire.com>
    
    [ Reorganize a few things, add CONFIG_NET dependency.  - Roland ]
    
    Signed-off-by: Roland Dreier <roland@purestorage.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 4c4ac3f3ce5a..a9dd89552f9c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -24,6 +24,7 @@
 /* leave room for NETLINK_DM (DM Events) */
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
+#define NETLINK_RDMA		20
 
 #define MAX_LINKS 32		
 

commit 01a16b21d6adf992aa863186c3c4e561a57c1714
Author: Patrick McHardy <kaber@trash.net>
Date:   Thu Mar 3 13:32:07 2011 -0800

    netlink: kill eff_cap from struct netlink_skb_parms
    
    Netlink message processing in the kernel is synchronous these days,
    capabilities can be checked directly in security_netlink_recv() from
    the current process.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Reviewed-by: James Morris <jmorris@namei.org>
    [chrisw: update to include pohmelfs and uvesafb]
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 66823b862022..4c4ac3f3ce5a 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -160,7 +160,6 @@ struct netlink_skb_parms {
 	struct ucred		creds;		/* Skb credentials	*/
 	__u32			pid;
 	__u32			dst_group;
-	kernel_cap_t		eff_cap;
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit c53fa1ed92cd671a1dfb1e7569e9ab672612ddc6
Author: Patrick McHardy <kaber@trash.net>
Date:   Thu Mar 3 10:55:40 2011 -0800

    netlink: kill loginuid/sessionid/sid members from struct netlink_skb_parms
    
    Netlink message processing in the kernel is synchronous these days, the
    session information can be collected when needed.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index e2b9e63afa68..66823b862022 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -161,9 +161,6 @@ struct netlink_skb_parms {
 	__u32			pid;
 	__u32			dst_group;
 	kernel_cap_t		eff_cap;
-	__u32			loginuid;	/* Login (audit) uid */
-	__u32			sessionid;	/* Session id (audit) */
-	__u32			sid;		/* SELinux security id */
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit 4b8fe66300acb2fba8b16d62606e0d30204022fc
Author: Dmitry V. Levin <ldv@altlinux.org>
Date:   Fri Dec 17 12:03:14 2010 -0800

    netlink: fix gcc -Wconversion compilation warning
    
    $ cat << EOF | gcc -Wconversion -xc -S -o/dev/null -
    unsigned f(void) {return NLMSG_HDRLEN;}
    EOF
    <stdin>: In function 'f':
    <stdin>:3:26: warning: negative integer implicitly converted to unsigned type
    
    Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>
    Signed-off-by: Kirill A. Shutemov <kirill@shutemov.name>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 123566912d73..e2b9e63afa68 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -70,7 +70,7 @@ struct nlmsghdr {
    Check		NLM_F_EXCL
  */
 
-#define NLMSG_ALIGNTO	4
+#define NLMSG_ALIGNTO	4U
 #define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
 #define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
 #define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))

commit 56b49f4b8f6728b91d10c556c116175051b77b60
Author: Ollie Wild <aaw@google.com>
Date:   Wed Sep 22 05:54:54 2010 +0000

    net: Move "struct net" declaration inside the __KERNEL__ macro guard
    
    This patch reduces namespace pollution by moving the "struct net" declaration
    out of the userspace-facing portion of linux/netlink.h.  It has no impact on
    the kernel.
    
    (This came up because we have several C++ applications which use "net" as a
    namespace name.)
    
    Signed-off-by: Ollie Wild <aaw@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 59d066936ab9..123566912d73 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -27,8 +27,6 @@
 
 #define MAX_LINKS 32		
 
-struct net;
-
 struct sockaddr_nl {
 	sa_family_t	nl_family;	/* AF_NETLINK	*/
 	unsigned short	nl_pad;		/* zero		*/
@@ -151,6 +149,8 @@ struct nlattr {
 #include <linux/capability.h>
 #include <linux/skbuff.h>
 
+struct net;
+
 static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 {
 	return (struct nlmsghdr *)skb->data;

commit 910a7e905f36e51a17d6e8bb4ad6dcd5ac5f1d53
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue May 4 17:36:46 2010 -0700

    netlink: Implment netlink_broadcast_filtered
    
    When netlink sockets are used to convey data that is in a namespace
    we need a way to select a subset of the listening sockets to deliver
    the packet to.  For the network namespace we have been doing this
    by only transmitting packets in the correct network namespace.
    
    For data belonging to other namespaces netlink_bradcast_filtered
    provides a mechanism that allows us to examine the destination
    socket and to decide if we should transmit the specified packet
    to it.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6eaca5e1e8ca..59d066936ab9 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -188,6 +188,10 @@ extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
 			     __u32 group, gfp_t allocation);
+extern int netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,
+	__u32 pid, __u32 group, gfp_t allocation,
+	int (*filter)(struct sock *dsk, struct sk_buff *skb, void *data),
+	void *filter_data);
 extern int netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
 extern int netlink_register_notifier(struct notifier_block *nb);
 extern int netlink_unregister_notifier(struct notifier_block *nb);

commit 1a50307ba1826e4da0024e64b245ce4eadf7688a
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Thu Mar 18 14:24:42 2010 +0000

    netlink: fix NETLINK_RECV_NO_ENOBUFS in netlink_set_err()
    
    Currently, ENOBUFS errors are reported to the socket via
    netlink_set_err() even if NETLINK_RECV_NO_ENOBUFS is set. However,
    that should not happen. This fixes this problem and it changes the
    prototype of netlink_set_err() to return the number of sockets that
    have set the NETLINK_RECV_NO_ENOBUFS socket option. This return
    value is used in the next patch in these bugfix series.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index fde27c017326..6eaca5e1e8ca 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -188,7 +188,7 @@ extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
 			     __u32 group, gfp_t allocation);
-extern void netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
+extern int netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
 extern int netlink_register_notifier(struct notifier_block *nb);
 extern int netlink_unregister_notifier(struct notifier_block *nb);
 

commit d94d9fee9fa4e66a0b91640a694b8b10177075b3
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Nov 4 09:50:58 2009 -0800

    net: cleanup include/linux
    
    This cleanup patch puts struct/union/enum opening braces,
    in first line to ease grep games.
    
    struct something
    {
    
    becomes :
    
    struct something {
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index ab5d3126831f..fde27c017326 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -29,16 +29,14 @@
 
 struct net;
 
-struct sockaddr_nl
-{
+struct sockaddr_nl {
 	sa_family_t	nl_family;	/* AF_NETLINK	*/
 	unsigned short	nl_pad;		/* zero		*/
 	__u32		nl_pid;		/* port ID	*/
        	__u32		nl_groups;	/* multicast groups mask */
 };
 
-struct nlmsghdr
-{
+struct nlmsghdr {
 	__u32		nlmsg_len;	/* Length of message including header */
 	__u16		nlmsg_type;	/* Message content */
 	__u16		nlmsg_flags;	/* Additional flags */
@@ -94,8 +92,7 @@ struct nlmsghdr
 
 #define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
 
-struct nlmsgerr
-{
+struct nlmsgerr {
 	int		error;
 	struct nlmsghdr msg;
 };
@@ -106,8 +103,7 @@ struct nlmsgerr
 #define NETLINK_BROADCAST_ERROR	4
 #define NETLINK_NO_ENOBUFS	5
 
-struct nl_pktinfo
-{
+struct nl_pktinfo {
 	__u32	group;
 };
 
@@ -127,8 +123,7 @@ enum {
  *  <-------------- nlattr->nla_len -------------->
  */
 
-struct nlattr
-{
+struct nlattr {
 	__u16           nla_len;
 	__u16           nla_type;
 };
@@ -161,8 +156,7 @@ static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
 	return (struct nlmsghdr *)skb->data;
 }
 
-struct netlink_skb_parms
-{
+struct netlink_skb_parms {
 	struct ucred		creds;		/* Skb credentials	*/
 	__u32			pid;
 	__u32			dst_group;
@@ -220,8 +214,7 @@ int netlink_sendskb(struct sock *sk, struct sk_buff *skb);
 #define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)
 
 
-struct netlink_callback
-{
+struct netlink_callback {
 	struct sk_buff		*skb;
 	const struct nlmsghdr	*nlh;
 	int			(*dump)(struct sk_buff * skb,
@@ -231,8 +224,7 @@ struct netlink_callback
 	long			args[6];
 };
 
-struct netlink_notify
-{
+struct netlink_notify {
 	struct net *net;
 	int pid;
 	int protocol;

commit b8273570f802a7658827dcb077b0b517ba75a289
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Sep 24 15:44:05 2009 -0700

    genetlink: fix netns vs. netlink table locking (2)
    
    Similar to commit d136f1bd366fdb7e747ca7e0218171e7a00a98a5,
    there's a bug when unregistering a generic netlink family,
    which is caught by the might_sleep() added in that commit:
    
        BUG: sleeping function called from invalid context at net/netlink/af_netlink.c:183
        in_atomic(): 1, irqs_disabled(): 0, pid: 1510, name: rmmod
        2 locks held by rmmod/1510:
         #0:  (genl_mutex){+.+.+.}, at: [<ffffffff8138283b>] genl_unregister_family+0x2b/0x130
         #1:  (rcu_read_lock){.+.+..}, at: [<ffffffff8138270c>] __genl_unregister_mc_group+0x1c/0x120
        Pid: 1510, comm: rmmod Not tainted 2.6.31-wl #444
        Call Trace:
         [<ffffffff81044ff9>] __might_sleep+0x119/0x150
         [<ffffffff81380501>] netlink_table_grab+0x21/0x100
         [<ffffffff813813a3>] netlink_clear_multicast_users+0x23/0x60
         [<ffffffff81382761>] __genl_unregister_mc_group+0x71/0x120
         [<ffffffff81382866>] genl_unregister_family+0x56/0x130
         [<ffffffffa0007d85>] nl80211_exit+0x15/0x20 [cfg80211]
         [<ffffffffa000005a>] cfg80211_exit+0x1a/0x40 [cfg80211]
    
    Fix in the same way by grabbing the netlink table lock
    before doing rcu_read_lock().
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 080f6ba9e73a..ab5d3126831f 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -187,6 +187,7 @@ extern struct sock *netlink_kernel_create(struct net *net,
 extern void netlink_kernel_release(struct sock *sk);
 extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
+extern void __netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);

commit d136f1bd366fdb7e747ca7e0218171e7a00a98a5
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Sat Sep 12 03:03:15 2009 +0000

    genetlink: fix netns vs. netlink table locking
    
    Since my commits introducing netns awareness into
    genetlink we can get this problem:
    
    BUG: scheduling while atomic: modprobe/1178/0x00000002
    2 locks held by modprobe/1178:
     #0:  (genl_mutex){+.+.+.}, at: [<ffffffff8135ee1a>] genl_register_mc_grou
     #1:  (rcu_read_lock){.+.+..}, at: [<ffffffff8135eeb5>] genl_register_mc_g
    Pid: 1178, comm: modprobe Not tainted 2.6.31-rc8-wl-34789-g95cb731-dirty #
    Call Trace:
     [<ffffffff8103e285>] __schedule_bug+0x85/0x90
     [<ffffffff81403138>] schedule+0x108/0x588
     [<ffffffff8135b131>] netlink_table_grab+0xa1/0xf0
     [<ffffffff8135c3a7>] netlink_change_ngroups+0x47/0x100
     [<ffffffff8135ef0f>] genl_register_mc_group+0x12f/0x290
    
    because I overlooked that netlink_table_grab() will
    schedule, thinking it was just the rwlock. However,
    in the contention case, that isn't actually true.
    
    Fix this by letting the code grab the netlink table
    lock first and then the RCU for netns protection.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 0fbecbbe8e9e..080f6ba9e73a 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -176,12 +176,16 @@ struct netlink_skb_parms
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
+extern void netlink_table_grab(void);
+extern void netlink_table_ungrab(void);
+
 extern struct sock *netlink_kernel_create(struct net *net,
 					  int unit,unsigned int groups,
 					  void (*input)(struct sk_buff *skb),
 					  struct mutex *cb_mutex,
 					  struct module *module);
 extern void netlink_kernel_release(struct sock *sk);
+extern int __netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);

commit 3a6c2b419b7768703cfb2cabdb894517c5065e33
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Aug 25 16:07:40 2009 +0200

    netlink: constify nlmsghdr arguments
    
    Consitfy nlmsghdr arguments to a couple of functions as preparation
    for the next patch, which will constify the netlink message data in
    all nfnetlink users.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 5ba398e90304..0fbecbbe8e9e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -217,12 +217,13 @@ int netlink_sendskb(struct sock *sk, struct sk_buff *skb);
 
 struct netlink_callback
 {
-	struct sk_buff	*skb;
-	struct nlmsghdr	*nlh;
-	int		(*dump)(struct sk_buff * skb, struct netlink_callback *cb);
-	int		(*done)(struct netlink_callback *cb);
-	int		family;
-	long		args[6];
+	struct sk_buff		*skb;
+	const struct nlmsghdr	*nlh;
+	int			(*dump)(struct sk_buff * skb,
+					struct netlink_callback *cb);
+	int			(*done)(struct netlink_callback *cb);
+	int			family;
+	long			args[6];
 };
 
 struct netlink_notify
@@ -258,7 +259,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 	NLMSG_NEW(skb, pid, seq, type, len, 0)
 
 extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
-			      struct nlmsghdr *nlh,
+			      const struct nlmsghdr *nlh,
 			      int (*dump)(struct sk_buff *skb, struct netlink_callback*),
 			      int (*done)(struct netlink_callback*));
 

commit 38938bfe3489394e2eed5e40c9bb8f66a2ce1405
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue Mar 24 16:37:55 2009 -0700

    netlink: add NETLINK_NO_ENOBUFS socket flag
    
    This patch adds the NETLINK_NO_ENOBUFS socket flag. This flag can
    be used by unicast and broadcast listeners to avoid receiving
    ENOBUFS errors.
    
    Generally speaking, ENOBUFS errors are useful to notify two things
    to the listener:
    
    a) You may increase the receiver buffer size via setsockopt().
    b) You have lost messages, you may be out of sync.
    
    In some cases, ignoring ENOBUFS errors can be useful. For example:
    
    a) nfnetlink_queue: this subsystem does not have any sort of resync
    method and you can decide to ignore ENOBUFS once you have set a
    given buffer size.
    
    b) ctnetlink: you can use this together with the socket flag
    NETLINK_BROADCAST_SEND_ERROR to stop getting ENOBUFS errors as
    you do not need to resync (packets whose event are not delivered
    are drop to provide reliable logging and state-synchronization).
    
    Moreover, the use of NETLINK_NO_ENOBUFS also reduces a "go up, go down"
    effect in terms of performance which is due to the netlink congestion
    control when the listener cannot back off. The effect is the following:
    
    1) throughput rate goes up and netlink messages are inserted in the
    receiver buffer.
    2) Then, netlink buffer fills and overruns (set on nlk->state bit 0).
    3) While the listener empties the receiver buffer, netlink keeps
    dropping messages. Thus, throughput goes dramatically down.
    4) Then, once the listener has emptied the buffer (nlk->state
    bit 0 is set off), goto step 1.
    
    This effect is easy to trigger with netlink broadcast under heavy
    load, and it is more noticeable when using a big receiver buffer.
    You can find some results in [1] that show this problem.
    
    [1] http://1984.lsi.us.es/linux/netlink/
    
    This patch also includes the use of sk_drop to account the number of
    netlink messages drop due to overrun. This value is shown in
    /proc/net/netlink.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 1e6bf995435c..5ba398e90304 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -104,6 +104,7 @@ struct nlmsgerr
 #define NETLINK_DROP_MEMBERSHIP	2
 #define NETLINK_PKTINFO		3
 #define NETLINK_BROADCAST_ERROR	4
+#define NETLINK_NO_ENOBUFS	5
 
 struct nl_pktinfo
 {

commit be0c22a46cfb79ab2342bb28fde99afa94ef868e
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed Feb 18 01:40:43 2009 +0000

    netlink: add NETLINK_BROADCAST_ERROR socket option
    
    This patch adds NETLINK_BROADCAST_ERROR which is a netlink
    socket option that the listener can set to make netlink_broadcast()
    return errors in the delivery to the caller. This option is useful
    if the caller of netlink_broadcast() do something with the result
    of the message delivery, like in ctnetlink where it drops a network
    packet if the event delivery failed, this is used to enable reliable
    logging and state-synchronization. If this socket option is not set,
    netlink_broadcast() only reports ESRCH errors and silently ignore
    ENOBUFS errors, which is what most netlink_broadcast() callers
    should do.
    
    This socket option is based on a suggestion from Patrick McHardy.
    Patrick McHardy can exchange this patch for a beer from me ;).
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 51b09a1f46c3..1e6bf995435c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -103,6 +103,7 @@ struct nlmsgerr
 #define NETLINK_ADD_MEMBERSHIP	1
 #define NETLINK_DROP_MEMBERSHIP	2
 #define NETLINK_PKTINFO		3
+#define NETLINK_BROADCAST_ERROR	4
 
 struct nl_pktinfo
 {

commit 0c19b0adb8dd33dbd10ff48e41971231c486855c
Author: Patrick McHardy <kaber@trash.net>
Date:   Thu Nov 20 04:08:29 2008 -0800

    netlink: avoid memset of 0 bytes sparse warning
    
    A netlink attribute padding of zero triggers this sparse warning:
    
    include/linux/netlink.h:245:8: warning: memset with byte count of 0
    
    Avoid the memset when the size parameter is constant and requires no padding.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 9ff1b54908f3..51b09a1f46c3 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -242,7 +242,8 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 	nlh->nlmsg_flags = flags;
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
-	memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
+	if (!__builtin_constant_p(size) || NLMSG_ALIGN(size) - size != 0)
+		memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
 	return nlh;
 }
 

commit 9457afee85e0dfc2b5075a391d6f34463b4c2b90
Author: Denis V. Lunev <den@openvz.org>
Date:   Thu Jun 5 11:23:39 2008 -0700

    netlink: Remove nonblock parameter from netlink_attachskb
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index bec1062a25a1..9ff1b54908f3 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -193,7 +193,7 @@ extern int netlink_unregister_notifier(struct notifier_block *nb);
 
 /* finegrained unicast helpers: */
 struct sock *netlink_getsockbyfilp(struct file *filp);
-int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock,
+int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
 		      long *timeo, struct sock *ssk);
 void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
 int netlink_sendskb(struct sock *sk, struct sk_buff *skb);

commit 2532386f480eefbdd67b48be55fb4fb3e5a6081c
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Apr 18 10:09:25 2008 -0400

    Audit: collect sessionid in netlink messages
    
    Previously I added sessionid output to all audit messages where it was
    available but we still didn't know the sessionid of the sender of
    netlink messages.  This patch adds that information to netlink messages
    so we can audit who sent netlink messages.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index fb0713b6ffaf..bec1062a25a1 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -166,6 +166,7 @@ struct netlink_skb_parms
 	__u32			dst_group;
 	kernel_cap_t		eff_cap;
 	__u32			loginuid;	/* Login (audit) uid */
+	__u32			sessionid;	/* Session id (audit) */
 	__u32			sid;		/* SELinux security id */
 };
 

commit 71d67e666e73e3b7e9ef124745ee2e454ac04be8
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Thu Jan 31 16:45:47 2008 -0800

    [IPV4] fib_trie: rescan if key is lost during dump
    
    Normally during a dump the key of the last dumped entry is used for
    continuation, but since lock is dropped it might be lost. In that case
    fallback to the old counter based N^2 behaviour.  This means the dump
    will end up skipping some routes which matches what FIB_HASH does.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index bd13b6f4a98e..fb0713b6ffaf 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -219,7 +219,7 @@ struct netlink_callback
 	int		(*dump)(struct sk_buff * skb, struct netlink_callback *cb);
 	int		(*done)(struct netlink_callback *cb);
 	int		family;
-	long		args[5];
+	long		args[6];
 };
 
 struct netlink_notify

commit b7c6ba6eb1234e35a74fb8ba8123232a7b1ba9e4
Author: Denis V. Lunev <den@openvz.org>
Date:   Mon Jan 28 14:41:19 2008 -0800

    [NETNS]: Consolidate kernel netlink socket destruction.
    
    Create a specific helper for netlink kernel socket disposal. This just
    let the code look better and provides a ground for proper disposal
    inside a namespace.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Tested-by: Alexey Dobriyan <adobriyan@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2aee0f510876..bd13b6f4a98e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -178,6 +178,7 @@ extern struct sock *netlink_kernel_create(struct net *net,
 					  void (*input)(struct sk_buff *skb),
 					  struct mutex *cb_mutex,
 					  struct module *module);
+extern void netlink_kernel_release(struct sock *sk);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);

commit f4d900a2cae94256f56be7769734100c7054bf00
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Dec 5 03:31:53 2007 -0800

    [NETLINK]: Mark attribute construction exception unlikely
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index d5bfaba595c7..2aee0f510876 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -245,7 +245,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 }
 
 #define NLMSG_NEW(skb, pid, seq, type, len, flags) \
-({	if (skb_tailroom(skb) < (int)NLMSG_SPACE(len)) \
+({	if (unlikely(skb_tailroom(skb) < (int)NLMSG_SPACE(len))) \
 		goto nlmsg_failure; \
 	__nlmsg_put(skb, pid, seq, type, len, flags); })
 

commit c3d8d1e30cace31fed6186a4b8c6b1401836d89c
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Nov 7 02:42:09 2007 -0800

    [NETLINK]: Fix unicast timeouts
    
    Commit ed6dcf4a in the history.git tree broke netlink_unicast timeouts
    by moving the schedule_timeout() call to a new function that doesn't
    propagate the remaining timeout back to the caller. This means on each
    retry we start with the full timeout again.
    
    ipc/mqueue.c seems to actually want to wait indefinitely so this
    behaviour is retained.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 7c1f3b1d2ee5..d5bfaba595c7 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -192,7 +192,7 @@ extern int netlink_unregister_notifier(struct notifier_block *nb);
 /* finegrained unicast helpers: */
 struct sock *netlink_getsockbyfilp(struct file *filp);
 int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock,
-		long timeo, struct sock *ssk);
+		      long *timeo, struct sock *ssk);
 void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
 int netlink_sendskb(struct sock *sk, struct sk_buff *skb);
 

commit cd40b7d3983c708aabe3d3008ec64ffce56d33b0
Author: Denis V. Lunev <den@openvz.org>
Date:   Wed Oct 10 21:15:29 2007 -0700

    [NET]: make netlink user -> kernel interface synchronious
    
    This patch make processing netlink user -> kernel messages synchronious.
    This change was inspired by the talk with Alexey Kuznetsov about current
    netlink messages processing. He says that he was badly wrong when introduced
    asynchronious user -> kernel communication.
    
    The call netlink_unicast is the only path to send message to the kernel
    netlink socket. But, unfortunately, it is also used to send data to the
    user.
    
    Before this change the user message has been attached to the socket queue
    and sk->sk_data_ready was called. The process has been blocked until all
    pending messages were processed. The bad thing is that this processing
    may occur in the arbitrary process context.
    
    This patch changes nlk->data_ready callback to get 1 skb and force packet
    processing right in the netlink_unicast.
    
    Kernel -> user path in netlink_unicast remains untouched.
    
    EINTR processing for in netlink_run_queue was changed. It forces rtnl_lock
    drop, but the process remains in the cycle until the message will be fully
    processed. So, there is no need to use this kludges now.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Acked-by: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 7b552b6c2c19..7c1f3b1d2ee5 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -175,7 +175,7 @@ struct netlink_skb_parms
 
 extern struct sock *netlink_kernel_create(struct net *net,
 					  int unit,unsigned int groups,
-					  void (*input)(struct sock *sk, int len),
+					  void (*input)(struct sk_buff *skb),
 					  struct mutex *cb_mutex,
 					  struct module *module);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);

commit 7ee015e0fa3c856416e9477aac4b850ec6f09017
Author: Denis V. Lunev <den@openvz.org>
Date:   Wed Oct 10 21:14:03 2007 -0700

    [NET]: cleanup 3rd argument in netlink_sendskb
    
    netlink_sendskb does not use third argument. Clean it and save a couple of
    bytes.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Acked-by: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index e638256ce472..7b552b6c2c19 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -194,7 +194,7 @@ struct sock *netlink_getsockbyfilp(struct file *filp);
 int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock,
 		long timeo, struct sock *ssk);
 void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
-int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol);
+int netlink_sendskb(struct sock *sk, struct sk_buff *skb);
 
 /*
  *	skb should fit one page. This choice is good for headerless malloc.

commit 8f4c1f9b049df3be11090f1c2c4738700302acae
Author: Thomas Graf <tgraf@suug.ch>
Date:   Wed Sep 12 14:44:36 2007 +0200

    [NETLINK]: Introduce nested and byteorder flag to netlink attribute
    
    This change allows the generic attribute interface to be used within
    the netfilter subsystem where this flag was initially introduced.
    
    The byte-order flag is yet unused, it's intended use is to
    allow automatic byte order convertions for all atomic types.
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index d2843ae4a83a..e638256ce472 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -131,6 +131,20 @@ struct nlattr
 	__u16           nla_type;
 };
 
+/*
+ * nla_type (16 bits)
+ * +---+---+-------------------------------+
+ * | N | O | Attribute Type                |
+ * +---+---+-------------------------------+
+ * N := Carries nested attributes
+ * O := Payload stored in network byte order
+ *
+ * Note: The N and O flag are mutually exclusive.
+ */
+#define NLA_F_NESTED		(1 << 15)
+#define NLA_F_NET_BYTEORDER	(1 << 14)
+#define NLA_TYPE_MASK		~(NLA_F_NESTED | NLA_F_NET_BYTEORDER)
+
 #define NLA_ALIGNTO		4
 #define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
 #define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))

commit b4b510290b056b86611757ce1175a230f1080f53
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Sep 12 13:05:38 2007 +0200

    [NET]: Support multiple network namespaces with netlink
    
    Each netlink socket will live in exactly one network namespace,
    this includes the controlling kernel sockets.
    
    This patch updates all of the existing netlink protocols
    to only support the initial network namespace.  Request
    by clients in other namespaces will get -ECONREFUSED.
    As they would if the kernel did not have the support for
    that netlink protocol compiled in.
    
    As each netlink protocol is updated to be multiple network
    namespace safe it can register multiple kernel sockets
    to acquire a presence in the rest of the network namespaces.
    
    The implementation in af_netlink is a simple filter implementation
    at hash table insertion and hash table look up time.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 83d8239f0cce..d2843ae4a83a 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -27,6 +27,8 @@
 
 #define MAX_LINKS 32		
 
+struct net;
+
 struct sockaddr_nl
 {
 	sa_family_t	nl_family;	/* AF_NETLINK	*/
@@ -157,7 +159,8 @@ struct netlink_skb_parms
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
-extern struct sock *netlink_kernel_create(int unit, unsigned int groups,
+extern struct sock *netlink_kernel_create(struct net *net,
+					  int unit,unsigned int groups,
 					  void (*input)(struct sock *sk, int len),
 					  struct mutex *cb_mutex,
 					  struct module *module);
@@ -206,6 +209,7 @@ struct netlink_callback
 
 struct netlink_notify
 {
+	struct net *net;
 	int pid;
 	int protocol;
 };

commit 84659eb529b33572bb3f8c94e0978bd5d084bc7e
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 18 15:47:05 2007 -0700

    [NETLIKN]: Allow removing multicast groups.
    
    Allow kicking listeners out of a multicast group when necessary
    (for example if that group is going to be removed.)
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Acked-by: Jamal Hadi Salim <hadi@cyberus.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index b971ddd24090..83d8239f0cce 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -162,6 +162,7 @@ extern struct sock *netlink_kernel_create(int unit, unsigned int groups,
 					  struct mutex *cb_mutex,
 					  struct module *module);
 extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
+extern void netlink_clear_multicast_users(struct sock *sk, unsigned int group);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);

commit b4ff4f0419ae5db83553fab79d03a89c10d540a8
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Jul 18 15:46:06 2007 -0700

    [NETLINK]: allocate group bitmaps dynamically
    
    Allow changing the number of groups for a netlink family
    after it has been created, use RCU to protect the listeners
    bitmap keeping netlink_has_listeners() lock-free.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Patrick McHardy <kaber@trash.net>
    Acked-by: Jamal Hadi Salim <hadi@cyberus.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2e23353c28a5..b971ddd24090 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -161,6 +161,7 @@ extern struct sock *netlink_kernel_create(int unit, unsigned int groups,
 					  void (*input)(struct sock *sk, int len),
 					  struct mutex *cb_mutex,
 					  struct module *module);
+extern int netlink_change_ngroups(struct sock *sk, unsigned int groups);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);

commit cf130cb102487723bdfc53e4abde1227a7563797
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat May 5 11:42:03 2007 -0700

    [NETLINK]: Remove references to process ID
    
    People treating the *_pid fields in netlink as a process ID has caused
    endless confusion over the years.  The fact that our own netlink.h
    does this only adds to the confusion.
    
    So here is a patch to change the comments to refer to it as the port
    ID which hopefully will make it clear what the purpose of the fields
    really is.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f41688f56632..2e23353c28a5 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -31,7 +31,7 @@ struct sockaddr_nl
 {
 	sa_family_t	nl_family;	/* AF_NETLINK	*/
 	unsigned short	nl_pad;		/* zero		*/
-	__u32		nl_pid;		/* process pid	*/
+	__u32		nl_pid;		/* port ID	*/
        	__u32		nl_groups;	/* multicast groups mask */
 };
 
@@ -41,7 +41,7 @@ struct nlmsghdr
 	__u16		nlmsg_type;	/* Message content */
 	__u16		nlmsg_flags;	/* Additional flags */
 	__u32		nlmsg_seq;	/* Sequence number */
-	__u32		nlmsg_pid;	/* Sending process PID */
+	__u32		nlmsg_pid;	/* Sending process port ID */
 };
 
 /* Flags values */

commit af65bdfce98d7965fbe93a48b8128444a2eea024
Author: Patrick McHardy <kaber@trash.net>
Date:   Fri Apr 20 14:14:21 2007 -0700

    [NETLINK]: Switch cb_lock spinlock to mutex and allow to override it
    
    Switch cb_lock to mutex and allow netlink kernel users to override it
    with a subsystem specific mutex for consistent locking in dump callbacks.
    All netlink_dump_start users have been audited not to rely on any
    side-effects of the previously used spinlock.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 0d11f6a7389c..f41688f56632 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -157,7 +157,10 @@ struct netlink_skb_parms
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
-extern struct sock *netlink_kernel_create(int unit, unsigned int groups, void (*input)(struct sock *sk, int len), struct module *module);
+extern struct sock *netlink_kernel_create(int unit, unsigned int groups,
+					  void (*input)(struct sock *sk, int len),
+					  struct mutex *cb_mutex,
+					  struct module *module);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);

commit a36ca733375860b389c15ffdf6a5f92df64a33b6
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 19 22:28:08 2007 -0300

    [NETLINK]: Remove NLMSG_{NEW_ANSWER,CANCEL,END}
    
    Not used anywhere and defined inside __KERNEL__, Thomas acked this on irc.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 36629fff26d3..0d11f6a7389c 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -229,18 +229,6 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 #define NLMSG_PUT(skb, pid, seq, type, len) \
 	NLMSG_NEW(skb, pid, seq, type, len, 0)
 
-#define NLMSG_NEW_ANSWER(skb, cb, type, len, flags) \
-	NLMSG_NEW(skb, NETLINK_CB((cb)->skb).pid, \
-		  (cb)->nlh->nlmsg_seq, type, len, flags)
-
-#define NLMSG_END(skb, nlh) \
-({	(nlh)->nlmsg_len = skb_tail_pointer(skb) - (unsigned char *)(nlh); \
-	(skb)->len; })
-
-#define NLMSG_CANCEL(skb, nlh) \
-({	skb_trim(skb, (unsigned char *) (nlh) - (skb)->data); \
-	-1; })
-
 extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 			      struct nlmsghdr *nlh,
 			      int (*dump)(struct sk_buff *skb, struct netlink_callback*),

commit b529ccf2799c14346d1518e9bdf1f88f03643e99
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 25 19:08:35 2007 -0700

    [NETLINK]: Introduce nlmsg_hdr() helper
    
    For the common "(struct nlmsghdr *)skb->data" sequence, so that we reduce the
    number of direct accesses to skb->data and for consistency with all the other
    cast skb member helpers.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 68a632b372ec..36629fff26d3 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -138,6 +138,11 @@ struct nlattr
 #include <linux/capability.h>
 #include <linux/skbuff.h>
 
+static inline struct nlmsghdr *nlmsg_hdr(const struct sk_buff *skb)
+{
+	return (struct nlmsghdr *)skb->data;
+}
+
 struct netlink_skb_parms
 {
 	struct ucred		creds;		/* Skb credentials	*/

commit 27a884dc3cb63b93c2b3b643f5b31eed5f8a4d26
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 19 20:29:13 2007 -0700

    [SK_BUFF]: Convert skb->tail to sk_buff_data_t
    
    So that it is also an offset from skb->head, reduces its size from 8 to 4 bytes
    on 64bit architectures, allowing us to combine the 4 bytes hole left by the
    layer headers conversion, reducing struct sk_buff size to 256 bytes, i.e. 4
    64byte cachelines, and since the sk_buff slab cache is SLAB_HWCACHE_ALIGN...
    :-)
    
    Many calculations that previously required that skb->{transport,network,
    mac}_header be first converted to a pointer now can be done directly, being
    meaningful as offsets or pointers.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index a9d3ad5bc80f..68a632b372ec 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -229,7 +229,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 		  (cb)->nlh->nlmsg_seq, type, len, flags)
 
 #define NLMSG_END(skb, nlh) \
-({	(nlh)->nlmsg_len = (skb)->tail - (unsigned char *) (nlh); \
+({	(nlh)->nlmsg_len = skb_tail_pointer(skb) - (unsigned char *)(nlh); \
 	(skb)->len; })
 
 #define NLMSG_CANCEL(skb, nlh) \

commit fc910a27839584209726537698b596576940add4
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Mar 25 20:27:59 2007 -0700

    [NETLINK]: Limit NLMSG_GOODSIZE to 8K.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2a20f488ac1b..a9d3ad5bc80f 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -171,9 +171,16 @@ int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol);
 
 /*
  *	skb should fit one page. This choice is good for headerless malloc.
+ *	But we should limit to 8K so that userspace does not have to
+ *	use enormous buffer sizes on recvmsg() calls just to avoid
+ *	MSG_TRUNC when PAGE_SIZE is very large.
  */
-#define NLMSG_GOODORDER 0
-#define NLMSG_GOODSIZE (SKB_MAX_ORDER(0, NLMSG_GOODORDER))
+#if PAGE_SIZE < 8192UL
+#define NLMSG_GOODSIZE	SKB_WITH_OVERHEAD(PAGE_SIZE)
+#else
+#define NLMSG_GOODSIZE	SKB_WITH_OVERHEAD(8192UL)
+#endif
+
 #define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)
 
 

commit 88b4a07e6610f4c93b08b0bb103318218db1e9f6
Author: Michael Halcrow <mhalcrow@us.ibm.com>
Date:   Mon Feb 12 00:53:43 2007 -0800

    [PATCH] eCryptfs: Public key transport mechanism
    
    This is the transport code for public key functionality in eCryptfs.  It
    manages encryption/decryption request queues with a transport mechanism.
    Currently, netlink is the only implemented transport.
    
    Each inode has a unique File Encryption Key (FEK).  Under passphrase, a File
    Encryption Key Encryption Key (FEKEK) is generated from a salt/passphrase
    combo on mount.  This FEKEK encrypts each FEK and writes it into the header of
    each file using the packet format specified in RFC 2440.  This is all
    symmetric key encryption, so it can all be done via the kernel crypto API.
    
    These new patches introduce public key encryption of the FEK.  There is no
    asymmetric key encryption support in the kernel crypto API, so eCryptfs pushes
    the FEK encryption and decryption out to a userspace daemon.  After
    considering our requirements and determining the complexity of using various
    transport mechanisms, we settled on netlink for this communication.
    
    eCryptfs stores authentication tokens into the kernel keyring.  These tokens
    correlate with individual keys.  For passphrase mode of operation, the
    authentication token contains the symmetric FEKEK.  For public key, the
    authentication token contains a PKI type and an opaque data blob managed by
    individual PKI modules in userspace.
    
    Each user who opens a file under an eCryptfs partition mounted in public key
    mode must be running a daemon.  That daemon has the user's credentials and has
    access to all of the keys to which the user should have access.  The daemon,
    when started, initializes the pluggable PKI modules available on the system
    and registers itself with the eCryptfs kernel module.  Userspace utilities
    register public key authentication tokens into the user session keyring.
    These authentication tokens correlate key signatures with PKI modules and PKI
    blobs.  The PKI blobs contain PKI-specific information necessary for the PKI
    module to carry out asymmetric key encryption and decryption.
    
    When the eCryptfs module parses the header of an existing file and finds a Tag
    1 (Public Key) packet (see RFC 2440), it reads in the public key identifier
    (signature).  The asymmetrically encrypted FEK is in the Tag 1 packet;
    eCryptfs puts together a decrypt request packet containing the signature and
    the encrypted FEK, then it passes it to the daemon registered for the
    current->euid via a netlink unicast to the PID of the daemon, which was
    registered at the time the daemon was started by the user.
    
    The daemon actually just makes calls to libecryptfs, which implements request
    packet parsing and manages PKI modules.  libecryptfs grabs the public key
    authentication token for the given signature from the user session keyring.
    This auth tok tells libecryptfs which PKI module should receive the request.
    libecryptfs then makes a decrypt() call to the PKI module, and it passes along
    the PKI block from the auth tok.  The PKI uses the blob to figure out how it
    should decrypt the data passed to it; it performs the decryption and passes
    the decrypted data back to libecryptfs.  libecryptfs then puts together a
    reply packet with the decrypted FEK and passes that back to the eCryptfs
    module.
    
    The eCryptfs module manages these request callouts to userspace code via
    message context structs.  The module maintains an array of message context
    structs and places the elements of the array on two lists: a free and an
    allocated list.  When eCryptfs wants to make a request, it moves a msg ctx
    from the free list to the allocated list, sets its state to pending, and fires
    off the message to the user's registered daemon.
    
    When eCryptfs receives a netlink message (via the callback), it correlates the
    msg ctx struct in the alloc list with the data in the message itself.  The
    msg->index contains the offset of the array of msg ctx structs.  It verifies
    that the registered daemon PID is the same as the PID of the process that sent
    the message.  It also validates a sequence number between the received packet
    and the msg ctx.  Then, it copies the contents of the message (the reply
    packet) into the msg ctx struct, sets the state in the msg ctx to done, and
    wakes up the process that was sleeping while waiting for the reply.
    
    The sleeping process was whatever was performing the sys_open().  This process
    originally called ecryptfs_send_message(); it is now in
    ecryptfs_wait_for_response().  When it wakes up and sees that the msg ctx
    state was set to done, it returns a pointer to the message contents (the reply
    packet) and returns.  If all went well, this packet contains the decrypted
    FEK, which is then copied into the crypt_stat struct, and life continues as
    normal.
    
    The case for creation of a new file is very similar, only instead of a decrypt
    request, eCryptfs sends out an encrypt request.
    
    > - We have a great clod of key mangement code in-kernel.  Why is that
    >   not suitable (or growable) for public key management?
    
    eCryptfs uses Howells' keyring to store persistent key data and PKI state
    information.  It defers public key cryptographic transformations to userspace
    code.  The userspace data manipulation request really is orthogonal to key
    management in and of itself.  What eCryptfs basically needs is a secure way to
    communicate with a particular daemon for a particular task doing a syscall,
    based on the UID.  Nothing running under another UID should be able to access
    that channel of communication.
    
    > - Is it appropriate that new infrastructure for public key
    > management be private to a particular fs?
    
    The messaging.c file contains a lot of code that, perhaps, could be extracted
    into a separate kernel service.  In essence, this would be a sort of
    request/reply mechanism that would involve a userspace daemon.  I am not aware
    of anything that does quite what eCryptfs does, so I was not aware of any
    existing tools to do just what we wanted.
    
    >   What happens if one of these daemons exits without sending a quit
    >   message?
    
    There is a stale uid<->pid association in the hash table for that user.  When
    the user registers a new daemon, eCryptfs cleans up the old association and
    generates a new one.  See ecryptfs_process_helo().
    
    > - _why_ does it use netlink?
    
    Netlink provides the transport mechanism that would minimize the complexity of
    the implementation, given that we can have multiple daemons (one per user).  I
    explored the possibility of using relayfs, but that would involve having to
    introduce control channels and a protocol for creating and tearing down
    channels for the daemons.  We do not have to worry about any of that with
    netlink.
    
    Signed-off-by: Michael Halcrow <mhalcrow@us.ibm.com>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index b3b9b609ee89..2a20f488ac1b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -23,6 +23,7 @@
 #define NETLINK_GENERIC		16
 /* leave room for NETLINK_DM (DM Events) */
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
+#define NETLINK_ECRYPTFS	19
 
 #define MAX_LINKS 32		
 

commit 4e9b82693542003b028c8494e9e3c49615b91ce7
Author: Thomas Graf <tgraf@suug.ch>
Date:   Mon Nov 27 09:25:58 2006 -0800

    [NETLINK]: Remove unused dst_pid field in netlink_skb_parms
    
    The destination PID is passed directly to netlink_unicast()
    respectively netlink_multicast().
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index e61e1e138421..b3b9b609ee89 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -141,7 +141,6 @@ struct netlink_skb_parms
 {
 	struct ucred		creds;		/* Skb credentials	*/
 	__u32			pid;
-	__u32			dst_pid;
 	__u32			dst_group;
 	kernel_cap_t		eff_cap;
 	__u32			loginuid;	/* Login (audit) uid */

commit 339bf98ffc6a8d8eb16fc532ac57ffbced2f8a68
Author: Thomas Graf <tgraf@suug.ch>
Date:   Fri Nov 10 14:10:15 2006 -0800

    [NETLINK]: Do precise netlink message allocations where possible
    
    Account for the netlink message header size directly in nlmsg_new()
    instead of relying on the caller calculate it correctly.
    
    Replaces error handling of message construction functions when
    constructing notifications with bug traps since a failure implies
    a bug in calculating the size of the skb.
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Acked-by: Paul Moore <paul.moore@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 66411622e06e..e61e1e138421 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -174,6 +174,7 @@ int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol);
  */
 #define NLMSG_GOODORDER 0
 #define NLMSG_GOODSIZE (SKB_MAX_ORDER(0, NLMSG_GOODORDER))
+#define NLMSG_DEFAULT_SIZE (NLMSG_GOODSIZE - NLMSG_HDRLEN)
 
 
 struct netlink_callback

commit 84314fd4740ad73550c76dee4a9578979d84af48
Author: James Smart <James.Smart@Emulex.Com>
Date:   Fri Aug 18 17:30:09 2006 -0400

    [SCSI] SCSI and FC Transport: add netlink support for posting of transport events
    
    This patch formally adds support for the posting of FC events via netlink.
    It is a followup to the original RFC at:
      http://marc.theaimsgroup.com/?l=linux-scsi&m=114530667923464&w=2
    and the initial posting at:
      http://marc.theaimsgroup.com/?l=linux-scsi&m=115507374832500&w=2
    
    The patch has been updated to optimize the send path, per the discussions
    in the initial posting.
    
    Per discussions at the Storage Summit and at OLS, we are to use netlink for
    async events from transports. Also per discussions, to avoid a netlink
    protocol per transport, I've create a single NETLINK_SCSITRANSPORT protocol,
    which can then be used by all transports.
    
    This patch:
    - Creates new files scsi_netlink.c and scsi_netlink.h, which contains the
      single and shared definitions for the SCSI Transport. It is tied into the
      base SCSI subsystem intialization.
      Contains a single interface routine, scsi_send_transport_event(), for a
      transport to send an event (via multicast to a protocol specific group).
    - Creates a new scsi_netlink_fc.h file, which contains the FC netlink event
      messages
    - Adds 3 new routines to the fc transport:
       fc_get_event_number() -  to get a FC event #
       fc_host_post_event()  -  to send a simple FC event (32 bits of data)
       fc_host_post_vendor_event() - to send a Vendor unique event, with
                                     arbitrary amounts of data.
    
       Note: the separation of event number allows for a LLD to send a standard
         event, followed by vendor-specific data for the event.
    
    Note: This patch assumes 2 prior fc transport patches have been installed:
       http://marc.theaimsgroup.com/?l=linux-scsi&m=115555807316329&w=2
       http://marc.theaimsgroup.com/?l=linux-scsi&m=115581614930261&w=2
    
       Sorry - next time I'll do something like making these individual
       patches of the same posting when I know they'll be posted closely
       together.
    
    Signed-off-by: James Smart <James.Smart@emulex.com>
    
    Tidy up configuration not to make SCSI always select NET
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 855b44668caa..66411622e06e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -21,6 +21,8 @@
 #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
 #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
 #define NETLINK_GENERIC		16
+/* leave room for NETLINK_DM (DM Events) */
+#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 
 #define MAX_LINKS 32		
 

commit bb5427b5466782ba0bbf56a4ed752e08b65a5d08
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Thu Mar 23 19:11:58 2006 +0300

    [PATCH] w1: netlink: Mark netlink group 1 as unused.
    
    netlink_w1 was moved to connector.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 87b8a5703ebc..855b44668caa 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -5,7 +5,7 @@
 #include <linux/types.h>
 
 #define NETLINK_ROUTE		0	/* Routing/device hook				*/
-#define NETLINK_W1		1	/* 1-wire subsystem				*/
+#define NETLINK_UNUSED		1	/* Unused number				*/
 #define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
 #define NETLINK_FIREWALL	3	/* Firewalling hook				*/
 #define NETLINK_INET_DIAG	4	/* INET socket monitoring			*/

commit e7c3497013a7e5496ce3d5fd3c73b5cf5af7a56e
Author: Steve Grubb <sgrubb@redhat.com>
Date:   Mon Apr 3 09:08:13 2006 -0400

    [PATCH] Reworked patch for labels on user space messages
    
    The below patch should be applied after the inode and ipc sid patches.
    This patch is a reworking of Tim's patch that has been updated to match
    the inode and ipc patches since its similar.
    
    [updated:
    >  Stephen Smalley also wanted to change a variable from isec to tsec in the
    >  user sid patch.                                                              ]
    
    Signed-off-by: Steve Grubb <sgrubb@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f8f3d1c927f8..87b8a5703ebc 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -143,6 +143,7 @@ struct netlink_skb_parms
 	__u32			dst_group;
 	kernel_cap_t		eff_cap;
 	__u32			loginuid;	/* Login (audit) uid */
+	__u32			sid;		/* SELinux security id */
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit 4277a083ecd2c8771058641132bcecea04ca6608
Author: Patrick McHardy <kaber@trash.net>
Date:   Mon Mar 20 18:52:01 2006 -0800

    [NETLINK]: Add netlink_has_listeners for avoiding unneccessary event message generation
    
    Keep a bitmask of multicast groups with subscribed listeners to let
    netlink users check for listeners before generating multicast
    messages.
    
    Queries don't perform any locking, which may result in false
    positives, it is guaranteed however that any new subscriptions are
    visible before bind() or setsockopt() return.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    ACKed-by: Jamal Hadi Salim<hadi@cyberus.ca>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index c256ebe2a7b4..f8f3d1c927f8 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -151,6 +151,7 @@ struct netlink_skb_parms
 
 extern struct sock *netlink_kernel_create(int unit, unsigned int groups, void (*input)(struct sock *sk, int len), struct module *module);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
+extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
 			     __u32 group, gfp_t allocation);

commit a70ea994a0d83fd0151a070be72b87d014ef0a7e
Author: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
Date:   Thu Feb 9 16:40:11 2006 -0800

    [NETLINK]: Fix a severe bug
    
    netlink overrun was broken while improvement of netlink.
    Destination socket is used in the place where it was meant to be source socket,
    so that now overrun is never sent to user netlink sockets, when it should be,
    and it even can be set on kernel socket, which results in complete deadlock
    of rtnetlink.
    
    Suggested fix is to restore status quo passing source socket as additional
    argument to netlink_attachskb().
    
    A little explanation: overrun is set on a socket, when it failed
    to receive some message and sender of this messages does not or even
    have no way to handle this error. This happens in two cases:
    1. when kernel sends something. Kernel never retransmits and cannot
       wait for buffer space.
    2. when user sends a broadcast and the message was not delivered
       to some recipients.
    
    Signed-off-by: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6a2ccf78a356..c256ebe2a7b4 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -160,7 +160,8 @@ extern int netlink_unregister_notifier(struct notifier_block *nb);
 
 /* finegrained unicast helpers: */
 struct sock *netlink_getsockbyfilp(struct file *filp);
-int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock, long timeo);
+int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock,
+		long timeo, struct sock *ssk);
 void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
 int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol);
 

commit bfa83a9e03cf8d501c6272999843470afecb32ed
Author: Thomas Graf <tgraf@suug.ch>
Date:   Thu Nov 10 02:25:51 2005 +0100

    [NETLINK]: Type-safe netlink messages/attributes interface
    
    Introduces a new type-safe interface for netlink message and
    attributes handling. The interface is fully binary compatible
    with the old interface towards userspace. Besides type safety,
    this interface features attribute validation capabilities,
    simplified message contstruction, and documentation.
    
    The resulting netlink code should be smaller, less error prone
    and easier to understand.
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index ba25ca874c20..6a2ccf78a356 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -71,7 +71,8 @@ struct nlmsghdr
 
 #define NLMSG_ALIGNTO	4
 #define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
-#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_HDRLEN	 ((int) NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(NLMSG_HDRLEN))
 #define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
 #define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
 #define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
@@ -86,6 +87,8 @@ struct nlmsghdr
 #define NLMSG_DONE		0x3	/* End of a dump	*/
 #define NLMSG_OVERRUN		0x4	/* Data lost		*/
 
+#define NLMSG_MIN_TYPE		0x10	/* < 0x10: reserved control messages */
+
 struct nlmsgerr
 {
 	int		error;
@@ -108,6 +111,25 @@ enum {
 	NETLINK_CONNECTED,
 };
 
+/*
+ *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ * |        Header       | Pad |     Payload       | Pad |
+ * |   (struct nlattr)   | ing |                   | ing |
+ * +---------------------+- - -+- - - - - - - - - -+- - -+
+ *  <-------------- nlattr->nla_len -------------->
+ */
+
+struct nlattr
+{
+	__u16           nla_len;
+	__u16           nla_type;
+};
+
+#define NLA_ALIGNTO		4
+#define NLA_ALIGN(len)		(((len) + NLA_ALIGNTO - 1) & ~(NLA_ALIGNTO - 1))
+#define NLA_HDRLEN		((int) NLA_ALIGN(sizeof(struct nlattr)))
+
 #ifdef __KERNEL__
 
 #include <linux/capability.h>

commit dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Oct 7 07:46:04 2005 +0100

    [PATCH] gfp flags annotations - part 1
    
     - added typedef unsigned int __nocast gfp_t;
    
     - replaced __nocast uses for gfp flags with gfp_t - it gives exactly
       the same warnings as far as sparse is concerned, doesn't change
       generated code (from gcc point of view we replaced unsigned int with
       typedef) and documents what's going on far better.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index bdebdc564506..ba25ca874c20 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -131,7 +131,7 @@ extern struct sock *netlink_kernel_create(int unit, unsigned int groups, void (*
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
-			     __u32 group, unsigned int __nocast allocation);
+			     __u32 group, gfp_t allocation);
 extern void netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
 extern int netlink_register_notifier(struct notifier_block *nb);
 extern int netlink_unregister_notifier(struct notifier_block *nb);

commit 20ae975dfd54de581287b2ca8a1ad97099ab0396
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Wed Sep 14 20:52:37 2005 -0700

    [NETLINK]: Reserve a slot for NETLINK_GENERIC.
    
    As requested by Jamal.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 7bbd25970c9e..bdebdc564506 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -20,6 +20,7 @@
 #define NETLINK_IP6_FW		13
 #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
 #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_GENERIC		16
 
 #define MAX_LINKS 32		
 

commit 7672d0b54411371e0b6a831c1cb2f0ce615de6dc
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Sun Sep 11 19:15:07 2005 -0700

    [NET]: Add netlink connector.
    
    Kernel connector - new userspace <-> kernel space easy to use
    communication module which implements easy to use bidirectional
    message bus using netlink as it's backend.  Connector was created to
    eliminate complex skb handling both in send and receive message bus
    direction.
    
    Connector driver adds possibility to connect various agents using as
    one of it's backends netlink based network.  One must register
    callback and identifier. When driver receives special netlink message
    with appropriate identifier, appropriate callback will be called.
    
    From the userspace point of view it's quite straightforward:
    
            socket();
            bind();
            send();
            recv();
    
    But if kernelspace want to use full power of such connections, driver
    writer must create special sockets, must know about struct sk_buff
    handling...  Connector allows any kernelspace agents to use netlink
    based networking for inter-process communication in a significantly
    easier way:
    
    int cn_add_callback(struct cb_id *id, char *name, void (*callback) (void *));
    void cn_netlink_send(struct cn_msg *msg, u32 __groups, int gfp_mask);
    
    struct cb_id
    {
            __u32                   idx;
            __u32                   val;
    };
    
    idx and val are unique identifiers which must be registered in
    connector.h for in-kernel usage.  void (*callback) (void *) - is a
    callback function which will be called when message with above idx.val
    will be received by connector core.
    
    Using connector completely hides low-level transport layer from it's
    users.
    
    Connector uses new netlink ability to have many groups in one socket.
    
    [ Incorporating many cleanups and fixes by myself and
      Andrew Morton -DaveM ]
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 167518668936..7bbd25970c9e 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -15,6 +15,7 @@
 #define NETLINK_ISCSI		8	/* Open-iSCSI */
 #define NETLINK_AUDIT		9	/* auditing */
 #define NETLINK_FIB_LOOKUP	10	
+#define NETLINK_CONNECTOR	11
 #define NETLINK_NETFILTER	12	/* netfilter subsystem */
 #define NETLINK_IP6_FW		13
 #define NETLINK_DNRTMSG		14	/* DECnet routing messages */

commit 6ed8a48582c08432e84e5610564c1d25fe00dd7f
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 16 19:02:15 2005 -0300

    [NETLINK]: Fix sparse warnings
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 7d1d9683b246..167518668936 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -129,7 +129,7 @@ extern struct sock *netlink_kernel_create(int unit, unsigned int groups, void (*
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
-			     __u32 group, int allocation);
+			     __u32 group, unsigned int __nocast allocation);
 extern void netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
 extern int netlink_register_notifier(struct notifier_block *nb);
 extern int netlink_unregister_notifier(struct notifier_block *nb);

commit 066286071d3542243baa68166acb779187c848b3
Author: Patrick McHardy <kaber@trash.net>
Date:   Mon Aug 15 12:33:26 2005 -0700

    [NETLINK]: Add "groups" argument to netlink_kernel_create
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 36a40449f9f1..7d1d9683b246 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -125,7 +125,7 @@ struct netlink_skb_parms
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
-extern struct sock *netlink_kernel_create(int unit, void (*input)(struct sock *sk, int len), struct module *module);
+extern struct sock *netlink_kernel_create(int unit, unsigned int groups, void (*input)(struct sock *sk, int len), struct module *module);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,

commit 9a4595bc7e67962f13232ee55a64e063062c3a99
Author: Patrick McHardy <kaber@trash.net>
Date:   Mon Aug 15 12:32:15 2005 -0700

    [NETLINK]: Add set/getsockopt options to support more than 32 groups
    
    NETLINK_ADD_MEMBERSHIP/NETLINK_DROP_MEMBERSHIP are used to join/leave
    groups, NETLINK_PKTINFO is used to enable nl_pktinfo control messages
    for received packets to get the extended destination group number.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index c724c9d4984a..36a40449f9f1 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -90,6 +90,15 @@ struct nlmsgerr
 	struct nlmsghdr msg;
 };
 
+#define NETLINK_ADD_MEMBERSHIP	1
+#define NETLINK_DROP_MEMBERSHIP	2
+#define NETLINK_PKTINFO		3
+
+struct nl_pktinfo
+{
+	__u32	group;
+};
+
 #define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
 
 enum {

commit d629b836d151d43332492651dd841d32e57ebe3b
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 14 19:27:50 2005 -0700

    [NETLINK]: Use group numbers instead of bitmasks internally
    
    Using the group number allows increasing the number of groups without
    beeing limited by the size of the bitmask. It introduces one limitation
    for netlink users: messages can't be broadcasted to multiple groups anymore,
    however this feature was never used inside the kernel.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index eab51f9c9c86..c724c9d4984a 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -107,7 +107,7 @@ struct netlink_skb_parms
 	struct ucred		creds;		/* Skb credentials	*/
 	__u32			pid;
 	__u32			dst_pid;
-	__u32			dst_groups;
+	__u32			dst_group;
 	kernel_cap_t		eff_cap;
 	__u32			loginuid;	/* Login (audit) uid */
 };

commit db080529798b497eb5a37b92a25e966be5a7dd5d
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 14 19:26:34 2005 -0700

    [NETLINK]: Remove unused groups member from struct netlink_skb_parms
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index d5e09bcd80f9..eab51f9c9c86 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -106,7 +106,6 @@ struct netlink_skb_parms
 {
 	struct ucred		creds;		/* Skb credentials	*/
 	__u32			pid;
-	__u32			groups;
 	__u32			dst_pid;
 	__u32			dst_groups;
 	kernel_cap_t		eff_cap;

commit 73c1f4a033675f168df7e98bbeeafca3c644b8a6
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Aug 12 12:51:49 2005 -0300

    [TCPDIAG]: Just rename everything to inet_diag
    
    Next changeset will rename tcp_diag.[ch] to inet_diag.[ch].
    
    I'm taking this longer route so as to easy review, making clear the changes
    made all along the way.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 1c50fea8995b..d5e09bcd80f9 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -8,7 +8,7 @@
 #define NETLINK_W1		1	/* 1-wire subsystem				*/
 #define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
 #define NETLINK_FIREWALL	3	/* Firewalling hook				*/
-#define NETLINK_TCPDIAG		4	/* TCP socket monitoring			*/
+#define NETLINK_INET_DIAG	4	/* INET socket monitoring			*/
 #define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
 #define NETLINK_XFRM		6	/* ipsec */
 #define NETLINK_SELINUX		7	/* SELinux event notifications */

commit 4fdb3bb723db469717c6d38fda667d8b0fa86ebd
Author: Harald Welte <laforge@netfilter.org>
Date:   Tue Aug 9 19:40:55 2005 -0700

    [NETLINK]: Add properly module refcounting for kernel netlink sockets.
    
    - Remove bogus code for compiling netlink as module
    - Add module refcounting support for modules implementing a netlink
      protocol
    - Add support for autoloading modules that implement a netlink protocol
      as soon as someone opens a socket for that protocol
    
    Signed-off-by: Harald Welte <laforge@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 6552b71bfa73..1c50fea8995b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -117,7 +117,7 @@ struct netlink_skb_parms
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
 
 
-extern struct sock *netlink_kernel_create(int unit, void (*input)(struct sock *sk, int len));
+extern struct sock *netlink_kernel_create(int unit, void (*input)(struct sock *sk, int len), struct module *module);
 extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
 extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,

commit 4d479e40e1748a877a24015fc6727b27b77110cd
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Aug 8 13:48:02 2005 -0700

    [NETLINK]: Allocate and kill some netlink numbers.
    
    NETLINK_ARPD is unused, allocate it to the Open-iSCSI folks.
    
    NETLINK_ROUTE6 and NETLINK_TAPBASE are no longer used, delete
    them.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 70c2a9dc4b2b..6552b71bfa73 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -12,15 +12,13 @@
 #define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
 #define NETLINK_XFRM		6	/* ipsec */
 #define NETLINK_SELINUX		7	/* SELinux event notifications */
-#define NETLINK_ARPD		8
+#define NETLINK_ISCSI		8	/* Open-iSCSI */
 #define NETLINK_AUDIT		9	/* auditing */
 #define NETLINK_FIB_LOOKUP	10	
-#define NETLINK_ROUTE6		11	/* af_inet6 route comm channel */
 #define NETLINK_NETFILTER	12	/* netfilter subsystem */
 #define NETLINK_IP6_FW		13
 #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
 #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
-#define NETLINK_TAPBASE		16	/* 16 to 31 are ethertap */
 
 #define MAX_LINKS 32		
 

commit 48647feed9f7a2d839c6ada12147b341833646e8
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jul 24 19:30:28 2005 -0700

    [W1]: Do not use NFLOG netlink number.
    
    Use the reserved by never used NETLINK_SKIP value instead.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 2f0c085f2c7d..70c2a9dc4b2b 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -5,7 +5,7 @@
 #include <linux/types.h>
 
 #define NETLINK_ROUTE		0	/* Routing/device hook				*/
-#define NETLINK_SKIP		1	/* Reserved for ENskip  			*/
+#define NETLINK_W1		1	/* 1-wire subsystem				*/
 #define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
 #define NETLINK_FIREWALL	3	/* Firewalling hook				*/
 #define NETLINK_TCPDIAG		4	/* TCP socket monitoring			*/

commit 63522f7fdb624adef20cb9d90c7effcd5b6301b2
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jul 11 14:29:11 2005 -0700

    [NETLINK]: Reserve NETLINK_NETFILTER.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 27e4d164a108..2f0c085f2c7d 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -16,6 +16,7 @@
 #define NETLINK_AUDIT		9	/* auditing */
 #define NETLINK_FIB_LOOKUP	10	
 #define NETLINK_ROUTE6		11	/* af_inet6 route comm channel */
+#define NETLINK_NETFILTER	12	/* netfilter subsystem */
 #define NETLINK_IP6_FW		13
 #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
 #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */

commit b3563c4fbff906991a1b4ef4609f99cca2a0de6a
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 28 12:54:43 2005 -0700

    [NETLINK]: Clear padding in netlink messages
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 3029cad63a01..27e4d164a108 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -168,6 +168,7 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 	nlh->nlmsg_flags = flags;
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
+	memset(NLMSG_DATA(nlh) + len, 0, NLMSG_ALIGN(size) - size);
 	return nlh;
 }
 

commit 18b504e25fd617bee8830d2cdcaff7fb7b5931bb
Author: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
Date:   Tue Jun 21 12:38:48 2005 -0700

    [NETLINK]: netlink_callback structure needs 5 args not 4
    
    net/ipv4/tcp_diag.c uses up to ->args[4]
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 561d4dc75836..3029cad63a01 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -147,7 +147,7 @@ struct netlink_callback
 	int		(*dump)(struct sk_buff * skb, struct netlink_callback *cb);
 	int		(*done)(struct netlink_callback *cb);
 	int		family;
-	long		args[4];
+	long		args[5];
 };
 
 struct netlink_notify

commit 246955fe4c38bd706ae30e37c64892c94213775d
Author: Robert Olsson <Robert.Olsson@data.slu.se>
Date:   Mon Jun 20 13:36:39 2005 -0700

    [NETLINK]: fib_lookup() via netlink
    
    Below is a more generic patch to do fib_lookup via netlink. For others
    we should say that we discussed this as a way to verify route selection.
    It's also possible there are others uses for this.
    
    In short the fist half of struct fib_result_nl is filled in by caller
    and netlink call fills in the other half and returns it.
    
    In case anyone is interested there is a corresponding user app to compare
    the full routing table this was used to test implementation of the LC-trie.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index e38407a23d04..561d4dc75836 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -14,6 +14,7 @@
 #define NETLINK_SELINUX		7	/* SELinux event notifications */
 #define NETLINK_ARPD		8
 #define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_FIB_LOOKUP	10	
 #define NETLINK_ROUTE6		11	/* af_inet6 route comm channel */
 #define NETLINK_IP6_FW		13
 #define NETLINK_DNRTMSG		14	/* DECnet routing messages */

commit 1797754ea7ee5e0d859b0a32506ff999f8d5fb71
Author: Thomas Graf <tgraf@suug.ch>
Date:   Sat Jun 18 22:53:48 2005 -0700

    [NETLINK]: Introduce NLMSG_NEW macro to better handle netlink flags
    
    Introduces a new macro NLMSG_NEW which extends NLMSG_PUT but takes
    a flags argument. NLMSG_PUT stays there for compatibility but now
    calls NLMSG_NEW with flags == 0. NLMSG_PUT_ANSWER is renamed to
    NLMSG_NEW_ANSWER which now also takes a flags argument.
    
    Also converts the users of NLMSG_PUT_ANSWER to use NLMSG_NEW_ANSWER
    and fixes the two direct users of __nlmsg_put to either provide
    the flags or use NLMSG_NEW(_ANSWER).
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index 8d1cb419a930..e38407a23d04 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -156,7 +156,7 @@ struct netlink_notify
 };
 
 static __inline__ struct nlmsghdr *
-__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len)
+__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
 {
 	struct nlmsghdr *nlh;
 	int size = NLMSG_LENGTH(len);
@@ -164,20 +164,23 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len)
 	nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));
 	nlh->nlmsg_type = type;
 	nlh->nlmsg_len = size;
-	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_flags = flags;
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_seq = seq;
 	return nlh;
 }
 
-#define NLMSG_PUT(skb, pid, seq, type, len) \
+#define NLMSG_NEW(skb, pid, seq, type, len, flags) \
 ({	if (skb_tailroom(skb) < (int)NLMSG_SPACE(len)) \
 		goto nlmsg_failure; \
-	__nlmsg_put(skb, pid, seq, type, len); })
+	__nlmsg_put(skb, pid, seq, type, len, flags); })
+
+#define NLMSG_PUT(skb, pid, seq, type, len) \
+	NLMSG_NEW(skb, pid, seq, type, len, 0)
 
-#define NLMSG_PUT_ANSWER(skb, cb, type, len) \
-	NLMSG_PUT(skb, NETLINK_CB((cb)->skb).pid, \
-		  (cb)->nlh->nlmsg_seq, type, len)
+#define NLMSG_NEW_ANSWER(skb, cb, type, len, flags) \
+	NLMSG_NEW(skb, NETLINK_CB((cb)->skb).pid, \
+		  (cb)->nlh->nlmsg_seq, type, len, flags)
 
 #define NLMSG_END(skb, nlh) \
 ({	(nlh)->nlmsg_len = (skb)->tail - (unsigned char *) (nlh); \

commit f88a10d65620d97b6d0a7e352a3493c1b7e7409b
Author: Thomas Graf <tgraf@suug.ch>
Date:   Sat Jun 18 22:50:12 2005 -0700

    [NETLINK]: New message building macros
    
     NLMSG_PUT_ANSWER(skb, nlcb, type, length)
       Start a new netlink message as answer to a request,
       returns the message header.
    
     NLMSG_END(skb, nlh)
       End a netlink message, fixes total message length,
       returns skb->len.
    
     NLMSG_CANCEL(skb, nlh)
       Cancel the building process and trim whole message
       from skb again, returns -1.
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index b2738ac8bc99..8d1cb419a930 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -171,8 +171,21 @@ __nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len)
 }
 
 #define NLMSG_PUT(skb, pid, seq, type, len) \
-({ if (skb_tailroom(skb) < (int)NLMSG_SPACE(len)) goto nlmsg_failure; \
-   __nlmsg_put(skb, pid, seq, type, len); })
+({	if (skb_tailroom(skb) < (int)NLMSG_SPACE(len)) \
+		goto nlmsg_failure; \
+	__nlmsg_put(skb, pid, seq, type, len); })
+
+#define NLMSG_PUT_ANSWER(skb, cb, type, len) \
+	NLMSG_PUT(skb, NETLINK_CB((cb)->skb).pid, \
+		  (cb)->nlh->nlmsg_seq, type, len)
+
+#define NLMSG_END(skb, nlh) \
+({	(nlh)->nlmsg_len = (skb)->tail - (unsigned char *) (nlh); \
+	(skb)->len; })
+
+#define NLMSG_CANCEL(skb, nlh) \
+({	skb_trim(skb, (unsigned char *) (nlh) - (skb)->data); \
+	-1; })
 
 extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
 			      struct nlmsghdr *nlh,

commit c94c257c88c517f251da273a15c654224c7b6e21
Author: Serge Hallyn <serue@us.ibm.com>
Date:   Fri Apr 29 16:27:17 2005 +0100

    Add audit uid to netlink credentials
    
    Most audit control messages are sent over netlink.In order to properly
    log the identity of the sender of audit control messages, we would like
    to add the loginuid to the netlink_creds structure, as per the attached
    patch.
    
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
index f731abdc1a29..b2738ac8bc99 100644
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@ -110,6 +110,7 @@ struct netlink_skb_parms
 	__u32			dst_pid;
 	__u32			dst_groups;
 	kernel_cap_t		eff_cap;
+	__u32			loginuid;	/* Login (audit) uid */
 };
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/netlink.h b/include/linux/netlink.h
new file mode 100644
index 000000000000..f731abdc1a29
--- /dev/null
+++ b/include/linux/netlink.h
@@ -0,0 +1,188 @@
+#ifndef __LINUX_NETLINK_H
+#define __LINUX_NETLINK_H
+
+#include <linux/socket.h> /* for sa_family_t */
+#include <linux/types.h>
+
+#define NETLINK_ROUTE		0	/* Routing/device hook				*/
+#define NETLINK_SKIP		1	/* Reserved for ENskip  			*/
+#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
+#define NETLINK_FIREWALL	3	/* Firewalling hook				*/
+#define NETLINK_TCPDIAG		4	/* TCP socket monitoring			*/
+#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
+#define NETLINK_XFRM		6	/* ipsec */
+#define NETLINK_SELINUX		7	/* SELinux event notifications */
+#define NETLINK_ARPD		8
+#define NETLINK_AUDIT		9	/* auditing */
+#define NETLINK_ROUTE6		11	/* af_inet6 route comm channel */
+#define NETLINK_IP6_FW		13
+#define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+#define NETLINK_TAPBASE		16	/* 16 to 31 are ethertap */
+
+#define MAX_LINKS 32		
+
+struct sockaddr_nl
+{
+	sa_family_t	nl_family;	/* AF_NETLINK	*/
+	unsigned short	nl_pad;		/* zero		*/
+	__u32		nl_pid;		/* process pid	*/
+       	__u32		nl_groups;	/* multicast groups mask */
+};
+
+struct nlmsghdr
+{
+	__u32		nlmsg_len;	/* Length of message including header */
+	__u16		nlmsg_type;	/* Message content */
+	__u16		nlmsg_flags;	/* Additional flags */
+	__u32		nlmsg_seq;	/* Sequence number */
+	__u32		nlmsg_pid;	/* Sending process PID */
+};
+
+/* Flags values */
+
+#define NLM_F_REQUEST		1	/* It is request message. 	*/
+#define NLM_F_MULTI		2	/* Multipart message, terminated by NLMSG_DONE */
+#define NLM_F_ACK		4	/* Reply with ack, with zero or error code */
+#define NLM_F_ECHO		8	/* Echo this request 		*/
+
+/* Modifiers to GET request */
+#define NLM_F_ROOT	0x100	/* specify tree	root	*/
+#define NLM_F_MATCH	0x200	/* return all matching	*/
+#define NLM_F_ATOMIC	0x400	/* atomic GET		*/
+#define NLM_F_DUMP	(NLM_F_ROOT|NLM_F_MATCH)
+
+/* Modifiers to NEW request */
+#define NLM_F_REPLACE	0x100	/* Override existing		*/
+#define NLM_F_EXCL	0x200	/* Do not touch, if it exists	*/
+#define NLM_F_CREATE	0x400	/* Create, if it does not exist	*/
+#define NLM_F_APPEND	0x800	/* Add to end of list		*/
+
+/*
+   4.4BSD ADD		NLM_F_CREATE|NLM_F_EXCL
+   4.4BSD CHANGE	NLM_F_REPLACE
+
+   True CHANGE		NLM_F_CREATE|NLM_F_REPLACE
+   Append		NLM_F_CREATE
+   Check		NLM_F_EXCL
+ */
+
+#define NLMSG_ALIGNTO	4
+#define NLMSG_ALIGN(len) ( ((len)+NLMSG_ALIGNTO-1) & ~(NLMSG_ALIGNTO-1) )
+#define NLMSG_LENGTH(len) ((len)+NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+#define NLMSG_SPACE(len) NLMSG_ALIGN(NLMSG_LENGTH(len))
+#define NLMSG_DATA(nlh)  ((void*)(((char*)nlh) + NLMSG_LENGTH(0)))
+#define NLMSG_NEXT(nlh,len)	 ((len) -= NLMSG_ALIGN((nlh)->nlmsg_len), \
+				  (struct nlmsghdr*)(((char*)(nlh)) + NLMSG_ALIGN((nlh)->nlmsg_len)))
+#define NLMSG_OK(nlh,len) ((len) >= (int)sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len >= sizeof(struct nlmsghdr) && \
+			   (nlh)->nlmsg_len <= (len))
+#define NLMSG_PAYLOAD(nlh,len) ((nlh)->nlmsg_len - NLMSG_SPACE((len)))
+
+#define NLMSG_NOOP		0x1	/* Nothing.		*/
+#define NLMSG_ERROR		0x2	/* Error		*/
+#define NLMSG_DONE		0x3	/* End of a dump	*/
+#define NLMSG_OVERRUN		0x4	/* Data lost		*/
+
+struct nlmsgerr
+{
+	int		error;
+	struct nlmsghdr msg;
+};
+
+#define NET_MAJOR 36		/* Major 36 is reserved for networking 						*/
+
+enum {
+	NETLINK_UNCONNECTED = 0,
+	NETLINK_CONNECTED,
+};
+
+#ifdef __KERNEL__
+
+#include <linux/capability.h>
+#include <linux/skbuff.h>
+
+struct netlink_skb_parms
+{
+	struct ucred		creds;		/* Skb credentials	*/
+	__u32			pid;
+	__u32			groups;
+	__u32			dst_pid;
+	__u32			dst_groups;
+	kernel_cap_t		eff_cap;
+};
+
+#define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))
+#define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
+
+
+extern struct sock *netlink_kernel_create(int unit, void (*input)(struct sock *sk, int len));
+extern void netlink_ack(struct sk_buff *in_skb, struct nlmsghdr *nlh, int err);
+extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 pid, int nonblock);
+extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 pid,
+			     __u32 group, int allocation);
+extern void netlink_set_err(struct sock *ssk, __u32 pid, __u32 group, int code);
+extern int netlink_register_notifier(struct notifier_block *nb);
+extern int netlink_unregister_notifier(struct notifier_block *nb);
+
+/* finegrained unicast helpers: */
+struct sock *netlink_getsockbyfilp(struct file *filp);
+int netlink_attachskb(struct sock *sk, struct sk_buff *skb, int nonblock, long timeo);
+void netlink_detachskb(struct sock *sk, struct sk_buff *skb);
+int netlink_sendskb(struct sock *sk, struct sk_buff *skb, int protocol);
+
+/*
+ *	skb should fit one page. This choice is good for headerless malloc.
+ */
+#define NLMSG_GOODORDER 0
+#define NLMSG_GOODSIZE (SKB_MAX_ORDER(0, NLMSG_GOODORDER))
+
+
+struct netlink_callback
+{
+	struct sk_buff	*skb;
+	struct nlmsghdr	*nlh;
+	int		(*dump)(struct sk_buff * skb, struct netlink_callback *cb);
+	int		(*done)(struct netlink_callback *cb);
+	int		family;
+	long		args[4];
+};
+
+struct netlink_notify
+{
+	int pid;
+	int protocol;
+};
+
+static __inline__ struct nlmsghdr *
+__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len)
+{
+	struct nlmsghdr *nlh;
+	int size = NLMSG_LENGTH(len);
+
+	nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));
+	nlh->nlmsg_type = type;
+	nlh->nlmsg_len = size;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = pid;
+	nlh->nlmsg_seq = seq;
+	return nlh;
+}
+
+#define NLMSG_PUT(skb, pid, seq, type, len) \
+({ if (skb_tailroom(skb) < (int)NLMSG_SPACE(len)) goto nlmsg_failure; \
+   __nlmsg_put(skb, pid, seq, type, len); })
+
+extern int netlink_dump_start(struct sock *ssk, struct sk_buff *skb,
+			      struct nlmsghdr *nlh,
+			      int (*dump)(struct sk_buff *skb, struct netlink_callback*),
+			      int (*done)(struct netlink_callback*));
+
+
+#define NL_NONROOT_RECV 0x1
+#define NL_NONROOT_SEND 0x2
+extern void netlink_set_nonroot(int protocol, unsigned flag);
+
+#endif /* __KERNEL__ */
+
+#endif	/* __LINUX_NETLINK_H */
