commit 8402a31dd803e091fd2ec9cd22040b34a0b07085
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 28 07:33:37 2020 -0600

    net: dccp: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 6b64b6cc2175..07e547c02fd8 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -198,7 +198,7 @@ enum dccp_role {
 
 struct dccp_service_list {
 	__u32	dccpsl_nr;
-	__be32	dccpsl_list[0];
+	__be32	dccpsl_list[];
 };
 
 #define DCCP_SERVICE_INVALID_VALUE htonl((__u32)-1)

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 68449293c4b6..6b64b6cc2175 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_DCCP_H
 #define _LINUX_DCCP_H
 

commit 62f8f4d9066c1c6f2474845d1ca7e2891f2ae3fd
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 5 10:52:16 2017 -0800

    dccp: fix use-after-free in dccp_feat_activate_values
    
    Dmitry reported crashes in DCCP stack [1]
    
    Problem here is that when I got rid of listener spinlock, I missed the
    fact that DCCP stores a complex state in struct dccp_request_sock,
    while TCP does not.
    
    Since multiple cpus could access it at the same time, we need to add
    protection.
    
    [1]
    BUG: KASAN: use-after-free in dccp_feat_activate_values+0x967/0xab0
    net/dccp/feat.c:1541 at addr ffff88003713be68
    Read of size 8 by task syz-executor2/8457
    CPU: 2 PID: 8457 Comm: syz-executor2 Not tainted 4.10.0-rc7+ #127
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Call Trace:
     <IRQ>
     __dump_stack lib/dump_stack.c:15 [inline]
     dump_stack+0x292/0x398 lib/dump_stack.c:51
     kasan_object_err+0x1c/0x70 mm/kasan/report.c:162
     print_address_description mm/kasan/report.c:200 [inline]
     kasan_report_error mm/kasan/report.c:289 [inline]
     kasan_report.part.1+0x20e/0x4e0 mm/kasan/report.c:311
     kasan_report mm/kasan/report.c:332 [inline]
     __asan_report_load8_noabort+0x29/0x30 mm/kasan/report.c:332
     dccp_feat_activate_values+0x967/0xab0 net/dccp/feat.c:1541
     dccp_create_openreq_child+0x464/0x610 net/dccp/minisocks.c:121
     dccp_v6_request_recv_sock+0x1f6/0x1960 net/dccp/ipv6.c:457
     dccp_check_req+0x335/0x5a0 net/dccp/minisocks.c:186
     dccp_v6_rcv+0x69e/0x1d00 net/dccp/ipv6.c:711
     ip6_input_finish+0x46d/0x17a0 net/ipv6/ip6_input.c:279
     NF_HOOK include/linux/netfilter.h:257 [inline]
     ip6_input+0xdb/0x590 net/ipv6/ip6_input.c:322
     dst_input include/net/dst.h:507 [inline]
     ip6_rcv_finish+0x289/0x890 net/ipv6/ip6_input.c:69
     NF_HOOK include/linux/netfilter.h:257 [inline]
     ipv6_rcv+0x12ec/0x23d0 net/ipv6/ip6_input.c:203
     __netif_receive_skb_core+0x1ae5/0x3400 net/core/dev.c:4190
     __netif_receive_skb+0x2a/0x170 net/core/dev.c:4228
     process_backlog+0xe5/0x6c0 net/core/dev.c:4839
     napi_poll net/core/dev.c:5202 [inline]
     net_rx_action+0xe70/0x1900 net/core/dev.c:5267
     __do_softirq+0x2fb/0xb7d kernel/softirq.c:284
     do_softirq_own_stack+0x1c/0x30 arch/x86/entry/entry_64.S:902
     </IRQ>
     do_softirq.part.17+0x1e8/0x230 kernel/softirq.c:328
     do_softirq kernel/softirq.c:176 [inline]
     __local_bh_enable_ip+0x1f2/0x200 kernel/softirq.c:181
     local_bh_enable include/linux/bottom_half.h:31 [inline]
     rcu_read_unlock_bh include/linux/rcupdate.h:971 [inline]
     ip6_finish_output2+0xbb0/0x23d0 net/ipv6/ip6_output.c:123
     ip6_finish_output+0x302/0x960 net/ipv6/ip6_output.c:148
     NF_HOOK_COND include/linux/netfilter.h:246 [inline]
     ip6_output+0x1cb/0x8d0 net/ipv6/ip6_output.c:162
     ip6_xmit+0xcdf/0x20d0 include/net/dst.h:501
     inet6_csk_xmit+0x320/0x5f0 net/ipv6/inet6_connection_sock.c:179
     dccp_transmit_skb+0xb09/0x1120 net/dccp/output.c:141
     dccp_xmit_packet+0x215/0x760 net/dccp/output.c:280
     dccp_write_xmit+0x168/0x1d0 net/dccp/output.c:362
     dccp_sendmsg+0x79c/0xb10 net/dccp/proto.c:796
     inet_sendmsg+0x164/0x5b0 net/ipv4/af_inet.c:744
     sock_sendmsg_nosec net/socket.c:635 [inline]
     sock_sendmsg+0xca/0x110 net/socket.c:645
     SYSC_sendto+0x660/0x810 net/socket.c:1687
     SyS_sendto+0x40/0x50 net/socket.c:1655
     entry_SYSCALL_64_fastpath+0x1f/0xc2
    RIP: 0033:0x4458b9
    RSP: 002b:00007f8ceb77bb58 EFLAGS: 00000282 ORIG_RAX: 000000000000002c
    RAX: ffffffffffffffda RBX: 0000000000000017 RCX: 00000000004458b9
    RDX: 0000000000000023 RSI: 0000000020e60000 RDI: 0000000000000017
    RBP: 00000000006e1b90 R08: 00000000200f9fe1 R09: 0000000000000020
    R10: 0000000000008010 R11: 0000000000000282 R12: 00000000007080a8
    R13: 0000000000000000 R14: 00007f8ceb77c9c0 R15: 00007f8ceb77c700
    Object at ffff88003713be50, in cache kmalloc-64 size: 64
    Allocated:
    PID = 8446
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:57
     save_stack+0x43/0xd0 mm/kasan/kasan.c:502
     set_track mm/kasan/kasan.c:514 [inline]
     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:605
     kmem_cache_alloc_trace+0x82/0x270 mm/slub.c:2738
     kmalloc include/linux/slab.h:490 [inline]
     dccp_feat_entry_new+0x214/0x410 net/dccp/feat.c:467
     dccp_feat_push_change+0x38/0x220 net/dccp/feat.c:487
     __feat_register_sp+0x223/0x2f0 net/dccp/feat.c:741
     dccp_feat_propagate_ccid+0x22b/0x2b0 net/dccp/feat.c:949
     dccp_feat_server_ccid_dependencies+0x1b3/0x250 net/dccp/feat.c:1012
     dccp_make_response+0x1f1/0xc90 net/dccp/output.c:423
     dccp_v6_send_response+0x4ec/0xc20 net/dccp/ipv6.c:217
     dccp_v6_conn_request+0xaba/0x11b0 net/dccp/ipv6.c:377
     dccp_rcv_state_process+0x51e/0x1650 net/dccp/input.c:606
     dccp_v6_do_rcv+0x213/0x350 net/dccp/ipv6.c:632
     sk_backlog_rcv include/net/sock.h:893 [inline]
     __sk_receive_skb+0x36f/0xcc0 net/core/sock.c:479
     dccp_v6_rcv+0xba5/0x1d00 net/dccp/ipv6.c:742
     ip6_input_finish+0x46d/0x17a0 net/ipv6/ip6_input.c:279
     NF_HOOK include/linux/netfilter.h:257 [inline]
     ip6_input+0xdb/0x590 net/ipv6/ip6_input.c:322
     dst_input include/net/dst.h:507 [inline]
     ip6_rcv_finish+0x289/0x890 net/ipv6/ip6_input.c:69
     NF_HOOK include/linux/netfilter.h:257 [inline]
     ipv6_rcv+0x12ec/0x23d0 net/ipv6/ip6_input.c:203
     __netif_receive_skb_core+0x1ae5/0x3400 net/core/dev.c:4190
     __netif_receive_skb+0x2a/0x170 net/core/dev.c:4228
     process_backlog+0xe5/0x6c0 net/core/dev.c:4839
     napi_poll net/core/dev.c:5202 [inline]
     net_rx_action+0xe70/0x1900 net/core/dev.c:5267
     __do_softirq+0x2fb/0xb7d kernel/softirq.c:284
    Freed:
    PID = 15
     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:57
     save_stack+0x43/0xd0 mm/kasan/kasan.c:502
     set_track mm/kasan/kasan.c:514 [inline]
     kasan_slab_free+0x73/0xc0 mm/kasan/kasan.c:578
     slab_free_hook mm/slub.c:1355 [inline]
     slab_free_freelist_hook mm/slub.c:1377 [inline]
     slab_free mm/slub.c:2954 [inline]
     kfree+0xe8/0x2b0 mm/slub.c:3874
     dccp_feat_entry_destructor.part.4+0x48/0x60 net/dccp/feat.c:418
     dccp_feat_entry_destructor net/dccp/feat.c:416 [inline]
     dccp_feat_list_pop net/dccp/feat.c:541 [inline]
     dccp_feat_activate_values+0x57f/0xab0 net/dccp/feat.c:1543
     dccp_create_openreq_child+0x464/0x610 net/dccp/minisocks.c:121
     dccp_v6_request_recv_sock+0x1f6/0x1960 net/dccp/ipv6.c:457
     dccp_check_req+0x335/0x5a0 net/dccp/minisocks.c:186
     dccp_v6_rcv+0x69e/0x1d00 net/dccp/ipv6.c:711
     ip6_input_finish+0x46d/0x17a0 net/ipv6/ip6_input.c:279
     NF_HOOK include/linux/netfilter.h:257 [inline]
     ip6_input+0xdb/0x590 net/ipv6/ip6_input.c:322
     dst_input include/net/dst.h:507 [inline]
     ip6_rcv_finish+0x289/0x890 net/ipv6/ip6_input.c:69
     NF_HOOK include/linux/netfilter.h:257 [inline]
     ipv6_rcv+0x12ec/0x23d0 net/ipv6/ip6_input.c:203
     __netif_receive_skb_core+0x1ae5/0x3400 net/core/dev.c:4190
     __netif_receive_skb+0x2a/0x170 net/core/dev.c:4228
     process_backlog+0xe5/0x6c0 net/core/dev.c:4839
     napi_poll net/core/dev.c:5202 [inline]
     net_rx_action+0xe70/0x1900 net/core/dev.c:5267
     __do_softirq+0x2fb/0xb7d kernel/softirq.c:284
    Memory state around the buggy address:
     ffff88003713bd00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
     ffff88003713bd80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    >ffff88003713be00: fc fc fc fc fc fc fc fc fc fc fb fb fb fb fb fb
                                                              ^
    
    Fixes: 079096f103fa ("tcp/dccp: install syn_recv requests into ehash table")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Tested-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 61d042bbbf60..68449293c4b6 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -163,6 +163,7 @@ struct dccp_request_sock {
 	__u64			 dreq_isr;
 	__u64			 dreq_gsr;
 	__be32			 dreq_service;
+	spinlock_t		 dreq_lock;
 	struct list_head	 dreq_featneg;
 	__u32			 dreq_timestamp_echo;
 	__u32			 dreq_timestamp_time;

commit 0c6119d99bf5df9403a688d267537284e9cc8bcb
Author: Yaowei Bai <bywxiaobai@163.com>
Date:   Thu Oct 8 21:28:58 2015 +0800

    net/dccp: dccp_list_has_service can be boolean
    
    This patch makes dccp_list_has_service return bool due to this
    particular function only using either one or zero as its return
    value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <bywxiaobai@163.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 221025423e6c..61d042bbbf60 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -202,16 +202,16 @@ struct dccp_service_list {
 #define DCCP_SERVICE_INVALID_VALUE htonl((__u32)-1)
 #define DCCP_SERVICE_CODE_IS_ABSENT		0
 
-static inline int dccp_list_has_service(const struct dccp_service_list *sl,
+static inline bool dccp_list_has_service(const struct dccp_service_list *sl,
 					const __be32 service)
 {
 	if (likely(sl != NULL)) {
 		u32 i = sl->dccpsl_nr;
 		while (i--)
 			if (sl->dccpsl_list[i] == service)
-				return 1;
+				return true;
 	}
-	return 0;
+	return false;
 }
 
 struct dccp_ackvec;

commit 85645bab57bfc6b0b43bb96a301c4ef83925c07d
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 22 10:22:24 2015 -0700

    ipv4: dccp: handle ICMP messages on DCCP_NEW_SYN_RECV request sockets
    
    dccp_v4_err() can restrict lookups to ehash table, and not to listeners.
    
    Note this patch creates the infrastructure, but this means that ICMP
    messages for request sockets are ignored until complete conversion.
    
    New dccp_req_err() helper is exported so that we can use it in IPv6
    in following patch.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 3dca24d3ac67..221025423e6c 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -43,6 +43,7 @@ enum dccp_state {
 	DCCP_CLOSING	     = TCP_CLOSING,
 	DCCP_TIME_WAIT	     = TCP_TIME_WAIT,
 	DCCP_CLOSED	     = TCP_CLOSE,
+	DCCP_NEW_SYN_RECV    = TCP_NEW_SYN_RECV,
 	DCCP_PARTOPEN	     = TCP_MAX_STATES,
 	DCCP_PASSIVE_CLOSEREQ,			/* clients receiving CloseReq */
 	DCCP_MAX_STATES
@@ -57,6 +58,7 @@ enum {
 	DCCPF_CLOSING	      = TCPF_CLOSING,
 	DCCPF_TIME_WAIT	      = TCPF_TIME_WAIT,
 	DCCPF_CLOSED	      = TCPF_CLOSE,
+	DCCPF_NEW_SYN_RECV    = TCPF_NEW_SYN_RECV,
 	DCCPF_PARTOPEN	      = (1 << DCCP_PARTOPEN),
 };
 

commit 42cb80a2353f42913ae78074ffa1f1b4a49e5436
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 22 10:22:19 2015 -0700

    inet: remove sk_listener parameter from syn_ack_timeout()
    
    It is not needed, and req->sk_listener points to the listener anyway.
    request_sock argument can be const.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 439ff698000a..3dca24d3ac67 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -317,6 +317,6 @@ static inline const char *dccp_role(const struct sock *sk)
 	return NULL;
 }
 
-extern void dccp_syn_ack_timeout(struct sock *sk, struct request_sock *req);
+extern void dccp_syn_ack_timeout(const struct request_sock *req);
 
 #endif /* _LINUX_DCCP_H */

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index d16294e2a118..439ff698000a 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -1,239 +1,6 @@
 #ifndef _LINUX_DCCP_H
 #define _LINUX_DCCP_H
 
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-/**
- * struct dccp_hdr - generic part of DCCP packet header
- *
- * @dccph_sport - Relevant port on the endpoint that sent this packet
- * @dccph_dport - Relevant port on the other endpoint
- * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
- * @dccph_ccval - Used by the HC-Sender CCID
- * @dccph_cscov - Parts of the packet that are covered by the Checksum field
- * @dccph_checksum - Internet checksum, depends on dccph_cscov
- * @dccph_x - 0 = 24 bit sequence number, 1 = 48
- * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
- * @dccph_seq - sequence number high or low order 24 bits, depends on dccph_x
- */
-struct dccp_hdr {
-	__be16	dccph_sport,
-		dccph_dport;
-	__u8	dccph_doff;
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8	dccph_cscov:4,
-		dccph_ccval:4;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	__u8	dccph_ccval:4,
-		dccph_cscov:4;
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
-	__sum16	dccph_checksum;
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8	dccph_x:1,
-		dccph_type:4,
-		dccph_reserved:3;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	__u8	dccph_reserved:3,
-		dccph_type:4,
-		dccph_x:1;
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
-	__u8	dccph_seq2;
-	__be16	dccph_seq;
-};
-
-/**
- * struct dccp_hdr_ext - the low bits of a 48 bit seq packet
- *
- * @dccph_seq_low - low 24 bits of a 48 bit seq packet
- */
-struct dccp_hdr_ext {
-	__be32	dccph_seq_low;
-};
-
-/**
- * struct dccp_hdr_request - Connection initiation request header
- *
- * @dccph_req_service - Service to which the client app wants to connect
- */
-struct dccp_hdr_request {
-	__be32	dccph_req_service;
-};
-/**
- * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
- *
- * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
- * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
- */
-struct dccp_hdr_ack_bits {
-	__be16	dccph_reserved1;
-	__be16	dccph_ack_nr_high;
-	__be32	dccph_ack_nr_low;
-};
-/**
- * struct dccp_hdr_response - Connection initiation response header
- *
- * @dccph_resp_ack - 48 bit Acknowledgment Number Subheader (5.3)
- * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
- */
-struct dccp_hdr_response {
-	struct dccp_hdr_ack_bits	dccph_resp_ack;
-	__be32				dccph_resp_service;
-};
-
-/**
- * struct dccp_hdr_reset - Unconditionally shut down a connection
- *
- * @dccph_reset_ack - 48 bit Acknowledgment Number Subheader (5.6)
- * @dccph_reset_code - one of %dccp_reset_codes
- * @dccph_reset_data - the Data 1 ... Data 3 fields from 5.6
- */
-struct dccp_hdr_reset {
-	struct dccp_hdr_ack_bits	dccph_reset_ack;
-	__u8				dccph_reset_code,
-					dccph_reset_data[3];
-};
-
-enum dccp_pkt_type {
-	DCCP_PKT_REQUEST = 0,
-	DCCP_PKT_RESPONSE,
-	DCCP_PKT_DATA,
-	DCCP_PKT_ACK,
-	DCCP_PKT_DATAACK,
-	DCCP_PKT_CLOSEREQ,
-	DCCP_PKT_CLOSE,
-	DCCP_PKT_RESET,
-	DCCP_PKT_SYNC,
-	DCCP_PKT_SYNCACK,
-	DCCP_PKT_INVALID,
-};
-
-#define DCCP_NR_PKT_TYPES DCCP_PKT_INVALID
-
-static inline unsigned int dccp_packet_hdr_len(const __u8 type)
-{
-	if (type == DCCP_PKT_DATA)
-		return 0;
-	if (type == DCCP_PKT_DATAACK	||
-	    type == DCCP_PKT_ACK	||
-	    type == DCCP_PKT_SYNC	||
-	    type == DCCP_PKT_SYNCACK	||
-	    type == DCCP_PKT_CLOSE	||
-	    type == DCCP_PKT_CLOSEREQ)
-		return sizeof(struct dccp_hdr_ack_bits);
-	if (type == DCCP_PKT_REQUEST)
-		return sizeof(struct dccp_hdr_request);
-	if (type == DCCP_PKT_RESPONSE)
-		return sizeof(struct dccp_hdr_response);
-	return sizeof(struct dccp_hdr_reset);
-}
-enum dccp_reset_codes {
-	DCCP_RESET_CODE_UNSPECIFIED = 0,
-	DCCP_RESET_CODE_CLOSED,
-	DCCP_RESET_CODE_ABORTED,
-	DCCP_RESET_CODE_NO_CONNECTION,
-	DCCP_RESET_CODE_PACKET_ERROR,
-	DCCP_RESET_CODE_OPTION_ERROR,
-	DCCP_RESET_CODE_MANDATORY_ERROR,
-	DCCP_RESET_CODE_CONNECTION_REFUSED,
-	DCCP_RESET_CODE_BAD_SERVICE_CODE,
-	DCCP_RESET_CODE_TOO_BUSY,
-	DCCP_RESET_CODE_BAD_INIT_COOKIE,
-	DCCP_RESET_CODE_AGGRESSION_PENALTY,
-
-	DCCP_MAX_RESET_CODES		/* Leave at the end!  */
-};
-
-/* DCCP options */
-enum {
-	DCCPO_PADDING = 0,
-	DCCPO_MANDATORY = 1,
-	DCCPO_MIN_RESERVED = 3,
-	DCCPO_MAX_RESERVED = 31,
-	DCCPO_CHANGE_L = 32,
-	DCCPO_CONFIRM_L = 33,
-	DCCPO_CHANGE_R = 34,
-	DCCPO_CONFIRM_R = 35,
-	DCCPO_NDP_COUNT = 37,
-	DCCPO_ACK_VECTOR_0 = 38,
-	DCCPO_ACK_VECTOR_1 = 39,
-	DCCPO_TIMESTAMP = 41,
-	DCCPO_TIMESTAMP_ECHO = 42,
-	DCCPO_ELAPSED_TIME = 43,
-	DCCPO_MAX = 45,
-	DCCPO_MIN_RX_CCID_SPECIFIC = 128,	/* from sender to receiver */
-	DCCPO_MAX_RX_CCID_SPECIFIC = 191,
-	DCCPO_MIN_TX_CCID_SPECIFIC = 192,	/* from receiver to sender */
-	DCCPO_MAX_TX_CCID_SPECIFIC = 255,
-};
-/* maximum size of a single TLV-encoded DCCP option (sans type/len bytes) */
-#define DCCP_SINGLE_OPT_MAXLEN	253
-
-/* DCCP CCIDS */
-enum {
-	DCCPC_CCID2 = 2,
-	DCCPC_CCID3 = 3,
-};
-
-/* DCCP features (RFC 4340 section 6.4) */
-enum dccp_feature_numbers {
-	DCCPF_RESERVED = 0,
-	DCCPF_CCID = 1,
-	DCCPF_SHORT_SEQNOS = 2,
-	DCCPF_SEQUENCE_WINDOW = 3,
-	DCCPF_ECN_INCAPABLE = 4,
-	DCCPF_ACK_RATIO = 5,
-	DCCPF_SEND_ACK_VECTOR = 6,
-	DCCPF_SEND_NDP_COUNT = 7,
-	DCCPF_MIN_CSUM_COVER = 8,
-	DCCPF_DATA_CHECKSUM = 9,
-	/* 10-127 reserved */
-	DCCPF_MIN_CCID_SPECIFIC = 128,
-	DCCPF_SEND_LEV_RATE = 192,	/* RFC 4342, sec. 8.4 */
-	DCCPF_MAX_CCID_SPECIFIC = 255,
-};
-
-/* DCCP socket control message types for cmsg */
-enum dccp_cmsg_type {
-	DCCP_SCM_PRIORITY = 1,
-	DCCP_SCM_QPOLICY_MAX = 0xFFFF,
-	/* ^-- Up to here reserved exclusively for qpolicy parameters */
-	DCCP_SCM_MAX
-};
-
-/* DCCP priorities for outgoing/queued packets */
-enum dccp_packet_dequeueing_policy {
-	DCCPQ_POLICY_SIMPLE,
-	DCCPQ_POLICY_PRIO,
-	DCCPQ_POLICY_MAX
-};
-
-/* DCCP socket options */
-#define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
-#define DCCP_SOCKOPT_SERVICE		2
-#define DCCP_SOCKOPT_CHANGE_L		3
-#define DCCP_SOCKOPT_CHANGE_R		4
-#define DCCP_SOCKOPT_GET_CUR_MPS	5
-#define DCCP_SOCKOPT_SERVER_TIMEWAIT	6
-#define DCCP_SOCKOPT_SEND_CSCOV		10
-#define DCCP_SOCKOPT_RECV_CSCOV		11
-#define DCCP_SOCKOPT_AVAILABLE_CCIDS	12
-#define DCCP_SOCKOPT_CCID		13
-#define DCCP_SOCKOPT_TX_CCID		14
-#define DCCP_SOCKOPT_RX_CCID		15
-#define DCCP_SOCKOPT_QPOLICY_ID		16
-#define DCCP_SOCKOPT_QPOLICY_TXQLEN	17
-#define DCCP_SOCKOPT_CCID_RX_INFO	128
-#define DCCP_SOCKOPT_CCID_TX_INFO	192
-
-/* maximum number of services provided on the same listening port */
-#define DCCP_SERVICE_LIST_MAX_LEN      32
-
-#ifdef __KERNEL__
 
 #include <linux/in.h>
 #include <linux/interrupt.h>
@@ -246,6 +13,7 @@ enum dccp_packet_dequeueing_policy {
 #include <net/inet_sock.h>
 #include <net/inet_timewait_sock.h>
 #include <net/tcp_states.h>
+#include <uapi/linux/dccp.h>
 
 enum dccp_state {
 	DCCP_OPEN	     = TCP_ESTABLISHED,
@@ -551,6 +319,4 @@ static inline const char *dccp_role(const struct sock *sk)
 
 extern void dccp_syn_ack_timeout(struct sock *sk, struct request_sock *req);
 
-#endif /* __KERNEL__ */
-
 #endif /* _LINUX_DCCP_H */

commit c72e118334a2590f4f07d9e51490b902c33f5280
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Apr 12 22:16:05 2012 +0000

    inet: makes syn_ack_timeout mandatory
    
    There are two struct request_sock_ops providers, tcp and dccp.
    
    inet_csk_reqsk_queue_prune() can avoid testing syn_ack_timeout being
    NULL if we make it non NULL like syn_ack_timeout
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Cc: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Cc: dccp@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index eaf95a023af4..d16294e2a118 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -549,6 +549,8 @@ static inline const char *dccp_role(const struct sock *sk)
 	return NULL;
 }
 
+extern void dccp_syn_ack_timeout(struct sock *sk, struct request_sock *req);
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_DCCP_H */

commit f541fb7e20c848f947ca65fbf169efe69400c942
Author: Samuel Jero <sj323707@ohio.edu>
Date:   Sun Feb 26 18:22:02 2012 -0700

    dccp: fix bug in sequence number validation during connection setup
    
    This fixes a bug in the sequence number validation during the initial handshake.
    
    The code did not treat the initial sequence numbers ISS and ISR as read-only and
    did not keep state for GSR and GSS as required by the specification. This causes
    problems with retransmissions during the initial handshake, causing the
    budding connection to be reset.
    
    This patch now treats ISS/ISR as read-only and tracks GSS/GSR as required.
    
    Signed-off-by: Samuel Jero <sj323707@ohio.edu>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 710c04302a15..eaf95a023af4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -376,8 +376,10 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 /**
  * struct dccp_request_sock  -  represent DCCP-specific connection request
  * @dreq_inet_rsk: structure inherited from
- * @dreq_iss: initial sequence number sent on the Response (RFC 4340, 7.1)
- * @dreq_isr: initial sequence number received on the Request
+ * @dreq_iss: initial sequence number, sent on the first Response (RFC 4340, 7.1)
+ * @dreq_gss: greatest sequence number sent (for retransmitted Responses)
+ * @dreq_isr: initial sequence number received in the first Request
+ * @dreq_gsr: greatest sequence number received (for retransmitted Request(s))
  * @dreq_service: service code present on the Request (there is just one)
  * @dreq_featneg: feature negotiation options for this connection
  * The following two fields are analogous to the ones in dccp_sock:
@@ -387,7 +389,9 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 struct dccp_request_sock {
 	struct inet_request_sock dreq_inet_rsk;
 	__u64			 dreq_iss;
+	__u64			 dreq_gss;
 	__u64			 dreq_isr;
+	__u64			 dreq_gsr;
 	__be32			 dreq_service;
 	struct list_head	 dreq_featneg;
 	__u32			 dreq_timestamp_echo;

commit a6b7a407865aab9f849dd99a71072b7cd1175116
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jun 6 10:43:46 2011 +0000

    net: remove interrupt.h inclusion from netdevice.h
    
    * remove interrupt.g inclusion from netdevice.h -- not needed
    * fixup fallout, add interrupt.h and hardirq.h back where needed.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index d638e85dc501..710c04302a15 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -236,6 +236,7 @@ enum dccp_packet_dequeueing_policy {
 #ifdef __KERNEL__
 
 #include <linux/in.h>
+#include <linux/interrupt.h>
 #include <linux/ktime.h>
 #include <linux/list.h>
 #include <linux/uio.h>

commit d18046b3cd989c06d2ad8d615e57c3cf63c63b67
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Wed Jan 19 23:12:54 2011 +0000

    dccp: clean up unused DCCP_STATE_MASK definition
    
    Remove unused DCCP_STATE_MASK macro.
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Acked-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 010e2d87ed75..d638e85dc501 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -279,8 +279,6 @@ enum dccp_state {
 	DCCP_MAX_STATES
 };
 
-#define DCCP_STATE_MASK 0x1f
-
 enum {
 	DCCPF_OPEN	      = TCPF_ESTABLISHED,
 	DCCPF_REQUESTING      = TCPF_SYN_SENT,

commit 871a2c16c21b988688b4ab1a78eadd969765c0a3
Author: Tomasz Grobelny <tomasz@grobelny.oswiecenia.net>
Date:   Sat Dec 4 13:38:01 2010 +0100

    dccp: Policy-based packet dequeueing infrastructure
    
    This patch adds a generic infrastructure for policy-based dequeueing of
    TX packets and provides two policies:
     * a simple FIFO policy (which is the default) and
     * a priority based policy (set via socket options).
    Both policies honour the tx_qlen sysctl for the maximum size of the write
    queue (can be overridden via socket options).
    
    The priority policy uses skb->priority internally to assign an u32 priority
    identifier, using the same ranking as SO_PRIORITY. The skb->priority field
    is set to 0 when the packet leaves DCCP. The priority is supplied as ancillary
    data using cmsg(3), the patch also provides the requisite parsing routines.
    
    Signed-off-by: Tomasz Grobelny <tomasz@grobelny.oswiecenia.net>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index eed52bcd35d0..010e2d87ed75 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -197,6 +197,21 @@ enum dccp_feature_numbers {
 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
+/* DCCP socket control message types for cmsg */
+enum dccp_cmsg_type {
+	DCCP_SCM_PRIORITY = 1,
+	DCCP_SCM_QPOLICY_MAX = 0xFFFF,
+	/* ^-- Up to here reserved exclusively for qpolicy parameters */
+	DCCP_SCM_MAX
+};
+
+/* DCCP priorities for outgoing/queued packets */
+enum dccp_packet_dequeueing_policy {
+	DCCPQ_POLICY_SIMPLE,
+	DCCPQ_POLICY_PRIO,
+	DCCPQ_POLICY_MAX
+};
+
 /* DCCP socket options */
 #define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
 #define DCCP_SOCKOPT_SERVICE		2
@@ -210,6 +225,8 @@ enum dccp_feature_numbers {
 #define DCCP_SOCKOPT_CCID		13
 #define DCCP_SOCKOPT_TX_CCID		14
 #define DCCP_SOCKOPT_RX_CCID		15
+#define DCCP_SOCKOPT_QPOLICY_ID		16
+#define DCCP_SOCKOPT_QPOLICY_TXQLEN	17
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
 #define DCCP_SOCKOPT_CCID_TX_INFO	192
 
@@ -458,6 +475,8 @@ struct dccp_ackvec;
  * @dccps_hc_rx_ccid - CCID used for the receiver (or receiving half-connection)
  * @dccps_hc_tx_ccid - CCID used for the sender (or sending half-connection)
  * @dccps_options_received - parsed set of retrieved options
+ * @dccps_qpolicy - TX dequeueing policy, one of %dccp_packet_dequeueing_policy
+ * @dccps_tx_qlen - maximum length of the TX queue
  * @dccps_role - role of this sock, one of %dccp_role
  * @dccps_hc_rx_insert_options - receiver wants to add options when acking
  * @dccps_hc_tx_insert_options - sender wants to add options when sending
@@ -500,6 +519,8 @@ struct dccp_sock {
 	struct ccid			*dccps_hc_rx_ccid;
 	struct ccid			*dccps_hc_tx_ccid;
 	struct dccp_options_received	dccps_options_received;
+	__u8				dccps_qpolicy;
+	__u32				dccps_tx_qlen;
 	enum dccp_role			dccps_role:2;
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;

commit d83447f0944e73d690218d79c07762ffa4ceb9e4
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 14 17:25:46 2010 +0100

    dccp ccid-2: Schedule Sync as out-of-band mechanism
    
    The problem with Ack Vectors is that
      i) their length is variable and can in principle grow quite large,
     ii) it is hard to predict exactly how large they will be.
    
    Due to the second point it seems not a good idea to reduce the MPS; in
    particular when on average there is enough room for the Ack Vector and an
    increase in length is momentarily due to some burst loss, after which the
    Ack Vector returns to its normal/average length.
    
    The solution taken by this patch is to subtract a minimum-expected Ack Vector
    length from the MPS, and to defer any larger Ack Vectors onto a separate
    Sync - but only if indeed there is no space left on the skb.
    
    This patch provides the infrastructure to schedule Sync-packets for transporting
    (urgent) out-of-band data. Its signalling is quicker than scheduling an Ack, since
    it does not need to wait for new application data.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 749f01ccd26e..eed52bcd35d0 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -462,6 +462,7 @@ struct dccp_ackvec;
  * @dccps_hc_rx_insert_options - receiver wants to add options when acking
  * @dccps_hc_tx_insert_options - sender wants to add options when sending
  * @dccps_server_timewait - server holds timewait state on close (RFC 4340, 8.3)
+ * @dccps_sync_scheduled - flag which signals "send out-of-band message soon"
  * @dccps_xmitlet - tasklet scheduled by the TX CCID to dequeue data packets
  * @dccps_xmit_timer - used by the TX CCID to delay sending (rate-based pacing)
  * @dccps_syn_rtt - RTT sample from Request/Response exchange (in usecs)
@@ -503,6 +504,7 @@ struct dccp_sock {
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;
 	__u8				dccps_server_timewait:1;
+	__u8				dccps_sync_scheduled:1;
 	struct tasklet_struct		dccps_xmitlet;
 	struct timer_list		dccps_xmit_timer;
 };

commit dc841e30eaea9f9f83c9ab1ee0b3ef9e5c95ce8a
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Oct 27 19:16:26 2010 +0000

    dccp: Extend CCID packet dequeueing interface
    
    This extends the packet dequeuing interface of dccp_write_xmit() to allow
     1. CCIDs to take care of timing when the next packet may be sent;
     2. delayed sending (as before, with an inter-packet gap up to 65.535 seconds).
    
    The main purpose is to take CCID-2 out of its polling mode (when it is network-
    limited, it tries every millisecond to send, without interruption).
    
    The mode of operation for (2) is as follows:
     * new packet is enqueued via dccp_sendmsg() => dccp_write_xmit(),
     * ccid_hc_tx_send_packet() detects that it may not send (e.g. window full),
     * it signals this condition via `CCID_PACKET_WILL_DEQUEUE_LATER',
     * dccp_write_xmit() returns without further action;
     * after some time the wait-condition for CCID becomes true,
     * that CCID schedules the tasklet,
     * tasklet function calls ccid_hc_tx_send_packet() via dccp_write_xmit(),
     * since the wait-condition is now true, ccid_hc_tx_packet() returns "send now",
     * packet is sent, and possibly more (since dccp_write_xmit() loops).
    
    Code reuse: the taskled function calls dccp_write_xmit(), the timer function
                reduces to a wrapper around the same code.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 7187bd8a75f6..749f01ccd26e 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -462,7 +462,8 @@ struct dccp_ackvec;
  * @dccps_hc_rx_insert_options - receiver wants to add options when acking
  * @dccps_hc_tx_insert_options - sender wants to add options when sending
  * @dccps_server_timewait - server holds timewait state on close (RFC 4340, 8.3)
- * @dccps_xmit_timer - timer for when CCID is not ready to send
+ * @dccps_xmitlet - tasklet scheduled by the TX CCID to dequeue data packets
+ * @dccps_xmit_timer - used by the TX CCID to delay sending (rate-based pacing)
  * @dccps_syn_rtt - RTT sample from Request/Response exchange (in usecs)
  */
 struct dccp_sock {
@@ -502,6 +503,7 @@ struct dccp_sock {
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;
 	__u8				dccps_server_timewait:1;
+	struct tasklet_struct		dccps_xmitlet;
 	struct timer_list		dccps_xmit_timer;
 };
 

commit a18213d1d2a469956845b437f5d1d0401ab22e8b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Sep 19 20:08:00 2010 +0200

    dccp: Replace magic CCID-specific numbers by symbolic constants
    
    The constants DCCPO_{MIN,MAX}_CCID_SPECIFIC are nowhere used in the code, but
    instead for the CCID-specific options numbers are used.
    
    This patch unifies the use of CCID-specific option numbers, by adding symbolic
    names reflecting the definitions in RFC 4340, 10.3.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 7434a8353e23..7187bd8a75f6 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -165,8 +165,10 @@ enum {
 	DCCPO_TIMESTAMP_ECHO = 42,
 	DCCPO_ELAPSED_TIME = 43,
 	DCCPO_MAX = 45,
-	DCCPO_MIN_CCID_SPECIFIC = 128,
-	DCCPO_MAX_CCID_SPECIFIC = 255,
+	DCCPO_MIN_RX_CCID_SPECIFIC = 128,	/* from sender to receiver */
+	DCCPO_MAX_RX_CCID_SPECIFIC = 191,
+	DCCPO_MIN_TX_CCID_SPECIFIC = 192,	/* from receiver to sender */
+	DCCPO_MAX_TX_CCID_SPECIFIC = 255,
 };
 /* maximum size of a single TLV-encoded DCCP option (sans type/len bytes) */
 #define DCCP_SINGLE_OPT_MAXLEN	253

commit 883ca833e5fb814fb03426c9d35e5489ce43e8da
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Jan 16 23:36:32 2009 +0000

    dccp: Initialisation and type-checking of feature sysctls
    
    This patch takes care of initialising and type-checking sysctls
    related to feature negotiation. Type checking is important since some
    of the sysctls now directly impact the feature-negotiation process.
    
    The sysctls are initialised with the known default values for each
    feature.  For the type-checking the value constraints from RFC 4340
    are used:
    
     * Sequence Window uses the specified Wmin=32, the maximum is ulong (4 bytes),
       tested and confirmed that it works up to 4294967295 - for Gbps speed;
     * Ack Ratio is between 0 .. 0xffff (2-byte unsigned integer);
     * CCIDs are between 0 .. 255;
     * request_retries, retries1, retries2 also between 0..255 for good measure;
     * tx_qlen is checked to be non-negative;
     * sync_ratelimit remains as before.
    
    Notes:
    ------
     1. Die s@sysctl_dccp_feat@sysctl_dccp@g since the sysctls are now in feat.c.
     2. As pointed out by Arnaldo, the pattern of type-checking repeats itself in
        other places, sometimes with exactly the same kind of definitions (e.g.
        "static int zero;"). It may be a good idea (kernel janitors?) to consolidate
        type checking. For the sake of keeping the changeset small and in order not
        to affect other subsystems, I have not strived to generalise here.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 7a0502ab383a..7434a8353e23 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -355,14 +355,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 	return __dccp_hdr_len(dccp_hdr(skb));
 }
 
-
-/* initial values for each feature */
-#define DCCPF_INITIAL_SEQUENCE_WINDOW		100
-#define DCCPF_INITIAL_ACK_RATIO			2
-#define DCCPF_INITIAL_CCID			DCCPC_CCID2
-/* FIXME: for now we're default to 1 but it should really be 0 */
-#define DCCPF_INITIAL_SEND_NDP_COUNT		1
-
 /**
  * struct dccp_request_sock  -  represent DCCP-specific connection request
  * @dreq_inet_rsk: structure inherited from

commit 792b48780e8b6435d017cef4b5c304876a48653e
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Jan 16 23:36:31 2009 +0000

    dccp: Implement both feature-local and feature-remote Sequence Window feature
    
    This adds full support for local/remote Sequence Window feature, from which the
      * sequence-number-validity (W) and
      * acknowledgment-number-validity (W') windows
    derive as specified in RFC 4340, 7.5.3.
    
    Specifically, the following is contained in this patch:
      * integrated new socket fields into dccp_sk;
      * updated the update_gsr/gss routines with regard to these fields;
      * updated handler code: the Sequence Window feature is located at the TX side,
        so the local feature is meant if the handler-rx flag is false;
      * the initialisation of `rcv_wnd' in reqsk is removed, since
        - rcv_wnd is not used by the code anywhere;
        - sequence number checks are not done in the LISTEN state (cf. 7.5.3);
        - dccp_check_req checks the Ack number validity more rigorously;
      * the `struct dccp_minisock' became empty and is now removed.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 990e97fa1f07..7a0502ab383a 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -363,19 +363,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
 
-/**
-  * struct dccp_minisock - Minimal DCCP connection representation
-  *
-  * Will be used to pass the state from dccp_request_sock to dccp_sock.
-  *
-  * @dccpms_sequence_window - Sequence Window Feature (section 7.5.2)
-  */
-struct dccp_minisock {
-	__u64			dccpms_sequence_window;
-};
-
-extern void dccp_minisock_init(struct dccp_minisock *dmsk);
-
 /**
  * struct dccp_request_sock  -  represent DCCP-specific connection request
  * @dreq_inet_rsk: structure inherited from
@@ -464,13 +451,14 @@ struct dccp_ackvec;
  * @dccps_timestamp_time - time of receiving latest @dccps_timestamp_echo
  * @dccps_l_ack_ratio - feature-local Ack Ratio
  * @dccps_r_ack_ratio - feature-remote Ack Ratio
+ * @dccps_l_seq_win - local Sequence Window (influences ack number validity)
+ * @dccps_r_seq_win - remote Sequence Window (influences seq number validity)
  * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
  * @dccps_pcrlen - receiver partial checksum coverage (via sockopt)
  * @dccps_send_ndp_count - local Send NDP Count feature (7.7.2)
  * @dccps_ndp_count - number of Non Data Packets since last data packet
  * @dccps_mss_cache - current value of MSS (path MTU minus header sizes)
  * @dccps_rate_last - timestamp for rate-limiting DCCP-Sync (RFC 4340, 7.5.4)
- * @dccps_minisock - associated minisock (accessed via dccp_msk)
  * @dccps_featneg - tracks feature-negotiation state (mostly during handshake)
  * @dccps_hc_rx_ackvec - rx half connection ack vector
  * @dccps_hc_rx_ccid - CCID used for the receiver (or receiving half-connection)
@@ -504,12 +492,13 @@ struct dccp_sock {
 	__u32				dccps_timestamp_time;
 	__u16				dccps_l_ack_ratio;
 	__u16				dccps_r_ack_ratio;
+	__u64				dccps_l_seq_win:48;
+	__u64				dccps_r_seq_win:48;
 	__u8				dccps_pcslen:4;
 	__u8				dccps_pcrlen:4;
 	__u8				dccps_send_ndp_count:1;
 	__u64				dccps_ndp_count:48;
 	unsigned long			dccps_rate_last;
-	struct dccp_minisock		dccps_minisock;
 	struct list_head		dccps_featneg;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;
 	struct ccid			*dccps_hc_rx_ccid;
@@ -527,11 +516,6 @@ static inline struct dccp_sock *dccp_sk(const struct sock *sk)
 	return (struct dccp_sock *)sk;
 }
 
-static inline struct dccp_minisock *dccp_msk(const struct sock *sk)
-{
-	return (struct dccp_minisock *)&dccp_sk(sk)->dccps_minisock;
-}
-
 static inline const char *dccp_role(const struct sock *sk)
 {
 	switch (dccp_sk(sk)->dccps_role) {

commit f90f92eed74251034f251e3cdf4fa5c4c1f09df0
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Jan 16 23:36:30 2009 +0000

    dccp: Initialisation framework for feature negotiation
    
    This initialises feature negotiation from two tables, which are in
    turn are initialised from sysctls.
    
    As a novel feature, specifics of the implementation (e.g. that short
    seqnos and ECN are not yet available) are advertised for robustness.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 61734e27abb7..990e97fa1f07 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -369,28 +369,9 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   * Will be used to pass the state from dccp_request_sock to dccp_sock.
   *
   * @dccpms_sequence_window - Sequence Window Feature (section 7.5.2)
-  * @dccpms_pending - List of features being negotiated
-  * @dccpms_conf -
   */
 struct dccp_minisock {
 	__u64			dccpms_sequence_window;
-	struct list_head	dccpms_pending;
-	struct list_head	dccpms_conf;
-};
-
-struct dccp_opt_conf {
-	__u8			*dccpoc_val;
-	__u8			dccpoc_len;
-};
-
-struct dccp_opt_pend {
-	struct list_head	dccpop_node;
-	__u8			dccpop_type;
-	__u8			dccpop_feat;
-	__u8		        *dccpop_val;
-	__u8			dccpop_len;
-	int			dccpop_conf;
-	struct dccp_opt_conf    *dccpop_sc;
 };
 
 extern void dccp_minisock_init(struct dccp_minisock *dmsk);

commit 6fdd34d43bff8be9bb925b49d87a0ee144d2ab07
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 8 01:19:06 2008 -0800

    dccp ccid-2: Phase out the use of boolean Ack Vector sysctl
    
    This removes the use of the sysctl and the minisock variable for the Send Ack
    Vector feature, as it now is handled fully dynamically via feature negotiation
    (i.e. when CCID-2 is enabled, Ack Vectors are automatically enabled as per
     RFC 4341, 4.).
    
    Using a sysctl in parallel to this implementation would open the door to
    crashes, since much of the code relies on tests of the boolean minisock /
    sysctl variable. Thus, this patch replaces all tests of type
    
            if (dccp_msk(sk)->dccpms_send_ack_vector)
                    /* ... */
    with
            if (dp->dccps_hc_rx_ackvec != NULL)
                    /* ... */
    
    The dccps_hc_rx_ackvec is allocated by the dccp_hdlr_ackvec() when feature
    negotiation concluded that Ack Vectors are to be used on the half-connection.
    Otherwise, it is NULL (due to dccp_init_sock/dccp_create_openreq_child),
    so that the test is a valid one.
    
    The activation handler for Ack Vectors is called as soon as the feature
    negotiation has concluded at the
     * server when the Ack marking the transition RESPOND => OPEN arrives;
     * client after it has sent its ACK, marking the transition REQUEST => PARTOPEN.
    
    Adding the sequence number of the Response packet to the Ack Vector has been
    removed, since
     (a) connection establishment implies that the Response has been received;
     (b) the CCIDs only look at packets received in the (PART)OPEN state, i.e.
         this entry will always be ignored;
     (c) it can not be used for anything useful - to detect loss for instance, only
         packets received after the loss can serve as pseudo-dupacks.
    
    There was a FIXME to change the error code when dccp_ackvec_add() fails.
    I removed this after finding out that:
     * the check whether ackno < ISN is already made earlier,
     * this Response is likely the 1st packet with an Ackno that the client gets,
     * so when dccp_ackvec_add() fails, the reason is likely not a packet error.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 60e94438eadd..61734e27abb7 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -360,7 +360,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
 #define DCCPF_INITIAL_ACK_RATIO			2
 #define DCCPF_INITIAL_CCID			DCCPC_CCID2
-#define DCCPF_INITIAL_SEND_ACK_VECTOR		1
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
 
@@ -370,13 +369,11 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   * Will be used to pass the state from dccp_request_sock to dccp_sock.
   *
   * @dccpms_sequence_window - Sequence Window Feature (section 7.5.2)
-  * @dccpms_send_ack_vector - Send Ack Vector Feature (section 11.5)
   * @dccpms_pending - List of features being negotiated
   * @dccpms_conf -
   */
 struct dccp_minisock {
 	__u64			dccpms_sequence_window;
-	__u8			dccpms_send_ack_vector;
 	struct list_head	dccpms_pending;
 	struct list_head	dccpms_conf;
 };

commit 4098dce5be537a157eed4a326efd464109825b8b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 8 01:18:37 2008 -0800

    dccp: Remove manual influence on NDP Count feature
    
    Updating the NDP count feature is handled automatically now:
     * for CCID-2 it is disabled, since the code does not use NDP counts;
     * for CCID-3 it is enabled, as NDP counts are used to determine loss lengths.
    
    Allowing the user to change NDP values leads to unpredictable and failing
    behaviour, since it is then possible to disable NDP counts even when they
    are needed (e.g. in CCID-3).
    
    This means that only those user settings are sensible that agree with the
    values for Send NDP Count implied by the choice of CCID. But those settings
    are already activated by the feature negotiation (CCID dependency tracking),
    hence this form of support is redundant.
    
    At startup the initialisation of the NDP count feature uses the default
    value of 0, which is done implicitly by the zeroing-out of the socket when
    it is allocated. If the choice of CCID or feature negotiation enables NDP
    count, this will then be updated via the NDP activation handler.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 46daea312d92..60e94438eadd 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -371,14 +371,12 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   *
   * @dccpms_sequence_window - Sequence Window Feature (section 7.5.2)
   * @dccpms_send_ack_vector - Send Ack Vector Feature (section 11.5)
-  * @dccpms_send_ndp_count - Send NDP Count Feature (7.7.2)
   * @dccpms_pending - List of features being negotiated
   * @dccpms_conf -
   */
 struct dccp_minisock {
 	__u64			dccpms_sequence_window;
 	__u8			dccpms_send_ack_vector;
-	__u8			dccpms_send_ndp_count;
 	struct list_head	dccpms_pending;
 	struct list_head	dccpms_conf;
 };
@@ -490,6 +488,7 @@ struct dccp_ackvec;
  * @dccps_r_ack_ratio - feature-remote Ack Ratio
  * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
  * @dccps_pcrlen - receiver partial checksum coverage (via sockopt)
+ * @dccps_send_ndp_count - local Send NDP Count feature (7.7.2)
  * @dccps_ndp_count - number of Non Data Packets since last data packet
  * @dccps_mss_cache - current value of MSS (path MTU minus header sizes)
  * @dccps_rate_last - timestamp for rate-limiting DCCP-Sync (RFC 4340, 7.5.4)
@@ -529,6 +528,7 @@ struct dccp_sock {
 	__u16				dccps_r_ack_ratio;
 	__u8				dccps_pcslen:4;
 	__u8				dccps_pcrlen:4;
+	__u8				dccps_send_ndp_count:1;
 	__u64				dccps_ndp_count:48;
 	unsigned long			dccps_rate_last;
 	struct dccp_minisock		dccps_minisock;

commit 0049bab5e765aa74cf767a834fa336e19453fc5e
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 8 01:18:05 2008 -0800

    dccp: Remove obsolete parts of the old CCID interface
    
    The TX/RX CCIDs of the minisock are now redundant: similar to the Ack Vector
    case, their value equals initially that of the sysctl, but at the end of
    feature negotiation may be something different.
    
    The old interface removed by this patch thus has been replaced by the newer
    interface to dynamically query the currently loaded CCIDs.
    
    Also removed are the constructors for the TX CCID and the RX CCID, since the
    switch "rx <-> non-rx" is done by the handler in minisocks.c (and the handler
    is the only place in the code where CCIDs are loaded).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 6a72ff52a8a4..46daea312d92 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -370,7 +370,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   * Will be used to pass the state from dccp_request_sock to dccp_sock.
   *
   * @dccpms_sequence_window - Sequence Window Feature (section 7.5.2)
-  * @dccpms_ccid - Congestion Control Id (CCID) (section 10)
   * @dccpms_send_ack_vector - Send Ack Vector Feature (section 11.5)
   * @dccpms_send_ndp_count - Send NDP Count Feature (7.7.2)
   * @dccpms_pending - List of features being negotiated
@@ -378,8 +377,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   */
 struct dccp_minisock {
 	__u64			dccpms_sequence_window;
-	__u8			dccpms_rx_ccid;
-	__u8			dccpms_tx_ccid;
 	__u8			dccpms_send_ack_vector;
 	__u8			dccpms_send_ndp_count;
 	struct list_head	dccpms_pending;

commit b20a9c24d5c5d466d7e4a25c6f1bedbd2d16ad4f
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 23 16:02:31 2008 -0800

    dccp: Set per-connection CCIDs via socket options
    
    With this patch, TX/RX CCIDs can now be changed on a per-connection
    basis, which overrides the defaults set by the global sysctl variables
    for TX/RX CCIDs.
    
    To make full use of this facility, the remaining patches of this patch
    set are needed, which track dependencies and activate negotiated
    feature values.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index eda389ce04f4..6a72ff52a8a4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -168,6 +168,8 @@ enum {
 	DCCPO_MIN_CCID_SPECIFIC = 128,
 	DCCPO_MAX_CCID_SPECIFIC = 255,
 };
+/* maximum size of a single TLV-encoded DCCP option (sans type/len bytes) */
+#define DCCP_SINGLE_OPT_MAXLEN	253
 
 /* DCCP CCIDS */
 enum {
@@ -203,6 +205,9 @@ enum dccp_feature_numbers {
 #define DCCP_SOCKOPT_SEND_CSCOV		10
 #define DCCP_SOCKOPT_RECV_CSCOV		11
 #define DCCP_SOCKOPT_AVAILABLE_CCIDS	12
+#define DCCP_SOCKOPT_CCID		13
+#define DCCP_SOCKOPT_TX_CCID		14
+#define DCCP_SOCKOPT_RX_CCID		15
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
 #define DCCP_SOCKOPT_CCID_TX_INFO	192
 

commit dd9c0e363cef32b7d6f23d4c87e8dfe4f91fd1c5
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 16 22:55:08 2008 -0800

    dccp: Deprecate Ack Ratio sysctl
    
    This patch deprecates the Ack Ratio sysctl, since
     * Ack Ratio is entirely ignored by CCID-3 and CCID-4,
     * Ack Ratio currently doesn't work in CCID-2 (i.e. is always set to 1);
     * even if it would work in CCID-2, there is no point for a user to change it:
       - Ack Ratio is constrained by cwnd (RFC 4341, 6.1.2),
       - if Ack Ratio > cwnd, the system resorts to spurious RTO timeouts
         (since waiting for Acks which will never arrive in this window),
       - cwnd is not a user-configurable value.
    
    The only reasonable place for Ack Ratio is to print it for debugging. It is
    planned to do this later on, as part of e.g. dccp_probe.
    
    With this patch Ack Ratio is now under full control of feature negotiation:
     * Ack Ratio is resolved as a dependency of the selected CCID;
     * if the chosen CCID supports it (i.e. CCID == CCID-2), Ack Ratio is set to
       the default of 2, following RFC 4340, 11.3 - "New connections start with Ack
       Ratio 2 for both endpoints";
     * what happens then is part of another patch set, since it concerns the
       dynamic update of Ack Ratio while the connection is in full flight.
    
    Thanks to Tomasz Grobelny for discussion leading up to this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 5a5a89935dbc..eda389ce04f4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -368,7 +368,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   * @dccpms_ccid - Congestion Control Id (CCID) (section 10)
   * @dccpms_send_ack_vector - Send Ack Vector Feature (section 11.5)
   * @dccpms_send_ndp_count - Send NDP Count Feature (7.7.2)
-  * @dccpms_ack_ratio - Ack Ratio Feature (section 11.3)
   * @dccpms_pending - List of features being negotiated
   * @dccpms_conf -
   */
@@ -378,7 +377,6 @@ struct dccp_minisock {
 	__u8			dccpms_tx_ccid;
 	__u8			dccpms_send_ack_vector;
 	__u8			dccpms_send_ndp_count;
-	__u8			dccpms_ack_ratio;
 	struct list_head	dccpms_pending;
 	struct list_head	dccpms_conf;
 };

commit 29450559849da7066813601effb7666966869853
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 16 22:53:48 2008 -0800

    dccp: Feature negotiation for minimum-checksum-coverage
    
    This provides feature negotiation for server minimum checksum coverage
    which so far has been missing.
    
    Since sender/receiver coverage values range only from 0...15, their
    type has also been reduced in size from u16 to u4.
    
    Feature-negotiation options are now generated for both sender and receiver
    coverage, i.e. when the peer has `forgotten' to enable partial coverage
    then feature negotiation will automatically enable (negotiate) the partial
    coverage value for this connection.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 6eaaca9b037a..5a5a89935dbc 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -527,8 +527,8 @@ struct dccp_sock {
 	__u32				dccps_timestamp_time;
 	__u16				dccps_l_ack_ratio;
 	__u16				dccps_r_ack_ratio;
-	__u16				dccps_pcslen;
-	__u16				dccps_pcrlen;
+	__u8				dccps_pcslen:4;
+	__u8				dccps_pcrlen:4;
 	__u64				dccps_ndp_count:48;
 	unsigned long			dccps_rate_last;
 	struct dccp_minisock		dccps_minisock;

commit 49aebc66d6b896f9c7c5739d85c4548c00015aa7
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 16 22:51:23 2008 -0800

    dccp: Deprecate old setsockopt framework
    
    The previous setsockopt interface, which passed socket options via struct
    dccp_so_feat, is complicated/difficult to use. Continuing to support it leads to
    ugly code since the old approach did not distinguish between NN and SP values.
    
    This patch removes the old setsockopt interface and replaces it with two new
    functions to register NN/SP values for feature negotiation.
    These are essentially wrappers around the internal __feat_register functions,
    with checking added to avoid
    
     * wrong usage (type);
     * changing values while the connection is in progress.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index d3ac1bde60b4..6eaaca9b037a 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -193,13 +193,6 @@ enum dccp_feature_numbers {
 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
-/* this structure is argument to DCCP_SOCKOPT_CHANGE_X */
-struct dccp_so_feat {
-	__u8 dccpsf_feat;
-	__u8 __user *dccpsf_val;
-	__u8 dccpsf_len;
-};
-
 /* DCCP socket options */
 #define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
 #define DCCP_SOCKOPT_SERVICE		2

commit d90ebcbfa7f5a8b4e20518c9f94c5c4e4cd3c2e5
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Nov 12 00:47:26 2008 -0800

    dccp: Query supported CCIDs
    
    This provides a data structure to record which CCIDs are locally supported
    and three accessor functions:
     - a test function for internal use which is used to validate CCID requests
       made by the user;
     - a copy function so that the list can be used for feature-negotiation;
     - documented getsockopt() support so that the user can query capabilities.
    
    The data structure is a table which is filled in at compile-time with the
    list of available CCIDs (which in turn depends on the Kconfig choices).
    
    Using the copy function for cloning the list of supported CCIDs is useful for
    feature negotiation, since the negotiation is now with the full list of available
    CCIDs (e.g. {2, 3}) instead of the default value {2}. This means negotiation
    will not fail if the peer requests to use CCID3 instead of CCID2.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 484b8a1fb023..d3ac1bde60b4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -209,6 +209,7 @@ struct dccp_so_feat {
 #define DCCP_SOCKOPT_SERVER_TIMEWAIT	6
 #define DCCP_SOCKOPT_SEND_CSCOV		10
 #define DCCP_SOCKOPT_RECV_CSCOV		11
+#define DCCP_SOCKOPT_AVAILABLE_CCIDS	12
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
 #define DCCP_SOCKOPT_CCID_TX_INFO	192
 

commit ac75773c2742d82cbcb078708df406e9017224b7
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 4 23:55:49 2008 -0800

    dccp: Per-socket initialisation of feature negotiation
    
    This provides feature-negotiation initialisation for both DCCP sockets
    and DCCP request_sockets, to support feature negotiation during
    connection setup.
    
    It also resolves a FIXME regarding the congestion control
    initialisation.
    
    Thanks to Wei Yongjun for help with the IPv6 side of this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 3978aff197d9..484b8a1fb023 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -412,6 +412,7 @@ extern void dccp_minisock_init(struct dccp_minisock *dmsk);
  * @dreq_iss: initial sequence number sent on the Response (RFC 4340, 7.1)
  * @dreq_isr: initial sequence number received on the Request
  * @dreq_service: service code present on the Request (there is just one)
+ * @dreq_featneg: feature negotiation options for this connection
  * The following two fields are analogous to the ones in dccp_sock:
  * @dreq_timestamp_echo: last received timestamp to echo (13.1)
  * @dreq_timestamp_echo: the time of receiving the last @dreq_timestamp_echo
@@ -421,6 +422,7 @@ struct dccp_request_sock {
 	__u64			 dreq_iss;
 	__u64			 dreq_isr;
 	__be32			 dreq_service;
+	struct list_head	 dreq_featneg;
 	__u32			 dreq_timestamp_echo;
 	__u32			 dreq_timestamp_time;
 };
@@ -498,6 +500,7 @@ struct dccp_ackvec;
  * @dccps_mss_cache - current value of MSS (path MTU minus header sizes)
  * @dccps_rate_last - timestamp for rate-limiting DCCP-Sync (RFC 4340, 7.5.4)
  * @dccps_minisock - associated minisock (accessed via dccp_msk)
+ * @dccps_featneg - tracks feature-negotiation state (mostly during handshake)
  * @dccps_hc_rx_ackvec - rx half connection ack vector
  * @dccps_hc_rx_ccid - CCID used for the receiver (or receiving half-connection)
  * @dccps_hc_tx_ccid - CCID used for the sender (or sending half-connection)
@@ -535,6 +538,7 @@ struct dccp_sock {
 	__u64				dccps_ndp_count:48;
 	unsigned long			dccps_rate_last;
 	struct dccp_minisock		dccps_minisock;
+	struct list_head		dccps_featneg;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;
 	struct ccid			*dccps_hc_rx_ccid;
 	struct ccid			*dccps_hc_tx_ccid;

commit 7d43d1a0f2cf535167ec7247f110a1f85cecac43
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 4 23:43:47 2008 -0800

    dccp: Implement lookup table for feature-negotiation information
    
    A lookup table for feature-negotiation information, extracted from RFC
    4340/42, is provided by this patch. All currently known features can
    be found in this table, along with their feature location, their
    default value, and type.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 6080449fbec9..3978aff197d9 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -176,19 +176,20 @@ enum {
 };
 
 /* DCCP features (RFC 4340 section 6.4) */
-enum {
+enum dccp_feature_numbers {
 	DCCPF_RESERVED = 0,
 	DCCPF_CCID = 1,
-	DCCPF_SHORT_SEQNOS = 2,		/* XXX: not yet implemented */
+	DCCPF_SHORT_SEQNOS = 2,
 	DCCPF_SEQUENCE_WINDOW = 3,
-	DCCPF_ECN_INCAPABLE = 4,	/* XXX: not yet implemented */
+	DCCPF_ECN_INCAPABLE = 4,
 	DCCPF_ACK_RATIO = 5,
 	DCCPF_SEND_ACK_VECTOR = 6,
 	DCCPF_SEND_NDP_COUNT = 7,
 	DCCPF_MIN_CSUM_COVER = 8,
-	DCCPF_DATA_CHECKSUM = 9,	/* XXX: not yet implemented */
+	DCCPF_DATA_CHECKSUM = 9,
 	/* 10-127 reserved */
 	DCCPF_MIN_CCID_SPECIFIC = 128,
+	DCCPF_SEND_LEV_RATE = 192,	/* RFC 4342, sec. 8.4 */
 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 

commit 5b5d0e704880addfd979c262e6441f126708539c
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Jul 13 11:51:40 2008 +0100

    dccp: Upgrade NDP count from 3 to 6 bytes
    
    RFC 4340, 7.7 specifies up to 6 bytes for the NDP Count option, whereas the code
    is currently limited to up to 3 bytes. This seems to be a relict of an earlier
    draft version and is brought up to date by the patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index aa0737019e37..6080449fbec9 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -364,8 +364,6 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
 
-#define DCCP_NDP_LIMIT 0xFFFFFF
-
 /**
   * struct dccp_minisock - Minimal DCCP connection representation
   *
@@ -437,7 +435,7 @@ extern int dccp_parse_options(struct sock *sk, struct dccp_request_sock *dreq,
 			      struct sk_buff *skb);
 
 struct dccp_options_received {
-	u32	dccpor_ndp; /* only 24 bits */
+	u64	dccpor_ndp:48;
 	u32	dccpor_timestamp;
 	u32	dccpor_timestamp_echo;
 	u32	dccpor_elapsed_time;
@@ -533,7 +531,7 @@ struct dccp_sock {
 	__u16				dccps_r_ack_ratio;
 	__u16				dccps_pcslen;
 	__u16				dccps_pcrlen;
-	unsigned long			dccps_ndp_count;
+	__u64				dccps_ndp_count:48;
 	unsigned long			dccps_rate_last;
 	struct dccp_minisock		dccps_minisock;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;

commit cf6b5fbe7426cab3322c3a82f25291672d70a65f
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Feb 3 04:07:48 2008 -0800

    [DCCP]: Reorganize struct dccp_sock to save 8 bytes
    
    /home/acme/git/net-2.6/net/dccp/ipv6.c:
      struct dccp_sock  |   -8
      struct dccp6_sock |   -8
     2 structs changed
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 484e45c7c89a..aa0737019e37 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -525,6 +525,7 @@ struct dccp_sock {
 	__u64				dccps_gsr;
 	__u64				dccps_gar;
 	__be32				dccps_service;
+	__u32				dccps_mss_cache;
 	struct dccp_service_list	*dccps_service_list;
 	__u32				dccps_timestamp_echo;
 	__u32				dccps_timestamp_time;
@@ -533,7 +534,6 @@ struct dccp_sock {
 	__u16				dccps_pcslen;
 	__u16				dccps_pcrlen;
 	unsigned long			dccps_ndp_count;
-	__u32				dccps_mss_cache;
 	unsigned long			dccps_rate_last;
 	struct dccp_minisock		dccps_minisock;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;

commit b4d4f7c70fd3361c6c889752e08ea9be304cf5f4
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Dec 13 12:37:19 2007 -0200

    [DCCP]: Handle timestamps on Request/Response exchange separately
    
    In DCCP, timestamps can occur on packets anytime, CCID3 uses a timestamp(/echo) on the Request/Response
    exchange. This patch addresses the following situation:
            * timestamps are recorded on the listening socket;
            * Responses are sent from dccp_request_sockets;
            * suppose two connections reach the listening socket with very small time in between:
            * the first timestamp value gets overwritten by the second connection request.
    
    This is not really good, so this patch separates timestamps into
     * those which are received by the server during the initial handshake (on dccp_request_sock);
     * those which are received by the client or the client after connection establishment.
    
    As before, a timestamp of 0 is regarded as indicating that no (meaningful) timestamp has been
    received (in addition, a warning message is printed if hosts send 0-valued timestamps).
    
    The timestamp-echoing now works as follows:
     * when a timestamp is present on the initial Request, it is placed into dreq, due to the
       call to dccp_parse_options in dccp_v{4,6}_conn_request;
     * when a timestamp is present on the Ack leading from RESPOND => OPEN, it is copied over
       from the request_sock into the child cocket in dccp_create_openreq_child;
     * timestamps received on an (established) dccp_sock are treated as before.
    
    Since Elapsed Time is measured in hundredths of milliseconds (13.2), the new dccp_timestamp()
    function is used, as it is expected that the time between receiving the timestamp and
    sending the timestamp echo will be very small against the wrap-around time. As a byproduct,
    this allows smaller timestamping-time fields.
    
    Furthermore, inserting the Timestamp Echo option has been taken out of the block starting with
    '!dccp_packet_without_ack()', since Timestamp Echo can be carried on any packet (5.8 and 13.3).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 7214031461d3..484e45c7c89a 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -407,11 +407,23 @@ struct dccp_opt_pend {
 
 extern void dccp_minisock_init(struct dccp_minisock *dmsk);
 
+/**
+ * struct dccp_request_sock  -  represent DCCP-specific connection request
+ * @dreq_inet_rsk: structure inherited from
+ * @dreq_iss: initial sequence number sent on the Response (RFC 4340, 7.1)
+ * @dreq_isr: initial sequence number received on the Request
+ * @dreq_service: service code present on the Request (there is just one)
+ * The following two fields are analogous to the ones in dccp_sock:
+ * @dreq_timestamp_echo: last received timestamp to echo (13.1)
+ * @dreq_timestamp_echo: the time of receiving the last @dreq_timestamp_echo
+ */
 struct dccp_request_sock {
 	struct inet_request_sock dreq_inet_rsk;
 	__u64			 dreq_iss;
 	__u64			 dreq_isr;
 	__be32			 dreq_service;
+	__u32			 dreq_timestamp_echo;
+	__u32			 dreq_timestamp_time;
 };
 
 static inline struct dccp_request_sock *dccp_rsk(const struct request_sock *req)
@@ -477,8 +489,8 @@ struct dccp_ackvec;
  * @dccps_gar - greatest valid ack number received on a non-Sync; initialized to %dccps_iss
  * @dccps_service - first (passive sock) or unique (active sock) service code
  * @dccps_service_list - second .. last service code on passive socket
- * @dccps_timestamp_time - time of latest TIMESTAMP option
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
+ * @dccps_timestamp_time - time of receiving latest @dccps_timestamp_echo
  * @dccps_l_ack_ratio - feature-local Ack Ratio
  * @dccps_r_ack_ratio - feature-remote Ack Ratio
  * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
@@ -514,8 +526,8 @@ struct dccp_sock {
 	__u64				dccps_gar;
 	__be32				dccps_service;
 	struct dccp_service_list	*dccps_service_list;
-	ktime_t				dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
+	__u32				dccps_timestamp_time;
 	__u16				dccps_l_ack_ratio;
 	__u16				dccps_r_ack_ratio;
 	__u16				dccps_pcslen;

commit 8b819412481494fb6861c08d360b75fabcbbfbbf
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Dec 13 12:29:24 2007 -0200

    [DCCP]: Allow to parse options on Request Sockets
    
    The option parsing code currently only parses on full sk's. This causes a problem for
    options sent during the initial handshake (in particular timestamps and feature-negotiation
    options). Therefore, this patch extends the option parsing code with an additional argument
    for request_socks: if it is non-NULL, options are parsed on the request socket, otherwise
    the normal path (parsing on the sk) is used.
    
    Subsequent patches, which implement feature negotiation during connection setup, make use
    of this facility.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index c676021603f5..7214031461d3 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -407,8 +407,6 @@ struct dccp_opt_pend {
 
 extern void dccp_minisock_init(struct dccp_minisock *dmsk);
 
-extern int dccp_parse_options(struct sock *sk, struct sk_buff *skb);
-
 struct dccp_request_sock {
 	struct inet_request_sock dreq_inet_rsk;
 	__u64			 dreq_iss;
@@ -423,6 +421,9 @@ static inline struct dccp_request_sock *dccp_rsk(const struct request_sock *req)
 
 extern struct inet_timewait_death_row dccp_death_row;
 
+extern int dccp_parse_options(struct sock *sk, struct dccp_request_sock *dreq,
+			      struct sk_buff *skb);
+
 struct dccp_options_received {
 	u32	dccpor_ndp; /* only 24 bits */
 	u32	dccpor_timestamp;

commit b8599d20708fa3bde1e414689f3474560c2d990b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Dec 13 12:25:01 2007 -0200

    [DCCP]: Support for server holding timewait state
    
    This adds a socket option and signalling support for the case where the server
    holds timewait state on closing the connection, as described in RFC 4340, 8.3.
    
    Since holding timewait state at the server is the non-usual case, it is enabled
    via a socket option. Documentation for this socket option has been added.
    
    The setsockopt statement has been made resilient against different possible cases
    of expressing boolean `true' values using a suggestion by Ian McDonald.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 312b989c7edb..c676021603f5 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -205,6 +205,7 @@ struct dccp_so_feat {
 #define DCCP_SOCKOPT_CHANGE_L		3
 #define DCCP_SOCKOPT_CHANGE_R		4
 #define DCCP_SOCKOPT_GET_CUR_MPS	5
+#define DCCP_SOCKOPT_SERVER_TIMEWAIT	6
 #define DCCP_SOCKOPT_SEND_CSCOV		10
 #define DCCP_SOCKOPT_RECV_CSCOV		11
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
@@ -492,6 +493,7 @@ struct dccp_ackvec;
  * @dccps_role - role of this sock, one of %dccp_role
  * @dccps_hc_rx_insert_options - receiver wants to add options when acking
  * @dccps_hc_tx_insert_options - sender wants to add options when sending
+ * @dccps_server_timewait - server holds timewait state on close (RFC 4340, 8.3)
  * @dccps_xmit_timer - timer for when CCID is not ready to send
  * @dccps_syn_rtt - RTT sample from Request/Response exchange (in usecs)
  */
@@ -528,6 +530,7 @@ struct dccp_sock {
 	enum dccp_role			dccps_role:2;
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;
+	__u8				dccps_server_timewait:1;
 	struct timer_list		dccps_xmit_timer;
 };
 

commit 0c869620762fea4b3acf6502d9e80840b27ec642
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Nov 28 11:59:48 2007 -0200

    [DCCP]: Integrate state transitions for passive-close
    
    This adds the necessary state transitions for the two forms of passive-close
    
     * PASSIVE_CLOSE    - which is entered when a host   receives a Close;
     * PASSIVE_CLOSEREQ - which is entered when a client receives a CloseReq.
    
    Here is a detailed account of what the patch does in each state.
    
    1) Receiving CloseReq
    
      The pseudo-code in 8.5 says:
    
         Step 13: Process CloseReq
              If P.type == CloseReq and S.state < CLOSEREQ,
                  Generate Close
                  S.state := CLOSING
                  Set CLOSING timer.
    
      This means we need to address what to do in CLOSED, LISTEN, REQUEST, RESPOND, PARTOPEN, and OPEN.
    
       * CLOSED:         silently ignore - it may be a late or duplicate CloseReq;
       * LISTEN/RESPOND: will not appear, since Step 7 is performed first (we know we are the client);
       * REQUEST:        perform Step 13 directly (no need to enqueue packet);
       * OPEN/PARTOPEN:  enter PASSIVE_CLOSEREQ so that the application has a chance to process unread data.
    
      When already in PASSIVE_CLOSEREQ, no second CloseReq is enqueued. In any other state, the CloseReq is ignored.
      I think that this offers some robustness against rare and pathological cases: e.g. a simultaneous close where
      the client sends a Close and the server a CloseReq. The client will then be retransmitting its Close until it
      gets the Reset, so ignoring the CloseReq while in state CLOSING is sane.
    
    2) Receiving Close
    
      The code below from 8.5 is unconditional.
    
         Step 14: Process Close
              If P.type == Close,
                  Generate Reset(Closed)
                  Tear down connection
                  Drop packet and return
    
      Thus we need to consider all states:
       * CLOSED:           silently ignore, since this can happen when a retransmitted or late Close arrives;
       * LISTEN:           dccp_rcv_state_process() will generate a Reset ("No Connection");
       * REQUEST:          perform Step 14 directly (no need to enqueue packet);
       * RESPOND:          dccp_check_req() will generate a Reset ("Packet Error") -- left it at that;
       * OPEN/PARTOPEN:    enter PASSIVE_CLOSE so that application has a chance to process unread data;
       * CLOSEREQ:         server performed active-close -- perform Step 14;
       * CLOSING:          simultaneous-close: use a tie-breaker to avoid message ping-pong (see comment);
       * PASSIVE_CLOSEREQ: ignore - the peer has a bug (sending first a CloseReq and now a Close);
       * TIMEWAIT:         packet is ignored.
    
       Note that the condition of receiving a packet in state CLOSED here is different from the condition "there
       is no socket for such a connection": the socket still exists, but its state indicates it is unusable.
    
       Last, dccp_finish_passive_close sets either DCCP_CLOSED or DCCP_CLOSING = TCP_CLOSING, so that
       sk_stream_wait_close() will wait for the final Reset (which will trigger CLOSING => CLOSED).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 8b3f9ad3cf04..312b989c7edb 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -260,7 +260,6 @@ enum dccp_state {
 };
 
 #define DCCP_STATE_MASK 0x1f
-#define DCCP_ACTION_FIN (1<<7)
 
 enum {
 	DCCPF_OPEN	      = TCPF_ESTABLISHED,

commit f11135a3442996d78dad99933bfdb90d1f6588d3
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Nov 28 11:34:53 2007 -0200

    [DCCP]: Dedicated auxiliary states to support passive-close
    
    This adds two auxiliary states to deal with passive closes:
      * PASSIVE_CLOSE    (reached from OPEN via reception of Close)    and
      * PASSIVE_CLOSEREQ (reached from OPEN via reception of CloseReq)
    as internal intermediate states.
    
    These states are used to allow a receiver to process unread data before
    acknowledging the received connection-termination-request (the Close/CloseReq).
    
    Without such support, it will happen that passively-closed sockets enter CLOSED
    state while there is still unprocessed data in the queue; leading to unexpected
    and erratic API behaviour.
    
    PASSIVE_CLOSE has been mapped into TCPF_CLOSE_WAIT, so that the code will
    seamlessly work with inet_accept() (which tests for this state).
    
    The state names are thanks to Arnaldo, who suggested this naming scheme
    following an earlier revision of this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index a0073268808f..8b3f9ad3cf04 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -227,29 +227,51 @@ struct dccp_so_feat {
 #include <net/tcp_states.h>
 
 enum dccp_state {
-	DCCP_OPEN	= TCP_ESTABLISHED,
-	DCCP_REQUESTING	= TCP_SYN_SENT,
-	DCCP_LISTEN	= TCP_LISTEN,
-	DCCP_RESPOND	= TCP_SYN_RECV,
-	DCCP_CLOSING	= TCP_CLOSING,
-	DCCP_TIME_WAIT	= TCP_TIME_WAIT,
-	DCCP_CLOSED	= TCP_CLOSE,
-	DCCP_PARTOPEN	= TCP_MAX_STATES,
+	DCCP_OPEN	     = TCP_ESTABLISHED,
+	DCCP_REQUESTING	     = TCP_SYN_SENT,
+	DCCP_LISTEN	     = TCP_LISTEN,
+	DCCP_RESPOND	     = TCP_SYN_RECV,
+	/*
+	 * States involved in closing a DCCP connection:
+	 * 1) ACTIVE_CLOSEREQ is entered by a server sending a CloseReq.
+	 *
+	 * 2) CLOSING can have three different meanings (RFC 4340, 8.3):
+	 *  a. Client has performed active-close, has sent a Close to the server
+	 *     from state OPEN or PARTOPEN, and is waiting for the final Reset
+	 *     (in this case, SOCK_DONE == 1).
+	 *  b. Client is asked to perform passive-close, by receiving a CloseReq
+	 *     in (PART)OPEN state. It sends a Close and waits for final Reset
+	 *     (in this case, SOCK_DONE == 0).
+	 *  c. Server performs an active-close as in (a), keeps TIMEWAIT state.
+	 *
+	 * 3) The following intermediate states are employed to give passively
+	 *    closing nodes a chance to process their unread data:
+	 *    - PASSIVE_CLOSE    (from OPEN => CLOSED) and
+	 *    - PASSIVE_CLOSEREQ (from (PART)OPEN to CLOSING; case (b) above).
+	 */
+	DCCP_ACTIVE_CLOSEREQ = TCP_FIN_WAIT1,
+	DCCP_PASSIVE_CLOSE   = TCP_CLOSE_WAIT,	/* any node receiving a Close */
+	DCCP_CLOSING	     = TCP_CLOSING,
+	DCCP_TIME_WAIT	     = TCP_TIME_WAIT,
+	DCCP_CLOSED	     = TCP_CLOSE,
+	DCCP_PARTOPEN	     = TCP_MAX_STATES,
+	DCCP_PASSIVE_CLOSEREQ,			/* clients receiving CloseReq */
 	DCCP_MAX_STATES
 };
 
-#define DCCP_STATE_MASK 0xf
+#define DCCP_STATE_MASK 0x1f
 #define DCCP_ACTION_FIN (1<<7)
 
 enum {
-	DCCPF_OPEN	 = TCPF_ESTABLISHED,
-	DCCPF_REQUESTING = TCPF_SYN_SENT,
-	DCCPF_LISTEN	 = TCPF_LISTEN,
-	DCCPF_RESPOND	 = TCPF_SYN_RECV,
-	DCCPF_CLOSING	 = TCPF_CLOSING,
-	DCCPF_TIME_WAIT	 = TCPF_TIME_WAIT,
-	DCCPF_CLOSED	 = TCPF_CLOSE,
-	DCCPF_PARTOPEN	 = 1 << DCCP_PARTOPEN,
+	DCCPF_OPEN	      = TCPF_ESTABLISHED,
+	DCCPF_REQUESTING      = TCPF_SYN_SENT,
+	DCCPF_LISTEN	      = TCPF_LISTEN,
+	DCCPF_RESPOND	      = TCPF_SYN_RECV,
+	DCCPF_ACTIVE_CLOSEREQ = TCPF_FIN_WAIT1,
+	DCCPF_CLOSING	      = TCPF_CLOSING,
+	DCCPF_TIME_WAIT	      = TCPF_TIME_WAIT,
+	DCCPF_CLOSED	      = TCPF_CLOSE,
+	DCCPF_PARTOPEN	      = (1 << DCCP_PARTOPEN),
 };
 
 static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)

commit 9b91ad2747891767c0efb4fb965c5dfed8d4f88e
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 20 21:56:37 2007 -0200

    [DCCP]: Make PARTOPEN an autonomous state
    
    This decouples PARTOPEN from TCP-specific stream-states.
    
    It thus addresses the FIXME.
    
    The code has been checked with regard to dependency on PARTOPEN and FIN_WAIT1
    states (to which PARTOPEN previously was mapped): there is no difference, as
    PARTOPEN is always referred to directly (i.e. not via the mapping to TCP
    state).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 333c3ea82a5d..a0073268808f 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -229,21 +229,13 @@ struct dccp_so_feat {
 enum dccp_state {
 	DCCP_OPEN	= TCP_ESTABLISHED,
 	DCCP_REQUESTING	= TCP_SYN_SENT,
-	DCCP_PARTOPEN	= TCP_FIN_WAIT1, /* FIXME:
-					    This mapping is horrible, but TCP has
-					    no matching state for DCCP_PARTOPEN,
-					    as TCP_SYN_RECV is already used by
-					    DCCP_RESPOND, why don't stop using TCP
-					    mapping of states? OK, now we don't use
-					    sk_stream_sendmsg anymore, so doesn't
-					    seem to exist any reason for us to
-					    do the TCP mapping here */
 	DCCP_LISTEN	= TCP_LISTEN,
 	DCCP_RESPOND	= TCP_SYN_RECV,
 	DCCP_CLOSING	= TCP_CLOSING,
 	DCCP_TIME_WAIT	= TCP_TIME_WAIT,
 	DCCP_CLOSED	= TCP_CLOSE,
-	DCCP_MAX_STATES = TCP_MAX_STATES,
+	DCCP_PARTOPEN	= TCP_MAX_STATES,
+	DCCP_MAX_STATES
 };
 
 #define DCCP_STATE_MASK 0xf
@@ -252,12 +244,12 @@ enum dccp_state {
 enum {
 	DCCPF_OPEN	 = TCPF_ESTABLISHED,
 	DCCPF_REQUESTING = TCPF_SYN_SENT,
-	DCCPF_PARTOPEN	 = TCPF_FIN_WAIT1,
 	DCCPF_LISTEN	 = TCPF_LISTEN,
 	DCCPF_RESPOND	 = TCPF_SYN_RECV,
 	DCCPF_CLOSING	 = TCPF_CLOSING,
 	DCCPF_TIME_WAIT	 = TCPF_TIME_WAIT,
 	DCCPF_CLOSED	 = TCPF_CLOSE,
+	DCCPF_PARTOPEN	 = 1 << DCCP_PARTOPEN,
 };
 
 static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)

commit d8ef2c29a0dcfccb2d90cac990143d1a4668708a
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Oct 24 10:27:48 2007 -0200

    [DCCP]: Convert Reset code into socket error number
    
    This adds support for converting the 11 currently defined Reset codes into system
    error numbers, which are stored in sk_err for further interpretation.
    
    This makes the externally visible API behaviour similar to TCP, since a client
    connecting to a non-existing port will experience ECONNREFUSED.
    
    * Code 0, Unspecified, is interpreted as non-error (0);
    * Code 1, Closed (normal termination), also maps into 0;
    * Code 2, Aborted, maps into "Connection reset by peer" (ECONNRESET);
    * Code 3, No Connection and
      Code 7, Connection Refused, map into "Connection refused" (ECONNREFUSED);
    * Code 4, Packet Error, maps into "No message of desired type" (ENOMSG);
    * Code 5, Option Error, maps into "Illegal byte sequence" (EILSEQ);
    * Code 6, Mandatory Error, maps into "Operation not supported on transport endpoint" (EOPNOTSUPP);
    * Code 8, Bad Service Code, maps into "Invalid request code" (EBADRQC);
    * Code 9, Too Busy, maps into "Too many users" (EUSERS);
    * Code 10, Bad Init Cookie, maps into "Invalid request descriptor" (EBADR);
    * Code 11, Aggression Penalty, maps into "Quota exceeded" (EDQUOT)
      which makes sense in terms of using more than the `fair share' of bandwidth.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 55d28cb97596..333c3ea82a5d 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -144,6 +144,8 @@ enum dccp_reset_codes {
 	DCCP_RESET_CODE_TOO_BUSY,
 	DCCP_RESET_CODE_BAD_INIT_COOKIE,
 	DCCP_RESET_CODE_AGGRESSION_PENALTY,
+
+	DCCP_MAX_RESET_CODES		/* Leave at the end!  */
 };
 
 /* DCCP options */

commit fde20105f332614b23a3131d706cd90bdd7db72d
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Oct 24 10:12:09 2007 -0200

    [DCCP]: Retrieve packet sequence number for error reporting
    
    This fixes a problem when analysing erroneous packets in dccp_v{4,6}_err:
    * dccp_hdr_seq currently takes an skb
    * however, the transport headers in the skb are shifted, due to the
      preceding IPv4/v6 header.
    Fixed for v4 and v6 by changing dccp_hdr_seq to take a struct dccp_hdr as
    argument. Verified that the correct sequence number is now reported in the
    error handler.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index f3fc4392e93d..55d28cb97596 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -270,10 +270,9 @@ static inline struct dccp_hdr *dccp_zeroed_hdr(struct sk_buff *skb, int headlen)
 	return memset(skb_transport_header(skb), 0, headlen);
 }
 
-static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
+static inline struct dccp_hdr_ext *dccp_hdrx(const struct dccp_hdr *dh)
 {
-	return (struct dccp_hdr_ext *)(skb_transport_header(skb) +
-				       sizeof(struct dccp_hdr));
+	return (struct dccp_hdr_ext *)((unsigned char *)dh + sizeof(*dh));
 }
 
 static inline unsigned int __dccp_basic_hdr_len(const struct dccp_hdr *dh)
@@ -287,13 +286,12 @@ static inline unsigned int dccp_basic_hdr_len(const struct sk_buff *skb)
 	return __dccp_basic_hdr_len(dh);
 }
 
-static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
+static inline __u64 dccp_hdr_seq(const struct dccp_hdr *dh)
 {
-	const struct dccp_hdr *dh = dccp_hdr(skb);
 	__u64 seq_nr =  ntohs(dh->dccph_seq);
 
 	if (dh->dccph_x != 0)
-		seq_nr = (seq_nr << 32) + ntohl(dccp_hdrx(skb)->dccph_seq_low);
+		seq_nr = (seq_nr << 32) + ntohl(dccp_hdrx(dh)->dccph_seq_low);
 	else
 		seq_nr += (u32)dh->dccph_seq2 << 16;
 

commit 451bc0473f010babeadd888ae8ec1015959fd1b2
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Oct 4 14:43:42 2007 -0700

    [DCCP]: Tidy-up -- minisock initialisation
    
    This
    
     * removes a declaration of a non-existent function
       __dccp_minisock_init;
    
     * shifts the initialisation function dccp_minisock_init() from
       options.c to minisocks.c, where it is more naturally expected to
       be.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 0e44a3e5208d..f3fc4392e93d 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -391,7 +391,6 @@ struct dccp_opt_pend {
 	struct dccp_opt_conf    *dccpop_sc;
 };
 
-extern void __dccp_minisock_init(struct dccp_minisock *dmsk);
 extern void dccp_minisock_init(struct dccp_minisock *dmsk);
 
 extern int dccp_parse_options(struct sock *sk, struct sk_buff *skb);

commit 7c559a9e44ee61faf2f339604ce708decb345a93
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Oct 4 14:39:22 2007 -0700

    [DCCP]: Add socket option to query the current MPS
    
    This enables applications to query the current value of the Maximum
    Packet Size via a socket option, suggested as a SHOULD in (RFC 4340,
    p. 102).
    
    This socket option is useful to avoid the annoying bail-out via
    `-EMSGSIZE'.  In particular, as fragmentation is not currently
    supported (and its use is partly discouraged in RFC 4340).
    
    With this option, it is possible to size buffers accordingly, e.g.
    
            int buflen = dccp_get_cur_mps(sockfd);
    
            /* or */
            if (msgsize > dccp_get_cur_mps(sockfd))
                    die("message is too large for this path");
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 4ed82e2c9f65..0e44a3e5208d 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -202,6 +202,7 @@ struct dccp_so_feat {
 #define DCCP_SOCKOPT_SERVICE		2
 #define DCCP_SOCKOPT_CHANGE_L		3
 #define DCCP_SOCKOPT_CHANGE_R		4
+#define DCCP_SOCKOPT_GET_CUR_MPS	5
 #define DCCP_SOCKOPT_SEND_CSCOV		10
 #define DCCP_SOCKOPT_RECV_CSCOV		11
 #define DCCP_SOCKOPT_CCID_RX_INFO	128

commit a94f0f970549e63e54c80c4509db299c514d8c11
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Sep 26 11:31:49 2007 -0300

    [DCCP]: Rate-limit DCCP-Syncs
    
    This implements a SHOULD from RFC 4340, 7.5.4:
     "To protect against denial-of-service attacks, DCCP implementations SHOULD
      impose a rate limit on DCCP-Syncs sent in response to sequence-invalid packets,
      such as not more than eight DCCP-Syncs per second."
    
    The rate-limit is maintained on a per-socket basis. This is a more stringent
    policy than enforcing the rate-limit on a per-source-address basis and
    protects against attacks with forged source addresses.
    
    Moreover, the mechanism is deliberately kept simple. In contrast to
    xrlim_allow(), bursts of Sync packets in reply to sequence-invalid packets
    are not supported.  This foils such attacks where the receipt of a Sync
    triggers further sequence-invalid packets. (I have tested this mechanism against
    xrlim_allow algorithm for Syncs, permitting bursts just increases the problems.)
    
    In order to keep flexibility, the timeout parameter can be set via sysctl; and
    the whole mechanism can even be disabled (which is however not recommended).
    
    The algorithm in this patch has been improved with regard to wrapping issues
    thanks to a suggestion by Arnaldo.
    
    Commiter note: Rate limited the step 6 DCCP_WARN too, as it says we're
                   sending a sync.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 20e0717aa8e1..4ed82e2c9f65 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -470,6 +470,7 @@ struct dccp_ackvec;
  * @dccps_pcrlen - receiver partial checksum coverage (via sockopt)
  * @dccps_ndp_count - number of Non Data Packets since last data packet
  * @dccps_mss_cache - current value of MSS (path MTU minus header sizes)
+ * @dccps_rate_last - timestamp for rate-limiting DCCP-Sync (RFC 4340, 7.5.4)
  * @dccps_minisock - associated minisock (accessed via dccp_msk)
  * @dccps_hc_rx_ackvec - rx half connection ack vector
  * @dccps_hc_rx_ccid - CCID used for the receiver (or receiving half-connection)
@@ -505,6 +506,7 @@ struct dccp_sock {
 	__u16				dccps_pcrlen;
 	unsigned long			dccps_ndp_count;
 	__u32				dccps_mss_cache;
+	unsigned long			dccps_rate_last;
 	struct dccp_minisock		dccps_minisock;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;
 	struct ccid			*dccps_hc_rx_ccid;

commit 0430ee3451f4589b68f522552b1896825f2043b3
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Sep 26 11:27:56 2007 -0300

    [DCCP]: Add Support for Data 1 .. 3 fields of Reset packets
    
    This adds fields to support the informational Data 1..3 fields of the
    DCCP-Reset packets (RFC 4340, 5.6), and makes minor cosmetic changes
    to documentation.
    Code which fills in these fields follows in subsequent patches, it is
    primarily used for reporting option-processing and feature-negotiation
    errors.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index a0441190dc71..20e0717aa8e1 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -56,10 +56,9 @@ struct dccp_hdr_ext {
 };
 
 /**
- * struct dccp_hdr_request - Conection initiation request header
+ * struct dccp_hdr_request - Connection initiation request header
  *
  * @dccph_req_service - Service to which the client app wants to connect
- * @dccph_req_options - list of options (must be a multiple of 32 bits
  */
 struct dccp_hdr_request {
 	__be32	dccph_req_service;
@@ -76,12 +75,10 @@ struct dccp_hdr_ack_bits {
 	__be32	dccph_ack_nr_low;
 };
 /**
- * struct dccp_hdr_response - Conection initiation response header
+ * struct dccp_hdr_response - Connection initiation response header
  *
- * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
- * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
+ * @dccph_resp_ack - 48 bit Acknowledgment Number Subheader (5.3)
  * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
- * @dccph_resp_options - list of options (must be a multiple of 32 bits
  */
 struct dccp_hdr_response {
 	struct dccp_hdr_ack_bits	dccph_resp_ack;
@@ -91,8 +88,9 @@ struct dccp_hdr_response {
 /**
  * struct dccp_hdr_reset - Unconditionally shut down a connection
  *
- * @dccph_reset_service - Echoes the Service Code on a received DCCP-Request
- * @dccph_reset_options - list of options (must be a multiple of 32 bits
+ * @dccph_reset_ack - 48 bit Acknowledgment Number Subheader (5.6)
+ * @dccph_reset_code - one of %dccp_reset_codes
+ * @dccph_reset_data - the Data 1 ... Data 3 fields from 5.6
  */
 struct dccp_hdr_reset {
 	struct dccp_hdr_ack_bits	dccph_reset_ack;

commit 8fb8354af9b92ce3bd41083995f1fe26024d0959
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sun Aug 19 17:19:21 2007 -0700

    [DCCP]: Nuke dccp_timestamp and dccps_epoch, not used anymore
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 3a4b96becfc4..a0441190dc71 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -512,7 +512,6 @@ struct dccp_sock {
 	struct ccid			*dccps_hc_rx_ccid;
 	struct ccid			*dccps_hc_tx_ccid;
 	struct dccp_options_received	dccps_options_received;
-	struct timeval			dccps_epoch;
 	enum dccp_role			dccps_role:2;
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;

commit 19ac21465e15e476220909c01b23df847b6ffa30
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sun Aug 19 17:18:33 2007 -0700

    [DCCP]: Convert dccps_timestamp_time to ktime_t
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index fda2148d8c85..3a4b96becfc4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -215,6 +215,7 @@ struct dccp_so_feat {
 #ifdef __KERNEL__
 
 #include <linux/in.h>
+#include <linux/ktime.h>
 #include <linux/list.h>
 #include <linux/uio.h>
 #include <linux/workqueue.h>
@@ -498,7 +499,7 @@ struct dccp_sock {
 	__u64				dccps_gar;
 	__be32				dccps_service;
 	struct dccp_service_list	*dccps_service_list;
-	struct timeval			dccps_timestamp_time;
+	ktime_t				dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
 	__u16				dccps_l_ack_ratio;
 	__u16				dccps_r_ack_ratio;

commit 91d73c15cb165195bc8c3d6a35e30df454b1485b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Apr 20 13:57:21 2007 -0700

    [DCCP]: Complete documentation of dccp_sock
    
    This fills in missing documentation for dccp_sock fields.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index e668cf531bab..fda2148d8c85 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -465,21 +465,20 @@ struct dccp_ackvec;
  * @dccps_service_list - second .. last service code on passive socket
  * @dccps_timestamp_time - time of latest TIMESTAMP option
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
- * @dccps_l_ack_ratio -
- * @dccps_r_ack_ratio -
+ * @dccps_l_ack_ratio - feature-local Ack Ratio
+ * @dccps_r_ack_ratio - feature-remote Ack Ratio
  * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
  * @dccps_pcrlen - receiver partial checksum coverage (via sockopt)
  * @dccps_ndp_count - number of Non Data Packets since last data packet
- * @dccps_mss_cache -
- * @dccps_minisock -
+ * @dccps_mss_cache - current value of MSS (path MTU minus header sizes)
+ * @dccps_minisock - associated minisock (accessed via dccp_msk)
  * @dccps_hc_rx_ackvec - rx half connection ack vector
- * @dccps_hc_rx_ccid -
- * @dccps_hc_tx_ccid -
- * @dccps_options_received -
- * @dccps_epoch -
- * @dccps_role - Role of this sock, one of %dccp_role
- * @dccps_hc_rx_insert_options -
- * @dccps_hc_tx_insert_options -
+ * @dccps_hc_rx_ccid - CCID used for the receiver (or receiving half-connection)
+ * @dccps_hc_tx_ccid - CCID used for the sender (or sending half-connection)
+ * @dccps_options_received - parsed set of retrieved options
+ * @dccps_role - role of this sock, one of %dccp_role
+ * @dccps_hc_rx_insert_options - receiver wants to add options when acking
+ * @dccps_hc_tx_insert_options - sender wants to add options when sending
  * @dccps_xmit_timer - timer for when CCID is not ready to send
  * @dccps_syn_rtt - RTT sample from Request/Response exchange (in usecs)
  */

commit 89560b53b92a07c529e13a462aa7fd87a844f1f5
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 15:27:17 2007 -0300

    [DCCP]: Sample RTT from SYN exchange
    
    Function:

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index fdd4217f1047..e668cf531bab 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -481,10 +481,12 @@ struct dccp_ackvec;
  * @dccps_hc_rx_insert_options -
  * @dccps_hc_tx_insert_options -
  * @dccps_xmit_timer - timer for when CCID is not ready to send
+ * @dccps_syn_rtt - RTT sample from Request/Response exchange (in usecs)
  */
 struct dccp_sock {
 	/* inet_connection_sock has to be the first member of dccp_sock */
 	struct inet_connection_sock	dccps_inet_connection;
+#define dccps_syn_rtt			dccps_inet_connection.icsk_ack.lrcvtime
 	__u64				dccps_swl;
 	__u64				dccps_swh;
 	__u64				dccps_awl;

commit 9c70220b73908f64792422a2c39c593c4792f2c5
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 25 18:04:18 2007 -0700

    [SK_BUFF]: Introduce skb_transport_header(skb)
    
    For the places where we need a pointer to the transport header, it is
    still legal to touch skb->h.raw directly if just adding to,
    subtracting from or setting it to another layer header.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 1f4df61735f7..fdd4217f1047 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -260,19 +260,20 @@ enum {
 
 static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)
 {
-	return (struct dccp_hdr *)skb->h.raw;
+	return (struct dccp_hdr *)skb_transport_header(skb);
 }
 
 static inline struct dccp_hdr *dccp_zeroed_hdr(struct sk_buff *skb, int headlen)
 {
 	skb_push(skb, headlen);
 	skb_reset_transport_header(skb);
-	return memset(skb->h.raw, 0, headlen);
+	return memset(skb_transport_header(skb), 0, headlen);
 }
 
 static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
 {
-	return (struct dccp_hdr_ext *)(skb->h.raw + sizeof(struct dccp_hdr));
+	return (struct dccp_hdr_ext *)(skb_transport_header(skb) +
+				       sizeof(struct dccp_hdr));
 }
 
 static inline unsigned int __dccp_basic_hdr_len(const struct dccp_hdr *dh)
@@ -301,12 +302,14 @@ static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
 
 static inline struct dccp_hdr_request *dccp_hdr_request(struct sk_buff *skb)
 {
-	return (struct dccp_hdr_request *)(skb->h.raw + dccp_basic_hdr_len(skb));
+	return (struct dccp_hdr_request *)(skb_transport_header(skb) +
+					   dccp_basic_hdr_len(skb));
 }
 
 static inline struct dccp_hdr_ack_bits *dccp_hdr_ack_bits(const struct sk_buff *skb)
 {
-	return (struct dccp_hdr_ack_bits *)(skb->h.raw + dccp_basic_hdr_len(skb));
+	return (struct dccp_hdr_ack_bits *)(skb_transport_header(skb) +
+					    dccp_basic_hdr_len(skb));
 }
 
 static inline u64 dccp_hdr_ack_seq(const struct sk_buff *skb)
@@ -317,12 +320,14 @@ static inline u64 dccp_hdr_ack_seq(const struct sk_buff *skb)
 
 static inline struct dccp_hdr_response *dccp_hdr_response(struct sk_buff *skb)
 {
-	return (struct dccp_hdr_response *)(skb->h.raw + dccp_basic_hdr_len(skb));
+	return (struct dccp_hdr_response *)(skb_transport_header(skb) +
+					    dccp_basic_hdr_len(skb));
 }
 
 static inline struct dccp_hdr_reset *dccp_hdr_reset(struct sk_buff *skb)
 {
-	return (struct dccp_hdr_reset *)(skb->h.raw + dccp_basic_hdr_len(skb));
+	return (struct dccp_hdr_reset *)(skb_transport_header(skb) +
+					 dccp_basic_hdr_len(skb));
 }
 
 static inline unsigned int __dccp_hdr_len(const struct dccp_hdr *dh)

commit badff6d01a8589a1c828b0bf118903ca38627f4e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 13 13:06:52 2007 -0300

    [SK_BUFF]: Introduce skb_reset_transport_header(skb)
    
    For the common, open coded 'skb->h.raw = skb->data' operation, so that we can
    later turn skb->h.raw into a offset, reducing the size of struct sk_buff in
    64bit land while possibly keeping it as a pointer on 32bit.
    
    This one touches just the most simple cases:
    
    skb->h.raw = skb->data;
    skb->h.raw = {skb_push|[__]skb_pull}()
    
    The next ones will handle the slightly more "complex" cases.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 1cb054bd93f2..1f4df61735f7 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -265,9 +265,9 @@ static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)
 
 static inline struct dccp_hdr *dccp_zeroed_hdr(struct sk_buff *skb, int headlen)
 {
-	skb->h.raw = skb_push(skb, headlen);
-	memset(skb->h.raw, 0, headlen);
-	return dccp_hdr(skb);
+	skb_push(skb, headlen);
+	skb_reset_transport_header(skb);
+	return memset(skb->h.raw, 0, headlen);
 }
 
 static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)

commit 8109b02b5397ed52a32c116163a62a34f4768b26
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Dec 10 16:01:18 2006 -0200

    [DCCP]: Whitespace cleanups
    
    That accumulated over the last months hackaton, shame on me for not
    using git-apply whitespace helping hand, will do that from now on.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index ed6cc8962d87..1cb054bd93f2 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -176,20 +176,20 @@ enum {
 };
 
 /* DCCP features (RFC 4340 section 6.4) */
- enum {
- 	DCCPF_RESERVED = 0,
- 	DCCPF_CCID = 1,
+enum {
+	DCCPF_RESERVED = 0,
+	DCCPF_CCID = 1,
 	DCCPF_SHORT_SEQNOS = 2,		/* XXX: not yet implemented */
- 	DCCPF_SEQUENCE_WINDOW = 3,
+	DCCPF_SEQUENCE_WINDOW = 3,
 	DCCPF_ECN_INCAPABLE = 4,	/* XXX: not yet implemented */
- 	DCCPF_ACK_RATIO = 5,
- 	DCCPF_SEND_ACK_VECTOR = 6,
- 	DCCPF_SEND_NDP_COUNT = 7,
+	DCCPF_ACK_RATIO = 5,
+	DCCPF_SEND_ACK_VECTOR = 6,
+	DCCPF_SEND_NDP_COUNT = 7,
 	DCCPF_MIN_CSUM_COVER = 8,
 	DCCPF_DATA_CHECKSUM = 9,	/* XXX: not yet implemented */
- 	/* 10-127 reserved */
- 	DCCPF_MIN_CCID_SPECIFIC = 128,
- 	DCCPF_MAX_CCID_SPECIFIC = 255,
+	/* 10-127 reserved */
+	DCCPF_MIN_CCID_SPECIFIC = 128,
+	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
 /* this structure is argument to DCCP_SOCKOPT_CHANGE_X */
@@ -427,7 +427,7 @@ struct dccp_service_list {
 };
 
 #define DCCP_SERVICE_INVALID_VALUE htonl((__u32)-1)
-#define DCCP_SERVICE_CODE_IS_ABSENT 		 0
+#define DCCP_SERVICE_CODE_IS_ABSENT		0
 
 static inline int dccp_list_has_service(const struct dccp_service_list *sl,
 					const __be32 service)
@@ -436,7 +436,7 @@ static inline int dccp_list_has_service(const struct dccp_service_list *sl,
 		u32 i = sl->dccpsl_nr;
 		while (i--)
 			if (sl->dccpsl_list[i] == service)
-				return 1; 
+				return 1;
 	}
 	return 0;
 }
@@ -511,7 +511,7 @@ struct dccp_sock {
 	__u8				dccps_hc_tx_insert_options:1;
 	struct timer_list		dccps_xmit_timer;
 };
- 
+
 static inline struct dccp_sock *dccp_sk(const struct sock *sk)
 {
 	return (struct dccp_sock *)sk;

commit 5aed324369c94a2c38469c8288e42eb1a9fac400
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 28 19:33:36 2006 -0200

    [DCCP]: Tidy up unused structures
    
    This removes and cleans up unused variables and structures which have become
    unnecessary following the introduction of the EWMA patch to automatically track
    the CCID 3 receiver/sender packet sizes `s'.
    
    It deprecates the PACKET_SIZE socket option by returning an error code and
    printing a deprecation warning if an application tries to read or write this
    socket option.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 72cc355d7a03..ed6cc8962d87 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -200,7 +200,7 @@ struct dccp_so_feat {
 };
 
 /* DCCP socket options */
-#define DCCP_SOCKOPT_PACKET_SIZE	1
+#define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
 #define DCCP_SOCKOPT_SERVICE		2
 #define DCCP_SOCKOPT_CHANGE_L		3
 #define DCCP_SOCKOPT_CHANGE_R		4
@@ -460,7 +460,6 @@ struct dccp_ackvec;
  * @dccps_service_list - second .. last service code on passive socket
  * @dccps_timestamp_time - time of latest TIMESTAMP option
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
- * @dccps_packet_size - Set thru setsockopt
  * @dccps_l_ack_ratio -
  * @dccps_r_ack_ratio -
  * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
@@ -495,7 +494,6 @@ struct dccp_sock {
 	struct dccp_service_list	*dccps_service_list;
 	struct timeval			dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
-	__u32				dccps_packet_size;
 	__u16				dccps_l_ack_ratio;
 	__u16				dccps_r_ack_ratio;
 	__u16				dccps_pcslen;

commit 9981a0e36a572e9fcf84bfab915fdc93bed0e3c9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 14 21:24:30 2006 -0800

    [NET]: Annotate checksums in on-the-wire packets.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index d308f1228b61..72cc355d7a03 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -30,7 +30,7 @@ struct dccp_hdr {
 #else
 #error  "Adjust your <asm/byteorder.h> defines"
 #endif
-	__u16	dccph_checksum;
+	__sum16	dccph_checksum;
 #if defined(__LITTLE_ENDIAN_BITFIELD)
 	__u8	dccph_x:1,
 		dccph_type:4,

commit 09dbc3895e3242346bd434dae743c456fd28fc6a
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 14 12:57:34 2006 -0200

    [DCCP]: Miscellaneous code tidy-ups
    
    This patch does not change code; it performs some trivial clean/tidy-ups:
    
      * removal of a `debug_prefix' string in favour of the
        already existing dccp_role(sk)
    
      * add documentation of structures and constants
    
      * separated out the cases for invalid packets (step 1
        of the packet validation)
    
      * removing duplicate statements
    
      * combining declaration & initialisation
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 696319ee2d5b..d308f1228b61 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -209,6 +209,7 @@ struct dccp_so_feat {
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
 #define DCCP_SOCKOPT_CCID_TX_INFO	192
 
+/* maximum number of services provided on the same listening port */
 #define DCCP_SERVICE_LIST_MAX_LEN      32
 
 #ifdef __KERNEL__
@@ -355,6 +356,9 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   * @dccpms_ccid - Congestion Control Id (CCID) (section 10)
   * @dccpms_send_ack_vector - Send Ack Vector Feature (section 11.5)
   * @dccpms_send_ndp_count - Send NDP Count Feature (7.7.2)
+  * @dccpms_ack_ratio - Ack Ratio Feature (section 11.3)
+  * @dccpms_pending - List of features being negotiated
+  * @dccpms_conf -
   */
 struct dccp_minisock {
 	__u64			dccpms_sequence_window;
@@ -452,14 +456,26 @@ struct dccp_ackvec;
  * @dccps_gss - greatest sequence number sent
  * @dccps_gsr - greatest valid sequence number received
  * @dccps_gar - greatest valid ack number received on a non-Sync; initialized to %dccps_iss
+ * @dccps_service - first (passive sock) or unique (active sock) service code
+ * @dccps_service_list - second .. last service code on passive socket
  * @dccps_timestamp_time - time of latest TIMESTAMP option
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
  * @dccps_packet_size - Set thru setsockopt
- * @dccps_role - Role of this sock, one of %dccp_role
+ * @dccps_l_ack_ratio -
+ * @dccps_r_ack_ratio -
  * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
  * @dccps_pcrlen - receiver partial checksum coverage (via sockopt)
  * @dccps_ndp_count - number of Non Data Packets since last data packet
+ * @dccps_mss_cache -
+ * @dccps_minisock -
  * @dccps_hc_rx_ackvec - rx half connection ack vector
+ * @dccps_hc_rx_ccid -
+ * @dccps_hc_tx_ccid -
+ * @dccps_options_received -
+ * @dccps_epoch -
+ * @dccps_role - Role of this sock, one of %dccp_role
+ * @dccps_hc_rx_insert_options -
+ * @dccps_hc_tx_insert_options -
  * @dccps_xmit_timer - timer for when CCID is not ready to send
  */
 struct dccp_sock {

commit c02fdc0e81e9c735d8d895af1e201b235df326d8
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 14 12:48:10 2006 -0200

    [DCCP]: Make feature negotiation more readable
    
    This patch replaces cryptic feature negotiation messages of type
    
    Oct 31 15:42:20 kernel: dccp_feat_change: feat change type=32 feat=1
    Oct 31 15:42:21 kernel: dccp_feat_change: feat change type=34 feat=1
    Oct 31 15:42:21 kernel: dccp_feat_change: feat change type=32 feat=5
    
    into ones of type:
    
    Nov  2 13:54:45 kernel: dccp_feat_change: ChangeL(CCID (1), 3)
    Nov  2 13:54:45 kernel: dccp_feat_change: ChangeR(CCID (1), 3)
    Nov  2 13:54:45 kernel: dccp_feat_change: ChangeL(Ack Ratio (5), 2)
    
    Also,
            * completed the feature number list wrt RFC 4340 sec. 6.4
            * annotating which ones have been implemented so far
            * implemented rudimentary sanity checking in feat.c (FIXMEs)
            * some minor fixes
    
    Commiter note: uninlined dccp_feat_name and dccp_feat_typename, for
                   consistency with dccp_{state,packet}_name, that, BTW,
                   should be compiled only if CONFIG_IP_DCCP_DEBUG is
                   selected, leaving this to another cset tho. Also
                   shortened dccp_feat_negotiation_debug to dccp_feat_debug.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 0502dfa7f32c..696319ee2d5b 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -175,18 +175,21 @@ enum {
 	DCCPC_CCID3 = 3,
 };
 
-/* DCCP features */
-enum {
-	DCCPF_RESERVED = 0,
-	DCCPF_CCID = 1,
-	DCCPF_SEQUENCE_WINDOW = 3,
-	DCCPF_ACK_RATIO = 5,
-	DCCPF_SEND_ACK_VECTOR = 6,
-	DCCPF_SEND_NDP_COUNT = 7,
+/* DCCP features (RFC 4340 section 6.4) */
+ enum {
+ 	DCCPF_RESERVED = 0,
+ 	DCCPF_CCID = 1,
+	DCCPF_SHORT_SEQNOS = 2,		/* XXX: not yet implemented */
+ 	DCCPF_SEQUENCE_WINDOW = 3,
+	DCCPF_ECN_INCAPABLE = 4,	/* XXX: not yet implemented */
+ 	DCCPF_ACK_RATIO = 5,
+ 	DCCPF_SEND_ACK_VECTOR = 6,
+ 	DCCPF_SEND_NDP_COUNT = 7,
 	DCCPF_MIN_CSUM_COVER = 8,
-	/* 10-127 reserved */
-	DCCPF_MIN_CCID_SPECIFIC = 128,
-	DCCPF_MAX_CCID_SPECIFIC = 255,
+	DCCPF_DATA_CHECKSUM = 9,	/* XXX: not yet implemented */
+ 	/* 10-127 reserved */
+ 	DCCPF_MIN_CCID_SPECIFIC = 128,
+ 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
 /* this structure is argument to DCCP_SOCKOPT_CHANGE_X */

commit 6f4e5fff1e4d46714ea554fd83e44eab534e8b11
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Nov 10 17:43:06 2006 -0200

    [DCCP]: Support for partial checksums (RFC 4340, sec. 9.2)
    
    This patch does the following:
      a) introduces variable-length checksums as specified in [RFC 4340, sec. 9.2]
      b) provides necessary socket options and documentation as to how to use them
      c) basic support and infrastructure for the Minimum Checksum Coverage feature
         [RFC 4340, sec. 9.2.1]: acceptability tests, user notification and user
         interface
    
    In addition, it
    
     (1) fixes two bugs in the DCCPv4 checksum computation:
            * pseudo-header used checksum_len instead of skb->len
            * incorrect checksum coverage calculation based on dccph_x
     (2) removes dccp_v4_verify_checksum() since it reduplicates code of the
         checksum computation; code calling this function is updated accordingly.
     (3) now uses skb_checksum(), which is safer than checksum_partial() if the
         sk_buff has is a non-linear buffer (has pages attached to it).
     (4) fixes an outstanding TODO item:
            * If P.CsCov is too large for the packet size, drop packet and return.
    
    The code has been tested with applications, the latest version of tcpdump now
    comes with support for partial DCCP checksums.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 90d04ffddae8..0502dfa7f32c 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -183,6 +183,7 @@ enum {
 	DCCPF_ACK_RATIO = 5,
 	DCCPF_SEND_ACK_VECTOR = 6,
 	DCCPF_SEND_NDP_COUNT = 7,
+	DCCPF_MIN_CSUM_COVER = 8,
 	/* 10-127 reserved */
 	DCCPF_MIN_CCID_SPECIFIC = 128,
 	DCCPF_MAX_CCID_SPECIFIC = 255,
@@ -200,6 +201,8 @@ struct dccp_so_feat {
 #define DCCP_SOCKOPT_SERVICE		2
 #define DCCP_SOCKOPT_CHANGE_L		3
 #define DCCP_SOCKOPT_CHANGE_R		4
+#define DCCP_SOCKOPT_SEND_CSCOV		10
+#define DCCP_SOCKOPT_RECV_CSCOV		11
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
 #define DCCP_SOCKOPT_CCID_TX_INFO	192
 
@@ -450,6 +453,8 @@ struct dccp_ackvec;
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
  * @dccps_packet_size - Set thru setsockopt
  * @dccps_role - Role of this sock, one of %dccp_role
+ * @dccps_pcslen - sender   partial checksum coverage (via sockopt)
+ * @dccps_pcrlen - receiver partial checksum coverage (via sockopt)
  * @dccps_ndp_count - number of Non Data Packets since last data packet
  * @dccps_hc_rx_ackvec - rx half connection ack vector
  * @dccps_xmit_timer - timer for when CCID is not ready to send
@@ -474,6 +479,8 @@ struct dccp_sock {
 	__u32				dccps_packet_size;
 	__u16				dccps_l_ack_ratio;
 	__u16				dccps_r_ack_ratio;
+	__u16				dccps_pcslen;
+	__u16				dccps_pcrlen;
 	unsigned long			dccps_ndp_count;
 	__u32				dccps_mss_cache;
 	struct dccp_minisock		dccps_minisock;

commit 9b42078ed6edfe04e9dc9a59b946ad912aeef717
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Nov 10 11:22:32 2006 -0200

    [DCCP]: Combine allocating & zeroing header space on skb
    
    This is a code simplification:
    it combines three often recurring operations into one inline function,
    
            * allocate `len' bytes header space in skb
            * fill these `len' bytes with zeroes
            * cast the start of this header space as dccp_hdr
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 53553c99cad6..90d04ffddae8 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -256,6 +256,13 @@ static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)
 	return (struct dccp_hdr *)skb->h.raw;
 }
 
+static inline struct dccp_hdr *dccp_zeroed_hdr(struct sk_buff *skb, int headlen)
+{
+	skb->h.raw = skb_push(skb, headlen);
+	memset(skb->h.raw, 0, headlen);
+	return dccp_hdr(skb);
+}
+
 static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
 {
 	return (struct dccp_hdr_ext *)(skb->h.raw + sizeof(struct dccp_hdr));

commit 1acc04cd4c0b54ada85d0dd5d7c5efc3441261bf
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Tue Oct 10 22:44:37 2006 +0100

    [PATCH] dccp __user annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index d6f4ec467a4b..53553c99cad6 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -191,7 +191,7 @@ enum {
 /* this structure is argument to DCCP_SOCKOPT_CHANGE_X */
 struct dccp_so_feat {
 	__u8 dccpsf_feat;
-	__u8 *dccpsf_val;
+	__u8 __user *dccpsf_val;
 	__u8 dccpsf_len;
 };
 

commit b83eff641ed39bd631535b9a8971e161b056f541
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Fri Sep 22 14:25:36 2006 +1200

    [DCCP]: Introduce constants for CCID numbers
    
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 29f9291e45c0..d6f4ec467a4b 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -169,6 +169,12 @@ enum {
 	DCCPO_MAX_CCID_SPECIFIC = 255,
 };
 
+/* DCCP CCIDS */
+enum {
+	DCCPC_CCID2 = 2,
+	DCCPC_CCID3 = 3,
+};
+
 /* DCCP features */
 enum {
 	DCCPF_RESERVED = 0,
@@ -320,7 +326,7 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 /* initial values for each feature */
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
 #define DCCPF_INITIAL_ACK_RATIO			2
-#define DCCPF_INITIAL_CCID			2
+#define DCCPF_INITIAL_CCID			DCCPC_CCID2
 #define DCCPF_INITIAL_SEND_ACK_VECTOR		1
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1

commit 00e4d116a7ef94eb910be037912b0b2fc09f608b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Sep 22 09:33:58 2006 +0100

    [DCCP]: Allow default/fallback service code.
    
    This has been discussed on dccp@vger and removes the necessity for applications
    to supply service codes in each and every case.
    
    If an application does not want to provide a service code, that's fine, it will
    be given 0. Otherwise, service codes can be set via socket options as before.
    
    This patch has been tested using various client/server configurations
    (including listening on multiple service codes).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 2d7671c92c0b..29f9291e45c0 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -404,6 +404,7 @@ struct dccp_service_list {
 };
 
 #define DCCP_SERVICE_INVALID_VALUE htonl((__u32)-1)
+#define DCCP_SERVICE_CODE_IS_ABSENT 		 0
 
 static inline int dccp_list_has_service(const struct dccp_service_list *sl,
 					const __be32 service)
@@ -484,11 +485,6 @@ static inline struct dccp_minisock *dccp_msk(const struct sock *sk)
 	return (struct dccp_minisock *)&dccp_sk(sk)->dccps_minisock;
 }
 
-static inline int dccp_service_not_initialized(const struct sock *sk)
-{
-	return dccp_sk(sk)->dccps_service == DCCP_SERVICE_INVALID_VALUE;
-}
-
 static inline const char *dccp_role(const struct sock *sk)
 {
 	switch (dccp_sk(sk)->dccps_role) {

commit 97e5848dd39e7e76bd6077735ebb5473763ab9c5
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Sat Aug 26 19:16:45 2006 -0700

    [DCCP]: Introduce tx buffering
    
    This adds transmit buffering to DCCP.
    
    I have tested with CCID2/3 and with loss and rate limiting.
    
    Signed off by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 676333b9fad0..2d7671c92c0b 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -438,6 +438,7 @@ struct dccp_ackvec;
  * @dccps_role - Role of this sock, one of %dccp_role
  * @dccps_ndp_count - number of Non Data Packets since last data packet
  * @dccps_hc_rx_ackvec - rx half connection ack vector
+ * @dccps_xmit_timer - timer for when CCID is not ready to send
  */
 struct dccp_sock {
 	/* inet_connection_sock has to be the first member of dccp_sock */
@@ -470,6 +471,7 @@ struct dccp_sock {
 	enum dccp_role			dccps_role:2;
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;
+	struct timer_list		dccps_xmit_timer;
 };
  
 static inline struct dccp_sock *dccp_sk(const struct sock *sk)

commit a4bf3902427a128455b8de299ff0918072b2e974
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 22:50:58 2006 -0800

    [DCCP] minisock: Rename struct dccp_options to struct dccp_minisock
    
    This will later be included in struct dccp_request_sock so that we can
    have per connection feature negotiation state while in the 3way
    handshake, when we clone the DCCP_ROLE_LISTEN socket (in
    dccp_create_openreq_child) we'll just copy this state from
    dreq_minisock to dccps_minisock.
    
    Also the feature negotiation and option parsing code will mostly touch
    dccps_minisock, which will simplify some stuff.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index e35f680f909b..676333b9fad0 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -328,21 +328,24 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 #define DCCP_NDP_LIMIT 0xFFFFFF
 
 /**
-  * struct dccp_options - option values for a DCCP connection
-  *	@dccpo_sequence_window - Sequence Window Feature (section 7.5.2)
-  *	@dccpo_ccid - Congestion Control Id (CCID) (section 10)
-  *	@dccpo_send_ack_vector - Send Ack Vector Feature (section 11.5)
-  *	@dccpo_send_ndp_count - Send NDP Count Feature (7.7.2)
+  * struct dccp_minisock - Minimal DCCP connection representation
+  *
+  * Will be used to pass the state from dccp_request_sock to dccp_sock.
+  *
+  * @dccpms_sequence_window - Sequence Window Feature (section 7.5.2)
+  * @dccpms_ccid - Congestion Control Id (CCID) (section 10)
+  * @dccpms_send_ack_vector - Send Ack Vector Feature (section 11.5)
+  * @dccpms_send_ndp_count - Send NDP Count Feature (7.7.2)
   */
-struct dccp_options {
-	__u64	dccpo_sequence_window;
-	__u8	dccpo_rx_ccid;
-	__u8	dccpo_tx_ccid;
-	__u8	dccpo_send_ack_vector;
-	__u8	dccpo_send_ndp_count;
-	__u8			dccpo_ack_ratio;
-	struct list_head	dccpo_pending;
-	struct list_head	dccpo_conf;
+struct dccp_minisock {
+	__u64			dccpms_sequence_window;
+	__u8			dccpms_rx_ccid;
+	__u8			dccpms_tx_ccid;
+	__u8			dccpms_send_ack_vector;
+	__u8			dccpms_send_ndp_count;
+	__u8			dccpms_ack_ratio;
+	struct list_head	dccpms_pending;
+	struct list_head	dccpms_conf;
 };
 
 struct dccp_opt_conf {
@@ -360,8 +363,9 @@ struct dccp_opt_pend {
 	struct dccp_opt_conf    *dccpop_sc;
 };
 
-extern void __dccp_options_init(struct dccp_options *dccpo);
-extern void dccp_options_init(struct dccp_options *dccpo);
+extern void __dccp_minisock_init(struct dccp_minisock *dmsk);
+extern void dccp_minisock_init(struct dccp_minisock *dmsk);
+
 extern int dccp_parse_options(struct sock *sk, struct sk_buff *skb);
 
 struct dccp_request_sock {
@@ -457,7 +461,7 @@ struct dccp_sock {
 	__u16				dccps_r_ack_ratio;
 	unsigned long			dccps_ndp_count;
 	__u32				dccps_mss_cache;
-	struct dccp_options		dccps_options;
+	struct dccp_minisock		dccps_minisock;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;
 	struct ccid			*dccps_hc_rx_ccid;
 	struct ccid			*dccps_hc_tx_ccid;
@@ -473,6 +477,11 @@ static inline struct dccp_sock *dccp_sk(const struct sock *sk)
 	return (struct dccp_sock *)sk;
 }
 
+static inline struct dccp_minisock *dccp_msk(const struct sock *sk)
+{
+	return (struct dccp_minisock *)&dccp_sk(sk)->dccps_minisock;
+}
+
 static inline int dccp_service_not_initialized(const struct sock *sk)
 {
 	return dccp_sk(sk)->dccps_service == DCCP_SERVICE_INVALID_VALUE;

commit 93ce20928f6e197707add8f670ae0cd029107e8f
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 19:23:58 2006 -0800

    [DCCP]: Make CCID2 be the default
    
    As per the draft. This fixes the build when netfilter dccp components
    are built and dccp isn't. Thanks to Reuben Farrelly for reporting
    this.
    
    The following changesets will introduce /proc/sys/net/dccp/defaults/
    to give more flexibility to DCCP developers and testers while apps
    doesn't use setsockopt to specify the desired CCID, etc.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 496dbad8e896..e35f680f909b 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -320,17 +320,8 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 /* initial values for each feature */
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
 #define DCCPF_INITIAL_ACK_RATIO			2
-
-#if defined(CONFIG_IP_DCCP_CCID2) || defined(CONFIG_IP_DCCP_CCID2_MODULE)
 #define DCCPF_INITIAL_CCID			2
 #define DCCPF_INITIAL_SEND_ACK_VECTOR		1
-#elif defined(CONFIG_IP_DCCP_CCID3) || defined(CONFIG_IP_DCCP_CCID3_MODULE)
-#define DCCPF_INITIAL_CCID			3
-#define DCCPF_INITIAL_SEND_ACK_VECTOR		0
-#else
-#error  "At least one CCID must be built as the default"
-#endif
-
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
 

commit 60fe62e789076ae7c13f7ffb35fec4b24802530d
Author: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
Date:   Mon Mar 20 19:23:32 2006 -0800

    [DCCP]: sparse endianness annotations
    
    This also fixes the layout of dccp_hdr short sequence numbers, problem
    was not fatal now as we only support long (48 bits) sequence numbers.
    
    Signed-off-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index bdd756cc60b1..496dbad8e896 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -18,7 +18,7 @@
  * @dccph_seq - sequence number high or low order 24 bits, depends on dccph_x
  */
 struct dccp_hdr {
-	__u16	dccph_sport,
+	__be16	dccph_sport,
 		dccph_dport;
 	__u8	dccph_doff;
 #if defined(__LITTLE_ENDIAN_BITFIELD)
@@ -32,18 +32,18 @@ struct dccp_hdr {
 #endif
 	__u16	dccph_checksum;
 #if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u32	dccph_x:1,
+	__u8	dccph_x:1,
 		dccph_type:4,
-		dccph_reserved:3,
-		dccph_seq:24;
+		dccph_reserved:3;
 #elif defined(__BIG_ENDIAN_BITFIELD)
-	__u32	dccph_reserved:3,
+	__u8	dccph_reserved:3,
 		dccph_type:4,
-		dccph_x:1,
-		dccph_seq:24;
+		dccph_x:1;
 #else
 #error  "Adjust your <asm/byteorder.h> defines"
 #endif
+	__u8	dccph_seq2;
+	__be16	dccph_seq;
 };
 
 /**
@@ -52,7 +52,7 @@ struct dccp_hdr {
  * @dccph_seq_low - low 24 bits of a 48 bit seq packet
  */
 struct dccp_hdr_ext {
-	__u32	dccph_seq_low;
+	__be32	dccph_seq_low;
 };
 
 /**
@@ -62,7 +62,7 @@ struct dccp_hdr_ext {
  * @dccph_req_options - list of options (must be a multiple of 32 bits
  */
 struct dccp_hdr_request {
-	__u32	dccph_req_service;
+	__be32	dccph_req_service;
 };
 /**
  * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
@@ -71,9 +71,9 @@ struct dccp_hdr_request {
  * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
  */
 struct dccp_hdr_ack_bits {
-	__u32	dccph_reserved1:8,
-		dccph_ack_nr_high:24;
-	__u32	dccph_ack_nr_low;
+	__be16	dccph_reserved1;
+	__be16	dccph_ack_nr_high;
+	__be32	dccph_ack_nr_low;
 };
 /**
  * struct dccp_hdr_response - Conection initiation response header
@@ -85,7 +85,7 @@ struct dccp_hdr_ack_bits {
  */
 struct dccp_hdr_response {
 	struct dccp_hdr_ack_bits	dccph_resp_ack;
-	__u32				dccph_resp_service;
+	__be32				dccph_resp_service;
 };
 
 /**
@@ -269,16 +269,12 @@ static inline unsigned int dccp_basic_hdr_len(const struct sk_buff *skb)
 static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
 {
 	const struct dccp_hdr *dh = dccp_hdr(skb);
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u64 seq_nr = ntohl(dh->dccph_seq << 8);
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	__u64 seq_nr = ntohl(dh->dccph_seq);
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
+	__u64 seq_nr =  ntohs(dh->dccph_seq);
 
 	if (dh->dccph_x != 0)
 		seq_nr = (seq_nr << 32) + ntohl(dccp_hdrx(skb)->dccph_seq_low);
+	else
+		seq_nr += (u32)dh->dccph_seq2 << 16;
 
 	return seq_nr;
 }
@@ -296,13 +292,7 @@ static inline struct dccp_hdr_ack_bits *dccp_hdr_ack_bits(const struct sk_buff *
 static inline u64 dccp_hdr_ack_seq(const struct sk_buff *skb)
 {
 	const struct dccp_hdr_ack_bits *dhack = dccp_hdr_ack_bits(skb);
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	return (((u64)ntohl(dhack->dccph_ack_nr_high << 8)) << 32) + ntohl(dhack->dccph_ack_nr_low);
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	return (((u64)ntohl(dhack->dccph_ack_nr_high)) << 32) + ntohl(dhack->dccph_ack_nr_low);
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
+	return ((u64)ntohs(dhack->dccph_ack_nr_high) << 32) + ntohl(dhack->dccph_ack_nr_low);
 }
 
 static inline struct dccp_hdr_response *dccp_hdr_response(struct sk_buff *skb)
@@ -387,7 +377,7 @@ struct dccp_request_sock {
 	struct inet_request_sock dreq_inet_rsk;
 	__u64			 dreq_iss;
 	__u64			 dreq_isr;
-	__u32			 dreq_service;
+	__be32			 dreq_service;
 };
 
 static inline struct dccp_request_sock *dccp_rsk(const struct request_sock *req)
@@ -415,13 +405,13 @@ enum dccp_role {
 
 struct dccp_service_list {
 	__u32	dccpsl_nr;
-	__u32	dccpsl_list[0];
+	__be32	dccpsl_list[0];
 };
 
 #define DCCP_SERVICE_INVALID_VALUE htonl((__u32)-1)
 
 static inline int dccp_list_has_service(const struct dccp_service_list *sl,
-					const u32 service)
+					const __be32 service)
 {
 	if (likely(sl != NULL)) {
 		u32 i = sl->dccpsl_nr;
@@ -467,7 +457,7 @@ struct dccp_sock {
 	__u64				dccps_gss;
 	__u64				dccps_gsr;
 	__u64				dccps_gar;
-	__u32				dccps_service;
+	__be32				dccps_service;
 	struct dccp_service_list	*dccps_service_list;
 	struct timeval			dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;

commit 91f0ebf7b6d5cb2b6e818d48587566144821babe
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 19:21:44 2006 -0800

    [DCCP] CCID: Improve CCID infrastructure
    
    1. No need for ->ccid_init nor ->ccid_exit, this is what module_{init,exit}
       does and anynways neither ccid2 nor ccid3 were using it.
    
    2. Rename struct ccid to struct ccid_operations and introduce struct ccid
       with a pointer to ccid_operations and rigth after it the rx or tx
       private state.
    
    3. Remove the pointer to the state of the half connections from struct
       dccp_sock, now its derived thru ccid_priv() from the ccid pointer.
    
    Now we also can implement the setsockopt for changing the CCID easily as
    no ccid init routines can affect struct dccp_sock in any way that prevents
    other CCIDs from working if a CCID switch operation is asked by apps.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index a70d1a27e7fc..bdd756cc60b1 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -478,8 +478,6 @@ struct dccp_sock {
 	__u32				dccps_mss_cache;
 	struct dccp_options		dccps_options;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;
-	void				*dccps_hc_rx_ccid_private;
-	void				*dccps_hc_tx_ccid_private;
 	struct ccid			*dccps_hc_rx_ccid;
 	struct ccid			*dccps_hc_tx_ccid;
 	struct dccp_options_received	dccps_options_received;

commit ba66c6e8b292997467128506f39fa6607e959050
Author: Ian McDonald <imcdnzl@gmail.com>
Date:   Mon Mar 20 17:56:56 2006 -0800

    [DCCP]: Set the default CCID according to kernel config selection
    
    Now CCID2 is the default, as stated in the RFC drafts, but we allow
    a config where just CCID3 is built, where CCID3 becomes the default.
    
    Signed-off-by: Ian McDonald <imcdnzl@gmail.com>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index f91c8a62406d..a70d1a27e7fc 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -329,9 +329,18 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 
 /* initial values for each feature */
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
-#define DCCPF_INITIAL_CCID			2
 #define DCCPF_INITIAL_ACK_RATIO			2
+
+#if defined(CONFIG_IP_DCCP_CCID2) || defined(CONFIG_IP_DCCP_CCID2_MODULE)
+#define DCCPF_INITIAL_CCID			2
 #define DCCPF_INITIAL_SEND_ACK_VECTOR		1
+#elif defined(CONFIG_IP_DCCP_CCID3) || defined(CONFIG_IP_DCCP_CCID3_MODULE)
+#define DCCPF_INITIAL_CCID			3
+#define DCCPF_INITIAL_SEND_ACK_VECTOR		0
+#else
+#error  "At least one CCID must be built as the default"
+#endif
+
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
 

commit afe00251dd9b53d51de91ff0099961f42bbf3754
Author: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
Date:   Mon Mar 20 17:43:56 2006 -0800

    [DCCP]: Initial feature negotiation implementation
    
    Still needs more work, but boots and doesn't crashes, even
    does some negotiation!
    
    18:38:52.174934  127.0.0.1.43458 > 127.0.0.1.5001: request <change_l ack_ratio 2, change_r ccid 2, change_l ccid 2>
    18:38:52.218526  127.0.0.1.5001 > 127.0.0.1.43458: response <nop, nop, change_l ack_ratio 2, confirm_r ccid 2 2, confirm_l ccid 2 2, confirm_r ack_ratio 2>
    18:38:52.185398  127.0.0.1.43458 > 127.0.0.1.5001: <nop, confirm_r ack_ratio 2, ack_vector0 0x00, elapsed_time 212>
    
    :-)
    
    Signed-off-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 268b4579d7e5..f91c8a62406d 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -154,6 +154,10 @@ enum {
 	DCCPO_MANDATORY = 1,
 	DCCPO_MIN_RESERVED = 3,
 	DCCPO_MAX_RESERVED = 31,
+	DCCPO_CHANGE_L = 32,
+	DCCPO_CONFIRM_L = 33,
+	DCCPO_CHANGE_R = 34,
+	DCCPO_CONFIRM_R = 35,
 	DCCPO_NDP_COUNT = 37,
 	DCCPO_ACK_VECTOR_0 = 38,
 	DCCPO_ACK_VECTOR_1 = 39,
@@ -168,7 +172,9 @@ enum {
 /* DCCP features */
 enum {
 	DCCPF_RESERVED = 0,
+	DCCPF_CCID = 1,
 	DCCPF_SEQUENCE_WINDOW = 3,
+	DCCPF_ACK_RATIO = 5,
 	DCCPF_SEND_ACK_VECTOR = 6,
 	DCCPF_SEND_NDP_COUNT = 7,
 	/* 10-127 reserved */
@@ -176,9 +182,18 @@ enum {
 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
+/* this structure is argument to DCCP_SOCKOPT_CHANGE_X */
+struct dccp_so_feat {
+	__u8 dccpsf_feat;
+	__u8 *dccpsf_val;
+	__u8 dccpsf_len;
+};
+
 /* DCCP socket options */
 #define DCCP_SOCKOPT_PACKET_SIZE	1
 #define DCCP_SOCKOPT_SERVICE		2
+#define DCCP_SOCKOPT_CHANGE_L		3
+#define DCCP_SOCKOPT_CHANGE_R		4
 #define DCCP_SOCKOPT_CCID_RX_INFO	128
 #define DCCP_SOCKOPT_CCID_TX_INFO	192
 
@@ -314,8 +329,8 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 
 /* initial values for each feature */
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
-/* FIXME: for now we're using CCID 2 (TCP-Like) */
 #define DCCPF_INITIAL_CCID			2
+#define DCCPF_INITIAL_ACK_RATIO			2
 #define DCCPF_INITIAL_SEND_ACK_VECTOR		1
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
@@ -335,6 +350,24 @@ struct dccp_options {
 	__u8	dccpo_tx_ccid;
 	__u8	dccpo_send_ack_vector;
 	__u8	dccpo_send_ndp_count;
+	__u8			dccpo_ack_ratio;
+	struct list_head	dccpo_pending;
+	struct list_head	dccpo_conf;
+};
+
+struct dccp_opt_conf {
+	__u8			*dccpoc_val;
+	__u8			dccpoc_len;
+};
+
+struct dccp_opt_pend {
+	struct list_head	dccpop_node;
+	__u8			dccpop_type;
+	__u8			dccpop_feat;
+	__u8		        *dccpop_val;
+	__u8			dccpop_len;
+	int			dccpop_conf;
+	struct dccp_opt_conf    *dccpop_sc;
 };
 
 extern void __dccp_options_init(struct dccp_options *dccpo);

commit 2a91aa3967398fb94eccc8da67c82bce9f67afdf
Author: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
Date:   Mon Mar 20 17:41:47 2006 -0800

    [DCCP] CCID2: Initial CCID2 (TCP-Like) implementation
    
    Original work by Andrea Bittau, Arnaldo Melo cleaned up and fixed several
    issues on the merge process.
    
    For now CCID2 was turned the default for all SOCK_DCCP connections, but this
    will be remedied soon with the merge of the feature negotiation code.
    
    Signed-off-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 088529f54965..268b4579d7e5 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -314,9 +314,9 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 
 /* initial values for each feature */
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
-/* FIXME: for now we're using CCID 3 (TFRC) */
-#define DCCPF_INITIAL_CCID			3
-#define DCCPF_INITIAL_SEND_ACK_VECTOR		0
+/* FIXME: for now we're using CCID 2 (TCP-Like) */
+#define DCCPF_INITIAL_CCID			2
+#define DCCPF_INITIAL_SEND_ACK_VECTOR		1
 /* FIXME: for now we're default to 1 but it should really be 0 */
 #define DCCPF_INITIAL_SEND_NDP_COUNT		1
 
@@ -430,6 +430,8 @@ struct dccp_sock {
 	struct timeval			dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
 	__u32				dccps_packet_size;
+	__u16				dccps_l_ack_ratio;
+	__u16				dccps_r_ack_ratio;
 	unsigned long			dccps_ndp_count;
 	__u32				dccps_mss_cache;
 	struct dccp_options		dccps_options;

commit 14c850212ed8f8cbb5972ad6b8812e08a0bc901c
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Dec 27 02:43:12 2005 -0200

    [INET_SOCK]: Move struct inet_sock & helper functions to net/inet_sock.h
    
    To help in reducing the number of include dependencies, several files were
    touched as they were getting needed headers indirectly for stuff they use.
    
    Thanks also to Alan Menegotto for pointing out that net/dccp/proto.c had
    linux/dccp.h include twice.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index d0bdb499cf8d..088529f54965 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -192,10 +192,9 @@ enum {
 #include <linux/workqueue.h>
 
 #include <net/inet_connection_sock.h>
+#include <net/inet_sock.h>
 #include <net/inet_timewait_sock.h>
-#include <net/sock.h>
 #include <net/tcp_states.h>
-#include <net/tcp.h>
 
 enum dccp_state {
 	DCCP_OPEN	= TCP_ESTABLISHED,

commit d83d8461f902c672bc1bd8fbc6a94e19f092da97
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Dec 13 23:26:10 2005 -0800

    [IP_SOCKGLUE]: Remove most of the tcp specific calls
    
    As DCCP needs to be called in the same spots.
    
    Now we have a member in inet_sock (is_icsk), set at sock creation time from
    struct inet_protosw->flags (if INET_PROTOSW_ICSK is set, like for TCP and
    DCCP) to see if a struct sock instance is a inet_connection_sock for places
    like the ones in ip_sockglue.c (v4 and v6) where we previously were looking if
    sk_type was SOCK_STREAM, that is insufficient because we now use the same code
    for DCCP, that has sk_type SOCK_DCCP.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 71fab4311e92..d0bdb499cf8d 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -408,8 +408,6 @@ struct dccp_ackvec;
  * @dccps_gar - greatest valid ack number received on a non-Sync; initialized to %dccps_iss
  * @dccps_timestamp_time - time of latest TIMESTAMP option
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
- * @dccps_ext_header_len - network protocol overhead (IP/IPv6 options)
- * @dccps_pmtu_cookie - Last pmtu seen by socket
  * @dccps_packet_size - Set thru setsockopt
  * @dccps_role - Role of this sock, one of %dccp_role
  * @dccps_ndp_count - number of Non Data Packets since last data packet
@@ -434,8 +432,6 @@ struct dccp_sock {
 	__u32				dccps_timestamp_echo;
 	__u32				dccps_packet_size;
 	unsigned long			dccps_ndp_count;
-	__u16				dccps_ext_header_len;
-	__u32				dccps_pmtu_cookie;
 	__u32				dccps_mss_cache;
 	struct dccp_options		dccps_options;
 	struct dccp_ackvec		*dccps_hc_rx_ackvec;

commit 88f964db6ef728982734356bf4c406270ea29c1d
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Sep 18 00:19:32 2005 -0700

    [DCCP]: Introduce CCID getsockopt for the CCIDs
    
    Allocation for the optnames is similar to the DCCP options, with a
    range for rx and tx half connection CCIDs.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 13f9b78483fc..71fab4311e92 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -179,6 +179,8 @@ enum {
 /* DCCP socket options */
 #define DCCP_SOCKOPT_PACKET_SIZE	1
 #define DCCP_SOCKOPT_SERVICE		2
+#define DCCP_SOCKOPT_CCID_RX_INFO	128
+#define DCCP_SOCKOPT_CCID_TX_INFO	192
 
 #define DCCP_SERVICE_LIST_MAX_LEN      32
 

commit 561713cf475de1f671cc89c437927ec008a20209
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Sep 18 00:18:52 2005 -0700

    [DCCP]: Don't use necessarily the same CCID for tx and rx
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 8c8e029095a5..13f9b78483fc 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -330,7 +330,8 @@ static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
   */
 struct dccp_options {
 	__u64	dccpo_sequence_window;
-	__u8	dccpo_ccid;
+	__u8	dccpo_rx_ccid;
+	__u8	dccpo_tx_ccid;
 	__u8	dccpo_send_ack_vector;
 	__u8	dccpo_send_ndp_count;
 };

commit ae31c3399d17b1f7bc1742724f70476b5417744f
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Sep 18 00:17:51 2005 -0700

    [DCCP]: Move the ack vector code to net/dccp/ackvec.[ch]
    
    Isolating it, that will be used when we introduce a CCID2 (TCP-Like)
    implementation.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 0e72708677e4..8c8e029095a5 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -353,14 +353,8 @@ static inline struct dccp_request_sock *dccp_rsk(const struct request_sock *req)
 
 extern struct inet_timewait_death_row dccp_death_row;
 
-/* Read about the ECN nonce to see why it is 253 */
-#define DCCP_MAX_ACK_VECTOR_LEN 253
-
 struct dccp_options_received {
-	u32	dccpor_ndp:24,
-		dccpor_ack_vector_len:8;
-	u32	dccpor_ack_vector_idx:10;
-	/* 22 bits hole, try to pack */
+	u32	dccpor_ndp; /* only 24 bits */
 	u32	dccpor_timestamp;
 	u32	dccpor_timestamp_echo;
 	u32	dccpor_elapsed_time;
@@ -394,6 +388,8 @@ static inline int dccp_list_has_service(const struct dccp_service_list *sl,
 	return 0;
 }
 
+struct dccp_ackvec;
+
 /**
  * struct dccp_sock - DCCP socket state
  *
@@ -414,7 +410,7 @@ static inline int dccp_list_has_service(const struct dccp_service_list *sl,
  * @dccps_packet_size - Set thru setsockopt
  * @dccps_role - Role of this sock, one of %dccp_role
  * @dccps_ndp_count - number of Non Data Packets since last data packet
- * @dccps_hc_rx_ackpkts - receiver half connection acked packets
+ * @dccps_hc_rx_ackvec - rx half connection ack vector
  */
 struct dccp_sock {
 	/* inet_connection_sock has to be the first member of dccp_sock */
@@ -439,7 +435,7 @@ struct dccp_sock {
 	__u32				dccps_pmtu_cookie;
 	__u32				dccps_mss_cache;
 	struct dccp_options		dccps_options;
-	struct dccp_ackpkts		*dccps_hc_rx_ackpkts;
+	struct dccp_ackvec		*dccps_hc_rx_ackvec;
 	void				*dccps_hc_rx_ccid_private;
 	void				*dccps_hc_tx_ccid_private;
 	struct ccid			*dccps_hc_rx_ccid;

commit 67e6b629212fa9ffb7420e8a88a41806af637e28
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Sep 16 16:58:40 2005 -0700

    [DCCP]: Introduce DCCP_SOCKOPT_SERVICE
    
    As discussed in the dccp@vger mailing list:
    
    Now applications have to use setsockopt(DCCP_SOCKOPT_SERVICE, service[s]),
    prior to calling listen() and connect().
    
    An array of unsigned ints can be passed meaning that the listening sock accepts
    connection requests for several services.
    
    With this we can ditch struct sockaddr_dccp and use only sockaddr_in (and
    sockaddr_in6 in the future).
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 8bf4bacb5051..0e72708677e4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -4,16 +4,6 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 
-/* Structure describing an Internet (DCCP) socket address. */
-struct sockaddr_dccp {
-	__u16	sdccp_family;	/* Address family   */
-	__u16	sdccp_port;	/* Port number	    */
-	__u32	sdccp_addr;	/* Internet address */
-	__u32	sdccp_service;	/* Service	    */
-	/* Pad to size of `struct sockaddr': 16 bytes . */
-	__u32	sdccp_pad;
-};
-
 /**
  * struct dccp_hdr - generic part of DCCP packet header
  *
@@ -188,6 +178,9 @@ enum {
 
 /* DCCP socket options */
 #define DCCP_SOCKOPT_PACKET_SIZE	1
+#define DCCP_SOCKOPT_SERVICE		2
+
+#define DCCP_SERVICE_LIST_MAX_LEN      32
 
 #ifdef __KERNEL__
 
@@ -382,6 +375,25 @@ enum dccp_role {
 	DCCP_ROLE_SERVER,
 };
 
+struct dccp_service_list {
+	__u32	dccpsl_nr;
+	__u32	dccpsl_list[0];
+};
+
+#define DCCP_SERVICE_INVALID_VALUE htonl((__u32)-1)
+
+static inline int dccp_list_has_service(const struct dccp_service_list *sl,
+					const u32 service)
+{
+	if (likely(sl != NULL)) {
+		u32 i = sl->dccpsl_nr;
+		while (i--)
+			if (sl->dccpsl_list[i] == service)
+				return 1; 
+	}
+	return 0;
+}
+
 /**
  * struct dccp_sock - DCCP socket state
  *
@@ -417,7 +429,8 @@ struct dccp_sock {
 	__u64				dccps_gss;
 	__u64				dccps_gsr;
 	__u64				dccps_gar;
-	unsigned long			dccps_service;
+	__u32				dccps_service;
+	struct dccp_service_list	*dccps_service_list;
 	struct timeval			dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
 	__u32				dccps_packet_size;
@@ -443,6 +456,11 @@ static inline struct dccp_sock *dccp_sk(const struct sock *sk)
 	return (struct dccp_sock *)sk;
 }
 
+static inline int dccp_service_not_initialized(const struct sock *sk)
+{
+	return dccp_sk(sk)->dccps_service == DCCP_SERVICE_INVALID_VALUE;
+}
+
 static inline const char *dccp_role(const struct sock *sk)
 {
 	switch (dccp_sk(sk)->dccps_role) {

commit b0e567806d16586629468c824dfb2e71155df7da
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Sep 9 02:38:35 2005 -0300

    [DCCP] Introduce dccp_timestamp
    
    To start the timestamps with 0.0ms, easing the integer maths in the CCIDs, this
    probably will be reworked to use the to be introduced struct timeval_offset
    infrastructure out of skb_get_timestamp, etc.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 5e0af0d08a93..8bf4bacb5051 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -432,6 +432,7 @@ struct dccp_sock {
 	struct ccid			*dccps_hc_rx_ccid;
 	struct ccid			*dccps_hc_tx_ccid;
 	struct dccp_options_received	dccps_options_received;
+	struct timeval			dccps_epoch;
 	enum dccp_role			dccps_role:2;
 	__u8				dccps_hc_rx_insert_options:1;
 	__u8				dccps_hc_tx_insert_options:1;

commit 507d37cf269ebbd1b32bcc435fe577e411f73151
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Sep 9 02:30:07 2005 -0300

    [CCID] Only call the HC insert_options methods when requested
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 007c290f74d4..5e0af0d08a93 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -433,6 +433,8 @@ struct dccp_sock {
 	struct ccid			*dccps_hc_tx_ccid;
 	struct dccp_options_received	dccps_options_received;
 	enum dccp_role			dccps_role:2;
+	__u8				dccps_hc_rx_insert_options:1;
+	__u8				dccps_hc_tx_insert_options:1;
 };
  
 static inline struct dccp_sock *dccp_sk(const struct sock *sk)

commit a84ffe430342db6ee585a5038f3242a6b4112d69
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Aug 28 04:51:32 2005 -0300

    [DCCP]: Introduce DCCP_SOCKOPT_PACKET_SIZE
    
    So that applications can set dccp_sock->dccps_pkt_size, that in turn
    is used in the CCID3 half connection init routines to set
    ccid3hc[tr]x_s and use it in its rate calculations.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 9e3a1370b906..007c290f74d4 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -186,6 +186,9 @@ enum {
 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
+/* DCCP socket options */
+#define DCCP_SOCKOPT_PACKET_SIZE	1
+
 #ifdef __KERNEL__
 
 #include <linux/in.h>
@@ -396,7 +399,7 @@ enum dccp_role {
  * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
  * @dccps_ext_header_len - network protocol overhead (IP/IPv6 options)
  * @dccps_pmtu_cookie - Last pmtu seen by socket
- * @dccps_avg_packet_size - FIXME: has to be set by the app thru some setsockopt or ioctl, CCID3 uses it
+ * @dccps_packet_size - Set thru setsockopt
  * @dccps_role - Role of this sock, one of %dccp_role
  * @dccps_ndp_count - number of Non Data Packets since last data packet
  * @dccps_hc_rx_ackpkts - receiver half connection acked packets
@@ -417,7 +420,7 @@ struct dccp_sock {
 	unsigned long			dccps_service;
 	struct timeval			dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
-	__u32				dccps_avg_packet_size;
+	__u32				dccps_packet_size;
 	unsigned long			dccps_ndp_count;
 	__u16				dccps_ext_header_len;
 	__u32				dccps_pmtu_cookie;

commit 1bc0986957b63a2fbbc46ab95d3d1d72830bda83
Author: Ian McDonald <iam4@cs.waikato.ac.nz>
Date:   Sat Aug 20 00:23:43 2005 -0300

    [DCCP]: Fix the timestamp options
    
    This changes timestamp, timestamp echo, and elapsed time to use units of 10
    usecs as per DCCP spec. This has been tested to verify that times are correct.
    Also fixed up length and used hton/ntoh more.
    
    Still to add in later patches:
    - actually use elapsed time to adjust RTT
    (commented out as was prior to this patch)
    - send options at times more closely following the spec
    (content is now correct)
    
    Signed-off-by: Ian McDonald <iam4@cs.waikato.ac.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 3dccdd5108b5..9e3a1370b906 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -415,7 +415,7 @@ struct dccp_sock {
 	__u64				dccps_gsr;
 	__u64				dccps_gar;
 	unsigned long			dccps_service;
-	unsigned long			dccps_timestamp_time;
+	struct timeval			dccps_timestamp_time;
 	__u32				dccps_timestamp_echo;
 	__u32				dccps_avg_packet_size;
 	unsigned long			dccps_ndp_count;

commit 64cf1e5d8b5f88d56509260e08fa0d8314277350
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 9 20:45:21 2005 -0700

    [DCCP]: Finish the TIMEWAIT minisock support
    
    Using most of the infrastructure TCP uses, with a dccp_death_row,
    etc. As per my current interpretation of the draft what we have with
    this changeset seems to be all we need (or very close to it 8)).
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index 431d58923ba9..3dccdd5108b5 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -194,6 +194,7 @@ enum {
 #include <linux/workqueue.h>
 
 #include <net/inet_connection_sock.h>
+#include <net/inet_timewait_sock.h>
 #include <net/sock.h>
 #include <net/tcp_states.h>
 #include <net/tcp.h>
@@ -354,6 +355,8 @@ static inline struct dccp_request_sock *dccp_rsk(const struct request_sock *req)
 	return (struct dccp_request_sock *)req;
 }
 
+extern struct inet_timewait_death_row dccp_death_row;
+
 /* Read about the ECN nonce to see why it is 253 */
 #define DCCP_MAX_ACK_VECTOR_LEN 253
 

commit 1d3de414eb20d937d82c5219fd13ee4cedc499cb
Author: Harald Welte <laforge@netfilter.org>
Date:   Tue Aug 9 20:26:55 2005 -0700

    [NETFILTER]: New iptables DCCP protocol header match
    
    Using this new iptables DCCP protocol header match, it is possible to
    create simplistic stateless packet filtering rules for DCCP.  It
    permits matching of port numbers, packet type and options.
    
    Signed-off-by: Harald Welte <laforge@netfilter.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index fd1412ddb3ff..431d58923ba9 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -242,10 +242,15 @@ static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
 	return (struct dccp_hdr_ext *)(skb->h.raw + sizeof(struct dccp_hdr));
 }
 
+static inline unsigned int __dccp_basic_hdr_len(const struct dccp_hdr *dh)
+{
+	return sizeof(*dh) + (dh->dccph_x ? sizeof(struct dccp_hdr_ext) : 0);
+}
+
 static inline unsigned int dccp_basic_hdr_len(const struct sk_buff *skb)
 {
 	const struct dccp_hdr *dh = dccp_hdr(skb);
-	return sizeof(*dh) + (dh->dccph_x ? sizeof(struct dccp_hdr_ext) : 0);
+	return __dccp_basic_hdr_len(dh);
 }
 
 static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
@@ -297,10 +302,15 @@ static inline struct dccp_hdr_reset *dccp_hdr_reset(struct sk_buff *skb)
 	return (struct dccp_hdr_reset *)(skb->h.raw + dccp_basic_hdr_len(skb));
 }
 
+static inline unsigned int __dccp_hdr_len(const struct dccp_hdr *dh)
+{
+	return __dccp_basic_hdr_len(dh) +
+	       dccp_packet_hdr_len(dh->dccph_type);
+}
+
 static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
 {
-	return dccp_basic_hdr_len(skb) +
-	       dccp_packet_hdr_len(dccp_hdr(skb)->dccph_type);
+	return __dccp_hdr_len(dccp_hdr(skb));
 }
 
 

commit e2e268665f6c01686b477a6b0cc5a70bab689d54
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Tue Aug 9 20:26:28 2005 -0700

    [DCCP]: Fix struct sockaddr_dccp definition
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index add4908b8e57..fd1412ddb3ff 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -4,10 +4,14 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 
-/* FIXME: this is utterly wrong */
+/* Structure describing an Internet (DCCP) socket address. */
 struct sockaddr_dccp {
-	struct sockaddr_in	in;
-	unsigned int		service;
+	__u16	sdccp_family;	/* Address family   */
+	__u16	sdccp_port;	/* Port number	    */
+	__u32	sdccp_addr;	/* Internet address */
+	__u32	sdccp_service;	/* Service	    */
+	/* Pad to size of `struct sockaddr': 16 bytes . */
+	__u32	sdccp_pad;
 };
 
 /**

commit 5a47a470e602eecb168ddd3b78841b84ceddd319
Author: Harald Welte <laforge@netfilter.org>
Date:   Tue Aug 9 20:26:03 2005 -0700

    [DCCP]: make <linux/dccp.h> include-able from userspace
    
    The protocol header files in <linux/foo.h> are usually structured in a
    way to be included by userspace code.  The top section consists of
    general protocol structure definitions, typedefs, enums - followed by
    an #ifdef __KERNEL__ section.
    
    Currently <linux/dccp.h> doesn't follow that convention and can
    therefore not be used from userspace.  However, for example iptables'
    libipt_dccp.c actually needs various definitions from there.
    
    Signed-off-by: Harald Welte <laforge@netfilter.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
index e3b4bf7346bb..add4908b8e57 100644
--- a/include/linux/dccp.h
+++ b/include/linux/dccp.h
@@ -1,16 +1,8 @@
 #ifndef _LINUX_DCCP_H
 #define _LINUX_DCCP_H
 
-#include <linux/in.h>
-#include <linux/list.h>
 #include <linux/types.h>
-#include <linux/uio.h>
-#include <linux/workqueue.h>
-
-#include <net/inet_connection_sock.h>
-#include <net/sock.h>
-#include <net/tcp_states.h>
-#include <net/tcp.h>
+#include <asm/byteorder.h>
 
 /* FIXME: this is utterly wrong */
 struct sockaddr_dccp {
@@ -18,40 +10,6 @@ struct sockaddr_dccp {
 	unsigned int		service;
 };
 
-enum dccp_state {
-	DCCP_OPEN	= TCP_ESTABLISHED,
-	DCCP_REQUESTING	= TCP_SYN_SENT,
-	DCCP_PARTOPEN	= TCP_FIN_WAIT1, /* FIXME:
-					    This mapping is horrible, but TCP has
-					    no matching state for DCCP_PARTOPEN,
-					    as TCP_SYN_RECV is already used by
-					    DCCP_RESPOND, why don't stop using TCP
-					    mapping of states? OK, now we don't use
-					    sk_stream_sendmsg anymore, so doesn't
-					    seem to exist any reason for us to
-					    do the TCP mapping here */
-	DCCP_LISTEN	= TCP_LISTEN,
-	DCCP_RESPOND	= TCP_SYN_RECV,
-	DCCP_CLOSING	= TCP_CLOSING,
-	DCCP_TIME_WAIT	= TCP_TIME_WAIT,
-	DCCP_CLOSED	= TCP_CLOSE,
-	DCCP_MAX_STATES = TCP_MAX_STATES,
-};
-
-#define DCCP_STATE_MASK 0xf
-#define DCCP_ACTION_FIN (1<<7)
-
-enum {
-	DCCPF_OPEN	 = TCPF_ESTABLISHED,
-	DCCPF_REQUESTING = TCPF_SYN_SENT,
-	DCCPF_PARTOPEN	 = TCPF_FIN_WAIT1,
-	DCCPF_LISTEN	 = TCPF_LISTEN,
-	DCCPF_RESPOND	 = TCPF_SYN_RECV,
-	DCCPF_CLOSING	 = TCPF_CLOSING,
-	DCCPF_TIME_WAIT	 = TCPF_TIME_WAIT,
-	DCCPF_CLOSED	 = TCPF_CLOSE,
-};
-
 /**
  * struct dccp_hdr - generic part of DCCP packet header
  *
@@ -94,11 +52,6 @@ struct dccp_hdr {
 #endif
 };
 
-static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)
-{
-	return (struct dccp_hdr *)skb->h.raw;
-}
-
 /**
  * struct dccp_hdr_ext - the low bits of a 48 bit seq packet
  *
@@ -108,34 +61,6 @@ struct dccp_hdr_ext {
 	__u32	dccph_seq_low;
 };
 
-static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
-{
-	return (struct dccp_hdr_ext *)(skb->h.raw + sizeof(struct dccp_hdr));
-}
-
-static inline unsigned int dccp_basic_hdr_len(const struct sk_buff *skb)
-{
-	const struct dccp_hdr *dh = dccp_hdr(skb);
-	return sizeof(*dh) + (dh->dccph_x ? sizeof(struct dccp_hdr_ext) : 0);
-}
-
-static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
-{
-	const struct dccp_hdr *dh = dccp_hdr(skb);
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u64 seq_nr = ntohl(dh->dccph_seq << 8);
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	__u64 seq_nr = ntohl(dh->dccph_seq);
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
-
-	if (dh->dccph_x != 0)
-		seq_nr = (seq_nr << 32) + ntohl(dccp_hdrx(skb)->dccph_seq_low);
-
-	return seq_nr;
-}
-
 /**
  * struct dccp_hdr_request - Conection initiation request header
  *
@@ -145,12 +70,6 @@ static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
 struct dccp_hdr_request {
 	__u32	dccph_req_service;
 };
-
-static inline struct dccp_hdr_request *dccp_hdr_request(struct sk_buff *skb)
-{
-	return (struct dccp_hdr_request *)(skb->h.raw + dccp_basic_hdr_len(skb));
-}
-
 /**
  * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
  *
@@ -162,24 +81,6 @@ struct dccp_hdr_ack_bits {
 		dccph_ack_nr_high:24;
 	__u32	dccph_ack_nr_low;
 };
-
-static inline struct dccp_hdr_ack_bits *dccp_hdr_ack_bits(const struct sk_buff *skb)
-{
-	return (struct dccp_hdr_ack_bits *)(skb->h.raw + dccp_basic_hdr_len(skb));
-}
-
-static inline u64 dccp_hdr_ack_seq(const struct sk_buff *skb)
-{
-	const struct dccp_hdr_ack_bits *dhack = dccp_hdr_ack_bits(skb);
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	return (((u64)ntohl(dhack->dccph_ack_nr_high << 8)) << 32) + ntohl(dhack->dccph_ack_nr_low);
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	return (((u64)ntohl(dhack->dccph_ack_nr_high)) << 32) + ntohl(dhack->dccph_ack_nr_low);
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
-}
-
 /**
  * struct dccp_hdr_response - Conection initiation response header
  *
@@ -193,11 +94,6 @@ struct dccp_hdr_response {
 	__u32				dccph_resp_service;
 };
 
-static inline struct dccp_hdr_response *dccp_hdr_response(struct sk_buff *skb)
-{
-	return (struct dccp_hdr_response *)(skb->h.raw + dccp_basic_hdr_len(skb));
-}
-
 /**
  * struct dccp_hdr_reset - Unconditionally shut down a connection
  *
@@ -210,11 +106,6 @@ struct dccp_hdr_reset {
 					dccph_reset_data[3];
 };
 
-static inline struct dccp_hdr_reset *dccp_hdr_reset(struct sk_buff *skb)
-{
-	return (struct dccp_hdr_reset *)(skb->h.raw + dccp_basic_hdr_len(skb));
-}
-
 enum dccp_pkt_type {
 	DCCP_PKT_REQUEST = 0,
 	DCCP_PKT_RESPONSE,
@@ -248,13 +139,6 @@ static inline unsigned int dccp_packet_hdr_len(const __u8 type)
 		return sizeof(struct dccp_hdr_response);
 	return sizeof(struct dccp_hdr_reset);
 }
-
-static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
-{
-	return dccp_basic_hdr_len(skb) +
-	       dccp_packet_hdr_len(dccp_hdr(skb)->dccph_type);
-}
-
 enum dccp_reset_codes {
 	DCCP_RESET_CODE_UNSPECIFIED = 0,
 	DCCP_RESET_CODE_CLOSED,
@@ -298,6 +182,124 @@ enum {
 	DCCPF_MAX_CCID_SPECIFIC = 255,
 };
 
+#ifdef __KERNEL__
+
+#include <linux/in.h>
+#include <linux/list.h>
+#include <linux/uio.h>
+#include <linux/workqueue.h>
+
+#include <net/inet_connection_sock.h>
+#include <net/sock.h>
+#include <net/tcp_states.h>
+#include <net/tcp.h>
+
+enum dccp_state {
+	DCCP_OPEN	= TCP_ESTABLISHED,
+	DCCP_REQUESTING	= TCP_SYN_SENT,
+	DCCP_PARTOPEN	= TCP_FIN_WAIT1, /* FIXME:
+					    This mapping is horrible, but TCP has
+					    no matching state for DCCP_PARTOPEN,
+					    as TCP_SYN_RECV is already used by
+					    DCCP_RESPOND, why don't stop using TCP
+					    mapping of states? OK, now we don't use
+					    sk_stream_sendmsg anymore, so doesn't
+					    seem to exist any reason for us to
+					    do the TCP mapping here */
+	DCCP_LISTEN	= TCP_LISTEN,
+	DCCP_RESPOND	= TCP_SYN_RECV,
+	DCCP_CLOSING	= TCP_CLOSING,
+	DCCP_TIME_WAIT	= TCP_TIME_WAIT,
+	DCCP_CLOSED	= TCP_CLOSE,
+	DCCP_MAX_STATES = TCP_MAX_STATES,
+};
+
+#define DCCP_STATE_MASK 0xf
+#define DCCP_ACTION_FIN (1<<7)
+
+enum {
+	DCCPF_OPEN	 = TCPF_ESTABLISHED,
+	DCCPF_REQUESTING = TCPF_SYN_SENT,
+	DCCPF_PARTOPEN	 = TCPF_FIN_WAIT1,
+	DCCPF_LISTEN	 = TCPF_LISTEN,
+	DCCPF_RESPOND	 = TCPF_SYN_RECV,
+	DCCPF_CLOSING	 = TCPF_CLOSING,
+	DCCPF_TIME_WAIT	 = TCPF_TIME_WAIT,
+	DCCPF_CLOSED	 = TCPF_CLOSE,
+};
+
+static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)
+{
+	return (struct dccp_hdr *)skb->h.raw;
+}
+
+static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
+{
+	return (struct dccp_hdr_ext *)(skb->h.raw + sizeof(struct dccp_hdr));
+}
+
+static inline unsigned int dccp_basic_hdr_len(const struct sk_buff *skb)
+{
+	const struct dccp_hdr *dh = dccp_hdr(skb);
+	return sizeof(*dh) + (dh->dccph_x ? sizeof(struct dccp_hdr_ext) : 0);
+}
+
+static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
+{
+	const struct dccp_hdr *dh = dccp_hdr(skb);
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u64 seq_nr = ntohl(dh->dccph_seq << 8);
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u64 seq_nr = ntohl(dh->dccph_seq);
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+
+	if (dh->dccph_x != 0)
+		seq_nr = (seq_nr << 32) + ntohl(dccp_hdrx(skb)->dccph_seq_low);
+
+	return seq_nr;
+}
+
+static inline struct dccp_hdr_request *dccp_hdr_request(struct sk_buff *skb)
+{
+	return (struct dccp_hdr_request *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+static inline struct dccp_hdr_ack_bits *dccp_hdr_ack_bits(const struct sk_buff *skb)
+{
+	return (struct dccp_hdr_ack_bits *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+static inline u64 dccp_hdr_ack_seq(const struct sk_buff *skb)
+{
+	const struct dccp_hdr_ack_bits *dhack = dccp_hdr_ack_bits(skb);
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	return (((u64)ntohl(dhack->dccph_ack_nr_high << 8)) << 32) + ntohl(dhack->dccph_ack_nr_low);
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	return (((u64)ntohl(dhack->dccph_ack_nr_high)) << 32) + ntohl(dhack->dccph_ack_nr_low);
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+}
+
+static inline struct dccp_hdr_response *dccp_hdr_response(struct sk_buff *skb)
+{
+	return (struct dccp_hdr_response *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+static inline struct dccp_hdr_reset *dccp_hdr_reset(struct sk_buff *skb)
+{
+	return (struct dccp_hdr_reset *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
+{
+	return dccp_basic_hdr_len(skb) +
+	       dccp_packet_hdr_len(dccp_hdr(skb)->dccph_type);
+}
+
+
 /* initial values for each feature */
 #define DCCPF_INITIAL_SEQUENCE_WINDOW		100
 /* FIXME: for now we're using CCID 3 (TFRC) */
@@ -429,4 +431,6 @@ static inline const char *dccp_role(const struct sock *sk)
 	return NULL;
 }
 
+#endif /* __KERNEL__ */
+
 #endif /* _LINUX_DCCP_H */

commit 7c657876b63cb1d8a2ec06f8fc6c37bb8412e66c
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Tue Aug 9 20:14:34 2005 -0700

    [DCCP]: Initial implementation
    
    Development to this point was done on a subversion repository at:
    
    http://oops.ghostprotocols.net:81/cgi-bin/viewcvs.cgi/dccp-2.6/
    
    This repository will be kept at this site for the foreseable future,
    so that interested parties can see the history of this code,
    attributions, etc.
    
    If I ever decide to take this offline I'll provide the full history at
    some other suitable place.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/dccp.h b/include/linux/dccp.h
new file mode 100644
index 000000000000..e3b4bf7346bb
--- /dev/null
+++ b/include/linux/dccp.h
@@ -0,0 +1,432 @@
+#ifndef _LINUX_DCCP_H
+#define _LINUX_DCCP_H
+
+#include <linux/in.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/uio.h>
+#include <linux/workqueue.h>
+
+#include <net/inet_connection_sock.h>
+#include <net/sock.h>
+#include <net/tcp_states.h>
+#include <net/tcp.h>
+
+/* FIXME: this is utterly wrong */
+struct sockaddr_dccp {
+	struct sockaddr_in	in;
+	unsigned int		service;
+};
+
+enum dccp_state {
+	DCCP_OPEN	= TCP_ESTABLISHED,
+	DCCP_REQUESTING	= TCP_SYN_SENT,
+	DCCP_PARTOPEN	= TCP_FIN_WAIT1, /* FIXME:
+					    This mapping is horrible, but TCP has
+					    no matching state for DCCP_PARTOPEN,
+					    as TCP_SYN_RECV is already used by
+					    DCCP_RESPOND, why don't stop using TCP
+					    mapping of states? OK, now we don't use
+					    sk_stream_sendmsg anymore, so doesn't
+					    seem to exist any reason for us to
+					    do the TCP mapping here */
+	DCCP_LISTEN	= TCP_LISTEN,
+	DCCP_RESPOND	= TCP_SYN_RECV,
+	DCCP_CLOSING	= TCP_CLOSING,
+	DCCP_TIME_WAIT	= TCP_TIME_WAIT,
+	DCCP_CLOSED	= TCP_CLOSE,
+	DCCP_MAX_STATES = TCP_MAX_STATES,
+};
+
+#define DCCP_STATE_MASK 0xf
+#define DCCP_ACTION_FIN (1<<7)
+
+enum {
+	DCCPF_OPEN	 = TCPF_ESTABLISHED,
+	DCCPF_REQUESTING = TCPF_SYN_SENT,
+	DCCPF_PARTOPEN	 = TCPF_FIN_WAIT1,
+	DCCPF_LISTEN	 = TCPF_LISTEN,
+	DCCPF_RESPOND	 = TCPF_SYN_RECV,
+	DCCPF_CLOSING	 = TCPF_CLOSING,
+	DCCPF_TIME_WAIT	 = TCPF_TIME_WAIT,
+	DCCPF_CLOSED	 = TCPF_CLOSE,
+};
+
+/**
+ * struct dccp_hdr - generic part of DCCP packet header
+ *
+ * @dccph_sport - Relevant port on the endpoint that sent this packet
+ * @dccph_dport - Relevant port on the other endpoint
+ * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
+ * @dccph_ccval - Used by the HC-Sender CCID
+ * @dccph_cscov - Parts of the packet that are covered by the Checksum field
+ * @dccph_checksum - Internet checksum, depends on dccph_cscov
+ * @dccph_x - 0 = 24 bit sequence number, 1 = 48
+ * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
+ * @dccph_seq - sequence number high or low order 24 bits, depends on dccph_x
+ */
+struct dccp_hdr {
+	__u16	dccph_sport,
+		dccph_dport;
+	__u8	dccph_doff;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	dccph_cscov:4,
+		dccph_ccval:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8	dccph_ccval:4,
+		dccph_cscov:4;
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+	__u16	dccph_checksum;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u32	dccph_x:1,
+		dccph_type:4,
+		dccph_reserved:3,
+		dccph_seq:24;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u32	dccph_reserved:3,
+		dccph_type:4,
+		dccph_x:1,
+		dccph_seq:24;
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+};
+
+static inline struct dccp_hdr *dccp_hdr(const struct sk_buff *skb)
+{
+	return (struct dccp_hdr *)skb->h.raw;
+}
+
+/**
+ * struct dccp_hdr_ext - the low bits of a 48 bit seq packet
+ *
+ * @dccph_seq_low - low 24 bits of a 48 bit seq packet
+ */
+struct dccp_hdr_ext {
+	__u32	dccph_seq_low;
+};
+
+static inline struct dccp_hdr_ext *dccp_hdrx(const struct sk_buff *skb)
+{
+	return (struct dccp_hdr_ext *)(skb->h.raw + sizeof(struct dccp_hdr));
+}
+
+static inline unsigned int dccp_basic_hdr_len(const struct sk_buff *skb)
+{
+	const struct dccp_hdr *dh = dccp_hdr(skb);
+	return sizeof(*dh) + (dh->dccph_x ? sizeof(struct dccp_hdr_ext) : 0);
+}
+
+static inline __u64 dccp_hdr_seq(const struct sk_buff *skb)
+{
+	const struct dccp_hdr *dh = dccp_hdr(skb);
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u64 seq_nr = ntohl(dh->dccph_seq << 8);
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u64 seq_nr = ntohl(dh->dccph_seq);
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+
+	if (dh->dccph_x != 0)
+		seq_nr = (seq_nr << 32) + ntohl(dccp_hdrx(skb)->dccph_seq_low);
+
+	return seq_nr;
+}
+
+/**
+ * struct dccp_hdr_request - Conection initiation request header
+ *
+ * @dccph_req_service - Service to which the client app wants to connect
+ * @dccph_req_options - list of options (must be a multiple of 32 bits
+ */
+struct dccp_hdr_request {
+	__u32	dccph_req_service;
+};
+
+static inline struct dccp_hdr_request *dccp_hdr_request(struct sk_buff *skb)
+{
+	return (struct dccp_hdr_request *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+/**
+ * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
+ *
+ * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
+ * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
+ */
+struct dccp_hdr_ack_bits {
+	__u32	dccph_reserved1:8,
+		dccph_ack_nr_high:24;
+	__u32	dccph_ack_nr_low;
+};
+
+static inline struct dccp_hdr_ack_bits *dccp_hdr_ack_bits(const struct sk_buff *skb)
+{
+	return (struct dccp_hdr_ack_bits *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+static inline u64 dccp_hdr_ack_seq(const struct sk_buff *skb)
+{
+	const struct dccp_hdr_ack_bits *dhack = dccp_hdr_ack_bits(skb);
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	return (((u64)ntohl(dhack->dccph_ack_nr_high << 8)) << 32) + ntohl(dhack->dccph_ack_nr_low);
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	return (((u64)ntohl(dhack->dccph_ack_nr_high)) << 32) + ntohl(dhack->dccph_ack_nr_low);
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+}
+
+/**
+ * struct dccp_hdr_response - Conection initiation response header
+ *
+ * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
+ * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
+ * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
+ * @dccph_resp_options - list of options (must be a multiple of 32 bits
+ */
+struct dccp_hdr_response {
+	struct dccp_hdr_ack_bits	dccph_resp_ack;
+	__u32				dccph_resp_service;
+};
+
+static inline struct dccp_hdr_response *dccp_hdr_response(struct sk_buff *skb)
+{
+	return (struct dccp_hdr_response *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+/**
+ * struct dccp_hdr_reset - Unconditionally shut down a connection
+ *
+ * @dccph_reset_service - Echoes the Service Code on a received DCCP-Request
+ * @dccph_reset_options - list of options (must be a multiple of 32 bits
+ */
+struct dccp_hdr_reset {
+	struct dccp_hdr_ack_bits	dccph_reset_ack;
+	__u8				dccph_reset_code,
+					dccph_reset_data[3];
+};
+
+static inline struct dccp_hdr_reset *dccp_hdr_reset(struct sk_buff *skb)
+{
+	return (struct dccp_hdr_reset *)(skb->h.raw + dccp_basic_hdr_len(skb));
+}
+
+enum dccp_pkt_type {
+	DCCP_PKT_REQUEST = 0,
+	DCCP_PKT_RESPONSE,
+	DCCP_PKT_DATA,
+	DCCP_PKT_ACK,
+	DCCP_PKT_DATAACK,
+	DCCP_PKT_CLOSEREQ,
+	DCCP_PKT_CLOSE,
+	DCCP_PKT_RESET,
+	DCCP_PKT_SYNC,
+	DCCP_PKT_SYNCACK,
+	DCCP_PKT_INVALID,
+};
+
+#define DCCP_NR_PKT_TYPES DCCP_PKT_INVALID
+
+static inline unsigned int dccp_packet_hdr_len(const __u8 type)
+{
+	if (type == DCCP_PKT_DATA)
+		return 0;
+	if (type == DCCP_PKT_DATAACK	||
+	    type == DCCP_PKT_ACK	||
+	    type == DCCP_PKT_SYNC	||
+	    type == DCCP_PKT_SYNCACK	||
+	    type == DCCP_PKT_CLOSE	||
+	    type == DCCP_PKT_CLOSEREQ)
+		return sizeof(struct dccp_hdr_ack_bits);
+	if (type == DCCP_PKT_REQUEST)
+		return sizeof(struct dccp_hdr_request);
+	if (type == DCCP_PKT_RESPONSE)
+		return sizeof(struct dccp_hdr_response);
+	return sizeof(struct dccp_hdr_reset);
+}
+
+static inline unsigned int dccp_hdr_len(const struct sk_buff *skb)
+{
+	return dccp_basic_hdr_len(skb) +
+	       dccp_packet_hdr_len(dccp_hdr(skb)->dccph_type);
+}
+
+enum dccp_reset_codes {
+	DCCP_RESET_CODE_UNSPECIFIED = 0,
+	DCCP_RESET_CODE_CLOSED,
+	DCCP_RESET_CODE_ABORTED,
+	DCCP_RESET_CODE_NO_CONNECTION,
+	DCCP_RESET_CODE_PACKET_ERROR,
+	DCCP_RESET_CODE_OPTION_ERROR,
+	DCCP_RESET_CODE_MANDATORY_ERROR,
+	DCCP_RESET_CODE_CONNECTION_REFUSED,
+	DCCP_RESET_CODE_BAD_SERVICE_CODE,
+	DCCP_RESET_CODE_TOO_BUSY,
+	DCCP_RESET_CODE_BAD_INIT_COOKIE,
+	DCCP_RESET_CODE_AGGRESSION_PENALTY,
+};
+
+/* DCCP options */
+enum {
+	DCCPO_PADDING = 0,
+	DCCPO_MANDATORY = 1,
+	DCCPO_MIN_RESERVED = 3,
+	DCCPO_MAX_RESERVED = 31,
+	DCCPO_NDP_COUNT = 37,
+	DCCPO_ACK_VECTOR_0 = 38,
+	DCCPO_ACK_VECTOR_1 = 39,
+	DCCPO_TIMESTAMP = 41,
+	DCCPO_TIMESTAMP_ECHO = 42,
+	DCCPO_ELAPSED_TIME = 43,
+	DCCPO_MAX = 45,
+	DCCPO_MIN_CCID_SPECIFIC = 128,
+	DCCPO_MAX_CCID_SPECIFIC = 255,
+};
+
+/* DCCP features */
+enum {
+	DCCPF_RESERVED = 0,
+	DCCPF_SEQUENCE_WINDOW = 3,
+	DCCPF_SEND_ACK_VECTOR = 6,
+	DCCPF_SEND_NDP_COUNT = 7,
+	/* 10-127 reserved */
+	DCCPF_MIN_CCID_SPECIFIC = 128,
+	DCCPF_MAX_CCID_SPECIFIC = 255,
+};
+
+/* initial values for each feature */
+#define DCCPF_INITIAL_SEQUENCE_WINDOW		100
+/* FIXME: for now we're using CCID 3 (TFRC) */
+#define DCCPF_INITIAL_CCID			3
+#define DCCPF_INITIAL_SEND_ACK_VECTOR		0
+/* FIXME: for now we're default to 1 but it should really be 0 */
+#define DCCPF_INITIAL_SEND_NDP_COUNT		1
+
+#define DCCP_NDP_LIMIT 0xFFFFFF
+
+/**
+  * struct dccp_options - option values for a DCCP connection
+  *	@dccpo_sequence_window - Sequence Window Feature (section 7.5.2)
+  *	@dccpo_ccid - Congestion Control Id (CCID) (section 10)
+  *	@dccpo_send_ack_vector - Send Ack Vector Feature (section 11.5)
+  *	@dccpo_send_ndp_count - Send NDP Count Feature (7.7.2)
+  */
+struct dccp_options {
+	__u64	dccpo_sequence_window;
+	__u8	dccpo_ccid;
+	__u8	dccpo_send_ack_vector;
+	__u8	dccpo_send_ndp_count;
+};
+
+extern void __dccp_options_init(struct dccp_options *dccpo);
+extern void dccp_options_init(struct dccp_options *dccpo);
+extern int dccp_parse_options(struct sock *sk, struct sk_buff *skb);
+
+struct dccp_request_sock {
+	struct inet_request_sock dreq_inet_rsk;
+	__u64			 dreq_iss;
+	__u64			 dreq_isr;
+	__u32			 dreq_service;
+};
+
+static inline struct dccp_request_sock *dccp_rsk(const struct request_sock *req)
+{
+	return (struct dccp_request_sock *)req;
+}
+
+/* Read about the ECN nonce to see why it is 253 */
+#define DCCP_MAX_ACK_VECTOR_LEN 253
+
+struct dccp_options_received {
+	u32	dccpor_ndp:24,
+		dccpor_ack_vector_len:8;
+	u32	dccpor_ack_vector_idx:10;
+	/* 22 bits hole, try to pack */
+	u32	dccpor_timestamp;
+	u32	dccpor_timestamp_echo;
+	u32	dccpor_elapsed_time;
+};
+
+struct ccid;
+
+enum dccp_role {
+	DCCP_ROLE_UNDEFINED,
+	DCCP_ROLE_LISTEN,
+	DCCP_ROLE_CLIENT,
+	DCCP_ROLE_SERVER,
+};
+
+/**
+ * struct dccp_sock - DCCP socket state
+ *
+ * @dccps_swl - sequence number window low
+ * @dccps_swh - sequence number window high
+ * @dccps_awl - acknowledgement number window low
+ * @dccps_awh - acknowledgement number window high
+ * @dccps_iss - initial sequence number sent
+ * @dccps_isr - initial sequence number received
+ * @dccps_osr - first OPEN sequence number received
+ * @dccps_gss - greatest sequence number sent
+ * @dccps_gsr - greatest valid sequence number received
+ * @dccps_gar - greatest valid ack number received on a non-Sync; initialized to %dccps_iss
+ * @dccps_timestamp_time - time of latest TIMESTAMP option
+ * @dccps_timestamp_echo - latest timestamp received on a TIMESTAMP option
+ * @dccps_ext_header_len - network protocol overhead (IP/IPv6 options)
+ * @dccps_pmtu_cookie - Last pmtu seen by socket
+ * @dccps_avg_packet_size - FIXME: has to be set by the app thru some setsockopt or ioctl, CCID3 uses it
+ * @dccps_role - Role of this sock, one of %dccp_role
+ * @dccps_ndp_count - number of Non Data Packets since last data packet
+ * @dccps_hc_rx_ackpkts - receiver half connection acked packets
+ */
+struct dccp_sock {
+	/* inet_connection_sock has to be the first member of dccp_sock */
+	struct inet_connection_sock	dccps_inet_connection;
+	__u64				dccps_swl;
+	__u64				dccps_swh;
+	__u64				dccps_awl;
+	__u64				dccps_awh;
+	__u64				dccps_iss;
+	__u64				dccps_isr;
+	__u64				dccps_osr;
+	__u64				dccps_gss;
+	__u64				dccps_gsr;
+	__u64				dccps_gar;
+	unsigned long			dccps_service;
+	unsigned long			dccps_timestamp_time;
+	__u32				dccps_timestamp_echo;
+	__u32				dccps_avg_packet_size;
+	unsigned long			dccps_ndp_count;
+	__u16				dccps_ext_header_len;
+	__u32				dccps_pmtu_cookie;
+	__u32				dccps_mss_cache;
+	struct dccp_options		dccps_options;
+	struct dccp_ackpkts		*dccps_hc_rx_ackpkts;
+	void				*dccps_hc_rx_ccid_private;
+	void				*dccps_hc_tx_ccid_private;
+	struct ccid			*dccps_hc_rx_ccid;
+	struct ccid			*dccps_hc_tx_ccid;
+	struct dccp_options_received	dccps_options_received;
+	enum dccp_role			dccps_role:2;
+};
+ 
+static inline struct dccp_sock *dccp_sk(const struct sock *sk)
+{
+	return (struct dccp_sock *)sk;
+}
+
+static inline const char *dccp_role(const struct sock *sk)
+{
+	switch (dccp_sk(sk)->dccps_role) {
+	case DCCP_ROLE_UNDEFINED: return "undefined";
+	case DCCP_ROLE_LISTEN:	  return "listen";
+	case DCCP_ROLE_SERVER:	  return "server";
+	case DCCP_ROLE_CLIENT:	  return "client";
+	}
+	return NULL;
+}
+
+#endif /* _LINUX_DCCP_H */
