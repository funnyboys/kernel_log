commit 2fff3f73e8c27801b84d2315e1a49bce96b00eff
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:55:32 2020 +0200

    Documentation: PM: sleep: Update driver flags documentation
    
    Update the documentation of the driver flags for system-wide power
    management to reflect the current code flows and be more consistent.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 35796fc49e7a..121c104a4090 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -545,25 +545,11 @@ struct pm_subsys_data {
  * cleared by the drivers as the driver core will take care of that.
  *
  * NO_DIRECT_COMPLETE: Do not apply direct-complete optimization to the device.
- * SMART_PREPARE: Check the return value of the driver's ->prepare callback.
- * SMART_SUSPEND: No need to resume the device from runtime suspend.
- * MAY_SKIP_RESUME: Avoid resuming the device during system resume if possible.
- *
- * Setting SMART_PREPARE instructs bus types and PM domains which may want
- * system suspend/resume callbacks to be skipped for the device to return 0 from
- * their ->prepare callbacks if the driver's ->prepare callback returns 0 (in
- * other words, the system suspend/resume callbacks can only be skipped for the
- * device if its driver doesn't object against that).  This flag has no effect
- * if NO_DIRECT_COMPLETE is set.
- *
- * Setting SMART_SUSPEND instructs bus types and PM domains which may want to
- * runtime resume the device upfront during system suspend that doing so is not
- * necessary from the driver's perspective.  It also may cause them to skip
- * invocations of the ->suspend_late and ->suspend_noirq callbacks provided by
- * the driver if they decide to leave the device in runtime suspend.
- *
- * Setting MAY_SKIP_RESUME informs the PM core and middle-layer code that the
- * driver prefers the device to be left in suspend after system resume.
+ * SMART_PREPARE: Take the driver ->prepare callback return value into account.
+ * SMART_SUSPEND: Avoid resuming the device from runtime suspend.
+ * MAY_SKIP_RESUME: Allow driver "noirq" and "early" callbacks to be skipped.
+ *
+ * See Documentation/driver-api/pm/devices.rst for details.
  */
 #define DPM_FLAG_NO_DIRECT_COMPLETE	BIT(0)
 #define DPM_FLAG_SMART_PREPARE		BIT(1)

commit 2a3f34750b8b07df42ab4b30b70e029d46e0d7f3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:53:20 2020 +0200

    PM: sleep: core: Rename DPM_FLAG_LEAVE_SUSPENDED
    
    Rename DPM_FLAG_LEAVE_SUSPENDED to DPM_FLAG_MAY_SKIP_RESUME which
    matches its purpose more closely.
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for I2C
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index cdb8fbd6ab18..35796fc49e7a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -547,7 +547,7 @@ struct pm_subsys_data {
  * NO_DIRECT_COMPLETE: Do not apply direct-complete optimization to the device.
  * SMART_PREPARE: Check the return value of the driver's ->prepare callback.
  * SMART_SUSPEND: No need to resume the device from runtime suspend.
- * LEAVE_SUSPENDED: Avoid resuming the device during system resume if possible.
+ * MAY_SKIP_RESUME: Avoid resuming the device during system resume if possible.
  *
  * Setting SMART_PREPARE instructs bus types and PM domains which may want
  * system suspend/resume callbacks to be skipped for the device to return 0 from
@@ -562,13 +562,13 @@ struct pm_subsys_data {
  * invocations of the ->suspend_late and ->suspend_noirq callbacks provided by
  * the driver if they decide to leave the device in runtime suspend.
  *
- * Setting LEAVE_SUSPENDED informs the PM core and middle-layer code that the
+ * Setting MAY_SKIP_RESUME informs the PM core and middle-layer code that the
  * driver prefers the device to be left in suspend after system resume.
  */
 #define DPM_FLAG_NO_DIRECT_COMPLETE	BIT(0)
 #define DPM_FLAG_SMART_PREPARE		BIT(1)
 #define DPM_FLAG_SMART_SUSPEND		BIT(2)
-#define DPM_FLAG_LEAVE_SUSPENDED	BIT(3)
+#define DPM_FLAG_MAY_SKIP_RESUME	BIT(3)
 
 struct dev_pm_info {
 	pm_message_t		power_state;

commit e07515563d010d8b32967634e8dc2fdc732c1aa6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:53:01 2020 +0200

    PM: sleep: core: Rename DPM_FLAG_NEVER_SKIP
    
    Rename DPM_FLAG_NEVER_SKIP to DPM_FLAG_NO_DIRECT_COMPLETE which
    matches its purpose more closely.
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> # for PCI parts
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 8c59a7f0bcf4..cdb8fbd6ab18 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -544,7 +544,7 @@ struct pm_subsys_data {
  * These flags can be set by device drivers at the probe time.  They need not be
  * cleared by the drivers as the driver core will take care of that.
  *
- * NEVER_SKIP: Do not skip all system suspend/resume callbacks for the device.
+ * NO_DIRECT_COMPLETE: Do not apply direct-complete optimization to the device.
  * SMART_PREPARE: Check the return value of the driver's ->prepare callback.
  * SMART_SUSPEND: No need to resume the device from runtime suspend.
  * LEAVE_SUSPENDED: Avoid resuming the device during system resume if possible.
@@ -554,7 +554,7 @@ struct pm_subsys_data {
  * their ->prepare callbacks if the driver's ->prepare callback returns 0 (in
  * other words, the system suspend/resume callbacks can only be skipped for the
  * device if its driver doesn't object against that).  This flag has no effect
- * if NEVER_SKIP is set.
+ * if NO_DIRECT_COMPLETE is set.
  *
  * Setting SMART_SUSPEND instructs bus types and PM domains which may want to
  * runtime resume the device upfront during system suspend that doing so is not
@@ -565,7 +565,7 @@ struct pm_subsys_data {
  * Setting LEAVE_SUSPENDED informs the PM core and middle-layer code that the
  * driver prefers the device to be left in suspend after system resume.
  */
-#define DPM_FLAG_NEVER_SKIP		BIT(0)
+#define DPM_FLAG_NO_DIRECT_COMPLETE	BIT(0)
 #define DPM_FLAG_SMART_PREPARE		BIT(1)
 #define DPM_FLAG_SMART_SUSPEND		BIT(2)
 #define DPM_FLAG_LEAVE_SUSPENDED	BIT(3)

commit fa2bfead910322e44e7e0bb74364ac198a2abd32
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:48 2020 +0200

    PM: sleep: core: Rename dev_pm_smart_suspend_and_suspended()
    
    Because all callers of dev_pm_smart_suspend_and_suspended use it only
    for checking whether or not to skip driver suspend callbacks for a
    device, rename it to dev_pm_skip_suspend() in analogy with
    dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index d89b7099f241..8c59a7f0bcf4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -759,7 +759,7 @@ extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 
 extern bool dev_pm_skip_resume(struct device *dev);
-extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
+extern bool dev_pm_skip_suspend(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */
 

commit 76c70cb58ce30264af4b714109ee756da25d830a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:52:30 2020 +0200

    PM: sleep: core: Rename dev_pm_may_skip_resume()
    
    The name of dev_pm_may_skip_resume() may be easily confused with the
    power.may_skip_resume flag which is not checked by that function, so
    rename the former as dev_pm_skip_resume().
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e057d1fa2469..d89b7099f241 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -758,7 +758,7 @@ extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 
-extern bool dev_pm_may_skip_resume(struct device *dev);
+extern bool dev_pm_skip_resume(struct device *dev);
 extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */

commit ca765a8cfe0c78bfa47b9d67121f4e342d4b4512
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Oct 16 15:16:03 2019 +0200

    PM / Domains: Introduce dev_pm_domain_start()
    
    For a subsystem/driver that either doesn't support runtime PM or makes use
    of pm_runtime_set_active() during ->probe(), may try to access its device
    when probing, even if it may not be fully powered on from the PM domain's
    point of view. This may be the case when the used PM domain is a genpd
    provider, that implements genpd's ->start|stop() device callbacks.
    
    There are cases where the subsystem/driver managed to avoid the above
    problem, simply by calling pm_runtime_enable() and pm_runtime_get_sync()
    during ->probe(). However, this approach comes with a drawback, especially
    if the subsystem/driver implements a ->runtime_resume() callback.
    
    More precisely, the subsystem/driver then needs to use a device flag, which
    is checked in its ->runtime_resume() callback, as to avoid powering on its
    resources the first time the callback is invoked. This is needed because
    the subsystem/driver has already powered on the resources for the device,
    during ->probe() and before it called pm_runtime_get_sync().
    
    In a way to avoid this boilerplate code and the inefficient check for "if
    (first_time_suspend)" in the ->runtime_resume() callback for these
    subsystems/drivers, let's introduce and export a dev_pm_domain_start()
    function, that may be called during ->probe() instead.
    
    Moreover, let the dev_pm_domain_start() invoke an optional ->start()
    callback, added to the struct dev_pm_domain, as to allow a PM domain
    specific implementation.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 4c441be03079..e057d1fa2469 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -637,6 +637,7 @@ extern void dev_pm_put_subsys_data(struct device *dev);
  * struct dev_pm_domain - power management domain representation.
  *
  * @ops: Power management operations associated with this domain.
+ * @start: Called when a user needs to start the device via the domain.
  * @detach: Called when removing a device from the domain.
  * @activate: Called before executing probe routines for bus types and drivers.
  * @sync: Called after successful driver probe.
@@ -648,6 +649,7 @@ extern void dev_pm_put_subsys_data(struct device *dev);
  */
 struct dev_pm_domain {
 	struct dev_pm_ops	ops;
+	int (*start)(struct device *dev);
 	void (*detach)(struct device *dev, bool power_off);
 	int (*activate)(struct device *dev);
 	void (*sync)(struct device *dev);

commit b605c44c30b59990e806f930c37bd288b9d901a5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 15 23:52:18 2019 +0200

    PM: sleep: Drop dpm_noirq_begin() and dpm_noirq_end()
    
    Note that after previous changes dpm_noirq_begin() and
    dpm_noirq_end() each have only one caller, so move the code from
    them to their respective callers and drop them.
    
    Also note that dpm_noirq_resume_devices() and
    dpm_noirq_suspend_devices() need not be exported any more, so make
    them both static.
    
    This change is not expected to alter functionality.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3619a870eaa4..4c441be03079 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -712,8 +712,6 @@ struct dev_pm_domain {
 extern void device_pm_lock(void);
 extern void dpm_resume_start(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);
-extern void dpm_noirq_resume_devices(pm_message_t state);
-extern void dpm_noirq_end(void);
 extern void dpm_resume_noirq(pm_message_t state);
 extern void dpm_resume_early(pm_message_t state);
 extern void dpm_resume(pm_message_t state);
@@ -722,8 +720,6 @@ extern void dpm_complete(pm_message_t state);
 extern void device_pm_unlock(void);
 extern int dpm_suspend_end(pm_message_t state);
 extern int dpm_suspend_start(pm_message_t state);
-extern void dpm_noirq_begin(void);
-extern int dpm_noirq_suspend_devices(pm_message_t state);
 extern int dpm_suspend_noirq(pm_message_t state);
 extern int dpm_suspend_late(pm_message_t state);
 extern int dpm_suspend(pm_message_t state);

commit fb4da215ed92f564f7ca090bb81a199b0d6cab8a
Merge: 2a3c389a0fde 7b4b0f6b34d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:44:49 2019 -0700

    Merge tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Evaluate PCI Boot Configuration _DSM to learn if firmware wants us
         to preserve its resource assignments (Benjamin Herrenschmidt)
    
       - Simplify resource distribution (Nicholas Johnson)
    
       - Decode 32 GT/s link speed (Gustavo Pimentel)
    
      Virtualization:
    
       - Fix incorrect caching of VF config space size (Alex Williamson)
    
       - Fix VF driver probing sysfs knobs (Alex Williamson)
    
      Peer-to-peer DMA:
    
       - Fix dma_virt_ops check (Logan Gunthorpe)
    
      Altera host bridge driver:
    
       - Allow building as module (Ley Foon Tan)
    
      Armada 8K host bridge driver:
    
       - add PHYs support (Miquel Raynal)
    
      DesignWare host bridge driver:
    
       - Export APIs to support removable loadable module (Vidya Sagar)
    
       - Enable Relaxed Ordering erratum workaround only on Tegra20 &
         Tegra30 (Vidya Sagar)
    
      Hyper-V host bridge driver:
    
       - Fix use-after-free in eject (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Clean up and fix many issues, including non-identify mapped
         windows, 64-bit windows, multi-MSI, class code, INTx clearing (Hou
         Zhiqiang)
    
      Qualcomm host bridge driver:
    
       - Use clk bulk API for 2.4.0 controllers (Bjorn Andersson)
    
       - Add QCS404 support (Bjorn Andersson)
    
       - Assert PERST for at least 100ms (Niklas Cassel)
    
      R-Car host bridge driver:
    
       - Add r8a774a1 DT support (Biju Das)
    
      Tegra host bridge driver:
    
       - Add support for Gen2, opportunistic UpdateFC and ACK (PCIe protocol
         details) AER, GPIO-based PERST# (Manikanta Maddireddy)
    
       - Fix many issues, including power-on failure cases, interrupt
         masking in suspend, UPHY settings, AFI dynamic clock gating,
         pending DLL transactions (Manikanta Maddireddy)
    
      Xilinx host bridge driver:
    
       - Fix NWL Multi-MSI programming (Bharat Kumar Gogada)
    
      Endpoint support:
    
       - Fix 64bit BAR support (Alan Mikhak)
    
       - Fix pcitest build issues (Alan Mikhak, Andy Shevchenko)
    
      Bug fixes:
    
       - Fix NVIDIA GPU multi-function power dependencies (Abhishek Sahu)
    
       - Fix NVIDIA GPU HDA enablement issue (Lukas Wunner)
    
       - Ignore lockdep for sysfs "remove" (Marek Vasut)
    
      Misc:
    
       - Convert docs to reST (Changbin Du, Mauro Carvalho Chehab)"
    
    * tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (107 commits)
      PCI: Enable NVIDIA HDA controllers
      tools: PCI: Fix installation when `make tools/pci_install`
      PCI: dwc: pci-dra7xx: Fix compilation when !CONFIG_GPIOLIB
      PCI: Fix typos and whitespace errors
      PCI: mobiveil: Fix INTx interrupt clearing in mobiveil_pcie_isr()
      PCI: mobiveil: Fix infinite-loop in the INTx handling function
      PCI: mobiveil: Move PCIe PIO enablement out of inbound window routine
      PCI: mobiveil: Add upper 32-bit PCI base address setup in inbound window
      PCI: mobiveil: Add upper 32-bit CPU base address setup in outbound window
      PCI: mobiveil: Mask out hardcoded bits in inbound/outbound windows setup
      PCI: mobiveil: Clear the control fields before updating it
      PCI: mobiveil: Add configured inbound windows counter
      PCI: mobiveil: Fix the valid check for inbound and outbound windows
      PCI: mobiveil: Clean-up program_{ib/ob}_windows()
      PCI: mobiveil: Remove an unnecessary return value check
      PCI: mobiveil: Fix error return values
      PCI: mobiveil: Refactor the MEM/IO outbound window initialization
      PCI: mobiveil: Make some register updates more readable
      PCI: mobiveil: Reformat the code for readability
      dt-bindings: PCI: mobiveil: Change gpio_slave and apb_csr to optional
      ...

commit 02bd45a28bf32993e396fdcfd7d7c7cdc0847ed1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 4 01:05:38 2019 +0200

    PM: sleep: Drop dev_pm_skip_next_resume_phases()
    
    After recent hibernation-related changes, there are no more callers
    of dev_pm_skip_next_resume_phases() except for the PM core itself
    in which it is more straightforward to run the statements from
    that function directly, so do that and drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 345d74a727e3..283fb3defe56 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -760,7 +760,6 @@ extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 
-extern void dev_pm_skip_next_resume_phases(struct device *dev);
 extern bool dev_pm_may_skip_resume(struct device *dev);
 extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
 

commit 151f4e2bdc7a04020ae5c533896fb91a16e1f501
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jun 13 07:10:36 2019 -0300

    docs: power: convert docs to ReST and rename to *.rst
    
    Convert the PM documents to ReST, in order to allow them to
    build with Sphinx.
    
    The conversion is actually:
      - add blank lines and indentation in order to identify paragraphs;
      - fix tables markups;
      - add some lists markups;
      - mark literal blocks;
      - adjust title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Srivatsa S. Bhat (VMware) <srivatsa@csail.mit.edu>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 66c19a65a514..c14ad8bc1a41 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -284,7 +284,7 @@ typedef struct pm_message {
  * actions to be performed by a device driver's callbacks generally depend on
  * the platform and subsystem the device belongs to.
  *
- * Refer to Documentation/power/runtime_pm.txt for more information about the
+ * Refer to Documentation/power/runtime_pm.rst for more information about the
  * role of the @runtime_suspend(), @runtime_resume() and @runtime_idle()
  * callbacks in device runtime power management.
  */

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 66c19a65a514..345d74a727e3 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -1,21 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *  pm.h - Power management interface
  *
  *  Copyright (C) 2000 Andrew Henroid
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #ifndef _LINUX_PM_H

commit 0996584b3026bed7f38abe02e8535e6a6c474118
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Mar 5 13:55:35 2019 +0100

    PM-runtime: Call pm_runtime_active|suspended_time() from sysfs
    
    Avoid the open-coding of the accounted time acquisition in
    runtime_active|suspend_time_show() and make them call
    pm_runtime_active|suspended_time() instead.
    
    Note that this change also indirectly avoids holding dev->power.lock
    around the do_div() computation and the sprintf() call which is an
    additional improvement.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 06f7ed893928..66c19a65a514 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -643,7 +643,6 @@ struct dev_pm_info {
 	struct dev_pm_qos	*qos;
 };
 
-extern void update_pm_runtime_accounting(struct device *dev);
 extern int dev_pm_get_subsys_data(struct device *dev);
 extern void dev_pm_put_subsys_data(struct device *dev);
 

commit 85945c28b5a888043cb2b54f880d80d8915f21f5
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Feb 14 18:29:10 2019 +0000

    PM / core: Add support to skip power management in device/driver model
    
    All device objects in the driver model contain fields that control the
    handling of various power management activities. However, it's not
    always useful. There are few instances where pseudo devices are added
    to the model just to take advantage of many other features like
    kobjects, udev events, and so on. One such example is cpu devices and
    their caches.
    
    The sysfs for the cpu caches are managed by adding devices with cpu
    as the parent in cpu_device_create() when secondary cpu is brought
    online. Generally when the secondary CPUs are hotplugged back in as part
    of resume from suspend-to-ram, we call cpu_device_create() from the cpu
    hotplug state machine while the cpu device associated with that CPU is
    not yet ready to be resumed as the device_resume() call happens bit
    later. It's not really needed to set the flag is_prepared for cpu
    devices as they are mostly pseudo device and hotplug framework deals
    with state machine and not managed through the cpu device.
    
    This often results in annoying warning when resuming:
    Enabling non-boot CPUs ...
    CPU1: Booted secondary processor
     cache: parent cpu1 should not be sleeping
    CPU1 is up
    CPU2: Booted secondary processor
     cache: parent cpu2 should not be sleeping
    CPU2 is up
    .... and so on.
    
    So in order to fix these kind of errors, we could just completely avoid
    doing any power management related initialisations and operations if
    they are not used by these devices.
    
    Add no_pm flags to indicate that the device doesn't require any sort of
    PM activities and all of them can be completely skipped. We can use the
    same flag to also avoid adding not used *power* sysfs entries for these
    devices. For now, lets use this for cpu cache devices.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Tested-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3d2cbf947768..06f7ed893928 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -592,6 +592,7 @@ struct dev_pm_info {
 	bool			is_suspended:1;	/* Ditto */
 	bool			is_noirq_suspended:1;
 	bool			is_late_suspended:1;
+	bool			no_pm:1;
 	bool			early_init:1;	/* Owned by the PM core */
 	bool			direct_complete:1;	/* Owned by the PM core */
 	u32			driver_flags;

commit a08c2a5a31941131c41feaa0429e4c8854cf48f2
Author: Thara Gopinath <thara.gopinath@linaro.org>
Date:   Wed Jan 23 08:50:14 2019 +0100

    PM-runtime: Replace jiffies-based accounting with ktime-based accounting
    
    Replace jiffies-based accounting for runtime_active_time and
    runtime_suspended_time with ktime-based accounting. This makes the
    runtime debug counters inline with genpd and other PM subsytems which
    use ktime-based accounting.
    
    Timekeeping is initialized before driver_init(). It's only at that time
    that PM-runtime can be enabled.
    
    Signed-off-by: Thara Gopinath <thara.gopinath@linaro.org>
    [switch from ktime to raw nsec]
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 0bd9de116826..3d2cbf947768 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -633,9 +633,9 @@ struct dev_pm_info {
 	int			runtime_error;
 	int			autosuspend_delay;
 	u64			last_busy;
-	unsigned long		active_jiffies;
-	unsigned long		suspended_jiffies;
-	unsigned long		accounting_timestamp;
+	u64			active_time;
+	u64			suspended_time;
+	u64			accounting_timestamp;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
 	void (*set_latency_tolerance)(struct device *, s32);

commit 8234f6734c5d74ac794e5517437f51c57d65f865
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Fri Dec 14 15:22:25 2018 +0100

    PM-runtime: Switch autosuspend over to using hrtimers
    
    PM-runtime uses the timer infrastructure for autosuspend. This implies
    that the minimum time before autosuspending a device is in the range
    of 1 tick included to 2 ticks excluded
     -On arm64 this means between 4ms and 8ms with default jiffies
      configuration
     -And on arm, it is between 10ms and 20ms
    
    These values are quite high for embedded systems which sometimes want
    the duration to be in the range of 1 ms.
    
    It is possible to switch autosuspend over to using hrtimers to get
    finer granularity for short durations and take advantage of slack to
    retain some margins and get long timeouts with minimum wakeups.
    
    On an arm64 platform that uses 1ms for autosuspending timeout of its
    GPU, idle power is reduced by 10% with hrtimer.
    
    The latency impact on arm64 hikey octo cores is:
     - mark_last_busy: from 1.11 us to 1.25 us
     - rpm_suspend: from 15.54 us to 15.38 us
    [Only the code path of rpm_suspend() that starts hrtimer has been
    measured.]
    
    arm64 image (arm64 default defconfig) decreases by around 3KB
    with following details:
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    12034646        6869268  386840 19290754        1265a82 vmlinux
    
    $ size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    12030550        6870164  387032 19287746        1264ec2 vmlinux
    
    The latency impact on arm 32bits snowball dual cores is :
     - mark_last_busy: from 0.31 us usec to 0.77 us
     - rpm_suspend: from 6.83 us to 6.67 usec
    
    The increase of the image for snowball platform that I used for
    testing performance impact, is neglictable (244B).
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    7157961 2119580  264120 9541661  91981d build-ux500/vmlinux
    
    size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    7157773 2119884  264248 9541905  919911 vmlinux-hrtimer
    
    And arm 32bits image (multi_v7_defconfig) increases by around 1.7KB
    with following details:
    
    $ size vmlinux-timer
       text    data     bss     dec     hex filename
    13304443        6803420  402768 20510631        138f7a7 vmlinux
    
    $ size vmlinux-hrtimer
       text    data     bss     dec     hex filename
    13304299        6805276  402768 20512343        138fe57 vmlinux
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e723b78d8357..0bd9de116826 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -26,6 +26,7 @@
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <linux/timer.h>
+#include <linux/hrtimer.h>
 #include <linux/completion.h>
 
 /*
@@ -608,7 +609,7 @@ struct dev_pm_info {
 	unsigned int		should_wakeup:1;
 #endif
 #ifdef CONFIG_PM
-	struct timer_list	suspend_timer;
+	struct hrtimer		suspend_timer;
 	unsigned long		timer_expires;
 	struct work_struct	work;
 	wait_queue_head_t	wait_queue;
@@ -631,7 +632,7 @@ struct dev_pm_info {
 	enum rpm_status		runtime_status;
 	int			runtime_error;
 	int			autosuspend_delay;
-	unsigned long		last_busy;
+	u64			last_busy;
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;

commit c51a024e3913e9dbaf4dfcb9aaba825668a89ace
Merge: 3487972d7fa6 34fb8f0ba9ce
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Dec 16 02:05:48 2017 +0100

    Merge back PM core material for v4.16.

commit 3487972d7fa6c5143951436ada5933dcf0ec659d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 7 02:41:18 2017 +0100

    PM / sleep: Avoid excess pm_runtime_enable() calls in device_resume()
    
    Middle-layer code doing suspend-time optimizations for devices with
    the DPM_FLAG_SMART_SUSPEND flag set (currently, the PCI bus type and
    the ACPI PM domain) needs to make the core skip ->thaw_early and
    ->thaw callbacks for those devices in some cases and it sets the
    power.direct_complete flag for them for this purpose.
    
    However, it turns out that setting power.direct_complete outside of
    the PM core is a bad idea as it triggers an excess invocation of
    pm_runtime_enable() in device_resume().
    
    For this reason, provide a helper to clear power.is_late_suspended
    and power.is_suspended to be invoked by the middle-layer code in
    question instead of setting power.direct_complete and make that code
    call the new helper.
    
    Fixes: c4b65157aeef (PCI / PM: Take SMART_SUSPEND driver flag into account)
    Fixes: 05087360fd7a (ACPI / PM: Take SMART_SUSPEND driver flag into account)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 65d39115f06d..492ed473ba7e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -765,6 +765,7 @@ extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 
+extern void dev_pm_skip_next_resume_phases(struct device *dev);
 extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */

commit 0d4b54c6fee87ff60b0bc1007ca487449698468d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 18 15:31:49 2017 +0100

    PM / core: Add LEAVE_SUSPENDED driver flag
    
    Define and document a new driver flag, DPM_FLAG_LEAVE_SUSPENDED, to
    instruct the PM core and middle-layer (bus type, PM domain, etc.)
    code that it is desirable to leave the device in runtime suspend
    after system-wide transitions to the working state (for example,
    the device may be slow to resume and it may be better to avoid
    resuming it right away).
    
    Generally, the middle-layer code involved in the handling of the
    device is expected to indicate to the PM core whether or not the
    device may be left in suspend with the help of the device's
    power.may_skip_resume status bit.  That has to happen in the "noirq"
    phase of the preceding system suspend (or analogous) transition.
    The middle layer is then responsible for handling the device as
    appropriate in its "noirq" resume callback which is executed
    regardless of whether or not the device may be left suspended, but
    the other resume callbacks (except for ->complete) will be skipped
    automatically by the core if the device really can be left in
    suspend.
    
    The additional power.must_resume status bit introduced for the
    implementation of this mechanisn is used internally by the PM core
    to track the requirement to resume the device (which may depend on
    its children etc).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 65d39115f06d..b5a40b713e9e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -556,9 +556,10 @@ struct pm_subsys_data {
  * These flags can be set by device drivers at the probe time.  They need not be
  * cleared by the drivers as the driver core will take care of that.
  *
- * NEVER_SKIP: Do not skip system suspend/resume callbacks for the device.
+ * NEVER_SKIP: Do not skip all system suspend/resume callbacks for the device.
  * SMART_PREPARE: Check the return value of the driver's ->prepare callback.
  * SMART_SUSPEND: No need to resume the device from runtime suspend.
+ * LEAVE_SUSPENDED: Avoid resuming the device during system resume if possible.
  *
  * Setting SMART_PREPARE instructs bus types and PM domains which may want
  * system suspend/resume callbacks to be skipped for the device to return 0 from
@@ -572,10 +573,14 @@ struct pm_subsys_data {
  * necessary from the driver's perspective.  It also may cause them to skip
  * invocations of the ->suspend_late and ->suspend_noirq callbacks provided by
  * the driver if they decide to leave the device in runtime suspend.
+ *
+ * Setting LEAVE_SUSPENDED informs the PM core and middle-layer code that the
+ * driver prefers the device to be left in suspend after system resume.
  */
-#define DPM_FLAG_NEVER_SKIP	BIT(0)
-#define DPM_FLAG_SMART_PREPARE	BIT(1)
-#define DPM_FLAG_SMART_SUSPEND	BIT(2)
+#define DPM_FLAG_NEVER_SKIP		BIT(0)
+#define DPM_FLAG_SMART_PREPARE		BIT(1)
+#define DPM_FLAG_SMART_SUSPEND		BIT(2)
+#define DPM_FLAG_LEAVE_SUSPENDED	BIT(3)
 
 struct dev_pm_info {
 	pm_message_t		power_state;
@@ -597,6 +602,8 @@ struct dev_pm_info {
 	bool			wakeup_path:1;
 	bool			syscore:1;
 	bool			no_pm_callbacks:1;	/* Owned by the PM core */
+	unsigned int		must_resume:1;	/* Owned by the PM core */
+	unsigned int		may_skip_resume:1;	/* Set by subsystems */
 #else
 	unsigned int		should_wakeup:1;
 #endif
@@ -765,6 +772,7 @@ extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 
+extern bool dev_pm_may_skip_resume(struct device *dev);
 extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */

commit c4b65157aeefad29b2351a00a010e8c40ce7fd0e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 26 12:12:22 2017 +0200

    PCI / PM: Take SMART_SUSPEND driver flag into account
    
    Make the PCI bus type take DPM_FLAG_SMART_SUSPEND into account in its
    system-wide PM callbacks and make sure that all code that should not
    run in parallel with pci_pm_runtime_resume() is executed in the "late"
    phases of system suspend, freeze and poweroff transitions.
    
    [Note that the pm_runtime_suspended() check in pci_dev_keep_suspended()
    is an optimization, because if is not passed, all of the subsequent
    checks may be skipped and some of them are much more overhead in
    general.]
    
    Also use the observation that if the device is in runtime suspend
    at the beginning of the "late" phase of a system-wide suspend-like
    transition, its state cannot change going forward (runtime PM is
    disabled for it at that time) until the transition is over and the
    subsequent system-wide PM callbacks should be skipped for it (as
    they generally assume the device to not be suspended), so add checks
    for that in pci_pm_suspend_late/noirq(), pci_pm_freeze_late/noirq()
    and pci_pm_poweroff_late/noirq().
    
    Moreover, if pci_pm_resume_noirq() or pci_pm_restore_noirq() is
    called during the subsequent system-wide resume transition and if
    the device was left in runtime suspend previously, its runtime PM
    status needs to be changed to "active" as it is going to be put
    into the full-power state, so add checks for that too to these
    functions.
    
    In turn, if pci_pm_thaw_noirq() runs after the device has been
    left in runtime suspend, the subsequent "thaw" callbacks need
    to be skipped for it (as they may not work correctly with a
    suspended device), so set the power.direct_complete flag for the
    device then to make the PM core skip those callbacks.
    
    In addition to the above add a core helper for checking if
    DPM_FLAG_SMART_SUSPEND is set and the device runtime PM status is
    "suspended" at the same time, which is done quite often in the new
    code (and will be done elsewhere going forward too).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 43b5418e05bb..65d39115f06d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -765,6 +765,8 @@ extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 
+extern bool dev_pm_smart_suspend_and_suspended(struct device *dev);
+
 #else /* !CONFIG_PM_SLEEP */
 
 #define device_pm_lock() do {} while (0)

commit 0eab11c9ae3b3cc5dd76f20b81d0247647a6e96f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Oct 26 12:12:08 2017 +0200

    PM / core: Add SMART_SUSPEND driver flag
    
    Define and document a SMART_SUSPEND flag to instruct bus types and PM
    domains that the system suspend callbacks provided by the driver can
    cope with runtime-suspended devices, so from the driver's perspective
    it should be safe to leave devices in runtime suspend during system
    suspend.
    
    Setting that flag may also cause middle-layer code (bus types,
    PM domains etc.) to skip invocations of the ->suspend_late and
    ->suspend_noirq callbacks provided by the driver if the device
    is in runtime suspend at the beginning of the "late" phase of
    the system-wide suspend transition, in which case the driver's
    system-wide resume callbacks may be invoked back-to-back with
    its ->runtime_suspend callback, so the driver has to be able to
    cope with that too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f10bad831bfa..43b5418e05bb 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -558,6 +558,7 @@ struct pm_subsys_data {
  *
  * NEVER_SKIP: Do not skip system suspend/resume callbacks for the device.
  * SMART_PREPARE: Check the return value of the driver's ->prepare callback.
+ * SMART_SUSPEND: No need to resume the device from runtime suspend.
  *
  * Setting SMART_PREPARE instructs bus types and PM domains which may want
  * system suspend/resume callbacks to be skipped for the device to return 0 from
@@ -565,9 +566,16 @@ struct pm_subsys_data {
  * other words, the system suspend/resume callbacks can only be skipped for the
  * device if its driver doesn't object against that).  This flag has no effect
  * if NEVER_SKIP is set.
+ *
+ * Setting SMART_SUSPEND instructs bus types and PM domains which may want to
+ * runtime resume the device upfront during system suspend that doing so is not
+ * necessary from the driver's perspective.  It also may cause them to skip
+ * invocations of the ->suspend_late and ->suspend_noirq callbacks provided by
+ * the driver if they decide to leave the device in runtime suspend.
  */
 #define DPM_FLAG_NEVER_SKIP	BIT(0)
 #define DPM_FLAG_SMART_PREPARE	BIT(1)
+#define DPM_FLAG_SMART_SUSPEND	BIT(2)
 
 struct dev_pm_info {
 	pm_message_t		power_state;

commit 08810a4119aaebf6318f209ec5dd9828e969cba4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 25 14:12:29 2017 +0200

    PM / core: Add NEVER_SKIP and SMART_PREPARE driver flags
    
    The motivation for this change is to provide a way to work around
    a problem with the direct-complete mechanism used for avoiding
    system suspend/resume handling for devices in runtime suspend.
    
    The problem is that some middle layer code (the PCI bus type and
    the ACPI PM domain in particular) returns positive values from its
    system suspend ->prepare callbacks regardless of whether the driver's
    ->prepare returns a positive value or 0, which effectively prevents
    drivers from being able to control the direct-complete feature.
    Some drivers need that control, however, and the PCI bus type has
    grown its own flag to deal with this issue, but since it is not
    limited to PCI, it is better to address it by adding driver flags at
    the core level.
    
    To that end, add a driver_flags field to struct dev_pm_info for flags
    that can be set by device drivers at the probe time to inform the PM
    core and/or bus types, PM domains and so on on the capabilities and/or
    preferences of device drivers.  Also add two static inline helpers
    for setting that field and testing it against a given set of flags
    and make the driver core clear it automatically on driver remove
    and probe failures.
    
    Define and document two PM driver flags related to the direct-
    complete feature: NEVER_SKIP and SMART_PREPARE that can be used,
    respectively, to indicate to the PM core that the direct-complete
    mechanism should never be used for the device and to inform the
    middle layer code (bus types, PM domains etc) that it can only
    request the PM core to use the direct-complete mechanism for
    the device (by returning a positive value from its ->prepare
    callback) if it also has been requested by the driver.
    
    While at it, make the core check pm_runtime_suspended() when
    setting power.direct_complete so that it doesn't need to be
    checked by ->prepare callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index a0ceeccf2846..f10bad831bfa 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -550,6 +550,25 @@ struct pm_subsys_data {
 #endif
 };
 
+/*
+ * Driver flags to control system suspend/resume behavior.
+ *
+ * These flags can be set by device drivers at the probe time.  They need not be
+ * cleared by the drivers as the driver core will take care of that.
+ *
+ * NEVER_SKIP: Do not skip system suspend/resume callbacks for the device.
+ * SMART_PREPARE: Check the return value of the driver's ->prepare callback.
+ *
+ * Setting SMART_PREPARE instructs bus types and PM domains which may want
+ * system suspend/resume callbacks to be skipped for the device to return 0 from
+ * their ->prepare callbacks if the driver's ->prepare callback returns 0 (in
+ * other words, the system suspend/resume callbacks can only be skipped for the
+ * device if its driver doesn't object against that).  This flag has no effect
+ * if NEVER_SKIP is set.
+ */
+#define DPM_FLAG_NEVER_SKIP	BIT(0)
+#define DPM_FLAG_SMART_PREPARE	BIT(1)
+
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
@@ -561,6 +580,7 @@ struct dev_pm_info {
 	bool			is_late_suspended:1;
 	bool			early_init:1;	/* Owned by the PM core */
 	bool			direct_complete:1;	/* Owned by the PM core */
+	u32			driver_flags;
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit 0e708fc602531b8355b5de6ea7c98f09129b223f
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Oct 3 09:11:07 2017 +0200

    PM / sleep: Remove pm_complete_with_resume_check()
    
    According to recent changes for ACPI, the are longer any users of
    pm_complete_with_resume_check(), thus let's drop it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 47ded8aa8a5d..a0ceeccf2846 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -736,7 +736,6 @@ extern int pm_generic_poweroff_noirq(struct device *dev);
 extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
-extern void pm_complete_with_resume_check(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */
 

commit 786f41fb6b008ea4341355b99083a38853a5311d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 02:09:22 2017 +0200

    PM / core: Split dpm_suspend_noirq() and dpm_resume_noirq()
    
    Put the device interrupts disabling and enabling as well as
    cpuidle_pause() and cpuidle_resume() called during the "noirq"
    stages of system suspend into separate functions to allow the
    core suspend-to-idle code to be optimized (later).
    
    The only functional difference this makes is that debug facilities
    and diagnostic tools will not include the above operations into the
    "noirq" device suspend/resume duration measurements.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b8b4df09fd8f..47ded8aa8a5d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -689,6 +689,8 @@ struct dev_pm_domain {
 extern void device_pm_lock(void);
 extern void dpm_resume_start(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);
+extern void dpm_noirq_resume_devices(pm_message_t state);
+extern void dpm_noirq_end(void);
 extern void dpm_resume_noirq(pm_message_t state);
 extern void dpm_resume_early(pm_message_t state);
 extern void dpm_resume(pm_message_t state);
@@ -697,6 +699,8 @@ extern void dpm_complete(pm_message_t state);
 extern void device_pm_unlock(void);
 extern int dpm_suspend_end(pm_message_t state);
 extern int dpm_suspend_start(pm_message_t state);
+extern void dpm_noirq_begin(void);
+extern int dpm_noirq_suspend_devices(pm_message_t state);
 extern int dpm_suspend_noirq(pm_message_t state);
 extern int dpm_suspend_late(pm_message_t state);
 extern int dpm_suspend(pm_message_t state);

commit de3ef1eb1cd0cc3a75f7a3661e10ed827f370ab8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:58:53 2017 +0200

    PM / core: Drop run_wake flag from struct dev_pm_info
    
    The run_wake flag in struct dev_pm_info is used to indicate whether
    or not the device is capable of generating remote wakeup signals at
    run time (or in the system working state), but the distinction
    between runtime remote wakeup and system wakeup signaling has always
    been rather artificial.  The only practical reason for it to exist
    at the core level was that ACPI and PCI treated those two cases
    differently, but that's not the case any more after recent changes.
    
    For this reason, get rid of the run_wake flag and, when applicable,
    use device_set_wakeup_capable() and device_can_wakeup() instead of
    device_set_run_wake() and device_run_wake(), respectively.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index a0894bc52bb4..b8b4df09fd8f 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -584,7 +584,6 @@ struct dev_pm_info {
 	unsigned int		idle_notification:1;
 	unsigned int		request_pending:1;
 	unsigned int		deferred_resume:1;
-	unsigned int		run_wake:1;
 	unsigned int		runtime_auto:1;
 	bool			ignore_children:1;
 	unsigned int		no_callbacks:1;

commit 2728b2d2e5be4b828a523a06089cd605419fc65c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 2 01:32:13 2017 +0100

    PM / core / docs: Convert sleep states API document to reST
    
    Move the document describing the system sleep state transitions API
    for devices to Documentation/driver-api/pm/, convert it to reST and
    update it to use current terminology.  Also remove the remaining
    reference to the old version of it from pm.h.
    
    The new document still contains references to some documents in the
    .txt format that will be converted later.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 10867b11d503..a0894bc52bb4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -276,9 +276,6 @@ typedef struct pm_message {
  * example, if it detects that a child was unplugged while the system was
  * asleep).
  *
- * Refer to Documentation/power/devices.txt for more information about the role
- * of the above callbacks in the system suspend process.
- *
  * There also are callbacks related to runtime power management of devices.
  * Again, as a rule these callbacks are executed by the PM core for subsystems
  * (PM domains, device types, classes and bus types) and the subsystem-level

commit 4d29b2e5ad37a50b186f828d73086cdbf36580bf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 2 01:30:49 2017 +0100

    PM / core: Update kerneldoc comments in pm.h
    
    Refresh the struct dev_pm_ops kerneldoc comment, so that it looks
    better and is more readable after processing by Sphinx, and drop
    the kerneldoc marker from a few other comments ("PM_EVENT_ messages"
    and a couple of enum types declarations) which are not proper
    kerneldoc and generally confuse Sphinx.
    
    Also change the comment describing struct dev_pm_domain into
    a kerneldoc one.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f926af41e122..10867b11d503 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -64,24 +64,7 @@ typedef struct pm_message {
 } pm_message_t;
 
 /**
- * struct dev_pm_ops - device PM callbacks
- *
- * Several device power state transitions are externally visible, affecting
- * the state of pending I/O queues and (for drivers that touch hardware)
- * interrupts, wakeups, DMA, and other hardware state.  There may also be
- * internal transitions to various low-power modes which are transparent
- * to the rest of the driver stack (such as a driver that's ON gating off
- * clocks which are not in active use).
- *
- * The externally visible transitions are handled with the help of callbacks
- * included in this structure in such a way that two levels of callbacks are
- * involved.  First, the PM core executes callbacks provided by PM domains,
- * device types, classes and bus types.  They are the subsystem-level callbacks
- * supposed to execute callbacks provided by device drivers, although they may
- * choose not to do that.  If the driver callbacks are executed, they have to
- * collaborate with the subsystem-level callbacks to achieve the goals
- * appropriate for the given system transition, given transition phase and the
- * subsystem the device belongs to.
+ * struct dev_pm_ops - device PM callbacks.
  *
  * @prepare: The principal role of this callback is to prevent new children of
  *	the device from being registered after it has returned (the driver's
@@ -240,34 +223,6 @@ typedef struct pm_message {
  *	driver's interrupt handler, which is guaranteed not to run while
  *	@restore_noirq() is being executed.  Analogous to @resume_noirq().
  *
- * All of the above callbacks, except for @complete(), return error codes.
- * However, the error codes returned by the resume operations, @resume(),
- * @thaw(), @restore(), @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do
- * not cause the PM core to abort the resume transition during which they are
- * returned.  The error codes returned in those cases are only printed by the PM
- * core to the system logs for debugging purposes.  Still, it is recommended
- * that drivers only return error codes from their resume methods in case of an
- * unrecoverable failure (i.e. when the device being handled refuses to resume
- * and becomes unusable) to allow us to modify the PM core in the future, so
- * that it can avoid attempting to handle devices that failed to resume and
- * their children.
- *
- * It is allowed to unregister devices while the above callbacks are being
- * executed.  However, a callback routine must NOT try to unregister the device
- * it was called for, although it may unregister children of that device (for
- * example, if it detects that a child was unplugged while the system was
- * asleep).
- *
- * Refer to Documentation/power/admin-guide/devices.rst for more information about the role
- * of the above callbacks in the system suspend process.
- *
- * There also are callbacks related to runtime power management of devices.
- * Again, these callbacks are executed by the PM core only for subsystems
- * (PM domains, device types, classes and bus types) and the subsystem-level
- * callbacks are supposed to invoke the driver callbacks.  Moreover, the exact
- * actions to be performed by a device driver's callbacks generally depend on
- * the platform and subsystem the device belongs to.
- *
  * @runtime_suspend: Prepare the device for a condition in which it won't be
  *	able to communicate with the CPU(s) and RAM due to power management.
  *	This need not mean that the device should be put into a low-power state.
@@ -287,11 +242,54 @@ typedef struct pm_message {
  *	Check these conditions, and return 0 if it's appropriate to let the PM
  *	core queue a suspend request for the device.
  *
- * Refer to Documentation/power/runtime_pm.txt for more information about the
- * role of the above callbacks in device runtime power management.
+ * Several device power state transitions are externally visible, affecting
+ * the state of pending I/O queues and (for drivers that touch hardware)
+ * interrupts, wakeups, DMA, and other hardware state.  There may also be
+ * internal transitions to various low-power modes which are transparent
+ * to the rest of the driver stack (such as a driver that's ON gating off
+ * clocks which are not in active use).
  *
+ * The externally visible transitions are handled with the help of callbacks
+ * included in this structure in such a way that, typically, two levels of
+ * callbacks are involved.  First, the PM core executes callbacks provided by PM
+ * domains, device types, classes and bus types.  They are the subsystem-level
+ * callbacks expected to execute callbacks provided by device drivers, although
+ * they may choose not to do that.  If the driver callbacks are executed, they
+ * have to collaborate with the subsystem-level callbacks to achieve the goals
+ * appropriate for the given system transition, given transition phase and the
+ * subsystem the device belongs to.
+ *
+ * All of the above callbacks, except for @complete(), return error codes.
+ * However, the error codes returned by @resume(), @thaw(), @restore(),
+ * @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do not cause the PM
+ * core to abort the resume transition during which they are returned.  The
+ * error codes returned in those cases are only printed to the system logs for
+ * debugging purposes.  Still, it is recommended that drivers only return error
+ * codes from their resume methods in case of an unrecoverable failure (i.e.
+ * when the device being handled refuses to resume and becomes unusable) to
+ * allow the PM core to be modified in the future, so that it can avoid
+ * attempting to handle devices that failed to resume and their children.
+ *
+ * It is allowed to unregister devices while the above callbacks are being
+ * executed.  However, a callback routine MUST NOT try to unregister the device
+ * it was called for, although it may unregister children of that device (for
+ * example, if it detects that a child was unplugged while the system was
+ * asleep).
+ *
+ * Refer to Documentation/power/devices.txt for more information about the role
+ * of the above callbacks in the system suspend process.
+ *
+ * There also are callbacks related to runtime power management of devices.
+ * Again, as a rule these callbacks are executed by the PM core for subsystems
+ * (PM domains, device types, classes and bus types) and the subsystem-level
+ * callbacks are expected to invoke the driver callbacks.  Moreover, the exact
+ * actions to be performed by a device driver's callbacks generally depend on
+ * the platform and subsystem the device belongs to.
+ *
+ * Refer to Documentation/power/runtime_pm.txt for more information about the
+ * role of the @runtime_suspend(), @runtime_resume() and @runtime_idle()
+ * callbacks in device runtime power management.
  */
-
 struct dev_pm_ops {
 	int (*prepare)(struct device *dev);
 	void (*complete)(struct device *dev);
@@ -391,7 +389,7 @@ const struct dev_pm_ops name = { \
 	SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
 }
 
-/**
+/*
  * PM_EVENT_ messages
  *
  * The following PM_EVENT_ messages are defined for the internal use of the PM
@@ -487,7 +485,7 @@ const struct dev_pm_ops name = { \
 
 #define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
 
-/**
+/*
  * Device run-time power management status.
  *
  * These status labels are used internally by the PM core to indicate the
@@ -517,7 +515,7 @@ enum rpm_status {
 	RPM_SUSPENDING,
 };
 
-/**
+/*
  * Device run-time power management request types.
  *
  * RPM_REQ_NONE		Do nothing.
@@ -616,15 +614,18 @@ extern void update_pm_runtime_accounting(struct device *dev);
 extern int dev_pm_get_subsys_data(struct device *dev);
 extern void dev_pm_put_subsys_data(struct device *dev);
 
-/*
- * Power domains provide callbacks that are executed during system suspend,
- * hibernation, system resume and during runtime PM transitions along with
- * subsystem-level and driver-level callbacks.
+/**
+ * struct dev_pm_domain - power management domain representation.
  *
+ * @ops: Power management operations associated with this domain.
  * @detach: Called when removing a device from the domain.
  * @activate: Called before executing probe routines for bus types and drivers.
  * @sync: Called after successful driver probe.
  * @dismiss: Called after unsuccessful driver probe and after driver removal.
+ *
+ * Power domains provide callbacks that are executed during system suspend,
+ * hibernation, system resume and during runtime PM transitions instead of
+ * subsystem-level and driver-level callbacks.
  */
 struct dev_pm_domain {
 	struct dev_pm_ops	ops;

commit 098c30557a9a19827240aaadc137e4668157dc6b
Merge: 72cca7baf4fb 5d47ec02c37e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 11:42:18 2016 -0800

    Merge tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the new driver core patches for 4.10-rc1.
    
      Big thing here is the nice addition of "functional dependencies" to
      the driver core. The idea has been talked about for a very long time,
      great job to Rafael for stepping up and implementing it. It's been
      tested for longer than the 4.9-rc1 date, we held off on merging it
      earlier in order to feel more comfortable about it.
    
      Other than that, it's just a handful of small other patches, some good
      cleanups to the mess that is the firmware class code, and we have a
      test driver for the deferred probe logic.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (30 commits)
      firmware: Correct handling of fw_state_wait() return value
      driver core: Silence device links sphinx warning
      firmware: remove warning at documentation generation time
      drivers: base: dma-mapping: Fix typo in dmam_alloc_non_coherent comments
      driver core: test_async: fix up typo found by 0-day
      firmware: move fw_state_is_done() into UHM section
      firmware: do not use fw_lock for fw_state protection
      firmware: drop bit ops in favor of simple state machine
      firmware: refactor loading status
      firmware: fix usermode helper fallback loading
      driver core: firmware_class: convert to use class_groups
      driver core: devcoredump: convert to use class_groups
      driver core: class: add class_groups support
      kernfs: Declare two local data structures static
      driver-core: fix platform_no_drv_owner.cocci warnings
      drivers/base/memory.c: Remove unused 'first_page' variable
      driver core: add CLASS_ATTR_WO()
      drivers: base: cacheinfo: support DT overrides for cache properties
      drivers: base: cacheinfo: add pr_fmt logging
      drivers: base: cacheinfo: fix boot error message when acpi is enabled
      ...

commit baa8809f60971d10220dfe79248f54b2b265f003
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:43 2016 +0100

    PM / runtime: Optimize the use of device links
    
    If the device has no links to suppliers that should be used for
    runtime PM (links with DEVICE_LINK_PM_RUNTIME set), there is no
    reason to walk the list of suppliers for that device during
    runtime suspend and resume.
    
    Add a simple mechanism to detect that case and possibly avoid the
    extra unnecessary overhead.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 721a70241fcd..ccfe00ecc7e6 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -597,6 +597,7 @@ struct dev_pm_info {
 	unsigned int		use_autosuspend:1;
 	unsigned int		timer_autosuspends:1;
 	unsigned int		memalloc_noio:1;
+	unsigned int		links_count;
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;

commit 9ed9895370aedd6032af2a9181c62c394d08223b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Oct 30 17:32:16 2016 +0100

    driver core: Functional dependencies tracking support
    
    Currently, there is a problem with taking functional dependencies
    between devices into account.
    
    What I mean by a "functional dependency" is when the driver of device
    B needs device A to be functional and (generally) its driver to be
    present in order to work properly.  This has certain consequences
    for power management (suspend/resume and runtime PM ordering) and
    shutdown ordering of these devices.  In general, it also implies that
    the driver of A needs to be working for B to be probed successfully
    and it cannot be unbound from the device before the B's driver.
    
    Support for representing those functional dependencies between
    devices is added here to allow the driver core to track them and act
    on them in certain cases where applicable.
    
    The argument for doing that in the driver core is that there are
    quite a few distinct use cases involving device dependencies, they
    are relatively hard to get right in a driver (if one wants to
    address all of them properly) and it only gets worse if multiplied
    by the number of drivers potentially needing to do it.  Morever, at
    least one case (asynchronous system suspend/resume) cannot be handled
    in a single driver at all, because it requires the driver of A to
    wait for B to suspend (during system suspend) and the driver of B to
    wait for A to resume (during system resume).
    
    For this reason, represent dependencies between devices as "links",
    with the help of struct device_link objects each containing pointers
    to the "linked" devices, a list node for each of them, status
    information, flags, and an RCU head for synchronization.
    
    Also add two new list heads, representing the lists of links to the
    devices that depend on the given one (consumers) and to the devices
    depended on by it (suppliers), and a "driver presence status" field
    (needed for figuring out initial states of device links) to struct
    device.
    
    The entire data structure consisting of all of the lists of link
    objects for all devices is protected by a mutex (for link object
    addition/removal and for list walks during device driver probing
    and removal) and by SRCU (for list walking in other case that will
    be introduced by subsequent change sets).  If CONFIG_SRCU is not
    selected, however, an rwsem is used for protecting the entire data
    structure.
    
    In addition, each link object has an internal status field whose
    value reflects whether or not drivers are bound to the devices
    pointed to by the link or probing/removal of their drivers is in
    progress etc.  That field is only modified under the device links
    mutex, but it may be read outside of it in some cases (introduced by
    subsequent change sets), so modifications of it are annotated with
    WRITE_ONCE().
    
    New links are added by calling device_link_add() which takes three
    arguments: pointers to the devices in question and flags.  In
    particular, if DL_FLAG_STATELESS is set in the flags, the link status
    is not to be taken into account for this link and the driver core
    will not manage it.  In turn, if DL_FLAG_AUTOREMOVE is set in the
    flags, the driver core will remove the link automatically when the
    consumer device driver unbinds from it.
    
    One of the actions carried out by device_link_add() is to reorder
    the lists used for device shutdown and system suspend/resume to
    put the consumer device along with all of its children and all of
    its consumers (and so on, recursively) to the ends of those lists
    in order to ensure the right ordering between all of the supplier
    and consumer devices.
    
    For this reason, it is not possible to create a link between two
    devices if the would-be supplier device already depends on the
    would-be consumer device as either a direct descendant of it or a
    consumer of one of its direct descendants or one of its consumers
    and so on.
    
    There are two types of link objects, persistent and non-persistent.
    The persistent ones stay around until one of the target devices is
    deleted, while the non-persistent ones are removed automatically when
    the consumer driver unbinds from its device (ie. they are assumed to
    be valid only as long as the consumer device has a driver bound to
    it).  Persistent links are created by default and non-persistent
    links are created when the DL_FLAG_AUTOREMOVE flag is passed
    to device_link_add().
    
    Both persistent and non-persistent device links can be deleted
    with an explicit call to device_link_del().
    
    Links created without the DL_FLAG_STATELESS flag set are managed
    by the driver core using a simple state machine.  There are 5 states
    each link can be in: DORMANT (unused), AVAILABLE (the supplier driver
    is present and functional), CONSUMER_PROBE (the consumer driver is
    probing), ACTIVE (both supplier and consumer drivers are present and
    functional), and SUPPLIER_UNBIND (the supplier driver is unbinding).
    The driver core updates the link state automatically depending on
    what happens to the linked devices and for each link state specific
    actions are taken in addition to that.
    
    For example, if the supplier driver unbinds from its device, the
    driver core will also unbind the drivers of all of its consumers
    automatically under the assumption that they cannot function
    properly without the supplier.  Analogously, the driver core will
    only allow the consumer driver to bind to its device if the
    supplier driver is present and functional (ie. the link is in
    the AVAILABLE state).  If that's not the case, it will rely on
    the existing deferred probing mechanism to wait for the supplier
    driver to become available.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 06eb353182ab..721a70241fcd 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -559,6 +559,7 @@ struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
+	bool			in_dpm_list:1;	/* Owned by the PM core */
 	bool			is_prepared:1;	/* Owned by the PM core */
 	bool			is_suspended:1;	/* Ditto */
 	bool			is_noirq_suspended:1;

commit 8c27ceff3604b249a9efafbd1bd8b141b79e619d
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 10:12:27 2016 -0200

    docs: fix locations of several documents that got moved
    
    The previous patch renamed several files that are cross-referenced
    along the Kernel documentation. Adjust the links to point to
    the right places.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 06eb353182ab..efa67b2dfee9 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -258,7 +258,7 @@ typedef struct pm_message {
  * example, if it detects that a child was unplugged while the system was
  * asleep).
  *
- * Refer to Documentation/power/devices.txt for more information about the role
+ * Refer to Documentation/power/admin-guide/devices.rst for more information about the role
  * of the above callbacks in the system suspend process.
  *
  * There also are callbacks related to runtime power management of devices.

commit 372a12ed9d99c02f105278a9b75f0cb176d15cc1
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Apr 8 13:40:53 2016 +0200

    PM / Runtime: Move ignore_children flag under CONFIG_PM
    
    The ignore_children flag is used only when CONFIG_PM is set, so let's move
    it into that section within the struct dev_pm_info.
    
    Move also the corresponding pm_suspend_ignore_children() API out of
    device.h into pm_runtime.h, to be consistent with similar APIs.
    
    Unfortunate this causes the Toshiba PCI SD mmc host driver to fail to
    compile as it needs pm_runtime.h, so let's fix this here as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6a5d654f4447..06eb353182ab 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -563,7 +563,6 @@ struct dev_pm_info {
 	bool			is_suspended:1;	/* Ditto */
 	bool			is_noirq_suspended:1;
 	bool			is_late_suspended:1;
-	bool			ignore_children:1;
 	bool			early_init:1;	/* Owned by the PM core */
 	bool			direct_complete:1;	/* Owned by the PM core */
 	spinlock_t		lock;
@@ -591,6 +590,7 @@ struct dev_pm_info {
 	unsigned int		deferred_resume:1;
 	unsigned int		run_wake:1;
 	unsigned int		runtime_auto:1;
+	bool			ignore_children:1;
 	unsigned int		no_callbacks:1;
 	unsigned int		irq_safe:1;
 	unsigned int		use_autosuspend:1;

commit aa8e54b559479d0cb7eb632ba443b8cacd20cd4b
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:14 2016 +0100

    PM / sleep: Go direct_complete if driver has no callbacks
    
    If a suitable prepare callback cannot be found for a given device and
    its driver has no PM callbacks at all, assume that it can go direct to
    complete when the system goes to sleep.
    
    The reason for this is that there's lots of devices in a system that do
    no PM at all and there's no reason for them to prevent their ancestors
    to do direct_complete if they can support it.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 528be6787796..6a5d654f4447 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -573,6 +573,7 @@ struct dev_pm_info {
 	struct wakeup_source	*wakeup;
 	bool			wakeup_path:1;
 	bool			syscore:1;
+	bool			no_pm_callbacks:1;	/* Owned by the PM core */
 #else
 	unsigned int		should_wakeup:1;
 #endif

commit 58a1fbbb2ee873dd1fe327e80bc7b08e80866269
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 7 00:50:24 2015 +0200

    PM / PCI / ACPI: Kick devices that might have been reset by firmware
    
    There is a concern that if the platform firmware was involved in
    the system resume that's being completed,  some devices might have
    been reset by it and if those devices had the power.direct_complete
    flag set during the preceding suspend transition, they may stay
    in a reset-power-on state indefinitely (until they are runtime-resumed
    and then suspended again).  That may not be a big deal from the
    individual device's perspective, but if the system is an SoC, it may
    be prevented from entering deep SoC-wide low-power states on idle
    because of that.
    
    The devices that are most likely to be affected by this issue are
    PCI devices and ACPI-enumerated devices using the general ACPI PM
    domain, so to prevent it from happening for those devices, force a
    runtime resume for them if they have their power.direct_complete
    flags set and the platform firmware was involved in the resume
    transition currently in progress.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 35d599e7250d..528be6787796 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -732,6 +732,7 @@ extern int pm_generic_poweroff_noirq(struct device *dev);
 extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
+extern void pm_complete_with_resume_check(struct device *dev);
 
 #else /* !CONFIG_PM_SLEEP */
 

commit 0d85fd42114ce97f209f3deb91ea0ac992c56013
Merge: ab232ba57043 db874c7e1055
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 19 01:18:14 2015 +0200

    Merge branch 'pm-wakeirq'
    
    * pm-wakeirq:
      PM / wakeirq: Fix typo in prototype for dev_pm_set_dedicated_wake_irq
      PM / Wakeirq: Add automated device wake IRQ handling

commit 4990d4fe327b9d9a7a3be7103a82699406fdde69
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon May 18 15:40:29 2015 -0700

    PM / Wakeirq: Add automated device wake IRQ handling
    
    Turns out we can automate the handling for the device_may_wakeup()
    quite a bit by using the kernel wakeup source list as suggested
    by Rafael J. Wysocki <rjw@rjwysocki.net>.
    
    And as some hardware has separate dedicated wake-up interrupt
    in addition to the IO interrupt, we can automate the handling by
    adding a generic threaded interrupt handler that just calls the
    device PM runtime to wake up the device.
    
    This allows dropping code from device drivers as we currently
    are doing it in multiple ways, and often wrong.
    
    For most drivers, we should be able to drop the following
    boilerplate code from runtime_suspend and runtime_resume
    functions:
    
            ...
            device_init_wakeup(dev, true);
            ...
            if (device_may_wakeup(dev))
                    enable_irq_wake(irq);
            ...
            if (device_may_wakeup(dev))
                    disable_irq_wake(irq);
            ...
            device_init_wakeup(dev, false);
            ...
    
    We can replace it with just the following init and exit
    time code:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    And for hardware with dedicated wake-up interrupts:
    
            ...
            device_init_wakeup(dev, true);
            dev_pm_set_dedicated_wake_irq(dev, irq);
            ...
            dev_pm_clear_wake_irq(dev);
            device_init_wakeup(dev, false);
            ...
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 2d29c64f8fb1..1c4ed0cb7907 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -529,6 +529,7 @@ enum rpm_request {
 };
 
 struct wakeup_source;
+struct wake_irq;
 struct pm_domain_data;
 
 struct pm_subsys_data {
@@ -568,6 +569,7 @@ struct dev_pm_info {
 	unsigned long		timer_expires;
 	struct work_struct	work;
 	wait_queue_head_t	wait_queue;
+	struct wake_irq		*wakeirq;
 	atomic_t		usage_count;
 	atomic_t		child_count;
 	unsigned int		disable_depth:3;

commit 020af89a41c41fd2c92d0da524968dfaba6269f0
Author: Grygorii Strashko <Grygorii.Strashko@linaro.org>
Date:   Mon Apr 27 21:24:30 2015 +0300

    PM / sleep: Add macro to define common noirq system PM callbacks
    
    The same approach is used as for the existing SET_SYSTEM_SLEEP_PM_OPS,
    but for noirq callbacks.
    
    New SET_NOIRQ_SYSTEM_SLEEP_PM_OPS, defined for CONFIG_PM_SLEEP, will
    point ->suspend_noirq, ->freeze_noirq and ->poweroff_noirq to the same
    function. Vice versa happens for ->resume_noirq, ->thaw_noirq and
    ->restore_noirq.
    
    Signed-off-by: Grygorii Strashko <Grygorii.Strashko@linaro.org>
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 2d29c64f8fb1..4890743892ef 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -342,6 +342,18 @@ struct dev_pm_ops {
 #define SET_LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
 #endif
 
+#ifdef CONFIG_PM_SLEEP
+#define SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
+	.suspend_noirq = suspend_fn, \
+	.resume_noirq = resume_fn, \
+	.freeze_noirq = suspend_fn, \
+	.thaw_noirq = resume_fn, \
+	.poweroff_noirq = suspend_fn, \
+	.restore_noirq = resume_fn,
+#else
+#define SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
+#endif
+
 #ifdef CONFIG_PM
 #define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
 	.runtime_suspend = suspend_fn, \

commit e90d5532773e2bcccc538dd346b9fc3482cd700c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Mar 20 13:59:27 2015 +0100

    driver core / PM: Add PM domain callbacks for device setup/cleanup
    
    If PM domains are in use, it may be necessary to prepare the code
    handling a PM domain for driver probing.  For example, in some
    cases device drivers rely on the ability to power on the devices
    with the help of the IO runtime PM framework and the PM domain
    code needs to be ready for that.  Also, if that code has not been
    fully initialized yet, the driver probing should be deferred.
    
    Moreover, after the probing is complete, it may be necessary to
    put the PM domain in question into the state reflecting the current
    needs of the devices in it, for example, so that power is not drawn
    in vain.  The same should be done after removing a driver from
    a device, as the PM domain state may need to be changed to reflect
    the new situation.
    
    For these reasons, introduce new PM domain callbacks, ->activate,
    ->sync and ->dismiss called, respectively, before probing for a
    device driver, after the probing has completed successfully and
    if the probing has failed or the driver has been removed.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e2f1be6dd9dd..2d29c64f8fb1 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -603,10 +603,18 @@ extern void dev_pm_put_subsys_data(struct device *dev);
  * Power domains provide callbacks that are executed during system suspend,
  * hibernation, system resume and during runtime PM transitions along with
  * subsystem-level and driver-level callbacks.
+ *
+ * @detach: Called when removing a device from the domain.
+ * @activate: Called before executing probe routines for bus types and drivers.
+ * @sync: Called after successful driver probe.
+ * @dismiss: Called after unsuccessful driver probe and after driver removal.
  */
 struct dev_pm_domain {
 	struct dev_pm_ops	ops;
 	void (*detach)(struct device *dev, bool power_off);
+	int (*activate)(struct device *dev);
+	void (*sync)(struct device *dev);
+	void (*dismiss)(struct device *dev);
 };
 
 /*

commit 1e95e3b2da424db68d0a465273f1901a990c6277
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Jan 29 18:39:05 2015 +0100

    PM: Convert dev_pm_put_subsys_data() into a void function
    
    Clients using the dev_pm_put_subsys_data() API isn't interested of a
    return value. They care only of decreasing a reference to the device's
    pm_subsys_data. So, let's convert the API to a void function, which
    anyway seems like reasonable thing to do.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 8b5976364619..e2f1be6dd9dd 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -597,7 +597,7 @@ struct dev_pm_info {
 
 extern void update_pm_runtime_accounting(struct device *dev);
 extern int dev_pm_get_subsys_data(struct device *dev);
-extern int dev_pm_put_subsys_data(struct device *dev);
+extern void dev_pm_put_subsys_data(struct device *dev);
 
 /*
  * Power domains provide callbacks that are executed during system suspend,

commit 40bd62c6194bdee1bc6652b3b0aa28e34883f603
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Dec 11 11:20:36 2014 +0100

    PM: Remove the SET_PM_RUNTIME_PM_OPS() macro
    
    There're now no users left of the SET_PM_RUNTIME_PM_OPS() macro, since
    all have converted to use the SET_RUNTIME_PM_OPS() macro instead, so
    let's remove it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 66a656eb335b..8b5976364619 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -351,8 +351,6 @@ struct dev_pm_ops {
 #define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)
 #endif
 
-#define SET_PM_RUNTIME_PM_OPS	SET_RUNTIME_PM_OPS
-
 /*
  * Use this if you want to use the same suspend and resume callbacks for suspend
  * to RAM and hibernation.

commit e3d857e1ae787a5e268bc89425aadae09c8e95a4
Merge: cfc75ed68ba7 2713775bf570
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Dec 8 20:00:44 2014 +0100

    Merge branch 'pm-runtime'
    
    * pm-runtime: (25 commits)
      i2c-omap / PM: Drop CONFIG_PM_RUNTIME from i2c-omap.c
      dmaengine / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      drivers: sh / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      e1000e / igb / PM: Eliminate CONFIG_PM_RUNTIME
      MMC / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      MFD / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      misc / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      media / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      input / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      iio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hsi / OMAP / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      i2c-hid / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      drm / exynos / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      gpio / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      hwrandom / exynos / PM: Use CONFIG_PM in #ifdef
      block / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
      PM: Merge the SET*_RUNTIME_PM_OPS() macros
      PM / Kconfig: Do not select PM directly from Kconfig files
      PCI / PM: Drop CONFIG_PM_RUNTIME from the PCI core
      ...

commit 6ed23b806e73bdd5b17722df507b0f4570c606b6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 4 00:34:11 2014 +0100

    PM: Merge the SET*_RUNTIME_PM_OPS() macros
    
    The SET_PM_RUNTIME_PM_OPS() and SET_RUNTIME_PM_OPS() macros are
    identical except that one of them is not empty for CONFIG_PM set,
    while the other one is not empty for CONFIG_PM_RUNTIME set,
    respectively.
    
    However, after commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if
    PM_SLEEP is selected) PM_RUNTIME is always set if PM is set, so one
    of these macros is now redundant.
    
    For this reason, replace SET_PM_RUNTIME_PM_OPS() with
    SET_RUNTIME_PM_OPS() everywhere and redefine the SET_PM_RUNTIME_PM_OPS
    symbol as SET_RUNTIME_PM_OPS in case new code is starting to use the
    macro being removed here.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 53b56cf5db3f..1dc338f6d4a9 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -342,7 +342,7 @@ struct dev_pm_ops {
 #define SET_LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
 #endif
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 #define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
 	.runtime_suspend = suspend_fn, \
 	.runtime_resume = resume_fn, \
@@ -351,14 +351,7 @@ struct dev_pm_ops {
 #define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)
 #endif
 
-#ifdef CONFIG_PM
-#define SET_PM_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
-	.runtime_suspend = suspend_fn, \
-	.runtime_resume = resume_fn, \
-	.runtime_idle = idle_fn,
-#else
-#define SET_PM_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)
-#endif
+#define SET_PM_RUNTIME_PM_OPS	SET_RUNTIME_PM_OPS
 
 /*
  * Use this if you want to use the same suspend and resume callbacks for suspend

commit d30d819dc83107812d9b2876e5e7194e511ed6af
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 27 22:38:05 2014 +0100

    PM: Drop CONFIG_PM_RUNTIME from the driver core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM or even may be dropped entirely in some cases.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the PM core code.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 383fd68aaee1..53b56cf5db3f 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -576,7 +576,7 @@ struct dev_pm_info {
 #else
 	unsigned int		should_wakeup:1;
 #endif
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 	struct timer_list	suspend_timer;
 	unsigned long		timer_expires;
 	struct work_struct	work;

commit 00e7c295968d74f4dbb00aef8334fafe788e3c89
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Nov 14 08:41:32 2014 +0100

    PM / Domains: Move struct pm_domain_data to pm_domain.h
    
    The definition of the struct pm_domain_data better belongs in the
    header for the PM domains, let's move it there.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 383fd68aaee1..45e3e78c1e3a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -538,11 +538,7 @@ enum rpm_request {
 };
 
 struct wakeup_source;
-
-struct pm_domain_data {
-	struct list_head list_node;
-	struct device *dev;
-};
+struct pm_domain_data;
 
 struct pm_subsys_data {
 	spinlock_t lock;

commit 49a09c9ab012017c4673b86dbb28c616cf8f2381
Merge: 28c399e2a1ed f39cb1797ec1
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 7 01:18:12 2014 +0200

    Merge branch 'pm-domains'
    
    * pm-domains: (32 commits)
      PM / Domains: Rename cpu_data to cpuidle_data
      PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
      PM / Domains: Remove legacy API for adding devices through DT
      PM / Domains: Add genpd attach/detach callbacks
      PM / Domains: add debugfs listing of struct generic_pm_domain-s
      ACPI / PM: Convert acpi_dev_pm_detach() into a static function
      ARM: exynos: Move to generic PM domain DT bindings
      amba: Add support for attach/detach of PM domains
      spi: core: Convert to dev_pm_domain_attach|detach()
      mmc: sdio: Convert to dev_pm_domain_attach|detach()
      i2c: core: Convert to dev_pm_domain_attach|detach()
      drivercore / platform: Convert to dev_pm_domain_attach|detach()
      PM / Domains: Add APIs to attach/detach a PM domain for a device
      PM / Domains: Add generic OF-based PM domain look-up
      ACPI / PM: Assign the ->detach() callback when attaching the PM domain
      PM / Domains: Add a detach callback to the struct dev_pm_domain
      PM / domains: Spelling s/domian/domain/
      PM / domains: Keep declaration of dev_power_governors together
      PM / domains: Remove default_stop_ok() API
      drivers: sh: Leave disabling of unused PM domains to genpd
      ...

commit 2a8a8ce651d3a88fdf83e2ed15633c8d19292108
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Sep 30 02:21:34 2014 +0200

    PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
    
    Subsequent change sets will add platform-related operations between
    dpm_suspend_late() and dpm_suspend_noirq() as well as between
    dpm_resume_noirq() and dpm_resume_early() in suspend_enter(), so
    export these functions for suspend_enter() to be able to call them
    separately and split the invocations of dpm_suspend_end() and
    dpm_resume_start() in there accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 72c0fe098a27..e1c00b7ee913 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -679,12 +679,16 @@ struct dev_pm_domain {
 extern void device_pm_lock(void);
 extern void dpm_resume_start(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);
+extern void dpm_resume_noirq(pm_message_t state);
+extern void dpm_resume_early(pm_message_t state);
 extern void dpm_resume(pm_message_t state);
 extern void dpm_complete(pm_message_t state);
 
 extern void device_pm_unlock(void);
 extern int dpm_suspend_end(pm_message_t state);
 extern int dpm_suspend_start(pm_message_t state);
+extern int dpm_suspend_noirq(pm_message_t state);
+extern int dpm_suspend_late(pm_message_t state);
 extern int dpm_suspend(pm_message_t state);
 extern int dpm_prepare(pm_message_t state);
 

commit f48c767ce8951e30eb716b8ef69142d21aacbd1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 29 13:58:47 2014 +0200

    PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
    
    The commit 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM
    domain for a device) started using errno values in pm.h header file.
    It also failed to include the header for these, thus it caused
    compiler errors.
    
    Instead of including the errno header to pm.h, let's move the functions
    to pm_domain.h, since it's a better match.
    
    Fixes: 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM domain for a device)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index c4cbf485a5d6..1022ba1eb4de 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -622,17 +622,6 @@ struct dev_pm_domain {
 	void (*detach)(struct device *dev, bool power_off);
 };
 
-#ifdef CONFIG_PM
-extern int dev_pm_domain_attach(struct device *dev, bool power_on);
-extern void dev_pm_domain_detach(struct device *dev, bool power_off);
-#else
-static inline int dev_pm_domain_attach(struct device *dev, bool power_on)
-{
-	return -ENODEV;
-}
-static inline void dev_pm_domain_detach(struct device *dev, bool power_off) {}
-#endif
-
 /*
  * The PM_EVENT_ messages are also used by drivers implementing the legacy
  * suspend framework, based on the ->suspend() and ->resume() callbacks common

commit 46420dd73b800f87a19af13af5883855cf38cb08
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:37 2014 +0200

    PM / Domains: Add APIs to attach/detach a PM domain for a device
    
    To maintain scalability let's add common methods to attach and detach
    a PM domain for a device, dev_pm_domain_attach|detach().
    
    Typically dev_pm_domain_attach() shall be invoked from subsystem level
    code at the probe phase to try to attach a device to its PM domain.
    The reversed actions may be done a the remove phase and then by
    invoking dev_pm_domain_detach().
    
    When attachment succeeds, the attach function should assign its
    corresponding detach function to a new ->detach() callback added in the
    struct dev_pm_domain.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Tested-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 1022ba1eb4de..c4cbf485a5d6 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -622,6 +622,17 @@ struct dev_pm_domain {
 	void (*detach)(struct device *dev, bool power_off);
 };
 
+#ifdef CONFIG_PM
+extern int dev_pm_domain_attach(struct device *dev, bool power_on);
+extern void dev_pm_domain_detach(struct device *dev, bool power_off);
+#else
+static inline int dev_pm_domain_attach(struct device *dev, bool power_on)
+{
+	return -ENODEV;
+}
+static inline void dev_pm_domain_detach(struct device *dev, bool power_off) {}
+#endif
+
 /*
  * The PM_EVENT_ messages are also used by drivers implementing the legacy
  * suspend framework, based on the ->suspend() and ->resume() callbacks common

commit c3099a5294f2c7266234e8ea35cbffc20a41aa9a
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:34 2014 +0200

    PM / Domains: Add a detach callback to the struct dev_pm_domain
    
    The intent of this callback is to simplify detachment of devices from
    their PM domains. Further patches will show the benefit.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 72c0fe098a27..1022ba1eb4de 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -619,6 +619,7 @@ extern int dev_pm_put_subsys_data(struct device *dev);
  */
 struct dev_pm_domain {
 	struct dev_pm_ops	ops;
+	void (*detach)(struct device *dev, bool power_off);
 };
 
 /*

commit aae4518b3124b29f8dc81c829c704fd2df72e98b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri May 16 02:46:50 2014 +0200

    PM / sleep: Mechanism to avoid resuming runtime-suspended devices unnecessarily
    
    Currently, some subsystems (e.g. PCI and the ACPI PM domain) have to
    resume all runtime-suspended devices during system suspend, mostly
    because those devices may need to be reprogrammed due to different
    wakeup settings for system sleep and for runtime PM.
    
    For some devices, though, it's OK to remain in runtime suspend
    throughout a complete system suspend/resume cycle (if the device was in
    runtime suspend at the start of the cycle).  We would like to do this
    whenever possible, to avoid the overhead of extra power-up and power-down
    events.
    
    However, problems may arise because the device's descendants may require
    it to be at full power at various points during the cycle.  Therefore the
    most straightforward way to do this safely is if the device and all its
    descendants can remain runtime suspended until the complete stage of
    system resume.
    
    To this end, introduce a new device PM flag, power.direct_complete
    and modify the PM core to use that flag as follows.
    
    If the ->prepare() callback of a device returns a positive number,
    the PM core will regard that as an indication that it may leave the
    device runtime-suspended.  It will then check if the system power
    transition in progress is a suspend (and not hibernation in particular)
    and if the device is, indeed, runtime-suspended.  In that case, the PM
    core will set the device's power.direct_complete flag.  Otherwise it
    will clear power.direct_complete for the device and it also will later
    clear it for the device's parent (if there's one).
    
    Next, the PM core will not invoke the ->suspend() ->suspend_late(),
    ->suspend_irq(), ->resume_irq(), ->resume_early(), or ->resume()
    callbacks for all devices having power.direct_complete set.  It
    will invoke their ->complete() callbacks, however, and those
    callbacks are then responsible for resuming the devices as
    appropriate, if necessary.  For example, in some cases they may
    need to queue up runtime resume requests for the devices using
    pm_request_resume().
    
    Changelog partly based on an Alan Stern's description of the idea
    (http://marc.info/?l=linux-pm&m=139940466625569&w=2).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index d915d0345fa1..72c0fe098a27 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -93,13 +93,23 @@ typedef struct pm_message {
  *	been registered) to recover from the race condition.
  *	This method is executed for all kinds of suspend transitions and is
  *	followed by one of the suspend callbacks: @suspend(), @freeze(), or
- *	@poweroff().  The PM core executes subsystem-level @prepare() for all
- *	devices before starting to invoke suspend callbacks for any of them, so
- *	generally devices may be assumed to be functional or to respond to
- *	runtime resume requests while @prepare() is being executed.  However,
- *	device drivers may NOT assume anything about the availability of user
- *	space at that time and it is NOT valid to request firmware from within
- *	@prepare() (it's too late to do that).  It also is NOT valid to allocate
+ *	@poweroff().  If the transition is a suspend to memory or standby (that
+ *	is, not related to hibernation), the return value of @prepare() may be
+ *	used to indicate to the PM core to leave the device in runtime suspend
+ *	if applicable.  Namely, if @prepare() returns a positive number, the PM
+ *	core will understand that as a declaration that the device appears to be
+ *	runtime-suspended and it may be left in that state during the entire
+ *	transition and during the subsequent resume if all of its descendants
+ *	are left in runtime suspend too.  If that happens, @complete() will be
+ *	executed directly after @prepare() and it must ensure the proper
+ *	functioning of the device after the system resume.
+ *	The PM core executes subsystem-level @prepare() for all devices before
+ *	starting to invoke suspend callbacks for any of them, so generally
+ *	devices may be assumed to be functional or to respond to runtime resume
+ *	requests while @prepare() is being executed.  However, device drivers
+ *	may NOT assume anything about the availability of user space at that
+ *	time and it is NOT valid to request firmware from within @prepare()
+ *	(it's too late to do that).  It also is NOT valid to allocate
  *	substantial amounts of memory from @prepare() in the GFP_KERNEL mode.
  *	[To work around these limitations, drivers may register suspend and
  *	hibernation notifiers to be executed before the freezing of tasks.]
@@ -112,7 +122,16 @@ typedef struct pm_message {
  *	of the other devices that the PM core has unsuccessfully attempted to
  *	suspend earlier).
  *	The PM core executes subsystem-level @complete() after it has executed
- *	the appropriate resume callbacks for all devices.
+ *	the appropriate resume callbacks for all devices.  If the corresponding
+ *	@prepare() at the beginning of the suspend transition returned a
+ *	positive number and the device was left in runtime suspend (without
+ *	executing any suspend and resume callbacks for it), @complete() will be
+ *	the only callback executed for the device during resume.  In that case,
+ *	@complete() must be prepared to do whatever is necessary to ensure the
+ *	proper functioning of the device after the system resume.  To this end,
+ *	@complete() can check the power.direct_complete flag of the device to
+ *	learn whether (unset) or not (set) the previous suspend and resume
+ *	callbacks have been executed for it.
  *
  * @suspend: Executed before putting the system into a sleep state in which the
  *	contents of main memory are preserved.  The exact action to perform
@@ -546,6 +565,7 @@ struct dev_pm_info {
 	bool			is_late_suspended:1;
 	bool			ignore_children:1;
 	bool			early_init:1;	/* Owned by the PM core */
+	bool			direct_complete:1;	/* Owned by the PM core */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit 36cc86e8ec1a0ab309052bc9b25e48a31288b8a5
Merge: 165f5fd04aa8 651665dbfdfc 33fe0ad946bb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 20 13:25:54 2014 +0100

    Merge branches 'pm-runtime' and 'pm-sleep'
    
    * pm-runtime:
      PM / Runtime: Update runtime_idle() documentation for return value meaning
    
    * pm-sleep:
      PM / sleep: Correct whitespace errors in <linux/pm.h>
      PM: Add missing "freeze" state
      PM / Hibernate: Spelling s/anonymouns/anonymous/
      PM / Runtime: Add missing "it" in comment
      PM / suspend: Remove unnecessary !!
      PCI / PM: Resume runtime-suspended devices later during system suspend
      ACPI / PM: Resume runtime-suspended devices later during system suspend
      PM / sleep: Set pm_generic functions to NULL for !CONFIG_PM_SLEEP
      PM: fix typo in comment
      PM / hibernate: use name_to_dev_t to parse resume
      PM / wakeup: Include appropriate header file in kernel/power/wakelock.c
      PM / sleep: Move prototype declaration to header file kernel/power/power.h
      PM / sleep: Asynchronous threads for suspend_late
      PM / sleep: Asynchronous threads for suspend_noirq
      PM / sleep: Asynchronous threads for resume_early
      PM / sleep: Asynchronous threads for resume_noirq
      PM / sleep: Two flags for async suspend_noirq and suspend_late

commit 33fe0ad946bbb0a2f04f551fce68a74d8821f32e
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Mon Mar 17 21:26:10 2014 +0100

    PM / sleep: Correct whitespace errors in <linux/pm.h>
    
    rjw> Why exactly are they errors?
    Geert> checkpatch.pl says: "WARNING: please, no space before tabs",
           Vim (with "let c_space_errors=1") shows them in red.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6fffbcd7bc37..f902ad83986e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -379,7 +379,7 @@ const struct dev_pm_ops name = { \
  *
  * ON		No transition.
  *
- * FREEZE 	System is going to hibernate, call ->prepare() and ->freeze()
+ * FREEZE	System is going to hibernate, call ->prepare() and ->freeze()
  *		for all devices.
  *
  * SUSPEND	System is going to suspend, call ->prepare() and ->suspend()
@@ -423,7 +423,7 @@ const struct dev_pm_ops name = { \
 
 #define PM_EVENT_INVALID	(-1)
 #define PM_EVENT_ON		0x0000
-#define PM_EVENT_FREEZE 	0x0001
+#define PM_EVENT_FREEZE		0x0001
 #define PM_EVENT_SUSPEND	0x0002
 #define PM_EVENT_HIBERNATE	0x0004
 #define PM_EVENT_QUIESCE	0x0008
@@ -614,11 +614,11 @@ struct dev_pm_domain {
  * message is implicit:
  *
  * ON		Driver starts working again, responding to hardware events
- * 		and software requests.  The hardware may have gone through
- * 		a power-off reset, or it may have maintained state from the
- * 		previous suspend() which the driver will rely on while
- * 		resuming.  On most platforms, there are no restrictions on
- * 		availability of resources like clocks during resume().
+ *		and software requests.  The hardware may have gone through
+ *		a power-off reset, or it may have maintained state from the
+ *		previous suspend() which the driver will rely on while
+ *		resuming.  On most platforms, there are no restrictions on
+ *		availability of resources like clocks during resume().
  *
  * Other transitions are triggered by messages sent using suspend().  All
  * these transitions quiesce the driver, so that I/O queues are inactive.
@@ -628,21 +628,21 @@ struct dev_pm_domain {
  * differ according to the message:
  *
  * SUSPEND	Quiesce, enter a low power device state appropriate for
- * 		the upcoming system state (such as PCI_D3hot), and enable
- * 		wakeup events as appropriate.
+ *		the upcoming system state (such as PCI_D3hot), and enable
+ *		wakeup events as appropriate.
  *
  * HIBERNATE	Enter a low power device state appropriate for the hibernation
- * 		state (eg. ACPI S4) and enable wakeup events as appropriate.
+ *		state (eg. ACPI S4) and enable wakeup events as appropriate.
  *
  * FREEZE	Quiesce operations so that a consistent image can be saved;
- * 		but do NOT otherwise enter a low power device state, and do
- * 		NOT emit system wakeup events.
+ *		but do NOT otherwise enter a low power device state, and do
+ *		NOT emit system wakeup events.
  *
  * PRETHAW	Quiesce as if for FREEZE; additionally, prepare for restoring
- * 		the system from a snapshot taken after an earlier FREEZE.
- * 		Some drivers will need to reset their hardware state instead
- * 		of preserving it, to ensure that it's never mistaken for the
- * 		state which that earlier snapshot had set up.
+ *		the system from a snapshot taken after an earlier FREEZE.
+ *		Some drivers will need to reset their hardware state instead
+ *		of preserving it, to ensure that it's never mistaken for the
+ *		state which that earlier snapshot had set up.
  *
  * A minimally power-aware driver treats all messages as SUSPEND, fully
  * reinitializes its device during resume() -- whether or not it was reset

commit 651665dbfdfca3201966c72edefdb0391160bea9
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Mon Mar 17 21:26:11 2014 +0100

    PM / Runtime: Update runtime_idle() documentation for return value meaning
    
    As of commit 45f0a85c8258 ('PM / Runtime: Rework the "runtime idle"
    helper routine'), the return value of ->runtime_idle() is no longer
    ignored by the PM core, but used to decide whether to suspend the
    device or not.
    
    Update the documentation to match the code.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 8c6583a53a06..0298b5e5de01 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -264,9 +264,9 @@ typedef struct pm_message {
  *	registers, so that it is fully operational.
  *
  * @runtime_idle: Device appears to be inactive and it might be put into a
- *	low-power state if all of the necessary conditions are satisfied.  Check
- *	these conditions and handle the device as appropriate, possibly queueing
- *	a suspend request for it.  The return value is ignored by the PM core.
+ *	low-power state if all of the necessary conditions are satisfied.
+ *	Check these conditions, and return 0 if it's appropriate to let the PM
+ *	core queue a suspend request for the device.
  *
  * Refer to Documentation/power/runtime_pm.txt for more information about the
  * role of the above callbacks in device runtime power management.

commit 0a9efc4d91df7b18fb3e97c24ee85a1529618899
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 19 13:09:21 2014 +0100

    PM / sleep: Set pm_generic functions to NULL for !CONFIG_PM_SLEEP
    
    Previously only a subset of the functions were defined and set to NULL
    while !CONFIG_PM_SLEEP. Let's make them all available so they can be
    used no matter of CONFIG_PM_SLEEP or not.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3540ea99717e..6fffbcd7bc37 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -719,14 +719,26 @@ static inline void dpm_for_each_dev(void *data, void (*fn)(struct device *, void
 {
 }
 
-#define pm_generic_prepare	NULL
-#define pm_generic_suspend	NULL
-#define pm_generic_resume	NULL
-#define pm_generic_freeze	NULL
-#define pm_generic_thaw		NULL
-#define pm_generic_restore	NULL
-#define pm_generic_poweroff	NULL
-#define pm_generic_complete	NULL
+#define pm_generic_prepare		NULL
+#define pm_generic_suspend_late		NULL
+#define pm_generic_suspend_noirq	NULL
+#define pm_generic_suspend		NULL
+#define pm_generic_resume_early		NULL
+#define pm_generic_resume_noirq		NULL
+#define pm_generic_resume		NULL
+#define pm_generic_freeze_noirq		NULL
+#define pm_generic_freeze_late		NULL
+#define pm_generic_freeze		NULL
+#define pm_generic_thaw_noirq		NULL
+#define pm_generic_thaw_early		NULL
+#define pm_generic_thaw			NULL
+#define pm_generic_restore_noirq	NULL
+#define pm_generic_restore_early	NULL
+#define pm_generic_restore		NULL
+#define pm_generic_poweroff_noirq	NULL
+#define pm_generic_poweroff_late	NULL
+#define pm_generic_poweroff		NULL
+#define pm_generic_complete		NULL
 #endif /* !CONFIG_PM_SLEEP */
 
 /* How to reorder dpm_list after device_move() */

commit 3e54d1518f8f31effd487b7609c6779f62b0c04f
Author: Lad, Prabhakar <prabhakar.csengg@gmail.com>
Date:   Thu Feb 20 13:30:32 2014 +0530

    PM: fix typo in comment
    
    Signed-off-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f23a4f1c1bfb..3540ea99717e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -352,7 +352,7 @@ const struct dev_pm_ops name = { \
 
 /*
  * Use this for defining a set of PM operations to be used in all situations
- * (sustem suspend, hibernation or runtime PM).
+ * (system suspend, hibernation or runtime PM).
  * NOTE: In general, system suspend callbacks, .suspend() and .resume(), should
  * be different from the corresponding runtime PM callbacks, .runtime_suspend(),
  * and .runtime_resume(), because .runtime_suspend() always works on an already

commit 3d2699bc179a10eee7d2aa1db50f822be01636f7
Author: Liu, Chuansheng <chuansheng.liu@intel.com>
Date:   Tue Feb 18 10:28:44 2014 +0800

    PM / sleep: Two flags for async suspend_noirq and suspend_late
    
    The patch is a helper adding two new flags for implementing
    async threads for suspend_noirq and suspend_late.
    
    Signed-off-by: Chuansheng Liu <chuansheng.liu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 8c6583a53a06..f23a4f1c1bfb 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -542,6 +542,8 @@ struct dev_pm_info {
 	unsigned int		async_suspend:1;
 	bool			is_prepared:1;	/* Owned by the PM core */
 	bool			is_suspended:1;	/* Ditto */
+	bool			is_noirq_suspended:1;
+	bool			is_late_suspended:1;
 	bool			ignore_children:1;
 	bool			early_init:1;	/* Owned by the PM core */
 	spinlock_t		lock;

commit 2d984ad132a87ca2112f81f21039493176a8bca0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 11 00:35:38 2014 +0100

    PM / QoS: Introcuce latency tolerance device PM QoS type
    
    Add a new latency tolerance device PM QoS type to be use for
    specifying active state (RPM_ACTIVE) memory access (DMA) latency
    tolerance requirements for devices.  It may be used to prevent
    hardware from choosing overly aggressive energy-saving operation
    modes (causing too much latency to appear) for the whole platform.
    
    This feature reqiures hardware support, so it only will be
    available for devices having a new .set_latency_tolerance()
    callback in struct dev_pm_info populated, in which case the
    routine pointed to by it should implement whatever is necessary
    to transfer the effective requirement value to the hardware.
    
    Whenever the effective latency tolerance changes for the device,
    its .set_latency_tolerance() callback will be executed and the
    effective value will be passed to it.  If that value is negative,
    which means that the list of latency tolerance requirements for
    the device is empty, the callback is expected to switch the
    underlying hardware latency tolerance control mechanism to an
    autonomous mode if available.  If that value is PM_QOS_LATENCY_ANY,
    in turn, and the hardware supports a special "no requirement"
    setting, the callback is expected to use it.  That allows software
    to prevent the hardware from automatically updating the device's
    latency tolerance in response to its power state changes (e.g. during
    transitions from D3cold to D0), which generally may be done in the
    autonomous latency tolerance control mode.
    
    If .set_latency_tolerance() is present for the device, a new
    pm_qos_latency_tolerance_us attribute will be present in the
    devivce's power directory in sysfs.  Then, user space can use
    that attribute to specify its latency tolerance requirement for
    the device, if any.  Writing "any" to it means "no requirement, but
    do not let the hardware control latency tolerance" and writing
    "auto" to it allows the hardware to be switched to the autonomous
    mode if there are no other requirements from the kernel side in the
    device's list.
    
    This changeset includes a fix from Mika Westerberg.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 8c6583a53a06..db2be5f3e030 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -582,6 +582,7 @@ struct dev_pm_info {
 	unsigned long		accounting_timestamp;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
+	void (*set_latency_tolerance)(struct device *, s32);
 	struct dev_pm_qos	*qos;
 };
 

commit 4ff913373a77b99cbe3c5df3c76d2622006200d6
Merge: a759012e5f97 362e77d1cb30 717e5d458e3b 6a1c64cb401d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:50:03 2014 +0100

    Merge branches 'pm-sleep', 'pm-runtime' and 'pm-apm'
    
    * pm-sleep:
      PM / hibernate: Call platform_leave() in suspend path too
      PM / Sleep: Add macro to define common late/early system PM callbacks
      PM / hibernate: export hibernation_set_ops
    
    * pm-runtime:
      PM / Runtime: Implement the pm_generic_runtime functions for CONFIG_PM
      PM / Runtime: Add second macro for definition of runtime PM callbacks
    
    * pm-apm:
      apm-emulation: add hibernation APM events to support suspend2disk

commit d9fb563d3cdfd774ee0a7c03e98bb305cdd613eb
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Dec 10 14:37:40 2013 +0100

    PM / Runtime: Add second macro for definition of runtime PM callbacks
    
    By having the runtime PM callbacks implemented for CONFIG_PM, these
    becomes available in all combinations of CONFIG_PM_SLEEP and
    CONFIG_PM_RUNTIME.
    
    The benefit using this, is that we don't need to implement the wrapper
    functions which handles runtime PM resourses, typically called from
    both runtime PM and system PM callbacks. Instead the runtime PM
    callbacks can be invoked directly from system PM callbacks, which is
    useful for some drivers, subsystems and power domains.
    
    Use the new macro SET_PM_RUNTIME_PM_OPS in cases were the above makes
    sense. Make sure the callbacks are encapsulated within CONFIG_PM
    instead of CONFIG_PM_RUNTIME.
    
    Do note that the old macro SET_RUNTIME_PM_OPS, which is being quite
    widely used right now, requires the callbacks to be defined for
    CONFIG_PM_RUNTIME. In many cases it will certainly be convenient to
    convert to the new macro above, but that will have to be distinguished
    in case by case.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index a224c7f5c377..7a830a7d516f 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -320,6 +320,15 @@ struct dev_pm_ops {
 #define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)
 #endif
 
+#ifdef CONFIG_PM
+#define SET_PM_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
+	.runtime_suspend = suspend_fn, \
+	.runtime_resume = resume_fn, \
+	.runtime_idle = idle_fn,
+#else
+#define SET_PM_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)
+#endif
+
 /*
  * Use this if you want to use the same suspend and resume callbacks for suspend
  * to RAM and hibernation.

commit f78c4cffb86a9f1732674d810ac338cd694b1885
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Dec 10 14:37:42 2013 +0100

    PM / Sleep: Add macro to define common late/early system PM callbacks
    
    We use the same approach as for the existing SET_SYSTEM_SLEEP_PM_OPS,
    but for the late and early callbacks instead.
    
    The new SET_LATE_SYSTEM_SLEEP_PM_OPS, defined for CONFIG_PM_SLEEP, will
    point ->suspend_late, ->freeze_late and ->poweroff_late to the same
    function. Vice verse happens for ->resume_early, ->thaw_early and
    ->restore_early.
    
    Cc: Kevin Hilman <khilman@linaro.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index a224c7f5c377..970b705e9967 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -311,6 +311,18 @@ struct dev_pm_ops {
 #define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
 #endif
 
+#ifdef CONFIG_PM_SLEEP
+#define SET_LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
+	.suspend_late = suspend_fn, \
+	.resume_early = resume_fn, \
+	.freeze_late = suspend_fn, \
+	.thaw_early = resume_fn, \
+	.poweroff_late = suspend_fn, \
+	.restore_early = resume_fn,
+#else
+#define SET_LATE_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
+#endif
+
 #ifdef CONFIG_PM_RUNTIME
 #define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
 	.runtime_suspend = suspend_fn, \

commit 0d4a42f6bd298e826620585e766a154ab460617a
Merge: d62b4892f3d9 a937536b868b
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Tue Mar 19 09:47:30 2013 +0100

    Merge tag 'v3.9-rc3' into drm-intel-next-queued
    
    Backmerge so that I can merge Imre Deak's coalesced sg entries fixes,
    which depend upon the new for_each_sg_page introduce in
    
    commit a321e91b6d73ed011ffceed384c40d2785cf723b
    Author: Imre Deak <imre.deak@intel.com>
    Date:   Wed Feb 27 17:02:56 2013 -0800
    
        lib/scatterlist: add simple page iterator
    
    The merge itself is just two trivial conflicts:
    
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

commit e823407f7b11fa06ba8e7a2801eb9ed11268a7ec
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Feb 22 16:34:11 2013 -0800

    pm / runtime: introduce pm_runtime_set_memalloc_noio()
    
    Introduce the flag memalloc_noio in 'struct dev_pm_info' to help PM core
    to teach mm not allocating memory with GFP_KERNEL flag for avoiding
    probable deadlock.
    
    As explained in the comment, any GFP_KERNEL allocation inside
    runtime_resume() or runtime_suspend() on any one of device in the path
    from one block or network device to the root device in the device tree
    may cause deadlock, the introduced pm_runtime_set_memalloc_noio() sets
    or clears the flag on device in the path recursively.
    
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Oliver Neukum <oneukum@suse.de>
    Cc: Jiri Kosina <jiri.kosina@suse.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: David Decotigny <david.decotigny@google.com>
    Cc: Tom Herbert <therbert@google.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 97bcf23e045a..e5d7230332a4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -537,6 +537,7 @@ struct dev_pm_info {
 	unsigned int		irq_safe:1;
 	unsigned int		use_autosuspend:1;
 	unsigned int		timer_autosuspends:1;
+	unsigned int		memalloc_noio:1;
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;

commit f43f627d2f17e95c78647eeddf968d12f5c286b1
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Feb 4 13:37:20 2013 +0000

    PM: make VT switching to the suspend console optional v3
    
    KMS drivers can potentially restore the display configuration without
    userspace help.  Such drivers can can call a new funciton,
    pm_vt_switch_required(false) if they support this feature.  In that
    case, the PM layer won't VT switch to the suspend console at suspend
    time and then back to the original VT on resume, but rather leave things
    alone for a nicer looking suspend and resume sequence.
    
    v2: make a function so we can handle multiple drivers (Alan)
    v3: use a list to track device requests (Rafael)
    v4: Squash in build fix from Jesse for CONFIG_VT_CONSOLE_SLEEP=n
    v5: Squash in patch from Wu Fengguang to add a few missing static
    qualifiers.
    v6: Add missing EXPORT_SYMBOL.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com> (v3)
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 03d7bb145311..e5da2f353e8f 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -35,6 +35,19 @@ extern void (*pm_idle)(void);
 extern void (*pm_power_off)(void);
 extern void (*pm_power_off_prepare)(void);
 
+struct device; /* we have a circular dep with device.h */
+#ifdef CONFIG_VT_CONSOLE_SLEEP
+extern void pm_vt_switch_required(struct device *dev, bool required);
+extern void pm_vt_switch_unregister(struct device *dev);
+#else
+static inline void pm_vt_switch_required(struct device *dev, bool required)
+{
+}
+static inline void pm_vt_switch_unregister(struct device *dev)
+{
+}
+#endif /* CONFIG_VT_CONSOLE_SLEEP */
+
 /*
  * Device power management
  */

commit 558bd3e8dc7a798c5c845f90cf038b9bbd2df2b8
Author: Len Brown <len.brown@intel.com>
Date:   Sat Feb 9 21:51:27 2013 -0500

    PM idle: remove global declaration of pm_idle
    
    pm_idle appears in no generic Linux code,
    it appears only in architecture-specific code.
    
    Thus, pm_idle should not be declared in pm.h.
    
    Architectures that  use an idle function pointer
    should delcare one local to their architecture,
    and/or use cpuidle.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Cc: linux-pm@vger.kernel.org

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 03d7bb145311..97bcf23e045a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -31,7 +31,6 @@
 /*
  * Callbacks for platform drivers to implement.
  */
-extern void (*pm_idle)(void);
 extern void (*pm_power_off)(void);
 extern void (*pm_power_off_prepare)(void);
 

commit e39473d0b9448e770f49b0b15e514be884264438
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 24 02:08:18 2012 +0200

    PM / QoS: Make it possible to expose PM QoS device flags to user space
    
    Define two device PM QoS flags, PM_QOS_FLAG_NO_POWER_OFF
    and PM_QOS_FLAG_REMOTE_WAKEUP, and introduce routines
    dev_pm_qos_expose_flags() and dev_pm_qos_hide_flags() allowing the
    caller to expose those two flags to user space or to hide them
    from it, respectively.
    
    After the flags have been exposed, user space will see two
    additional sysfs attributes, pm_qos_no_power_off and
    pm_qos_remote_wakeup, under the device's /sys/devices/.../power/
    directory.  Then, writing 1 to one of them will update the
    PM QoS flags request owned by user space so that the corresponding
    flag is requested to be set.  In turn, writing 0 to one of them
    will cause the corresponding flag in the user space's request to
    be cleared (however, the owners of the other PM QoS flags requests
    for the same device may still request the flag to be set and it
    may be effectively set even if user space doesn't request that).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jean Pihet <j-pihet@ti.com>
    Acked-by: mark gross <markgross@thegnar.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 0ce6df94221a..03d7bb145311 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -546,7 +546,6 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
-	struct dev_pm_qos_request *pq_req;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
 	struct dev_pm_qos	*qos;

commit 5f986c590fcf4284924fcda991cf14ab32bff49f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Oct 23 01:07:27 2012 +0200

    PM / QoS: Prepare device structure for adding more constraint types
    
    Currently struct dev_pm_info contains only one PM QoS constraints
    pointer reserved for latency requirements.  Since one more device
    constraints type (i.e. flags) will be necessary, introduce a new
    structure, struct dev_pm_qos, that eventually will contain all of
    the available device PM QoS constraints and replace the "constraints"
    pointer in struct dev_pm_info with a pointer to the new structure
    called "qos".
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jean Pihet <j-pihet@ti.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 007e687c4f69..0ce6df94221a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -549,7 +549,7 @@ struct dev_pm_info {
 	struct dev_pm_qos_request *pq_req;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
-	struct pm_qos_constraints *constraints;
+	struct dev_pm_qos	*qos;
 };
 
 extern void update_pm_runtime_accounting(struct device *dev);

commit 16642a2e7be23bbda013fc32d8f6c68982eab603
Merge: 51562cba9893 b9142167a2bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 18:32:35 2012 -0700

    Merge tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael J Wysocki:
    
     - Improved system suspend/resume and runtime PM handling for the SH
       TMU, CMT and MTU2 clock event devices (also used by ARM/shmobile).
    
     - Generic PM domains framework extensions related to cpuidle support
       and domain objects lookup using names.
    
     - ARM/shmobile power management updates including improved support for
       the SH7372's A4S power domain containing the CPU core.
    
     - cpufreq changes related to AMD CPUs support from Matthew Garrett,
       Andre Przywara and Borislav Petkov.
    
     - cpu0 cpufreq driver from Shawn Guo.
    
     - cpufreq governor fixes related to the relaxing of limit from Michal
       Pecio.
    
     - OMAP cpufreq updates from Axel Lin and Richard Zhao.
    
     - cpuidle ladder governor fixes related to the disabling of states from
       Carsten Emde and me.
    
     - Runtime PM core updates related to the interactions with the system
       suspend core from Alan Stern and Kevin Hilman.
    
     - Wakeup sources modification allowing more helper functions to be
       called from interrupt context from John Stultz and additional
       diagnostic code from Todd Poynor.
    
     - System suspend error code path fix from Feng Hong.
    
    Fixed up conflicts in cpufreq/powernow-k8 that stemmed from the
    workqueue fixes conflicting fairly badly with the removal of support for
    hardware P-state chips.  The changes were independent but somewhat
    intertwined.
    
    * tag 'pm-for-3.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (76 commits)
      Revert "PM QoS: Use spinlock in the per-device PM QoS constraints code"
      PM / Runtime: let rpm_resume() succeed if RPM_ACTIVE, even when disabled, v2
      cpuidle: rename function name "__cpuidle_register_driver", v2
      cpufreq: OMAP: Check IS_ERR() instead of NULL for omap_device_get_by_hwmod_name
      cpuidle: remove some empty lines
      PM: Prevent runtime suspend during system resume
      PM QoS: Use spinlock in the per-device PM QoS constraints code
      PM / Sleep: use resume event when call dpm_resume_early
      cpuidle / ACPI : move cpuidle_device field out of the acpi_processor_power structure
      ACPI / processor: remove pointless variable initialization
      ACPI / processor: remove unused function parameter
      cpufreq: OMAP: remove loops_per_jiffy recalculate for smp
      sections: fix section conflicts in drivers/cpufreq
      cpufreq: conservative: update frequency when limits are relaxed
      cpufreq / ondemand: update frequency when limits are relaxed
      properly __init-annotate pm_sysrq_init()
      cpufreq: Add a generic cpufreq-cpu0 driver
      PM / OPP: Initialize OPP table from device tree
      ARM: add cpufreq transiton notifier to adjust loops_per_jiffy for smp
      cpufreq: Remove support for hardware P-state chips from powernow-k8
      ...

commit feb70af0e3ac6817327be70b47731039ea135dbc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 13 14:00:25 2012 +0200

    PM: Do not use the syscore flag for runtime PM
    
    The syscore device PM flag used to mark the devices (belonging to
    PM domains) that should never be turned off, except for the system
    core (syscore) suspend/hibernation and resume stages, need not be
    accessed by the runtime PM core functions, because all of the devices
    it is set for need to be marked as "irq safe" anyway and are
    protected from being turned off by runtime PM by ensuring that their
    usage counters are always set.
    
    For this reason, make the syscore flag system-wide PM-specific
    and simplify the code used for manipulating it, because it need not
    acquire the device's power.lock any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b79a0dd3bc6d..44d1f2307dbc 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -43,12 +43,8 @@ struct device;
 
 #ifdef CONFIG_PM
 extern const char power_group_name[];		/* = "power" */
-
-extern void dev_pm_syscore_device(struct device *dev, bool val);
 #else
 #define power_group_name	NULL
-
-static inline void dev_pm_syscore_device(struct device *dev, bool val) {}
 #endif
 
 typedef struct pm_message {
@@ -515,13 +511,13 @@ struct dev_pm_info {
 	bool			is_suspended:1;	/* Ditto */
 	bool			ignore_children:1;
 	bool			early_init:1;	/* Owned by the PM core */
-	bool			syscore:1;
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;
 	struct completion	completion;
 	struct wakeup_source	*wakeup;
 	bool			wakeup_path:1;
+	bool			syscore:1;
 #else
 	unsigned int		should_wakeup:1;
 #endif

commit dbf374142dd7a3c394ec124ebe7339a6c412d9b6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 6 01:46:39 2012 +0200

    PM / Domains: Move syscore flag from subsys data to struct device
    
    The syscore device PM flag is used to mark the devices (belonging to
    a PM domain) that should never be turned off, except for the system
    core (syscore) suspend/hibernation and resume stages.  That flag is
    stored in the device's struct pm_subsys_data object whose address is
    available from struct device.  However, in some situations it may be
    convenient to set that flag before the device is added to a PM
    domain, so it is better to move it directly to the "power" member of
    struct device.  Then, it can be checked by the routines in
    drivers/base/power/runtime.c and drivers/base/power/main.c, which is
    more straightforward.
    
    This also reduces the number of dev_gpd_data() invocations in the
    generic PM domains framework, so the overhead related to the syscore
    flag is slightly smaller.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Magnus Damm <damm@opensource.se>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 716517af1543..b79a0dd3bc6d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -43,8 +43,12 @@ struct device;
 
 #ifdef CONFIG_PM
 extern const char power_group_name[];		/* = "power" */
+
+extern void dev_pm_syscore_device(struct device *dev, bool val);
 #else
 #define power_group_name	NULL
+
+static inline void dev_pm_syscore_device(struct device *dev, bool val) {}
 #endif
 
 typedef struct pm_message {
@@ -511,6 +515,7 @@ struct dev_pm_info {
 	bool			is_suspended:1;	/* Ditto */
 	bool			ignore_children:1;
 	bool			early_init:1;	/* Owned by the PM core */
+	bool			syscore:1;
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit bed2b42d9f0b411f384c5619870ab0fea5dd116b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 6 01:45:11 2012 +0200

    PM / Runtime: Allow helpers to be called by early platform drivers
    
    Runtime PM helper functions, like pm_runtime_get_sync(), cannot be
    called by early platform device drivers, because the devices' power
    management locks are not initialized at that time.  This is quite
    inconvenient, so modify early_platform_add_devices() to initialize
    the devices power management locks as appropriate and make sure that
    they won't be initialized more than once if an early platform
    device is going to be used as a regular one later.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f067e60a3832..716517af1543 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -510,6 +510,7 @@ struct dev_pm_info {
 	bool			is_prepared:1;	/* Owned by the PM core */
 	bool			is_suspended:1;	/* Ditto */
 	bool			ignore_children:1;
+	bool			early_init:1;	/* Owned by the PM core */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit dfe3212e0196c01402154971841463d721dea915
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Aug 17 22:06:59 2012 +0800

    PM / Sleep: introduce dpm_for_each_dev
    
    dpm_list and its pm lock provide a good way to iterate all
    devices in system. Except this way, there is no other easy
    way to iterate devices in system.
    
    firmware loader need to cache firmware images for devices
    before system sleep, so introduce the function to meet its
    demand.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f067e60a3832..88f034a23f2c 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -638,6 +638,7 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 	} while (0)
 
 extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
+extern void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *));
 
 extern int pm_generic_prepare(struct device *dev);
 extern int pm_generic_suspend_late(struct device *dev);
@@ -677,6 +678,10 @@ static inline int device_pm_wait_for_dev(struct device *a, struct device *b)
 	return 0;
 }
 
+static inline void dpm_for_each_dev(void *data, void (*fn)(struct device *, void *))
+{
+}
+
 #define pm_generic_prepare	NULL
 #define pm_generic_suspend	NULL
 #define pm_generic_resume	NULL

commit 76e267d822f2913893ad210ba431607aa8e2af94
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 29 22:54:36 2012 +0200

    PM / Runtime: Remove device fields related to suspend time, v2
    
    After the previous changes in default_stop_ok() and
    default_power_down_ok() for PM domains, there are two fields in
    struct dev_pm_info that aren't necessary any more,  suspend_time
    and max_time_suspended_ns.
    
    Remove those fields along with all of the code that accesses them,
    which simplifies the runtime PM framework quite a bit.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 715305e05123..f067e60a3832 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -544,8 +544,6 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
-	ktime_t			suspend_time;
-	s64			max_time_suspended_ns;
 	struct dev_pm_qos_request *pq_req;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */

commit 59fb53ea75eef4aa029cf31c88cdacec2f7b794b
Merge: ed819e3b964b efe6a8ad7fc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Mar 16 21:49:24 2012 +0100

    Merge branch 'pm-qos'
    
    * pm-qos:
      sh_mmcif / PM: Use PM QoS latency constraint
      tmio_mmc / PM: Use PM QoS latency constraint
      PM / QoS: Make it possible to expose PM QoS latency constraints

commit 85dc0b8a4019e38ad4fd0c008f89a5c241805ac2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Mar 13 01:01:39 2012 +0100

    PM / QoS: Make it possible to expose PM QoS latency constraints
    
    A runtime suspend of a device (e.g. an MMC controller) belonging to
    a power domain or, in a more complicated scenario, a runtime suspend
    of another device in the same power domain, may cause power to be
    removed from the entire domain.  In that case, the amount of time
    necessary to runtime-resume the given device (e.g. the MMC
    controller) is often substantially greater than the time needed to
    run its driver's runtime resume callback.  That may hurt performance
    in some situations, because user data may need to wait for the
    device to become operational, so we should make it possible to
    prevent that from happening.
    
    For this reason, introduce a new sysfs attribute for devices,
    power/pm_qos_resume_latency_us, allowing user space to specify the
    upper bound of the time necessary to bring the (runtime-suspended)
    device up after the resume of it has been requested.  However, make
    that attribute appear only for the devices whose drivers declare
    support for it by calling the (new) dev_pm_qos_expose_latency_limit()
    helper function with the appropriate initial value of the attribute.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 73c610573a74..4db39ed1a6ef 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -537,6 +537,7 @@ struct dev_pm_info {
 	unsigned long		accounting_timestamp;
 	ktime_t			suspend_time;
 	s64			max_time_suspended_ns;
+	struct dev_pm_qos_request *pq_req;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
 	struct pm_qos_constraints *constraints;

commit c48825251cf5950da9d618144c4db6c130e6c0cd
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 13 16:29:47 2012 +0100

    PM: Add comment describing relationships between PM callbacks to pm.h
    
    The UNIVERSAL_DEV_PM_OPS() macro is slightly misleading, because it
    may suggest that it's a good idea to point runtime PM callback
    pointers to the same routines as system suspend/resume callbacks
    .suspend() and .resume(), which is not the case.  For this reason,
    add a comment to include/linux/pm.h, next to the definition of
    UNIVERSAL_DEV_PM_OPS(), describing how device PM callbacks are
    related to each other.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 73c610573a74..d6dd6f612b8d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -320,6 +320,15 @@ const struct dev_pm_ops name = { \
 /*
  * Use this for defining a set of PM operations to be used in all situations
  * (sustem suspend, hibernation or runtime PM).
+ * NOTE: In general, system suspend callbacks, .suspend() and .resume(), should
+ * be different from the corresponding runtime PM callbacks, .runtime_suspend(),
+ * and .runtime_resume(), because .runtime_suspend() always works on an already
+ * quiescent device, while .suspend() should assume that the device may be doing
+ * something when it is called (it should ensure that the device will be
+ * quiescent after it has returned).  Therefore it's better to point the "late"
+ * suspend and "early" resume callback pointers, .suspend_late() and
+ * .resume_early(), to the same routines as .runtime_suspend() and
+ * .runtime_resume(), respectively (and analogously for hibernation).
  */
 #define UNIVERSAL_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \
 const struct dev_pm_ops name = { \

commit e470d06655e00749f6f9372e4fa4f20cea7ed7c5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jan 29 20:38:41 2012 +0100

    PM / Sleep: Introduce generic callbacks for new device PM phases
    
    Introduce generic subsystem callbacks for the new phases of device
    suspend/resume during system power transitions: "late suspend",
    "early resume", "late freeze", "early thaw", "late poweroff",
    "early restore".
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index c68e1f22ac95..73c610573a74 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -632,17 +632,23 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
 
 extern int pm_generic_prepare(struct device *dev);
+extern int pm_generic_suspend_late(struct device *dev);
 extern int pm_generic_suspend_noirq(struct device *dev);
 extern int pm_generic_suspend(struct device *dev);
+extern int pm_generic_resume_early(struct device *dev);
 extern int pm_generic_resume_noirq(struct device *dev);
 extern int pm_generic_resume(struct device *dev);
 extern int pm_generic_freeze_noirq(struct device *dev);
+extern int pm_generic_freeze_late(struct device *dev);
 extern int pm_generic_freeze(struct device *dev);
 extern int pm_generic_thaw_noirq(struct device *dev);
+extern int pm_generic_thaw_early(struct device *dev);
 extern int pm_generic_thaw(struct device *dev);
 extern int pm_generic_restore_noirq(struct device *dev);
+extern int pm_generic_restore_early(struct device *dev);
 extern int pm_generic_restore(struct device *dev);
 extern int pm_generic_poweroff_noirq(struct device *dev);
+extern int pm_generic_poweroff_late(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 

commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jan 29 20:38:29 2012 +0100

    PM / Sleep: Introduce "late suspend" and "early resume" of devices
    
    The current device suspend/resume phases during system-wide power
    transitions appear to be insufficient for some platforms that want
    to use the same callback routines for saving device states and
    related operations during runtime suspend/resume as well as during
    system suspend/resume.  In principle, they could point their
    .suspend_noirq() and .resume_noirq() to the same callback routines
    as their .runtime_suspend() and .runtime_resume(), respectively,
    but at least some of them require device interrupts to be enabled
    while the code in those routines is running.
    
    It also makes sense to have device suspend-resume callbacks that will
    be executed with runtime PM disabled and with device interrupts
    enabled in case someone needs to run some special code in that
    context during system-wide power transitions.
    
    Apart from this, .suspend_noirq() and .resume_noirq() were introduced
    as a workaround for drivers using shared interrupts and failing to
    prevent their interrupt handlers from accessing suspended hardware.
    It appears to be better not to use them for other porposes, or we may
    have to deal with some serious confusion (which seems to be happening
    already).
    
    For the above reasons, introduce new device suspend/resume phases,
    "late suspend" and "early resume" (and analogously for hibernation)
    whose callback will be executed with runtime PM disabled and with
    device interrupts enabled and whose callback pointers generally may
    point to runtime suspend/resume routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e4982ac3fbbc..c68e1f22ac95 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -110,6 +110,10 @@ typedef struct pm_message {
  *	Subsystem-level @suspend() is executed for all devices after invoking
  *	subsystem-level @prepare() for all of them.
  *
+ * @suspend_late: Continue operations started by @suspend().  For a number of
+ *	devices @suspend_late() may point to the same callback routine as the
+ *	runtime suspend callback.
+ *
  * @resume: Executed after waking the system up from a sleep state in which the
  *	contents of main memory were preserved.  The exact action to perform
  *	depends on the device's subsystem, but generally the driver is expected
@@ -122,6 +126,10 @@ typedef struct pm_message {
  *	Subsystem-level @resume() is executed for all devices after invoking
  *	subsystem-level @resume_noirq() for all of them.
  *
+ * @resume_early: Prepare to execute @resume().  For a number of devices
+ *	@resume_early() may point to the same callback routine as the runtime
+ *	resume callback.
+ *
  * @freeze: Hibernation-specific, executed before creating a hibernation image.
  *	Analogous to @suspend(), but it should not enable the device to signal
  *	wakeup events or change its power state.  The majority of subsystems
@@ -131,6 +139,10 @@ typedef struct pm_message {
  *	Subsystem-level @freeze() is executed for all devices after invoking
  *	subsystem-level @prepare() for all of them.
  *
+ * @freeze_late: Continue operations started by @freeze().  Analogous to
+ *	@suspend_late(), but it should not enable the device to signal wakeup
+ *	events or change its power state.
+ *
  * @thaw: Hibernation-specific, executed after creating a hibernation image OR
  *	if the creation of an image has failed.  Also executed after a failing
  *	attempt to restore the contents of main memory from such an image.
@@ -140,15 +152,23 @@ typedef struct pm_message {
  *	subsystem-level @thaw_noirq() for all of them.  It also may be executed
  *	directly after @freeze() in case of a transition error.
  *
+ * @thaw_early: Prepare to execute @thaw().  Undo the changes made by the
+ *	preceding @freeze_late().
+ *
  * @poweroff: Hibernation-specific, executed after saving a hibernation image.
  *	Analogous to @suspend(), but it need not save the device's settings in
  *	memory.
  *	Subsystem-level @poweroff() is executed for all devices after invoking
  *	subsystem-level @prepare() for all of them.
  *
+ * @poweroff_late: Continue operations started by @poweroff().  Analogous to
+ *	@suspend_late(), but it need not save the device's settings in memory.
+ *
  * @restore: Hibernation-specific, executed after restoring the contents of main
  *	memory from a hibernation image, analogous to @resume().
  *
+ * @restore_early: Prepare to execute @restore(), analogous to @resume_early().
+ *
  * @suspend_noirq: Complete the actions started by @suspend().  Carry out any
  *	additional operations required for suspending the device that might be
  *	racing with its driver's interrupt handler, which is guaranteed not to
@@ -158,9 +178,10 @@ typedef struct pm_message {
  *	@suspend_noirq() has returned successfully.  If the device can generate
  *	system wakeup signals and is enabled to wake up the system, it should be
  *	configured to do so at that time.  However, depending on the platform
- *	and device's subsystem, @suspend() may be allowed to put the device into
- *	the low-power state and configure it to generate wakeup signals, in
- *	which case it generally is not necessary to define @suspend_noirq().
+ *	and device's subsystem, @suspend() or @suspend_late() may be allowed to
+ *	put the device into the low-power state and configure it to generate
+ *	wakeup signals, in which case it generally is not necessary to define
+ *	@suspend_noirq().
  *
  * @resume_noirq: Prepare for the execution of @resume() by carrying out any
  *	operations required for resuming the device that might be racing with
@@ -171,9 +192,9 @@ typedef struct pm_message {
  *	additional operations required for freezing the device that might be
  *	racing with its driver's interrupt handler, which is guaranteed not to
  *	run while @freeze_noirq() is being executed.
- *	The power state of the device should not be changed by either @freeze()
- *	or @freeze_noirq() and it should not be configured to signal system
- *	wakeup by any of these callbacks.
+ *	The power state of the device should not be changed by either @freeze(),
+ *	or @freeze_late(), or @freeze_noirq() and it should not be configured to
+ *	signal system wakeup by any of these callbacks.
  *
  * @thaw_noirq: Prepare for the execution of @thaw() by carrying out any
  *	operations required for thawing the device that might be racing with its
@@ -249,6 +270,12 @@ struct dev_pm_ops {
 	int (*thaw)(struct device *dev);
 	int (*poweroff)(struct device *dev);
 	int (*restore)(struct device *dev);
+	int (*suspend_late)(struct device *dev);
+	int (*resume_early)(struct device *dev);
+	int (*freeze_late)(struct device *dev);
+	int (*thaw_early)(struct device *dev);
+	int (*poweroff_late)(struct device *dev);
+	int (*restore_early)(struct device *dev);
 	int (*suspend_noirq)(struct device *dev);
 	int (*resume_noirq)(struct device *dev);
 	int (*freeze_noirq)(struct device *dev);
@@ -584,13 +611,13 @@ struct dev_pm_domain {
 
 #ifdef CONFIG_PM_SLEEP
 extern void device_pm_lock(void);
-extern void dpm_resume_noirq(pm_message_t state);
+extern void dpm_resume_start(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);
 extern void dpm_resume(pm_message_t state);
 extern void dpm_complete(pm_message_t state);
 
 extern void device_pm_unlock(void);
-extern int dpm_suspend_noirq(pm_message_t state);
+extern int dpm_suspend_end(pm_message_t state);
 extern int dpm_suspend_start(pm_message_t state);
 extern int dpm_suspend(pm_message_t state);
 extern int dpm_prepare(pm_message_t state);

commit 0015afaa1f818d38ea9f8e81a84a6aeeca5fdaf0
Merge: b7ba68c4a072 00dc9ad18d70
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 25 23:43:05 2011 +0100

    Merge branch 'pm-runtime' into pm-for-linus
    
    * pm-runtime:
      PM / Runtime: Use device PM QoS constraints (v2)

commit 90363ddf0a1a4dccfbb8d0c10b8f488bc7fa69f8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 18 00:34:42 2011 +0100

    PM: Drop generic_subsys_pm_ops
    
    Since the PM core is now going to execute driver callbacks directly
    if the corresponding subsystem callbacks are not present,
    forward-only subsystem callbacks (i.e. such that only execute the
    corresponding driver callbacks) are not necessary any more.  Thus
    it is possible to remove generic_subsys_pm_ops, because the only
    callback in there that is not forward-only, .runtime_idle, is not
    really used by the only user of generic_subsys_pm_ops, which is
    vio_bus_type.
    
    However, the generic callback routines themselves cannot be removed
    from generic_ops.c, because they are used individually by a number
    of subsystems.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3f3ed83a9aa5..21e04dd72a84 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -300,19 +300,6 @@ const struct dev_pm_ops name = { \
 	SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
 }
 
-/*
- * Use this for subsystems (bus types, device types, device classes) that don't
- * need any special suspend/resume handling in addition to invoking the PM
- * callbacks provided by device drivers supporting both the system sleep PM and
- * runtime PM, make the pm member point to generic_subsys_pm_ops.
- */
-#ifdef CONFIG_PM
-extern struct dev_pm_ops generic_subsys_pm_ops;
-#define GENERIC_SUBSYS_PM_OPS	(&generic_subsys_pm_ops)
-#else
-#define GENERIC_SUBSYS_PM_OPS	NULL
-#endif
-
 /**
  * PM_EVENT_ messages
  *

commit 00dc9ad18d707f36b2fb4af98fd2cf0548d2b258
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 1 00:01:31 2011 +0100

    PM / Runtime: Use device PM QoS constraints (v2)
    
    Make the runtime PM core use device PM QoS constraints to check if
    it is allowed to suspend a given device, so that an error code is
    returned if the device's own PM QoS constraint is negative or one of
    its children has already been suspended for too long.  If this is
    not the case, the maximum estimated time the device is allowed to be
    suspended, computed as the minimum of the device's PM QoS constraint
    and the PM QoS constraints of its children (reduced by the difference
    between the current time and their suspend times) is stored in a new
    device's PM field power.max_time_suspended_ns that can be used by
    the device's subsystem or PM domain to decide whether or not to put
    the device into lower-power (and presumably higher-latency) states
    later (if the constraint is 0, which means "no constraint", the
    power.max_time_suspended_ns is set to -1).
    
    Additionally, the time of execution of the subsystem-level
    .runtime_suspend() callback for the device is recorded in the new
    power.suspend_time field for later use by the device's subsystem or
    PM domain along with power.max_time_suspended_ns (it also is used
    by the core code when the device's parent is suspended).
    
    Introduce a new helper function,
    pm_runtime_update_max_time_suspended(), allowing subsystems and PM
    domains (or device drivers) to update the power.max_time_suspended_ns
    field, for example after changing the power state of a suspended
    device.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3f3ed83a9aa5..a7676efa6831 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -521,6 +521,8 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
+	ktime_t			suspend_time;
+	s64			max_time_suspended_ns;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
 	struct pm_qos_constraints *constraints;

commit f7bc83d87d242917ca0ee041ed509f57f361dd56
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Nov 23 21:20:32 2011 +0100

    PM: Update comments describing device power management callbacks
    
    The comments describing device power management callbacks in
    include/pm.h are outdated and somewhat confusing, so make them
    reflect the reality more accurately.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 5c4c8b18c8b7..3f3ed83a9aa5 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -54,118 +54,145 @@ typedef struct pm_message {
 /**
  * struct dev_pm_ops - device PM callbacks
  *
- * Several driver power state transitions are externally visible, affecting
+ * Several device power state transitions are externally visible, affecting
  * the state of pending I/O queues and (for drivers that touch hardware)
  * interrupts, wakeups, DMA, and other hardware state.  There may also be
- * internal transitions to various low power modes, which are transparent
+ * internal transitions to various low-power modes which are transparent
  * to the rest of the driver stack (such as a driver that's ON gating off
  * clocks which are not in active use).
  *
- * The externally visible transitions are handled with the help of the following
- * callbacks included in this structure:
- *
- * @prepare: Prepare the device for the upcoming transition, but do NOT change
- *	its hardware state.  Prevent new children of the device from being
- *	registered after @prepare() returns (the driver's subsystem and
- *	generally the rest of the kernel is supposed to prevent new calls to the
- *	probe method from being made too once @prepare() has succeeded).  If
- *	@prepare() detects a situation it cannot handle (e.g. registration of a
- *	child already in progress), it may return -EAGAIN, so that the PM core
- *	can execute it once again (e.g. after the new child has been registered)
- *	to recover from the race condition.  This method is executed for all
- *	kinds of suspend transitions and is followed by one of the suspend
- *	callbacks: @suspend(), @freeze(), or @poweroff().
- *	The PM core executes @prepare() for all devices before starting to
- *	execute suspend callbacks for any of them, so drivers may assume all of
- *	the other devices to be present and functional while @prepare() is being
- *	executed.  In particular, it is safe to make GFP_KERNEL memory
- *	allocations from within @prepare().  However, drivers may NOT assume
- *	anything about the availability of the user space at that time and it
- *	is not correct to request firmware from within @prepare() (it's too
- *	late to do that).  [To work around this limitation, drivers may
- *	register suspend and hibernation notifiers that are executed before the
- *	freezing of tasks.]
+ * The externally visible transitions are handled with the help of callbacks
+ * included in this structure in such a way that two levels of callbacks are
+ * involved.  First, the PM core executes callbacks provided by PM domains,
+ * device types, classes and bus types.  They are the subsystem-level callbacks
+ * supposed to execute callbacks provided by device drivers, although they may
+ * choose not to do that.  If the driver callbacks are executed, they have to
+ * collaborate with the subsystem-level callbacks to achieve the goals
+ * appropriate for the given system transition, given transition phase and the
+ * subsystem the device belongs to.
+ *
+ * @prepare: The principal role of this callback is to prevent new children of
+ *	the device from being registered after it has returned (the driver's
+ *	subsystem and generally the rest of the kernel is supposed to prevent
+ *	new calls to the probe method from being made too once @prepare() has
+ *	succeeded).  If @prepare() detects a situation it cannot handle (e.g.
+ *	registration of a child already in progress), it may return -EAGAIN, so
+ *	that the PM core can execute it once again (e.g. after a new child has
+ *	been registered) to recover from the race condition.
+ *	This method is executed for all kinds of suspend transitions and is
+ *	followed by one of the suspend callbacks: @suspend(), @freeze(), or
+ *	@poweroff().  The PM core executes subsystem-level @prepare() for all
+ *	devices before starting to invoke suspend callbacks for any of them, so
+ *	generally devices may be assumed to be functional or to respond to
+ *	runtime resume requests while @prepare() is being executed.  However,
+ *	device drivers may NOT assume anything about the availability of user
+ *	space at that time and it is NOT valid to request firmware from within
+ *	@prepare() (it's too late to do that).  It also is NOT valid to allocate
+ *	substantial amounts of memory from @prepare() in the GFP_KERNEL mode.
+ *	[To work around these limitations, drivers may register suspend and
+ *	hibernation notifiers to be executed before the freezing of tasks.]
  *
  * @complete: Undo the changes made by @prepare().  This method is executed for
  *	all kinds of resume transitions, following one of the resume callbacks:
  *	@resume(), @thaw(), @restore().  Also called if the state transition
- *	fails before the driver's suspend callback (@suspend(), @freeze(),
- *	@poweroff()) can be executed (e.g. if the suspend callback fails for one
+ *	fails before the driver's suspend callback: @suspend(), @freeze() or
+ *	@poweroff(), can be executed (e.g. if the suspend callback fails for one
  *	of the other devices that the PM core has unsuccessfully attempted to
  *	suspend earlier).
- *	The PM core executes @complete() after it has executed the appropriate
- *	resume callback for all devices.
+ *	The PM core executes subsystem-level @complete() after it has executed
+ *	the appropriate resume callbacks for all devices.
  *
  * @suspend: Executed before putting the system into a sleep state in which the
- *	contents of main memory are preserved.  Quiesce the device, put it into
- *	a low power state appropriate for the upcoming system state (such as
- *	PCI_D3hot), and enable wakeup events as appropriate.
+ *	contents of main memory are preserved.  The exact action to perform
+ *	depends on the device's subsystem (PM domain, device type, class or bus
+ *	type), but generally the device must be quiescent after subsystem-level
+ *	@suspend() has returned, so that it doesn't do any I/O or DMA.
+ *	Subsystem-level @suspend() is executed for all devices after invoking
+ *	subsystem-level @prepare() for all of them.
  *
  * @resume: Executed after waking the system up from a sleep state in which the
- *	contents of main memory were preserved.  Put the device into the
- *	appropriate state, according to the information saved in memory by the
- *	preceding @suspend().  The driver starts working again, responding to
- *	hardware events and software requests.  The hardware may have gone
- *	through a power-off reset, or it may have maintained state from the
- *	previous suspend() which the driver may rely on while resuming.  On most
- *	platforms, there are no restrictions on availability of resources like
- *	clocks during @resume().
+ *	contents of main memory were preserved.  The exact action to perform
+ *	depends on the device's subsystem, but generally the driver is expected
+ *	to start working again, responding to hardware events and software
+ *	requests (the device itself may be left in a low-power state, waiting
+ *	for a runtime resume to occur).  The state of the device at the time its
+ *	driver's @resume() callback is run depends on the platform and subsystem
+ *	the device belongs to.  On most platforms, there are no restrictions on
+ *	availability of resources like clocks during @resume().
+ *	Subsystem-level @resume() is executed for all devices after invoking
+ *	subsystem-level @resume_noirq() for all of them.
  *
  * @freeze: Hibernation-specific, executed before creating a hibernation image.
- *	Quiesce operations so that a consistent image can be created, but do NOT
- *	otherwise put the device into a low power device state and do NOT emit
- *	system wakeup events.  Save in main memory the device settings to be
- *	used by @restore() during the subsequent resume from hibernation or by
- *	the subsequent @thaw(), if the creation of the image or the restoration
- *	of main memory contents from it fails.
+ *	Analogous to @suspend(), but it should not enable the device to signal
+ *	wakeup events or change its power state.  The majority of subsystems
+ *	(with the notable exception of the PCI bus type) expect the driver-level
+ *	@freeze() to save the device settings in memory to be used by @restore()
+ *	during the subsequent resume from hibernation.
+ *	Subsystem-level @freeze() is executed for all devices after invoking
+ *	subsystem-level @prepare() for all of them.
  *
  * @thaw: Hibernation-specific, executed after creating a hibernation image OR
- *	if the creation of the image fails.  Also executed after a failing
+ *	if the creation of an image has failed.  Also executed after a failing
  *	attempt to restore the contents of main memory from such an image.
  *	Undo the changes made by the preceding @freeze(), so the device can be
  *	operated in the same way as immediately before the call to @freeze().
+ *	Subsystem-level @thaw() is executed for all devices after invoking
+ *	subsystem-level @thaw_noirq() for all of them.  It also may be executed
+ *	directly after @freeze() in case of a transition error.
  *
  * @poweroff: Hibernation-specific, executed after saving a hibernation image.
- *	Quiesce the device, put it into a low power state appropriate for the
- *	upcoming system state (such as PCI_D3hot), and enable wakeup events as
- *	appropriate.
+ *	Analogous to @suspend(), but it need not save the device's settings in
+ *	memory.
+ *	Subsystem-level @poweroff() is executed for all devices after invoking
+ *	subsystem-level @prepare() for all of them.
  *
  * @restore: Hibernation-specific, executed after restoring the contents of main
- *	memory from a hibernation image.  Driver starts working again,
- *	responding to hardware events and software requests.  Drivers may NOT
- *	make ANY assumptions about the hardware state right prior to @restore().
- *	On most platforms, there are no restrictions on availability of
- *	resources like clocks during @restore().
- *
- * @suspend_noirq: Complete the operations of ->suspend() by carrying out any
- *	actions required for suspending the device that need interrupts to be
- *	disabled
- *
- * @resume_noirq: Prepare for the execution of ->resume() by carrying out any
- *	actions required for resuming the device that need interrupts to be
- *	disabled
- *
- * @freeze_noirq: Complete the operations of ->freeze() by carrying out any
- *	actions required for freezing the device that need interrupts to be
- *	disabled
- *
- * @thaw_noirq: Prepare for the execution of ->thaw() by carrying out any
- *	actions required for thawing the device that need interrupts to be
- *	disabled
- *
- * @poweroff_noirq: Complete the operations of ->poweroff() by carrying out any
- *	actions required for handling the device that need interrupts to be
- *	disabled
- *
- * @restore_noirq: Prepare for the execution of ->restore() by carrying out any
- *	actions required for restoring the operations of the device that need
- *	interrupts to be disabled
+ *	memory from a hibernation image, analogous to @resume().
+ *
+ * @suspend_noirq: Complete the actions started by @suspend().  Carry out any
+ *	additional operations required for suspending the device that might be
+ *	racing with its driver's interrupt handler, which is guaranteed not to
+ *	run while @suspend_noirq() is being executed.
+ *	It generally is expected that the device will be in a low-power state
+ *	(appropriate for the target system sleep state) after subsystem-level
+ *	@suspend_noirq() has returned successfully.  If the device can generate
+ *	system wakeup signals and is enabled to wake up the system, it should be
+ *	configured to do so at that time.  However, depending on the platform
+ *	and device's subsystem, @suspend() may be allowed to put the device into
+ *	the low-power state and configure it to generate wakeup signals, in
+ *	which case it generally is not necessary to define @suspend_noirq().
+ *
+ * @resume_noirq: Prepare for the execution of @resume() by carrying out any
+ *	operations required for resuming the device that might be racing with
+ *	its driver's interrupt handler, which is guaranteed not to run while
+ *	@resume_noirq() is being executed.
+ *
+ * @freeze_noirq: Complete the actions started by @freeze().  Carry out any
+ *	additional operations required for freezing the device that might be
+ *	racing with its driver's interrupt handler, which is guaranteed not to
+ *	run while @freeze_noirq() is being executed.
+ *	The power state of the device should not be changed by either @freeze()
+ *	or @freeze_noirq() and it should not be configured to signal system
+ *	wakeup by any of these callbacks.
+ *
+ * @thaw_noirq: Prepare for the execution of @thaw() by carrying out any
+ *	operations required for thawing the device that might be racing with its
+ *	driver's interrupt handler, which is guaranteed not to run while
+ *	@thaw_noirq() is being executed.
+ *
+ * @poweroff_noirq: Complete the actions started by @poweroff().  Analogous to
+ *	@suspend_noirq(), but it need not save the device's settings in memory.
+ *
+ * @restore_noirq: Prepare for the execution of @restore() by carrying out any
+ *	operations required for thawing the device that might be racing with its
+ *	driver's interrupt handler, which is guaranteed not to run while
+ *	@restore_noirq() is being executed.  Analogous to @resume_noirq().
  *
  * All of the above callbacks, except for @complete(), return error codes.
  * However, the error codes returned by the resume operations, @resume(),
- * @thaw(), @restore(), @resume_noirq(), @thaw_noirq(), and @restore_noirq() do
+ * @thaw(), @restore(), @resume_noirq(), @thaw_noirq(), and @restore_noirq(), do
  * not cause the PM core to abort the resume transition during which they are
- * returned.  The error codes returned in that cases are only printed by the PM
+ * returned.  The error codes returned in those cases are only printed by the PM
  * core to the system logs for debugging purposes.  Still, it is recommended
  * that drivers only return error codes from their resume methods in case of an
  * unrecoverable failure (i.e. when the device being handled refuses to resume
@@ -174,31 +201,43 @@ typedef struct pm_message {
  * their children.
  *
  * It is allowed to unregister devices while the above callbacks are being
- * executed.  However, it is not allowed to unregister a device from within any
- * of its own callbacks.
+ * executed.  However, a callback routine must NOT try to unregister the device
+ * it was called for, although it may unregister children of that device (for
+ * example, if it detects that a child was unplugged while the system was
+ * asleep).
+ *
+ * Refer to Documentation/power/devices.txt for more information about the role
+ * of the above callbacks in the system suspend process.
  *
- * There also are the following callbacks related to run-time power management
- * of devices:
+ * There also are callbacks related to runtime power management of devices.
+ * Again, these callbacks are executed by the PM core only for subsystems
+ * (PM domains, device types, classes and bus types) and the subsystem-level
+ * callbacks are supposed to invoke the driver callbacks.  Moreover, the exact
+ * actions to be performed by a device driver's callbacks generally depend on
+ * the platform and subsystem the device belongs to.
  *
  * @runtime_suspend: Prepare the device for a condition in which it won't be
  *	able to communicate with the CPU(s) and RAM due to power management.
- *	This need not mean that the device should be put into a low power state.
+ *	This need not mean that the device should be put into a low-power state.
  *	For example, if the device is behind a link which is about to be turned
  *	off, the device may remain at full power.  If the device does go to low
- *	power and is capable of generating run-time wake-up events, remote
- *	wake-up (i.e., a hardware mechanism allowing the device to request a
- *	change of its power state via a wake-up event, such as PCI PME) should
- *	be enabled for it.
+ *	power and is capable of generating runtime wakeup events, remote wakeup
+ *	(i.e., a hardware mechanism allowing the device to request a change of
+ *	its power state via an interrupt) should be enabled for it.
  *
  * @runtime_resume: Put the device into the fully active state in response to a
- *	wake-up event generated by hardware or at the request of software.  If
- *	necessary, put the device into the full power state and restore its
+ *	wakeup event generated by hardware or at the request of software.  If
+ *	necessary, put the device into the full-power state and restore its
  *	registers, so that it is fully operational.
  *
- * @runtime_idle: Device appears to be inactive and it might be put into a low
- *	power state if all of the necessary conditions are satisfied.  Check
+ * @runtime_idle: Device appears to be inactive and it might be put into a
+ *	low-power state if all of the necessary conditions are satisfied.  Check
  *	these conditions and handle the device as appropriate, possibly queueing
  *	a suspend request for it.  The return value is ignored by the PM core.
+ *
+ * Refer to Documentation/power/runtime_pm.txt for more information about the
+ * role of the above callbacks in device runtime power management.
+ *
  */
 
 struct dev_pm_ops {

commit 8b258cc8ac229aa7d5dcb7cc34cb35d9124498ac
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 17 21:39:33 2011 +0100

    PM Sleep: Do not extend wakeup paths to devices with ignore_children set
    
    Commit 4ca46ff3e0d8c234cb40ebb6457653b59584426c (PM / Sleep: Mark
    devices involved in wakeup signaling during suspend) introduced
    the power.wakeup_path field in struct dev_pm_info to mark devices
    whose children are enabled to wake up the system from sleep states,
    so that power domains containing the parents that provide their
    children with wakeup power and/or relay their wakeup signals are not
    turned off.  Unfortunately, that introduced a PM regression on SH7372
    whose power consumption in the system "memory sleep" state increased
    as a result of it, because it prevented the power domain containing
    the I2C controller from being turned off when some children of that
    controller were enabled to wake up the system, although the
    controller was not necessary for them to signal wakeup.
    
    To fix this issue use the observation that devices whose
    power.ignore_children flag is set for runtime PM should be treated
    analogously during system suspend.  Namely, they shouldn't be
    included in wakeup paths going through their children.  Since the
    SH7372 I2C controller's power.ignore_children flag is set, doing so
    will restore the previous behavior of that SOC.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f15acb646813..5c4c8b18c8b7 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -447,6 +447,7 @@ struct dev_pm_info {
 	unsigned int		async_suspend:1;
 	bool			is_prepared:1;	/* Owned by the PM core */
 	bool			is_suspended:1;	/* Ditto */
+	bool			ignore_children:1;
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;
@@ -464,7 +465,6 @@ struct dev_pm_info {
 	atomic_t		usage_count;
 	atomic_t		child_count;
 	unsigned int		disable_depth:3;
-	unsigned int		ignore_children:1;
 	unsigned int		idle_notification:1;
 	unsigned int		request_pending:1;
 	unsigned int		deferred_resume:1;

commit d033e078566faed8c8f59baf97ee57ce2524ef5c
Merge: 081a9d043c98 382414b93ac1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Oct 22 00:21:52 2011 +0200

    Merge branch 'pm-domains' into pm-for-linus
    
    * pm-domains:
      ARM: mach-shmobile: sh7372 A4R support (v4)
      ARM: mach-shmobile: sh7372 A3SP support (v4)
      PM / Sleep: Mark devices involved in wakeup signaling during suspend

commit 4ca46ff3e0d8c234cb40ebb6457653b59584426c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Oct 16 23:34:36 2011 +0200

    PM / Sleep: Mark devices involved in wakeup signaling during suspend
    
    The generic PM domains code in drivers/base/power/domain.c has
    to avoid powering off domains that provide power to wakeup devices
    during system suspend.  Currently, however, this only works for
    wakeup devices directly belonging to the given domain and not for
    their children (or the children of their children and so on).
    Thus, if there's a wakeup device whose parent belongs to a power
    domain handled by the generic PM domains code, the domain will be
    powered off during system suspend preventing the device from
    signaling wakeup.
    
    To address this problem introduce a device flag, power.wakeup_path,
    that will be set during system suspend for all wakeup devices,
    their parents, the parents of their parents and so on.  This way,
    all wakeup paths in the device hierarchy will be marked and the
    generic PM domains code will only need to avoid powering off
    domains containing devices whose power.wakeup_path is set.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f25682477f08..74711a9c2f69 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -448,6 +448,7 @@ struct dev_pm_info {
 	struct list_head	entry;
 	struct completion	completion;
 	struct wakeup_source	*wakeup;
+	bool			wakeup_path:1;
 #else
 	unsigned int		should_wakeup:1;
 #endif

commit 9696cc90071e3660ec02a3728acdedb68afdce4c
Merge: c28b56b1d46b e3cba3243eb8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 7 23:17:07 2011 +0200

    Merge branch 'pm-qos' into pm-for-linus
    
    * pm-qos:
      PM / QoS: Update Documentation for the pm_qos and dev_pm_qos frameworks
      PM / QoS: Add function dev_pm_qos_read_value() (v3)
      PM QoS: Add global notification mechanism for device constraints
      PM QoS: Implement per-device PM QoS constraints
      PM QoS: Generalize and export constraints management code
      PM QoS: Reorganize data structs
      PM QoS: Code reorganization
      PM QoS: Minor clean-ups
      PM QoS: Move and rename the implementation files

commit c28b56b1d46b1bbb1be33c8f2632a88b0de1ef68
Merge: d727b60659a1 cd0ea672f58d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 7 23:17:02 2011 +0200

    Merge branch 'pm-domains' into pm-for-linus
    
    * pm-domains:
      PM / Domains: Split device PM domain data into base and need_restore
      ARM: mach-shmobile: sh7372 sleep warning fixes
      ARM: mach-shmobile: sh7372 A3SM support
      ARM: mach-shmobile: sh7372 generic suspend/resume support
      PM / Domains: Preliminary support for devices with power.irq_safe set
      PM: Move clock-related definitions and headers to separate file
      PM / Domains: Use power.sybsys_data to reduce overhead
      PM: Reference counting of power.subsys_data
      PM: Introduce struct pm_subsys_data
      ARM / shmobile: Make A3RV be a subdomain of A4LC on SH7372
      PM / Domains: Rename argument of pm_genpd_add_subdomain()
      PM / Domains: Rename GPD_STATE_WAIT_PARENT to GPD_STATE_WAIT_MASTER
      PM / Domains: Allow generic PM domains to have multiple masters
      PM / Domains: Add "wait for parent" status for generic PM domains
      PM / Domains: Make pm_genpd_poweron() always survive parent removal
      PM / Domains: Do not take parent locks to modify subdomain counters
      PM / Domains: Implement subdomain counters as atomic fields

commit 1a9a91525d806f2b3bd8b57b963755a96fd36ce2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Sep 29 22:29:44 2011 +0200

    PM / QoS: Add function dev_pm_qos_read_value() (v3)
    
    To read the current PM QoS value for a given device we need to
    make sure that the device's power.constraints object won't be
    removed while we're doing that.  For this reason, put the
    operation under dev->power.lock and acquire the lock
    around the initialization and removal of power.constraints.
    
    Moreover, since we're using the value of power.constraints to
    determine whether or not the object is present, the
    power.constraints_state field isn't necessary any more and may be
    removed.  However, dev_pm_qos_add_request() needs to check if the
    device is being removed from the system before allocating a new
    PM QoS constraints object for it, so make it use the
    power.power_state field of struct device for this purpose.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index d78187e9ca99..62a876ec4d4e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -326,6 +326,7 @@ extern struct dev_pm_ops generic_subsys_pm_ops;
  *			requested by a driver.
  */
 
+#define PM_EVENT_INVALID	(-1)
 #define PM_EVENT_ON		0x0000
 #define PM_EVENT_FREEZE 	0x0001
 #define PM_EVENT_SUSPEND	0x0002
@@ -346,6 +347,7 @@ extern struct dev_pm_ops generic_subsys_pm_ops;
 #define PM_EVENT_AUTO_SUSPEND	(PM_EVENT_AUTO | PM_EVENT_SUSPEND)
 #define PM_EVENT_AUTO_RESUME	(PM_EVENT_AUTO | PM_EVENT_RESUME)
 
+#define PMSG_INVALID	((struct pm_message){ .event = PM_EVENT_INVALID, })
 #define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
 #define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
 #define PMSG_QUIESCE	((struct pm_message){ .event = PM_EVENT_QUIESCE, })
@@ -419,13 +421,6 @@ enum rpm_request {
 	RPM_REQ_RESUME,
 };
 
-/* Per-device PM QoS constraints data struct state */
-enum dev_pm_qos_state {
-	DEV_PM_QOS_NO_DEVICE,		/* No device present */
-	DEV_PM_QOS_DEVICE_PRESENT,	/* Device present, data not allocated */
-	DEV_PM_QOS_ALLOCATED,		/* Device present, data allocated */
-};
-
 struct wakeup_source;
 
 struct pm_domain_data {
@@ -488,7 +483,6 @@ struct dev_pm_info {
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
 	struct pm_qos_constraints *constraints;
-	enum dev_pm_qos_state	constraints_state;
 };
 
 extern void update_pm_runtime_accounting(struct device *dev);

commit cd0ea672f58d5cfdea271c45cec0c897f2b792aa
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 26 20:22:02 2011 +0200

    PM / Domains: Split device PM domain data into base and need_restore
    
    The struct pm_domain_data data type is defined in such a way that
    adding new fields specific to the generic PM domains code will
    require include/linux/pm.h to be modified.  As a result, data types
    used only by the generic PM domains code will be defined in two
    headers, although they all should be defined in pm_domain.h and
    pm.h will need to include more headers, which won't be very nice.
    
    For this reason change the definition of struct pm_subsys_data
    so that its domain_data member is a pointer, which will allow
    struct pm_domain_data to be subclassed by various PM domains
    implementations.  Remove the need_restore member from
    struct pm_domain_data and make the generic PM domains code
    subclass it by adding the need_restore member to the new data type.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ed10f24d5259..f25682477f08 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -424,7 +424,6 @@ struct wakeup_source;
 struct pm_domain_data {
 	struct list_head list_node;
 	struct device *dev;
-	bool need_restore;
 };
 
 struct pm_subsys_data {
@@ -434,7 +433,7 @@ struct pm_subsys_data {
 	struct list_head clock_list;
 #endif
 #ifdef CONFIG_PM_GENERIC_DOMAINS
-	struct pm_domain_data domain_data;
+	struct pm_domain_data *domain_data;
 #endif
 };
 

commit 91ff4cb803df6de9114351b9f2f0f39f397ee03e
Author: Jean Pihet <j-pihet@ti.com>
Date:   Thu Aug 25 15:35:41 2011 +0200

    PM QoS: Implement per-device PM QoS constraints
    
    Implement the per-device PM QoS constraints by creating a device
    PM QoS API, which calls the PM QoS constraints management core code.
    
    The per-device latency constraints data strctures are stored
    in the device dev_pm_info struct.
    
    The device PM code calls the init and destroy of the per-device constraints
    data struct in order to support the dynamic insertion and removal of the
    devices in the system.
    
    To minimize the data usage by the per-device constraints, the data struct
    is only allocated at the first call to dev_pm_qos_add_request.
    The data is later free'd when the device is removed from the system.
    A global mutex protects the constraints users from the data being
    allocated and free'd.
    
    Signed-off-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ed10f24d5259..d78187e9ca99 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -419,6 +419,13 @@ enum rpm_request {
 	RPM_REQ_RESUME,
 };
 
+/* Per-device PM QoS constraints data struct state */
+enum dev_pm_qos_state {
+	DEV_PM_QOS_NO_DEVICE,		/* No device present */
+	DEV_PM_QOS_DEVICE_PRESENT,	/* Device present, data not allocated */
+	DEV_PM_QOS_ALLOCATED,		/* Device present, data allocated */
+};
+
 struct wakeup_source;
 
 struct pm_domain_data {
@@ -480,6 +487,8 @@ struct dev_pm_info {
 	unsigned long		accounting_timestamp;
 #endif
 	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
+	struct pm_qos_constraints *constraints;
+	enum dev_pm_qos_state	constraints_state;
 };
 
 extern void update_pm_runtime_accounting(struct device *dev);

commit 4605ab653c1f9d7cc2dda8033de215c9cee325f4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:34:12 2011 +0200

    PM / Domains: Use power.sybsys_data to reduce overhead
    
    Currently pm_genpd_runtime_resume() has to walk the list of devices
    from the device's PM domain to find the corresponding device list
    object containing the need_restore field to check if the driver's
    .runtime_resume() callback should be executed for the device.
    This is suboptimal and can be simplified by using power.sybsys_data
    to store device information used by the generic PM domains code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index c6b5a0a41ab3..ed10f24d5259 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -421,12 +421,21 @@ enum rpm_request {
 
 struct wakeup_source;
 
+struct pm_domain_data {
+	struct list_head list_node;
+	struct device *dev;
+	bool need_restore;
+};
+
 struct pm_subsys_data {
 	spinlock_t lock;
 	unsigned int refcount;
 #ifdef CONFIG_PM_CLK
 	struct list_head clock_list;
 #endif
+#ifdef CONFIG_PM_GENERIC_DOMAINS
+	struct pm_domain_data domain_data;
+#endif
 };
 
 struct dev_pm_info {

commit ef27bed1870dbd5fd363ff5ec51eebd5a695e277
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:34:01 2011 +0200

    PM: Reference counting of power.subsys_data
    
    Since the power.subsys_data device field will be used by multiple
    filesystems, introduce a reference counting mechanism for it to avoid
    freeing it prematurely or changing its value at a wrong time.
    
    Make the PM clocks management code that currently is the only user of
    power.subsys_data use the new reference counting.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index bf5ee37388d4..c6b5a0a41ab3 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -423,6 +423,7 @@ struct wakeup_source;
 
 struct pm_subsys_data {
 	spinlock_t lock;
+	unsigned int refcount;
 #ifdef CONFIG_PM_CLK
 	struct list_head clock_list;
 #endif
@@ -473,6 +474,8 @@ struct dev_pm_info {
 };
 
 extern void update_pm_runtime_accounting(struct device *dev);
+extern int dev_pm_get_subsys_data(struct device *dev);
+extern int dev_pm_put_subsys_data(struct device *dev);
 
 /*
  * Power domains provide callbacks that are executed during system suspend,

commit 5c095a0e0d600d5a5a4207eaadabd18db46395ce
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Aug 25 15:33:50 2011 +0200

    PM: Introduce struct pm_subsys_data
    
    Introduce struct pm_subsys_data that may be subclassed by subsystems
    to store subsystem-specific information related to the device.  Move
    the clock management fields accessed through the power.subsys_data
    pointer in struct device to the new strucutre.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f7c84c9abd30..bf5ee37388d4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -421,6 +421,13 @@ enum rpm_request {
 
 struct wakeup_source;
 
+struct pm_subsys_data {
+	spinlock_t lock;
+#ifdef CONFIG_PM_CLK
+	struct list_head clock_list;
+#endif
+};
+
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
@@ -462,7 +469,7 @@ struct dev_pm_info {
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
 #endif
-	void			*subsys_data;  /* Owned by the subsystem. */
+	struct pm_subsys_data	*subsys_data;  /* Owned by the subsystem. */
 };
 
 extern void update_pm_runtime_accounting(struct device *dev);

commit 5b1b0b812a7b1a5b968c5d06d90d1cb88621b941
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Aug 19 23:49:48 2011 +0200

    PM / Runtime: Add macro to test for runtime PM events
    
    This patch (as1482) adds a macro for testing whether or not a
    pm_message value represents an autosuspend or autoresume (i.e., a
    runtime PM) event.  Encapsulating this notion seems preferable to
    open-coding the test all over the place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index f7c84c9abd30..18de9f893497 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -366,6 +366,8 @@ extern struct dev_pm_ops generic_subsys_pm_ops;
 #define PMSG_AUTO_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_AUTO_RESUME, })
 
+#define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
+
 /**
  * Device run-time power management status.
  *

commit e5291928839877f8e73c2643ee1d3fe0bcdcaf5c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jul 1 22:12:59 2011 +0200

    PM: Introduce generic "noirq" callback routines for subsystems (v2)
    
    Introduce generic "noirq" power management callback routines for
    subsystems in addition to the "regular" generic PM callback routines.
    
    The new routines will be used, among other things, for implementing
    system-wide PM transitions support for generic PM domains.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 7e8f0763d1ec..f7c84c9abd30 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -553,11 +553,17 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
 
 extern int pm_generic_prepare(struct device *dev);
+extern int pm_generic_suspend_noirq(struct device *dev);
 extern int pm_generic_suspend(struct device *dev);
+extern int pm_generic_resume_noirq(struct device *dev);
 extern int pm_generic_resume(struct device *dev);
+extern int pm_generic_freeze_noirq(struct device *dev);
 extern int pm_generic_freeze(struct device *dev);
+extern int pm_generic_thaw_noirq(struct device *dev);
 extern int pm_generic_thaw(struct device *dev);
+extern int pm_generic_restore_noirq(struct device *dev);
 extern int pm_generic_restore(struct device *dev);
+extern int pm_generic_poweroff_noirq(struct device *dev);
 extern int pm_generic_poweroff(struct device *dev);
 extern void pm_generic_complete(struct device *dev);
 

commit dc6e4e56e6ef473a696a1ab24f80b79b9aceb92d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 23 01:53:04 2011 +0200

    PM: subsys_data in struct dev_pm_info need not depend on RM_RUNTIME
    
    The subsys_data field of struct dev_pm_info, introduced by commit
    1d2b71f61b6a10216274e27b717becf9ae101fc7 (PM / Runtime: Add subsystem
    data field to struct dev_pm_info), is going to be used even if
    CONFIG_PM_RUNTIME is not set, so move it from under the #ifdef.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e3963208aa93..7e8f0763d1ec 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -461,8 +461,8 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
-	void			*subsys_data;  /* Owned by the subsystem. */
 #endif
+	void			*subsys_data;  /* Owned by the subsystem. */
 };
 
 extern void update_pm_runtime_accounting(struct device *dev);

commit 564b905ab10d17fb42f86aa8b7b9b796276d1336
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 23 01:52:55 2011 +0200

    PM / Domains: Rename struct dev_power_domain to struct dev_pm_domain
    
    The naming convention used by commit 7538e3db6e015e890825fbd9f86599b
    (PM: Add support for device power domains), which introduced the
    struct dev_power_domain type for representing device power domains,
    evidently confuses some developers who tend to think that objects
    of this type must correspond to "power domains" as defined by
    hardware, which is not the case.  Namely, at the kernel level, a
    struct dev_power_domain object can represent arbitrary set of devices
    that are mutually dependent power management-wise and need not belong
    to one hardware power domain.  To avoid that confusion, rename struct
    dev_power_domain to struct dev_pm_domain and rename the related
    pointers in struct device and struct pm_clk_notifier_block from
    pwr_domain to pm_domain.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 411e4f4be52b..e3963208aa93 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -472,7 +472,7 @@ extern void update_pm_runtime_accounting(struct device *dev);
  * hibernation, system resume and during runtime PM transitions along with
  * subsystem-level and driver-level callbacks.
  */
-struct dev_power_domain {
+struct dev_pm_domain {
 	struct dev_pm_ops	ops;
 };
 

commit 6d0e0e84f66d32c33511984dd3badd32364b863c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jun 18 22:42:09 2011 +0200

    PM: Fix async resume following suspend failure
    
    The PM core doesn't handle suspend failures correctly when it comes to
    asynchronously suspended devices.  These devices are moved onto the
    dpm_suspended_list as soon as the corresponding async thread is
    started up, and they remain on the list even if they fail to suspend
    or the sleep transition is cancelled before they get suspended.  As a
    result, when the PM core unwinds the transition, it tries to resume
    the devices even though they were never suspended.
    
    This patch (as1474) fixes the problem by adding a new "is_suspended"
    flag to dev_pm_info.  Devices are resumed only if the flag is set.
    
    [rjw:
     * Moved the dev->power.is_suspended check into device_resume(),
       because we need to complete dev->power.completion and clear
       dev->power.is_prepared too for devices whose
       dev->power.is_suspended flags are unset.
     * Fixed __device_suspend() to avoid setting dev->power.is_suspended
       if async_error is different from zero.]
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

diff --git a/include/linux/pm.h b/include/linux/pm.h
index cc536bd80984..411e4f4be52b 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -426,6 +426,7 @@ struct dev_pm_info {
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
 	bool			is_prepared:1;	/* Owned by the PM core */
+	bool			is_suspended:1;	/* Ditto */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit f76b168b6f117a49d36307053e1acbe30580ea5b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jun 18 20:22:23 2011 +0200

    PM: Rename dev_pm_info.in_suspend to is_prepared
    
    This patch (as1473) renames the "in_suspend" field in struct
    dev_pm_info to "is_prepared", in preparation for an upcoming change.
    The new name is more descriptive of what the field really means.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3160648ccdda..cc536bd80984 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -425,7 +425,7 @@ struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
-	unsigned int		in_suspend:1;	/* Owned by the PM core */
+	bool			is_prepared:1;	/* Owned by the PM core */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit 6538df80194e305f1b78cafb556f4bb442f808b3
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 17 23:26:21 2011 +0200

    PM: Introduce generic prepare and complete callbacks for subsystems
    
    Introduce generic .prepare() and .complete() power management
    callbacks, currently missing, that can be used by subsystems and
    power domains and export them.  Provide NULL definitions of all
    the generic system sleep callbacks for CONFIG_PM_SLEEP unset.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index dce7c7148771..3160648ccdda 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -550,6 +550,16 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 	} while (0)
 
 extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
+
+extern int pm_generic_prepare(struct device *dev);
+extern int pm_generic_suspend(struct device *dev);
+extern int pm_generic_resume(struct device *dev);
+extern int pm_generic_freeze(struct device *dev);
+extern int pm_generic_thaw(struct device *dev);
+extern int pm_generic_restore(struct device *dev);
+extern int pm_generic_poweroff(struct device *dev);
+extern void pm_generic_complete(struct device *dev);
+
 #else /* !CONFIG_PM_SLEEP */
 
 #define device_pm_lock() do {} while (0)
@@ -566,6 +576,15 @@ static inline int device_pm_wait_for_dev(struct device *a, struct device *b)
 {
 	return 0;
 }
+
+#define pm_generic_prepare	NULL
+#define pm_generic_suspend	NULL
+#define pm_generic_resume	NULL
+#define pm_generic_freeze	NULL
+#define pm_generic_thaw		NULL
+#define pm_generic_restore	NULL
+#define pm_generic_poweroff	NULL
+#define pm_generic_complete	NULL
 #endif /* !CONFIG_PM_SLEEP */
 
 /* How to reorder dpm_list after device_move() */
@@ -576,11 +595,4 @@ enum dpm_order {
 	DPM_ORDER_DEV_LAST,
 };
 
-extern int pm_generic_suspend(struct device *dev);
-extern int pm_generic_resume(struct device *dev);
-extern int pm_generic_freeze(struct device *dev);
-extern int pm_generic_thaw(struct device *dev);
-extern int pm_generic_restore(struct device *dev);
-extern int pm_generic_poweroff(struct device *dev);
-
 #endif /* _LINUX_PM_H */

commit 91e7c75ba93c48a82670d630b9daac92ff70095d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 17 23:26:00 2011 +0200

    PM: Allow drivers to allocate memory from .prepare() callbacks safely
    
    If device drivers allocate substantial amounts of memory (above 1 MB)
    in their hibernate .freeze() callbacks (or in their legacy suspend
    callbcks during hibernation), the subsequent creation of hibernate
    image may fail due to the lack of memory.  This is the case, because
    the drivers' .freeze() callbacks are executed after the hibernate
    memory preallocation has been carried out and the preallocated amount
    of memory may be too small to cover the new driver allocations.
    Unfortunately, the drivers' .prepare() callbacks also are executed
    after the hibernate memory preallocation has completed, so they are
    not suitable for allocating additional memory either.  Thus the only
    way a driver can safely allocate memory during hibernation is to use
    a hibernate/suspend notifier.  However, the notifiers are called
    before the freezing of user space and the drivers wanting to use them
    for allocating additional memory may not know how much memory needs
    to be allocated at that point.
    
    To let device drivers overcome this difficulty rework the hibernation
    sequence so that the memory preallocation is carried out after the
    drivers' .prepare() callbacks have been executed, so that the
    .prepare() callbacks can be used for allocating additional memory
    to be used by the drivers' .freeze() callbacks.  Update documentation
    to match the new behavior of the code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3cc3e7e589f0..dce7c7148771 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -533,10 +533,14 @@ struct dev_power_domain {
 extern void device_pm_lock(void);
 extern void dpm_resume_noirq(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);
+extern void dpm_resume(pm_message_t state);
+extern void dpm_complete(pm_message_t state);
 
 extern void device_pm_unlock(void);
 extern int dpm_suspend_noirq(pm_message_t state);
 extern int dpm_suspend_start(pm_message_t state);
+extern int dpm_suspend(pm_message_t state);
+extern int dpm_prepare(pm_message_t state);
 
 extern void __suspend_report_result(const char *function, void *fn, int ret);
 

commit 290c748725c170ed9a02522959ae67f528eefe98
Merge: 2d2a9163bd4f 72874daa5e90
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 17 23:23:46 2011 +0200

    Merge branch 'power-domains' into for-linus
    
    * power-domains:
      PM: Fix build issue in clock_ops.c for CONFIG_PM_RUNTIME unset
      PM: Revert "driver core: platform_bus: allow runtime override of dev_pm_ops"
      OMAP1 / PM: Use generic clock manipulation routines for runtime PM
      PM / Runtime: Generic clock manipulation rountines for runtime PM (v6)
      PM / Runtime: Add subsystem data field to struct dev_pm_info
      OMAP2+ / PM: move runtime PM implementation to use device power domains
      PM / Platform: Use generic runtime PM callbacks directly
      shmobile: Use power domains for platform runtime PM
      PM: Export platform bus type's default PM callbacks
      PM: Make power domain callbacks take precedence over subsystem ones

commit 2e711c04dbbf7a7732a3f7073b1fc285d12b369d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 19:15:07 2011 +0200

    PM: Remove sysdev suspend, resume and shutdown operations
    
    Since suspend, resume and shutdown operations in struct sysdev_class
    and struct sysdev_driver are not used any more, remove them.  Also
    drop sysdev_suspend(), sysdev_resume() and sysdev_shutdown() used
    for executing those operations and modify all of their users
    accordingly.  This reduces kernel code size quite a bit and reduces
    its complexity.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 512e09177e57..3c053e2beb84 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -529,14 +529,6 @@ struct dev_power_domain {
  */
 
 #ifdef CONFIG_PM_SLEEP
-#ifndef CONFIG_ARCH_NO_SYSDEV_OPS
-extern int sysdev_suspend(pm_message_t state);
-extern int sysdev_resume(void);
-#else
-static inline int sysdev_suspend(pm_message_t state) { return 0; }
-static inline int sysdev_resume(void) { return 0; }
-#endif
-
 extern void device_pm_lock(void);
 extern void dpm_resume_noirq(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);

commit 1d2b71f61b6a10216274e27b717becf9ae101fc7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Apr 29 00:36:53 2011 +0200

    PM / Runtime: Add subsystem data field to struct dev_pm_info
    
    Some subsystems need to attach PM-related data to struct device and
    they need to use devres for this purpose.  For their convenience
    and to make code more straightforward, add a new field called
    subsys_data to struct dev_pm_info and let subsystems use it for
    attaching PM-related information to devices.
    
    Convert the ARM shmobile platform to using the new field.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 512e09177e57..f4167d0faa67 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -460,6 +460,7 @@ struct dev_pm_info {
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;
+	void			*subsys_data;  /* Owned by the subsystem. */
 #endif
 };
 

commit d47d81c0e9abdc3c88653fabff5beae82c949b09
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Mar 23 22:16:41 2011 +0100

    Introduce ARCH_NO_SYSDEV_OPS config option (v2)
    
    Introduce Kconfig option allowing architectures where sysdev
    operations used during system suspend, resume and shutdown have been
    completely replaced with struct sycore_ops operations to avoid
    building sysdev code that will never be used.
    
    Make callbacks in struct sys_device and struct sysdev_driver depend
    on ARCH_NO_SYSDEV_OPS to allows us to verify if all of the references
    have been actually removed from the code the given architecture
    depends on.
    
    Make x86 select ARCH_NO_SYSDEV_OPS.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6618216bb973..512e09177e57 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -529,13 +529,19 @@ struct dev_power_domain {
  */
 
 #ifdef CONFIG_PM_SLEEP
-extern void device_pm_lock(void);
+#ifndef CONFIG_ARCH_NO_SYSDEV_OPS
+extern int sysdev_suspend(pm_message_t state);
 extern int sysdev_resume(void);
+#else
+static inline int sysdev_suspend(pm_message_t state) { return 0; }
+static inline int sysdev_resume(void) { return 0; }
+#endif
+
+extern void device_pm_lock(void);
 extern void dpm_resume_noirq(pm_message_t state);
 extern void dpm_resume_end(pm_message_t state);
 
 extern void device_pm_unlock(void);
-extern int sysdev_suspend(pm_message_t state);
 extern int dpm_suspend_noirq(pm_message_t state);
 extern int dpm_suspend_start(pm_message_t state);
 

commit 7538e3db6e015e890825fbd9f8659952896ddd5b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 16 21:53:17 2011 +0100

    PM: Add support for device power domains
    
    The platform bus type is often used to handle Systems-on-a-Chip (SoC)
    where all devices are represented by objects of type struct
    platform_device.  In those cases the same "platform" device driver
    may be used with multiple different system configurations, but the
    actions needed to put the devices it handles into a low-power state
    and back into the full-power state may depend on the design of the
    given SoC.  The driver, however, cannot possibly include all the
    information necessary for the power management of its device on all
    the systems it is used with.  Moreover, the device hierarchy in its
    current form also is not suitable for representing this kind of
    information.
    
    The patch below attempts to address this problem by introducing
    objects of type struct dev_power_domain that can be used for
    representing power domains within a SoC.  Every struct
    dev_power_domain object provides a sets of device power
    management callbacks that can be used to perform what's needed for
    device power management in addition to the operations carried out by
    the device's driver and subsystem.
    
    Namely, if a struct dev_power_domain object is pointed to by the
    pwr_domain field in a struct device, the callbacks provided by its
    ops member will be executed in addition to the corresponding
    callbacks provided by the device's subsystem and driver during all
    power transitions.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-and-acked-by: Kevin Hilman <khilman@ti.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 1f79c98f1e56..6618216bb973 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -465,6 +465,14 @@ struct dev_pm_info {
 
 extern void update_pm_runtime_accounting(struct device *dev);
 
+/*
+ * Power domains provide callbacks that are executed during system suspend,
+ * hibernation, system resume and during runtime PM transitions along with
+ * subsystem-level and driver-level callbacks.
+ */
+struct dev_power_domain {
+	struct dev_pm_ops	ops;
+};
 
 /*
  * The PM_EVENT_ messages are also used by drivers implementing the legacy

commit 6831c6edc7b272a08dd2a6c71bb183a48fe98ae6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 15 21:22:24 2011 +0100

    PM: Drop pm_flags that is not necessary
    
    The variable pm_flags is used to prevent APM from being enabled
    along with ACPI, which would lead to problems.  However, acpi_init()
    is always called before apm_init() and after acpi_init() has
    returned, it is known whether or not ACPI will be used.  Namely, if
    acpi_disabled is not set after acpi_init() has returned, this means
    that ACPI is enabled.  Thus, it is sufficient to check acpi_disabled
    in apm_init() to prevent APM from being enabled in parallel with
    ACPI.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 9279175a4557..1f79c98f1e56 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -565,15 +565,6 @@ enum dpm_order {
 	DPM_ORDER_DEV_LAST,
 };
 
-/*
- * Global Power Management flags
- * Used to keep APM and ACPI from both being active
- */
-extern unsigned int	pm_flags;
-
-#define PM_APM	1
-#define PM_ACPI	2
-
 extern int pm_generic_suspend(struct device *dev);
 extern int pm_generic_resume(struct device *dev);
 extern int pm_generic_freeze(struct device *dev);

commit aa33860158114d0df3c7997bc1dd41c0168e1c2a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Feb 11 00:06:54 2011 +0100

    PM: Remove CONFIG_PM_OPS
    
    After redefining CONFIG_PM to depend on (CONFIG_PM_SLEEP ||
    CONFIG_PM_RUNTIME) the CONFIG_PM_OPS option is redundant and can be
    replaced with CONFIG_PM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 21415cc91cbb..9279175a4557 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -267,7 +267,7 @@ const struct dev_pm_ops name = { \
  * callbacks provided by device drivers supporting both the system sleep PM and
  * runtime PM, make the pm member point to generic_subsys_pm_ops.
  */
-#ifdef CONFIG_PM_OPS
+#ifdef CONFIG_PM
 extern struct dev_pm_ops generic_subsys_pm_ops;
 #define GENERIC_SUBSYS_PM_OPS	(&generic_subsys_pm_ops)
 #else

commit 805bdaec1a44155db35f6ee5410d6bbc365324a8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Feb 24 11:10:01 2011 +0100

    PM: Make ACPI wakeup from S5 work again when CONFIG_PM_SLEEP is unset
    
    Commit 074037e (PM / Wakeup: Introduce wakeup source objects and
    event statistics (v3)) caused ACPI wakeup to only work if
    CONFIG_PM_SLEEP is set, but it also worked for CONFIG_PM_SLEEP unset
    before.  This can be fixed by making device_set_wakeup_enable(),
    device_init_wakeup() and device_may_wakeup() work in the same way
    as before commit 074037e when CONFIG_PM_SLEEP is unset.
    
    Reported-and-tested-by: Justin Maggard <jmaggard10@gmail.com>
    Cc: stable@kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index dd9c7ab38270..21415cc91cbb 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -431,6 +431,8 @@ struct dev_pm_info {
 	struct list_head	entry;
 	struct completion	completion;
 	struct wakeup_source	*wakeup;
+#else
+	unsigned int		should_wakeup:1;
 #endif
 #ifdef CONFIG_PM_RUNTIME
 	struct timer_list	suspend_timer;

commit 62bcb91573425975d6ad2389d7ab1d8feca88ab4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Dec 24 15:04:41 2010 +0100

    PM: Prototype the pm_generic_ operations
    
    The pm_generic_ operations are all exported but are not prototyped in any
    header file for direct use. Do so.
    
    [rjw: Added extern.]
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index c1756dfeb8c5..dd9c7ab38270 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -572,4 +572,11 @@ extern unsigned int	pm_flags;
 #define PM_APM	1
 #define PM_ACPI	2
 
+extern int pm_generic_suspend(struct device *dev);
+extern int pm_generic_resume(struct device *dev);
+extern int pm_generic_freeze(struct device *dev);
+extern int pm_generic_thaw(struct device *dev);
+extern int pm_generic_restore(struct device *dev);
+extern int pm_generic_poweroff(struct device *dev);
+
 #endif /* _LINUX_PM_H */

commit b8c76f6aed0ab7df73a6410f3f82de2c831bb144
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 16 00:51:21 2010 +0100

    PM: Replace the device power.status field with a bit field
    
    The device power.status field is too complicated for its purpose
    (storing the information about whether or not the device is in the
    "active" state from the PM core's point of view), so replace it with
    a bit field and modify all of its users accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 61f2066e6852..c1756dfeb8c5 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -366,45 +366,6 @@ extern struct dev_pm_ops generic_subsys_pm_ops;
 #define PMSG_AUTO_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_AUTO_RESUME, })
 
-/**
- * Device power management states
- *
- * These state labels are used internally by the PM core to indicate the current
- * status of a device with respect to the PM core operations.
- *
- * DPM_ON		Device is regarded as operational.  Set this way
- *			initially and when ->complete() is about to be called.
- *			Also set when ->prepare() fails.
- *
- * DPM_PREPARING	Device is going to be prepared for a PM transition.  Set
- *			when ->prepare() is about to be called.
- *
- * DPM_RESUMING		Device is going to be resumed.  Set when ->resume(),
- *			->thaw(), or ->restore() is about to be called.
- *
- * DPM_SUSPENDING	Device has been prepared for a power transition.  Set
- *			when ->prepare() has just succeeded.
- *
- * DPM_OFF		Device is regarded as inactive.  Set immediately after
- *			->suspend(), ->freeze(), or ->poweroff() has succeeded.
- *			Also set when ->resume()_noirq, ->thaw_noirq(), or
- *			->restore_noirq() is about to be called.
- *
- * DPM_OFF_IRQ		Device is in a "deep sleep".  Set immediately after
- *			->suspend_noirq(), ->freeze_noirq(), or
- *			->poweroff_noirq() has just succeeded.
- */
-
-enum dpm_state {
-	DPM_INVALID,
-	DPM_ON,
-	DPM_PREPARING,
-	DPM_RESUMING,
-	DPM_SUSPENDING,
-	DPM_OFF,
-	DPM_OFF_IRQ,
-};
-
 /**
  * Device run-time power management status.
  *
@@ -463,8 +424,8 @@ struct wakeup_source;
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
-	unsigned		async_suspend:1;
-	enum dpm_state		status;		/* Owned by the PM core */
+	unsigned int		async_suspend:1;
+	unsigned int		in_suspend:1;	/* Owned by the PM core */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;

commit c7b61de5b7b17f0df34dc7d2f8b9576f8bd36fce
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 1 00:14:42 2010 +0100

    PM / Runtime: Add synchronous runtime interface for interrupt handlers (v3)
    
    This patch (as1431c) makes the synchronous runtime-PM interface
    suitable for use in interrupt handlers.  Subsystems can call the new
    pm_runtime_irq_safe() function to tell the PM core that a device's
    runtime_suspend and runtime_resume callbacks should be invoked with
    interrupts disabled and the spinlock held.  This permits the
    pm_runtime_get_sync() and the new pm_runtime_put_sync_suspend()
    routines to be called from within interrupt handlers.
    
    When a device is declared irq-safe in this way, the PM core increments
    the parent's usage count, so the parent will never be runtime
    suspended.  This prevents difficult situations in which an irq-safe
    device can't resume because it is forced to wait for its non-irq-safe
    parent.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 40f3f45702ba..61f2066e6852 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -486,6 +486,7 @@ struct dev_pm_info {
 	unsigned int		run_wake:1;
 	unsigned int		runtime_auto:1;
 	unsigned int		no_callbacks:1;
+	unsigned int		irq_safe:1;
 	unsigned int		use_autosuspend:1;
 	unsigned int		timer_autosuspends:1;
 	enum rpm_request	request;

commit 15bcb91d7e607d8a2e060f01f7784a7454668da4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:21 2010 +0200

    PM / Runtime: Implement autosuspend support
    
    This patch (as1427) implements the "autosuspend" facility for runtime
    PM.  A few new fields are added to the dev_pm_info structure and
    several new PM helper functions are defined, for telling the PM core
    whether or not a device uses autosuspend, for setting the autosuspend
    delay, and for marking periods of device activity.
    
    Drivers that do not want to use autosuspend can continue using the
    same helper functions as before; their behavior will not change.  In
    addition, drivers supporting autosuspend can also call the old helper
    functions to get the old behavior.
    
    The details are all explained in Documentation/power/runtime_pm.txt
    and Documentation/ABI/testing/sysfs-devices-power.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index abd81ffaba3c..40f3f45702ba 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -444,6 +444,9 @@ enum rpm_status {
  *
  * RPM_REQ_SUSPEND	Run the device bus type's ->runtime_suspend() callback
  *
+ * RPM_REQ_AUTOSUSPEND	Same as RPM_REQ_SUSPEND, but not until the device has
+ *			been inactive for as long as power.autosuspend_delay
+ *
  * RPM_REQ_RESUME	Run the device bus type's ->runtime_resume() callback
  */
 
@@ -451,6 +454,7 @@ enum rpm_request {
 	RPM_REQ_NONE = 0,
 	RPM_REQ_IDLE,
 	RPM_REQ_SUSPEND,
+	RPM_REQ_AUTOSUSPEND,
 	RPM_REQ_RESUME,
 };
 
@@ -482,9 +486,13 @@ struct dev_pm_info {
 	unsigned int		run_wake:1;
 	unsigned int		runtime_auto:1;
 	unsigned int		no_callbacks:1;
+	unsigned int		use_autosuspend:1;
+	unsigned int		timer_autosuspends:1;
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;
+	int			autosuspend_delay;
+	unsigned long		last_busy;
 	unsigned long		active_jiffies;
 	unsigned long		suspended_jiffies;
 	unsigned long		accounting_timestamp;

commit 7490e44239e60293bca0c2663229050c36c660c2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Sep 25 23:35:15 2010 +0200

    PM / Runtime: Add no_callbacks flag
    
    Some devices, such as USB interfaces, cannot be power-managed
    independently of their parents, i.e., they cannot be put in low power
    while the parent remains at full power.  This patch (as1425) creates a
    new "no_callbacks" flag, which tells the PM core not to invoke the
    runtime-PM callback routines for the such devices but instead to
    assume that the callbacks always succeed.  In addition, the
    non-debugging runtime-PM sysfs attributes for the devices are removed,
    since they are pretty much meaningless.
    
    The advantage of this scheme comes not so much from avoiding the
    callbacks themselves, but rather from the fact that without the need
    for a process context in which to run the callbacks, more work can be
    done in interrupt context.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 1abfe84f447d..abd81ffaba3c 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -41,6 +41,12 @@ extern void (*pm_power_off_prepare)(void);
 
 struct device;
 
+#ifdef CONFIG_PM
+extern const char power_group_name[];		/* = "power" */
+#else
+#define power_group_name	NULL
+#endif
+
 typedef struct pm_message {
 	int event;
 } pm_message_t;
@@ -475,6 +481,7 @@ struct dev_pm_info {
 	unsigned int		deferred_resume:1;
 	unsigned int		run_wake:1;
 	unsigned int		runtime_auto:1;
+	unsigned int		no_callbacks:1;
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;

commit 098dff738abbeaea15fc95c4f4fdaee1e9bbea75
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:10:57 2010 +0200

    PM: Fix potential issue with failing asynchronous suspend
    
    There is a potential issue with the asynchronous suspend code that
    a device driver suspending asynchronously may not notice that it
    should back off.  There are two failing scenarions, (1) when the
    driver is waiting for a driver suspending synchronously to complete
    and that second driver returns error code, in which case async_error
    won't be set and the waiting driver will continue suspending and (2)
    after the driver has called device_pm_wait_for_dev() and the waited
    for driver returns error code, in which case the caller of
    device_pm_wait_for_dev() will not know that there was an error and
    will continue suspending.
    
    To fix this issue make __device_suspend() set async_error, so
    async_suspend() doesn't need to set it any more, and make
    device_pm_wait_for_dev() return async_error, so that its callers
    can check whether or not they should continue suspending.
    
    No more changes are necessary, since device_pm_wait_for_dev() is
    not used by any drivers' suspend routines.
    
    Reported-by: Colin Cross <ccross@android.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index a84118911ced..1abfe84f447d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -559,7 +559,7 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 		__suspend_report_result(__func__, fn, ret);		\
 	} while (0)
 
-extern void device_pm_wait_for_dev(struct device *sub, struct device *dev);
+extern int device_pm_wait_for_dev(struct device *sub, struct device *dev);
 #else /* !CONFIG_PM_SLEEP */
 
 #define device_pm_lock() do {} while (0)
@@ -572,7 +572,10 @@ static inline int dpm_suspend_start(pm_message_t state)
 
 #define suspend_report_result(fn, ret)		do {} while (0)
 
-static inline void device_pm_wait_for_dev(struct device *a, struct device *b) {}
+static inline int device_pm_wait_for_dev(struct device *a, struct device *b)
+{
+	return 0;
+}
 #endif /* !CONFIG_PM_SLEEP */
 
 /* How to reorder dpm_list after device_move() */

commit 074037ec79bea73edf1b1ec72fef1010e83e3cc5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 22 22:09:10 2010 +0200

    PM / Wakeup: Introduce wakeup source objects and event statistics (v3)
    
    Introduce struct wakeup_source for representing system wakeup sources
    within the kernel and for collecting statistics related to them.
    Make the recently introduced helper functions pm_wakeup_event(),
    pm_stay_awake() and pm_relax() use struct wakeup_source objects
    internally, so that wakeup statistics associated with wakeup devices
    can be collected and reported in a consistent way (the definition of
    pm_relax() is changed, which is harmless, because this function is
    not called directly by anyone yet).  Introduce new wakeup-related
    sysfs device attributes in /sys/devices/.../power for reporting the
    device wakeup statistics.
    
    Change the global wakeup events counters event_count and
    events_in_progress into atomic variables, so that it is not necessary
    to acquire a global spinlock in pm_wakeup_event(), pm_stay_awake()
    and pm_relax(), which should allow us to avoid lock contention in
    these functions on SMP systems with many wakeup devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 52e8c55ff314..a84118911ced 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -448,23 +448,24 @@ enum rpm_request {
 	RPM_REQ_RESUME,
 };
 
+struct wakeup_source;
+
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
-	unsigned int		should_wakeup:1;
 	unsigned		async_suspend:1;
 	enum dpm_state		status;		/* Owned by the PM core */
+	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;
 	struct completion	completion;
-	unsigned long		wakeup_count;
+	struct wakeup_source	*wakeup;
 #endif
 #ifdef CONFIG_PM_RUNTIME
 	struct timer_list	suspend_timer;
 	unsigned long		timer_expires;
 	struct work_struct	work;
 	wait_queue_head_t	wait_queue;
-	spinlock_t		lock;
 	atomic_t		usage_count;
 	atomic_t		child_count;
 	unsigned int		disable_depth:3;
@@ -559,11 +560,6 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 	} while (0)
 
 extern void device_pm_wait_for_dev(struct device *sub, struct device *dev);
-
-/* drivers/base/power/wakeup.c */
-extern void pm_wakeup_event(struct device *dev, unsigned int msec);
-extern void pm_stay_awake(struct device *dev);
-extern void pm_relax(void);
 #else /* !CONFIG_PM_SLEEP */
 
 #define device_pm_lock() do {} while (0)
@@ -577,10 +573,6 @@ static inline int dpm_suspend_start(pm_message_t state)
 #define suspend_report_result(fn, ret)		do {} while (0)
 
 static inline void device_pm_wait_for_dev(struct device *a, struct device *b) {}
-
-static inline void pm_wakeup_event(struct device *dev, unsigned int msec) {}
-static inline void pm_stay_awake(struct device *dev) {}
-static inline void pm_relax(void) {}
 #endif /* !CONFIG_PM_SLEEP */
 
 /* How to reorder dpm_list after device_move() */

commit 8d4b9d1bfef117862a2889dec4dac227068544c9
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Jul 19 02:01:06 2010 +0200

    PM / Runtime: Add runtime PM statistics (v3)
    
    In order for PowerTOP to be able to report how well the new runtime PM is
    working for the various drivers, the kernel needs to export some basic
    statistics in sysfs.
    
    This patch adds two sysfs files in the runtime PM domain that expose the
    total time a device has been active, and the time a device has been
    suspended.
    
    With this PowerTOP can compute the activity percentage
    
    Active %age = 100 * (delta active) / (delta active + delta suspended)
    
    and present the information to the user.
    
    I've written the PowerTOP code (slated for version 1.12) already, and the
    output looks like this:
    
    Runtime Device Power Management statistics
    Active  Device name
     10.0%  06:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8101E/RTL8102E PCI Express Fast Ethernet controller
    
    [version 2: fix stat update bugs noticed by Alan Stern]
    [version 3: rebase to -next and move the sysfs declaration]
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b417fc46f3fc..52e8c55ff314 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -477,9 +477,15 @@ struct dev_pm_info {
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;
+	unsigned long		active_jiffies;
+	unsigned long		suspended_jiffies;
+	unsigned long		accounting_timestamp;
 #endif
 };
 
+extern void update_pm_runtime_accounting(struct device *dev);
+
+
 /*
  * The PM_EVENT_ messages are also used by drivers implementing the legacy
  * suspend framework, based on the ->suspend() and ->resume() callbacks common

commit c125e96f044427f38d106fab7bc5e4a5e6a18262
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 5 22:43:53 2010 +0200

    PM: Make it possible to avoid races between wakeup and system sleep
    
    One of the arguments during the suspend blockers discussion was that
    the mainline kernel didn't contain any mechanisms making it possible
    to avoid races between wakeup and system suspend.
    
    Generally, there are two problems in that area.  First, if a wakeup
    event occurs exactly when /sys/power/state is being written to, it
    may be delivered to user space right before the freezer kicks in, so
    the user space consumer of the event may not be able to process it
    before the system is suspended.  Second, if a wakeup event occurs
    after user space has been frozen, it is not generally guaranteed that
    the ongoing transition of the system into a sleep state will be
    aborted.
    
    To address these issues introduce a new global sysfs attribute,
    /sys/power/wakeup_count, associated with a running counter of wakeup
    events and three helper functions, pm_stay_awake(), pm_relax(), and
    pm_wakeup_event(), that may be used by kernel subsystems to control
    the behavior of this attribute and to request the PM core to abort
    system transitions into a sleep state already in progress.
    
    The /sys/power/wakeup_count file may be read from or written to by
    user space.  Reads will always succeed (unless interrupted by a
    signal) and return the current value of the wakeup events counter.
    Writes, however, will only succeed if the written number is equal to
    the current value of the wakeup events counter.  If a write is
    successful, it will cause the kernel to save the current value of the
    wakeup events counter and to abort the subsequent system transition
    into a sleep state if any wakeup events are reported after the write
    has returned.
    
    [The assumption is that before writing to /sys/power/state user space
    will first read from /sys/power/wakeup_count.  Next, user space
    consumers of wakeup events will have a chance to acknowledge or
    veto the upcoming system transition to a sleep state.  Finally, if
    the transition is allowed to proceed, /sys/power/wakeup_count will
    be written to and if that succeeds, /sys/power/state will be written
    to as well.  Still, if any wakeup events are reported to the PM core
    by kernel subsystems after that point, the transition will be
    aborted.]
    
    Additionally, put a wakeup events counter into struct dev_pm_info and
    make these per-device wakeup event counters available via sysfs,
    so that it's possible to check the activity of various wakeup event
    sources within the kernel.
    
    To illustrate how subsystems can use pm_wakeup_event(), make the
    low-level PCI runtime PM wakeup-handling code use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 8e258c727971..b417fc46f3fc 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -457,6 +457,7 @@ struct dev_pm_info {
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;
 	struct completion	completion;
+	unsigned long		wakeup_count;
 #endif
 #ifdef CONFIG_PM_RUNTIME
 	struct timer_list	suspend_timer;
@@ -552,6 +553,11 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 	} while (0)
 
 extern void device_pm_wait_for_dev(struct device *sub, struct device *dev);
+
+/* drivers/base/power/wakeup.c */
+extern void pm_wakeup_event(struct device *dev, unsigned int msec);
+extern void pm_stay_awake(struct device *dev);
+extern void pm_relax(void);
 #else /* !CONFIG_PM_SLEEP */
 
 #define device_pm_lock() do {} while (0)
@@ -565,6 +571,10 @@ static inline int dpm_suspend_start(pm_message_t state)
 #define suspend_report_result(fn, ret)		do {} while (0)
 
 static inline void device_pm_wait_for_dev(struct device *a, struct device *b) {}
+
+static inline void pm_wakeup_event(struct device *dev, unsigned int msec) {}
+static inline void pm_stay_awake(struct device *dev) {}
+static inline void pm_relax(void) {}
 #endif /* !CONFIG_PM_SLEEP */
 
 /* How to reorder dpm_list after device_move() */

commit d690b2cd222afc75320b9b8e9da7df02e9e630ca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Mar 6 21:28:37 2010 +0100

    PM: Provide generic subsystem-level callbacks
    
    There are subsystems whose power management callbacks only need to
    invoke the callbacks provided by device drivers.  Still, their system
    sleep PM callbacks should play well with the runtime PM callbacks,
    so that devices suspended at run time can be left in that state for
    a system sleep transition.
    
    Provide a set of generic PM callbacks for such subsystems and
    define convenience macros for populating dev_pm_ops structures.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e80df06ad22a..8e258c727971 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -215,20 +215,59 @@ struct dev_pm_ops {
 	int (*runtime_idle)(struct device *dev);
 };
 
+#ifdef CONFIG_PM_SLEEP
+#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
+	.suspend = suspend_fn, \
+	.resume = resume_fn, \
+	.freeze = suspend_fn, \
+	.thaw = resume_fn, \
+	.poweroff = suspend_fn, \
+	.restore = resume_fn,
+#else
+#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
+	.runtime_suspend = suspend_fn, \
+	.runtime_resume = resume_fn, \
+	.runtime_idle = idle_fn,
+#else
+#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn)
+#endif
+
 /*
  * Use this if you want to use the same suspend and resume callbacks for suspend
  * to RAM and hibernation.
  */
 #define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \
 const struct dev_pm_ops name = { \
-	.suspend = suspend_fn, \
-	.resume = resume_fn, \
-	.freeze = suspend_fn, \
-	.thaw = resume_fn, \
-	.poweroff = suspend_fn, \
-	.restore = resume_fn, \
+	SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
+}
+
+/*
+ * Use this for defining a set of PM operations to be used in all situations
+ * (sustem suspend, hibernation or runtime PM).
+ */
+#define UNIVERSAL_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \
+const struct dev_pm_ops name = { \
+	SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
+	SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
 }
 
+/*
+ * Use this for subsystems (bus types, device types, device classes) that don't
+ * need any special suspend/resume handling in addition to invoking the PM
+ * callbacks provided by device drivers supporting both the system sleep PM and
+ * runtime PM, make the pm member point to generic_subsys_pm_ops.
+ */
+#ifdef CONFIG_PM_OPS
+extern struct dev_pm_ops generic_subsys_pm_ops;
+#define GENERIC_SUBSYS_PM_OPS	(&generic_subsys_pm_ops)
+#else
+#define GENERIC_SUBSYS_PM_OPS	NULL
+#endif
+
 /**
  * PM_EVENT_ messages
  *

commit f8824cee405c62ba465b85365201166d9cf86a14
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 27 23:47:38 2010 +0100

    PM: Allow device drivers to use dpm_wait()
    
    There are some dependencies between devices (in particular, between
    EHCI USB controllers and their OHCI/UHCI siblings) which are not
    reflected by the structure of the device tree.  With synchronous
    suspend and resume these dependencies are taken into accout
    automatically, because the devices in question are always registered
    in the right order, but to meet these constraints with asynchronous
    suspend and resume the drivers of these devices will need to use
    dpm_wait() in their suspend/resume routines, so introduce a helper
    function allowing them to do that.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 9c16cd20fc96..e80df06ad22a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -512,6 +512,7 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 		__suspend_report_result(__func__, fn, ret);		\
 	} while (0)
 
+extern void device_pm_wait_for_dev(struct device *sub, struct device *dev);
 #else /* !CONFIG_PM_SLEEP */
 
 #define device_pm_lock() do {} while (0)
@@ -524,6 +525,7 @@ static inline int dpm_suspend_start(pm_message_t state)
 
 #define suspend_report_result(fn, ret)		do {} while (0)
 
+static inline void device_pm_wait_for_dev(struct device *a, struct device *b) {}
 #endif /* !CONFIG_PM_SLEEP */
 
 /* How to reorder dpm_list after device_move() */

commit 5af84b82701a96be4b033aaa51d86c72e2ded061
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 23 22:23:32 2010 +0100

    PM: Asynchronous suspend and resume of devices
    
    Theoretically, the total time of system sleep transitions (suspend
    to RAM, hibernation) can be reduced by running suspend and resume
    callbacks of device drivers in parallel with each other.  However,
    there are dependencies between devices such that we're not allowed
    to suspend the parent of a device before suspending the device
    itself.  Analogously, we're not allowed to resume a device before
    resuming its parent.
    
    The most straightforward way to take these dependencies into accout
    is to start the async threads used for suspending and resuming
    devices at the core level, so that async_schedule() is called for
    each suspend and resume callback supposed to be executed
    asynchronously.
    
    For this purpose, introduce a new device flag, power.async_suspend,
    used to mark the devices whose suspend and resume callbacks are to be
    executed asynchronously (ie. in parallel with the main suspend/resume
    thread and possibly in parallel with each other) and helper function
    device_enable_async_suspend() allowing one to set power.async_suspend
    for given device (power.async_suspend is unset by default for all
    devices).  For each device with the power.async_suspend flag set the
    PM core will use async_schedule() to execute its suspend and resume
    callbacks.
    
    The async threads started for different devices as a result of
    calling async_schedule() are synchronized with each other and with
    the main suspend/resume thread with the help of completions, in the
    following way:
    (1) There is a completion, power.completion, for each device object.
    (2) Each device's completion is reset before calling async_schedule()
        for the device or, in the case of devices with the
        power.async_suspend flags unset, before executing the device's
        suspend and resume callbacks.
    (3) During suspend, right before running the bus type, device type
        and device class suspend callbacks for the device, the PM core
        waits for the completions of all the device's children to be
        completed.
    (4) During resume, right before running the bus type, device type and
        device class resume callbacks for the device, the PM core waits
        for the completion of the device's parent to be completed.
    (5) The PM core completes power.completion for each device right
        after the bus type, device type and device class suspend (or
        resume) callbacks executed for the device have returned.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 25b1eca8049d..9c16cd20fc96 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -26,6 +26,7 @@
 #include <linux/spinlock.h>
 #include <linux/wait.h>
 #include <linux/timer.h>
+#include <linux/completion.h>
 
 /*
  * Callbacks for platform drivers to implement.
@@ -412,9 +413,11 @@ struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
 	unsigned int		should_wakeup:1;
+	unsigned		async_suspend:1;
 	enum dpm_state		status;		/* Owned by the PM core */
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;
+	struct completion	completion;
 #endif
 #ifdef CONFIG_PM_RUNTIME
 	struct timer_list	suspend_timer;

commit 53823639173cc9e9a261f68f4abefe62364b86c6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 23 22:02:51 2010 +0100

    PM / Runtime: Add sysfs switch for disabling device run-time PM
    
    Add new device sysfs attribute, power/control, allowing the user
    space to block the run-time power management of the devices.  If this
    attribute is set to "on", the driver of the device won't be able to power
    manage it at run time (without breaking the rules) and the device will
    always be in the full power state (except when the entire system goes
    into a sleep state).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 198b8f9fe05e..25b1eca8049d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -430,6 +430,7 @@ struct dev_pm_info {
 	unsigned int		request_pending:1;
 	unsigned int		deferred_resume:1;
 	unsigned int		run_wake:1;
+	unsigned int		runtime_auto:1;
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;

commit 471452104b8520337ae2fb48c4e61cd4896e025d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Dec 14 18:00:08 2009 -0800

    const: constify remaining dev_pm_ops
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 0d65934246af..198b8f9fe05e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -219,7 +219,7 @@ struct dev_pm_ops {
  * to RAM and hibernation.
  */
 #define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \
-struct dev_pm_ops name = { \
+const struct dev_pm_ops name = { \
 	.suspend = suspend_fn, \
 	.resume = resume_fn, \
 	.freeze = suspend_fn, \

commit 7a1a8eb58a2c6cd819d17332c5a2c369203635d5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 3 21:19:18 2009 +0100

    PM: Add flag for devices capable of generating run-time wake-up events
    
    Apparently, there are devices that can wake up the system from sleep
    states and yet are incapable of generating wake-up events at run
    time.  Thus, introduce a flag indicating if given device is capable
    of generating run-time wake-up events.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3b7e04b95bd2..0d65934246af 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -178,9 +178,10 @@ typedef struct pm_message {
  *	This need not mean that the device should be put into a low power state.
  *	For example, if the device is behind a link which is about to be turned
  *	off, the device may remain at full power.  If the device does go to low
- *	power and if device_may_wakeup(dev) is true, remote wake-up (i.e., a
- *	hardware mechanism allowing the device to request a change of its power
- *	state, such as PCI PME) should be enabled for it.
+ *	power and is capable of generating run-time wake-up events, remote
+ *	wake-up (i.e., a hardware mechanism allowing the device to request a
+ *	change of its power state via a wake-up event, such as PCI PME) should
+ *	be enabled for it.
  *
  * @runtime_resume: Put the device into the fully active state in response to a
  *	wake-up event generated by hardware or at the request of software.  If
@@ -428,6 +429,7 @@ struct dev_pm_info {
 	unsigned int		idle_notification:1;
 	unsigned int		request_pending:1;
 	unsigned int		deferred_resume:1;
+	unsigned int		run_wake:1;
 	enum rpm_request	request;
 	enum rpm_status		runtime_status;
 	int			runtime_error;

commit 9d62ec6ca71d71c8a0d2cb1004f476d33f668955
Author: Albin Tonnerre <albin.tonnerre@free-electrons.com>
Date:   Wed Aug 5 23:59:59 2009 +0200

    PM: Add convenience macro to make switching to dev_pm_ops less error-prone
    
    In a number of cases, the .suspend, .freeze, .poweroff and .resume,
    .thaw, .restore functions are identical. However, they all need to be
    assigned to avoid regressionsm as the previous code called .suspend
    resp. .resume in all those cases. SIMPLE_DEV_PM_OPS helps to deal
    with this case.
    
    [rjw: Changed the name of the macro and added the comment explaining its
     purpose.]
    
    Signed-off-by: Albin Tonnerre <albin.tonnerre@free-electrons.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 2b6e20df0e52..3b7e04b95bd2 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -213,6 +213,20 @@ struct dev_pm_ops {
 	int (*runtime_idle)(struct device *dev);
 };
 
+/*
+ * Use this if you want to use the same suspend and resume callbacks for suspend
+ * to RAM and hibernation.
+ */
+#define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \
+struct dev_pm_ops name = { \
+	.suspend = suspend_fn, \
+	.resume = resume_fn, \
+	.freeze = suspend_fn, \
+	.thaw = resume_fn, \
+	.poweroff = suspend_fn, \
+	.restore = resume_fn, \
+}
+
 /**
  * PM_EVENT_ messages
  *

commit 5e928f77a09a07f9dd595bb8a489965d69a83458
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Aug 18 23:38:32 2009 +0200

    PM: Introduce core framework for run-time PM of I/O devices (rev. 17)
    
    Introduce a core framework for run-time power management of I/O
    devices.  Add device run-time PM fields to 'struct dev_pm_info'
    and device run-time PM callbacks to 'struct dev_pm_ops'.  Introduce
    a run-time PM workqueue and define some device run-time PM helper
    functions at the core level.  Document all these things.
    
    Special thanks to Alan Stern for his help with the design and
    multiple detailed reviews of the pereceding versions of this patch
    and to Magnus Damm for testing feedback.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Magnus Damm <damm@igel.co.jp>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b3f74764a586..2b6e20df0e52 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -22,6 +22,10 @@
 #define _LINUX_PM_H
 
 #include <linux/list.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/timer.h>
 
 /*
  * Callbacks for platform drivers to implement.
@@ -165,6 +169,28 @@ typedef struct pm_message {
  * It is allowed to unregister devices while the above callbacks are being
  * executed.  However, it is not allowed to unregister a device from within any
  * of its own callbacks.
+ *
+ * There also are the following callbacks related to run-time power management
+ * of devices:
+ *
+ * @runtime_suspend: Prepare the device for a condition in which it won't be
+ *	able to communicate with the CPU(s) and RAM due to power management.
+ *	This need not mean that the device should be put into a low power state.
+ *	For example, if the device is behind a link which is about to be turned
+ *	off, the device may remain at full power.  If the device does go to low
+ *	power and if device_may_wakeup(dev) is true, remote wake-up (i.e., a
+ *	hardware mechanism allowing the device to request a change of its power
+ *	state, such as PCI PME) should be enabled for it.
+ *
+ * @runtime_resume: Put the device into the fully active state in response to a
+ *	wake-up event generated by hardware or at the request of software.  If
+ *	necessary, put the device into the full power state and restore its
+ *	registers, so that it is fully operational.
+ *
+ * @runtime_idle: Device appears to be inactive and it might be put into a low
+ *	power state if all of the necessary conditions are satisfied.  Check
+ *	these conditions and handle the device as appropriate, possibly queueing
+ *	a suspend request for it.  The return value is ignored by the PM core.
  */
 
 struct dev_pm_ops {
@@ -182,6 +208,9 @@ struct dev_pm_ops {
 	int (*thaw_noirq)(struct device *dev);
 	int (*poweroff_noirq)(struct device *dev);
 	int (*restore_noirq)(struct device *dev);
+	int (*runtime_suspend)(struct device *dev);
+	int (*runtime_resume)(struct device *dev);
+	int (*runtime_idle)(struct device *dev);
 };
 
 /**
@@ -315,14 +344,80 @@ enum dpm_state {
 	DPM_OFF_IRQ,
 };
 
+/**
+ * Device run-time power management status.
+ *
+ * These status labels are used internally by the PM core to indicate the
+ * current status of a device with respect to the PM core operations.  They do
+ * not reflect the actual power state of the device or its status as seen by the
+ * driver.
+ *
+ * RPM_ACTIVE		Device is fully operational.  Indicates that the device
+ *			bus type's ->runtime_resume() callback has completed
+ *			successfully.
+ *
+ * RPM_SUSPENDED	Device bus type's ->runtime_suspend() callback has
+ *			completed successfully.  The device is regarded as
+ *			suspended.
+ *
+ * RPM_RESUMING		Device bus type's ->runtime_resume() callback is being
+ *			executed.
+ *
+ * RPM_SUSPENDING	Device bus type's ->runtime_suspend() callback is being
+ *			executed.
+ */
+
+enum rpm_status {
+	RPM_ACTIVE = 0,
+	RPM_RESUMING,
+	RPM_SUSPENDED,
+	RPM_SUSPENDING,
+};
+
+/**
+ * Device run-time power management request types.
+ *
+ * RPM_REQ_NONE		Do nothing.
+ *
+ * RPM_REQ_IDLE		Run the device bus type's ->runtime_idle() callback
+ *
+ * RPM_REQ_SUSPEND	Run the device bus type's ->runtime_suspend() callback
+ *
+ * RPM_REQ_RESUME	Run the device bus type's ->runtime_resume() callback
+ */
+
+enum rpm_request {
+	RPM_REQ_NONE = 0,
+	RPM_REQ_IDLE,
+	RPM_REQ_SUSPEND,
+	RPM_REQ_RESUME,
+};
+
 struct dev_pm_info {
 	pm_message_t		power_state;
-	unsigned		can_wakeup:1;
-	unsigned		should_wakeup:1;
+	unsigned int		can_wakeup:1;
+	unsigned int		should_wakeup:1;
 	enum dpm_state		status;		/* Owned by the PM core */
-#ifdef	CONFIG_PM_SLEEP
+#ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;
 #endif
+#ifdef CONFIG_PM_RUNTIME
+	struct timer_list	suspend_timer;
+	unsigned long		timer_expires;
+	struct work_struct	work;
+	wait_queue_head_t	wait_queue;
+	spinlock_t		lock;
+	atomic_t		usage_count;
+	atomic_t		child_count;
+	unsigned int		disable_depth:3;
+	unsigned int		ignore_children:1;
+	unsigned int		idle_notification:1;
+	unsigned int		request_pending:1;
+	unsigned int		deferred_resume:1;
+	enum rpm_request	request;
+	enum rpm_status		runtime_status;
+	int			runtime_error;
+#endif
 };
 
 /*

commit d161630297a20802d01c55847bfcba85d2118a9f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sun May 24 22:05:42 2009 +0200

    PM core: rename suspend and resume functions
    
    This patch (as1241) renames a bunch of functions in the PM core.
    Rather than go through a boring list of name changes, suffice it to
    say that in the end we have a bunch of pairs of functions:
    
            device_resume_noirq     dpm_resume_noirq
            device_resume           dpm_resume
            device_complete         dpm_complete
            device_suspend_noirq    dpm_suspend_noirq
            device_suspend          dpm_suspend
            device_prepare          dpm_prepare
    
    in which device_X does the X operation on a single device and dpm_X
    invokes device_X for all devices in the dpm_list.
    
    In addition, the old dpm_power_up and device_resume_noirq have been
    combined into a single function (dpm_resume_noirq).
    
    Lastly, dpm_suspend_start and dpm_resume_end are the renamed versions
    of the former top-level device_suspend and device_resume routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 2170252074f3..b3f74764a586 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -382,14 +382,13 @@ struct dev_pm_info {
 #ifdef CONFIG_PM_SLEEP
 extern void device_pm_lock(void);
 extern int sysdev_resume(void);
-extern void device_resume_noirq(pm_message_t state);
-extern void device_resume(pm_message_t state);
+extern void dpm_resume_noirq(pm_message_t state);
+extern void dpm_resume_end(pm_message_t state);
 
 extern void device_pm_unlock(void);
 extern int sysdev_suspend(pm_message_t state);
-extern int device_suspend_noirq(pm_message_t state);
-extern int device_suspend(pm_message_t state);
-extern int device_prepare_suspend(pm_message_t state);
+extern int dpm_suspend_noirq(pm_message_t state);
+extern int dpm_suspend_start(pm_message_t state);
 
 extern void __suspend_report_result(const char *function, void *fn, int ret);
 
@@ -403,7 +402,7 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 #define device_pm_lock() do {} while (0)
 #define device_pm_unlock() do {} while (0)
 
-static inline int device_suspend(pm_message_t state)
+static inline int dpm_suspend_start(pm_message_t state)
 {
 	return 0;
 }

commit e39a71ef80877f4e30d808af9acceec80f4d2f7c
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri May 15 00:53:26 2009 +0200

    PM: Rename device_power_down/up()
    
    Rename the functions performing "_noirq" dev_pm_ops
    operations from device_power_down() and device_power_up()
    to device_suspend_noirq() and device_resume_noirq().
    
    The new function names are chosen to show that the functions
    are responsible for calling the _noirq() versions to finalize
    the suspend/resume operation. The current function names do
    not perform power down/up anymore so the names may be misleading.
    
    Global function renames:
    - device_power_down() -> device_suspend_noirq()
    - device_power_up() -> device_resume_noirq()
    
    Static function renames:
    - suspend_device_noirq() -> __device_suspend_noirq()
    - resume_device_noirq() -> __device_resume_noirq()
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 1d4e2d289821..2170252074f3 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -382,12 +382,12 @@ struct dev_pm_info {
 #ifdef CONFIG_PM_SLEEP
 extern void device_pm_lock(void);
 extern int sysdev_resume(void);
-extern void device_power_up(pm_message_t state);
+extern void device_resume_noirq(pm_message_t state);
 extern void device_resume(pm_message_t state);
 
 extern void device_pm_unlock(void);
 extern int sysdev_suspend(pm_message_t state);
-extern int device_power_down(pm_message_t state);
+extern int device_suspend_noirq(pm_message_t state);
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);
 

commit ffa6a7054d172a2f57248dff2de600ca795c5656
Author: Cornelia Huck <cornelia.huck@de.ibm.com>
Date:   Wed Mar 4 12:44:00 2009 +0100

    Driver core: Fix device_move() vs. dpm list ordering, v2
    
    dpm_list currently relies on the fact that child devices will
    be registered after their parents to get a correct suspend
    order. Using device_move() however destroys this assumption, as
    an already registered device may be moved under a newly registered
    one.
    
    This patch adds a new argument to device_move(), allowing callers
    to specify how dpm_list should be adapted.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 24ba5f67b3a3..1d4e2d289821 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -400,6 +400,9 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 
 #else /* !CONFIG_PM_SLEEP */
 
+#define device_pm_lock() do {} while (0)
+#define device_pm_unlock() do {} while (0)
+
 static inline int device_suspend(pm_message_t state)
 {
 	return 0;
@@ -409,6 +412,14 @@ static inline int device_suspend(pm_message_t state)
 
 #endif /* !CONFIG_PM_SLEEP */
 
+/* How to reorder dpm_list after device_move() */
+enum dpm_order {
+	DPM_ORDER_NONE,
+	DPM_ORDER_DEV_AFTER_PARENT,
+	DPM_ORDER_PARENT_BEFORE_DEV,
+	DPM_ORDER_DEV_LAST,
+};
+
 /*
  * Global Power Management flags
  * Used to keep APM and ACPI from both being active

commit 770824bdc421ff58a64db608294323571c949f4c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 22 18:38:50 2009 +0100

    PM: Split up sysdev_[suspend|resume] from device_power_[down|up]
    
    Move the sysdev_suspend/resume from the callee to the callers, with
    no real change in semantics, so that we can rework the disabling of
    interrupts during suspend/hibernation.
    
    This is based on an earlier patch from Linus.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index de2e0a8f6728..24ba5f67b3a3 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -381,10 +381,12 @@ struct dev_pm_info {
 
 #ifdef CONFIG_PM_SLEEP
 extern void device_pm_lock(void);
+extern int sysdev_resume(void);
 extern void device_power_up(pm_message_t state);
 extern void device_resume(pm_message_t state);
 
 extern void device_pm_unlock(void);
+extern int sysdev_suspend(pm_message_t state);
 extern int device_power_down(pm_message_t state);
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);

commit 7f4f5d4516b441d712fa0ffe5380618fb7fc545e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 17 11:14:19 2008 -0500

    Fix misspellings in pm.h macros
    
    This patch (as1167) fixes some misspellings in various recently-added
    macros in pm.h.  Fortunately these macros are not yet used anywhere.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 5785666d0cc4..de2e0a8f6728 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -252,7 +252,7 @@ struct dev_pm_ops {
 #define PM_EVENT_SLEEP		(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
 #define PM_EVENT_USER_SUSPEND	(PM_EVENT_USER | PM_EVENT_SUSPEND)
 #define PM_EVENT_USER_RESUME	(PM_EVENT_USER | PM_EVENT_RESUME)
-#define PM_EVENT_REMOTE_WAKEUP	(PM_EVENT_REMOTE | PM_EVENT_RESUME)
+#define PM_EVENT_REMOTE_RESUME	(PM_EVENT_REMOTE | PM_EVENT_RESUME)
 #define PM_EVENT_AUTO_SUSPEND	(PM_EVENT_AUTO | PM_EVENT_SUSPEND)
 #define PM_EVENT_AUTO_RESUME	(PM_EVENT_AUTO | PM_EVENT_RESUME)
 
@@ -265,15 +265,15 @@ struct dev_pm_ops {
 #define PMSG_THAW	((struct pm_message){ .event = PM_EVENT_THAW, })
 #define PMSG_RESTORE	((struct pm_message){ .event = PM_EVENT_RESTORE, })
 #define PMSG_RECOVER	((struct pm_message){ .event = PM_EVENT_RECOVER, })
-#define PMSG_USER_SUSPEND	((struct pm_messge) \
+#define PMSG_USER_SUSPEND	((struct pm_message) \
 					{ .event = PM_EVENT_USER_SUSPEND, })
-#define PMSG_USER_RESUME	((struct pm_messge) \
+#define PMSG_USER_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_USER_RESUME, })
-#define PMSG_REMOTE_RESUME	((struct pm_messge) \
+#define PMSG_REMOTE_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_REMOTE_RESUME, })
-#define PMSG_AUTO_SUSPEND	((struct pm_messge) \
+#define PMSG_AUTO_SUSPEND	((struct pm_message) \
 					{ .event = PM_EVENT_AUTO_SUSPEND, })
-#define PMSG_AUTO_RESUME		((struct pm_messge) \
+#define PMSG_AUTO_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_AUTO_RESUME, })
 
 /**

commit adf094931ffb25ef4b381559918f1a34181a5273
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 6 22:46:05 2008 +0200

    PM: Simplify the new suspend/hibernation framework for devices
    
    PM: Simplify the new suspend/hibernation framework for devices
    
    Following the discussion at the Kernel Summit, simplify the new
    device PM framework by merging 'struct pm_ops' and
    'struct pm_ext_ops' and removing pointers to 'struct pm_ext_ops'
    from 'struct platform_driver' and 'struct pci_driver'.
    
    After this change, the suspend/hibernation callbacks will only
    reside in 'struct device_driver' as well as at the bus type/
    device class/device type level.  Accordingly, PCI and platform
    device drivers are now expected to put their suspend/hibernation
    callbacks into the 'struct device_driver' embedded in
    'struct pci_driver' or 'struct platform_driver', respectively.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 42de4003c4ee..5785666d0cc4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -41,7 +41,7 @@ typedef struct pm_message {
 } pm_message_t;
 
 /**
- * struct pm_ops - device PM callbacks
+ * struct dev_pm_ops - device PM callbacks
  *
  * Several driver power state transitions are externally visible, affecting
  * the state of pending I/O queues and (for drivers that touch hardware)
@@ -126,46 +126,6 @@ typedef struct pm_message {
  *	On most platforms, there are no restrictions on availability of
  *	resources like clocks during @restore().
  *
- * All of the above callbacks, except for @complete(), return error codes.
- * However, the error codes returned by the resume operations, @resume(),
- * @thaw(), and @restore(), do not cause the PM core to abort the resume
- * transition during which they are returned.  The error codes returned in
- * that cases are only printed by the PM core to the system logs for debugging
- * purposes.  Still, it is recommended that drivers only return error codes
- * from their resume methods in case of an unrecoverable failure (i.e. when the
- * device being handled refuses to resume and becomes unusable) to allow us to
- * modify the PM core in the future, so that it can avoid attempting to handle
- * devices that failed to resume and their children.
- *
- * It is allowed to unregister devices while the above callbacks are being
- * executed.  However, it is not allowed to unregister a device from within any
- * of its own callbacks.
- */
-
-struct pm_ops {
-	int (*prepare)(struct device *dev);
-	void (*complete)(struct device *dev);
-	int (*suspend)(struct device *dev);
-	int (*resume)(struct device *dev);
-	int (*freeze)(struct device *dev);
-	int (*thaw)(struct device *dev);
-	int (*poweroff)(struct device *dev);
-	int (*restore)(struct device *dev);
-};
-
-/**
- * struct pm_ext_ops - extended device PM callbacks
- *
- * Some devices require certain operations related to suspend and hibernation
- * to be carried out with interrupts disabled.  Thus, 'struct pm_ext_ops' below
- * is defined, adding callbacks to be executed with interrupts disabled to
- * 'struct pm_ops'.
- *
- * The following callbacks included in 'struct pm_ext_ops' are executed with
- * the nonboot CPUs switched off and with interrupts disabled on the only
- * functional CPU.  They also are executed with the PM core list of devices
- * locked, so they must NOT unregister any devices.
- *
  * @suspend_noirq: Complete the operations of ->suspend() by carrying out any
  *	actions required for suspending the device that need interrupts to be
  *	disabled
@@ -190,18 +150,32 @@ struct pm_ops {
  *	actions required for restoring the operations of the device that need
  *	interrupts to be disabled
  *
- * All of the above callbacks return error codes, but the error codes returned
- * by the resume operations, @resume_noirq(), @thaw_noirq(), and
- * @restore_noirq(), do not cause the PM core to abort the resume transition
- * during which they are returned.  The error codes returned in that cases are
- * only printed by the PM core to the system logs for debugging purposes.
- * Still, as stated above, it is recommended that drivers only return error
- * codes from their resume methods if the device being handled fails to resume
- * and is not usable any more.
+ * All of the above callbacks, except for @complete(), return error codes.
+ * However, the error codes returned by the resume operations, @resume(),
+ * @thaw(), @restore(), @resume_noirq(), @thaw_noirq(), and @restore_noirq() do
+ * not cause the PM core to abort the resume transition during which they are
+ * returned.  The error codes returned in that cases are only printed by the PM
+ * core to the system logs for debugging purposes.  Still, it is recommended
+ * that drivers only return error codes from their resume methods in case of an
+ * unrecoverable failure (i.e. when the device being handled refuses to resume
+ * and becomes unusable) to allow us to modify the PM core in the future, so
+ * that it can avoid attempting to handle devices that failed to resume and
+ * their children.
+ *
+ * It is allowed to unregister devices while the above callbacks are being
+ * executed.  However, it is not allowed to unregister a device from within any
+ * of its own callbacks.
  */
 
-struct pm_ext_ops {
-	struct pm_ops base;
+struct dev_pm_ops {
+	int (*prepare)(struct device *dev);
+	void (*complete)(struct device *dev);
+	int (*suspend)(struct device *dev);
+	int (*resume)(struct device *dev);
+	int (*freeze)(struct device *dev);
+	int (*thaw)(struct device *dev);
+	int (*poweroff)(struct device *dev);
+	int (*restore)(struct device *dev);
 	int (*suspend_noirq)(struct device *dev);
 	int (*resume_noirq)(struct device *dev);
 	int (*freeze_noirq)(struct device *dev);

commit d5c003b4d1690e666dbab02bc8e705947baa848c
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Oct 15 22:01:24 2008 -0700

    include: replace __FUNCTION__ with __func__
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 4dcce54b6d76..42de4003c4ee 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -419,7 +419,7 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 
 #define suspend_report_result(fn, ret)					\
 	do {								\
-		__suspend_report_result(__FUNCTION__, fn, ret);		\
+		__suspend_report_result(__func__, fn, ret);		\
 	} while (0)
 
 #else /* !CONFIG_PM_SLEEP */

commit 8111d1b552349921aae1acf73e4e8cea98e80970
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Jul 23 21:28:37 2008 -0700

    pm: add new PM_EVENT codes for runtime power transitions
    
    This patch (as1112) adds some new PM_EVENT_* codes for use by kernel
    subsystems.  They describe runtime power-state transitions of the sort already
    implemented by the USB subsystem.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ed98d967f9fb..4dcce54b6d76 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -245,6 +245,21 @@ struct pm_ext_ops {
  * RECOVER	Creation of a hibernation image or restoration of the main
  *		memory contents from a hibernation image has failed, call
  *		->thaw() and ->complete() for all devices.
+ *
+ * The following PM_EVENT_ messages are defined for internal use by
+ * kernel subsystems.  They are never issued by the PM core.
+ *
+ * USER_SUSPEND		Manual selective suspend was issued by userspace.
+ *
+ * USER_RESUME		Manual selective resume was issued by userspace.
+ *
+ * REMOTE_WAKEUP	Remote-wakeup request was received from the device.
+ *
+ * AUTO_SUSPEND		Automatic (device idle) runtime suspend was
+ *			initiated by the subsystem.
+ *
+ * AUTO_RESUME		Automatic (device needed) runtime resume was
+ *			requested by a driver.
  */
 
 #define PM_EVENT_ON		0x0000
@@ -256,9 +271,18 @@ struct pm_ext_ops {
 #define PM_EVENT_THAW		0x0020
 #define PM_EVENT_RESTORE	0x0040
 #define PM_EVENT_RECOVER	0x0080
+#define PM_EVENT_USER		0x0100
+#define PM_EVENT_REMOTE		0x0200
+#define PM_EVENT_AUTO		0x0400
 
-#define PM_EVENT_SLEEP	(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
+#define PM_EVENT_SLEEP		(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
+#define PM_EVENT_USER_SUSPEND	(PM_EVENT_USER | PM_EVENT_SUSPEND)
+#define PM_EVENT_USER_RESUME	(PM_EVENT_USER | PM_EVENT_RESUME)
+#define PM_EVENT_REMOTE_WAKEUP	(PM_EVENT_REMOTE | PM_EVENT_RESUME)
+#define PM_EVENT_AUTO_SUSPEND	(PM_EVENT_AUTO | PM_EVENT_SUSPEND)
+#define PM_EVENT_AUTO_RESUME	(PM_EVENT_AUTO | PM_EVENT_RESUME)
 
+#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
 #define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
 #define PMSG_QUIESCE	((struct pm_message){ .event = PM_EVENT_QUIESCE, })
 #define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
@@ -267,7 +291,16 @@ struct pm_ext_ops {
 #define PMSG_THAW	((struct pm_message){ .event = PM_EVENT_THAW, })
 #define PMSG_RESTORE	((struct pm_message){ .event = PM_EVENT_RESTORE, })
 #define PMSG_RECOVER	((struct pm_message){ .event = PM_EVENT_RECOVER, })
-#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
+#define PMSG_USER_SUSPEND	((struct pm_messge) \
+					{ .event = PM_EVENT_USER_SUSPEND, })
+#define PMSG_USER_RESUME	((struct pm_messge) \
+					{ .event = PM_EVENT_USER_RESUME, })
+#define PMSG_REMOTE_RESUME	((struct pm_messge) \
+					{ .event = PM_EVENT_REMOTE_RESUME, })
+#define PMSG_AUTO_SUSPEND	((struct pm_messge) \
+					{ .event = PM_EVENT_AUTO_SUSPEND, })
+#define PMSG_AUTO_RESUME		((struct pm_messge) \
+					{ .event = PM_EVENT_AUTO_RESUME, })
 
 /**
  * Device power management states

commit 8c363265d57d755e62053e9f69a1f2164e83f7ea
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 23 21:28:37 2008 -0700

    pm: drop unnecessary includes from pm.h
    
    Drop unnecessary includes from include/linux/pm.h .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 390dd95a375e..ed98d967f9fb 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -22,8 +22,6 @@
 #define _LINUX_PM_H
 
 #include <linux/list.h>
-#include <asm/atomic.h>
-#include <asm/errno.h>
 
 /*
  * Callbacks for platform drivers to implement.

commit e7ecb331e11d1f7aa66aeef9170fc20781c9bb55
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 23 21:28:35 2008 -0700

    pm: remove remaining obsolete definitions from pm.h
    
    Remove the remaining obsolete definitions from include/linux/pm.h and move
    the definitions of PM_SUSPEND and PM_RESUME to the header of h3600 which
    is the only user of them.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 5bf1ce89cfbb..390dd95a375e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -25,52 +25,6 @@
 #include <asm/atomic.h>
 #include <asm/errno.h>
 
-/*
- * Power management requests... these are passed to pm_send_all() and friends.
- *
- * these functions are old and deprecated, see below.
- */
-typedef int __bitwise pm_request_t;
-
-#define PM_SUSPEND	((__force pm_request_t) 1)	/* enter D1-D3 */
-#define PM_RESUME	((__force pm_request_t) 2)	/* enter D0 */
-
-
-/*
- * Device types... these are passed to pm_register
- */
-typedef int __bitwise pm_dev_t;
-
-#define PM_UNKNOWN_DEV	((__force pm_dev_t) 0)	/* generic */
-#define PM_SYS_DEV	((__force pm_dev_t) 1)	/* system device (fan, KB controller, ...) */
-#define PM_PCI_DEV	((__force pm_dev_t) 2)	/* PCI device */
-#define PM_USB_DEV	((__force pm_dev_t) 3)	/* USB device */
-#define PM_SCSI_DEV	((__force pm_dev_t) 4)	/* SCSI device */
-#define PM_ISA_DEV	((__force pm_dev_t) 5)	/* ISA device */
-#define	PM_MTD_DEV	((__force pm_dev_t) 6)	/* Memory Technology Device */
-
-/*
- * System device hardware ID (PnP) values
- */
-enum
-{
-	PM_SYS_UNKNOWN = 0x00000000, /* generic */
-	PM_SYS_KBC =	 0x41d00303, /* keyboard controller */
-	PM_SYS_COM =	 0x41d00500, /* serial port */
-	PM_SYS_IRDA =	 0x41d00510, /* IRDA controller */
-	PM_SYS_FDC =	 0x41d00700, /* floppy controller */
-	PM_SYS_VGA =	 0x41d00900, /* VGA controller */
-	PM_SYS_PCMCIA =	 0x41d00e00, /* PCMCIA controller */
-};
-
-/*
- * Device identifier
- */
-#define PM_PCI_ID(dev) ((dev)->bus->number << 16 | (dev)->devfn)
-
-/* Functions above this comment are list-based old-style power
- * management. Please avoid using them.  */
-
 /*
  * Callbacks for platform drivers to implement.
  */

commit 558481f038e587b22d02167af58914c814ce9de5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 23 21:28:35 2008 -0700

    pm: remove definition of struct pm_dev
    
    Remove the definition of 'struct pm_dev', which is not used any more,
    along with some related stuff from include/linux/pm.h .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 4ad9de94449a..5bf1ce89cfbb 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -68,30 +68,6 @@ enum
  */
 #define PM_PCI_ID(dev) ((dev)->bus->number << 16 | (dev)->devfn)
 
-/*
- * Request handler callback
- */
-struct pm_dev;
-
-typedef int (*pm_callback)(struct pm_dev *dev, pm_request_t rqst, void *data);
-
-/*
- * Dynamic device information
- */
-struct pm_dev
-{
-	pm_dev_t	 type;
-	unsigned long	 id;
-	pm_callback	 callback;
-	void		*data;
-
-	unsigned long	 flags;
-	unsigned long	 state;
-	unsigned long	 prev_state;
-
-	struct list_head entry;
-};
-
 /* Functions above this comment are list-based old-style power
  * management. Please avoid using them.  */
 

commit 1eede070a59e1cc73da51e1aaa00d9ab86572cfc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue May 20 23:00:01 2008 +0200

    Introduce new top level suspend and hibernation callbacks
    
    Introduce 'struct pm_ops' and 'struct pm_ext_ops' ('ext' meaning
    'extended') representing suspend and hibernation operations for bus
    types, device classes, device types and device drivers.
    
    Modify the PM core to use 'struct pm_ops' and 'struct pm_ext_ops'
    objects, if defined, instead of the ->suspend(), ->resume(),
    ->suspend_late(), and ->resume_early() callbacks (the old callbacks
    will be considered as legacy and gradually phased out).
    
    The main purpose of doing this is to separate suspend (aka S2RAM and
    standby) callbacks from hibernation callbacks in such a way that the
    new callbacks won't take arguments and the semantics of each of them
    will be clearly specified.  This has been requested for multiple
    times by many people, including Linus himself, and the reason is that
    within the current scheme if ->resume() is called, for example, it's
    difficult to say why it's been called (ie. is it a resume from RAM or
    from hibernation or a suspend/hibernation failure etc.?).
    
    The second purpose is to make the suspend/hibernation callbacks more
    flexible so that device drivers can handle more than they can within
    the current scheme.  For example, some drivers may need to prevent
    new children of the device from being registered before their
    ->suspend() callbacks are executed or they may want to carry out some
    operations requiring the availability of some other devices, not
    directly bound via the parent-child relationship, in order to prepare
    for the execution of ->suspend(), etc.
    
    Ultimately, we'd like to stop using the freezing of tasks for suspend
    and therefore the drivers' suspend/hibernation code will have to take
    care of the handling of the user space during suspend/hibernation.
    That, in turn, would be difficult within the current scheme, without
    the new ->prepare() and ->complete() callbacks.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 39a7ee859b67..4ad9de94449a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -112,7 +112,9 @@ typedef struct pm_message {
 	int event;
 } pm_message_t;
 
-/*
+/**
+ * struct pm_ops - device PM callbacks
+ *
  * Several driver power state transitions are externally visible, affecting
  * the state of pending I/O queues and (for drivers that touch hardware)
  * interrupts, wakeups, DMA, and other hardware state.  There may also be
@@ -120,6 +122,284 @@ typedef struct pm_message {
  * to the rest of the driver stack (such as a driver that's ON gating off
  * clocks which are not in active use).
  *
+ * The externally visible transitions are handled with the help of the following
+ * callbacks included in this structure:
+ *
+ * @prepare: Prepare the device for the upcoming transition, but do NOT change
+ *	its hardware state.  Prevent new children of the device from being
+ *	registered after @prepare() returns (the driver's subsystem and
+ *	generally the rest of the kernel is supposed to prevent new calls to the
+ *	probe method from being made too once @prepare() has succeeded).  If
+ *	@prepare() detects a situation it cannot handle (e.g. registration of a
+ *	child already in progress), it may return -EAGAIN, so that the PM core
+ *	can execute it once again (e.g. after the new child has been registered)
+ *	to recover from the race condition.  This method is executed for all
+ *	kinds of suspend transitions and is followed by one of the suspend
+ *	callbacks: @suspend(), @freeze(), or @poweroff().
+ *	The PM core executes @prepare() for all devices before starting to
+ *	execute suspend callbacks for any of them, so drivers may assume all of
+ *	the other devices to be present and functional while @prepare() is being
+ *	executed.  In particular, it is safe to make GFP_KERNEL memory
+ *	allocations from within @prepare().  However, drivers may NOT assume
+ *	anything about the availability of the user space at that time and it
+ *	is not correct to request firmware from within @prepare() (it's too
+ *	late to do that).  [To work around this limitation, drivers may
+ *	register suspend and hibernation notifiers that are executed before the
+ *	freezing of tasks.]
+ *
+ * @complete: Undo the changes made by @prepare().  This method is executed for
+ *	all kinds of resume transitions, following one of the resume callbacks:
+ *	@resume(), @thaw(), @restore().  Also called if the state transition
+ *	fails before the driver's suspend callback (@suspend(), @freeze(),
+ *	@poweroff()) can be executed (e.g. if the suspend callback fails for one
+ *	of the other devices that the PM core has unsuccessfully attempted to
+ *	suspend earlier).
+ *	The PM core executes @complete() after it has executed the appropriate
+ *	resume callback for all devices.
+ *
+ * @suspend: Executed before putting the system into a sleep state in which the
+ *	contents of main memory are preserved.  Quiesce the device, put it into
+ *	a low power state appropriate for the upcoming system state (such as
+ *	PCI_D3hot), and enable wakeup events as appropriate.
+ *
+ * @resume: Executed after waking the system up from a sleep state in which the
+ *	contents of main memory were preserved.  Put the device into the
+ *	appropriate state, according to the information saved in memory by the
+ *	preceding @suspend().  The driver starts working again, responding to
+ *	hardware events and software requests.  The hardware may have gone
+ *	through a power-off reset, or it may have maintained state from the
+ *	previous suspend() which the driver may rely on while resuming.  On most
+ *	platforms, there are no restrictions on availability of resources like
+ *	clocks during @resume().
+ *
+ * @freeze: Hibernation-specific, executed before creating a hibernation image.
+ *	Quiesce operations so that a consistent image can be created, but do NOT
+ *	otherwise put the device into a low power device state and do NOT emit
+ *	system wakeup events.  Save in main memory the device settings to be
+ *	used by @restore() during the subsequent resume from hibernation or by
+ *	the subsequent @thaw(), if the creation of the image or the restoration
+ *	of main memory contents from it fails.
+ *
+ * @thaw: Hibernation-specific, executed after creating a hibernation image OR
+ *	if the creation of the image fails.  Also executed after a failing
+ *	attempt to restore the contents of main memory from such an image.
+ *	Undo the changes made by the preceding @freeze(), so the device can be
+ *	operated in the same way as immediately before the call to @freeze().
+ *
+ * @poweroff: Hibernation-specific, executed after saving a hibernation image.
+ *	Quiesce the device, put it into a low power state appropriate for the
+ *	upcoming system state (such as PCI_D3hot), and enable wakeup events as
+ *	appropriate.
+ *
+ * @restore: Hibernation-specific, executed after restoring the contents of main
+ *	memory from a hibernation image.  Driver starts working again,
+ *	responding to hardware events and software requests.  Drivers may NOT
+ *	make ANY assumptions about the hardware state right prior to @restore().
+ *	On most platforms, there are no restrictions on availability of
+ *	resources like clocks during @restore().
+ *
+ * All of the above callbacks, except for @complete(), return error codes.
+ * However, the error codes returned by the resume operations, @resume(),
+ * @thaw(), and @restore(), do not cause the PM core to abort the resume
+ * transition during which they are returned.  The error codes returned in
+ * that cases are only printed by the PM core to the system logs for debugging
+ * purposes.  Still, it is recommended that drivers only return error codes
+ * from their resume methods in case of an unrecoverable failure (i.e. when the
+ * device being handled refuses to resume and becomes unusable) to allow us to
+ * modify the PM core in the future, so that it can avoid attempting to handle
+ * devices that failed to resume and their children.
+ *
+ * It is allowed to unregister devices while the above callbacks are being
+ * executed.  However, it is not allowed to unregister a device from within any
+ * of its own callbacks.
+ */
+
+struct pm_ops {
+	int (*prepare)(struct device *dev);
+	void (*complete)(struct device *dev);
+	int (*suspend)(struct device *dev);
+	int (*resume)(struct device *dev);
+	int (*freeze)(struct device *dev);
+	int (*thaw)(struct device *dev);
+	int (*poweroff)(struct device *dev);
+	int (*restore)(struct device *dev);
+};
+
+/**
+ * struct pm_ext_ops - extended device PM callbacks
+ *
+ * Some devices require certain operations related to suspend and hibernation
+ * to be carried out with interrupts disabled.  Thus, 'struct pm_ext_ops' below
+ * is defined, adding callbacks to be executed with interrupts disabled to
+ * 'struct pm_ops'.
+ *
+ * The following callbacks included in 'struct pm_ext_ops' are executed with
+ * the nonboot CPUs switched off and with interrupts disabled on the only
+ * functional CPU.  They also are executed with the PM core list of devices
+ * locked, so they must NOT unregister any devices.
+ *
+ * @suspend_noirq: Complete the operations of ->suspend() by carrying out any
+ *	actions required for suspending the device that need interrupts to be
+ *	disabled
+ *
+ * @resume_noirq: Prepare for the execution of ->resume() by carrying out any
+ *	actions required for resuming the device that need interrupts to be
+ *	disabled
+ *
+ * @freeze_noirq: Complete the operations of ->freeze() by carrying out any
+ *	actions required for freezing the device that need interrupts to be
+ *	disabled
+ *
+ * @thaw_noirq: Prepare for the execution of ->thaw() by carrying out any
+ *	actions required for thawing the device that need interrupts to be
+ *	disabled
+ *
+ * @poweroff_noirq: Complete the operations of ->poweroff() by carrying out any
+ *	actions required for handling the device that need interrupts to be
+ *	disabled
+ *
+ * @restore_noirq: Prepare for the execution of ->restore() by carrying out any
+ *	actions required for restoring the operations of the device that need
+ *	interrupts to be disabled
+ *
+ * All of the above callbacks return error codes, but the error codes returned
+ * by the resume operations, @resume_noirq(), @thaw_noirq(), and
+ * @restore_noirq(), do not cause the PM core to abort the resume transition
+ * during which they are returned.  The error codes returned in that cases are
+ * only printed by the PM core to the system logs for debugging purposes.
+ * Still, as stated above, it is recommended that drivers only return error
+ * codes from their resume methods if the device being handled fails to resume
+ * and is not usable any more.
+ */
+
+struct pm_ext_ops {
+	struct pm_ops base;
+	int (*suspend_noirq)(struct device *dev);
+	int (*resume_noirq)(struct device *dev);
+	int (*freeze_noirq)(struct device *dev);
+	int (*thaw_noirq)(struct device *dev);
+	int (*poweroff_noirq)(struct device *dev);
+	int (*restore_noirq)(struct device *dev);
+};
+
+/**
+ * PM_EVENT_ messages
+ *
+ * The following PM_EVENT_ messages are defined for the internal use of the PM
+ * core, in order to provide a mechanism allowing the high level suspend and
+ * hibernation code to convey the necessary information to the device PM core
+ * code:
+ *
+ * ON		No transition.
+ *
+ * FREEZE 	System is going to hibernate, call ->prepare() and ->freeze()
+ *		for all devices.
+ *
+ * SUSPEND	System is going to suspend, call ->prepare() and ->suspend()
+ *		for all devices.
+ *
+ * HIBERNATE	Hibernation image has been saved, call ->prepare() and
+ *		->poweroff() for all devices.
+ *
+ * QUIESCE	Contents of main memory are going to be restored from a (loaded)
+ *		hibernation image, call ->prepare() and ->freeze() for all
+ *		devices.
+ *
+ * RESUME	System is resuming, call ->resume() and ->complete() for all
+ *		devices.
+ *
+ * THAW		Hibernation image has been created, call ->thaw() and
+ *		->complete() for all devices.
+ *
+ * RESTORE	Contents of main memory have been restored from a hibernation
+ *		image, call ->restore() and ->complete() for all devices.
+ *
+ * RECOVER	Creation of a hibernation image or restoration of the main
+ *		memory contents from a hibernation image has failed, call
+ *		->thaw() and ->complete() for all devices.
+ */
+
+#define PM_EVENT_ON		0x0000
+#define PM_EVENT_FREEZE 	0x0001
+#define PM_EVENT_SUSPEND	0x0002
+#define PM_EVENT_HIBERNATE	0x0004
+#define PM_EVENT_QUIESCE	0x0008
+#define PM_EVENT_RESUME		0x0010
+#define PM_EVENT_THAW		0x0020
+#define PM_EVENT_RESTORE	0x0040
+#define PM_EVENT_RECOVER	0x0080
+
+#define PM_EVENT_SLEEP	(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
+
+#define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
+#define PMSG_QUIESCE	((struct pm_message){ .event = PM_EVENT_QUIESCE, })
+#define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
+#define PMSG_HIBERNATE	((struct pm_message){ .event = PM_EVENT_HIBERNATE, })
+#define PMSG_RESUME	((struct pm_message){ .event = PM_EVENT_RESUME, })
+#define PMSG_THAW	((struct pm_message){ .event = PM_EVENT_THAW, })
+#define PMSG_RESTORE	((struct pm_message){ .event = PM_EVENT_RESTORE, })
+#define PMSG_RECOVER	((struct pm_message){ .event = PM_EVENT_RECOVER, })
+#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
+
+/**
+ * Device power management states
+ *
+ * These state labels are used internally by the PM core to indicate the current
+ * status of a device with respect to the PM core operations.
+ *
+ * DPM_ON		Device is regarded as operational.  Set this way
+ *			initially and when ->complete() is about to be called.
+ *			Also set when ->prepare() fails.
+ *
+ * DPM_PREPARING	Device is going to be prepared for a PM transition.  Set
+ *			when ->prepare() is about to be called.
+ *
+ * DPM_RESUMING		Device is going to be resumed.  Set when ->resume(),
+ *			->thaw(), or ->restore() is about to be called.
+ *
+ * DPM_SUSPENDING	Device has been prepared for a power transition.  Set
+ *			when ->prepare() has just succeeded.
+ *
+ * DPM_OFF		Device is regarded as inactive.  Set immediately after
+ *			->suspend(), ->freeze(), or ->poweroff() has succeeded.
+ *			Also set when ->resume()_noirq, ->thaw_noirq(), or
+ *			->restore_noirq() is about to be called.
+ *
+ * DPM_OFF_IRQ		Device is in a "deep sleep".  Set immediately after
+ *			->suspend_noirq(), ->freeze_noirq(), or
+ *			->poweroff_noirq() has just succeeded.
+ */
+
+enum dpm_state {
+	DPM_INVALID,
+	DPM_ON,
+	DPM_PREPARING,
+	DPM_RESUMING,
+	DPM_SUSPENDING,
+	DPM_OFF,
+	DPM_OFF_IRQ,
+};
+
+struct dev_pm_info {
+	pm_message_t		power_state;
+	unsigned		can_wakeup:1;
+	unsigned		should_wakeup:1;
+	enum dpm_state		status;		/* Owned by the PM core */
+#ifdef	CONFIG_PM_SLEEP
+	struct list_head	entry;
+#endif
+};
+
+/*
+ * The PM_EVENT_ messages are also used by drivers implementing the legacy
+ * suspend framework, based on the ->suspend() and ->resume() callbacks common
+ * for suspend and hibernation transitions, according to the rules below.
+ */
+
+/* Necessary, because several drivers use PM_EVENT_PRETHAW */
+#define PM_EVENT_PRETHAW PM_EVENT_QUIESCE
+
+/*
  * One transition is triggered by resume(), after a suspend() call; the
  * message is implicit:
  *
@@ -164,35 +444,13 @@ typedef struct pm_message {
  * or from system low-power states such as standby or suspend-to-RAM.
  */
 
-#define PM_EVENT_ON 0
-#define PM_EVENT_FREEZE 1
-#define PM_EVENT_SUSPEND 2
-#define PM_EVENT_HIBERNATE 4
-#define PM_EVENT_PRETHAW 8
-
-#define PM_EVENT_SLEEP	(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
-
-#define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
-#define PMSG_PRETHAW	((struct pm_message){ .event = PM_EVENT_PRETHAW, })
-#define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
-#define PMSG_HIBERNATE	((struct pm_message){ .event = PM_EVENT_HIBERNATE, })
-#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
-
-struct dev_pm_info {
-	pm_message_t		power_state;
-	unsigned		can_wakeup:1;
-	unsigned		should_wakeup:1;
-	bool			sleeping:1;	/* Owned by the PM core */
-#ifdef	CONFIG_PM_SLEEP
-	struct list_head	entry;
-#endif
-};
+#ifdef CONFIG_PM_SLEEP
+extern void device_pm_lock(void);
+extern void device_power_up(pm_message_t state);
+extern void device_resume(pm_message_t state);
 
+extern void device_pm_unlock(void);
 extern int device_power_down(pm_message_t state);
-extern void device_power_up(void);
-extern void device_resume(void);
-
-#ifdef CONFIG_PM_SLEEP
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);
 

commit 735643ee6cc5249bfac07fcad0946a5e7aff4423
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Wed Apr 30 00:55:12 2008 -0700

    Remove "#ifdef __KERNEL__" checks from unexported headers
    
    Remove the "#ifdef __KERNEL__" tests from unexported header files in
    linux/include whose entire contents are wrapped in that preprocessor
    test.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 1de72cbbe0d1..39a7ee859b67 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -21,8 +21,6 @@
 #ifndef _LINUX_PM_H
 #define _LINUX_PM_H
 
-#ifdef __KERNEL__
-
 #include <linux/list.h>
 #include <asm/atomic.h>
 #include <asm/errno.h>
@@ -225,6 +223,4 @@ extern unsigned int	pm_flags;
 #define PM_APM	1
 #define PM_ACPI	2
 
-#endif /* __KERNEL__ */
-
 #endif /* _LINUX_PM_H */

commit 9a3df1f7de0ecaf77a1dde86f2a4dc020f37f87e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 19 22:39:13 2008 +0100

    PM: Convert wakeup flag accessors to inline functions
    
    This patch (as1058) improves the wakeup macros in include/linux/pm.h.
    All but the trivial ones are converted to inline routines, which
    requires moving them to a separate header file since they depend on
    the definition of struct device.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3342627e2bd6..1de72cbbe0d1 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -212,54 +212,10 @@ static inline int device_suspend(pm_message_t state)
 	return 0;
 }
 
-#define suspend_report_result(fn, ret) do { } while (0)
+#define suspend_report_result(fn, ret)		do {} while (0)
 
 #endif /* !CONFIG_PM_SLEEP */
 
-#ifdef CONFIG_PM
-
-#define device_set_wakeup_enable(dev,val) \
-	((dev)->power.should_wakeup = !!(val))
-#define device_may_wakeup(dev) \
-	(device_can_wakeup(dev) && (dev)->power.should_wakeup)
-
-/*
- * Platform hook to activate device wakeup capability, if that's not already
- * handled by enable_irq_wake() etc.
- * Returns zero on success, else negative errno
- */
-extern int (*platform_enable_wakeup)(struct device *dev, int is_on);
-
-static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
-{
-	if (platform_enable_wakeup)
-		return (*platform_enable_wakeup)(dev, is_on);
-	return 0;
-}
-
-#else /* !CONFIG_PM */
-
-#define device_set_wakeup_enable(dev,val)	do{}while(0)
-#define device_may_wakeup(dev)			(0)
-
-static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
-{
-	return 0;
-}
-
-#endif /* !CONFIG_PM */
-
-/* changes to device_may_wakeup take effect on the next pm state change.
- * by default, devices should wakeup if they can.
- */
-#define device_can_wakeup(dev) \
-	((dev)->power.can_wakeup)
-#define device_init_wakeup(dev,val) \
-	do { \
-		device_can_wakeup(dev) = !!(val); \
-		device_set_wakeup_enable(dev,val); \
-	} while(0)
-
 /*
  * Global Power Management flags
  * Used to keep APM and ACPI from both being active

commit d288e47c471e1090e80c62ad95882fafbf3f499d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 19 22:37:42 2008 +0100

    PM: Make wakeup flags available whenever CONFIG_PM is set
    
    The various wakeup flags and their accessor macros in struct
    dev_pm_info should be available whenever CONFIG_PM is enabled, not
    just when CONFIG_PM_SLEEP is on.  Otherwise remote wakeup won't always
    be configurable for runtime power management.  This patch (as1056b)
    fixes the oversight.
    
    David Brownell adds:
            More accurately, fixes the "regression" ... as noted sometime
            last summer, after 296699de6bdc717189a331ab6bbe90e05c94db06
            introduced CONFIG_SUSPEND.  But that didn't make the regression
            list for that kernel, ergo the delay in fixing it.
    
    [rjw: rebased]
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e6b9f29e27d7..3342627e2bd6 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -183,9 +183,9 @@ typedef struct pm_message {
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned		can_wakeup:1;
+	unsigned		should_wakeup:1;
 	bool			sleeping:1;	/* Owned by the PM core */
 #ifdef	CONFIG_PM_SLEEP
-	unsigned		should_wakeup:1;
 	struct list_head	entry;
 #endif
 };
@@ -198,11 +198,6 @@ extern void device_resume(void);
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);
 
-#define device_set_wakeup_enable(dev,val) \
-	((dev)->power.should_wakeup = !!(val))
-#define device_may_wakeup(dev) \
-	(device_can_wakeup(dev) && (dev)->power.should_wakeup)
-
 extern void __suspend_report_result(const char *function, void *fn, int ret);
 
 #define suspend_report_result(fn, ret)					\
@@ -210,6 +205,24 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 		__suspend_report_result(__FUNCTION__, fn, ret);		\
 	} while (0)
 
+#else /* !CONFIG_PM_SLEEP */
+
+static inline int device_suspend(pm_message_t state)
+{
+	return 0;
+}
+
+#define suspend_report_result(fn, ret) do { } while (0)
+
+#endif /* !CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM
+
+#define device_set_wakeup_enable(dev,val) \
+	((dev)->power.should_wakeup = !!(val))
+#define device_may_wakeup(dev) \
+	(device_can_wakeup(dev) && (dev)->power.should_wakeup)
+
 /*
  * Platform hook to activate device wakeup capability, if that's not already
  * handled by enable_irq_wake() etc.
@@ -224,24 +237,17 @@ static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 	return 0;
 }
 
-#else /* !CONFIG_PM_SLEEP */
-
-static inline int device_suspend(pm_message_t state)
-{
-	return 0;
-}
+#else /* !CONFIG_PM */
 
 #define device_set_wakeup_enable(dev,val)	do{}while(0)
 #define device_may_wakeup(dev)			(0)
 
-#define suspend_report_result(fn, ret) do { } while (0)
-
 static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 {
 	return 0;
 }
 
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* !CONFIG_PM */
 
 /* changes to device_may_wakeup take effect on the next pm state change.
  * by default, devices should wakeup if they can.

commit 58aca23226a19983571bd3b65167521fc64f5869
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Mar 12 00:57:22 2008 +0100

    PM: Handle device registrations during suspend/resume
    
    Modify the PM core to protect its data structures, specifically the
    dpm_active list, from being corrupted if a child of the currently
    suspending device is registered concurrently with its ->suspend()
    callback.  In that case, since the new device (the child) is added
    to dpm_active after its parent, the PM core will attempt to
    suspend it after the parent, which is wrong.
    
    Introduce a new member of struct dev_pm_info, called 'sleeping',
    and use it to check if the parent of the device being added to
    dpm_active has been suspended, in which case the device registration
    fails.  Also, use 'sleeping' for checking if the ordering of devices
    on dpm_active is correct.
    
    Introduce variable 'all_sleeping' that will be set to 'true' once all
    devices have been suspended and make new device registrations fail
    until 'all_sleeping' is reset to 'false', in order to avoid having
    unsuspended devices around while the system is going into a sleep state.
    
    Remove pm_sleep_rwsem which is not necessary any more.
    
    Special thanks to Alan Stern for discussions and suggestions that
    lead to the creation of this patch.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 015b735811b4..e6b9f29e27d7 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -183,6 +183,7 @@ typedef struct pm_message {
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned		can_wakeup:1;
+	bool			sleeping:1;	/* Owned by the PM core */
 #ifdef	CONFIG_PM_SLEEP
 	unsigned		should_wakeup:1;
 	struct list_head	entry;

commit 3a2d5b700132f35401f1d9e22fe3c2cab02c2549
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 23 19:13:25 2008 +0100

    PM: Introduce PM_EVENT_HIBERNATE callback state
    
    During the last step of hibernation in the "platform" mode (with the
    help of ACPI) we use the suspend code, including the devices'
    ->suspend() methods, to prepare the system for entering the ACPI S4
    system sleep state.
    
    But at least for some devices the operations performed by the
    ->suspend() callback in that case must be different from its operations
    during regular suspend.
    
    For this reason, introduce the new PM event type PM_EVENT_HIBERNATE and
    pass it to the device drivers' ->suspend() methods during the last phase
    of hibernation, so that they can distinguish this case and handle it as
    appropriate.  Modify the drivers that handle PM_EVENT_SUSPEND in a
    special way and need to handle PM_EVENT_HIBERNATE in the same way.
    
    These changes are necessary to fix a hibernation regression related
    to the i915 driver (ref. http://lkml.org/lkml/2008/2/22/488).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Jeff Chua <jeff.chua.linux@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index eccf59ea2a77..015b735811b4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -143,6 +143,9 @@ typedef struct pm_message {
  * 		the upcoming system state (such as PCI_D3hot), and enable
  * 		wakeup events as appropriate.
  *
+ * HIBERNATE	Enter a low power device state appropriate for the hibernation
+ * 		state (eg. ACPI S4) and enable wakeup events as appropriate.
+ *
  * FREEZE	Quiesce operations so that a consistent image can be saved;
  * 		but do NOT otherwise enter a low power device state, and do
  * 		NOT emit system wakeup events.
@@ -166,11 +169,15 @@ typedef struct pm_message {
 #define PM_EVENT_ON 0
 #define PM_EVENT_FREEZE 1
 #define PM_EVENT_SUSPEND 2
-#define PM_EVENT_PRETHAW 3
+#define PM_EVENT_HIBERNATE 4
+#define PM_EVENT_PRETHAW 8
+
+#define PM_EVENT_SLEEP	(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
 
 #define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
 #define PMSG_PRETHAW	((struct pm_message){ .event = PM_EVENT_PRETHAW, })
 #define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
+#define PMSG_HIBERNATE	((struct pm_message){ .event = PM_EVENT_HIBERNATE, })
 #define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
 
 struct dev_pm_info {

commit fd3f8984f6fa1ad1a6c2283eef48ba6e5242bcc5
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 17:45:46 2008 +0200

    include/linux/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b78e0295adf4..eccf59ea2a77 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -95,7 +95,7 @@ struct pm_dev
 };
 
 /* Functions above this comment are list-based old-style power
- * managment. Please avoid using them.  */
+ * management. Please avoid using them.  */
 
 /*
  * Callbacks for platform drivers to implement.

commit 9f9adecd2d0e4f88fa0e8cb06c6ec207748df70a
Author: Len Brown <len.brown@intel.com>
Date:   Thu Dec 13 17:38:03 2007 -0500

    PM: ACPI and APM must not be enabled at the same time
    
    ACPI and APM used "pm_active" to guarantee that
    they would not be simultaneously active.
    
    But pm_active was recently moved under CONFIG_PM_LEGACY,
    so that without CONFIG_PM_LEGACY, pm_active became a NOP --
    allowing ACPI and APM to both be simultaneously enabled.
    This caused unpredictable results, including boot hangs.
    
    Further, the code under CONFIG_PM_LEGACY is scheduled
    for removal.
    
    So replace pm_active with pm_flags.
    pm_flags depends only on CONFIG_PM,
    which is present for both CONFIG_APM and CONFIG_ACPI.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=9194
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 09a309b7b5d2..b78e0295adf4 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -246,6 +246,15 @@ static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 		device_set_wakeup_enable(dev,val); \
 	} while(0)
 
+/*
+ * Global Power Management flags
+ * Used to keep APM and ACPI from both being active
+ */
+extern unsigned int	pm_flags;
+
+#define PM_APM	1
+#define PM_ACPI	2
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_PM_H */

commit 95d9ffbe01fb21d524c86bf77871255066bc6e55
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Oct 18 03:04:39 2007 -0700

    PM: Move definition of struct pm_ops to suspend.h
    
    Move the definition of 'struct pm_ops' and related functions from <linux/pm.h>
    to <linux/suspend.h> .
    
    There are, at least, the following reasons to do that:
    * 'struct pm_ops' is specifically related to suspend and not to the power
      management in general.
    * As long as 'struct pm_ops' is defined in <linux/pm.h>, any modification of it
      causes the entire kernel to be recompiled, which is unnecessary and annoying.
    * Some suspend-related features are already defined in <linux/suspend.h>, so it
      is logical to move the definition of 'struct pm_ops' into there.
    * 'struct hibernation_ops', being the hibernation-related counterpart of
      'struct pm_ops', is defined in <linux/suspend.h> .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 48b71badfb4c..09a309b7b5d2 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -104,104 +104,6 @@ extern void (*pm_idle)(void);
 extern void (*pm_power_off)(void);
 extern void (*pm_power_off_prepare)(void);
 
-typedef int __bitwise suspend_state_t;
-
-#define PM_SUSPEND_ON		((__force suspend_state_t) 0)
-#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)
-#define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
-#define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
-
-/**
- * struct pm_ops - Callbacks for managing platform dependent system sleep
- *	states.
- *
- * @valid: Callback to determine if given system sleep state is supported by
- *	the platform.
- *	Valid (ie. supported) states are advertised in /sys/power/state.  Note
- *	that it still may be impossible to enter given system sleep state if the
- *	conditions aren't right.
- *	There is the %pm_valid_only_mem function available that can be assigned
- *	to this if the platform only supports mem sleep.
- *
- * @set_target: Tell the platform which system sleep state is going to be
- *	entered.
- *	@set_target() is executed right prior to suspending devices.  The
- *	information conveyed to the platform code by @set_target() should be
- *	disregarded by the platform as soon as @finish() is executed and if
- *	@prepare() fails.  If @set_target() fails (ie. returns nonzero),
- *	@prepare(), @enter() and @finish() will not be called by the PM core.
- *	This callback is optional.  However, if it is implemented, the argument
- *	passed to @prepare(), @enter() and @finish() is meaningless and should
- *	be ignored.
- *
- * @prepare: Prepare the platform for entering the system sleep state indicated
- *	by @set_target() or represented by the argument if @set_target() is not
- *	implemented.
- *	@prepare() is called right after devices have been suspended (ie. the
- *	appropriate .suspend() method has been executed for each device) and
- *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
- *	This callback is optional.  It returns 0 on success or a negative
- *	error code otherwise, in which case the system cannot enter the desired
- *	sleep state (@enter() and @finish() will not be called in that case).
- *
- * @enter: Enter the system sleep state indicated by @set_target() or
- *	represented by the argument if @set_target() is not implemented.
- *	This callback is mandatory.  It returns 0 on success or a negative
- *	error code otherwise, in which case the system cannot enter the desired
- *	sleep state.
- *
- * @finish: Called when the system has just left a sleep state, right after
- *	the nonboot CPUs have been enabled and before devices are resumed (it is
- *	executed with IRQs enabled).  If @set_target() is not implemented, the
- *	argument represents the sleep state being left.
- *	This callback is optional, but should be implemented by the platforms
- *	that implement @prepare().  If implemented, it is always called after
- *	@enter() (even if @enter() fails).
- */
-struct pm_ops {
-	int (*valid)(suspend_state_t state);
-	int (*set_target)(suspend_state_t state);
-	int (*prepare)(suspend_state_t state);
-	int (*enter)(suspend_state_t state);
-	int (*finish)(suspend_state_t state);
-};
-
-#ifdef CONFIG_SUSPEND
-extern struct pm_ops *pm_ops;
-
-/**
- * pm_set_ops - set platform dependent power management ops
- * @pm_ops: The new power management operations to set.
- */
-extern void pm_set_ops(struct pm_ops *pm_ops);
-extern int pm_valid_only_mem(suspend_state_t state);
-
-/**
- * arch_suspend_disable_irqs - disable IRQs for suspend
- *
- * Disables IRQs (in the default case). This is a weak symbol in the common
- * code and thus allows architectures to override it if more needs to be
- * done. Not called for suspend to disk.
- */
-extern void arch_suspend_disable_irqs(void);
-
-/**
- * arch_suspend_enable_irqs - enable IRQs after suspend
- *
- * Enables IRQs (in the default case). This is a weak symbol in the common
- * code and thus allows architectures to override it if more needs to be
- * done. Not called for suspend to disk.
- */
-extern void arch_suspend_enable_irqs(void);
-
-extern int pm_suspend(suspend_state_t state);
-#else /* !CONFIG_SUSPEND */
-#define suspend_valid_only_mem	NULL
-
-static inline void pm_set_ops(struct pm_ops *pm_ops) {}
-static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
-#endif /* !CONFIG_SUSPEND */
-
 /*
  * Device power management
  */

commit 80ba80a9bf25d251237694c3fcee850a73324532
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jul 30 23:08:46 2007 +0400

    Fallout from "Remove fs.h from mm.h" patch
    
    While I was busy compile-testing my patch, ENOSYS sneaked into pm.h
    leading to some compile-breakages mostly on ia64 and some mips configs.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index e52f6f83c061..48b71badfb4c 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -25,6 +25,7 @@
 
 #include <linux/list.h>
 #include <asm/atomic.h>
+#include <asm/errno.h>
 
 /*
  * Power management requests... these are passed to pm_send_all() and friends.

commit 296699de6bdc717189a331ab6bbe90e05c94db06
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 29 23:27:18 2007 +0200

    Introduce CONFIG_SUSPEND for suspend-to-Ram and standby
    
    Introduce CONFIG_SUSPEND representing the ability to enter system sleep
    states, such as the ACPI S3 state, and allow the user to choose SUSPEND
    and HIBERNATION independently of each other.
    
    Make HOTPLUG_CPU be selected automatically if SUSPEND or HIBERNATION has
    been chosen and the kernel is intended for SMP systems.
    
    Also, introduce CONFIG_PM_SLEEP which is automatically selected if
    CONFIG_SUSPEND or CONFIG_HIBERNATION is set and use it to select the
    code needed for both suspend and hibernation.
    
    The top-level power management headers and the ACPI code related to
    suspend and hibernation are modified to use the new definitions (the
    changes in drivers/acpi/sleep/main.c are, mostly, moving code to reduce
    the number of ifdefs).
    
    There are many other files in which CONFIG_PM can be replaced with
    CONFIG_PM_SLEEP or even with CONFIG_SUSPEND, but they can be updated in
    the future.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ad3cc2eb0d34..e52f6f83c061 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -165,6 +165,7 @@ struct pm_ops {
 	int (*finish)(suspend_state_t state);
 };
 
+#ifdef CONFIG_SUSPEND
 extern struct pm_ops *pm_ops;
 
 /**
@@ -193,6 +194,12 @@ extern void arch_suspend_disable_irqs(void);
 extern void arch_suspend_enable_irqs(void);
 
 extern int pm_suspend(suspend_state_t state);
+#else /* !CONFIG_SUSPEND */
+#define suspend_valid_only_mem	NULL
+
+static inline void pm_set_ops(struct pm_ops *pm_ops) {}
+static inline int pm_suspend(suspend_state_t state) { return -ENOSYS; }
+#endif /* !CONFIG_SUSPEND */
 
 /*
  * Device power management
@@ -266,7 +273,7 @@ typedef struct pm_message {
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned		can_wakeup:1;
-#ifdef	CONFIG_PM
+#ifdef	CONFIG_PM_SLEEP
 	unsigned		should_wakeup:1;
 	struct list_head	entry;
 #endif
@@ -276,7 +283,7 @@ extern int device_power_down(pm_message_t state);
 extern void device_power_up(void);
 extern void device_resume(void);
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);
 
@@ -306,7 +313,7 @@ static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 	return 0;
 }
 
-#else /* !CONFIG_PM */
+#else /* !CONFIG_PM_SLEEP */
 
 static inline int device_suspend(pm_message_t state)
 {
@@ -323,7 +330,7 @@ static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 	return 0;
 }
 
-#endif
+#endif /* !CONFIG_PM_SLEEP */
 
 /* changes to device_may_wakeup take effect on the next pm state change.
  * by default, devices should wakeup if they can.

commit bd804eba1c8597cbb7cd5a5f9fe886aae16a079a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 19 01:47:40 2007 -0700

    PM: Introduce pm_power_off_prepare
    
    Introduce the pm_power_off_prepare() callback that can be registered by the
    interested platforms in analogy with pm_idle() and pm_power_off(), used for
    preparing the system to power off (needed by ACPI).
    
    This allows us to drop acpi_sysclass and device_acpi that are only defined in
    order to register the ACPI power off preparation callback, which is needed by
    pm_power_off() registered in a much different way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 2735b7cadd20..ad3cc2eb0d34 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -101,6 +101,7 @@ struct pm_dev
  */
 extern void (*pm_idle)(void);
 extern void (*pm_power_off)(void);
+extern void (*pm_power_off_prepare)(void);
 
 typedef int __bitwise suspend_state_t;
 

commit 3f8df781fc5f9ee5253a54ba669e1c8872844b86
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jul 12 16:57:22 2007 -0400

    PM: remove deprecated dpm_runtime_* routines
    
    This patch (as933) removes the deprecated dpm_runtime_suspend() and
    dpm_runtime_resume() routines from the PM core.  The only user of
    those routines is the PCMCIA ds driver; local replacements are added.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 273781c82e4d..2735b7cadd20 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -284,8 +284,6 @@ extern int device_prepare_suspend(pm_message_t state);
 #define device_may_wakeup(dev) \
 	(device_can_wakeup(dev) && (dev)->power.should_wakeup)
 
-extern int dpm_runtime_suspend(struct device *, pm_message_t);
-extern void dpm_runtime_resume(struct device *);
 extern void __suspend_report_result(const char *function, void *fn, int ret);
 
 #define suspend_report_result(fn, ret)					\
@@ -317,15 +315,6 @@ static inline int device_suspend(pm_message_t state)
 #define device_set_wakeup_enable(dev,val)	do{}while(0)
 #define device_may_wakeup(dev)			(0)
 
-static inline int dpm_runtime_suspend(struct device * dev, pm_message_t state)
-{
-	return 0;
-}
-
-static inline void dpm_runtime_resume(struct device * dev)
-{
-}
-
 #define suspend_report_result(fn, ret) do { } while (0)
 
 static inline int call_platform_enable_wakeup(struct device *dev, int is_on)

commit 515c53576299e32d6bdb6295cfa2fe1307516eb4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jun 17 19:48:06 2007 +0200

    PM: Remove prev_state from struct dev_pm_info
    
    The prev_state member of struct dev_pm_info (defined in include/linux/pm.h) is
    only used during a resume to check if the device's state before the suspend was
    'off', in which case the device is not resumed.  However, in such cases the
    decision whether or not to resume the device should be made on the driver level
    and the resume callbacks from the device's bus and class should be executed
    anyway (the may be needed for some things other than just powering on the
    device).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6e7f06671683..273781c82e4d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -267,7 +267,6 @@ struct dev_pm_info {
 	unsigned		can_wakeup:1;
 #ifdef	CONFIG_PM
 	unsigned		should_wakeup:1;
-	pm_message_t		prev_state;
 	struct list_head	entry;
 #endif
 };

commit cc4900690bf77257996e90f0059eb074b8db52e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 13 15:55:34 2007 +0200

    PM: Remove saved_state from struct dev_pm_info
    
    The saved_state member of struct dev_pm_info, defined in include/linux/pm.h, is
    not used anywhere, so it can be removed.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3fd65ad4b097..6e7f06671683 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -268,7 +268,6 @@ struct dev_pm_info {
 #ifdef	CONFIG_PM
 	unsigned		should_wakeup:1;
 	pm_message_t		prev_state;
-	void			* saved_state;
 	struct list_head	entry;
 #endif
 };

commit 9cddad77574313fcee36c5e60122718daa7c0361
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jun 13 15:53:34 2007 +0200

    PM: Remove pm_parent from struct dev_pm_info
    
    The pm_parent member of struct dev_pm_info (defined in include/linux/pm.h) is
    only used to check if the device's parent is in the right state while the
    device is being suspended or resumed.  However, this can be done just as well
    with the help of the parent pointer in struct device, so pm_parent can be
    removed along with some code that handles it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b2c4fde4e994..3fd65ad4b097 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -269,13 +269,10 @@ struct dev_pm_info {
 	unsigned		should_wakeup:1;
 	pm_message_t		prev_state;
 	void			* saved_state;
-	struct device		* pm_parent;
 	struct list_head	entry;
 #endif
 };
 
-extern void device_pm_set_parent(struct device * dev, struct device * parent);
-
 extern int device_power_down(pm_message_t state);
 extern void device_power_up(void);
 extern void device_resume(void);

commit 2391dae3e36c19fe668c71eac2eb8344dbaaf46d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 1 12:07:33 2007 -0700

    PM: introduce set_target method in pm_ops
    
    Commit 52ade9b3b97fd3bea42842a056fe0786c28d0555 changed the suspend code
    ordering to execute pm_ops->prepare() after the device model per-device
    .suspend() calls in order to fix some ACPI-related issues.  Unfortunately, it
    broke the at91 platform which assumed that pm_ops->prepare() would be called
    before suspending devices.
    
    at91 used pm_ops->prepare() to get notified of the target system sleep state,
    so that it could use this information while suspending devices.  However, with
    the current suspend code ordering pm_ops->prepare() is called too late for
    this purpose.  Thus, at91 needs an additional method in 'struct pm_ops' that
    will be used for notifying the platform of the target system sleep state.
    Moreover, in the future such a method will also be needed by ACPI.
    
    This patch adds the .set_target() method to 'struct pm_ops' and makes the
    suspend code call it, if implemented, before executing the device model
    per-device .suspend() calls.  It also modifies the at91 code to use
    pm_ops->set_target() instead of pm_ops->prepare().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 87545e0f0b58..b2c4fde4e994 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -110,37 +110,67 @@ typedef int __bitwise suspend_state_t;
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
 /**
- * struct pm_ops - Callbacks for managing platform dependent suspend states.
- * @valid: Callback to determine whether the given state can be entered.
- *	Valid states are advertised in /sys/power/state but can still
- *	be rejected by prepare or enter if the conditions aren't right.
- *	There is a %pm_valid_only_mem function available that can be assigned
- *	to this if you only implement mem sleep.
+ * struct pm_ops - Callbacks for managing platform dependent system sleep
+ *	states.
  *
- * @prepare: Prepare the platform for the given suspend state. Can return a
- *	negative error code if necessary.
+ * @valid: Callback to determine if given system sleep state is supported by
+ *	the platform.
+ *	Valid (ie. supported) states are advertised in /sys/power/state.  Note
+ *	that it still may be impossible to enter given system sleep state if the
+ *	conditions aren't right.
+ *	There is the %pm_valid_only_mem function available that can be assigned
+ *	to this if the platform only supports mem sleep.
  *
- * @enter: Enter the given suspend state, must be assigned. Can return a
- *	negative error code if necessary.
+ * @set_target: Tell the platform which system sleep state is going to be
+ *	entered.
+ *	@set_target() is executed right prior to suspending devices.  The
+ *	information conveyed to the platform code by @set_target() should be
+ *	disregarded by the platform as soon as @finish() is executed and if
+ *	@prepare() fails.  If @set_target() fails (ie. returns nonzero),
+ *	@prepare(), @enter() and @finish() will not be called by the PM core.
+ *	This callback is optional.  However, if it is implemented, the argument
+ *	passed to @prepare(), @enter() and @finish() is meaningless and should
+ *	be ignored.
  *
- * @finish: Called when the system has left the given state and all devices
- *	are resumed. The return value is ignored.
+ * @prepare: Prepare the platform for entering the system sleep state indicated
+ *	by @set_target() or represented by the argument if @set_target() is not
+ *	implemented.
+ *	@prepare() is called right after devices have been suspended (ie. the
+ *	appropriate .suspend() method has been executed for each device) and
+ *	before the nonboot CPUs are disabled (it is executed with IRQs enabled).
+ *	This callback is optional.  It returns 0 on success or a negative
+ *	error code otherwise, in which case the system cannot enter the desired
+ *	sleep state (@enter() and @finish() will not be called in that case).
+ *
+ * @enter: Enter the system sleep state indicated by @set_target() or
+ *	represented by the argument if @set_target() is not implemented.
+ *	This callback is mandatory.  It returns 0 on success or a negative
+ *	error code otherwise, in which case the system cannot enter the desired
+ *	sleep state.
+ *
+ * @finish: Called when the system has just left a sleep state, right after
+ *	the nonboot CPUs have been enabled and before devices are resumed (it is
+ *	executed with IRQs enabled).  If @set_target() is not implemented, the
+ *	argument represents the sleep state being left.
+ *	This callback is optional, but should be implemented by the platforms
+ *	that implement @prepare().  If implemented, it is always called after
+ *	@enter() (even if @enter() fails).
  */
 struct pm_ops {
 	int (*valid)(suspend_state_t state);
+	int (*set_target)(suspend_state_t state);
 	int (*prepare)(suspend_state_t state);
 	int (*enter)(suspend_state_t state);
 	int (*finish)(suspend_state_t state);
 };
 
+extern struct pm_ops *pm_ops;
+
 /**
  * pm_set_ops - set platform dependent power management ops
  * @pm_ops: The new power management operations to set.
  */
 extern void pm_set_ops(struct pm_ops *pm_ops);
-extern struct pm_ops *pm_ops;
-extern int pm_suspend(suspend_state_t state);
-
 extern int pm_valid_only_mem(suspend_state_t state);
 
 /**
@@ -161,6 +191,8 @@ extern void arch_suspend_disable_irqs(void);
  */
 extern void arch_suspend_enable_irqs(void);
 
+extern int pm_suspend(suspend_state_t state);
+
 /*
  * Device power management
  */

commit a3d25c275d383975504dc53c25b691df59bd3c48
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 9 02:33:18 2007 -0700

    PM: Separate hibernation code from suspend code
    
    [ With Johannes Berg <johannes@sipsolutions.net> ]
    
    Separate the hibernation (aka suspend to disk code) from the other suspend
    code.  In particular:
    
     * Remove the definitions related to hibernation from include/linux/pm.h
     * Introduce struct hibernation_ops and a new hibernate() function to hibernate
       the system, defined in include/linux/suspend.h
     * Separate suspend code in kernel/power/main.c from hibernation-related code
       in kernel/power/disk.c and kernel/power/user.c (with the help of
       hibernation_ops)
     * Switch ACPI (the only user of pm_ops.pm_disk_mode) to hibernation_ops
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Greg KH <greg@kroah.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@nigel.suspend2.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6e8fa3049e5d..87545e0f0b58 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -107,26 +107,11 @@ typedef int __bitwise suspend_state_t;
 #define PM_SUSPEND_ON		((__force suspend_state_t) 0)
 #define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)
 #define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
-#define PM_SUSPEND_DISK		((__force suspend_state_t) 4)
-#define PM_SUSPEND_MAX		((__force suspend_state_t) 5)
-
-typedef int __bitwise suspend_disk_method_t;
-
-/* invalid must be 0 so struct pm_ops initialisers can leave it out */
-#define PM_DISK_INVALID		((__force suspend_disk_method_t) 0)
-#define	PM_DISK_PLATFORM	((__force suspend_disk_method_t) 1)
-#define	PM_DISK_SHUTDOWN	((__force suspend_disk_method_t) 2)
-#define	PM_DISK_REBOOT		((__force suspend_disk_method_t) 3)
-#define	PM_DISK_TEST		((__force suspend_disk_method_t) 4)
-#define	PM_DISK_TESTPROC	((__force suspend_disk_method_t) 5)
-#define	PM_DISK_MAX		((__force suspend_disk_method_t) 6)
+#define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
 /**
  * struct pm_ops - Callbacks for managing platform dependent suspend states.
  * @valid: Callback to determine whether the given state can be entered.
- * 	If %CONFIG_SOFTWARE_SUSPEND is set then %PM_SUSPEND_DISK is
- *	always valid and never passed to this call. If not assigned,
- *	no suspend states are valid.
  *	Valid states are advertised in /sys/power/state but can still
  *	be rejected by prepare or enter if the conditions aren't right.
  *	There is a %pm_valid_only_mem function available that can be assigned
@@ -140,24 +125,12 @@ typedef int __bitwise suspend_disk_method_t;
  *
  * @finish: Called when the system has left the given state and all devices
  *	are resumed. The return value is ignored.
- *
- * @pm_disk_mode: The generic code always allows one of the shutdown methods
- *	%PM_DISK_SHUTDOWN, %PM_DISK_REBOOT, %PM_DISK_TEST and
- *	%PM_DISK_TESTPROC. If this variable is set, the mode it is set
- *	to is allowed in addition to those modes and is also made default.
- *	When this mode is sent selected, the @prepare call will be called
- *	before suspending to disk (if present), the @enter call should be
- *	present and will be called after all state has been saved and the
- *	machine is ready to be powered off; the @finish callback is called
- *	after state has been restored. All these calls are called with
- *	%PM_SUSPEND_DISK as the state.
  */
 struct pm_ops {
 	int (*valid)(suspend_state_t state);
 	int (*prepare)(suspend_state_t state);
 	int (*enter)(suspend_state_t state);
 	int (*finish)(suspend_state_t state);
-	suspend_disk_method_t pm_disk_mode;
 };
 
 /**
@@ -276,8 +249,6 @@ extern void device_power_up(void);
 extern void device_resume(void);
 
 #ifdef CONFIG_PM
-extern suspend_disk_method_t pm_disk_mode;
-
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);
 

commit 14e38ac823b7b25e3f4e563c182f93fde78167d6
Author: David Rientjes <rientjes@google.com>
Date:   Mon Apr 30 15:09:56 2007 -0700

    pm: include EIO from errno-base.h
    
    For backwards compatibility, call_platform_enable_wakeup() can return 0
    instead of -EIO since we aren't guaranteed to have errno defined.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: David Rientjes <rientjes@google.com>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 7a516690dcb3..6e8fa3049e5d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -332,7 +332,7 @@ static inline void dpm_runtime_resume(struct device * dev)
 
 static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 {
-	return -EIO;
+	return 0;
 }
 
 #endif

commit 9684e51cd157607f0727c1550e7df6e31de40808
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:55 2007 -0700

    power management: force pm_ops.valid callback to be assigned
    
    This patch changes the docs and behaviour from "all states valid" to "no
    states valid" if no .valid callback is assigned.  Users of pm_ops that only
    need mem sleep can assign pm_valid_only_mem without any overhead, others
    will require more elaborate callbacks.
    
    Now that all users of pm_ops have a .valid callback this is a safe thing to
    do and prevents things from getting messy again as they were before.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Looks-okay-to: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6035209cf31e..7a516690dcb3 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -125,12 +125,12 @@ typedef int __bitwise suspend_disk_method_t;
  * struct pm_ops - Callbacks for managing platform dependent suspend states.
  * @valid: Callback to determine whether the given state can be entered.
  * 	If %CONFIG_SOFTWARE_SUSPEND is set then %PM_SUSPEND_DISK is
- *	always valid and never passed to this call.
- *	If not assigned, all suspend states are advertised as valid
- *	in /sys/power/state (but can still be rejected by prepare or enter.)
- *	Since new states can be added for other platforms, you should
- *	assign this callback. There is a %pm_valid_only_mem function
- *	available if you only implemented mem sleep.
+ *	always valid and never passed to this call. If not assigned,
+ *	no suspend states are valid.
+ *	Valid states are advertised in /sys/power/state but can still
+ *	be rejected by prepare or enter if the conditions aren't right.
+ *	There is a %pm_valid_only_mem function available that can be assigned
+ *	to this if you only implement mem sleep.
  *
  * @prepare: Prepare the platform for the given suspend state. Can return a
  *	negative error code if necessary.

commit e8c9c502690efd24b7055bf608e7a3c34216848b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:54 2007 -0700

    power management: implement pm_ops.valid for everybody
    
    Almost all users of pm_ops only support mem sleep, don't check in .valid and
    don't reject any others in .prepare so users can be confused if they check
    /sys/power/state, especially when new states are added (these would then
    result in s-t-r although they're supposed to be something different).
    
    This patch implements a generic pm_valid_only_mem function that is then
    exported for users and puts it to use in almost all existing pm_ops.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: linux-pm@lists.linux-foundation.org
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index c2a55f94c29a..6035209cf31e 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -128,6 +128,9 @@ typedef int __bitwise suspend_disk_method_t;
  *	always valid and never passed to this call.
  *	If not assigned, all suspend states are advertised as valid
  *	in /sys/power/state (but can still be rejected by prepare or enter.)
+ *	Since new states can be added for other platforms, you should
+ *	assign this callback. There is a %pm_valid_only_mem function
+ *	available if you only implemented mem sleep.
  *
  * @prepare: Prepare the platform for the given suspend state. Can return a
  *	negative error code if necessary.
@@ -165,6 +168,7 @@ extern void pm_set_ops(struct pm_ops *pm_ops);
 extern struct pm_ops *pm_ops;
 extern int pm_suspend(suspend_state_t state);
 
+extern int pm_valid_only_mem(suspend_state_t state);
 
 /**
  * arch_suspend_disable_irqs - disable IRQs for suspend

commit 11d77d0c01b80e44c7aceb21928508dafce774f9
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:53 2007 -0700

    power management: remove firmware disk mode
    
    This patch removes the firmware disk suspend mode which is the wrong approach,
    it is supposed to be used for implementing firmware-based disk suspend but
    cannot actually be used for that.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index dfced9188bdc..c2a55f94c29a 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -114,13 +114,12 @@ typedef int __bitwise suspend_disk_method_t;
 
 /* invalid must be 0 so struct pm_ops initialisers can leave it out */
 #define PM_DISK_INVALID		((__force suspend_disk_method_t) 0)
-#define	PM_DISK_FIRMWARE	((__force suspend_disk_method_t) 1)
-#define	PM_DISK_PLATFORM	((__force suspend_disk_method_t) 2)
-#define	PM_DISK_SHUTDOWN	((__force suspend_disk_method_t) 3)
-#define	PM_DISK_REBOOT		((__force suspend_disk_method_t) 4)
-#define	PM_DISK_TEST		((__force suspend_disk_method_t) 5)
-#define	PM_DISK_TESTPROC	((__force suspend_disk_method_t) 6)
-#define	PM_DISK_MAX		((__force suspend_disk_method_t) 7)
+#define	PM_DISK_PLATFORM	((__force suspend_disk_method_t) 1)
+#define	PM_DISK_SHUTDOWN	((__force suspend_disk_method_t) 2)
+#define	PM_DISK_REBOOT		((__force suspend_disk_method_t) 3)
+#define	PM_DISK_TEST		((__force suspend_disk_method_t) 4)
+#define	PM_DISK_TESTPROC	((__force suspend_disk_method_t) 5)
+#define	PM_DISK_MAX		((__force suspend_disk_method_t) 6)
 
 /**
  * struct pm_ops - Callbacks for managing platform dependent suspend states.

commit fe0c935a6cbf25d72a27c7a345df8a2151de0b74
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 15:09:51 2007 -0700

    rework pm_ops pm_disk_mode, kill misuse
    
    This patch series cleans up some misconceptions about pm_ops.  Some users of
    the pm_ops structure attempt to use it to stop the user from entering suspend
    to disk, this, however, is not possible since the user can always use
    "shutdown" in /sys/power/disk and then the pm_ops are never invoked.  Also,
    platforms that don't support suspend to disk simply should not allow
    configuring SOFTWARE_SUSPEND (read the help text on it, it only selects
    suspend to disk and nothing else, all the other stuff depends on PM).
    
    The pm_ops structure is actually intended to provide a way to enter
    platform-defined sleep states (currently supported states are "standby" and
    "mem" (suspend to ram)) and additionally (if SOFTWARE_SUSPEND is configured)
    allows a platform to support a platform specific way to enter low-power mode
    once everything has been saved to disk.  This is currently only used by ACPI
    (S4).
    
    This patch:
    
    The pm_ops.pm_disk_mode is used in totally bogus ways since nobody really
    seems to understand what it actually does.
    
    This patch clarifies the pm_disk_mode description.
    
    It also removes all the arm and sh users that think they can veto suspend to
    disk via pm_ops; not so since the user can always do echo shutdown >
    /sys/power/disk, they need to find a better way involving Kconfig or such.
    
    ACPI is the only user left with a non-zero pm_disk_mode.
    
    The patch also sets the default mode to shutdown again, but when a new pm_ops
    is registered its pm_disk_mode is selected as default, that way the default
    stays for ACPI where it is apparently required.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: <linux-pm@lists.linux-foundation.org>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 9bd86db4d395..dfced9188bdc 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -112,6 +112,8 @@ typedef int __bitwise suspend_state_t;
 
 typedef int __bitwise suspend_disk_method_t;
 
+/* invalid must be 0 so struct pm_ops initialisers can leave it out */
+#define PM_DISK_INVALID		((__force suspend_disk_method_t) 0)
 #define	PM_DISK_FIRMWARE	((__force suspend_disk_method_t) 1)
 #define	PM_DISK_PLATFORM	((__force suspend_disk_method_t) 2)
 #define	PM_DISK_SHUTDOWN	((__force suspend_disk_method_t) 3)
@@ -137,17 +139,16 @@ typedef int __bitwise suspend_disk_method_t;
  * @finish: Called when the system has left the given state and all devices
  *	are resumed. The return value is ignored.
  *
- * @pm_disk_mode: Set to the disk method that the user should be able to
- *	configure for suspend-to-disk. Since %PM_DISK_SHUTDOWN,
- *	%PM_DISK_REBOOT, %PM_DISK_TEST and %PM_DISK_TESTPROC
- *	are always allowed, currently only %PM_DISK_PLATFORM
- *	makes sense. If the user then choses %PM_DISK_PLATFORM,
- *	the @prepare call will be called before suspending to disk
- *	(if present), the @enter call should be present and will
- *	be called after all state has been saved and the machine
- *	is ready to be shut down/suspended/..., and the @finish
- *	callback is called after state has been restored. All
- *	these calls are called with %PM_SUSPEND_DISK as the state.
+ * @pm_disk_mode: The generic code always allows one of the shutdown methods
+ *	%PM_DISK_SHUTDOWN, %PM_DISK_REBOOT, %PM_DISK_TEST and
+ *	%PM_DISK_TESTPROC. If this variable is set, the mode it is set
+ *	to is allowed in addition to those modes and is also made default.
+ *	When this mode is sent selected, the @prepare call will be called
+ *	before suspending to disk (if present), the @enter call should be
+ *	present and will be called after all state has been saved and the
+ *	machine is ready to be powered off; the @finish callback is called
+ *	after state has been restored. All these calls are called with
+ *	%PM_SUSPEND_DISK as the state.
  */
 struct pm_ops {
 	int (*valid)(suspend_state_t state);

commit a53c46dc8253cc613ad66a2ca7aad6de8b7e61b9
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Apr 26 11:43:58 2007 +0200

    s2ram: add arch irq disable/enable hooks
    
    After some more discussion this patch replaces it:
    
    From: Johannes Berg <johannes@sipsolutions.net>
    Subject: suspend: add arch irq disable/enable hooks
    
    For powermac, we need to do some things between suspending devices and
    device_power_off, for example setting the decrementer. This patch
    allows architectures to define arch_s2ram_{en,dis}able_irqs in their
    asm/suspend.h to have control over this step.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index b0ab623adbf5..9bd86db4d395 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -166,6 +166,24 @@ extern struct pm_ops *pm_ops;
 extern int pm_suspend(suspend_state_t state);
 
 
+/**
+ * arch_suspend_disable_irqs - disable IRQs for suspend
+ *
+ * Disables IRQs (in the default case). This is a weak symbol in the common
+ * code and thus allows architectures to override it if more needs to be
+ * done. Not called for suspend to disk.
+ */
+extern void arch_suspend_disable_irqs(void);
+
+/**
+ * arch_suspend_enable_irqs - enable IRQs after suspend
+ *
+ * Enables IRQs (in the default case). This is a weak symbol in the common
+ * code and thus allows architectures to override it if more needs to be
+ * done. Not called for suspend to disk.
+ */
+extern void arch_suspend_enable_irqs(void);
+
 /*
  * Device power management
  */

commit 075c1771526c85849ed22298d048bc07e400aee5
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Apr 26 00:12:06 2007 -0700

    define platform wakeup hook, use in pci_enable_wake()
    
    This defines a platform hook to enable/disable a device as a wakeup event
    source.  It's initially for use with ACPI, but more generally it could be used
    whenever enable_irq_wake()/disable_irq_wake() don't suffice.
    
    The hook is called -- if available -- inside pci_enable_wake(); and the
    semantics of that call are enhanced so that support for PCI PME# is no longer
    needed.  It can now work for devices with "legacy PCI PM", when platform
    support allows it.  (That support would use some board-specific signal for for
    the same purpose as PME#.)
    
    [akpm@linux-foundation.org: Make it compile with CONFIG_PM=n]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 21db05ac7c0b..b0ab623adbf5 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -273,6 +273,20 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 		__suspend_report_result(__FUNCTION__, fn, ret);		\
 	} while (0)
 
+/*
+ * Platform hook to activate device wakeup capability, if that's not already
+ * handled by enable_irq_wake() etc.
+ * Returns zero on success, else negative errno
+ */
+extern int (*platform_enable_wakeup)(struct device *dev, int is_on);
+
+static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
+{
+	if (platform_enable_wakeup)
+		return (*platform_enable_wakeup)(dev, is_on);
+	return 0;
+}
+
 #else /* !CONFIG_PM */
 
 static inline int device_suspend(pm_message_t state)
@@ -294,6 +308,11 @@ static inline void dpm_runtime_resume(struct device * dev)
 
 #define suspend_report_result(fn, ret) do { } while (0)
 
+static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
+{
+	return -EIO;
+}
+
 #endif
 
 /* changes to device_may_wakeup take effect on the next pm state change.

commit 2a9df4945106d62ed9249a44d666fab93c685f7a
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Fri Feb 16 01:38:30 2007 -0800

    power management: fix struct layout and docs
    
    Because the pm ops in powermac are obviously not using them as intended, I
    added documentation for it in kernel-doc format.
    
    Reordering the fields in struct pm_ops not only makes the output of kernel-doc
    make more sense but also removes a hole from the structure on 64-bit
    platforms.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Macheck <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 070394e846d0..21db05ac7c0b 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -120,15 +120,48 @@ typedef int __bitwise suspend_disk_method_t;
 #define	PM_DISK_TESTPROC	((__force suspend_disk_method_t) 6)
 #define	PM_DISK_MAX		((__force suspend_disk_method_t) 7)
 
+/**
+ * struct pm_ops - Callbacks for managing platform dependent suspend states.
+ * @valid: Callback to determine whether the given state can be entered.
+ * 	If %CONFIG_SOFTWARE_SUSPEND is set then %PM_SUSPEND_DISK is
+ *	always valid and never passed to this call.
+ *	If not assigned, all suspend states are advertised as valid
+ *	in /sys/power/state (but can still be rejected by prepare or enter.)
+ *
+ * @prepare: Prepare the platform for the given suspend state. Can return a
+ *	negative error code if necessary.
+ *
+ * @enter: Enter the given suspend state, must be assigned. Can return a
+ *	negative error code if necessary.
+ *
+ * @finish: Called when the system has left the given state and all devices
+ *	are resumed. The return value is ignored.
+ *
+ * @pm_disk_mode: Set to the disk method that the user should be able to
+ *	configure for suspend-to-disk. Since %PM_DISK_SHUTDOWN,
+ *	%PM_DISK_REBOOT, %PM_DISK_TEST and %PM_DISK_TESTPROC
+ *	are always allowed, currently only %PM_DISK_PLATFORM
+ *	makes sense. If the user then choses %PM_DISK_PLATFORM,
+ *	the @prepare call will be called before suspending to disk
+ *	(if present), the @enter call should be present and will
+ *	be called after all state has been saved and the machine
+ *	is ready to be shut down/suspended/..., and the @finish
+ *	callback is called after state has been restored. All
+ *	these calls are called with %PM_SUSPEND_DISK as the state.
+ */
 struct pm_ops {
-	suspend_disk_method_t pm_disk_mode;
 	int (*valid)(suspend_state_t state);
 	int (*prepare)(suspend_state_t state);
 	int (*enter)(suspend_state_t state);
 	int (*finish)(suspend_state_t state);
+	suspend_disk_method_t pm_disk_mode;
 };
 
-extern void pm_set_ops(struct pm_ops *);
+/**
+ * pm_set_ops - set platform dependent power management ops
+ * @pm_ops: The new power management operations to set.
+ */
+extern void pm_set_ops(struct pm_ops *pm_ops);
 extern struct pm_ops *pm_ops;
 extern int pm_suspend(suspend_state_t state);
 

commit b918f6e62cd46774f9fc0a3fbba6bd10ad85ee14
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Nov 2 22:07:19 2006 -0800

    [PATCH] swsusp: debugging
    
    Add a swsusp debugging mode.  This does everything that's needed for a suspend
    except for actually suspending.  So we can look in the log messages and work
    out a) what code is being slow and b) which drivers are misbehaving.
    
    (1)
    # echo testproc > /sys/power/disk
    # echo disk > /sys/power/state
    
    This should turn off the non-boot CPU, freeze all processes, wait for 5
    seconds and then thaw the processes and the CPU.
    
    (2)
    # echo test > /sys/power/disk
    # echo disk > /sys/power/state
    
    This should turn off the non-boot CPU, freeze all processes, shrink
    memory, suspend all devices, wait for 5 seconds, resume the devices etc.
    
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Stefan Seyfried <seife@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6b27e07aef19..070394e846d0 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -116,7 +116,9 @@ typedef int __bitwise suspend_disk_method_t;
 #define	PM_DISK_PLATFORM	((__force suspend_disk_method_t) 2)
 #define	PM_DISK_SHUTDOWN	((__force suspend_disk_method_t) 3)
 #define	PM_DISK_REBOOT		((__force suspend_disk_method_t) 4)
-#define	PM_DISK_MAX		((__force suspend_disk_method_t) 5)
+#define	PM_DISK_TEST		((__force suspend_disk_method_t) 5)
+#define	PM_DISK_TESTPROC	((__force suspend_disk_method_t) 6)
+#define	PM_DISK_MAX		((__force suspend_disk_method_t) 7)
 
 struct pm_ops {
 	suspend_disk_method_t pm_disk_mode;

commit 82bb67f2c1f9ef438c56ac24e7dca027fe7289b5
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Aug 14 23:11:04 2006 -0700

    PM: define PM_EVENT_PRETHAW
    
    This adds a new pm_message_t event type to use when preparing to restore a
    swsusp snapshot.  Devices that have been initialized by Linux after resume
    (rather than left in power-up-reset state) may need to be reset; this new
    event type give drivers the chance to do that.
    
    The drivers that will care about this are those which understand more hardware
    states than just "on" and "reset", relying on hardware state during resume()
    methods to be either the state left by the preceding suspend(), or a
    power-lost reset.  The best current example of this class of drivers are USB
    host controller drivers, which currently do not work through swsusp when
    they're statically linked.
    
    When the swsusp freeze/thaw mechanism kicks in, a troublesome third state
    could exist: one state set up by a different kernel instance, before a
    snapshot image is resumed.  This mechanism lets drivers prevent that state.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 096fb6f754cf..6b27e07aef19 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -142,29 +142,61 @@ typedef struct pm_message {
 } pm_message_t;
 
 /*
- * There are 4 important states driver can be in:
- * ON     -- driver is working
- * FREEZE -- stop operations and apply whatever policy is applicable to a
- *           suspended driver of that class, freeze queues for block like IDE
- *           does, drop packets for ethernet, etc... stop DMA engine too etc...
- *           so a consistent image can be saved; but do not power any hardware
- *           down.
- * SUSPEND - like FREEZE, but hardware is doing as much powersaving as
- *           possible. Roughly pci D3.
+ * Several driver power state transitions are externally visible, affecting
+ * the state of pending I/O queues and (for drivers that touch hardware)
+ * interrupts, wakeups, DMA, and other hardware state.  There may also be
+ * internal transitions to various low power modes, which are transparent
+ * to the rest of the driver stack (such as a driver that's ON gating off
+ * clocks which are not in active use).
  *
- * Unfortunately, current drivers only recognize numeric values 0 (ON) and 3
- * (SUSPEND).  We'll need to fix the drivers. So yes, putting 3 to all different
- * defines is intentional, and will go away as soon as drivers are fixed.  Also
- * note that typedef is neccessary, we'll probably want to switch to
- *   typedef struct pm_message_t { int event; int flags; } pm_message_t
- * or something similar soon.
+ * One transition is triggered by resume(), after a suspend() call; the
+ * message is implicit:
+ *
+ * ON		Driver starts working again, responding to hardware events
+ * 		and software requests.  The hardware may have gone through
+ * 		a power-off reset, or it may have maintained state from the
+ * 		previous suspend() which the driver will rely on while
+ * 		resuming.  On most platforms, there are no restrictions on
+ * 		availability of resources like clocks during resume().
+ *
+ * Other transitions are triggered by messages sent using suspend().  All
+ * these transitions quiesce the driver, so that I/O queues are inactive.
+ * That commonly entails turning off IRQs and DMA; there may be rules
+ * about how to quiesce that are specific to the bus or the device's type.
+ * (For example, network drivers mark the link state.)  Other details may
+ * differ according to the message:
+ *
+ * SUSPEND	Quiesce, enter a low power device state appropriate for
+ * 		the upcoming system state (such as PCI_D3hot), and enable
+ * 		wakeup events as appropriate.
+ *
+ * FREEZE	Quiesce operations so that a consistent image can be saved;
+ * 		but do NOT otherwise enter a low power device state, and do
+ * 		NOT emit system wakeup events.
+ *
+ * PRETHAW	Quiesce as if for FREEZE; additionally, prepare for restoring
+ * 		the system from a snapshot taken after an earlier FREEZE.
+ * 		Some drivers will need to reset their hardware state instead
+ * 		of preserving it, to ensure that it's never mistaken for the
+ * 		state which that earlier snapshot had set up.
+ *
+ * A minimally power-aware driver treats all messages as SUSPEND, fully
+ * reinitializes its device during resume() -- whether or not it was reset
+ * during the suspend/resume cycle -- and can't issue wakeup events.
+ *
+ * More power-aware drivers may also use low power states at runtime as
+ * well as during system sleep states like PM_SUSPEND_STANDBY.  They may
+ * be able to use wakeup events to exit from runtime low-power states,
+ * or from system low-power states such as standby or suspend-to-RAM.
  */
 
 #define PM_EVENT_ON 0
 #define PM_EVENT_FREEZE 1
 #define PM_EVENT_SUSPEND 2
+#define PM_EVENT_PRETHAW 3
 
 #define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
+#define PMSG_PRETHAW	((struct pm_message){ .event = PM_EVENT_PRETHAW, })
 #define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
 #define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
 

commit 7c8265f51073bc8632a99de78d5fd19117ed78b7
Author: Linus Torvalds <torvalds@osdl.org>
Date:   Sat Jun 24 14:50:29 2006 -0700

    Suspend infrastructure cleanup and extension
    
    Allow devices to participate in the suspend process more intimately,
    in particular, allow the final phase (with interrupts disabled) to
    also be open to normal devices, not just system devices.
    
    Also, allow classes to participate in device suspend.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 658c1b93d5bb..096fb6f754cf 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -190,6 +190,7 @@ extern void device_resume(void);
 extern suspend_disk_method_t pm_disk_mode;
 
 extern int device_suspend(pm_message_t state);
+extern int device_prepare_suspend(pm_message_t state);
 
 #define device_set_wakeup_enable(dev,val) \
 	((dev)->power.should_wakeup = !!(val))

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 66be58902b17..658c1b93d5bb 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -23,7 +23,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/list.h>
 #include <asm/atomic.h>
 

commit 026694920579590c73b5c56705d543568ed5ad41
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Mar 23 01:38:34 2006 -0800

    [PATCH] pm: print name of failed suspend function
    
    Print more diagnostic info to help identify the source of power management
    suspend failures.
    
    Example:
    
    usb_hcd_pci_suspend(): pci_set_power_state+0x0/0x1af() returns -22
    pci_device_suspend(): usb_hcd_pci_suspend+0x0/0x11b() returns -22
    suspend_device(): pci_device_suspend+0x0/0x34() returns -22
    
    Work-in-progress.  It needs lots more suspend_report_result() calls sprinkled
    everywhere.
    
    Cc: Patrick Mochel <mochel@digitalimplant.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 6df2585c0169..66be58902b17 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -199,6 +199,12 @@ extern int device_suspend(pm_message_t state);
 
 extern int dpm_runtime_suspend(struct device *, pm_message_t);
 extern void dpm_runtime_resume(struct device *);
+extern void __suspend_report_result(const char *function, void *fn, int ret);
+
+#define suspend_report_result(fn, ret)					\
+	do {								\
+		__suspend_report_result(__FUNCTION__, fn, ret);		\
+	} while (0)
 
 #else /* !CONFIG_PM */
 
@@ -219,6 +225,8 @@ static inline void dpm_runtime_resume(struct device * dev)
 {
 }
 
+#define suspend_report_result(fn, ret) do { } while (0)
+
 #endif
 
 /* changes to device_may_wakeup take effect on the next pm state change.

commit 74c7e2efbe37378026f00ad9e7253796d7b2fc99
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Mar 23 03:00:01 2006 -0800

    [PATCH] kernel/power: move externs to header files
    
    Move externs from C source files to header files.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 5be87ba3b7ac..6df2585c0169 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -188,6 +188,8 @@ extern void device_power_up(void);
 extern void device_resume(void);
 
 #ifdef CONFIG_PM
+extern suspend_disk_method_t pm_disk_mode;
+
 extern int device_suspend(pm_message_t state);
 
 #define device_set_wakeup_enable(dev,val) \
@@ -215,7 +217,6 @@ static inline int dpm_runtime_suspend(struct device * dev, pm_message_t state)
 
 static inline void dpm_runtime_resume(struct device * dev)
 {
-
 }
 
 #endif

commit bca73e4bf8563d83f7856164caa44d5f42e44cca
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sun Nov 13 16:06:25 2005 -0800

    [PATCH] move pm_register/etc. to CONFIG_PM_LEGACY, pm_legacy.h
    
    Since few people need the support anymore, this moves the legacy
    pm_xxx functions to CONFIG_PM_LEGACY, and include/linux/pm_legacy.h.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 1514098d156d..5be87ba3b7ac 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -94,55 +94,6 @@ struct pm_dev
 	struct list_head entry;
 };
 
-#ifdef CONFIG_PM
-
-extern int pm_active;
-
-#define PM_IS_ACTIVE() (pm_active != 0)
-
-/*
- * Register a device with power management
- */
-struct pm_dev __deprecated *
-pm_register(pm_dev_t type, unsigned long id, pm_callback callback);
-
-/*
- * Unregister a device with power management
- */
-void __deprecated pm_unregister(struct pm_dev *dev);
-
-/*
- * Unregister all devices with matching callback
- */
-void __deprecated pm_unregister_all(pm_callback callback);
-
-/*
- * Send a request to all devices
- */
-int __deprecated pm_send_all(pm_request_t rqst, void *data);
-
-#else /* CONFIG_PM */
-
-#define PM_IS_ACTIVE() 0
-
-static inline struct pm_dev *pm_register(pm_dev_t type,
-					 unsigned long id,
-					 pm_callback callback)
-{
-	return NULL;
-}
-
-static inline void pm_unregister(struct pm_dev *dev) {}
-
-static inline void pm_unregister_all(pm_callback callback) {}
-
-static inline int pm_send_all(pm_request_t rqst, void *data)
-{
-	return 0;
-}
-
-#endif /* CONFIG_PM */
-
 /* Functions above this comment are list-based old-style power
  * managment. Please avoid using them.  */
 

commit eb9289eb20df6b54214c45ac7c6bf5179a149026
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Sun Oct 30 15:00:01 2005 -0800

    [PATCH] introduce .valid callback for pm_ops
    
    Add pm_ops.valid callback, so only the available pm states show in
    /sys/power/state.  And this also makes an earlier states error report at
    enter_state before we do actual suspend/resume.
    
    Signed-off-by: Shaohua Li<shaohua.li@intel.com>
    Acked-by: Pavel Machek<pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index c61d5de837ef..1514098d156d 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -170,6 +170,7 @@ typedef int __bitwise suspend_disk_method_t;
 
 struct pm_ops {
 	suspend_disk_method_t pm_disk_mode;
+	int (*valid)(suspend_state_t state);
 	int (*prepare)(suspend_state_t state);
 	int (*enter)(suspend_state_t state);
 	int (*finish)(suspend_state_t state);

commit 9a7834d06d553d02cc6e659e94772f69a8b5367f
Author: Andrew Morton <akpm@osdl.org>
Date:   Sun Oct 23 23:02:20 2005 -0700

    [PATCH] USB: fix pm patches with CONFIG_PM off part 2
    
    With CONFIG_PM=n:
    
    drivers/built-in.o(.text+0x1098c): In function `hub_thread':
    drivers/usb/core/hub.c:2673: undefined reference to `.dpm_runtime_resume'
    drivers/built-in.o(.text+0x10998):drivers/usb/core/hub.c:2674: undefined reference to `.dpm_runtime_resume'
    
    Please, never ever ever put extern decls into .c files.  Use the darn header
    files :(
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 83bae1cbe55b..c61d5de837ef 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -243,6 +243,9 @@ extern int device_suspend(pm_message_t state);
 #define device_may_wakeup(dev) \
 	(device_can_wakeup(dev) && (dev)->power.should_wakeup)
 
+extern int dpm_runtime_suspend(struct device *, pm_message_t);
+extern void dpm_runtime_resume(struct device *);
+
 #else /* !CONFIG_PM */
 
 static inline int device_suspend(pm_message_t state)
@@ -253,6 +256,16 @@ static inline int device_suspend(pm_message_t state)
 #define device_set_wakeup_enable(dev,val)	do{}while(0)
 #define device_may_wakeup(dev)			(0)
 
+static inline int dpm_runtime_suspend(struct device * dev, pm_message_t state)
+{
+	return 0;
+}
+
+static inline void dpm_runtime_resume(struct device * dev)
+{
+
+}
+
 #endif
 
 /* changes to device_may_wakeup take effect on the next pm state change.

commit e9b7bd4ee7f6e3ee002dc72c5211cd97c7186d00
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Sep 22 22:30:48 2005 -0700

    [PATCH] one less word in struct device
    
    This saves a word from "struct device" ... there's a refcounting mechanism
    stub that's rather ineffective (the values are never even tested!), which
    can safely be deleted.  With this patch it uses normal device refcounting,
    so any potential users of the pm_parent mechanism will be more correct.
    (That mechanism is actually unusable for now though; it does nothing.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/base/power/main.c |   26 +++-----------------------
     include/linux/pm.h        |    1 -
     2 files changed, 3 insertions(+), 24 deletions(-)

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 7897cf500c51..83bae1cbe55b 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -224,7 +224,6 @@ struct dev_pm_info {
 	unsigned		should_wakeup:1;
 	pm_message_t		prev_state;
 	void			* saved_state;
-	atomic_t		pm_users;
 	struct device		* pm_parent;
 	struct list_head	entry;
 #endif

commit 0ac85241ebc7bf6b86ab498960cc121d53ef69ae
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Sep 12 19:39:34 2005 -0700

    [PATCH] driver model wakeup flags
    
    This is a refresh of an earlier patch to add "wakeup" support to the
    PM core model.  This provides per-device bus-neutral control of the
    use of wakeup events.
    
      * "struct device_pm_info" has two bits that are initialized as
        part of setting up the enclosing struct device:
          - "can_wakeup", reflecting hardware capabilities
          - "may_wakeup", the policy setting (when CONFIG_PM)
    
      * There's a writeable sysfs "wakeup" file, with one of two values:
          - "enabled", when the policy is to allow wakeup
          - "disabled", when the policy is not to allow it
          - "" if the device can't currently issue wakeups
    
    By default, wakeup is enabled on all devices that support it.  If its
    driver doesn't support it ... treat it as a bug.  :)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 5cfb07648eca..7897cf500c51 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -219,7 +219,9 @@ typedef struct pm_message {
 
 struct dev_pm_info {
 	pm_message_t		power_state;
+	unsigned		can_wakeup:1;
 #ifdef	CONFIG_PM
+	unsigned		should_wakeup:1;
 	pm_message_t		prev_state;
 	void			* saved_state;
 	atomic_t		pm_users;
@@ -236,13 +238,35 @@ extern void device_resume(void);
 
 #ifdef CONFIG_PM
 extern int device_suspend(pm_message_t state);
-#else
+
+#define device_set_wakeup_enable(dev,val) \
+	((dev)->power.should_wakeup = !!(val))
+#define device_may_wakeup(dev) \
+	(device_can_wakeup(dev) && (dev)->power.should_wakeup)
+
+#else /* !CONFIG_PM */
+
 static inline int device_suspend(pm_message_t state)
 {
 	return 0;
 }
+
+#define device_set_wakeup_enable(dev,val)	do{}while(0)
+#define device_may_wakeup(dev)			(0)
+
 #endif
 
+/* changes to device_may_wakeup take effect on the next pm state change.
+ * by default, devices should wakeup if they can.
+ */
+#define device_can_wakeup(dev) \
+	((dev)->power.can_wakeup)
+#define device_init_wakeup(dev,val) \
+	do { \
+		device_can_wakeup(dev) = !!(val); \
+		device_set_wakeup_enable(dev,val); \
+	} while(0)
+
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_PM_H */

commit ca078bae813dd46c0f9b102fdfb4a3384641ff48
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Sep 3 15:56:57 2005 -0700

    [PATCH] swsusp: switch pm_message_t to struct
    
    This adds type-checking to pm_message_t, so that people can't confuse it
    with int or u32.  It also allows us to fix "disk yoyo" during suspend (disk
    spinning down/up/down).
    
    [We've tried that before; since that cpufreq problems were fixed and I've
    tried make allyes config and fixed resulting damage.]
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index 7aeb208ed713..5cfb07648eca 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -186,7 +186,9 @@ extern int pm_suspend(suspend_state_t state);
 
 struct device;
 
-typedef u32 __bitwise pm_message_t;
+typedef struct pm_message {
+	int event;
+} pm_message_t;
 
 /*
  * There are 4 important states driver can be in:
@@ -207,9 +209,13 @@ typedef u32 __bitwise pm_message_t;
  * or something similar soon.
  */
 
-#define PMSG_FREEZE	((__force pm_message_t) 3)
-#define PMSG_SUSPEND	((__force pm_message_t) 3)
-#define PMSG_ON		((__force pm_message_t) 0)
+#define PM_EVENT_ON 0
+#define PM_EVENT_FREEZE 1
+#define PM_EVENT_SUSPEND 2
+
+#define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
+#define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
+#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
 
 struct dev_pm_info {
 	pm_message_t		power_state;

commit 5028770a42e7bc4d15791a44c28f0ad539323807
Merge: 9f02d6b7b43d d8683a0cb5d0
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 12 17:21:56 2005 -0400

    [ACPI] merge acpi-2.6.12 branch into latest Linux 2.6.13-rc...
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit e2a5b420f716cd1a46674b1a90389612eced916f
Author: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
Date:   Fri Mar 18 16:20:46 2005 -0500

    [ACPI] ACPI poweroff fix
    
    Register an "acpi" system device to be notified of shutdown preparation.
    This depends on CONFIG_PM
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4041
    
    Signed-off-by: Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ed2b76e75199..da88851266b8 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -175,7 +175,7 @@ struct pm_ops {
 };
 
 extern void pm_set_ops(struct pm_ops *);
-
+extern struct pm_ops *pm_ops;
 extern int pm_suspend(suspend_state_t state);
 
 

commit 620b03276488c3cf103caf1e326bd21f00d3df84
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Jun 25 14:55:11 2005 -0700

    [PATCH] properly stop devices before poweroff
    
    Without this patch, Linux provokes emergency disk shutdowns and
    similar nastiness. It was in SuSE kernels for some time, IIRC.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ed2b76e75199..14479325e3f3 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -103,7 +103,8 @@ extern int pm_active;
 /*
  * Register a device with power management
  */
-struct pm_dev __deprecated *pm_register(pm_dev_t type, unsigned long id, pm_callback callback);
+struct pm_dev __deprecated *
+pm_register(pm_dev_t type, unsigned long id, pm_callback callback);
 
 /*
  * Unregister a device with power management
@@ -190,17 +191,18 @@ typedef u32 __bitwise pm_message_t;
 /*
  * There are 4 important states driver can be in:
  * ON     -- driver is working
- * FREEZE -- stop operations and apply whatever policy is applicable to a suspended driver
- *           of that class, freeze queues for block like IDE does, drop packets for
- *           ethernet, etc... stop DMA engine too etc... so a consistent image can be
- *           saved; but do not power any hardware down.
- * SUSPEND - like FREEZE, but hardware is doing as much powersaving as possible. Roughly
- *           pci D3.
+ * FREEZE -- stop operations and apply whatever policy is applicable to a
+ *           suspended driver of that class, freeze queues for block like IDE
+ *           does, drop packets for ethernet, etc... stop DMA engine too etc...
+ *           so a consistent image can be saved; but do not power any hardware
+ *           down.
+ * SUSPEND - like FREEZE, but hardware is doing as much powersaving as
+ *           possible. Roughly pci D3.
  *
- * Unfortunately, current drivers only recognize numeric values 0 (ON) and 3 (SUSPEND).
- * We'll need to fix the drivers. So yes, putting 3 to all diferent defines is intentional,
- * and will go away as soon as drivers are fixed. Also note that typedef is neccessary,
- * we'll probably want to switch to
+ * Unfortunately, current drivers only recognize numeric values 0 (ON) and 3
+ * (SUSPEND).  We'll need to fix the drivers. So yes, putting 3 to all different
+ * defines is intentional, and will go away as soon as drivers are fixed.  Also
+ * note that typedef is neccessary, we'll probably want to switch to
  *   typedef struct pm_message_t { int event; int flags; } pm_message_t
  * or something similar soon.
  */
@@ -222,11 +224,18 @@ struct dev_pm_info {
 
 extern void device_pm_set_parent(struct device * dev, struct device * parent);
 
-extern int device_suspend(pm_message_t state);
 extern int device_power_down(pm_message_t state);
 extern void device_power_up(void);
 extern void device_resume(void);
 
+#ifdef CONFIG_PM
+extern int device_suspend(pm_message_t state);
+#else
+static inline int device_suspend(pm_message_t state)
+{
+	return 0;
+}
+#endif
 
 #endif /* __KERNEL__ */
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/pm.h b/include/linux/pm.h
new file mode 100644
index 000000000000..ed2b76e75199
--- /dev/null
+++ b/include/linux/pm.h
@@ -0,0 +1,233 @@
+/*
+ *  pm.h - Power management interface
+ *
+ *  Copyright (C) 2000 Andrew Henroid
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_PM_H
+#define _LINUX_PM_H
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/list.h>
+#include <asm/atomic.h>
+
+/*
+ * Power management requests... these are passed to pm_send_all() and friends.
+ *
+ * these functions are old and deprecated, see below.
+ */
+typedef int __bitwise pm_request_t;
+
+#define PM_SUSPEND	((__force pm_request_t) 1)	/* enter D1-D3 */
+#define PM_RESUME	((__force pm_request_t) 2)	/* enter D0 */
+
+
+/*
+ * Device types... these are passed to pm_register
+ */
+typedef int __bitwise pm_dev_t;
+
+#define PM_UNKNOWN_DEV	((__force pm_dev_t) 0)	/* generic */
+#define PM_SYS_DEV	((__force pm_dev_t) 1)	/* system device (fan, KB controller, ...) */
+#define PM_PCI_DEV	((__force pm_dev_t) 2)	/* PCI device */
+#define PM_USB_DEV	((__force pm_dev_t) 3)	/* USB device */
+#define PM_SCSI_DEV	((__force pm_dev_t) 4)	/* SCSI device */
+#define PM_ISA_DEV	((__force pm_dev_t) 5)	/* ISA device */
+#define	PM_MTD_DEV	((__force pm_dev_t) 6)	/* Memory Technology Device */
+
+/*
+ * System device hardware ID (PnP) values
+ */
+enum
+{
+	PM_SYS_UNKNOWN = 0x00000000, /* generic */
+	PM_SYS_KBC =	 0x41d00303, /* keyboard controller */
+	PM_SYS_COM =	 0x41d00500, /* serial port */
+	PM_SYS_IRDA =	 0x41d00510, /* IRDA controller */
+	PM_SYS_FDC =	 0x41d00700, /* floppy controller */
+	PM_SYS_VGA =	 0x41d00900, /* VGA controller */
+	PM_SYS_PCMCIA =	 0x41d00e00, /* PCMCIA controller */
+};
+
+/*
+ * Device identifier
+ */
+#define PM_PCI_ID(dev) ((dev)->bus->number << 16 | (dev)->devfn)
+
+/*
+ * Request handler callback
+ */
+struct pm_dev;
+
+typedef int (*pm_callback)(struct pm_dev *dev, pm_request_t rqst, void *data);
+
+/*
+ * Dynamic device information
+ */
+struct pm_dev
+{
+	pm_dev_t	 type;
+	unsigned long	 id;
+	pm_callback	 callback;
+	void		*data;
+
+	unsigned long	 flags;
+	unsigned long	 state;
+	unsigned long	 prev_state;
+
+	struct list_head entry;
+};
+
+#ifdef CONFIG_PM
+
+extern int pm_active;
+
+#define PM_IS_ACTIVE() (pm_active != 0)
+
+/*
+ * Register a device with power management
+ */
+struct pm_dev __deprecated *pm_register(pm_dev_t type, unsigned long id, pm_callback callback);
+
+/*
+ * Unregister a device with power management
+ */
+void __deprecated pm_unregister(struct pm_dev *dev);
+
+/*
+ * Unregister all devices with matching callback
+ */
+void __deprecated pm_unregister_all(pm_callback callback);
+
+/*
+ * Send a request to all devices
+ */
+int __deprecated pm_send_all(pm_request_t rqst, void *data);
+
+#else /* CONFIG_PM */
+
+#define PM_IS_ACTIVE() 0
+
+static inline struct pm_dev *pm_register(pm_dev_t type,
+					 unsigned long id,
+					 pm_callback callback)
+{
+	return NULL;
+}
+
+static inline void pm_unregister(struct pm_dev *dev) {}
+
+static inline void pm_unregister_all(pm_callback callback) {}
+
+static inline int pm_send_all(pm_request_t rqst, void *data)
+{
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+/* Functions above this comment are list-based old-style power
+ * managment. Please avoid using them.  */
+
+/*
+ * Callbacks for platform drivers to implement.
+ */
+extern void (*pm_idle)(void);
+extern void (*pm_power_off)(void);
+
+typedef int __bitwise suspend_state_t;
+
+#define PM_SUSPEND_ON		((__force suspend_state_t) 0)
+#define PM_SUSPEND_STANDBY	((__force suspend_state_t) 1)
+#define PM_SUSPEND_MEM		((__force suspend_state_t) 3)
+#define PM_SUSPEND_DISK		((__force suspend_state_t) 4)
+#define PM_SUSPEND_MAX		((__force suspend_state_t) 5)
+
+typedef int __bitwise suspend_disk_method_t;
+
+#define	PM_DISK_FIRMWARE	((__force suspend_disk_method_t) 1)
+#define	PM_DISK_PLATFORM	((__force suspend_disk_method_t) 2)
+#define	PM_DISK_SHUTDOWN	((__force suspend_disk_method_t) 3)
+#define	PM_DISK_REBOOT		((__force suspend_disk_method_t) 4)
+#define	PM_DISK_MAX		((__force suspend_disk_method_t) 5)
+
+struct pm_ops {
+	suspend_disk_method_t pm_disk_mode;
+	int (*prepare)(suspend_state_t state);
+	int (*enter)(suspend_state_t state);
+	int (*finish)(suspend_state_t state);
+};
+
+extern void pm_set_ops(struct pm_ops *);
+
+extern int pm_suspend(suspend_state_t state);
+
+
+/*
+ * Device power management
+ */
+
+struct device;
+
+typedef u32 __bitwise pm_message_t;
+
+/*
+ * There are 4 important states driver can be in:
+ * ON     -- driver is working
+ * FREEZE -- stop operations and apply whatever policy is applicable to a suspended driver
+ *           of that class, freeze queues for block like IDE does, drop packets for
+ *           ethernet, etc... stop DMA engine too etc... so a consistent image can be
+ *           saved; but do not power any hardware down.
+ * SUSPEND - like FREEZE, but hardware is doing as much powersaving as possible. Roughly
+ *           pci D3.
+ *
+ * Unfortunately, current drivers only recognize numeric values 0 (ON) and 3 (SUSPEND).
+ * We'll need to fix the drivers. So yes, putting 3 to all diferent defines is intentional,
+ * and will go away as soon as drivers are fixed. Also note that typedef is neccessary,
+ * we'll probably want to switch to
+ *   typedef struct pm_message_t { int event; int flags; } pm_message_t
+ * or something similar soon.
+ */
+
+#define PMSG_FREEZE	((__force pm_message_t) 3)
+#define PMSG_SUSPEND	((__force pm_message_t) 3)
+#define PMSG_ON		((__force pm_message_t) 0)
+
+struct dev_pm_info {
+	pm_message_t		power_state;
+#ifdef	CONFIG_PM
+	pm_message_t		prev_state;
+	void			* saved_state;
+	atomic_t		pm_users;
+	struct device		* pm_parent;
+	struct list_head	entry;
+#endif
+};
+
+extern void device_pm_set_parent(struct device * dev, struct device * parent);
+
+extern int device_suspend(pm_message_t state);
+extern int device_power_down(pm_message_t state);
+extern void device_power_up(void);
+extern void device_resume(void);
+
+
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_PM_H */
