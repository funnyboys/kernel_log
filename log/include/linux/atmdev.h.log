commit 9bbe60a67be5a1c6f79b3c9be5003481a50529ff
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat Jun 16 11:55:44 2018 +0100

    atm: Preserve value of skb->truesize when accounting to vcc
    
    ATM accounts for in-flight TX packets in sk_wmem_alloc of the VCC on
    which they are to be sent. But it doesn't take ownership of those
    packets from the sock (if any) which originally owned them. They should
    remain owned by their actual sender until they've left the box.
    
    There's a hack in pskb_expand_head() to avoid adjusting skb->truesize
    for certain skbs, precisely to avoid messing up sk_wmem_alloc
    accounting. Ideally that hack would cover the ATM use case too, but it
    doesn't â€” skbs which aren't owned by any sock, for example PPP control
    frames, still get their truesize adjusted when the low-level ATM driver
    adds headroom.
    
    This has always been an issue, it seems. The truesize of a packet
    increases, and sk_wmem_alloc on the VCC goes negative. But this wasn't
    for normal traffic, only for control frames. So I think we just got away
    with it, and we probably needed to send 2GiB of LCP echo frames before
    the misaccounting would ever have caused a problem and caused
    atm_may_send() to start refusing packets.
    
    Commit 14afee4b609 ("net: convert sock.sk_wmem_alloc from atomic_t to
    refcount_t") did exactly what it was intended to do, and turned this
    mostly-theoretical problem into a real one, causing PPPoATM to fail
    immediately as sk_wmem_alloc underflows and atm_may_send() *immediately*
    starts refusing to allow new packets.
    
    The least intrusive solution to this problem is to stash the value of
    skb->truesize that was accounted to the VCC, in a new member of the
    ATM_SKB(skb) structure. Then in atm_pop_raw() subtract precisely that
    value instead of the then-current value of skb->truesize.
    
    Fixes: 158f323b9868 ("net: adjust skb->truesize in pskb_expand_head()")
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Tested-by: Kevin Darbyshire-Bryant <ldir@darbyshire-bryant.me.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 0c27515d2cf6..8124815eb121 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -214,6 +214,7 @@ struct atmphy_ops {
 struct atm_skb_data {
 	struct atm_vcc	*vcc;		/* ATM VCC */
 	unsigned long	atm_options;	/* ATM layer options */
+	unsigned int	acct_truesize;  /* truesize accounted to vcc */
 };
 
 #define VCC_HTABLE_SIZE 32
@@ -241,6 +242,20 @@ void vcc_insert_socket(struct sock *sk);
 
 void atm_dev_release_vccs(struct atm_dev *dev);
 
+static inline void atm_account_tx(struct atm_vcc *vcc, struct sk_buff *skb)
+{
+	/*
+	 * Because ATM skbs may not belong to a sock (and we don't
+	 * necessarily want to), skb->truesize may be adjusted,
+	 * escaping the hack in pskb_expand_head() which avoids
+	 * doing so for some cases. So stash the value of truesize
+	 * at the time we accounted it, and atm_pop_raw() can use
+	 * that value later, in case it changes.
+	 */
+	refcount_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);
+	ATM_SKB(skb)->acct_truesize = skb->truesize;
+	ATM_SKB(skb)->atm_options = vcc->atm_options;
+}
 
 static inline void atm_force_charge(struct atm_vcc *vcc,int truesize)
 {

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 0ec9bdb1cc9f..0c27515d2cf6 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* atmdev.h - ATM device driver declarations and various related items */
 #ifndef LINUX_ATMDEV_H
 #define LINUX_ATMDEV_H

commit 458bc30cec26c2716746ae215ed23773257e417d
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 15:53:01 2017 +0300

    net, atm: convert atm_dev.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 4d97a89da066..0ec9bdb1cc9f 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -11,6 +11,7 @@
 #include <linux/uio.h>
 #include <net/sock.h>
 #include <linux/atomic.h>
+#include <linux/refcount.h>
 #include <uapi/linux/atmdev.h>
 
 #ifdef CONFIG_PROC_FS
@@ -158,7 +159,7 @@ struct atm_dev {
 	struct k_atm_dev_stats stats;	/* statistics */
 	char		signal;		/* signal status (ATM_PHY_SIG_*) */
 	int		link_rate;	/* link rate (default: OC3) */
-	atomic_t	refcnt;		/* reference count */
+	refcount_t	refcnt;		/* reference count */
 	spinlock_t	lock;		/* protect internal members */
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry *proc_entry; /* proc entry */
@@ -261,13 +262,13 @@ static inline int atm_may_send(struct atm_vcc *vcc,unsigned int size)
 
 static inline void atm_dev_hold(struct atm_dev *dev)
 {
-	atomic_inc(&dev->refcnt);
+	refcount_inc(&dev->refcnt);
 }
 
 
 static inline void atm_dev_put(struct atm_dev *dev)
 {
-	if (atomic_dec_and_test(&dev->refcnt)) {
+	if (refcount_dec_and_test(&dev->refcnt)) {
 		BUG_ON(!test_bit(ATM_DF_REMOVED, &dev->flags));
 		if (dev->ops->dev_close)
 			dev->ops->dev_close(dev);

commit 14afee4b6092fde451ee17604e5f5c89da33e71e
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Fri Jun 30 13:08:00 2017 +0300

    net: convert sock.sk_wmem_alloc from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index c1da539f5e28..4d97a89da066 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -254,7 +254,7 @@ static inline void atm_return(struct atm_vcc *vcc,int truesize)
 
 static inline int atm_may_send(struct atm_vcc *vcc,unsigned int size)
 {
-	return (size + atomic_read(&sk_atm(vcc)->sk_wmem_alloc)) <
+	return (size + refcount_read(&sk_atm(vcc)->sk_wmem_alloc)) <
 	       sk_atm(vcc)->sk_sndbuf;
 }
 

commit c971f08cba56ed17fe22040ca5ff97fe5c3f0bd7
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Wed Nov 28 00:03:11 2012 +0000

    atm: add release_cb() callback to vcc
    
    The immediate use case for this is that it will allow us to ensure that a
    pppoatm queue is woken after it has to drop a packet due to the sock being
    locked.
    
    Note that 'release_cb' is called when the socket is *unlocked*. This is
    not to be confused with vcc_release() â€” which probably ought to be called
    vcc_close().
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Krzysztof Mazur <krzysiek@podlesie.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 72db2af902a8..c1da539f5e28 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -99,6 +99,7 @@ struct atm_vcc {
 	struct atm_dev	*dev;		/* device back pointer */
 	struct atm_qos	qos;		/* QOS */
 	struct atm_sap	sap;		/* SAP */
+	void (*release_cb)(struct atm_vcc *vcc); /* release_sock callback */
 	void (*push)(struct atm_vcc *vcc,struct sk_buff *skb);
 	void (*pop)(struct atm_vcc *vcc,struct sk_buff *skb); /* optional */
 	int (*push_oam)(struct atm_vcc *vcc,void *cell);

commit ec809bd817dfa1905283468e4c813684ed4efe78
Author: Krzysztof Mazur <krzysiek@podlesie.net>
Date:   Tue Nov 6 23:16:57 2012 +0100

    atm: add owner of push() callback to atmvcc
    
    The atm is using atmvcc->push(vcc, NULL) callback to notify protocol
    that vcc will be closed and protocol must detach from it. This callback
    is usually used by protocol to decrement module usage count by module_put(),
    but it leaves small window then module is still used after module_put().
    
    Now the owner of push() callback is kept in atmvcc and
    module_put(atmvcc->owner) is called after the protocol is detached from vcc.
    
    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Chas Williams <chas@cmf.nrl.navy.mil>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 22ef21c33d0c..72db2af902a8 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -106,6 +106,7 @@ struct atm_vcc {
 	void		*dev_data;	/* per-device data */
 	void		*proto_data;	/* per-protocol data */
 	struct k_atm_aal_stats *stats;	/* pointer to AAL stats group */
+	struct module *owner;		/* owner of ->push function */
 	/* SVC part --- may move later ------------------------------------- */
 	short		itf;		/* interface number */
 	struct sockaddr_atmsvc local;

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 06fd4bbc58f6..22ef21c33d0c 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -1,218 +1,8 @@
 /* atmdev.h - ATM device driver declarations and various related items */
- 
-/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
- 
-
 #ifndef LINUX_ATMDEV_H
 #define LINUX_ATMDEV_H
 
 
-#include <linux/atmapi.h>
-#include <linux/atm.h>
-#include <linux/atmioc.h>
-
-
-#define ESI_LEN		6
-
-#define ATM_OC3_PCR	(155520000/270*260/8/53)
-			/* OC3 link rate:  155520000 bps
-			   SONET overhead: /270*260 (9 section, 1 path)
-			   bits per cell:  /8/53
-			   max cell rate:  353207.547 cells/sec */
-#define ATM_25_PCR	((25600000/8-8000)/54)
-			/* 25 Mbps ATM cell rate (59111) */
-#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
-			/* OC12 link rate: 622080000 bps
-			   SONET overhead: /1080*1040
-			   bits per cell:  /8/53
-			   max cell rate:  1412830.188 cells/sec */
-#define ATM_DS3_PCR	(8000*12)
-			/* DS3: 12 cells in a 125 usec time slot */
-
-
-#define __AAL_STAT_ITEMS \
-    __HANDLE_ITEM(tx);			/* TX okay */ \
-    __HANDLE_ITEM(tx_err);		/* TX errors */ \
-    __HANDLE_ITEM(rx);			/* RX okay */ \
-    __HANDLE_ITEM(rx_err);		/* RX errors */ \
-    __HANDLE_ITEM(rx_drop);		/* RX out of memory */
-
-struct atm_aal_stats {
-#define __HANDLE_ITEM(i) int i
-	__AAL_STAT_ITEMS
-#undef __HANDLE_ITEM
-};
-
-
-struct atm_dev_stats {
-	struct atm_aal_stats aal0;
-	struct atm_aal_stats aal34;
-	struct atm_aal_stats aal5;
-} __ATM_API_ALIGN;
-
-
-#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
-					/* get link rate */
-#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
-					/* get interface names (numbers) */
-#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
-					/* get interface type name */
-#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
-					/* get interface ESI */
-#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
-					/* get itf's local ATM addr. list */
-#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
-					/* reset itf's ATM address list */
-#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
-					/* add a local ATM address */
-#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
-					/* remove a local ATM address */
-#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
-					/* get connection identifier range */
-#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
-					/* set connection identifier range */
-#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
-					/* set interface ESI */
-#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
-					/* force interface ESI */
-#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
-					/* register a LECS address */
-#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
-					/* unregister a LECS address */
-#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
-					/* retrieve LECS address(es) */
-
-#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
-					/* get AAL layer statistics */
-#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
-					/* get AAL layer statistics and zero */
-#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
-					/* get loopback mode */
-#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
-					/* set loopback mode */
-#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
-					/* query supported loopback modes */
-#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
-					/* enable or disable single-copy */
-#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
-					/* set backend handler */
-#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
-					/* use backend to make new if */
-#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
- 					/* add party to p2mp call */
-#ifdef CONFIG_COMPAT
-/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
-#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
-#endif
-#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
-					/* drop party from p2mp call */
-
-/*
- * These are backend handkers that can be set via the ATM_SETBACKEND call
- * above.  In the future we may support dynamic loading of these - for now,
- * they're just being used to share the ATMIOC_BACKEND ioctls
- */
-#define ATM_BACKEND_RAW		0	
-#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
-#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
-
-/* for ATM_GETTYPE */
-#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
-
-/*
- * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
- */
-
-/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
-#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
-#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
-#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
-/* RESERVED		4	loop back on PHY side  ---'		      */
-#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
-#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
-
-/* Direction of loopback */
-#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
-#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */
-
-#define __ATM_LM_XTLOC(n)	((n) & 0xff)
-#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)
-
-#define ATM_LM_NONE	0	/* no loopback */
-
-#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
-#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
-#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
-#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)
-
-#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
-#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
-#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
-#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)
-
-/*
- * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
- * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
- */
-
-
-struct atm_iobuf {
-	int length;
-	void __user *buffer;
-};
-
-/* for ATM_GETCIRANGE / ATM_SETCIRANGE */
-
-#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
- 
-struct atm_cirange {
-	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
-	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
-};
-
-/* for ATM_SETSC; actually taken from the ATM_VF number space */
-
-#define ATM_SC_RX	1024		/* enable RX single-copy */
-#define ATM_SC_TX	2048		/* enable TX single-copy */
-
-#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
-				  anyway */
-
-/* MF: change_qos (Modify) flags */
-
-#define ATM_MF_IMMED	 1	/* Block until change is effective */
-#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
-#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
-#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
-#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
-#define ATM_MF_BWD	32	/* Set the backward direction parameters */
-
-#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
-			  ATM_MF_DEC_SHP | ATM_MF_BWD)
-
-/*
- * ATM_VS_* are used to express VC state in a human-friendly way.
- */
-
-#define ATM_VS_IDLE	0	/* VC is not used */
-#define ATM_VS_CONNECTED 1	/* VC is connected */
-#define ATM_VS_CLOSING	2	/* VC is closing */
-#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
-#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
-#define ATM_VS_BOUND	5	/* VC is bound */
-
-#define ATM_VS2TXT_MAP \
-    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"
-
-#define ATM_VF2TXT_MAP \
-    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
-    "RELEASED", "HASQOS",	"LISTEN",	"META", \
-    "256",	"512",		"1024",		"2048", \
-    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
-
-
-#ifdef __KERNEL__
-
 #include <linux/wait.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
 #include <linux/net.h>
@@ -221,6 +11,7 @@ struct atm_cirange {
 #include <linux/uio.h>
 #include <net/sock.h>
 #include <linux/atomic.h>
+#include <uapi/linux/atmdev.h>
 
 #ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>
@@ -521,6 +312,4 @@ void deregister_atm_ioctl(struct atm_ioctl *);
 int register_atmdevice_notifier(struct notifier_block *nb);
 void unregister_atmdevice_notifier(struct notifier_block *nb);
 
-#endif /* __KERNEL__ */
-
 #endif

commit 250f6715a4112d6686670c5a62ceb9305da94616
Merge: 11bcb32848dd 313162d0b838
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:41:37 2012 -0700

    Merge tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/device.h> avoidance patches from Paul Gortmaker:
     "Nearly every subsystem has some kind of header with a proto like:
    
            void foo(struct device *dev);
    
      and yet there is no reason for most of these guys to care about the
      sub fields within the device struct.  This allows us to significantly
      reduce the scope of headers including headers.  For this instance, a
      reduction of about 40% is achieved by replacing the include with the
      simple fact that the device is some kind of a struct.
    
      Unlike the much larger module.h cleanup, this one is simply two
      commits.  One to fix the implicit <linux/device.h> users, and then one
      to delete the device.h includes from the linux/include/ dir wherever
      possible."
    
    * tag 'device-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      device.h: audit and cleanup users in main include dir
      device.h: cleanup users outside of linux/include (C files)

commit 313162d0b83836e2f57e51b9b8650fb4b9c396ea
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 30 11:46:54 2012 -0500

    device.h: audit and cleanup users in main include dir
    
    The <linux/device.h> header includes a lot of stuff, and
    it in turn gets a lot of use just for the basic "struct device"
    which appears so often.
    
    Clean up the users as follows:
    
    1) For those headers only needing "struct device" as a pointer
    in fcn args, replace the include with exactly that.
    
    2) For headers not really using anything from device.h, simply
    delete the include altogether.
    
    3) For headers relying on getting device.h implicitly before
    being included themselves, now explicitly include device.h
    
    4) For files in which doing #1 or #2 uncovers an implicit
    dependency on some other header, fix by explicitly adding
    the required header(s).
    
    Any C files that were implicitly relying on device.h to be
    present have already been dealt with in advance.
    
    Total removals from #1 and #2: 51.  Total additions coming
    from #3: 9.  Total other implicit dependencies from #4: 7.
    
    As of 3.3-rc1, there were 110, so a net removal of 42 gives
    about a 38% reduction in device.h presence in include/*
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index f4ff882cb2da..52c940935bd1 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -213,7 +213,6 @@ struct atm_cirange {
 
 #ifdef __KERNEL__
 
-#include <linux/device.h>
 #include <linux/wait.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
 #include <linux/net.h>
@@ -249,6 +248,7 @@ struct k_atm_dev_stats {
 	struct k_atm_aal_stats aal5;
 };
 
+struct device;
 
 enum {
 	ATM_VF_ADDR,		/* Address is in use. Set by anybody, cleared

commit 187f1882b5b0748b3c4c22274663fdb372ac0452
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Nov 23 20:12:59 2011 -0500

    BUG: headers with BUG/BUG_ON etc. need linux/bug.h
    
    If a header file is making use of BUG, BUG_ON, BUILD_BUG_ON, or any
    other BUG variant in a static inline (i.e. not in a #define) then
    that header really should be including <linux/bug.h> and not just
    expecting it to be implicitly present.
    
    We can make this change risk-free, since if the files using these
    headers didn't have exposure to linux/bug.h already, they would have
    been causing compile failures/warnings.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index f4ff882cb2da..42c471afc52a 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -217,6 +217,7 @@ struct atm_cirange {
 #include <linux/wait.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
 #include <linux/net.h>
+#include <linux/bug.h>
 #include <linux/skbuff.h> /* struct sk_buff */
 #include <linux/uio.h>
 #include <net/sock.h>

commit 49f5ed4250c757cb19d953fcac2737a35ca14d76
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Tue Nov 22 12:51:56 2011 +0000

    atm: eliminate atm_guess_pdu2truesize()
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 43ea1b2de3ee..f4ff882cb2da 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -445,16 +445,6 @@ void vcc_insert_socket(struct sock *sk);
 
 void atm_dev_release_vccs(struct atm_dev *dev);
 
-/*
- * This is approximately the algorithm used by alloc_skb.
- *
- */
-
-static inline int atm_guess_pdu2truesize(int size)
-{
-	return SKB_TRUESIZE(size);
-}
-
 
 static inline void atm_force_charge(struct atm_vcc *vcc,int truesize)
 {

commit 570e57bcbcc4df5581b1e9c806ab2b16e96ea7d3
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon Nov 21 19:51:34 2011 +0000

    atm: use SKB_TRUESIZE() in atm_guess_pdu2truesize()
    
    SKB_TRUESIZE() provides a better approximation of expected skb truesize.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 49a83ca900ba..43ea1b2de3ee 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -452,7 +452,7 @@ void atm_dev_release_vccs(struct atm_dev *dev);
 
 static inline int atm_guess_pdu2truesize(int size)
 {
-	return SKB_DATA_ALIGN(size) + sizeof(struct skb_shared_info);
+	return SKB_TRUESIZE(size);
 }
 
 

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 381f4cec8260..49a83ca900ba 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -220,7 +220,7 @@ struct atm_cirange {
 #include <linux/skbuff.h> /* struct sk_buff */
 #include <linux/uio.h>
 #include <net/sock.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 #ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>

commit c031235b395433350f25943b7580a5e343c7b7b2
Author: Philip A. Prindeville <philipp@redfish-solutions.com>
Date:   Wed Mar 30 13:17:04 2011 +0000

    atm/solos-pci: Don't flap VCs when carrier state changes
    
    Don't flap VCs when carrier state changes; higher-level protocols
    can detect loss of connectivity and act accordingly. This is more
    consistent with how other network interfaces work.
    
    We no longer use release_vccs() so we can delete it.
    
    release_vccs() was duplicated from net/atm/common.c; make the
    corresponding function exported, since other code duplicates it
    and could leverage it if it were public.
    
    Signed-off-by: Philip A. Prindeville <philipp@redfish-solutions.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 475f8c42c0e9..381f4cec8260 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -443,6 +443,7 @@ void atm_dev_signal_change(struct atm_dev *dev, char signal);
 
 void vcc_insert_socket(struct sock *sk);
 
+void atm_dev_release_vccs(struct atm_dev *dev);
 
 /*
  * This is approximately the algorithm used by alloc_skb.

commit d9ca676bcb26e1fdff9265a3e70f697cd381c889
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Dec 8 19:40:47 2010 +0000

    atm: correct sysfs 'device' link creation and parent relationships
    
    The ATM subsystem was incorrectly creating the 'device' link for ATM
    nodes in sysfs.  This led to incorrect device/parent relationships
    exposed by sysfs and udev.  Instead of rolling the 'device' link by hand
    in the generic ATM code, pass each ATM driver's bus device down to the
    sysfs code and let sysfs do this stuff correctly.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index a8e4e832cdbb..475f8c42c0e9 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -427,8 +427,10 @@ extern rwlock_t vcc_sklist_lock;
 
 #define ATM_SKB(skb) (((struct atm_skb_data *) (skb)->cb))
 
-struct atm_dev *atm_dev_register(const char *type,const struct atmdev_ops *ops,
-    int number,unsigned long *flags); /* number == -1: pick first available */
+struct atm_dev *atm_dev_register(const char *type, struct device *parent,
+				 const struct atmdev_ops *ops,
+				 int number, /* -1 == pick first available */
+				 unsigned long *flags);
 struct atm_dev *atm_dev_lookup(int number);
 void atm_dev_deregister(struct atm_dev *dev);
 

commit a02cec2155fbea457eca8881870fd2de1a4c4c76
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Sep 22 20:43:57 2010 +0000

    net: return operator cleanup
    
    Change "return (EXPR);" to "return EXPR;"
    
    return is not a function, parentheses are not required.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index f6481daf6e52..a8e4e832cdbb 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -449,7 +449,7 @@ void vcc_insert_socket(struct sock *sk);
 
 static inline int atm_guess_pdu2truesize(int size)
 {
-	return (SKB_DATA_ALIGN(size) + sizeof(struct skb_shared_info));
+	return SKB_DATA_ALIGN(size) + sizeof(struct skb_shared_info);
 }
 
 

commit 7313bb8f3dd6e28bcf9c42adfd54a5cf9a4949e0
Author: Karl Hiramoto <karl@hiramoto.org>
Date:   Thu Jul 8 20:55:30 2010 +0000

    atm: propagate signal changes via notifier
    
    Add notifier chain for changes in atm_dev.
    
    Clients like br2684 will call register_atmdevice_notifier() to be notified of
    changes. Drivers will call atm_dev_signal_change() to notify clients like
    br2684 of the change.
    
    On DSL and ATM devices it's usefull to have a know if you have a carrier
    signal. netdevice LOWER_UP changes can be propagated to userspace via netlink
    monitor.
    
    Signed-off-by: Karl Hiramoto <karl@hiramoto.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 817b23705c91..f6481daf6e52 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -431,6 +431,14 @@ struct atm_dev *atm_dev_register(const char *type,const struct atmdev_ops *ops,
     int number,unsigned long *flags); /* number == -1: pick first available */
 struct atm_dev *atm_dev_lookup(int number);
 void atm_dev_deregister(struct atm_dev *dev);
+
+/* atm_dev_signal_change
+ *
+ * Propagate lower layer signal change in atm_dev->signal to netdevice.
+ * The event will be sent via a notifier call chain.
+ */
+void atm_dev_signal_change(struct atm_dev *dev, char signal);
+
 void vcc_insert_socket(struct sock *sk);
 
 
@@ -510,6 +518,15 @@ void register_atm_ioctl(struct atm_ioctl *);
  */
 void deregister_atm_ioctl(struct atm_ioctl *);
 
+
+/* register_atmdevice_notifier - register atm_dev notify events
+ *
+ * Clients like br2684 will register notify events
+ * Currently we notify of signal found/lost
+ */
+int register_atmdevice_notifier(struct notifier_block *nb);
+void unregister_atmdevice_notifier(struct notifier_block *nb);
+
 #endif /* __KERNEL__ */
 
 #endif

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 086e5c362d3a..817b23705c91 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -397,7 +397,7 @@ struct atmdev_ops { /* only send is required */
 	int (*getsockopt)(struct atm_vcc *vcc,int level,int optname,
 	    void __user *optval,int optlen);
 	int (*setsockopt)(struct atm_vcc *vcc,int level,int optname,
-	    void __user *optval,int optlen);
+	    void __user *optval,unsigned int optlen);
 	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
 	int (*send_oam)(struct atm_vcc *vcc,void *cell,int flags);
 	void (*phy_put)(struct atm_dev *dev,unsigned char value,

commit 8865c418caf4e9dd2c24bdfae3a5a4106e143e60
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Wed Dec 3 22:12:38 2008 -0800

    atm: 32-bit ioctl compatibility
    
    We lack compat ioctl support through most of the ATM code. This patch
    deals with most of it, and I can now at least use BR2684 and PPPoATM
    with 32-bit userspace.
    
    I haven't added a .compat_ioctl method to struct atm_ioctl, because
    AFAICT none of the current users need any conversion -- so we can just
    call the ->ioctl() method in every case. I looked at br2684, clip, lec,
    mpc, pppoatm and atmtcp.
    
    In svc_compat_ioctl() the only mangling which is needed is to change
    COMPAT_ATM_ADDPARTY to ATM_ADDPARTY. Although it's defined as
            _IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
    it doesn't actually _take_ a struct atm_iobuf as an argument -- it takes
    a struct sockaddr_atmsvc, which _is_ the same between 32-bit and 64-bit
    code, so doesn't need conversion.
    
    Almost all of vcc_ioctl() would have been identical, so I converted that
    into a core do_vcc_ioctl() function with an 'int compat' argument.
    
    I've done the same with atm_dev_ioctl(), where there _are_ a few
    differences, but still it's relatively contained and there would
    otherwise have been a lot of duplication.
    
    I haven't done any of the actual device-specific ioctls, although I've
    added a compat_ioctl method to struct atmdev_ops.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index a3d07c29d16c..086e5c362d3a 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -100,6 +100,10 @@ struct atm_dev_stats {
 					/* use backend to make new if */
 #define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
  					/* add party to p2mp call */
+#ifdef CONFIG_COMPAT
+/* It actually takes struct sockaddr_atmsvc, not struct atm_iobuf */
+#define COMPAT_ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct compat_atm_iobuf)
+#endif
 #define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
 					/* drop party from p2mp call */
 
@@ -224,6 +228,13 @@ struct atm_cirange {
 extern struct proc_dir_entry *atm_proc_root;
 #endif
 
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+struct compat_atm_iobuf {
+	int length;
+	compat_uptr_t buffer;
+};
+#endif
 
 struct k_atm_aal_stats {
 #define __HANDLE_ITEM(i) atomic_t i
@@ -379,6 +390,10 @@ struct atmdev_ops { /* only send is required */
 	int (*open)(struct atm_vcc *vcc);
 	void (*close)(struct atm_vcc *vcc);
 	int (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);
+#ifdef CONFIG_COMPAT
+	int (*compat_ioctl)(struct atm_dev *dev,unsigned int cmd,
+			    void __user *arg);
+#endif
 	int (*getsockopt)(struct atm_vcc *vcc,int level,int optname,
 	    void __user *optval,int optlen);
 	int (*setsockopt)(struct atm_vcc *vcc,int level,int optname,

commit ef39592f786b6d56d9faf988a3f18786eeb050b3
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Dec 30 23:16:06 2007 -0800

    [ATM]: Convert struct class_device to struct device
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 2096e5c72827..a3d07c29d16c 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -359,7 +359,7 @@ struct atm_dev {
 	struct proc_dir_entry *proc_entry; /* proc entry */
 	char *proc_name;		/* proc entry name */
 #endif
-	struct class_device class_dev;	/* sysfs class device */
+	struct device class_dev;	/* sysfs device */
 	struct list_head dev_list;	/* linkage */
 };
 
@@ -461,7 +461,7 @@ static inline void atm_dev_put(struct atm_dev *dev)
 		BUG_ON(!test_bit(ATM_DF_REMOVED, &dev->flags));
 		if (dev->ops->dev_close)
 			dev->ops->dev_close(dev);
-		class_device_put(&dev->class_dev);
+		put_device(&dev->class_dev);
 	}
 }
 

commit bb98ad77d8451a3ccf9478738ffe7ec63394fcdf
Author: Ismail Donmez <ismail@pardus.org.tr>
Date:   Wed Sep 6 00:03:44 2006 -0700

    [PATCH] Move linux/device.h include in linux/atmdev.h to #ifdef __KERNEL__ section
    
    linux/device.h header is not included in the David Woodhouse's
    kernel-headers git tree which is used for userspace kernel headers.  Which
    results in compile errors when building iproute2.  Attached patch moves
    linux/device.h include under the #ifdef __KERNEL__ section.
    
    Signed-off-by: Ismail Donmez <ismail@pardus.org.tr>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 41788a31c438..2096e5c72827 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -7,7 +7,6 @@
 #define LINUX_ATMDEV_H
 
 
-#include <linux/device.h>
 #include <linux/atmapi.h>
 #include <linux/atm.h>
 #include <linux/atmioc.h>
@@ -210,6 +209,7 @@ struct atm_cirange {
 
 #ifdef __KERNEL__
 
+#include <linux/device.h>
 #include <linux/wait.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
 #include <linux/net.h>

commit 656d98b09d57d4e1185c5d2436a42600d48fbcb5
Author: Roman Kagan <rkagan@mail.ru>
Date:   Thu Jun 29 12:36:34 2006 -0700

    [ATM]: basic sysfs support for ATM devices
    
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 1eb238affb12..41788a31c438 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -7,6 +7,7 @@
 #define LINUX_ATMDEV_H
 
 
+#include <linux/device.h>
 #include <linux/atmapi.h>
 #include <linux/atm.h>
 #include <linux/atmioc.h>
@@ -358,6 +359,7 @@ struct atm_dev {
 	struct proc_dir_entry *proc_entry; /* proc entry */
 	char *proc_name;		/* proc entry name */
 #endif
+	struct class_device class_dev;	/* sysfs class device */
 	struct list_head dev_list;	/* linkage */
 };
 
@@ -459,7 +461,7 @@ static inline void atm_dev_put(struct atm_dev *dev)
 		BUG_ON(!test_bit(ATM_DF_REMOVED, &dev->flags));
 		if (dev->ops->dev_close)
 			dev->ops->dev_close(dev);
-		kfree(dev);
+		class_device_put(&dev->class_dev);
 	}
 }
 

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index b203ea82a0a8..1eb238affb12 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -209,7 +209,6 @@ struct atm_cirange {
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/wait.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
 #include <linux/net.h>

commit 64bf69ddff7637b7ed7acf9b2a823cc0ee519439
Author: Stanislaw Gruszka <stf_xl@wp.pl>
Date:   Tue Nov 29 16:16:41 2005 -0800

    [ATM]: deregistration removes device from atm_devs list immediately
    
    atm_dev_deregister() removes device from atm_dev list immediately to
    prevent operations on a phantom device.  Decision to free device based
    only on ->refcnt  now. Remove shutdown_atm_dev() use atm_dev_deregister()
    instead.  atm_dev_deregister() also asynchronously releases all vccs
    related to device.
    
    Signed-off-by: Stanislaw Gruszka <stf_xl@wp.pl>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 8fadb073c834..b203ea82a0a8 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -274,7 +274,7 @@ enum {
 
 
 enum {
-	ATM_DF_CLOSE,		/* close device when last VCC is closed */
+	ATM_DF_REMOVED,		/* device was removed from atm_devs list */
 };
 
 
@@ -415,7 +415,6 @@ struct atm_dev *atm_dev_register(const char *type,const struct atmdev_ops *ops,
     int number,unsigned long *flags); /* number == -1: pick first available */
 struct atm_dev *atm_dev_lookup(int number);
 void atm_dev_deregister(struct atm_dev *dev);
-void shutdown_atm_dev(struct atm_dev *dev);
 void vcc_insert_socket(struct sock *sk);
 
 
@@ -457,11 +456,12 @@ static inline void atm_dev_hold(struct atm_dev *dev)
 
 static inline void atm_dev_put(struct atm_dev *dev)
 {
-	atomic_dec(&dev->refcnt);
-
-	if ((atomic_read(&dev->refcnt) == 1) &&
-	    test_bit(ATM_DF_CLOSE,&dev->flags))
-		shutdown_atm_dev(dev);
+	if (atomic_dec_and_test(&dev->refcnt)) {
+		BUG_ON(!test_bit(ATM_DF_REMOVED, &dev->flags));
+		if (dev->ops->dev_close)
+			dev->ops->dev_close(dev);
+		kfree(dev);
+	}
 }
 
 

commit 5045b6d34c6a9efa4a8a1815265ca9fcf44d6a7c
Author: Chas Williams <chas@cmf.nrl.navy.mil>
Date:   Tue Nov 29 16:15:38 2005 -0800

    [ATM]: linux/config.h only needed for #ifdef __KERNEL__ section
    
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 37e5ee485399..8fadb073c834 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -7,7 +7,6 @@
 #define LINUX_ATMDEV_H
 
 
-#include <linux/config.h>
 #include <linux/atmapi.h>
 #include <linux/atm.h>
 #include <linux/atmioc.h>
@@ -210,6 +209,7 @@ struct atm_cirange {
 
 #ifdef __KERNEL__
 
+#include <linux/config.h>
 #include <linux/wait.h> /* wait_queue_head_t */
 #include <linux/time.h> /* struct timeval */
 #include <linux/net.h>

commit c219750b2e667f4f79f4d8faca5057dad793db87
Author: Mitchell Blank Jr <mitch@sfgoth.com>
Date:   Tue Nov 29 16:13:55 2005 -0800

    [ATM]: atm_pcr_goal() doesn't modify its argument's contents -- mark it as const
    
    Signed-off-by: Mitchell Blank Jr <mitch@sfgoth.com>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index e7d0593bb576..37e5ee485399 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -468,7 +468,7 @@ static inline void atm_dev_put(struct atm_dev *dev)
 int atm_charge(struct atm_vcc *vcc,int truesize);
 struct sk_buff *atm_alloc_charge(struct atm_vcc *vcc,int pdu_size,
     gfp_t gfp_flags);
-int atm_pcr_goal(struct atm_trafprm *tp);
+int atm_pcr_goal(const struct atm_trafprm *tp);
 
 void vcc_release_async(struct atm_vcc *vcc, int reply);
 

commit dd0fc66fb33cd610bc1a5db8a5e232d34879b4d7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Oct 7 07:46:04 2005 +0100

    [PATCH] gfp flags annotations - part 1
    
     - added typedef unsigned int __nocast gfp_t;
    
     - replaced __nocast uses for gfp flags with gfp_t - it gives exactly
       the same warnings as far as sparse is concerned, doesn't change
       generated code (from gcc point of view we replaced unsigned int with
       typedef) and documents what's going on far better.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index aca9b344bd35..e7d0593bb576 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -467,7 +467,7 @@ static inline void atm_dev_put(struct atm_dev *dev)
 
 int atm_charge(struct atm_vcc *vcc,int truesize);
 struct sk_buff *atm_alloc_charge(struct atm_vcc *vcc,int pdu_size,
-    unsigned int __nocast gfp_flags);
+    gfp_t gfp_flags);
 int atm_pcr_goal(struct atm_trafprm *tp);
 
 void vcc_release_async(struct atm_vcc *vcc, int reply);

commit 0f21ba7cc3320d33459ecb3f538f1a42040c29cd
Author: Eric Kinzie <ekinzie@cmf.nrl.navy.mil>
Date:   Thu Oct 6 22:19:28 2005 -0700

    [ATM]: add support for LECS addresses learned from network
    
    From: Eric Kinzie <ekinzie@cmf.nrl.navy.mil>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index f1fd849e5535..aca9b344bd35 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -76,6 +76,13 @@ struct atm_dev_stats {
 					/* set interface ESI */
 #define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
 					/* force interface ESI */
+#define ATM_ADDLECSADDR	_IOW('a', ATMIOC_ITF+14, struct atmif_sioc)
+					/* register a LECS address */
+#define ATM_DELLECSADDR	_IOW('a', ATMIOC_ITF+15, struct atmif_sioc)
+					/* unregister a LECS address */
+#define ATM_GETLECSADDR	_IOW('a', ATMIOC_ITF+16, struct atmif_sioc)
+					/* retrieve LECS address(es) */
+
 #define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
 					/* get AAL layer statistics */
 #define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
@@ -328,6 +335,8 @@ struct atm_dev_addr {
 	struct list_head entry;		/* next address */
 };
 
+enum atm_addr_type_t { ATM_ADDR_LOCAL, ATM_ADDR_LECS };
+
 struct atm_dev {
 	const struct atmdev_ops *ops;	/* device operations; NULL if unused */
 	const struct atmphy_ops *phy;	/* PHY operations, may be undefined */
@@ -338,6 +347,7 @@ struct atm_dev {
 	void		*phy_data;	/* private PHY date */
 	unsigned long	flags;		/* device flags (ATM_DF_*) */
 	struct list_head local;		/* local ATM addresses */
+	struct list_head lecs;		/* LECS ATM addresses learned via ILMI */
 	unsigned char	esi[ESI_LEN];	/* ESI ("MAC" addr) */
 	struct atm_cirange ci_range;	/* VPI/VCI range */
 	struct k_atm_dev_stats stats;	/* statistics */

commit 7b5b3f3d826ea87c224c66de9c95c09e7f110ecd
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Tue Oct 4 22:38:44 2005 -0700

    [ATM]: fix sparse gfp nocast warnings
    
    Fix implicit nocast warnings in atm code:
    net/atm/atm_misc.c:35:44: warning: implicit cast to nocast type
    drivers/atm/fore200e.c:183:33: warning: implicit cast to nocast type
    
    Also use kzalloc() instead of kmalloc().
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
index 9f374cfa1b05..f1fd849e5535 100644
--- a/include/linux/atmdev.h
+++ b/include/linux/atmdev.h
@@ -457,7 +457,7 @@ static inline void atm_dev_put(struct atm_dev *dev)
 
 int atm_charge(struct atm_vcc *vcc,int truesize);
 struct sk_buff *atm_alloc_charge(struct atm_vcc *vcc,int pdu_size,
-    int gfp_flags);
+    unsigned int __nocast gfp_flags);
 int atm_pcr_goal(struct atm_trafprm *tp);
 
 void vcc_release_async(struct atm_vcc *vcc, int reply);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/atmdev.h b/include/linux/atmdev.h
new file mode 100644
index 000000000000..9f374cfa1b05
--- /dev/null
+++ b/include/linux/atmdev.h
@@ -0,0 +1,489 @@
+/* atmdev.h - ATM device driver declarations and various related items */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+ 
+
+#ifndef LINUX_ATMDEV_H
+#define LINUX_ATMDEV_H
+
+
+#include <linux/config.h>
+#include <linux/atmapi.h>
+#include <linux/atm.h>
+#include <linux/atmioc.h>
+
+
+#define ESI_LEN		6
+
+#define ATM_OC3_PCR	(155520000/270*260/8/53)
+			/* OC3 link rate:  155520000 bps
+			   SONET overhead: /270*260 (9 section, 1 path)
+			   bits per cell:  /8/53
+			   max cell rate:  353207.547 cells/sec */
+#define ATM_25_PCR	((25600000/8-8000)/54)
+			/* 25 Mbps ATM cell rate (59111) */
+#define ATM_OC12_PCR	(622080000/1080*1040/8/53)
+			/* OC12 link rate: 622080000 bps
+			   SONET overhead: /1080*1040
+			   bits per cell:  /8/53
+			   max cell rate:  1412830.188 cells/sec */
+#define ATM_DS3_PCR	(8000*12)
+			/* DS3: 12 cells in a 125 usec time slot */
+
+
+#define __AAL_STAT_ITEMS \
+    __HANDLE_ITEM(tx);			/* TX okay */ \
+    __HANDLE_ITEM(tx_err);		/* TX errors */ \
+    __HANDLE_ITEM(rx);			/* RX okay */ \
+    __HANDLE_ITEM(rx_err);		/* RX errors */ \
+    __HANDLE_ITEM(rx_drop);		/* RX out of memory */
+
+struct atm_aal_stats {
+#define __HANDLE_ITEM(i) int i
+	__AAL_STAT_ITEMS
+#undef __HANDLE_ITEM
+};
+
+
+struct atm_dev_stats {
+	struct atm_aal_stats aal0;
+	struct atm_aal_stats aal34;
+	struct atm_aal_stats aal5;
+} __ATM_API_ALIGN;
+
+
+#define ATM_GETLINKRATE	_IOW('a',ATMIOC_ITF+1,struct atmif_sioc)
+					/* get link rate */
+#define ATM_GETNAMES	_IOW('a',ATMIOC_ITF+3,struct atm_iobuf)
+					/* get interface names (numbers) */
+#define ATM_GETTYPE	_IOW('a',ATMIOC_ITF+4,struct atmif_sioc)
+					/* get interface type name */
+#define ATM_GETESI	_IOW('a',ATMIOC_ITF+5,struct atmif_sioc)
+					/* get interface ESI */
+#define ATM_GETADDR	_IOW('a',ATMIOC_ITF+6,struct atmif_sioc)
+					/* get itf's local ATM addr. list */
+#define ATM_RSTADDR	_IOW('a',ATMIOC_ITF+7,struct atmif_sioc)
+					/* reset itf's ATM address list */
+#define ATM_ADDADDR	_IOW('a',ATMIOC_ITF+8,struct atmif_sioc)
+					/* add a local ATM address */
+#define ATM_DELADDR	_IOW('a',ATMIOC_ITF+9,struct atmif_sioc)
+					/* remove a local ATM address */
+#define ATM_GETCIRANGE	_IOW('a',ATMIOC_ITF+10,struct atmif_sioc)
+					/* get connection identifier range */
+#define ATM_SETCIRANGE	_IOW('a',ATMIOC_ITF+11,struct atmif_sioc)
+					/* set connection identifier range */
+#define ATM_SETESI	_IOW('a',ATMIOC_ITF+12,struct atmif_sioc)
+					/* set interface ESI */
+#define ATM_SETESIF	_IOW('a',ATMIOC_ITF+13,struct atmif_sioc)
+					/* force interface ESI */
+#define ATM_GETSTAT	_IOW('a',ATMIOC_SARCOM+0,struct atmif_sioc)
+					/* get AAL layer statistics */
+#define ATM_GETSTATZ	_IOW('a',ATMIOC_SARCOM+1,struct atmif_sioc)
+					/* get AAL layer statistics and zero */
+#define ATM_GETLOOP	_IOW('a',ATMIOC_SARCOM+2,struct atmif_sioc)
+					/* get loopback mode */
+#define ATM_SETLOOP	_IOW('a',ATMIOC_SARCOM+3,struct atmif_sioc)
+					/* set loopback mode */
+#define ATM_QUERYLOOP	_IOW('a',ATMIOC_SARCOM+4,struct atmif_sioc)
+					/* query supported loopback modes */
+#define ATM_SETSC	_IOW('a',ATMIOC_SPECIAL+1,int)
+					/* enable or disable single-copy */
+#define ATM_SETBACKEND	_IOW('a',ATMIOC_SPECIAL+2,atm_backend_t)
+					/* set backend handler */
+#define ATM_NEWBACKENDIF _IOW('a',ATMIOC_SPECIAL+3,atm_backend_t)
+					/* use backend to make new if */
+#define ATM_ADDPARTY  	_IOW('a', ATMIOC_SPECIAL+4,struct atm_iobuf)
+ 					/* add party to p2mp call */
+#define ATM_DROPPARTY 	_IOW('a', ATMIOC_SPECIAL+5,int)
+					/* drop party from p2mp call */
+
+/*
+ * These are backend handkers that can be set via the ATM_SETBACKEND call
+ * above.  In the future we may support dynamic loading of these - for now,
+ * they're just being used to share the ATMIOC_BACKEND ioctls
+ */
+#define ATM_BACKEND_RAW		0	
+#define ATM_BACKEND_PPP		1	/* PPPoATM - RFC2364 */
+#define ATM_BACKEND_BR2684	2	/* Bridged RFC1483/2684 */
+
+/* for ATM_GETTYPE */
+#define ATM_ITFTYP_LEN	8	/* maximum length of interface type name */
+
+/*
+ * Loopback modes for ATM_{PHY,SAR}_{GET,SET}LOOP
+ */
+
+/* Point of loopback				CPU-->SAR-->PHY-->line--> ... */
+#define __ATM_LM_NONE	0	/* no loop back     ^     ^     ^      ^      */
+#define __ATM_LM_AAL	1	/* loop back PDUs --'     |     |      |      */
+#define __ATM_LM_ATM	2	/* loop back ATM cells ---'     |      |      */
+/* RESERVED		4	loop back on PHY side  ---'		      */
+#define __ATM_LM_PHY	8	/* loop back bits (digital) ----'      |      */
+#define __ATM_LM_ANALOG 16	/* loop back the analog signal --------'      */
+
+/* Direction of loopback */
+#define __ATM_LM_MKLOC(n)	((n))	    /* Local (i.e. loop TX to RX) */
+#define __ATM_LM_MKRMT(n)	((n) << 8)  /* Remote (i.e. loop RX to TX) */
+
+#define __ATM_LM_XTLOC(n)	((n) & 0xff)
+#define __ATM_LM_XTRMT(n)	(((n) >> 8) & 0xff)
+
+#define ATM_LM_NONE	0	/* no loopback */
+
+#define ATM_LM_LOC_AAL	__ATM_LM_MKLOC(__ATM_LM_AAL)
+#define ATM_LM_LOC_ATM	__ATM_LM_MKLOC(__ATM_LM_ATM)
+#define ATM_LM_LOC_PHY	__ATM_LM_MKLOC(__ATM_LM_PHY)
+#define ATM_LM_LOC_ANALOG __ATM_LM_MKLOC(__ATM_LM_ANALOG)
+
+#define ATM_LM_RMT_AAL	__ATM_LM_MKRMT(__ATM_LM_AAL)
+#define ATM_LM_RMT_ATM	__ATM_LM_MKRMT(__ATM_LM_ATM)
+#define ATM_LM_RMT_PHY	__ATM_LM_MKRMT(__ATM_LM_PHY)
+#define ATM_LM_RMT_ANALOG __ATM_LM_MKRMT(__ATM_LM_ANALOG)
+
+/*
+ * Note: ATM_LM_LOC_* and ATM_LM_RMT_* can be combined, provided that
+ * __ATM_LM_XTLOC(x) <= __ATM_LM_XTRMT(x)
+ */
+
+
+struct atm_iobuf {
+	int length;
+	void __user *buffer;
+};
+
+/* for ATM_GETCIRANGE / ATM_SETCIRANGE */
+
+#define ATM_CI_MAX      -1              /* use maximum range of VPI/VCI */
+ 
+struct atm_cirange {
+	signed char	vpi_bits;	/* 1..8, ATM_CI_MAX (-1) for maximum */
+	signed char	vci_bits;	/* 1..16, ATM_CI_MAX (-1) for maximum */
+};
+
+/* for ATM_SETSC; actually taken from the ATM_VF number space */
+
+#define ATM_SC_RX	1024		/* enable RX single-copy */
+#define ATM_SC_TX	2048		/* enable TX single-copy */
+
+#define ATM_BACKLOG_DEFAULT 32 /* if we get more, we're likely to time out
+				  anyway */
+
+/* MF: change_qos (Modify) flags */
+
+#define ATM_MF_IMMED	 1	/* Block until change is effective */
+#define ATM_MF_INC_RSV	 2	/* Change reservation on increase */
+#define ATM_MF_INC_SHP	 4	/* Change shaping on increase */
+#define ATM_MF_DEC_RSV	 8	/* Change reservation on decrease */
+#define ATM_MF_DEC_SHP	16	/* Change shaping on decrease */
+#define ATM_MF_BWD	32	/* Set the backward direction parameters */
+
+#define ATM_MF_SET	(ATM_MF_INC_RSV | ATM_MF_INC_SHP | ATM_MF_DEC_RSV | \
+			  ATM_MF_DEC_SHP | ATM_MF_BWD)
+
+/*
+ * ATM_VS_* are used to express VC state in a human-friendly way.
+ */
+
+#define ATM_VS_IDLE	0	/* VC is not used */
+#define ATM_VS_CONNECTED 1	/* VC is connected */
+#define ATM_VS_CLOSING	2	/* VC is closing */
+#define ATM_VS_LISTEN	3	/* VC is listening for incoming setups */
+#define ATM_VS_INUSE	4	/* VC is in use (registered with atmsigd) */
+#define ATM_VS_BOUND	5	/* VC is bound */
+
+#define ATM_VS2TXT_MAP \
+    "IDLE", "CONNECTED", "CLOSING", "LISTEN", "INUSE", "BOUND"
+
+#define ATM_VF2TXT_MAP \
+    "ADDR",	"READY",	"PARTIAL",	"REGIS", \
+    "RELEASED", "HASQOS",	"LISTEN",	"META", \
+    "256",	"512",		"1024",		"2048", \
+    "SESSION",	"HASSAP",	"BOUND",	"CLOSE"
+
+
+#ifdef __KERNEL__
+
+#include <linux/wait.h> /* wait_queue_head_t */
+#include <linux/time.h> /* struct timeval */
+#include <linux/net.h>
+#include <linux/skbuff.h> /* struct sk_buff */
+#include <linux/uio.h>
+#include <net/sock.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+
+extern struct proc_dir_entry *atm_proc_root;
+#endif
+
+
+struct k_atm_aal_stats {
+#define __HANDLE_ITEM(i) atomic_t i
+	__AAL_STAT_ITEMS
+#undef __HANDLE_ITEM
+};
+
+
+struct k_atm_dev_stats {
+	struct k_atm_aal_stats aal0;
+	struct k_atm_aal_stats aal34;
+	struct k_atm_aal_stats aal5;
+};
+
+
+enum {
+	ATM_VF_ADDR,		/* Address is in use. Set by anybody, cleared
+				   by device driver. */
+	ATM_VF_READY,		/* VC is ready to transfer data. Set by device
+				   driver, cleared by anybody. */
+	ATM_VF_PARTIAL,		/* resources are bound to PVC (partial PVC
+				   setup), controlled by socket layer */
+	ATM_VF_REGIS,		/* registered with demon, controlled by SVC
+				   socket layer */
+	ATM_VF_BOUND,		/* local SAP is set, controlled by SVC socket
+				   layer */
+	ATM_VF_RELEASED,	/* demon has indicated/requested release,
+				   controlled by SVC socket layer */
+	ATM_VF_HASQOS,		/* QOS parameters have been set */
+	ATM_VF_LISTEN,		/* socket is used for listening */
+	ATM_VF_META,		/* SVC socket isn't used for normal data
+				   traffic and doesn't depend on signaling
+				   to be available */
+	ATM_VF_SESSION,		/* VCC is p2mp session control descriptor */
+	ATM_VF_HASSAP,		/* SAP has been set */
+	ATM_VF_CLOSE,		/* asynchronous close - treat like VF_RELEASED*/
+	ATM_VF_WAITING,		/* waiting for reply from sigd */
+	ATM_VF_IS_CLIP,		/* in use by CLIP protocol */
+};
+
+
+#define ATM_VF2VS(flags) \
+    (test_bit(ATM_VF_READY,&(flags)) ? ATM_VS_CONNECTED : \
+     test_bit(ATM_VF_RELEASED,&(flags)) ? ATM_VS_CLOSING : \
+     test_bit(ATM_VF_LISTEN,&(flags)) ? ATM_VS_LISTEN : \
+     test_bit(ATM_VF_REGIS,&(flags)) ? ATM_VS_INUSE : \
+     test_bit(ATM_VF_BOUND,&(flags)) ? ATM_VS_BOUND : ATM_VS_IDLE)
+
+
+enum {
+	ATM_DF_CLOSE,		/* close device when last VCC is closed */
+};
+
+
+#define ATM_PHY_SIG_LOST    0	/* no carrier/light */
+#define ATM_PHY_SIG_UNKNOWN 1	/* carrier/light status is unknown */
+#define ATM_PHY_SIG_FOUND   2	/* carrier/light okay */
+
+#define ATM_ATMOPT_CLP	1	/* set CLP bit */
+
+struct atm_vcc {
+	/* struct sock has to be the first member of atm_vcc */
+	struct sock	sk;
+	unsigned long	flags;		/* VCC flags (ATM_VF_*) */
+	short		vpi;		/* VPI and VCI (types must be equal */
+					/* with sockaddr) */
+	int 		vci;
+	unsigned long	aal_options;	/* AAL layer options */
+	unsigned long	atm_options;	/* ATM layer options */
+	struct atm_dev	*dev;		/* device back pointer */
+	struct atm_qos	qos;		/* QOS */
+	struct atm_sap	sap;		/* SAP */
+	void (*push)(struct atm_vcc *vcc,struct sk_buff *skb);
+	void (*pop)(struct atm_vcc *vcc,struct sk_buff *skb); /* optional */
+	int (*push_oam)(struct atm_vcc *vcc,void *cell);
+	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
+	void		*dev_data;	/* per-device data */
+	void		*proto_data;	/* per-protocol data */
+	struct k_atm_aal_stats *stats;	/* pointer to AAL stats group */
+	/* SVC part --- may move later ------------------------------------- */
+	short		itf;		/* interface number */
+	struct sockaddr_atmsvc local;
+	struct sockaddr_atmsvc remote;
+	/* Multipoint part ------------------------------------------------- */
+	struct atm_vcc	*session;	/* session VCC descriptor */
+	/* Other stuff ----------------------------------------------------- */
+	void		*user_back;	/* user backlink - not touched by */
+					/* native ATM stack. Currently used */
+					/* by CLIP and sch_atm. */
+};
+
+static inline struct atm_vcc *atm_sk(struct sock *sk)
+{
+	return (struct atm_vcc *)sk;
+}
+
+static inline struct atm_vcc *ATM_SD(struct socket *sock)
+{
+	return atm_sk(sock->sk);
+}
+
+static inline struct sock *sk_atm(struct atm_vcc *vcc)
+{
+	return (struct sock *)vcc;
+}
+
+struct atm_dev_addr {
+	struct sockaddr_atmsvc addr;	/* ATM address */
+	struct list_head entry;		/* next address */
+};
+
+struct atm_dev {
+	const struct atmdev_ops *ops;	/* device operations; NULL if unused */
+	const struct atmphy_ops *phy;	/* PHY operations, may be undefined */
+					/* (NULL) */
+	const char	*type;		/* device type name */
+	int		number;		/* device index */
+	void		*dev_data;	/* per-device data */
+	void		*phy_data;	/* private PHY date */
+	unsigned long	flags;		/* device flags (ATM_DF_*) */
+	struct list_head local;		/* local ATM addresses */
+	unsigned char	esi[ESI_LEN];	/* ESI ("MAC" addr) */
+	struct atm_cirange ci_range;	/* VPI/VCI range */
+	struct k_atm_dev_stats stats;	/* statistics */
+	char		signal;		/* signal status (ATM_PHY_SIG_*) */
+	int		link_rate;	/* link rate (default: OC3) */
+	atomic_t	refcnt;		/* reference count */
+	spinlock_t	lock;		/* protect internal members */
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc_entry; /* proc entry */
+	char *proc_name;		/* proc entry name */
+#endif
+	struct list_head dev_list;	/* linkage */
+};
+
+ 
+/* OF: send_Oam Flags */
+
+#define ATM_OF_IMMED  1		/* Attempt immediate delivery */
+#define ATM_OF_INRATE 2		/* Attempt in-rate delivery */
+
+
+/*
+ * ioctl, getsockopt, and setsockopt are optional and can be set to NULL.
+ */
+
+struct atmdev_ops { /* only send is required */
+	void (*dev_close)(struct atm_dev *dev);
+	int (*open)(struct atm_vcc *vcc);
+	void (*close)(struct atm_vcc *vcc);
+	int (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);
+	int (*getsockopt)(struct atm_vcc *vcc,int level,int optname,
+	    void __user *optval,int optlen);
+	int (*setsockopt)(struct atm_vcc *vcc,int level,int optname,
+	    void __user *optval,int optlen);
+	int (*send)(struct atm_vcc *vcc,struct sk_buff *skb);
+	int (*send_oam)(struct atm_vcc *vcc,void *cell,int flags);
+	void (*phy_put)(struct atm_dev *dev,unsigned char value,
+	    unsigned long addr);
+	unsigned char (*phy_get)(struct atm_dev *dev,unsigned long addr);
+	int (*change_qos)(struct atm_vcc *vcc,struct atm_qos *qos,int flags);
+	int (*proc_read)(struct atm_dev *dev,loff_t *pos,char *page);
+	struct module *owner;
+};
+
+struct atmphy_ops {
+	int (*start)(struct atm_dev *dev);
+	int (*ioctl)(struct atm_dev *dev,unsigned int cmd,void __user *arg);
+	void (*interrupt)(struct atm_dev *dev);
+	int (*stop)(struct atm_dev *dev);
+};
+
+struct atm_skb_data {
+	struct atm_vcc	*vcc;		/* ATM VCC */
+	unsigned long	atm_options;	/* ATM layer options */
+};
+
+#define VCC_HTABLE_SIZE 32
+
+extern struct hlist_head vcc_hash[VCC_HTABLE_SIZE];
+extern rwlock_t vcc_sklist_lock;
+
+#define ATM_SKB(skb) (((struct atm_skb_data *) (skb)->cb))
+
+struct atm_dev *atm_dev_register(const char *type,const struct atmdev_ops *ops,
+    int number,unsigned long *flags); /* number == -1: pick first available */
+struct atm_dev *atm_dev_lookup(int number);
+void atm_dev_deregister(struct atm_dev *dev);
+void shutdown_atm_dev(struct atm_dev *dev);
+void vcc_insert_socket(struct sock *sk);
+
+
+/*
+ * This is approximately the algorithm used by alloc_skb.
+ *
+ */
+
+static inline int atm_guess_pdu2truesize(int size)
+{
+	return (SKB_DATA_ALIGN(size) + sizeof(struct skb_shared_info));
+}
+
+
+static inline void atm_force_charge(struct atm_vcc *vcc,int truesize)
+{
+	atomic_add(truesize, &sk_atm(vcc)->sk_rmem_alloc);
+}
+
+
+static inline void atm_return(struct atm_vcc *vcc,int truesize)
+{
+	atomic_sub(truesize, &sk_atm(vcc)->sk_rmem_alloc);
+}
+
+
+static inline int atm_may_send(struct atm_vcc *vcc,unsigned int size)
+{
+	return (size + atomic_read(&sk_atm(vcc)->sk_wmem_alloc)) <
+	       sk_atm(vcc)->sk_sndbuf;
+}
+
+
+static inline void atm_dev_hold(struct atm_dev *dev)
+{
+	atomic_inc(&dev->refcnt);
+}
+
+
+static inline void atm_dev_put(struct atm_dev *dev)
+{
+	atomic_dec(&dev->refcnt);
+
+	if ((atomic_read(&dev->refcnt) == 1) &&
+	    test_bit(ATM_DF_CLOSE,&dev->flags))
+		shutdown_atm_dev(dev);
+}
+
+
+int atm_charge(struct atm_vcc *vcc,int truesize);
+struct sk_buff *atm_alloc_charge(struct atm_vcc *vcc,int pdu_size,
+    int gfp_flags);
+int atm_pcr_goal(struct atm_trafprm *tp);
+
+void vcc_release_async(struct atm_vcc *vcc, int reply);
+
+struct atm_ioctl {
+	struct module *owner;
+	/* A module reference is kept if appropriate over this call.
+	 * Return -ENOIOCTLCMD if you don't handle it. */
+	int (*ioctl)(struct socket *, unsigned int cmd, unsigned long arg);
+	struct list_head list;
+};
+
+/**
+ * register_atm_ioctl - register handler for ioctl operations
+ *
+ * Special (non-device) handlers of ioctl's should
+ * register here. If you're a normal device, you should
+ * set .ioctl in your atmdev_ops instead.
+ */
+void register_atm_ioctl(struct atm_ioctl *);
+
+/**
+ * deregister_atm_ioctl - remove the ioctl handler
+ */
+void deregister_atm_ioctl(struct atm_ioctl *);
+
+#endif /* __KERNEL__ */
+
+#endif
