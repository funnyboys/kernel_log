commit b1b11d0063aab28aaf65f63cff56470bc01dc290
Merge: 1bfde037425d 775802c0571f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 10 09:45:15 2020 -0700

    Merge tag 'cleanup-kernel_read_write' of git://git.infradead.org/users/hch/misc
    
    Pull in-kernel read and write op cleanups from Christoph Hellwig:
     "Cleanup in-kernel read and write operations
    
      Reshuffle the (__)kernel_read and (__)kernel_write helpers, and ensure
      all users of in-kernel file I/O use them if they don't use iov_iter
      based methods already.
    
      The new WARN_ONs in combination with syzcaller already found a missing
      input validation in 9p. The fix should be on your way through the
      maintainer ASAP".
    
    [ This is prep-work for the real changes coming 5.9 ]
    
    * tag 'cleanup-kernel_read_write' of git://git.infradead.org/users/hch/misc:
      fs: remove __vfs_read
      fs: implement kernel_read using __kernel_read
      integrity/ima: switch to using __kernel_read
      fs: add a __kernel_read helper
      fs: remove __vfs_write
      fs: implement kernel_write using __kernel_write
      fs: check FMODE_WRITE in __kernel_write
      fs: unexport __kernel_write
      bpfilter: switch to kernel_write
      autofs: switch to kernel_write
      cachefiles: switch to kernel_write

commit 775802c0571fb438cd4f6548a323f9e4cb89f5aa
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 8 11:17:46 2020 +0200

    fs: remove __vfs_read
    
    Fold it into the two callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 22cbe7b2e919..0c0ec76b600b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1917,7 +1917,6 @@ ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      struct iovec *fast_pointer,
 			      struct iovec **ret_pointer);
 
-extern ssize_t __vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,

commit 61a707c543e2afe3aa7e88f87267c5dafa4b5afa
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri May 8 08:54:16 2020 +0200

    fs: add a __kernel_read helper
    
    This is the counterpart to __kernel_write, and skip the rw_verify_area
    call compared to kernel_read.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f881a892ea7..22cbe7b2e919 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3033,6 +3033,7 @@ extern int kernel_read_file_from_path_initns(const char *, void **, loff_t *, lo
 extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
 				    enum kernel_read_file_id);
 extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);
+ssize_t __kernel_read(struct file *file, void *buf, size_t count, loff_t *pos);
 extern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);
 extern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);
 extern struct file * open_exec(const char *);

commit 41da51bce36f44eefc1e3d0f47d18841cbd065ba
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Nov 21 23:25:07 2019 +0000

    fs: Add IOCB_NOIO flag for generic_file_read_iter
    
    Add an IOCB_NOIO flag that indicates to generic_file_read_iter that it
    shouldn't trigger any filesystem I/O for the actual request or for
    readahead.  This allows to do tentative reads out of the page cache as
    some filesystems allow, and to take the appropriate locks and retry the
    reads only if the requested pages are not cached.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f881a892ea7..4b7cb76e5837 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -315,6 +315,7 @@ enum rw_hint {
 #define IOCB_SYNC		(1 << 5)
 #define IOCB_WRITE		(1 << 6)
 #define IOCB_NOWAIT		(1 << 7)
+#define IOCB_NOIO		(1 << 9)
 
 struct kiocb {
 	struct file		*ki_filp;

commit 3373a3461aa15b7f9a871fa4cb2c9ef21ac20b47
Author: Zheng Bin <zhengbin13@huawei.com>
Date:   Thu Jun 18 12:21:38 2020 +0800

    block: make function 'kill_bdev' static
    
    kill_bdev does not have any external user, so make it static.
    
    Signed-off-by: Zheng Bin <zhengbin13@huawei.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c4ab4dc1cd7..3f881a892ea7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2592,7 +2592,6 @@ extern void bdput(struct block_device *);
 extern void invalidate_bdev(struct block_device *);
 extern void iterate_bdevs(void (*)(struct block_device *, void *), void *);
 extern int sync_blockdev(struct block_device *bdev);
-extern void kill_bdev(struct block_device *);
 extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern void emergency_thaw_bdev(struct super_block *sb);
@@ -2608,7 +2607,6 @@ static inline bool sb_is_blkdev_sb(struct super_block *sb)
 #else
 static inline void bd_forget(struct inode *inode) {}
 static inline int sync_blockdev(struct block_device *bdev) { return 0; }
-static inline void kill_bdev(struct block_device *bdev) {}
 static inline void invalidate_bdev(struct block_device *bdev) {}
 
 static inline struct super_block *freeze_bdev(struct block_device *sb)

commit 9d645db853a4cd1b7077931491d0055602d3d420
Merge: 96144c58abe7 55e20bd12a56
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 14 09:47:25 2020 -0700

    Merge tag 'for-5.8-part2-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs updates from David Sterba:
     "This reverts the direct io port to iomap infrastructure of btrfs
      merged in the first pull request. We found problems in invalidate page
      that don't seem to be fixable as regressions or without changing iomap
      code that would not affect other filesystems.
    
      There are four reverts in total, but three of them are followup
      cleanups needed to revert a43a67a2d715 cleanly. The result is the
      buffer head based implementation of direct io.
    
      Reverts are not great, but under current circumstances I don't see
      better options"
    
    * tag 'for-5.8-part2-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux:
      Revert "btrfs: switch to iomap_dio_rw() for dio"
      Revert "fs: remove dio_end_io()"
      Revert "btrfs: remove BTRFS_INODE_READDIO_NEED_LOCK"
      Revert "btrfs: split btrfs_direct_IO to read and write part"

commit c742b63473b3c5180db8b5d74fdbd56e4371dfa2
Merge: b29482fde649 1eb2f96d0bff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 11 10:33:13 2020 -0700

    Merge tag 'nfsd-5.8' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Highlights:
    
       - Keep nfsd clients from unnecessarily breaking their own
         delegations.
    
         Note this requires a small kthreadd addition. The result is Tejun
         Heo's suggestion (see link), and he was OK with this going through
         my tree.
    
       - Patch nfsd/clients/ to display filenames, and to fix byte-order
         when displaying stateid's.
    
       - fix a module loading/unloading bug, from Neil Brown.
    
       - A big series from Chuck Lever with RPC/RDMA and tracing
         improvements, and lay some groundwork for RPC-over-TLS"
    
    Link: https://lore.kernel.org/r/1588348912-24781-1-git-send-email-bfields@redhat.com
    
    * tag 'nfsd-5.8' of git://linux-nfs.org/~bfields/linux: (49 commits)
      sunrpc: use kmemdup_nul() in gssp_stringify()
      nfsd: safer handling of corrupted c_type
      nfsd4: make drc_slab global, not per-net
      SUNRPC: Remove unreachable error condition in rpcb_getport_async()
      nfsd: Fix svc_xprt refcnt leak when setup callback client failed
      sunrpc: clean up properly in gss_mech_unregister()
      sunrpc: svcauth_gss_register_pseudoflavor must reject duplicate registrations.
      sunrpc: check that domain table is empty at module unload.
      NFSD: Fix improperly-formatted Doxygen comments
      NFSD: Squash an annoying compiler warning
      SUNRPC: Clean up request deferral tracepoints
      NFSD: Add tracepoints for monitoring NFSD callbacks
      NFSD: Add tracepoints to the NFSD state management code
      NFSD: Add tracepoints to NFSD's duplicate reply cache
      SUNRPC: svc_show_status() macro should have enum definitions
      SUNRPC: Restructure svc_udp_recvfrom()
      SUNRPC: Refactor svc_recvfrom()
      SUNRPC: Clean up svc_release_skb() functions
      SUNRPC: Refactor recvfrom path dealing with incomplete TCP receives
      SUNRPC: Replace dprintk() call sites in TCP receive path
      ...

commit 52435c86bf0f5c892804912481af7f1a5b95ff2d
Merge: 4964dd29140a 2068cf7dfbc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 9 15:40:50 2020 -0700

    Merge tag 'ovl-update-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "Fixes:
    
       - Resolve mount option conflicts consistently
    
       - Sync before remount R/O
    
       - Fix file handle encoding corner cases
    
       - Fix metacopy related issues
    
       - Fix an unintialized return value
    
       - Add missing permission checks for underlying layers
    
      Optimizations:
    
       - Allow multipe whiteouts to share an inode
    
       - Optimize small writes by inheriting SB_NOSEC from upper layer
    
       - Do not call ->syncfs() multiple times for sync(2)
    
       - Do not cache negative lookups on upper layer
    
       - Make private internal mounts longterm"
    
    * tag 'ovl-update-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (27 commits)
      ovl: remove unnecessary lock check
      ovl: make oip->index bool
      ovl: only pass ->ki_flags to ovl_iocb_to_rwf()
      ovl: make private mounts longterm
      ovl: get rid of redundant members in struct ovl_fs
      ovl: add accessor for ofs->upper_mnt
      ovl: initialize error in ovl_copy_xattr
      ovl: drop negative dentry in upper layer
      ovl: check permission to open real file
      ovl: call secutiry hook in ovl_real_ioctl()
      ovl: verify permissions in ovl_path_open()
      ovl: switch to mounter creds in readdir
      ovl: pass correct flags for opening real directory
      ovl: fix redirect traversal on metacopy dentries
      ovl: initialize OVL_UPPERDATA in ovl_lookup()
      ovl: use only uppermetacopy state in ovl_lookup()
      ovl: simplify setting of origin for index lookup
      ovl: fix out of bounds access warning in ovl_check_fb_len()
      ovl: return required buffer size for file handles
      ovl: sync dirty data when remounting to ro mode
      ...

commit f1084bc60a1ec592011a805a0f925f2f1205897d
Author: David Sterba <dsterba@suse.com>
Date:   Tue Jun 9 19:22:47 2020 +0200

    Revert "fs: remove dio_end_io()"
    
    This reverts commit b75b7ca7c27dfd61dba368f390b7d4dc20b3a8cb.
    
    The patch restores a helper that was not necessary after direct IO port
    to iomap infrastructure, which gets reverted.
    
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e84623d5e173..366c533d30cd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3187,6 +3187,8 @@ enum {
 	DIO_SKIP_HOLES	= 0x02,
 };
 
+void dio_end_io(struct bio *bio);
+
 ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
 			     struct block_device *bdev, struct iov_iter *iter,
 			     get_block_t get_block,

commit c1e8d7c6a7a682e1405e3e242d32fc377fd196ff
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Jun 8 21:33:54 2020 -0700

    mmap locking API: convert mmap_sem comments
    
    Convert comments that reference mmap_sem to reference mmap_lock instead.
    
    [akpm@linux-foundation.org: fix up linux-next leftovers]
    [akpm@linux-foundation.org: s/lockaphore/lock/, per Vlastimil]
    [akpm@linux-foundation.org: more linux-next fixups, per Michel]
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Reviewed-by: Daniel Jordan <daniel.m.jordan@oracle.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Hubbard <jhubbard@nvidia.com>
    Cc: Laurent Dufour <ldufour@linux.ibm.com>
    Cc: Liam Howlett <Liam.Howlett@oracle.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ying Han <yinghan@google.com>
    Link: http://lkml.kernel.org/r/20200520052908.204642-13-walken@google.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 01f5d296f9bb..0b026329dbed 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1679,10 +1679,10 @@ static inline int sb_start_write_trylock(struct super_block *sb)
  *
  * Since page fault freeze protection behaves as a lock, users have to preserve
  * ordering of freeze protection and other filesystem locks. It is advised to
- * put sb_start_pagefault() close to mmap_sem in lock ordering. Page fault
+ * put sb_start_pagefault() close to mmap_lock in lock ordering. Page fault
  * handling code implies lock dependency:
  *
- * mmap_sem
+ * mmap_lock
  *   -> sb_start_pagefault
  */
 static inline void sb_start_pagefault(struct super_block *sb)

commit 9daa0a27a0bce6596be287fb1df372ff80bb1087
Merge: 0b166a57e622 8409f67b6437
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 5 16:26:36 2020 -0700

    Merge tag 'afs-next-20200604' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull AFS updates from David Howells:
     "There's some core VFS changes which affect a couple of filesystems:
    
       - Make the inode hash table RCU safe and providing some RCU-safe
         accessor functions. The search can then be done without taking the
         inode_hash_lock. Care must be taken because the object may be being
         deleted and no wait is made.
    
       - Allow iunique() to avoid taking the inode_hash_lock.
    
       - Allow AFS's callback processing to avoid taking the inode_hash_lock
         when using the inode table to find an inode to notify.
    
       - Improve Ext4's time updating. Konstantin Khlebnikov said "For now,
         I've plugged this issue with try-lock in ext4 lazy time update.
         This solution is much better."
    
      Then there's a set of changes to make a number of improvements to the
      AFS driver:
    
       - Improve callback (ie. third party change notification) processing
         by:
    
          (a) Relying more on the fact we're doing this under RCU and by
              using fewer locks. This makes use of the RCU-based inode
              searching outlined above.
    
          (b) Moving to keeping volumes in a tree indexed by volume ID
              rather than a flat list.
    
          (c) Making the server and volume records logically part of the
              cell. This means that a server record now points directly at
              the cell and the tree of volumes is there. This removes an N:M
              mapping table, simplifying things.
    
       - Improve keeping NAT or firewall channels open for the server
         callbacks to reach the client by actively polling the fileserver on
         a timed basis, instead of only doing it when we have an operation
         to process.
    
       - Improving detection of delayed or lost callbacks by including the
         parent directory in the list of file IDs to be queried when doing a
         bulk status fetch from lookup. We can then check to see if our copy
         of the directory has changed under us without us getting notified.
    
       - Determine aliasing of cells (such as a cell that is pointed to be a
         DNS alias). This allows us to avoid having ambiguity due to
         apparently different cells using the same volume and file servers.
    
       - Improve the fileserver rotation to do more probing when it detects
         that all of the addresses to a server are listed as non-responsive.
         It's possible that an address that previously stopped responding
         has become responsive again.
    
      Beyond that, lay some foundations for making some calls asynchronous:
    
       - Turn the fileserver cursor struct into a general operation struct
         and hang the parameters off of that rather than keeping them in
         local variables and hang results off of that rather than the call
         struct.
    
       - Implement some general operation handling code and simplify the
         callers of operations that affect a volume or a volume component
         (such as a file). Most of the operation is now done by core code.
    
       - Operations are supplied with a table of operations to issue
         different variants of RPCs and to manage the completion, where all
         the required data is held in the operation object, thereby allowing
         these to be called from a workqueue.
    
       - Put the standard "if (begin), while(select), call op, end" sequence
         into a canned function that just emulates the current behaviour for
         now.
    
      There are also some fixes interspersed:
    
       - Don't let the EACCES from ICMP6 mapping reach the user as such,
         since it's confusing as to whether it's a filesystem error. Convert
         it to EHOSTUNREACH.
    
       - Don't use the epoch value acquired through probing a server. If we
         have two servers with the same UUID but in different cells, it's
         hard to draw conclusions from them having different epoch values.
    
       - Don't interpret the argument to the CB.ProbeUuid RPC as a
         fileserver UUID and look up a fileserver from it.
    
       - Deal with servers in different cells having the same UUIDs. In the
         event that a CB.InitCallBackState3 RPC is received, we have to
         break the callback promises for every server record matching that
         UUID.
    
       - Don't let afs_statfs return values that go below 0.
    
       - Don't use running fileserver probe state to make server selection
         and address selection decisions on. Only make decisions on final
         state as the running state is cleared at the start of probing"
    
    Acked-by: Al Viro <viro@zeniv.linux.org.uk> (fs/inode.c part)
    
    * tag 'afs-next-20200604' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs: (27 commits)
      afs: Adjust the fileserver rotation algorithm to reprobe/retry more quickly
      afs: Show more a bit more server state in /proc/net/afs/servers
      afs: Don't use probe running state to make decisions outside probe code
      afs: Fix afs_statfs() to not let the values go below zero
      afs: Fix the by-UUID server tree to allow servers with the same UUID
      afs: Reorganise volume and server trees to be rooted on the cell
      afs: Add a tracepoint to track the lifetime of the afs_volume struct
      afs: Detect cell aliases 3 - YFS Cells with a canonical cell name op
      afs: Detect cell aliases 2 - Cells with no root volumes
      afs: Detect cell aliases 1 - Cells with root volumes
      afs: Implement client support for the YFSVL.GetCellName RPC op
      afs: Retain more of the VLDB record for alias detection
      afs: Fix handling of CB.ProbeUuid cache manager op
      afs: Don't get epoch from a server because it may be ambiguous
      afs: Build an abstraction around an "operation" concept
      afs: Rename struct afs_fs_cursor to afs_operation
      afs: Remove the error argument from afs_protocol_error()
      afs: Set error flag rather than return error from file status decode
      afs: Make callback processing more efficient.
      afs: Show more information in /proc/net/afs/servers
      ...

commit 0b166a57e6222666292a481b742af92b50c3ba50
Merge: b25c6644bfd3 6b8ed62008a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 5 16:19:28 2020 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "A lot of bug fixes and cleanups for ext4, including:
    
       - Fix performance problems found in dioread_nolock now that it is the
         default, caused by transaction leaks.
    
       - Clean up fiemap handling in ext4
    
       - Clean up and refactor multiple block allocator (mballoc) code
    
       - Fix a problem with mballoc with a smaller file systems running out
         of blocks because they couldn't properly use blocks that had been
         reserved by inode preallocation.
    
       - Fixed a race in ext4_sync_parent() versus rename()
    
       - Simplify the error handling in the extent manipulation code
    
       - Make sure all metadata I/O errors are felected to
         ext4_ext_dirty()'s and ext4_make_inode_dirty()'s callers.
    
       - Avoid passing an error pointer to brelse in ext4_xattr_set()
    
       - Fix race which could result to freeing an inode on the dirty last
         in data=journal mode.
    
       - Fix refcount handling if ext4_iget() fails
    
       - Fix a crash in generic/019 caused by a corrupted extent node"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (58 commits)
      ext4: avoid unnecessary transaction starts during writeback
      ext4: don't block for O_DIRECT if IOCB_NOWAIT is set
      ext4: remove the access_ok() check in ext4_ioctl_get_es_cache
      fs: remove the access_ok() check in ioctl_fiemap
      fs: handle FIEMAP_FLAG_SYNC in fiemap_prep
      fs: move fiemap range validation into the file systems instances
      iomap: fix the iomap_fiemap prototype
      fs: move the fiemap definitions out of fs.h
      fs: mark __generic_block_fiemap static
      ext4: remove the call to fiemap_check_flags in ext4_fiemap
      ext4: split _ext4_fiemap
      ext4: fix fiemap size checks for bitmap files
      ext4: fix EXT4_MAX_LOGICAL_BLOCK macro
      add comment for ext4_dir_entry_2 file_type member
      jbd2: avoid leaking transaction credits when unreserving handle
      ext4: drop ext4_journal_free_reserved()
      ext4: mballoc: use lock for checking free blocks while retrying
      ext4: mballoc: refactor ext4_mb_good_group()
      ext4: mballoc: introduce pcpu seqcnt for freeing PA to improve ENOSPC handling
      ext4: mballoc: refactor ext4_mb_discard_preallocations()
      ...

commit 10c5db286452b8c60e8f58e9a4c1cbc5a91e4e5b
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat May 23 09:30:11 2020 +0200

    fs: move the fiemap definitions out of fs.h
    
    No need to pull the fiemap definitions into almost every file in the
    kernel build.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Ritesh Harjani <riteshh@linux.ibm.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Link: https://lore.kernel.org/r/20200523073016.2944131-5-hch@lst.de
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3104c6f7527b..09bcd329c062 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -24,7 +24,6 @@
 #include <linux/capability.h>
 #include <linux/semaphore.h>
 #include <linux/fcntl.h>
-#include <linux/fiemap.h>
 #include <linux/rculist_bl.h>
 #include <linux/atomic.h>
 #include <linux/shrinker.h>
@@ -48,6 +47,7 @@ struct backing_dev_info;
 struct bdi_writeback;
 struct bio;
 struct export_operations;
+struct fiemap_extent_info;
 struct hd_geometry;
 struct iovec;
 struct kiocb;
@@ -1745,19 +1745,6 @@ extern long compat_ptr_ioctl(struct file *file, unsigned int cmd,
 extern void inode_init_owner(struct inode *inode, const struct inode *dir,
 			umode_t mode);
 extern bool may_open_dev(const struct path *path);
-/*
- * VFS FS_IOC_FIEMAP helper definitions.
- */
-struct fiemap_extent_info {
-	unsigned int fi_flags;		/* Flags as passed from user */
-	unsigned int fi_extents_mapped;	/* Number of mapped extents */
-	unsigned int fi_extents_max;	/* Size of fiemap_extent array */
-	struct fiemap_extent __user *fi_extents_start; /* Start of
-							fiemap_extent array */
-};
-int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
-			    u64 phys, u64 len, u32 flags);
-int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
 
 /*
  * This is the "filldir" function type, used by readdir() to let
@@ -3299,10 +3286,6 @@ static inline int vfs_fstat(int fd, struct kstat *stat)
 extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
 extern int vfs_readlink(struct dentry *, char __user *, int);
 
-extern int generic_block_fiemap(struct inode *inode,
-				struct fiemap_extent_info *fieinfo, u64 start,
-				u64 len, get_block_t *get_block);
-
 extern struct file_system_type *get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);

commit 44ebcd06bbb3ab3ee446b933800aca32fc4ca9b1
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat May 23 09:30:10 2020 +0200

    fs: mark __generic_block_fiemap static
    
    There is no caller left outside of ioctl.c.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Ritesh Harjani <riteshh@linux.ibm.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Link: https://lore.kernel.org/r/20200523073016.2944131-4-hch@lst.de
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..3104c6f7527b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3299,10 +3299,6 @@ static inline int vfs_fstat(int fd, struct kstat *stat)
 extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
 extern int vfs_readlink(struct dentry *, char __user *, int);
 
-extern int __generic_block_fiemap(struct inode *inode,
-				  struct fiemap_extent_info *fieinfo,
-				  loff_t start, loff_t len,
-				  get_block_t *get_block);
 extern int generic_block_fiemap(struct inode *inode,
 				struct fiemap_extent_info *fieinfo, u64 start,
 				u64 len, get_block_t *get_block);

commit cb8e59cc87201af93dfbb6c3dccc8fcad72a09c2
Merge: 2e63f6ce7ed2 065fcfd49763
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 3 16:27:18 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next
    
    Pull networking updates from David Miller:
    
     1) Allow setting bluetooth L2CAP modes via socket option, from Luiz
        Augusto von Dentz.
    
     2) Add GSO partial support to igc, from Sasha Neftin.
    
     3) Several cleanups and improvements to r8169 from Heiner Kallweit.
    
     4) Add IF_OPER_TESTING link state and use it when ethtool triggers a
        device self-test. From Andrew Lunn.
    
     5) Start moving away from custom driver versions, use the globally
        defined kernel version instead, from Leon Romanovsky.
    
     6) Support GRO vis gro_cells in DSA layer, from Alexander Lobakin.
    
     7) Allow hard IRQ deferral during NAPI, from Eric Dumazet.
    
     8) Add sriov and vf support to hinic, from Luo bin.
    
     9) Support Media Redundancy Protocol (MRP) in the bridging code, from
        Horatiu Vultur.
    
    10) Support netmap in the nft_nat code, from Pablo Neira Ayuso.
    
    11) Allow UDPv6 encapsulation of ESP in the ipsec code, from Sabrina
        Dubroca. Also add ipv6 support for espintcp.
    
    12) Lots of ReST conversions of the networking documentation, from Mauro
        Carvalho Chehab.
    
    13) Support configuration of ethtool rxnfc flows in bcmgenet driver,
        from Doug Berger.
    
    14) Allow to dump cgroup id and filter by it in inet_diag code, from
        Dmitry Yakunin.
    
    15) Add infrastructure to export netlink attribute policies to
        userspace, from Johannes Berg.
    
    16) Several optimizations to sch_fq scheduler, from Eric Dumazet.
    
    17) Fallback to the default qdisc if qdisc init fails because otherwise
        a packet scheduler init failure will make a device inoperative. From
        Jesper Dangaard Brouer.
    
    18) Several RISCV bpf jit optimizations, from Luke Nelson.
    
    19) Correct the return type of the ->ndo_start_xmit() method in several
        drivers, it's netdev_tx_t but many drivers were using
        'int'. From Yunjian Wang.
    
    20) Add an ethtool interface for PHY master/slave config, from Oleksij
        Rempel.
    
    21) Add BPF iterators, from Yonghang Song.
    
    22) Add cable test infrastructure, including ethool interfaces, from
        Andrew Lunn. Marvell PHY driver is the first to support this
        facility.
    
    23) Remove zero-length arrays all over, from Gustavo A. R. Silva.
    
    24) Calculate and maintain an explicit frame size in XDP, from Jesper
        Dangaard Brouer.
    
    25) Add CAP_BPF, from Alexei Starovoitov.
    
    26) Support terse dumps in the packet scheduler, from Vlad Buslov.
    
    27) Support XDP_TX bulking in dpaa2 driver, from Ioana Ciornei.
    
    28) Add devm_register_netdev(), from Bartosz Golaszewski.
    
    29) Minimize qdisc resets, from Cong Wang.
    
    30) Get rid of kernel_getsockopt and kernel_setsockopt in order to
        eliminate set_fs/get_fs calls. From Christoph Hellwig.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next: (2517 commits)
      selftests: net: ip_defrag: ignore EPERM
      net_failover: fixed rollback in net_failover_open()
      Revert "tipc: Fix potential tipc_aead refcnt leak in tipc_crypto_rcv"
      Revert "tipc: Fix potential tipc_node refcnt leak in tipc_rcv"
      vmxnet3: allow rx flow hash ops only when rss is enabled
      hinic: add set_channels ethtool_ops support
      selftests/bpf: Add a default $(CXX) value
      tools/bpf: Don't use $(COMPILE.c)
      bpf, selftests: Use bpf_probe_read_kernel
      s390/bpf: Use bcr 0,%0 as tail call nop filler
      s390/bpf: Maintain 8-byte stack alignment
      selftests/bpf: Fix verifier test
      selftests/bpf: Fix sample_cnt shared between two threads
      bpf, selftests: Adapt cls_redirect to call csum_level helper
      bpf: Add csum_level helper for fixing up csum levels
      bpf: Fix up bpf_skb_adjust_room helper's skb csum setting
      sfc: add missing annotation for efx_ef10_try_update_nic_stats_vf()
      crypto/chtls: IPv6 support for inline TLS
      Crypto/chcr: Fixes a coccinile check error
      Crypto/chcr: Fixes compilations warnings
      ...

commit f3cdc8ae116e27d84e1f33c7a2995960cebb73ac
Merge: 8eeae5bae123 2166e5edce9a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 19:59:25 2020 -0700

    Merge tag 'for-5.8-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux
    
    Pull btrfs updates from David Sterba:
     "Highlights:
    
       - speedup dead root detection during orphan cleanup, eg. when there
         are many deleted subvolumes waiting to be cleaned, the trees are
         now looked up in radix tree instead of a O(N^2) search
    
       - snapshot creation with inherited qgroup will mark the qgroup
         inconsistent, requires a rescan
    
       - send will emit file capabilities after chown, this produces a
         stream that does not need postprocessing to set the capabilities
         again
    
       - direct io ported to iomap infrastructure, cleaned up and simplified
         code, notably removing last use of struct buffer_head in btrfs code
    
      Core changes:
    
       - factor out backreference iteration, to be used by ordinary
         backreferences and relocation code
    
       - improved global block reserve utilization
          * better logic to serialize requests
          * increased maximum available for unlink
          * improved handling on large pages (64K)
    
       - direct io cleanups and fixes
          * simplify layering, where cloned bios were unnecessarily created
            for some cases
          * error handling fixes (submit, endio)
          * remove repair worker thread, used to avoid deadlocks during
            repair
    
       - refactored block group reading code, preparatory work for new type
         of block group storage that should improve mount time on large
         filesystems
    
      Cleanups:
    
       - cleaned up (and slightly sped up) set/get helpers for metadata data
         structure members
    
       - root bit REF_COWS got renamed to SHAREABLE to reflect the that the
         blocks of the tree get shared either among subvolumes or with the
         relocation trees
    
      Fixes:
    
       - when subvolume deletion fails due to ENOSPC, the filesystem is not
         turned read-only
    
       - device scan deals with devices from other filesystems that changed
         ownership due to overwrite (mkfs)
    
       - fix a race between scrub and block group removal/allocation
    
       - fix long standing bug of a runaway balance operation, printing the
         same line to the syslog, caused by a stale status bit on a reloc
         tree that prevented progress
    
       - fix corrupt log due to concurrent fsync of inodes with shared
         extents
    
       - fix space underflow for NODATACOW and buffered writes when it for
         some reason needs to fallback to COW mode"
    
    * tag 'for-5.8-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux: (133 commits)
      btrfs: fix space_info bytes_may_use underflow during space cache writeout
      btrfs: fix space_info bytes_may_use underflow after nocow buffered write
      btrfs: fix wrong file range cleanup after an error filling dealloc range
      btrfs: remove redundant local variable in read_block_for_search
      btrfs: open code key_search
      btrfs: split btrfs_direct_IO to read and write part
      btrfs: remove BTRFS_INODE_READDIO_NEED_LOCK
      fs: remove dio_end_io()
      btrfs: switch to iomap_dio_rw() for dio
      iomap: remove lockdep_assert_held()
      iomap: add a filesystem hook for direct I/O bio submission
      fs: export generic_file_buffered_read()
      btrfs: turn space cache writeout failure messages into debug messages
      btrfs: include error on messages about failure to write space/inode caches
      btrfs: remove useless 'fail_unlock' label from btrfs_csum_file_blocks()
      btrfs: do not ignore error from btrfs_next_leaf() when inserting checksums
      btrfs: make checksum item extension more efficient
      btrfs: fix corrupt log due to concurrent fsync of inodes with shared extents
      btrfs: unexport btrfs_compress_set_level()
      btrfs: simplify iget helpers
      ...

commit 8eeae5bae1239c030ba0b34cac97ebd5e7ec1886
Merge: 96ed320d527e 2c567af418e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 19:48:41 2020 -0700

    Merge tag 'vfs-5.8-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull DAX updates part two from Darrick Wong:
     "This time around, we're hoisting the DONTCACHE flag from XFS into the
      VFS so that we can make the incore DAX mode changes become effective
      sooner.
    
      We can't change the file data access mode on a live inode because we
      don't have a safe way to change the file ops pointers. The incore
      state change becomes effective at inode loading time, which can happen
      if the inode is evicted. Therefore, we're making it so that
      filesystems can ask the VFS to evict the inode as soon as the last
      holder drops.
    
      The per-fs changes to make this call this will be in subsequent pull
      requests from Ted and myself.
    
      Summary:
    
       - Introduce DONTCACHE flags for dentries and inodes. This hint will
         cause the VFS to drop the associated objects immediately after the
         last put, so that we can change the file access mode (DAX or page
         cache) on the fly"
    
    * tag 'vfs-5.8-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      fs: Introduce DCACHE_DONTCACHE
      fs: Lift XFS_IDONTCACHE to the VFS layer

commit 96ed320d527eb071389f69cbd6772440805af7d7
Merge: 16d91548d105 83d9088659e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 19:45:12 2020 -0700

    Merge tag 'vfs-5.8-merge-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull DAX updates part one from Darrick Wong:
     "After many years of LKML-wrangling about how to enable programs to
      query and influence the file data access mode (DAX) when a filesystem
      resides on storage devices such as persistent memory, Ira Weiny has
      emerged with a proposed set of standard behaviors that has not been
      shot down by anyone! We're more or less standardizing on the current
      XFS behavior and adapting ext4 to do the same.
    
      This is the first of a handful pull requests that will make ext4 and
      XFS present a consistent interface for user programs that care about
      DAX. We add a statx attribute that programs can check to see if DAX is
      enabled on a particular file. Then, we update the DAX documentation to
      spell out the user-visible behaviors that filesystems will guarantee
      (until the next storage industry shakeup). The on-disk inode flag has
      been in XFS for a few years now.
    
      Summary:
    
       - Clean up io_is_direct.
    
       - Add a new statx flag to indicate when file data access is being
         done via DAX (as opposed to the page cache).
    
       - Update the documentation for how system administrators and
         application programmers can take advantage of the (still
         experimental DAX) feature"
    
    Link: https://lore.kernel.org/lkml/20200505002016.1085071-1-ira.weiny@intel.com/
    
    * tag 'vfs-5.8-merge-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      Documentation/dax: Update Usage section
      fs/stat: Define DAX statx attribute
      fs: Remove unneeded IS_DAX() check in io_is_direct()

commit bce159d734091fe31340976081577333f52a85e4
Merge: 750a02ab8d3c 0c8d3fceade2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 15:37:03 2020 -0700

    Merge tag 'for-5.8/drivers-2020-06-01' of git://git.kernel.dk/linux-block
    
    Pull block driver updates from Jens Axboe:
     "On top of the core changes, here are the block driver changes for this
      merge window:
    
       - NVMe changes:
            - NVMe over Fibre Channel protocol updates, which also reach
              over to drivers/scsi/lpfc (James Smart)
            - namespace revalidation support on the target (Anthony
              Iliopoulos)
            - gcc zero length array fix (Arnd Bergmann)
            - nvmet cleanups (Chaitanya Kulkarni)
            - misc cleanups and fixes (me, Keith Busch, Sagi Grimberg)
            - use a SRQ per completion vector (Max Gurtovoy)
            - fix handling of runtime changes to the queue count (Weiping
              Zhang)
            - t10 protection information support for nvme-rdma and
              nvmet-rdma (Israel Rukshin and Max Gurtovoy)
            - target side AEN improvements (Chaitanya Kulkarni)
            - various fixes and minor improvements all over, icluding the
              nvme part of the lpfc driver"
    
       - Floppy code cleanup series (Willy, Denis)
    
       - Floppy contention fix (Jiri)
    
       - Loop CONFIGURE support (Martijn)
    
       - bcache fixes/improvements (Coly, Joe, Colin)
    
       - q->queuedata cleanups (Christoph)
    
       - Get rid of ioctl_by_bdev (Christoph, Stefan)
    
       - md/raid5 allocation fixes (Coly)
    
       - zero length array fixes (Gustavo)
    
       - swim3 task state fix (Xu)"
    
    * tag 'for-5.8/drivers-2020-06-01' of git://git.kernel.dk/linux-block: (166 commits)
      bcache: configure the asynchronous registertion to be experimental
      bcache: asynchronous devices registration
      bcache: fix refcount underflow in bcache_device_free()
      bcache: Convert pr_<level> uses to a more typical style
      bcache: remove redundant variables i and n
      lpfc: Fix return value in __lpfc_nvme_ls_abort
      lpfc: fix axchg pointer reference after free and double frees
      lpfc: Fix pointer checks and comments in LS receive refactoring
      nvme: set dma alignment to qword
      nvmet: cleanups the loop in nvmet_async_events_process
      nvmet: fix memory leak when removing namespaces and controllers concurrently
      nvmet-rdma: add metadata/T10-PI support
      nvmet: add metadata support for block devices
      nvmet: add metadata/T10-PI support
      nvme: add Metadata Capabilities enumerations
      nvmet: rename nvmet_check_data_len to nvmet_check_transfer_len
      nvmet: rename nvmet_rw_len to nvmet_rw_data_len
      nvmet: add metadata characteristics for a namespace
      nvme-rdma: add metadata/T10-PI support
      nvme-rdma: introduce nvme_rdma_sgl structure
      ...

commit 750a02ab8d3c49ca7d23102be90d3d1db19e2827
Merge: 1966391fa576 abb30460bda2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 15:29:19 2020 -0700

    Merge tag 'for-5.8/block-2020-06-01' of git://git.kernel.dk/linux-block
    
    Pull block updates from Jens Axboe:
     "Core block changes that have been queued up for this release:
    
       - Remove dead blk-throttle and blk-wbt code (Guoqing)
    
       - Include pid in blktrace note traces (Jan)
    
       - Don't spew I/O errors on wouldblock termination (me)
    
       - Zone append addition (Johannes, Keith, Damien)
    
       - IO accounting improvements (Konstantin, Christoph)
    
       - blk-mq hardware map update improvements (Ming)
    
       - Scheduler dispatch improvement (Salman)
    
       - Inline block encryption support (Satya)
    
       - Request map fixes and improvements (Weiping)
    
       - blk-iocost tweaks (Tejun)
    
       - Fix for timeout failing with error injection (Keith)
    
       - Queue re-run fixes (Douglas)
    
       - CPU hotplug improvements (Christoph)
    
       - Queue entry/exit improvements (Christoph)
    
       - Move DMA drain handling to the few drivers that use it (Christoph)
    
       - Partition handling cleanups (Christoph)"
    
    * tag 'for-5.8/block-2020-06-01' of git://git.kernel.dk/linux-block: (127 commits)
      block: mark bio_wouldblock_error() bio with BIO_QUIET
      blk-wbt: rename __wbt_update_limits to wbt_update_limits
      blk-wbt: remove wbt_update_limits
      blk-throttle: remove tg_drain_bios
      blk-throttle: remove blk_throtl_drain
      null_blk: force complete for timeout request
      blk-mq: drain I/O when all CPUs in a hctx are offline
      blk-mq: add blk_mq_all_tag_iter
      blk-mq: open code __blk_mq_alloc_request in blk_mq_alloc_request_hctx
      blk-mq: use BLK_MQ_NO_TAG in more places
      blk-mq: rename BLK_MQ_TAG_FAIL to BLK_MQ_NO_TAG
      blk-mq: move more request initialization to blk_mq_rq_ctx_init
      blk-mq: simplify the blk_mq_get_request calling convention
      blk-mq: remove the bio argument to ->prepare_request
      nvme: force complete cancelled requests
      blk-mq: blk-mq: provide forced completion method
      block: fix a warning when blkdev.h is included for !CONFIG_BLOCK builds
      block: blk-crypto-fallback: remove redundant initialization of variable err
      block: reduce part_stat_lock() scope
      block: use __this_cpu_add() instead of access by smp_processor_id()
      ...

commit 94709049fb8442fb2f7b91fbec3c2897a75e18df
Merge: 17839856fd58 4fba37586e4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 12:21:36 2020 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge updates from Andrew Morton:
     "A few little subsystems and a start of a lot of MM patches.
    
      Subsystems affected by this patch series: squashfs, ocfs2, parisc,
      vfs. With mm subsystems: slab-generic, slub, debug, pagecache, gup,
      swap, memcg, pagemap, memory-failure, vmalloc, kasan"
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (128 commits)
      kasan: move kasan_report() into report.c
      mm/mm_init.c: report kasan-tag information stored in page->flags
      ubsan: entirely disable alignment checks under UBSAN_TRAP
      kasan: fix clang compilation warning due to stack protector
      x86/mm: remove vmalloc faulting
      mm: remove vmalloc_sync_(un)mappings()
      x86/mm/32: implement arch_sync_kernel_mappings()
      x86/mm/64: implement arch_sync_kernel_mappings()
      mm/ioremap: track which page-table levels were modified
      mm/vmalloc: track which page-table levels were modified
      mm: add functions to track page directory modifications
      s390: use __vmalloc_node in stack_alloc
      powerpc: use __vmalloc_node in alloc_vm_stack
      arm64: use __vmalloc_node in arch_alloc_vmap_stack
      mm: remove vmalloc_user_node_flags
      mm: switch the test_vmalloc module to use __vmalloc_node
      mm: remove __vmalloc_node_flags_caller
      mm: remove both instances of __vmalloc_node_flags
      mm: remove the prot argument to __vmalloc_node
      mm: remove the pgprot argument to __vmalloc
      ...

commit 8151b4c8bee43cea7a28cb0300123df90880e60c
Author: Matthew Wilcox (Oracle) <willy@infradead.org>
Date:   Mon Jun 1 21:46:44 2020 -0700

    mm: add readahead address space operation
    
    This replaces ->readpages with a saner interface:
     - Return void instead of an ignored error code.
     - Page cache is already populated with locked pages when ->readahead
       is called.
     - New arguments can be passed to the implementation without changing
       all the filesystems that use a common helper function like
       mpage_readahead().
    
    Signed-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: John Hubbard <jhubbard@nvidia.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: William Kucharski <william.kucharski@oracle.com>
    Cc: Chao Yu <yuchao0@huawei.com>
    Cc: Cong Wang <xiyou.wangcong@gmail.com>
    Cc: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: Eric Biggers <ebiggers@google.com>
    Cc: Gao Xiang <gaoxiang25@huawei.com>
    Cc: Jaegeuk Kim <jaegeuk@kernel.org>
    Cc: Joseph Qi <joseph.qi@linux.alibaba.com>
    Cc: Junxiao Bi <junxiao.bi@oracle.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Zi Yan <ziy@nvidia.com>
    Cc: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Cc: Miklos Szeredi <mszeredi@redhat.com>
    Link: http://lkml.kernel.org/r/20200414150233.24495-12-willy@infradead.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f2fb5b7406b9..1434ed801b80 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -292,6 +292,7 @@ enum positive_aop_returns {
 struct page;
 struct address_space;
 struct writeback_control;
+struct readahead_control;
 
 /*
  * Write life time hint values.
@@ -375,6 +376,7 @@ struct address_space_operations {
 	 */
 	int (*readpages)(struct file *filp, struct address_space *mapping,
 			struct list_head *pages, unsigned nr_pages);
+	void (*readahead)(struct readahead_control *);
 
 	int (*write_begin)(struct file *, struct address_space *mapping,
 				loff_t pos, unsigned len, unsigned flags,

commit 735e4ae5ba28c886d249ad04d3c8cc097dad6336
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jun 1 21:45:36 2020 -0700

    vfs: track per-sb writeback errors and report them to syncfs
    
    Patch series "vfs: have syncfs() return error when there are writeback
    errors", v6.
    
    Currently, syncfs does not return errors when one of the inodes fails to
    be written back.  It will return errors based on the legacy AS_EIO and
    AS_ENOSPC flags when syncing out the block device fails, but that's not
    particularly helpful for filesystems that aren't backed by a blockdev.
    It's also possible for a stray sync to lose those errors.
    
    The basic idea in this set is to track writeback errors at the
    superblock level, so that we can quickly and easily check whether
    something bad happened without having to fsync each file individually.
    syncfs is then changed to reliably report writeback errors after they
    occur, much in the same fashion as fsync does now.
    
    This patch (of 2):
    
    Usually we suggest that applications call fsync when they want to ensure
    that all data written to the file has made it to the backing store, but
    that can be inefficient when there are a lot of open files.
    
    Calling syncfs on the filesystem can be more efficient in some
    situations, but the error reporting doesn't currently work the way most
    people expect.  If a single inode on a filesystem reports a writeback
    error, syncfs won't necessarily return an error.  syncfs only returns an
    error if __sync_blockdev fails, and on some filesystems that's a no-op.
    
    It would be better if syncfs reported an error if there were any
    writeback failures.  Then applications could call syncfs to see if there
    are any errors on any open files, and could then call fsync on all of
    the other descriptors to figure out which one failed.
    
    This patch adds a new errseq_t to struct super_block, and has
    mapping_set_error also record writeback errors there.
    
    To report those errors, we also need to keep an errseq_t in struct file
    to act as a cursor.  This patch adds a dedicated field for that purpose,
    which slots nicely into 4 bytes of padding at the end of struct file on
    x86_64.
    
    An earlier version of this patch used an O_PATH file descriptor to cue
    the kernel that the open file should track the superblock error and not
    the inode's writeback error.
    
    I think that API is just too weird though.  This is simpler and should
    make syncfs error reporting "just work" even if someone is multiplexing
    fsync and syncfs on the same fds.
    
    Signed-off-by: Jeff Layton <jlayton@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Andres Freund <andres@anarazel.de>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: David Howells <dhowells@redhat.com>
    Link: http://lkml.kernel.org/r/20200428135155.19223-1-jlayton@kernel.org
    Link: http://lkml.kernel.org/r/20200428135155.19223-2-jlayton@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45cc10cdf6dd..f2fb5b7406b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -976,6 +976,7 @@ struct file {
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
 	errseq_t		f_wb_err;
+	errseq_t		f_sb_err; /* for syncfs */
 } __randomize_layout
   __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
@@ -1520,6 +1521,9 @@ struct super_block {
 	/* Being remounted read-only */
 	int s_readonly_remount;
 
+	/* per-sb errseq_t for reporting writeback errors via syncfs */
+	errseq_t s_wb_err;
+
 	/* AIO completions deferred from interrupt context */
 	struct workqueue_struct *s_dio_done_wq;
 	struct hlist_head s_pins;
@@ -2827,6 +2831,18 @@ static inline errseq_t filemap_sample_wb_err(struct address_space *mapping)
 	return errseq_sample(&mapping->wb_err);
 }
 
+/**
+ * file_sample_sb_err - sample the current errseq_t to test for later errors
+ * @mapping: mapping to be sampled
+ *
+ * Grab the most current superblock-level errseq_t value for the given
+ * struct file.
+ */
+static inline errseq_t file_sample_sb_err(struct file *file)
+{
+	return errseq_sample(&file->f_path.dentry->d_sb->s_wb_err);
+}
+
 static inline int filemap_nr_thps(struct address_space *mapping)
 {
 #ifdef CONFIG_READ_ONLY_THP_FOR_FS

commit f359287765c04711ff54fbd11645271d8e5ff763
Merge: 8b39a57e9654 c8ffd8bcdd28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 1 16:44:06 2020 -0700

    Merge branch 'from-miklos' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "Assorted patches from Miklos.
    
      An interesting part here is /proc/mounts stuff..."
    
    The "/proc/mounts stuff" is using a cursor for keeeping the location
    data while traversing the mount listing.
    
    Also probably worth noting is the addition of faccessat2(), which takes
    an additional set of flags to specify how the lookup is done
    (AT_EACCESS, AT_SYMLINK_NOFOLLOW, AT_EMPTY_PATH).
    
    * 'from-miklos' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: add faccessat2 syscall
      vfs: don't parse "silent" option
      vfs: don't parse "posixacl" option
      vfs: don't parse forbidden flags
      statx: add mount_root
      statx: add mount ID
      statx: don't clear STATX_ATIME on SB_RDONLY
      uapi: deprecate STATX_ALL
      utimensat: AT_EMPTY_PATH support
      vfs: split out access_override_creds()
      proc/mounts: add cursor
      aio: fix async fsync creds
      vfs: allow unprivileged whiteout creation

commit 3f19b2ab97a97b413c24b66c67ae16daa4f56c35
Author: David Howells <dhowells@redhat.com>
Date:   Fri Dec 1 11:40:16 2017 +0000

    vfs, afs, ext4: Make the inode hash table RCU searchable
    
    Make the inode hash table RCU searchable so that searches that want to
    access or modify an inode without taking a ref on that inode can do so
    without taking the inode hash table lock.
    
    The main thing this requires is some RCU annotation on the list
    manipulation operations.  Inodes are already freed by RCU in most cases.
    
    Users of this interface must take care as the inode may be still under
    construction or may be being torn down around them.
    
    There are at least three instances where this can be of use:
    
     (1) Testing whether the inode number iunique() is going to return is
         currently unique (the iunique_lock is still held).
    
     (2) Ext4 date stamp updating.
    
     (3) AFS callback breaking.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    cc: linux-ext4@vger.kernel.org
    cc: linux-afs@lists.infradead.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45cc10cdf6dd..5f9b2bb4b44f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3070,6 +3070,9 @@ extern struct inode *find_inode_nowait(struct super_block *,
 				       int (*match)(struct inode *,
 						    unsigned long, void *),
 				       void *data);
+extern struct inode *find_inode_rcu(struct super_block *, unsigned long,
+				    int (*)(struct inode *, void *), void *);
+extern struct inode *find_inode_by_ino_rcu(struct super_block *, unsigned long);
 extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
 extern int insert_inode_locked(struct inode *);
 #ifdef CONFIG_DEBUG_LOCK_ALLOC

commit b75b7ca7c27dfd61dba368f390b7d4dc20b3a8cb
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Mon Nov 25 13:24:03 2019 -0600

    fs: remove dio_end_io()
    
    Since we removed the last user of dio_end_io(), remove the helper
    function dio_end_io().
    
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 366c533d30cd..e84623d5e173 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3187,8 +3187,6 @@ enum {
 	DIO_SKIP_HOLES	= 0x02,
 };
 
-void dio_end_io(struct bio *bio);
-
 ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
 			     struct block_device *bdev, struct iov_iter *iter,
 			     get_block_t get_block,

commit d85dc2e116fdce776280224ed2bee4c78e5e5af2
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Fri Aug 30 12:09:24 2019 -0500

    fs: export generic_file_buffered_read()
    
    Export generic_file_buffered_read() to be used to supplement incomplete
    direct reads.
    
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reviewed-by: David Sterba <dsterba@suse.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45cc10cdf6dd..366c533d30cd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3124,6 +3124,8 @@ extern int generic_file_rw_checks(struct file *file_in, struct file *file_out);
 extern int generic_copy_file_checks(struct file *file_in, loff_t pos_in,
 				    struct file *file_out, loff_t pos_out,
 				    size_t *count, unsigned int flags);
+extern ssize_t generic_file_buffered_read(struct kiocb *iocb,
+		struct iov_iter *to, ssize_t already_read);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit 6670ee2ef219ac9e1c836a277dda0c949ad8b1ff
Merge: 746c6237ece6 f2453978a4f2
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu May 21 10:58:15 2020 -0400

    Merge branch 'nfsd-5.8' of git://linux-nfs.org/~cel/cel-2.6 into for-5.8-incoming
    
    Highlights of this series:
    * Remove serialization of sending RPC/RDMA Replies
    * Convert the TCP socket send path to use xdr_buf::bvecs (pre-requisite for
    RPC-on-TLS)
    * Fix svcrdma backchannel sendto return code
    * Convert a number of dprintk call sites to use tracepoints
    * Fix the "suggest braces around empty body in an 'else' statement" warning

commit 3783daeb1d24696ff00125050353cfce4f5b6239
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 19 16:33:21 2020 +0200

    block: remove ioctl_by_bdev
    
    No callers left.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1a95e5158811..861ca61d728b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2636,7 +2636,6 @@ extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
 #ifdef CONFIG_BLOCK
-extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder);

commit a3c751a50fe6bbe50eb7622a14b18b361804ee0c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu May 14 16:44:23 2020 +0200

    vfs: allow unprivileged whiteout creation
    
    Whiteouts, unlike real device node should not require privileges to create.
    
    The general concern with device nodes is that opening them can have side
    effects.  The kernel already avoids zero major (see
    Documentation/admin-guide/devices.txt).  To be on the safe side the patch
    explicitly forbids registering a char device with 0/0 number (see
    cdev_add()).
    
    This guarantees that a non-O_PATH open on a whiteout will fail with ENODEV;
    i.e. it won't have any side effect.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..15665ef1ef90 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1721,7 +1721,11 @@ extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct ino
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
-extern int vfs_whiteout(struct inode *, struct dentry *);
+
+static inline int vfs_whiteout(struct inode *dir, struct dentry *dentry)
+{
+	return vfs_mknod(dir, dentry, S_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);
+}
 
 extern struct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode,
 				  int open_flag);

commit 2c567af418e3f9380c2051aada58b4e5a4b5c2ad
Author: Ira Weiny <ira.weiny@intel.com>
Date:   Thu Apr 30 07:41:37 2020 -0700

    fs: Introduce DCACHE_DONTCACHE
    
    DCACHE_DONTCACHE indicates a dentry should not be cached on final
    dput().
    
    Also add a helper function to mark DCACHE_DONTCACHE on all dentries
    pointing to a specific inode when that inode is being set I_DONTCACHE.
    
    This facilitates dropping dentry references to inodes sooner which
    require eviction to swap S_DAX mode.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Ira Weiny <ira.weiny@intel.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 44bd45af760f..7c3e8c0306e0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3055,6 +3055,7 @@ static inline int generic_drop_inode(struct inode *inode)
 	return !inode->i_nlink || inode_unhashed(inode) ||
 		(inode->i_state & I_DONTCACHE);
 }
+extern void d_mark_dontcache(struct inode *inode);
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,
 		unsigned long hashval, int (*test)(struct inode *, void *),

commit dae2f8ed7992e88c8d62c54e8295ffc8475b4a80
Author: Ira Weiny <ira.weiny@intel.com>
Date:   Thu Apr 30 07:41:37 2020 -0700

    fs: Lift XFS_IDONTCACHE to the VFS layer
    
    DAX effective mode (S_DAX) changes requires inode eviction.
    
    XFS has an advisory flag (XFS_IDONTCACHE) to prevent caching of the
    inode if no other additional references are taken.  We lift this flag to
    the VFS layer and change the behavior slightly by allowing the flag to
    remain even if multiple references are taken.
    
    This will expedite the eviction of inodes to change S_DAX.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Ira Weiny <ira.weiny@intel.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a87cc5845a02..44bd45af760f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2156,6 +2156,8 @@ static inline void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,
  *
  * I_CREATING		New object's inode in the middle of setting up.
  *
+ * I_DONTCACHE		Evict inode as soon as it is not used anymore.
+ *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
 #define I_DIRTY_SYNC		(1 << 0)
@@ -2178,6 +2180,7 @@ static inline void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,
 #define I_WB_SWITCH		(1 << 13)
 #define I_OVL_INUSE		(1 << 14)
 #define I_CREATING		(1 << 15)
+#define I_DONTCACHE		(1 << 16)
 
 #define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)
 #define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)
@@ -3049,7 +3052,8 @@ extern int inode_needs_sync(struct inode *inode);
 extern int generic_delete_inode(struct inode *inode);
 static inline int generic_drop_inode(struct inode *inode)
 {
-	return !inode->i_nlink || inode_unhashed(inode);
+	return !inode->i_nlink || inode_unhashed(inode) ||
+		(inode->i_state & I_DONTCACHE);
 }
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,

commit 32b1924b210a70dcacdf65abd687c5ef86a67541
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Thu Apr 9 11:29:47 2020 +0300

    ovl: skip overlayfs superblocks at global sync
    
    Stacked filesystems like overlayfs has no own writeback, but they have to
    forward syncfs() requests to backend for keeping data integrity.
    
    During global sync() each overlayfs instance calls method ->sync_fs() for
    backend although it itself is in global list of superblocks too.  As a
    result one syscall sync() could write one superblock several times and send
    multiple disk barriers.
    
    This patch adds flag SB_I_SKIP_SYNC into sb->sb_iflags to avoid that.
    
    Reported-by: Dmitry Monakhov <dmtrmonakhov@yandex-team.ru>
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..f186a966a36c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1409,6 +1409,8 @@ extern int send_sigurg(struct fown_struct *fown);
 #define SB_I_IMA_UNVERIFIABLE_SIGNATURE	0x00000020
 #define SB_I_UNTRUSTED_MOUNTER		0x00000040
 
+#define SB_I_SKIP_SYNC	0x00000100	/* Skip superblock at global sync */
+
 /* Possible states of 'frozen' field */
 enum {
 	SB_UNFROZEN = 0,		/* FS is unfrozen */

commit 28df3d1539de5090f7916f6fff03891b67f366f4
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Jul 28 16:35:15 2017 -0400

    nfsd: clients don't need to break their own delegations
    
    We currently revoke read delegations on any write open or any operation
    that modifies file data or metadata (including rename, link, and
    unlink).  But if the delegation in question is the only read delegation
    and is held by the client performing the operation, that's not really
    necessary.
    
    It's not always possible to prevent this in the NFSv4.0 case, because
    there's not always a way to determine which client an NFSv4.0 delegation
    came from.  (In theory we could try to guess this from the transport
    layer, e.g., by assuming all traffic on a given TCP connection comes
    from the same client.  But that's not really correct.)
    
    In the NFSv4.1 case the session layer always tells us the client.
    
    This patch should remove such self-conflicts in all cases where we can
    reliably determine the client from the compound.
    
    To do that we need to track "who" is performing a given (possibly
    lease-breaking) file operation.  We're doing that by storing the
    information in the svc_rqst and using kthread_data() to map the current
    task back to a svc_rqst.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..4b784560ffaf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1045,6 +1045,7 @@ struct lock_manager_operations {
 	bool (*lm_break)(struct file_lock *);
 	int (*lm_change)(struct file_lock *, int, struct list_head *);
 	void (*lm_setup)(struct file_lock *, void **);
+	bool (*lm_breaker_owns_lease)(struct file_lock *);
 };
 
 struct lock_manager {

commit 3793faad7b5b730941b2efbc252d14374b60843a
Merge: ae1804de93f6 a811c1fa0a02
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 6 22:10:13 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Conflicts were all overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9d82973e032e246ff5663c9805fbb5407ae932e3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 4 09:16:37 2020 -0700

    gcc-10 warnings: fix low-hanging fruit
    
    Due to a bug-report that was compiler-dependent, I updated one of my
    machines to gcc-10.  That shows a lot of new warnings.  Happily they
    seem to be mostly the valid kind, but it's going to cause a round of
    churn for getting rid of them..
    
    This is the really low-hanging fruit of removing a couple of zero-sized
    arrays in some core code.  We have had a round of these patches before,
    and we'll have many more coming, and there is nothing special about
    these except that they were particularly trivial, and triggered more
    warnings than most.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..45cc10cdf6dd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -983,7 +983,7 @@ struct file_handle {
 	__u32 handle_bytes;
 	int handle_type;
 	/* file identifier */
-	unsigned char f_handle[0];
+	unsigned char f_handle[];
 };
 
 static inline struct file *get_file(struct file *f)

commit efbe3c2493d2f7a1e1a753780fe727b34709ebd2
Author: Ira Weiny <ira.weiny@intel.com>
Date:   Thu Apr 30 07:41:33 2020 -0700

    fs: Remove unneeded IS_DAX() check in io_is_direct()
    
    Remove the check because DAX now has it's own read/write methods and
    file systems which support DAX check IS_DAX() prior to IOCB_DIRECT on
    their own.  Therefore, it does not matter if the file state is DAX when
    the iocb flags are created.
    
    Also remove io_is_direct() as it is just a simple flag check.
    
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Ira Weiny <ira.weiny@intel.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..a87cc5845a02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3394,11 +3394,6 @@ extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern int file_update_time(struct file *file);
 
-static inline bool io_is_direct(struct file *filp)
-{
-	return (filp->f_flags & O_DIRECT) || IS_DAX(filp->f_mapping->host);
-}
-
 static inline bool vma_is_dax(const struct vm_area_struct *vma)
 {
 	return vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);
@@ -3423,7 +3418,7 @@ static inline int iocb_flags(struct file *file)
 	int res = 0;
 	if (file->f_flags & O_APPEND)
 		res |= IOCB_APPEND;
-	if (io_is_direct(file))
+	if (file->f_flags & O_DIRECT)
 		res |= IOCB_DIRECT;
 	if ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))
 		res |= IOCB_DSYNC;

commit 32927393dc1ccd60fb2bdc05b9e8e88753761469
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 24 08:43:38 2020 +0200

    sysctl: pass kernel pointers to ->proc_handler
    
    Instead of having all the sysctl handlers deal with user pointers, which
    is rather hairy in terms of the BPF interaction, copy the input to and
    from  userspace in common code.  This also means that the strings are
    always NUL-terminated by the common code, making the API a little bit
    safer.
    
    As most handler just pass through the data to one of the common handlers
    a lot of the changes are mechnical.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Andrey Ignatov <rdna@fb.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..9b028d260649 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3536,11 +3536,11 @@ ssize_t simple_attr_write(struct file *file, const char __user *buf,
 
 struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write,
-		  void __user *buffer, size_t *lenp, loff_t *ppos);
+		  void *buffer, size_t *lenp, loff_t *ppos);
 int proc_nr_dentry(struct ctl_table *table, int write,
-		  void __user *buffer, size_t *lenp, loff_t *ppos);
+		  void *buffer, size_t *lenp, loff_t *ppos);
 int proc_nr_inodes(struct ctl_table *table, int write,
-		   void __user *buffer, size_t *lenp, loff_t *ppos);
+		   void *buffer, size_t *lenp, loff_t *ppos);
 int __init get_filesystem_list(char *buf);
 
 #define __FMODE_EXEC		((__force int) FMODE_EXEC)

commit 9bc5c397d8384b50c8202f4400bf2f87fe8291d9
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 14 09:29:02 2020 +0200

    block: fold bdev_unhash_inode into invalidate_partition
    
    invalidate_partition and bdev_unhash_inode are always paired, and
    invalidate_partition already does an icache lookup for the block device
    inode.  Piggy back on that to remove the inode from the hash.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2b4e9f86b151..1a95e5158811 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2581,7 +2581,6 @@ extern struct kmem_cache *names_cachep;
 #ifdef CONFIG_BLOCK
 extern int register_blkdev(unsigned int, const char *);
 extern void unregister_blkdev(unsigned int, const char *);
-extern void bdev_unhash_inode(dev_t dev);
 extern struct block_device *bdget(dev_t);
 extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);

commit 02d33b6771fcc63c98cb48cad0cd8b8fb033837a
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 14 09:29:01 2020 +0200

    block: mark invalidate_partition static
    
    invalidate_partition is only used in genhd.c, so mark it static.  Also
    drop the return value given that is is always ignored.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f6f59b4f22a..2b4e9f86b151 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2723,7 +2723,6 @@ extern bool is_bad_inode(struct inode *);
 extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *, bool);
-extern int invalidate_partition(struct gendisk *, int);
 #endif
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);

commit ea9448b254e253e4d95afaab071b341d86c11795
Merge: 83eb69f3b80f 0e7e6198af28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 4 11:58:55 2020 -0700

    Merge tag 'drm-next-2020-04-03-1' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm hugepage support from Dave Airlie:
     "This adds support for hugepages to TTM and has been tested with the
      vmwgfx drivers, though I expect other drivers to start using it"
    
    * tag 'drm-next-2020-04-03-1' of git://anongit.freedesktop.org/drm/drm:
      drm/vmwgfx: Hook up the helpers to align buffer objects
      drm/vmwgfx: Introduce a huge page aligning TTM range manager
      drm: Add a drm_get_unmapped_area() helper
      drm/vmwgfx: Support huge page faults
      drm/ttm, drm/vmwgfx: Support huge TTM pagefaults
      mm: Add vmf_insert_pfn_xxx_prot() for huge page-table entries
      mm: Split huge pages on write-notify or COW
      mm: Introduce vma_is_special_huge
      fs: Constify vma argument to vma_is_dax

commit 0e7e6198af28c1573267aba1be33dd0b7fb35691
Merge: 59e7a8cc2dcf 9431042dbc8c
Author: Dave Airlie <airlied@redhat.com>
Date:   Fri Apr 3 06:09:51 2020 +1000

    Merge branch 'ttm-transhuge' of git://people.freedesktop.org/~thomash/linux into drm-next
    
    Huge page-table entries for TTM
    
    In order to reduce CPU usage [1] and in theory TLB misses this patchset enables
    huge- and giant page-table entries for TTM and TTM-enabled graphics drivers.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    From: Thomas Hellstrom (VMware) <thomas_os@shipmail.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20200325073102.6129-1-thomas_os@shipmail.org

commit c0d0381ade79885c04a04c303284b040616b116e
Author: Mike Kravetz <mike.kravetz@oracle.com>
Date:   Wed Apr 1 21:11:05 2020 -0700

    hugetlbfs: use i_mmap_rwsem for more pmd sharing synchronization
    
    Patch series "hugetlbfs: use i_mmap_rwsem for more synchronization", v2.
    
    While discussing the issue with huge_pte_offset [1], I remembered that
    there were more outstanding hugetlb races.  These issues are:
    
    1) For shared pmds, huge PTE pointers returned by huge_pte_alloc can become
       invalid via a call to huge_pmd_unshare by another thread.
    2) hugetlbfs page faults can race with truncation causing invalid global
       reserve counts and state.
    
    A previous attempt was made to use i_mmap_rwsem in this manner as
    described at [2].  However, those patches were reverted starting with [3]
    due to locking issues.
    
    To effectively use i_mmap_rwsem to address the above issues it needs to be
    held (in read mode) during page fault processing.  However, during fault
    processing we need to lock the page we will be adding.  Lock ordering
    requires we take page lock before i_mmap_rwsem.  Waiting until after
    taking the page lock is too late in the fault process for the
    synchronization we want to do.
    
    To address this lock ordering issue, the following patches change the lock
    ordering for hugetlb pages.  This is not too invasive as hugetlbfs
    processing is done separate from core mm in many places.  However, I don't
    really like this idea.  Much ugliness is contained in the new routine
    hugetlb_page_mapping_lock_write() of patch 1.
    
    The only other way I can think of to address these issues is by catching
    all the races.  After catching a race, cleanup, backout, retry ...  etc,
    as needed.  This can get really ugly, especially for huge page
    reservations.  At one time, I started writing some of the reservation
    backout code for page faults and it got so ugly and complicated I went
    down the path of adding synchronization to avoid the races.  Any other
    suggestions would be welcome.
    
    [1] https://lore.kernel.org/linux-mm/1582342427-230392-1-git-send-email-longpeng2@huawei.com/
    [2] https://lore.kernel.org/linux-mm/20181222223013.22193-1-mike.kravetz@oracle.com/
    [3] https://lore.kernel.org/linux-mm/20190103235452.29335-1-mike.kravetz@oracle.com
    [4] https://lore.kernel.org/linux-mm/1584028670.7365.182.camel@lca.pw/
    [5] https://lore.kernel.org/lkml/20200312183142.108df9ac@canb.auug.org.au/
    
    This patch (of 2):
    
    While looking at BUGs associated with invalid huge page map counts, it was
    discovered and observed that a huge pte pointer could become 'invalid' and
    point to another task's page table.  Consider the following:
    
    A task takes a page fault on a shared hugetlbfs file and calls
    huge_pte_alloc to get a ptep.  Suppose the returned ptep points to a
    shared pmd.
    
    Now, another task truncates the hugetlbfs file.  As part of truncation, it
    unmaps everyone who has the file mapped.  If the range being truncated is
    covered by a shared pmd, huge_pmd_unshare will be called.  For all but the
    last user of the shared pmd, huge_pmd_unshare will clear the pud pointing
    to the pmd.  If the task in the middle of the page fault is not the last
    user, the ptep returned by huge_pte_alloc now points to another task's
    page table or worse.  This leads to bad things such as incorrect page
    map/reference counts or invalid memory references.
    
    To fix, expand the use of i_mmap_rwsem as follows:
    - i_mmap_rwsem is held in read mode whenever huge_pmd_share is called.
      huge_pmd_share is only called via huge_pte_alloc, so callers of
      huge_pte_alloc take i_mmap_rwsem before calling.  In addition, callers
      of huge_pte_alloc continue to hold the semaphore until finished with
      the ptep.
    - i_mmap_rwsem is held in write mode whenever huge_pmd_unshare is called.
    
    One problem with this scheme is that it requires taking i_mmap_rwsem
    before taking the page lock during page faults.  This is not the order
    specified in the rest of mm code.  Handling of hugetlbfs pages is mostly
    isolated today.  Therefore, we use this alternative locking order for
    PageHuge() pages.
    
             mapping->i_mmap_rwsem
               hugetlb_fault_mutex (hugetlbfs specific page fault mutex)
                 page->flags PG_locked (lock_page)
    
    To help with lock ordering issues, hugetlb_page_mapping_lock_write() is
    introduced to write lock the i_mmap_rwsem associated with a page.
    
    In most cases it is easy to get address_space via vma->vm_file->f_mapping.
    However, in the case of migration or memory errors for anon pages we do
    not have an associated vma.  A new routine _get_hugetlb_page_mapping()
    will use anon_vma to get address_space in these cases.
    
    Signed-off-by: Mike Kravetz <mike.kravetz@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
    Cc: "Aneesh Kumar K . V" <aneesh.kumar@linux.vnet.ibm.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: "Kirill A . Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Davidlohr Bueso <dave@stgolabs.net>
    Cc: Prakash Sangappa <prakash.sangappa@oracle.com>
    Link: http://lkml.kernel.org/r/20200316205756.146666-2-mike.kravetz@oracle.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3d69de600494..f81c822f4d89 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -526,6 +526,11 @@ static inline void i_mmap_lock_write(struct address_space *mapping)
 	down_write(&mapping->i_mmap_rwsem);
 }
 
+static inline int i_mmap_trylock_write(struct address_space *mapping)
+{
+	return down_write_trylock(&mapping->i_mmap_rwsem);
+}
+
 static inline void i_mmap_unlock_write(struct address_space *mapping)
 {
 	up_write(&mapping->i_mmap_rwsem);

commit 59838093be51ee9447f6ad05483d697b6fa0368d
Merge: db34c5ffee64 18555cb6db23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 13:59:52 2020 -0700

    Merge tag 'driver-core-5.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here is the "big" set of driver core changes for 5.7-rc1.
    
      Nothing huge in here, just lots of little firmware core changes and
      use of new apis, a libfs fix, a debugfs api change, and some driver
      core deferred probe rework.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'driver-core-5.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (44 commits)
      Revert "driver core: Set fw_devlink to "permissive" behavior by default"
      driver core: Set fw_devlink to "permissive" behavior by default
      driver core: Replace open-coded list_last_entry()
      driver core: Read atomic counter once in driver_probe_done()
      libfs: fix infoleak in simple_attr_read()
      driver core: Add device links from fwnode only for the primary device
      platform/x86: touchscreen_dmi: Add info for the Chuwi Vi8 Plus tablet
      platform/x86: touchscreen_dmi: Add EFI embedded firmware info support
      Input: icn8505 - Switch to firmware_request_platform for retreiving the fw
      Input: silead - Switch to firmware_request_platform for retreiving the fw
      selftests: firmware: Add firmware_request_platform tests
      test_firmware: add support for firmware_request_platform
      firmware: Add new platform fallback mechanism and firmware_request_platform()
      Revert "drivers: base: power: wakeup.c: Use built-in RCU list checking"
      drivers: base: power: wakeup.c: Use built-in RCU list checking
      component: allow missing unbind callback
      debugfs: remove return value of debugfs_create_file_size()
      debugfs: Check module state before warning in {full/open}_proxy_open()
      firmware: fix a double abort case with fw_load_sysfs_fallback
      arch_topology: Fix putting invalid cpu clk
      ...

commit 10f36b1e80a9f7afdaefe6f0b06dcdf89715eed7
Merge: 3a0eb192c01f 654a3667df36
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 11:20:13 2020 -0700

    Merge tag 'for-5.7/block-2020-03-29' of git://git.kernel.dk/linux-block
    
    Pull block updates from Jens Axboe:
    
     - Online capacity resizing (Balbir)
    
     - Number of hardware queue change fixes (Bart)
    
     - null_blk fault injection addition (Bart)
    
     - Cleanup of queue allocation, unifying the node/no-node API
       (Christoph)
    
     - Cleanup of genhd, moving code to where it makes sense (Christoph)
    
     - Cleanup of the partition handling code (Christoph)
    
     - disk stat fixes/improvements (Konstantin)
    
     - BFQ improvements (Paolo)
    
     - Various fixes and improvements
    
    * tag 'for-5.7/block-2020-03-29' of git://git.kernel.dk/linux-block: (72 commits)
      block: return NULL in blk_alloc_queue() on error
      block: move bio_map_* to blk-map.c
      Revert "blkdev: check for valid request queue before issuing flush"
      block: simplify queue allocation
      bcache: pass the make_request methods to blk_queue_make_request
      null_blk: use blk_mq_init_queue_data
      block: add a blk_mq_init_queue_data helper
      block: move the ->devnode callback to struct block_device_operations
      block: move the part_stat* helpers from genhd.h to a new header
      block: move block layer internals out of include/linux/genhd.h
      block: move guard_bio_eod to bio.c
      block: unexport get_gendisk
      block: unexport disk_map_sector_rcu
      block: unexport disk_get_part
      block: mark part_in_flight and part_in_flight_rw static
      block: mark block_depr static
      block: factor out requeue handling from dispatch code
      block/diskstats: replace time_in_queue with sum of request times
      block/diskstats: accumulate all per-cpu counters in one pass
      block/diskstats: more accurate approximation of io_ticks for slow disks
      ...

commit f05a3849f6449f67843113778bf56e02f2b4ddf8
Author: Thomas Hellstrom (VMware) <thomas_os@shipmail.org>
Date:   Tue Mar 24 18:46:48 2020 +0100

    fs: Constify vma argument to vma_is_dax
    
    The function is used by upcoming vma_is_special_huge() with which we want
    to use a const vma argument. Since for vma_is_dax() the vma argument is
    only dereferenced for reading, constify it.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Ralph Campbell <rcampbell@nvidia.com>
    Cc: "Jrme Glisse" <jglisse@redhat.com>
    Cc: "Christian Knig" <christian.koenig@amd.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Thomas Hellstrom (VMware) <thomas_os@shipmail.org>
    Reviewed-by: Roland Scheidegger <sroland@vmware.com>
    Acked-by: Christian Knig <christian.koenig@amd.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3cd4fe6b845e..2b38ce5b73ad 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3391,7 +3391,7 @@ static inline bool io_is_direct(struct file *filp)
 	return (filp->f_flags & O_DIRECT) || IS_DAX(filp->f_mapping->host);
 }
 
-static inline bool vma_is_dax(struct vm_area_struct *vma)
+static inline bool vma_is_dax(const struct vm_area_struct *vma)
 {
 	return vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);
 }

commit ea3edd4dc23027083fbb4a73b65114d08fe73a76
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 24 08:25:11 2020 +0100

    block: remove __bdevname
    
    There is no good reason for __bdevname to exist.  Just open code
    printing the string in the callers.  For three of them the format
    string can be trivially merged into existing printk statements,
    and in init/do_mounts.c we can at least do the scnprintf once at
    the start of the function, and unconditional of CONFIG_BLOCK to
    make the output for tiny configfs a little more helpful.
    
    Acked-by: Theodore Ts'o <tytso@mit.edu> # for ext4
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3cd4fe6b845e..561b35e3b95b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2699,7 +2699,6 @@ static inline void unregister_chrdev(unsigned int major, const char *name)
 
 #ifdef CONFIG_BLOCK
 #define BLKDEV_MAJOR_MAX	512
-extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern void blkdev_show(struct seq_file *,off_t);

commit e4c2c0ff00ecaf8e245455a199b86ce22143becf
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Jan 15 17:35:48 2020 +0100

    firmware: Add new platform fallback mechanism and firmware_request_platform()
    
    In some cases the platform's main firmware (e.g. the UEFI fw) may contain
    an embedded copy of device firmware which needs to be (re)loaded into the
    peripheral. Normally such firmware would be part of linux-firmware, but in
    some cases this is not feasible, for 2 reasons:
    
    1) The firmware is customized for a specific use-case of the chipset / use
    with a specific hardware model, so we cannot have a single firmware file
    for the chipset. E.g. touchscreen controller firmwares are compiled
    specifically for the hardware model they are used with, as they are
    calibrated for a specific model digitizer.
    
    2) Despite repeated attempts we have failed to get permission to
    redistribute the firmware. This is especially a problem with customized
    firmwares, these get created by the chip vendor for a specific ODM and the
    copyright may partially belong with the ODM, so the chip vendor cannot
    give a blanket permission to distribute these.
    
    This commit adds a new platform fallback mechanism to the firmware loader
    which will try to lookup a device fw copy embedded in the platform's main
    firmware if direct filesystem lookup fails.
    
    Drivers which need such embedded fw copies can enable this fallback
    mechanism by using the new firmware_request_platform() function.
    
    Note that for now this is only supported on EFI platforms and even on
    these platforms firmware_fallback_platform() only works if
    CONFIG_EFI_EMBEDDED_FIRMWARE is enabled (this gets selected by drivers
    which need this), in all other cases firmware_fallback_platform() simply
    always returns -ENOENT.
    
    Reported-by: Dave Olsthoorn <dave@bewaar.me>
    Suggested-by: Peter Jones <pjones@redhat.com>
    Acked-by: Luis Chamberlain <mcgrof@kernel.org>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Link: https://lore.kernel.org/r/20200115163554.101315-5-hdegoede@redhat.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f814ccd8d929..8e08f7f0cd5f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2982,6 +2982,7 @@ extern int do_pipe_flags(int *, int);
 	id(UNKNOWN, unknown)		\
 	id(FIRMWARE, firmware)		\
 	id(FIRMWARE_PREALLOC_BUFFER, firmware)	\
+	id(FIRMWARE_EFI_EMBEDDED, firmware)	\
 	id(MODULE, kernel-module)		\
 	id(KEXEC_IMAGE, kexec-image)		\
 	id(KEXEC_INITRAMFS, kexec-initramfs)	\

commit 8019ad13ef7f64be44d4f892af9c840179009254
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Mar 4 11:28:31 2020 +0100

    futex: Fix inode life-time issue
    
    As reported by Jann, ihold() does not in fact guarantee inode
    persistence. And instead of making it so, replace the usage of inode
    pointers with a per boot, machine wide, unique inode identifier.
    
    This sequence number is global, but shared (file backed) futexes are
    rare enough that this should not become a performance issue.
    
    Reported-by: Jann Horn <jannh@google.com>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3cd4fe6b845e..abedbffe2c9e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -698,6 +698,7 @@ struct inode {
 		struct rcu_head		i_rcu;
 	};
 	atomic64_t		i_version;
+	atomic64_t		i_sequence; /* see futex */
 	atomic_t		i_count;
 	atomic_t		i_dio_count;
 	atomic_t		i_writecount;

commit 901cff7cb96140a658a848a568b606ba764239bc
Author: Topi Miettinen <toiwoton@gmail.com>
Date:   Thu Jan 23 14:58:38 2020 +0200

    firmware_loader: load files from the mount namespace of init
    
    I have an experimental setup where almost every possible system
    service (even early startup ones) runs in separate namespace, using a
    dedicated, minimal file system. In process of minimizing the contents
    of the file systems with regards to modules and firmware files, I
    noticed that in my system, the firmware files are loaded from three
    different mount namespaces, those of systemd-udevd, init and
    systemd-networkd. The logic of the source namespace is not very clear,
    it seems to depend on the driver, but the namespace of the current
    process is used.
    
    So, this patch tries to make things a bit clearer and changes the
    loading of firmware files only from the mount namespace of init. This
    may also improve security, though I think that using firmware files as
    attack vector could be too impractical anyway.
    
    Later, it might make sense to make the mount namespace configurable,
    for example with a new file in /proc/sys/kernel/firmware_config/. That
    would allow a dedicated file system only for firmware files and those
    need not be present anywhere else. This configurability would make
    more sense if made also for kernel modules and /sbin/modprobe. Modules
    are already loaded from init namespace (usermodehelper uses kthreadd
    namespace) except when directly loaded by systemd-udevd.
    
    Instead of using the mount namespace of the current process to load
    firmware files, use the mount namespace of init process.
    
    Link: https://lore.kernel.org/lkml/bb46ebae-4746-90d9-ec5b-fce4c9328c86@gmail.com/
    Link: https://lore.kernel.org/lkml/0e3f7653-c59d-9341-9db2-c88f5b988c68@gmail.com/
    Signed-off-by: Topi Miettinen <toiwoton@gmail.com>
    Link: https://lore.kernel.org/r/20200123125839.37168-1-toiwoton@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3cd4fe6b845e..f814ccd8d929 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3012,6 +3012,8 @@ extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
 			    enum kernel_read_file_id);
 extern int kernel_read_file_from_path(const char *, void **, loff_t *, loff_t,
 				      enum kernel_read_file_id);
+extern int kernel_read_file_from_path_initns(const char *, void **, loff_t *, loff_t,
+					     enum kernel_read_file_id);
 extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
 				    enum kernel_read_file_id);
 extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);

commit c9d35ee049b40f1d73e890bf88dd55f83b1e9be8
Merge: 236f45329460 f35aa2bc809e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 8 13:26:41 2020 -0800

    Merge branch 'merge.nfs-fs_parse.1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs file system parameter updates from Al Viro:
     "Saner fs_parser.c guts and data structures. The system-wide registry
      of syntax types (string/enum/int32/oct32/.../etc.) is gone and so is
      the horror switch() in fs_parse() that would have to grow another case
      every time something got added to that system-wide registry.
    
      New syntax types can be added by filesystems easily now, and their
      namespace is that of functions - not of system-wide enum members. IOW,
      they can be shared or kept private and if some turn out to be widely
      useful, we can make them common library helpers, etc., without having
      to do anything whatsoever to fs_parse() itself.
    
      And we already get that kind of requests - the thing that finally
      pushed me into doing that was "oh, and let's add one for timeouts -
      things like 15s or 2h". If some filesystem really wants that, let them
      do it. Without somebody having to play gatekeeper for the variants
      blessed by direct support in fs_parse(), TYVM.
    
      Quite a bit of boilerplate is gone. And IMO the data structures make a
      lot more sense now. -200LoC, while we are at it"
    
    * 'merge.nfs-fs_parse.1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (25 commits)
      tmpfs: switch to use of invalfc()
      cgroup1: switch to use of errorfc() et.al.
      procfs: switch to use of invalfc()
      hugetlbfs: switch to use of invalfc()
      cramfs: switch to use of errofc() et.al.
      gfs2: switch to use of errorfc() et.al.
      fuse: switch to use errorfc() et.al.
      ceph: use errorfc() and friends instead of spelling the prefix out
      prefix-handling analogues of errorf() and friends
      turn fs_param_is_... into functions
      fs_parse: handle optional arguments sanely
      fs_parse: fold fs_parameter_desc/fs_parameter_spec
      fs_parser: remove fs_parameter_description name field
      add prefix to fs_context->log
      ceph_parse_param(), ceph_parse_mon_ips(): switch to passing fc_log
      new primitive: __fs_parse()
      switch rbd and libceph to p_log-based primitives
      struct p_log, variants of warnf() et.al. taking that one instead
      teach logfc() to handle prefices, give it saner calling conventions
      get rid of cg_invalf()
      ...

commit 236f45329460f76d058111de1a1cea12f5a8b734
Merge: 995933305e11 12efec560274
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 8 13:04:49 2020 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
    
     - bmap series from cmaiolino
    
     - getting rid of convolutions in copy_mount_options() (use a couple of
       copy_from_user() instead of the __get_user() crap)
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      saner copy_mount_options()
      fibmap: Reject negative block numbers
      fibmap: Use bmap instead of ->bmap method in ioctl_fibmap
      ecryptfs: drop direct calls to ->bmap
      cachefiles: drop direct usage of ->bmap method.
      fs: Enable bmap() function to properly return errors

commit d7167b149943e38ad610191ecbb0800c78bbced9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Sep 7 07:23:15 2019 -0400

    fs_parse: fold fs_parameter_desc/fs_parameter_spec
    
    The former contains nothing but a pointer to an array of the latter...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..5ace552a2a23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -67,7 +67,7 @@ struct fscrypt_operations;
 struct fsverity_info;
 struct fsverity_operations;
 struct fs_context;
-struct fs_parameter_description;
+struct fs_parameter_spec;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2224,7 +2224,7 @@ struct file_system_type {
 #define FS_DISALLOW_NOTIFY_PERM	16	/* Disable fanotify permission events */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	int (*init_fs_context)(struct fs_context *);
-	const struct fs_parameter_description *parameters;
+	const struct fs_parameter_spec *parameters;
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
 	void (*kill_sb) (struct super_block *);

commit 72f582ff8569900ccc4439b26bbe5e2fff509f08
Merge: bddea11b1b93 a3d1e7eb5abe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 5 05:09:46 2020 +0000

    Merge branch 'work.recursive_removal' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs recursive removal updates from Al Viro:
     "We have quite a few places where synthetic filesystems do an
      equivalent of 'rm -rf', with varying amounts of code duplication,
      wrong locking, etc. That really ought to be a library helper.
    
      Only debugfs (and very similar tracefs) are converted here - I have
      more conversions, but they'd never been in -next, so they'll have to
      wait"
    
    * 'work.recursive_removal' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      simple_recursive_removal(): kernel-side rm -rf for ramfs-style filesystems

commit bddea11b1b9385f713006820f16a9fbe5efe6b47
Merge: 33b40134e5cf f0f3588f7a95
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 5 05:02:42 2020 +0000

    Merge branch 'imm.timestamp' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs timestamp updates from Al Viro:
     "More 64bit timestamp work"
    
    * 'imm.timestamp' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      kernfs: don't bother with timestamp truncation
      fs: Do not overload update_time
      fs: Delete timespec64_trunc()
      fs: ubifs: Eliminate timespec64_trunc() usage
      fs: ceph: Delete timespec64_trunc() usage
      fs: cifs: Delete usage of timespec64_trunc
      fs: fat: Eliminate timespec64_trunc() usage
      utimes: Clamp the timestamps in notify_change()

commit 7f879e1a94ac99586abf0659c03f35c1e48279c4
Merge: a45ad71e8995 a4ac9d45c0cd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 4 11:45:21 2020 +0000

    Merge tag 'ovl-update-5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs update from Miklos Szeredi:
    
     - Try to preserve holes in sparse files when copying up, thus saving
       disk space and improving performance.
    
     - Fix a performance regression introduced in v4.19 by preserving
       asynchronicity of IO when fowarding to underlying layers. Add VFS
       helpers to submit async iocbs.
    
     - Fix a regression in lseek(2) introduced in v4.19 that breaks >2G
       seeks on 32bit kernels.
    
     - Fix a corner case where st_ino/st_dev was not preserved across copy
       up.
    
     - Miscellaneous fixes and cleanups.
    
    * tag 'ovl-update-5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: fix lseek overflow on 32bit
      ovl: add splice file read write helper
      ovl: implement async IO routines
      vfs: add vfs_iocb_iter_[read|write] helper functions
      ovl: layer is const
      ovl: fix corner case of non-constant st_dev;st_ino
      ovl: fix corner case of conflicting lower layer uuid
      ovl: generalize the lower_fs[] array
      ovl: simplify ovl_same_sb() helper
      ovl: generalize the lower_layers[] array
      ovl: improving copy-up efficiency for big sparse file
      ovl: use ovl_inode_lock in ovl_llseek()
      ovl: use pr_fmt auto generate prefix
      ovl: fix wrong WARN_ON() in ovl_cache_update_ino()

commit 30460e1ea3e62f8457e087db9a309ed1031630da
Author: Carlos Maiolino <cmaiolino@redhat.com>
Date:   Thu Jan 9 14:30:41 2020 +0100

    fs: Enable bmap() function to properly return errors
    
    By now, bmap() will either return the physical block number related to
    the requested file offset or 0 in case of error or the requested offset
    maps into a hole.
    This patch makes the needed changes to enable bmap() to proper return
    errors, using the return value as an error return, and now, a pointer
    must be passed to bmap() to be filled with the mapped physical block.
    
    It will change the behavior of bmap() on return:
    
    - negative value in case of error
    - zero on success or map fell into a hole
    
    In case of a hole, the *block will be zero too
    
    Since this is a prep patch, by now, the only error return is -EINVAL if
    ->bmap doesn't exist.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..f762e07ea589 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2865,9 +2865,16 @@ static inline ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)
 
 extern void emergency_sync(void);
 extern void emergency_remount(void);
+
 #ifdef CONFIG_BLOCK
-extern sector_t bmap(struct inode *, sector_t);
+extern int bmap(struct inode *inode, sector_t *block);
+#else
+static inline int bmap(struct inode *inode,  sector_t *block)
+{
+	return -EINVAL;
+}
 #endif
+
 extern int notify_change(struct dentry *, struct iattr *, struct inode **);
 extern int inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int);

commit ddf8f376d137ba41ca67347a0b80ba0c357a1018
Author: Ira Weiny <ira.weiny@intel.com>
Date:   Thu Jan 30 22:12:07 2020 -0800

    mm/filemap.c: clean up filemap_write_and_wait()
    
    At some point filemap_write_and_wait() and
    filemap_write_and_wait_range() got the exact same implementation with
    the exception of the range being specified in *_range()
    
    Similar to other functions in fs.h which call *_range(..., 0,
    LLONG_MAX), change filemap_write_and_wait() to be a static inline which
    calls filemap_write_and_wait_range()
    
    Link: http://lkml.kernel.org/r/20191129160713.30892-1-ira.weiny@intel.com
    Signed-off-by: Ira Weiny <ira.weiny@intel.com>
    Reviewed-by: Nikolay Borisov <nborisov@suse.com>
    Reviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 40be2ccb87f3..41584f50af0d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2737,7 +2737,6 @@ static inline int filemap_fdatawait(struct address_space *mapping)
 
 extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
 				  loff_t lend);
-extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);
 extern int __filemap_fdatawrite_range(struct address_space *mapping,
@@ -2747,6 +2746,11 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 extern int filemap_check_errors(struct address_space *mapping);
 extern void __filemap_set_wb_err(struct address_space *mapping, int err);
 
+static inline int filemap_write_and_wait(struct address_space *mapping)
+{
+	return filemap_write_and_wait_range(mapping, 0, LLONG_MAX);
+}
+
 extern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,
 						loff_t lend);
 extern int __must_check file_check_and_advance_wb_err(struct file *file);

commit 33c84e89abe4a92ab699c33029bd54269d574782
Merge: e9f8ca0ae7b7 11e673206f21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 29 18:16:16 2020 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This series is slightly unusual because it includes Arnd's compat
      ioctl tree here:
    
        1c46a2cf2dbd Merge tag 'block-ioctl-cleanup-5.6' into 5.6/scsi-queue
    
      Excluding Arnd's changes, this is mostly an update of the usual
      drivers: megaraid_sas, mpt3sas, qla2xxx, ufs, lpfc, hisi_sas.
    
      There are a couple of core and base updates around error propagation
      and atomicity in the attribute container base we use for the SCSI
      transport classes.
    
      The rest is minor changes and updates"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (149 commits)
      scsi: hisi_sas: Rename hisi_sas_cq.pci_irq_mask
      scsi: hisi_sas: Add prints for v3 hw interrupt converge and automatic affinity
      scsi: hisi_sas: Modify the file permissions of trigger_dump to write only
      scsi: hisi_sas: Replace magic number when handle channel interrupt
      scsi: hisi_sas: replace spin_lock_irqsave/spin_unlock_restore with spin_lock/spin_unlock
      scsi: hisi_sas: use threaded irq to process CQ interrupts
      scsi: ufs: Use UFS device indicated maximum LU number
      scsi: ufs: Add max_lu_supported in struct ufs_dev_info
      scsi: ufs: Delete is_init_prefetch from struct ufs_hba
      scsi: ufs: Inline two functions into their callers
      scsi: ufs: Move ufshcd_get_max_pwr_mode() to ufshcd_device_params_init()
      scsi: ufs: Split ufshcd_probe_hba() based on its called flow
      scsi: ufs: Delete struct ufs_dev_desc
      scsi: ufs: Fix ufshcd_probe_hba() reture value in case ufshcd_scsi_add_wlus() fails
      scsi: ufs-mediatek: enable low-power mode for hibern8 state
      scsi: ufs: export some functions for vendor usage
      scsi: ufs-mediatek: add dbg_register_dump implementation
      scsi: qla2xxx: Fix a NULL pointer dereference in an error path
      scsi: qla1280: Make checking for 64bit support consistent
      scsi: megaraid_sas: Update driver version to 07.713.01.00-rc1
      ...

commit 5dcdc43e24a1810d3c3f4959af3d0c8e0026d863
Author: Jiufei Xue <jiufei.xue@linux.alibaba.com>
Date:   Wed Nov 20 17:45:25 2019 +0800

    vfs: add vfs_iocb_iter_[read|write] helper functions
    
    This doesn't cause any behavior changes and will be used by overlay async
    IO implementation.
    
    Signed-off-by: Jiufei Xue <jiufei.xue@linux.alibaba.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..28315a286bab 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2078,6 +2078,18 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 	};
 }
 
+static inline void kiocb_clone(struct kiocb *kiocb, struct kiocb *kiocb_src,
+			       struct file *filp)
+{
+	*kiocb = (struct kiocb) {
+		.ki_filp = filp,
+		.ki_flags = kiocb_src->ki_flags,
+		.ki_hint = kiocb_src->ki_hint,
+		.ki_ioprio = kiocb_src->ki_ioprio,
+		.ki_pos = kiocb_src->ki_pos,
+	};
+}
+
 /*
  * Inode state bits.  Protected by inode->i_lock
  *
@@ -3108,6 +3120,10 @@ ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,
 		rwf_t flags);
 ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,
 		rwf_t flags);
+ssize_t vfs_iocb_iter_read(struct file *file, struct kiocb *iocb,
+			   struct iov_iter *iter);
+ssize_t vfs_iocb_iter_write(struct file *file, struct kiocb *iocb,
+			    struct iov_iter *iter);
 
 /* fs/block_dev.c */
 extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);

commit 77b9040195dea3fcddf19e136c9e99a501351778
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 27 21:25:36 2019 +0100

    compat_ioctl: simplify the implementation
    
    Now that both native and compat ioctl syscalls are
    in the same file, a couple of simplifications can
    be made, bringing the implementation closer together:
    
    - do_vfs_ioctl(), ioctl_preallocate(), and compat_ioctl_preallocate()
      can become static, allowing the compiler to optimize better
    
    - slightly update the coding style for consistency between
      the functions.
    
    - rather than listing each command in two switch statements
      for the compat case, just call a single function that has
      all the common commands.
    
    As a side-effect, FS_IOC_RESVSP/FS_IOC_RESVSP64 are now available
    to x86 compat tasks, along with FS_IOC_RESVSP_32/FS_IOC_RESVSP64_32.
    This is harmless for i386 emulation, and can be considered a bugfix
    for x32 emulation, which never supported these in the past.
    
    Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..daf570bca42a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2552,10 +2552,6 @@ extern int finish_open(struct file *file, struct dentry *dentry,
 			int (*open)(struct inode *, struct file *));
 extern int finish_no_open(struct file *file, struct dentry *dentry);
 
-/* fs/ioctl.c */
-
-extern int ioctl_preallocate(struct file *filp, int mode, void __user *argp);
-
 /* fs/dcache.c */
 extern void __init vfs_caches_init_early(void);
 extern void __init vfs_caches_init(void);

commit a3d1e7eb5abe3aa1095bc75d1a6760d3809bd672
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 18 09:43:10 2019 -0500

    simple_recursive_removal(): kernel-side rm -rf for ramfs-style filesystems
    
    two requirements: no file creations in IS_DEADDIR and no cross-directory
    renames whatsoever.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..9a2be7c0c088 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3303,6 +3303,8 @@ extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *,
 			 struct inode *, struct dentry *, unsigned int);
+extern void simple_recursive_removal(struct dentry *,
+                              void (*callback)(struct dentry *));
 extern int noop_fsync(struct file *, loff_t, loff_t, int);
 extern int noop_set_page_dirty(struct page *page);
 extern void noop_invalidatepage(struct page *page, unsigned int offset,

commit ba70609d5ec664a8f36ba1c857fcd97a478adf79
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Mon Dec 2 21:19:44 2019 -0800

    fs: Delete timespec64_trunc()
    
    There are no more callers to the function remaining.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..46dd7e6f6d73 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1575,7 +1575,6 @@ static inline void i_gid_write(struct inode *inode, gid_t gid)
 	inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
 }
 
-extern struct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran);
 extern struct timespec64 current_time(struct inode *inode);
 
 /*

commit 2496396fcb44404ead24b578c583d5286886e857
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Oct 15 21:18:10 2019 +0200

    sched/rt, fs: Use CONFIG_PREEMPTION
    
    CONFIG_PREEMPTION is selected by CONFIG_PREEMPT and by CONFIG_PREEMPT_RT.
    Both PREEMPT and PREEMPT_RT require the same functionality which today
    depends on CONFIG_PREEMPT.
    
    Switch the i_size() and part_nr_sects_() code over to use
    CONFIG_PREEMPTION. Update the comment for fsstack_copy_inode_size() also
    to refer to CONFIG_PREEMPTION.
    
    [bigeasy: +PREEMPT comments]
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: linux-fsdevel@vger.kernel.org
    Link: https://lore.kernel.org/r/20191015191821.11479-24-bigeasy@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98e0349adb52..dddfcbb140a7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -855,7 +855,7 @@ static inline loff_t i_size_read(const struct inode *inode)
 		i_size = inode->i_size;
 	} while (read_seqcount_retry(&inode->i_size_seqcount, seq));
 	return i_size;
-#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)
 	loff_t i_size;
 
 	preempt_disable();
@@ -880,7 +880,7 @@ static inline void i_size_write(struct inode *inode, loff_t i_size)
 	inode->i_size = i_size;
 	write_seqcount_end(&inode->i_size_seqcount);
 	preempt_enable();
-#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)
 	preempt_disable();
 	inode->i_size = i_size;
 	preempt_enable();

commit 97eeb4d9d755605385fa329da9afa38729f3413c
Merge: 9b326948c239 8feb4732ff9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 2 14:46:22 2019 -0800

    Merge tag 'xfs-5.5-merge-16' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull XFS updates from Darrick Wong:
     "For this release, we changed quite a few things.
    
      Highlights:
    
       - Fixed some long tail latency problems in the block allocator
    
       - Removed some long deprecated (and for the past several years no-op)
         mount options and ioctls
    
       - Strengthened the extended attribute and directory verifiers
    
       - Audited and fixed all the places where we could return EFSCORRUPTED
         without logging anything
    
       - Refactored the old SGI space allocation ioctls to make the
         equivalent fallocate calls
    
       - Fixed a race between fallocate and directio
    
       - Fixed an integer overflow when files have more than a few
         billion(!) extents
    
       - Fixed a longstanding bug where quota accounting could be incorrect
         when performing unwritten extent conversion on a freshly mounted fs
    
       - Fixed various complaints in scrub about soft lockups and
         unresponsiveness to signals
    
       - De-vtable'd the directory handling code, which should make it
         faster
    
       - Converted to the new mount api, for better or for worse
    
       - Cleaned up some memory leaks
    
      and quite a lot of other smaller fixes and cleanups.
    
      A more detailed summary:
    
       - Fill out the build string
    
       - Prevent inode fork extent count overflows
    
       - Refactor the allocator to reduce long tail latency
    
       - Rework incore log locking a little to reduce spinning
    
       - Break up the xfs_iomap_begin functions into smaller more cohesive
         parts
    
       - Fix allocation alignment being dropped too early when the
         allocation request is for more blocks than an AG is large
    
       - Other small cleanups
    
       - Clean up file buftarg retrieval helpers
    
       - Hoist the resvsp and unresvsp ioctls to the vfs
    
       - Remove the undocumented biosize mount option, since it has never
         been mentioned as existing or supported on linux
    
       - Clean up some of the mount option printing and parsing
    
       - Enhance attr leaf verifier to check block structure
    
       - Check dirent and attr names for invalid characters before passing
         them to the vfs
    
       - Refactor open-coded bmbt walking
    
       - Fix a few places where we return EIO instead of EFSCORRUPTED after
         failing metadata sanity checks
    
       - Fix a synchronization problem between fallocate and aio dio
         corrupting the file length
    
       - Clean up various loose ends in the iomap and bmap code
    
       - Convert to the new mount api
    
       - Make sure we always log something when returning EFSCORRUPTED
    
       - Fix some problems where long running scrub loops could trigger soft
         lockup warnings and/or fail to exit due to fatal signals pending
    
       - Fix various Coverity complaints
    
       - Remove most of the function pointers from the directory code to
         reduce indirection penalties
    
       - Ensure that dquots are attached to the inode when performing
         unwritten extent conversion after io
    
       - Deuglify incore projid and crtime types
    
       - Fix another AGI/AGF locking order deadlock when renaming
    
       - Clean up some quota typedefs
    
       - Remove the FSSETDM ioctls which haven't done anything in 20 years
    
       - Fix some memory leaks when mounting the log fails
    
       - Fix an underflow when updating an xattr leaf freemap
    
       - Remove some trivial wrappers
    
       - Report metadata corruption as an error, not a (potentially) fatal
         assertion
    
       - Clean up the dir/attr buffer mapping code
    
       - Allow fatal signals to kill scrub during parent pointer checks"
    
    * tag 'xfs-5.5-merge-16' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux: (198 commits)
      xfs: allow parent directory scans to be interrupted with fatal signals
      xfs: remove the mappedbno argument to xfs_da_get_buf
      xfs: remove the mappedbno argument to xfs_da_read_buf
      xfs: split xfs_da3_node_read
      xfs: remove the mappedbno argument to xfs_dir3_leafn_read
      xfs: remove the mappedbno argument to xfs_dir3_leaf_read
      xfs: remove the mappedbno argument to xfs_attr3_leaf_read
      xfs: remove the mappedbno argument to xfs_da_reada_buf
      xfs: improve the xfs_dabuf_map calling conventions
      xfs: refactor xfs_dabuf_map
      xfs: simplify mappedbno handling in xfs_da_{get,read}_buf
      xfs: report corruption only as a regular error
      xfs: Remove kmem_zone_free() wrapper
      xfs: Remove kmem_zone_destroy() wrapper
      xfs: Remove slab init wrappers
      xfs: fix attr leaf header freemap.size underflow
      xfs: fix some memory leaks in log recovery
      xfs: fix another missing include
      xfs: remove XFS_IOC_FSSETDM and XFS_IOC_FSSETDM_BY_HANDLE
      xfs: remove duplicated include from xfs_dir2_data.c
      ...

commit 596cf45cbf6e4fa7bcb0df33e373a7d062b644b5
Merge: c3bfc5dd73c6 937790699be9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 1 20:36:41 2019 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge updates from Andrew Morton:
     "Incoming:
    
       - a small number of updates to scripts/, ocfs2 and fs/buffer.c
    
       - most of MM
    
      I still have quite a lot of material (mostly not MM) staged after
      linux-next due to -next dependencies. I'll send those across next week
      as the preprequisites get merged up"
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (135 commits)
      mm/page_io.c: annotate refault stalls from swap_readpage
      mm/Kconfig: fix trivial help text punctuation
      mm/Kconfig: fix indentation
      mm/memory_hotplug.c: remove __online_page_set_limits()
      mm: fix typos in comments when calling __SetPageUptodate()
      mm: fix struct member name in function comments
      mm/shmem.c: cast the type of unmap_start to u64
      mm: shmem: use proper gfp flags for shmem_writepage()
      mm/shmem.c: make array 'values' static const, makes object smaller
      userfaultfd: require CAP_SYS_PTRACE for UFFD_FEATURE_EVENT_FORK
      fs/userfaultfd.c: wp: clear VM_UFFD_MISSING or VM_UFFD_WP during userfaultfd_register()
      userfaultfd: wrap the common dst_vma check into an inlined function
      userfaultfd: remove unnecessary WARN_ON() in __mcopy_atomic_hugetlb()
      userfaultfd: use vma_pagesize for all huge page size calculation
      mm/madvise.c: use PAGE_ALIGN[ED] for range checking
      mm/madvise.c: replace with page_size() in madvise_inject_error()
      mm/mmap.c: make vma_merge() comment more easy to understand
      mm/hwpoison-inject: use DEFINE_DEBUGFS_ATTRIBUTE to define debugfs fops
      autonuma: reduce cache footprint when scanning page tables
      autonuma: fix watermark checking in migrate_balanced_pgdat()
      ...

commit 0da522107e5d9c000a4871d52e570912aa1225a2
Merge: ad0b314e0030 142b2ac82e31
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 1 13:46:15 2019 -0800

    Merge tag 'compat-ioctl-5.5' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground
    
    Pull removal of most of fs/compat_ioctl.c from Arnd Bergmann:
     "As part of the cleanup of some remaining y2038 issues, I came to
      fs/compat_ioctl.c, which still has a couple of commands that need
      support for time64_t.
    
      In completely unrelated work, I spent time on cleaning up parts of
      this file in the past, moving things out into drivers instead.
    
      After Al Viro reviewed an earlier version of this series and did a lot
      more of that cleanup, I decided to try to completely eliminate the
      rest of it and move it all into drivers.
    
      This series incorporates some of Al's work and many patches of my own,
      but in the end stops short of actually removing the last part, which
      is the scsi ioctl handlers. I have patches for those as well, but they
      need more testing or possibly a rewrite"
    
    * tag 'compat-ioctl-5.5' of git://git.kernel.org:/pub/scm/linux/kernel/git/arnd/playground: (42 commits)
      scsi: sd: enable compat ioctls for sed-opal
      pktcdvd: add compat_ioctl handler
      compat_ioctl: move SG_GET_REQUEST_TABLE handling
      compat_ioctl: ppp: move simple commands into ppp_generic.c
      compat_ioctl: handle PPPIOCGIDLE for 64-bit time_t
      compat_ioctl: move PPPIOCSCOMPRESS to ppp_generic
      compat_ioctl: unify copy-in of ppp filters
      tty: handle compat PPP ioctls
      compat_ioctl: move SIOCOUTQ out of compat_ioctl.c
      compat_ioctl: handle SIOCOUTQNSD
      af_unix: add compat_ioctl support
      compat_ioctl: reimplement SG_IO handling
      compat_ioctl: move WDIOC handling into wdt drivers
      fs: compat_ioctl: move FITRIM emulation into file systems
      gfs2: add compat_ioctl support
      compat_ioctl: remove unused convert_in_user macro
      compat_ioctl: remove last RAID handling code
      compat_ioctl: remove /dev/raw ioctl translation
      compat_ioctl: remove PCI ioctl translation
      compat_ioctl: remove joystick ioctl translation
      ...

commit a92853b6746fe5ffef20a7c30addf6320561e669
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Sat Nov 30 17:49:44 2019 -0800

    fs/direct-io.c: keep dio_warn_stale_pagecache() when CONFIG_BLOCK=n
    
    This helper prints warning if direct I/O write failed to invalidate cache,
    and set EIO at inode to warn usersapce about possible data corruption.
    
    See also commit 5a9d929d6e13 ("iomap: report collisions between directio
    and buffered writes to userspace").
    
    Direct I/O is supported by non-disk filesystems, for example NFS.  Thus
    generic code needs this even in kernel without CONFIG_BLOCK.
    
    Link: http://lkml.kernel.org/r/157270038074.4812.7980855544557488880.stgit@buzz
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ae6c5c37f3ae..eeed80fab36a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3149,7 +3149,6 @@ enum {
 };
 
 void dio_end_io(struct bio *bio);
-void dio_warn_stale_pagecache(struct file *filp);
 
 ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
 			     struct block_device *bdev, struct iov_iter *iter,
@@ -3194,6 +3193,11 @@ static inline void inode_dio_end(struct inode *inode)
 		wake_up_bit(&inode->i_state, __I_DIO_WAKEUP);
 }
 
+/*
+ * Warn about a page cache invalidation failure diring a direct I/O write.
+ */
+void dio_warn_stale_pagecache(struct file *filp);
+
 extern void inode_set_flags(struct inode *inode, unsigned int flags,
 			    unsigned int mask);
 

commit 2be7d348fe924f0c5583c6a805bd42cecda93104
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 26 11:34:06 2019 -0800

    Revert "vfs: properly and reliably lock f_pos in fdget_pos()"
    
    This reverts commit 0be0ee71816b2b6725e2b4f32ad6726c9d729777.
    
    I was hoping it would be benign to switch over entirely to FMODE_STREAM,
    and we'd have just a couple of small fixups we'd need, but it looks like
    we're not quite there yet.
    
    While it worked fine on both my desktop and laptop, they are fairly
    similar in other respects, and run mostly the same loads.  Kenneth
    Crudup reports that it seems to break both his vmware installation and
    the KDE upower service.  In both cases apparently leading to timeouts
    due to waitinmg for the f_pos lock.
    
    There are a number of character devices in particular that definitely
    want stream-like behavior, but that currently don't get marked as
    streams, and as a result get the exclusion between concurrent
    read()/write() on the same file descriptor.  Which doesn't work well for
    them.
    
    The most obvious example if this is /dev/console and /dev/tty, which use
    console_fops and tty_fops respectively (and ptmx_fops for the pty master
    side).  It may be that it's just this that causes problems, but we
    clearly weren't ready yet.
    
    Because there's a number of other likely common cases that don't have
    llseek implementations and would seem to act as stream devices:
    
      /dev/fuse             (fuse_dev_operations)
      /dev/mcelog           (mce_chrdev_ops)
      /dev/mei0             (mei_fops)
      /dev/net/tun          (tun_fops)
      /dev/nvme0            (nvme_dev_fops)
      /dev/tpm0             (tpm_fops)
      /proc/self/ns/mnt     (ns_file_operations)
      /dev/snd/pcm*         (snd_pcm_f_ops[])
    
    and while some of these could be trivially automatically detected by the
    vfs layer when the character device is opened by just noticing that they
    have no read or write operations either, it often isn't that obvious.
    
    Some character devices most definitely do use the file position, even if
    they don't allow seeking: the firmware update code, for example, uses
    simple_read_from_buffer() that does use f_pos, but doesn't allow seeking
    back and forth.
    
    We'll revisit this when there's a better way to detect the problem and
    fix it (possibly with a coccinelle script to do more of the FMODE_STREAM
    annotations).
    
    Reported-by: Kenneth R. Crudup <kenny@panix.com>
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dde6dc4492a0..ae6c5c37f3ae 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -148,6 +148,8 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File is opened with O_PATH; almost nothing can be done with it */
 #define FMODE_PATH		((__force fmode_t)0x4000)
 
+/* File needs atomic accesses to f_pos */
+#define FMODE_ATOMIC_POS	((__force fmode_t)0x8000)
 /* Write access to underlying fs */
 #define FMODE_WRITER		((__force fmode_t)0x10000)
 /* Has read method(s) */

commit 7e5192b93c3b8661791f65f0d477d0da234ca202
Merge: 464a47f45d2a 979c690d9a01
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 25 11:37:01 2019 -0800

    Merge tag 'for-5.5/disk-revalidate-20191122' of git://git.kernel.dk/linux-block
    
    Pull disk revalidation updates from Jens Axboe:
     "This continues the work that Jan Kara started to thoroughly cleanup
      and consolidate how we handle rescans and revalidations"
    
    * tag 'for-5.5/disk-revalidate-20191122' of git://git.kernel.dk/linux-block:
      block: move clearing bd_invalidated into check_disk_size_change
      block: remove (__)blkdev_reread_part as an exported API
      block: fix bdev_disk_changed for non-partitioned devices
      block: move rescan_partitions to fs/block_dev.c
      block: merge invalidate_partitions into rescan_partitions
      block: refactor rescan_partitions

commit 0be0ee71816b2b6725e2b4f32ad6726c9d729777
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 11 15:51:03 2019 -0800

    vfs: properly and reliably lock f_pos in fdget_pos()
    
    fdget_pos() is used by file operations that will read and update f_pos:
    things like "read()", "write()" and "lseek()" (but not, for example,
    "pread()/pwrite" that get their file positions elsewhere).
    
    However, it had two separate escape clauses for this, because not
    everybody wants or needs serialization of the file position.
    
    The first and most obvious case is the "file descriptor doesn't have a
    position at all", ie a stream-like file.  Except we didn't actually use
    FMODE_STREAM, but instead used FMODE_ATOMIC_POS.  The reason for that
    was that FMODE_STREAM didn't exist back in the days, but also that we
    didn't want to mark all the special cases, so we only marked the ones
    that _required_ position atomicity according to POSIX - regular files
    and directories.
    
    The case one was intentionally lazy, but now that we _do_ have
    FMODE_STREAM we could and should just use it.  With the change to use
    FMODE_STREAM, there are no remaining uses for FMODE_ATOMIC_POS, and all
    the code to set it is deleted.
    
    Any cases where we don't want the serialization because the driver (or
    subsystem) doesn't use the file position should just be updated to do
    "stream_open()".  We've done that for all the obvious and common
    situations, we may need a few more.  Quoting Kirill Smelkov in the
    original FMODE_STREAM thread (see link below for full email):
    
     "And I appreciate if people could help at least somehow with "getting
      rid of mixed case entirely" (i.e. always lock f_pos_lock on
      !FMODE_STREAM), because this transition starts to diverge from my
      particular use-case too far. To me it makes sense to do that
      transition as follows:
    
       - convert nonseekable_open -> stream_open via stream_open.cocci;
       - audit other nonseekable_open calls and convert left users that
         truly don't depend on position to stream_open;
       - extend stream_open.cocci to analyze alloc_file_pseudo as well (this
         will cover pipes and sockets), or maybe convert pipes and sockets
         to FMODE_STREAM manually;
       - extend stream_open.cocci to analyze file_operations that use
         no_llseek or noop_llseek, but do not use nonseekable_open or
         alloc_file_pseudo. This might find files that have stream semantic
         but are opened differently;
       - extend stream_open.cocci to analyze file_operations whose
         .read/.write do not use ppos at all (independently of how file was
         opened);
       - ...
       - after that remove FMODE_ATOMIC_POS and always take f_pos_lock if
         !FMODE_STREAM;
       - gather bug reports for deadlocked read/write and convert missed
         cases to FMODE_STREAM, probably extending stream_open.cocci along
         the road to catch similar cases
    
      i.e. always take f_pos_lock unless a file is explicitly marked as
      being stream, and try to find and cover all files that are streams"
    
    We have not done the "extend stream_open.cocci to analyze
    alloc_file_pseudo" as well, but the previous commit did manually handle
    the case of pipes and sockets.
    
    The other case where we can avoid locking f_pos is the "this file
    descriptor only has a single user and it is us, and thus there is no
    need to lock it".
    
    The second test was correct, although a bit subtle and worth just
    re-iterating here.  There are two kinds of other sources of references
    to the same file descriptor: file descriptors that have been explicitly
    shared across fork() or with dup(), and file tables having elevated
    reference counts due to threading (or explicit file sharing with
    clone()).
    
    The first case would have incremented the file count explicitly, and in
    the second case the previous __fdget() would have incremented it for us
    and set the FDPUT_FPUT flag.
    
    But in both cases the file count would be greater than one, so the
    "file_count(file) > 1" test catches both situations.  Also note that if
    file_count is 1, that also means that no other thread can have access to
    the file table, so there also cannot be races with concurrent calls to
    dup()/fork()/clone() that would increment the file count any other way.
    
    Link: https://lore.kernel.org/linux-fsdevel/20190413184404.GA13490@deco.navytux.spb.ru
    Cc: Kirill Smelkov <kirr@nexedi.com>
    Cc: Eic Dumazet <edumazet@google.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Marco Elver <elver@google.com>
    Cc: Andrea Parri <parri.andrea@gmail.com>
    Cc: Paul McKenney <paulmck@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0d909d35763..a7c3f6dd5701 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -148,8 +148,6 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File is opened with O_PATH; almost nothing can be done with it */
 #define FMODE_PATH		((__force fmode_t)0x4000)
 
-/* File needs atomic accesses to f_pos */
-#define FMODE_ATOMIC_POS	((__force fmode_t)0x8000)
 /* Write access to underlying fs */
 #define FMODE_WRITER		((__force fmode_t)0x10000)
 /* Has read method(s) */

commit f0b870df80bc70dad432fd0c142bb709a49964f5
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 14 15:34:36 2019 +0100

    block: remove (__)blkdev_reread_part as an exported API
    
    In general drivers should never mess with partition tables directly.
    Unfortunately s390 and loop do for somewhat historic reasons, but they
    can use bdev_disk_changed directly instead when we export it as they
    satisfy the sanity checks we have in __blkdev_reread_part.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Stefan Haberland <sth@linux.ibm.com>       [dasd]
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d233dd661df7..ae6c5c37f3ae 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2632,8 +2632,6 @@ extern void bd_finish_claiming(struct block_device *bdev,
 extern void bd_abort_claiming(struct block_device *bdev,
 			      struct block_device *whole, void *holder);
 extern void blkdev_put(struct block_device *bdev, fmode_t mode);
-extern int __blkdev_reread_part(struct block_device *bdev);
-extern int blkdev_reread_part(struct block_device *bdev);
 
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);

commit a1548b674403c0de70cc29a1575689917ba60157
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 14 15:34:34 2019 +0100

    block: move rescan_partitions to fs/block_dev.c
    
    Large parts of rescan_partitions aren't about partitions, and
    moving it to block_dev.c will allow for some further cleanups by
    merging it into its only caller.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0d909d35763..d233dd661df7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2703,8 +2703,6 @@ extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
-extern void check_disk_size_change(struct gendisk *disk,
-		struct block_device *bdev, bool verbose);
 extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *, bool);

commit 837a6e7f5cdb5e411c6187729e12962c2705160d
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 24 22:26:02 2019 -0700

    fs: add generic UNRESVSP and ZERO_RANGE ioctl handlers
    
    These use the same scheme as the pre-existing mapping of the XFS
    RESVP ioctls to ->falloc, so just extend it and remove the XFS
    implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    [darrick: fix compile error on s390]
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0d909d35763..2b5692207c1d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2547,7 +2547,7 @@ extern int finish_no_open(struct file *file, struct dentry *dentry);
 
 /* fs/ioctl.c */
 
-extern int ioctl_preallocate(struct file *filp, void __user *argp);
+extern int ioctl_preallocate(struct file *filp, int mode, void __user *argp);
 
 /* fs/dcache.c */
 extern void __init vfs_caches_init_early(void);

commit 2952db0fd51b0890f728df94ac563c21407f4f43
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Sep 11 16:55:03 2018 +0200

    compat_ioctl: add compat_ptr_ioctl()
    
    Many drivers have ioctl() handlers that are completely compatible between
    32-bit and 64-bit architectures, except for the argument that is passed
    down from user space and may have to be passed through compat_ptr()
    in order to become a valid 64-bit pointer.
    
    Using ".compat_ptr = compat_ptr_ioctl" in file operations should let
    us simplify a lot of those drivers to avoid #ifdef checks, and convert
    additional drivers that don't have proper compat handling yet.
    
    On most architectures, the compat_ptr_ioctl() just passes all arguments
    to the corresponding ->ioctl handler. The exception is arch/s390, where
    compat_ptr() clears the top bit of a 32-bit pointer value, so user space
    pointers to the second 2GB alias the first 2GB, as is the case for native
    32-bit s390 user space.
    
    The compat_ptr_ioctl() function must therefore be used only with
    ioctl functions that either ignore the argument or pass a pointer to a
    compatible data type.
    
    If any ioctl command handled by fops->unlocked_ioctl passes a plain
    integer instead of a pointer, or any of the passed data types is
    incompatible between 32-bit and 64-bit architectures, a proper handler
    is required instead of compat_ptr_ioctl.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    ---
    v3: add a better description
    v2: use compat_ptr_ioctl instead of generic_compat_ioctl_ptrarg,
    as suggested by Al Viro

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0d909d35763..0b4d8fc79e0f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1727,6 +1727,13 @@ int vfs_mkobj(struct dentry *, umode_t,
 
 extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 
+#ifdef CONFIG_COMPAT
+extern long compat_ptr_ioctl(struct file *file, unsigned int cmd,
+					unsigned long arg);
+#else
+#define compat_ptr_ioctl NULL
+#endif
+
 /*
  * VFS file helper functions.
  */

commit 298fb76a5583900a155d387efaf37a8b39e5dea2
Merge: 8f744bdee4fe e41f9efb85d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 27 17:00:27 2019 -0700

    Merge tag 'nfsd-5.4' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Highlights:
    
       - Add a new knfsd file cache, so that we don't have to open and close
         on each (NFSv2/v3) READ or WRITE. This can speed up read and write
         in some cases. It also replaces our readahead cache.
    
       - Prevent silent data loss on write errors, by treating write errors
         like server reboots for the purposes of write caching, thus forcing
         clients to resend their writes.
    
       - Tweak the code that allocates sessions to be more forgiving, so
         that NFSv4.1 mounts are less likely to hang when a server already
         has a lot of clients.
    
       - Eliminate an arbitrary limit on NFSv4 ACL sizes; they should now be
         limited only by the backend filesystem and the maximum RPC size.
    
       - Allow the server to enforce use of the correct kerberos credentials
         when a client reclaims state after a reboot.
    
      And some miscellaneous smaller bugfixes and cleanup"
    
    * tag 'nfsd-5.4' of git://linux-nfs.org/~bfields/linux: (34 commits)
      sunrpc: clean up indentation issue
      nfsd: fix nfs read eof detection
      nfsd: Make nfsd_reset_boot_verifier_locked static
      nfsd: degraded slot-count more gracefully as allocation nears exhaustion.
      nfsd: handle drc over-allocation gracefully.
      nfsd: add support for upcall version 2
      nfsd: add a "GetVersion" upcall for nfsdcld
      nfsd: Reset the boot verifier on all write I/O errors
      nfsd: Don't garbage collect files that might contain write errors
      nfsd: Support the server resetting the boot verifier
      nfsd: nfsd_file cache entries should be per net namespace
      nfsd: eliminate an unnecessary acl size limit
      Deprecate nfsd fault injection
      nfsd: remove duplicated include from filecache.c
      nfsd: Fix the documentation for svcxdr_tmpalloc()
      nfsd: Fix up some unused variable warnings
      nfsd: close cached files prior to a REMOVE or RENAME that would replace target
      nfsd: rip out the raparms cache
      nfsd: have nfsd_test_lock use the nfsd_file cache
      nfsd: hook up nfs4_preprocess_stateid_op to the nfsd_file cache
      ...

commit 09d91cda0e8207c1f14ee0d572f61a53dbcdaf85
Author: Song Liu <songliubraving@fb.com>
Date:   Mon Sep 23 15:38:03 2019 -0700

    mm,thp: avoid writes to file with THP in pagecache
    
    In previous patch, an application could put part of its text section in
    THP via madvise().  These THPs will be protected from writes when the
    application is still running (TXTBSY).  However, after the application
    exits, the file is available for writes.
    
    This patch avoids writes to file THP by dropping page cache for the file
    when the file is open for write.  A new counter nr_thps is added to struct
    address_space.  In do_dentry_open(), if the file is open for write and
    nr_thps is non-zero, we drop page cache for the whole file.
    
    Link: http://lkml.kernel.org/r/20190801184244.3169074-8-songliubraving@fb.com
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Acked-by: Rik van Riel <riel@surriel.com>
    Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Hillf Danton <hdanton@sina.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: William Kucharski <william.kucharski@oracle.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 866268c2c6e3..b0c6b0d34d02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -429,6 +429,7 @@ int pagecache_write_end(struct file *, struct address_space *mapping,
  * @i_pages: Cached pages.
  * @gfp_mask: Memory allocation flags to use for allocating pages.
  * @i_mmap_writable: Number of VM_SHARED mappings.
+ * @nr_thps: Number of THPs in the pagecache (non-shmem only).
  * @i_mmap: Tree of private and shared mappings.
  * @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable.
  * @nrpages: Number of page entries, protected by the i_pages lock.
@@ -446,6 +447,10 @@ struct address_space {
 	struct xarray		i_pages;
 	gfp_t			gfp_mask;
 	atomic_t		i_mmap_writable;
+#ifdef CONFIG_READ_ONLY_THP_FOR_FS
+	/* number of thp, only for non-shmem files */
+	atomic_t		nr_thps;
+#endif
 	struct rb_root_cached	i_mmap;
 	struct rw_semaphore	i_mmap_rwsem;
 	unsigned long		nrpages;
@@ -2798,6 +2803,33 @@ static inline errseq_t filemap_sample_wb_err(struct address_space *mapping)
 	return errseq_sample(&mapping->wb_err);
 }
 
+static inline int filemap_nr_thps(struct address_space *mapping)
+{
+#ifdef CONFIG_READ_ONLY_THP_FOR_FS
+	return atomic_read(&mapping->nr_thps);
+#else
+	return 0;
+#endif
+}
+
+static inline void filemap_nr_thps_inc(struct address_space *mapping)
+{
+#ifdef CONFIG_READ_ONLY_THP_FOR_FS
+	atomic_inc(&mapping->nr_thps);
+#else
+	WARN_ON_ONCE(1);
+#endif
+}
+
+static inline void filemap_nr_thps_dec(struct address_space *mapping)
+{
+#ifdef CONFIG_READ_ONLY_THP_FOR_FS
+	atomic_dec(&mapping->nr_thps);
+#else
+	WARN_ON_ONCE(1);
+#endif
+}
+
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);

commit cfb82e1df8b7c76991ea12958855897c2fb4debc
Merge: b41dae061bbd cba465b4f982
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 09:42:37 2019 -0700

    Merge tag 'y2038-vfs' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground
    
    Pull y2038 vfs updates from Arnd Bergmann:
     "Add inode timestamp clamping.
    
      This series from Deepa Dinamani adds a per-superblock minimum/maximum
      timestamp limit for a file system, and clamps timestamps as they are
      written, to avoid random behavior from integer overflow as well as
      having different time stamps on disk vs in memory.
    
      At mount time, a warning is now printed for any file system that can
      represent current timestamps but not future timestamps more than 30
      years into the future, similar to the arbitrary 30 year limit that was
      added to settimeofday().
    
      This was picked as a compromise to warn users to migrate to other file
      systems (e.g. ext4 instead of ext3) when they need the file system to
      survive beyond 2038 (or similar limits in other file systems), but not
      get in the way of normal usage"
    
    * tag 'y2038-vfs' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground:
      ext4: Reduce ext4 timestamp warnings
      isofs: Initialize filesystem timestamp ranges
      pstore: fs superblock limits
      fs: omfs: Initialize filesystem timestamp ranges
      fs: hpfs: Initialize filesystem timestamp ranges
      fs: ceph: Initialize filesystem timestamp ranges
      fs: sysv: Initialize filesystem timestamp ranges
      fs: affs: Initialize filesystem timestamp ranges
      fs: fat: Initialize filesystem timestamp ranges
      fs: cifs: Initialize filesystem timestamp ranges
      fs: nfs: Initialize filesystem timestamp ranges
      ext4: Initialize timestamps limits
      9p: Fill min and max timestamps in sb
      fs: Fill in max and min timestamps in superblock
      utimes: Clamp the timestamps before update
      mount: Add mount warning for impending timestamp expiry
      timestamp_truncate: Replace users of timespec64_trunc
      vfs: Add timestamp_truncate() api
      vfs: Add file timestamp range support

commit b41dae061bbd722b9d7fa828f35d22035b218e18
Merge: e6bc9de71497 14e15f1bcd73
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 18 18:32:43 2019 -0700

    Merge tag 'xfs-5.4-merge-7' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull xfs updates from Darrick Wong:
     "For this cycle we have the usual pile of cleanups and bug fixes, some
      performance improvements for online metadata scrubbing, massive
      speedups in the directory entry creation code, some performance
      improvement in the file ACL lookup code, a fix for a logging stall
      during mount, and fixes for concurrency problems.
    
      It has survived a couple of weeks of xfstests runs and merges cleanly.
    
      Summary:
    
       - Remove KM_SLEEP/KM_NOSLEEP.
    
       - Ensure that memory buffers for IO are properly sector-aligned to
         avoid problems that the block layer doesn't check.
    
       - Make the bmap scrubber more efficient in its record checking.
    
       - Don't crash xfs_db when superblock inode geometry is corrupt.
    
       - Fix btree key helper functions.
    
       - Remove unneeded error returns for things that can't fail.
    
       - Fix buffer logging bugs in repair.
    
       - Clean up iterator return values.
    
       - Speed up directory entry creation.
    
       - Enable allocation of xattr value memory buffer during lookup.
    
       - Fix readahead racing with truncate/punch hole.
    
       - Other minor cleanups.
    
       - Fix one AGI/AGF deadlock with RENAME_WHITEOUT.
    
       - More BUG -> WARN whackamole.
    
       - Fix various problems with the log failing to advance under certain
         circumstances, which results in stalls during mount"
    
    * tag 'xfs-5.4-merge-7' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux: (45 commits)
      xfs: push the grant head when the log head moves forward
      xfs: push iclog state cleaning into xlog_state_clean_log
      xfs: factor iclog state processing out of xlog_state_do_callback()
      xfs: factor callbacks out of xlog_state_do_callback()
      xfs: factor debug code out of xlog_state_do_callback()
      xfs: prevent CIL push holdoff in log recovery
      xfs: fix missed wakeup on l_flush_wait
      xfs: push the AIL in xlog_grant_head_wake
      xfs: Use WARN_ON_ONCE for bailout mount-operation
      xfs: Fix deadlock between AGI and AGF with RENAME_WHITEOUT
      xfs: define a flags field for the AG geometry ioctl structure
      xfs: add a xfs_valid_startblock helper
      xfs: remove the unused XFS_ALLOC_USERDATA flag
      xfs: cleanup xfs_fsb_to_db
      xfs: fix the dax supported check in xfs_ioctl_setattr_dax_invalidate
      xfs: Fix stale data exposure when readahead races with hole punch
      fs: Export generic_fadvise()
      mm: Handle MADV_WILLNEED through vfs_fadvise()
      xfs: allocate xattr buffer on demand
      xfs: consolidate attribute value copying
      ...

commit e6bc9de714972cac34daa1dc1567ee48a47a9342
Merge: b6c0d3577246 dc617f29dbe5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 18 17:35:20 2019 -0700

    Merge tag 'vfs-5.4-merge-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull swap access updates from Darrick Wong:
     "Prohibit writing to active swap files and swap partitions.
    
      There's no non-malicious use case for allowing userspace to scribble
      on storage that the kernel thinks it owns"
    
    * tag 'vfs-5.4-merge-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      vfs: don't allow writes to swap files
      mm: set S_SWAPFILE on blockdev swap devices

commit f60c55a94e1d127186566f06294f2dadd966e9b4
Merge: 734d1ed83e1f 95ae251fe828
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 18 16:59:14 2019 -0700

    Merge tag 'fsverity-for-linus' of git://git.kernel.org/pub/scm/fs/fscrypt/fscrypt
    
    Pull fs-verity support from Eric Biggers:
     "fs-verity is a filesystem feature that provides Merkle tree based
      hashing (similar to dm-verity) for individual readonly files, mainly
      for the purpose of efficient authenticity verification.
    
      This pull request includes:
    
       (a) The fs/verity/ support layer and documentation.
    
       (b) fs-verity support for ext4 and f2fs.
    
      Compared to the original fs-verity patchset from last year, the UAPI
      to enable fs-verity on a file has been greatly simplified. Lots of
      other things were cleaned up too.
    
      fs-verity is planned to be used by two different projects on Android;
      most of the userspace code is in place already. Another userspace tool
      ("fsverity-utils"), and xfstests, are also available. e2fsprogs and
      f2fs-tools already have fs-verity support. Other people have shown
      interest in using fs-verity too.
    
      I've tested this on ext4 and f2fs with xfstests, both the existing
      tests and the new fs-verity tests. This has also been in linux-next
      since July 30 with no reported issues except a couple minor ones I
      found myself and folded in fixes for.
    
      Ted and I will be co-maintaining fs-verity"
    
    * tag 'fsverity-for-linus' of git://git.kernel.org/pub/scm/fs/fscrypt/fscrypt:
      f2fs: add fs-verity support
      ext4: update on-disk format documentation for fs-verity
      ext4: add fs-verity read support
      ext4: add basic fs-verity support
      fs-verity: support builtin file signatures
      fs-verity: add SHA-512 support
      fs-verity: implement FS_IOC_MEASURE_VERITY ioctl
      fs-verity: implement FS_IOC_ENABLE_VERITY ioctl
      fs-verity: add data verification hooks for ->readpages()
      fs-verity: add the hook for file ->setattr()
      fs-verity: add the hook for file ->open()
      fs-verity: add inode and superblock fields
      fs-verity: add Kconfig and the helper functions for hashing
      fs: uapi: define verity bit for FS_IOC_GETFLAGS
      fs-verity: add UAPI header
      fs-verity: add MAINTAINERS file entry
      fs-verity: add a documentation file

commit cf1ea0592dbf109e7e7935b7d5b1a47a1ba04174
Author: Jan Kara <jack@suse.cz>
Date:   Thu Aug 29 09:04:11 2019 -0700

    fs: Export generic_fadvise()
    
    Filesystems will need to call this function from their fadvise handlers.
    
    CC: stable@vger.kernel.org
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 997a530ff4e9..bc1b40fb0db7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3531,6 +3531,8 @@ extern void inode_nohighmem(struct inode *inode);
 /* mm/fadvise.c */
 extern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,
 		       int advice);
+extern int generic_fadvise(struct file *file, loff_t offset, loff_t len,
+			   int advice);
 
 #if defined(CONFIG_IO_URING)
 extern struct sock *io_uring_get_socket(struct file *file);

commit 50e17c000c467fbc927fc001df99beb4027a5323
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sun Jan 21 18:04:25 2018 -0800

    vfs: Add timestamp_truncate() api
    
    timespec_trunc() function is used to truncate a
    filesystem timestamp to the right granularity.
    But, the function does not clamp tv_sec part of the
    timestamps according to the filesystem timestamp limits.
    
    The replacement api: timestamp_truncate() also alters the
    signature of the function to accommodate filesystem
    timestamp clamping according to flesystem limits.
    
    Note that the tv_nsec part is set to 0 if tv_sec is not within
    the range supported for the filesystem.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b349851b00c..7e6be3bf0ce0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -726,6 +726,8 @@ struct inode {
 	void			*i_private; /* fs or device private pointer */
 } __randomize_layout;
 
+struct timespec64 timestamp_truncate(struct timespec64 t, struct inode *inode);
+
 static inline unsigned int i_blocksize(const struct inode *node)
 {
 	return (1 << node->i_blkbits);

commit 188d20bcd1ebd8277d9b8a79525bd66b66d40a2a
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sun Jan 21 18:04:23 2018 -0800

    vfs: Add file timestamp range support
    
    Add fields to the superblock to track the min and max
    timestamps supported by filesystems.
    
    Initially, when a superblock is allocated, initialize
    it to the max and min values the fields can hold.
    Individual filesystems override these to match their
    actual limits.
    
    Pseudo filesystems are assumed to always support the
    min and max allowable values for the fields.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 997a530ff4e9..4b349851b00c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1448,6 +1448,9 @@ struct super_block {
 
 	/* Granularity of c/m/atime in ns (cannot be worse than a second) */
 	u32			s_time_gran;
+	/* Time limits for c/m/atime in seconds */
+	time64_t		   s_time_min;
+	time64_t		   s_time_max;
 #ifdef CONFIG_FSNOTIFY
 	__u32			s_fsnotify_mask;
 	struct fsnotify_mark_connector __rcu	*s_fsnotify_marks;

commit dc617f29dbe5ef0c8ced65ce62c464af1daaab3d
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Aug 20 07:55:16 2019 -0700

    vfs: don't allow writes to swap files
    
    Don't let userspace write to an active swap file because the kernel
    effectively has a long term lease on the storage and things could get
    seriously corrupted if we let this happen.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56b8e358af5c..a2e3d446ba8e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3547,4 +3547,15 @@ static inline void simple_fill_fsxattr(struct fsxattr *fa, __u32 xflags)
 	fa->fsx_xflags = xflags;
 }
 
+/*
+ * Flush file data before changing attributes.  Caller must hold any locks
+ * required to prevent further writes to this file until we're done setting
+ * flags.
+ */
+static inline int inode_drain_writes(struct inode *inode)
+{
+	inode_dio_wait(inode);
+	return filemap_write_and_wait(inode->i_mapping);
+}
+
 #endif /* _LINUX_FS_H */

commit 18f6622ebbdea56a83f8e553c159ce2d62d3ad0c
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Sun Aug 18 14:18:45 2019 -0400

    locks: create a new notifier chain for lease attempts
    
    With the new file caching infrastructure in nfsd, we can end up holding
    files open for an indefinite period of time, even when they are still
    idle. This may prevent the kernel from handing out leases on the file,
    which is something we don't want to block.
    
    Fix this by running a SRCU notifier call chain whenever on any
    lease attempt. nfsd can then purge the cache for that inode before
    returning.
    
    Since SRCU is only conditionally compiled in, we must only define the
    new chain if it's enabled, and users of the chain must ensure that
    SRCU is enabled.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56b8e358af5c..0f106c7f4bb9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1155,6 +1155,11 @@ extern void lease_get_mtime(struct inode *, struct timespec64 *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
 extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
 extern int lease_modify(struct file_lock *, int, struct list_head *);
+
+struct notifier_block;
+extern int lease_register_notifier(struct notifier_block *);
+extern void lease_unregister_notifier(struct notifier_block *);
+
 struct files_struct;
 extern void show_fd_locks(struct seq_file *f,
 			 struct file *filp, struct files_struct *files);

commit 22d94f493bfb408fdd764f7b1d0363af2122fba5
Author: Eric Biggers <ebiggers@google.com>
Date:   Sun Aug 4 19:35:46 2019 -0700

    fscrypt: add FS_IOC_ADD_ENCRYPTION_KEY ioctl
    
    Add a new fscrypt ioctl, FS_IOC_ADD_ENCRYPTION_KEY.  This ioctl adds an
    encryption key to the filesystem's fscrypt keyring ->s_master_keys,
    making any files encrypted with that key appear "unlocked".
    
    Why we need this
    ~~~~~~~~~~~~~~~~
    
    The main problem is that the "locked/unlocked" (ciphertext/plaintext)
    status of encrypted files is global, but the fscrypt keys are not.
    fscrypt only looks for keys in the keyring(s) the process accessing the
    filesystem is subscribed to: the thread keyring, process keyring, and
    session keyring, where the session keyring may contain the user keyring.
    
    Therefore, userspace has to put fscrypt keys in the keyrings for
    individual users or sessions.  But this means that when a process with a
    different keyring tries to access encrypted files, whether they appear
    "unlocked" or not is nondeterministic.  This is because it depends on
    whether the files are currently present in the inode cache.
    
    Fixing this by consistently providing each process its own view of the
    filesystem depending on whether it has the key or not isn't feasible due
    to how the VFS caches work.  Furthermore, while sometimes users expect
    this behavior, it is misguided for two reasons.  First, it would be an
    OS-level access control mechanism largely redundant with existing access
    control mechanisms such as UNIX file permissions, ACLs, LSMs, etc.
    Encryption is actually for protecting the data at rest.
    
    Second, almost all users of fscrypt actually do need the keys to be
    global.  The largest users of fscrypt, Android and Chromium OS, achieve
    this by having PID 1 create a "session keyring" that is inherited by
    every process.  This works, but it isn't scalable because it prevents
    session keyrings from being used for any other purpose.
    
    On general-purpose Linux distros, the 'fscrypt' userspace tool [1] can't
    similarly abuse the session keyring, so to make 'sudo' work on all
    systems it has to link all the user keyrings into root's user keyring
    [2].  This is ugly and raises security concerns.  Moreover it can't make
    the keys available to system services, such as sshd trying to access the
    user's '~/.ssh' directory (see [3], [4]) or NetworkManager trying to
    read certificates from the user's home directory (see [5]); or to Docker
    containers (see [6], [7]).
    
    By having an API to add a key to the *filesystem* we'll be able to fix
    the above bugs, remove userspace workarounds, and clearly express the
    intended semantics: the locked/unlocked status of an encrypted directory
    is global, and encryption is orthogonal to OS-level access control.
    
    Why not use the add_key() syscall
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    We use an ioctl for this API rather than the existing add_key() system
    call because the ioctl gives us the flexibility needed to implement
    fscrypt-specific semantics that will be introduced in later patches:
    
    - Supporting key removal with the semantics such that the secret is
      removed immediately and any unused inodes using the key are evicted;
      also, the eviction of any in-use inodes can be retried.
    
    - Calculating a key-dependent cryptographic identifier and returning it
      to userspace.
    
    - Allowing keys to be added and removed by non-root users, but only keys
      for v2 encryption policies; and to prevent denial-of-service attacks,
      users can only remove keys they themselves have added, and a key is
      only really removed after all users who added it have removed it.
    
    Trying to shoehorn these semantics into the keyrings syscalls would be
    very difficult, whereas the ioctls make things much easier.
    
    However, to reuse code the implementation still uses the keyrings
    service internally.  Thus we get lockless RCU-mode key lookups without
    having to re-implement it, and the keys automatically show up in
    /proc/keys for debugging purposes.
    
    References:
    
        [1] https://github.com/google/fscrypt
        [2] https://goo.gl/55cCrI#heading=h.vf09isp98isb
        [3] https://github.com/google/fscrypt/issues/111#issuecomment-444347939
        [4] https://github.com/google/fscrypt/issues/116
        [5] https://bugs.launchpad.net/ubuntu/+source/fscrypt/+bug/1770715
        [6] https://github.com/google/fscrypt/issues/128
        [7] https://askubuntu.com/questions/1130306/cannot-run-docker-on-an-encrypted-filesystem
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 997a530ff4e9..5dff77326cec 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1427,6 +1427,7 @@ struct super_block {
 	const struct xattr_handler **s_xattr;
 #ifdef CONFIG_FS_ENCRYPTION
 	const struct fscrypt_operations	*s_cop;
+	struct key		*s_master_keys; /* master crypto keys in use */
 #endif
 	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */

commit 89e524c04fa966330e2e80ab2bc50b9944c5847a
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jul 30 13:10:14 2019 +0200

    loop: Fix mount(2) failure due to race with LOOP_SET_FD
    
    Commit 33ec3e53e7b1 ("loop: Don't change loop device under exclusive
    opener") made LOOP_SET_FD ioctl acquire exclusive block device reference
    while it updates loop device binding. However this can make perfectly
    valid mount(2) fail with EBUSY due to racing LOOP_SET_FD holding
    temporarily the exclusive bdev reference in cases like this:
    
    for i in {a..z}{a..z}; do
            dd if=/dev/zero of=$i.image bs=1k count=0 seek=1024
            mkfs.ext2 $i.image
            mkdir mnt$i
    done
    
    echo "Run"
    for i in {a..z}{a..z}; do
            mount -o loop -t ext2 $i.image mnt$i &
    done
    
    Fix the problem by not getting full exclusive bdev reference in
    LOOP_SET_FD but instead just mark the bdev as being claimed while we
    update the binding information. This just blocks new exclusive openers
    instead of failing them with EBUSY thus fixing the problem.
    
    Fixes: 33ec3e53e7b1 ("loop: Don't change loop device under exclusive opener")
    Cc: stable@vger.kernel.org
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56b8e358af5c..997a530ff4e9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2598,6 +2598,12 @@ extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
 					       void *holder);
 extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
 					      void *holder);
+extern struct block_device *bd_start_claiming(struct block_device *bdev,
+					      void *holder);
+extern void bd_finish_claiming(struct block_device *bdev,
+			       struct block_device *whole, void *holder);
+extern void bd_abort_claiming(struct block_device *bdev,
+			      struct block_device *whole, void *holder);
 extern void blkdev_put(struct block_device *bdev, fmode_t mode);
 extern int __blkdev_reread_part(struct block_device *bdev);
 extern int blkdev_reread_part(struct block_device *bdev);

commit 5585f2af737ae3d7454cb0ae77b995cd3ac7e43c
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Jul 22 09:26:21 2019 -0700

    fs-verity: add inode and superblock fields
    
    Analogous to fs/crypto/, add fields to the VFS inode and superblock for
    use by the fs/verity/ support layer:
    
    - ->s_vop: points to the fsverity_operations if the filesystem supports
      fs-verity, otherwise is NULL.
    
    - ->i_verity_info: points to cached fs-verity information for the inode
      after someone opens it, otherwise is NULL.
    
    - S_VERITY: bit in ->i_flags that identifies verity inodes, even when
      they haven't been opened yet and thus still have NULL ->i_verity_info.
    
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Jaegeuk Kim <jaegeuk@kernel.org>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56b8e358af5c..b3a0f5bfb06d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -64,6 +64,8 @@ struct workqueue_struct;
 struct iov_iter;
 struct fscrypt_info;
 struct fscrypt_operations;
+struct fsverity_info;
+struct fsverity_operations;
 struct fs_context;
 struct fs_parameter_description;
 
@@ -723,6 +725,10 @@ struct inode {
 	struct fscrypt_info	*i_crypt_info;
 #endif
 
+#ifdef CONFIG_FS_VERITY
+	struct fsverity_info	*i_verity_info;
+#endif
+
 	void			*i_private; /* fs or device private pointer */
 } __randomize_layout;
 
@@ -1427,6 +1433,9 @@ struct super_block {
 	const struct xattr_handler **s_xattr;
 #ifdef CONFIG_FS_ENCRYPTION
 	const struct fscrypt_operations	*s_cop;
+#endif
+#ifdef CONFIG_FS_VERITY
+	const struct fsverity_operations *s_vop;
 #endif
 	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
@@ -1965,6 +1974,7 @@ struct super_operations {
 #endif
 #define S_ENCRYPTED	16384	/* Encrypted file (using fs/crypto/) */
 #define S_CASEFOLD	32768	/* Casefolded file */
+#define S_VERITY	65536	/* Verity file (using fs/verity/) */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -2006,6 +2016,7 @@ static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags
 #define IS_DAX(inode)		((inode)->i_flags & S_DAX)
 #define IS_ENCRYPTED(inode)	((inode)->i_flags & S_ENCRYPTED)
 #define IS_CASEFOLDED(inode)	((inode)->i_flags & S_CASEFOLD)
+#define IS_VERITY(inode)	((inode)->i_flags & S_VERITY)
 
 #define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
 				 (inode)->i_rdev == WHITEOUT_DEV)

commit 933a90bf4f3505f8ec83bda21a3c7d70d7c2b426
Merge: 5f4fc6d440d7 037f11b4752f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 10:42:02 2019 -0700

    Merge branch 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount updates from Al Viro:
     "The first part of mount updates.
    
      Convert filesystems to use the new mount API"
    
    * 'work.mount0' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      mnt_init(): call shmem_init() unconditionally
      constify ksys_mount() string arguments
      don't bother with registering rootfs
      init_rootfs(): don't bother with init_ramfs_fs()
      vfs: Convert smackfs to use the new mount API
      vfs: Convert selinuxfs to use the new mount API
      vfs: Convert securityfs to use the new mount API
      vfs: Convert apparmorfs to use the new mount API
      vfs: Convert openpromfs to use the new mount API
      vfs: Convert xenfs to use the new mount API
      vfs: Convert gadgetfs to use the new mount API
      vfs: Convert oprofilefs to use the new mount API
      vfs: Convert ibmasmfs to use the new mount API
      vfs: Convert qib_fs/ipathfs to use the new mount API
      vfs: Convert efivarfs to use the new mount API
      vfs: Convert configfs to use the new mount API
      vfs: Convert binfmt_misc to use the new mount API
      convenience helper: get_tree_single()
      convenience helper get_tree_nodev()
      vfs: Kill sget_userns()
      ...

commit 5010fe9f095414b959fd6fda63986dc90fd0c419
Merge: 8487d8229990 dbc77f31e58b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 16:54:37 2019 -0700

    Merge tag 'vfs-fix-ioctl-checking-3' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull common SETFLAGS/FSSETXATTR parameter checking from Darrick Wong:
     "Here's a patch series that sets up common parameter checking functions
      for the FS_IOC_SETFLAGS and FS_IOC_FSSETXATTR ioctl implementations.
    
      The goal here is to reduce the amount of behaviorial variance between
      the filesystems where those ioctls originated (ext2 and XFS,
      respectively) and everybody else.
    
       - Standardize parameter checking for the SETFLAGS and FSSETXATTR
         ioctls (which were the file attribute setters for ext4 and xfs and
         have now been hoisted to the vfs)
    
       - Only allow the DAX flag to be set on files and directories"
    
    * tag 'vfs-fix-ioctl-checking-3' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      vfs: only allow FSSETXATTR to set DAX flag on files and dirs
      vfs: teach vfs_ioc_fssetxattr_check to check extent size hints
      vfs: teach vfs_ioc_fssetxattr_check to check project id info
      vfs: create a generic checking function for FS_IOC_FSSETXATTR
      vfs: create a generic checking and prep function for FS_IOC_SETFLAGS

commit d2b6b4c832f7e3067709e8d4970b7b82b44419ac
Merge: 0248a8be6d21 b78fa45d4edb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 21:22:43 2019 -0700

    Merge tag 'nfsd-5.3' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Highlights:
    
       - Add a new /proc/fs/nfsd/clients/ directory which exposes some
         long-requested information about NFSv4 clients (like open files)
         and allows forced revocation of client state.
    
       - Replace the global duplicate reply cache by a cache per network
         namespace; previously, a request in one network namespace could
         incorrectly match an entry from another, though we haven't seen
         this in production. This is the last remaining container bug that
         I'm aware of; at this point you should be able to run separate
         nfsd's in each network namespace, each with their own set of
         exports, and everything should work.
    
       - Cleanup and modify lock code to show the pid of lockd as the owner
         of NLM locks. This is the correct version of the bugfix originally
         attempted in b8eee0e90f97 ("lockd: Show pid of lockd for remote
         locks")"
    
    * tag 'nfsd-5.3' of git://linux-nfs.org/~bfields/linux: (34 commits)
      nfsd: Make __get_nfsdfs_client() static
      nfsd: Make two functions static
      nfsd: Fix misuse of strlcpy
      sunrpc/cache: remove the exporting of cache_seq_next
      nfsd: decode implementation id
      nfsd: create xdr_netobj_dup helper
      nfsd: allow forced expiration of NFSv4 clients
      nfsd: create get_nfsdfs_clp helper
      nfsd4: show layout stateids
      nfsd: show lock and deleg stateids
      nfsd4: add file to display list of client's opens
      nfsd: add more information to client info file
      nfsd: escape high characters in binary data
      nfsd: copy client's address including port number to cl_addr
      nfsd4: add a client info file
      nfsd: make client/ directory names small ints
      nfsd: add nfsd/clients directory
      nfsd4: use reference count to free client
      nfsd: rename cl_refcount
      nfsd: persist nfsd filesystem across mounts
      ...

commit 2e756758e5cb4ea29cba5865d00fad476ce94a93
Merge: 8dda9957e3a1 96fcaf86c3cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 21:06:01 2019 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "Many bug fixes and cleanups, and an optimization for case-insensitive
      lookups"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4:
      ext4: fix coverity warning on error path of filename setup
      ext4: replace ktype default_attrs with default_groups
      ext4: rename htree_inline_dir_to_tree() to ext4_inlinedir_to_tree()
      ext4: refactor initialize_dirent_tail()
      ext4: rename "dirent_csum" functions to use "dirblock"
      ext4: allow directory holes
      jbd2: drop declaration of journal_sync_buffer()
      ext4: use jbd2_inode dirty range scoping
      jbd2: introduce jbd2_inode dirty range scoping
      mm: add filemap_fdatawait_range_keep_errors()
      ext4: remove redundant assignment to node
      ext4: optimize case-insensitive lookups
      ext4: make __ext4_get_inode_loc plug
      ext4: clean up kerneldoc warnigns when building with W=1
      ext4: only set project inherit bit for directory
      ext4: enforce the immutable flag on open files
      ext4: don't allow any modifications to an immutable file
      jbd2: fix typo in comment of journal_submit_inode_data_buffers
      jbd2: fix some print format mistakes
      ext4: gracefully handle ext4_break_layouts() failure during truncate

commit 40f06c799539739a08a56be8a096f56aeed05731
Merge: a47f5c56b2eb fe0da9c09b2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 20:32:37 2019 -0700

    Merge tag 'copy-file-range-fixes-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull copy_file_range updates from Darrick Wong:
     "This fixes numerous parameter checking problems and inconsistent
      behaviors in the new(ish) copy_file_range system call.
    
      Now the system call will actually check its range parameters
      correctly; refuse to copy into files for which the caller does not
      have sufficient privileges; update mtime and strip setuid like file
      writes are supposed to do; and allows copying up to the EOF of the
      source file instead of failing the call like we used to.
    
      Summary:
    
       - Create a generic copy_file_range handler and make individual
         filesystems responsible for calling it (i.e. no more assuming that
         do_splice_direct will work or is appropriate)
    
       - Refactor copy_file_range and remap_range parameter checking where
         they are the same
    
       - Install missing copy_file_range parameter checking(!)
    
       - Remove suid/sgid and update mtime like any other file write
    
       - Change the behavior so that a copy range crossing the source file's
         eof will result in a short copy to the source file's eof instead of
         EINVAL
    
       - Permit filesystems to decide if they want to handle
         cross-superblock copy_file_range in their local handlers"
    
    * tag 'copy-file-range-fixes-1' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux:
      fuse: copy_file_range needs to strip setuid bits and update timestamps
      vfs: allow copy_file_range to copy across devices
      xfs: use file_modified() helper
      vfs: introduce file_modified() helper
      vfs: add missing checks to copy_file_range
      vfs: remove redundant checks from generic_remap_checks()
      vfs: introduce generic_file_rw_checks()
      vfs: no fallback for ->copy_file_range
      vfs: introduce generic_copy_file_range()

commit e6983afd9254c559acf67dd5f62df824d19851eb
Merge: 988052f47adc 7377f5bec133
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 20:09:17 2019 -0700

    Merge tag 'fsnotify_for_v5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull fsnotify updates from Jan Kara:
     "This contains cleanups of the fsnotify name removal hook and also a
      patch to disable fanotify permission events for 'proc' filesystem"
    
    * tag 'fsnotify_for_v5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      fsnotify: get rid of fsnotify_nameremove()
      fsnotify: move fsnotify_nameremove() hook out of d_delete()
      configfs: call fsnotify_rmdir() hook
      debugfs: call fsnotify_{unlink,rmdir}() hooks
      debugfs: simplify __debugfs_remove_file()
      devpts: call fsnotify_unlink() hook
      tracefs: call fsnotify_{unlink,rmdir}() hooks
      rpc_pipefs: call fsnotify_{unlink,rmdir}() hooks
      btrfs: call fsnotify_rmdir() hook
      fsnotify: add empty fsnotify_{unlink,rmdir}() hooks
      fanotify: Disallow permission events for proc filesystem

commit 988052f47adc5c3b0b004180b59bb3761d91b752
Merge: 028db3e290f1 387e3746d01c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 10 19:21:38 2019 -0700

    Merge tag 'locks-v5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux
    
    Pull file locking updates from Jeff Layton:
     "Just a couple of small lease-related patches this cycle.
    
      One from Ira to add a new tracepoint that fires during lease conflict
      checks, and another patch from Amir to reduce false positives when
      checking for lease conflicts"
    
    * tag 'locks-v5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux:
      locks: eliminate false positive conflicts for write lease
      locks: Add trace_leases_conflict

commit f85d93385e9fe6886a751f647f6812a89bf6bee3
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Thu May 23 10:45:48 2019 -0400

    locks: Cleanup lm_compare_owner and lm_owner_key
    
    After the update to use nlm_lockowners for the NLM server, there are no
    more users of lm_compare_owner and lm_owner_key.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..0fa010bb7b6a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1019,8 +1019,6 @@ struct file_lock_operations {
 };
 
 struct lock_manager_operations {
-	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
-	unsigned long (*lm_owner_key)(struct file_lock *);
 	fl_owner_t (*lm_get_owner)(fl_owner_t);
 	void (*lm_put_owner)(fl_owner_t);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */

commit 7b0e492e6b80d51db4156996b248522c7b50d467
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Mon Jul 1 08:25:35 2019 -0700

    vfs: create a generic checking function for FS_IOC_FSSETXATTR
    
    Create a generic checking function for the incoming FS_IOC_FSSETXATTR
    fsxattr values so that we can standardize some of the implementation
    behaviors.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 41d5175ffdd7..36f9691d7046 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3549,4 +3549,13 @@ static inline struct sock *io_uring_get_socket(struct file *file)
 int vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,
 			     unsigned int flags);
 
+int vfs_ioc_fssetxattr_check(struct inode *inode, const struct fsxattr *old_fa,
+			     struct fsxattr *fa);
+
+static inline void simple_fill_fsxattr(struct fsxattr *fa, __u32 xflags)
+{
+	memset(fa, 0, sizeof(*fa));
+	fa->fsx_xflags = xflags;
+}
+
 #endif /* _LINUX_FS_H */

commit 5aca284210ce827f780ea2f4f9c6ab8d6e2d6648
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Mon Jul 1 08:25:34 2019 -0700

    vfs: create a generic checking and prep function for FS_IOC_SETFLAGS
    
    Create a generic function to check incoming FS_IOC_SETFLAGS flag values
    and later prepare the inode for updates so that we can standardize the
    implementations that follow ext4's flag values.
    
    Note that the efivarfs implementation no longer fails a no-op SETFLAGS
    without CAP_LINUX_IMMUTABLE since that's the behavior in ext*.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: David Sterba <dsterba@suse.com>
    Reviewed-by: Bob Peterson <rpeterso@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..41d5175ffdd7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3546,4 +3546,7 @@ static inline struct sock *io_uring_get_socket(struct file *file)
 }
 #endif
 
+int vfs_ioc_setflags_prepare(struct inode *inode, unsigned int oldflags,
+			     unsigned int flags);
+
 #endif /* _LINUX_FS_H */

commit aa0bfcd939c30617385ffa28682c062d78050eba
Author: Ross Zwisler <zwisler@chromium.org>
Date:   Thu Jun 20 17:05:37 2019 -0400

    mm: add filemap_fdatawait_range_keep_errors()
    
    In the spirit of filemap_fdatawait_range() and
    filemap_fdatawait_keep_errors(), introduce
    filemap_fdatawait_range_keep_errors() which both takes a range upon
    which to wait and does not clear errors from the address space.
    
    Signed-off-by: Ross Zwisler <zwisler@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..79fec8a8413f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2712,6 +2712,8 @@ extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait_keep_errors(struct address_space *mapping);
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
+extern int filemap_fdatawait_range_keep_errors(struct address_space *mapping,
+		loff_t start_byte, loff_t end_byte);
 
 static inline int filemap_fdatawait(struct address_space *mapping)
 {

commit 387e3746d01c34457d6a73688acd90428725070b
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Jun 7 17:24:38 2019 +0300

    locks: eliminate false positive conflicts for write lease
    
    check_conflicting_open() is checking for existing fd's open for read or
    for write before allowing to take a write lease.  The check that was
    implemented using i_count and d_count is an approximation that has
    several false positives.  For example, overlayfs since v4.19, takes an
    extra reference on the dentry; An open with O_PATH takes a reference on
    the dentry although the file cannot be read nor written.
    
    Change the implementation to use i_readcount and i_writecount to
    eliminate the false positive conflicts and allow a write lease to be
    taken on an overlayfs file.
    
    The change of behavior with existing fd's open with O_PATH is symmetric
    w.r.t. current behavior of lease breakers - an open with O_PATH currently
    does not break a write lease.
    
    This increases the size of struct inode by 4 bytes on 32bit archs when
    CONFIG_FILE_LOCKING is defined and CONFIG_IMA was not already
    defined.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..419e327022de 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -694,7 +694,7 @@ struct inode {
 	atomic_t		i_count;
 	atomic_t		i_dio_count;
 	atomic_t		i_writecount;
-#ifdef CONFIG_IMA
+#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)
 	atomic_t		i_readcount; /* struct files open RO */
 #endif
 	union {
@@ -2890,7 +2890,7 @@ static inline bool inode_is_open_for_write(const struct inode *inode)
 	return atomic_read(&inode->i_writecount) > 0;
 }
 
-#ifdef CONFIG_IMA
+#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)
 static inline void i_readcount_dec(struct inode *inode)
 {
 	BUG_ON(!atomic_read(&inode->i_readcount));

commit e38f7f53c35213b1cbce70eee5de7ced17f40d4a
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 5 08:04:49 2019 -0700

    vfs: introduce file_modified() helper
    
    The combination of file_remove_privs() and file_update_mtime() is
    quite common in filesystem ->write_iter() methods.
    
    Modelled after the helper file_accessed(), introduce file_modified()
    and use it from generic_remap_file_range_prep().
    
    Note that the order of calling file_remove_privs() before
    file_update_mtime() in the helper was matched to the more common order by
    filesystems and not the current order in generic_remap_file_range_prep().
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e4d382c4342a..79ffa2958bd8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2177,6 +2177,8 @@ static inline void file_accessed(struct file *file)
 		touch_atime(&file->f_path);
 }
 
+extern int file_modified(struct file *file);
+
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
 int sync_inode_metadata(struct inode *inode, int wait);
 

commit 96e6e8f4a68df2d94800311163faa67124df24e5
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 5 08:04:49 2019 -0700

    vfs: add missing checks to copy_file_range
    
    Like the clone and dedupe interfaces we've recently fixed, the
    copy_file_range() implementation is missing basic sanity, limits and
    boundary condition tests on the parameters that are passed to it
    from userspace. Create a new "generic_copy_file_checks()" function
    modelled on the generic_remap_checks() function to provide this
    missing functionality.
    
    [Amir] Shorten copy length instead of checking pos_in limits
    because input file size already abides by the limits.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 89b9b73eb581..e4d382c4342a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3050,6 +3050,9 @@ extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out,
 				loff_t *count, unsigned int remap_flags);
 extern int generic_file_rw_checks(struct file *file_in, struct file *file_out);
+extern int generic_copy_file_checks(struct file *file_in, loff_t pos_in,
+				    struct file *file_out, loff_t pos_out,
+				    size_t *count, unsigned int flags);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit a31713517dac0862a3f0ec9006df9160ce022b0c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 5 08:04:48 2019 -0700

    vfs: introduce generic_file_rw_checks()
    
    Factor out helper with some checks on in/out file that are
    common to clone_file_range and copy_file_range.
    
    Suggested-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ea17858310ff..89b9b73eb581 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3049,6 +3049,7 @@ extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
 extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out,
 				loff_t *count, unsigned int remap_flags);
+extern int generic_file_rw_checks(struct file *file_in, struct file *file_out);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit f16acc9d9b3761ae5e45219c9302f99e20919829
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Jun 5 08:04:47 2019 -0700

    vfs: introduce generic_copy_file_range()
    
    Right now if vfs_copy_file_range() does not use any offload
    mechanism, it falls back to calling do_splice_direct(). This fails
    to do basic sanity checks on the files being copied. Before we
    start adding this necessarily functionality to the fallback path,
    separate it out into generic_copy_file_range().
    
    generic_copy_file_range() has the same prototype as
    ->copy_file_range() so that filesystems can use it in their custom
    ->copy_file_range() method if they so choose.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..ea17858310ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1889,6 +1889,9 @@ extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *, rwf_t);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
+extern ssize_t generic_copy_file_range(struct file *file_in, loff_t pos_in,
+				       struct file *file_out, loff_t pos_out,
+				       size_t len, unsigned int flags);
 extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
 					 struct file *file_out, loff_t pos_out,
 					 loff_t *count,

commit 5c437fa29561f5809ef114ba3a5e80556cc43fb3
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Jun 7 15:54:35 2019 -0300

    docs: fs: fix broken links to vfs.txt with was renamed to vfs.rst
    
    A recent documentation conversion renamed this file but forgot
    to update the links.
    
    Fixes: af96c1e304f7 ("docs: filesystems: vfs: Convert vfs.txt to RST")
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..c564cf3f48d9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1769,7 +1769,7 @@ struct block_device_operations;
 /*
  * These flags control the behavior of the remap_file_range function pointer.
  * If it is called with len == 0 that means "remap to end of source file".
- * See Documentation/filesystems/vfs.txt for more details about this call.
+ * See Documentation/filesystems/vfs.rst for more details about this call.
  *
  * REMAP_FILE_DEDUP: only remap if contents identical (i.e. deduplicate)
  * REMAP_FILE_CAN_SHORTEN: caller can handle a shortened request

commit 0b3b094ac9a7bb1fcf5d694f3ec981e6864a63d3
Author: Jan Kara <jack@suse.cz>
Date:   Wed May 15 16:28:34 2019 +0200

    fanotify: Disallow permission events for proc filesystem
    
    Proc filesystem has special locking rules for various files. Thus
    fanotify which opens files on event delivery can easily deadlock
    against another process that waits for fanotify permission event to be
    handled. Since permission events on /proc have doubtful value anyway,
    just disallow them.
    
    Link: https://lore.kernel.org/linux-fsdevel/20190320131642.GE9485@quack2.suse.cz/
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..c7136c98b5ba 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2184,6 +2184,7 @@ struct file_system_type {
 #define FS_BINARY_MOUNTDATA	2
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
+#define FS_DISALLOW_NOTIFY_PERM	16	/* Disable fanotify permission events */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	int (*init_fs_context)(struct fs_context *);
 	const struct fs_parameter_description *parameters;

commit 023d066a0d0a87696c04b0de2ceae53063d0b655
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 25 16:38:28 2019 +0000

    vfs: Kill sget_userns()
    
    Kill sget_userns(), folding it into sget() as that's the only remaining
    user.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-fsdevel@vger.kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d625acabbfcf..71421856ff2c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2245,11 +2245,6 @@ void free_anon_bdev(dev_t);
 struct super_block *sget_fc(struct fs_context *fc,
 			    int (*test)(struct super_block *, struct fs_context *),
 			    int (*set)(struct super_block *, struct fs_context *));
-struct super_block *sget_userns(struct file_system_type *type,
-			int (*test)(struct super_block *,void *),
-			int (*set)(struct super_block *,void *),
-			int flags, struct user_namespace *user_ns,
-			void *data);
 struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),

commit 8d9e46d80777b484f8f0945c317ad618224d7811
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 11 11:43:59 2019 -0400

    fold mount_pseudo_xattr() into pseudo_fs_get_tree()
    
    ... now that all other callers are gone
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 790342cf4df9..d625acabbfcf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2254,19 +2254,6 @@ struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),
 			int flags, void *data);
-extern struct dentry *mount_pseudo_xattr(struct file_system_type *,
-					 const struct super_operations *ops,
-					 const struct xattr_handler **xattr,
-					 const struct dentry_operations *dops,
-					 unsigned long);
-
-static inline struct dentry *
-mount_pseudo(struct file_system_type *fs_type,
-	     const struct super_operations *ops,
-	     const struct dentry_operations *dops, unsigned long magic)
-{
-	return mount_pseudo_xattr(fs_type, ops, NULL, dops, magic);
-}
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \

commit bb7b6b2bbdb827e68cd506c8f5e3ba13215cccb2
Author: David Howells <dhowells@redhat.com>
Date:   Mon Mar 25 16:38:28 2019 +0000

    vfs: Kill mount_ns()
    
    Kill mount_ns() as it has been replaced by vfs_get_super() in the new mount
    API.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b06251dd429f..790342cf4df9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2206,9 +2206,6 @@ struct file_system_type {
 
 #define MODULE_ALIAS_FS(NAME) MODULE_ALIAS("fs-" NAME)
 
-extern struct dentry *mount_ns(struct file_system_type *fs_type,
-	int flags, void *data, void *ns, struct user_namespace *user_ns,
-	int (*fill_super)(struct super_block *, void *, int));
 #ifdef CONFIG_BLOCK
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,

commit 1f58bb18f6f28d1df0b7144d90bc90ee5672416d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 20 13:44:57 2019 +0100

    mount_pseudo(): drop 'name' argument, switch to d_make_root()
    
    Once upon a time we used to set ->d_name of e.g. pipefs root
    so that d_path() on pipes would work.  These days it's
    completely pointless - dentries of pipes are not even connected
    to pipefs root.  However, mount_pseudo() had set the root
    dentry name (passed as the second argument) and callers
    kept inventing names to pass to it.  Including those that
    didn't *have* any non-root dentries to start with...
    
    All of that had been pointless for about 8 years now; it's
    time to get rid of that cargo-culting...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f7fdfe93e25d..b06251dd429f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2257,18 +2257,18 @@ struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),
 			int flags, void *data);
-extern struct dentry *mount_pseudo_xattr(struct file_system_type *, char *,
+extern struct dentry *mount_pseudo_xattr(struct file_system_type *,
 					 const struct super_operations *ops,
 					 const struct xattr_handler **xattr,
 					 const struct dentry_operations *dops,
 					 unsigned long);
 
 static inline struct dentry *
-mount_pseudo(struct file_system_type *fs_type, char *name,
+mount_pseudo(struct file_system_type *fs_type,
 	     const struct super_operations *ops,
 	     const struct dentry_operations *dops, unsigned long magic)
 {
-	return mount_pseudo_xattr(fs_type, name, ops, NULL, dops, magic);
+	return mount_pseudo_xattr(fs_type, ops, NULL, dops, magic);
 }
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */

commit 5abe37954e9a315c35c9490f78d55f307c3c636b
Merge: e5fef2a97325 db90f41916cf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 21:12:44 2019 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "Add as a feature case-insensitive directories (the casefold feature)
      using Unicode 12.1.
    
      Also, the usual largish number of cleanups and bug fixes"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (25 commits)
      ext4: export /sys/fs/ext4/feature/casefold if Unicode support is present
      ext4: fix ext4_show_options for file systems w/o journal
      unicode: refactor the rule for regenerating utf8data.h
      docs: ext4.rst: document case-insensitive directories
      ext4: Support case-insensitive file name lookups
      ext4: include charset encoding information in the superblock
      MAINTAINERS: add Unicode subsystem entry
      unicode: update unicode database unicode version 12.1.0
      unicode: introduce test module for normalized utf8 implementation
      unicode: implement higher level API for string handling
      unicode: reduce the size of utf8data[]
      unicode: introduce code for UTF-8 normalization
      unicode: introduce UTF-8 character database
      ext4: actually request zeroing of inode table after grow
      ext4: cond_resched in work-heavy group loops
      ext4: fix use-after-free race with debug_want_extra_isize
      ext4: avoid drop reference to iloc.bh twice
      ext4: ignore e_value_offs for xattrs with value-in-ea-inode
      ext4: protect journal inode's blocks using block_validity
      ext4: use BUG() instead of BUG_ON(1)
      ...

commit e5fef2a9732580c5bd30c0097f5e9091a3d58ce5
Merge: 149e703cb8bf f5e4546347bc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 20:51:58 2019 -0700

    Merge tag 'afs-next-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs
    
    Pull AFS updates from David Howells:
     "A set of fix and development patches for AFS for 5.2.
    
      Summary:
    
       - Fix the AFS file locking so that sqlite can run on an AFS mount and
         also so that firefox and gnome can use a homedir that's mounted
         through AFS.
    
         This required emulation of fine-grained locking when the server
         will only support whole-file locks and no upgrade/downgrade. Four
         modes are provided, settable by mount parameter:
    
           "flock=local"   - No reference to the server
    
           "flock=openafs" - Fine-grained locks are local-only, whole-file
                             locks require sufficient server locks
    
           "flock=strict"  - All locks require sufficient server locks
    
           "flock=write"   - Always get an exclusive server lock
    
         If the volume is a read-only or backup volume, then flock=local for
         that volume.
    
       - Log extra information for a couple of cases where the client mucks
         up somehow: AFS vnode with undefined type and dir check failure -
         in both cases we seem to end up with unfilled data, but the issues
         happen infrequently and are difficult to reproduce at will.
    
       - Implement silly rename for unlink() and rename().
    
       - Set i_blocks so that du can get some information about usage.
    
       - Fix xattr handlers to return the right amount of data and to not
         overflow buffers.
    
       - Implement getting/setting raw AFS and YFS ACLs as xattrs"
    
    * tag 'afs-next-20190507' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs:
      afs: Implement YFS ACL setting
      afs: Get YFS ACLs and information through xattrs
      afs: implement acl setting
      afs: Get an AFS3 ACL as an xattr
      afs: Fix getting the afs.fid xattr
      afs: Fix the afs.cell and afs.volume xattr handlers
      afs: Calculate i_blocks based on file size
      afs: Log more information for "kAFS: AFS vnode with undefined type\n"
      afs: Provide mount-time configurable byte-range file locking emulation
      afs: Add more tracepoints
      afs: Implement sillyrename for unlink and rename
      afs: Add directory reload tracepoint
      afs: Handle lock rpc ops failing on a file that got deleted
      afs: Improve dir check failure reports
      afs: Add file locking tracepoints
      afs: Further fix file locking
      afs: Fix AFS file locking to allow fine grained locks
      afs: Calculate lock extend timer from set/extend reply reception
      afs: Split wait from afs_make_call()

commit d897166d8598e362a31d79dfd9a1e2eedb9ac85c
Merge: 400913252d09 3b85d3028e2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 20:34:21 2019 -0700

    Merge branch 'work.file' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs 'struct file' related updates from Al Viro:
     "A bit more of 'this fget() would be better off as fdget()'
      whack-a-mole + a couple of ->f_count-related cleanups"
    
    * 'work.file' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      media: switch to fdget()
      drm_syncobj: switch to fdget()
      amdgpu: switch to fdget()
      don't open-code file_count()
      fs: drop unused fput_atomic definition

commit 400913252d09f9cfb8cce33daee43167921fc343
Merge: d27fb65bc238 f1b5618e013a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 20:17:51 2019 -0700

    Merge branch 'work.mount-syscalls' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull mount ABI updates from Al Viro:
     "The syscalls themselves, finally.
    
      That's not all there is to that stuff, but switching individual
      filesystems to new methods is fortunately independent from everything
      else, so e.g. NFS series can go through NFS tree, etc.
    
      As those conversions get done, we'll be finally able to get rid of a
      bunch of duplication in fs/super.c introduced in the beginning of the
      entire thing. I expect that to be finished in the next window..."
    
    * 'work.mount-syscalls' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: Add a sample program for the new mount API
      vfs: syscall: Add fspick() to select a superblock for reconfiguration
      vfs: syscall: Add fsmount() to create a mount for a superblock
      vfs: syscall: Add fsconfig() for configuring and managing a context
      vfs: Implement logging through fs_context
      vfs: syscall: Add fsopen() to prepare for superblock creation
      Make anon_inodes unconditional
      teach move_mount(2) to work with OPEN_TREE_CLONE
      vfs: syscall: Add move_mount(2) to move mounts around
      vfs: syscall: Add open_tree(2) to reference or clone a mount

commit 52ae2456d6a455ef958bcf1c2d1965674076887e
Merge: 67a242223958 7889f44dd9ce
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 7 18:30:11 2019 -0700

    Merge tag 'for-5.2/io_uring-20190507' of git://git.kernel.dk/linux-block
    
    Pull io_uring updates from Jens Axboe:
     "Set of changes/improvements for io_uring. This contains:
    
       - Fix of a shadowed variable (Colin)
    
       - Add support for draining commands (me)
    
       - Add support for sync_file_range() (me)
    
       - Add eventfd support (me)
    
       - cpu_online() fix (Shenghui)
    
       - Removal of a redundant ->error assignment (Stefan)"
    
    * tag 'for-5.2/io_uring-20190507' of git://git.kernel.dk/linux-block:
      io_uring: use cpu_online() to check p->sq_thread_cpu instead of cpu_possible()
      io_uring: fix shadowed variable ret return code being not checked
      req->error only used for iopoll
      io_uring: add support for eventfd notifications
      io_uring: add support for IORING_OP_SYNC_FILE_RANGE
      fs: add sync_file_range() helper
      io_uring: add support for marking commands as draining

commit 22f96b3808c12a218e9a3bce6e1bfbd74efbe374
Author: Jens Axboe <axboe@kernel.dk>
Date:   Tue Apr 9 14:51:48 2019 -0600

    fs: add sync_file_range() helper
    
    This just pulls out the ksys_sync_file_range() code to work on a struct
    file instead of an fd, so we can use it elsewhere.
    
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd28e7679089..2f66e247ecba 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2785,6 +2785,9 @@ extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
 
+extern int sync_file_range(struct file *file, loff_t offset, loff_t nbytes,
+				unsigned int flags);
+
 /*
  * Sync the bytes written if this was a synchronous write.  Expect ki_pos
  * to already be updated for the write, and will return either the amount

commit fdb0da89f4ba0c74d7d3b9e6f471e96a5766820b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 10 14:43:44 2019 -0400

    new inode method: ->free_inode()
    
    A lot of ->destroy_inode() instances end with call_rcu() of a callback
    that does RCU-delayed part of freeing.  Introduce a new method for
    doing just that, with saner signature.
    
    Rules:
    ->destroy_inode         ->free_inode
            f                       g               immediate call of f(),
                                                    RCU-delayed call of g()
            f                       NULL            immediate call of f(),
                                                    no RCU-delayed calls
            NULL                    g               RCU-delayed call of g()
            NULL                    NULL            RCU-delayed default freeing
    
    IOW, NULL ->free_inode gives the same behaviour as now.
    
    Note that NULL, NULL is equivalent to NULL, free_inode_nonrcu; we could
    mandate the latter form, but that would have very little benefit beyond
    making rules a bit more symmetric.  It would break backwards compatibility,
    require extra boilerplate and expected semantics for (NULL, NULL) pair
    would have no use whatsoever...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd28e7679089..92732286b748 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -694,7 +694,10 @@ struct inode {
 #ifdef CONFIG_IMA
 	atomic_t		i_readcount; /* struct files open RO */
 #endif
-	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
+	union {
+		const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
+		void (*free_inode)(struct inode *);
+	};
 	struct file_lock_context	*i_flctx;
 	struct address_space	i_data;
 	struct list_head	i_devices;
@@ -1903,6 +1906,7 @@ extern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);
 	void (*destroy_inode)(struct inode *);
+	void (*free_inode)(struct inode *);
 
    	void (*dirty_inode) (struct inode *, int flags);
 	int (*write_inode) (struct inode *, struct writeback_control *wbc);

commit b886ee3e778ec2ad43e276fd378ab492cf6819b7
Author: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
Date:   Thu Apr 25 14:12:08 2019 -0400

    ext4: Support case-insensitive file name lookups
    
    This patch implements the actual support for case-insensitive file name
    lookups in ext4, based on the feature bit and the encoding stored in the
    superblock.
    
    A filesystem that has the casefold feature set is able to configure
    directories with the +F (EXT4_CASEFOLD_FL) attribute, enabling lookups
    to succeed in that directory in a case-insensitive fashion, i.e: match
    a directory entry even if the name used by userspace is not a byte per
    byte match with the disk name, but is an equivalent case-insensitive
    version of the Unicode string.  This operation is called a
    case-insensitive file name lookup.
    
    The feature is configured as an inode attribute applied to directories
    and inherited by its children.  This attribute can only be enabled on
    empty directories for filesystems that support the encoding feature,
    thus preventing collision of file names that only differ by case.
    
    * dcache handling:
    
    For a +F directory, Ext4 only stores the first equivalent name dentry
    used in the dcache. This is done to prevent unintentional duplication of
    dentries in the dcache, while also allowing the VFS code to quickly find
    the right entry in the cache despite which equivalent string was used in
    a previous lookup, without having to resort to ->lookup().
    
    d_hash() of casefolded directories is implemented as the hash of the
    casefolded string, such that we always have a well-known bucket for all
    the equivalencies of the same string. d_compare() uses the
    utf8_strncasecmp() infrastructure, which handles the comparison of
    equivalent, same case, names as well.
    
    For now, negative lookups are not inserted in the dcache, since they
    would need to be invalidated anyway, because we can't trust missing file
    dentries.  This is bad for performance but requires some leveraging of
    the vfs layer to fix.  We can live without that for now, and so does
    everyone else.
    
    * on-disk data:
    
    Despite using a specific version of the name as the internal
    representation within the dcache, the name stored and fetched from the
    disk is a byte-per-byte match with what the user requested, making this
    implementation 'name-preserving'. i.e. no actual information is lost
    when writing to storage.
    
    DX is supported by modifying the hashes used in +F directories to make
    them case/encoding-aware.  The new disk hashes are calculated as the
    hash of the full casefolded string, instead of the string directly.
    This allows us to efficiently search for file names in the htree without
    requiring the user to provide an exact name.
    
    * Dealing with invalid sequences:
    
    By default, when a invalid UTF-8 sequence is identified, ext4 will treat
    it as an opaque byte sequence, ignoring the encoding and reverting to
    the old behavior for that unique file.  This means that case-insensitive
    file name lookup will not work only for that file.  An optional bit can
    be set in the superblock telling the filesystem code and userspace tools
    to enforce the encoding.  When that optional bit is set, any attempt to
    create a file name using an invalid UTF-8 sequence will fail and return
    an error to userspace.
    
    * Normalization algorithm:
    
    The UTF-8 algorithms used to compare strings in ext4 is implemented
    lives in fs/unicode, and is based on a previous version developed by
    SGI.  It implements the Canonical decomposition (NFD) algorithm
    described by the Unicode specification 12.1, or higher, combined with
    the elimination of ignorable code points (NFDi) and full
    case-folding (CF) as documented in fs/unicode/utf8_norm.c.
    
    NFD seems to be the best normalization method for EXT4 because:
    
      - It has a lower cost than NFC/NFKC (which requires
        decomposing to NFD as an intermediary step)
      - It doesn't eliminate important semantic meaning like
        compatibility decompositions.
    
    Although:
    
      - This implementation is not completely linguistic accurate, because
      different languages have conflicting rules, which would require the
      specialization of the filesystem to a given locale, which brings all
      sorts of problems for removable media and for users who use more than
      one language.
    
    Signed-off-by: Gabriel Krisman Bertazi <krisman@collabora.co.uk>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8b42df09b04c..6261090e605b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1953,6 +1953,7 @@ struct super_operations {
 #define S_DAX		0	/* Make all the DAX code disappear */
 #endif
 #define S_ENCRYPTED	16384	/* Encrypted file (using fs/crypto/) */
+#define S_CASEFOLD	32768	/* Casefolded file */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -1993,6 +1994,7 @@ static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags
 #define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
 #define IS_DAX(inode)		((inode)->i_flags & S_DAX)
 #define IS_ENCRYPTED(inode)	((inode)->i_flags & S_ENCRYPTED)
+#define IS_CASEFOLDED(inode)	((inode)->i_flags & S_CASEFOLD)
 
 #define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
 				 (inode)->i_rdev == WHITEOUT_DEV)

commit d46966013bb4f1fbed7cf995828523a3d1f265c6
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 25 14:26:50 2019 +0100

    afs: Add file locking tracepoints
    
    Add two tracepoints for monitoring AFS file locking.  Firstly, add one that
    follows the operational part:
    
        echo 1 >/sys/kernel/debug/tracing/events/afs/afs_flock_op/enable
    
    And add a second that more follows the event-driven part:
    
        echo 1 >/sys/kernel/debug/tracing/events/afs/afs_flock_ev/enable
    
    Individual file_lock structs seen by afs are tagged with debugging IDs that
    are displayed in the trace log to make it easier to see what's going on,
    especially as setting the first lock always seems to involve copying the
    file_lock twice.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd28e7679089..744908e0bdec 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1093,6 +1093,7 @@ struct file_lock {
 		struct {
 			struct list_head link;	/* link in AFS vnode's pending_locks list */
 			int state;		/* state of grant or error if -ve */
+			unsigned int	debug_id;
 		} afs;
 	} fl_u;
 } __randomize_layout;

commit 1caf7a70a93f81fad622131e34ce68d131a71064
Author: Lukas Bulwahn <lukas.bulwahn@gmail.com>
Date:   Thu Apr 11 05:53:52 2019 +0200

    fs: drop unused fput_atomic definition
    
    commit d7065da03822 ("get rid of the magic around f_count in aio") added
    fput_atomic to include/linux/fs.h, motivated by its use in __aio_put_req()
    in fs/aio.c.
    
    Later, commit 3ffa3c0e3f6e ("aio: now fput() is OK from interrupt context;
    get rid of manual delayed __fput()") removed the only use of fput_atomic
    in __aio_put_req(), but did not remove the since then unused fput_atomic
    definition in include/linux/fs.h.
    
    We curate this now and finally remove the unused definition.
    
    This issue was identified during a code review due to a coccinelle warning
    from the atomic_as_refcounter.cocci rule pointing to the use of atomic_t
    in fput_atomic.
    
    Suggested-by: Krystian Radlak <kradlak@exida.com>
    Signed-off-by: Lukas Bulwahn <lukas.bulwahn@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd28e7679089..79b2f43b945d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -969,7 +969,6 @@ static inline struct file *get_file(struct file *f)
 #define get_file_rcu_many(x, cnt)	\
 	atomic_long_add_unless(&(x)->f_count, (cnt), 0)
 #define get_file_rcu(x) get_file_rcu_many((x), 1)
-#define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)

commit 10dce8af34226d90fa56746a934f8da5dcdba3df
Author: Kirill Smelkov <kirr@nexedi.com>
Date:   Tue Mar 26 22:20:43 2019 +0000

    fs: stream_open - opener for stream-like files so that read and write can run simultaneously without deadlock
    
    Commit 9c225f2655e3 ("vfs: atomic f_pos accesses as per POSIX") added
    locking for file.f_pos access and in particular made concurrent read and
    write not possible - now both those functions take f_pos lock for the
    whole run, and so if e.g. a read is blocked waiting for data, write will
    deadlock waiting for that read to complete.
    
    This caused regression for stream-like files where previously read and
    write could run simultaneously, but after that patch could not do so
    anymore. See e.g. commit 581d21a2d02a ("xenbus: fix deadlock on writes
    to /proc/xen/xenbus") which fixes such regression for particular case of
    /proc/xen/xenbus.
    
    The patch that added f_pos lock in 2014 did so to guarantee POSIX thread
    safety for read/write/lseek and added the locking to file descriptors of
    all regular files. In 2014 that thread-safety problem was not new as it
    was already discussed earlier in 2006.
    
    However even though 2006'th version of Linus's patch was adding f_pos
    locking "only for files that are marked seekable with FMODE_LSEEK (thus
    avoiding the stream-like objects like pipes and sockets)", the 2014
    version - the one that actually made it into the tree as 9c225f2655e3 -
    is doing so irregardless of whether a file is seekable or not.
    
    See
    
        https://lore.kernel.org/lkml/53022DB1.4070805@gmail.com/
        https://lwn.net/Articles/180387
        https://lwn.net/Articles/180396
    
    for historic context.
    
    The reason that it did so is, probably, that there are many files that
    are marked non-seekable, but e.g. their read implementation actually
    depends on knowing current position to correctly handle the read. Some
    examples:
    
            kernel/power/user.c             snapshot_read
            fs/debugfs/file.c               u32_array_read
            fs/fuse/control.c               fuse_conn_waiting_read + ...
            drivers/hwmon/asus_atk0110.c    atk_debugfs_ggrp_read
            arch/s390/hypfs/inode.c         hypfs_read_iter
            ...
    
    Despite that, many nonseekable_open users implement read and write with
    pure stream semantics - they don't depend on passed ppos at all. And for
    those cases where read could wait for something inside, it creates a
    situation similar to xenbus - the write could be never made to go until
    read is done, and read is waiting for some, potentially external, event,
    for potentially unbounded time -> deadlock.
    
    Besides xenbus, there are 14 such places in the kernel that I've found
    with semantic patch (see below):
    
            drivers/xen/evtchn.c:667:8-24: ERROR: evtchn_fops: .read() can deadlock .write()
            drivers/isdn/capi/capi.c:963:8-24: ERROR: capi_fops: .read() can deadlock .write()
            drivers/input/evdev.c:527:1-17: ERROR: evdev_fops: .read() can deadlock .write()
            drivers/char/pcmcia/cm4000_cs.c:1685:7-23: ERROR: cm4000_fops: .read() can deadlock .write()
            net/rfkill/core.c:1146:8-24: ERROR: rfkill_fops: .read() can deadlock .write()
            drivers/s390/char/fs3270.c:488:1-17: ERROR: fs3270_fops: .read() can deadlock .write()
            drivers/usb/misc/ldusb.c:310:1-17: ERROR: ld_usb_fops: .read() can deadlock .write()
            drivers/hid/uhid.c:635:1-17: ERROR: uhid_fops: .read() can deadlock .write()
            net/batman-adv/icmp_socket.c:80:1-17: ERROR: batadv_fops: .read() can deadlock .write()
            drivers/media/rc/lirc_dev.c:198:1-17: ERROR: lirc_fops: .read() can deadlock .write()
            drivers/leds/uleds.c:77:1-17: ERROR: uleds_fops: .read() can deadlock .write()
            drivers/input/misc/uinput.c:400:1-17: ERROR: uinput_fops: .read() can deadlock .write()
            drivers/infiniband/core/user_mad.c:985:7-23: ERROR: umad_fops: .read() can deadlock .write()
            drivers/gnss/core.c:45:1-17: ERROR: gnss_fops: .read() can deadlock .write()
    
    In addition to the cases above another regression caused by f_pos
    locking is that now FUSE filesystems that implement open with
    FOPEN_NONSEEKABLE flag, can no longer implement bidirectional
    stream-like files - for the same reason as above e.g. read can deadlock
    write locking on file.f_pos in the kernel.
    
    FUSE's FOPEN_NONSEEKABLE was added in 2008 in a7c1b990f715 ("fuse:
    implement nonseekable open") to support OSSPD. OSSPD implements /dev/dsp
    in userspace with FOPEN_NONSEEKABLE flag, with corresponding read and
    write routines not depending on current position at all, and with both
    read and write being potentially blocking operations:
    
    See
    
        https://github.com/libfuse/osspd
        https://lwn.net/Articles/308445
    
        https://github.com/libfuse/osspd/blob/14a9cff0/osspd.c#L1406
        https://github.com/libfuse/osspd/blob/14a9cff0/osspd.c#L1438-L1477
        https://github.com/libfuse/osspd/blob/14a9cff0/osspd.c#L1479-L1510
    
    Corresponding libfuse example/test also describes FOPEN_NONSEEKABLE as
    "somewhat pipe-like files ..." with read handler not using offset.
    However that test implements only read without write and cannot exercise
    the deadlock scenario:
    
        https://github.com/libfuse/libfuse/blob/fuse-3.4.2-3-ga1bff7d/example/poll.c#L124-L131
        https://github.com/libfuse/libfuse/blob/fuse-3.4.2-3-ga1bff7d/example/poll.c#L146-L163
        https://github.com/libfuse/libfuse/blob/fuse-3.4.2-3-ga1bff7d/example/poll.c#L209-L216
    
    I've actually hit the read vs write deadlock for real while implementing
    my FUSE filesystem where there is /head/watch file, for which open
    creates separate bidirectional socket-like stream in between filesystem
    and its user with both read and write being later performed
    simultaneously. And there it is semantically not easy to split the
    stream into two separate read-only and write-only channels:
    
        https://lab.nexedi.com/kirr/wendelin.core/blob/f13aa600/wcfs/wcfs.go#L88-169
    
    Let's fix this regression. The plan is:
    
    1. We can't change nonseekable_open to include &~FMODE_ATOMIC_POS -
       doing so would break many in-kernel nonseekable_open users which
       actually use ppos in read/write handlers.
    
    2. Add stream_open() to kernel to open stream-like non-seekable file
       descriptors. Read and write on such file descriptors would never use
       nor change ppos. And with that property on stream-like files read and
       write will be running without taking f_pos lock - i.e. read and write
       could be running simultaneously.
    
    3. With semantic patch search and convert to stream_open all in-kernel
       nonseekable_open users for which read and write actually do not
       depend on ppos and where there is no other methods in file_operations
       which assume @offset access.
    
    4. Add FOPEN_STREAM to fs/fuse/ and open in-kernel file-descriptors via
       steam_open if that bit is present in filesystem open reply.
    
       It was tempting to change fs/fuse/ open handler to use stream_open
       instead of nonseekable_open on just FOPEN_NONSEEKABLE flags, but
       grepping through Debian codesearch shows users of FOPEN_NONSEEKABLE,
       and in particular GVFS which actually uses offset in its read and
       write handlers
    
            https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
            https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
            https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
            https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481
    
       so if we would do such a change it will break a real user.
    
    5. Add stream_open and FOPEN_STREAM handling to stable kernels starting
       from v3.14+ (the kernel where 9c225f2655 first appeared).
    
       This will allow to patch OSSPD and other FUSE filesystems that
       provide stream-like files to return FOPEN_STREAM | FOPEN_NONSEEKABLE
       in their open handler and this way avoid the deadlock on all kernel
       versions. This should work because fs/fuse/ ignores unknown open
       flags returned from a filesystem and so passing FOPEN_STREAM to a
       kernel that is not aware of this flag cannot hurt. In turn the kernel
       that is not aware of FOPEN_STREAM will be < v3.14 where just
       FOPEN_NONSEEKABLE is sufficient to implement streams without read vs
       write deadlock.
    
    This patch adds stream_open, converts /proc/xen/xenbus to it and adds
    semantic patch to automatically locate in-kernel places that are either
    required to be converted due to read vs write deadlock, or that are just
    safe to be converted because read and write do not use ppos and there
    are no other funky methods in file_operations.
    
    Regarding semantic patch I've verified each generated change manually -
    that it is correct to convert - and each other nonseekable_open instance
    left - that it is either not correct to convert there, or that it is not
    converted due to current stream_open.cocci limitations.
    
    The script also does not convert files that should be valid to convert,
    but that currently have .llseek = noop_llseek or generic_file_llseek for
    unknown reason despite file being opened with nonseekable_open (e.g.
    drivers/input/mousedev.c)
    
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Yongzhi Pan <panyongzhi@gmail.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: David Vrabel <david.vrabel@citrix.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Kirill Tkhai <ktkhai@virtuozzo.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Nikolaus Rath <Nikolaus@rath.org>
    Cc: Han-Wen Nienhuys <hanwen@google.com>
    Signed-off-by: Kirill Smelkov <kirr@nexedi.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8b42df09b04c..dd28e7679089 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -158,6 +158,9 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define FMODE_OPENED		((__force fmode_t)0x80000)
 #define FMODE_CREATED		((__force fmode_t)0x100000)
 
+/* File is stream-like */
+#define FMODE_STREAM		((__force fmode_t)0x200000)
+
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x4000000)
 
@@ -3074,6 +3077,7 @@ extern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);
 extern loff_t no_seek_end_llseek(struct file *, loff_t, int);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
+extern int stream_open(struct inode * inode, struct file * filp);
 
 #ifdef CONFIG_BLOCK
 typedef void (dio_submit_t)(struct bio *bio, struct inode *inode,

commit a07b20004793d8926f78d63eb5980559f7813404
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 5 17:40:30 2018 +0000

    vfs: syscall: Add open_tree(2) to reference or clone a mount
    
    open_tree(dfd, pathname, flags)
    
    Returns an O_PATH-opened file descriptor or an error.
    dfd and pathname specify the location to open, in usual
    fashion (see e.g. fstatat(2)).  flags should be an OR of
    some of the following:
            * AT_PATH_EMPTY, AT_NO_AUTOMOUNT, AT_SYMLINK_NOFOLLOW -
    same meanings as usual
            * OPEN_TREE_CLOEXEC - make the resulting descriptor
    close-on-exec
            * OPEN_TREE_CLONE or OPEN_TREE_CLONE | AT_RECURSIVE -
    instead of opening the location in question, create a detached
    mount tree matching the subtree rooted at location specified by
    dfd/pathname.  With AT_RECURSIVE the entire subtree is cloned,
    without it - only the part within in the mount containing the
    location in question.  In other words, the same as mount --rbind
    or mount --bind would've taken.  The detached tree will be
    dissolved on the final close of obtained file.  Creation of such
    detached trees requires the same capabilities as doing mount --bind.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-api@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8b42df09b04c..09b05ec5d059 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -162,10 +162,13 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define FMODE_NONOTIFY		((__force fmode_t)0x4000000)
 
 /* File is capable of returning -EAGAIN if I/O will block */
-#define FMODE_NOWAIT	((__force fmode_t)0x8000000)
+#define FMODE_NOWAIT		((__force fmode_t)0x8000000)
+
+/* File represents mount that needs unmounting */
+#define FMODE_NEED_UNMOUNT	((__force fmode_t)0x10000000)
 
 /* File does not contribute to nr_files count */
-#define FMODE_NOACCOUNT	((__force fmode_t)0x20000000)
+#define FMODE_NOACCOUNT		((__force fmode_t)0x20000000)
 
 /*
  * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector

commit 7b47a9e7c8f672b6fb0b77fca11a63a8a77f5a91
Merge: dbc2fba3fc46 c99c2171fc61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 12 14:08:19 2019 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs mount infrastructure updates from Al Viro:
     "The rest of core infrastructure; no new syscalls in that pile, but the
      old parts are switched to new infrastructure. At that point
      conversions of individual filesystems can happen independently; some
      are done here (afs, cgroup, procfs, etc.), there's also a large series
      outside of that pile dealing with NFS (quite a bit of option-parsing
      stuff is getting used there - it's one of the most convoluted
      filesystems in terms of mount-related logics), but NFS bits are the
      next cycle fodder.
    
      It got seriously simplified since the last cycle; documentation is
      probably the weakest bit at the moment - I considered dropping the
      commit introducing Documentation/filesystems/mount_api.txt (cutting
      the size increase by quarter ;-), but decided that it would be better
      to fix it up after -rc1 instead.
    
      That pile allows to do followup work in independent branches, which
      should make life much easier for the next cycle. fs/super.c size
      increase is unpleasant; there's a followup series that allows to
      shrink it considerably, but I decided to leave that until the next
      cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (41 commits)
      afs: Use fs_context to pass parameters over automount
      afs: Add fs_context support
      vfs: Add some logging to the core users of the fs_context log
      vfs: Implement logging through fs_context
      vfs: Provide documentation for new mount API
      vfs: Remove kern_mount_data()
      hugetlbfs: Convert to fs_context
      cpuset: Use fs_context
      kernfs, sysfs, cgroup, intel_rdt: Support fs_context
      cgroup: store a reference to cgroup_ns into cgroup_fs_context
      cgroup1_get_tree(): separate "get cgroup_root to use" into a separate helper
      cgroup_do_mount(): massage calling conventions
      cgroup: stash cgroup_root reference into cgroup_fs_context
      cgroup2: switch to option-by-option parsing
      cgroup1: switch to option-by-option parsing
      cgroup: take options parsing into ->parse_monolithic()
      cgroup: fold cgroup1_mount() into cgroup1_get_tree()
      cgroup: start switching to fs_context
      ipc: Convert mqueue fs to fs_context
      proc: Add fs_context support to procfs
      ...

commit d1cae94871330cb9f5fdcea34529abf7917e682e
Merge: 99b25a7fc615 129ca2d2a83f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 9 10:54:24 2019 -0800

    Merge tag 'fscrypt-for-linus' of git://git.kernel.org/pub/scm/fs/fscrypt/fscrypt
    
    Pull fscrypt updates from Eric Biggers:
     "First: Ted, Jaegeuk, and I have decided to add me as a co-maintainer
      for fscrypt, and we're now using a shared git tree. So we've updated
      MAINTAINERS accordingly, and I'm doing the pull request this time.
    
      The actual changes for v5.1 are:
    
       - Remove the fs-specific kconfig options like CONFIG_EXT4_ENCRYPTION
         and make fscrypt support for all fscrypt-capable filesystems be
         controlled by CONFIG_FS_ENCRYPTION, similar to how CONFIG_QUOTA
         works.
    
       - Improve error code for rename() and link() into encrypted
         directories.
    
       - Various cleanups"
    
    * tag 'fscrypt-for-linus' of git://git.kernel.org/pub/scm/fs/fscrypt/fscrypt:
      MAINTAINERS: add Eric Biggers as an fscrypt maintainer
      fscrypt: return -EXDEV for incompatible rename or link into encrypted dir
      fscrypt: remove filesystem specific build config option
      f2fs: use IS_ENCRYPTED() to check encryption status
      ext4: use IS_ENCRYPTED() to check encryption status
      fscrypt: remove CRYPTO_CTR dependency

commit 38e7571c07be01f9f19b355a9306a4e3d5cb0f5b
Merge: 80201fe175cb 21b4aa5d20fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 14:48:40 2019 -0800

    Merge tag 'io_uring-2019-03-06' of git://git.kernel.dk/linux-block
    
    Pull io_uring IO interface from Jens Axboe:
     "Second attempt at adding the io_uring interface.
    
      Since the first one, we've added basic unit testing of the three
      system calls, that resides in liburing like the other unit tests that
      we have so far. It'll take a while to get full coverage of it, but
      we're working towards it. I've also added two basic test programs to
      tools/io_uring. One uses the raw interface and has support for all the
      various features that io_uring supports outside of standard IO, like
      fixed files, fixed IO buffers, and polled IO. The other uses the
      liburing API, and is a simplified version of cp(1).
    
      This adds support for a new IO interface, io_uring.
    
      io_uring allows an application to communicate with the kernel through
      two rings, the submission queue (SQ) and completion queue (CQ) ring.
      This allows for very efficient handling of IOs, see the v5 posting for
      some basic numbers:
    
        https://lore.kernel.org/linux-block/20190116175003.17880-1-axboe@kernel.dk/
    
      Outside of just efficiency, the interface is also flexible and
      extendable, and allows for future use cases like the upcoming NVMe
      key-value store API, networked IO, and so on. It also supports async
      buffered IO, something that we've always failed to support in the
      kernel.
    
      Outside of basic IO features, it supports async polled IO as well.
      This particular feature has already been tested at Facebook months ago
      for flash storage boxes, with 25-33% improvements. It makes polled IO
      actually useful for real world use cases, where even basic flash sees
      a nice win in terms of efficiency, latency, and performance. These
      boxes were IOPS bound before, now they are not.
    
      This series adds three new system calls. One for setting up an
      io_uring instance (io_uring_setup(2)), one for submitting/completing
      IO (io_uring_enter(2)), and one for aux functions like registrating
      file sets, buffers, etc (io_uring_register(2)). Through the help of
      Arnd, I've coordinated the syscall numbers so merge on that front
      should be painless.
    
      Jon did a writeup of the interface a while back, which (except for
      minor details that have been tweaked) is still accurate. Find that
      here:
    
        https://lwn.net/Articles/776703/
    
      Huge thanks to Al Viro for helping getting the reference cycle code
      correct, and to Jann Horn for his extensive reviews focused on both
      security and bugs in general.
    
      There's a userspace library that provides basic functionality for
      applications that don't need or want to care about how to fiddle with
      the rings directly. It has helpers to allow applications to easily set
      up an io_uring instance, and submit/complete IO through it without
      knowing about the intricacies of the rings. It also includes man pages
      (thanks to Jeff Moyer), and will continue to grow support helper
      functions and features as time progresses. Find it here:
    
        git://git.kernel.dk/liburing
    
      Fio has full support for the raw interface, both in the form of an IO
      engine (io_uring), but also with a small test application (t/io_uring)
      that can exercise and benchmark the interface"
    
    * tag 'io_uring-2019-03-06' of git://git.kernel.dk/linux-block:
      io_uring: add a few test tools
      io_uring: allow workqueue item to handle multiple buffered requests
      io_uring: add support for IORING_OP_POLL
      io_uring: add io_kiocb ref count
      io_uring: add submission polling
      io_uring: add file set registration
      net: split out functions related to registering inflight socket files
      io_uring: add support for pre-mapped user IO buffers
      block: implement bio helper to add iter bvec pages to bio
      io_uring: batch io_kiocb allocation
      io_uring: use fget/fput_many() for file references
      fs: add fget_many() and fput_many()
      io_uring: support for IO polling
      io_uring: add fsync support
      Add io_uring IO interface

commit 80201fe175cbf7f3e372f53eba0a881a702ad926
Merge: 4221b807d1f7 aaeee62c841c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 8 14:12:17 2019 -0800

    Merge tag 'for-5.1/block-20190302' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
     "Not a huge amount of changes in this round, the biggest one is that we
      finally have Mings multi-page bvec support merged. Apart from that,
      this pull request contains:
    
       - Small series that avoids quiescing the queue for sysfs changes that
         match what we currently have (Aleksei)
    
       - Series of bcache fixes (via Coly)
    
       - Series of lightnvm fixes (via Mathias)
    
       - NVMe pull request from Christoph. Nothing major, just SPDX/license
         cleanups, RR mp policy (Hannes), and little fixes (Bart,
         Chaitanya).
    
       - BFQ series (Paolo)
    
       - Save blk-mq cpu -> hw queue mapping, removing a pointer indirection
         for the fast path (Jianchao)
    
       - fops->iopoll() added for async IO polling, this is a feature that
         the upcoming io_uring interface will use (Christoph, me)
    
       - Partition scan loop fixes (Dongli)
    
       - mtip32xx conversion from managed resource API (Christoph)
    
       - cdrom registration race fix (Guenter)
    
       - MD pull from Song, two minor fixes.
    
       - Various documentation fixes (Marcos)
    
       - Multi-page bvec feature. This brings a lot of nice improvements
         with it, like more efficient splitting, larger IOs can be supported
         without growing the bvec table size, and so on. (Ming)
    
       - Various little fixes to core and drivers"
    
    * tag 'for-5.1/block-20190302' of git://git.kernel.dk/linux-block: (117 commits)
      block: fix updating bio's front segment size
      block: Replace function name in string with __func__
      nbd: propagate genlmsg_reply return code
      floppy: remove set but not used variable 'q'
      null_blk: fix checking for REQ_FUA
      block: fix NULL pointer dereference in register_disk
      fs: fix guard_bio_eod to check for real EOD errors
      blk-mq: use HCTX_TYPE_DEFAULT but not 0 to index blk_mq_tag_set->map
      block: optimize bvec iteration in bvec_iter_advance
      block: introduce mp_bvec_for_each_page() for iterating over page
      block: optimize blk_bio_segment_split for single-page bvec
      block: optimize __blk_segment_map_sg() for single-page bvec
      block: introduce bvec_nth_page()
      iomap: wire up the iopoll method
      block: add bio_set_polled() helper
      block: wire up block device iopoll method
      fs: add an iopoll method to struct file_operations
      loop: set GENHD_FL_NO_PART_SCAN after blkdev_reread_part()
      loop: do not print warn message if partition scan is successful
      block: bounce: make sure that bvec table is updated
      ...

commit b5dd0c658c31b469ccff1b637e5124851e7a4a1c
Merge: 610cd4eadec4 fe0436e10c88
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 7 19:25:37 2019 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge more updates from Andrew Morton:
    
     - some of the rest of MM
    
     - various misc things
    
     - dynamic-debug updates
    
     - checkpatch
    
     - some epoll speedups
    
     - autofs
    
     - rapidio
    
     - lib/, lib/lzo/ updates
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (83 commits)
      samples/mic/mpssd/mpssd.h: remove duplicate header
      kernel/fork.c: remove duplicated include
      include/linux/relay.h: fix percpu annotation in struct rchan
      arch/nios2/mm/fault.c: remove duplicate include
      unicore32: stop printing the virtual memory layout
      MAINTAINERS: fix GTA02 entry and mark as orphan
      mm: create the new vm_fault_t type
      arm, s390, unicore32: remove oneliner wrappers for memblock_alloc()
      arch: simplify several early memory allocations
      openrisc: simplify pte_alloc_one_kernel()
      sh: prefer memblock APIs returning virtual address
      microblaze: prefer memblock API returning virtual address
      powerpc: prefer memblock APIs returning virtual address
      lib/lzo: separate lzo-rle from lzo
      lib/lzo: implement run-length encoding
      lib/lzo: fast 8-byte copy on arm64
      lib/lzo: 64-bit CTZ on arm64
      lib/lzo: tidy-up ifdefs
      ipc/sem.c: replace kvmalloc/memset with kvzalloc and use struct_size
      ipc: annotate implicit fall through
      ...

commit f1fffbd44722cec9b8dd54d5cc86bd081ce39217
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Mar 7 16:27:07 2019 -0800

    linux/fs.h: move member alignment check next to definition of struct filename
    
    Instead of doing this compile-time check in some slightly arbitrary user
    of struct filename, put it next to the definition.
    
    Link: http://lkml.kernel.org/r/20190208203015.29702-3-linux@rasmusvillemoes.dk
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Nick Desaulniers <ndesaulniers@google.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 08f26046233e..1a775aa3e349 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -37,6 +37,8 @@
 #include <linux/uuid.h>
 #include <linux/errseq.h>
 #include <linux/ioprio.h>
+#include <linux/build_bug.h>
+#include <linux/stddef.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -2493,6 +2495,7 @@ struct filename {
 	struct audit_names	*aname;
 	const char		iname[];
 };
+static_assert(offsetof(struct filename, iname) % sizeof(long) == 0);
 
 extern long vfs_truncate(const struct path *, loff_t);
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,

commit b39a07a5e073ba783cd86b60c77044587ddbf8a1
Merge: f90d64483ebd e10892189428
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 7 08:23:17 2019 -0800

    Merge tag 'dtype_for_v5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull dtype handling cleanups from Jan Kara:
     "A reworked dtype cleanup patches based on your feedback to the
      previous version of these.
    
      Again the series includes only the generic code and ext2 cleanup as a
      sample. The plan is to push cleanups for other filesystems separately
      through respective trees once the generic code lands to reduce the
      number of conflicts"
    
    * tag 'dtype_for_v5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      ext2: use common file type conversion
      fs: common implementation of file type

commit a9519defc771d574888ffe01e84747889152ec35
Author: Greg Thelen <gthelen@google.com>
Date:   Tue Mar 5 15:50:03 2019 -0800

    writeback: fix inode cgroup switching comment
    
    Commit 682aa8e1a6a1 ("writeback: implement unlocked_inode_to_wb
    transaction and use it for stat updates") refers to
    inode_switch_wb_work_fn() which never got merged.
    
    Switch the comments to inode_switch_wbs_work_fn().
    
    Link: http://lkml.kernel.org/r/20190305004617.142590-1-gthelen@google.com
    Fixes: 682aa8e1a6a1 ("writeback: implement unlocked_inode_to_wb transaction and use it for stat updates")
    Signed-off-by: Greg Thelen <gthelen@google.com>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fd423fec8d83..08f26046233e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2091,7 +2091,7 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
  * I_WB_SWITCH		Cgroup bdi_writeback switching in progress.  Used to
  *			synchronize competing switching instances and to tell
  *			wb stat updates to grab the i_pages lock.  See
- *			inode_switch_wb_work_fn() for details.
+ *			inode_switch_wbs_work_fn() for details.
  *
  * I_OVL_INUSE		Used by overlayfs to get exclusive ownership on upper
  *			and work dirs among overlayfs mounts.

commit 84c4e1f89fefe70554da0ab33be72c9be7994379
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 3 14:23:33 2019 -0800

    aio: simplify - and fix - fget/fput for io_submit()
    
    Al Viro root-caused a race where the IOCB_CMD_POLL handling of
    fget/fput() could cause us to access the file pointer after it had
    already been freed:
    
     "In more details - normally IOCB_CMD_POLL handling looks so:
    
       1) io_submit(2) allocates aio_kiocb instance and passes it to
          aio_poll()
    
       2) aio_poll() resolves the descriptor to struct file by req->file =
          fget(iocb->aio_fildes)
    
       3) aio_poll() sets ->woken to false and raises ->ki_refcnt of that
          aio_kiocb to 2 (bumps by 1, that is).
    
       4) aio_poll() calls vfs_poll(). After sanity checks (basically,
          "poll_wait() had been called and only once") it locks the queue.
          That's what the extra reference to iocb had been for - we know we
          can safely access it.
    
       5) With queue locked, we check if ->woken has already been set to
          true (by aio_poll_wake()) and, if it had been, we unlock the
          queue, drop a reference to aio_kiocb and bugger off - at that
          point it's a responsibility to aio_poll_wake() and the stuff
          called/scheduled by it. That code will drop the reference to file
          in req->file, along with the other reference to our aio_kiocb.
    
       6) otherwise, we see whether we need to wait. If we do, we unlock the
          queue, drop one reference to aio_kiocb and go away - eventual
          wakeup (or cancel) will deal with the reference to file and with
          the other reference to aio_kiocb
    
       7) otherwise we remove ourselves from waitqueue (still under the
          queue lock), so that wakeup won't get us. No async activity will
          be happening, so we can safely drop req->file and iocb ourselves.
    
      If wakeup happens while we are in vfs_poll(), we are fine - aio_kiocb
      won't get freed under us, so we can do all the checks and locking
      safely. And we don't touch ->file if we detect that case.
    
      However, vfs_poll() most certainly *does* touch the file it had been
      given. So wakeup coming while we are still in ->poll() might end up
      doing fput() on that file. That case is not too rare, and usually we
      are saved by the still present reference from descriptor table - that
      fput() is not the final one.
    
      But if another thread closes that descriptor right after our fget()
      and wakeup does happen before ->poll() returns, we are in trouble -
      final fput() done while we are in the middle of a method:
    
    Al also wrote a patch to take an extra reference to the file descriptor
    to fix this, but I instead suggested we just streamline the whole file
    pointer handling by submit_io() so that the generic aio submission code
    simply keeps the file pointer around until the aio has completed.
    
    Fixes: bfe4037e722e ("aio: implement IOCB_CMD_POLL")
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Reported-by: syzbot+503d4cc169fcec1cb18c@syzkaller.appspotmail.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 29d8e2cfed0e..fd423fec8d83 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -304,13 +304,19 @@ enum rw_hint {
 
 struct kiocb {
 	struct file		*ki_filp;
+
+	/* The 'ki_filp' pointer is shared in a union for aio */
+	randomized_struct_fields_start
+
 	loff_t			ki_pos;
 	void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 	void			*private;
 	int			ki_flags;
 	u16			ki_hint;
 	u16			ki_ioprio; /* See linux/ioprio.h */
-} __randomize_layout;
+
+	randomized_struct_fields_end
+};
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
 {

commit 091141a42e15fe47ada737f3996b317072afcefb
Author: Jens Axboe <axboe@kernel.dk>
Date:   Wed Nov 21 10:32:39 2018 -0700

    fs: add fget_many() and fput_many()
    
    Some uses cases repeatedly get and put references to the same file, but
    the only exposed interface is doing these one at the time. As each of
    these entail an atomic inc or dec on a shared structure, that cost can
    add up.
    
    Add fget_many(), which works just like fget(), except it takes an
    argument for how many references to get on the file. Ditto fput_many(),
    which can drop an arbitrary number of references to a file.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 61aa210f0c2b..80e1b199a4b1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -952,7 +952,9 @@ static inline struct file *get_file(struct file *f)
 	atomic_long_inc(&f->f_count);
 	return f;
 }
-#define get_file_rcu(x) atomic_long_inc_not_zero(&(x)->f_count)
+#define get_file_rcu_many(x, cnt)	\
+	atomic_long_add_unless(&(x)->f_count, (cnt), 0)
+#define get_file_rcu(x) get_file_rcu_many((x), 1)
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 

commit 2b188cc1bb857a9d4701ae59aa7768b5124e262e
Author: Jens Axboe <axboe@kernel.dk>
Date:   Mon Jan 7 10:46:33 2019 -0700

    Add io_uring IO interface
    
    The submission queue (SQ) and completion queue (CQ) rings are shared
    between the application and the kernel. This eliminates the need to
    copy data back and forth to submit and complete IO.
    
    IO submissions use the io_uring_sqe data structure, and completions
    are generated in the form of io_uring_cqe data structures. The SQ
    ring is an index into the io_uring_sqe array, which makes it possible
    to submit a batch of IOs without them being contiguous in the ring.
    The CQ ring is always contiguous, as completion events are inherently
    unordered, and hence any io_uring_cqe entry can point back to an
    arbitrary submission.
    
    Two new system calls are added for this:
    
    io_uring_setup(entries, params)
            Sets up an io_uring instance for doing async IO. On success,
            returns a file descriptor that the application can mmap to
            gain access to the SQ ring, CQ ring, and io_uring_sqes.
    
    io_uring_enter(fd, to_submit, min_complete, flags, sigset, sigsetsize)
            Initiates IO against the rings mapped to this fd, or waits for
            them to complete, or both. The behavior is controlled by the
            parameters passed in. If 'to_submit' is non-zero, then we'll
            try and submit new IO. If IORING_ENTER_GETEVENTS is set, the
            kernel will wait for 'min_complete' events, if they aren't
            already available. It's valid to set IORING_ENTER_GETEVENTS
            and 'min_complete' == 0 at the same time, this allows the
            kernel to return already completed events without waiting
            for them. This is useful only for polling, as for IRQ
            driven IO, the application can just check the CQ ring
            without entering the kernel.
    
    With this setup, it's possible to do async IO with a single system
    call. Future developments will enable polled IO with this interface,
    and polled submission as well. The latter will enable an application
    to do IO without doing ANY system calls at all.
    
    For IRQ driven IO, an application only needs to enter the kernel for
    completions if it wants to wait for them to occur.
    
    Each io_uring is backed by a workqueue, to support buffered async IO
    as well. We will only punt to an async context if the command would
    need to wait for IO on the device side. Any data that can be accessed
    directly in the page cache is done inline. This avoids the slowness
    issue of usual threadpools, since cached data is accessed as quickly
    as a sync interface.
    
    Sample application: http://git.kernel.dk/cgit/fio/plain/t/io_uring.c
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dedcc2e9265c..61aa210f0c2b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3517,4 +3517,13 @@ extern void inode_nohighmem(struct inode *inode);
 extern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,
 		       int advice);
 
+#if defined(CONFIG_IO_URING)
+extern struct sock *io_uring_get_socket(struct file *file);
+#else
+static inline struct sock *io_uring_get_socket(struct file *file)
+{
+	return NULL;
+}
+#endif
+
 #endif /* _LINUX_FS_H */

commit d911b4585eb3501f752160e8e0f1bb00c3c7c4e5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:26 2018 +0000

    vfs: Remove kern_mount_data()
    
    The kern_mount_data() isn't used any more so remove it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9d05c128ccf6..3e85cb8e8c20 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2280,8 +2280,7 @@ mount_pseudo(struct file_system_type *fs_type, char *name,
 
 extern int register_filesystem(struct file_system_type *);
 extern int unregister_filesystem(struct file_system_type *);
-extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
-#define kern_mount(type) kern_mount_data(type, NULL)
+extern struct vfsmount *kern_mount(struct file_system_type *);
 extern void kern_unmount(struct vfsmount *mnt);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);

commit cb50b348c71ffa90d7d1b2a494b553b5099bc090
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 23 17:25:47 2018 -0500

    convenience helpers: vfs_get_super() and sget_fc()
    
    the former is an analogue of mount_{single,nodev} for use in
    ->get_tree() instances, the latter - analogue of sget() for the
    same.
    
    These are fairly similar to the originals, but the callback signature
    for sget_fc() is different from sget() ones, so getting bits and
    pieces shared would be too convoluted; we might get around to that
    later, but for now let's just remember to keep them in sync.  They
    do live next to each other, and changes in either won't be hard
    to spot.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cf6e9ea161eb..9d05c128ccf6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2232,8 +2232,12 @@ void kill_litter_super(struct super_block *sb);
 void deactivate_super(struct super_block *sb);
 void deactivate_locked_super(struct super_block *sb);
 int set_anon_super(struct super_block *s, void *data);
+int set_anon_super_fc(struct super_block *s, struct fs_context *fc);
 int get_anon_bdev(dev_t *);
 void free_anon_bdev(dev_t);
+struct super_block *sget_fc(struct fs_context *fc,
+			    int (*test)(struct super_block *, struct fs_context *),
+			    int (*set)(struct super_block *, struct fs_context *));
 struct super_block *sget_userns(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),

commit 3e1aeb00e6d132efc151dacc062b38269bc9eccc
Author: David Howells <dhowells@redhat.com>
Date:   Thu Nov 1 23:07:25 2018 +0000

    vfs: Implement a filesystem superblock creation/configuration context
    
    [AV - unfuck kern_mount_data(); we want non-NULL ->mnt_ns on long-living
    mounts]
    [AV - reordering fs/namespace.c is badly overdue, but let's keep it
    separate from that series]
    [AV - drop simple_pin_fs() change]
    [AV - clean vfs_kern_mount() failure exits up]
    
    Implement a filesystem context concept to be used during superblock
    creation for mount and superblock reconfiguration for remount.
    
    The mounting procedure then becomes:
    
     (1) Allocate new fs_context context.
    
     (2) Configure the context.
    
     (3) Create superblock.
    
     (4) Query the superblock.
    
     (5) Create a mount for the superblock.
    
     (6) Destroy the context.
    
    Rather than calling fs_type->mount(), an fs_context struct is created and
    fs_type->init_fs_context() is called to set it up.  Pointers exist for the
    filesystem and LSM to hang their private data off.
    
    A set of operations has to be set by ->init_fs_context() to provide
    freeing, duplication, option parsing, binary data parsing, validation,
    mounting and superblock filling.
    
    Legacy filesystems are supported by the provision of a set of legacy
    fs_context operations that build up a list of mount options and then invoke
    fs_type->mount() from within the fs_context ->get_tree() operation.  This
    allows all filesystems to be accessed using fs_context.
    
    It should be noted that, whilst this patch adds a lot of lines of code,
    there is quite a bit of duplication with existing code that can be
    eliminated should all filesystems be converted over.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8d578a9e1e8c..cf6e9ea161eb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -62,6 +62,7 @@ struct iov_iter;
 struct fscrypt_info;
 struct fscrypt_operations;
 struct fs_context;
+struct fs_parameter_description;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2175,6 +2176,7 @@ struct file_system_type {
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	int (*init_fs_context)(struct fs_context *);
+	const struct fs_parameter_description *parameters;
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
 	void (*kill_sb) (struct super_block *);

commit fb7e160019f4abb4082740bfeb27a38f6389c745
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 22 16:37:38 2018 +0100

    fs: add an iopoll method to struct file_operations
    
    This new methods is used to explicitly poll for I/O completion for an
    iocb.  It must be called for any iocb submitted asynchronously (that
    is with a non-null ki_complete) which has the IOCB_HIPRI flag set.
    
    The method is assisted by a new ki_cookie field in struct iocb to store
    the polling cookie.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 29d8e2cfed0e..dedcc2e9265c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -310,6 +310,7 @@ struct kiocb {
 	int			ki_flags;
 	u16			ki_hint;
 	u16			ki_ioprio; /* See linux/ioprio.h */
+	unsigned int		ki_cookie; /* for ->iopoll */
 } __randomize_layout;
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
@@ -1787,6 +1788,7 @@ struct file_operations {
 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
+	int (*iopoll)(struct kiocb *kiocb, bool spin);
 	int (*iterate) (struct file *, struct dir_context *);
 	int (*iterate_shared) (struct file *, struct dir_context *);
 	__poll_t (*poll) (struct file *, struct poll_table_struct *);

commit f3a09c92018a91ad0981146a4ac59414f814d801
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 23 18:55:56 2018 -0500

    introduce fs_context methods
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c65d02c5c512..8d578a9e1e8c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -61,6 +61,7 @@ struct workqueue_struct;
 struct iov_iter;
 struct fscrypt_info;
 struct fscrypt_operations;
+struct fs_context;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2173,6 +2174,7 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
+	int (*init_fs_context)(struct fs_context *);
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
 	void (*kill_sb) (struct super_block *);

commit 8d0347f6c3a9d4953ddd636a31c6584da082e084
Author: David Howells <dhowells@redhat.com>
Date:   Sun Nov 4 09:28:36 2018 -0500

    convert do_remount_sb() to fs_context
    
    Replace do_remount_sb() with a function, reconfigure_super(), that's
    fs_context aware.  The fs_context is expected to be parameterised already
    and have ->root pointing to the superblock to be reconfigured.
    
    A legacy wrapper is provided that is intended to be called from the
    fs_context ops when those appear, but for now is called directly from
    reconfigure_super().  This wrapper invokes the ->remount_fs() superblock op
    for the moment.  It is intended that the remount_fs() op will be phased
    out.
    
    The fs_context->purpose is set to FS_CONTEXT_FOR_RECONFIGURE to indicate
    that the context is being used for reconfiguration.
    
    do_umount_root() is provided to consolidate remount-to-R/O for umount and
    emergency remount by creating a context and invoking reconfiguration.
    
    do_remount(), do_umount() and do_emergency_remount_callback() are switched
    to use the new process.
    
    [AV -- fold UMOUNT and EMERGENCY_REMOUNT in; fixes the
    umount / bug, gets rid of pointless complexity]
    [AV -- set ->net_ns in all cases; nfs remount will need that]
    [AV -- shift security_sb_remount() call into reconfigure_super(); the callers
    that didn't do security_sb_remount() have NULL fc->security anyway, so it's
    a no-op for them]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Co-developed-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 36fff12ab890..c65d02c5c512 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1337,6 +1337,7 @@ extern int send_sigurg(struct fown_struct *fown);
 
 /* These sb flags are internal to the kernel */
 #define SB_SUBMOUNT     (1<<26)
+#define SB_FORCE    	(1<<27)
 #define SB_NOSEC	(1<<28)
 #define SB_BORN		(1<<29)
 #define SB_ACTIVE	(1<<30)

commit a0c9a8b8fd9fd572b0d60276beb2142c8f59f9b8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 4 07:18:51 2018 -0500

    teach vfs_get_tree() to handle subtype, switch do_new_mount() to it
    
    Roll the handling of subtypes into do_new_mount() and vfs_get_tree().  The
    former determines any subtype string and hangs it off the fs_context; the
    latter applies it.
    
    Make do_new_mount() create, parameterise and commit an fs_context and
    create a mount for itself rather than calling vfs_kern_mount().
    
    [AV -- missing kstrdup()]
    [AV -- ... and no kstrdup() if we get to setting ->s_submount - we
    simply transfer it from fc, leaving NULL behind]
    [AV -- constify ->s_submount, while we are at it]
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 811c77743dad..36fff12ab890 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1447,7 +1447,7 @@ struct super_block {
 	 * Filesystem subtype.  If non-empty the filesystem type field
 	 * in /proc/mounts will be "type.subtype"
 	 */
-	char *s_subtype;
+	const char *s_subtype;
 
 	const struct dentry_operations *s_d_op; /* default d_op for dentries */
 

commit 7d10f70fc198877b43d92bdcd7604279788b9568
Author: Waiman Long <longman@redhat.com>
Date:   Wed Jan 30 13:52:37 2019 -0500

    fs: Don't need to put list_lru into its own cacheline
    
    The list_lru structure is essentially just a pointer to a table of
    per-node LRU lists.  Even if CONFIG_MEMCG_KMEM is defined, the list
    field is just used for LRU list registration and shrinker_id is set at
    initialization.  Those fields won't need to be touched that often.
    
    So there is no point to make the list_lru structures to sit in their own
    cachelines.
    
    Signed-off-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 811c77743dad..29d8e2cfed0e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1479,11 +1479,12 @@ struct super_block {
 	struct user_namespace *s_user_ns;
 
 	/*
-	 * Keep the lru lists last in the structure so they always sit on their
-	 * own individual cachelines.
+	 * The list_lru structure is essentially just a pointer to a table
+	 * of per-node lru lists, each of which has its own spinlock.
+	 * There is no need to put them into separate cachelines.
 	 */
-	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
-	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
+	struct list_lru		s_dentry_lru;
+	struct list_lru		s_inode_lru;
 	struct rcu_head		rcu;
 	struct work_struct	destroy_work;
 

commit 643fa9612bf1a29153eee46fd398117632f93cbe
Author: Chandan Rajendra <chandan@linux.vnet.ibm.com>
Date:   Wed Dec 12 15:20:12 2018 +0530

    fscrypt: remove filesystem specific build config option
    
    In order to have a common code base for fscrypt "post read" processing
    for all filesystems which support encryption, this commit removes
    filesystem specific build config option (e.g. CONFIG_EXT4_FS_ENCRYPTION)
    and replaces it with a build option (i.e. CONFIG_FS_ENCRYPTION) whose
    value affects all the filesystems making use of fscrypt.
    
    Reviewed-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 811c77743dad..ba7889bb9ef6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -698,7 +698,7 @@ struct inode {
 	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;
 #endif
 
-#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
+#ifdef CONFIG_FS_ENCRYPTION
 	struct fscrypt_info	*i_crypt_info;
 #endif
 
@@ -1403,7 +1403,7 @@ struct super_block {
 	void                    *s_security;
 #endif
 	const struct xattr_handler **s_xattr;
-#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
+#ifdef CONFIG_FS_ENCRYPTION
 	const struct fscrypt_operations	*s_cop;
 #endif
 	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */

commit bbe7449e2599b58cf7b995461e2189998111f907
Author: Phillip Potter <phil@philpotter.co.uk>
Date:   Mon Jan 21 00:54:27 2019 +0000

    fs: common implementation of file type
    
    Many file systems use a copy&paste implementation
    of dirent to on-disk file type conversions.
    
    Create a common implementation to be used by file systems
    with some useful conversion helpers to reduce open coded
    file type conversions in file system code.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Phillip Potter <phil@philpotter.co.uk>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 811c77743dad..92966678539d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -37,6 +37,7 @@
 #include <linux/uuid.h>
 #include <linux/errseq.h>
 #include <linux/ioprio.h>
+#include <linux/fs_types.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -1699,22 +1700,6 @@ int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
 			    u64 phys, u64 len, u32 flags);
 int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
 
-/*
- * File types
- *
- * NOTE! These match bits 12..15 of stat.st_mode
- * (ie "(i_mode >> 12) & 15").
- */
-#define DT_UNKNOWN	0
-#define DT_FIFO		1
-#define DT_CHR		2
-#define DT_DIR		4
-#define DT_BLK		6
-#define DT_REG		8
-#define DT_LNK		10
-#define DT_SOCK		12
-#define DT_WHT		14
-
 /*
  * This is the "filldir" function type, used by readdir() to let
  * the kernel specify what kind of dirent layout it wants to have.

commit f346b0becb1bc62e45495f9cdbae3eef35d0b635
Merge: 00d59fde8532 0f4991e8fd48
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 16:55:46 2018 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge misc updates from Andrew Morton:
    
     - large KASAN update to use arm's "software tag-based mode"
    
     - a few misc things
    
     - sh updates
    
     - ocfs2 updates
    
     - just about all of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (167 commits)
      kernel/fork.c: mark 'stack_vm_area' with __maybe_unused
      memcg, oom: notify on oom killer invocation from the charge path
      mm, swap: fix swapoff with KSM pages
      include/linux/gfp.h: fix typo
      mm/hmm: fix memremap.h, move dev_page_fault_t callback to hmm
      hugetlbfs: Use i_mmap_rwsem to fix page fault/truncate race
      hugetlbfs: use i_mmap_rwsem for more pmd sharing synchronization
      memory_hotplug: add missing newlines to debugging output
      mm: remove __hugepage_set_anon_rmap()
      include/linux/vmstat.h: remove unused page state adjustment macro
      mm/page_alloc.c: allow error injection
      mm: migrate: drop unused argument of migrate_page_move_mapping()
      blkdev: avoid migration stalls for blkdev pages
      mm: migrate: provide buffer_migrate_page_norefs()
      mm: migrate: move migrate_page_lock_buffers()
      mm: migrate: lock buffers before migrate_page_move_mapping()
      mm: migration: factor out code to compute expected number of page references
      mm, page_alloc: enable pcpu_drain with zone capability
      kmemleak: add config to select auto scan
      mm/page_alloc.c: don't call kasan_free_pages() at deferred mem init
      ...

commit 0e9da3fbf7d81f0f913b491c8de1ba7883d4f217
Merge: b12a9124eeb7 00203ba40d40
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 13:19:59 2018 -0800

    Merge tag 'for-4.21/block-20181221' of git://git.kernel.dk/linux-block
    
    Pull block updates from Jens Axboe:
     "This is the main pull request for block/storage for 4.21.
    
      Larger than usual, it was a busy round with lots of goodies queued up.
      Most notable is the removal of the old IO stack, which has been a long
      time coming. No new features for a while, everything coming in this
      week has all been fixes for things that were previously merged.
    
      This contains:
    
       - Use atomic counters instead of semaphores for mtip32xx (Arnd)
    
       - Cleanup of the mtip32xx request setup (Christoph)
    
       - Fix for circular locking dependency in loop (Jan, Tetsuo)
    
       - bcache (Coly, Guoju, Shenghui)
          * Optimizations for writeback caching
          * Various fixes and improvements
    
       - nvme (Chaitanya, Christoph, Sagi, Jay, me, Keith)
          * host and target support for NVMe over TCP
          * Error log page support
          * Support for separate read/write/poll queues
          * Much improved polling
          * discard OOM fallback
          * Tracepoint improvements
    
       - lightnvm (Hans, Hua, Igor, Matias, Javier)
          * Igor added packed metadata to pblk. Now drives without metadata
            per LBA can be used as well.
          * Fix from Geert on uninitialized value on chunk metadata reads.
          * Fixes from Hans and Javier to pblk recovery and write path.
          * Fix from Hua Su to fix a race condition in the pblk recovery
            code.
          * Scan optimization added to pblk recovery from Zhoujie.
          * Small geometry cleanup from me.
    
       - Conversion of the last few drivers that used the legacy path to
         blk-mq (me)
    
       - Removal of legacy IO path in SCSI (me, Christoph)
    
       - Removal of legacy IO stack and schedulers (me)
    
       - Support for much better polling, now without interrupts at all.
         blk-mq adds support for multiple queue maps, which enables us to
         have a map per type. This in turn enables nvme to have separate
         completion queues for polling, which can then be interrupt-less.
         Also means we're ready for async polled IO, which is hopefully
         coming in the next release.
    
       - Killing of (now) unused block exports (Christoph)
    
       - Unification of the blk-rq-qos and blk-wbt wait handling (Josef)
    
       - Support for zoned testing with null_blk (Masato)
    
       - sx8 conversion to per-host tag sets (Christoph)
    
       - IO priority improvements (Damien)
    
       - mq-deadline zoned fix (Damien)
    
       - Ref count blkcg series (Dennis)
    
       - Lots of blk-mq improvements and speedups (me)
    
       - sbitmap scalability improvements (me)
    
       - Make core inflight IO accounting per-cpu (Mikulas)
    
       - Export timeout setting in sysfs (Weiping)
    
       - Cleanup the direct issue path (Jianchao)
    
       - Export blk-wbt internals in block debugfs for easier debugging
         (Ming)
    
       - Lots of other fixes and improvements"
    
    * tag 'for-4.21/block-20181221' of git://git.kernel.dk/linux-block: (364 commits)
      kyber: use sbitmap add_wait_queue/list_del wait helpers
      sbitmap: add helpers for add/del wait queue handling
      block: save irq state in blkg_lookup_create()
      dm: don't reuse bio for flushes
      nvme-pci: trace SQ status on completions
      nvme-rdma: implement polling queue map
      nvme-fabrics: allow user to pass in nr_poll_queues
      nvme-fabrics: allow nvmf_connect_io_queue to poll
      nvme-core: optionally poll sync commands
      block: make request_to_qc_t public
      nvme-tcp: fix spelling mistake "attepmpt" -> "attempt"
      nvme-tcp: fix endianess annotations
      nvmet-tcp: fix endianess annotations
      nvme-pci: refactor nvme_poll_irqdisable to make sparse happy
      nvme-pci: only set nr_maps to 2 if poll queues are supported
      nvmet: use a macro for default error location
      nvmet: fix comparison of a u16 with -1
      blk-mq: enable IO poll if .nr_queues of type poll > 0
      blk-mq: change blk_mq_queue_busy() to blk_mq_queue_inflight()
      blk-mq: skip zero-queue maps in blk_mq_map_swqueue
      ...

commit 89cb0888ca1483ad72648844ddd1b801863a8949
Author: Jan Kara <jack@suse.cz>
Date:   Fri Dec 28 00:39:12 2018 -0800

    mm: migrate: provide buffer_migrate_page_norefs()
    
    Provide a variant of buffer_migrate_page() that also checks whether there
    are no unexpected references to buffer heads.  This function will then be
    safe to use for block device pages.
    
    [akpm@linux-foundation.org: remove EXPORT_SYMBOL(buffer_migrate_page_norefs)]
    Link: http://lkml.kernel.org/r/20181211172143.7358-5-jack@suse.cz
    Signed-off-by: Jan Kara <jack@suse.cz>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 26a8607b3c3c..1cda6648a41f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3269,8 +3269,12 @@ extern int generic_check_addressable(unsigned, u64);
 extern int buffer_migrate_page(struct address_space *,
 				struct page *, struct page *,
 				enum migrate_mode);
+extern int buffer_migrate_page_norefs(struct address_space *,
+				struct page *, struct page *,
+				enum migrate_mode);
 #else
 #define buffer_migrate_page NULL
+#define buffer_migrate_page_norefs NULL
 #endif
 
 extern int setattr_prepare(struct dentry *, struct iattr *);

commit cb03f94ffb070b13bc0fa58b4ef4fdb558418d27
Author: NeilBrown <neilb@suse.com>
Date:   Fri Nov 30 10:04:08 2018 +1100

    fs/locks: merge posix_unblock_lock() and locks_delete_block()
    
    posix_unblock_lock() is not specific to posix locks, and behaves
    nearly identically to locks_delete_block() - the former returning a
    status while the later doesn't.
    
    So discard posix_unblock_lock() and use locks_delete_block() instead,
    after giving that function an appropriate return value.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Reviewed-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 16df3a7df378..26a8607b3c3c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1124,7 +1124,7 @@ extern void locks_remove_file(struct file *);
 extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
-extern int posix_unblock_lock(struct file_lock *);
+extern int locks_delete_block(struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
@@ -1214,7 +1214,7 @@ static inline int posix_lock_file(struct file *filp, struct file_lock *fl,
 	return -ENOLCK;
 }
 
-static inline int posix_unblock_lock(struct file_lock *waiter)
+static inline int locks_delete_block(struct file_lock *waiter)
 {
 	return -ENOENT;
 }

commit ada5c1da8660ecae24b3e75c18ee77d79e099fee
Author: NeilBrown <neilb@suse.com>
Date:   Fri Nov 30 10:04:08 2018 +1100

    fs/locks: rename some lists and pointers.
    
    struct file lock contains an 'fl_next' pointer which
    is used to point to the lock that this request is blocked
    waiting for.  So rename it to fl_blocker.
    
    The fl_blocked list_head in an active lock is the head of a list of
    blocked requests.  In a request it is a node in that list.
    These are two distinct uses, so replace with two list_heads
    with different names.
    fl_blocked_requests is the head of a list of blocked requests
    fl_blocked_member is a node in a member of that list.
    
    The two different list_heads are never used at the same time, but that
    will change in a future patch.
    
    Note that a tracepoint is changed to report fl_blocker instead
    of fl_next.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Reviewed-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c95c0807471f..16df3a7df378 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1044,10 +1044,15 @@ bool opens_in_grace(struct net *);
  * Obviously, the last two criteria only matter for POSIX locks.
  */
 struct file_lock {
-	struct file_lock *fl_next;	/* singly linked list for this inode  */
+	struct file_lock *fl_blocker;	/* The lock, that is blocking us */
 	struct list_head fl_list;	/* link into file_lock_context */
 	struct hlist_node fl_link;	/* node in global lists */
-	struct list_head fl_block;	/* circular list of blocked processes */
+	struct list_head fl_blocked_requests;	/* list of requests with
+						 * ->fl_blocker pointing here
+						 */
+	struct list_head fl_blocked_member;	/* node in
+						 * ->fl_blocker->fl_blocked_requests
+						 */
 	fl_owner_t fl_owner;
 	unsigned int fl_flags;
 	unsigned char fl_type;

commit 20578bdfd0418efb11ec316229e670d085cd574a
Author: Damien Le Moal <damien.lemoal@wdc.com>
Date:   Tue Nov 20 10:52:38 2018 +0900

    block: Initialize BIO I/O priority early
    
    For the synchronous I/O path case (read(), write() etc system calls), a
    BIO I/O priority is not initialized until the execution of
    blk_init_request_from_bio() when the BIO is submitted and a request
    initialized for the BIO execution. This is due to the ki_ioprio field of
    the struct kiocb defined on stack being always initialized to
    IOPRIO_CLASS_NONE, regardless of the calling process I/O context ioprio
    value set with ioprio_set(). This late initialization can result in the
    BIO being merged to pending requests even when the I/O priorities
    differ.
    
    Fix this by initializing the ki_iopriority field of on stack struct
    kiocb using the get_current_ioprio() helper, ensuring that all BIOs
    allocated and submitted for the system call execution see the correct
    intended I/O priority early. With this, since a BIO I/O priority is
    always set to the intended effective value for both the sync and async
    path, blk_init_request_from_bio() can be simplified.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Adam Manzanares <adam.manzanares@wdc.com>
    Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c95c0807471f..a1ab233e6469 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2021,7 +2021,7 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 		.ki_filp = filp,
 		.ki_flags = iocb_flags(filp),
 		.ki_hint = ki_hint_validate(file_write_hint(filp)),
-		.ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0),
+		.ki_ioprio = get_current_ioprio(),
 	};
 }
 

commit c2aa1a444cab2c673650ada80a7dffc4345ce2e6
Merge: b69f9e17a57a bf4a1fcf0bc1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 2 09:33:08 2018 -0700

    Merge tag 'xfs-4.20-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull vfs dedup fixes from Dave Chinner:
     "This reworks the vfs data cloning infrastructure.
    
      We discovered many issues with these interfaces late in the 4.19 cycle
      - the worst of them (data corruption, setuid stripping) were fixed for
      XFS in 4.19-rc8, but a larger rework of the infrastructure fixing all
      the problems was needed. That rework is the contents of this pull
      request.
    
      Rework the vfs_clone_file_range and vfs_dedupe_file_range
      infrastructure to use a common .remap_file_range method and supply
      generic bounds and sanity checking functions that are shared with the
      data write path. The current VFS infrastructure has problems with
      rlimit, LFS file sizes, file time stamps, maximum filesystem file
      sizes, stripping setuid bits, etc and so they are addressed in these
      commits.
    
      We also introduce the ability for the ->remap_file_range methods to
      return short clones so that clones for vfs_copy_file_range() don't get
      rejected if the entire range can't be cloned. It also allows
      filesystems to sliently skip deduplication of partial EOF blocks if
      they are not capable of doing so without requiring errors to be thrown
      to userspace.
    
      Existing filesystems are converted to user the new remap_file_range
      method, and both XFS and ocfs2 are modified to make use of the new
      generic checking infrastructure"
    
    * tag 'xfs-4.20-merge-2' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux: (28 commits)
      xfs: remove [cm]time update from reflink calls
      xfs: remove xfs_reflink_remap_range
      xfs: remove redundant remap partial EOF block checks
      xfs: support returning partial reflink results
      xfs: clean up xfs_reflink_remap_blocks call site
      xfs: fix pagecache truncation prior to reflink
      ocfs2: remove ocfs2_reflink_remap_range
      ocfs2: support partial clone range and dedupe range
      ocfs2: fix pagecache truncation prior to reflink
      ocfs2: truncate page cache for clone destination file before remapping
      vfs: clean up generic_remap_file_range_prep return value
      vfs: hide file range comparison function
      vfs: enable remap callers that can handle short operations
      vfs: plumb remap flags through the vfs dedupe functions
      vfs: plumb remap flags through the vfs clone functions
      vfs: make remap_file_range functions take and return bytes completed
      vfs: remap helper should update destination inode metadata
      vfs: pass remap flags to generic_remap_checks
      vfs: pass remap flags to generic_remap_file_range_prep
      vfs: combine the clone and dedupe into a single remap_file_range
      ...

commit c32e5f39953fa6bbff35c655bdcb7b3128f1e79f
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:42:17 2018 +1100

    vfs: hide file range comparison function
    
    There are no callers of vfs_dedupe_file_range_compare, so we might as
    well make it a static helper and remove the export.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 34c22d695011..346036a84f18 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1853,9 +1853,6 @@ extern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
 extern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 				   struct file *file_out, loff_t pos_out,
 				   loff_t len, unsigned int remap_flags);
-extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
-					 struct inode *dest, loff_t destoff,
-					 loff_t len, bool *is_same);
 extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
 extern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,

commit eca3654e3cc7d93e9734d0fa96cfb15c7f356244
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:42:10 2018 +1100

    vfs: enable remap callers that can handle short operations
    
    Plumb in a remap flag that enables the filesystem remap handler to
    shorten remapping requests for callers that can handle it.  Now
    copy_file_range can report partial success (in case we run up against
    alignment problems, resource limits, etc.).
    
    We also enable CAN_SHORTEN for fideduperange to maintain existing
    userspace-visible behavior where xfs/btrfs shorten the dedupe range to
    avoid stale post-eof data exposure.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 544ab5083b48..34c22d695011 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1727,8 +1727,10 @@ struct block_device_operations;
  * See Documentation/filesystems/vfs.txt for more details about this call.
  *
  * REMAP_FILE_DEDUP: only remap if contents identical (i.e. deduplicate)
+ * REMAP_FILE_CAN_SHORTEN: caller can handle a shortened request
  */
 #define REMAP_FILE_DEDUP		(1 << 0)
+#define REMAP_FILE_CAN_SHORTEN		(1 << 1)
 
 /*
  * These flags signal that the caller is ok with altering various aspects of
@@ -1736,9 +1738,8 @@ struct block_device_operations;
  * implementation; the vfs remap helper functions can take advantage of them.
  * Flags in this category exist to preserve the quirky behavior of the hoisted
  * btrfs clone/dedupe ioctls.
- * There are no flags yet, but subsequent commits will add some.
  */
-#define REMAP_FILE_ADVISORY		(0)
+#define REMAP_FILE_ADVISORY		(REMAP_FILE_CAN_SHORTEN)
 
 struct iov_iter;
 

commit df3658361951e17364f1e1c3fa92862a990ad8bd
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:42:03 2018 +1100

    vfs: plumb remap flags through the vfs dedupe functions
    
    Plumb a remap_flags argument through the vfs_dedupe_file_range_one
    functions so that dedupe can take advantage of it.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1c5e55d2a67d..544ab5083b48 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1859,7 +1859,7 @@ extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
 extern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
 					struct file *dst_file, loff_t dst_pos,
-					loff_t len);
+					loff_t len, unsigned int remap_flags);
 
 
 struct super_operations {

commit 452ce65951a2f0719e4e119ecca134c06cfe22ee
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:56 2018 +1100

    vfs: plumb remap flags through the vfs clone functions
    
    Plumb a remap_flags argument through the {do,vfs}_clone_file_range
    functions so that clone can take advantage of it.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c72d8c3c065a..1c5e55d2a67d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1848,10 +1848,10 @@ extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
 					 unsigned int remap_flags);
 extern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
 				  struct file *file_out, loff_t pos_out,
-				  loff_t len);
+				  loff_t len, unsigned int remap_flags);
 extern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 				   struct file *file_out, loff_t pos_out,
-				   loff_t len);
+				   loff_t len, unsigned int remap_flags);
 extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
 					 struct inode *dest, loff_t destoff,
 					 loff_t len, bool *is_same);

commit 42ec3d4c02187a18e27ff94b409ec27234bf2ffd
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:49 2018 +1100

    vfs: make remap_file_range functions take and return bytes completed
    
    Change the remap_file_range functions to take a number of bytes to
    operate upon and return the number of bytes they operated on.  This is a
    requirement for allowing fs implementations to return short clone/dedupe
    results to the user, which will enable us to obey resource limits in a
    graceful manner.
    
    A subsequent patch will enable copy_file_range to signal to the
    ->clone_file_range implementation that it can handle a short length,
    which will be returned in the function's return value.  For now the
    short return is not implemented anywhere so the behavior won't change --
    either copy_file_range manages to clone the entire range or it tries an
    alternative.
    
    Neither clone ioctl can take advantage of this, alas.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c5435ca81132..c72d8c3c065a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1777,9 +1777,9 @@ struct file_operations {
 #endif
 	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
 			loff_t, size_t, unsigned int);
-	int (*remap_file_range)(struct file *file_in, loff_t pos_in,
-				struct file *file_out, loff_t pos_out,
-				u64 len, unsigned int remap_flags);
+	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
+				   struct file *file_out, loff_t pos_out,
+				   loff_t len, unsigned int remap_flags);
 	int (*fadvise)(struct file *, loff_t, loff_t, int);
 } __randomize_layout;
 
@@ -1844,19 +1844,22 @@ extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
 extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
 					 struct file *file_out, loff_t pos_out,
-					 u64 *count, unsigned int remap_flags);
-extern int do_clone_file_range(struct file *file_in, loff_t pos_in,
-			       struct file *file_out, loff_t pos_out, u64 len);
-extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
-				struct file *file_out, loff_t pos_out, u64 len);
+					 loff_t *count,
+					 unsigned int remap_flags);
+extern loff_t do_clone_file_range(struct file *file_in, loff_t pos_in,
+				  struct file *file_out, loff_t pos_out,
+				  loff_t len);
+extern loff_t vfs_clone_file_range(struct file *file_in, loff_t pos_in,
+				   struct file *file_out, loff_t pos_out,
+				   loff_t len);
 extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
 					 struct inode *dest, loff_t destoff,
 					 loff_t len, bool *is_same);
 extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
-extern int vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
-				     struct file *dst_file, loff_t dst_pos,
-				     u64 len);
+extern loff_t vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
+					struct file *dst_file, loff_t dst_pos,
+					loff_t len);
 
 
 struct super_operations {
@@ -2986,7 +2989,7 @@ extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
 extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out,
-				uint64_t *count, unsigned int remap_flags);
+				loff_t *count, unsigned int remap_flags);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit 3d28193e1df043764deb7abdaba5e3a6660bc393
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:34 2018 +1100

    vfs: pass remap flags to generic_remap_checks
    
    Pass the same remap flags to generic_remap_checks for consistency.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 631c28ce1436..c5435ca81132 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2986,7 +2986,7 @@ extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
 extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out,
-				uint64_t *count, bool is_dedupe);
+				uint64_t *count, unsigned int remap_flags);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit a91ae49bbaf43910edb09e03fedf26b23875bd52
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:28 2018 +1100

    vfs: pass remap flags to generic_remap_file_range_prep
    
    Plumb the remap flags through the filesystem from the vfs function
    dispatcher all the way to the prep function to prepare for behavior
    changes in subsequent patches.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 888cef35c7d7..631c28ce1436 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1844,7 +1844,7 @@ extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
 extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
 					 struct file *file_out, loff_t pos_out,
-					 u64 *count, bool is_dedupe);
+					 u64 *count, unsigned int remap_flags);
 extern int do_clone_file_range(struct file *file_in, loff_t pos_in,
 			       struct file *file_out, loff_t pos_out, u64 len);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,

commit 2e5dfc99f2e61c42083ba742395e7a7b353513d1
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:21 2018 +1100

    vfs: combine the clone and dedupe into a single remap_file_range
    
    Combine the clone_file_range and dedupe_file_range operations into a
    single remap_file_range file operation dispatch since they're
    fundamentally the same operation.  The differences between the two can
    be made in the prep functions.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 55729e1c2e75..888cef35c7d7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1721,6 +1721,24 @@ struct block_device_operations;
 #define NOMMU_VMFLAGS \
 	(NOMMU_MAP_READ | NOMMU_MAP_WRITE | NOMMU_MAP_EXEC)
 
+/*
+ * These flags control the behavior of the remap_file_range function pointer.
+ * If it is called with len == 0 that means "remap to end of source file".
+ * See Documentation/filesystems/vfs.txt for more details about this call.
+ *
+ * REMAP_FILE_DEDUP: only remap if contents identical (i.e. deduplicate)
+ */
+#define REMAP_FILE_DEDUP		(1 << 0)
+
+/*
+ * These flags signal that the caller is ok with altering various aspects of
+ * the behavior of the remap operation.  The changes must be made by the
+ * implementation; the vfs remap helper functions can take advantage of them.
+ * Flags in this category exist to preserve the quirky behavior of the hoisted
+ * btrfs clone/dedupe ioctls.
+ * There are no flags yet, but subsequent commits will add some.
+ */
+#define REMAP_FILE_ADVISORY		(0)
 
 struct iov_iter;
 
@@ -1759,10 +1777,9 @@ struct file_operations {
 #endif
 	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
 			loff_t, size_t, unsigned int);
-	int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,
-			u64);
-	int (*dedupe_file_range)(struct file *, loff_t, struct file *, loff_t,
-			u64);
+	int (*remap_file_range)(struct file *file_in, loff_t pos_in,
+				struct file *file_out, loff_t pos_out,
+				u64 len, unsigned int remap_flags);
 	int (*fadvise)(struct file *, loff_t, loff_t, int);
 } __randomize_layout;
 

commit a83ab01a62e61616ebb8b97f90f568c1214dc10d
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:41:08 2018 +1100

    vfs: rename vfs_clone_file_prep to be more descriptive
    
    The vfs_clone_file_prep is a generic function to be called by filesystem
    implementations only.  Rename the prefix to generic_ and make it more
    clear that it applies to remap operations, not just clones.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ba93a6e7dac4..55729e1c2e75 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1825,9 +1825,9 @@ extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *, rwf_t);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
-extern int vfs_clone_file_prep(struct file *file_in, loff_t pos_in,
-			       struct file *file_out, loff_t pos_out,
-			       u64 *count, bool is_dedupe);
+extern int generic_remap_file_range_prep(struct file *file_in, loff_t pos_in,
+					 struct file *file_out, loff_t pos_out,
+					 u64 *count, bool is_dedupe);
 extern int do_clone_file_range(struct file *file_in, loff_t pos_in,
 			       struct file *file_out, loff_t pos_out, u64 len);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,

commit 1383a7ed67490fb00d793e36c7a4d599ff88a64d
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Tue Oct 30 10:40:31 2018 +1100

    vfs: check file ranges before cloning files
    
    Move the file range checks from vfs_clone_file_prep into a separate
    generic_remap_checks function so that all the checks are collected in a
    central location.  This forms the basis for adding more checks from
    generic_write_checks that will make cloning's input checking more
    consistent with write input checking.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 897eae8faee1..ba93a6e7dac4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1825,9 +1825,9 @@ extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *, rwf_t);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
-extern int vfs_clone_file_prep_inodes(struct inode *inode_in, loff_t pos_in,
-				      struct inode *inode_out, loff_t pos_out,
-				      u64 *len, bool is_dedupe);
+extern int vfs_clone_file_prep(struct file *file_in, loff_t pos_in,
+			       struct file *file_out, loff_t pos_out,
+			       u64 *count, bool is_dedupe);
 extern int do_clone_file_range(struct file *file_in, loff_t pos_in,
 			       struct file *file_out, loff_t pos_out, u64 len);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
@@ -2967,6 +2967,9 @@ extern int sb_min_blocksize(struct super_block *, int);
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
+extern int generic_remap_checks(struct file *file_in, loff_t pos_in,
+				struct file *file_out, loff_t pos_out,
+				uint64_t *count, bool is_dedupe);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit 79257514f532bd6e500267a061ae2cae4e3d28d5
Merge: 7da4221b530f 721fb6fbfd21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 29 09:19:53 2018 -0700

    Merge tag 'for_v4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull fsnotify updates from Jan Kara:
     "Amir's patches to implement superblock fanotify watches, Xiaoming's
      patch to enable reporting of thread IDs in fanotify events instead of
      TGIDs (sadly the patch got mis-attributed to Amir and I've noticed
      only now), and a fix of possible oops on umount caused by fsnotify
      infrastructure"
    
    * tag 'for_v4.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      fsnotify: Fix busy inodes during unmount
      fs: group frequently accessed fields of struct super_block together
      fanotify: support reporting thread id instead of process id
      fanotify: add BUILD_BUG_ON() to count the bits of fanotify constants
      fsnotify: convert runtime BUG_ON() to BUILD_BUG_ON()
      fanotify: deprecate uapi FAN_ALL_* constants
      fanotify: simplify handling of FAN_ONDIR
      fsnotify: generalize handling of extra event flags
      fanotify: fix collision of internal and uapi mark flags
      fanotify: store fanotify_init() flags in group's fanotify_data
      fanotify: add API to attach/detach super block mark
      fsnotify: send path type events to group with super block marks
      fsnotify: add super block object type

commit dad4f140edaa3f6bb452b6913d41af1ffd672e45
Merge: 69d5b97c5973 3a08cd52c37c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 28 11:35:40 2018 -0700

    Merge branch 'xarray' of git://git.infradead.org/users/willy/linux-dax
    
    Pull XArray conversion from Matthew Wilcox:
     "The XArray provides an improved interface to the radix tree data
      structure, providing locking as part of the API, specifying GFP flags
      at allocation time, eliminating preloading, less re-walking the tree,
      more efficient iterations and not exposing RCU-protected pointers to
      its users.
    
      This patch set
    
       1. Introduces the XArray implementation
    
       2. Converts the pagecache to use it
    
       3. Converts memremap to use it
    
      The page cache is the most complex and important user of the radix
      tree, so converting it was most important. Converting the memremap
      code removes the only other user of the multiorder code, which allows
      us to remove the radix tree code that supported it.
    
      I have 40+ followup patches to convert many other users of the radix
      tree over to the XArray, but I'd like to get this part in first. The
      other conversions haven't been in linux-next and aren't suitable for
      applying yet, but you can see them in the xarray-conv branch if you're
      interested"
    
    * 'xarray' of git://git.infradead.org/users/willy/linux-dax: (90 commits)
      radix tree: Remove multiorder support
      radix tree test: Convert multiorder tests to XArray
      radix tree tests: Convert item_delete_rcu to XArray
      radix tree tests: Convert item_kill_tree to XArray
      radix tree tests: Move item_insert_order
      radix tree test suite: Remove multiorder benchmarking
      radix tree test suite: Remove __item_insert
      memremap: Convert to XArray
      xarray: Add range store functionality
      xarray: Move multiorder_check to in-kernel tests
      xarray: Move multiorder_shrink to kernel tests
      xarray: Move multiorder account test in-kernel
      radix tree test suite: Convert iteration test to XArray
      radix tree test suite: Convert tag_tagged_items to XArray
      radix tree: Remove radix_tree_clear_tags
      radix tree: Remove radix_tree_maybe_preload_order
      radix tree: Remove split/join code
      radix tree: Remove radix_tree_update_node_t
      page cache: Finish XArray conversion
      dax: Convert page fault handlers to XArray
      ...

commit 721fb6fbfd2132164c2e8777cc837f9b2c1794dc
Author: Jan Kara <jack@suse.cz>
Date:   Wed Oct 17 13:07:05 2018 +0200

    fsnotify: Fix busy inodes during unmount
    
    Detaching of mark connector from fsnotify_put_mark() can race with
    unmounting of the filesystem like:
    
      CPU1                          CPU2
    fsnotify_put_mark()
      spin_lock(&conn->lock);
      ...
      inode = fsnotify_detach_connector_from_object(conn)
      spin_unlock(&conn->lock);
                                    generic_shutdown_super()
                                      fsnotify_unmount_inodes()
                                        sees connector detached for inode
                                          -> nothing to do
                                      evict_inode()
                                        barfs on pending inode reference
      iput(inode);
    
    Resulting in "Busy inodes after unmount" message and possible kernel
    oops. Make fsnotify_unmount_inodes() properly wait for outstanding inode
    references from detached connectors.
    
    Note that the accounting of outstanding inode references in the
    superblock can cause some cacheline contention on the counter. OTOH it
    happens only during deletion of the last notification mark from an inode
    (or during unlinking of watched inode) and that is not too bad. I have
    measured time to create & delete inotify watch 100000 times from 64
    processes in parallel (each process having its own inotify group and its
    own file on a shared superblock) on a 64 CPU machine. Average and
    standard deviation of 15 runs look like:
    
            Avg             Stddev
    Vanilla 9.817400        0.276165
    Fixed   9.710467        0.228294
    
    So there's no statistically significant difference.
    
    Fixes: 6b3f05d24d35 ("fsnotify: Detach mark from object list when last reference is dropped")
    CC: stable@vger.kernel.org
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6da94deb957f..00b23b21e78a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1437,6 +1437,9 @@ struct super_block {
 	/* Number of inodes with nlink == 0 but still referenced */
 	atomic_long_t s_remove_count;
 
+	/* Pending fsnotify inode refs */
+	atomic_long_t s_fsnotify_inode_refs;
+
 	/* Being remounted read-only */
 	int s_readonly_remount;
 

commit ff9c745b81ff1e482167fd73558450e66ad43a33
Author: Matthew Wilcox <willy@infradead.org>
Date:   Wed Nov 22 11:41:23 2017 -0500

    mm: Convert page-writeback to XArray
    
    Includes moving mapping_tagged() to fs.h as a static inline, and
    changing it to return bool.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d126cad0f621..e10278e4db66 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -483,15 +483,18 @@ struct block_device {
 	struct mutex		bd_fsfreeze_mutex;
 } __randomize_layout;
 
+/* XArray tags, for tagging dirty and writeback pages in the pagecache. */
+#define PAGECACHE_TAG_DIRTY	XA_MARK_0
+#define PAGECACHE_TAG_WRITEBACK	XA_MARK_1
+#define PAGECACHE_TAG_TOWRITE	XA_MARK_2
+
 /*
- * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
- * radix trees
+ * Returns true if any of the pages in the mapping are marked with the tag.
  */
-#define PAGECACHE_TAG_DIRTY	0
-#define PAGECACHE_TAG_WRITEBACK	1
-#define PAGECACHE_TAG_TOWRITE	2
-
-int mapping_tagged(struct address_space *mapping, int tag);
+static inline bool mapping_tagged(struct address_space *mapping, xa_mark_t tag)
+{
+	return xa_marked(&mapping->i_pages, tag);
+}
 
 static inline void i_mmap_lock_write(struct address_space *mapping)
 {

commit eb797a8ee0ab4cd03df556980ce7bf167cadaa50
Author: Matthew Wilcox <willy@infradead.org>
Date:   Mon Mar 5 22:46:03 2018 -0500

    page cache: Rearrange address_space
    
    Change i_pages from a radix_tree_root to an xarray, convert the
    documentation into kernel-doc format and change the order of the elements
    to pack them better on 64-bit systems.
    
    Signed-off-by: Matthew Wilcox <willy@infradead.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c0b4a1c22ff..d126cad0f621 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -403,24 +403,40 @@ int pagecache_write_end(struct file *, struct address_space *mapping,
 				loff_t pos, unsigned len, unsigned copied,
 				struct page *page, void *fsdata);
 
+/**
+ * struct address_space - Contents of a cacheable, mappable object.
+ * @host: Owner, either the inode or the block_device.
+ * @i_pages: Cached pages.
+ * @gfp_mask: Memory allocation flags to use for allocating pages.
+ * @i_mmap_writable: Number of VM_SHARED mappings.
+ * @i_mmap: Tree of private and shared mappings.
+ * @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable.
+ * @nrpages: Number of page entries, protected by the i_pages lock.
+ * @nrexceptional: Shadow or DAX entries, protected by the i_pages lock.
+ * @writeback_index: Writeback starts here.
+ * @a_ops: Methods.
+ * @flags: Error bits and flags (AS_*).
+ * @wb_err: The most recent error which has occurred.
+ * @private_lock: For use by the owner of the address_space.
+ * @private_list: For use by the owner of the address_space.
+ * @private_data: For use by the owner of the address_space.
+ */
 struct address_space {
-	struct inode		*host;		/* owner: inode, block_device */
-	struct radix_tree_root	i_pages;	/* cached pages */
-	atomic_t		i_mmap_writable;/* count VM_SHARED mappings */
-	struct rb_root_cached	i_mmap;		/* tree of private and shared mappings */
-	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
-	/* Protected by the i_pages lock */
-	unsigned long		nrpages;	/* number of total pages */
-	/* number of shadow or DAX exceptional entries */
+	struct inode		*host;
+	struct xarray		i_pages;
+	gfp_t			gfp_mask;
+	atomic_t		i_mmap_writable;
+	struct rb_root_cached	i_mmap;
+	struct rw_semaphore	i_mmap_rwsem;
+	unsigned long		nrpages;
 	unsigned long		nrexceptional;
-	pgoff_t			writeback_index;/* writeback starts here */
-	const struct address_space_operations *a_ops;	/* methods */
-	unsigned long		flags;		/* error bits */
-	spinlock_t		private_lock;	/* for use by the address_space */
-	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
-	struct list_head	private_list;	/* for use by the address_space */
-	void			*private_data;	/* ditto */
+	pgoff_t			writeback_index;
+	const struct address_space_operations *a_ops;
+	unsigned long		flags;
 	errseq_t		wb_err;
+	spinlock_t		private_lock;
+	struct list_head	private_list;
+	void			*private_data;
 } __attribute__((aligned(sizeof(long)))) __randomize_layout;
 	/*
 	 * On most architectures that alignment is already the case; but

commit 99c228a994ec8b1580c43631866fd2c5440f5bfd
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Oct 18 14:22:55 2018 +0300

    fs: group frequently accessed fields of struct super_block together
    
    Kernel test robot reported [1] a 6% performance regression in a
    concurrent unlink(2) workload on commit 60f7ed8c7c4d ("fsnotify: send
    path type events to group with super block marks").
    
    The performance test was run with no fsnotify marks at all on the
    data set, so the only extra instructions added by the offending
    commit are tests of the super_block fields s_fsnotify_{marks,mask}
    and these tests happen on almost every single inode access.
    
    When adding those fields to the super_block struct, we did not give much
    thought of placing them on a hot cache lines (we just placed them at the
    end of the struct).
    
    Re-organize struct super_block to try and keep some frequently accessed
    fields on the same cache line.
    
    Move the frequently accessed fields s_fsnotify_{marks,mask} near the
    frequently accessed fields s_fs_info,s_time_gran, while filling a 64bit
    alignment hole after s_time_gran.
    
    Move the seldom accessed fields s_id,s_uuid,s_max_links,s_mode near the
    seldom accessed fields s_vfs_rename_mutex,s_subtype.
    
    Rong Chen confirmed that this patch solved the reported problem.
    
    [1] https://lkml.org/lkml/2018/9/30/206
    
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Tested-by: kernel test robot <rong.a.chen@intel.com>
    Fixes: 1e6cb72399 ("fsnotify: add super block object type")
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c14801d0aa3..6da94deb957f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1393,17 +1393,26 @@ struct super_block {
 
 	struct sb_writers	s_writers;
 
+	/*
+	 * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and
+	 * s_fsnotify_marks together for cache efficiency. They are frequently
+	 * accessed and rarely modified.
+	 */
+	void			*s_fs_info;	/* Filesystem private info */
+
+	/* Granularity of c/m/atime in ns (cannot be worse than a second) */
+	u32			s_time_gran;
+#ifdef CONFIG_FSNOTIFY
+	__u32			s_fsnotify_mask;
+	struct fsnotify_mark_connector __rcu	*s_fsnotify_marks;
+#endif
+
 	char			s_id[32];	/* Informational name */
 	uuid_t			s_uuid;		/* UUID */
 
-	void 			*s_fs_info;	/* Filesystem private info */
 	unsigned int		s_max_links;
 	fmode_t			s_mode;
 
-	/* Granularity of c/m/atime in ns.
-	   Cannot be worse than a second */
-	u32		   s_time_gran;
-
 	/*
 	 * The next field is for VFS *only*. No filesystems have any business
 	 * even looking at it. You had been warned.
@@ -1464,11 +1473,6 @@ struct super_block {
 
 	spinlock_t		s_inode_wblist_lock;
 	struct list_head	s_inodes_wb;	/* writeback inodes */
-
-#ifdef CONFIG_FSNOTIFY
-	__u32			s_fsnotify_mask;
-	struct fsnotify_mark_connector __rcu	*s_fsnotify_marks;
-#endif
 } __randomize_layout;
 
 /* Helper functions so that in most cases filesystems will

commit a725356b6659469d182d662f22d770d83d3bc7b5
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Sep 18 16:34:34 2018 +0300

    vfs: swap names of {do,vfs}_clone_file_range()
    
    Commit 031a072a0b8a ("vfs: call vfs_clone_file_range() under freeze
    protection") created a wrapper do_clone_file_range() around
    vfs_clone_file_range() moving the freeze protection to former, so
    overlayfs could call the latter.
    
    The more common vfs practice is to call do_xxx helpers from vfs_xxx
    helpers, where freeze protecction is taken in the vfs_xxx helper, so
    this anomality could be a source of confusion.
    
    It seems that commit 8ede205541ff ("ovl: add reflink/copyfile/dedup
    support") may have fallen a victim to this confusion -
    ovl_clone_file_range() calls the vfs_clone_file_range() helper in the
    hope of getting freeze protection on upper fs, but in fact results in
    overlayfs allowing to bypass upper fs freeze protection.
    
    Swap the names of the two helpers to conform to common vfs practice
    and call the correct helpers from overlayfs and nfsd.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c0b4a1c22ff..897eae8faee1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1828,8 +1828,10 @@ extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 extern int vfs_clone_file_prep_inodes(struct inode *inode_in, loff_t pos_in,
 				      struct inode *inode_out, loff_t pos_out,
 				      u64 *len, bool is_dedupe);
+extern int do_clone_file_range(struct file *file_in, loff_t pos_in,
+			       struct file *file_out, loff_t pos_out, u64 len);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
-		struct file *file_out, loff_t pos_out, u64 len);
+				struct file *file_out, loff_t pos_out, u64 len);
 extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
 					 struct inode *dest, loff_t destoff,
 					 loff_t len, bool *is_same);
@@ -2773,19 +2775,6 @@ static inline void file_end_write(struct file *file)
 	__sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);
 }
 
-static inline int do_clone_file_range(struct file *file_in, loff_t pos_in,
-				      struct file *file_out, loff_t pos_out,
-				      u64 len)
-{
-	int ret;
-
-	file_start_write(file_out);
-	ret = vfs_clone_file_range(file_in, pos_in, file_out, pos_out, len);
-	file_end_write(file_out);
-
-	return ret;
-}
-
 /*
  * get_write_access() gets write permission for a file.
  * put_write_access() releases this write permission.

commit 1e6cb72399fd58b38a1c11055ef18fe01f535cda
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sat Sep 1 10:41:11 2018 +0300

    fsnotify: add super block object type
    
    Add the infrastructure to attach a mark to a super_block struct
    and detach all attached marks when super block is destroyed.
    
    This is going to be used by fanotify backend to setup super block
    marks.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 33322702c910..2c14801d0aa3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1464,6 +1464,11 @@ struct super_block {
 
 	spinlock_t		s_inode_wblist_lock;
 	struct list_head	s_inodes_wb;	/* writeback inodes */
+
+#ifdef CONFIG_FSNOTIFY
+	__u32			s_fsnotify_mask;
+	struct fsnotify_mark_connector __rcu	*s_fsnotify_marks;
+#endif
 } __randomize_layout;
 
 /* Helper functions so that in most cases filesystems will

commit 45cd0faae3715e305bc46e23b34c5ed4d185ceb8
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Mon Aug 27 15:56:02 2018 +0300

    vfs: add the fadvise() file operation
    
    This is going to be used by overlayfs and possibly useful
    for other filesystems.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 33322702c910..6c0b4a1c22ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1763,6 +1763,7 @@ struct file_operations {
 			u64);
 	int (*dedupe_file_range)(struct file *, loff_t, struct file *, loff_t,
 			u64);
+	int (*fadvise)(struct file *, loff_t, loff_t, int);
 } __randomize_layout;
 
 struct inode_operations {
@@ -3459,4 +3460,8 @@ static inline bool dir_relax_shared(struct inode *inode)
 extern bool path_noexec(const struct path *path);
 extern void inode_nohighmem(struct inode *inode);
 
+/* mm/fadvise.c */
+extern int vfs_fadvise(struct file *file, loff_t offset, loff_t len,
+		       int advice);
+
 #endif /* _LINUX_FS_H */

commit 30aba6656f61ed44cba445a3c0d38b296fa9e8f5
Author: Salvatore Mesoraca <s.mesoraca16@gmail.com>
Date:   Thu Aug 23 17:00:35 2018 -0700

    namei: allow restricted O_CREAT of FIFOs and regular files
    
    Disallows open of FIFOs or regular files not owned by the user in world
    writable sticky directories, unless the owner is the same as that of the
    directory or the file is opened without the O_CREAT flag.  The purpose
    is to make data spoofing attacks harder.  This protection can be turned
    on and off separately for FIFOs and regular files via sysctl, just like
    the symlinks/hardlinks protection.  This patch is based on Openwall's
    "HARDEN_FIFO" feature by Solar Designer.
    
    This is a brief list of old vulnerabilities that could have been prevented
    by this feature, some of them even allow for privilege escalation:
    
    CVE-2000-1134
    CVE-2007-3852
    CVE-2008-0525
    CVE-2009-0416
    CVE-2011-4834
    CVE-2015-1838
    CVE-2015-7442
    CVE-2016-7489
    
    This list is not meant to be complete.  It's difficult to track down all
    vulnerabilities of this kind because they were often reported without any
    mention of this particular attack vector.  In fact, before
    hardlinks/symlinks restrictions, fifos/regular files weren't the favorite
    vehicle to exploit them.
    
    [s.mesoraca16@gmail.com: fix bug reported by Dan Carpenter]
      Link: https://lkml.kernel.org/r/20180426081456.GA7060@mwanda
      Link: http://lkml.kernel.org/r/1524829819-11275-1-git-send-email-s.mesoraca16@gmail.com
    [keescook@chromium.org: drop pr_warn_ratelimited() in favor of audit changes in the future]
    [keescook@chromium.org: adjust commit subjet]
    Link: http://lkml.kernel.org/r/20180416175918.GA13494@beast
    Signed-off-by: Salvatore Mesoraca <s.mesoraca16@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Suggested-by: Solar Designer <solar@openwall.com>
    Suggested-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e5710541183b..33322702c910 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -74,6 +74,8 @@ extern struct inodes_stat_t inodes_stat;
 extern int leases_enable, lease_break_time;
 extern int sysctl_protected_symlinks;
 extern int sysctl_protected_hardlinks;
+extern int sysctl_protected_fifos;
+extern int sysctl_protected_regular;
 
 typedef __kernel_rwf_t rwf_t;
 

commit d9a185f8b49678775ef56ecbdbc7b76970302897
Merge: c22fc16d172f 989974c80457
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 21 18:19:09 2018 -0700

    Merge tag 'ovl-update-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This contains two new features:
    
       - Stack file operations: this allows removal of several hacks from
         the VFS, proper interaction of read-only open files with copy-up,
         possibility to implement fs modifying ioctls properly, and others.
    
       - Metadata only copy-up: when file is on lower layer and only
         metadata is modified (except size) then only copy up the metadata
         and continue to use the data from the lower file"
    
    * tag 'ovl-update-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (66 commits)
      ovl: Enable metadata only feature
      ovl: Do not do metacopy only for ioctl modifying file attr
      ovl: Do not do metadata only copy-up for truncate operation
      ovl: add helper to force data copy-up
      ovl: Check redirect on index as well
      ovl: Set redirect on upper inode when it is linked
      ovl: Set redirect on metacopy files upon rename
      ovl: Do not set dentry type ORIGIN for broken hardlinks
      ovl: Add an inode flag OVL_CONST_INO
      ovl: Treat metacopy dentries as type OVL_PATH_MERGE
      ovl: Check redirects for metacopy files
      ovl: Move some dir related ovl_lookup_single() code in else block
      ovl: Do not expose metacopy only dentry from d_real()
      ovl: Open file with data except for the case of fsync
      ovl: Add helper ovl_inode_realdata()
      ovl: Store lower data inode in ovl_inode
      ovl: Fix ovl_getattr() to get number of blocks from lower
      ovl: Add helper ovl_dentry_lowerdata() to get lower data dentry
      ovl: Copy up meta inode data from lowest data inode
      ovl: Modify ovl_lookup() and friends to lookup metacopy dentry
      ...

commit 74c8164e1cdb1eb22f1d49d54e515e81821a8ad0
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Aug 17 15:45:36 2018 -0700

    mpage: mpage_readpages() should submit IO as read-ahead
    
    a_ops->readpages() is only ever used for read-ahead, yet we don't flag
    the IO being submitted as such.  Fix that up.  Any file system that uses
    mpage_readpages() as its ->readpages() implementation will now get this
    right.
    
    Since we're passing in whether the IO is read-ahead or not, we don't
    need to pass in the 'gfp' separately, as it is dependent on the IO being
    read-ahead.  Kill off that member.
    
    Add some documentation notes on ->readpages() being purely for
    read-ahead.
    
    Link: http://lkml.kernel.org/r/20180621010725.17813-3-axboe@kernel.dk
    Signed-off-by: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Chris Mason <clm@fb.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9d319f1f66f6..a9242f336f02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -344,6 +344,10 @@ struct address_space_operations {
 	/* Set a page dirty.  Return true if this dirtied it */
 	int (*set_page_dirty)(struct page *page);
 
+	/*
+	 * Reads in the requested pages. Unlike ->readpage(), this is
+	 * PURELY used for read-ahead!.
+	 */
 	int (*readpages)(struct file *filp, struct address_space *mapping,
 			struct list_head *pages, unsigned nr_pages);
 

commit 4cdfffc8722e99be8d400d8fa1fcd615d078ad43
Author: NeilBrown <neilb@suse.com>
Date:   Fri Aug 17 15:44:37 2018 -0700

    vfs: discard ATTR_ATTR_FLAG
    
    This flag was introduce in 2.1.37pre1 and the only place it was tested
    was removed in 2.1.43pre1.  The flag was never set.
    
    Let's discard it properly.
    
    Link: http://lkml.kernel.org/r/877en0hewz.fsf@notabene.neil.brown.name
    Signed-off-by: NeilBrown <neilb@suse.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ec33fd0423f..9d319f1f66f6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -179,7 +179,6 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define ATTR_ATIME_SET	(1 << 7)
 #define ATTR_MTIME_SET	(1 << 8)
 #define ATTR_FORCE	(1 << 9) /* Not a change, but a change it */
-#define ATTR_ATTR_FLAG	(1 << 10)
 #define ATTR_KILL_SUID	(1 << 11)
 #define ATTR_KILL_SGID	(1 << 12)
 #define ATTR_FILE	(1 << 13)

commit 4591343e3560d51fa37a24cd262192a7b889a6a3
Merge: f2be26989770 7964410fcf13 63a67a926e21
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 21:28:25 2018 -0700

    Merge branches 'work.misc' and 'work.dcache' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Misc cleanups from various folks all over the place
    
      I expected more fs/dcache.c cleanups this cycle, so that went into a
      separate branch. Said cleanups have missed the window, so in the
      hindsight it could've gone into work.misc instead. Decided not to
      cherry-pick, thus the 'work.dcache' branch"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: dcache: Use true and false for boolean values
      fold generic_readlink() into its only caller
      fs: shave 8 bytes off of struct inode
      fs: Add more kernel-doc to the produced documentation
      fs: Fix attr.c kernel-doc
      removed extra extern file_fdatawait_range
    
    * 'work.dcache' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      kill dentry_update_name_case()

commit 0ea97a2d61df729ccce75b00a2fa37d39a508ab6
Merge: a66b4cd1e716 c7b15a8657da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 20:25:58 2018 -0700

    Merge branch 'work.mkdir' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs icache updates from Al Viro:
    
     - NFS mkdir/open_by_handle race fix
    
     - analogous solution for FUSE, replacing the one currently in mainline
    
     - new primitive to be used when discarding halfway set up inodes on
       failed object creation; gives sane warranties re icache lookups not
       returning such doomed by still not freed inodes. A bunch of
       filesystems switched to that animal.
    
     - Miklos' fix for last cycle regression in iget5_locked(); -stable will
       need a slightly different variant, unfortunately.
    
     - misc bits and pieces around things icache-related (in adfs and jfs).
    
    * 'work.mkdir' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      jfs: don't bother with make_bad_inode() in ialloc()
      adfs: don't put inodes into icache
      new helper: inode_fake_hash()
      vfs: don't evict uninitialized inode
      jfs: switch to discard_new_inode()
      ext2: make sure that partially set up inodes won't be returned by ext2_iget()
      udf: switch to discard_new_inode()
      ufs: switch to discard_new_inode()
      btrfs: switch to discard_new_inode()
      new primitive: discard_new_inode()
      kill d_instantiate_no_diralias()
      nfs_instantiate(): prevent multiple aliases for directory inode

commit a66b4cd1e7163adb327838a3c81faaf6a9330d5a
Merge: b16528466786 5f336e722cc9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 19:58:36 2018 -0700

    Merge branch 'work.open3' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs open-related updates from Al Viro:
    
     - "do we need fput() or put_filp()" rules are gone - it's always fput()
       now. We keep track of that state where it belongs - in ->f_mode.
    
     - int *opened mess killed - in finish_open(), in ->atomic_open()
       instances and in fs/namei.c code around do_last()/lookup_open()/atomic_open().
    
     - alloc_file() wrappers with saner calling conventions are introduced
       (alloc_file_clone() and alloc_file_pseudo()); callers converted, with
       much simplification.
    
     - while we are at it, saner calling conventions for path_init() and
       link_path_walk(), simplifying things inside fs/namei.c (both on
       open-related paths and elsewhere).
    
    * 'work.open3' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (40 commits)
      few more cleanups of link_path_walk() callers
      allow link_path_walk() to take ERR_PTR()
      make path_init() unconditionally paired with terminate_walk()
      document alloc_file() changes
      make alloc_file() static
      do_shmat(): grab shp->shm_file earlier, switch to alloc_file_clone()
      new helper: alloc_file_clone()
      create_pipe_files(): switch the first allocation to alloc_file_pseudo()
      anon_inode_getfile(): switch to alloc_file_pseudo()
      hugetlb_file_setup(): switch to alloc_file_pseudo()
      ocxlflash_getfile(): switch to alloc_file_pseudo()
      cxl_getfile(): switch to alloc_file_pseudo()
      ... and switch shmem_file_setup() to alloc_file_pseudo()
      __shmem_file_setup(): reorder allocations
      new wrapper: alloc_file_pseudo()
      kill FILE_{CREATED,OPENED}
      switch atomic_open() and lookup_open() to returning 0 in all success cases
      document ->atomic_open() changes
      ->atomic_open(): return 0 in all success cases
      get rid of 'opened' in path_openat() and the helpers downstream
      ...

commit 5bef915104f32c9d0bb5df6e86a98e31cb524e9a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 29 19:36:57 2018 -0400

    new helper: inode_fake_hash()
    
    open-coded in a quite a few places...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a42600565925..43941e230e2b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -684,6 +684,17 @@ static inline int inode_unhashed(struct inode *inode)
 	return hlist_unhashed(&inode->i_hash);
 }
 
+/*
+ * __mark_inode_dirty expects inodes to be hashed.  Since we don't
+ * want special inodes in the fileset inode space, we make them
+ * appear hashed, but do not put on any lists.  hlist_del()
+ * will work fine and require no locking.
+ */
+static inline void inode_fake_hash(struct inode *inode)
+{
+	hlist_add_fake(&inode->i_hash);
+}
+
 /*
  * inode->i_mutex nesting subclasses for the lock validator:
  *

commit c2b6d621c4ffe9936adf7a55c8b1c769672c306f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 28 15:53:17 2018 -0400

    new primitive: discard_new_inode()
    
            We don't want open-by-handle picking half-set-up in-core
    struct inode from e.g. mkdir() having failed halfway through.
    In other words, we don't want such inodes returned by iget_locked()
    on their way to extinction.  However, we can't just have them
    unhashed - otherwise open-by-handle immediately *after* that would've
    ended up creating a new in-core inode over the on-disk one that
    is in process of being freed right under us.
    
            Solution: new flag (I_CREATING) set by insert_inode_locked() and
    removed by unlock_new_inode() and a new primitive (discard_new_inode())
    to be used by such halfway-through-setup failure exits instead of
    unlock_new_inode() / iput() combinations.  That primitive unlocks new
    inode, but leaves I_CREATING in place.
    
            iget_locked() treats finding an I_CREATING inode as failure
    (-ESTALE, once we sort out the error propagation).
            insert_inode_locked() treats the same as instant -EBUSY.
            ilookup() treats those as icache miss.
    
    [Fix by Dan Carpenter <dan.carpenter@oracle.com> folded in]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5c91108846db..a42600565925 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2016,6 +2016,8 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
  * I_OVL_INUSE		Used by overlayfs to get exclusive ownership on upper
  *			and work dirs among overlayfs mounts.
  *
+ * I_CREATING		New object's inode in the middle of setting up.
+ *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
 #define I_DIRTY_SYNC		(1 << 0)
@@ -2036,7 +2038,8 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 #define __I_DIRTY_TIME_EXPIRED	12
 #define I_DIRTY_TIME_EXPIRED	(1 << __I_DIRTY_TIME_EXPIRED)
 #define I_WB_SWITCH		(1 << 13)
-#define I_OVL_INUSE			(1 << 14)
+#define I_OVL_INUSE		(1 << 14)
+#define I_CREATING		(1 << 15)
 
 #define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)
 #define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)
@@ -2919,6 +2922,7 @@ extern void lockdep_annotate_inode_mutex_key(struct inode *inode);
 static inline void lockdep_annotate_inode_mutex_key(struct inode *inode) { };
 #endif
 extern void unlock_new_inode(struct inode *);
+extern void discard_new_inode(struct inode *);
 extern unsigned int get_next_ino(void);
 extern void evict_inodes(struct super_block *sb);
 

commit 165ea0d1c2286f550efbf14dc3528267af088f08
Merge: f88a333b4431 9ba546c01976
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 22 12:04:51 2018 -0700

    Merge branch 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs fixes from Al Viro:
     "Fix several places that screw up cleanups after failures halfway
      through opening a file (one open-coding filp_clone_open() and getting
      it wrong, two misusing alloc_file()). That part is -stable fodder from
      the 'work.open' branch.
    
      And Christoph's regression fix for uapi breakage in aio series;
      include/uapi/linux/aio_abi.h shouldn't be pulling in the kernel
      definition of sigset_t, the reason for doing so in the first place had
      been bogus - there's no need to expose struct __aio_sigset in
      aio_abi.h at all"
    
    * 'fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      aio: don't expose __aio_sigset in uapi
      ocxlflash_getfile(): fix double-iput() on alloc_file() failures
      cxl_getfile(): fix double-iput() on alloc_file() failures
      drm_mode_create_lease_ioctl(): fix open-coded filp_clone_open()

commit fb16043b46831a75c9b076a7262ae035290b0409
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:44 2018 +0200

    vfs: remove open_flags from d_real()
    
    Opening regular files on overlayfs is now handled via ovl_open().  Remove
    the now unused "open_flags" argument from d_op->d_real() and the d_real()
    helper.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1cbcf37c45e1..1fa63d184d1f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1239,7 +1239,7 @@ static inline struct inode *file_inode(const struct file *f)
 
 static inline struct dentry *file_dentry(const struct file *file)
 {
-	return d_real(file->f_path.dentry, file_inode(file), 0);
+	return d_real(file->f_path.dentry, file_inode(file));
 }
 
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)

commit de2a4a501e716bbf5ff691ba16faf59a35320228
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:43 2018 +0200

    Partially revert "locks: fix file locking on overlayfs"
    
    This partially reverts commit c568d68341be7030f5647def68851e469b21ca11.
    
    Overlayfs files will now automatically get the correct locks, no need to
    hack overlay support in VFS.
    
    It is a partial revert, because it leaves the locks_inode() calls in place
    and defines locks_inode() to file_inode().  We could revert those as well,
    but it would be unnecessary code churn and it makes sense to document that
    we are getting the inode for locking purposes.
    
    Don't revert MS_NOREMOTELOCK yet since that has been part of the userspace
    API for some time (though not in a useful way).  Will try to remove
    internal flags later when the dust around the new mount API settles.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Acked-by: Jeff Layton <jlayton@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 16e2741cec3c..1cbcf37c45e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1054,17 +1054,7 @@ struct file_lock_context {
 
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
-/*
- * Return the inode to use for locking
- *
- * For overlayfs this should be the overlay inode, not the real inode returned
- * by file_inode().  For any other fs file_inode(filp) and locks_inode(filp) are
- * equal.
- */
-static inline struct inode *locks_inode(const struct file *f)
-{
-	return f->f_path.dentry->d_inode;
-}
+#define locks_inode(f) file_inode(f)
 
 #ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, unsigned int, struct flock *);
@@ -1305,7 +1295,6 @@ extern int send_sigurg(struct fown_struct *fown);
 
 /* These sb flags are internal to the kernel */
 #define SB_SUBMOUNT     (1<<26)
-#define SB_NOREMOTELOCK	(1<<27)
 #define SB_NOSEC	(1<<28)
 #define SB_BORN		(1<<29)
 #define SB_ACTIVE	(1<<30)

commit 4ab30319fd7c691a1b3165325c647a5cd6d282ac
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:43 2018 +0200

    Revert "vfs: add flags to d_real()"
    
    This reverts commit 495e642939114478a5237a7d91661ba93b76f15a.
    
    No user of "flags" argument of d_real() remain.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8f8c9ac1c9d5..16e2741cec3c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1249,7 +1249,7 @@ static inline struct inode *file_inode(const struct file *f)
 
 static inline struct dentry *file_dentry(const struct file *file)
 {
-	return d_real(file->f_path.dentry, file_inode(file), 0, 0);
+	return d_real(file->f_path.dentry, file_inode(file), 0);
 }
 
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)

commit c6718543463dbb78486ad259f884cb800df802b5
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:43 2018 +0200

    Revert "vfs: update ovl inode before relatime check"
    
    This reverts commit 598e3c8f72f5b77c84d2cb26cfd936ffb3cfdbaa.
    
    Overlayfs no longer relies on the vfs correct atime handling.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b67209948f1b..8f8c9ac1c9d5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2088,6 +2088,7 @@ enum file_time_flags {
 	S_VERSION = 8,
 };
 
+extern bool atime_needs_update(const struct path *, struct inode *);
 extern void touch_atime(const struct path *);
 static inline void file_accessed(struct file *file)
 {

commit f182536684d876afaf4627c36a16c4e15ea8a2b8
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:40 2018 +0200

    vfs: export vfs_dedupe_file_range_one() to modules
    
    This is needed by the stacked dedupe implementation in overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 019817a083a0..b67209948f1b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1829,6 +1829,10 @@ extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
 					 loff_t len, bool *is_same);
 extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
+extern int vfs_dedupe_file_range_one(struct file *src_file, loff_t src_pos,
+				     struct file *dst_file, loff_t dst_pos,
+				     u64 len);
+
 
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);

commit 9df6702ad0e85901450fe48a7b5f0f8975353eeb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:40 2018 +0200

    vfs: export vfs_ioctl() to modules
    
    This is needed by the stacked ioctl implementation in overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e1884840d556..019817a083a0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1634,6 +1634,8 @@ int vfs_mkobj(struct dentry *, umode_t,
 		int (*f)(struct dentry *, umode_t, void *),
 		void *);
 
+extern long vfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+
 /*
  * VFS file helper functions.
  */

commit d3b1084dfd629ef89bc1c4bab95e5cb87e7d08c2
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:44:40 2018 +0200

    vfs: make open_with_fake_path() not contribute to nr_files
    
    Stacking file operations in overlay will store an extra open file for each
    overlay file opened.
    
    The overhead is just that of "struct file" which is about 256bytes, because
    overlay already pins an extra dentry and inode when the file is open, which
    add up to a much larger overhead.
    
    For fear of breaking working setups, don't start accounting the extra file.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5ce2b413abc6..e1884840d556 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -156,6 +156,9 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File is capable of returning -EAGAIN if I/O will block */
 #define FMODE_NOWAIT	((__force fmode_t)0x8000000)
 
+/* File does not contribute to nr_files count */
+#define FMODE_NOACCOUNT	((__force fmode_t)0x20000000)
+
 /*
  * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
  * that indicates that they should check the contents of the iovec are

commit 51e6ce820bd43e51883eddf291bd830217bb6382
Merge: 9951934d76b0 1b4f42a1e33f
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Jul 18 15:39:29 2018 +0200

    Merge branch 'dedupe-cleanup' into overlayfs-next
    
    Following series for stacking overlay files depends on this mini series.

commit 2abc77af89e17582db9039293c8ac881c8c96d79
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jul 12 11:18:42 2018 -0400

    new helper: open_with_fake_path()
    
    open a file by given inode, faking ->f_path.  Use with shitloads
    of caution - at the very least you'd damn better make sure that
    some dentry alias of that inode is pinned down by the path in
    question.  Again, this is no general-purpose interface and I hope
    it will eventually go away.  Right now overlayfs wants something
    like that, but nothing else should.
    
    Any out-of-tree code with bright idea of using this one *will*
    eventually get hurt, with zero notice and great delight on my part.
    I refuse to use EXPORT_SYMBOL_GPL(), especially in situations when
    it's really EXPORT_SYMBOL_DONT_USE_IT(), but don't take that export
    as "you are welcome to use it".
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 05f34726e29c..4ff7b7012186 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2424,6 +2424,8 @@ extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int, umode_t);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
+extern struct file * open_with_fake_path(const struct path *, int,
+					 struct inode*, const struct cred *);
 static inline struct file *file_clone_open(struct file *file)
 {
 	return dentry_open(&file->f_path, file->f_flags, file->f_cred);

commit dbae8f2ca2f0586f4b80201c78ff0aed2a012ab5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 17:51:47 2018 -0400

    kill FILE_{CREATED,OPENED}
    
    no users left
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c25896b30e9f..bd904c496878 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2436,10 +2436,6 @@ extern struct filename *getname(const char __user *);
 extern struct filename *getname_kernel(const char *);
 extern void putname(struct filename *name);
 
-enum {
-	FILE_CREATED = 1,
-	FILE_OPENED = 2
-};
 extern int finish_open(struct file *file, struct dentry *dentry,
 			int (*open)(struct inode *, struct file *));
 extern int finish_no_open(struct file *file, struct dentry *dentry);

commit 44907d79002466049fdbb8ef15730d185e0808b4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 13:32:02 2018 -0400

    get rid of 'opened' argument of ->atomic_open() - part 3
    
    now it can be done...
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 70be3e4c26ac..c25896b30e9f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1781,7 +1781,7 @@ struct inode_operations {
 	int (*update_time)(struct inode *, struct timespec64 *, int);
 	int (*atomic_open)(struct inode *, struct dentry *,
 			   struct file *, unsigned open_flag,
-			   umode_t create_mode, int *opened);
+			   umode_t create_mode);
 	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 	int (*set_acl)(struct inode *, struct posix_acl *, int);
 } ____cacheline_aligned;

commit be12af3ef5e61ebc44d065e121424ac605d7bb8e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 11:44:56 2018 -0400

    getting rid of 'opened' argument of ->atomic_open() - part 1
    
    'opened' argument of finish_open() is unused.  Kill it.
    
    Signed-off-by Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ca668c7e48a7..70be3e4c26ac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2441,8 +2441,7 @@ enum {
 	FILE_OPENED = 2
 };
 extern int finish_open(struct file *file, struct dentry *dentry,
-			int (*open)(struct inode *, struct file *),
-			int *opened);
+			int (*open)(struct inode *, struct file *));
 extern int finish_no_open(struct file *file, struct dentry *dentry);
 
 /* fs/ioctl.c */

commit 73a09dd94377e4b186b300bd5461920710c7c3d5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 13:22:02 2018 -0400

    introduce FMODE_CREATED and switch to it
    
    Parallel to FILE_CREATED, goes into ->f_mode instead of *opened.
    NFS is a bit of a wart here - it doesn't have file at the point
    where FILE_CREATED used to be set, so we need to propagate it
    there (for now).  IMA is another one (here and everywhere)...
    
    Note that this needs do_dentry_open() to leave old bits in ->f_mode
    alone - we want it to preserve FMODE_CREATED if it had been already
    set (no other bit can be there).
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 05f34726e29c..ca668c7e48a7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -149,6 +149,7 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)
 
 #define FMODE_OPENED		((__force fmode_t)0x80000)
+#define FMODE_CREATED		((__force fmode_t)0x100000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x4000000)

commit f5d11409e61dadf1f9af91b22bbedc28a60a2e2c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 9 02:35:08 2018 -0400

    introduce FMODE_OPENED
    
    basically, "is that instance set up enough for regular fput(), or
    do we want put_filp() for that one".
    
    NOTE: the only alloc_file() caller that could be followed by put_filp()
    is in arch/ia64/kernel/perfmon.c, which is (Kconfig-level) broken.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c4ca4c9c1130..05f34726e29c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -148,6 +148,8 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* Has write method(s) */
 #define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)
 
+#define FMODE_OPENED		((__force fmode_t)0x80000)
+
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x4000000)
 

commit b4e7a7a88b5d060650094b8d3454bc521d669f6a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 11:17:54 2018 -0400

    drm_mode_create_lease_ioctl(): fix open-coded filp_clone_open()
    
    Failure of ->open() should *not* be followed by fput().  Fixed by
    using filp_clone_open(), which gets the cleanups right.
    
    Cc: stable@vger.kernel.org
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5c91108846db..aa9b4c169ed2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2422,6 +2422,7 @@ extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int, umode_t);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
+extern struct file *filp_clone_open(struct file *);
 extern int filp_close(struct file *, fl_owner_t id);
 
 extern struct filename *getname_flags(const char __user *, int, int *);

commit 19f391eb05b8b005f2907ddc8f284487b446abf3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 8 11:19:32 2018 -0400

    turn filp_clone_open() into inline wrapper for dentry_open()
    
    it's exactly the same thing as
            dentry_open(&file->f_path, file->f_flags, file->f_cred)
    
    ... and rename it to file_clone_open(), while we are at it.
    'filp' naming convention is bogus; sure, it's "file pointer",
    but we generally don't do that kind of Hungarian notation.
    Some of the instances have too many callers to touch, but this
    one has only two, so let's sanitize it while we can...
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa9b4c169ed2..c4ca4c9c1130 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2422,7 +2422,10 @@ extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int, umode_t);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
-extern struct file *filp_clone_open(struct file *);
+static inline struct file *file_clone_open(struct file *file)
+{
+	return dentry_open(&file->f_path, file->f_flags, file->f_cred);
+}
 extern int filp_close(struct file *, fl_owner_t id);
 
 extern struct filename *getname_flags(const char __user *, int, int *);

commit 69448867abcb231afaa7891ff9d9fd04b2b94a0d
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Thu Jul 5 09:25:43 2018 +0300

    fs: shave 8 bytes off of struct inode
    
    Here is a link to Linus' reply to Jan's concern about making
    i_blkbibts byte addressable:
    https://marc.info/?l=linux-fsdevel&m=152882624707975&w=2
    
    Here is a link to an lkp.org report about potential performance
    improvement in some workload, which could(?) be related to packing
    i_blkbits closer to i_bytes/i_lock:
    https://marc.info/?l=linux-fsdevel&m=153077048108198&w=2
    
    Changes since v1:
    - Add links to relevant discussions
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f140c11d35dd..9b00676f5d9d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -275,6 +275,7 @@ struct writeback_control;
 
 /*
  * Write life time hint values.
+ * Stored in struct inode as u8.
  */
 enum rw_hint {
 	WRITE_LIFE_NOT_SET	= 0,
@@ -609,8 +610,8 @@ struct inode {
 	struct timespec64	i_ctime;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	unsigned short          i_bytes;
-	unsigned int		i_blkbits;
-	enum rw_hint		i_write_hint;
+	u8			i_blkbits;
+	u8			i_write_hint;
 	blkcnt_t		i_blocks;
 
 #ifdef __NEED_I_SIZE_ORDERED

commit 87eb5eb2423213ac0e7315ce5d275f1ff80e0263
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 6 23:57:03 2018 +0200

    vfs: dedupe: rationalize args
    
    Clean up f_op->dedupe_file_range() interface.
    
    1) Use loff_t for offsets and length instead of u64
    2) Order the arguments the same way as {copy|clone}_file_range().
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b81c4b7e339f..a8fee2f44981 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1749,7 +1749,7 @@ struct file_operations {
 			loff_t, size_t, unsigned int);
 	int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,
 			u64);
-	int (*dedupe_file_range)(struct file *, u64, u64, struct file *,
+	int (*dedupe_file_range)(struct file *, loff_t, struct file *, loff_t,
 			u64);
 } __randomize_layout;
 

commit 5740c99e9d30b81fcc478797e7215c61e241f44e
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 6 23:57:03 2018 +0200

    vfs: dedupe: return int
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5c91108846db..b81c4b7e339f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1749,7 +1749,7 @@ struct file_operations {
 			loff_t, size_t, unsigned int);
 	int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,
 			u64);
-	ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *,
+	int (*dedupe_file_range)(struct file *, u64, u64, struct file *,
 			u64);
 } __randomize_layout;
 

commit a11e1d432b51f63ba698d044441284a661f01144
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 28 09:43:44 2018 -0700

    Revert changes to convert to ->poll_mask() and aio IOCB_CMD_POLL
    
    The poll() changes were not well thought out, and completely
    unexplained.  They also caused a huge performance regression, because
    "->poll()" was no longer a trivial file operation that just called down
    to the underlying file operations, but instead did at least two indirect
    calls.
    
    Indirect calls are sadly slow now with the Spectre mitigation, but the
    performance problem could at least be largely mitigated by changing the
    "->get_poll_head()" operation to just have a per-file-descriptor pointer
    to the poll head instead.  That gets rid of one of the new indirections.
    
    But that doesn't fix the new complexity that is completely unwarranted
    for the regular case.  The (undocumented) reason for the poll() changes
    was some alleged AIO poll race fixing, but we don't make the common case
    slower and more complex for some uncommon special case, so this all
    really needs way more explanations and most likely a fundamental
    redesign.
    
    [ This revert is a revert of about 30 different commits, not reverted
      individually because that would just be unnecessarily messy  - Linus ]
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5c91108846db..d78d146a98da 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1720,8 +1720,6 @@ struct file_operations {
 	int (*iterate) (struct file *, struct dir_context *);
 	int (*iterate_shared) (struct file *, struct dir_context *);
 	__poll_t (*poll) (struct file *, struct poll_table_struct *);
-	struct wait_queue_head * (*get_poll_head)(struct file *, __poll_t);
-	__poll_t (*poll_mask) (struct file *, __poll_t);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);

commit cf85ec88701610f0de2e959ac447d9613462fbc7
Author: Vasily Averin <vvs@virtuozzo.com>
Date:   Sat Jun 9 16:18:16 2018 +0300

    removed extra extern file_fdatawait_range
    
    Jeff added this extern twice in commit a823e4589e68
    
    Fixes: a823e4589e68 ("mm: add file_fdatawait_range and file_write_and_wait")
    Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5c91108846db..f140c11d35dd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2623,8 +2623,6 @@ static inline int filemap_fdatawait(struct address_space *mapping)
 
 extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
 				  loff_t lend);
-extern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,
-						loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);

commit 7a932516f55cdf430c7cce78df2010ff7db6b874
Merge: dc594c39f7a9 e264abeaf9da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 15 07:31:07 2018 +0900

    Merge tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground
    
    Pull inode timestamps conversion to timespec64 from Arnd Bergmann:
     "This is a late set of changes from Deepa Dinamani doing an automated
      treewide conversion of the inode and iattr structures from 'timespec'
      to 'timespec64', to push the conversion from the VFS layer into the
      individual file systems.
    
      As Deepa writes:
    
       'The series aims to switch vfs timestamps to use struct timespec64.
        Currently vfs uses struct timespec, which is not y2038 safe.
    
        The series involves the following:
        1. Add vfs helper functions for supporting struct timepec64
           timestamps.
        2. Cast prints of vfs timestamps to avoid warnings after the switch.
        3. Simplify code using vfs timestamps so that the actual replacement
           becomes easy.
        4. Convert vfs timestamps to use struct timespec64 using a script.
           This is a flag day patch.
    
        Next steps:
        1. Convert APIs that can handle timespec64, instead of converting
           timestamps at the boundaries.
        2. Update internal data structures to avoid timestamp conversions'
    
      Thomas Gleixner adds:
    
       'I think there is no point to drag that out for the next merge
        window. The whole thing needs to be done in one go for the core
        changes which means that you're going to play that catchup game
        forever. Let's get over with it towards the end of the merge window'"
    
    * tag 'vfs-timespec64' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/playground:
      pstore: Remove bogus format string definition
      vfs: change inode times to use struct timespec64
      pstore: Convert internal records to timespec64
      udf: Simplify calls to udf_disk_stamp_to_time
      fs: nfs: get rid of memcpys for inode times
      ceph: make inode time prints to be long long
      lustre: Use long long type to print inode time
      fs: add timespec64_truncate()

commit 4a189982e293e662d719f5dd3ba6eec247d7bbc2
Merge: 4189b863ba32 9a6d9a62e0fd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 8 10:00:20 2018 -0700

    Merge branch 'work.aio' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull aio iopriority support from Al Viro:
     "The rest of aio stuff for this cycle - Adam's aio ioprio series"
    
    * 'work.aio' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: aio ioprio use ioprio_check_cap ret val
      fs: aio ioprio add explicit block layer dependence
      fs: iomap dio set bio prio from kiocb prio
      fs: blkdev set bio prio from kiocb prio
      fs: Add aio iopriority support
      fs: Convert kiocb rw_hint from enum to u16
      block: add ioprio_check_cap function

commit 70f2ae1f002b0ed4b4382210df8e4b6e54079012
Merge: da315f6e0398 01b39dcc9568
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 7 08:53:50 2018 -0700

    Merge tag 'ovl-fixes-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs fixes from Miklos Szeredi:
     "This contains a fix for the vfs_mkdir() issue discovered by Al, as
      well as other fixes and cleanups"
    
    * tag 'ovl-fixes-4.18' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: use inode_insert5() to hash a newly created inode
      ovl: Pass argument to ovl_get_inode() in a structure
      vfs: factor out inode_insert5()
      ovl: clean up copy-up error paths
      ovl: return EIO on internal error
      ovl: make ovl_create_real() cope with vfs_mkdir() safely
      ovl: create helper ovl_create_temp()
      ovl: return dentry from ovl_create_real()
      ovl: struct cattr cleanups
      ovl: strip debug argument from ovl_do_ helpers
      ovl: remove WARN_ON() real inode attributes mismatch
      ovl: Kconfig documentation fixes
      ovl: update documentation for unionmount-testsuite

commit 95582b00838837fc07e042979320caf917ce3fe6
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Tue May 8 19:36:02 2018 -0700

    vfs: change inode times to use struct timespec64
    
    struct timespec is not y2038 safe. Transition vfs to use
    y2038 safe struct timespec64 instead.
    
    The change was made with the help of the following cocinelle
    script. This catches about 80% of the changes.
    All the header file and logic changes are included in the
    first 5 rules. The rest are trivial substitutions.
    I avoid changing any of the function signatures or any other
    filesystem specific data structures to keep the patch simple
    for review.
    
    The script can be a little shorter by combining different cases.
    But, this version was sufficient for my usecase.
    
    virtual patch
    
    @ depends on patch @
    identifier now;
    @@
    - struct timespec
    + struct timespec64
      current_time ( ... )
      {
    - struct timespec now = current_kernel_time();
    + struct timespec64 now = current_kernel_time64();
      ...
    - return timespec_trunc(
    + return timespec64_trunc(
      ... );
      }
    
    @ depends on patch @
    identifier xtime;
    @@
     struct \( iattr \| inode \| kstat \) {
     ...
    -       struct timespec xtime;
    +       struct timespec64 xtime;
     ...
     }
    
    @ depends on patch @
    identifier t;
    @@
     struct inode_operations {
     ...
    int (*update_time) (...,
    -       struct timespec t,
    +       struct timespec64 t,
    ...);
     ...
     }
    
    @ depends on patch @
    identifier t;
    identifier fn_update_time =~ "update_time$";
    @@
     fn_update_time (...,
    - struct timespec *t,
    + struct timespec64 *t,
     ...) { ... }
    
    @ depends on patch @
    identifier t;
    @@
    lease_get_mtime( ... ,
    - struct timespec *t
    + struct timespec64 *t
      ) { ... }
    
    @te depends on patch forall@
    identifier ts;
    local idexpression struct inode *inode_node;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn_update_time =~ "update_time$";
    identifier fn;
    expression e, E3;
    local idexpression struct inode *node1;
    local idexpression struct inode *node2;
    local idexpression struct iattr *attr1;
    local idexpression struct iattr *attr2;
    local idexpression struct iattr attr;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    @@
    (
    (
    - struct timespec ts;
    + struct timespec64 ts;
    |
    - struct timespec ts = current_time(inode_node);
    + struct timespec64 ts = current_time(inode_node);
    )
    
    <+... when != ts
    (
    - timespec_equal(&inode_node->i_xtime, &ts)
    + timespec64_equal(&inode_node->i_xtime, &ts)
    |
    - timespec_equal(&ts, &inode_node->i_xtime)
    + timespec64_equal(&ts, &inode_node->i_xtime)
    |
    - timespec_compare(&inode_node->i_xtime, &ts)
    + timespec64_compare(&inode_node->i_xtime, &ts)
    |
    - timespec_compare(&ts, &inode_node->i_xtime)
    + timespec64_compare(&ts, &inode_node->i_xtime)
    |
    ts = current_time(e)
    |
    fn_update_time(..., &ts,...)
    |
    inode_node->i_xtime = ts
    |
    node1->i_xtime = ts
    |
    ts = inode_node->i_xtime
    |
    <+... attr1->ia_xtime ...+> = ts
    |
    ts = attr1->ia_xtime
    |
    ts.tv_sec
    |
    ts.tv_nsec
    |
    btrfs_set_stack_timespec_sec(..., ts.tv_sec)
    |
    btrfs_set_stack_timespec_nsec(..., ts.tv_nsec)
    |
    - ts = timespec64_to_timespec(
    + ts =
    ...
    -)
    |
    - ts = ktime_to_timespec(
    + ts = ktime_to_timespec64(
    ...)
    |
    - ts = E3
    + ts = timespec_to_timespec64(E3)
    |
    - ktime_get_real_ts(&ts)
    + ktime_get_real_ts64(&ts)
    |
    fn(...,
    - ts
    + timespec64_to_timespec(ts)
    ,...)
    )
    ...+>
    (
    <... when != ts
    - return ts;
    + return timespec64_to_timespec(ts);
    ...>
    )
    |
    - timespec_equal(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_equal(&node1->i_xtime2, &node2->i_xtime2)
    |
    - timespec_equal(&node1->i_xtime1, &attr2->ia_xtime2)
    + timespec64_equal(&node1->i_xtime2, &attr2->ia_xtime2)
    |
    - timespec_compare(&node1->i_xtime1, &node2->i_xtime2)
    + timespec64_compare(&node1->i_xtime1, &node2->i_xtime2)
    |
    node1->i_xtime1 =
    - timespec_trunc(attr1->ia_xtime1,
    + timespec64_trunc(attr1->ia_xtime1,
    ...)
    |
    - attr1->ia_xtime1 = timespec_trunc(attr2->ia_xtime2,
    + attr1->ia_xtime1 =  timespec64_trunc(attr2->ia_xtime2,
    ...)
    |
    - ktime_get_real_ts(&attr1->ia_xtime1)
    + ktime_get_real_ts64(&attr1->ia_xtime1)
    |
    - ktime_get_real_ts(&attr.ia_xtime1)
    + ktime_get_real_ts64(&attr.ia_xtime1)
    )
    
    @ depends on patch @
    struct inode *node;
    struct iattr *attr;
    identifier fn;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    expression e;
    @@
    (
    - fn(node->i_xtime);
    + fn(timespec64_to_timespec(node->i_xtime));
    |
     fn(...,
    - node->i_xtime);
    + timespec64_to_timespec(node->i_xtime));
    |
    - e = fn(attr->ia_xtime);
    + e = fn(timespec64_to_timespec(attr->ia_xtime));
    )
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    identifier i_xtime =~ "^i_[acm]time$";
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier fn;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    )
    ...+>
    }
    
    @ depends on patch forall @
    struct inode *node;
    struct iattr *attr;
    struct kstat *stat;
    identifier ia_xtime =~ "^ia_[acm]time$";
    identifier i_xtime =~ "^i_[acm]time$";
    identifier xtime =~ "^[acm]time$";
    identifier fn, ret;
    @@
    {
    + struct timespec ts;
    <+...
    (
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(node->i_xtime);
    ret = fn (...,
    - &node->i_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime,
    + &ts,
    ...);
    |
    + ts = timespec64_to_timespec(attr->ia_xtime);
    ret = fn (...,
    - &attr->ia_xtime);
    + &ts);
    |
    + ts = timespec64_to_timespec(stat->xtime);
    ret = fn (...,
    - &stat->xtime);
    + &ts);
    )
    ...+>
    }
    
    @ depends on patch @
    struct inode *node;
    struct inode *node2;
    identifier i_xtime1 =~ "^i_[acm]time$";
    identifier i_xtime2 =~ "^i_[acm]time$";
    identifier i_xtime3 =~ "^i_[acm]time$";
    struct iattr *attrp;
    struct iattr *attrp2;
    struct iattr attr ;
    identifier ia_xtime1 =~ "^ia_[acm]time$";
    identifier ia_xtime2 =~ "^ia_[acm]time$";
    struct kstat *stat;
    struct kstat stat1;
    struct timespec64 ts;
    identifier xtime =~ "^[acmb]time$";
    expression e;
    @@
    (
    ( node->i_xtime2 \| attrp->ia_xtime2 \| attr.ia_xtime2 \) = node->i_xtime1  ;
    |
     node->i_xtime2 = \( node2->i_xtime1 \| timespec64_trunc(...) \);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     node->i_xtime1 = node->i_xtime3 = \(ts \| current_time(...) \);
    |
     stat->xtime = node2->i_xtime1;
    |
     stat1.xtime = node2->i_xtime1;
    |
    ( node->i_xtime2 \| attrp->ia_xtime2 \) = attrp->ia_xtime1  ;
    |
    ( attrp->ia_xtime1 \| attr.ia_xtime1 \) = attrp2->ia_xtime2;
    |
    - e = node->i_xtime1;
    + e = timespec64_to_timespec( node->i_xtime1 );
    |
    - e = attrp->ia_xtime1;
    + e = timespec64_to_timespec( attrp->ia_xtime1 );
    |
    node->i_xtime1 = current_time(...);
    |
     node->i_xtime2 = node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
     node->i_xtime1 = node->i_xtime3 =
    - e;
    + timespec_to_timespec64(e);
    |
    - node->i_xtime1 = e;
    + node->i_xtime1 = timespec_to_timespec64(e);
    )
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: <anton@tuxera.com>
    Cc: <balbi@kernel.org>
    Cc: <bfields@fieldses.org>
    Cc: <darrick.wong@oracle.com>
    Cc: <dhowells@redhat.com>
    Cc: <dsterba@suse.com>
    Cc: <dwmw2@infradead.org>
    Cc: <hch@lst.de>
    Cc: <hirofumi@mail.parknet.co.jp>
    Cc: <hubcap@omnibond.com>
    Cc: <jack@suse.com>
    Cc: <jaegeuk@kernel.org>
    Cc: <jaharkes@cs.cmu.edu>
    Cc: <jslaby@suse.com>
    Cc: <keescook@chromium.org>
    Cc: <mark@fasheh.com>
    Cc: <miklos@szeredi.hu>
    Cc: <nico@linaro.org>
    Cc: <reiserfs-devel@vger.kernel.org>
    Cc: <richard@nod.at>
    Cc: <sage@redhat.com>
    Cc: <sfrench@samba.org>
    Cc: <swhiteho@redhat.com>
    Cc: <tj@kernel.org>
    Cc: <trond.myklebust@primarydata.com>
    Cc: <tytso@mit.edu>
    Cc: <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7f6997e0dabf..f15329aa9cad 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -206,9 +206,9 @@ struct iattr {
 	kuid_t		ia_uid;
 	kgid_t		ia_gid;
 	loff_t		ia_size;
-	struct timespec	ia_atime;
-	struct timespec	ia_mtime;
-	struct timespec	ia_ctime;
+	struct timespec64 ia_atime;
+	struct timespec64 ia_mtime;
+	struct timespec64 ia_ctime;
 
 	/*
 	 * Not an attribute, but an auxiliary info for filesystems wanting to
@@ -602,9 +602,9 @@ struct inode {
 	};
 	dev_t			i_rdev;
 	loff_t			i_size;
-	struct timespec		i_atime;
-	struct timespec		i_mtime;
-	struct timespec		i_ctime;
+	struct timespec64	i_atime;
+	struct timespec64	i_mtime;
+	struct timespec64	i_ctime;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	unsigned short          i_bytes;
 	unsigned int		i_blkbits;
@@ -1091,7 +1091,7 @@ extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
-extern void lease_get_mtime(struct inode *, struct timespec *time);
+extern void lease_get_mtime(struct inode *, struct timespec64 *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
 extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
 extern int lease_modify(struct file_lock *, int, struct list_head *);
@@ -1206,7 +1206,8 @@ static inline int __break_lease(struct inode *inode, unsigned int mode, unsigned
 	return 0;
 }
 
-static inline void lease_get_mtime(struct inode *inode, struct timespec *time)
+static inline void lease_get_mtime(struct inode *inode,
+				   struct timespec64 *time)
 {
 	return;
 }
@@ -1477,7 +1478,7 @@ static inline void i_gid_write(struct inode *inode, gid_t gid)
 }
 
 extern struct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran);
-extern struct timespec current_time(struct inode *inode);
+extern struct timespec64 current_time(struct inode *inode);
 
 /*
  * Snapshotting support.
@@ -1765,7 +1766,7 @@ struct inode_operations {
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
-	int (*update_time)(struct inode *, struct timespec *, int);
+	int (*update_time)(struct inode *, struct timespec64 *, int);
 	int (*atomic_open)(struct inode *, struct dentry *,
 			   struct file *, unsigned open_flag,
 			   umode_t create_mode, int *opened);
@@ -2199,7 +2200,7 @@ extern int current_umask(void);
 
 extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
-extern int generic_update_time(struct inode *, struct timespec *, int);
+extern int generic_update_time(struct inode *, struct timespec64 *, int);
 
 /* /sys/fs */
 extern struct kobject *fs_kobj;

commit fd59ccc53062964007beda8787ffd9cd93968d63
Merge: 6567af78acd1 e1cc40e5d42a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 15:15:32 2018 -0700

    Merge tag 'fscrypt_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/fscrypt
    
    Pull fscrypt updates from Ted Ts'o:
     "Add bunch of cleanups, and add support for the Speck128/256
      algorithms.
    
      Yes, Speck is contrversial, but the intention is to use them only for
      the lowest end Android devices, where the alternative *really* is no
      encryption at all for data stored at rest"
    
    * tag 'fscrypt_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/fscrypt:
      fscrypt: log the crypto algorithm implementations
      fscrypt: add Speck128/256 support
      fscrypt: only derive the needed portion of the key
      fscrypt: separate key lookup from key derivation
      fscrypt: use a common logging function
      fscrypt: remove internal key size constants
      fscrypt: remove unnecessary check for non-logon key type
      fscrypt: make fscrypt_operations.max_namelen an integer
      fscrypt: drop empty name check from fname_decrypt()
      fscrypt: drop max_namelen check from fname_decrypt()
      fscrypt: don't special-case EOPNOTSUPP from fscrypt_get_encryption_info()
      fscrypt: don't clear flags on crypto transform
      fscrypt: remove stale comment from fscrypt_d_revalidate()
      fscrypt: remove error messages for skcipher_request_alloc() failure
      fscrypt: remove unnecessary NULL check when allocating skcipher
      fscrypt: clean up after fscrypt_prepare_lookup() conversions
      fs, fscrypt: only define ->s_cop when FS_ENCRYPTION is enabled
      fscrypt: use unbound workqueue for decryption

commit 1434763ca5b300ad3b880954bd32dc339d16a833
Merge: 5037be168f0e 4f2f76f75143
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 12:49:17 2018 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "A lot of cleanups and bug fixes, especially dealing with corrupted
      file systems"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (23 commits)
      ext4: fix fencepost error in check for inode count overflow during resize
      ext4: correctly handle a zero-length xattr with a non-zero e_value_offs
      ext4: bubble errors from ext4_find_inline_data_nolock() up to ext4_iget()
      ext4: do not allow external inodes for inline data
      ext4: report delalloc reserve as non-free in statfs for project quota
      ext4: remove NULL check before calling kmem_cache_destroy()
      jbd2: remove NULL check before calling kmem_cache_destroy()
      jbd2: remove bunch of empty lines with jbd2 debug
      ext4: handle errors on ext4_commit_super
      ext4: do not update s_last_mounted of a frozen fs
      ext4: factor out helper ext4_sample_last_mounted()
      vfs: add the sb_start_intwrite_trylock() helper
      ext4: update mtime in ext4_punch_hole even if no blocks are released
      ext4: add verifier check for symlink with append/immutable flags
      fs: ext4: add new return type vm_fault_t
      ext4: fix hole length detection in ext4_ind_map_blocks()
      ext4: mark block bitmap corrupted when found
      ext4: mark inode bitmap corrupted when found
      ext4: add new ext4_mark_group_bitmap_corrupted() helper
      ext4: fix wrong return value in ext4_read_inode_bitmap()
      ...

commit 408afb8d7847faea115508ba154346e33edfc7d5
Merge: b058efc1acfd 1da92779e2e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 4 13:57:43 2018 -0700

    Merge branch 'work.aio-1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull aio updates from Al Viro:
     "Majority of AIO stuff this cycle. aio-fsync and aio-poll, mostly.
    
      The only thing I'm holding back for a day or so is Adam's aio ioprio -
      his last-minute fixup is trivial (missing stub in !CONFIG_BLOCK case),
      but let it sit in -next for decency sake..."
    
    * 'work.aio-1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (46 commits)
      aio: sanitize the limit checking in io_submit(2)
      aio: fold do_io_submit() into callers
      aio: shift copyin of iocb into io_submit_one()
      aio_read_events_ring(): make a bit more readable
      aio: all callers of aio_{read,write,fsync,poll} treat 0 and -EIOCBQUEUED the same way
      aio: take list removal to (some) callers of aio_complete()
      aio: add missing break for the IOCB_CMD_FDSYNC case
      random: convert to ->poll_mask
      timerfd: convert to ->poll_mask
      eventfd: switch to ->poll_mask
      pipe: convert to ->poll_mask
      crypto: af_alg: convert to ->poll_mask
      net/rxrpc: convert to ->poll_mask
      net/iucv: convert to ->poll_mask
      net/phonet: convert to ->poll_mask
      net/nfc: convert to ->poll_mask
      net/caif: convert to ->poll_mask
      net/bluetooth: convert to ->poll_mask
      net/sctp: convert to ->poll_mask
      net/tipc: convert to ->poll_mask
      ...

commit 9214407d1237a985894894f9be2b1a7416b69d14
Merge: eeee3149aaa0 7a107c0f55a3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 4 13:05:02 2018 -0700

    Merge tag 'locks-v4.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux
    
    Pull fasync fix from Jeff Layton:
     "Just a single fix for a deadlock in the fasync handling code that
      Kirill observed while testing.
    
      The fix is to change the fa_lock to be rwlock_t, and use a read lock
      in kill_fasync_rcu"
    
    * tag 'locks-v4.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux:
      fasync: Fix deadlock between task-context and interrupt-context kill_fasync()

commit f956d08a56732c61a4d44e8034eeeedfc06fe721
Merge: cf626b0da78d eb915375757c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 4 10:14:28 2018 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Misc bits and pieces not fitting into anything more specific"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: delete unnecessary assignment in vfs_listxattr
      Documentation: filesystems: update filesystem locking documentation
      vfs: namei: use path_equal() in follow_dotdot()
      fs.h: fix outdated comment about file flags
      __inode_security_revalidate() never gets NULL opt_dentry
      make xattr_getsecurity() static
      vfat: simplify checks in vfat_lookup()
      get rid of dead code in d_find_alias()
      it's SB_BORN, not MS_BORN...
      msdos_rmdir(): kill BS comment
      remove rpc_rmdir()
      fs: avoid fdput() after failed fdget() in vfs_dedupe_file_range()

commit d9a08a9e616beeccdbd0e7262b7225ffdfa49e92
Author: Adam Manzanares <adam.manzanares@wdc.com>
Date:   Tue May 22 10:52:19 2018 -0700

    fs: Add aio iopriority support
    
    This is the per-I/O equivalent of the ioprio_set system call.
    
    When IOCB_FLAG_IOPRIO is set on the iocb aio_flags field, then we set the
    newly added kiocb ki_ioprio field to the value in the iocb aio_reqprio field.
    
    This patch depends on block: add ioprio_check_cap function.
    
    Signed-off-by: Adam Manzanares <adam.manzanares@wdc.com>
    Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b432fc3feb93..eef9334b26d1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -36,6 +36,7 @@
 #include <linux/delayed_call.h>
 #include <linux/uuid.h>
 #include <linux/errseq.h>
+#include <linux/ioprio.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -300,6 +301,7 @@ struct kiocb {
 	void			*private;
 	int			ki_flags;
 	u16			ki_hint;
+	u16			ki_ioprio; /* See linux/ioprio.h */
 } __randomize_layout;
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
@@ -1944,6 +1946,7 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 		.ki_filp = filp,
 		.ki_flags = iocb_flags(filp),
 		.ki_hint = ki_hint_validate(file_write_hint(filp)),
+		.ki_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, 0),
 	};
 }
 

commit fc28724d67c90ff48b976e0687caf79993160bed
Author: Adam Manzanares <adam.manzanares@wdc.com>
Date:   Tue May 22 10:52:18 2018 -0700

    fs: Convert kiocb rw_hint from enum to u16
    
    In order to avoid kiocb bloat for per command iopriority support, rw_hint
    is converted from enum to a u16. Added a guard around ki_hint assignment.
    
    Signed-off-by: Adam Manzanares <adam.manzanares@wdc.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b6045ebb2f2..b432fc3feb93 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -299,7 +299,7 @@ struct kiocb {
 	void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 	void			*private;
 	int			ki_flags;
-	enum rw_hint		ki_hint;
+	u16			ki_hint;
 } __randomize_layout;
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
@@ -1929,12 +1929,21 @@ static inline enum rw_hint file_write_hint(struct file *file)
 
 static inline int iocb_flags(struct file *file);
 
+static inline u16 ki_hint_validate(enum rw_hint hint)
+{
+	typeof(((struct kiocb *)0)->ki_hint) max_hint = -1;
+
+	if (hint <= max_hint)
+		return hint;
+	return 0;
+}
+
 static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 {
 	*kiocb = (struct kiocb) {
 		.ki_filp = filp,
 		.ki_flags = iocb_flags(filp),
-		.ki_hint = file_write_hint(filp),
+		.ki_hint = ki_hint_validate(file_write_hint(filp)),
 	};
 }
 

commit 80ea09a002bf4384fda5f087b1b198b3a274f9da
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu May 17 10:53:05 2018 +0200

    vfs: factor out inode_insert5()
    
    Split out common helper for race free insertion of an already allocated
    inode into the cache.  Use this from iget5_locked() and
    insert_inode_locked4().  Make iget5_locked() use new_inode()/iput() instead
    of alloc_inode()/destroy_inode() directly.
    
    Also export to modules for use by filesystems which want to preallocate an
    inode before file/directory creation.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..4f637a9b213d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2879,6 +2879,10 @@ extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
 		int (*test)(struct inode *, void *), void *data);
 extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
 
+extern struct inode *inode_insert5(struct inode *inode, unsigned long hashval,
+		int (*test)(struct inode *, void *),
+		int (*set)(struct inode *, void *),
+		void *data);
 extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
 extern struct inode * iget_locked(struct super_block *, unsigned long);
 extern struct inode *find_inode_nowait(struct super_block *,

commit 5afb78356cead66db2203061fed6fc8957527ed4
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 29 16:42:59 2018 +0200

    block: don't print a message when the device went away
    
    The information about a size change in this case just creates confusion.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..d8d4831af9ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2570,7 +2570,7 @@ extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
 extern void check_disk_size_change(struct gendisk *disk,
-				   struct block_device *bdev);
+		struct block_device *bdev, bool verbose);
 extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *, bool);

commit 3deb642f0de4c14f37437dd247f9c77839f043f8
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 9 15:29:24 2018 +0100

    fs: introduce new ->get_poll_head and ->poll_mask methods
    
    ->get_poll_head returns the waitqueue that the poll operation is going
    to sleep on.  Note that this means we can only use a single waitqueue
    for the poll, unlike some current drivers that use two waitqueues for
    different events.  But now that we have keyed wakeups and heavily use
    those for poll there aren't that many good reason left to keep the
    multiple waitqueues, and if there are any ->poll is still around, the
    driver just won't support aio poll.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..4b6045ebb2f2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1711,6 +1711,8 @@ struct file_operations {
 	int (*iterate) (struct file *, struct dir_context *);
 	int (*iterate_shared) (struct file *, struct dir_context *);
 	__poll_t (*poll) (struct file *, struct poll_table_struct *);
+	struct wait_queue_head * (*get_poll_head)(struct file *, __poll_t);
+	__poll_t (*poll_mask) (struct file *, __poll_t);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);

commit 8efd6894ff089adeeac7cb9f32125b85d963d1bc
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Sun Apr 22 20:18:46 2018 -0700

    fs: add timespec64_truncate()
    
    As vfs moves to using struct timespec64 to represent times,
    update the argument to timespec_truncate() to use
    struct timespec64. Also change the name of the function.
    The rest of the implementation logic is the same.
    
    Move this to fs/inode.c instead of kernel/time/time.c as all the
    users of this api are filesystems.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Cc: <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..7f6997e0dabf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1476,6 +1476,7 @@ static inline void i_gid_write(struct inode *inode, gid_t gid)
 	inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
 }
 
+extern struct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran);
 extern struct timespec current_time(struct inode *inode);
 
 /*

commit bbbc3fb663947764d338c305087322a646298894
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Apr 30 15:51:35 2018 -0700

    fs, fscrypt: only define ->s_cop when FS_ENCRYPTION is enabled
    
    Now that filesystems only set and use their fscrypt_operations when they
    are built with encryption support, we can remove ->s_cop from
    'struct super_block' when FS_ENCRYPTION is disabled.  This saves a few
    bytes on some kernels and also makes it consistent with ->i_crypt_info.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..8e2460694c3a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1364,9 +1364,9 @@ struct super_block {
 	void                    *s_security;
 #endif
 	const struct xattr_handler **s_xattr;
-
+#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
 	const struct fscrypt_operations	*s_cop;
-
+#endif
 	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	struct block_device	*s_bdev;

commit 75abe32946604887a3fa600eb0956e9946d4170c
Author: Li Qiang <liq3ea@gmail.com>
Date:   Thu May 17 19:01:03 2018 -0700

    fs.h: fix outdated comment about file flags
    
    The __dentry_open function was removed in
    commit <2a027e7a18738>("fold __dentry_open() into its sole caller").
    
    Signed-off-by: Li Qiang <liq3ea@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..7f07977bdfd7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -94,7 +94,7 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 
 /*
  * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
- * to O_WRONLY and O_RDWR via the strange trick in __dentry_open()
+ * to O_WRONLY and O_RDWR via the strange trick in do_dentry_open()
  */
 
 /* file is open for reading */

commit 0c8e3fe35db9b66ae0030849545030ec7c0fc45c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Sun May 13 22:40:30 2018 -0400

    vfs: add the sb_start_intwrite_trylock() helper
    
    Needed by ext4 to test frozen fs before updating s_last_mounted.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..cac41f1bad05 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1597,6 +1597,11 @@ static inline void sb_start_intwrite(struct super_block *sb)
 	__sb_start_write(sb, SB_FREEZE_FS, true);
 }
 
+static inline int sb_start_intwrite_trylock(struct super_block *sb)
+{
+	return __sb_start_write(sb, SB_FREEZE_FS, false);
+}
+
 
 extern bool inode_owner_or_capable(const struct inode *inode);
 

commit 7a107c0f55a3b4c6f84a4323df5610360bde1684
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Thu Apr 5 14:58:06 2018 +0300

    fasync: Fix deadlock between task-context and interrupt-context kill_fasync()
    
    I observed the following deadlock between them:
    
    [task 1]                          [task 2]                         [task 3]
    kill_fasync()                     mm_update_next_owner()           copy_process()
     spin_lock_irqsave(&fa->fa_lock)   read_lock(&tasklist_lock)        write_lock_irq(&tasklist_lock)
      send_sigio()                    <IRQ>                             ...
       read_lock(&fown->lock)         kill_fasync()                     ...
        read_lock(&tasklist_lock)      spin_lock_irqsave(&fa->fa_lock)  ...
    
    Task 1 can't acquire read locked tasklist_lock, since there is
    already task 3 expressed its wish to take the lock exclusive.
    Task 2 holds the read locked lock, but it can't take the spin lock.
    
    Also, there is possible another deadlock (which I haven't observed):
    
    [task 1]                            [task 2]
    f_getown()                          kill_fasync()
     read_lock(&f_own->lock)             spin_lock_irqsave(&fa->fa_lock,)
     <IRQ>                               send_sigio()                     write_lock_irq(&f_own->lock)
      kill_fasync()                       read_lock(&fown->lock)
       spin_lock_irqsave(&fa->fa_lock,)
    
    Actually, we do not need exclusive fa->fa_lock in kill_fasync_rcu(),
    as it guarantees fa->fa_file->f_owner integrity only. It may seem,
    that it used to give a task a small possibility to receive two sequential
    signals, if there are two parallel kill_fasync() callers, and task
    handles the first signal fastly, but the behaviour won't become
    different, since there is exclusive sighand lock in do_send_sig_info().
    
    The patch converts fa_lock into rwlock_t, and this fixes two above
    deadlocks, as rwlock is allowed to be taken from interrupt handler
    by qrwlock design.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 760d8da1b6c7..d6c24b68a092 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1250,7 +1250,7 @@ static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
 }
 
 struct fasync_struct {
-	spinlock_t		fa_lock;
+	rwlock_t		fa_lock;
 	int			magic;
 	int			fa_fd;
 	struct fasync_struct	*fa_next; /* singly linked list */

commit 7214dd4ea9048d2031e14fc552980cecd6573a9e
Merge: 19e8a2f875a5 08fdc8a0138a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 12 12:28:32 2018 -0700

    Merge branch 'work.thaw' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs thaw updates from Al Viro:
     "An ancient series that has fallen through the cracks in the previous
      cycle"
    
    * 'work.thaw' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      buffer.c: call thaw_super during emergency thaw
      vfs: factor sb iteration out of do_emergency_remount

commit 19e8a2f875a56009c0ce30389964aca452a85510
Merge: 5d1365940a68 5a8132761609
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 12 11:59:06 2018 -0700

    Merge branch 'afs-dh' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull AFS updates from Al Viro:
     "The AFS series posted by dhowells depended upon lookup_one_len()
      rework; now that prereq is in the mainline, that series had been
      rebased on top of it and got some exposure and testing..."
    
    * 'afs-dh' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      afs: Do better accretion of small writes on newly created content
      afs: Add stats for data transfer operations
      afs: Trace protocol errors
      afs: Locally edit directory data for mkdir/create/unlink/...
      afs: Adjust the directory XDR structures
      afs: Split the directory content defs into a header
      afs: Fix directory handling
      afs: Split the dynroot stuff out and give it its own ops tables
      afs: Keep track of invalid-before version for dentry coherency
      afs: Rearrange status mapping
      afs: Make it possible to get the data version in readpage
      afs: Init inode before accessing cache
      afs: Introduce a statistics proc file
      afs: Dump bad status record
      afs: Implement @cell substitution handling
      afs: Implement @sys substitution handling
      afs: Prospectively look up extra files when doing a single lookup
      afs: Don't over-increment the cell usage count when pinning it
      afs: Fix checker warnings
      vfs: Remove the const from dir_context::actor

commit b93b016313b3ba8003c3b8bb71f569af91f19fc7
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Tue Apr 10 16:36:56 2018 -0700

    page cache: use xa_lock
    
    Remove the address_space ->tree_lock and use the xa_lock newly added to
    the radix_tree_root.  Rename the address_space ->page_tree to ->i_pages,
    since we don't really care that it's a tree.
    
    [willy@infradead.org: fix nds32, fs/dax.c]
      Link: http://lkml.kernel.org/r/20180406145415.GB20605@bombadil.infradead.orgLink: http://lkml.kernel.org/r/20180313132639.17387-9-willy@infradead.org
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Cc: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Cc: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2aa02cad94d4..92efaf1f8977 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -13,6 +13,7 @@
 #include <linux/list_lru.h>
 #include <linux/llist.h>
 #include <linux/radix-tree.h>
+#include <linux/xarray.h>
 #include <linux/rbtree.h>
 #include <linux/init.h>
 #include <linux/pid.h>
@@ -390,12 +391,11 @@ int pagecache_write_end(struct file *, struct address_space *mapping,
 
 struct address_space {
 	struct inode		*host;		/* owner: inode, block_device */
-	struct radix_tree_root	page_tree;	/* radix tree of all pages */
-	spinlock_t		tree_lock;	/* and lock protecting it */
+	struct radix_tree_root	i_pages;	/* cached pages */
 	atomic_t		i_mmap_writable;/* count VM_SHARED mappings */
 	struct rb_root_cached	i_mmap;		/* tree of private and shared mappings */
 	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
-	/* Protected by tree_lock together with the radix tree */
+	/* Protected by the i_pages lock */
 	unsigned long		nrpages;	/* number of total pages */
 	/* number of shadow or DAX exceptional entries */
 	unsigned long		nrexceptional;
@@ -1989,7 +1989,7 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
  *
  * I_WB_SWITCH		Cgroup bdi_writeback switching in progress.  Used to
  *			synchronize competing switching instances and to tell
- *			wb stat updates to grab mapping->tree_lock.  See
+ *			wb stat updates to grab the i_pages lock.  See
  *			inode_switch_wb_work_fn() for details.
  *
  * I_OVL_INUSE		Used by overlayfs to get exclusive ownership on upper

commit 9f3a0941fb5efaa4d27911e251dc595034d58baa
Merge: fbe173e3ffbd e13e75b86ef2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 10 10:25:57 2018 -0700

    Merge tag 'libnvdimm-for-4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "This cycle was was not something I ever want to repeat as there were
      several late changes that have only now just settled.
    
      Half of the branch up to commit d2c997c0f145 ("fs, dax: use
      page->mapping to warn...") have been in -next for several releases.
      The of_pmem driver and the address range scrub rework were late
      arrivals, and the dax work was scaled back at the last moment.
    
      The of_pmem driver missed a previous merge window due to an oversight.
      A sense of obligation to rectify that miss is why it is included for
      4.17. It has acks from PowerPC folks. Stephen reported a build failure
      that only occurs when merging it with your latest tree, for now I have
      fixed that up by disabling modular builds of of_pmem. A test merge
      with your tree has received a build success report from the 0day robot
      over 156 configs.
    
      An initial version of the ARS rework was submitted before the merge
      window. It is self contained to libnvdimm, a net code reduction, and
      passing all unit tests.
    
      The filesystem-dax changes are based on the wait_var_event()
      functionality from tip/sched/core. However, late review feedback
      showed that those changes regressed truncate performance to a large
      degree. The branch was rewound to drop the truncate behavior change
      and now only includes preparation patches and cleanups (with full acks
      and reviews). The finalization of this dax-dma-vs-trnucate work will
      need to wait for 4.18.
    
      Summary:
    
       - A rework of the filesytem-dax implementation provides for detection
         of unmap operations (truncate / hole punch) colliding with
         in-progress device-DMA. A fix for these collisions remains a
         work-in-progress pending resolution of truncate latency and
         starvation regressions.
    
       - The of_pmem driver expands the users of libnvdimm outside of x86
         and ACPI to describe an implementation of persistent memory on
         PowerPC with Open Firmware / Device tree.
    
       - Address Range Scrub (ARS) handling is completely rewritten to
         account for the fact that ARS may run for 100s of seconds and there
         is no platform defined way to cancel it. ARS will now no longer
         block namespace initialization.
    
       - The NVDIMM Namespace Label implementation is updated to handle
         label areas as small as 1K, down from 128K.
    
       - Miscellaneous cleanups and updates to unit test infrastructure"
    
    * tag 'libnvdimm-for-4.17' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (39 commits)
      libnvdimm, of_pmem: workaround OF_NUMA=n build error
      nfit, address-range-scrub: add module option to skip initial ars
      nfit, address-range-scrub: rework and simplify ARS state machine
      nfit, address-range-scrub: determine one platform max_ars value
      powerpc/powernv: Create platform devs for nvdimm buses
      doc/devicetree: Persistent memory region bindings
      libnvdimm: Add device-tree based driver
      libnvdimm: Add of_node to region and bus descriptors
      libnvdimm, region: quiet region probe
      libnvdimm, namespace: use a safe lookup for dimm device name
      libnvdimm, dimm: fix dpa reservation vs uninitialized label area
      libnvdimm, testing: update the default smart ctrl_temperature
      libnvdimm, testing: Add emulation for smart injection commands
      nfit, address-range-scrub: introduce nfit_spa->ars_state
      libnvdimm: add an api to cast a 'struct nd_region' to its 'struct device'
      nfit, address-range-scrub: fix scrub in-progress reporting
      dax, dm: allow device-mapper to operate without dax support
      dax: introduce CONFIG_DAX_DRIVER
      fs, dax: use page->mapping to warn if truncate collides with a busy page
      ext2, dax: introduce ext2_dax_aops
      ...

commit a09acf4b43b90581bf53b0c03cc84ed693bf27e2
Author: David Howells <dhowells@redhat.com>
Date:   Mon Apr 9 21:12:30 2018 +0100

    vfs: Remove the const from dir_context::actor
    
    Remove the const marking from the actor function pointer in the dir_context
    struct.  The const prevents the structure from being used as part of a
    kmalloc'd object as it makes the compiler require that the actor member be
    set at object initialisation time (or not at all), incuring something like
    the following error if you try and set it later:
    
            fs/afs/dir.c:556:20: error: assignment of read-only member 'actor'
    
    Marking the member const like this adds very little in the way of sanity
    checking as the type checking system is likely to provide sufficient - and
    if not, the kernel is very likely to oops repeatably in this case.
    
    Fixes: ac6614b76478 ("[readdir] constify ->actor")
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ee7f592e239..3a5c19d9f651 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1667,7 +1667,7 @@ typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,
 			 unsigned);
 
 struct dir_context {
-	const filldir_t actor;
+	filldir_t actor;
 	loff_t pos;
 };
 

commit e13e75b86ef2f88e3a47d672dd4c52a293efb95b
Merge: 1ed41b5696cc 976431b02c2e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Apr 9 10:50:17 2018 -0700

    Merge branch 'for-4.17/dax' into libnvdimm-for-next

commit f8cf2f16a7c95acce497bfafa90e7c6d8397d653
Merge: 4b3f1a151571 ab60368ab6a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 7 16:53:59 2018 -0700

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull integrity updates from James Morris:
     "A mixture of bug fixes, code cleanup, and continues to close
      IMA-measurement, IMA-appraisal, and IMA-audit gaps.
    
      Also note the addition of a new cred_getsecid LSM hook by Matthew
      Garrett:
    
         For IMA purposes, we want to be able to obtain the prepared secid
         in the bprm structure before the credentials are committed. Add a
         cred_getsecid hook that makes this possible.
    
      which is used by a new CREDS_CHECK target in IMA:
    
         In ima_bprm_check(), check with both the existing process
         credentials and the credentials that will be committed when the new
         process is started. This will not change behaviour unless the
         system policy is extended to include CREDS_CHECK targets -
         BPRM_CHECK will continue to check the same credentials that it did
         previously"
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      ima: Fallback to the builtin hash algorithm
      ima: Add smackfs to the default appraise/measure list
      evm: check for remount ro in progress before writing
      ima: Improvements in ima_appraise_measurement()
      ima: Simplify ima_eventsig_init()
      integrity: Remove unused macro IMA_ACTION_RULE_FLAGS
      ima: drop vla in ima_audit_measurement()
      ima: Fix Kconfig to select TPM 2.0 CRB interface
      evm: Constify *integrity_status_msg[]
      evm: Move evm_hmac and evm_hash from evm_main.c to evm_crypto.c
      fuse: define the filesystem as untrusted
      ima: fail signature verification based on policy
      ima: clear IMA_HASH
      ima: re-evaluate files on privileged mounted filesystems
      ima: fail file signature verification on non-init mounted filesystems
      IMA: Support using new creds in appraisal policy
      security: Add a cred_getsecid hook

commit 9022ca6b1129da44e3d5c4fa779b8bb9ceabe2ce
Merge: 38c23685b273 0e11f6443f52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 11:07:08 2018 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted stuff, including Christoph's I_DIRTY patches"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: move I_DIRTY_INODE to fs.h
      ubifs: fix bogus __mark_inode_dirty(I_DIRTY_SYNC | I_DIRTY_DATASYNC) call
      ntfs: fix bogus __mark_inode_dirty(I_DIRTY_SYNC | I_DIRTY_DATASYNC) call
      gfs2: fix bogus __mark_inode_dirty(I_DIRTY_SYNC | I_DIRTY_DATASYNC) calls
      fs: fold open_check_o_direct into do_dentry_open
      vfs: Replace stray non-ASCII homoglyph characters with their ASCII equivalents
      vfs: make sure struct filename->iname is word-aligned
      get rid of pointless includes of fs_struct.h
      [poll] annotate SAA6588_CMD_POLL users

commit 3526dd0c7832f1011a0477cc6d903662bae05ea8
Merge: dd972f924df6 bc6d65e6dc89
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 5 14:27:02 2018 -0700

    Merge tag 'for-4.17/block-20180402' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
     "It's a pretty quiet round this time, which is nice. This contains:
    
       - series from Bart, cleaning up the way we set/test/clear atomic
         queue flags.
    
       - series from Bart, fixing races between gendisk and queue
         registration and removal.
    
       - set of bcache fixes and improvements from various folks, by way of
         Michael Lyle.
    
       - set of lightnvm updates from Matias, most of it being the 1.2 to
         2.0 transition.
    
       - removal of unused DIO flags from Nikolay.
    
       - blk-mq/sbitmap memory ordering fixes from Omar.
    
       - divide-by-zero fix for BFQ from Paolo.
    
       - minor documentation patches from Randy.
    
       - timeout fix from Tejun.
    
       - Alpha "can't write a char atomically" fix from Mikulas.
    
       - set of NVMe fixes by way of Keith.
    
       - bsg and bsg-lib improvements from Christoph.
    
       - a few sed-opal fixes from Jonas.
    
       - cdrom check-disk-change deadlock fix from Maurizio.
    
       - various little fixes, comment fixes, etc from various folks"
    
    * tag 'for-4.17/block-20180402' of git://git.kernel.dk/linux-block: (139 commits)
      blk-mq: Directly schedule q->timeout_work when aborting a request
      blktrace: fix comment in blktrace_api.h
      lightnvm: remove function name in strings
      lightnvm: pblk: remove some unnecessary NULL checks
      lightnvm: pblk: don't recover unwritten lines
      lightnvm: pblk: implement 2.0 support
      lightnvm: pblk: implement get log report chunk
      lightnvm: pblk: rename ppaf* to addrf*
      lightnvm: pblk: check for supported version
      lightnvm: implement get log report chunk helpers
      lightnvm: make address conversions depend on generic device
      lightnvm: add support for 2.0 address format
      lightnvm: normalize geometry nomenclature
      lightnvm: complete geo structure with maxoc*
      lightnvm: add shorten OCSSD version in geo
      lightnvm: add minor version to generic geometry
      lightnvm: simplify geometry structure
      lightnvm: pblk: refactor init/exit sequences
      lightnvm: Avoid validation of default op value
      lightnvm: centralize permission check for lightnvm ioctl
      ...

commit f44c77630d26ca2c2a60b20c47dd9ce07c4361b3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 7 15:26:44 2018 -0800

    fs, dax: prepare for dax-specific address_space_operations
    
    In preparation for the dax implementation to start associating dax pages
    to inodes via page->mapping, we need to provide a 'struct
    address_space_operations' instance for dax. Define some generic VFS aops
    helpers for dax. These noop implementations are there in the dax case to
    prevent the VFS from falling back to operations with page-cache
    assumptions, dax_writeback_mapping_range() may not be referenced in the
    FS_DAX=n case.
    
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Suggested-by: Matthew Wilcox <mawilcox@microsoft.com>
    Suggested-by: Jan Kara <jack@suse.cz>
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Suggested-by: Dave Chinner <david@fromorbit.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 79c413985305..44f7f7080faa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3129,6 +3129,10 @@ extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *,
 			 struct inode *, struct dentry *, unsigned int);
 extern int noop_fsync(struct file *, loff_t, loff_t, int);
+extern int noop_set_page_dirty(struct page *page);
+extern void noop_invalidatepage(struct page *page, unsigned int offset,
+		unsigned int length);
+extern ssize_t noop_direct_IO(struct kiocb *iocb, struct iov_iter *iter);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,

commit 0e11f6443f522f89509495b13ef1f3745640144d
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Feb 21 07:54:49 2018 -0800

    fs: move I_DIRTY_INODE to fs.h
    
    And use it in a few more places rather than opencoding the values.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d7b2caadb292..00da24bc0350 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2014,7 +2014,8 @@ static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 #define I_WB_SWITCH		(1 << 13)
 #define I_OVL_INUSE			(1 << 14)
 
-#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
+#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)
+#define I_DIRTY (I_DIRTY_INODE | I_DIRTY_PAGES)
 #define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)
 
 extern void __mark_inode_dirty(struct inode *, int);

commit 57b56ac6fecb05c3192586e4892572dd13d972de
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Feb 21 11:33:37 2018 -0500

    ima: fail file signature verification on non-init mounted filesystems
    
    FUSE can be mounted by unprivileged users either today with fusermount
    installed with setuid, or soon with the upcoming patches to allow FUSE
    mounts in a non-init user namespace.
    
    This patch addresses the new unprivileged non-init mounted filesystems,
    which are untrusted, by failing the signature verification.
    
    This patch defines two new flags SB_I_IMA_UNVERIFIABLE_SIGNATURE and
    SB_I_UNTRUSTED_MOUNTER.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Seth Forshee <seth.forshee@canonical.com>
    Cc: Dongsu Park <dongsu@kinvolk.io>
    Cc: Alban Crequy <alban@kinvolk.io>
    Acked-by: Serge Hallyn <serge@hallyn.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c6baf767619e..d9e60824c374 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1321,6 +1321,8 @@ extern int send_sigurg(struct fown_struct *fown);
 
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
+#define SB_I_IMA_UNVERIFIABLE_SIGNATURE	0x00000020
+#define SB_I_UNTRUSTED_MOUNTER		0x00000040
 
 /* Possible states of 'frozen' field */
 enum {

commit 08fdc8a0138afaf324296a342f32ad26ec465e43
Author: Mateusz Guzik <mguzik@redhat.com>
Date:   Tue Oct 3 18:17:41 2017 +0200

    buffer.c: call thaw_super during emergency thaw
    
    There are 2 distinct freezing mechanisms - one operates on block
    devices and another one directly on super blocks. Both end up with the
    same result, but thaw of only one of these does not thaw the other.
    
    In particular fsfreeze --freeze uses the ioctl variant going to the
    super block. Since prior to this patch emergency thaw was not doing
    a relevant thaw, filesystems frozen with this method remained
    unaffected.
    
    The patch is a hack which adds blind unfreezing.
    
    In order to keep the super block write-locked the whole time the code
    is shuffled around and the newly introduced __iterate_supers is
    employed.
    
    Signed-off-by: Mateusz Guzik <mguzik@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 339e73742e73..b864fcb3b5aa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2428,6 +2428,7 @@ extern int sync_blockdev(struct block_device *bdev);
 extern void kill_bdev(struct block_device *);
 extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
+extern void emergency_thaw_bdev(struct super_block *sb);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
 
@@ -2453,6 +2454,11 @@ static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
 	return 0;
 }
 
+static inline int emergency_thaw_bdev(struct super_block *sb)
+{
+	return 0;
+}
+
 static inline void iterate_bdevs(void (*f)(struct block_device *, void *), void *arg)
 {
 }

commit 1c94984396dc7bc40b4f6899674eaa41f29a4f6e
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Mar 1 00:19:21 2018 +0100

    vfs: make sure struct filename->iname is word-aligned
    
    I noticed that offsetof(struct filename, iname) is actually 28 on 64
    bit platforms, so we always pass an unaligned pointer to
    strncpy_from_user. This is mostly a problem for those 64 bit platforms
    without HAVE_EFFICIENT_UNALIGNED_ACCESS, but even on x86_64, unaligned
    accesses carry a penalty.
    
    A user-space microbenchmark doing nothing but strncpy_from_user from the
    same (aligned) source string runs about 5% faster when the destination
    is aligned. That number increases to 20% when the string is long
    enough (~32 bytes) that we cross a cache line boundary - that's for
    example the case for about half the files a "git status" in a kernel
    tree ends up stat'ing.
    
    This won't make any real-life workloads 5%, or even 1%, faster, but path
    lookup is common enough that cutting even a few cycles should be
    worthwhile. So ensure we always pass an aligned destination pointer to
    strncpy_from_user. Instead of explicit padding, simply swap the refcnt
    and aname members, as suggested by Al Viro.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2a815560fda0..d7b2caadb292 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2380,8 +2380,8 @@ struct audit_names;
 struct filename {
 	const char		*name;	/* pointer to actual string */
 	const __user char	*uptr;	/* original userland pointer */
-	struct audit_names	*aname;
 	int			refcnt;
+	struct audit_names	*aname;
 	const char		iname[];
 };
 

commit df09348f78dc53a14faddca4414d66bea849a749
Merge: cfb61b5e3e09 95dd77580ccd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 15 18:57:14 2018 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs fixes from Al Viro:
    
     - backport-friendly part of lock_parent() race fix
    
     - a fix for an assumption in the heurisic used by path_connected() that
       is not true on NFS
    
     - livelock fixes for d_alloc_parallel()
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Teach path_connected to handle nfs filesystems with multiple roots.
      fs: dcache: Use READ_ONCE when accessing i_dir_seq
      fs: dcache: Avoid livelock between d_alloc_parallel and __d_add
      lock_parent() needs to recheck if dentry got __dentry_kill'ed under it

commit 95dd77580ccd66a0da96e6d4696945b8cea39431
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Mar 14 18:20:29 2018 -0500

    fs: Teach path_connected to handle nfs filesystems with multiple roots.
    
    On nfsv2 and nfsv3 the nfs server can export subsets of the same
    filesystem and report the same filesystem identifier, so that the nfs
    client can know they are the same filesystem.  The subsets can be from
    disjoint directory trees.  The nfsv2 and nfsv3 filesystems provides no
    way to find the common root of all directory trees exported form the
    server with the same filesystem identifier.
    
    The practical result is that in struct super s_root for nfs s_root is
    not necessarily the root of the filesystem.  The nfs mount code sets
    s_root to the root of the first subset of the nfs filesystem that the
    kernel mounts.
    
    This effects the dcache invalidation code in generic_shutdown_super
    currently called shrunk_dcache_for_umount and that code for years
    has gone through an additional list of dentries that might be dentry
    trees that need to be freed to accomodate nfs.
    
    When I wrote path_connected I did not realize nfs was so special, and
    it's hueristic for avoiding calling is_subdir can fail.
    
    The practical case where this fails is when there is a move of a
    directory from the subtree exposed by one nfs mount to the subtree
    exposed by another nfs mount.  This move can happen either locally or
    remotely.  With the remote case requiring that the move directory be cached
    before the move and that after the move someone walks the path
    to where the move directory now exists and in so doing causes the
    already cached directory to be moved in the dcache through the magic
    of d_splice_alias.
    
    If someone whose working directory is in the move directory or a
    subdirectory and now starts calling .. from the initial mount of nfs
    (where s_root == mnt_root), then path_connected as a heuristic will
    not bother with the is_subdir check.  As s_root really is not the root
    of the nfs filesystem this heuristic is wrong, and the path may
    actually not be connected and path_connected can fail.
    
    The is_subdir function might be cheap enough that we can call it
    unconditionally.  Verifying that will take some benchmarking and
    the result may not be the same on all kernels this fix needs
    to be backported to.  So I am avoiding that for now.
    
    Filesystems with snapshots such as nilfs and btrfs do something
    similar.  But as the directory tree of the snapshots are disjoint
    from one another and from the main directory tree rename won't move
    things between them and this problem will not occur.
    
    Cc: stable@vger.kernel.org
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Fixes: 397d425dc26d ("vfs: Test for and handle paths that are unreachable from their mnt_root")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2a815560fda0..0430e03febaa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1317,6 +1317,7 @@ extern int send_sigurg(struct fown_struct *fown);
 #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 #define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
 #define SB_I_NODEV	0x00000004	/* Ignore devices on this fs */
+#define SB_I_MULTIROOT	0x00000008	/* Multiple roots to the dentry tree */
 
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */

commit ce3077ee80d6ac1087c06441f4c63ce5f13ef12c
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Feb 23 13:45:29 2018 +0200

    direct-io: Remove unused DIO_SKIP_DIO_COUNT logic
    
    This flag was added by fe0f07d08ee3 ("direct-io: only inc/deci
    inode->i_dio_count for file systems") as means to optimise the atomic
    modificaiton of the variable for blockdevices. However with the advent
    of 542ff7bf18c6 ("block: new direct I/O implementation") it became
    unused. So let's remove it.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 260c233e7375..9bee267209e5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2976,9 +2976,6 @@ enum {
 
 	/* filesystem does not support filling holes */
 	DIO_SKIP_HOLES	= 0x02,
-
-	/* inode/fs/bdev does not need truncate protection */
-	DIO_SKIP_DIO_COUNT = 0x08,
 };
 
 void dio_end_io(struct bio *bio);

commit c8f4c36f81623002165dce874fa60bb0c154b10e
Author: Nikolay Borisov <nborisov@suse.com>
Date:   Fri Feb 23 13:45:28 2018 +0200

    direct-io: Remove unused DIO_ASYNC_EXTEND flag
    
    This flag was added by 6039257378e4 ("direct-io: add flag to allow aio
    writes beyond i_size") to support XFS. However, with the rework of
    XFS' DIO's path to use iomap in acdda3aae146 ("xfs: use iomap_dio_rw")
    it became redundant. So let's remove it.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Nikolay Borisov <nborisov@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2a815560fda0..260c233e7375 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2977,9 +2977,6 @@ enum {
 	/* filesystem does not support filling holes */
 	DIO_SKIP_HOLES	= 0x02,
 
-	/* filesystem can handle aio writes beyond i_size */
-	DIO_ASYNC_EXTEND = 0x04,
-
 	/* inode/fs/bdev does not need truncate protection */
 	DIO_SKIP_DIO_COUNT = 0x08,
 };

commit 230f5a8969d8345fc9bbe3683f068246cf1be4b8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 21 17:08:01 2018 -0800

    dax: fix vma_is_fsdax() helper
    
    Gerd reports that ->i_mode may contain other bits besides S_IFCHR. Use
    S_ISCHR() instead. Otherwise, get_user_pages_longterm() may fail on
    device-dax instances when those are meant to be explicitly allowed.
    
    Fixes: 2bb6d2837083 ("mm: introduce get_user_pages_longterm")
    Cc: <stable@vger.kernel.org>
    Reported-by: Gerd Rausch <gerd.rausch@oracle.com>
    Acked-by: Jane Chu <jane.chu@oracle.com>
    Reported-by: Haozhong Zhang <haozhong.zhang@intel.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2a815560fda0..79c413985305 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3198,7 +3198,7 @@ static inline bool vma_is_fsdax(struct vm_area_struct *vma)
 	if (!vma_is_dax(vma))
 		return false;
 	inode = file_inode(vma->vm_file);
-	if (inode->i_mode == S_IFCHR)
+	if (S_ISCHR(inode->i_mode))
 		return false; /* device-dax */
 	return true;
 }

commit 20c59c71ae711aff845eef640b25935bc9578c93
Merge: 5a87e37ee094 1e369b0e199b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 10:18:00 2018 -0800

    Merge tag 'xfs-4.16-merge-4' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull xfs updates from Darrick Wong:
     "This merge cycle, we're again some substantive changes to XFS.
    
      Metadata verifiers have been restructured to provide more detail about
      which part of a metadata structure failed checks, and we've enhanced
      the new online fsck feature to cross-reference extent allocation
      information with the other metadata structures. With this pull, the
      metadata verification part of online fsck is more or less finished,
      though the feature is still experimental and still disabled by
      default.
    
      We're also preparing to remove the EXPERIMENTAL tag from a couple of
      features this cycle. This week we're committing a bunch of space
      accounting fixes for reflink and removing the EXPERIMENTAL tag from
      reflink; I anticipate that we'll be ready to do the same for the
      reverse mapping feature next week. (I don't have any pending fixes for
      rmap; however I wish to remove the tags one at a time.)
    
      This giant pile of patches has been run through a full xfstests run
      over the weekend and through a quick xfstests run against this
      morning's master, with no major failures reported. Let me know if
      there's any merge problems -- git merge reported that one of our
      patches touched the same function as the i_version series, but it
      resolved things cleanly.
    
      Summary:
    
       - Log faulting code locations when verifiers fail, for improved
         diagnosis of corrupt filesystems.
    
       - Implement metadata verifiers for local format inode fork data.
    
       - Online scrub now cross-references metadata records with other
         metadata.
    
       - Refactor the fs geometry ioctl generation functions.
    
       - Harden various metadata verifiers.
    
       - Fix various accounting problems.
    
       - Fix uncancelled transactions leaking when xattr functions fail.
    
       - Prevent the copy-on-write speculative preallocation garbage
         collector from racing with writeback.
    
       - Emit log reservation type information as trace data so that we can
         compare against xfsprogs.
    
       - Fix some erroneous asserts in the online scrub code.
    
       - Clean up the transaction reservation calculations.
    
       - Fix various minor bugs in online scrub.
    
       - Log complaints about mixed dio/buffered writes once per day and
         less noisily than before.
    
       - Refactor buffer log item lists to use list_head.
    
       - Break PNFS leases before reflinking blocks.
    
       - Reduce lock contention on reflink source files.
    
       - Fix some quota accounting problems with reflink.
    
       - Fix a serious corruption problem in the direct cow write code where
         we fed bad iomaps to the vfs iomap consumers.
    
       - Various other refactorings.
    
       - Remove EXPERIMENTAL tag from reflink!"
    
    * tag 'xfs-4.16-merge-4' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux: (94 commits)
      xfs: remove experimental tag for reflinks
      xfs: don't screw up direct writes when freesp is fragmented
      xfs: check reflink allocation mappings
      iomap: warn on zero-length mappings
      xfs: treat CoW fork operations as delalloc for quota accounting
      xfs: only grab shared inode locks for source file during reflink
      xfs: allow xfs_lock_two_inodes to take different EXCL/SHARED modes
      xfs: reflink should break pnfs leases before sharing blocks
      xfs: don't clobber inobt/finobt cursors when xref with rmap
      xfs: skip CoW writes past EOF when writeback races with truncate
      xfs: preserve i_rdev when recycling a reclaimable inode
      xfs: refactor accounting updates out of xfs_bmap_btalloc
      xfs: refactor inode verifier corruption error printing
      xfs: make tracepoint inode number format consistent
      xfs: always zero di_flags2 when we free the inode
      xfs: call xfs_qm_dqattach before performing reflink operations
      xfs: bmap code cleanup
      Use list_head infra-structure for buffer's log items list
      Split buffer's b_fspriv field
      Get rid of xfs_buf_log_item_t typedef
      ...

commit 19e7b5f99474107e8d0b4b3e4652fa19ddb87efc
Merge: 26064ea409b4 ce4c253573ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 31 09:25:20 2018 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "All kinds of misc stuff, without any unifying topic, from various
      people.
    
      Neil's d_anon patch, several bugfixes, introduction of kvmalloc
      analogue of kmemdup_user(), extending bitfield.h to deal with
      fixed-endians, assorted cleanups all over the place..."
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (28 commits)
      alpha: osf_sys.c: use timespec64 where appropriate
      alpha: osf_sys.c: fix put_tv32 regression
      jffs2: Fix use-after-free bug in jffs2_iget()'s error handling path
      dcache: delete unused d_hash_mask
      dcache: subtract d_hash_shift from 32 in advance
      fs/buffer.c: fold init_buffer() into init_page_buffers()
      fs: fold __inode_permission() into inode_permission()
      fs: add RWF_APPEND
      sctp: use vmemdup_user() rather than badly open-coding memdup_user()
      snd_ctl_elem_init_enum_names(): switch to vmemdup_user()
      replace_user_tlv(): switch to vmemdup_user()
      new primitive: vmemdup_user()
      memdup_user(): switch to GFP_USER
      eventfd: fold eventfd_ctx_get() into eventfd_ctx_fileget()
      eventfd: fold eventfd_ctx_read() into eventfd_read()
      eventfd: convert to use anon_inode_getfd()
      nfs4file: get rid of pointless include of btrfs.h
      uvc_v4l2: clean copyin/copyout up
      vme_user: don't use __copy_..._user()
      usx2y: don't bother with memdup_user() for 16-byte structure
      ...

commit 8b0fdf631cf6a31f60a9ed3e1c0f37a9715de807
Merge: 168fe32a072a 36735a6a2b5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 30 18:32:21 2018 -0800

    Merge branch 'work.mqueue' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull mqueue/bpf vfs cleanups from Al Viro:
     "mqueue and bpf go through rather painful and similar contortions to
      create objects in their dentry trees. Provide a primitive for doing
      that without abusing ->mknod(), switch bpf and mqueue to it.
    
      Another mqueue-related thing that has ended up in that branch is
      on-demand creation of internal mount (based upon the work of Giuseppe
      Scrivano)"
    
    * 'work.mqueue' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      mqueue: switch to on-demand creation of internal mount
      tidy do_mq_open() up a bit
      mqueue: clean prepare_open() up
      do_mq_open(): move all work prior to dentry_open() into a helper
      mqueue: fold mq_attr_ok() into mqueue_get_inode()
      move dentry_open() calls up into do_mq_open()
      mqueue: switch to vfs_mkobj(), quit abusing ->d_fsdata
      bpf_obj_do_pin(): switch to vfs_mkobj(), quit abusing ->mknod()
      new primitive: vfs_mkobj()

commit 168fe32a072a4b8dc81a3aebf0e5e588d38e2955
Merge: 13ddd1667e7f c71d227fc413
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 30 17:58:07 2018 -0800

    Merge branch 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull poll annotations from Al Viro:
     "This introduces a __bitwise type for POLL### bitmap, and propagates
      the annotations through the tree. Most of that stuff is as simple as
      'make ->poll() instances return __poll_t and do the same to local
      variables used to hold the future return value'.
    
      Some of the obvious brainos found in process are fixed (e.g. POLLIN
      misspelled as POLL_IN). At that point the amount of sparse warnings is
      low and most of them are for genuine bugs - e.g. ->poll() instance
      deciding to return -EINVAL instead of a bitmap. I hadn't touched those
      in this series - it's large enough as it is.
    
      Another problem it has caught was eventpoll() ABI mess; select.c and
      eventpoll.c assumed that corresponding POLL### and EPOLL### were
      equal. That's true for some, but not all of them - EPOLL### are
      arch-independent, but POLL### are not.
    
      The last commit in this series separates userland POLL### values from
      the (now arch-independent) kernel-side ones, converting between them
      in the few places where they are copied to/from userland. AFAICS, this
      is the least disruptive fix preserving poll(2) ABI and making epoll()
      work on all architectures.
    
      As it is, it's simply broken on sparc - try to give it EPOLLWRNORM and
      it will trigger only on what would've triggered EPOLLWRBAND on other
      architectures. EPOLLWRBAND and EPOLLRDHUP, OTOH, are never triggered
      at all on sparc. With this patch they should work consistently on all
      architectures"
    
    * 'misc.poll' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (37 commits)
      make kernel-side POLL... arch-independent
      eventpoll: no need to mask the result of epi_item_poll() again
      eventpoll: constify struct epoll_event pointers
      debugging printk in sg_poll() uses %x to print POLL... bitmap
      annotate poll(2) guts
      9p: untangle ->poll() mess
      ->si_band gets POLL... bitmap stored into a user-visible long field
      ring_buffer_poll_wait() return value used as return value of ->poll()
      the rest of drivers/*: annotate ->poll() instances
      media: annotate ->poll() instances
      fs: annotate ->poll() instances
      ipc, kernel, mm: annotate ->poll() instances
      net: annotate ->poll() instances
      apparmor: annotate ->poll() instances
      tomoyo: annotate ->poll() instances
      sound: annotate ->poll() instances
      acpi: annotate ->poll() instances
      crypto: annotate ->poll() instances
      block: annotate ->poll() instances
      x86: annotate ->poll() instances
      ...

commit 01c2e13dcae9757ea987af8933f9fcc6e33f2d7c
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Thu Jan 18 14:07:53 2018 -0800

    xfs: only grab shared inode locks for source file during reflink
    
    Reflink and dedupe operations remap blocks from a source file into a
    destination file.  The destination file needs exclusive locks on all
    levels because we're updating its block map, but the source file isn't
    undergoing any block map changes so we can use a shared lock.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7f8d96d68f34..5cbeab8a63ca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -748,6 +748,11 @@ static inline void inode_lock_nested(struct inode *inode, unsigned subclass)
 	down_write_nested(&inode->i_rwsem, subclass);
 }
 
+static inline void inode_lock_shared_nested(struct inode *inode, unsigned subclass)
+{
+	down_read_nested(&inode->i_rwsem, subclass);
+}
+
 void lock_two_nondirectories(struct inode *, struct inode*);
 void unlock_two_nondirectories(struct inode *, struct inode*);
 

commit f02a9ad1f15daf4378afeda025a53455f72645dd
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Dec 21 07:45:44 2017 -0500

    fs: handle inode->i_version more efficiently
    
    Since i_version is mostly treated as an opaque value, we can exploit that
    fact to avoid incrementing it when no one is watching. With that change,
    we can avoid incrementing the counter on writes, unless someone has
    queried for it since it was last incremented. If the a/c/mtime don't
    change, and the i_version hasn't changed, then there's no need to dirty
    the inode metadata on a write.
    
    Convert the i_version counter to an atomic64_t, and use the lowest order
    bit to hold a flag that will tell whether anyone has queried the value
    since it was last incremented.
    
    When we go to maybe increment it, we fetch the value and check the flag
    bit.  If it's clear then we don't need to do anything if the update
    isn't being forced.
    
    If we do need to update, then we increment the counter by 2, and clear
    the flag bit, and then use a CAS op to swap it into place. If that
    works, we return true. If it doesn't then do it again with the value
    that we fetch from the CAS operation.
    
    On the query side, if the flag is already set, then we just shift the
    value down by 1 bit and return it. Otherwise, we set the flag in our
    on-stack value and again use cmpxchg to swap it into place if it hasn't
    changed. If it has, then we use the value from the cmpxchg as the new
    "old" value and try again.
    
    This method allows us to avoid incrementing the counter on writes (and
    dirtying the metadata) under typical workloads. We only need to increment
    if it has been queried since it was last changed.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Tested-by: Krzysztof Kozlowski <krzk@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 76382c24e9d0..6804d075933e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -639,7 +639,7 @@ struct inode {
 		struct hlist_head	i_dentry;
 		struct rcu_head		i_rcu;
 	};
-	u64			i_version;
+	atomic64_t		i_version;
 	atomic_t		i_count;
 	atomic_t		i_dio_count;
 	atomic_t		i_writecount;

commit ae5e165d855dd978a461b22175531b07f54fb61f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jan 29 06:41:30 2018 -0500

    fs: new API for handling inode->i_version
    
    Add a documentation blob that explains what the i_version field is, how
    it is expected to work, and how it is currently implemented by various
    filesystems.
    
    We already have inode_inc_iversion. Add several other functions for
    manipulating and accessing the i_version counter. For now, the
    implementation is trivial and basically works the way that all of the
    open-coded i_version accesses work today.
    
    Future patches will convert existing users of i_version to use the new
    API, and then convert the backend implementation to do things more
    efficiently.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 511fbaabf624..76382c24e9d0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2036,21 +2036,6 @@ static inline void inode_dec_link_count(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
-/**
- * inode_inc_iversion - increments i_version
- * @inode: inode that need to be updated
- *
- * Every time the inode is modified, the i_version field will be incremented.
- * The filesystem has to be mounted with i_version flag
- */
-
-static inline void inode_inc_iversion(struct inode *inode)
-{
-       spin_lock(&inode->i_lock);
-       inode->i_version++;
-       spin_unlock(&inode->i_lock);
-}
-
 enum file_time_flags {
 	S_ATIME = 1,
 	S_MTIME = 2,

commit 4bfd054ae11ea061685c4a2a6234fdc8e92fad41
Author: Eric Biggers <ebiggers@google.com>
Date:   Tue Jan 16 21:44:24 2018 -0800

    fs: fold __inode_permission() into inode_permission()
    
    Since commit 9c630ebefeee ("ovl: simplify permission checking"),
    overlayfs doesn't call __inode_permission() anymore, which leaves no
    users other than inode_permission().  So just fold it back into
    inode_permission().
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 85c8ddc55760..b49251112add 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2699,7 +2699,6 @@ extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct iattr *, struct inode **);
 extern int inode_permission(struct inode *, int);
-extern int __inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int);
 extern int __check_sticky(struct inode *dir, struct inode *inode);
 

commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
Author: Jrg Billeter <j@bitron.ch>
Date:   Fri Sep 29 14:07:17 2017 +0200

    fs: add RWF_APPEND
    
    This is the per-I/O equivalent of O_APPEND to support atomic append
    operations on any open file.
    
    If a file is opened with O_APPEND, pwrite() ignores the offset and
    always appends data to the end of the file. RWF_APPEND enables atomic
    append and pwrite() with offset on a single file descriptor.
    
    Signed-off-by: Jrg Billeter <j@bitron.ch>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6276f8315e5b..85c8ddc55760 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3224,6 +3224,8 @@ static inline int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)
 		ki->ki_flags |= IOCB_DSYNC;
 	if (flags & RWF_SYNC)
 		ki->ki_flags |= (IOCB_DSYNC | IOCB_SYNC);
+	if (flags & RWF_APPEND)
+		ki->ki_flags |= IOCB_APPEND;
 	return 0;
 }
 

commit 5a9d929d6e13278df62bd9e3d3ceae8c87ad1eea
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Mon Jan 8 10:41:39 2018 -0800

    iomap: report collisions between directio and buffered writes to userspace
    
    If two programs simultaneously try to write to the same part of a file
    via direct IO and buffered IO, there's a chance that the post-diowrite
    pagecache invalidation will fail on the dirty page.  When this happens,
    the dio write succeeded, which means that the page cache is no longer
    coherent with the disk!
    
    Programs are not supposed to mix IO types and this is a clear case of
    data corruption, so store an EIO which will be reflected to userspace
    during the next fsync.  Replace the WARN_ON with a ratelimited pr_crit
    so that the developers have /some/ kind of breadcrumb to track down the
    offending program(s) and file(s) involved.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 511fbaabf624..7f8d96d68f34 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2992,6 +2992,7 @@ enum {
 };
 
 void dio_end_io(struct bio *bio);
+void dio_warn_stale_pagecache(struct file *filp);
 
 ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
 			     struct block_device *bdev, struct iov_iter *iter,

commit 8e6c848eceaa38a7e0192953b08162467e51f852
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 1 17:12:45 2017 -0500

    new primitive: vfs_mkobj()
    
    Similar to vfs_create(), but with caller-supplied callback (and
    argument for it) to be used instead of ->create().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 511fbaabf624..aad23d4fae47 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1608,6 +1608,10 @@ extern int vfs_whiteout(struct inode *, struct dentry *);
 extern struct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode,
 				  int open_flag);
 
+int vfs_mkobj(struct dentry *, umode_t,
+		int (*f)(struct dentry *, umode_t, void *),
+		void *);
+
 /*
  * VFS file helper functions.
  */

commit f1ee616214cb22410e939d963bbb2349c2570f02
Author: NeilBrown <neilb@suse.com>
Date:   Thu Dec 21 09:45:40 2017 +1100

    VFS: don't keep disconnected dentries on d_anon
    
    The original purpose of the per-superblock d_anon list was to
    keep disconnected dentries in the cache between consecutive
    requests to the NFS server.  Dentries can be disconnected if
    a client holds a file open and repeatedly performs IO on it,
    and if the server drops the dentry, whether due to memory
    pressure, server restart, or "echo 3 > /proc/sys/vm/drop_caches".
    
    This purpose was thwarted by commit 75a6f82a0d10 ("freeing unlinked
    file indefinitely delayed") which caused disconnected dentries
    to be freed as soon as their refcount reached zero.
    
    This means that, when a dentry being used by nfsd gets disconnected, a
    new one needs to be allocated for every request (unless requests
    overlap).  As the dentry has no name, no parent, and no children,
    there is little of value to cache.  As small memory allocations are
    typically fast (from per-cpu free lists) this likely has little cost.
    
    This means that the original purpose of s_anon is no longer relevant:
    there is no longer any need to keep disconnected dentries on a list so
    they appear to be hashed.
    
    However, s_anon now has a new use.  When you mount an NFS filesystem,
    the dentry stored in s_root is just a placebo.  The "real" root dentry
    is allocated using d_obtain_root() and so it kept on the s_anon list.
    I don't know the reason for this, but suspect it related to NFSv4
    where a mount of "server:/some/path" require NFS to look up the root
    filehandle on the server, then walk down "/some" and "/path" to get
    the filehandle to mount.
    
    Whatever the reason, NFS depends on the s_anon list and on
    shrink_dcache_for_umount() pruning all dentries on this list.  So we
    cannot simply remove s_anon.
    
    We could just leave the code unchanged, but apart from that being
    potentially confusing, the (unfair) bit-spin-lock which protects
    s_anon can become a bottle neck when lots of disconnected dentries are
    being created.
    
    So this patch renames s_anon to s_roots, and stops storing
    disconnected dentries on the list.  Only dentries obtained with
    d_obtain_root() are now stored on this list.  There are many fewer of
    these (only NFS and NILFS2 use the call, and only during filesystem
    mount) so contention on the bit-lock will not be a problem.
    
    Possibly an alternate solution should be found for NFS and NILFS2, but
    that would require understanding their needs first.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2995a271ec46..6276f8315e5b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1359,7 +1359,7 @@ struct super_block {
 
 	const struct fscrypt_operations	*s_cop;
 
-	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
+	struct hlist_bl_head	s_roots;	/* alternate root dentries for NFS */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;

commit 5d38f049cee1e1c4a7ac55aa79d37d01ddcc3860
Author: Ian Kent <raven@themaw.net>
Date:   Wed Nov 29 16:11:26 2017 -0800

    autofs: revert "autofs: fix AT_NO_AUTOMOUNT not being honored"
    
    Commit 42f461482178 ("autofs: fix AT_NO_AUTOMOUNT not being honored")
    allowed the fstatat(2) system call to properly honor the AT_NO_AUTOMOUNT
    flag but introduced a semantic change.
    
    In order to honor AT_NO_AUTOMOUNT a semantic change was made to the
    negative dentry case for stat family system calls in follow_automount().
    
    This changed the unconditional triggering of an automount in this case
    to no longer be done and an error returned instead.
    
    This has caused more problems than I expected so reverting the change is
    needed.
    
    In a discussion with Neil Brown it was concluded that the automount(8)
    daemon can implement this change without kernel modifications.  So that
    will be done instead and the autofs module documentation updated with a
    description of the problem and what needs to be done by module users for
    this specific case.
    
    Link: http://lkml.kernel.org/r/151174730120.6162.3848002191530283984.stgit@pluto.themaw.net
    Fixes: 42f4614821 ("autofs: fix AT_NO_AUTOMOUNT not being honored")
    Signed-off-by: Ian Kent <raven@themaw.net>
    Cc: Neil Brown <neilb@suse.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Colin Walters <walters@redhat.com>
    Cc: Ondrej Holy <oholy@redhat.com>
    Cc: <stable@vger.kernel.org>    [4.11+]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9dc498d16cc1..511fbaabf624 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3088,7 +3088,8 @@ static inline int vfs_lstat(const char __user *name, struct kstat *stat)
 static inline int vfs_fstatat(int dfd, const char __user *filename,
 			      struct kstat *stat, int flags)
 {
-	return vfs_statx(dfd, filename, flags, stat, STATX_BASIC_STATS);
+	return vfs_statx(dfd, filename, flags | AT_NO_AUTOMOUNT,
+			 stat, STATX_BASIC_STATS);
 }
 static inline int vfs_fstat(int fd, struct kstat *stat)
 {

commit 2bb6d2837083de722bfdc369cb0d76ce188dd9b4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 29 16:10:35 2017 -0800

    mm: introduce get_user_pages_longterm
    
    Patch series "introduce get_user_pages_longterm()", v2.
    
    Here is a new get_user_pages api for cases where a driver intends to
    keep an elevated page count indefinitely.  This is distinct from usages
    like iov_iter_get_pages where the elevated page counts are transient.
    The iov_iter_get_pages cases immediately turn around and submit the
    pages to a device driver which will put_page when the i/o operation
    completes (under kernel control).
    
    In the longterm case userspace is responsible for dropping the page
    reference at some undefined point in the future.  This is untenable for
    filesystem-dax case where the filesystem is in control of the lifetime
    of the block / page and needs reasonable limits on how long it can wait
    for pages in a mapping to become idle.
    
    Fixing filesystems to actually wait for dax pages to be idle before
    blocks from a truncate/hole-punch operation are repurposed is saved for
    a later patch series.
    
    Also, allowing longterm registration of dax mappings is a future patch
    series that introduces a "map with lease" semantic where the kernel can
    revoke a lease and force userspace to drop its page references.
    
    I have also tagged these for -stable to purposely break cases that might
    assume that longterm memory registrations for filesystem-dax mappings
    were supported by the kernel.  The behavior regression this policy
    change implies is one of the reasons we maintain the "dax enabled.
    Warning: EXPERIMENTAL, use at your own risk" notification when mounting
    a filesystem in dax mode.
    
    It is worth noting the device-dax interface does not suffer the same
    constraints since it does not support file space management operations
    like hole-punch.
    
    This patch (of 4):
    
    Until there is a solution to the dma-to-dax vs truncate problem it is
    not safe to allow long standing memory registrations against
    filesytem-dax vmas.  Device-dax vmas do not have this problem and are
    explicitly allowed.
    
    This is temporary until a "memory registration with layout-lease"
    mechanism can be implemented for the affected sub-systems (RDMA and
    V4L2).
    
    [akpm@linux-foundation.org: use kcalloc()]
    Link: http://lkml.kernel.org/r/151068939435.7446.13560129395419350737.stgit@dwillia2-desk3.amr.corp.intel.com
    Fixes: 3565fce3a659 ("mm, x86: get_user_pages() for dax mappings")
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Cc: Doug Ledford <dledford@redhat.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: Inki Dae <inki.dae@samsung.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jason Gunthorpe <jgg@mellanox.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Joonyoung Shim <jy0922.shim@samsung.com>
    Cc: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Seung-Woo Kim <sw0312.kim@samsung.com>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bbd92da0946e..9dc498d16cc1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3194,6 +3194,20 @@ static inline bool vma_is_dax(struct vm_area_struct *vma)
 	return vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);
 }
 
+static inline bool vma_is_fsdax(struct vm_area_struct *vma)
+{
+	struct inode *inode;
+
+	if (!vma->vm_file)
+		return false;
+	if (!vma_is_dax(vma))
+		return false;
+	inode = file_inode(vma->vm_file);
+	if (inode->i_mode == S_IFCHR)
+		return false; /* device-dax */
+	return true;
+}
+
 static inline int iocb_flags(struct file *file)
 {
 	int res = 0;

commit a3f8683bf7d5e6254fe68f5c5d3585e27eea8ed0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 22:22:01 2017 -0400

    ->poll() methods should return __poll_t
    
    The most common place to find POLL... bitmaps: return values
    of ->poll() and its subsystem counterparts.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2995a271ec46..64695eb07992 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1698,7 +1698,7 @@ struct file_operations {
 	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 	int (*iterate) (struct file *, struct dir_context *);
 	int (*iterate_shared) (struct file *, struct dir_context *);
-	unsigned int (*poll) (struct file *, struct poll_table_struct *);
+	__poll_t (*poll) (struct file *, struct poll_table_struct *);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);

commit 1751e8a6cb935e555fcdbcb9ab4f0446e322ca3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 27 13:05:09 2017 -0800

    Rename superblock flags (MS_xyz -> SB_xyz)
    
    This is a pure automated search-and-replace of the internal kernel
    superblock flags.
    
    The s_flags are now called SB_*, with the names and the values for the
    moment mirroring the MS_* flags that they're equivalent to.
    
    Note how the MS_xyz flags are the ones passed to the mount system call,
    while the SB_xyz flags are what we then use in sb->s_flags.
    
    The script to do this was:
    
        # places to look in; re security/*: it generally should *not* be
        # touched (that stuff parses mount(2) arguments directly), but
        # there are two places where we really deal with superblock flags.
        FILES="drivers/mtd drivers/staging/lustre fs ipc mm \
                include/linux/fs.h include/uapi/linux/bfs_fs.h \
                security/apparmor/apparmorfs.c security/apparmor/include/lib.h"
        # the list of MS_... constants
        SYMS="RDONLY NOSUID NODEV NOEXEC SYNCHRONOUS REMOUNT MANDLOCK \
              DIRSYNC NOATIME NODIRATIME BIND MOVE REC VERBOSE SILENT \
              POSIXACL UNBINDABLE PRIVATE SLAVE SHARED RELATIME KERNMOUNT \
              I_VERSION STRICTATIME LAZYTIME SUBMOUNT NOREMOTELOCK NOSEC BORN \
              ACTIVE NOUSER"
    
        SED_PROG=
        for i in $SYMS; do SED_PROG="$SED_PROG -e s/MS_$i/SB_$i/g"; done
    
        # we want files that contain at least one of MS_...,
        # with fs/namespace.c and fs/pnode.c excluded.
        L=$(for i in $SYMS; do git grep -w -l MS_$i $FILES; done| sort|uniq|grep -v '^fs/namespace.c'|grep -v '^fs/pnode.c')
    
        for f in $L; do sed -i $f $SED_PROG; done
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2995a271ec46..bbd92da0946e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1872,7 +1872,7 @@ struct super_operations {
  */
 #define __IS_FLG(inode, flg)	((inode)->i_sb->s_flags & (flg))
 
-static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & MS_RDONLY; }
+static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & SB_RDONLY; }
 #define IS_RDONLY(inode)	sb_rdonly((inode)->i_sb)
 #define IS_SYNC(inode)		(__IS_FLG(inode, SB_SYNCHRONOUS) || \
 					((inode)->i_flags & S_SYNC))

commit 4dd3c2e5a4225e3df85afc6033e62ce8b09f0ed2
Merge: 07c455ee222f 22700f3c6df5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 18 11:22:04 2017 -0800

    Merge tag 'nfsd-4.15' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Lots of good bugfixes, including:
    
       -  fix a number of races in the NFSv4+ state code
    
       -  fix some shutdown crashes in multiple-network-namespace cases
    
       -  relax our 4.1 session limits; if you've an artificially low limit
          to the number of 4.1 clients that can mount simultaneously, try
          upgrading"
    
    * tag 'nfsd-4.15' of git://linux-nfs.org/~bfields/linux: (22 commits)
      SUNRPC: Improve ordering of transport processing
      nfsd: deal with revoked delegations appropriately
      svcrdma: Enqueue after setting XPT_CLOSE in completion handlers
      nfsd: use nfs->ns.inum as net ID
      rpc: remove some BUG()s
      svcrdma: Preserve CB send buffer across retransmits
      nfds: avoid gettimeofday for nfssvc_boot time
      fs, nfsd: convert nfs4_file.fi_ref from atomic_t to refcount_t
      fs, nfsd: convert nfs4_cntl_odstate.co_odcount from atomic_t to refcount_t
      fs, nfsd: convert nfs4_stid.sc_count from atomic_t to refcount_t
      lockd: double unregister of inetaddr notifiers
      nfsd4: catch some false session retries
      nfsd4: fix cached replies to solo SEQUENCE compounds
      sunrcp: make function _svc_create_xprt static
      SUNRPC: Fix tracepoint storage issues with svc_recv and svc_rqst_status
      nfsd: use ARRAY_SIZE
      nfsd: give out fewer session slots as limit approaches
      nfsd: increase DRC cache limit
      nfsd: remove unnecessary nofilehandle checks
      nfs_common: convert int to bool
      ...

commit ca5b857cb0f42986520abd9dbb0c2508067342b2
Merge: a0e136e5da98 c02b1a9b41c2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 17 12:54:01 2017 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted stuff, really no common topic here"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: grab the lock instead of blocking in __fd_install during resizing
      vfs: stop clearing close on exec when closing a fd
      include/linux/fs.h: fix comment about struct address_space
      fs: make fiemap work from compat_ioctl
      coda: fix 'kernel memory exposure attempt' in fsync
      pstore: remove unneeded unlikely()
      vfs: remove unneeded unlikely()
      stubs for mount_bdev() and kill_block_super() in !CONFIG_BLOCK case
      make vfs_ustat() static
      do_handle_open() should be static
      elf_fdpic: fix unused variable warning
      fold destroy_super() into __put_super()
      new helper: destroy_unused_super()
      fix address space warnings in ipc/
      acct.h: get rid of detritus

commit a3841f94c7ecb3ede0f888d3fcfe8fb6368ddd7a
Merge: adeba81ac2a6 4247f24c2358
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 17 09:51:57 2017 -0800

    Merge tag 'libnvdimm-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm and dax updates from Dan Williams:
     "Save for a few late fixes, all of these commits have shipped in -next
      releases since before the merge window opened, and 0day has given a
      build success notification.
    
      The ext4 touches came from Jan, and the xfs touches have Darrick's
      reviewed-by. An xfstest for the MAP_SYNC feature has been through
      a few round of reviews and is on track to be merged.
    
       - Introduce MAP_SYNC and MAP_SHARED_VALIDATE, a mechanism to enable
         'userspace flush' of persistent memory updates via filesystem-dax
         mappings. It arranges for any filesystem metadata updates that may
         be required to satisfy a write fault to also be flushed ("on disk")
         before the kernel returns to userspace from the fault handler.
         Effectively every write-fault that dirties metadata completes an
         fsync() before returning from the fault handler. The new
         MAP_SHARED_VALIDATE mapping type guarantees that the MAP_SYNC flag
         is validated as supported by the filesystem's ->mmap() file
         operation.
    
       - Add support for the standard ACPI 6.2 label access methods that
         replace the NVDIMM_FAMILY_INTEL (vendor specific) label methods.
         This enables interoperability with environments that only implement
         the standardized methods.
    
       - Add support for the ACPI 6.2 NVDIMM media error injection methods.
    
       - Add support for the NVDIMM_FAMILY_INTEL v1.6 DIMM commands for
         latch last shutdown status, firmware update, SMART error injection,
         and SMART alarm threshold control.
    
       - Cleanup physical address information disclosures to be root-only.
    
       - Fix revalidation of the DIMM "locked label area" status to support
         dynamic unlock of the label area.
    
       - Expand unit test infrastructure to mock the ACPI 6.2 Translate SPA
         (system-physical-address) command and error injection commands.
    
      Acknowledgements that came after the commits were pushed to -next:
    
       - 957ac8c421ad ("dax: fix PMD faults on zero-length files"):
           Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    
       - a39e596baa07 ("xfs: support for synchronous DAX faults") and
         7b565c9f965b ("xfs: Implement xfs_filemap_pfn_mkwrite() using __xfs_filemap_fault()")
            Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>"
    
    * tag 'libnvdimm-for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (49 commits)
      acpi, nfit: add 'Enable Latch System Shutdown Status' command support
      dax: fix general protection fault in dax_alloc_inode
      dax: fix PMD faults on zero-length files
      dax: stop requiring a live device for dax_flush()
      brd: remove dax support
      dax: quiet bdev_dax_supported()
      fs, dax: unify IOMAP_F_DIRTY read vs write handling policy in the dax core
      tools/testing/nvdimm: unit test clear-error commands
      acpi, nfit: validate commands against the device type
      tools/testing/nvdimm: stricter bounds checking for error injection commands
      xfs: support for synchronous DAX faults
      xfs: Implement xfs_filemap_pfn_mkwrite() using __xfs_filemap_fault()
      ext4: Support for synchronous DAX faults
      ext4: Simplify error handling in ext4_dax_huge_fault()
      dax: Implement dax_finish_sync_fault()
      dax, iomap: Add support for synchronous faults
      mm: Define MAP_SYNC and VM_SYNC flags
      dax: Allow tuning whether dax_insert_mapping_entry() dirties entry
      dax: Allow dax_iomap_fault() to return pfn
      dax: Fix comment describing dax_iomap_fault()
      ...

commit 32190f0afbf4f1c0a9142e5a886a078ee0b794fd
Merge: 37dc79565c4b a0b3bc855374
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 11:35:15 2017 -0800

    Merge tag 'fscrypt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/fscrypt
    
    Pull fscrypt updates from Ted Ts'o:
     "Lots of cleanups, mostly courtesy by Eric Biggers"
    
    * tag 'fscrypt-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/fscrypt:
      fscrypt: lock mutex before checking for bounce page pool
      fscrypt: add a documentation file for filesystem-level encryption
      ext4: switch to fscrypt_prepare_setattr()
      ext4: switch to fscrypt_prepare_lookup()
      ext4: switch to fscrypt_prepare_rename()
      ext4: switch to fscrypt_prepare_link()
      ext4: switch to fscrypt_file_open()
      fscrypt: new helper function - fscrypt_prepare_setattr()
      fscrypt: new helper function - fscrypt_prepare_lookup()
      fscrypt: new helper function - fscrypt_prepare_rename()
      fscrypt: new helper function - fscrypt_prepare_link()
      fscrypt: new helper function - fscrypt_file_open()
      fscrypt: new helper function - fscrypt_require_key()
      fscrypt: remove unneeded empty fscrypt_operations structs
      fscrypt: remove ->is_encrypted()
      fscrypt: switch from ->is_encrypted() to IS_ENCRYPTED()
      fs, fscrypt: add an S_ENCRYPTED inode flag
      fscrypt: clean up include file mess

commit b33e3cc5c90b8293599318b68e61b93a89c127bb
Merge: 55b3a0cb5aee e5729f86a298
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 10:41:25 2017 -0800

    Merge branch 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem integrity updates from James Morris:
     "There is a mixture of bug fixes, code cleanup, preparatory code for
      new functionality and new functionality.
    
      Commit 26ddabfe96bb ("evm: enable EVM when X509 certificate is
      loaded") enabled EVM without loading a symmetric key, but was limited
      to defining the x509 certificate pathname at build. Included in this
      set of patches is the ability of enabling EVM, without loading the EVM
      symmetric key, from userspace. New is the ability to prevent the
      loading of an EVM symmetric key."
    
    * 'next-integrity' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security:
      ima: Remove redundant conditional operator
      ima: Fix bool initialization/comparison
      ima: check signature enforcement against cmdline param instead of CONFIG
      module: export module signature enforcement status
      ima: fix hash algorithm initialization
      EVM: Only complain about a missing HMAC key once
      EVM: Allow userspace to signal an RSA key has been loaded
      EVM: Include security.apparmor in EVM measurements
      ima: call ima_file_free() prior to calling fasync
      integrity: use kernel_read_file_from_path() to read x509 certs
      ima: always measure and audit files in policy
      ima: don't remove the securityfs policy file
      vfs: fix mounting a filesystem with i_version

commit a7d3d0392a325d630225b7dbccf2558f944114e5
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Sep 10 09:49:45 2017 +0200

    integrity: use kernel_read_file_from_path() to read x509 certs
    
    The CONFIG_IMA_LOAD_X509 and CONFIG_EVM_LOAD_X509 options permit
    loading x509 signed certificates onto the trusted keyrings without
    verifying the x509 certificate file's signature.
    
    This patch replaces the call to the integrity_read_file() specific
    function with the common kernel_read_file_from_path() function.
    To avoid verifying the file signature, this patch defines
    READING_X509_CERTFICATE.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 339e73742e73..456325084f1d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2792,6 +2792,7 @@ extern int do_pipe_flags(int *, int);
 	id(KEXEC_IMAGE, kexec-image)		\
 	id(KEXEC_INITRAMFS, kexec-initramfs)	\
 	id(POLICY, security-policy)		\
+	id(X509_CERTIFICATE, x509-certificate)	\
 	id(MAX_ID, )
 
 #define __fid_enumify(ENUM, dummy) READING_ ## ENUM,

commit 63dcb81e5b9e1faadf4b55450141bc4446e5a3d3
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 3 08:53:07 2017 +0300

    include/linux/fs.h: fix comment about struct address_space
    
    Before commit 9c5d760b8d22 ("mm: split gfp_mask and mapping flags into
    separate fields") the private_* fields of struct adrress_space were grouped
    together and using "ditto" in comments describing the last fields was
    correct.
    
    With introduction of gpf_mask between private_lock and private_list "ditto"
    references the wrong description.
    
    Fix it by using the elaborate description.
    
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 31f8b2ea358c..ccbac0ed672c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -403,7 +403,7 @@ struct address_space {
 	unsigned long		flags;		/* error bits */
 	spinlock_t		private_lock;	/* for use by the address_space */
 	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
-	struct list_head	private_list;	/* ditto */
+	struct list_head	private_list;	/* for use by the address_space */
 	void			*private_data;	/* ditto */
 	errseq_t		wb_err;
 } __attribute__((aligned(sizeof(long)))) __randomize_layout;

commit 1c9725974074a047f6080eecc62c50a8e840d050
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 1 16:36:30 2017 +0100

    mm: introduce MAP_SHARED_VALIDATE, a mechanism to safely define new mmap flags
    
    The mmap(2) syscall suffers from the ABI anti-pattern of not validating
    unknown flags. However, proposals like MAP_SYNC need a mechanism to
    define new behavior that is known to fail on older kernels without the
    support. Define a new MAP_SHARED_VALIDATE flag pattern that is
    guaranteed to fail on all legacy mmap implementations.
    
    It is worth noting that the original proposal was for a standalone
    MAP_VALIDATE flag. However, when that  could not be supported by all
    archs Linus observed:
    
        I see why you *think* you want a bitmap. You think you want
        a bitmap because you want to make MAP_VALIDATE be part of MAP_SYNC
        etc, so that people can do
    
        ret = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED
                        | MAP_SYNC, fd, 0);
    
        and "know" that MAP_SYNC actually takes.
    
        And I'm saying that whole wish is bogus. You're fundamentally
        depending on special semantics, just make it explicit. It's already
        not portable, so don't try to make it so.
    
        Rename that MAP_VALIDATE as MAP_SHARED_VALIDATE, make it have a value
        of 0x3, and make people do
    
        ret = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED_VALIDATE
                        | MAP_SYNC, fd, 0);
    
        and then the kernel side is easier too (none of that random garbage
        playing games with looking at the "MAP_VALIDATE bit", but just another
        case statement in that map type thing.
    
        Boom. Done.
    
    Similar to ->fallocate() we also want the ability to validate the
    support for new flags on a per ->mmap() 'struct file_operations'
    instance basis.  Towards that end arrange for flags to be generically
    validated against a mmap_supported_flags exported by 'struct
    file_operations'. By default all existing flags are implicitly
    supported, but new flags require MAP_SHARED_VALIDATE and
    per-instance-opt-in.
    
    Cc: Jan Kara <jack@suse.cz>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 13dab191a23e..57added3201d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1701,6 +1701,7 @@ struct file_operations {
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);
+	unsigned long mmap_supported_flags;
 	int (*open) (struct inode *, struct file *);
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 13dab191a23e..885266aae2d7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _LINUX_FS_H
 #define _LINUX_FS_H
 

commit 2ee6a576be56427209d370d8a511d49340c84139
Author: Eric Biggers <ebiggers@google.com>
Date:   Mon Oct 9 12:15:35 2017 -0700

    fs, fscrypt: add an S_ENCRYPTED inode flag
    
    Introduce a flag S_ENCRYPTED which can be set in ->i_flags to indicate
    that the inode is encrypted using the fscrypt (fs/crypto/) mechanism.
    
    Checking this flag will give the same information that
    inode->i_sb->s_cop->is_encrypted(inode) currently does, but will be more
    efficient.  This will be useful for adding higher-level helper functions
    for filesystems to use.  For example we'll be able to replace this:
    
            if (ext4_encrypted_inode(inode)) {
                    ret = fscrypt_get_encryption_info(inode);
                    if (ret)
                            return ret;
                    if (!fscrypt_has_encryption_key(inode))
                            return -ENOKEY;
            }
    
    with this:
    
            ret = fscrypt_require_key(inode);
            if (ret)
                    return ret;
    
    ... since we'll be able to retain the fast path for unencrypted files as
    a single flag check, using an inline function.  This wasn't possible
    before because we'd have had to frequently call through the
    ->i_sb->s_cop->is_encrypted function pointer, even when the encryption
    support was disabled or not being used.
    
    Note: we don't define S_ENCRYPTED to 0 if CONFIG_FS_ENCRYPTION is
    disabled because we want to continue to return an error if an encrypted
    file is accessed without encryption support, rather than pretending that
    it is unencrypted.
    
    Reviewed-by: Chao Yu <yuchao0@huawei.com>
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 339e73742e73..055d2fbf8eca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1853,6 +1853,7 @@ struct super_operations {
 #else
 #define S_DAX		0	/* Make all the DAX code disappear */
 #endif
+#define S_ENCRYPTED	16384	/* Encrypted file (using fs/crypto/) */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -1892,6 +1893,7 @@ static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags
 #define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
 #define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
 #define IS_DAX(inode)		((inode)->i_flags & S_DAX)
+#define IS_ENCRYPTED(inode)	((inode)->i_flags & S_ENCRYPTED)
 
 #define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
 				 (inode)->i_rdev == WHITEOUT_DEV)

commit f175f307dd0bd1ca3825d244f9b870ff12981d3c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 15 00:38:00 2017 -0400

    stubs for mount_bdev() and kill_block_super() in !CONFIG_BLOCK case
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 89323e03e648..31f8b2ea358c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2094,9 +2094,18 @@ struct file_system_type {
 extern struct dentry *mount_ns(struct file_system_type *fs_type,
 	int flags, void *data, void *ns, struct user_namespace *user_ns,
 	int (*fill_super)(struct super_block *, void *, int));
+#ifdef CONFIG_BLOCK
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int));
+#else
+static inline struct dentry *mount_bdev(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data,
+	int (*fill_super)(struct super_block *, void *, int))
+{
+	return ERR_PTR(-ENODEV);
+}
+#endif
 extern struct dentry *mount_single(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int));
@@ -2105,7 +2114,14 @@ extern struct dentry *mount_nodev(struct file_system_type *fs_type,
 	int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);
 void generic_shutdown_super(struct super_block *sb);
+#ifdef CONFIG_BLOCK
 void kill_block_super(struct super_block *sb);
+#else
+static inline void kill_block_super(struct super_block *sb)
+{
+	BUG();
+}
+#endif
 void kill_anon_super(struct super_block *sb);
 void kill_litter_super(struct super_block *sb);
 void deactivate_super(struct super_block *sb);

commit 53fd88ab61948f711147204c1c5017c7301979e9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 14 23:00:54 2017 -0400

    make vfs_ustat() static
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 339e73742e73..89323e03e648 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2169,7 +2169,6 @@ extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 extern int vfs_statfs(const struct path *, struct kstatfs *);
 extern int user_statfs(const char __user *, struct kstatfs *);
 extern int fd_statfs(int, struct kstatfs *);
-extern int vfs_ustat(dev_t, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);

commit 32e57c29e3c038ac802b7cc214a8795a4234055f
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 3 16:16:54 2017 -0700

    include/linux/fs.h: fix comment about struct address_space
    
    Before commit 9c5d760b8d22 ("mm: split gfp_mask and mapping flags into
    separate fields") the private_* fields of struct adrress_space were
    grouped together and using "ditto" in comments describing the last
    fields was correct.
    
    With introduction of gpf_mask between private_lock and private_list
    "ditto" references the wrong description.
    
    Fix it by using the elaborate description.
    
    Link: http://lkml.kernel.org/r/1507009987-8746-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 339e73742e73..13dab191a23e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -403,7 +403,7 @@ struct address_space {
 	unsigned long		flags;		/* error bits */
 	spinlock_t		private_lock;	/* for use by the address_space */
 	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
-	struct list_head	private_list;	/* ditto */
+	struct list_head	private_list;	/* for use by the address_space */
 	void			*private_data;	/* ditto */
 	errseq_t		wb_err;
 } __attribute__((aligned(sizeof(long)))) __randomize_layout;

commit 003278e431bffa4070d18c821eff1d95867f24db
Author: Corentin Labbe <clabbe.montjoie@gmail.com>
Date:   Tue Sep 26 09:14:07 2017 +0200

    nfs_common: convert int to bool
    
    Since __state_in_grace return only true/false, make it return bool
    instead of int.
    Same change for the two user of it, locks_in_grace/opens_in_grace
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 339e73742e73..8cc0493c7c39 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -970,8 +970,8 @@ struct lock_manager {
 struct net;
 void locks_start_grace(struct net *, struct lock_manager *);
 void locks_end_grace(struct lock_manager *);
-int locks_in_grace(struct net *);
-int opens_in_grace(struct net *);
+bool locks_in_grace(struct net *);
+bool opens_in_grace(struct net *);
 
 /* that will die - we need it for nfs_lock_info */
 #include <linux/nfs_fs_i.h>

commit 711aab1dbb324d321e3d84368a435a78908c7bce
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Sep 12 22:45:33 2017 -0400

    vfs: constify path argument to kernel_read_file_from_path
    
    This patch constifies the path argument to kernel_read_file_from_path().
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bc475dfeb4ce..339e73742e73 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2815,7 +2815,7 @@ static inline const char *kernel_read_file_id_str(enum kernel_read_file_id id)
 
 extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
 			    enum kernel_read_file_id);
-extern int kernel_read_file_from_path(char *, void **, loff_t *, loff_t,
+extern int kernel_read_file_from_path(const char *, void **, loff_t *, loff_t,
 				      enum kernel_read_file_id);
 extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
 				    enum kernel_read_file_id);

commit e253d98f5babbec7e6ced810f7335b265a7f7e83
Merge: 0f0d12728e56 c35fc7a5abae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 19:29:55 2017 -0700

    Merge branch 'work.read_write' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull nowait read support from Al Viro:
     "Support IOCB_NOWAIT for buffered reads and block devices"
    
    * 'work.read_write' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      block_dev: support RFW_NOWAIT on block device nodes
      fs: support RWF_NOWAIT for buffered reads
      fs: support IOCB_NOWAIT in generic_file_buffered_read
      fs: pass iocb to do_generic_file_read

commit 0f0d12728e56c94d3289c6831243b6faeae8a19d
Merge: 581bfce969cb e462ec50cb5f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 18:54:01 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull mount flag updates from Al Viro:
     "Another chunk of fmount preparations from dhowells; only trivial
      conflicts for that part. It separates MS_... bits (very grotty
      mount(2) ABI) from the struct super_block ->s_flags (kernel-internal,
      only a small subset of MS_... stuff).
    
      This does *not* convert the filesystems to new constants; only the
      infrastructure is done here. The next step in that series is where the
      conflicts would be; that's the conversion of filesystems. It's purely
      mechanical and it's better done after the merge, so if you could run
      something like
    
            list=$(for i in MS_RDONLY MS_NOSUID MS_NODEV MS_NOEXEC MS_SYNCHRONOUS MS_MANDLOCK MS_DIRSYNC MS_NOATIME MS_NODIRATIME MS_SILENT MS_POSIXACL MS_KERNMOUNT MS_I_VERSION MS_LAZYTIME; do git grep -l $i fs drivers/staging/lustre drivers/mtd ipc mm include/linux; done|sort|uniq|grep -v '^fs/namespace.c$')
    
            sed -i -e 's/\<MS_RDONLY\>/SB_RDONLY/g' \
                    -e 's/\<MS_NOSUID\>/SB_NOSUID/g' \
                    -e 's/\<MS_NODEV\>/SB_NODEV/g' \
                    -e 's/\<MS_NOEXEC\>/SB_NOEXEC/g' \
                    -e 's/\<MS_SYNCHRONOUS\>/SB_SYNCHRONOUS/g' \
                    -e 's/\<MS_MANDLOCK\>/SB_MANDLOCK/g' \
                    -e 's/\<MS_DIRSYNC\>/SB_DIRSYNC/g' \
                    -e 's/\<MS_NOATIME\>/SB_NOATIME/g' \
                    -e 's/\<MS_NODIRATIME\>/SB_NODIRATIME/g' \
                    -e 's/\<MS_SILENT\>/SB_SILENT/g' \
                    -e 's/\<MS_POSIXACL\>/SB_POSIXACL/g' \
                    -e 's/\<MS_KERNMOUNT\>/SB_KERNMOUNT/g' \
                    -e 's/\<MS_I_VERSION\>/SB_I_VERSION/g' \
                    -e 's/\<MS_LAZYTIME\>/SB_LAZYTIME/g' \
                    $list
    
      and commit it with something along the lines of 'convert filesystems
      away from use of MS_... constants' as commit message, it would save a
      quite a bit of headache next cycle"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      VFS: Differentiate mount flags (MS_*) from internal superblock flags
      VFS: Convert sb->s_flags & MS_RDONLY to sb_rdonly(sb)
      vfs: Add sb_rdonly(sb) to query the MS_RDONLY flag on s_flags

commit 581bfce969cbfc7ce43ee92273be9cb7c3fdfa61
Merge: cc73fee0bae2 9725d4cef622
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 14 18:13:32 2017 -0700

    Merge branch 'work.set_fs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more set_fs removal from Al Viro:
     "Christoph's 'use kernel_read and friends rather than open-coding
      set_fs()' series"
    
    * 'work.set_fs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: unexport vfs_readv and vfs_writev
      fs: unexport vfs_read and vfs_write
      fs: unexport __vfs_read/__vfs_write
      lustre: switch to kernel_write
      gadget/f_mass_storage: stop messing with the address limit
      mconsole: switch to kernel_read
      btrfs: switch write_buf to kernel_write
      net/9p: switch p9_fd_read to kernel_write
      mm/nommu: switch do_mmap_private to kernel_read
      serial2002: switch serial2002_tty_write to kernel_{read/write}
      fs: make the buf argument to __kernel_write a void pointer
      fs: fix kernel_write prototype
      fs: fix kernel_read prototype
      fs: move kernel_read to fs/read_write.c
      fs: move kernel_write to fs/read_write.c
      autofs4: switch autofs4_write to __kernel_write
      ashmem: switch to ->read_iter

commit c353f88f3de485a059e5c003721e2dc276d02fad
Merge: 6d8ef53e8b2f 939ae4efd51c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 13 09:11:44 2017 -0700

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This fixes d_ino correctness in readdir, which brings overlayfs on par
      with normal filesystems regarding inode number semantics, as long as
      all layers are on the same filesystem.
    
      There are also some bug fixes, one in particular (random ioctl's
      shouldn't be able to modify lower layers) that touches some vfs code,
      but of course no-op for non-overlay fs"
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: fix false positive ESTALE on lookup
      ovl: don't allow writing ioctl on lower layer
      ovl: fix relatime for directories
      vfs: add flags to d_real()
      ovl: cleanup d_real for negative
      ovl: constant d_ino for non-merge dirs
      ovl: constant d_ino across copy up
      ovl: fix readdir error value
      ovl: check snprintf return

commit 42f46148217865a545e129612075f3d828a2c4e4
Author: Ian Kent <raven@themaw.net>
Date:   Fri Sep 8 16:16:24 2017 -0700

    autofs: fix AT_NO_AUTOMOUNT not being honored
    
    The fstatat(2) and statx() calls can pass the flag AT_NO_AUTOMOUNT which
    is meant to clear the LOOKUP_AUTOMOUNT flag and prevent triggering of an
    automount by the call.  But this flag is unconditionally cleared for all
    stat family system calls except statx().
    
    stat family system calls have always triggered mount requests for the
    negative dentry case in follow_automount() which is intended but prevents
    the fstatat(2) and statx() AT_NO_AUTOMOUNT case from being handled.
    
    In order to handle the AT_NO_AUTOMOUNT for both system calls the negative
    dentry case in follow_automount() needs to be changed to return ENOENT
    when the LOOKUP_AUTOMOUNT flag is clear (and the other required flags are
    clear).
    
    AFAICT this change doesn't have any noticable side effects and may, in
    some use cases (although I didn't see it in testing) prevent unnecessary
    callbacks to the automount daemon.
    
    It's also possible that a stat family call has been made with a path that
    is in the process of being mounted by some other process.  But stat family
    calls should return the automount state of the path as it is "now" so it
    shouldn't wait for mount completion.
    
    This is the same semantic as the positive dentry case already handled.
    
    Link: http://lkml.kernel.org/r/150216641255.11652.4204561328197919771.stgit@pluto.themaw.net
    Fixes: deccf497d804a4c5fca ("Make stat/lstat/fstatat pass AT_NO_AUTOMOUNT to vfs_statx()")
    Signed-off-by: Ian Kent <raven@themaw.net>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Colin Walters <walters@redhat.com>
    Cc: Ondrej Holy <oholy@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6111976848ff..2d0e6748e46e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3043,8 +3043,7 @@ static inline int vfs_lstat(const char __user *name, struct kstat *stat)
 static inline int vfs_fstatat(int dfd, const char __user *filename,
 			      struct kstat *stat, int flags)
 {
-	return vfs_statx(dfd, filename, flags | AT_NO_AUTOMOUNT,
-			 stat, STATX_BASIC_STATS);
+	return vfs_statx(dfd, filename, flags, stat, STATX_BASIC_STATS);
 }
 static inline int vfs_fstat(int fd, struct kstat *stat)
 {

commit f808c13fd3738948e10196496959871130612b61
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Sep 8 16:15:08 2017 -0700

    lib/interval_tree: fast overlap detection
    
    Allow interval trees to quickly check for overlaps to avoid unnecesary
    tree lookups in interval_tree_iter_first().
    
    As of this patch, all interval tree flavors will require using a
    'rb_root_cached' such that we can have the leftmost node easily
    available.  While most users will make use of this feature, those with
    special functions (in addition to the generic insert, delete, search
    calls) will avoid using the cached option as they can do funky things
    with insertions -- for example, vma_interval_tree_insert_after().
    
    [jglisse@redhat.com: fix deadlock from typo vm_lock_anon_vma()]
      Link: http://lkml.kernel.org/r/20170808225719.20723-1-jglisse@redhat.com
    Link: http://lkml.kernel.org/r/20170719014603.19029-12-dave@stgolabs.net
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Signed-off-by: Jrme Glisse <jglisse@redhat.com>
    Acked-by: Christian Knig <christian.koenig@amd.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Acked-by: Doug Ledford <dledford@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Jason Wang <jasowang@redhat.com>
    Cc: Christian Benvenuti <benve@cisco.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 509434aaf5a4..6111976848ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -392,7 +392,7 @@ struct address_space {
 	struct radix_tree_root	page_tree;	/* radix tree of all pages */
 	spinlock_t		tree_lock;	/* and lock protecting it */
 	atomic_t		i_mmap_writable;/* count VM_SHARED mappings */
-	struct rb_root		i_mmap;		/* tree of private and shared mappings */
+	struct rb_root_cached	i_mmap;		/* tree of private and shared mappings */
 	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
 	/* Protected by tree_lock together with the radix tree */
 	unsigned long		nrpages;	/* number of total pages */
@@ -487,7 +487,7 @@ static inline void i_mmap_unlock_read(struct address_space *mapping)
  */
 static inline int mapping_mapped(struct address_space *mapping)
 {
-	return	!RB_EMPTY_ROOT(&mapping->i_mmap);
+	return	!RB_EMPTY_ROOT(&mapping->i_mmap.rb_root);
 }
 
 /*

commit ae8ac6b7dbfd67f883050421fd195c153d02f5f3
Merge: 460352c2f18e 6c83fd5142c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 15:19:35 2017 -0700

    Merge branch 'quota_scaling' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull quota scaling updates from Jan Kara:
     "This contains changes to make the quota subsystem more scalable.
    
      Reportedly it improves number of files created per second on ext4
      filesystem on fast storage by about a factor of 2x"
    
    * 'quota_scaling' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs: (28 commits)
      quota: Add lock annotations to struct members
      quota: Reduce contention on dq_data_lock
      fs: Provide __inode_get_bytes()
      quota: Inline dquot_[re]claim_reserved_space() into callsite
      quota: Inline inode_{incr,decr}_space() into callsites
      quota: Inline functions into their callsites
      ext4: Disable dirty list tracking of dquots when journalling quotas
      quota: Allow disabling tracking of dirty dquots in a list
      quota: Remove dq_wait_unused from dquot
      quota: Move locking into clear_dquot_dirty()
      quota: Do not dirty bad dquots
      quota: Fix possible corruption of dqi_flags
      quota: Propagate ->quota_read errors from v2_read_file_info()
      quota: Fix error codes in v2_read_file_info()
      quota: Push dqio_sem down to ->read_file_info()
      quota: Push dqio_sem down to ->write_file_info()
      quota: Push dqio_sem down to ->get_next_id()
      quota: Push dqio_sem down to ->release_dqblk()
      quota: Remove locking for writing to the old quota format
      quota: Do not acquire dqio_sem for dquot overwrites in v2 format
      ...

commit a0725ab0c7536076d5477264420ef420ebb64501
Merge: 3ee31b89d9b1 ef13ecbc134d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 7 11:59:42 2017 -0700

    Merge branch 'for-4.14/block' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
     "This is the first pull request for 4.14, containing most of the code
      changes. It's a quiet series this round, which I think we needed after
      the churn of the last few series. This contains:
    
       - Fix for a registration race in loop, from Anton Volkov.
    
       - Overflow complaint fix from Arnd for DAC960.
    
       - Series of drbd changes from the usual suspects.
    
       - Conversion of the stec/skd driver to blk-mq. From Bart.
    
       - A few BFQ improvements/fixes from Paolo.
    
       - CFQ improvement from Ritesh, allowing idling for group idle.
    
       - A few fixes found by Dan's smatch, courtesy of Dan.
    
       - A warning fixup for a race between changing the IO scheduler and
         device remova. From David Jeffery.
    
       - A few nbd fixes from Josef.
    
       - Support for cgroup info in blktrace, from Shaohua.
    
       - Also from Shaohua, new features in the null_blk driver to allow it
         to actually hold data, among other things.
    
       - Various corner cases and error handling fixes from Weiping Zhang.
    
       - Improvements to the IO stats tracking for blk-mq from me. Can
         drastically improve performance for fast devices and/or big
         machines.
    
       - Series from Christoph removing bi_bdev as being needed for IO
         submission, in preparation for nvme multipathing code.
    
       - Series from Bart, including various cleanups and fixes for switch
         fall through case complaints"
    
    * 'for-4.14/block' of git://git.kernel.dk/linux-block: (162 commits)
      kernfs: checking for IS_ERR() instead of NULL
      drbd: remove BIOSET_NEED_RESCUER flag from drbd_{md_,}io_bio_set
      drbd: Fix allyesconfig build, fix recent commit
      drbd: switch from kmalloc() to kmalloc_array()
      drbd: abort drbd_start_resync if there is no connection
      drbd: move global variables to drbd namespace and make some static
      drbd: rename "usermode_helper" to "drbd_usermode_helper"
      drbd: fix race between handshake and admin disconnect/down
      drbd: fix potential deadlock when trying to detach during handshake
      drbd: A single dot should be put into a sequence.
      drbd: fix rmmod cleanup, remove _all_ debugfs entries
      drbd: Use setup_timer() instead of init_timer() to simplify the code.
      drbd: fix potential get_ldev/put_ldev refcount imbalance during attach
      drbd: new disk-option disable-write-same
      drbd: Fix resource role for newly created resources in events2
      drbd: mark symbols static where possible
      drbd: Send P_NEG_ACK upon write error in protocol != C
      drbd: add explicit plugging when submitting batches
      drbd: change list_for_each_safe to while(list_first_entry_or_null)
      drbd: introduce drbd_recv_header_maybe_unplug
      ...

commit d34fc1adf01ff87026da85fb972dc259dc347540
Merge: 1c9fe4409ce3 d2cd9ede6e19
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 6 20:49:49 2017 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge updates from Andrew Morton:
    
     - various misc bits
    
     - DAX updates
    
     - OCFS2
    
     - most of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (119 commits)
      mm,fork: introduce MADV_WIPEONFORK
      x86,mpx: make mpx depend on x86-64 to free up VMA flag
      mm: add /proc/pid/smaps_rollup
      mm: hugetlb: clear target sub-page last when clearing huge page
      mm: oom: let oom_reap_task and exit_mmap run concurrently
      swap: choose swap device according to numa node
      mm: replace TIF_MEMDIE checks by tsk_is_oom_victim
      mm, oom: do not rely on TIF_MEMDIE for memory reserves access
      z3fold: use per-cpu unbuddied lists
      mm, swap: don't use VMA based swap readahead if HDD is used as swap
      mm, swap: add sysfs interface for VMA based swap readahead
      mm, swap: VMA based swap readahead
      mm, swap: fix swap readahead marking
      mm, swap: add swap readahead hit statistics
      mm/vmalloc.c: don't reinvent the wheel but use existing llist API
      mm/vmstat.c: fix wrong comment
      selftests/memfd: add memfd_create hugetlbfs selftest
      mm/shmem: add hugetlbfs support to memfd_create()
      mm, devm_memremap_pages: use multi-order radix for ZONE_DEVICE lookups
      mm/vmalloc.c: halve the number of comparisons performed in pcpu_get_vm_areas()
      ...

commit a446d6f9ce545248c62ab9694d05ac6f68563706
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Sep 6 16:23:22 2017 -0700

    include/linux/fs.h: remove unneeded forward definition of mm_struct
    
    Link: http://lkml.kernel.org/r/20170525102927.6163-1-jlayton@redhat.com
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc2e0f5a8fd1..baea880c5c03 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1270,8 +1270,6 @@ extern void f_delown(struct file *filp);
 extern pid_t f_getown(struct file *filp);
 extern int send_sigurg(struct fown_struct *fown);
 
-struct mm_struct;
-
 /*
  *	Umount options
  */

commit ec3604c7a5aae8953545b0d05495357009a960e5
Merge: 066dea8c30ae 6d4b51241394
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 6 14:11:03 2017 -0700

    Merge tag 'wberr-v4.14-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux
    
    Pull writeback error handling updates from Jeff Layton:
     "This pile continues the work from last cycle on better tracking
      writeback errors. In v4.13 we added some basic errseq_t infrastructure
      and converted a few filesystems to use it.
    
      This set continues refining that infrastructure, adds documentation,
      and converts most of the other filesystems to use it. The main
      exception at this point is the NFS client"
    
    * tag 'wberr-v4.14-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux:
      ecryptfs: convert to file_write_and_wait in ->fsync
      mm: remove optimizations based on i_size in mapping writeback waits
      fs: convert a pile of fsync routines to errseq_t based reporting
      gfs2: convert to errseq_t based writeback error reporting for fsync
      fs: convert sync_file_range to use errseq_t based error-tracking
      mm: add file_fdatawait_range and file_write_and_wait
      fuse: convert to errseq_t based error tracking for fsync
      mm: consolidate dax / non-dax checks for writeback
      Documentation: add some docs for errseq_t
      errseq: rename __errseq_set to errseq_set

commit 066dea8c30ae7d8e061145bcf5422ce0773582eb
Merge: c7f396f12fb3 3953704fde7e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 6 13:43:26 2017 -0700

    Merge tag 'locks-v4.14-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux
    
    Pull file locking updates from Jeff Layton:
     "This pile just has a few file locking fixes from Ben Coddington. There
      are a couple of cleanup patches + an attempt to bring sanity to the
      l_pid value that is reported back to userland on an F_GETLK request.
    
      After a few gyrations, he came up with a way for filesystems to
      communicate to the VFS layer code whether the pid should be translated
      according to the namespace or presented as-is to userland"
    
    * tag 'locks-v4.14-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux:
      locks: restore a warn for leaked locks on close
      fs/locks: Remove fl_nspid and use fs-specific l_pid for remote locks
      fs/locks: Use allocation rather than the stack in fcntl_getlk()

commit 5791577963426c5a2db51fff57e9fcd72061e2c3
Merge: 77d0ab600af4 6c370590cfe0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 6 12:19:23 2017 -0700

    Merge tag 'xfs-4.14-merge-7' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux
    
    Pull XFS updates from Darrick Wong:
     "Here are the changes for xfs for 4.14. Most of these are cleanups and
      fixes for bad behavior, as we're mostly focusing on improving
      reliablity this cycle (read: there's potentially a lot of stuff on the
      horizon for 4.15 so better to spend a few weeks killing other bugs
      now).
    
      Summary:
    
       - Write unmount record for a ro mount to avoid unnecessary log replay
    
       - Clean up orphaned inodes when mounting fs readonly
    
       - Resubmit inode log items when buffer writeback fails to avoid
         umount hang
    
       - Fix log recovery corruption problems when log headers wrap around
         the end
    
       - Avoid infinite loop searching for free inodes when inode counters
         are wrong
    
       - Evict inodes involved with log redo so that we don't leak them
         later
    
       - Fix a potential race between reclaim and inode cluster freeing
    
       - Refactor the inode joining code w.r.t. transaction rolling &
         deferred ops
    
       - Fix a bug where the log doesn't properly deal with dirty buffers
         that are about to become ordered buffers
    
       - Fix the extent swap code to deal with making dirty buffers ordered
         properly
    
       - Consolidate page fault handlers
    
       - Refactor the incore extent manipulation functions to use the iext
         abstractions instead of directly modifying with extent data
    
       - Disable crashy chattr +/-x until we fix it
    
       - Don't allow us to set S_DAX for v2 inodes
    
       - Various cleanups
    
       - Clarify some documentation
    
       - Fix a problem where fsync and a log commit race to send the disk a
         flush command, resulting in a small window where power fail data
         loss could occur
    
       - Simplify some rmap operations in the fcollapse code
    
       - Fix some use-after-free problems in async writeback"
    
    * tag 'xfs-4.14-merge-7' of git://git.kernel.org/pub/scm/fs/xfs/xfs-linux: (44 commits)
      xfs: use kmem_free to free return value of kmem_zalloc
      xfs: open code end_buffer_async_write in xfs_finish_page_writeback
      xfs: don't set v3 xflags for v2 inodes
      xfs: fix compiler warnings
      fsmap: fix documentation of FMR_OF_LAST
      xfs: simplify the rmap code in xfs_bmse_merge
      xfs: remove unused flags arg from xfs_file_iomap_begin_delay
      xfs: fix incorrect log_flushed on fsync
      xfs: disable per-inode DAX flag
      xfs: replace xfs_qm_get_rtblks with a direct call to xfs_bmap_count_leaves
      xfs: rewrite xfs_bmap_count_leaves using xfs_iext_get_extent
      xfs: use xfs_iext_*_extent helpers in xfs_bmap_split_extent_at
      xfs: use xfs_iext_*_extent helpers in xfs_bmap_shift_extents
      xfs: move some code around inside xfs_bmap_shift_extents
      xfs: use xfs_iext_get_extent in xfs_bmap_first_unused
      xfs: switch xfs_bmap_local_to_extents to use xfs_iext_insert
      xfs: add a xfs_iext_update_extent helper
      xfs: consolidate the various page fault handlers
      iomap: return VM_FAULT_* codes from iomap_page_mkwrite
      xfs: relog dirty buffers during swapext bmbt owner change
      ...

commit bafb0762cb6a906eb4105cccfb3bcd90be7f40d2
Merge: 44b1671fae88 3a6430ce4621
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 11:08:17 2017 -0700

    Merge tag 'char-misc-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here is the big char/misc driver update for 4.14-rc1.
    
      Lots of different stuff in here, it's been an active development cycle
      for some reason. Highlights are:
    
       - updated binder driver, this brings binder up to date with what
         shipped in the Android O release, plus some more changes that
         happened since then that are in the Android development trees.
    
       - coresight updates and fixes
    
       - mux driver file renames to be a bit "nicer"
    
       - intel_th driver updates
    
       - normal set of hyper-v updates and changes
    
       - small fpga subsystem and driver updates
    
       - lots of const code changes all over the driver trees
    
       - extcon driver updates
    
       - fmc driver subsystem upadates
    
       - w1 subsystem minor reworks and new features and drivers added
    
       - spmi driver updates
    
      Plus a smattering of other minor driver updates and fixes.
    
      All of these have been in linux-next with no reported issues for a
      while"
    
    * tag 'char-misc-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (244 commits)
      ANDROID: binder: don't queue async transactions to thread.
      ANDROID: binder: don't enqueue death notifications to thread todo.
      ANDROID: binder: Don't BUG_ON(!spin_is_locked()).
      ANDROID: binder: Add BINDER_GET_NODE_DEBUG_INFO ioctl
      ANDROID: binder: push new transactions to waiting threads.
      ANDROID: binder: remove proc waitqueue
      android: binder: Add page usage in binder stats
      android: binder: fixup crash introduced by moving buffer hdr
      drivers: w1: add hwmon temp support for w1_therm
      drivers: w1: refactor w1_slave_show to make the temp reading functionality separate
      drivers: w1: add hwmon support structures
      eeprom: idt_89hpesx: Support both ACPI and OF probing
      mcb: Fix an error handling path in 'chameleon_parse_cells()'
      MCB: add support for SC31 to mcb-lpc
      mux: make device_type const
      char: virtio: constify attribute_group structures.
      Documentation/ABI: document the nvmem sysfs files
      lkdtm: fix spelling mistake: "incremeted" -> "incremented"
      perf: cs-etm: Fix ETMv4 CONFIGR entry in perf.data file
      nvmem: include linux/err.h from header
      ...

commit 9725d4cef62229b4ec4c912e0db0761e7d400650
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 1 17:39:25 2017 +0200

    fs: unexport vfs_readv and vfs_writev
    
    We've got no modular users left, and any potential modular user is better
    of with iov_iter based variants.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f24b821cee8d..355cf02830a0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1758,8 +1758,6 @@ extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *, int);
-extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *, int);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
 extern int vfs_clone_file_prep_inodes(struct inode *inode_in, loff_t pos_in,

commit eb031849d52e61d24ba54e9d27553189ff328174
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 1 17:39:23 2017 +0200

    fs: unexport __vfs_read/__vfs_write
    
    No modular users left, and any new ones should use kernel_read/write
    or iov_iter variants instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab7e2bf7dd1..f24b821cee8d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1754,7 +1754,6 @@ ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      struct iovec **ret_pointer);
 
 extern ssize_t __vfs_read(struct file *, char __user *, size_t, loff_t *);
-extern ssize_t __vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,

commit 73e18f7c0b3e1432353cdd86672c27cace7e6a7e
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 1 17:39:15 2017 +0200

    fs: make the buf argument to __kernel_write a void pointer
    
    This matches kernel_read and kernel_write and avoids any need for casts in
    the callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0e7d3da8a307..9ab7e2bf7dd1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2780,7 +2780,7 @@ extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
 				    enum kernel_read_file_id);
 extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);
 extern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);
-extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
+extern ssize_t __kernel_write(struct file *, const void *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */

commit e13ec939e96b13e664bb6cee361cc976a0ee621a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 1 17:39:14 2017 +0200

    fs: fix kernel_write prototype
    
    Make the position an in/out argument like all the other read/write
    helpers and and make the buf argument a void pointer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2ba8f38a4d63..0e7d3da8a307 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2779,7 +2779,7 @@ extern int kernel_read_file_from_path(char *, void **, loff_t *, loff_t,
 extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
 				    enum kernel_read_file_id);
 extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);
-extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
+extern ssize_t kernel_write(struct file *, const void *, size_t, loff_t *);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
  

commit bdd1d2d3d251c65b74ac4493e08db18971c09240
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 1 17:39:13 2017 +0200

    fs: fix kernel_read prototype
    
    Use proper ssize_t and size_t types for the return value and count
    argument, move the offset last and make it an in/out argument like
    all other read/write helpers, and make the buf argument a void pointer
    to get rid of lots of casts in the callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cbfe127bccf8..2ba8f38a4d63 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2772,13 +2772,13 @@ static inline const char *kernel_read_file_id_str(enum kernel_read_file_id id)
 	return kernel_read_file_str[id];
 }
 
-extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
 			    enum kernel_read_file_id);
 extern int kernel_read_file_from_path(char *, void **, loff_t *, loff_t,
 				      enum kernel_read_file_id);
 extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
 				    enum kernel_read_file_id);
+extern ssize_t kernel_read(struct file *, void *, size_t, loff_t *);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);

commit 91f9943e1c7b6638f27312d03fe71fcc67b23571
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Aug 29 16:13:20 2017 +0200

    fs: support RWF_NOWAIT for buffered reads
    
    This is based on the old idea and code from Milosz Tanski.  With the aio
    nowait code it becomes mostly trivial now.  Buffered writes continue to
    return -EOPNOTSUPP if RWF_NOWAIT is passed.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cbfe127bccf8..94582c379dac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -146,8 +146,8 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x4000000)
 
-/* File is capable of returning -EAGAIN if AIO will block */
-#define FMODE_AIO_NOWAIT	((__force fmode_t)0x8000000)
+/* File is capable of returning -EAGAIN if I/O will block */
+#define FMODE_NOWAIT	((__force fmode_t)0x8000000)
 
 /*
  * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
@@ -3149,7 +3149,7 @@ static inline int kiocb_set_rw_flags(struct kiocb *ki, int flags)
 		return -EOPNOTSUPP;
 
 	if (flags & RWF_NOWAIT) {
-		if (!(ki->ki_filp->f_mode & FMODE_AIO_NOWAIT))
+		if (!(ki->ki_filp->f_mode & FMODE_NOWAIT))
 			return -EOPNOTSUPP;
 		ki->ki_flags |= IOCB_NOWAIT;
 	}

commit 495e642939114478a5237a7d91661ba93b76f15a
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Sep 4 21:42:22 2017 +0200

    vfs: add flags to d_real()
    
    Add a separate flags argument (in addition to the open flags) to control
    the behavior of d_real().
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e1fd5d21248..ee1db83c39cb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1233,7 +1233,7 @@ static inline struct inode *file_inode(const struct file *f)
 
 static inline struct dentry *file_dentry(const struct file *file)
 {
-	return d_real(file->f_path.dentry, file_inode(file), 0);
+	return d_real(file->f_path.dentry, file_inode(file), 0, 0);
 }
 
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)

commit 799ea9e9c59949008770aab4e1da87f10e99dbe4
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Fri Aug 18 18:08:25 2017 -0700

    xfs: evict all inodes involved with log redo item
    
    When we introduced the bmap redo log items, we set MS_ACTIVE on the
    mountpoint and XFS_IRECOVERY on the inode to prevent unlinked inodes
    from being truncated prematurely during log recovery.  This also had the
    effect of putting linked inodes on the lru instead of evicting them.
    
    Unfortunately, we neglected to find all those unreferenced lru inodes
    and evict them after finishing log recovery, which means that we leak
    them if anything goes wrong in the rest of xfs_mountfs, because the lru
    is only cleaned out on unmount.
    
    Therefore, evict unreferenced inodes in the lru list immediately
    after clearing MS_ACTIVE.
    
    Fixes: 17c12bcd30 ("xfs: when replaying bmap operations, don't let unlinked inodes get reaped")
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Cc: viro@ZenIV.linux.org.uk
    Reviewed-by: Brian Foster <bfoster@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e1fd5d21248..00f46e018370 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2831,6 +2831,7 @@ static inline void lockdep_annotate_inode_mutex_key(struct inode *inode) { };
 #endif
 extern void unlock_new_inode(struct inode *);
 extern unsigned int get_next_ino(void);
+extern void evict_inodes(struct super_block *sb);
 
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);

commit ddef7ed2b5cbafae692d1d580bb5a07808926a9c
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jul 6 18:58:37 2017 +0200

    annotate RWF_... flags
    
    [AV: added missing annotations in syscalls.h/compat.h]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cbfe127bccf8..2625fc47c7e5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -72,6 +72,8 @@ extern int leases_enable, lease_break_time;
 extern int sysctl_protected_symlinks;
 extern int sysctl_protected_hardlinks;
 
+typedef __kernel_rwf_t rwf_t;
+
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
@@ -1758,9 +1760,9 @@ extern ssize_t __vfs_write(struct file *, const char __user *, size_t, loff_t *)
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *, int);
+		unsigned long, loff_t *, rwf_t);
 extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *, int);
+		unsigned long, loff_t *, rwf_t);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
 extern int vfs_clone_file_prep_inodes(struct inode *inode_in, loff_t pos_in,
@@ -2874,9 +2876,9 @@ extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 
 ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,
-		int flags);
+		rwf_t flags);
 ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,
-		int flags);
+		rwf_t flags);
 
 /* fs/block_dev.c */
 extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);
@@ -3143,7 +3145,7 @@ static inline int iocb_flags(struct file *file)
 	return res;
 }
 
-static inline int kiocb_set_rw_flags(struct kiocb *ki, int flags)
+static inline int kiocb_set_rw_flags(struct kiocb *ki, rwf_t flags)
 {
 	if (unlikely(flags & ~RWF_SUPPORTED))
 		return -EOPNOTSUPP;

commit 9749c37275cb1f72d309e676642f45eb92724190
Merge: 4f9adc8f91ba cc4a41fe5541
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 28 10:19:01 2017 +0200

    Merge 4.13-rc7 into char-misc-next
    
    We want the binder fix in here as well for testing and merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0cc3b0ec23ce4c69e1e890ed2b8d2fa932b14aad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 27 12:12:25 2017 -0700

    Clarify (and fix) MAX_LFS_FILESIZE macros
    
    We have a MAX_LFS_FILESIZE macro that is meant to be filled in by
    filesystems (and other IO targets) that know they are 64-bit clean and
    don't have any 32-bit limits in their IO path.
    
    It turns out that our 32-bit value for that limit was bogus.  On 32-bit,
    the VM layer is limited by the page cache to only 32-bit index values,
    but our logic for that was confusing and actually wrong.  We used to
    define that value to
    
            (((loff_t)PAGE_SIZE << (BITS_PER_LONG-1))-1)
    
    which is actually odd in several ways: it limits the index to 31 bits,
    and then it limits files so that they can't have data in that last byte
    of a page that has the highest 31-bit index (ie page index 0x7fffffff).
    
    Neither of those limitations make sense.  The index is actually the full
    32 bit unsigned value, and we can use that whole full page.  So the
    maximum size of the file would logically be "PAGE_SIZE << BITS_PER_LONG".
    
    However, we do wan tto avoid the maximum index, because we have code
    that iterates over the page indexes, and we don't want that code to
    overflow.  So the maximum size of a file on a 32-bit host should
    actually be one page less than the full 32-bit index.
    
    So the actual limit is ULONG_MAX << PAGE_SHIFT.  That means that we will
    not actually be using the page of that last index (ULONG_MAX), but we
    can grow a file up to that limit.
    
    The wrong value of MAX_LFS_FILESIZE actually caused problems for Doug
    Nazar, who was still using a 32-bit host, but with a 9.7TB 2 x RAID5
    volume.  It turns out that our old MAX_LFS_FILESIZE was 8TiB (well, one
    byte less), but the actual true VM limit is one page less than 16TiB.
    
    This was invisible until commit c2a9737f45e2 ("vfs,mm: fix a dead loop
    in truncate_inode_pages_range()"), which started applying that
    MAX_LFS_FILESIZE limit to block devices too.
    
    NOTE! On 64-bit, the page index isn't a limiter at all, and the limit is
    actually just the offset type itself (loff_t), which is signed.  But for
    clarity, on 64-bit, just use the maximum signed value, and don't make
    people have to count the number of 'f' characters in the hex constant.
    
    So just use LLONG_MAX for the 64-bit case.  That was what the value had
    been before too, just written out as a hex constant.
    
    Fixes: c2a9737f45e2 ("vfs,mm: fix a dead loop in truncate_inode_pages_range()")
    Reported-and-tested-by: Doug Nazar <nazard@nazar.ca>
    Cc: Andreas Dilger <adilger@dilger.ca>
    Cc: Mark Fasheh <mfasheh@versity.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Dave Kleikamp <shaggy@kernel.org>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e1fd5d21248..cbfe127bccf8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -907,9 +907,9 @@ static inline struct file *get_file(struct file *f)
 /* Page cache limit. The filesystems should put that into their s_maxbytes 
    limits, otherwise bad things can happen in VM. */ 
 #if BITS_PER_LONG==32
-#define MAX_LFS_FILESIZE	(((loff_t)PAGE_SIZE << (BITS_PER_LONG-1))-1)
+#define MAX_LFS_FILESIZE	((loff_t)ULONG_MAX << PAGE_SHIFT)
 #elif BITS_PER_LONG==64
-#define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)
+#define MAX_LFS_FILESIZE 	((loff_t)LLONG_MAX)
 #endif
 
 #define FL_POSIX	1

commit c2ee070fb00365d7841f6661dcdc7fbe6620bdf8
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Aug 23 19:10:31 2017 +0200

    block: cache the partition index in struct block_device
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e1fd5d21248..706dd3a972d2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -427,6 +427,7 @@ struct block_device {
 #endif
 	struct block_device *	bd_contains;
 	unsigned		bd_block_size;
+	u8			bd_partno;
 	struct hd_struct *	bd_part;
 	/* number of times partitions within this device have been opened. */
 	unsigned		bd_part_count;

commit f4a8116a4c8c8f754d0ec1498a2ba4b63d114e6a
Author: Jan Kara <jack@suse.cz>
Date:   Tue Aug 8 09:54:36 2017 +0200

    fs: Provide __inode_get_bytes()
    
    Provide helper __inode_get_bytes() which assumes i_lock is already
    acquired. Quota code will need this to be able to use i_lock to protect
    consistency of quota accounting information and inode usage.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e1fd5d21248..d6e9ab7f184f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2998,6 +2998,10 @@ void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
 void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
+static inline loff_t __inode_get_bytes(struct inode *inode)
+{
+	return (((loff_t)inode->i_blocks) << 9) + inode->i_bytes;
+}
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
 const char *simple_get_link(struct dentry *, struct inode *,

commit ffb959bbdf923b4f89a08a04aba2501b1b16d164
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jul 31 10:29:38 2017 -0400

    mm: remove optimizations based on i_size in mapping writeback waits
    
    Marcelo added this i_size based optimization with a patch in 2004
    (commitid is from the linux-history tree):
    
        commit 765dad09b4ac101a32d87af2bb793c3060497d3c
        Author: Marcelo Tosatti <marcelo.tosatti@cyclades.com>
        Date:   Tue Sep 7 17:51:17 2004 -0700
    
            small wait_on_page_writeback_range() optimization
    
            filemap_fdatawait() calls wait_on_page_writeback_range() with -1
            as "end" parameter.  This is not needed since we know the EOF
            from the inode.  Use that instead.
    
    There may be races here, particularly with clustered or network
    filesystems. It also seems like a bit of a layering violation since
    we're operating on an address_space here, not an inode.
    
    Finally, it's also questionable whether this optimization really helps
    on workloads that we care about. Should we be optimizing for writeback
    vs. truncate races in a codepath where we expect to wait anyway? It
    doesn't seem worth the risk.
    
    Remove this optimization from the filemap_fdatawait codepaths. This
    means that filemap_fdatawait becomes a trivial wrapper around
    filemap_fdatawait_range.
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index af592ca3d509..909210bd6366 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2538,10 +2538,15 @@ extern int invalidate_inode_pages2_range(struct address_space *mapping,
 extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);
-extern int filemap_fdatawait(struct address_space *);
 extern int filemap_fdatawait_keep_errors(struct address_space *mapping);
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
+
+static inline int filemap_fdatawait(struct address_space *mapping)
+{
+	return filemap_fdatawait_range(mapping, 0, LLONG_MAX);
+}
+
 extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
 				  loff_t lend);
 extern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,

commit a823e4589e68996436d16db4ede9a43b646332f9
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jul 28 07:24:43 2017 -0400

    mm: add file_fdatawait_range and file_write_and_wait
    
    Necessary now for gfs2_fsync and sync_file_range, but there will
    eventually be other callers.
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 21e7df1ad613..af592ca3d509 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2544,6 +2544,8 @@ extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
 extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
 				  loff_t lend);
+extern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,
+						loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);
@@ -2552,12 +2554,19 @@ extern int __filemap_fdatawrite_range(struct address_space *mapping,
 extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
 extern int filemap_check_errors(struct address_space *mapping);
-
 extern void __filemap_set_wb_err(struct address_space *mapping, int err);
+
+extern int __must_check file_fdatawait_range(struct file *file, loff_t lstart,
+						loff_t lend);
 extern int __must_check file_check_and_advance_wb_err(struct file *file);
 extern int __must_check file_write_and_wait_range(struct file *file,
 						loff_t start, loff_t end);
 
+static inline int file_write_and_wait(struct file *file)
+{
+	return file_write_and_wait_range(file, 0, LLONG_MAX);
+}
+
 /**
  * filemap_set_wb_err - set a writeback error on an address_space
  * @mapping: mapping in which to set writeback error

commit 80aafd50b6a4fa6b6bba4b451b553d5d221f59ff
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Jul 24 06:22:16 2017 -0400

    Documentation: add some docs for errseq_t
    
    ...and fix up a few comments in the code.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b5d6816542b..21e7df1ad613 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2571,8 +2571,6 @@ extern int __must_check file_write_and_wait_range(struct file *file,
  * When a writeback error occurs, most filesystems will want to call
  * filemap_set_wb_err to record the error in the mapping so that it will be
  * automatically reported whenever fsync is called on the file.
- *
- * FIXME: mention FS_* flag here?
  */
 static inline void filemap_set_wb_err(struct address_space *mapping, int err)
 {

commit 24a81a2c258177ba334838a372651f784953b03a
Merge: 91c17449fe04 520eccdfe187
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Jul 23 19:58:30 2017 -0700

    Merge 4.13-rc2 into char-misc-next
    
    We want the char/misc driver fixes in here as well to handle future
    changes.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e06fdaf40a5c021dd4a2ec797e8b724f07360070
Merge: a90c6ac2b565 8acdf5055974
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 19 08:55:18 2017 -0700

    Merge tag 'gcc-plugins-v4.13-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux
    
    Pull structure randomization updates from Kees Cook:
     "Now that IPC and other changes have landed, enable manual markings for
      randstruct plugin, including the task_struct.
    
      This is the rest of what was staged in -next for the gcc-plugins, and
      comes in three patches, largest first:
    
       - mark "easy" structs with __randomize_layout
    
       - mark task_struct with an optional anonymous struct to isolate the
         __randomize_layout section
    
       - mark structs to opt _out_ of automated marking (which will come
         later)
    
      And, FWIW, this continues to pass allmodconfig (normal and patched to
      enable gcc-plugins) builds of x86_64, i386, arm64, arm, powerpc, and
      s390 for me"
    
    * tag 'gcc-plugins-v4.13-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/kees/linux:
      randstruct: opt-out externally exposed function pointer structs
      task_struct: Allow randomized layout
      randstruct: Mark various structs for randomization

commit 133d55cdb2f1f9e258d6dc34594a6c565f10b3fd
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Fri Jun 16 17:48:21 2017 -0600

    block: order /proc/devices by major number
    
    Presently, the order of the block devices listed in /proc/devices is not
    entirely sequential. If a block device has a major number greater than
    BLKDEV_MAJOR_HASH_SIZE (255), it will be ordered as if its major were
    module 255. For example, 511 appears after 1.
    
    This patch cleans that up and prints each major number in the correct
    order, regardless of where they are stored in the hash table.
    
    In order to do this, we introduce BLKDEV_MAJOR_MAX as an artificial
    limit (chosen to be 512). It will then print all devices in major
    order number from 0 to the maximum.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Jeff Layton <jlayton@poochiereds.net>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b07433c335ca..570dcc61fda6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2503,14 +2503,14 @@ static inline void unregister_chrdev(unsigned int major, const char *name)
 #define BDEVT_SIZE	10	/* Largest string for MAJ:MIN for blkdev */
 
 #ifdef CONFIG_BLOCK
-#define BLKDEV_MAJOR_HASH_SIZE	255
+#define BLKDEV_MAJOR_MAX	512
 extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern void blkdev_show(struct seq_file *,off_t);
 
 #else
-#define BLKDEV_MAJOR_HASH_SIZE	0
+#define BLKDEV_MAJOR_MAX	0
 #endif
 
 extern void init_special_inode(struct inode *, umode_t, dev_t);

commit 8a932f73e5b4227bf787474b44dc70b6961d6246
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Jun 15 14:05:21 2017 -0600

    char_dev: order /proc/devices by major number
    
    Presently, the order of the char devices listed in /proc/devices is not
    entirely sequential. If a char device has a major number greater than
    CHRDEV_MAJOR_HASH_SIZE (255), it will be ordered as if its major were
    module 255. For example, 511 appears after 1.
    
    This patch cleans that up and prints each major number in the correct
    order, regardless of where they are stored in the hash table.
    
    In order to do this, we introduce CHRDEV_MAJOR_MAX as an artificial
    limit (chosen to be 511). It will then print all devices in major
    order number from 0 to the maximum.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1773dcf1e318..b07433c335ca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2470,7 +2470,7 @@ static inline void bd_unlink_disk_holder(struct block_device *bdev,
 #endif
 
 /* fs/char_dev.c */
-#define CHRDEV_MAJOR_HASH_SIZE	255
+#define CHRDEV_MAJOR_MAX 512
 /* Marks the bottom of the first segment of free char majors */
 #define CHRDEV_MAJOR_DYN_END 234
 /* Marks the top and bottom of the second segment of free char majors */

commit a5d31a3f81c6fb13b381951bf6163444c0257e8b
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Jun 15 14:05:20 2017 -0600

    char_dev: extend dynamic allocation of majors into a higher range
    
    We've run into problems with running out of dynamicly assign char
    device majors particullarly on automated test systems with
    all-yes-configs. Roughly 40 dynamic assignments can be made with such
    kernels at this time while space is reserved for only 20.
    
    Currently, the kernel only prints a warning when dynamic allocation
    overflows the reserved region. And when this happens drivers that have
    fixed assignments can randomly fail depending on the order of
    initialization of other drivers. Thus, adding a new char device can cause
    unexpected failures in completely unrelated parts of the kernel.
    
    This patch solves the problem by extending dynamic major number
    allocations down from 511 once the 234-254 region fills up. Fixed
    majors already exist above 255 so the infrastructure to support
    high number majors is already in place. The patch reserves an
    additional 128 major numbers which should hopefully last us a while.
    
    Kernels that don't require more than 20 dynamic majors assigned (which
    is pretty typical) should not be affected by this change.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lkml.org/lkml/2017/6/4/107
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b5d6816542b..1773dcf1e318 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2473,6 +2473,10 @@ static inline void bd_unlink_disk_holder(struct block_device *bdev,
 #define CHRDEV_MAJOR_HASH_SIZE	255
 /* Marks the bottom of the first segment of free char majors */
 #define CHRDEV_MAJOR_DYN_END 234
+/* Marks the top and bottom of the second segment of free char majors */
+#define CHRDEV_MAJOR_DYN_EXT_START 511
+#define CHRDEV_MAJOR_DYN_EXT_END 384
+
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
 extern int __register_chrdev(unsigned int major, unsigned int baseminor,

commit e462ec50cb5fad19f6003a3d8087f4a0945dd2b1
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 17 08:45:35 2017 +0100

    VFS: Differentiate mount flags (MS_*) from internal superblock flags
    
    Differentiate the MS_* flags passed to mount(2) from the internal flags set
    in the super_block's s_flags.  s_flags are now called SB_*, with the names
    and the values for the moment mirroring the MS_* flags that they're
    equivalent to.
    
    In this patch, just the headers are altered and some kernel code where
    blind automated conversion isn't necessarily correct.
    
    Note that this shows up some interesting issues:
    
     (1) Some MS_* flags get translated to MNT_* flags (such as MS_NODEV ->
         MNT_NODEV) without passing this on to the filesystem, but some
         filesystems set such flags anyway.
    
     (2) The ->remount_fs() methods of some filesystems adjust the *flags
         argument by setting MS_* flags in it, such as MS_NOATIME - but these
         flags are then scrubbed by do_remount_sb() (only the occupants of
         MS_RMT_MASK are permitted: MS_RDONLY, MS_SYNCHRONOUS, MS_MANDLOCK,
         MS_I_VERSION and MS_LAZYTIME)
    
    I'm not sure what's the best way to solve all these cases.
    
    Suggested-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6ae137c1bdf6..3d6ee0c0ebb0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1269,6 +1269,33 @@ extern int send_sigurg(struct fown_struct *fown);
 
 struct mm_struct;
 
+/*
+ * sb->s_flags.  Note that these mirror the equivalent MS_* flags where
+ * represented in both.
+ */
+#define SB_RDONLY	 1	/* Mount read-only */
+#define SB_NOSUID	 2	/* Ignore suid and sgid bits */
+#define SB_NODEV	 4	/* Disallow access to device special files */
+#define SB_NOEXEC	 8	/* Disallow program execution */
+#define SB_SYNCHRONOUS	16	/* Writes are synced at once */
+#define SB_MANDLOCK	64	/* Allow mandatory locks on an FS */
+#define SB_DIRSYNC	128	/* Directory modifications are synchronous */
+#define SB_NOATIME	1024	/* Do not update access times. */
+#define SB_NODIRATIME	2048	/* Do not update directory access times */
+#define SB_SILENT	32768
+#define SB_POSIXACL	(1<<16)	/* VFS does not apply the umask */
+#define SB_KERNMOUNT	(1<<22) /* this is a kern_mount call */
+#define SB_I_VERSION	(1<<23) /* Update inode I_version field */
+#define SB_LAZYTIME	(1<<25) /* Update the on-disk [acm]times lazily */
+
+/* These sb flags are internal to the kernel */
+#define SB_SUBMOUNT     (1<<26)
+#define SB_NOREMOTELOCK	(1<<27)
+#define SB_NOSEC	(1<<28)
+#define SB_BORN		(1<<29)
+#define SB_ACTIVE	(1<<30)
+#define SB_NOUSER	(1<<31)
+
 /*
  *	Umount options
  */
@@ -1835,7 +1862,7 @@ struct super_operations {
  * possible to override it selectively if you really wanted to with some
  * ioctl() that is not currently implemented.
  *
- * Exception: MS_RDONLY is always applied to the entire file system.
+ * Exception: SB_RDONLY is always applied to the entire file system.
  *
  * Unfortunately, it is possible to change a filesystems flags with it mounted
  * with files in use.  This means that all of the inodes will not have their
@@ -1846,18 +1873,18 @@ struct super_operations {
 
 static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & MS_RDONLY; }
 #define IS_RDONLY(inode)	sb_rdonly((inode)->i_sb)
-#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
+#define IS_SYNC(inode)		(__IS_FLG(inode, SB_SYNCHRONOUS) || \
 					((inode)->i_flags & S_SYNC))
-#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
+#define IS_DIRSYNC(inode)	(__IS_FLG(inode, SB_SYNCHRONOUS|SB_DIRSYNC) || \
 					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
-#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
-#define IS_NOATIME(inode)	__IS_FLG(inode, MS_RDONLY|MS_NOATIME)
-#define IS_I_VERSION(inode)	__IS_FLG(inode, MS_I_VERSION)
+#define IS_MANDLOCK(inode)	__IS_FLG(inode, SB_MANDLOCK)
+#define IS_NOATIME(inode)	__IS_FLG(inode, SB_RDONLY|SB_NOATIME)
+#define IS_I_VERSION(inode)	__IS_FLG(inode, SB_I_VERSION)
 
 #define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
 #define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
 #define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
-#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+#define IS_POSIXACL(inode)	__IS_FLG(inode, SB_POSIXACL)
 
 #define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
 #define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
@@ -2178,7 +2205,7 @@ static inline int __mandatory_lock(struct inode *ino)
 }
 
 /*
- * ... and these candidates should be on MS_MANDLOCK mounted fs,
+ * ... and these candidates should be on SB_MANDLOCK mounted fs,
  * otherwise these will be advisory locks
  */
 
@@ -3274,7 +3301,7 @@ static inline int check_sticky(struct inode *dir, struct inode *inode)
 
 static inline void inode_has_no_xattr(struct inode *inode)
 {
-	if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & MS_NOSEC))
+	if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & SB_NOSEC))
 		inode->i_flags |= S_NOSEC;
 }
 

commit 94e92e7ac90d06e1e839e112d3ae80b2457dbdd7
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 17 08:45:34 2017 +0100

    vfs: Add sb_rdonly(sb) to query the MS_RDONLY flag on s_flags
    
    Add an sb_rdonly() function to query the MS_RDONLY flag on sb->s_flags
    preparatory to providing an SB_RDONLY flag.
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b5d6816542b..6ae137c1bdf6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1844,7 +1844,8 @@ struct super_operations {
  */
 #define __IS_FLG(inode, flg)	((inode)->i_sb->s_flags & (flg))
 
-#define IS_RDONLY(inode)	((inode)->i_sb->s_flags & MS_RDONLY)
+static inline bool sb_rdonly(const struct super_block *sb) { return sb->s_flags & MS_RDONLY; }
+#define IS_RDONLY(inode)	sb_rdonly((inode)->i_sb)
 #define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
 					((inode)->i_flags & S_SYNC))
 #define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \

commit 9d5b86ac13c573795525ecac6ed2db39ab23e2a8
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Sun Jul 16 10:28:22 2017 -0400

    fs/locks: Remove fl_nspid and use fs-specific l_pid for remote locks
    
    Since commit c69899a17ca4 "NFSv4: Update of VFS byte range lock must be
    atomic with the stateid update", NFSv4 has been inserting locks in rpciod
    worker context.  The result is that the file_lock's fl_nspid is the
    kworker's pid instead of the original userspace pid.
    
    The fl_nspid is only used to represent the namespaced virtual pid number
    when displaying locks or returning from F_GETLK.  There's no reason to set
    it for every inserted lock, since we can usually just look it up from
    fl_pid.  So, instead of looking up and holding struct pid for every lock,
    let's just look up the virtual pid number from fl_pid when it is needed.
    That means we can remove fl_nspid entirely.
    
    The translaton and presentation of fl_pid should handle the following four
    cases:
    
    1 - F_GETLK on a remote file with a remote lock:
        In this case, the filesystem should determine the l_pid to return here.
        Filesystems should indicate that the fl_pid represents a non-local pid
        value that should not be translated by returning an fl_pid <= 0.
    
    2 - F_GETLK on a local file with a remote lock:
        This should be the l_pid of the lock manager process, and translated.
    
    3 - F_GETLK on a remote file with a local lock, and
    4 - F_GETLK on a local file with a local lock:
        These should be the translated l_pid of the local locking process.
    
    Fuse was already doing the correct thing by translating the pid into the
    caller's namespace.  With this change we must update fuse to translate
    to init's pid namespace, so that the locks API can then translate from
    init's pid namespace into the pid namespace of the caller.
    
    With this change, the locks API will expect that if a filesystem returns
    a remote pid as opposed to a local pid for F_GETLK, that remote pid will
    be <= 0.  This signifies that the pid is remote, and the locks API will
    forego translating that pid into the pid namespace of the local calling
    process.
    
    Finally, we convert remote filesystems to present remote pids using
    negative numbers. Have lustre, 9p, ceph, cifs, and dlm negate the remote
    pid returned for F_GETLK lock requests.
    
    Since local pids will never be larger than PID_MAX_LIMIT (which is
    currently defined as <= 4 million), but pid_t is an unsigned int, we
    should have plenty of room to represent remote pids with negative
    numbers if we assume that remote pid numbers are similarly limited.
    
    If this is not the case, then we run the risk of having a remote pid
    returned for which there is also a corresponding local pid.  This is a
    problem we have now, but this patch should reduce the chances of that
    occurring, while also returning those remote pid numbers, for whatever
    that may be worth.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b5d6816542b..f0b108af9b02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -999,7 +999,6 @@ struct file_lock {
 	unsigned char fl_type;
 	unsigned int fl_pid;
 	int fl_link_cpu;		/* what cpu's list is this on? */
-	struct pid *fl_nspid;
 	wait_queue_head_t fl_wait;
 	struct file *fl_file;
 	loff_t fl_start;

commit 78dcf73421a879d22319d3889119945b85954a68
Merge: 93ff81859733 fdb254db21bb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 15 12:00:42 2017 -0700

    Merge branch 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull ->s_options removal from Al Viro:
     "Preparations for fsmount/fsopen stuff (coming next cycle). Everything
      gets moved to explicit ->show_options(), killing ->s_options off +
      some cosmetic bits around fs/namespace.c and friends. Basically, the
      stuff needed to work with fsmount series with minimum of conflicts
      with other work.
    
      It's not strictly required for this merge window, but it would reduce
      the PITA during the coming cycle, so it would be nice to have those
      bits and pieces out of the way"
    
    * 'work.mount' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      isofs: Fix isofs_show_options()
      VFS: Kill off s_options and helpers
      orangefs: Implement show_options
      9p: Implement show_options
      isofs: Implement show_options
      afs: Implement show_options
      affs: Implement show_options
      befs: Implement show_options
      spufs: Implement show_options
      bpf: Implement show_options
      ramfs: Implement show_options
      pstore: Implement show_options
      omfs: Implement show_options
      hugetlbfs: Implement show_options
      VFS: Don't use save/replace_mount_options if not using generic_show_options
      VFS: Provide empty name qstr
      VFS: Make get_filesystem() return the affected filesystem
      VFS: Clean up whitespace in fs/namespace.c and fs/super.c
      Provide a function to create a NUL-terminated string from unterminated data

commit 6b1c776d3efbda31085b6a9f3bc7f774511fafd9
Merge: 58c7ffc0747a f4439de11828
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 12 09:28:55 2017 -0700

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This work from Amir introduces the inodes index feature, which
      provides:
    
       - hardlinks are not broken on copy up
    
       - infrastructure for overlayfs NFS export
    
      This also fixes constant st_ino for samefs case for lower hardlinks"
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (33 commits)
      ovl: mark parent impure and restore timestamp on ovl_link_up()
      ovl: document copying layers restrictions with inodes index
      ovl: cleanup orphan index entries
      ovl: persistent overlay inode nlink for indexed inodes
      ovl: implement index dir copy up
      ovl: move copy up lock out
      ovl: rearrange copy up
      ovl: add flag for upper in ovl_entry
      ovl: use struct copy_up_ctx as function argument
      ovl: base tmpfile in workdir too
      ovl: factor out ovl_copy_up_inode() helper
      ovl: extract helper to get temp file in copy up
      ovl: defer upper dir lock to tempfile link
      ovl: hash overlay non-dir inodes by copy up origin
      ovl: cleanup bad and stale index entries on mount
      ovl: lookup index entry for copy up origin
      ovl: verify index dir matches upper dir
      ovl: verify upper root dir matches lower root dir
      ovl: introduce the inodes index dir feature
      ovl: generalize ovl_create_workdir()
      ...

commit 1d278a879081ddc40286500e58868aaee47de257
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 5 16:25:53 2017 +0100

    VFS: Kill off s_options and helpers
    
    Kill off s_options, save/replace_mount_options() and generic_show_options()
    as all filesystems now implement ->show_options() for themselves.  This
    should make it easier to implement a context-based mount where the mount
    options can be passed individually over a file descriptor.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bc0c054894b9..e265b2ea72c6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1351,11 +1351,6 @@ struct super_block {
 	 */
 	char *s_subtype;
 
-	/*
-	 * Saved mount options for lazy filesystems using
-	 * generic_show_options()
-	 */
-	char __rcu *s_options;
 	const struct dentry_operations *s_d_op; /* default d_op for dentries */
 
 	/*
@@ -3033,10 +3028,6 @@ extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern int file_update_time(struct file *file);
 
-extern int generic_show_options(struct seq_file *m, struct dentry *root);
-extern void save_mount_options(struct super_block *sb, char *options);
-extern void replace_mount_options(struct super_block *sb, char *options);
-
 static inline bool io_is_direct(struct file *filp)
 {
 	return (filp->f_flags & O_DIRECT) || IS_DAX(filp->f_mapping->host);

commit baabda261424517110ea98c6651f632ebf2561e3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jul 10 15:48:25 2017 -0700

    mm: always enable thp for dax mappings
    
    The madvise policy for transparent huge pages is meant to avoid unwanted
    allocations of transparent huge pages.  It allows a policy of disabling
    the extra memory pressure and effort to arrange for a huge page when it
    is not needed.
    
    DAX by definition never incurs this overhead since it is statically
    allocated.  The policy choice makes even less sense for device-dax which
    tries to guarantee a given tlb-fault size.  Specifically, the following
    setting:
    
            echo never > /sys/kernel/mm/transparent_hugepage/enabled
    
    ...violates that guarantee and silently disables all device-dax
    instances with a 2M or 1G alignment.  So, let's avoid that non-obvious
    side effect by force enabling thp for dax mappings in all cases.
    
    It is worth noting that the reason this uses vma_is_dax(), and the
    resulting header include changes, is that previous attempts to add a
    VM_DAX flag were NAKd.
    
    Link: http://lkml.kernel.org/r/149739531127.20686.15813586620597484283.stgit@dwillia2-desk3.amr.corp.intel.com
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0cfa47125d52..78e1dbbe4cfd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -18,6 +18,7 @@
 #include <linux/bug.h>
 #include <linux/mutex.h>
 #include <linux/rwsem.h>
+#include <linux/mm_types.h>
 #include <linux/capability.h>
 #include <linux/semaphore.h>
 #include <linux/fcntl.h>
@@ -3127,6 +3128,11 @@ static inline bool io_is_direct(struct file *filp)
 	return (filp->f_flags & O_DIRECT) || IS_DAX(filp->f_mapping->host);
 }
 
+static inline bool vma_is_dax(struct vm_area_struct *vma)
+{
+	return vma->vm_file && IS_DAX(vma->vm_file->f_mapping->host);
+}
+
 static inline int iocb_flags(struct file *file)
 {
 	int res = 0;

commit 088737f44bbf6378745f5b57b035e57ee3dc4750
Merge: 33198c165b7a 333427a505be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 19:38:17 2017 -0700

    Merge tag 'for-linus-v4.13-2' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux
    
    Pull Writeback error handling updates from Jeff Layton:
     "This pile represents the bulk of the writeback error handling fixes
      that I have for this cycle. Some of the earlier patches in this pile
      may look trivial but they are prerequisites for later patches in the
      series.
    
      The aim of this set is to improve how we track and report writeback
      errors to userland. Most applications that care about data integrity
      will periodically call fsync/fdatasync/msync to ensure that their
      writes have made it to the backing store.
    
      For a very long time, we have tracked writeback errors using two flags
      in the address_space: AS_EIO and AS_ENOSPC. Those flags are set when a
      writeback error occurs (via mapping_set_error) and are cleared as a
      side-effect of filemap_check_errors (as you noted yesterday). This
      model really sucks for userland.
    
      Only the first task to call fsync (or msync or fdatasync) will see the
      error. Any subsequent task calling fsync on a file will get back 0
      (unless another writeback error occurs in the interim). If I have
      several tasks writing to a file and calling fsync to ensure that their
      writes got stored, then I need to have them coordinate with one
      another. That's difficult enough, but in a world of containerized
      setups that coordination may even not be possible.
    
      But wait...it gets worse!
    
      The calls to filemap_check_errors can be buried pretty far down in the
      call stack, and there are internal callers of filemap_write_and_wait
      and the like that also end up clearing those errors. Many of those
      callers ignore the error return from that function or return it to
      userland at nonsensical times (e.g. truncate() or stat()). If I get
      back -EIO on a truncate, there is no reason to think that it was
      because some previous writeback failed, and a subsequent fsync() will
      (incorrectly) return 0.
    
      This pile aims to do three things:
    
       1) ensure that when a writeback error occurs that that error will be
          reported to userland on a subsequent fsync/fdatasync/msync call,
          regardless of what internal callers are doing
    
       2) report writeback errors on all file descriptions that were open at
          the time that the error occurred. This is a user-visible change,
          but I think most applications are written to assume this behavior
          anyway. Those that aren't are unlikely to be hurt by it.
    
       3) document what filesystems should do when there is a writeback
          error. Today, there is very little consistency between them, and a
          lot of cargo-cult copying. We need to make it very clear what
          filesystems should do in this situation.
    
      To achieve this, the set adds a new data type (errseq_t) and then
      builds new writeback error tracking infrastructure around that. Once
      all of that is in place, we change the filesystems to use the new
      infrastructure for reporting wb errors to userland.
    
      Note that this is just the initial foray into cleaning up this mess.
      There is a lot of work remaining here:
    
       1) convert the rest of the filesystems in a similar fashion. Once the
          initial set is in, then I think most other fs' will be fairly
          simple to convert. Hopefully most of those can in via individual
          filesystem trees.
    
       2) convert internal waiters on writeback to use errseq_t for
          detecting errors instead of relying on the AS_* flags. I have some
          draft patches for this for ext4, but they are not quite ready for
          prime time yet.
    
      This was a discussion topic this year at LSF/MM too. If you're
      interested in the gory details, LWN has some good articles about this:
    
          https://lwn.net/Articles/718734/
          https://lwn.net/Articles/724307/"
    
    * tag 'for-linus-v4.13-2' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux:
      btrfs: minimal conversion to errseq_t writeback error reporting on fsync
      xfs: minimal conversion to errseq_t writeback error reporting
      ext4: use errseq_t based error handling for reporting data writeback errors
      fs: convert __generic_file_fsync to use errseq_t based reporting
      block: convert to errseq_t based writeback error tracking
      dax: set errors in mapping when writeback fails
      Documentation: flesh out the section in vfs.txt on storing and reporting writeback errors
      mm: set both AS_EIO/AS_ENOSPC and errseq_t in mapping_set_error
      fs: new infrastructure for writeback error handling and reporting
      lib: add errseq_t type and infrastructure for handling it
      mm: don't TestClearPageError in __filemap_fdatawait_range
      mm: clear AS_EIO/AS_ENOSPC when writeback initiation fails
      jbd2: don't clear and reset errors after waiting on writeback
      buffer: set errors in mapping at the time that the error occurs
      fs: check for writeback errors after syncing out buffers in generic_file_fsync
      buffer: use mapping_set_error instead of setting the flag
      mm: fix mapping_set_error call in me_pagecache_dirty

commit 33198c165b7afd500f7b6b7680ef994296805ef0
Merge: 3ea4fcc5fe7f 0f41074a6575
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 7 18:39:15 2017 -0700

    Merge tag 'for-linus-v4.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux
    
    Pull Writeback error handling fixes from Jeff Layton:
     "The main rationale for all of these changes is to tighten up writeback
      error reporting to userland. There are many ways now that writeback
      errors can be lost, such that fsync/fdatasync/msync return 0 when
      writeback actually failed.
    
      This pile contains a small set of cleanups and writeback error
      handling fixes that I was able to break off from the main pile (#2).
    
      Two of the patches in this pile are trivial. The exceptions are the
      patch to fix up error handling in write_one_page, and the patch to
      make JFS pay attention to write_one_page errors"
    
    * tag 'for-linus-v4.13-1' of git://git.kernel.org/pub/scm/linux/kernel/git/jlayton/linux:
      fs: remove call_fsync helper function
      mm: clean up error handling in write_one_page
      JFS: do not ignore return code from write_one_page()
      mm: drop "wait" parameter from write_one_page()

commit 5660e13d2fd6af1903d4b0b98020af95ca2d638a
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jul 6 07:02:25 2017 -0400

    fs: new infrastructure for writeback error handling and reporting
    
    Most filesystems currently use mapping_set_error and
    filemap_check_errors for setting and reporting/clearing writeback errors
    at the mapping level. filemap_check_errors is indirectly called from
    most of the filemap_fdatawait_* functions and from
    filemap_write_and_wait*. These functions are called from all sorts of
    contexts to wait on writeback to finish -- e.g. mostly in fsync, but
    also in truncate calls, getattr, etc.
    
    The non-fsync callers are problematic. We should be reporting writeback
    errors during fsync, but many places spread over the tree clear out
    errors before they can be properly reported, or report errors at
    nonsensical times.
    
    If I get -EIO on a stat() call, there is no reason for me to assume that
    it is because some previous writeback failed. The fact that it also
    clears out the error such that a subsequent fsync returns 0 is a bug,
    and a nasty one since that's potentially silent data corruption.
    
    This patch adds a small bit of new infrastructure for setting and
    reporting errors during address_space writeback. While the above was my
    original impetus for adding this, I think it's also the case that
    current fsync semantics are just problematic for userland. Most
    applications that call fsync do so to ensure that the data they wrote
    has hit the backing store.
    
    In the case where there are multiple writers to the file at the same
    time, this is really hard to determine. The first one to call fsync will
    see any stored error, and the rest get back 0. The processes with open
    fds may not be associated with one another in any way. They could even
    be in different containers, so ensuring coordination between all fsync
    callers is not really an option.
    
    One way to remedy this would be to track what file descriptor was used
    to dirty the file, but that's rather cumbersome and would likely be
    slow. However, there is a simpler way to improve the semantics here
    without incurring too much overhead.
    
    This set adds an errseq_t to struct address_space, and a corresponding
    one is added to struct file. Writeback errors are recorded in the
    mapping's errseq_t, and the one in struct file is used as the "since"
    value.
    
    This changes the semantics of the Linux fsync implementation such that
    applications can now use it to determine whether there were any
    writeback errors since fsync(fd) was last called (or since the file was
    opened in the case of fsync having never been called).
    
    Note that those writeback errors may have occurred when writing data
    that was dirtied via an entirely different fd, but that's the case now
    with the current mapping_set_error/filemap_check_error infrastructure.
    This will at least prevent you from getting a false report of success.
    
    The new behavior is still consistent with the POSIX spec, and is more
    reliable for application developers. This patch just adds some basic
    infrastructure for doing this, and ensures that the f_wb_err "cursor"
    is properly set when a file is opened. Later patches will change the
    existing code to use this new infrastructure for reporting errors at
    fsync time.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8ac8df1b3550..78b5c2901712 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -30,7 +30,7 @@
 #include <linux/percpu-rwsem.h>
 #include <linux/workqueue.h>
 #include <linux/delayed_call.h>
-
+#include <linux/errseq.h>
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
 
@@ -392,6 +392,7 @@ struct address_space {
 	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
 	struct list_head	private_list;	/* ditto */
 	void			*private_data;	/* ditto */
+	errseq_t		wb_err;
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but
@@ -868,6 +869,7 @@ struct file {
 	struct list_head	f_tfile_llink;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
+	errseq_t		f_wb_err;
 } __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
 struct file_handle {
@@ -2526,6 +2528,62 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
 extern int filemap_check_errors(struct address_space *mapping);
 
+extern void __filemap_set_wb_err(struct address_space *mapping, int err);
+extern int __must_check file_check_and_advance_wb_err(struct file *file);
+extern int __must_check file_write_and_wait_range(struct file *file,
+						loff_t start, loff_t end);
+
+/**
+ * filemap_set_wb_err - set a writeback error on an address_space
+ * @mapping: mapping in which to set writeback error
+ * @err: error to be set in mapping
+ *
+ * When writeback fails in some way, we must record that error so that
+ * userspace can be informed when fsync and the like are called.  We endeavor
+ * to report errors on any file that was open at the time of the error.  Some
+ * internal callers also need to know when writeback errors have occurred.
+ *
+ * When a writeback error occurs, most filesystems will want to call
+ * filemap_set_wb_err to record the error in the mapping so that it will be
+ * automatically reported whenever fsync is called on the file.
+ *
+ * FIXME: mention FS_* flag here?
+ */
+static inline void filemap_set_wb_err(struct address_space *mapping, int err)
+{
+	/* Fastpath for common case of no error */
+	if (unlikely(err))
+		__filemap_set_wb_err(mapping, err);
+}
+
+/**
+ * filemap_check_wb_error - has an error occurred since the mark was sampled?
+ * @mapping: mapping to check for writeback errors
+ * @since: previously-sampled errseq_t
+ *
+ * Grab the errseq_t value from the mapping, and see if it has changed "since"
+ * the given value was sampled.
+ *
+ * If it has then report the latest error set, otherwise return 0.
+ */
+static inline int filemap_check_wb_err(struct address_space *mapping,
+					errseq_t since)
+{
+	return errseq_check(&mapping->wb_err, since);
+}
+
+/**
+ * filemap_sample_wb_err - sample the current errseq_t to test for later errors
+ * @mapping: mapping to be sampled
+ *
+ * Writeback errors are always reported relative to a particular sample point
+ * in the past. This function provides those sample points.
+ */
+static inline errseq_t filemap_sample_wb_err(struct address_space *mapping)
+{
+	return errseq_sample(&mapping->wb_err);
+}
+
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);

commit 76341cabbdad65c10a4162e9dfa82a6342afc02f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Jul 6 07:02:22 2017 -0400

    jbd2: don't clear and reset errors after waiting on writeback
    
    Resetting this flag is almost certainly racy, and will be problematic
    with some coming changes.
    
    Make filemap_fdatawait_keep_errors return int, but not clear the flag(s).
    Have jbd2 call it instead of filemap_fdatawait and don't attempt to
    re-set the error flag if it fails.
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..8ac8df1b3550 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2514,7 +2514,7 @@ extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
-extern void filemap_fdatawait_keep_errors(struct address_space *);
+extern int filemap_fdatawait_keep_errors(struct address_space *mapping);
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);

commit ee416bcdba9975065de571e09de1f7ebfde2156a
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jul 4 17:25:16 2017 +0100

    VFS: Make get_filesystem() return the affected filesystem
    
    Make get_filesystem() return a pointer to the filesystem on which it just
    got a ref.
    
    Suggested-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..bc0c054894b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2956,7 +2956,7 @@ extern int generic_block_fiemap(struct inode *inode,
 				struct fiemap_extent_info *fieinfo, u64 start,
 				u64 len, get_block_t *get_block);
 
-extern void get_filesystem(struct file_system_type *fs);
+extern struct file_system_type *get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);

commit 0f41074a65757b46acbdd4293f0de8a70b147406
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Jul 5 15:26:50 2017 -0400

    fs: remove call_fsync helper function
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Carlos Maiolino <cmaiolino@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..2d9e71e2a308 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1739,12 +1739,6 @@ static inline int call_mmap(struct file *file, struct vm_area_struct *vma)
 	return file->f_op->mmap(file, vma);
 }
 
-static inline int call_fsync(struct file *file, loff_t start, loff_t end,
-			     int datasync)
-{
-	return file->f_op->fsync(file, start, end, datasync);
-}
-
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,

commit 89fbf5384ddf666a595eb6562dc63fcbfeb8f6a5
Merge: 4be95131bf3b a4058c5bce8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 14:35:57 2017 -0700

    Merge branch 'work.read_write' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull read/write updates from Al Viro:
     "Christoph's fs/read_write.c series - consolidation and cleanups"
    
    * 'work.read_write' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      nfsd: remove nfsd_vfs_read
      nfsd: use vfs_iter_read/write
      fs: implement vfs_iter_write using do_iter_write
      fs: implement vfs_iter_read using do_iter_read
      fs: move more code into do_iter_read/do_iter_write
      fs: remove __do_readv_writev
      fs: remove do_compat_readv_writev
      fs: remove do_readv_writev

commit 3bad2f1c676581d01e7645eb03e9b27e28b0a92e
Merge: b4b8cbf679c4 8c6657cb50cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 13:13:32 2017 -0700

    Merge branch 'work.misc-set_fs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc user access cleanups from Al Viro:
     "The first pile is assorted getting rid of cargo-culted access_ok(),
      cargo-culted set_fs() and field-by-field copyouts.
    
      The same description applies to a lot of stuff in other branches -
      this is just the stuff that didn't fit into a more specific topical
      branch"
    
    * 'work.misc-set_fs' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      Switch flock copyin/copyout primitives to copy_{from,to}_user()
      fs/fcntl: return -ESRCH in f_setown when pid/pgid can't be found
      fs/fcntl: f_setown, avoid undefined behaviour
      fs/fcntl: f_setown, allow returning error
      lpfc debugfs: get rid of pointless access_ok()
      adb: get rid of pointless access_ok()
      isdn: get rid of pointless access_ok()
      compat statfs: switch to copy_to_user()
      fs/locks: don't mess with the address limit in compat_fcntl64
      nfsd_readlink(): switch to vfs_get_link()
      drbd: ->sendpage() never needed set_fs()
      fs/locks: pass kernel struct flock to fcntl_getlk/setlk
      fs: locks: Fix some troubles at kernel-doc comments

commit ad0af7104dadccd55cd2b390271677fac142650f
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Wed Jun 21 15:28:32 2017 +0300

    vfs: introduce inode 'inuse' lock
    
    Added an i_state flag I_INUSE and helpers to set/clear/test the bit.
    
    The 'inuse' lock is an 'advisory' inode lock, that can be used to extend
    exclusive create protection beyond parent->i_mutex lock among cooperating
    users.
    
    This is going to be used by overlayfs to get exclusive ownership on upper
    and work dirs among overlayfs mounts.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3e68cabb8457..75a5fafaf096 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1930,6 +1930,9 @@ static inline bool HAS_UNMAPPED_ID(struct inode *inode)
  *			wb stat updates to grab mapping->tree_lock.  See
  *			inode_switch_wb_work_fn() for details.
  *
+ * I_OVL_INUSE		Used by overlayfs to get exclusive ownership on upper
+ *			and work dirs among overlayfs mounts.
+ *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
 #define I_DIRTY_SYNC		(1 << 0)
@@ -1950,6 +1953,7 @@ static inline bool HAS_UNMAPPED_ID(struct inode *inode)
 #define __I_DIRTY_TIME_EXPIRED	12
 #define I_DIRTY_TIME_EXPIRED	(1 << __I_DIRTY_TIME_EXPIRED)
 #define I_WB_SWITCH		(1 << 13)
+#define I_OVL_INUSE			(1 << 14)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 #define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)

commit 9bd42183b951051f73de121f7ee17091e7d26fbb
Merge: 7447d56217e2 72298e5c92c5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 13:08:04 2017 -0700

    Merge branch 'sched-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull scheduler updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - Add the SYSTEM_SCHEDULING bootup state to move various scheduler
         debug checks earlier into the bootup. This turns silent and
         sporadically deadly bugs into nice, deterministic splats. Fix some
         of the splats that triggered. (Thomas Gleixner)
    
       - A round of restructuring and refactoring of the load-balancing and
         topology code (Peter Zijlstra)
    
       - Another round of consolidating ~20 of incremental scheduler code
         history: this time in terms of wait-queue nomenclature. (I didn't
         get much feedback on these renaming patches, and we can still
         easily change any names I might have misplaced, so if anyone hates
         a new name, please holler and I'll fix it.) (Ingo Molnar)
    
       - sched/numa improvements, fixes and updates (Rik van Riel)
    
       - Another round of x86/tsc scheduler clock code improvements, in hope
         of making it more robust (Peter Zijlstra)
    
       - Improve NOHZ behavior (Frederic Weisbecker)
    
       - Deadline scheduler improvements and fixes (Luca Abeni, Daniel
         Bristot de Oliveira)
    
       - Simplify and optimize the topology setup code (Lauro Ramos
         Venancio)
    
       - Debloat and decouple scheduler code some more (Nicolas Pitre)
    
       - Simplify code by making better use of llist primitives (Byungchul
         Park)
    
       - ... plus other fixes and improvements"
    
    * 'sched-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (103 commits)
      sched/cputime: Refactor the cputime_adjust() code
      sched/debug: Expose the number of RT/DL tasks that can migrate
      sched/numa: Hide numa_wake_affine() from UP build
      sched/fair: Remove effective_load()
      sched/numa: Implement NUMA node level wake_affine()
      sched/fair: Simplify wake_affine() for the single socket case
      sched/numa: Override part of migrate_degrades_locality() when idle balancing
      sched/rt: Move RT related code from sched/core.c to sched/rt.c
      sched/deadline: Move DL related code from sched/core.c to sched/deadline.c
      sched/cpuset: Only offer CONFIG_CPUSETS if SMP is enabled
      sched/fair: Spare idle load balancing on nohz_full CPUs
      nohz: Move idle balancer registration to the idle path
      sched/loadavg: Generalize "_idle" naming to "_nohz"
      sched/core: Drop the unused try_get_task_struct() helper function
      sched/fair: WARN() and refuse to set buddy when !se->on_rq
      sched/debug: Fix SCHED_WARN_ON() to return a value on !CONFIG_SCHED_DEBUG as well
      sched/wait: Disambiguate wq_entry->task_list and wq_head->task_list naming
      sched/wait: Move bit_wait_table[] and related functionality from sched/core.c to sched/wait_bit.c
      sched/wait: Split out the wait_bit*() APIs from <linux/wait.h> into <linux/wait_bit.h>
      sched/wait: Re-adjust macro line continuation backslashes in <linux/wait.h>
      ...

commit 3859a271a003aba01e45b85c9d8b355eb7bf25f9
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Oct 28 01:22:25 2016 -0700

    randstruct: Mark various structs for randomization
    
    This marks many critical kernel structures for randomization. These are
    structures that have been targeted in the past in security exploits, or
    contain functions pointers, pointers to function pointer tables, lists,
    workqueues, ref-counters, credentials, permissions, or are otherwise
    sensitive. This initial list was extracted from Brad Spengler/PaX Team's
    code in the last public patch of grsecurity/PaX based on my understanding
    of the code. Changes or omissions from the original code are mine and
    don't reflect the original grsecurity/PaX code.
    
    Left out of this list is task_struct, which requires special handling
    and will be covered in a subsequent patch.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..8f28143486c4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -275,7 +275,7 @@ struct kiocb {
 	void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 	void			*private;
 	int			ki_flags;
-};
+} __randomize_layout;
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
 {
@@ -392,7 +392,7 @@ struct address_space {
 	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
 	struct list_head	private_list;	/* ditto */
 	void			*private_data;	/* ditto */
-} __attribute__((aligned(sizeof(long))));
+} __attribute__((aligned(sizeof(long)))) __randomize_layout;
 	/*
 	 * On most architectures that alignment is already the case; but
 	 * must be enforced here for CRIS, to let the least significant bit
@@ -435,7 +435,7 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
-};
+} __randomize_layout;
 
 /*
  * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
@@ -653,7 +653,7 @@ struct inode {
 #endif
 
 	void			*i_private; /* fs or device private pointer */
-};
+} __randomize_layout;
 
 static inline unsigned int i_blocksize(const struct inode *node)
 {
@@ -868,7 +868,8 @@ struct file {
 	struct list_head	f_tfile_llink;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
-} __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
+} __randomize_layout
+  __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
 struct file_handle {
 	__u32 handle_bytes;
@@ -1005,7 +1006,7 @@ struct file_lock {
 			int state;		/* state of grant or error if -ve */
 		} afs;
 	} fl_u;
-};
+} __randomize_layout;
 
 struct file_lock_context {
 	spinlock_t		flc_lock;
@@ -1404,7 +1405,7 @@ struct super_block {
 
 	spinlock_t		s_inode_wblist_lock;
 	struct list_head	s_inodes_wb;	/* writeback inodes */
-};
+} __randomize_layout;
 
 /* Helper functions so that in most cases filesystems will
  * not need to deal directly with kuid_t and kgid_t and can
@@ -1690,7 +1691,7 @@ struct file_operations {
 			u64);
 	ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *,
 			u64);
-};
+} __randomize_layout;
 
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);

commit abbb65899aecfc97bda64b6816d1e501754cfe1f
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat May 27 11:16:52 2017 +0300

    fs: implement vfs_iter_write using do_iter_write
    
    De-dupliate some code and allow for passing the flags argument to
    vfs_iter_write.  Additionally it now properly updates timestamps.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f6a4f4efb32..c67f1f8ee789 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2791,7 +2791,8 @@ extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 
 ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,
 		int flags);
-ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos);
+ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos,
+		int flags);
 
 /* fs/block_dev.c */
 extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);

commit 18e9710ee59ce3bd2a2512ddcd3f7ceebe8b8d17
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat May 27 11:16:51 2017 +0300

    fs: implement vfs_iter_read using do_iter_read
    
    De-dupliate some code and allow for passing the flags argument to
    vfs_iter_read.  Additional it properly updates atime now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..3f6a4f4efb32 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2789,7 +2789,8 @@ extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 
-ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos);
+ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos,
+		int flags);
 ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos);
 
 /* fs/block_dev.c */

commit c75b1d9421f80f4143e389d2d50ddfc8a28c8c35
Author: Jens Axboe <axboe@kernel.dk>
Date:   Tue Jun 27 11:47:04 2017 -0600

    fs: add fcntl() interface for setting/getting write life time hints
    
    Define a set of write life time hints:
    
    RWH_WRITE_LIFE_NOT_SET  No hint information set
    RWH_WRITE_LIFE_NONE     No hints about write life time
    RWH_WRITE_LIFE_SHORT    Data written has a short life time
    RWH_WRITE_LIFE_MEDIUM   Data written has a medium life time
    RWH_WRITE_LIFE_LONG     Data written has a long life time
    RWH_WRITE_LIFE_EXTREME  Data written has an extremely long life time
    
    The intent is for these values to be relative to each other, no
    absolute meaning should be attached to these flag names.
    
    Add an fcntl interface for querying these flags, and also for
    setting them as well:
    
    F_GET_RW_HINT           Returns the read/write hint set on the
                            underlying inode.
    
    F_SET_RW_HINT           Set one of the above write hints on the
                            underlying inode.
    
    F_GET_FILE_RW_HINT      Returns the read/write hint set on the
                            file descriptor.
    
    F_SET_FILE_RW_HINT      Set one of the above write hints on the
                            file descriptor.
    
    The user passes in a 64-bit pointer to get/set these values, and
    the interface returns 0/-1 on success/error.
    
    Sample program testing/implementing basic setting/getting of write
    hints is below.
    
    Add support for storing the write life time hint in the inode flags
    and in struct file as well, and pass them to the kiocb flags. If
    both a file and its corresponding inode has a write hint, then we
    use the one in the file, if available. The file hint can be used
    for sync/direct IO, for buffered writeback only the inode hint
    is available.
    
    This is in preparation for utilizing these hints in the block layer,
    to guide on-media data placement.
    
    /*
     * writehint.c: get or set an inode write hint
     */
     #include <stdio.h>
     #include <fcntl.h>
     #include <stdlib.h>
     #include <unistd.h>
     #include <stdbool.h>
     #include <inttypes.h>
    
     #ifndef F_GET_RW_HINT
     #define F_LINUX_SPECIFIC_BASE  1024
     #define F_GET_RW_HINT          (F_LINUX_SPECIFIC_BASE + 11)
     #define F_SET_RW_HINT          (F_LINUX_SPECIFIC_BASE + 12)
     #endif
    
    static char *str[] = { "RWF_WRITE_LIFE_NOT_SET", "RWH_WRITE_LIFE_NONE",
                            "RWH_WRITE_LIFE_SHORT", "RWH_WRITE_LIFE_MEDIUM",
                            "RWH_WRITE_LIFE_LONG", "RWH_WRITE_LIFE_EXTREME" };
    
    int main(int argc, char *argv[])
    {
            uint64_t hint;
            int fd, ret;
    
            if (argc < 2) {
                    fprintf(stderr, "%s: file <hint>\n", argv[0]);
                    return 1;
            }
    
            fd = open(argv[1], O_RDONLY);
            if (fd < 0) {
                    perror("open");
                    return 2;
            }
    
            if (argc > 2) {
                    hint = atoi(argv[2]);
                    ret = fcntl(fd, F_SET_RW_HINT, &hint);
                    if (ret < 0) {
                            perror("fcntl: F_SET_RW_HINT");
                            return 4;
                    }
            }
    
            ret = fcntl(fd, F_GET_RW_HINT, &hint);
            if (ret < 0) {
                    perror("fcntl: F_GET_RW_HINT");
                    return 3;
            }
    
            printf("%s: hint %s\n", argv[1], str[hint]);
            close(fd);
            return 0;
    }
    
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4574121f4746..65adbddb3163 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -20,6 +20,7 @@
 #include <linux/rwsem.h>
 #include <linux/capability.h>
 #include <linux/semaphore.h>
+#include <linux/fcntl.h>
 #include <linux/fiemap.h>
 #include <linux/rculist_bl.h>
 #include <linux/atomic.h>
@@ -265,6 +266,18 @@ struct page;
 struct address_space;
 struct writeback_control;
 
+/*
+ * Write life time hint values.
+ */
+enum rw_hint {
+	WRITE_LIFE_NOT_SET	= 0,
+	WRITE_LIFE_NONE		= RWH_WRITE_LIFE_NONE,
+	WRITE_LIFE_SHORT	= RWH_WRITE_LIFE_SHORT,
+	WRITE_LIFE_MEDIUM	= RWH_WRITE_LIFE_MEDIUM,
+	WRITE_LIFE_LONG		= RWH_WRITE_LIFE_LONG,
+	WRITE_LIFE_EXTREME	= RWH_WRITE_LIFE_EXTREME,
+};
+
 #define IOCB_EVENTFD		(1 << 0)
 #define IOCB_APPEND		(1 << 1)
 #define IOCB_DIRECT		(1 << 2)
@@ -280,6 +293,7 @@ struct kiocb {
 	void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
 	void			*private;
 	int			ki_flags;
+	enum rw_hint		ki_hint;
 };
 
 static inline bool is_sync_kiocb(struct kiocb *kiocb)
@@ -287,16 +301,6 @@ static inline bool is_sync_kiocb(struct kiocb *kiocb)
 	return kiocb->ki_complete == NULL;
 }
 
-static inline int iocb_flags(struct file *file);
-
-static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
-{
-	*kiocb = (struct kiocb) {
-		.ki_filp = filp,
-		.ki_flags = iocb_flags(filp),
-	};
-}
-
 /*
  * "descriptor" for what we're up to with a read.
  * This allows us to use the same read code yet
@@ -597,6 +601,7 @@ struct inode {
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	unsigned short          i_bytes;
 	unsigned int		i_blkbits;
+	enum rw_hint		i_write_hint;
 	blkcnt_t		i_blocks;
 
 #ifdef __NEED_I_SIZE_ORDERED
@@ -851,6 +856,7 @@ struct file {
 	 * Must not be taken from IRQ context.
 	 */
 	spinlock_t		f_lock;
+	enum rw_hint		f_write_hint;
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
@@ -1026,8 +1032,6 @@ struct file_lock_context {
 #define OFFT_OFFSET_MAX	INT_LIMIT(off_t)
 #endif
 
-#include <linux/fcntl.h>
-
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
 /*
@@ -1878,6 +1882,25 @@ static inline bool HAS_UNMAPPED_ID(struct inode *inode)
 	return !uid_valid(inode->i_uid) || !gid_valid(inode->i_gid);
 }
 
+static inline enum rw_hint file_write_hint(struct file *file)
+{
+	if (file->f_write_hint != WRITE_LIFE_NOT_SET)
+		return file->f_write_hint;
+
+	return file_inode(file)->i_write_hint;
+}
+
+static inline int iocb_flags(struct file *file);
+
+static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
+{
+	*kiocb = (struct kiocb) {
+		.ki_filp = filp,
+		.ki_flags = iocb_flags(filp),
+		.ki_hint = file_write_hint(filp),
+	};
+}
+
 /*
  * Inode state bits.  Protected by inode->i_lock
  *

commit b745fafaf70c0a98a2e1e7ac8cb14542889ceb0e
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Tue Jun 20 07:05:43 2017 -0500

    fs: Introduce RWF_NOWAIT and FMODE_AIO_NOWAIT
    
    RWF_NOWAIT informs kernel to bail out if an AIO request will block
    for reasons such as file allocations, or a writeback triggered,
    or would block while allocating requests while performing
    direct I/O.
    
    RWF_NOWAIT is translated to IOCB_NOWAIT for iocb->ki_flags.
    
    FMODE_AIO_NOWAIT is a flag which identifies the file opened is capable
    of returning -EAGAIN if the AIO call will block. This must be set by
    supporting filesystems in the ->open() call.
    
    Filesystems xfs, btrfs and ext4 would be supported in the following patches.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0d34f5b5a6b0..4574121f4746 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -143,6 +143,9 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x4000000)
 
+/* File is capable of returning -EAGAIN if AIO will block */
+#define FMODE_AIO_NOWAIT	((__force fmode_t)0x8000000)
+
 /*
  * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
  * that indicates that they should check the contents of the iovec are
@@ -269,6 +272,7 @@ struct writeback_control;
 #define IOCB_DSYNC		(1 << 4)
 #define IOCB_SYNC		(1 << 5)
 #define IOCB_WRITE		(1 << 6)
+#define IOCB_NOWAIT		(1 << 7)
 
 struct kiocb {
 	struct file		*ki_filp;
@@ -3064,6 +3068,11 @@ static inline int kiocb_set_rw_flags(struct kiocb *ki, int flags)
 	if (unlikely(flags & ~RWF_SUPPORTED))
 		return -EOPNOTSUPP;
 
+	if (flags & RWF_NOWAIT) {
+		if (!(ki->ki_filp->f_mode & FMODE_AIO_NOWAIT))
+			return -EOPNOTSUPP;
+		ki->ki_flags |= IOCB_NOWAIT;
+	}
 	if (flags & RWF_HIPRI)
 		ki->ki_flags |= IOCB_HIPRI;
 	if (flags & RWF_DSYNC)

commit 7fc9e4722435cd8459182c4975f48934f2bb1274
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Tue Jun 20 07:05:41 2017 -0500

    fs: Introduce filemap_range_has_page()
    
    filemap_range_has_page() return true if the file's mapping has
    a page within the range mentioned. This function will be used
    to check if a write() call will cause a writeback of previous
    writes.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 96a1a1fa54a9..0d34f5b5a6b0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2518,6 +2518,8 @@ extern int filemap_fdatawait(struct address_space *);
 extern void filemap_fdatawait_keep_errors(struct address_space *);
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
+extern bool filemap_range_has_page(struct address_space *, loff_t lstart,
+				  loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);

commit fdd2f5b7de2afaa931e5f7bad7bcda35d1f1b479
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Tue Jun 20 07:05:40 2017 -0500

    fs: Separate out kiocb flags setup based on RWF_* flags
    
    Also added RWF_SUPPORTED to encompass all flags.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 023f0324762b..96a1a1fa54a9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3057,6 +3057,20 @@ static inline int iocb_flags(struct file *file)
 	return res;
 }
 
+static inline int kiocb_set_rw_flags(struct kiocb *ki, int flags)
+{
+	if (unlikely(flags & ~RWF_SUPPORTED))
+		return -EOPNOTSUPP;
+
+	if (flags & RWF_HIPRI)
+		ki->ki_flags |= IOCB_HIPRI;
+	if (flags & RWF_DSYNC)
+		ki->ki_flags |= IOCB_DSYNC;
+	if (flags & RWF_SYNC)
+		ki->ki_flags |= (IOCB_DSYNC | IOCB_SYNC);
+	return 0;
+}
+
 static inline ino_t parent_ino(struct dentry *dentry)
 {
 	ino_t res;

commit 5dd43ce2f69d42a71dcacdb13d17d8c0ac1fe8f7
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Jun 20 12:19:09 2017 +0200

    sched/wait: Split out the wait_bit*() APIs from <linux/wait.h> into <linux/wait_bit.h>
    
    The wait_bit*() types and APIs are mixed into wait.h, but they
    are a pretty orthogonal extension of wait-queues.
    
    Furthermore, only about 50 kernel files use these APIs, while
    over 1000 use the regular wait-queue functionality.
    
    So clean up the main wait.h by moving the wait-bit functionality
    out of it, into a separate .h and .c file:
    
      include/linux/wait_bit.h  for types and APIs
      kernel/sched/wait_bit.c   for the implementation
    
    Update all header dependencies.
    
    This reduces the size of wait.h rather significantly, by about 30%.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..53f7e49d8fe5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2,7 +2,7 @@
 #define _LINUX_FS_H
 
 #include <linux/linkage.h>
-#include <linux/wait.h>
+#include <linux/wait_bit.h>
 #include <linux/kdev_t.h>
 #include <linux/dcache.h>
 #include <linux/path.h>

commit 393cc3f51135ea2520521f776ef3afdf3395c797
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Tue Jun 13 13:35:50 2017 +0200

    fs/fcntl: f_setown, allow returning error
    
    Allow f_setown to return an error value. We will fail in the next patch
    with EINVAL for bad input to f_setown, so tile the path for the later
    patch.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Cc: Jeff Layton <jlayton@poochiereds.net>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa4affb38c39..25ee1ff6d45b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1249,7 +1249,7 @@ extern void fasync_free(struct fasync_struct *);
 extern void kill_fasync(struct fasync_struct **, int, int);
 
 extern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
-extern void f_setown(struct file *filp, unsigned long arg, int force);
+extern int f_setown(struct file *filp, unsigned long arg, int force);
 extern void f_delown(struct file *filp);
 extern pid_t f_getown(struct file *filp);
 extern int send_sigurg(struct fown_struct *fown);

commit fdd050b5b3c96813ae6756ed68157d32ba31b9f2
Merge: f06345add95f 87085ff2e90e
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 13 11:45:14 2017 +0200

    Merge branch 'uuid-types' of bombadil.infradead.org:public_git/uuid into nvme-base

commit 4055351cdbb44e8646ff67b346c80097e1d2c04c
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 09:37:58 2017 +0200

    fs: remove the unused error argument to dio_end_io()
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..4388ab58843d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2843,7 +2843,7 @@ enum {
 	DIO_SKIP_DIO_COUNT = 0x08,
 };
 
-void dio_end_io(struct bio *bio, int error);
+void dio_end_io(struct bio *bio);
 
 ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
 			     struct block_device *bdev, struct iov_iter *iter,

commit 85787090a21eb749d8b347eaf9ff1a455637473c
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 10 15:06:33 2017 +0200

    fs: switch ->s_uuid to uuid_t
    
    For some file systems we still memcpy into it, but in various places this
    already allows us to use the proper uuid helpers.  More to come..
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>(Changes to IMA/EVM)
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..3e68cabb8457 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -30,6 +30,7 @@
 #include <linux/percpu-rwsem.h>
 #include <linux/workqueue.h>
 #include <linux/delayed_call.h>
+#include <linux/uuid.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -1328,8 +1329,8 @@ struct super_block {
 
 	struct sb_writers	s_writers;
 
-	char s_id[32];				/* Informational name */
-	u8 s_uuid[16];				/* UUID */
+	char			s_id[32];	/* Informational name */
+	uuid_t			s_uuid;		/* UUID */
 
 	void 			*s_fs_info;	/* Filesystem private info */
 	unsigned int		s_max_links;

commit a75d30c772078546ac00399a94ecdc82df1a4d72
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat May 27 06:07:19 2017 -0400

    fs/locks: pass kernel struct flock to fcntl_getlk/setlk
    
    This will make it easier to implement a sane compat fcntl syscall.
    
    [ jlayton: fix undeclared identifiers in 32-bit fcntl64 syscall handler ]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803e5a9b2654..aa4affb38c39 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1038,14 +1038,14 @@ static inline struct inode *locks_inode(const struct file *f)
 }
 
 #ifdef CONFIG_FILE_LOCKING
-extern int fcntl_getlk(struct file *, unsigned int, struct flock __user *);
+extern int fcntl_getlk(struct file *, unsigned int, struct flock *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
-			struct flock __user *);
+			struct flock *);
 
 #if BITS_PER_LONG == 32
-extern int fcntl_getlk64(struct file *, unsigned int, struct flock64 __user *);
+extern int fcntl_getlk64(struct file *, unsigned int, struct flock64 *);
 extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
-			struct flock64 __user *);
+			struct flock64 *);
 #endif
 
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);

commit 572e0ca9b909339fbe017aaff1a225efb6db3b61
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Fri May 12 15:46:29 2017 -0700

    time: delete current_fs_time()
    
    All uses of the current_fs_time() function have been replaced by other
    time interfaces.
    
    And, its use cases can be fulfilled by current_time() or ktime_get_*
    variants.
    
    Link: http://lkml.kernel.org/r/1491613030-11599-13-git-send-email-deepa.kernel@gmail.com
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0ad325ed71e8..803e5a9b2654 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1431,7 +1431,6 @@ static inline void i_gid_write(struct inode *inode, gid_t gid)
 	inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
 }
 
-extern struct timespec current_fs_time(struct super_block *sb);
 extern struct timespec current_time(struct inode *inode);
 
 /*

commit 73ccb023a2f25b72c4b95499ca24760588014614
Merge: f94c128eefcc 76b2a303384e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 13:03:38 2017 -0700

    Merge tag 'nfs-for-4.12-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs
    
    Pull NFS client updates from Trond Myklebust:
     "Highlights include:
    
      Stable bugfixes:
       - Fix use after free in write error path
       - Use GFP_NOIO for two allocations in writeback
       - Fix a hang in OPEN related to server reboot
       - Check the result of nfs4_pnfs_ds_connect
       - Fix an rcu lock leak
    
      Features:
       - Removal of the unmaintained and unused OSD pNFS layout
       - Cleanup and removal of lots of unnecessary dprintk()s
       - Cleanup and removal of some memory failure paths now that GFP_NOFS
         is guaranteed to never fail.
       - Remove the v3-only data server limitation on pNFS/flexfiles
    
      Bugfixes:
       - RPC/RDMA connection handling bugfixes
       - Copy offload: fixes to ensure the copied data is COMMITed to disk.
       - Readdir: switch back to using the ->iterate VFS interface
       - File locking fixes from Ben Coddington
       - Various use-after-free and deadlock issues in pNFS
       - Write path bugfixes"
    
    * tag 'nfs-for-4.12-1' of git://git.linux-nfs.org/projects/trondmy/linux-nfs: (89 commits)
      pNFS/flexfiles: Always attempt to call layoutstats when flexfiles is enabled
      NFSv4.1: Work around a Linux server bug...
      NFS append COMMIT after synchronous COPY
      NFSv4: Fix exclusive create attributes encoding
      NFSv4: Fix an rcu lock leak
      nfs: use kmap/kunmap directly
      NFS: always treat the invocation of nfs_getattr as cache hit when noac is on
      Fix nfs_client refcounting if kmalloc fails in nfs4_proc_exchange_id and nfs4_proc_async_renew
      NFSv4.1: RECLAIM_COMPLETE must handle NFS4ERR_CONN_NOT_BOUND_TO_SESSION
      pNFS: Fix NULL dereference in pnfs_generic_alloc_ds_commits
      pNFS: Fix a typo in pnfs_generic_alloc_ds_commits
      pNFS: Fix a deadlock when coalescing writes and returning the layout
      pNFS: Don't clear the layout return info if there are segments to return
      pNFS: Ensure we commit the layout if it has been invalidated
      pNFS: Don't send COMMITs to the DSes if the server invalidated our layout
      pNFS/flexfiles: Fix up the ff_layout_write_pagelist failure path
      pNFS: Ensure we check layout validity before marking it for return
      NFS4.1 handle interrupted slot reuse from ERR_DELAY
      NFSv4: check return value of xdr_inline_decode
      nfs/filelayout: fix NULL pointer dereference in fl_pnfs_update_layout()
      ...

commit 11fbf53d66ec302fe50b06bd7cb4863dbb98775a
Merge: 339fbf6796f8 6b4657667ba0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 09:12:53 2017 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted bits and pieces from various people. No common topic in this
      pile, sorry"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs/affs: add rename exchange
      fs/affs: add rename2 to prepare multiple methods
      Make stat/lstat/fstatat pass AT_NO_AUTOMOUNT to vfs_statx()
      fs: don't set *REFERENCED on single use objects
      fs: compat: Remove warning from COMPATIBLE_IOCTL
      remove pointless extern of atime_need_update_rcu()
      fs: completely ignore unknown open flags
      fs: add a VALID_OPEN_FLAGS
      fs: remove _submit_bh()
      fs: constify tree_descr arrays passed to simple_fill_super()
      fs: drop duplicate header percpu-rwsem.h
      fs/affs: bugfix: Write files greater than page size on OFS
      fs/affs: bugfix: enable writes on OFS disks
      fs/affs: remove node generation check
      fs/affs: import amigaffs.h
      fs/affs: bugfix: make symbolic links work again

commit c718a97514e4d77c97a35734b728aaf541a0621b
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Mon May 8 15:58:59 2017 -0700

    fs: semove set but not checked AOP_FLAG_UNINTERRUPTIBLE flag
    
    Commit afddba49d18f ("fs: introduce write_begin, write_end, and
    perform_write aops") introduced AOP_FLAG_UNINTERRUPTIBLE flag which was
    checked in pagecache_write_begin(), but that check was removed by
    4e02ed4b4a2f ("fs: remove prepare_write/commit_write").
    
    Between these two commits, commit d9414774dc0c ("cifs: Convert cifs to
    new aops.") added a check in cifs_write_begin(), but that check was soon
    removed by commit a98ee8c1c707 ("[CIFS] fix regression in
    cifs_write_begin/cifs_write_end").
    
    Therefore, AOP_FLAG_UNINTERRUPTIBLE flag is checked nowhere.  Let's
    remove this flag.  This patch has no functionality changes.
    
    Link: http://lkml.kernel.org/r/1489294781-53494-1-git-send-email-penguin-kernel@I-love.SAKURA.ne.jp
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Nick Piggin <npiggin@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5d62d2c47939..249dad4e8d26 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -250,9 +250,8 @@ enum positive_aop_returns {
 	AOP_TRUNCATED_PAGE	= 0x80001,
 };
 
-#define AOP_FLAG_UNINTERRUPTIBLE	0x0001 /* will not do a short write */
-#define AOP_FLAG_CONT_EXPAND		0x0002 /* called from cont_expand */
-#define AOP_FLAG_NOFS			0x0004 /* used by filesystem to direct
+#define AOP_FLAG_CONT_EXPAND		0x0001 /* called from cont_expand */
+#define AOP_FLAG_NOFS			0x0002 /* used by filesystem to direct
 						* helper code (eg buffer layer)
 						* to clear GFP_FS from alloc */
 

commit deccf497d804a4c5fca2dbfad2f104675a6f9102
Author: David Howells <dhowells@redhat.com>
Date:   Thu May 4 23:30:16 2017 +0100

    Make stat/lstat/fstatat pass AT_NO_AUTOMOUNT to vfs_statx()
    
    stat/lstat/fstatat need to pass AT_NO_AUTOMOUNT to vfs_statx() as the
    pre-statx code didn't set LOOKUP_AUTOMOUNT, even though fstatat() accepted
    the AT_NO_AUTOMOUNT flag.
    
    Fixes: a528d35e8bfc ("statx: Add a system call to make enhanced file info available")
    Reported-by: Ian Kent <raven@themaw.net>
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Ian Kent <raven@themaw.net>
    cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fc1b4faa6272..866c955314db 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2920,17 +2920,19 @@ extern int vfs_statx_fd(unsigned int, struct kstat *, u32, unsigned int);
 
 static inline int vfs_stat(const char __user *filename, struct kstat *stat)
 {
-	return vfs_statx(AT_FDCWD, filename, 0, stat, STATX_BASIC_STATS);
+	return vfs_statx(AT_FDCWD, filename, AT_NO_AUTOMOUNT,
+			 stat, STATX_BASIC_STATS);
 }
 static inline int vfs_lstat(const char __user *name, struct kstat *stat)
 {
-	return vfs_statx(AT_FDCWD, name, AT_SYMLINK_NOFOLLOW,
+	return vfs_statx(AT_FDCWD, name, AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT,
 			 stat, STATX_BASIC_STATS);
 }
 static inline int vfs_fstatat(int dfd, const char __user *filename,
 			      struct kstat *stat, int flags)
 {
-	return vfs_statx(dfd, filename, flags, stat, STATX_BASIC_STATS);
+	return vfs_statx(dfd, filename, flags | AT_NO_AUTOMOUNT,
+			 stat, STATX_BASIC_STATS);
 }
 static inline int vfs_fstat(int fd, struct kstat *stat)
 {

commit 5133cd7518758211e827481e7d5053333bb926f0
Merge: 7b66f13207e6 4ff33aafd32e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 3 11:05:15 2017 -0700

    Merge branch 'fsnotify' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull fsnotify updates from Jan Kara:
     "The branch contains mainly a rework of fsnotify infrastructure fixing
      a shortcoming that we have waited for response to fanotify permission
      events with SRCU read lock held and when the process consuming events
      was slow to respond the kernel has stalled.
    
      It also contains several cleanups of unnecessary indirections in
      fsnotify framework and a bugfix from Amir fixing leakage of kernel
      internal errno to userspace"
    
    * 'fsnotify' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs: (37 commits)
      fanotify: don't expose EOPENSTALE to userspace
      fsnotify: remove a stray unlock
      fsnotify: Move ->free_mark callback to fsnotify_ops
      fsnotify: Add group pointer in fsnotify_init_mark()
      fsnotify: Drop inode_mark.c
      fsnotify: Remove fsnotify_find_{inode|vfsmount}_mark()
      fsnotify: Remove fsnotify_detach_group_marks()
      fsnotify: Rename fsnotify_clear_marks_by_group_flags()
      fsnotify: Inline fsnotify_clear_{inode|vfsmount}_mark_group()
      fsnotify: Remove fsnotify_recalc_{inode|vfsmount}_mask()
      fsnotify: Remove fsnotify_set_mark_{,ignored_}mask_locked()
      fanotify: Release SRCU lock when waiting for userspace response
      fsnotify: Pass fsnotify_iter_info into handle_event handler
      fsnotify: Provide framework for dropping SRCU lock in ->handle_event
      fsnotify: Remove special handling of mark destruction on group shutdown
      fsnotify: Detach mark from object list when last reference is dropped
      fsnotify: Move queueing of mark for destruction into fsnotify_put_mark()
      inotify: Do not drop mark reference under idr_lock
      fsnotify: Free fsnotify_mark_connector when there is no mark attached
      fsnotify: Lock object list with connector lock
      ...

commit cda37124f4e95ad5ccb11394a5802b0972668b32
Author: Eric Biggers <ebiggers@google.com>
Date:   Sat Mar 25 21:15:37 2017 -0700

    fs: constify tree_descr arrays passed to simple_fill_super()
    
    simple_fill_super() is passed an array of tree_descr structures which
    describe the files to create in the filesystem's root directory.  Since
    these arrays are never modified intentionally, they should be 'const' so
    that they are placed in .rodata and benefit from memory protection.
    This patch updates the function signature and all users, and also
    constifies tree_descr.name.
    
    Signed-off-by: Eric Biggers <ebiggers@google.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dee12c171e07..fc1b4faa6272 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2995,9 +2995,10 @@ extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;
 extern void make_empty_dir_inode(struct inode *inode);
 extern bool is_empty_dir_inode(struct inode *inode);
-struct tree_descr { char *name; const struct file_operations *ops; int mode; };
+struct tree_descr { const char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
-extern int simple_fill_super(struct super_block *, unsigned long, struct tree_descr *);
+extern int simple_fill_super(struct super_block *, unsigned long,
+			     const struct tree_descr *);
 extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
 extern void simple_release_fs(struct vfsmount **mount, int *count);
 

commit a0c111b49bbe11c3970bc668600e3b61fbbb7fca
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Sun Apr 9 09:32:14 2017 +0800

    fs: drop duplicate header percpu-rwsem.h
    
    Drop duplicate header percpu-rwsem.h from linux/fs.h.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7251f7bb45e8..dee12c171e07 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -29,7 +29,6 @@
 #include <linux/lockdep.h>
 #include <linux/percpu-rwsem.h>
 #include <linux/workqueue.h>
-#include <linux/percpu-rwsem.h>
 #include <linux/delayed_call.h>
 
 #include <asm/byteorder.h>

commit 50f2112cf7a3e62a8d33838eb205d5fef306457a
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Tue Apr 11 12:50:09 2017 -0400

    locks: Set FL_CLOSE when removing flock locks on close()
    
    Set FL_CLOSE in fl_flags as in locks_remove_posix() when clearing locks.
    NFS will check for this flag to ensure an unlock is sent in a following
    patch.
    
    Fuse handles flock and posix locks differently for FL_CLOSE, and so
    requires a fixup to retain the existing behavior for flock.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7251f7bb45e8..72061aa65405 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -909,6 +909,8 @@ static inline struct file *get_file(struct file *f)
 #define FL_OFDLCK	1024	/* lock is "owned" by struct file */
 #define FL_LAYOUT	2048	/* outstanding pNFS layout */
 
+#define FL_CLOSE_POSIX (FL_POSIX | FL_CLOSE)
+
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for
  * asynchronous locking.

commit c1844d536dafa5f2cddf4b4841a3634f80a27666
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:47 2017 +0200

    fs: Remove SB_I_DYNBDI flag
    
    Now that all bdi structures filesystems use are properly refcounted, we
    can remove the SB_I_DYNBDI flag.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98cf14ea78c0..30e5c14bd743 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1272,9 +1272,6 @@ struct mm_struct;
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
 
-/* Temporary flag until all filesystems are converted to dynamic bdis */
-#define SB_I_DYNBDI	0x00000100
-
 /* Possible states of 'frozen' field */
 enum {
 	SB_UNFROZEN = 0,		/* FS is unfrozen */

commit fca39346a55bb7196888ffc77d9e3557340d1d0b
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:28 2017 +0200

    fs: Provide infrastructure for dynamic BDIs in filesystems
    
    Provide helper functions for setting up dynamically allocated
    backing_dev_info structures for filesystems and cleaning them up on
    superblock destruction.
    
    CC: linux-mtd@lists.infradead.org
    CC: linux-nfs@vger.kernel.org
    CC: Petr Vandrovec <petr@vandrovec.name>
    CC: linux-nilfs@vger.kernel.org
    CC: cluster-devel@redhat.com
    CC: osd-dev@open-osd.org
    CC: codalist@coda.cs.cmu.edu
    CC: linux-afs@lists.infradead.org
    CC: ecryptfs@vger.kernel.org
    CC: linux-cifs@vger.kernel.org
    CC: ceph-devel@vger.kernel.org
    CC: linux-btrfs@vger.kernel.org
    CC: v9fs-developer@lists.sourceforge.net
    CC: lustre-devel@lists.lustre.org
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7251f7bb45e8..98cf14ea78c0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1272,6 +1272,9 @@ struct mm_struct;
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
 
+/* Temporary flag until all filesystems are converted to dynamic bdis */
+#define SB_I_DYNBDI	0x00000100
+
 /* Possible states of 'frozen' field */
 enum {
 	SB_UNFROZEN = 0,		/* FS is unfrozen */
@@ -2121,6 +2124,9 @@ extern int vfs_ustat(dev_t, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
+extern __printf(2, 3)
+int super_setup_bdi_name(struct super_block *sb, char *fmt, ...);
+extern int super_setup_bdi(struct super_block *sb);
 
 extern int current_umask(void);
 

commit 08991e83b7286635167bab40927665a90fb00d81
Author: Jan Kara <jack@suse.cz>
Date:   Wed Feb 1 09:21:58 2017 +0100

    fsnotify: Free fsnotify_mark_connector when there is no mark attached
    
    Currently we free fsnotify_mark_connector structure only when inode /
    vfsmount is getting freed. This can however impose noticeable memory
    overhead when marks get attached to inodes only temporarily. So free the
    connector structure once the last mark is detached from the object.
    Since notification infrastructure can be working with the connector
    under the protection of fsnotify_mark_srcu, we have to be careful and
    free the fsnotify_mark_connector only after SRCU period passes.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 66e52342be2d..c0b6150c5fcc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -647,7 +647,7 @@ struct inode {
 
 #ifdef CONFIG_FSNOTIFY
 	__u32			i_fsnotify_mask; /* all events this inode cares about */
-	struct fsnotify_mark_connector	*i_fsnotify_marks;
+	struct fsnotify_mark_connector __rcu	*i_fsnotify_marks;
 #endif
 
 #if IS_ENABLED(CONFIG_FS_ENCRYPTION)

commit 9dd813c15b2c101168808d4f5941a29985758973
Author: Jan Kara <jack@suse.cz>
Date:   Tue Mar 14 12:31:02 2017 +0100

    fsnotify: Move mark list head from object into dedicated structure
    
    Currently notification marks are attached to object (inode or vfsmnt) by
    a hlist_head in the object. The list is also protected by a spinlock in
    the object. So while there is any mark attached to the list of marks,
    the object must be pinned in memory (and thus e.g. last iput() deleting
    inode cannot happen). Also for list iteration in fsnotify() to work, we
    must hold fsnotify_mark_srcu lock so that mark itself and
    mark->obj_list.next cannot get freed. Thus we are required to wait for
    response to fanotify events from userspace process with
    fsnotify_mark_srcu lock held. That causes issues when userspace process
    is buggy and does not reply to some event - basically the whole
    notification subsystem gets eventually stuck.
    
    So to be able to drop fsnotify_mark_srcu lock while waiting for
    response, we have to pin the mark in memory and make sure it stays in
    the object list (as removing the mark waiting for response could lead to
    lost notification events for groups later in the list). However we don't
    want inode reclaim to block on such mark as that would lead to system
    just locking up elsewhere.
    
    This commit is the first in the series that paves way towards solving
    these conflicting lifetime needs. Instead of anchoring the list of marks
    directly in the object, we anchor it in a dedicated structure
    (fsnotify_mark_connector) and just point to that structure from the
    object. The following commits will also add spinlock protecting the list
    and object pointer to the structure.
    
    Reviewed-by: Miklos Szeredi <mszeredi@redhat.com>
    Reviewed-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7251f7bb45e8..66e52342be2d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -546,6 +546,8 @@ is_uncached_acl(struct posix_acl *acl)
 #define IOP_XATTR	0x0008
 #define IOP_DEFAULT_READLINK	0x0010
 
+struct fsnotify_mark_connector;
+
 /*
  * Keep mostly read-only and often accessed (especially for
  * the RCU path lookup and 'stat' data) fields at the beginning
@@ -645,7 +647,7 @@ struct inode {
 
 #ifdef CONFIG_FSNOTIFY
 	__u32			i_fsnotify_mask; /* all events this inode cares about */
-	struct hlist_head	i_fsnotify_marks;
+	struct fsnotify_mark_connector	*i_fsnotify_marks;
 #endif
 
 #if IS_ENABLED(CONFIG_FS_ENCRYPTION)

commit cbfd0c1001bedb4b051cf4a1f5df24f1500381bc
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 9 16:16:57 2017 -0800

    include/linux/fs.h: fix unsigned enum warning with gcc-4.2
    
    With arm-linux-gcc-4.2, almost every file we build in the kernel ends up
    with this warning:
    
      include/linux/fs.h:2648: warning: comparison of unsigned expression < 0 is always false
    
    Later versions don't have this problem, but it's easy enough to work
    around.
    
    Link: http://lkml.kernel.org/r/20161216105634.235457-12-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Russell King <rmk+kernel@armlinux.org.uk>
    Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aad3fd0ff5f8..7251f7bb45e8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2678,7 +2678,7 @@ static const char * const kernel_read_file_str[] = {
 
 static inline const char *kernel_read_file_id_str(enum kernel_read_file_id id)
 {
-	if (id < 0 || id >= READING_MAX_ID)
+	if ((unsigned)id >= READING_MAX_ID)
 		return kernel_read_file_str[READING_UNKNOWN];
 
 	return kernel_read_file_str[id];

commit a528d35e8bfcc521d7cb70aaf03e1bd296c8493f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Jan 31 16:46:22 2017 +0000

    statx: Add a system call to make enhanced file info available
    
    Add a system call to make extended file information available, including
    file creation and some attribute flags where available through the
    underlying filesystem.
    
    The getattr inode operation is altered to take two additional arguments: a
    u32 request_mask and an unsigned int flags that indicate the
    synchronisation mode.  This change is propagated to the vfs_getattr*()
    function.
    
    Functions like vfs_stat() are now inline wrappers around new functions
    vfs_statx() and vfs_statx_fd() to reduce stack usage.
    
    ========
    OVERVIEW
    ========
    
    The idea was initially proposed as a set of xattrs that could be retrieved
    with getxattr(), but the general preference proved to be for a new syscall
    with an extended stat structure.
    
    A number of requests were gathered for features to be included.  The
    following have been included:
    
     (1) Make the fields a consistent size on all arches and make them large.
    
     (2) Spare space, request flags and information flags are provided for
         future expansion.
    
     (3) Better support for the y2038 problem [Arnd Bergmann] (tv_sec is an
         __s64).
    
     (4) Creation time: The SMB protocol carries the creation time, which could
         be exported by Samba, which will in turn help CIFS make use of
         FS-Cache as that can be used for coherency data (stx_btime).
    
         This is also specified in NFSv4 as a recommended attribute and could
         be exported by NFSD [Steve French].
    
     (5) Lightweight stat: Ask for just those details of interest, and allow a
         netfs (such as NFS) to approximate anything not of interest, possibly
         without going to the server [Trond Myklebust, Ulrich Drepper, Andreas
         Dilger] (AT_STATX_DONT_SYNC).
    
     (6) Heavyweight stat: Force a netfs to go to the server, even if it thinks
         its cached attributes are up to date [Trond Myklebust]
         (AT_STATX_FORCE_SYNC).
    
    And the following have been left out for future extension:
    
     (7) Data version number: Could be used by userspace NFS servers [Aneesh
         Kumar].
    
         Can also be used to modify fill_post_wcc() in NFSD which retrieves
         i_version directly, but has just called vfs_getattr().  It could get
         it from the kstat struct if it used vfs_xgetattr() instead.
    
         (There's disagreement on the exact semantics of a single field, since
         not all filesystems do this the same way).
    
     (8) BSD stat compatibility: Including more fields from the BSD stat such
         as creation time (st_btime) and inode generation number (st_gen)
         [Jeremy Allison, Bernd Schubert].
    
     (9) Inode generation number: Useful for FUSE and userspace NFS servers
         [Bernd Schubert].
    
         (This was asked for but later deemed unnecessary with the
         open-by-handle capability available and caused disagreement as to
         whether it's a security hole or not).
    
    (10) Extra coherency data may be useful in making backups [Andreas Dilger].
    
         (No particular data were offered, but things like last backup
         timestamp, the data version number and the DOS archive bit would come
         into this category).
    
    (11) Allow the filesystem to indicate what it can/cannot provide: A
         filesystem can now say it doesn't support a standard stat feature if
         that isn't available, so if, for instance, inode numbers or UIDs don't
         exist or are fabricated locally...
    
         (This requires a separate system call - I have an fsinfo() call idea
         for this).
    
    (12) Store a 16-byte volume ID in the superblock that can be returned in
         struct xstat [Steve French].
    
         (Deferred to fsinfo).
    
    (13) Include granularity fields in the time data to indicate the
         granularity of each of the times (NFSv4 time_delta) [Steve French].
    
         (Deferred to fsinfo).
    
    (14) FS_IOC_GETFLAGS value.  These could be translated to BSD's st_flags.
         Note that the Linux IOC flags are a mess and filesystems such as Ext4
         define flags that aren't in linux/fs.h, so translation in the kernel
         may be a necessity (or, possibly, we provide the filesystem type too).
    
         (Some attributes are made available in stx_attributes, but the general
         feeling was that the IOC flags were to ext[234]-specific and shouldn't
         be exposed through statx this way).
    
    (15) Mask of features available on file (eg: ACLs, seclabel) [Brad Boyer,
         Michael Kerrisk].
    
         (Deferred, probably to fsinfo.  Finding out if there's an ACL or
         seclabal might require extra filesystem operations).
    
    (16) Femtosecond-resolution timestamps [Dave Chinner].
    
         (A __reserved field has been left in the statx_timestamp struct for
         this - if there proves to be a need).
    
    (17) A set multiple attributes syscall to go with this.
    
    ===============
    NEW SYSTEM CALL
    ===============
    
    The new system call is:
    
            int ret = statx(int dfd,
                            const char *filename,
                            unsigned int flags,
                            unsigned int mask,
                            struct statx *buffer);
    
    The dfd, filename and flags parameters indicate the file to query, in a
    similar way to fstatat().  There is no equivalent of lstat() as that can be
    emulated with statx() by passing AT_SYMLINK_NOFOLLOW in flags.  There is
    also no equivalent of fstat() as that can be emulated by passing a NULL
    filename to statx() with the fd of interest in dfd.
    
    Whether or not statx() synchronises the attributes with the backing store
    can be controlled by OR'ing a value into the flags argument (this typically
    only affects network filesystems):
    
     (1) AT_STATX_SYNC_AS_STAT tells statx() to behave as stat() does in this
         respect.
    
     (2) AT_STATX_FORCE_SYNC will require a network filesystem to synchronise
         its attributes with the server - which might require data writeback to
         occur to get the timestamps correct.
    
     (3) AT_STATX_DONT_SYNC will suppress synchronisation with the server in a
         network filesystem.  The resulting values should be considered
         approximate.
    
    mask is a bitmask indicating the fields in struct statx that are of
    interest to the caller.  The user should set this to STATX_BASIC_STATS to
    get the basic set returned by stat().  It should be noted that asking for
    more information may entail extra I/O operations.
    
    buffer points to the destination for the data.  This must be 256 bytes in
    size.
    
    ======================
    MAIN ATTRIBUTES RECORD
    ======================
    
    The following structures are defined in which to return the main attribute
    set:
    
            struct statx_timestamp {
                    __s64   tv_sec;
                    __s32   tv_nsec;
                    __s32   __reserved;
            };
    
            struct statx {
                    __u32   stx_mask;
                    __u32   stx_blksize;
                    __u64   stx_attributes;
                    __u32   stx_nlink;
                    __u32   stx_uid;
                    __u32   stx_gid;
                    __u16   stx_mode;
                    __u16   __spare0[1];
                    __u64   stx_ino;
                    __u64   stx_size;
                    __u64   stx_blocks;
                    __u64   __spare1[1];
                    struct statx_timestamp  stx_atime;
                    struct statx_timestamp  stx_btime;
                    struct statx_timestamp  stx_ctime;
                    struct statx_timestamp  stx_mtime;
                    __u32   stx_rdev_major;
                    __u32   stx_rdev_minor;
                    __u32   stx_dev_major;
                    __u32   stx_dev_minor;
                    __u64   __spare2[14];
            };
    
    The defined bits in request_mask and stx_mask are:
    
            STATX_TYPE              Want/got stx_mode & S_IFMT
            STATX_MODE              Want/got stx_mode & ~S_IFMT
            STATX_NLINK             Want/got stx_nlink
            STATX_UID               Want/got stx_uid
            STATX_GID               Want/got stx_gid
            STATX_ATIME             Want/got stx_atime{,_ns}
            STATX_MTIME             Want/got stx_mtime{,_ns}
            STATX_CTIME             Want/got stx_ctime{,_ns}
            STATX_INO               Want/got stx_ino
            STATX_SIZE              Want/got stx_size
            STATX_BLOCKS            Want/got stx_blocks
            STATX_BASIC_STATS       [The stuff in the normal stat struct]
            STATX_BTIME             Want/got stx_btime{,_ns}
            STATX_ALL               [All currently available stuff]
    
    stx_btime is the file creation time, stx_mask is a bitmask indicating the
    data provided and __spares*[] are where as-yet undefined fields can be
    placed.
    
    Time fields are structures with separate seconds and nanoseconds fields
    plus a reserved field in case we want to add even finer resolution.  Note
    that times will be negative if before 1970; in such a case, the nanosecond
    fields will also be negative if not zero.
    
    The bits defined in the stx_attributes field convey information about a
    file, how it is accessed, where it is and what it does.  The following
    attributes map to FS_*_FL flags and are the same numerical value:
    
            STATX_ATTR_COMPRESSED           File is compressed by the fs
            STATX_ATTR_IMMUTABLE            File is marked immutable
            STATX_ATTR_APPEND               File is append-only
            STATX_ATTR_NODUMP               File is not to be dumped
            STATX_ATTR_ENCRYPTED            File requires key to decrypt in fs
    
    Within the kernel, the supported flags are listed by:
    
            KSTAT_ATTR_FS_IOC_FLAGS
    
    [Are any other IOC flags of sufficient general interest to be exposed
    through this interface?]
    
    New flags include:
    
            STATX_ATTR_AUTOMOUNT            Object is an automount trigger
    
    These are for the use of GUI tools that might want to mark files specially,
    depending on what they are.
    
    Fields in struct statx come in a number of classes:
    
     (0) stx_dev_*, stx_blksize.
    
         These are local system information and are always available.
    
     (1) stx_mode, stx_nlinks, stx_uid, stx_gid, stx_[amc]time, stx_ino,
         stx_size, stx_blocks.
    
         These will be returned whether the caller asks for them or not.  The
         corresponding bits in stx_mask will be set to indicate whether they
         actually have valid values.
    
         If the caller didn't ask for them, then they may be approximated.  For
         example, NFS won't waste any time updating them from the server,
         unless as a byproduct of updating something requested.
    
         If the values don't actually exist for the underlying object (such as
         UID or GID on a DOS file), then the bit won't be set in the stx_mask,
         even if the caller asked for the value.  In such a case, the returned
         value will be a fabrication.
    
         Note that there are instances where the type might not be valid, for
         instance Windows reparse points.
    
     (2) stx_rdev_*.
    
         This will be set only if stx_mode indicates we're looking at a
         blockdev or a chardev, otherwise will be 0.
    
     (3) stx_btime.
    
         Similar to (1), except this will be set to 0 if it doesn't exist.
    
    =======
    TESTING
    =======
    
    The following test program can be used to test the statx system call:
    
            samples/statx/test-statx.c
    
    Just compile and run, passing it paths to the files you want to examine.
    The file is built automatically if CONFIG_SAMPLES is enabled.
    
    Here's some example output.  Firstly, an NFS directory that crosses to
    another FSID.  Note that the AUTOMOUNT attribute is set because transiting
    this directory will cause d_automount to be invoked by the VFS.
    
            [root@andromeda ~]# /tmp/test-statx -A /warthog/data
            statx(/warthog/data) = 0
            results=7ff
              Size: 4096            Blocks: 8          IO Block: 1048576  directory
            Device: 00:26           Inode: 1703937     Links: 125
            Access: (3777/drwxrwxrwx)  Uid:     0   Gid:  4041
            Access: 2016-11-24 09:02:12.219699527+0000
            Modify: 2016-11-17 10:44:36.225653653+0000
            Change: 2016-11-17 10:44:36.225653653+0000
            Attributes: 0000000000001000 (-------- -------- -------- -------- -------- -------- ---m---- --------)
    
    Secondly, the result of automounting on that directory.
    
            [root@andromeda ~]# /tmp/test-statx /warthog/data
            statx(/warthog/data) = 0
            results=7ff
              Size: 4096            Blocks: 8          IO Block: 1048576  directory
            Device: 00:27           Inode: 2           Links: 125
            Access: (3777/drwxrwxrwx)  Uid:     0   Gid:  4041
            Access: 2016-11-24 09:02:12.219699527+0000
            Modify: 2016-11-17 10:44:36.225653653+0000
            Change: 2016-11-17 10:44:36.225653653+0000
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 52350947c670..aad3fd0ff5f8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1709,7 +1709,7 @@ struct inode_operations {
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);
-	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+	int (*getattr) (const struct path *, struct kstat *, u32, unsigned int);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
@@ -2902,8 +2902,8 @@ extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern void kfree_link(void *);
 extern void generic_fillattr(struct inode *, struct kstat *);
-int vfs_getattr_nosec(struct path *path, struct kstat *stat);
-extern int vfs_getattr(struct path *, struct kstat *);
+extern int vfs_getattr_nosec(const struct path *, struct kstat *, u32, unsigned int);
+extern int vfs_getattr(const struct path *, struct kstat *, u32, unsigned int);
 void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
 void __inode_sub_bytes(struct inode *inode, loff_t bytes);
@@ -2916,10 +2916,29 @@ extern const struct inode_operations simple_symlink_inode_operations;
 
 extern int iterate_dir(struct file *, struct dir_context *);
 
-extern int vfs_stat(const char __user *, struct kstat *);
-extern int vfs_lstat(const char __user *, struct kstat *);
-extern int vfs_fstat(unsigned int, struct kstat *);
-extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
+extern int vfs_statx(int, const char __user *, int, struct kstat *, u32);
+extern int vfs_statx_fd(unsigned int, struct kstat *, u32, unsigned int);
+
+static inline int vfs_stat(const char __user *filename, struct kstat *stat)
+{
+	return vfs_statx(AT_FDCWD, filename, 0, stat, STATX_BASIC_STATS);
+}
+static inline int vfs_lstat(const char __user *name, struct kstat *stat)
+{
+	return vfs_statx(AT_FDCWD, name, AT_SYMLINK_NOFOLLOW,
+			 stat, STATX_BASIC_STATS);
+}
+static inline int vfs_fstatat(int dfd, const char __user *filename,
+			      struct kstat *stat, int flags)
+{
+	return vfs_statx(dfd, filename, flags, stat, STATX_BASIC_STATS);
+}
+static inline int vfs_fstat(int fd, struct kstat *stat)
+{
+	return vfs_statx_fd(fd, stat, STATX_BASIC_STATS, 0);
+}
+
+
 extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
 extern int vfs_readlink(struct dentry *, char __user *, int);
 
@@ -2949,7 +2968,7 @@ extern int dcache_dir_close(struct inode *, struct file *);
 extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
 extern int dcache_readdir(struct file *, struct dir_context *);
 extern int simple_setattr(struct dentry *, struct iattr *);
-extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+extern int simple_getattr(const struct path *, struct kstat *, u32, unsigned int);
 extern int simple_statfs(struct dentry *, struct kstatfs *);
 extern int simple_open(struct inode *inode, struct file *file);
 extern int simple_link(struct dentry *, struct inode *, struct dentry *);

commit 94e877d0fb43bec0540d6a37d49cb4f7f05a5348
Merge: 69fd110eb650 653a7746fa2f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 2 15:20:00 2017 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile two from Al Viro:
    
     - orangefs fix
    
     - series of fs/namei.c cleanups from me
    
     - VFS stuff coming from overlayfs tree
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      orangefs: Use RCU for destroy_inode
      vfs: use helper for calling f_op->fsync()
      mm: use helper for calling f_op->mmap()
      vfs: use helpers for calling f_op->{read,write}_iter()
      vfs: pass type instead of fn to do_{loop,iter}_readv_writev()
      vfs: extract common parts of {compat_,}do_readv_writev()
      vfs: wrap write f_ops with file_{start,end}_write()
      vfs: deny copy_file_range() for non regular files
      vfs: deny fallocate() on directory
      vfs: create vfs helper vfs_tmpfile()
      namei.c: split unlazy_walk()
      namei.c: fold the check for DCACHE_OP_REVALIDATE into d_revalidate()
      lookup_fast(): clean up the logics around the fallback to non-rcu mode
      namei: fold unlazy_link() into its sole caller

commit 653a7746fa2f5369985f5368ffc162b6510db6c8
Merge: f6c99aad4d9f 0eb8af4916a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Mar 2 06:41:22 2017 -0500

    Merge remote-tracking branch 'ovl/for-viro' into for-linus
    
    Overlayfs-related series from Miklos and Amir

commit 93407472a21b82f39c955ea7787e5bc7da100642
Author: Fabian Frederick <fabf@skynet.be>
Date:   Mon Feb 27 14:28:32 2017 -0800

    fs: add i_blocksize()
    
    Replace all 1 << inode->i_blkbits and (1 << inode->i_blkbits) in fs
    branch.
    
    This patch also fixes multiple checkpatch warnings: WARNING: Prefer
    'unsigned int' to bare use of 'unsigned'
    
    Thanks to Andrew Morton for suggesting more appropriate function instead
    of macro.
    
    [geliangtang@gmail.com: truncate: use i_blocksize()]
      Link: http://lkml.kernel.org/r/9c8b2cd83c8f5653805d43debde9fa8817e02fc4.1484895804.git.geliangtang@gmail.com
    Link: http://lkml.kernel.org/r/1481319905-10126-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c930cbc19342..c64f2cb7d364 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -655,6 +655,11 @@ struct inode {
 	void			*i_private; /* fs or device private pointer */
 };
 
+static inline unsigned int i_blocksize(const struct inode *node)
+{
+	return (1 << node->i_blkbits);
+}
+
 static inline int inode_unhashed(struct inode *inode)
 {
 	return hlist_unhashed(&inode->i_hash);

commit 0eb8af4916a540c362a2950e5ab54eca32eb7d58
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Feb 20 16:51:23 2017 +0100

    vfs: use helper for calling f_op->fsync()
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 93691b59e476..72a33007ec24 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1732,6 +1732,12 @@ static inline int call_mmap(struct file *file, struct vm_area_struct *vma)
 	return file->f_op->mmap(file, vma);
 }
 
+static inline int call_fsync(struct file *file, loff_t start, loff_t end,
+			     int datasync)
+{
+	return file->f_op->fsync(file, start, end, datasync);
+}
+
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,

commit f74ac01520c9f6d89bbc3c6931a72f757b742f86
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Feb 20 16:51:23 2017 +0100

    mm: use helper for calling f_op->mmap()
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a3145cdff8f2..93691b59e476 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1727,6 +1727,11 @@ static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,
 	return file->f_op->write_iter(kio, iter);
 }
 
+static inline int call_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return file->f_op->mmap(file, vma);
+}
+
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,

commit bb7462b6fd64e40809a857223bf7f0e628969f87
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Mon Feb 20 16:51:23 2017 +0100

    vfs: use helpers for calling f_op->{read,write}_iter()
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 78c81e6f5d76..a3145cdff8f2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1715,6 +1715,18 @@ struct inode_operations {
 	int (*set_acl)(struct inode *, struct posix_acl *, int);
 } ____cacheline_aligned;
 
+static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,
+				     struct iov_iter *iter)
+{
+	return file->f_op->read_iter(kio, iter);
+}
+
+static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio,
+				      struct iov_iter *iter)
+{
+	return file->f_op->write_iter(kio, iter);
+}
+
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,

commit bfe219d373cadab761373aeea4c70406bc27ea2c
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 31 10:34:57 2017 +0200

    vfs: wrap write f_ops with file_{start,end}_write()
    
    Before calling write f_ops, call file_start_write() instead
    of sb_start_write().
    
    Replace {sb,file}_start_write() for {copy,clone}_file_range() and
    for fallocate().
    
    Beyond correct semantics, this avoids freeze protection to sb when
    operating on special inodes, such as fallocate() on a blockdev.
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a7f3cc9edab..78c81e6f5d76 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1741,19 +1741,6 @@ extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
 extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
 
-static inline int do_clone_file_range(struct file *file_in, loff_t pos_in,
-				      struct file *file_out, loff_t pos_out,
-				      u64 len)
-{
-	int ret;
-
-	sb_start_write(file_inode(file_out)->i_sb);
-	ret = vfs_clone_file_range(file_in, pos_in, file_out, pos_out, len);
-	sb_end_write(file_inode(file_out)->i_sb);
-
-	return ret;
-}
-
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);
 	void (*destroy_inode)(struct inode *);
@@ -2564,6 +2551,19 @@ static inline void file_end_write(struct file *file)
 	__sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);
 }
 
+static inline int do_clone_file_range(struct file *file_in, loff_t pos_in,
+				      struct file *file_out, loff_t pos_out,
+				      u64 len)
+{
+	int ret;
+
+	file_start_write(file_out);
+	ret = vfs_clone_file_range(file_in, pos_in, file_out, pos_out, len);
+	file_end_write(file_out);
+
+	return ret;
+}
+
 /*
  * get_write_access() gets write permission for a file.
  * put_write_access() releases this write permission.

commit af7bd4dc13093bf1477f370722bbab24cf457b91
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Tue Jan 17 06:34:52 2017 +0200

    vfs: create vfs helper vfs_tmpfile()
    
    Factor out some common vfs bits from do_tmpfile()
    to be used by overlayfs for concurrent copy up.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2ba074328894..4a7f3cc9edab 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1561,6 +1561,9 @@ extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
 extern int vfs_whiteout(struct inode *, struct dentry *);
 
+extern struct dentry *vfs_tmpfile(struct dentry *dentry, umode_t mode,
+				  int open_flag);
+
 /*
  * VFS file helper functions.
  */

commit b1d2dc5659b41741f5a29b2ade76ffb4e5bb13d8
Author: Jan Kara <jack@suse.cz>
Date:   Thu Feb 2 15:56:52 2017 +0100

    block: Make blk_get_backing_dev_info() safe without open bdev
    
    Currenly blk_get_backing_dev_info() is not safe to be called when the
    block device is not open as bdev->bd_disk is NULL in that case. However
    inode_to_bdi() uses this function and may be call called from flusher
    worker or other writeback related functions without bdev being open
    which leads to crashes such as:
    
    [113031.075540] Unable to handle kernel paging request for data at address 0x00000000
    [113031.075614] Faulting instruction address: 0xc0000000003692e0
    0:mon> t
    [c0000000fb65f900] c00000000036cb6c writeback_sb_inodes+0x30c/0x590
    [c0000000fb65fa10] c00000000036ced4 __writeback_inodes_wb+0xe4/0x150
    [c0000000fb65fa70] c00000000036d33c wb_writeback+0x30c/0x450
    [c0000000fb65fb40] c00000000036e198 wb_workfn+0x268/0x580
    [c0000000fb65fc50] c0000000000f3470 process_one_work+0x1e0/0x590
    [c0000000fb65fce0] c0000000000f38c8 worker_thread+0xa8/0x660
    [c0000000fb65fd80] c0000000000fc4b0 kthread+0x110/0x130
    [c0000000fb65fe30] c0000000000098f0 ret_from_kernel_thread+0x5c/0x6c
    
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 702cb6c50194..c930cbc19342 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -423,6 +423,7 @@ struct block_device {
 	int			bd_invalidated;
 	struct gendisk *	bd_disk;
 	struct request_queue *  bd_queue;
+	struct backing_dev_info *bd_bdi;
 	struct list_head	bd_list;
 	/*
 	 * Private data.  You must have bd_claim'ed the block_device

commit f44f1ab5a2dcd4e16eab850fd08e40ff2d0c28d4
Author: Jan Kara <jack@suse.cz>
Date:   Thu Feb 2 15:56:49 2017 +0100

    block: Unhash block device inodes on gendisk destruction
    
    Currently, block device inodes stay around after corresponding gendisk
    hash died until memory reclaim finds them and frees them. Since we will
    make block device inode pin the bdi, we want to free the block device
    inode as soon as the device goes away so that bdi does not stay around
    unnecessarily. Furthermore we need to avoid issues when new device with
    the same major,minor pair gets created since reusing the bdi structure
    would be rather difficult in this case.
    
    Unhashing block device inode on gendisk destruction nicely deals with
    these problems. Once last block device inode reference is dropped (which
    may be directly in del_gendisk()), the inode gets evicted. Furthermore if
    the major,minor pair gets reallocated, we are guaranteed to get new
    block device inode even if old block device inode is not yet evicted and
    thus we avoid issues with possible reuse of bdi.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2ba074328894..702cb6c50194 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2342,6 +2342,7 @@ extern struct kmem_cache *names_cachep;
 #ifdef CONFIG_BLOCK
 extern int register_blkdev(unsigned int, const char *);
 extern void unregister_blkdev(unsigned int, const char *);
+extern void bdev_unhash_inode(dev_t dev);
 extern struct block_device *bdget(dev_t);
 extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);

commit e93b1cc8a8965da137ffea0b88e5f62fa1d2a9e6
Merge: 45d36906e256 2700e6067c72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 19 08:23:53 2016 -0800

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull quota, fsnotify and ext2 updates from Jan Kara:
     "Changes to locking of some quota operations from dedicated quota mutex
      to s_umount semaphore, a fsnotify fix and a simple ext2 fix"
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      quota: Fix bogus warning in dquot_disable()
      fsnotify: Fix possible use-after-free in inode iteration on umount
      ext2: reject inodes with negative size
      quota: Remove dqonoff_mutex
      ocfs2: Use s_umount for quota recovery protection
      quota: Remove dqonoff_mutex from dquot_scan_active()
      ocfs2: Protect periodic quota syncing with s_umount semaphore
      quota: Use s_umount protection for quota operations
      quota: Hold s_umount in exclusive mode when enabling / disabling quotas
      fs: Provide function to get superblock with exclusive s_umount

commit 231753ef780012eb6f3922c3dfc0a7186baa33c2
Merge: 0110c350c86d d16744ec8ad0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 17 19:16:12 2016 -0800

    Merge uncontroversial parts of branch 'readlink' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull partial readlink cleanups from Miklos Szeredi.
    
    This is the uncontroversial part of the readlink cleanup patch-set that
    simplifies the default readlink handling.
    
    Miklos and Al are still discussing the rest of the series.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      vfs: make generic_readlink() static
      vfs: remove ".readlink = generic_readlink" assignments
      vfs: default to generic_readlink()
      vfs: replace calling i_op->readlink with vfs_readlink()
      proc/self: use generic_readlink
      ecryptfs: use vfs_get_link()
      bad_inode: add missing i_op initializers

commit 0110c350c86d511be2130cb2a30dcbb76c4af750
Merge: d9cb5bfcc333 9763f7a4a5f7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 17 18:44:00 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     "In this pile:
    
       - autofs-namespace series
       - dedupe stuff
       - more struct path constification"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (40 commits)
      ocfs2: implement the VFS clone_range, copy_range, and dedupe_range features
      ocfs2: charge quota for reflinked blocks
      ocfs2: fix bad pointer cast
      ocfs2: always unlock when completing dio writes
      ocfs2: don't eat io errors during _dio_end_io_write
      ocfs2: budget for extent tree splits when adding refcount flag
      ocfs2: prohibit refcounted swapfiles
      ocfs2: add newlines to some error messages
      ocfs2: convert inode refcount test to a helper
      simple_write_end(): don't zero in short copy into uptodate
      exofs: don't mess with simple_write_{begin,end}
      9p: saner ->write_end() on failing copy into non-uptodate page
      fix gfs2_stuffed_write_end() on short copies
      fix ceph_write_end()
      nfs_write_end(): fix handling of short copies
      vfs: refactor clone/dedupe_file_range common functions
      fs: try to clone files first in vfs_copy_file_range
      vfs: misc struct path constification
      namespace.c: constify struct path passed to a bunch of primitives
      quota: constify struct path in quota_on
      ...

commit 3c55d6bcfe8163ff2b5636b4aabe3caa3f5d95f4
Merge: 4da00fd1b948 29ac8e856cb3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 16 16:21:05 2016 -0500

    Merge remote-tracking branch 'djwong/ocfs2-vfs-reflink-6' into for-linus

commit ff0f962ca3c38239b299a70e7eea27abfbb979c3
Merge: 087a76d390cb c3c869966480
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 10:58:12 2016 -0800

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This update contains:
    
       - try to clone on copy-up
    
       - allow renaming a directory
    
       - split source into managable chunks
    
       - misc cleanups and fixes
    
      It does not contain the read-only fd data inconsistency fix, which Al
      didn't like. I'll leave that to the next year..."
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs: (36 commits)
      ovl: fix reStructuredText syntax errors in documentation
      ovl: fix return value of ovl_fill_super
      ovl: clean up kstat usage
      ovl: fold ovl_copy_up_truncate() into ovl_copy_up()
      ovl: create directories inside merged parent opaque
      ovl: opaque cleanup
      ovl: show redirect_dir mount option
      ovl: allow setting max size of redirect
      ovl: allow redirect_dir to default to "on"
      ovl: check for emptiness of redirect dir
      ovl: redirect on rename-dir
      ovl: lookup redirects
      ovl: consolidate lookup for underlying layers
      ovl: fix nested overlayfs mount
      ovl: check namelen
      ovl: split super.c
      ovl: use d_is_dir()
      ovl: simplify lookup
      ovl: check lower existence of rename target
      ovl: rename: simplify handling of lower/merged directory
      ...

commit 031a072a0b8ac2646def77aa310a95016c884bb0
Author: Amir Goldstein <amir73il@gmail.com>
Date:   Fri Sep 23 11:38:11 2016 +0300

    vfs: call vfs_clone_file_range() under freeze protection
    
    Move sb_start_write()/sb_end_write() out of the vfs helper and up into the
    ioctl handler.
    
    Signed-off-by: Amir Goldstein <amir73il@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dc0478c07b2a..52663f1f3084 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1783,6 +1783,19 @@ extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
 
+static inline int do_clone_file_range(struct file *file_in, loff_t pos_in,
+				      struct file *file_out, loff_t pos_out,
+				      u64 len)
+{
+	int ret;
+
+	sb_start_write(file_inode(file_out)->i_sb);
+	ret = vfs_clone_file_range(file_in, pos_in, file_out, pos_out, len);
+	sb_end_write(file_inode(file_out)->i_sb);
+
+	return ret;
+}
+
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);
 	void (*destroy_inode)(struct inode *);

commit 36869cb93d36269f34800b3384ba7991060a69cf
Merge: 9439b3710df6 7cd54aa84389
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 10:19:16 2016 -0800

    Merge branch 'for-4.10/block' of git://git.kernel.dk/linux-block
    
    Pull block layer updates from Jens Axboe:
     "This is the main block pull request this series. Contrary to previous
      release, I've kept the core and driver changes in the same branch. We
      always ended up having dependencies between the two for obvious
      reasons, so makes more sense to keep them together. That said, I'll
      probably try and keep more topical branches going forward, especially
      for cycles that end up being as busy as this one.
    
      The major parts of this pull request is:
    
       - Improved support for O_DIRECT on block devices, with a small
         private implementation instead of using the pig that is
         fs/direct-io.c. From Christoph.
    
       - Request completion tracking in a scalable fashion. This is utilized
         by two components in this pull, the new hybrid polling and the
         writeback queue throttling code.
    
       - Improved support for polling with O_DIRECT, adding a hybrid mode
         that combines pure polling with an initial sleep. From me.
    
       - Support for automatic throttling of writeback queues on the block
         side. This uses feedback from the device completion latencies to
         scale the queue on the block side up or down. From me.
    
       - Support from SMR drives in the block layer and for SD. From Hannes
         and Shaun.
    
       - Multi-connection support for nbd. From Josef.
    
       - Cleanup of request and bio flags, so we have a clear split between
         which are bio (or rq) private, and which ones are shared. From
         Christoph.
    
       - A set of patches from Bart, that improve how we handle queue
         stopping and starting in blk-mq.
    
       - Support for WRITE_ZEROES from Chaitanya.
    
       - Lightnvm updates from Javier/Matias.
    
       - Supoort for FC for the nvme-over-fabrics code. From James Smart.
    
       - A bunch of fixes from a whole slew of people, too many to name
         here"
    
    * 'for-4.10/block' of git://git.kernel.dk/linux-block: (182 commits)
      blk-stat: fix a few cases of missing batch flushing
      blk-flush: run the queue when inserting blk-mq flush
      elevator: make the rqhash helpers exported
      blk-mq: abstract out blk_mq_dispatch_rq_list() helper
      blk-mq: add blk_mq_start_stopped_hw_queue()
      block: improve handling of the magic discard payload
      blk-wbt: don't throttle discard or write zeroes
      nbd: use dev_err_ratelimited in io path
      nbd: reset the setup task for NBD_CLEAR_SOCK
      nvme-fabrics: Add FC LLDD loopback driver to test FC-NVME
      nvme-fabrics: Add target support for FC transport
      nvme-fabrics: Add host support for FC transport
      nvme-fabrics: Add FC transport LLDD api definitions
      nvme-fabrics: Add FC transport FC-NVME definitions
      nvme-fabrics: Add FC transport error codes to nvme.h
      Add type 0x28 NVME type code to scsi fc headers
      nvme-fabrics: patch target code in prep for FC transport support
      nvme-fabrics: set sqe.command_id in core not transports
      parser: add u64 number parser
      nvme-rdma: align to generic ib_event logging helper
      ...

commit 876bec6f9bbfcb394916d17e35226b086c04dc45
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Fri Dec 9 16:18:30 2016 -0800

    vfs: refactor clone/dedupe_file_range common functions
    
    Hoist both the XFS reflink inode state and preparation code and the XFS
    file blocks compare functions into the VFS so that ocfs2 can take
    advantage of it for reflink and dedupe.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dc0478c07b2a..caea736fa09c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1778,8 +1778,14 @@ extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *, int);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
+extern int vfs_clone_file_prep_inodes(struct inode *inode_in, loff_t pos_in,
+				      struct inode *inode_out, loff_t pos_out,
+				      u64 *len, bool is_dedupe);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 		struct file *file_out, loff_t pos_out, u64 len);
+extern int vfs_dedupe_file_range_compare(struct inode *src, loff_t srcoff,
+					 struct inode *dest, loff_t destoff,
+					 loff_t len, bool *is_same);
 extern int vfs_dedupe_file_range(struct file *file,
 				 struct file_dedupe_range *same);
 

commit d16744ec8ad011793144bb932ce822cc0c1733cb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 9 16:45:04 2016 +0100

    vfs: make generic_readlink() static
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f6c206eae6ac..e343d784651a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2915,7 +2915,6 @@ extern int __page_symlink(struct inode *inode, const char *symname, int len,
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern void kfree_link(void *);
-extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat);
 extern int vfs_getattr(struct path *, struct kstat *);

commit 76fca90e9f3abc82114d9d02d8e14e0324a18ca2
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 9 16:45:04 2016 +0100

    vfs: default to generic_readlink()
    
    If i_op->readlink is NULL, but i_op->get_link is set then vfs_readlink()
    defaults to calling generic_readlink().
    
    The IOP_DEFAULT_READLINK flag indicates that the above conditions are met
    and the default action can be taken.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eba20d1c068d..f6c206eae6ac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -595,6 +595,7 @@ is_uncached_acl(struct posix_acl *acl)
 #define IOP_LOOKUP	0x0002
 #define IOP_NOFOLLOW	0x0004
 #define IOP_XATTR	0x0008
+#define IOP_DEFAULT_READLINK	0x0010
 
 /*
  * Keep mostly read-only and often accessed (especially for

commit fd4a0edf2a3d781c6ae07d2810776ce22302ee1c
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Dec 9 16:45:04 2016 +0100

    vfs: replace calling i_op->readlink with vfs_readlink()
    
    Also check d_is_symlink() in callers instead of inode->i_op->readlink
    because following patches will allow NULL ->readlink for symlinks.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dc0478c07b2a..eba20d1c068d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2935,6 +2935,7 @@ extern int vfs_lstat(const char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
 extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
+extern int vfs_readlink(struct dentry *, char __user *, int);
 
 extern int __generic_block_fiemap(struct inode *inode,
 				  struct fiemap_extent_info *fieinfo,

commit f0bb5aaf2c51267c49ed5e2c6103df22acfe30f5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 20 20:27:12 2016 -0500

    vfs: misc struct path constification
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3056fe46f336..0e177d395efb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2127,7 +2127,7 @@ extern struct vfsmount *collect_mounts(const struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 			  struct vfsmount *);
-extern int vfs_statfs(struct path *, struct kstatfs *);
+extern int vfs_statfs(const struct path *, struct kstatfs *);
 extern int user_statfs(const char __user *, struct kstatfs *);
 extern int fd_statfs(int, struct kstatfs *);
 extern int vfs_ustat(dev_t, struct kstatfs *);

commit ca71cf71eeda04dc9ad18271504e499013af5415
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Nov 20 19:45:28 2016 -0500

    namespace.c: constify struct path passed to a bunch of primitives
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f96501b51c49..3056fe46f336 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2123,7 +2123,7 @@ extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
 extern long do_mount(const char *, const char __user *,
 		     const char *, unsigned long, void *);
-extern struct vfsmount *collect_mounts(struct path *);
+extern struct vfsmount *collect_mounts(const struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 			  struct vfsmount *);

commit 640eb7e7b5242af53c456552a526d0080e6333f8
Author: Mickal Salan <mic@digikod.net>
Date:   Mon Nov 14 22:14:35 2016 +0100

    fs: Constify path_is_under()'s arguments
    
    The function path_is_under() doesn't modify the paths pointed by its
    arguments but only browse them. Constifying this pointers make a cleaner
    interface to be used by (future) code which may only have access to
    const struct path pointers (e.g. LSM hooks).
    
    Signed-off-by: Mickal Salan <mic@digikod.net>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dc0478c07b2a..f96501b51c49 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2709,7 +2709,7 @@ extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */
 extern bool is_subdir(struct dentry *, struct dentry *);
-extern bool path_is_under(struct path *, struct path *);
+extern bool path_is_under(const struct path *, const struct path *);
 
 extern char *file_path(struct file *, char *, int);
 

commit ba6379f7e6c7e51b3c0e92672bc61bb6961c2b5e
Author: Jan Kara <jack@suse.cz>
Date:   Wed Nov 23 12:53:00 2016 +0100

    fs: Provide function to get superblock with exclusive s_umount
    
    Quota code will need a variant of get_super_thawed() that returns
    superblock with s_umount held in exclusive mode to serialize quota on
    and quota off operations. Provide this functionality.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dc0478c07b2a..d04cfdefcd11 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2949,8 +2949,10 @@ extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);
 extern struct super_block *get_super_thawed(struct block_device *);
+extern struct super_block *get_super_exclusive_thawed(struct block_device *bdev);
 extern struct super_block *get_active_super(struct block_device *bdev);
 extern void drop_super(struct super_block *sb);
+extern void drop_super_exclusive(struct super_block *sb);
 extern void iterate_supers(void (*)(struct super_block *, void *), void *);
 extern void iterate_supers_type(struct file_system_type *,
 			        void (*)(struct super_block *, void *), void *);

commit 2f8b544477e627a42e66902e948d87f86554aeca
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:13 2016 -0600

    block,fs: untangle fs.h and blk_types.h
    
    Nothing in fs.h should require blk_types.h to be included.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5b0a9b77534d..8533e9d59c29 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -28,7 +28,6 @@
 #include <linux/uidgid.h>
 #include <linux/lockdep.h>
 #include <linux/percpu-rwsem.h>
-#include <linux/blk_types.h>
 #include <linux/workqueue.h>
 #include <linux/percpu-rwsem.h>
 #include <linux/delayed_call.h>
@@ -38,6 +37,7 @@
 
 struct backing_dev_info;
 struct bdi_writeback;
+struct bio;
 struct export_operations;
 struct hd_geometry;
 struct iovec;

commit 1e3914d4cf4e14653b7917b0e965217465cb7a9c
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:12 2016 -0600

    block, fs: move submit_bio to bio.h
    
    This is where all the other bio operations live, so users must include
    bio.h anyway.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0ad36e0c7fa7..5b0a9b77534d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2717,7 +2717,6 @@ static inline void remove_inode_hash(struct inode *inode)
 extern void inode_sb_list_add(struct inode *inode);
 
 #ifdef CONFIG_BLOCK
-extern blk_qc_t submit_bio(struct bio *);
 extern int bdev_read_only(struct block_device *);
 #endif
 extern int set_blocksize(struct block_device *, int);

commit d38499530e5f170d30f32d3841fade204e63081d
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:11 2016 -0600

    fs: decouple READ and WRITE from the block layer ops
    
    Move READ and WRITE to kernel.h and don't define them in terms of block
    layer ops; they are our generic data direction indicators these days
    and have no more resemblance with the block layer ops.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a1b78ab7c15..0ad36e0c7fa7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -151,11 +151,6 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  */
 #define CHECK_IOVEC_ONLY -1
 
-#define RW_MASK			REQ_OP_WRITE
-
-#define READ			REQ_OP_READ
-#define WRITE			REQ_OP_WRITE
-
 /*
  * Attribute flags.  These should be or-ed together to figure out what
  * has been changed!
@@ -2452,14 +2447,6 @@ extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
-/*
- * return data direction, READ or WRITE
- */
-static inline int bio_data_dir(struct bio *bio)
-{
-	return op_is_write(bio_op(bio)) ? WRITE : READ;
-}
-
 extern void check_disk_size_change(struct gendisk *disk,
 				   struct block_device *bdev);
 extern int revalidate_disk(struct gendisk *);

commit 70fd76140a6cb63262bd47b68d57b42e889c10ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:10 2016 -0600

    block,fs: use REQ_* flags directly
    
    Remove the WRITE_* and READ_SYNC wrappers, and just use the flags
    directly.  Where applicable this also drops usage of the
    bio_set_op_attrs wrapper.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 46a74209917f..7a1b78ab7c15 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -151,58 +151,11 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  */
 #define CHECK_IOVEC_ONLY -1
 
-/*
- * The below are the various read and write flags that we support. Some of
- * them include behavioral modifiers that send information down to the
- * block layer and IO scheduler. They should be used along with a req_op.
- * Terminology:
- *
- *	The block layer uses device plugging to defer IO a little bit, in
- *	the hope that we will see more IO very shortly. This increases
- *	coalescing of adjacent IO and thus reduces the number of IOs we
- *	have to send to the device. It also allows for better queuing,
- *	if the IO isn't mergeable. If the caller is going to be waiting
- *	for the IO, then he must ensure that the device is unplugged so
- *	that the IO is dispatched to the driver.
- *
- *	All IO is handled async in Linux. This is fine for background
- *	writes, but for reads or writes that someone waits for completion
- *	on, we want to notify the block layer and IO scheduler so that they
- *	know about it. That allows them to make better scheduling
- *	decisions. So when the below references 'sync' and 'async', it
- *	is referencing this priority hint.
- *
- * With that in mind, the available types are:
- *
- * READ			A normal read operation. Device will be plugged.
- * READ_SYNC		A synchronous read. Device is not plugged, caller can
- *			immediately wait on this read without caring about
- *			unplugging.
- * WRITE		A normal async write. Device will be plugged.
- * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down
- *			the hint that someone will be waiting on this IO
- *			shortly. The write equivalent of READ_SYNC.
- * WRITE_ODIRECT	Special case write for O_DIRECT only.
- * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
- * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
- *			non-volatile media on completion.
- * WRITE_FLUSH_FUA	Combination of WRITE_FLUSH and FUA. The IO is preceded
- *			by a cache flush and data is guaranteed to be on
- *			non-volatile media on completion.
- *
- */
 #define RW_MASK			REQ_OP_WRITE
 
 #define READ			REQ_OP_READ
 #define WRITE			REQ_OP_WRITE
 
-#define READ_SYNC		0
-#define WRITE_SYNC		REQ_SYNC
-#define WRITE_ODIRECT		(REQ_SYNC | REQ_IDLE)
-#define WRITE_FLUSH		REQ_PREFLUSH
-#define WRITE_FUA		REQ_FUA
-#define WRITE_FLUSH_FUA		(REQ_PREFLUSH | REQ_FUA)
-
 /*
  * Attribute flags.  These should be or-ed together to figure out what
  * has been changed!

commit a2b809672ee6fcb4d5756ea815725b3dbaea654e
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:09 2016 -0600

    block: replace REQ_NOIDLE with REQ_IDLE
    
    Noidle should be the default for writes as seen by all the compounds
    definitions in fs.h using it.  In fact only direct I/O really should
    be using NODILE, so turn the whole flag around to get the defaults
    right, which will make our life much easier especially onces the
    WRITE_* defines go away.
    
    This assumes all the existing "raw" users of REQ_SYNC for writes
    want noidle behavior, which seems to be spot on from a quick audit.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ccedccb28ec8..46a74209917f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -197,11 +197,11 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define WRITE			REQ_OP_WRITE
 
 #define READ_SYNC		0
-#define WRITE_SYNC		(REQ_SYNC | REQ_NOIDLE)
-#define WRITE_ODIRECT		REQ_SYNC
-#define WRITE_FLUSH		(REQ_NOIDLE | REQ_PREFLUSH)
-#define WRITE_FUA		(REQ_NOIDLE | REQ_FUA)
-#define WRITE_FLUSH_FUA		(REQ_NOIDLE | REQ_PREFLUSH | REQ_FUA)
+#define WRITE_SYNC		REQ_SYNC
+#define WRITE_ODIRECT		(REQ_SYNC | REQ_IDLE)
+#define WRITE_FLUSH		REQ_PREFLUSH
+#define WRITE_FUA		REQ_FUA
+#define WRITE_FLUSH_FUA		(REQ_PREFLUSH | REQ_FUA)
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what

commit b685d3d65ac791406e0dfd8779cc9b3707fea5a3
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:08 2016 -0600

    block: treat REQ_FUA and REQ_PREFLUSH as synchronous
    
    Instead of requiring everyone to specify the REQ_SYNC flag a well.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5e0078fceed7..ccedccb28ec8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -199,9 +199,9 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define READ_SYNC		0
 #define WRITE_SYNC		(REQ_SYNC | REQ_NOIDLE)
 #define WRITE_ODIRECT		REQ_SYNC
-#define WRITE_FLUSH		(REQ_SYNC | REQ_NOIDLE | REQ_PREFLUSH)
-#define WRITE_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_FUA)
-#define WRITE_FLUSH_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_PREFLUSH | REQ_FUA)
+#define WRITE_FLUSH		(REQ_NOIDLE | REQ_PREFLUSH)
+#define WRITE_FUA		(REQ_NOIDLE | REQ_FUA)
+#define WRITE_FLUSH_FUA		(REQ_NOIDLE | REQ_PREFLUSH | REQ_FUA)
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what

commit 6f6b29171a192e84b666c816e49d2175afbbb09f
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 1 07:40:07 2016 -0600

    block: don't use REQ_SYNC in the READ_SYNC definition
    
    Reads are synchronous per definition, don't add another flag for it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e3e878f12b25..5e0078fceed7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -196,7 +196,7 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define READ			REQ_OP_READ
 #define WRITE			REQ_OP_WRITE
 
-#define READ_SYNC		REQ_SYNC
+#define READ_SYNC		0
 #define WRITE_SYNC		(REQ_SYNC | REQ_NOIDLE)
 #define WRITE_ODIRECT		REQ_SYNC
 #define WRITE_FLUSH		(REQ_SYNC | REQ_NOIDLE | REQ_PREFLUSH)

commit 70fe2f48152e60664809e2fed76bbb50c9fa2aa3
Author: Jan Kara <jack@suse.cz>
Date:   Sun Oct 30 11:42:04 2016 -0500

    aio: fix freeze protection of aio writes
    
    Currently we dropped freeze protection of aio writes just after IO was
    submitted. Thus aio write could be in flight while the filesystem was
    frozen and that could result in unexpected situation like aio completion
    wanting to convert extent type on frozen filesystem. Testcase from
    Dmitry triggering this is like:
    
    for ((i=0;i<60;i++));do fsfreeze -f /mnt ;sleep 1;fsfreeze -u /mnt;done &
    fio --bs=4k --ioengine=libaio --iodepth=128 --size=1g --direct=1 \
        --runtime=60 --filename=/mnt/file --name=rand-write --rw=randwrite
    
    Fix the problem by dropping freeze protection only once IO is completed
    in aio_complete().
    
    Reported-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Jan Kara <jack@suse.cz>
    [hch: forward ported on top of various VFS and aio changes]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ff7bcd9e8398..dc0478c07b2a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -321,6 +321,7 @@ struct writeback_control;
 #define IOCB_HIPRI		(1 << 3)
 #define IOCB_DSYNC		(1 << 4)
 #define IOCB_SYNC		(1 << 5)
+#define IOCB_WRITE		(1 << 6)
 
 struct kiocb {
 	struct file		*ki_filp;

commit 723c038475b78edc9327eb952f95f9881cc9d79d
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Oct 30 11:42:02 2016 -0500

    fs: remove the never implemented aio_fsync file operation
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 16d2b6e874d6..ff7bcd9e8398 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1709,7 +1709,6 @@ struct file_operations {
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);
 	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
-	int (*aio_fsync) (struct kiocb *, int datasync);
 	int (*fasync) (int, struct file *, int);
 	int (*lock) (struct file *, int, struct file_lock *);
 	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);

commit 87374179c535a98337569904727aa02f960fe79e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 20 15:12:15 2016 +0200

    block: add a proper block layer data direction encoding
    
    Currently the block layer op_is_write, bio_data_dir and rq_data_dir
    helper treat every operation that is not a READ as a data out operation.
    This worked surprisingly long, but the new REQ_OP_ZONE_REPORT operation
    actually adds a second operation that reads data from the device.
    Surprisingly nothing critical relied on this direction, but this might
    be a good opportunity to properly fix this issue up.
    
    We take a little inspiration and use the least significant bit of the
    operation number to encode the data direction, which just requires us
    to renumber the operations to fix this scheme.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Shaun Tancheff <shaun.tancheff@seagate.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 16d2b6e874d6..e3e878f12b25 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2499,11 +2499,6 @@ extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
-static inline bool op_is_write(unsigned int op)
-{
-	return op == REQ_OP_READ ? false : true;
-}
-
 /*
  * return data direction, READ or WRITE
  */

commit 1a892b485f328224b4882818f84fcc0a3208677d
Merge: 5d89d9f502f9 7764235becf3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 14 17:23:33 2016 -0700

    Merge branch 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull overlayfs updates from Miklos Szeredi:
     "This update contains fixes to the "use mounter's permission to access
      underlying layers" area, and miscellaneous other fixes and cleanups.
    
      No new features this time"
    
    * 'overlayfs-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ovl: use vfs_get_link()
      vfs: add vfs_get_link() helper
      ovl: use generic_readlink
      ovl: explain error values when removing acl from workdir
      ovl: Fix info leak in ovl_lookup_temp()
      ovl: during copy up, switch to mounter's creds early
      ovl: lookup: do getxattr with mounter's permission
      ovl: copy_up_xattr(): use strnlen

commit d60874cd58fcb21372f2df698c20f8cf2f78fdcb
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Oct 4 14:40:45 2016 +0200

    vfs: add vfs_get_link() helper
    
    This helper is for filesystems that want to read the symlink and are better
    off with the get_link() interface (returning a char *) rather than the
    readlink() interface (copy into a userspace buffer).
    
    Also call the LSM hook for readlink (not get_link) since this is for
    symlink reading not following.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..bc8ac5108368 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2919,6 +2919,7 @@ extern int vfs_stat(const char __user *, struct kstat *);
 extern int vfs_lstat(const char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
+extern const char *vfs_get_link(struct dentry *, struct delayed_call *);
 
 extern int __generic_block_fiemap(struct inode *inode,
 				  struct fiemap_extent_info *fieinfo,

commit 9c5d760b8d229b94c5030863a5edaee5f1a9d7b7
Author: Michal Hocko <mhocko@suse.com>
Date:   Tue Oct 11 13:56:04 2016 -0700

    mm: split gfp_mask and mapping flags into separate fields
    
    mapping->flags currently encodes two different things into a single flag.
    It contains sticky gfp_mask for page cache allocations and AS_ codes used
    to report errors/enospace and other states which are mapping specific.
    Condensing the two semantically unrelated things saves few bytes but it
    also complicates other things.  For one thing the gfp flags space is
    reduced and in fact we are already running out of available bits.  It can
    be assumed that more gfp flags will be necessary later on.
    
    To not introduce the address_space grow (at least on x86_64) we can stick
    it right after private_lock because we have a hole there.
    
    struct address_space {
            struct inode *             host;                 /*     0     8 */
            struct radix_tree_root     page_tree;            /*     8    16 */
            spinlock_t                 tree_lock;            /*    24     4 */
            atomic_t                   i_mmap_writable;      /*    28     4 */
            struct rb_root             i_mmap;               /*    32     8 */
            struct rw_semaphore        i_mmap_rwsem;         /*    40    40 */
            /* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
            long unsigned int          nrpages;              /*    80     8 */
            long unsigned int          nrexceptional;        /*    88     8 */
            long unsigned int          writeback_index;      /*    96     8 */
            const struct address_space_operations  * a_ops;  /*   104     8 */
            long unsigned int          flags;                /*   112     8 */
            spinlock_t                 private_lock;         /*   120     4 */
    
            /* XXX 4 bytes hole, try to pack */
    
            /* --- cacheline 2 boundary (128 bytes) --- */
            struct list_head           private_list;         /*   128    16 */
            void *                     private_data;         /*   144     8 */
    
            /* size: 152, cachelines: 3, members: 14 */
            /* sum members: 148, holes: 1, sum holes: 4 */
            /* last cacheline: 24 bytes */
    };
    
    Link: http://lkml.kernel.org/r/20160912114852.GI14524@dhcp22.suse.cz
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c145219286a8..bc65d5918140 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -440,8 +440,9 @@ struct address_space {
 	unsigned long		nrexceptional;
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */
-	unsigned long		flags;		/* error bits/gfp mask */
+	unsigned long		flags;		/* error bits */
 	spinlock_t		private_lock;	/* for use by the address_space */
+	gfp_t			gfp_mask;	/* implicit gfp mask for allocations */
 	struct list_head	private_list;	/* ditto */
 	void			*private_data;	/* ditto */
 } __attribute__((aligned(sizeof(long))));

commit 101105b1717f536ca741f940033996302d4ef191
Merge: 35ff96dfd3c9 3873691e5ab3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 20:16:43 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     ">rename2() work from Miklos + current_time() from Deepa"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: Replace current_fs_time() with current_time()
      fs: Replace CURRENT_TIME_SEC with current_time() for inode timestamps
      fs: Replace CURRENT_TIME with current_time() for inode timestamps
      fs: proc: Delete inode time initializations in proc_alloc_inode()
      vfs: Add current_time() api
      vfs: add note about i_op->rename changes to porting
      fs: rename "rename2" i_op to "rename"
      vfs: remove unused i_op->rename
      fs: make remaining filesystems use .rename2
      libfs: support RENAME_NOREPLACE in simple_rename()
      fs: support RENAME_NOREPLACE for local filesystems
      ncpfs: fix unused variable warning

commit 3873691e5ab34fa26948643d038a2b98c4437298
Merge: c2050a454c7f aadfa8019e81
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 10 23:02:51 2016 -0400

    Merge remote-tracking branch 'ovl/rename2' into for-linus

commit 97d2116708ca0fd6ad8b00811ee4349b7e19e96f
Merge: 30066ce675d3 fd50ecaddf83
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 17:11:50 2016 -0700

    Merge branch 'work.xattr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs xattr updates from Al Viro:
     "xattr stuff from Andreas
    
      This completes the switch to xattr_handler ->get()/->set() from
      ->getxattr/->setxattr/->removexattr"
    
    * 'work.xattr' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: Remove {get,set,remove}xattr inode operations
      xattr: Stop calling {get,set,remove}xattr inode operations
      vfs: Check for the IOP_XATTR flag in listxattr
      xattr: Add __vfs_{get,set,remove}xattr helpers
      libfs: Use IOP_XATTR flag for empty directory handling
      vfs: Use IOP_XATTR flag for bad-inode handling
      vfs: Add IOP_XATTR inode operations flag
      vfs: Move xattr_resolve_name to the front of fs/xattr.c
      ecryptfs: Switch to generic xattr handlers
      sockfs: Get rid of getxattr iop
      sockfs: getxattr: Fail with -EOPNOTSUPP for invalid attribute names
      kernfs: Switch to generic xattr handlers
      hfs: Switch to generic xattr handlers
      jffs2: Remove jffs2_{get,set,remove}xattr macros
      xattr: Remove unnecessary NULL attribute name check

commit abb5a14fa20fdd400995926134b7be9eb8ce6048
Merge: 911f9dab301e e55f1d1d13e7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 10 13:04:49 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "Assorted misc bits and pieces.
    
      There are several single-topic branches left after this (rename2
      series from Miklos, current_time series from Deepa Dinamani, xattr
      series from Andreas, uaccess stuff from from me) and I'd prefer to
      send those separately"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (39 commits)
      proc: switch auxv to use of __mem_open()
      hpfs: support FIEMAP
      cifs: get rid of unused arguments of CIFSSMBWrite()
      posix_acl: uapi header split
      posix_acl: xattr representation cleanups
      fs/aio.c: eliminate redundant loads in put_aio_ring_file
      fs/internal.h: add const to ns_dentry_operations declaration
      compat: remove compat_printk()
      fs/buffer.c: make __getblk_slow() static
      proc: unsigned file descriptors
      fs/file: more unsigned file descriptors
      fs: compat: remove redundant check of nr_segs
      cachefiles: Fix attempt to read i_blocks after deleting file [ver #2]
      cifs: don't use memcpy() to copy struct iov_iter
      get rid of separate multipage fault-in primitives
      fs: Avoid premature clearing of capabilities
      fs: Give dentry to inode_change_ok() instead of inode
      fuse: Propagate dentry down to inode_change_ok()
      ceph: Propagate dentry down to inode_change_ok()
      xfs: Propagate dentry down to inode_change_ok()
      ...

commit e55f1d1d13e7f1c364672d667d78fd1f640ab9f9
Merge: f334bcd94b7d 030b533c4fd4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 8 11:06:08 2016 -0400

    Merge remote-tracking branch 'jk/vfs' into work.misc

commit f334bcd94b7d3c0fbc34d518a86548f451ab5faf
Merge: 73e8fb2d596d 814184fd4025
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 8 11:00:01 2016 -0400

    Merge remote-tracking branch 'ovl/misc' into work.misc

commit fd50ecaddf8372a1d96e0daeaac0f93cf04e4d42
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:45 2016 +0200

    vfs: Remove {get,set,remove}xattr inode operations
    
    These inode operations are no longer used; remove them.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 91a7245e58c7..788261b74d45 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1739,12 +1739,7 @@ struct inode_operations {
 			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
-	int (*setxattr) (struct dentry *, struct inode *,
-			 const char *, const void *, size_t, int);
-	ssize_t (*getxattr) (struct dentry *, struct inode *,
-			     const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
-	int (*removexattr) (struct dentry *, const char *);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
 	int (*update_time)(struct inode *, struct timespec *, int);

commit d0a5b995a308347fdb1bb0412df32acd0312523b
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:39 2016 +0200

    vfs: Add IOP_XATTR inode operations flag
    
    The IOP_XATTR inode operations flag in inode->i_opflags indicates that
    the inode has xattr support.  The flag is automatically set by
    new_inode() on filesystems with xattr support (where sb->s_xattr is
    defined), and cleared otherwise.  Filesystems can explicitly clear it
    for inodes that should not have xattr support.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7540e872591a..91a7245e58c7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -591,6 +591,7 @@ is_uncached_acl(struct posix_acl *acl)
 #define IOP_FASTPERM	0x0001
 #define IOP_LOOKUP	0x0002
 #define IOP_NOFOLLOW	0x0004
+#define IOP_XATTR	0x0008
 
 /*
  * Keep mostly read-only and often accessed (especially for

commit bba0bd31b117cba754322f337e61def53d9b22e5
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Sep 29 17:48:35 2016 +0200

    sockfs: Get rid of getxattr iop
    
    If we allow pseudo-filesystems created with mount_pseudo to have xattr
    handlers, we can replace sockfs_getxattr with a sockfs_xattr_get handler
    to use the xattr handler name parsing.
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..7540e872591a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2075,10 +2075,19 @@ struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),
 			int flags, void *data);
-extern struct dentry *mount_pseudo(struct file_system_type *, char *,
-	const struct super_operations *ops,
-	const struct dentry_operations *dops,
-	unsigned long);
+extern struct dentry *mount_pseudo_xattr(struct file_system_type *, char *,
+					 const struct super_operations *ops,
+					 const struct xattr_handler **xattr,
+					 const struct dentry_operations *dops,
+					 unsigned long);
+
+static inline struct dentry *
+mount_pseudo(struct file_system_type *fs_type, char *name,
+	     const struct super_operations *ops,
+	     const struct dentry_operations *dops, unsigned long magic)
+{
+	return mount_pseudo_xattr(fs_type, name, ops, NULL, dops, magic);
+}
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \

commit 82c156f853840645604acd7c2cebcb75ed1b6652
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Sep 22 23:35:42 2016 -0400

    switch generic_file_splice_read() to use of ->read_iter()
    
    ... and kill the ->splice_read() instances that can be switched to it
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..b04883e74579 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2794,8 +2794,6 @@ extern void block_sync_page(struct page *page);
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
-extern ssize_t default_file_splice_read(struct file *, loff_t *,
-		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t iter_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,

commit 3cd886666ff19e9796a519e16d94fc94f79c8a4c
Author: Deepa Dinamani <deepa.kernel@gmail.com>
Date:   Wed Sep 14 07:48:02 2016 -0700

    vfs: Add current_time() api
    
    current_fs_time() is used for inode timestamps.
    
    Change the signature of the function to take inode pointer
    instead of superblock as per Linus's suggestion.
    
    Also, move the api under vfs as per the discussion on the
    thread: https://lkml.org/lkml/2016/6/9/36 . As per Arnd's
    suggestion on the thread, changing the function name.
    
    current_fs_time() will be deleted after all the references
    to it are replaced by current_time().
    
    There was a bug reported by kbuild test bot with the change
    as some of the calls to current_time() were made before the
    super_block was initialized. Catch these accidental assignments
    as timespec_trunc() does for wrong granularities. This allows
    for the function to work right even in these circumstances.
    But, adds a warning to make the user aware of the bug.
    
    A coccinelle script was used to identify all the current
    .alloc_inode super_block callbacks that updated inode timestamps.
    proc filesystem was the only one that was modifying inode times
    as part of this callback. The series includes a patch to fix that.
    
    Note that timespec_trunc() will also be moved to fs/inode.c
    in a separate patch when this will need to be revamped for
    bounds checking purposes.
    
    Signed-off-by: Deepa Dinamani <deepa.kernel@gmail.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..32ce6b31a61b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1459,6 +1459,7 @@ static inline void i_gid_write(struct inode *inode, gid_t gid)
 }
 
 extern struct timespec current_fs_time(struct super_block *sb);
+extern struct timespec current_time(struct inode *inode);
 
 /*
  * Snapshotting support.

commit 9b80a184eaadc117f27faad522008f31d571621b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Sep 2 00:38:52 2016 +0300

    fs/file: more unsigned file descriptors
    
    Propagate unsignedness for grand total of 149 bytes:
    
            $ ./scripts/bloat-o-meter ../vmlinux-000 ../obj/vmlinux
            add/remove: 0/0 grow/shrink: 0/10 up/down: 0/-149 (-149)
            function                                     old     new   delta
            set_close_on_exec                             99      98      -1
            put_files_struct                             201     200      -1
            get_close_on_exec                             59      58      -1
            do_prlimit                                   498     497      -1
            do_execveat_common.isra                     1662    1661      -1
            __close_fd                                   178     173      -5
            do_dup2                                      219     204     -15
            seq_show                                     685     660     -25
            __alloc_fd                                   384     357     -27
            dup_fd                                       718     646     -72
    
    It mostly comes from converting "unsigned int" to "long" for bit operations.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..2f6f059d739c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -63,7 +63,7 @@ extern void __init files_maxfiles_init(void);
 
 extern struct files_stat_struct files_stat;
 extern unsigned long get_max_files(void);
-extern int sysctl_nr_open;
+extern unsigned int sysctl_nr_open;
 extern struct inodes_stat_t inodes_stat;
 extern int leases_enable, lease_break_time;
 extern int sysctl_protected_symlinks;

commit 2773bf00aeb9bf39e022463272a61dd0ec9f55f4
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 27 11:03:58 2016 +0200

    fs: rename "rename2" i_op to "rename"
    
    Generated patch:
    
    sed -i "s/\.rename2\t/\.rename\t\t/" `git grep -wl rename2`
    sed -i "s/\brename2\b/rename/g" `git grep -wl rename2`
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6b14ceba4f20..cf7e621f7413 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1732,7 +1732,7 @@ struct inode_operations {
 	int (*mkdir) (struct inode *,struct dentry *,umode_t);
 	int (*rmdir) (struct inode *,struct dentry *);
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
-	int (*rename2) (struct inode *, struct dentry *,
+	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);

commit 18fc84dafaac1fd63d5e6e600058eada8fc7914b
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 27 11:03:58 2016 +0200

    vfs: remove unused i_op->rename
    
    No in-tree uses remain.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2bd67545fdf8..6b14ceba4f20 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1732,8 +1732,6 @@ struct inode_operations {
 	int (*mkdir) (struct inode *,struct dentry *,umode_t);
 	int (*rmdir) (struct inode *,struct dentry *);
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
-	int (*rename) (struct inode *, struct dentry *,
-			struct inode *, struct dentry *);
 	int (*rename2) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);

commit e0e0be8a835520e2f7c89f214dfda570922a1b90
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Tue Sep 27 11:03:57 2016 +0200

    libfs: support RENAME_NOREPLACE in simple_rename()
    
    This is trivial to do:
    
     - add flags argument to simple_rename()
     - check if flags doesn't have any other than RENAME_NOREPLACE
     - assign simple_rename() to .rename2 instead of .rename
    
    Filesystems converted:
    
    hugetlbfs, ramfs, bpf.
    
    Debugfs uses simple_rename() to implement debugfs_rename(), which is for
    debugfs instances to rename files internally, not for userspace filesystem
    access.  For this case pass zero flags to simple_rename().
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Alexei Starovoitov <ast@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..2bd67545fdf8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2950,7 +2950,8 @@ extern int simple_open(struct inode *inode, struct file *file);
 extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
-extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int simple_rename(struct inode *, struct dentry *,
+			 struct inode *, struct dentry *, unsigned int);
 extern int noop_fsync(struct file *, loff_t, loff_t, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);

commit 31051c85b5e2aaaf6315f74c72a732673632a905
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 26 16:55:18 2016 +0200

    fs: Give dentry to inode_change_ok() instead of inode
    
    inode_change_ok() will be resposible for clearing capabilities and IMA
    extended attributes and as such will need dentry. Give it as an argument
    to inode_change_ok() instead of an inode. Also rename inode_change_ok()
    to setattr_prepare() to better relect that it does also some
    modifications in addition to checks.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3523bf62f328..943a21cbb469 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2994,7 +2994,7 @@ extern int buffer_migrate_page(struct address_space *,
 #define buffer_migrate_page NULL
 #endif
 
-extern int inode_change_ok(const struct inode *, struct iattr *);
+extern int setattr_prepare(struct dentry *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 

commit c568d68341be7030f5647def68851e469b21ca11
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Sep 16 12:44:20 2016 +0200

    locks: fix file locking on overlayfs
    
    This patch allows flock, posix locks, ofd locks and leases to work
    correctly on overlayfs.
    
    Instead of using the underlying inode for storing lock context use the
    overlay inode.  This allows locks to be persistent across copy-up.
    
    This is done by introducing locks_inode() helper and using it instead of
    file_inode() to get the inode in locking code.  For non-overlayfs the two
    are equivalent, except for an extra pointer dereference in locks_inode().
    
    Since lock operations are in "struct file_operations" we must also make
    sure not to call underlying filesystem's lock operations.  Introcude a
    super block flag MS_NOREMOTELOCK to this effect.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Acked-by: Jeff Layton <jlayton@poochiereds.net>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7db097d673a8..8ee0f011547f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1065,6 +1065,18 @@ struct file_lock_context {
 
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
+/*
+ * Return the inode to use for locking
+ *
+ * For overlayfs this should be the overlay inode, not the real inode returned
+ * by file_inode().  For any other fs file_inode(filp) and locks_inode(filp) are
+ * equal.
+ */
+static inline struct inode *locks_inode(const struct file *f)
+{
+	return f->f_path.dentry->d_inode;
+}
+
 #ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, unsigned int, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
@@ -1252,7 +1264,7 @@ static inline struct dentry *file_dentry(const struct file *file)
 
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
 {
-	return locks_lock_inode_wait(file_inode(filp), fl);
+	return locks_lock_inode_wait(locks_inode(filp), fl);
 }
 
 struct fasync_struct {
@@ -2155,7 +2167,7 @@ static inline int mandatory_lock(struct inode *ino)
 
 static inline int locks_verify_locked(struct file *file)
 {
-	if (mandatory_lock(file_inode(file)))
+	if (mandatory_lock(locks_inode(file)))
 		return locks_mandatory_locked(file);
 	return 0;
 }

commit 598e3c8f72f5b77c84d2cb26cfd936ffb3cfdbaa
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Sep 16 12:44:20 2016 +0200

    vfs: update ovl inode before relatime check
    
    On overlayfs relatime_need_update() needs inode times to be correct on
    overlay inode.  But i_mtime and i_ctime are updated by filesystem code on
    underlying inode only, so they will be out-of-date on the overlay inode.
    
    This patch copies the times from the underlying inode if needed.  This
    can't be done if called from RCU lookup (link following) but link m/ctime
    are not updated by fs, so this is all right.
    
    This patch doesn't change functionality for anything but overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7c391366fb43..7db097d673a8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2007,7 +2007,6 @@ enum file_time_flags {
 	S_VERSION = 8,
 };
 
-extern bool atime_needs_update(const struct path *, struct inode *);
 extern void touch_atime(const struct path *);
 static inline void file_accessed(struct file *file)
 {

commit f2b20f6ee842313a0d681dbbf7f87b70291a6a3b
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Sep 16 12:44:20 2016 +0200

    vfs: move permission checking into notify_change() for utimes(NULL)
    
    This fixes a bug where the permission was not properly checked in
    overlayfs.  The testcase is ltp/utimensat01.
    
    It is also cleaner and safer to do the permission checking in the vfs
    helper instead of the caller.
    
    This patch introduces an additional ia_valid flag ATTR_TOUCH (since
    touch(1) is the most obvious user of utimes(NULL)) that is passed into
    notify_change whenever the conditions for this special permission checking
    mode are met.
    
    Reported-by: Aihua Zhang <zhangaihua1@huawei.com>
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Tested-by: Aihua Zhang <zhangaihua1@huawei.com>
    Cc: <stable@vger.kernel.org> # v3.18+

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 901e25d495cc..7c391366fb43 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -224,6 +224,7 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define ATTR_KILL_PRIV	(1 << 14)
 #define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
 #define ATTR_TIMES_SET	(1 << 16)
+#define ATTR_TOUCH	(1 << 17)
 
 /*
  * Whiteout is represented by a char device.  The following constants define the

commit 2a3a2a3f35249412e35fbb48b743348c40373409
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Sep 1 11:11:59 2016 +0200

    ovl: don't cache acl on overlay layer
    
    Some operations (setxattr/chmod) can make the cached acl stale.  We either
    need to clear overlay's acl cache for the affected inode or prevent acl
    caching on the overlay altogether.  Preventing caching has the following
    advantages:
    
     - no double caching, less memory used
    
     - overlay cache doesn't go stale when fs clears it's own cache
    
    Possible disadvantage is performance loss.  If that becomes a problem
    get_acl() can be optimized for overlayfs.
    
    This patch disables caching by pre setting i_*acl to a value that
    
      - has bit 0 set, so is_uncached_acl() will return true
    
      - is not equal to ACL_NOT_CACHED, so get_acl() will not overwrite it
    
    The constant -3 was chosen for this purpose.
    
    Fixes: 39a25b2b3762 ("ovl: define ->get_acl() for overlay inodes")
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3523bf62f328..901e25d495cc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -574,6 +574,7 @@ static inline void mapping_allow_writable(struct address_space *mapping)
 
 struct posix_acl;
 #define ACL_NOT_CACHED ((void *)(-1))
+#define ACL_DONT_CACHE ((void *)(-3))
 
 static inline struct posix_acl *
 uncached_acl_sentinel(struct task_struct *task)

commit c11f0c0b5bb949673e4fc16c742f0316ae4ced20
Author: Jens Axboe <axboe@fb.com>
Date:   Fri Aug 5 08:11:04 2016 -0600

    block/mm: make bdev_ops->rw_page() take a bool for read/write
    
    Commit abf545484d31 changed it from an 'rw' flags type to the
    newer ops based interface, but now we're effectively leaking
    some bdev internals to the rest of the kernel. Since we only
    care about whether it's a read or a write at that level, just
    pass in a bool 'is_write' parameter instead.
    
    Then we can also move op_is_write() and friends back under
    CONFIG_BLOCK protection.
    
    Reviewed-by: Mike Christie <mchristi@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 33f0e96db06f..3523bf62f328 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2480,13 +2480,12 @@ extern void init_special_inode(struct inode *, umode_t, dev_t);
 extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
+#ifdef CONFIG_BLOCK
 static inline bool op_is_write(unsigned int op)
 {
 	return op == REQ_OP_READ ? false : true;
 }
 
-#ifdef CONFIG_BLOCK
-
 /*
  * return data direction, READ or WRITE
  */

commit fe64f3283fb315e3d8f2b78785a86904a852ca82
Merge: 0cbbc422d566 db20a8925bc4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 7 10:01:14 2016 -0400

    Merge branch 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     "Assorted cleanups and fixes.
    
      In the "trivial API change" department - ->d_compare() losing 'parent'
      argument"
    
    * 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      cachefiles: Fix race between inactivating and culling a cache object
      9p: use clone_fid()
      9p: fix braino introduced in "9p: new helper - v9fs_parent_fid()"
      vfs: make dentry_needs_remove_privs() internal
      vfs: remove file_needs_remove_privs()
      vfs: fix deadlock in file_remove_privs() on overlayfs
      get rid of 'parent' argument of ->d_compare()
      cifs, msdos, vfat, hfs+: don't bother with parent in ->d_compare()
      affs ->d_compare(): don't bother with ->d_inode
      fold _d_rehash() and __d_rehash() together
      fold dentry_rcuwalk_invalidate() into its only remaining caller

commit abf545484d31b68777a85c5c8f5b4bcde08283eb
Author: Mike Christie <mchristi@redhat.com>
Date:   Thu Aug 4 14:23:34 2016 -0600

    mm/block: convert rw_page users to bio op use
    
    The rw_page users were not converted to use bio/req ops. As a result
    bdev_write_page is not passing down REQ_OP_WRITE and the IOs will
    be sent down as reads.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Fixes: 4e1b2d52a80d ("block, fs, drivers: remove REQ_OP compat defs and related code")
    
    Modified by me to:
    
    1) Drop op_flags passing into ->rw_page(), as we don't use it.
    2) Make op_is_write() and friends safe to use for !CONFIG_BLOCK
    
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f3f0b4c8e8ac..498255e6914e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2480,12 +2480,13 @@ extern void init_special_inode(struct inode *, umode_t, dev_t);
 extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
-#ifdef CONFIG_BLOCK
 static inline bool op_is_write(unsigned int op)
 {
 	return op == REQ_OP_READ ? false : true;
 }
 
+#ifdef CONFIG_BLOCK
+
 /*
  * return data direction, READ or WRITE
  */

commit 8ecfb75216a71ba0e00e419ddafa52d12d965445
Merge: 7d50a29fe438 f0fce87c36ae
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Aug 3 13:31:51 2016 -0400

    Merge branch 'for-viro' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs into for-linus

commit f0fce87c36aec5c4a895c78b76396f5727047b93
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Aug 3 13:44:27 2016 +0200

    vfs: make dentry_needs_remove_privs() internal
    
    Only used by the vfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3888341913ef..448641bcafc5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2725,7 +2725,6 @@ extern struct inode *new_inode(struct super_block *sb);
 extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_privs(struct file *);
-extern int dentry_needs_remove_privs(struct dentry *dentry);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 static inline void insert_inode_hash(struct inode *inode)

commit 3e5a4c94a4f88b545d64bbfc7647b06b92c66e98
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Wed Aug 3 13:44:27 2016 +0200

    vfs: remove file_needs_remove_privs()
    
    This function is now unused.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd288148a6b1..3888341913ef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2726,10 +2726,6 @@ extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_privs(struct file *);
 extern int dentry_needs_remove_privs(struct dentry *dentry);
-static inline int file_needs_remove_privs(struct file *file)
-{
-	return dentry_needs_remove_privs(file->f_path.dentry);
-}
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 static inline void insert_inode_hash(struct inode *inode)

commit a098ecd2fa7db8fa4fcc178a43627b29b226edb9
Author: Stephen Boyd <stephen.boyd@linaro.org>
Date:   Tue Aug 2 14:04:28 2016 -0700

    firmware: support loading into a pre-allocated buffer
    
    Some systems are memory constrained but they need to load very large
    firmwares.  The firmware subsystem allows drivers to request this
    firmware be loaded from the filesystem, but this requires that the
    entire firmware be loaded into kernel memory first before it's provided
    to the driver.  This can lead to a situation where we map the firmware
    twice, once to load the firmware into kernel memory and once to copy the
    firmware into the final resting place.
    
    This creates needless memory pressure and delays loading because we have
    to copy from kernel memory to somewhere else.  Let's add a
    request_firmware_into_buf() API that allows drivers to request firmware
    be loaded directly into a pre-allocated buffer.  This skips the
    intermediate step of allocating a buffer in kernel memory to hold the
    firmware image while it's read from the filesystem.  It also requires
    that drivers know how much memory they'll require before requesting the
    firmware and negates any benefits of firmware caching because the
    firmware layer doesn't manage the buffer lifetime.
    
    For a 16MB buffer, about half the time is spent performing a memcpy from
    the buffer to the final resting place.  I see loading times go from
    0.081171 seconds to 0.047696 seconds after applying this patch.  Plus
    the vmalloc pressure is reduced.
    
    This is based on a patch from Vikram Mulukutla on codeaurora.org:
      https://www.codeaurora.org/cgit/quic/la/kernel/msm-3.18/commit/drivers/base/firmware_class.c?h=rel/msm-3.18&id=0a328c5f6cd999f5c591f172216835636f39bcb5
    
    Link: http://lkml.kernel.org/r/20160607164741.31849-4-stephen.boyd@linaro.org
    Signed-off-by: Stephen Boyd <stephen.boyd@linaro.org>
    Cc: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Cc: Vikram Mulukutla <markivx@codeaurora.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Ming Lei <ming.lei@canonical.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 577365a77b47..f3f0b4c8e8ac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2652,6 +2652,7 @@ extern int do_pipe_flags(int *, int);
 #define __kernel_read_file_id(id) \
 	id(UNKNOWN, unknown)		\
 	id(FIRMWARE, firmware)		\
+	id(FIRMWARE_PREALLOC_BUFFER, firmware)	\
 	id(MODULE, kernel-module)		\
 	id(KEXEC_IMAGE, kexec-image)		\
 	id(KEXEC_INITRAMFS, kexec-initramfs)	\

commit a867d7349e94b6409b08629886a819f802377e91
Merge: 601f887d6105 aeaa4a79ff6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 15:54:19 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull userns vfs updates from Eric Biederman:
     "This tree contains some very long awaited work on generalizing the
      user namespace support for mounting filesystems to include filesystems
      with a backing store.  The real world target is fuse but the goal is
      to update the vfs to allow any filesystem to be supported.  This
      patchset is based on a lot of code review and testing to approach that
      goal.
    
      While looking at what is needed to support the fuse filesystem it
      became clear that there were things like xattrs for security modules
      that needed special treatment.  That the resolution of those concerns
      would not be fuse specific.  That sorting out these general issues
      made most sense at the generic level, where the right people could be
      drawn into the conversation, and the issues could be solved for
      everyone.
    
      At a high level what this patchset does a couple of simple things:
    
       - Add a user namespace owner (s_user_ns) to struct super_block.
    
       - Teach the vfs to handle filesystem uids and gids not mapping into
         to kuids and kgids and being reported as INVALID_UID and
         INVALID_GID in vfs data structures.
    
      By assigning a user namespace owner filesystems that are mounted with
      only user namespace privilege can be detected.  This allows security
      modules and the like to know which mounts may not be trusted.  This
      also allows the set of uids and gids that are communicated to the
      filesystem to be capped at the set of kuids and kgids that are in the
      owning user namespace of the filesystem.
    
      One of the crazier corner casees this handles is the case of inodes
      whose i_uid or i_gid are not mapped into the vfs.  Most of the code
      simply doesn't care but it is easy to confuse the inode writeback path
      so no operation that could cause an inode write-back is permitted for
      such inodes (aka only reads are allowed).
    
      This set of changes starts out by cleaning up the code paths involved
      in user namespace permirted mounts.  Then when things are clean enough
      adds code that cleanly sets s_user_ns.  Then additional restrictions
      are added that are possible now that the filesystem superblock
      contains owner information.
    
      These changes should not affect anyone in practice, but there are some
      parts of these restrictions that are changes in behavior.
    
       - Andy's restriction on suid executables that does not honor the
         suid bit when the path is from another mount namespace (think
         /proc/[pid]/fd/) or when the filesystem was mounted by a less
         privileged user.
    
       - The replacement of the user namespace implicit setting of MNT_NODEV
         with implicitly setting SB_I_NODEV on the filesystem superblock
         instead.
    
         Using SB_I_NODEV is a stronger form that happens to make this state
         user invisible.  The user visibility can be managed but it caused
         problems when it was introduced from applications reasonably
         expecting mount flags to be what they were set to.
    
      There is a little bit of work remaining before it is safe to support
      mounting filesystems with backing store in user namespaces, beyond
      what is in this set of changes.
    
       - Verifying the mounter has permission to read/write the block device
         during mount.
    
       - Teaching the integrity modules IMA and EVM to handle filesystems
         mounted with only user namespace root and to reduce trust in their
         security xattrs accordingly.
    
       - Capturing the mounters credentials and using that for permission
         checks in d_automount and the like.  (Given that overlayfs already
         does this, and we need the work in d_automount it make sense to
         generalize this case).
    
      Furthermore there are a few changes that are on the wishlist:
    
       - Get all filesystems supporting posix acls using the generic posix
         acls so that posix_acl_fix_xattr_from_user and
         posix_acl_fix_xattr_to_user may be removed.  [Maintainability]
    
       - Reducing the permission checks in places such as remount to allow
         the superblock owner to perform them.
    
       - Allowing the superblock owner to chown files with unmapped uids and
         gids to something that is mapped so the files may be treated
         normally.
    
      I am not considering even obvious relaxations of permission checks
      until it is clear there are no more corner cases that need to be
      locked down and handled generically.
    
      Many thanks to Seth Forshee who kept this code alive, and putting up
      with me rewriting substantial portions of what he did to handle more
      corner cases, and for his diligent testing and reviewing of my
      changes"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (30 commits)
      fs: Call d_automount with the filesystems creds
      fs: Update i_[ug]id_(read|write) to translate relative to s_user_ns
      evm: Translate user/group ids relative to s_user_ns when computing HMAC
      dquot: For now explicitly don't support filesystems outside of init_user_ns
      quota: Handle quota data stored in s_user_ns in quota_setxquota
      quota: Ensure qids map to the filesystem
      vfs: Don't create inodes with a uid or gid unknown to the vfs
      vfs: Don't modify inodes with a uid or gid unknown to the vfs
      cred: Reject inodes with invalid ids in set_create_file_as()
      fs: Check for invalid i_uid in may_follow_link()
      vfs: Verify acls are valid within superblock's s_user_ns.
      userns: Handle -1 in k[ug]id_has_mapping when !CONFIG_USER_NS
      fs: Refuse uid/gid changes which don't map into s_user_ns
      selinux: Add support for unprivileged mounts from user namespaces
      Smack: Handle labels consistently in untrusted mounts
      Smack: Add support for unprivileged mounts from user namespaces
      fs: Treat foreign mounts as nosuid
      fs: Limit file caps to the user namespace of the super block
      userns: Remove the now unnecessary FS_USERNS_DEV_MOUNT flag
      userns: Remove implicit MNT_NODEV fragility.
      ...

commit 27ae0c41ed2ef724905741488668c879bb016405
Merge: 20d00ee82942 4a7f4e88fef1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 12:29:15 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse
    
    Pull fuse updates from Miklos Szeredi:
     "This fixes error propagation from writeback to fsync/close for
      writeback cache mode as well as adding a missing capability flag to
      the INIT message.  The rest are cleanups.
    
      (The commits are recent but all the code actually sat in -next for a
      while now.  The recommits are due to conflict avoidance and the
      addition of Cc: stable@...)"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/fuse:
      fuse: use filemap_check_errors()
      mm: export filemap_check_errors() to modules
      fuse: fix wrong assignment of ->flags in fuse_send_init()
      fuse: fuse_flush must check mapping->flags for errors
      fuse: fsync() did not return IO errors
      fuse: don't mess with blocking signals
      new helper: wait_event_killable_exclusive()
      fuse: improve aio directIO write performance for size extending writes

commit d72d9e2a5d7ec04a1f92925c5ac633d8031fa7fc
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Fri Jul 29 14:10:57 2016 +0200

    mm: export filemap_check_errors() to modules
    
    Can be used by fuse, btrfs and f2fs to replace opencoded variants.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd288148a6b1..6f2536a3a916 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2507,6 +2507,7 @@ extern int __filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end, int sync_mode);
 extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
+extern int filemap_check_errors(struct address_space *mapping);
 
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);

commit 6784725ab0b9473ce44bfad91a256bd72b5cddc1
Merge: 554828ee0db4 47be61845c77
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 28 12:59:05 2016 -0700

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "Assorted cleanups and fixes.
    
      Probably the most interesting part long-term is ->d_init() - that will
      have a bunch of followups in (at least) ceph and lustre, but we'll
      need to sort the barrier-related rules before it can get used for
      really non-trivial stuff.
    
      Another fun thing is the merge of ->d_iput() callers (dentry_iput()
      and dentry_unlink_inode()) and a bunch of ->d_compare() ones (all
      except the one in __d_lookup_lru())"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (26 commits)
      fs/dcache.c: avoid soft-lockup in dput()
      vfs: new d_init method
      vfs: Update lookup_dcache() comment
      bdev: get rid of ->bd_inodes
      Remove last traces of ->sync_page
      new helper: d_same_name()
      dentry_cmp(): use lockless_dereference() instead of smp_read_barrier_depends()
      vfs: clean up documentation
      vfs: document ->d_real()
      vfs: merge .d_select_inode() into .d_real()
      unify dentry_iput() and dentry_unlink_inode()
      binfmt_misc: ->s_root is not going anywhere
      drop redundant ->owner initializations
      ufs: get rid of redundant checks
      orangefs: constify inode_operations
      missed comment updates from ->direct_IO() prototype change
      file_inode(f)->i_mapping is f->f_mapping
      trim fsnotify hooks a bit
      9p: new helper - v9fs_parent_fid()
      debugfs: ->d_parent is never NULL or negative
      ...

commit 0e06f5c0deeef0332a5da2ecb8f1fcf3e024d958
Merge: f7816ad0f878 8f19b0c058d9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 26 19:55:54 2016 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge updates from Andrew Morton:
    
     - a few misc bits
    
     - ocfs2
    
     - most(?) of MM
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (125 commits)
      thp: fix comments of __pmd_trans_huge_lock()
      cgroup: remove unnecessary 0 check from css_from_id()
      cgroup: fix idr leak for the first cgroup root
      mm: memcontrol: fix documentation for compound parameter
      mm: memcontrol: remove BUG_ON in uncharge_list
      mm: fix build warnings in <linux/compaction.h>
      mm, thp: convert from optimistic swapin collapsing to conservative
      mm, thp: fix comment inconsistency for swapin readahead functions
      thp: update Documentation/{vm/transhuge,filesystems/proc}.txt
      shmem: split huge pages beyond i_size under memory pressure
      thp: introduce CONFIG_TRANSPARENT_HUGE_PAGECACHE
      khugepaged: add support of collapse for tmpfs/shmem pages
      shmem: make shmem_inode_info::lock irq-safe
      khugepaged: move up_read(mmap_sem) out of khugepaged_alloc_page()
      thp: extract khugepaged from mm/huge_memory.c
      shmem, thp: respect MADV_{NO,}HUGEPAGE for file mappings
      shmem: add huge pages support
      shmem: get_unmapped_area align huge page
      shmem: prepare huge= mount option and sysfs knob
      mm, rmap: account shmem thp pages
      ...

commit bda807d4445414e8e77da704f116bb0880fe0c76
Author: Minchan Kim <minchan@kernel.org>
Date:   Tue Jul 26 15:23:05 2016 -0700

    mm: migrate: support non-lru movable page migration
    
    We have allowed migration for only LRU pages until now and it was enough
    to make high-order pages.  But recently, embedded system(e.g., webOS,
    android) uses lots of non-movable pages(e.g., zram, GPU memory) so we
    have seen several reports about troubles of small high-order allocation.
    For fixing the problem, there were several efforts (e,g,.  enhance
    compaction algorithm, SLUB fallback to 0-order page, reserved memory,
    vmalloc and so on) but if there are lots of non-movable pages in system,
    their solutions are void in the long run.
    
    So, this patch is to support facility to change non-movable pages with
    movable.  For the feature, this patch introduces functions related to
    migration to address_space_operations as well as some page flags.
    
    If a driver want to make own pages movable, it should define three
    functions which are function pointers of struct
    address_space_operations.
    
    1. bool (*isolate_page) (struct page *page, isolate_mode_t mode);
    
    What VM expects on isolate_page function of driver is to return *true*
    if driver isolates page successfully.  On returing true, VM marks the
    page as PG_isolated so concurrent isolation in several CPUs skip the
    page for isolation.  If a driver cannot isolate the page, it should
    return *false*.
    
    Once page is successfully isolated, VM uses page.lru fields so driver
    shouldn't expect to preserve values in that fields.
    
    2. int (*migratepage) (struct address_space *mapping,
                    struct page *newpage, struct page *oldpage, enum migrate_mode);
    
    After isolation, VM calls migratepage of driver with isolated page.  The
    function of migratepage is to move content of the old page to new page
    and set up fields of struct page newpage.  Keep in mind that you should
    indicate to the VM the oldpage is no longer movable via
    __ClearPageMovable() under page_lock if you migrated the oldpage
    successfully and returns 0.  If driver cannot migrate the page at the
    moment, driver can return -EAGAIN.  On -EAGAIN, VM will retry page
    migration in a short time because VM interprets -EAGAIN as "temporal
    migration failure".  On returning any error except -EAGAIN, VM will give
    up the page migration without retrying in this time.
    
    Driver shouldn't touch page.lru field VM using in the functions.
    
    3. void (*putback_page)(struct page *);
    
    If migration fails on isolated page, VM should return the isolated page
    to the driver so VM calls driver's putback_page with migration failed
    page.  In this function, driver should put the isolated page back to the
    own data structure.
    
    4. non-lru movable page flags
    
    There are two page flags for supporting non-lru movable page.
    
    * PG_movable
    
    Driver should use the below function to make page movable under
    page_lock.
    
            void __SetPageMovable(struct page *page, struct address_space *mapping)
    
    It needs argument of address_space for registering migration family
    functions which will be called by VM.  Exactly speaking, PG_movable is
    not a real flag of struct page.  Rather than, VM reuses page->mapping's
    lower bits to represent it.
    
            #define PAGE_MAPPING_MOVABLE 0x2
            page->mapping = page->mapping | PAGE_MAPPING_MOVABLE;
    
    so driver shouldn't access page->mapping directly.  Instead, driver
    should use page_mapping which mask off the low two bits of page->mapping
    so it can get right struct address_space.
    
    For testing of non-lru movable page, VM supports __PageMovable function.
    However, it doesn't guarantee to identify non-lru movable page because
    page->mapping field is unified with other variables in struct page.  As
    well, if driver releases the page after isolation by VM, page->mapping
    doesn't have stable value although it has PAGE_MAPPING_MOVABLE (Look at
    __ClearPageMovable).  But __PageMovable is cheap to catch whether page
    is LRU or non-lru movable once the page has been isolated.  Because LRU
    pages never can have PAGE_MAPPING_MOVABLE in page->mapping.  It is also
    good for just peeking to test non-lru movable pages before more
    expensive checking with lock_page in pfn scanning to select victim.
    
    For guaranteeing non-lru movable page, VM provides PageMovable function.
    Unlike __PageMovable, PageMovable functions validates page->mapping and
    mapping->a_ops->isolate_page under lock_page.  The lock_page prevents
    sudden destroying of page->mapping.
    
    Driver using __SetPageMovable should clear the flag via
    __ClearMovablePage under page_lock before the releasing the page.
    
    * PG_isolated
    
    To prevent concurrent isolation among several CPUs, VM marks isolated
    page as PG_isolated under lock_page.  So if a CPU encounters PG_isolated
    non-lru movable page, it can skip it.  Driver doesn't need to manipulate
    the flag because VM will set/clear it automatically.  Keep in mind that
    if driver sees PG_isolated page, it means the page have been isolated by
    VM so it shouldn't touch page.lru field.  PG_isolated is alias with
    PG_reclaim flag so driver shouldn't use the flag for own purpose.
    
    [opensource.ganesh@gmail.com: mm/compaction: remove local variable is_lru]
      Link: http://lkml.kernel.org/r/20160618014841.GA7422@leo-test
    Link: http://lkml.kernel.org/r/1464736881-24886-3-git-send-email-minchan@kernel.org
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Minchan Kim <minchan@kernel.org>
    Signed-off-by: Ganesh Mahendran <opensource.ganesh@gmail.com>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Rafael Aquini <aquini@redhat.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: John Einar Reitan <john.reitan@foss.arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0c9ebf530d9e..97fe08d17d89 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -402,6 +402,8 @@ struct address_space_operations {
 	 */
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *, enum migrate_mode);
+	bool (*isolate_page)(struct page *, isolate_mode_t);
+	void (*putback_page)(struct page *);
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, unsigned long,
 					unsigned long);

commit 6c60d2b5746cf23025ffe71bd7ff9075048fc90c
Author: Dave Chinner <dchinner@redhat.com>
Date:   Tue Jul 26 15:21:50 2016 -0700

    fs/fs-writeback.c: add a new writeback list for sync
    
    wait_sb_inodes() currently does a walk of all inodes in the filesystem
    to find dirty one to wait on during sync.  This is highly inefficient
    and wastes a lot of CPU when there are lots of clean cached inodes that
    we don't need to wait on.
    
    To avoid this "all inode" walk, we need to track inodes that are
    currently under writeback that we need to wait for.  We do this by
    adding inodes to a writeback list on the sb when the mapping is first
    tagged as having pages under writeback.  wait_sb_inodes() can then walk
    this list of "inodes under IO" and wait specifically just for the inodes
    that the current sync(2) needs to wait for.
    
    Define a couple helpers to add/remove an inode from the writeback list
    and call them when the overall mapping is tagged for or cleared from
    writeback.  Update wait_sb_inodes() to walk only the inodes under
    writeback due to the sync.
    
    With this change, filesystem sync times are significantly reduced for
    fs' with largely populated inode caches and otherwise no other work to
    do.  For example, on a 16xcpu 2GHz x86-64 server, 10TB XFS filesystem
    with a ~10m entry inode cache, sync times are reduced from ~7.3s to less
    than 0.1s when the filesystem is fully clean.
    
    Link: http://lkml.kernel.org/r/1466594593-6757-2-git-send-email-bfoster@redhat.com
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Brian Foster <bfoster@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Tested-by: Holger Hoffsttte <holger.hoffstaette@applied-asynchrony.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd288148a6b1..0c9ebf530d9e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -665,6 +665,7 @@ struct inode {
 #endif
 	struct list_head	i_lru;		/* inode LRU list */
 	struct list_head	i_sb_list;
+	struct list_head	i_wb_list;	/* backing dev writeback list */
 	union {
 		struct hlist_head	i_dentry;
 		struct rcu_head		i_rcu;
@@ -1448,6 +1449,9 @@ struct super_block {
 	/* s_inode_list_lock protects s_inodes */
 	spinlock_t		s_inode_list_lock ____cacheline_aligned_in_smp;
 	struct list_head	s_inodes;	/* all inodes */
+
+	spinlock_t		s_inode_wblist_lock;
+	struct list_head	s_inodes_wb;	/* writeback inodes */
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 70246286e94c335b5bea0cbc68a17a96dd620281
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jul 19 11:28:41 2016 +0200

    block: get rid of bio_rw and READA
    
    These two are confusing leftover of the old world order, combining
    values of the REQ_OP_ and REQ_ namespaces.  For callers that don't
    special case we mostly just replace bi_rw with bio_data_dir or
    op_is_write, except for the few cases where a switch over the REQ_OP_
    values makes more sense.  Any check for READA is replaced with an
    explicit check for REQ_RAHEAD.  Also remove the READA alias for
    REQ_RAHEAD.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Mike Christie <mchristi@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 183024525d40..dc488662ce0b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -178,9 +178,6 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  * READ_SYNC		A synchronous read. Device is not plugged, caller can
  *			immediately wait on this read without caring about
  *			unplugging.
- * READA		Used for read-ahead operations. Lower priority, and the
- *			block layer could (in theory) choose to ignore this
- *			request if it runs into resource problems.
  * WRITE		A normal async write. Device will be plugged.
  * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down
  *			the hint that someone will be waiting on this IO
@@ -195,11 +192,9 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  *
  */
 #define RW_MASK			REQ_OP_WRITE
-#define RWA_MASK		REQ_RAHEAD
 
 #define READ			REQ_OP_READ
-#define WRITE			RW_MASK
-#define READA			RWA_MASK
+#define WRITE			REQ_OP_WRITE
 
 #define READ_SYNC		REQ_SYNC
 #define WRITE_SYNC		(REQ_SYNC | REQ_NOIDLE)
@@ -2470,17 +2465,6 @@ static inline bool op_is_write(unsigned int op)
 	return op == REQ_OP_READ ? false : true;
 }
 
-/*
- * return READ, READA, or WRITE
- */
-static inline int bio_rw(struct bio *bio)
-{
-	if (op_is_write(bio_op(bio)))
-		return WRITE;
-
-	return bio->bi_rw & RWA_MASK;
-}
-
 /*
  * return data direction, READ or WRITE
  */

commit a4a4f9439c73b921ef246368fc6f2d7c0281e99d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 19 13:16:52 2016 -0400

    bdev: get rid of ->bd_inodes
    
    Since 2006 we have ->i_bdev pinning bdev in question, so there's no
    way to get to bdev ->evict_inode() while there's an aliasing inode
    anywhere.  In other words, the only place walking the list of aliases
    is guaranteed to do it only when the list is empty...
    
    Remove the detritus; it should've been done in "[PATCH] Fix a race
    condition between ->i_mapping and iput()", but nobody had noticed it
    back then.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bacc0733663c..1878c8461622 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -459,7 +459,6 @@ struct block_device {
 	struct inode *		bd_inode;	/* will die */
 	struct super_block *	bd_super;
 	struct mutex		bd_mutex;	/* open/close mutex */
-	struct list_head	bd_inodes;
 	void *			bd_claiming;
 	void *			bd_holder;
 	int			bd_holders;

commit 81754357770ebd900801231e7bc8d151ddc00498
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Thu Dec 11 10:15:45 2014 -0600

    fs: Update i_[ug]id_(read|write) to translate relative to s_user_ns
    
    For filesystems mounted from a user namespace on-disk ids should
    be translated relative to s_users_ns rather than init_user_ns.
    
    When an id in the filesystem doesn't exist in s_user_ns the
    associated id in the inode will be set to INVALID_[UG]ID, which
    turns these into de facto "nobody" ids. This actually maps pretty
    well into the way most code already works, and those places where
    it didn't were fixed in previous patches. Moving forward vfs code
    needs to be careful to handle instances where ids in inodes may
    be invalid.
    
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cb25ceb6d1ef..8aa9b72e0bc5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -831,31 +831,6 @@ static inline void i_size_write(struct inode *inode, loff_t i_size)
 #endif
 }
 
-/* Helper functions so that in most cases filesystems will
- * not need to deal directly with kuid_t and kgid_t and can
- * instead deal with the raw numeric values that are stored
- * in the filesystem.
- */
-static inline uid_t i_uid_read(const struct inode *inode)
-{
-	return from_kuid(&init_user_ns, inode->i_uid);
-}
-
-static inline gid_t i_gid_read(const struct inode *inode)
-{
-	return from_kgid(&init_user_ns, inode->i_gid);
-}
-
-static inline void i_uid_write(struct inode *inode, uid_t uid)
-{
-	inode->i_uid = make_kuid(&init_user_ns, uid);
-}
-
-static inline void i_gid_write(struct inode *inode, gid_t gid)
-{
-	inode->i_gid = make_kgid(&init_user_ns, gid);
-}
-
 static inline unsigned iminor(const struct inode *inode)
 {
 	return MINOR(inode->i_rdev);
@@ -1461,6 +1436,31 @@ struct super_block {
 	struct list_head	s_inodes;	/* all inodes */
 };
 
+/* Helper functions so that in most cases filesystems will
+ * not need to deal directly with kuid_t and kgid_t and can
+ * instead deal with the raw numeric values that are stored
+ * in the filesystem.
+ */
+static inline uid_t i_uid_read(const struct inode *inode)
+{
+	return from_kuid(inode->i_sb->s_user_ns, inode->i_uid);
+}
+
+static inline gid_t i_gid_read(const struct inode *inode)
+{
+	return from_kgid(inode->i_sb->s_user_ns, inode->i_gid);
+}
+
+static inline void i_uid_write(struct inode *inode, uid_t uid)
+{
+	inode->i_uid = make_kuid(inode->i_sb->s_user_ns, uid);
+}
+
+static inline void i_gid_write(struct inode *inode, gid_t gid)
+{
+	inode->i_gid = make_kgid(inode->i_sb->s_user_ns, gid);
+}
+
 extern struct timespec current_fs_time(struct super_block *sb);
 
 /*

commit 0bd23d09b874e53bd1a2fe2296030aa2720d7b08
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Jun 29 14:54:46 2016 -0500

    vfs: Don't modify inodes with a uid or gid unknown to the vfs
    
    When a filesystem outside of init_user_ns is mounted it could have
    uids and gids stored in it that do not map to init_user_ns.
    
    The plan is to allow those filesystems to set i_uid to INVALID_UID and
    i_gid to INVALID_GID for unmapped uids and gids and then to handle
    that strange case in the vfs to ensure there is consistent robust
    handling of the weirdness.
    
    Upon a careful review of the vfs and filesystems about the only case
    where there is any possibility of confusion or trouble is when the
    inode is written back to disk.  In that case filesystems typically
    read the inode->i_uid and inode->i_gid and write them to disk even
    when just an inode timestamp is being updated.
    
    Which leads to a rule that is very simple to implement and understand
    inodes whose i_uid or i_gid is not valid may not be written.
    
    In dealing with access times this means treat those inodes as if the
    inode flag S_NOATIME was set.  Reads of the inodes appear safe and
    useful, but any write or modification is disallowed.  The only inode
    write that is allowed is a chown that sets the uid and gid on the
    inode to valid values.  After such a chown the inode is normal and may
    be treated as such.
    
    Denying all writes to inodes with uids or gids unknown to the vfs also
    prevents several oddball cases where corruption would have occurred
    because the vfs does not have complete information.
    
    One problem case that is prevented is attempting to use the gid of a
    directory for new inodes where the directories sgid bit is set but the
    directories gid is not mapped.
    
    Another problem case avoided is attempting to update the evm hash
    after setxattr, removexattr, and setattr.  As the evm hash includeds
    the inode->i_uid or inode->i_gid not knowning the uid or gid prevents
    a correct evm hash from being computed.  evm hash verification also
    fails when i_uid or i_gid is unknown but that is essentially harmless
    as it does not cause filesystem corruption.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 375e37f42cdf..cb25ceb6d1ef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1874,6 +1874,11 @@ struct super_operations {
 #define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
 				 (inode)->i_rdev == WHITEOUT_DEV)
 
+static inline bool HAS_UNMAPPED_ID(struct inode *inode)
+{
+	return !uid_valid(inode->i_uid) || !gid_valid(inode->i_gid);
+}
+
 /*
  * Inode state bits.  Protected by inode->i_lock
  *

commit 2d902671ce1cd98cdc88d78c481889a1b2996101
Author: Miklos Szeredi <mszeredi@redhat.com>
Date:   Thu Jun 30 08:53:27 2016 +0200

    vfs: merge .d_select_inode() into .d_real()
    
    The two methods essentially do the same: find the real dentry/inode
    belonging to an overlay dentry.  The difference is in the usage:
    
    vfs_open() uses ->d_select_inode() and expects the function to perform
    copy-up if necessary based on the open flags argument.
    
    file_dentry() uses ->d_real() passing in the overlay dentry as well as the
    underlying inode.
    
    vfs_rename() uses ->d_select_inode() but passes zero flags.  ->d_real()
    with a zero inode would have worked just as well here.
    
    This patch merges the functionality of ->d_select_inode() into ->d_real()
    by adding an 'open_flags' argument to the latter.
    
    [Al Viro] Make the signature of d_real() match that of ->d_real() again.
    And constify the inode argument, while we are at it.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd288148a6b1..bacc0733663c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1272,12 +1272,7 @@ static inline struct inode *file_inode(const struct file *f)
 
 static inline struct dentry *file_dentry(const struct file *file)
 {
-	struct dentry *dentry = file->f_path.dentry;
-
-	if (unlikely(dentry->d_flags & DCACHE_OP_REAL))
-		return dentry->d_op->d_real(dentry, file_inode(file));
-	else
-		return dentry;
+	return d_real(file->f_path.dentry, file_inode(file), 0);
 }
 
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)

commit cc50a07a247e17db76b1f0b0ca06652556e04fa3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 9 15:44:48 2016 -0500

    userns: Remove the now unnecessary FS_USERNS_DEV_MOUNT flag
    
    Now that SB_I_NODEV controls the nodev behavior devpts can just clear
    this flag during mount.  Simplifying the code and making it easier
    to audit how the code works.  While still preserving the invariant
    that s_iflags is only modified during mount.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e05983170d23..375e37f42cdf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2022,7 +2022,6 @@ struct file_system_type {
 #define FS_BINARY_MOUNTDATA	2
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
-#define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);

commit a2982cc922c3068783eb9a1f77a5626a1ec36a1f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 9 15:34:02 2016 -0500

    vfs: Generalize filesystem nodev handling.
    
    Introduce a function may_open_dev that tests MNT_NODEV and a new
    superblock flab SB_I_NODEV.  Use this new function in all of the
    places where MNT_NODEV was previously tested.
    
    Add the new SB_I_NODEV s_iflag to proc, sysfs, and mqueuefs as those
    filesystems should never support device nodes, and a simple superblock
    flags makes that very hard to get wrong.  With SB_I_NODEV set if any
    device nodes somehow manage to show up on on a filesystem those
    device nodes will be unopenable.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9eef64f23a75..e05983170d23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1327,6 +1327,7 @@ struct mm_struct;
 /* sb->s_iflags */
 #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 #define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
+#define SB_I_NODEV	0x00000004	/* Ignore devices on this fs */
 
 /* sb->s_iflags to limit user namespace mounts */
 #define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
@@ -1602,6 +1603,7 @@ extern int vfs_whiteout(struct inode *, struct dentry *);
  */
 extern void inode_init_owner(struct inode *inode, const struct inode *dir,
 			umode_t mode);
+extern bool may_open_dev(const struct path *path);
 /*
  * VFS FS_IOC_FIEMAP helper definitions.
  */

commit 6e4eab577a0cae15b3da9b888cff16fe57981b3e
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue May 24 09:29:01 2016 -0500

    fs: Add user namespace member to struct super_block
    
    Start marking filesystems with a user namespace owner, s_user_ns.  In
    this change this is only used for permission checks of who may mount a
    filesystem.  Ultimately s_user_ns will be used for translating ids and
    checking capabilities for filesystems mounted from user namespaces.
    
    The default policy for setting s_user_ns is implemented in sget(),
    which arranges for s_user_ns to be set to current_user_ns() and to
    ensure that the mounter of the filesystem has CAP_SYS_ADMIN in that
    user_ns.
    
    The guts of sget are split out into another function sget_userns().
    The function sget_userns calls alloc_super with the specified user
    namespace or it verifies the existing superblock that was found
    has the expected user namespace, and fails with EBUSY when it is not.
    This failing prevents users with the wrong privileges mounting a
    filesystem.
    
    The reason for the split of sget_userns from sget is that in some
    cases such as mount_ns and kernfs_mount_ns a different policy for
    permission checking of mounts and setting s_user_ns is necessary, and
    the existence of sget_userns() allows those policies to be
    implemented.
    
    The helper mount_ns is expected to be used for filesystems such as
    proc and mqueuefs which present per namespace information.  The
    function mount_ns is modified to call sget_userns instead of sget to
    ensure the user namespace owner of the namespace whose information is
    presented by the filesystem is used on the superblock.
    
    For sysfs and cgroup the appropriate permission checks are already in
    place, and kernfs_mount_ns is modified to call sget_userns so that
    the init_user_ns is the only user namespace used.
    
    For the cgroup filesystem cgroup namespace mounts are bind mounts of a
    subset of the full cgroup filesystem and as such s_user_ns must be the
    same for all of them as there is only a single superblock.
    
    Mounts of sysfs that vary based on the network namespace could in principle
    change s_user_ns but it keeps the analysis and implementation of kernfs
    simpler if that is not supported, and at present there appear to be no
    benefits from supporting a different s_user_ns on any sysfs mount.
    
    Getting the details of setting s_user_ns correct has been
    a long process.  Thanks to Pavel Tikhorirorv who spotted a leak
    in sget_userns.  Thanks to Seth Forshee who has kept the work alive.
    
    Thanks-to: Seth Forshee <seth.forshee@canonical.com>
    Thanks-to: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ce006a24f49..9eef64f23a75 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1432,6 +1432,13 @@ struct super_block {
 	struct workqueue_struct *s_dio_done_wq;
 	struct hlist_head s_pins;
 
+	/*
+	 * Owning user namespace and default context in which to
+	 * interpret filesystem uids, gids, quotas, device nodes,
+	 * xattrs and security labels.
+	 */
+	struct user_namespace *s_user_ns;
+
 	/*
 	 * Keep the lru lists last in the structure so they always sit on their
 	 * own individual cachelines.
@@ -2056,6 +2063,11 @@ void deactivate_locked_super(struct super_block *sb);
 int set_anon_super(struct super_block *s, void *data);
 int get_anon_bdev(dev_t *);
 void free_anon_bdev(dev_t);
+struct super_block *sget_userns(struct file_system_type *type,
+			int (*test)(struct super_block *,void *),
+			int (*set)(struct super_block *,void *),
+			int flags, struct user_namespace *user_ns,
+			void *data);
 struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),

commit d91ee87d8d85a0808c01787e8b4a6b48f2ba487b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon May 23 14:51:59 2016 -0500

    vfs: Pass data, ns, and ns->userns to mount_ns
    
    Today what is normally called data (the mount options) is not passed
    to fill_super through mount_ns.
    
    Pass the mount options and the namespace separately to mount_ns so
    that filesystems such as proc that have mount options, can use
    mount_ns.
    
    Pass the user namespace to mount_ns so that the standard permission
    check that verifies the mounter has permissions over the namespace can
    be performed in mount_ns instead of in each filesystems .mount method.
    Thus removing the duplication between mqueuefs and proc in terms of
    permission checks.  The extra permission check does not currently
    affect the rpc_pipefs filesystem and the nfsd filesystem as those
    filesystems do not currently allow unprivileged mounts.  Without
    unpvileged mounts it is guaranteed that the caller has already passed
    capable(CAP_SYS_ADMIN) which guarantees extra permission check will
    pass.
    
    Update rpc_pipefs and the nfsd filesystem to ensure that the network
    namespace reference is always taken in fill_super and always put in kill_sb
    so that the logic is simpler and so that errors originating inside of
    fill_super do not cause a network namespace leak.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 71988dd3af95..1ce006a24f49 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2034,8 +2034,9 @@ struct file_system_type {
 
 #define MODULE_ALIAS_FS(NAME) MODULE_ALIAS("fs-" NAME)
 
-extern struct dentry *mount_ns(struct file_system_type *fs_type, int flags,
-	void *data, int (*fill_super)(struct super_block *, void *, int));
+extern struct dentry *mount_ns(struct file_system_type *fs_type,
+	int flags, void *data, void *ns, struct user_namespace *user_ns,
+	int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int));

commit 8654df4e2ac9704905198d63845554c2ddf6a93f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jun 9 16:06:06 2016 -0500

    mnt: Refactor fs_fully_visible into mount_too_revealing
    
    Replace the call of fs_fully_visible in do_new_mount from before the
    new superblock is allocated with a call of mount_too_revealing after
    the superblock is allocated.   This winds up being a much better location
    for maintainability of the code.
    
    The first change this enables is the replacement of FS_USERNS_VISIBLE
    with SB_I_USERNS_VISIBLE.  Moving the flag from struct filesystem_type
    to sb_iflags on the superblock.
    
    Unfortunately mount_too_revealing fundamentally needs to touch
    mnt_flags adding several MNT_LOCKED_XXX flags at the appropriate
    times.  If the mnt_flags did not need to be touched the code
    could be easily moved into the filesystem specific mount code.
    
    Acked-by: Seth Forshee <seth.forshee@canonical.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd288148a6b1..71988dd3af95 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1328,6 +1328,9 @@ struct mm_struct;
 #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 #define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
 
+/* sb->s_iflags to limit user namespace mounts */
+#define SB_I_USERNS_VISIBLE		0x00000010 /* fstype already mounted */
+
 /* Possible states of 'frozen' field */
 enum {
 	SB_UNFROZEN = 0,		/* FS is unfrozen */
@@ -2011,7 +2014,6 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
-#define FS_USERNS_VISIBLE	32	/* FS must already be visible */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);

commit 28a8f0d317bf225ff15008f5dd66ae16242dd843
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:32:25 2016 -0500

    block, drivers, fs: rename REQ_FLUSH to REQ_PREFLUSH
    
    To avoid confusion between REQ_OP_FLUSH, which is handled by
    request_fn drivers, and upper layers requesting the block layer
    perform a flush sequence along with possibly a WRITE, this patch
    renames REQ_FLUSH to REQ_PREFLUSH.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ccd166477487..183024525d40 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -204,9 +204,9 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define READ_SYNC		REQ_SYNC
 #define WRITE_SYNC		(REQ_SYNC | REQ_NOIDLE)
 #define WRITE_ODIRECT		REQ_SYNC
-#define WRITE_FLUSH		(REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
+#define WRITE_FLUSH		(REQ_SYNC | REQ_NOIDLE | REQ_PREFLUSH)
 #define WRITE_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_FUA)
-#define WRITE_FLUSH_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
+#define WRITE_FLUSH_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_PREFLUSH | REQ_FUA)
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what

commit 4e1b2d52a80d79296a5d899d73249748dea71a53
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:32:22 2016 -0500

    block, fs, drivers: remove REQ_OP compat defs and related code
    
    This patch drops the compat definition of req_op where it matches
    the rq_flag_bits definitions, and drops the related old and compat
    code that allowed users to set either the op or flags for the operation.
    
    We also then store the operation in the bi_rw/cmd_flags field similar
    to how we used to store the bio ioprio where it sat in the upper bits
    of the field.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index af6f3c7e4822..ccd166477487 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -152,9 +152,10 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define CHECK_IOVEC_ONLY -1
 
 /*
- * The below are the various read and write types that we support. Some of
+ * The below are the various read and write flags that we support. Some of
  * them include behavioral modifiers that send information down to the
- * block layer and IO scheduler. Terminology:
+ * block layer and IO scheduler. They should be used along with a req_op.
+ * Terminology:
  *
  *	The block layer uses device plugging to defer IO a little bit, in
  *	the hope that we will see more IO very shortly. This increases
@@ -193,19 +194,19 @@ typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  *			non-volatile media on completion.
  *
  */
-#define RW_MASK			REQ_WRITE
+#define RW_MASK			REQ_OP_WRITE
 #define RWA_MASK		REQ_RAHEAD
 
-#define READ			0
+#define READ			REQ_OP_READ
 #define WRITE			RW_MASK
 #define READA			RWA_MASK
 
-#define READ_SYNC		(READ | REQ_SYNC)
-#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)
-#define WRITE_ODIRECT		(WRITE | REQ_SYNC)
-#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
-#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)
-#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
+#define READ_SYNC		REQ_SYNC
+#define WRITE_SYNC		(REQ_SYNC | REQ_NOIDLE)
+#define WRITE_ODIRECT		REQ_SYNC
+#define WRITE_FLUSH		(REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
+#define WRITE_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_FUA)
+#define WRITE_FLUSH_FUA		(REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what
@@ -2464,17 +2465,9 @@ extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
-/*
- * tmp cpmpat. Users used to set the write bit for all non reads, but
- * we will be dropping the bitmap use for ops. Support both until
- * the end of the patchset.
- */
-static inline bool op_is_write(unsigned long flags)
+static inline bool op_is_write(unsigned int op)
 {
-	if (flags & (REQ_OP_WRITE | REQ_OP_WRITE_SAME | REQ_OP_DISCARD))
-		return true;
-	else
-		return false;
+	return op == REQ_OP_READ ? false : true;
 }
 
 /*
@@ -2482,7 +2475,7 @@ static inline bool op_is_write(unsigned long flags)
  */
 static inline int bio_rw(struct bio *bio)
 {
-	if (op_is_write(op_from_rq_bits(bio->bi_rw)))
+	if (op_is_write(bio_op(bio)))
 		return WRITE;
 
 	return bio->bi_rw & RWA_MASK;
@@ -2493,7 +2486,7 @@ static inline int bio_rw(struct bio *bio)
  */
 static inline int bio_data_dir(struct bio *bio)
 {
-	return op_is_write(op_from_rq_bits(bio->bi_rw)) ? WRITE : READ;
+	return op_is_write(bio_op(bio)) ? WRITE : READ;
 }
 
 extern void check_disk_size_change(struct gendisk *disk,

commit 8a4c1e42e0eb7189296ac140761370e2549cffe7
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:50 2016 -0500

    direct-io: use bio set/get op accessors
    
    This patch has the dio code use a REQ_OP for the op and rq_flag_bits
    for bi_rw flags. To set/get the op it uses the bio_set_op_attrs/bio_op
    accssors.
    
    It also begins to convert btrfs's dio_submit_t because of the dio
    submit_io callout use. The next patches will completely convert
    this code and the reset of the btrfs code paths.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 62ca2f9cad95..af6f3c7e4822 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2824,7 +2824,7 @@ extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
 #ifdef CONFIG_BLOCK
-typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
+typedef void (dio_submit_t)(struct bio *bio, struct inode *inode,
 			    loff_t file_offset);
 
 enum {

commit f21508211d2b16e65821abd171378fa6ece126fe
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:42 2016 -0500

    block: add REQ_OP definitions and helpers
    
    The following patches separate the operation (WRITE, READ, DISCARD,
    etc) from the rq_flag_bits flags. This patch adds definitions for
    request/bio operations (REQ_OPs) and adds request/bio accessors to
    get/set the op.
    
    In this patch the REQ_OPs match the REQ rq_flag_bits ones
    for compat reasons while all the code is converted to use the
    op accessors in the set. In the last patches the op will become a
    number and the accessors and helpers in this patch will be dropped
    or updated.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65e4c51ecb3d..62ca2f9cad95 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2464,15 +2464,37 @@ extern void make_bad_inode(struct inode *);
 extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
+/*
+ * tmp cpmpat. Users used to set the write bit for all non reads, but
+ * we will be dropping the bitmap use for ops. Support both until
+ * the end of the patchset.
+ */
+static inline bool op_is_write(unsigned long flags)
+{
+	if (flags & (REQ_OP_WRITE | REQ_OP_WRITE_SAME | REQ_OP_DISCARD))
+		return true;
+	else
+		return false;
+}
+
 /*
  * return READ, READA, or WRITE
  */
-#define bio_rw(bio)		((bio)->bi_rw & (RW_MASK | RWA_MASK))
+static inline int bio_rw(struct bio *bio)
+{
+	if (op_is_write(op_from_rq_bits(bio->bi_rw)))
+		return WRITE;
+
+	return bio->bi_rw & RWA_MASK;
+}
 
 /*
  * return data direction, READ or WRITE
  */
-#define bio_data_dir(bio)	((bio)->bi_rw & 1)
+static inline int bio_data_dir(struct bio *bio)
+{
+	return op_is_write(op_from_rq_bits(bio->bi_rw)) ? WRITE : READ;
+}
 
 extern void check_disk_size_change(struct gendisk *disk,
 				   struct block_device *bdev);

commit 4e49ea4a3d276365bf7396c9b77b4d1d5923835a
Author: Mike Christie <mchristi@redhat.com>
Date:   Sun Jun 5 14:31:41 2016 -0500

    block/fs/drivers: remove rw argument from submit_bio
    
    This has callers of submit_bio/submit_bio_wait set the bio->bi_rw
    instead of passing it in. This makes that use the same as
    generic_make_request and how we set the other bio fields.
    
    Signed-off-by: Mike Christie <mchristi@redhat.com>
    
    Fixed up fs/ext4/crypto.c
    
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd288148a6b1..65e4c51ecb3d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2747,7 +2747,7 @@ static inline void remove_inode_hash(struct inode *inode)
 extern void inode_sb_list_add(struct inode *inode);
 
 #ifdef CONFIG_BLOCK
-extern blk_qc_t submit_bio(int, struct bio *);
+extern blk_qc_t submit_bio(struct bio *);
 extern int bdev_read_only(struct block_device *);
 #endif
 extern int set_blocksize(struct block_device *, int);

commit d102a56edba7a3f236454716fa09920e66772044
Merge: 0121a32201dc 3767e255b390
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 27 17:14:05 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs fixes from Al Viro:
     "Followups to the parallel lookup work:
    
       - update docs
    
       - restore killability of the places that used to take ->i_mutex
         killably now that we have down_write_killable() merged
    
       - Additionally, it turns out that I missed a prerequisite for
         security_d_instantiate() stuff - ->getxattr() wasn't the only thing
         that could be called before dentry is attached to inode; with smack
         we needed the same treatment applied to ->setxattr() as well"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      switch ->setxattr() to passing dentry and inode separately
      switch xattr_handler->set() to passing dentry and inode separately
      restore killability of old mutex_lock_killable(&inode->i_mutex) users
      add down_write_killable_nested()
      update D/f/directory-locking

commit 3767e255b390d72f9a33c08d9e86c5f21f25860f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 27 11:06:05 2016 -0400

    switch ->setxattr() to passing dentry and inode separately
    
    smack ->d_instantiate() uses ->setxattr(), so to be able to call it before
    we'd hashed the new dentry and attached it to inode, we need ->setxattr()
    instances getting the inode as an explicit argument rather than obtaining
    it from dentry.
    
    Similar change for ->getxattr() had been done in commit ce23e64.  Unlike
    ->getxattr() (which is used by both selinux and smack instances of
    ->d_instantiate()) ->setxattr() is used only by smack one and unfortunately
    it got missed back then.
    
    Reported-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Tested-by: Casey Schaufler <casey@schaufler-ca.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5f61431d8673..62bdb0a6cf2d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1730,7 +1730,8 @@ struct inode_operations {
 			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
-	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
+	int (*setxattr) (struct dentry *, struct inode *,
+			 const char *, const void *, size_t, int);
 	ssize_t (*getxattr) (struct dentry *, struct inode *,
 			     const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);

commit 315227f6da389f3a560f27f7777080857278e1b4
Merge: a10c38a4f385 40543f62cbdc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 26 19:34:26 2016 -0700

    Merge tag 'dax-misc-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull misc DAX updates from Vishal Verma:
     "DAX error handling for 4.7
    
       - Until now, dax has been disabled if media errors were found on any
         device.  This enables the use of DAX in the presence of these
         errors by making all sector-aligned zeroing go through the driver.
    
       - The driver (already) has the ability to clear errors on writes that
         are sent through the block layer using 'DSMs' defined in ACPI 6.1.
    
      Other misc changes:
    
       - When mounting DAX filesystems, check to make sure the partition is
         page aligned.  This is a requirement for DAX, and previously, we
         allowed such unaligned mounts to succeed, but subsequent
         reads/writes would fail.
    
       - Misc/cleanup fixes from Jan that remove unused code from DAX
         related to zeroing, writeback, and some size checks"
    
    * tag 'dax-misc-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm:
      dax: fix a comment in dax_zero_page_range and dax_truncate_page
      dax: for truncate/hole-punch, do zeroing through the driver if possible
      dax: export a low-level __dax_zero_page_range helper
      dax: use sb_issue_zerout instead of calling dax_clear_sectors
      dax: enable dax in the presence of known media errors (badblocks)
      dax: fallback from pmd to pte on error
      block: Update blkdev_dax_capable() for consistency
      xfs: Add alignment check for DAX mount
      ext2: Add alignment check for DAX mount
      ext4: Add alignment check for DAX mount
      block: Add bdev_dax_supported() for dax mount checks
      block: Add vfs_msg() interface
      dax: Remove redundant inode size checks
      dax: Remove pointless writeback from dax_do_io()
      dax: Remove zeroing from dax_io()
      dax: Remove dead zeroing code from fault handlers
      ext2: Avoid DAX zeroing to corrupt data
      ext2: Fix block zeroing in ext2_get_blocks() for DAX
      dax: Remove complete_unwritten argument
      DAX: move RADIX_DAX_ definitions to dax.c

commit 1f40c49570eb01436786a9b5845c4469a9a1f362
Merge: 7639dad93a55 36092ee8ba69
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 23 11:18:01 2016 -0700

    Merge tag 'libnvdimm-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "The bulk of this update was stabilized before the merge window and
      appeared in -next.  The "device dax" implementation was revised this
      week in response to review feedback, and to address failures detected
      by the recently expanded ndctl unit test suite.
    
      Not included in this pull request are two dax topic branches (dax
      error handling, and dax radix-tree locking).  These topics were
      deferred to get a few more days of -next integration testing, and to
      coordinate a branch baseline with Ted and the ext4 tree.  Vishal and
      Ross will send the error handling and locking topics respectively in
      the next few days.
    
      This branch has received a positive build result from the kbuild robot
      across 226 configs.
    
      Summary:
    
       - Device DAX for persistent memory: Device DAX is the device-centric
         analogue of Filesystem DAX (CONFIG_FS_DAX).  It allows memory
         ranges to be allocated and mapped without need of an intervening
         file system.  Device DAX is strict, precise and predictable.
         Specifically this interface:
    
          a) Guarantees fault granularity with respect to a given page size
             (pte, pmd, or pud) set at configuration time.
    
          b) Enforces deterministic behavior by being strict about what
             fault scenarios are supported.
    
         Persistent memory is the first target, but the mechanism is also
         targeted for exclusive allocations of performance/feature
         differentiated memory ranges.
    
       - Support for the HPE DSM (device specific method) command formats.
         This enables management of these first generation devices until a
         unified DSM specification materializes.
    
       - Further ACPI 6.1 compliance with support for the common dimm
         identifier format.
    
       - Various fixes and cleanups across the subsystem"
    
    * tag 'libnvdimm-for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (40 commits)
      libnvdimm, dax: fix deletion
      libnvdimm, dax: fix alignment validation
      libnvdimm, dax: autodetect support
      libnvdimm: release ida resources
      Revert "block: enable dax for raw block devices"
      /dev/dax, core: file operations and dax-mmap
      /dev/dax, pmem: direct access to persistent memory
      libnvdimm: stop requiring a driver ->remove() method
      libnvdimm, dax: record the specified alignment of a dax-device instance
      libnvdimm, dax: reserve space to store labels for device-dax
      libnvdimm, dax: introduce device-dax infrastructure
      nfit: add sysfs dimm 'family' and 'dsm_mask' attributes
      tools/testing/nvdimm: ND_CMD_CALL support
      nfit: disable vendor specific commands
      nfit: export subsystem ids as attributes
      nfit: fix format interface code byte order per ACPI6.1
      nfit, libnvdimm: limited/whitelisted dimm command marshaling mechanism
      nfit, libnvdimm: clarify "commands" vs "_DSMs"
      libnvdimm: increase max envelope size for ioctl
      acpi/nfit: Add sysfs "id" for NVDIMM ID
      ...

commit acc93d30d7d43f428272c20a047389c4cbca82ba
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat May 7 11:40:28 2016 -0700

    Revert "block: enable dax for raw block devices"
    
    This reverts commit 5a023cdba50c5f5f2bc351783b3131699deb3937.
    
    The functionality is superseded by the new "Device DAX" facility.
    
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Jan Kara <jack@suse.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 70e61b58baaf..8363a10660f6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2320,14 +2320,6 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
-#ifdef CONFIG_FS_DAX
-extern bool blkdev_dax_capable(struct block_device *bdev);
-#else
-static inline bool blkdev_dax_capable(struct block_device *bdev)
-{
-	return false;
-}
-#endif
 
 extern struct super_block *blockdev_superblock;
 

commit 3aa2fc1667acdd9cca816a2bc9529f494bd61b05
Merge: 5af234401345 c6e360a0d9d2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 21:26:15 2016 -0700

    Merge tag 'driver-core-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core updates from Greg KH:
     "Here's the "big" driver core update for 4.7-rc1.
    
      Mostly just debugfs changes, the long-known and messy races with
      removing debugfs files should be fixed thanks to the great work of
      Nicolai Stange.  We also have some isa updates in here (the x86
      maintainers told me to take it through this tree), a new warning when
      we run out of dynamic char major numbers, and a few other assorted
      changes, details in the shortlog.
    
      All have been in linux-next for some time with no reported issues"
    
    * tag 'driver-core-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (32 commits)
      Revert "base: dd: don't remove driver_data in -EPROBE_DEFER case"
      gpio: ws16c48: Utilize the ISA bus driver
      gpio: 104-idio-16: Utilize the ISA bus driver
      gpio: 104-idi-48: Utilize the ISA bus driver
      gpio: 104-dio-48e: Utilize the ISA bus driver
      watchdog: ebc-c384_wdt: Utilize the ISA bus driver
      iio: stx104: Utilize the module_isa_driver and max_num_isa_dev macros
      iio: stx104: Add X86 dependency to STX104 Kconfig option
      Documentation: Add ISA bus driver documentation
      isa: Implement the max_num_isa_dev macro
      isa: Implement the module_isa_driver macro
      pnp: pnpbios: Add explicit X86_32 dependency to PNPBIOS
      isa: Decouple X86_32 dependency from the ISA Kconfig option
      driver-core: use 'dev' argument in dev_dbg_ratelimited stub
      base: dd: don't remove driver_data in -EPROBE_DEFER case
      kernfs: Move faulting copy_user operations outside of the mutex
      devcoredump: add scatterlist support
      debugfs: unproxify files created through debugfs_create_u32_array()
      debugfs: unproxify files created through debugfs_create_blob()
      debugfs: unproxify files created through debugfs_create_bool()
      ...

commit f4f27d0028aabce57e44c16c2fdefccd6310d2f3
Merge: 2600a46ee0ed b937190c40de
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 09:21:36 2016 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Highlights:
    
       - A new LSM, "LoadPin", from Kees Cook is added, which allows forcing
         of modules and firmware to be loaded from a specific device (this
         is from ChromeOS, where the device as a whole is verified
         cryptographically via dm-verity).
    
         This is disabled by default but can be configured to be enabled by
         default (don't do this if you don't know what you're doing).
    
       - Keys: allow authentication data to be stored in an asymmetric key.
         Lots of general fixes and updates.
    
       - SELinux: add restrictions for loading of kernel modules via
         finit_module().  Distinguish non-init user namespace capability
         checks.  Apply execstack check on thread stacks"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (48 commits)
      LSM: LoadPin: provide enablement CONFIG
      Yama: use atomic allocations when reporting
      seccomp: Fix comment typo
      ima: add support for creating files using the mknodat syscall
      ima: fix ima_inode_post_setattr
      vfs: forbid write access when reading a file into memory
      fs: fix over-zealous use of "const"
      selinux: apply execstack check on thread stacks
      selinux: distinguish non-init user namespace capability checks
      LSM: LoadPin for kernel file loading restrictions
      fs: define a string representation of the kernel_read_file_id enumeration
      Yama: consolidate error reporting
      string_helpers: add kstrdup_quotable_file
      string_helpers: add kstrdup_quotable_cmdline
      string_helpers: add kstrdup_quotable
      selinux: check ss_initialized before revalidating an inode label
      selinux: delay inode label lookup as long as possible
      selinux: don't revalidate an inode's label when explicitly setting it
      selinux: Change bool variable name to index.
      KEYS: Add KEYCTL_DH_COMPUTE command
      ...

commit c2e7b207058d4ff6a9010430763fb561f307eb67
Merge: c52b76185b7a 24368aad47dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 15:05:23 2016 -0700

    Merge branch 'work.preadv2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs cleanups from Al Viro:
     "More cleanups from Christoph"
    
    * 'work.preadv2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      nfsd: use RWF_SYNC
      fs: add RWF_DSYNC aand RWF_SYNC
      ceph: use generic_write_sync
      fs: simplify the generic_write_sync prototype
      fs: add IOCB_SYNC and IOCB_DSYNC
      direct-io: remove the offset argument to dio_complete
      direct-io: eliminate the offset argument to ->direct_IO
      xfs: eliminate the pos variable in xfs_file_dio_aio_write
      filemap: remove the pos argument to generic_file_direct_write
      filemap: remove pos variables in generic_file_read_iter

commit c52b76185b7a1b300e5f15ff871c8f45ced3dee9
Merge: 681750c04681 81cd8896a64c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 17 14:41:03 2016 -0700

    Merge branch 'work.const-path' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull 'struct path' constification update from Al Viro:
     "'struct path' is passed by reference to a bunch of Linux security
      methods; in theory, there's nothing to stop them from modifying the
      damn thing and LSM community being what it is, sooner or later some
      enterprising soul is going to decide that it's a good idea.
    
      Let's remove the temptation and constify all of those..."
    
    * 'work.const-path' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      constify ima_d_path()
      constify security_sb_pivotroot()
      constify security_path_chroot()
      constify security_path_{link,rename}
      apparmor: remove useless checks for NULL ->mnt
      constify security_path_{mkdir,mknod,symlink}
      constify security_path_{unlink,rmdir}
      apparmor: constify common_perm_...()
      apparmor: constify aa_path_link()
      apparmor: new helper - common_path_perm()
      constify chmod_common/security_path_chmod
      constify security_sb_mount()
      constify chown_common/security_path_chown
      tomoyo: constify assorted struct path *
      apparmor_path_truncate(): path->mnt is never NULL
      constify vfs_truncate()
      constify security_path_truncate()
      [apparmor] constify struct path * in a bunch of helpers

commit a8078b1fc616da6112eb95f0063cd34531d4ccf0
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue May 10 10:23:57 2016 -0600

    block: Update blkdev_dax_capable() for consistency
    
    blkdev_dax_capable() is similar to bdev_dax_supported(), but needs
    to remain as a separate interface for checking dax capability of
    a raw block device.
    
    Rename and relocate blkdev_dax_capable() to keep them maintained
    consistently, and call bdev_direct_access() for the dax capability
    check.
    
    There is no change in the behavior.
    
    Link: https://lkml.org/lkml/2016/5/9/950
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Andreas Dilger <adilger.kernel@dilger.ca>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9f2813090d1b..17f934fcf564 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2319,14 +2319,6 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
-#ifdef CONFIG_FS_DAX
-extern bool blkdev_dax_capable(struct block_device *bdev);
-#else
-static inline bool blkdev_dax_capable(struct block_device *bdev)
-{
-	return false;
-}
-#endif
 
 extern struct super_block *blockdev_superblock;
 

commit 02fbd139759feb1f331cebd858523b5d774082e6
Author: Jan Kara <jack@suse.cz>
Date:   Wed May 11 11:58:48 2016 +0200

    dax: Remove complete_unwritten argument
    
    Fault handlers currently take complete_unwritten argument to convert
    unwritten extents after PTEs are updated. However no filesystem uses
    this anymore as the code is racy. Remove the unused argument.
    
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 70e61b58baaf..9f2813090d1b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -74,7 +74,6 @@ typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
 typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private);
-typedef void (dax_iodone_t)(struct buffer_head *bh_map, int uptodate);
 
 #define MAY_EXEC		0x00000001
 #define MAY_WRITE		0x00000002

commit ae05327a00fd47c34dfe25294b359a3f3fef96e8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 12 20:36:01 2016 -0400

    ext4: switch to ->iterate_shared()
    
    Note that we need relax_dir() equivalent for directories
    locked shared.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3dc0258a2b64..e87245ac6941 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3134,6 +3134,13 @@ static inline bool dir_relax(struct inode *inode)
 	return !IS_DEADDIR(inode);
 }
 
+static inline bool dir_relax_shared(struct inode *inode)
+{
+	inode_unlock_shared(inode);
+	inode_lock_shared(inode);
+	return !IS_DEADDIR(inode);
+}
+
 extern bool path_noexec(const struct path *path);
 extern void inode_nohighmem(struct inode *inode);
 

commit 6192269444ebfbfb42e23c7a6a93c76ffe4b5e51
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 20 23:08:32 2016 -0400

    introduce a parallel variant of ->iterate()
    
    New method: ->iterate_shared().  Same arguments as in ->iterate(),
    called with the directory locked only shared.  Once all filesystems
    switch, the old one will be gone.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3018f31f7aa0..3dc0258a2b64 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1674,6 +1674,7 @@ struct file_operations {
 	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 	int (*iterate) (struct file *, struct dir_context *);
+	int (*iterate_shared) (struct file *, struct dir_context *);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);

commit 9902af79c01a8e39bb99b922fa3eef6d4ea23d69
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 15 15:08:36 2016 -0400

    parallel lookups: actual switch to rwsem
    
    ta-da!
    
    The main issue is the lack of down_write_killable(), so the places
    like readdir.c switched to plain inode_lock(); once killable
    variants of rwsem primitives appear, that'll be dealt with.
    
    lockdep side also might need more work
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 00cecc5a2f75..3018f31f7aa0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -647,7 +647,7 @@ struct inode {
 
 	/* Misc */
 	unsigned long		i_state;
-	struct mutex		i_mutex;
+	struct rw_semaphore	i_rwsem;
 
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
 	unsigned long		dirtied_time_when;
@@ -734,27 +734,42 @@ enum inode_i_mutex_lock_class
 
 static inline void inode_lock(struct inode *inode)
 {
-	mutex_lock(&inode->i_mutex);
+	down_write(&inode->i_rwsem);
 }
 
 static inline void inode_unlock(struct inode *inode)
 {
-	mutex_unlock(&inode->i_mutex);
+	up_write(&inode->i_rwsem);
+}
+
+static inline void inode_lock_shared(struct inode *inode)
+{
+	down_read(&inode->i_rwsem);
+}
+
+static inline void inode_unlock_shared(struct inode *inode)
+{
+	up_read(&inode->i_rwsem);
 }
 
 static inline int inode_trylock(struct inode *inode)
 {
-	return mutex_trylock(&inode->i_mutex);
+	return down_write_trylock(&inode->i_rwsem);
+}
+
+static inline int inode_trylock_shared(struct inode *inode)
+{
+	return down_read_trylock(&inode->i_rwsem);
 }
 
 static inline int inode_is_locked(struct inode *inode)
 {
-	return mutex_is_locked(&inode->i_mutex);
+	return rwsem_is_locked(&inode->i_rwsem);
 }
 
 static inline void inode_lock_nested(struct inode *inode, unsigned subclass)
 {
-	mutex_lock_nested(&inode->i_mutex, subclass);
+	down_write_nested(&inode->i_rwsem, subclass);
 }
 
 void lock_two_nondirectories(struct inode *, struct inode*);

commit 84e710da2a1dfacfc87f604869a4d22df91ce6cd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 15 00:58:55 2016 -0400

    parallel lookups machinery, part 2
    
    We'll need to verify that there's neither a hashed nor in-lookup
    dentry with desired parent/name before adding to in-lookup set.
    
    One possible solution would be to hold the parent's ->d_lock through
    both checks, but while the in-lookup set is relatively small at any
    time, dcache is not.  And holding the parent's ->d_lock through
    something like __d_lookup_rcu() would suck too badly.
    
    So we leave the parent's ->d_lock alone, which means that we watch
    out for the following scenario:
            * we verify that there's no hashed match
            * existing in-lookup match gets hashed by another process
            * we verify that there's no in-lookup matches and decide
    that everything's fine.
    
    Solution: per-directory kinda-sorta seqlock, bumped around the times
    we hash something that used to be in-lookup or move (and hash)
    something in place of in-lookup.  Then the above would turn into
            * read the counter
            * do dcache lookup
            * if no matches found, check for in-lookup matches
            * if there had been none of those either, check if the
    counter has changed; repeat if it has.
    
    The "kinda-sorta" part is due to the fact that we don't have much spare
    space in inode.  There is a spare word (shared with i_bdev/i_cdev/i_pipe),
    so the counter part is not a problem, but spinlock is a different story.
    
    We could use the parent's ->d_lock, and it would be less painful in
    terms of contention, for __d_add() it would be rather inconvenient to
    grab; we could do that (using lock_parent()), but...
    
    Fortunately, we can get serialization on the counter itself, and it
    might be a good idea in general; we can use cmpxchg() in a loop to
    get from even to odd and smp_store_release() from odd to even.
    
    This commit adds the counter and updating logics; the readers will be
    added in the next commit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6d0fa9174a24..00cecc5a2f75 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -684,6 +684,7 @@ struct inode {
 		struct block_device	*i_bdev;
 		struct cdev		*i_cdev;
 		char			*i_link;
+		unsigned		i_dir_seq;
 	};
 
 	__u32			i_generation;

commit 84695ffee7987ee1e581be4c4696e47e1a29403b
Merge: bf1620068911 ce23e6401334
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon May 2 19:45:47 2016 -0400

    Merge getxattr prototype change into work.lookups
    
    The rest of work.xattr stuff isn't needed for this branch

commit e259221763a40403d5bb232209998e8c45804ab8
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 7 08:52:01 2016 -0700

    fs: simplify the generic_write_sync prototype
    
    The kiocb already has the new position, so use that.  The only interesting
    case is AIO, where we currently don't bother updating ki_pos.  We're about
    to free the kiocb after we're done, so we might as well update it to make
    everyone's life simpler.
    
    While we're at it also return the bytes written argument passed in if
    we were successful so that the boilerplate error switch code in the
    callers can go away.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 310ca1ed9293..f6a8ed864651 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2487,13 +2487,25 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
-static inline int generic_write_sync(struct kiocb *iocb, loff_t pos, loff_t count)
-{
-	if (!(iocb->ki_flags & IOCB_DSYNC))
-		return 0;
-	return vfs_fsync_range(iocb->ki_filp, pos, pos + count - 1,
-			       (iocb->ki_flags & IOCB_SYNC) ? 0 : 1);
+
+/*
+ * Sync the bytes written if this was a synchronous write.  Expect ki_pos
+ * to already be updated for the write, and will return either the amount
+ * of bytes passed in, or an error if syncing the file failed.
+ */
+static inline ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)
+{
+	if (iocb->ki_flags & IOCB_DSYNC) {
+		int ret = vfs_fsync_range(iocb->ki_filp,
+				iocb->ki_pos - count, iocb->ki_pos - 1,
+				(iocb->ki_flags & IOCB_SYNC) ? 0 : 1);
+		if (ret)
+			return ret;
+	}
+
+	return count;
 }
+
 extern void emergency_sync(void);
 extern void emergency_remount(void);
 #ifdef CONFIG_BLOCK

commit dde0c2e79848298cc25621ad080d47f94dbd7cce
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 7 08:52:00 2016 -0700

    fs: add IOCB_SYNC and IOCB_DSYNC
    
    This will allow us to do per-I/O sync file writes, as required by a lot
    of fileservers or storage targets.
    
    XXX: Will need a few additional audits for O_DSYNC
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e6b2de159736..310ca1ed9293 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -323,6 +323,8 @@ struct writeback_control;
 #define IOCB_APPEND		(1 << 1)
 #define IOCB_DIRECT		(1 << 2)
 #define IOCB_HIPRI		(1 << 3)
+#define IOCB_DSYNC		(1 << 4)
+#define IOCB_SYNC		(1 << 5)
 
 struct kiocb {
 	struct file		*ki_filp;
@@ -2485,12 +2487,12 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
-static inline int generic_write_sync(struct file *file, loff_t pos, loff_t count)
+static inline int generic_write_sync(struct kiocb *iocb, loff_t pos, loff_t count)
 {
-	if (!(file->f_flags & O_DSYNC) && !IS_SYNC(file->f_mapping->host))
+	if (!(iocb->ki_flags & IOCB_DSYNC))
 		return 0;
-	return vfs_fsync_range(file, pos, pos + count - 1,
-			       (file->f_flags & __O_SYNC) ? 0 : 1);
+	return vfs_fsync_range(iocb->ki_filp, pos, pos + count - 1,
+			       (iocb->ki_flags & IOCB_SYNC) ? 0 : 1);
 }
 extern void emergency_sync(void);
 extern void emergency_remount(void);
@@ -2942,6 +2944,10 @@ static inline int iocb_flags(struct file *file)
 		res |= IOCB_APPEND;
 	if (io_is_direct(file))
 		res |= IOCB_DIRECT;
+	if ((file->f_flags & O_DSYNC) || IS_SYNC(file->f_mapping->host))
+		res |= IOCB_DSYNC;
+	if (file->f_flags & __O_SYNC)
+		res |= IOCB_SYNC;
 	return res;
 }
 

commit c8b8e32d700fe943a935e435ae251364d016c497
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 7 08:51:58 2016 -0700

    direct-io: eliminate the offset argument to ->direct_IO
    
    Including blkdev_direct_IO and dax_do_io.  It has to be ki_pos to actually
    work, so eliminate the superflous argument.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e9eaa2074061..e6b2de159736 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -394,7 +394,7 @@ struct address_space_operations {
 	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 	int (*releasepage) (struct page *, gfp_t);
 	void (*freepage)(struct page *);
-	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter, loff_t offset);
+	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);
 	/*
 	 * migrate the contents of a page to the specified target. If
 	 * migrate_mode is MIGRATE_ASYNC, it must not block.
@@ -2766,18 +2766,17 @@ void dio_end_io(struct bio *bio, int error);
 
 ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
 			     struct block_device *bdev, struct iov_iter *iter,
-			     loff_t offset, get_block_t get_block,
+			     get_block_t get_block,
 			     dio_iodone_t end_io, dio_submit_t submit_io,
 			     int flags);
 
 static inline ssize_t blockdev_direct_IO(struct kiocb *iocb,
 					 struct inode *inode,
-					 struct iov_iter *iter, loff_t offset,
+					 struct iov_iter *iter,
 					 get_block_t get_block)
 {
 	return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,
-				    offset, get_block, NULL, NULL,
-				    DIO_LOCKING | DIO_SKIP_HOLES);
+			get_block, NULL, NULL, DIO_LOCKING | DIO_SKIP_HOLES);
 }
 #endif
 

commit 1af5bb491fbb41c8dab9d728a92758dd6a28afd4
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 7 08:51:56 2016 -0700

    filemap: remove the pos argument to generic_file_direct_write
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 70e61b58baaf..e9eaa2074061 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2703,7 +2703,7 @@ extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
-extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff_t);
+extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 
 ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos);

commit da20dfe6b50ea4c1a82797b7ee8655a370535d73
Author: Kees Cook <keescook@chromium.org>
Date:   Thu Apr 21 12:53:29 2016 -0700

    fs: fix over-zealous use of "const"
    
    When I was fixing up const recommendations from checkpatch.pl, I went
    overboard. This fixes the warning (during a W=1 build):
    
    include/linux/fs.h:2627:74: warning: type qualifiers ignored on function return type [-Wignored-qualifiers]
    static inline const char * const kernel_read_file_id_str(enum kernel_read_file_id id)
    
    Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 90477550b935..9847d5c49a0e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2600,7 +2600,7 @@ static const char * const kernel_read_file_str[] = {
 	__kernel_read_file_id(__fid_stringify)
 };
 
-static inline const char * const kernel_read_file_id_str(enum kernel_read_file_id id)
+static inline const char *kernel_read_file_id_str(enum kernel_read_file_id id)
 {
 	if (id < 0 || id >= READING_MAX_ID)
 		return kernel_read_file_str[READING_UNKNOWN];

commit 1284ab5b2dcb927d38e4f3fbc2e307f3d1af9262
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Apr 20 15:46:27 2016 -0700

    fs: define a string representation of the kernel_read_file_id enumeration
    
    A string representation of the kernel_read_file_id enumeration is
    needed for displaying messages (eg. pr_info, auditing) that can be
    used by multiple LSMs and the integrity subsystem.  To simplify
    keeping the list of strings up to date with the enumeration, this
    patch defines two new preprocessing macros named __fid_enumify and
    __fid_stringify to create the enumeration and an array of strings.
    kernel_read_file_id_str() returns a string based on the enumeration.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    [kees: removed removal of my old version, constified pointer values]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: James Morris <james.l.morris@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a97194b34b..90477550b935 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2580,15 +2580,34 @@ static inline void i_readcount_inc(struct inode *inode)
 #endif
 extern int do_pipe_flags(int *, int);
 
+#define __kernel_read_file_id(id) \
+	id(UNKNOWN, unknown)		\
+	id(FIRMWARE, firmware)		\
+	id(MODULE, kernel-module)		\
+	id(KEXEC_IMAGE, kexec-image)		\
+	id(KEXEC_INITRAMFS, kexec-initramfs)	\
+	id(POLICY, security-policy)		\
+	id(MAX_ID, )
+
+#define __fid_enumify(ENUM, dummy) READING_ ## ENUM,
+#define __fid_stringify(dummy, str) #str,
+
 enum kernel_read_file_id {
-	READING_FIRMWARE = 1,
-	READING_MODULE,
-	READING_KEXEC_IMAGE,
-	READING_KEXEC_INITRAMFS,
-	READING_POLICY,
-	READING_MAX_ID
+	__kernel_read_file_id(__fid_enumify)
+};
+
+static const char * const kernel_read_file_str[] = {
+	__kernel_read_file_id(__fid_stringify)
 };
 
+static inline const char * const kernel_read_file_id_str(enum kernel_read_file_id id)
+{
+	if (id < 0 || id >= READING_MAX_ID)
+		return kernel_read_file_str[READING_UNKNOWN];
+
+	return kernel_read_file_str[id];
+}
+
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
 			    enum kernel_read_file_id);

commit 5614e7725856ea383f458377980298111439e0fb
Merge: 522566376a3f c3b46c73264b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 19 04:28:28 2016 +0900

    Merge 4.6-rc4 into driver-core-next
    
    We want those fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ce23e640133484eebc20ca7b7668388213e11327
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 11 00:48:00 2016 -0400

    ->getxattr(): pass dentry and inode as separate arguments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 329ed372d708..1b5fcaeea827 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1702,7 +1702,8 @@ struct inode_operations {
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
-	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+	ssize_t (*getxattr) (struct dentry *, struct inode *,
+			     const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*removexattr) (struct dentry *, const char *);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,

commit 93061f390f107c37bad7e3bf9eb07bda58a4a99f
Merge: 1c915b3ac4ec c325a67c7290
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 7 17:22:20 2016 -0700

    Merge tag 'ext4_for_linus_stable' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 bugfixes from Ted Ts'o:
     "These changes contains a fix for overlayfs interacting with some
      (badly behaved) dentry code in various file systems.  These have been
      reviewed by Al and the respective file system mtinainers and are going
      through the ext4 tree for convenience.
    
      This also has a few ext4 encryption bug fixes that were discovered in
      Android testing (yes, we will need to get these sync'ed up with the
      fs/crypto code; I'll take care of that).  It also has some bug fixes
      and a change to ignore the legacy quota options to allow for xfstests
      regression testing of ext4's internal quota feature and to be more
      consistent with how xfs handles this case"
    
    * tag 'ext4_for_linus_stable' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4:
      ext4: ignore quota mount options if the quota feature is enabled
      ext4 crypto: fix some error handling
      ext4: avoid calling dquot_get_next_id() if quota is not enabled
      ext4: retry block allocation for failed DIO and DAX writes
      ext4: add lockdep annotations for i_data_sem
      ext4: allow readdir()'s of large empty directories to be interrupted
      btrfs: fix crash/invalid memory access on fsync when using overlayfs
      ext4 crypto: use dget_parent() in ext4_d_revalidate()
      ext4: use file_dentry()
      ext4: use dget_parent() in ext4_file_open()
      nfs: use file_dentry()
      fs: add file_dentry()
      ext4 crypto: don't let data integrity writebacks fail with ENOMEM
      ext4: check if in-inode xattr is corrupted in ext4_expand_extra_isize_ea()

commit 09cbfeaf1a5a67bfb3201e0c83c810cecb2efa5a
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Fri Apr 1 15:29:47 2016 +0300

    mm, fs: get rid of PAGE_CACHE_* and page_cache_{get,release} macros
    
    PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} macros were introduced *long* time
    ago with promise that one day it will be possible to implement page
    cache with bigger chunks than PAGE_SIZE.
    
    This promise never materialized.  And unlikely will.
    
    We have many places where PAGE_CACHE_SIZE assumed to be equal to
    PAGE_SIZE.  And it's constant source of confusion on whether
    PAGE_CACHE_* or PAGE_* constant should be used in a particular case,
    especially on the border between fs and mm.
    
    Global switching to PAGE_CACHE_SIZE != PAGE_SIZE would cause to much
    breakage to be doable.
    
    Let's stop pretending that pages in page cache are special.  They are
    not.
    
    The changes are pretty straight-forward:
    
     - <foo> << (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - <foo> >> (PAGE_CACHE_SHIFT - PAGE_SHIFT) -> <foo>;
    
     - PAGE_CACHE_{SIZE,SHIFT,MASK,ALIGN} -> PAGE_{SIZE,SHIFT,MASK,ALIGN};
    
     - page_cache_get() -> get_page();
    
     - page_cache_release() -> put_page();
    
    This patch contains automated changes generated with coccinelle using
    script below.  For some reason, coccinelle doesn't patch header files.
    I've called spatch for them manually.
    
    The only adjustment after coccinelle is revert of changes to
    PAGE_CAHCE_ALIGN definition: we are going to drop it later.
    
    There are few places in the code where coccinelle didn't reach.  I'll
    fix them manually in a separate patch.  Comments and documentation also
    will be addressed with the separate patch.
    
    virtual patch
    
    @@
    expression E;
    @@
    - E << (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    expression E;
    @@
    - E >> (PAGE_CACHE_SHIFT - PAGE_SHIFT)
    + E
    
    @@
    @@
    - PAGE_CACHE_SHIFT
    + PAGE_SHIFT
    
    @@
    @@
    - PAGE_CACHE_SIZE
    + PAGE_SIZE
    
    @@
    @@
    - PAGE_CACHE_MASK
    + PAGE_MASK
    
    @@
    expression E;
    @@
    - PAGE_CACHE_ALIGN(E)
    + PAGE_ALIGN(E)
    
    @@
    expression E;
    @@
    - page_cache_get(E)
    + get_page(E)
    
    @@
    expression E;
    @@
    - page_cache_release(E)
    + put_page(E)
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a97194b34b..304991a80e23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -929,7 +929,7 @@ static inline struct file *get_file(struct file *f)
 /* Page cache limit. The filesystems should put that into their s_maxbytes 
    limits, otherwise bad things can happen in VM. */ 
 #if BITS_PER_LONG==32
-#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#define MAX_LFS_FILESIZE	(((loff_t)PAGE_SIZE << (BITS_PER_LONG-1))-1)
 #elif BITS_PER_LONG==64
 #define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)
 #endif
@@ -2067,7 +2067,7 @@ extern int generic_update_time(struct inode *, struct timespec *, int);
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 
-#define MAX_RW_COUNT (INT_MAX & PAGE_CACHE_MASK)
+#define MAX_RW_COUNT (INT_MAX & PAGE_MASK)
 
 #ifdef CONFIG_MANDATORY_FILE_LOCKING
 extern int locks_mandatory_locked(struct file *);

commit b8a7a3a6674725d7ca0ff6e322f6c1cab6e6a11d
Author: Andreas Gruenbacher <agruenba@redhat.com>
Date:   Thu Mar 24 14:38:37 2016 +0100

    posix_acl: Inode acl caching fixes
    
    When get_acl() is called for an inode whose ACL is not cached yet, the
    get_acl inode operation is called to fetch the ACL from the filesystem.
    The inode operation is responsible for updating the cached acl with
    set_cached_acl().  This is done without locking at the VFS level, so
    another task can call set_cached_acl() or forget_cached_acl() before the
    get_acl inode operation gets to calling set_cached_acl(), and then
    get_acl's call to set_cached_acl() results in caching an outdate ACL.
    
    Prevent this from happening by setting the cached ACL pointer to a
    task-specific sentinel value before calling the get_acl inode operation.
    Move the responsibility for updating the cached ACL from the get_acl
    inode operations to get_acl().  There, only set the cached ACL if the
    sentinel value hasn't changed.
    
    The sentinel values are chosen to have odd values.  Likewise, the value
    of ACL_NOT_CACHED is odd.  In contrast, ACL object pointers always have
    an even value (ACLs are aligned in memory).  This allows to distinguish
    uncached ACLs values from ACL objects.
    
    In addition, switch from guarding inode->i_acl and inode->i_default_acl
    upates by the inode->i_lock spinlock to using xchg() and cmpxchg().
    
    Filesystems that do not want ACLs returned from their get_acl inode
    operations to be cached must call forget_cached_acl() to prevent the VFS
    from doing so.
    
    (Patch written by Al Viro and Andreas Gruenbacher.)
    
    Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a97194b34b..329ed372d708 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -577,6 +577,18 @@ static inline void mapping_allow_writable(struct address_space *mapping)
 struct posix_acl;
 #define ACL_NOT_CACHED ((void *)(-1))
 
+static inline struct posix_acl *
+uncached_acl_sentinel(struct task_struct *task)
+{
+	return (void *)task + 1;
+}
+
+static inline bool
+is_uncached_acl(struct posix_acl *acl)
+{
+	return (long)acl & 1;
+}
+
 #define IOP_FASTPERM	0x0001
 #define IOP_LOOKUP	0x0002
 #define IOP_NOFOLLOW	0x0004

commit 49db08c358873af11ba3c25401de88156fa5d365
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Feb 19 15:36:07 2016 +0100

    chrdev: emit a warning when we go below dynamic major range
    
    Currently a dynamically allocated character device major is taken
    from 254 and downward. This mechanism is used for RTC, IIO and a
    few other subsystems.
    
    The kernel currently has no check prevening these dynamic
    allocations from eating into the assigned numbers at 233 and
    downward.
    
    In a recent test it was reported that so many dynamic device
    majors were used on a test server, that the major number for
    infiniband (231) was stolen. This occurred when allocating a new
    major number for GPIO chips. The error messages from the kernel
    were not helpful. (See: https://lkml.org/lkml/2016/2/14/124)
    
    This patch adds a defined lower limit of the dynamic major
    allocation region will henceforth emit a warning if we start to
    eat into the assigned numbers. It does not do any semantic
    changes and will not change the kernels behaviour: numbers will
    still continue to be stolen, but we will know from dmesg what
    is going on.
    
    This also updates the Documentation/devices.txt to clearly
    reflect that we are using this range of major numbers for dynamic
    allocation.
    
    Reported-by: Ying Huang <ying.huang@linux.intel.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a97194b34b..60082be96de8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2385,6 +2385,8 @@ static inline void bd_unlink_disk_holder(struct block_device *bdev,
 
 /* fs/char_dev.c */
 #define CHRDEV_MAJOR_HASH_SIZE	255
+/* Marks the bottom of the first segment of free char majors */
+#define CHRDEV_MAJOR_DYN_END 234
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
 extern int __register_chrdev(unsigned int major, unsigned int baseminor,

commit 7df818b2370a9aab5fc58a85b70b8af3d835affa
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 25 14:24:09 2016 -0400

    constify vfs_truncate()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a97194b34b..09a68517e952 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2253,7 +2253,7 @@ struct filename {
 	const char		iname[];
 };
 
-extern long vfs_truncate(struct path *, loff_t);
+extern long vfs_truncate(const struct path *, loff_t);
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
 extern int vfs_fallocate(struct file *file, int mode, loff_t offset,

commit d101a125954eae1d397adda94ca6319485a50493
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sat Mar 26 16:14:37 2016 -0400

    fs: add file_dentry()
    
    This series fixes bugs in nfs and ext4 due to 4bacc9c9234c ("overlayfs:
    Make f_path always point to the overlay and f_inode to the underlay").
    
    Regular files opened on overlayfs will result in the file being opened on
    the underlying filesystem, while f_path points to the overlayfs
    mount/dentry.
    
    This confuses filesystems which get the dentry from struct file and assume
    it's theirs.
    
    Add a new helper, file_dentry() [*], to get the filesystem's own dentry
    from the file.  This checks file->f_path.dentry->d_flags against
    DCACHE_OP_REAL, and returns file->f_path.dentry if DCACHE_OP_REAL is not
    set (this is the common, non-overlayfs case).
    
    In the uncommon case it will call into overlayfs's ->d_real() to get the
    underlying dentry, matching file_inode(file).
    
    The reason we need to check against the inode is that if the file is copied
    up while being open, d_real() would return the upper dentry, while the open
    file comes from the lower dentry.
    
    [*] If possible, it's better simply to use file_inode() instead.
    
    Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Tested-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reviewed-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Cc: <stable@vger.kernel.org> # v4.2
    Cc: David Howells <dhowells@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Daniel Axtens <dja@axtens.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 35d99266ca9a..b2ed2311b021 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1241,6 +1241,16 @@ static inline struct inode *file_inode(const struct file *f)
 	return f->f_inode;
 }
 
+static inline struct dentry *file_dentry(const struct file *file)
+{
+	struct dentry *dentry = file->f_path.dentry;
+
+	if (unlikely(dentry->d_flags & DCACHE_OP_REAL))
+		return dentry->d_op->d_real(dentry, file_inode(file));
+	else
+		return dentry;
+}
+
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
 {
 	return locks_lock_inode_wait(file_inode(filp), fl);

commit 378c6520e7d29280f400ef2ceaf155c86f05a71a
Author: Jann Horn <jann@thejh.net>
Date:   Tue Mar 22 14:25:36 2016 -0700

    fs/coredump: prevent fsuid=0 dumps into user-controlled directories
    
    This commit fixes the following security hole affecting systems where
    all of the following conditions are fulfilled:
    
     - The fs.suid_dumpable sysctl is set to 2.
     - The kernel.core_pattern sysctl's value starts with "/". (Systems
       where kernel.core_pattern starts with "|/" are not affected.)
     - Unprivileged user namespace creation is permitted. (This is
       true on Linux >=3.8, but some distributions disallow it by
       default using a distro patch.)
    
    Under these conditions, if a program executes under secure exec rules,
    causing it to run with the SUID_DUMP_ROOT flag, then unshares its user
    namespace, changes its root directory and crashes, the coredump will be
    written using fsuid=0 and a path derived from kernel.core_pattern - but
    this path is interpreted relative to the root directory of the process,
    allowing the attacker to control where a coredump will be written with
    root privileges.
    
    To fix the security issue, always interpret core_pattern for dumps that
    are written under SUID_DUMP_ROOT relative to the root directory of init.
    
    Signed-off-by: Jann Horn <jann@thejh.net>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 35d99266ca9a..14a97194b34b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2263,7 +2263,7 @@ extern long do_sys_open(int dfd, const char __user *filename, int flags,
 extern struct file *file_open_name(struct filename *, int, umode_t);
 extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
-				   const char *, int);
+				   const char *, int, umode_t);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 

commit 53d2e6976bd4042672ed7b90dfbf4b31635b7dcf
Merge: d407574e7948 2cdb958aba6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 21 11:53:05 2016 -0700

    Merge tag 'xfs-for-linus-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs
    
    Pull xfs updates from Dave Chinner:
     "There's quite a lot in this request, and there's some cross-over with
      ext4, dax and quota code due to the nature of the changes being made.
    
      As for the rest of the XFS changes, there are lots of little things
      all over the place, which add up to a lot of changes in the end.
    
      The major changes are that we've reduced the size of the struct
      xfs_inode by ~100 bytes (gives an inode cache footprint reduction of
      >10%), the writepage code now only does a single set of mapping tree
      lockups so uses less CPU, delayed allocation reservations won't
      overrun under random write loads anymore, and we added compile time
      verification for on-disk structure sizes so we find out when a commit
      or platform/compiler change breaks the on disk structure as early as
      possible.
    
      Change summary:
    
       - error propagation for direct IO failures fixes for both XFS and
         ext4
       - new quota interfaces and XFS implementation for iterating all the
         quota IDs in the filesystem
       - locking fixes for real-time device extent allocation
       - reduction of duplicate information in the xfs and vfs inode, saving
         roughly 100 bytes of memory per cached inode.
       - buffer flag cleanup
       - rework of the writepage code to use the generic write clustering
         mechanisms
       - several fixes for inode flag based DAX enablement
       - rework of remount option parsing
       - compile time verification of on-disk format structure sizes
       - delayed allocation reservation overrun fixes
       - lots of little error handling fixes
       - small memory leak fixes
       - enable xfsaild freezing again"
    
    * tag 'xfs-for-linus-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs: (66 commits)
      xfs: always set rvalp in xfs_dir2_node_trim_free
      xfs: ensure committed is initialized in xfs_trans_roll
      xfs: borrow indirect blocks from freed extent when available
      xfs: refactor delalloc indlen reservation split into helper
      xfs: update freeblocks counter after extent deletion
      xfs: debug mode forced buffered write failure
      xfs: remove impossible condition
      xfs: check sizes of XFS on-disk structures at compile time
      xfs: ioends require logically contiguous file offsets
      xfs: use named array initializers for log item dumping
      xfs: fix computation of inode btree maxlevels
      xfs: reinitialise per-AG structures if geometry changes during recovery
      xfs: remove xfs_trans_get_block_res
      xfs: fix up inode32/64 (re)mount handling
      xfs: fix format specifier , should be %llx and not %llu
      xfs: sanitize remount options
      xfs: convert mount option parsing to tokens
      xfs: fix two memory leaks in xfs_attr_list.c error paths
      xfs: XFS_DIFLAG2_DAX limited by PAGE_SIZE
      xfs: dynamically switch modes when XFS_DIFLAG2_DAX is set/cleared
      ...

commit d407574e7948210223a7adca5ff26e3b0ec8143e
Merge: 5518f66b5a64 12bb0a8fd47e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 21 11:03:02 2016 -0700

    Merge tag 'for-f2fs-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs
    
    Pull f2fs updates from Jaegeuk Kim:
     "New Features:
       - uplift filesystem encryption into fs/crypto/
       - give sysfs entries to control memroy consumption
    
      Enhancements:
       - aio performance by preallocating blocks in ->write_iter
       - use writepages lock for only WB_SYNC_ALL
       - avoid redundant inline_data conversion
       - enhance forground GC
       - use wait_for_stable_page as possible
       - speed up SEEK_DATA and fiiemap
    
      Bug Fixes:
       - corner case in terms of -ENOSPC for inline_data
       - hung task caused by long latency in shrinker
       - corruption between atomic write and f2fs_trace_pid
       - avoid garbage lengths in dentries
       - revoke atomicly written pages if an error occurs
    
      In addition, there are various minor bug fixes and clean-ups"
    
    * tag 'for-f2fs-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/jaegeuk/f2fs: (81 commits)
      f2fs: submit node page write bios when really required
      f2fs: add missing argument to f2fs_setxattr stub
      f2fs: fix to avoid unneeded unlock_new_inode
      f2fs: clean up opened code with f2fs_update_dentry
      f2fs: declare static functions
      f2fs: use cryptoapi crc32 functions
      f2fs: modify the readahead method in ra_node_page()
      f2fs crypto: sync ext4_lookup and ext4_file_open
      fs crypto: move per-file encryption from f2fs tree to fs/crypto
      f2fs: mutex can't be used by down_write_nest_lock()
      f2fs: recovery missing dot dentries in root directory
      f2fs: fix to avoid deadlock when merging inline data
      f2fs: introduce f2fs_flush_merged_bios for cleanup
      f2fs: introduce f2fs_update_data_blkaddr for cleanup
      f2fs crypto: fix incorrect positioning for GCing encrypted data page
      f2fs: fix incorrect upper bound when iterating inode mapping tree
      f2fs: avoid hungtask problem caused by losing wake_up
      f2fs: trace old block address for CoWed page
      f2fs: try to flush inode after merging inline data
      f2fs: show more info about superblock recovery
      ...

commit 3c2de27d793bf55167804fc47954711e94f27be7
Merge: 51b3eae8dbe5 8b23a8ce1094
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 18:52:29 2016 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
    
     - Preparations of parallel lookups (the remaining main obstacle is the
       need to move security_d_instantiate(); once that becomes safe, the
       rest will be a matter of rather short series local to fs/*.c
    
     - preadv2/pwritev2 series from Christoph
    
     - assorted fixes
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (32 commits)
      splice: handle zero nr_pages in splice_to_pipe()
      vfs: show_vfsstat: do not ignore errors from show_devname method
      dcache.c: new helper: __d_add()
      don't bother with __d_instantiate(dentry, NULL)
      untangle fsnotify_d_instantiate() a bit
      uninline d_add()
      replace d_add_unique() with saner primitive
      quota: use lookup_one_len_unlocked()
      cifs_get_root(): use lookup_one_len_unlocked()
      nfs_lookup: don't bother with d_instantiate(dentry, NULL)
      kill dentry_unhash()
      ceph_fill_trace(): don't bother with d_instantiate(dn, NULL)
      autofs4: don't bother with d_instantiate(dentry, NULL) in ->lookup()
      configfs: move d_rehash() into configfs_create() for regular files
      ceph: don't bother with d_rehash() in splice_dentry()
      namei: teach lookup_slow() to skip revalidate
      namei: massage lookup_slow() to be usable by lookup_one_len_unlocked()
      lookup_one_len_unlocked(): use lookup_dcache()
      namei: simplify invalidation logics in lookup_dcache()
      namei: change calling conventions for lookup_{fast,slow} and follow_managed()
      ...

commit 8b23a8ce1094f25a85826e25217c5b9779a4f5aa
Merge: f93812846f31 ed782b5a70a0 d6785d915214 8e0b60b96ba0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 18 16:07:38 2016 -0400

    Merge branches 'work.lookups', 'work.misc' and 'work.preadv2' into for-next

commit 0b81d0779072696371822e5ed9e7c6292e547024
Author: Jaegeuk Kim <jaegeuk@kernel.org>
Date:   Fri May 15 16:26:10 2015 -0700

    fs crypto: move per-file encryption from f2fs tree to fs/crypto
    
    This patch adds the renamed functions moved from the f2fs crypto files.
    
    1. definitions for per-file encryption used by ext4 and f2fs.
    
    2. crypto.c for encrypt/decrypt functions
     a. IO preparation:
      - fscrypt_get_ctx / fscrypt_release_ctx
     b. before IOs:
      - fscrypt_encrypt_page
      - fscrypt_decrypt_page
      - fscrypt_zeroout_range
     c. after IOs:
      - fscrypt_decrypt_bio_pages
      - fscrypt_pullback_bio_page
      - fscrypt_restore_control_page
    
    3. policy.c supporting context management.
     a. For ioctls:
      - fscrypt_process_policy
      - fscrypt_get_policy
     b. For context permission
      - fscrypt_has_permitted_context
      - fscrypt_inherit_context
    
    4. keyinfo.c to handle permissions
      - fscrypt_get_encryption_info
      - fscrypt_free_encryption_info
    
    5. fname.c to support filename encryption
     a. general wrapper functions
      - fscrypt_fname_disk_to_usr
      - fscrypt_fname_usr_to_disk
      - fscrypt_setup_filename
      - fscrypt_free_filename
    
     b. specific filename handling functions
      - fscrypt_fname_alloc_buffer
      - fscrypt_fname_free_buffer
    
    6. Makefile and Kconfig
    
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Signed-off-by: Michael Halcrow <mhalcrow@google.com>
    Signed-off-by: Ildar Muslukhov <ildarm@google.com>
    Signed-off-by: Uday Savagaonkar <savagaon@google.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jaegeuk Kim <jaegeuk@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ae681002100a..28fc12189997 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -53,6 +53,8 @@ struct swap_info_struct;
 struct seq_file;
 struct workqueue_struct;
 struct iov_iter;
+struct fscrypt_info;
+struct fscrypt_operations;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -678,6 +680,10 @@ struct inode {
 	struct hlist_head	i_fsnotify_marks;
 #endif
 
+#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
+	struct fscrypt_info	*i_crypt_info;
+#endif
+
 	void			*i_private; /* fs or device private pointer */
 };
 
@@ -1323,6 +1329,8 @@ struct super_block {
 #endif
 	const struct xattr_handler **s_xattr;
 
+	const struct fscrypt_operations	*s_cop;
+
 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	struct block_device	*s_bdev;

commit 9d95afd5971918b1aa8db1960ba24532c2d6ec89
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 1 15:35:06 2016 -0500

    kill dentry_unhash()
    
    the last user is gone
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ae681002100a..c577923cd400 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1539,11 +1539,6 @@ extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
 extern int vfs_whiteout(struct inode *, struct dentry *);
 
-/*
- * VFS dentry helper functions.
- */
-extern void dentry_unhash(struct dentry *dentry);
-
 /*
  * VFS file helper functions.
  */

commit 97be7ebe53915af504fb491fb99f064c7cf3cb09
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Mar 3 16:04:01 2016 +0100

    vfs: add the RWF_HIPRI flag for preadv2/pwritev2
    
    This adds a flag that tells the file system that this is a high priority
    request for which it's worth to poll the hardware.  The flag is purely
    advisory and can be ignored if not supported.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Stephen Bates <stephen.bates@pmcs.com>
    Tested-by: Stephen Bates <stephen.bates@pmcs.com>
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6ec87964644f..337de88ff50f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -320,6 +320,7 @@ struct writeback_control;
 #define IOCB_EVENTFD		(1 << 0)
 #define IOCB_APPEND		(1 << 1)
 #define IOCB_DIRECT		(1 << 2)
+#define IOCB_HIPRI		(1 << 3)
 
 struct kiocb {
 	struct file		*ki_filp;

commit 793b80ef14af56d20c998265287648ad34239b6f
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Mar 3 16:03:58 2016 +0100

    vfs: pass a flags argument to vfs_readv/vfs_writev
    
    This way we can set kiocb flags also from the sync read/write path for
    the read_iter/write_iter operations.  For now there is no way to pass
    flags to plain read/write operations as there is no real need for that,
    and all flags passed are explicitly rejected for these files.
    
    Signed-off-by: Milosz Tanski <milosz@adfin.com>
    [hch: rebased on top of my kiocb changes]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Stephen Bates <stephen.bates@pmcs.com>
    Tested-by: Stephen Bates <stephen.bates@pmcs.com>
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1a2046275cdf..6ec87964644f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1712,9 +1712,9 @@ extern ssize_t __vfs_write(struct file *, const char __user *, size_t, loff_t *)
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *);
+		unsigned long, loff_t *, int);
 extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
-		unsigned long, loff_t *);
+		unsigned long, loff_t *, int);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,

commit 7429b092811fb20c6a5b261c2c116a6a90cb9a29
Author: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
Date:   Fri Apr 11 17:47:01 2014 +0300

    ima: load policy using path
    
    We currently cannot do appraisal or signature vetting of IMA policies
    since we currently can only load IMA policies by writing the contents
    of the policy directly in, as follows:
    
    cat policy-file > <securityfs>/ima/policy
    
    If we provide the kernel the path to the IMA policy so it can load
    the policy itself it'd be able to later appraise or vet the file
    signature if it has one.  This patch adds support to load the IMA
    policy with a given path as follows:
    
    echo /etc/ima/ima_policy > /sys/kernel/security/ima/policy
    
    Changelog v4+:
    - moved kernel_read_file_from_path() error messages to callers
    v3:
    - moved kernel_read_file_from_path() to a separate patch
    v2:
    - after re-ordering the patches, replace calling integrity_kernel_read()
      to read the file with kernel_read_file_from_path() (Mimi)
    - Patch description re-written by Luis R. Rodriguez
    
    Signed-off-by: Dmitry Kasatkin <dmitry.kasatkin@huawei.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 52567252288e..e514f76db04f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2581,6 +2581,7 @@ enum kernel_read_file_id {
 	READING_MODULE,
 	READING_KEXEC_IMAGE,
 	READING_KEXEC_INITRAMFS,
+	READING_POLICY,
 	READING_MAX_ID
 };
 

commit b804defe4297157a9ff45863769efe9a01953398
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Jan 14 20:59:14 2016 -0500

    kexec: replace call to copy_file_from_fd() with kernel version
    
    Replace copy_file_from_fd() with kernel_read_file_from_fd().
    
    Two new identifiers named READING_KEXEC_IMAGE and READING_KEXEC_INITRAMFS
    are defined for measuring, appraising or auditing the kexec image and
    initramfs.
    
    Changelog v3:
    - return -EBADF, not -ENOEXEC
    - identifier change
    - split patch, moving copy_file_from_fd() to a separate patch
    - split patch, moving IMA changes to a separate patch
    v0:
    - use kstat file size type loff_t, not size_t
    - Calculate the file hash from the in memory buffer - Dave Young
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Acked-by: Dave Young <dyoung@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fb08b668c37a..52567252288e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2579,6 +2579,8 @@ extern int do_pipe_flags(int *, int);
 enum kernel_read_file_id {
 	READING_FIRMWARE = 1,
 	READING_MODULE,
+	READING_KEXEC_IMAGE,
+	READING_KEXEC_INITRAMFS,
 	READING_MAX_ID
 };
 

commit a1db74209483a24c861c848b4bb79a4d945ef6fa
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Dec 30 07:35:30 2015 -0500

    module: replace copy_module_from_fd with kernel version
    
    Replace copy_module_from_fd() with kernel_read_file_from_fd().
    
    Although none of the upstreamed LSMs define a kernel_module_from_file
    hook, IMA is called, based on policy, to prevent unsigned kernel modules
    from being loaded by the original kernel module syscall and to
    measure/appraise signed kernel modules.
    
    The security function security_kernel_module_from_file() was called prior
    to reading a kernel module.  Preventing unsigned kernel modules from being
    loaded by the original kernel module syscall remains on the pre-read
    kernel_read_file() security hook.  Instead of reading the kernel module
    twice, once for measuring/appraising and again for loading the kernel
    module, the signature validation is moved to the kernel_post_read_file()
    security hook.
    
    This patch removes the security_kernel_module_from_file() hook and security
    call.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9c85deae1bf2..fb08b668c37a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2578,6 +2578,7 @@ extern int do_pipe_flags(int *, int);
 
 enum kernel_read_file_id {
 	READING_FIRMWARE = 1,
+	READING_MODULE,
 	READING_MAX_ID
 };
 

commit b844f0ecbc5626ec26cfc70cb144a4c9b85dc3f2
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Feb 1 08:36:21 2016 -0500

    vfs: define kernel_copy_file_from_fd()
    
    This patch defines kernel_read_file_from_fd(), a wrapper for the VFS
    common kernel_read_file().
    
    Changelog:
    - Separated from the kernel modules patch
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c8bc4d8c843f..9c85deae1bf2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2586,6 +2586,8 @@ extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
 			    enum kernel_read_file_id);
 extern int kernel_read_file_from_path(char *, void **, loff_t *, loff_t,
 				      enum kernel_read_file_id);
+extern int kernel_read_file_from_fd(int, void **, loff_t *, loff_t,
+				    enum kernel_read_file_id);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);

commit e40ba6d56b41754b37b995dbc8035b2b3a6afd8a
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Nov 19 12:39:22 2015 -0500

    firmware: replace call to fw_read_file_contents() with kernel version
    
    Replace the fw_read_file_contents with kernel_file_read_from_path().
    
    Although none of the upstreamed LSMs define a kernel_fw_from_file hook,
    IMA is called by the security function to prevent unsigned firmware from
    being loaded and to measure/appraise signed firmware, based on policy.
    
    Instead of reading the firmware twice, once for measuring/appraising the
    firmware and again for reading the firmware contents into memory, the
    kernel_post_read_file() security hook calculates the file hash based on
    the in memory file buffer.  The firmware is read once.
    
    This patch removes the LSM kernel_fw_from_file() hook and security call.
    
    Changelog v4+:
    - revert dropped buf->size assignment - reported by Sergey Senozhatsky
    v3:
    - remove kernel_fw_from_file hook
    - use kernel_file_read_from_path() - requested by Luis
    v2:
    - reordered and squashed firmware patches
    - fix MAX firmware size (Kees Cook)
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 00fa5c45fd63..c8bc4d8c843f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2577,6 +2577,7 @@ static inline void i_readcount_inc(struct inode *inode)
 extern int do_pipe_flags(int *, int);
 
 enum kernel_read_file_id {
+	READING_FIRMWARE = 1,
 	READING_MAX_ID
 };
 

commit 09596b94f7d28595602482e69ed954deab707437
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Thu Nov 19 12:39:22 2015 -0500

    vfs: define kernel_read_file_from_path
    
    This patch defines kernel_read_file_from_path(), a wrapper for the VFS
    common kernel_read_file().
    
    Changelog:
    - revert error msg regression - reported by Sergey Senozhatsky
    - Separated from the IMA patch
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa84bcb9c368..00fa5c45fd63 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2583,6 +2583,8 @@ enum kernel_read_file_id {
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
 			    enum kernel_read_file_id);
+extern int kernel_read_file_from_path(char *, void **, loff_t *, loff_t,
+				      enum kernel_read_file_id);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);

commit bc8ca5b92d54f6f005fa73ad546f02fca26ddd85
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Sun Jan 24 10:07:32 2016 -0500

    vfs: define kernel_read_file_id enumeration
    
    To differentiate between the kernel_read_file() callers, this patch
    defines a new enumeration named kernel_read_file_id and includes the
    caller identifier as an argument.
    
    Subsequent patches define READING_KEXEC_IMAGE, READING_KEXEC_INITRAMFS,
    READING_FIRMWARE, READING_MODULE, and READING_POLICY.
    
    Changelog v3:
    - Replace the IMA specific enumeration with a generic one.
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Acked-by: Luis R. Rodriguez <mcgrof@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9a83d82b61ac..aa84bcb9c368 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2576,8 +2576,13 @@ static inline void i_readcount_inc(struct inode *inode)
 #endif
 extern int do_pipe_flags(int *, int);
 
+enum kernel_read_file_id {
+	READING_MAX_ID
+};
+
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
-extern int kernel_read_file(struct file *, void **, loff_t *, loff_t);
+extern int kernel_read_file(struct file *, void **, loff_t *, loff_t,
+			    enum kernel_read_file_id);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);

commit b44a7dfc6fa16e01f2497c9fa62c3926f94be174
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Dec 28 16:02:29 2015 -0500

    vfs: define a generic function to read a file from the kernel
    
    For a while it was looked down upon to directly read files from Linux.
    These days there exists a few mechanisms in the kernel that do just
    this though to load a file into a local buffer.  There are minor but
    important checks differences on each.  This patch set is the first
    attempt at resolving some of these differences.
    
    This patch introduces a common function for reading files from the kernel
    with the corresponding security post-read hook and function.
    
    Changelog v4+:
    - export security_kernel_post_read_file() - Fengguang Wu
    v3:
    - additional bounds checking - Luis
    v2:
    - To simplify patch review, re-ordered patches
    
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Reviewed-by: Luis R. Rodriguez <mcgrof@suse.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ae681002100a..9a83d82b61ac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2577,6 +2577,7 @@ static inline void i_readcount_inc(struct inode *inode)
 extern int do_pipe_flags(int *, int);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
+extern int kernel_read_file(struct file *, void **, loff_t *, loff_t);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);

commit 187372a3b9faff68ed61c291d0135e6739e0dbdf
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Feb 8 14:40:51 2016 +1100

    direct-io: always call ->end_io if non-NULL
    
    This way we can pass back errors to the file system, and allow for
    cleanup required for all direct I/O invocations.
    
    Also allow the ->end_io handlers to return errors on their own, so that
    I/O completion errors can be passed on to the callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1a2046275cdf..d7f37bfcbdce 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -70,7 +70,7 @@ extern int sysctl_protected_hardlinks;
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
-typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
+typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private);
 typedef void (dax_iodone_t)(struct buffer_head *bh_map, int uptodate);
 

commit 9f4736fe7ca804aa79b5916221bb13dfc6221a0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jan 28 20:13:39 2016 -0800

    block: revert runtime dax control of the raw block device
    
    Dynamically enabling DAX requires that the page cache first be flushed
    and invalidated.  This must occur atomically with the change of DAX mode
    otherwise we confuse the fsync/msync tracking and violate data
    durability guarantees.  Eliminate the possibilty of DAX-disabled to
    DAX-enabled transitions for now and revisit this for the next cycle.
    
    Cc: Jan Kara <jack@suse.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b10002d4a5f5..ae681002100a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -484,9 +484,6 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
-#ifdef CONFIG_FS_DAX
-	int			bd_map_count;
-#endif
 };
 
 /*

commit 65f87ee71852a754f7981d0653e7136039b8798a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jan 25 17:23:18 2016 -0800

    fs, block: force direct-I/O for dax-enabled block devices
    
    Similar to the file I/O path, re-direct all I/O to the DAX path for I/O
    to a block-device special file.  Both regular files and device special
    files can use the common filp->f_mapping->host lookup to determing is
    DAX is enabled.
    
    Otherwise, we confuse the DAX code that does not expect to find live
    data in the page cache:
    
        ------------[ cut here ]------------
        WARNING: CPU: 0 PID: 7676 at mm/filemap.c:217
        __delete_from_page_cache+0x9f6/0xb60()
        Modules linked in:
        CPU: 0 PID: 7676 Comm: a.out Not tainted 4.4.0+ #276
        Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
         00000000ffffffff ffff88006d3f7738 ffffffff82999e2d 0000000000000000
         ffff8800620a0000 ffffffff86473d20 ffff88006d3f7778 ffffffff81352089
         ffffffff81658d36 ffffffff86473d20 00000000000000d9 ffffea0000009d60
        Call Trace:
         [<     inline     >] __dump_stack lib/dump_stack.c:15
         [<ffffffff82999e2d>] dump_stack+0x6f/0xa2 lib/dump_stack.c:50
         [<ffffffff81352089>] warn_slowpath_common+0xd9/0x140 kernel/panic.c:482
         [<ffffffff813522b9>] warn_slowpath_null+0x29/0x30 kernel/panic.c:515
         [<ffffffff81658d36>] __delete_from_page_cache+0x9f6/0xb60 mm/filemap.c:217
         [<ffffffff81658fb2>] delete_from_page_cache+0x112/0x200 mm/filemap.c:244
         [<ffffffff818af369>] __dax_fault+0x859/0x1800 fs/dax.c:487
         [<ffffffff8186f4f6>] blkdev_dax_fault+0x26/0x30 fs/block_dev.c:1730
         [<     inline     >] wp_pfn_shared mm/memory.c:2208
         [<ffffffff816e9145>] do_wp_page+0xc85/0x14f0 mm/memory.c:2307
         [<     inline     >] handle_pte_fault mm/memory.c:3323
         [<     inline     >] __handle_mm_fault mm/memory.c:3417
         [<ffffffff816ecec3>] handle_mm_fault+0x2483/0x4640 mm/memory.c:3446
         [<ffffffff8127eff6>] __do_page_fault+0x376/0x960 arch/x86/mm/fault.c:1238
         [<ffffffff8127f738>] trace_do_page_fault+0xe8/0x420 arch/x86/mm/fault.c:1331
         [<ffffffff812705c4>] do_async_page_fault+0x14/0xd0 arch/x86/kernel/kvm.c:264
         [<ffffffff86338f78>] async_page_fault+0x28/0x30 arch/x86/entry/entry_64.S:986
         [<ffffffff86336c36>] entry_SYSCALL_64_fastpath+0x16/0x7a
        arch/x86/entry/entry_64.S:185
        ---[ end trace dae21e0f85f1f98c ]---
    
    Fixes: 5a023cdba50c ("block: enable dax for raw block devices")
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Reported-by: Kirill A. Shutemov <kirill@shutemov.name>
    Suggested-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Suggested-by: Matthew Wilcox <willy@linux.intel.com>
    Tested-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1a2046275cdf..b10002d4a5f5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2907,7 +2907,7 @@ extern void replace_mount_options(struct super_block *sb, char *options);
 
 static inline bool io_is_direct(struct file *filp)
 {
-	return (filp->f_flags & O_DIRECT) || IS_DAX(file_inode(filp));
+	return (filp->f_flags & O_DIRECT) || IS_DAX(filp->f_mapping->host);
 }
 
 static inline int iocb_flags(struct file *file)

commit cc673757e24d018d64ff8038e28835db1e2902c4
Merge: fa7d9a1d286e e62e560fc8b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 23 12:24:56 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull final vfs updates from Al Viro:
    
     - The ->i_mutex wrappers (with small prereq in lustre)
    
     - a fix for too early freeing of symlink bodies on shmem (they need to
       be RCU-delayed) (-stable fodder)
    
     - followup to dedupe stuff merged this cycle
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: abort dedupe loop if fatal signals are pending
      make sure that freeing shmem fast symlinks is RCU-delayed
      wrappers for ->i_mutex access
      lustre: remove unused declaration

commit f9fe48bece3af2d60e1bad65db4825f5a025dd36
Author: Ross Zwisler <ross.zwisler@linux.intel.com>
Date:   Fri Jan 22 15:10:40 2016 -0800

    dax: support dirty DAX entries in radix tree
    
    Add support for tracking dirty DAX entries in the struct address_space
    radix tree.  This tree is already used for dirty page writeback, and it
    already supports the use of exceptional (non struct page*) entries.
    
    In order to properly track dirty DAX pages we will insert new
    exceptional entries into the radix tree that represent dirty DAX PTE or
    PMD pages.  These exceptional entries will also contain the writeback
    addresses for the PTE or PMD faults that we can use at fsync/msync time.
    
    There are currently two types of exceptional entries (shmem and shadow)
    that can be placed into the radix tree, and this adds a third.  We rely
    on the fact that only one type of exceptional entry can be found in a
    given radix tree based on its usage.  This happens for free with DAX vs
    shmem but we explicitly prevent shadow entries from being added to radix
    trees for DAX mappings.
    
    The only shadow entries that would be generated for DAX radix trees
    would be to track zero page mappings that were created for holes.  These
    pages would receive minimal benefit from having shadow entries, and the
    choice to have only one type of exceptional entry in a given radix tree
    makes the logic simpler both in clear_exceptional_entry() and in the
    rest of DAX.
    
    Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Andreas Dilger <adilger.kernel@dilger.ca>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Jan Kara <jack@suse.com>
    Cc: Jeff Layton <jlayton@poochiereds.net>
    Cc: Matthew Wilcox <willy@linux.intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Cc: Dave Hansen <dave.hansen@linux.intel.com>
    Cc: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eb73d74ed992..0d7570320d63 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -433,7 +433,8 @@ struct address_space {
 	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
 	/* Protected by tree_lock together with the radix tree */
 	unsigned long		nrpages;	/* number of total pages */
-	unsigned long		nrshadows;	/* number of shadow entries */
+	/* number of shadow or DAX exceptional entries */
+	unsigned long		nrexceptional;
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */
 	unsigned long		flags;		/* error bits/gfp mask */

commit 5955102c9984fa081b2d570cfac75c97eecf8f3b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 22 15:40:57 2016 -0500

    wrappers for ->i_mutex access
    
    parallel to mutex_{lock,unlock,trylock,is_locked,lock_nested},
    inode_foo(inode) being mutex_foo(&inode->i_mutex).
    
    Please, use those for access to ->i_mutex; over the coming cycle
    ->i_mutex will become rwsem, with ->lookup() done with it held
    only shared.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eb73d74ed992..2df6c033c3f5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -714,6 +714,31 @@ enum inode_i_mutex_lock_class
 	I_MUTEX_PARENT2,
 };
 
+static inline void inode_lock(struct inode *inode)
+{
+	mutex_lock(&inode->i_mutex);
+}
+
+static inline void inode_unlock(struct inode *inode)
+{
+	mutex_unlock(&inode->i_mutex);
+}
+
+static inline int inode_trylock(struct inode *inode)
+{
+	return mutex_trylock(&inode->i_mutex);
+}
+
+static inline int inode_is_locked(struct inode *inode)
+{
+	return mutex_is_locked(&inode->i_mutex);
+}
+
+static inline void inode_lock_nested(struct inode *inode, unsigned subclass)
+{
+	mutex_lock_nested(&inode->i_mutex, subclass);
+}
+
 void lock_two_nondirectories(struct inode *, struct inode*);
 void unlock_two_nondirectories(struct inode *, struct inode*);
 
@@ -3047,8 +3072,8 @@ static inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)
 }
 static inline bool dir_relax(struct inode *inode)
 {
-	mutex_unlock(&inode->i_mutex);
-	mutex_lock(&inode->i_mutex);
+	inode_unlock(inode);
+	inode_lock(inode);
 	return !IS_DEADDIR(inode);
 }
 

commit d080827f850ba4df5b955d5ca8c8c0fc92fe18c0
Merge: cbd88cd4c07f 8b63b6bfc1a5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 13 19:15:14 2016 -0800

    Merge tag 'libnvdimm-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "The bulk of this has appeared in -next and independently received a
      build success notification from the kbuild robot.  The 'for-4.5/block-
      dax' topic branch was rebased over the weekend to drop the "block
      device end-of-life" rework that Al would like to see re-implemented
      with a notifier, and to address bug reports against the badblocks
      integration.
    
      There is pending feedback against "libnvdimm: Add a poison list and
      export badblocks" received last week.  Linda identified some localized
      fixups that we will handle incrementally.
    
      Summary:
    
       - Media error handling: The 'badblocks' implementation that
         originated in md-raid is up-levelled to a generic capability of a
         block device.  This initial implementation is limited to being
         consulted in the pmem block-i/o path.  Later, 'badblocks' will be
         consulted when creating dax mappings.
    
       - Raw block device dax: For virtualization and other cases that want
         large contiguous mappings of persistent memory, add the capability
         to dax-mmap a block device directly.
    
       - Increased /dev/mem restrictions: Add an option to treat all
         io-memory as IORESOURCE_EXCLUSIVE, i.e. disable /dev/mem access
         while a driver is actively using an address range.  This behavior
         is controlled via the new CONFIG_IO_STRICT_DEVMEM option and can be
         overridden by the existing "iomem=relaxed" kernel command line
         option.
    
       - Miscellaneous fixes include a 'pfn'-device huge page alignment fix,
         block device shutdown crash fix, and other small libnvdimm fixes"
    
    * tag 'libnvdimm-for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (32 commits)
      block: kill disk_{check|set|clear|alloc}_badblocks
      libnvdimm, pmem: nvdimm_read_bytes() badblocks support
      pmem, dax: disable dax in the presence of bad blocks
      pmem: fail io-requests to known bad blocks
      libnvdimm: convert to statically allocated badblocks
      libnvdimm: don't fail init for full badblocks list
      block, badblocks: introduce devm_init_badblocks
      block: clarify badblocks lifetime
      badblocks: rename badblocks_free to badblocks_exit
      libnvdimm, pmem: move definition of nvdimm_namespace_add_poison to nd.h
      libnvdimm: Add a poison list and export badblocks
      nfit_test: Enable DSMs for all test NFITs
      md: convert to use the generic badblocks code
      block: Add badblock management for gendisks
      badblocks: Add core badblock management code
      block: fix del_gendisk() vs blkdev_ioctl crash
      block: enable dax for raw block devices
      block: introduce bdev_file_inode()
      restrict /dev/mem to idle io memory ranges
      arch: consolidate CONFIG_STRICT_DEVM in lib/Kconfig.debug
      ...

commit 33caf82acf4dc420bf0f0136b886f7b27ecf90c5
Merge: ca9706a28294 bbddca8e8fac
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 17:11:47 2016 -0800

    Merge branch 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull misc vfs updates from Al Viro:
     "All kinds of stuff.  That probably should've been 5 or 6 separate
      branches, but by the time I'd realized how large and mixed that bag
      had become it had been too close to -final to play with rebasing.
    
      Some fs/namei.c cleanups there, memdup_user_nul() introduction and
      switching open-coded instances, burying long-dead code, whack-a-mole
      of various kinds, several new helpers for ->llseek(), assorted
      cleanups and fixes from various people, etc.
    
      One piece probably deserves special mention - Neil's
      lookup_one_len_unlocked().  Similar to lookup_one_len(), but gets
      called without ->i_mutex and tries to avoid ever taking it.  That, of
      course, means that it's not useful for any directory modifications,
      but things like getting inode attributes in nfds readdirplus are fine
      with that.  I really should've asked for moratorium on lookup-related
      changes this cycle, but since I hadn't done that early enough...  I
      *am* asking for that for the coming cycle, though - I'm going to try
      and get conversion of i_mutex to rwsem with ->lookup() done under lock
      taken shared.
    
      There will be a patch closer to the end of the window, along the lines
      of the one Linus had posted last May - mechanical conversion of
      ->i_mutex accesses to inode_lock()/inode_unlock()/inode_trylock()/
      inode_is_locked()/inode_lock_nested().  To quote Linus back then:
    
        -----
        |    This is an automated patch using
        |
        |        sed 's/mutex_lock(&\(.*\)->i_mutex)/inode_lock(\1)/'
        |        sed 's/mutex_unlock(&\(.*\)->i_mutex)/inode_unlock(\1)/'
        |        sed 's/mutex_lock_nested(&\(.*\)->i_mutex,[     ]*I_MUTEX_\([A-Z0-9_]*\))/inode_lock_nested(\1, I_MUTEX_\2)/'
        |        sed 's/mutex_is_locked(&\(.*\)->i_mutex)/inode_is_locked(\1)/'
        |        sed 's/mutex_trylock(&\(.*\)->i_mutex)/inode_trylock(\1)/'
        |
        |    with a very few manual fixups
        -----
    
      I'm going to send that once the ->i_mutex-affecting stuff in -next
      gets mostly merged (or when Linus says he's about to stop taking
      merges)"
    
    * 'work.misc' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      nfsd: don't hold i_mutex over userspace upcalls
      fs:affs:Replace time_t with time64_t
      fs/9p: use fscache mutex rather than spinlock
      proc: add a reschedule point in proc_readfd_common()
      logfs: constify logfs_block_ops structures
      fcntl: allow to set O_DIRECT flag on pipe
      fs: __generic_file_splice_read retry lookup on AOP_TRUNCATED_PAGE
      fs: xattr: Use kvfree()
      [s390] page_to_phys() always returns a multiple of PAGE_SIZE
      nbd: use ->compat_ioctl()
      fs: use block_device name vsprintf helper
      lib/vsprintf: add %*pg format specifier
      fs: use gendisk->disk_name where possible
      poll: plug an unused argument to do_poll
      amdkfd: don't open-code memdup_user()
      cdrom: don't open-code memdup_user()
      rsxx: don't open-code memdup_user()
      mtip32xx: don't open-code memdup_user()
      [um] mconsole: don't open-code memdup_user_nul()
      [um] hostaudio: don't open-code memdup_user()
      ...

commit fce205e9da8e063aa1cf3d6583c1a9ed2b82f3f0
Merge: 065019a38fea 2b3909f8a7fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 16:30:34 2016 -0800

    Merge branch 'work.copy_file_range' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs copy_file_range updates from Al Viro:
     "Several series around copy_file_range/CLONE"
    
    * 'work.copy_file_range' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      btrfs: use new dedupe data function pointer
      vfs: hoist the btrfs deduplication ioctl to the vfs
      vfs: wire up compat ioctl for CLONE/CLONE_RANGE
      cifs: avoid unused variable and label
      nfsd: implement the NFSv4.2 CLONE operation
      nfsd: Pass filehandle to nfs4_preprocess_stateid_op()
      vfs: pull btrfs clone API to vfs layer
      locks: new locks_mandatory_area calling convention
      vfs: Add vfs_copy_file_range() support for pagecache copies
      btrfs: add .copy_file_range file operation
      x86: add sys_copy_file_range to syscall tables
      vfs: add copy_file_range syscall and vfs helper

commit 065019a38feab5f2659cbd44080d528f8dff0b00
Merge: 4f31d774dd52 b4d629a39e10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 15:46:17 2016 -0800

    Merge tag 'locks-v4.5-1' of git://git.samba.org/jlayton/linux
    
    Pull file locking updates from Jeff Layton:
     "File locking related changes for v4.5 (pile #1)
    
      Highlights:
       - new Kconfig option to allow disabling mandatory locking (which is
         racy anyway)
       - new tracepoints for setlk and close codepaths
       - fix for a long-standing bug in code that handles races between
         setting a POSIX lock and close()"
    
    * tag 'locks-v4.5-1' of git://git.samba.org/jlayton/linux:
      locks: rename __posix_lock_file to posix_lock_inode
      locks: prink more detail when there are leaked locks
      locks: pass inode pointer to locks_free_lock_context
      locks: sprinkle some tracepoints around the file locking code
      locks: don't check for race with close when setting OFD lock
      locks: fix unlock when fcntl_setlk races with a close
      fs: make locks.c explicitly non-modular
      locks: use list_first_entry_or_null()
      locks: Don't allow mounts in user namespaces to enable mandatory locking
      locks: Allow disabling mandatory locking at compile time

commit 32fb378437a1d716e72a442237d7ead1f435ecf0
Merge: 19ccb28e296d fceef393a538
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 11 13:13:23 2016 -0800

    Merge branch 'work.symlinks' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs RCU symlink updates from Al Viro:
     "Replacement of ->follow_link/->put_link, allowing to stay in RCU mode
      even if the symlink is not an embedded one.
    
      No changes since the mailbomb on Jan 1"
    
    * 'work.symlinks' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      switch ->get_link() to delayed_call, kill ->put_link()
      kill free_page_put_link()
      teach nfs_get_link() to work in RCU mode
      teach proc_self_get_link()/proc_thread_self_get_link() to work in RCU mode
      teach shmem_get_link() to work in RCU mode
      teach page_get_link() to work in RCU mode
      replace ->follow_link() with new method that could stay in RCU mode
      don't put symlink bodies in pagecache into highmem
      namei: page_getlink() and page_follow_link_light() are the same thing
      ufs: get rid of ->setattr() for symlinks
      udf: don't duplicate page_symlink_inode_operations
      logfs: don't duplicate page_symlink_inode_operations
      switch befs long symlinks to page_symlink_operations

commit 5a023cdba50c5f5f2bc351783b3131699deb3937
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Nov 30 10:20:29 2015 -0800

    block: enable dax for raw block devices
    
    If an application wants exclusive access to all of the persistent memory
    provided by an NVDIMM namespace it can use this raw-block-dax facility
    to forgo establishing a filesystem.  This capability is targeted
    primarily to hypervisors wanting to provision persistent memory for
    guests.  It can be disabled / enabled dynamically via the new BLKDAXSET
    ioctl.
    
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Reviewed-by: Jan Kara <jack@suse.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3aa514254161..96fabc93b583 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -482,6 +482,9 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
+#ifdef CONFIG_FS_DAX
+	int			bd_map_count;
+#endif
 };
 
 /*
@@ -2264,6 +2267,14 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
+#ifdef CONFIG_FS_DAX
+extern bool blkdev_dax_capable(struct block_device *bdev);
+#else
+static inline bool blkdev_dax_capable(struct block_device *bdev)
+{
+	return false;
+}
+#endif
 
 extern struct super_block *blockdev_superblock;
 

commit 6108209c4ae964836f6bac5210f1c64153800b62
Merge: a1c6f05733c2 a7f61e89af73
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 8 21:20:11 2016 -0500

    Merge branch 'for-linus' into work.misc

commit 66cf191f3eae4582a83cb4251b75b43bee95a999
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 7 09:53:30 2016 -0500

    compat_ioctl: don't pass fd around when not needed
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3aa514254161..51f9f8d93d4d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2764,8 +2764,6 @@ extern int vfs_lstat(const char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
 
-extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
-		    unsigned long arg);
 extern int __generic_block_fiemap(struct inode *inode,
 				  struct fiemap_extent_info *fieinfo,
 				  loff_t start, loff_t len,

commit f27a0fe083bf46fef0d7045aa2e9a7e56e72d8d8
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Thu Jan 7 15:08:51 2016 -0500

    locks: pass inode pointer to locks_free_lock_context
    
    ...so we can print information about it if there are leaked locks.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Acked-by: "J. Bruce Fields" <bfields@fieldses.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cbf08d5c246e..6c4983aceb02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1042,7 +1042,7 @@ extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
 /* fs/locks.c */
-void locks_free_lock_context(struct file_lock_context *ctx);
+void locks_free_lock_context(struct inode *inode);
 void locks_free_lock(struct file_lock *fl);
 extern void locks_init_lock(struct file_lock *);
 extern struct file_lock * locks_alloc_lock(void);
@@ -1103,7 +1103,7 @@ static inline int fcntl_getlease(struct file *filp)
 }
 
 static inline void
-locks_free_lock_context(struct file_lock_context *ctx)
+locks_free_lock_context(struct inode *inode)
 {
 }
 

commit 54dbc15172375641ef03399e8f911d7165eb90fb
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Sat Dec 19 00:55:59 2015 -0800

    vfs: hoist the btrfs deduplication ioctl to the vfs
    
    Hoist the btrfs EXTENT_SAME ioctl up to the VFS and make the name
    more systematic (FIDEDUPERANGE).
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5d987aefcf1e..d71814b81a3c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1633,6 +1633,8 @@ struct file_operations {
 			loff_t, size_t, unsigned int);
 	int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,
 			u64);
+	ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *,
+			u64);
 };
 
 struct inode_operations {
@@ -1688,6 +1690,8 @@ extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
 extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
 		struct file *file_out, loff_t pos_out, u64 len);
+extern int vfs_dedupe_file_range(struct file *file,
+				 struct file_dedupe_range *same);
 
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);

commit fceef393a538134f03b778c5d2519e670269342f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 29 15:58:39 2015 -0500

    switch ->get_link() to delayed_call, kill ->put_link()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 138e206df2fc..5de5edb01e70 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -31,6 +31,7 @@
 #include <linux/blk_types.h>
 #include <linux/workqueue.h>
 #include <linux/percpu-rwsem.h>
+#include <linux/delayed_call.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -1633,12 +1634,11 @@ struct file_operations {
 
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
-	const char * (*get_link) (struct dentry *, struct inode *, void **);
+	const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);
 	int (*permission) (struct inode *, int);
 	struct posix_acl * (*get_acl)(struct inode *, int);
 
 	int (*readlink) (struct dentry *, char __user *,int);
-	void (*put_link) (struct inode *, void *);
 
 	int (*create) (struct inode *,struct dentry *, umode_t, bool);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
@@ -2736,13 +2736,14 @@ extern const struct file_operations generic_ro_fops;
 
 extern int readlink_copy(char __user *, int, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
-extern const char *page_get_link(struct dentry *, struct inode *, void **);
-extern void page_put_link(struct inode *, void *);
+extern const char *page_get_link(struct dentry *, struct inode *,
+				 struct delayed_call *);
+extern void page_put_link(void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
-extern void kfree_put_link(struct inode *, void *);
+extern void kfree_link(void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat);
@@ -2753,7 +2754,8 @@ void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
-const char *simple_get_link(struct dentry *, struct inode *, void **);
+const char *simple_get_link(struct dentry *, struct inode *,
+			    struct delayed_call *);
 extern const struct inode_operations simple_symlink_inode_operations;
 
 extern int iterate_dir(struct file *, struct dir_context *);

commit cd3417c8fc9504cc1afe944515f338aff9ec286b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 29 16:03:53 2015 -0500

    kill free_page_put_link()
    
    all callers are better off with kfree_put_link()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d2fdf09a4407..138e206df2fc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2743,7 +2743,6 @@ extern int __page_symlink(struct inode *inode, const char *symname, int len,
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern void kfree_put_link(struct inode *, void *);
-extern void free_page_put_link(struct inode *, void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat);

commit b25472f9b96159cc0b9b7ed449448805973cd789
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 5 22:04:48 2015 -0500

    new helpers: no_seek_end_llseek{,_size}()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd1447661e3c..fb0fa224d8e8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2660,6 +2660,8 @@ extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
 		int whence, loff_t maxsize, loff_t eof);
 extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
 		int whence, loff_t size);
+extern loff_t no_seek_end_llseek_size(struct file *, loff_t, int, loff_t);
+extern loff_t no_seek_end_llseek(struct file *, loff_t, int);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit 6b2553918d8b4e6de9853fd6315bec7271a2e592
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 17 10:20:54 2015 -0500

    replace ->follow_link() with new method that could stay in RCU mode
    
    new method: ->get_link(); replacement of ->follow_link().  The differences
    are:
            * inode and dentry are passed separately
            * might be called both in RCU and non-RCU mode;
    the former is indicated by passing it a NULL dentry.
            * when called that way it isn't allowed to block
    and should return ERR_PTR(-ECHILD) if it needs to be called
    in non-RCU mode.
    
    It's a flagday change - the old method is gone, all in-tree instances
    converted.  Conversion isn't hard; said that, so far very few instances
    do not immediately bail out when called in RCU mode.  That'll change
    in the next commits.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dfeda44b9ba4..d2fdf09a4407 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1633,7 +1633,7 @@ struct file_operations {
 
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
-	const char * (*follow_link) (struct dentry *, void **);
+	const char * (*get_link) (struct dentry *, struct inode *, void **);
 	int (*permission) (struct inode *, int);
 	struct posix_acl * (*get_acl)(struct inode *, int);
 
@@ -2736,7 +2736,7 @@ extern const struct file_operations generic_ro_fops;
 
 extern int readlink_copy(char __user *, int, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
-extern const char *page_follow_link_light(struct dentry *, void **);
+extern const char *page_get_link(struct dentry *, struct inode *, void **);
 extern void page_put_link(struct inode *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		int nofs);
@@ -2754,7 +2754,7 @@ void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
-const char *simple_follow_link(struct dentry *, void **);
+const char *simple_get_link(struct dentry *, struct inode *, void **);
 extern const struct inode_operations simple_symlink_inode_operations;
 
 extern int iterate_dir(struct file *, struct dir_context *);

commit 21fc61c73c3903c4c312d0802da01ec2b323d174
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 17 01:07:57 2015 -0500

    don't put symlink bodies in pagecache into highmem
    
    kmap() in page_follow_link_light() needed to go - allowing to hold
    an arbitrary number of kmaps for long is a great way to deadlocking
    the system.
    
    new helper (inode_nohighmem(inode)) needs to be used for pagecache
    symlinks inodes; done for all in-tree cases.  page_follow_link_light()
    instrumented to yell about anything missed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3aa514254161..dfeda44b9ba4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -3025,5 +3025,6 @@ static inline bool dir_relax(struct inode *inode)
 }
 
 extern bool path_noexec(const struct path *path);
+extern void inode_nohighmem(struct inode *inode);
 
 #endif /* _LINUX_FS_H */

commit 04b38d601239b4d9be641b412cf4b7456a041c67
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 3 12:59:50 2015 +0100

    vfs: pull btrfs clone API to vfs layer
    
    The btrfs clone ioctls are now adopted by other file systems, with NFS
    and CIFS already having support for them, and XFS being under active
    development.  To avoid growth of various slightly incompatible
    implementations, add one to the VFS.  Note that clones are different from
    file copies in several ways:
    
     - they are atomic vs other writers
     - they support whole file clones
     - they support 64-bit legth clones
     - they do not allow partial success (aka short writes)
     - clones are expected to be a fast metadata operation
    
    Because of that it would be rather cumbersome to try to piggyback them on
    top of the recent clone_file_range infrastructure.  The converse isn't
    true and the clone_file_range system call could try clone file range as
    a first attempt to copy, something that further patches will enable.
    
    Based on earlier work from Peng Tao.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4377b2df991d..5d987aefcf1e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1629,7 +1629,10 @@ struct file_operations {
 #ifndef CONFIG_MMU
 	unsigned (*mmap_capabilities)(struct file *);
 #endif
-	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
+	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
+			loff_t, size_t, unsigned int);
+	int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,
+			u64);
 };
 
 struct inode_operations {
@@ -1683,6 +1686,8 @@ extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *);
 extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
 				   loff_t, size_t, unsigned int);
+extern int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
+		struct file *file_out, loff_t pos_out, u64 len);
 
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);

commit acc15575e78e534c12549d8057a692f490a50f61
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 3 12:59:49 2015 +0100

    locks: new locks_mandatory_area calling convention
    
    Pass a loff_t end for the last byte instead of the 32-bit count
    parameter to allow full file clones even on 32-bit architectures.
    While we're at it also simplify the read/write selection.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e8a736242b1a..4377b2df991d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2030,12 +2030,9 @@ extern struct kobject *fs_kobj;
 
 #define MAX_RW_COUNT (INT_MAX & PAGE_CACHE_MASK)
 
-#define FLOCK_VERIFY_READ  1
-#define FLOCK_VERIFY_WRITE 2
-
 #ifdef CONFIG_FILE_LOCKING
 extern int locks_mandatory_locked(struct file *);
-extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
+extern int locks_mandatory_area(struct inode *, struct file *, loff_t, loff_t, unsigned char);
 
 /*
  * Candidates for mandatory locking have the setgid bit set
@@ -2065,17 +2062,19 @@ static inline int locks_verify_locked(struct file *file)
 }
 
 static inline int locks_verify_truncate(struct inode *inode,
-				    struct file *filp,
+				    struct file *f,
 				    loff_t size)
 {
-	if (inode->i_flctx && mandatory_lock(inode))
-		return locks_mandatory_area(
-			FLOCK_VERIFY_WRITE, inode, filp,
-			size < inode->i_size ? size : inode->i_size,
-			(size < inode->i_size ? inode->i_size - size
-			 : size - inode->i_size)
-		);
-	return 0;
+	if (!inode->i_flctx || !mandatory_lock(inode))
+		return 0;
+
+	if (size < inode->i_size) {
+		return locks_mandatory_area(inode, f, size, inode->i_size - 1,
+				F_WRLCK);
+	} else {
+		return locks_mandatory_area(inode, f, inode->i_size, size - 1,
+				F_WRLCK);
+	}
 }
 
 static inline int break_lease(struct inode *inode, unsigned int mode)
@@ -2144,9 +2143,8 @@ static inline int locks_mandatory_locked(struct file *file)
 	return 0;
 }
 
-static inline int locks_mandatory_area(int rw, struct inode *inode,
-				       struct file *filp, loff_t offset,
-				       size_t count)
+static inline int locks_mandatory_area(struct inode *inode, struct file *filp,
+		loff_t start, loff_t end, unsigned char type)
 {
 	return 0;
 }

commit d37177bacdf7cbcdb23a513cbb475fa241f8083c
Author: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
Date:   Thu Nov 19 21:00:12 2015 +0800

    fs/attr.c: is_sxid can be boolean
    
    This patch makes is_sxid return bool to improve readability
    due to this particular function only using either one or zero
    as its return value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6b33ac447612..bd1447661e3c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2963,7 +2963,7 @@ int __init get_filesystem_list(char *buf);
 #define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \
 					    (flag & __FMODE_NONOTIFY)))
 
-static inline int is_sxid(umode_t mode)
+static inline bool is_sxid(umode_t mode)
 {
 	return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));
 }

commit 0e3ef1fe453c9f29c30d040cd2559c5cac724e93
Author: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
Date:   Thu Nov 19 21:00:11 2015 +0800

    fs/bad_inode.c: is_bad_inode can be boolean
    
    This patch makes is_bad_inode return bool to improve
    readability due to this particular function only using either
    one or zero as its return value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b23def18aa9..6b33ac447612 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2371,7 +2371,7 @@ extern void init_special_inode(struct inode *, umode_t, dev_t);
 
 /* Invalid inode operations -- fs/bad_inode.c */
 extern void make_bad_inode(struct inode *);
-extern int is_bad_inode(struct inode *);
+extern bool is_bad_inode(struct inode *);
 
 #ifdef CONFIG_BLOCK
 /*

commit a6e5787fc8fc9c88290a7bceed07aa4d14029fa7
Author: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
Date:   Tue Nov 17 14:40:11 2015 +0800

    fs/dcache.c: is_subdir can be boolean
    
    This patch makes is_subdir return bool to improve
    readability due to this particular function only using either
    one or zero as its return value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aab8094656e4..4b23def18aa9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2532,7 +2532,7 @@ extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */
-extern int is_subdir(struct dentry *, struct dentry *);
+extern bool is_subdir(struct dentry *, struct dentry *);
 extern bool path_is_under(struct path *, struct path *);
 
 extern char *file_path(struct file *, char *, int);

commit 25ab4c9b1ccb64b1433cecd3f19f28fe300c1576
Author: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
Date:   Tue Nov 17 14:40:10 2015 +0800

    fs/namespace.c: path_is_under can be boolean
    
    This patch makes path_is_under return bool to improve
    readability due to this particular function only using either
    one or zero as its return value.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 11505af0d358..aab8094656e4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2533,7 +2533,7 @@ extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */
 extern int is_subdir(struct dentry *, struct dentry *);
-extern int path_is_under(struct path *, struct path *);
+extern bool path_is_under(struct path *, struct path *);
 
 extern char *file_path(struct file *, char *, int);
 

commit 3e004eea56b4f2cb6768ebe9000c830eda0c71b1
Author: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
Date:   Tue Nov 17 14:40:09 2015 +0800

    fs/block_dev.c: make sb_is_blkdev_sb return bool when CONFIG_BLOCK undefined
    
    Currently when CONFIG_BLOCK is defined sb_is_blkdev_sb returns bool,
    while when CONFIG_BLOCK is not defined it returns int. Let's keep
    consistent to make sb_is_blkdev_sb return bool as well when CONFIG_BLOCK
    isn't defined.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <baiyaowei@cmss.chinamobile.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3aa514254161..11505af0d358 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2291,9 +2291,9 @@ static inline void iterate_bdevs(void (*f)(struct block_device *, void *), void
 {
 }
 
-static inline int sb_is_blkdev_sb(struct super_block *sb)
+static inline bool sb_is_blkdev_sb(struct super_block *sb)
 {
-	return 0;
+	return false;
 }
 #endif
 extern int sync_filesystem(struct super_block *);

commit 29732938a6289a15e907da234d6692a2ead71855
Author: Zach Brown <zab@redhat.com>
Date:   Tue Nov 10 16:53:30 2015 -0500

    vfs: add copy_file_range syscall and vfs helper
    
    Add a copy_file_range() system call for offloading copies between
    regular files.
    
    This gives an interface to underlying layers of the storage stack which
    can copy without reading and writing all the data.  There are a few
    candidates that should support copy offloading in the nearer term:
    
    - btrfs shares extent references with its clone ioctl
    - NFS has patches to add a COPY command which copies on the server
    - SCSI has a family of XCOPY commands which copy in the device
    
    This system call avoids the complexity of also accelerating the creation
    of the destination file by operating on an existing destination file
    descriptor, not a path.
    
    Currently the high level vfs entry point limits copy offloading to files
    on the same mount and super (and not in the same file).  This can be
    relaxed if we get implementations which can copy between file systems
    safely.
    
    Signed-off-by: Zach Brown <zab@redhat.com>
    [Anna Schumaker: Change -EINVAL to -EBADF during file verification,
                     Change flags parameter from int to unsigned int,
                     Add function to include/linux/syscalls.h,
                     Check copy len after file open mode,
                     Don't forbid ranges inside the same file,
                     Use rw_verify_area() to veriy ranges,
                     Use file_out rather than file_in,
                     Add COPY_FR_REFLINK flag]
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3aa514254161..e8a736242b1a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1629,6 +1629,7 @@ struct file_operations {
 #ifndef CONFIG_MMU
 	unsigned (*mmap_capabilities)(struct file *);
 #endif
+	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
 };
 
 struct inode_operations {
@@ -1680,6 +1681,8 @@ extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *);
 extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *);
+extern ssize_t vfs_copy_file_range(struct file *, loff_t , struct file *,
+				   loff_t, size_t, unsigned int);
 
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);

commit 9e8925b67a809bb27ce4b7d352d67f25cf1d7fc5
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Mon Nov 16 09:49:34 2015 -0500

    locks: Allow disabling mandatory locking at compile time
    
    Mandatory locking appears to be almost unused and buggy and there
    appears no real interest in doing anything with it.  Since effectively
    no one uses the code and since the code is buggy let's allow it to be
    disabled at compile time.  I would just suggest removing the code but
    undoubtedly that will break some piece of userspace code somewhere.
    
    For the distributions that don't care about this piece of code
    this gives a nice starting point to make mandatory locking go away.
    
    Cc: Benjamin Coddington <bcodding@redhat.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Jeff Layton <jeff.layton@primarydata.com>
    Cc: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3aa514254161..cbf08d5c246e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2030,7 +2030,7 @@ extern struct kobject *fs_kobj;
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2
 
-#ifdef CONFIG_FILE_LOCKING
+#ifdef CONFIG_MANDATORY_FILE_LOCKING
 extern int locks_mandatory_locked(struct file *);
 extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
 
@@ -2075,6 +2075,45 @@ static inline int locks_verify_truncate(struct inode *inode,
 	return 0;
 }
 
+#else /* !CONFIG_MANDATORY_FILE_LOCKING */
+
+static inline int locks_mandatory_locked(struct file *file)
+{
+	return 0;
+}
+
+static inline int locks_mandatory_area(int rw, struct inode *inode,
+				       struct file *filp, loff_t offset,
+				       size_t count)
+{
+	return 0;
+}
+
+static inline int __mandatory_lock(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int mandatory_lock(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int locks_verify_locked(struct file *file)
+{
+	return 0;
+}
+
+static inline int locks_verify_truncate(struct inode *inode, struct file *filp,
+					size_t size)
+{
+	return 0;
+}
+
+#endif /* CONFIG_MANDATORY_FILE_LOCKING */
+
+
+#ifdef CONFIG_FILE_LOCKING
 static inline int break_lease(struct inode *inode, unsigned int mode)
 {
 	/*
@@ -2136,39 +2175,6 @@ static inline int break_layout(struct inode *inode, bool wait)
 }
 
 #else /* !CONFIG_FILE_LOCKING */
-static inline int locks_mandatory_locked(struct file *file)
-{
-	return 0;
-}
-
-static inline int locks_mandatory_area(int rw, struct inode *inode,
-				       struct file *filp, loff_t offset,
-				       size_t count)
-{
-	return 0;
-}
-
-static inline int __mandatory_lock(struct inode *inode)
-{
-	return 0;
-}
-
-static inline int mandatory_lock(struct inode *inode)
-{
-	return 0;
-}
-
-static inline int locks_verify_locked(struct file *file)
-{
-	return 0;
-}
-
-static inline int locks_verify_truncate(struct inode *inode, struct file *filp,
-					size_t size)
-{
-	return 0;
-}
-
 static inline int break_lease(struct inode *inode, unsigned int mode)
 {
 	return 0;

commit 842cf0b9525813b084720a82d0d3aabc750b7ccc
Merge: 65d57b3050ee 7c7afc440c8e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 11 09:45:24 2015 -0800

    Merge branch 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs update from Al Viro:
    
     - misc stable fixes
    
     - trivial kernel-doc and comment fixups
    
     - remove never-used block_page_mkwrite() wrapper function, and rename
       the function that is _actually_ used to not have double underscores.
    
    * 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: 9p: cache.h: Add #define of include guard
      vfs: remove stale comment in inode_operations
      vfs: remove unused wrapper block_page_mkwrite()
      binfmt_elf: Correct `arch_check_elf's description
      fs: fix writeback.c kernel-doc warnings
      fs: fix inode.c kernel-doc warning
      fs/pipe.c: return error code rather than 0 in pipe_write()
      fs/pipe.c: preserve alloc_file() error code
      binfmt_elf: Don't clobber passed executable's file header
      FS-Cache: Handle a write to the page immediately beyond the EOF marker
      cachefiles: perform test on s_blocksize when opening cache file.
      FS-Cache: Don't override netfs's primary_index if registering failed
      FS-Cache: Increase reference of parent after registering, netfs success
      debugfs: fix refcount imbalance in start_creating

commit c8fffa643583e00eb9a783abbca251b11bc0d163
Author: Ross Zwisler <ross.zwisler@linux.intel.com>
Date:   Thu Oct 8 17:07:20 2015 -0600

    vfs: remove stale comment in inode_operations
    
    The big warning comment that is currently at the end of struct
    inode_operations was added as part of this commit:
    
    4aa7c6346be3 ("vfs: add i_op->dentry_open()")
    
    It was added to warn people not to use the newly added 'dentry_open'
    function pointer.
    
    This function pointer was removed as part of this commit:
    
    4bacc9c9234c ("overlayfs: Make f_path always point to the overlay and
                    f_inode to the underlay")
    
    The comment was left behind and now refers to nothing, so remove it.
    
    Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9a1cb8c605e0..f3bfbd7d3fa9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1665,8 +1665,6 @@ struct inode_operations {
 			   umode_t create_mode, int *opened);
 	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 	int (*set_acl)(struct inode *, struct posix_acl *, int);
-
-	/* WARNING: probably going away soon, do not use! */
 } ____cacheline_aligned;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,

commit 3419b45039c6b799c974a8019361c045e7ca232c
Merge: 01504f5e9e07 c1c534609fe8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 10 17:23:49 2015 -0800

    Merge branch 'for-4.4/io-poll' of git://git.kernel.dk/linux-block
    
    Pull block IO poll support from Jens Axboe:
     "Various groups have been doing experimentation around IO polling for
      (really) fast devices.  The code has been reviewed and has been
      sitting on the side for a few releases, but this is now good enough
      for coordinated benchmarking and further experimentation.
    
      Currently O_DIRECT sync read/write are supported.  A framework is in
      the works that allows scalable stats tracking so we can auto-tune
      this.  And we'll add libaio support as well soon.  Fow now, it's an
      opt-in feature for test purposes"
    
    * 'for-4.4/io-poll' of git://git.kernel.dk/linux-block:
      direct-io: be sure to assign dio->bio_bdev for both paths
      directio: add block polling support
      NVMe: add blk polling support
      block: add block polling support
      blk-mq: return tag/queue combo in the make_request_fn handlers
      block: change ->make_request_fn() and users to return a queue cookie

commit dece16353ef47d8d33f5302bc158072a9d65e26f
Author: Jens Axboe <axboe@fb.com>
Date:   Thu Nov 5 10:41:16 2015 -0700

    block: change ->make_request_fn() and users to return a queue cookie
    
    No functional changes in this patch, but it prepares us for returning
    a more useful cookie related to the IO that was queued up.
    
    Signed-off-by: Jens Axboe <axboe@fb.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Keith Busch <keith.busch@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 72d8a844c692..bcca36e4bc1e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2625,7 +2625,7 @@ static inline void remove_inode_hash(struct inode *inode)
 extern void inode_sb_list_add(struct inode *inode);
 
 #ifdef CONFIG_BLOCK
-extern void submit_bio(int, struct bio *);
+extern blk_qc_t submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);
 #endif
 extern int set_blocksize(struct block_device *, int);

commit 2e3078af2c67730c479f1d183af5b367f5d95337
Merge: ea5c58e70c3a b3b0d09c7a23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 5 23:10:54 2015 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge patch-bomb from Andrew Morton:
    
     - inotify tweaks
    
     - some ocfs2 updates (many more are awaiting review)
    
     - various misc bits
    
     - kernel/watchdog.c updates
    
     - Some of mm.  I have a huge number of MM patches this time and quite a
       lot of it is quite difficult and much will be held over to next time.
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (162 commits)
      selftests: vm: add tests for lock on fault
      mm: mlock: add mlock flags to enable VM_LOCKONFAULT usage
      mm: introduce VM_LOCKONFAULT
      mm: mlock: add new mlock system call
      mm: mlock: refactor mlock, munlock, and munlockall code
      kasan: always taint kernel on report
      mm, slub, kasan: enable user tracking by default with KASAN=y
      kasan: use IS_ALIGNED in memory_is_poisoned_8()
      kasan: Fix a type conversion error
      lib: test_kasan: add some testcases
      kasan: update reference to kasan prototype repo
      kasan: move KASAN_SANITIZE in arch/x86/boot/Makefile
      kasan: various fixes in documentation
      kasan: update log messages
      kasan: accurately determine the type of the bad access
      kasan: update reported bug types for kernel memory accesses
      kasan: update reported bug types for not user nor kernel memory accesses
      mm/kasan: prevent deadlock in kasan reporting
      mm/kasan: don't use kasan shadow pointer in generic functions
      mm/kasan: MODULE_VADDR is not available on all archs
      ...

commit aa750fd71c242dba02ee2034e15fbd7d0cdb2461
Author: Junichi Nomura <j-nomura@ce.jp.nec.com>
Date:   Thu Nov 5 18:47:23 2015 -0800

    mm/filemap.c: make global sync not clear error status of individual inodes
    
    filemap_fdatawait() is a function to wait for on-going writeback to
    complete but also consume and clear error status of the mapping set during
    writeback.
    
    The latter functionality is critical for applications to detect writeback
    error with system calls like fsync(2)/fdatasync(2).
    
    However filemap_fdatawait() is also used by sync(2) or FIFREEZE ioctl,
    which don't check error status of individual mappings.
    
    As a result, fsync() may not be able to detect writeback error if events
    happen in the following order:
    
       Application                    System admin
       ----------------------------------------------------------
       write data on page cache
                                      Run sync command
                                      writeback completes with error
                                      filemap_fdatawait() clears error
       fsync returns success
       (but the data is not on disk)
    
    This patch adds filemap_fdatawait_keep_errors() for call sites where
    writeback error is not handled so that they don't clear error status.
    
    Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Cc: Fengguang Wu <fengguang.wu@gmail.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 72d8a844c692..9355f377fd46 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2422,6 +2422,7 @@ extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
+extern void filemap_fdatawait_keep_errors(struct address_space *);
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);

commit 616fb38fa7a9599293e05ae1fa9acfaf73922434
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Thu Oct 22 13:38:15 2015 -0400

    locks: cleanup posix_lock_inode_wait and flock_lock_inode_wait
    
    All callers use locks_lock_inode_wait() instead.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b064d4c0b233..49749688156d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1053,12 +1053,10 @@ extern void locks_remove_file(struct file *);
 extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
-extern int posix_lock_inode_wait(struct inode *, struct file_lock *);
 extern int posix_unblock_lock(struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
-extern int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl);
 extern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
@@ -1145,12 +1143,6 @@ static inline int posix_lock_file(struct file *filp, struct file_lock *fl,
 	return -ENOLCK;
 }
 
-static inline int posix_lock_inode_wait(struct inode *inode,
-					struct file_lock *fl)
-{
-	return -ENOLCK;
-}
-
 static inline int posix_unblock_lock(struct file_lock *waiter)
 {
 	return -ENOENT;
@@ -1172,12 +1164,6 @@ static inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)
 	return 0;
 }
 
-static inline int flock_lock_inode_wait(struct inode *inode,
-					struct file_lock *request)
-{
-	return -ENOLCK;
-}
-
 static inline int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)
 {
 	return -ENOLCK;
@@ -1221,16 +1207,6 @@ static inline struct inode *file_inode(const struct file *f)
 	return f->f_inode;
 }
 
-static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
-{
-	return posix_lock_inode_wait(file_inode(filp), fl);
-}
-
-static inline int flock_lock_file_wait(struct file *filp, struct file_lock *fl)
-{
-	return flock_lock_inode_wait(file_inode(filp), fl);
-}
-
 static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
 {
 	return locks_lock_inode_wait(file_inode(filp), fl);

commit e55c34a66f87e78fb1fc6b623b78c5ad74b475af
Author: Benjamin Coddington <bcodding@redhat.com>
Date:   Thu Oct 22 13:38:13 2015 -0400

    locks: introduce locks_lock_inode_wait()
    
    Users of the locks API commonly call either posix_lock_file_wait() or
    flock_lock_file_wait() depending upon the lock type.  Add a new function
    locks_lock_inode_wait() which will check and call the correct function for
    the type of lock passed in.
    
    Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 72d8a844c692..b064d4c0b233 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1059,6 +1059,7 @@ extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl);
+extern int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
@@ -1177,6 +1178,11 @@ static inline int flock_lock_inode_wait(struct inode *inode,
 	return -ENOLCK;
 }
 
+static inline int locks_lock_inode_wait(struct inode *inode, struct file_lock *fl)
+{
+	return -ENOLCK;
+}
+
 static inline int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)
 {
 	return 0;
@@ -1225,6 +1231,11 @@ static inline int flock_lock_file_wait(struct file *filp, struct file_lock *fl)
 	return flock_lock_inode_wait(file_inode(filp), fl);
 }
 
+static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
+{
+	return locks_lock_inode_wait(file_inode(filp), fl);
+}
+
 struct fasync_struct {
 	spinlock_t		fa_lock;
 	int			magic;

commit c94c2acf84dc16cf4b989bb0bc849785b7ff52f5
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Tue Sep 8 14:58:40 2015 -0700

    dax: move DAX-related functions to a new header
    
    In order to handle the !CONFIG_TRANSPARENT_HUGEPAGES case, we need to
    return VM_FAULT_FALLBACK from the inlined dax_pmd_fault(), which is
    defined in linux/mm.h.  Given that we don't want to include <linux/mm.h>
    in <linux/fs.h>, the easiest solution is to move the DAX-related
    functions to a new header, <linux/dax.h>.  We could also have moved
    VM_FAULT_* definitions to a new header, or a different header that isn't
    quite such a boil-the-ocean header as <linux/mm.h>, but this felt like
    the best option.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Hillf Danton <dhillf@gmail.com>
    Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b2f9b9c25e41..72d8a844c692 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -52,7 +52,6 @@ struct swap_info_struct;
 struct seq_file;
 struct workqueue_struct;
 struct iov_iter;
-struct vm_fault;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2678,19 +2677,6 @@ extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
-ssize_t dax_do_io(struct kiocb *, struct inode *, struct iov_iter *, loff_t,
-		  get_block_t, dio_iodone_t, int flags);
-int dax_clear_blocks(struct inode *, sector_t block, long size);
-int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
-int dax_truncate_page(struct inode *, loff_t from, get_block_t);
-int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
-		dax_iodone_t);
-int __dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
-		dax_iodone_t);
-int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);
-#define dax_mkwrite(vma, vmf, gb, iod)		dax_fault(vma, vmf, gb, iod)
-#define __dax_mkwrite(vma, vmf, gb, iod)	__dax_fault(vma, vmf, gb, iod)
-
 #ifdef CONFIG_BLOCK
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
 			    loff_t file_offset);

commit 7d9071a095023cd1db8fa18fa0d648dc1a5210e0
Merge: bd779669945e 397d425dc26d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 5 20:34:28 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "In this one:
    
       - d_move fixes (Eric Biederman)
    
       - UFS fixes (me; locking is mostly sane now, a bunch of bugs in error
         handling ought to be fixed)
    
       - switch of sb_writers to percpu rwsem (Oleg Nesterov)
    
       - superblock scalability (Josef Bacik and Dave Chinner)
    
       - swapon(2) race fix (Hugh Dickins)"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (65 commits)
      vfs: Test for and handle paths that are unreachable from their mnt_root
      dcache: Reduce the scope of i_lock in d_splice_alias
      dcache: Handle escaped paths in prepend_path
      mm: fix potential data race in SyS_swapon
      inode: don't softlockup when evicting inodes
      inode: rename i_wb_list to i_io_list
      sync: serialise per-superblock sync operations
      inode: convert inode_sb_list_lock to per-sb
      inode: add hlist_fake to avoid the inode hash lock in evict
      writeback: plug writeback at a high level
      change sb_writers to use percpu_rw_semaphore
      shift percpu_counter_destroy() into destroy_super_work()
      percpu-rwsem: kill CONFIG_PERCPU_RWSEM
      percpu-rwsem: introduce percpu_rwsem_release() and percpu_rwsem_acquire()
      percpu-rwsem: introduce percpu_down_read_trylock()
      document rwsem_release() in sb_wait_write()
      fix the broken lockdep logic in __sb_start_write()
      introduce __sb_writers_{acquired,release}() helpers
      ufs_inode_get{frag,block}(): get rid of 'phys' argument
      ufs_getfrag_block(): tidy up a bit
      ...

commit 17447717a3266965e257d3eae79d89539ce3ec0a
Merge: 22365979ab15 a457974f1b95
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 5 17:26:24 2015 -0700

    Merge tag 'nfsd-4.3' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "Nothing major, but:
    
       - Add Jeff Layton as an nfsd co-maintainer: no change to existing
         practice, just an acknowledgement of the status quo.
    
       - Two patches ("nfsd: ensure that...") for a race overlooked by the
         state locking rewrite, causing a crash noticed by multiple users.
    
       - Lots of smaller bugfixes all over from Kinglong Mee.
    
       - From Jeff, some cleanup of server rpc code in preparation for
         possible shift of nfsd threads to workqueues"
    
    * tag 'nfsd-4.3' of git://linux-nfs.org/~bfields/linux: (52 commits)
      nfsd: deal with DELEGRETURN racing with CB_RECALL
      nfsd: return CLID_INUSE for unexpected SETCLIENTID_CONFIRM case
      nfsd: ensure that delegation stateid hash references are only put once
      nfsd: ensure that the ol stateid hash reference is only put once
      net: sunrpc: fix tracepoint Warning: unknown op '->'
      nfsd: allow more than one laundry job to run at a time
      nfsd: don't WARN/backtrace for invalid container deployment.
      fs: fix fs/locks.c kernel-doc warning
      nfsd: Add Jeff Layton as co-maintainer
      NFSD: Return word2 bitmask if setting security label in OPEN/CREATE
      NFSD: Set the attributes used to store the verifier for EXCLUSIVE4_1
      nfsd: SUPPATTR_EXCLCREAT must be encoded before SECURITY_LABEL.
      nfsd: Fix an FS_LAYOUT_TYPES/LAYOUT_TYPES encode bug
      NFSD: Store parent's stat in a separate value
      nfsd: Fix two typos in comments
      lockd: NLM grace period shouldn't block NFSv4 opens
      nfsd: include linux/nfs4.h in export.h
      sunrpc: Switch to using hash list instead single list
      sunrpc/nfsd: Remove redundant code by exports seq_operations functions
      sunrpc: Store cache_detail in seq_file's private directly
      ...

commit 5477e70a6420a6b7ca96c8e21413ee1c96a84260
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Fri Sep 4 15:48:04 2015 -0700

    mm: move ->mremap() from file_operations to vm_operations_struct
    
    vma->vm_ops->mremap() looks more natural and clean in move_vma(), and this
    way ->mremap() can have more users.  Say, vdso.
    
    While at it, s/aio_ring_remap/aio_ring_mremap/.
    
    Note: this is the minimal change before ->mremap() finds another user in
    file_operations; this method should have more arguments, and it can be
    used to kill arch_remap().
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Pavel Emelyanov <xemul@parallels.com>
    Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Benjamin LaHaise <bcrl@kvack.org>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Laurent Dufour <ldufour@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fbd780c33c5f..864203c10dbc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1612,7 +1612,6 @@ struct file_operations {
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);
-	int (*mremap)(struct file *, struct vm_area_struct *);
 	int (*open) (struct inode *, struct file *);
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);

commit 73b6fa8e49c2d13e04d20186261e5f7855c6d0bf
Merge: e713c80a4e49 4b75de861505
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 16:13:25 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace updates from Eric Biederman:
     "This finishes up the changes to ensure proc and sysfs do not start
      implementing executable files, as the there are application today that
      are only secure because such files do not exist.
    
      It akso fixes a long standing misfeature of /proc/<pid>/mountinfo that
      did not show the proper source for files bind mounted from
      /proc/<pid>/ns/*.
    
      It also straightens out the handling of clone flags related to user
      namespaces, fixing an unnecessary failure of unshare(CLONE_NEWUSER)
      when files such as /proc/<pid>/environ are read while <pid> is calling
      unshare.  This winds up fixing a minor bug in unshare flag handling
      that dates back to the first version of unshare in the kernel.
    
      Finally, this fixes a minor regression caused by the introduction of
      sysfs_create_mount_point, which broke someone's in house application,
      by restoring the size of /sys/fs/cgroup to 0 bytes.  Apparently that
      application uses the directory size to determine if a tmpfs is mounted
      on /sys/fs/cgroup.
    
      The bind mount escape fixes are present in Al Viros for-next branch.
      and I expect them to come from there.  The bind mount escape is the
      last of the user namespace related security bugs that I am aware of"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      fs: Set the size of empty dirs to 0.
      userns,pidns: Force thread group sharing, not signal handler sharing.
      unshare: Unsharing a thread does not require unsharing a vm
      nsfs: Add a show_path method to fix mountinfo
      mnt: fs_fully_visible enforce noexec and nosuid  if !SB_I_NOEXEC
      vfs: Commit to never having exectuables on proc and sysfs.

commit 061f98e959ea025a5d87c3e089d59ec2ec5f5d6d
Merge: b5f5914cb8a2 ac05fbb40062
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Aug 21 02:31:20 2015 -0400

    Merge branch 'superblock-scaling' of git://git.kernel.org/pub/scm/linux/kernel/git/josef/btrfs-next into for-next
    
    Conflicts:
            include/linux/fs.h

commit c7f5408493aeb01532927b2276316797a03ed6ee
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Mar 4 14:07:22 2015 -0500

    inode: rename i_wb_list to i_io_list
    
    There's a small consistency problem between the inode and writeback
    naming. Writeback calls the "for IO" inode queues b_io and
    b_more_io, but the inode calls these the "writeback list" or
    i_wb_list. This makes it hard to an new "under writeback" list to
    the inode, or call it an "under IO" list on the bdi because either
    way we'll have writeback on IO and IO on writeback and it'll just be
    confusing. I'm getting confused just writing this!
    
    So, rename the inode "for IO" list variable to i_io_list so we can
    add a new "writeback list" in a subsequent patch.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Dave Chinner <dchinner@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 82dfc5519b4b..34cfa60db678 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -636,7 +636,7 @@ struct inode {
 	unsigned long		dirtied_time_when;
 
 	struct hlist_node	i_hash;
-	struct list_head	i_wb_list;	/* backing dev IO list */
+	struct list_head	i_io_list;	/* backing dev IO list */
 #ifdef CONFIG_CGROUP_WRITEBACK
 	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */
 

commit e97fedb9ef9868ff24d588be781906cf7c1b59ae
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Mar 4 13:40:00 2015 -0500

    sync: serialise per-superblock sync operations
    
    When competing sync(2) calls walk the same filesystem, they need to
    walk the list of inodes on the superblock to find all the inodes
    that we need to wait for IO completion on. However, when multiple
    wait_sb_inodes() calls do this at the same time, they contend on the
    the inode_sb_list_lock and the contention causes system wide
    slowdowns. In effect, concurrent sync(2) calls can take longer and
    burn more CPU than if they were serialised.
    
    Stop the worst of the contention by adding a per-sb mutex to wrap
    around wait_sb_inodes() so that we only execute one sync(2) IO
    completion walk per superblock superblock at a time and hence avoid
    contention being triggered by concurrent sync(2) calls.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Dave Chinner <dchinner@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 09bbd38485f9..82dfc5519b4b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1375,6 +1375,8 @@ struct super_block {
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 	struct rcu_head		rcu;
 
+	struct mutex		s_sync_lock;	/* sync serialisation lock */
+
 	/*
 	 * Indicates how deep in a filesystem stack this SB is
 	 */

commit 74278da9f70d84d715601fe794567a6d2bfdf078
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Mar 4 12:37:22 2015 -0500

    inode: convert inode_sb_list_lock to per-sb
    
    The process of reducing contention on per-superblock inode lists
    starts with moving the locking to match the per-superblock inode
    list. This takes the global lock out of the picture and reduces the
    contention problems to within a single filesystem. This doesn't get
    rid of contention as the locks still have global CPU scope, but it
    does isolate operations on different superblocks form each other.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Dave Chinner <dchinner@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a40fa843040..09bbd38485f9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1309,7 +1309,6 @@ struct super_block {
 #endif
 	const struct xattr_handler **s_xattr;
 
-	struct list_head	s_inodes;	/* all inodes */
 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	struct block_device	*s_bdev;
@@ -1380,6 +1379,10 @@ struct super_block {
 	 * Indicates how deep in a filesystem stack this SB is
 	 */
 	int s_stack_depth;
+
+	/* s_inode_list_lock protects s_inodes */
+	spinlock_t		s_inode_list_lock ____cacheline_aligned_in_smp;
+	struct list_head	s_inodes;	/* all inodes */
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit cbedaac63481dea52327127a9f1c60f092bd6b07
Author: Josef Bacik <jbacik@fb.com>
Date:   Thu Mar 12 08:19:11 2015 -0400

    inode: add hlist_fake to avoid the inode hash lock in evict
    
    Some filesystems don't use the VFS inode hash and fake the fact they
    are hashed so that all the writeback code works correctly. However,
    this means the evict() path still tries to remove the inode from the
    hash, meaning that the inode_hash_lock() needs to be taken
    unnecessarily. Hence under certain workloads the inode_hash_lock can
    be contended even if the inode is never actually hashed.
    
    To avoid this add hlist_fake to test if the inode isn't actually
    hashed to avoid taking the hash lock on inodes that have never been
    hashed.  Based on Dave Chinner's
    
    inode: add IOP_NOTHASHED to avoid inode hash lock in evict
    
    basd on Al's suggestions.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Dave Chinner <dchinner@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 84b783f277f7..4a40fa843040 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2608,7 +2608,7 @@ static inline void insert_inode_hash(struct inode *inode)
 extern void __remove_inode_hash(struct inode *);
 static inline void remove_inode_hash(struct inode *inode)
 {
-	if (!inode_unhashed(inode))
+	if (!inode_unhashed(inode) && !hlist_fake(&inode->i_hash))
 		__remove_inode_hash(inode);
 }
 

commit 8129ed29644bf56ed17ec1bbbeed5c568b43d6a0
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Tue Aug 11 17:05:04 2015 +0200

    change sb_writers to use percpu_rw_semaphore
    
    We can remove everything from struct sb_writers except frozen
    and add the array of percpu_rw_semaphore's instead.
    
    This patch doesn't remove sb_writers->wait_unfrozen yet, we keep
    it for get_super_thawed(). We will probably remove it later.
    
    This change tries to address the following problems:
    
            - Firstly, __sb_start_write() looks simply buggy. It does
              __sb_end_write() if it sees ->frozen, but if it migrates
              to another CPU before percpu_counter_dec(), sb_wait_write()
              can wrongly succeed if there is another task which holds
              the same "semaphore": sb_wait_write() can miss the result
              of the previous percpu_counter_inc() but see the result
              of this percpu_counter_dec().
    
            - As Dave Hansen reports, it is suboptimal. The trivial
              microbenchmark that writes to a tmpfs file in a loop runs
              12% faster if we change this code to rely on RCU and kill
              the memory barriers.
    
            - This code doesn't look simple. It would be better to rely
              on the generic locking code.
    
              According to Dave, this change adds the same performance
              improvement.
    
    Note: with this change both freeze_super() and thaw_super() will do
    synchronize_sched_expedited() 3 times. This is just ugly. But:
    
            - This will be "fixed" by the rcu_sync changes we are going
              to merge. After that freeze_super()->percpu_down_write()
              will use synchronize_sched(), and thaw_super() won't use
              synchronize() at all.
    
              This doesn't need any changes in fs/super.c.
    
            - Once we merge rcu_sync changes, we can also change super.c
              so that all wb_write->rw_sem's will share the single ->rss
              in struct sb_writes, then freeze_super() will need only one
              synchronize_sched().
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4bed78966c6b..ce356f66cc2a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1,7 +1,6 @@
 #ifndef _LINUX_FS_H
 #define _LINUX_FS_H
 
-
 #include <linux/linkage.h>
 #include <linux/wait.h>
 #include <linux/kdev_t.h>
@@ -31,6 +30,7 @@
 #include <linux/percpu-rwsem.h>
 #include <linux/blk_types.h>
 #include <linux/workqueue.h>
+#include <linux/percpu-rwsem.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -1275,16 +1275,9 @@ enum {
 #define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)
 
 struct sb_writers {
-	/* Counters for counting writers at each level */
-	struct percpu_counter	counter[SB_FREEZE_LEVELS];
-	wait_queue_head_t	wait;		/* queue for waiting for
-						   writers / faults to finish */
-	int			frozen;		/* Is sb frozen? */
-	wait_queue_head_t	wait_unfrozen;	/* queue for waiting for
-						   sb to be thawed */
-#ifdef CONFIG_DEBUG_LOCK_ALLOC
-	struct lockdep_map	lock_map[SB_FREEZE_LEVELS];
-#endif
+	int				frozen;		/* Is sb frozen? */
+	wait_queue_head_t		wait_unfrozen;	/* for get_super_thawed() */
+	struct percpu_rw_semaphore	rw_sem[SB_FREEZE_LEVELS];
 };
 
 struct super_block {
@@ -1393,9 +1386,9 @@ void __sb_end_write(struct super_block *sb, int level);
 int __sb_start_write(struct super_block *sb, int level, bool wait);
 
 #define __sb_writers_acquired(sb, lev)	\
-	rwsem_acquire_read(&(sb)->s_writers.lock_map[(lev)-1], 0, 1, _THIS_IP_)
+	percpu_rwsem_acquire(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)
 #define __sb_writers_release(sb, lev)	\
-	rwsem_release(&(sb)->s_writers.lock_map[(lev)-1], 1, _THIS_IP_)
+	percpu_rwsem_release(&(sb)->s_writers.rw_sem[(lev)-1], 1, _THIS_IP_)
 
 /**
  * sb_end_write - drop write access to a superblock

commit 853b39a7c82826b8413048feec7bf08e98ce7a84
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Wed Jul 22 20:21:13 2015 +0200

    shift percpu_counter_destroy() into destroy_super_work()
    
    Of course, this patch is ugly as hell. It will be (partially)
    reverted later. We add it to ensure that other WIP changes in
    percpu_rw_semaphore won't break fs/super.c.
    
    We do not even need this change right now, percpu_free_rwsem()
    is fine in atomic context. But we are going to change this, it
    will be might_sleep() after we merge the rcu_sync() patches.
    
    And even after that we do not really need destroy_super_work(),
    we will kill it in any case. Instead, destroy_super_rcu() should
    just check that rss->cb_state == CB_IDLE and do call_rcu() again
    in the (very unlikely) case this is not true.
    
    So this is just the temporary kludge which helps us to avoid the
    conflicts with the changes which will be (hopefully) routed via
    rcu tree.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index acb7cad84edd..4bed78966c6b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -30,6 +30,7 @@
 #include <linux/lockdep.h>
 #include <linux/percpu-rwsem.h>
 #include <linux/blk_types.h>
+#include <linux/workqueue.h>
 
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
@@ -1375,7 +1376,7 @@ struct super_block {
 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 	struct rcu_head		rcu;
-
+	struct work_struct	destroy_work;
 	/*
 	 * Indicates how deep in a filesystem stack this SB is
 	 */

commit bee9182d955227f01ff3b80c4cb6acca9bb40b11
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Sun Jul 19 23:48:20 2015 +0200

    introduce __sb_writers_{acquired,release}() helpers
    
    Preparation to hide the sb->s_writers internals from xfs and btrfs.
    Add 2 trivial define's they can use rather than play with ->s_writers
    directly. No changes in btrfs/transaction.o and xfs/xfs_aops.o.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 84b783f277f7..acb7cad84edd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1391,6 +1391,11 @@ extern struct timespec current_fs_time(struct super_block *sb);
 void __sb_end_write(struct super_block *sb, int level);
 int __sb_start_write(struct super_block *sb, int level, bool wait);
 
+#define __sb_writers_acquired(sb, lev)	\
+	rwsem_acquire_read(&(sb)->s_writers.lock_map[(lev)-1], 0, 1, _THIS_IP_)
+#define __sb_writers_release(sb, lev)	\
+	rwsem_release(&(sb)->s_writers.lock_map[(lev)-1], 1, _THIS_IP_)
+
 /**
  * sb_end_write - drop write access to a superblock
  * @sb: the super we wrote to

commit c87fb4a378f93f114b9906e180d83877cee4e7f4
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Thu Aug 6 12:47:02 2015 -0400

    lockd: NLM grace period shouldn't block NFSv4 opens
    
    NLM locks don't conflict with NFSv4 share reservations, so we're not
    going to learn anything new by watiting for them.
    
    They do conflict with NFSv4 locks and with delegations.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc008c338f5a..9a9d314f7b27 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -942,12 +942,18 @@ struct lock_manager_operations {
 
 struct lock_manager {
 	struct list_head list;
+	/*
+	 * NFSv4 and up also want opens blocked during the grace period;
+	 * NLM doesn't care:
+	 */
+	bool block_opens;
 };
 
 struct net;
 void locks_start_grace(struct net *, struct lock_manager *);
 void locks_end_grace(struct lock_manager *);
 int locks_in_grace(struct net *);
+int opens_in_grace(struct net *);
 
 /* that will die - we need it for nfs_lock_info */
 #include <linux/nfs_fs_i.h>

commit 4248b0da460839e30eaaad78992b9a1dd3e63e21
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Aug 6 15:46:20 2015 -0700

    fs, file table: reinit files_stat.max_files after deferred memory initialisation
    
    Dave Hansen reported the following;
    
            My laptop has been behaving strangely with 4.2-rc2.  Once I log
            in to my X session, I start getting all kinds of strange errors
            from applications and see this in my dmesg:
    
                    VFS: file-max limit 8192 reached
    
    The problem is that the file-max is calculated before memory is fully
    initialised and miscalculates how much memory the kernel is using.  This
    patch recalculates file-max after deferred memory initialisation.  Note
    that using memory hotplug infrastructure would not have avoided this
    problem as the value is not recalculated after memory hot-add.
    
    4.1:             files_stat.max_files = 6582781
    4.2-rc2:         files_stat.max_files = 8192
    4.2-rc2 patched: files_stat.max_files = 6562467
    
    Small differences with the patch applied and 4.1 but not enough to matter.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reported-by: Dave Hansen <dave.hansen@intel.com>
    Cc: Nicolai Stange <nicstange@gmail.com>
    Cc: Dave Hansen <dave.hansen@intel.com>
    Cc: Alex Ng <alexng@microsoft.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc008c338f5a..84b783f277f7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -55,7 +55,8 @@ struct vm_fault;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
-extern void __init files_init(unsigned long);
+extern void __init files_init(void);
+extern void __init files_maxfiles_init(void);
 
 extern struct files_stat_struct files_stat;
 extern unsigned long get_max_files(void);
@@ -2245,7 +2246,7 @@ extern int ioctl_preallocate(struct file *filp, void __user *argp);
 
 /* fs/dcache.c */
 extern void __init vfs_caches_init_early(void);
-extern void __init vfs_caches_init(unsigned long);
+extern void __init vfs_caches_init(void);
 
 extern struct kmem_cache *names_cachep;
 

commit ee296d7c5709440f8abd36b5b65c6b3e388538d9
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Sat Jul 11 06:43:03 2015 -0400

    locks: inline posix_lock_file_wait and flock_lock_file_wait
    
    They just call file_inode and then the corresponding *_inode_file_wait
    function. Just make them static inlines instead.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4c990edd1377..cc008c338f5a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1047,13 +1047,11 @@ extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_inode_wait(struct inode *, struct file_lock *);
-extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl);
-extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
@@ -1145,11 +1143,6 @@ static inline int posix_lock_inode_wait(struct inode *inode,
 	return -ENOLCK;
 }
 
-static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
-{
-	return -ENOLCK;
-}
-
 static inline int posix_unblock_lock(struct file_lock *waiter)
 {
 	return -ENOENT;
@@ -1177,12 +1170,6 @@ static inline int flock_lock_inode_wait(struct inode *inode,
 	return -ENOLCK;
 }
 
-static inline int flock_lock_file_wait(struct file *filp,
-				       struct file_lock *request)
-{
-	return -ENOLCK;
-}
-
 static inline int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)
 {
 	return 0;
@@ -1216,6 +1203,20 @@ static inline void show_fd_locks(struct seq_file *f,
 			struct file *filp, struct files_struct *files) {}
 #endif /* !CONFIG_FILE_LOCKING */
 
+static inline struct inode *file_inode(const struct file *f)
+{
+	return f->f_inode;
+}
+
+static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
+{
+	return posix_lock_inode_wait(file_inode(filp), fl);
+}
+
+static inline int flock_lock_file_wait(struct file *filp, struct file_lock *fl)
+{
+	return flock_lock_inode_wait(file_inode(filp), fl);
+}
 
 struct fasync_struct {
 	spinlock_t		fa_lock;
@@ -2025,11 +2026,6 @@ extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
 extern int generic_update_time(struct inode *, struct timespec *, int);
 
-static inline struct inode *file_inode(const struct file *f)
-{
-	return f->f_inode;
-}
-
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 

commit 29d01b22eaa18d8b46091d3c98c6001c49f78e4a
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Sat Jul 11 06:43:02 2015 -0400

    locks: new helpers - flock_lock_inode_wait and posix_lock_inode_wait
    
    Allow callers to pass in an inode instead of a filp.
    
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
    Reviewed-by: "J. Bruce Fields" <bfields@fieldses.org>
    Tested-by: "J. Bruce Fields" <bfields@fieldses.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a0653e560c26..4c990edd1377 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1046,11 +1046,13 @@ extern void locks_remove_file(struct file *);
 extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
+extern int posix_lock_inode_wait(struct inode *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
+extern int flock_lock_inode_wait(struct inode *inode, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
@@ -1137,6 +1139,12 @@ static inline int posix_lock_file(struct file *filp, struct file_lock *fl,
 	return -ENOLCK;
 }
 
+static inline int posix_lock_inode_wait(struct inode *inode,
+					struct file_lock *fl)
+{
+	return -ENOLCK;
+}
+
 static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
 {
 	return -ENOLCK;
@@ -1163,6 +1171,12 @@ static inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)
 	return 0;
 }
 
+static inline int flock_lock_inode_wait(struct inode *inode,
+					struct file_lock *request)
+{
+	return -ENOLCK;
+}
+
 static inline int flock_lock_file_wait(struct file *filp,
 				       struct file_lock *request)
 {

commit 90f8572b0f021fdd1baa68e00a8c30482ee9e5f4
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Jun 29 14:42:03 2015 -0500

    vfs: Commit to never having exectuables on proc and sysfs.
    
    Today proc and sysfs do not contain any executable files.  Several
    applications today mount proc or sysfs without noexec and nosuid and
    then depend on there being no exectuables files on proc or sysfs.
    Having any executable files show on proc or sysfs would cause
    a user space visible regression, and most likely security problems.
    
    Therefore commit to never allowing executables on proc and sysfs by
    adding a new flag to mark them as filesystems without executables and
    enforce that flag.
    
    Test the flag where MNT_NOEXEC is tested today, so that the only user
    visible effect will be that exectuables will be treated as if the
    execute bit is cleared.
    
    The filesystems proc and sysfs do not currently incoporate any
    executable files so this does not result in any user visible effects.
    
    This makes it unnecessary to vet changes to proc and sysfs tightly for
    adding exectuable files or changes to chattr that would modify
    existing files, as no matter what the individual file say they will
    not be treated as exectuable files by the vfs.
    
    Not having to vet changes to closely is important as without this we
    are only one proc_create call (or another goof up in the
    implementation of notify_change) from having problematic executables
    on proc.  Those mistakes are all too easy to make and would create
    a situation where there are security issues or the assumptions of
    some program having to be broken (and cause userspace regressions).
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a0653e560c26..42912f8d286e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1244,6 +1244,7 @@ struct mm_struct;
 
 /* sb->s_iflags */
 #define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
+#define SB_I_NOEXEC	0x00000002	/* Ignore executables on this fs */
 
 /* Possible states of 'frozen' field */
 enum {
@@ -3030,4 +3031,6 @@ static inline bool dir_relax(struct inode *inode)
 	return !IS_DEADDIR(inode);
 }
 
+extern bool path_noexec(const struct path *path);
+
 #endif /* _LINUX_FS_H */

commit 1dc51b8288007753ad7cd7d08bb8fa930fc8bb10
Merge: 9b284cbdb5de 0f1db7dee200
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 4 19:36:06 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs updates from Al Viro:
     "Assorted VFS fixes and related cleanups (IMO the most interesting in
      that part are f_path-related things and Eric's descriptor-related
      stuff).  UFS regression fixes (it got broken last cycle).  9P fixes.
      fs-cache series, DAX patches, Jan's file_remove_suid() work"
    
    [ I'd say this is much more than "fixes and related cleanups".  The
      file_table locking rule change by Eric Dumazet is a rather big and
      fundamental update even if the patch isn't huge.   - Linus ]
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (49 commits)
      9p: cope with bogus responses from server in p9_client_{read,write}
      p9_client_write(): avoid double p9_free_req()
      9p: forgetting to cancel request on interrupted zero-copy RPC
      dax: bdev_direct_access() may sleep
      block: Add support for DAX reads/writes to block devices
      dax: Use copy_from_iter_nocache
      dax: Add block size note to documentation
      fs/file.c: __fget() and dup2() atomicity rules
      fs/file.c: don't acquire files->file_lock in fd_install()
      fs:super:get_anon_bdev: fix race condition could cause dev exceed its upper limitation
      vfs: avoid creation of inode number 0 in get_next_ino
      namei: make set_root_rcu() return void
      make simple_positive() public
      ufs: use dir_pages instead of ufs_dir_pages()
      pagemap.h: move dir_pages() over there
      remove the pointless include of lglock.h
      fs: cleanup slight list_entry abuse
      xfs: Correctly lock inode when removing suid and file capabilities
      fs: Call security_ops->inode_killpriv on truncate
      fs: Provide function telling whether file_remove_privs() will do anything
      ...

commit 0cbee992696236227a7ea411e4b0fbf73b918b6a
Merge: 2fee94b74b45 93e3bce6287e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 3 15:20:57 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace updates from Eric Biederman:
     "Long ago and far away when user namespaces where young it was realized
      that allowing fresh mounts of proc and sysfs with only user namespace
      permissions could violate the basic rule that only root gets to decide
      if proc or sysfs should be mounted at all.
    
      Some hacks were put in place to reduce the worst of the damage could
      be done, and the common sense rule was adopted that fresh mounts of
      proc and sysfs should allow no more than bind mounts of proc and
      sysfs.  Unfortunately that rule has not been fully enforced.
    
      There are two kinds of gaps in that enforcement.  Only filesystems
      mounted on empty directories of proc and sysfs should be ignored but
      the test for empty directories was insufficient.  So in my tree
      directories on proc, sysctl and sysfs that will always be empty are
      created specially.  Every other technique is imperfect as an ordinary
      directory can have entries added even after a readdir returns and
      shows that the directory is empty.  Special creation of directories
      for mount points makes the code in the kernel a smidge clearer about
      it's purpose.  I asked container developers from the various container
      projects to help test this and no holes were found in the set of mount
      points on proc and sysfs that are created specially.
    
      This set of changes also starts enforcing the mount flags of fresh
      mounts of proc and sysfs are consistent with the existing mount of
      proc and sysfs.  I expected this to be the boring part of the work but
      unfortunately unprivileged userspace winds up mounting fresh copies of
      proc and sysfs with noexec and nosuid clear when root set those flags
      on the previous mount of proc and sysfs.  So for now only the atime,
      read-only and nodev attributes which userspace happens to keep
      consistent are enforced.  Dealing with the noexec and nosuid
      attributes remains for another time.
    
      This set of changes also addresses an issue with how open file
      descriptors from /proc/<pid>/ns/* are displayed.  Recently readlink of
      /proc/<pid>/fd has been triggering a WARN_ON that has not been
      meaningful since it was added (as all of the code in the kernel was
      converted) and is not now actively wrong.
    
      There is also a short list of issues that have not been fixed yet that
      I will mention briefly.
    
      It is possible to rename a directory from below to above a bind mount.
      At which point any directory pointers below the renamed directory can
      be walked up to the root directory of the filesystem.  With user
      namespaces enabled a bind mount of the bind mount can be created
      allowing the user to pick a directory whose children they can rename
      to outside of the bind mount.  This is challenging to fix and doubly
      so because all obvious solutions must touch code that is in the
      performance part of pathname resolution.
    
      As mentioned above there is also a question of how to ensure that
      developers by accident or with purpose do not introduce exectuable
      files on sysfs and proc and in doing so introduce security regressions
      in the current userspace that will not be immediately obvious and as
      such are likely to require breaking userspace in painful ways once
      they are recognized"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      vfs: Remove incorrect debugging WARN in prepend_path
      mnt: Update fs_fully_visible to test for permanently empty directories
      sysfs: Create mountpoints with sysfs_create_mount_point
      sysfs: Add support for permanently empty directories to serve as mount points.
      kernfs: Add support for always empty directories.
      proc: Allow creating permanently empty directories that serve as mount points
      sysctl: Allow creating permanently empty directories that serve as mountpoints.
      fs: Add helper functions for permanently empty directories.
      vfs: Ignore unlocked mounts in fs_fully_visible
      mnt: Modify fs_fully_visible to deal with locked ro nodev and atime
      mnt: Refactor the logic for mounting sysfs and proc in a user namespace

commit fbabfd0f4ee2e8847bf56edf481249ad1bb8c44d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat May 9 15:54:49 2015 -0500

    fs: Add helper functions for permanently empty directories.
    
    To ensure it is safe to mount proc and sysfs I need to check if
    filesystems that are mounted on top of them are mounted on truly empty
    directories.  Given that some directories can gain entries over time,
    knowing that a directory is empty right now is insufficient.
    
    Therefore add supporting infrastructure for permantently empty
    directories that proc and sysfs can use when they create mount points
    for filesystems and fs_fully_visible can use to test for permanently
    empty directories to ensure that nothing will be gained by mounting a
    fresh copy of proc or sysfs.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2d24eeb8e59c..571aab91bfc0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2780,6 +2780,8 @@ extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned in
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
 extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;
+extern void make_empty_dir_inode(struct inode *inode);
+extern bool is_empty_dir_inode(struct inode *inode);
 struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
 extern int simple_fill_super(struct super_block *, unsigned long, struct tree_descr *);

commit 68b4449d79f00dc3cb6ea1f4bf54cf8e453a53c8
Merge: 043cd0495043 de50e16ffabf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 30 20:16:08 2015 -0700

    Merge tag 'xfs-for-linus-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs
    
    Pul xfs updates from Dave Chinner:
     "There's a couple of small API changes to the core DAX code which
      required small changes to the ext2 and ext4 code bases, but otherwise
      everything is within the XFS codebase.
    
      This update contains:
    
       - A new sparse on-disk inode record format to allow small extents to
         be used for inode allocation when free space is fragmented.
    
       - DAX support.  This includes minor changes to the DAX core code to
         fix problems with lock ordering and bufferhead mapping abuse.
    
       - transaction commit interface cleanup
    
       - removal of various unnecessary XFS specific type definitions
    
       - cleanup and optimisation of freelist preparation before allocation
    
       - various minor cleanups
    
       - bug fixes for
            - transaction reservation leaks
            - incorrect inode logging in unwritten extent conversion
            - mmap lock vs freeze ordering
            - remote symlink mishandling
            - attribute fork removal issues"
    
    * tag 'xfs-for-linus-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs: (49 commits)
      xfs: don't truncate attribute extents if no extents exist
      xfs: clean up XFS_MIN_FREELIST macros
      xfs: sanitise error handling in xfs_alloc_fix_freelist
      xfs: factor out free space extent length check
      xfs: xfs_alloc_fix_freelist() can use incore perag structures
      xfs: remove xfs_caddr_t
      xfs: use void pointers in log validation helpers
      xfs: return a void pointer from xfs_buf_offset
      xfs: remove inst_t
      xfs: remove __psint_t and __psunsigned_t
      xfs: fix remote symlinks on V5/CRC filesystems
      xfs: fix xfs_log_done interface
      xfs: saner xfs_trans_commit interface
      xfs: remove the flags argument to xfs_trans_cancel
      xfs: pass a boolean flag to xfs_trans_free_items
      xfs: switch remaining xfs_trans_dup users to xfs_trans_roll
      xfs: check min blks for random debug mode sparse allocations
      xfs: fix sparse inodes 32-bit compile failure
      xfs: add initial DAX support
      xfs: add DAX IO path support
      ...

commit e4bc13adfd016fc1036838170288b5680d1a98b0
Merge: ad90fb97515b 3e1534cf4a2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 25 16:00:17 2015 -0700

    Merge branch 'for-4.2/writeback' of git://git.kernel.dk/linux-block
    
    Pull cgroup writeback support from Jens Axboe:
     "This is the big pull request for adding cgroup writeback support.
    
      This code has been in development for a long time, and it has been
      simmering in for-next for a good chunk of this cycle too.  This is one
      of those problems that has been talked about for at least half a
      decade, finally there's a solution and code to go with it.
    
      Also see last weeks writeup on LWN:
    
            http://lwn.net/Articles/648292/"
    
    * 'for-4.2/writeback' of git://git.kernel.dk/linux-block: (85 commits)
      writeback, blkio: add documentation for cgroup writeback support
      vfs, writeback: replace FS_CGROUP_WRITEBACK with SB_I_CGROUPWB
      writeback: do foreign inode detection iff cgroup writeback is enabled
      v9fs: fix error handling in v9fs_session_init()
      bdi: fix wrong error return value in cgwb_create()
      buffer: remove unusued 'ret' variable
      writeback: disassociate inodes from dying bdi_writebacks
      writeback: implement foreign cgroup inode bdi_writeback switching
      writeback: add lockdep annotation to inode_to_wb()
      writeback: use unlocked_inode_to_wb transaction in inode_congested()
      writeback: implement unlocked_inode_to_wb transaction and use it for stat updates
      writeback: implement [locked_]inode_to_wb_and_lock_list()
      writeback: implement foreign cgroup inode detection
      writeback: make writeback_control track the inode being written back
      writeback: relocate wb[_try]_get(), wb_put(), inode_{attach|detach}_wb()
      mm: vmscan: disable memcg direct reclaim stalling if cgroup writeback support is in use
      writeback: implement memcg writeback domain based throttling
      writeback: reset wb_domain->dirty_limit[_tstmp] when memcg domain size changes
      writeback: implement memcg wb_domain
      writeback: update wb_over_bg_thresh() to use wb_domain aware operations
      ...

commit bfffa1cc9db8a950dd4b1a09999f8a20e69a6652
Merge: cc8a0a943948 ae994ea97247
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 25 14:29:53 2015 -0700

    Merge branch 'for-4.2/core' of git://git.kernel.dk/linux-block
    
    Pull core block IO update from Jens Axboe:
     "Nothing really major in here, mostly a collection of smaller
      optimizations and cleanups, mixed with various fixes.  In more detail,
      this contains:
    
       - Addition of policy specific data to blkcg for block cgroups.  From
         Arianna Avanzini.
    
       - Various cleanups around command types from Christoph.
    
       - Cleanup of the suspend block I/O path from Christoph.
    
       - Plugging updates from Shaohua and Jeff Moyer, for blk-mq.
    
       - Eliminating atomic inc/dec of both remaining IO count and reference
         count in a bio.  From me.
    
       - Fixes for SG gap and chunk size support for data-less (discards)
         IO, so we can merge these better.  From me.
    
       - Small restructuring of blk-mq shared tag support, freeing drivers
         from iterating hardware queues.  From Keith Busch.
    
       - A few cfq-iosched tweaks, from Tahsin Erdogan and me.  Makes the
         IOPS mode the default for non-rotational storage"
    
    * 'for-4.2/core' of git://git.kernel.dk/linux-block: (35 commits)
      cfq-iosched: fix other locations where blkcg_to_cfqgd() can return NULL
      cfq-iosched: fix sysfs oops when attempting to read unconfigured weights
      cfq-iosched: move group scheduling functions under ifdef
      cfq-iosched: fix the setting of IOPS mode on SSDs
      blktrace: Add blktrace.c to BLOCK LAYER in MAINTAINERS file
      block, cgroup: implement policy-specific per-blkcg data
      block: Make CFQ default to IOPS mode on SSDs
      block: add blk_set_queue_dying() to blkdev.h
      blk-mq: Shared tag enhancements
      block: don't honor chunk sizes for data-less IO
      block: only honor SG gap prevention for merges that contain data
      block: fix returnvar.cocci warnings
      block, dm: don't copy bios for request clones
      block: remove management of bi_remaining when restoring original bi_end_io
      block: replace trylock with mutex_lock in blkdev_reread_part()
      block: export blkdev_reread_part() and __blkdev_reread_part()
      suspend: simplify block I/O handling
      block: collapse bio bit space
      block: remove unused BIO_RW_BLOCK and BIO_EOF flags
      block: remove BIO_EOPNOTSUPP
      ...

commit 45f147a1bc97c743c6101a8d2741c69a51f583e4
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 21 16:05:55 2015 +0200

    fs: Call security_ops->inode_killpriv on truncate
    
    Comment in include/linux/security.h says that ->inode_killpriv() should
    be called when setuid bit is being removed and that similar security
    labels (in fact this applies only to file capabilities) should be
    removed at this time as well. However we don't call ->inode_killpriv()
    when we remove suid bit on truncate.
    
    We fix the problem by calling ->inode_need_killpriv() and subsequently
    ->inode_killpriv() on truncate the same way as we do it on file write.
    
    After this patch there's only one user of should_remove_suid() - ocfs2 -
    and indeed it's buggy because it doesn't call ->inode_killpriv() on
    write. However fixing it is difficult because of special locking
    constraints.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ee60e8ab210f..1e658b11c265 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2554,7 +2554,11 @@ extern struct inode *new_inode(struct super_block *sb);
 extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_privs(struct file *);
-extern int file_needs_remove_privs(struct file *file);
+extern int dentry_needs_remove_privs(struct dentry *dentry);
+static inline int file_needs_remove_privs(struct file *file)
+{
+	return dentry_needs_remove_privs(file->f_path.dentry);
+}
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 static inline void insert_inode_hash(struct inode *inode)

commit dbfae0cdcd87602737101d4417811f4323156b54
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 21 16:05:54 2015 +0200

    fs: Provide function telling whether file_remove_privs() will do anything
    
    Provide function telling whether file_remove_privs() will do anything.
    Currently we only have should_remove_suid() and that does something
    slightly different.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 641e68d850cf..ee60e8ab210f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2554,6 +2554,7 @@ extern struct inode *new_inode(struct super_block *sb);
 extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_privs(struct file *);
+extern int file_needs_remove_privs(struct file *file);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 static inline void insert_inode_hash(struct inode *inode)

commit 5fa8e0a1c6a762857ae67d1628c58b9a02362003
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 21 16:05:53 2015 +0200

    fs: Rename file_remove_suid() to file_remove_privs()
    
    file_remove_suid() is a misnomer since it removes also file capabilities
    stored in xattrs and sets S_NOSEC flag. Also should_remove_suid() tells
    something else than whether file_remove_suid() call is necessary which
    leads to bugs.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c135ad741a9..641e68d850cf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2553,7 +2553,7 @@ extern struct inode *new_inode_pseudo(struct super_block *sb);
 extern struct inode *new_inode(struct super_block *sb);
 extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
-extern int file_remove_suid(struct file *);
+extern int file_remove_privs(struct file *);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 static inline void insert_inode_hash(struct inode *inode)

commit 9bf39ab2adafd7cf8740859cb49e7b7952813a5d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Jun 19 10:29:13 2015 +0200

    vfs: add file_path() helper
    
    Turn
            d_path(&file->f_path, ...);
    into
            file_path(file, ...);
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2bd77e10e8e5..2c135ad741a9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2500,6 +2500,8 @@ extern struct file * open_exec(const char *);
 extern int is_subdir(struct dentry *, struct dentry *);
 extern int path_is_under(struct path *, struct path *);
 
+extern char *file_path(struct file *, char *, int);
+
 #include <linux/err.h>
 
 /* needed for stackable file system support */

commit 4bacc9c9234c7c8eec44f5ed4e960d9f96fa0f01
Author: David Howells <dhowells@redhat.com>
Date:   Thu Jun 18 14:32:31 2015 +0100

    overlayfs: Make f_path always point to the overlay and f_inode to the underlay
    
    Make file->f_path always point to the overlay dentry so that the path in
    /proc/pid/fd is correct and to ensure that label-based LSMs have access to the
    overlay as well as the underlay (path-based LSMs probably don't need it).
    
    Using my union testsuite to set things up, before the patch I see:
    
            [root@andromeda union-testsuite]# bash 5</mnt/a/foo107
            [root@andromeda union-testsuite]# ls -l /proc/$$/fd/
            ...
            lr-x------. 1 root root 64 Jun  5 14:38 5 -> /a/foo107
            [root@andromeda union-testsuite]# stat /mnt/a/foo107
            ...
            Device: 23h/35d Inode: 13381       Links: 1
            ...
            [root@andromeda union-testsuite]# stat -L /proc/$$/fd/5
            ...
            Device: 23h/35d Inode: 13381       Links: 1
            ...
    
    After the patch:
    
            [root@andromeda union-testsuite]# bash 5</mnt/a/foo107
            [root@andromeda union-testsuite]# ls -l /proc/$$/fd/
            ...
            lr-x------. 1 root root 64 Jun  5 14:22 5 -> /mnt/a/foo107
            [root@andromeda union-testsuite]# stat /mnt/a/foo107
            ...
            Device: 23h/35d Inode: 40346       Links: 1
            ...
            [root@andromeda union-testsuite]# stat -L /proc/$$/fd/5
            ...
            Device: 23h/35d Inode: 40346       Links: 1
            ...
    
    Note the change in where /proc/$$/fd/5 points to in the ls command.  It was
    pointing to /a/foo107 (which doesn't exist) and now points to /mnt/a/foo107
    (which is correct).
    
    The inode accessed, however, is the lower layer.  The union layer is on device
    25h/37d and the upper layer on 24h/36d.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b577e801b4af..2bd77e10e8e5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1641,7 +1641,6 @@ struct inode_operations {
 	int (*set_acl)(struct inode *, struct posix_acl *, int);
 
 	/* WARNING: probably going away soon, do not use! */
-	int (*dentry_open)(struct dentry *, struct file *, const struct cred *);
 } ____cacheline_aligned;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
@@ -2194,7 +2193,6 @@ extern struct file *file_open_name(struct filename *, int, umode_t);
 extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int);
-extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 

commit 46b15caa7cb19b0f6e3bc8ebaee5bc1bb2e35110
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jun 16 18:48:31 2015 -0400

    vfs, writeback: replace FS_CGROUP_WRITEBACK with SB_I_CGROUPWB
    
    FS_CGROUP_WRITEBACK indicates whether a file_system_type supports
    cgroup writeback; however, different super_blocks of the same
    file_system_type may or may not support cgroup writeback depending on
    filesystem options.  This patch replaces FS_CGROUP_WRITEBACK with a
    per-super_block flag.
    
    super_block->s_flags carries some internal flags in the high bits but
    it's exposd to userland through uapi header and running out of space
    anyway.  This patch adds a new field super_block->s_iflags to carry
    kernel-internal flags.  It is currently only used by the new
    SB_I_CGROUPWB flag whose concatenated and abbreviated name is for
    consistency with other super_block flags.
    
    ext2_fill_super() is updated to set SB_I_CGROUPWB.
    
    v2: Added super_block->s_iflags instead of stealing another high bit
        from sb->s_flags as suggested by Christoph and Jan.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: linux-fsdevel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: linux-ext4@vger.kernel.org
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b5e1dcfbc5e3..2c5e33a5b2af 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1241,6 +1241,8 @@ struct mm_struct;
 #define UMOUNT_NOFOLLOW	0x00000008	/* Don't follow symlink on umount */
 #define UMOUNT_UNUSED	0x80000000	/* Flag guaranteed to be unused */
 
+/* sb->s_iflags */
+#define SB_I_CGROUPWB	0x00000001	/* cgroup-aware writeback enabled */
 
 /* Possible states of 'frozen' field */
 enum {
@@ -1279,6 +1281,7 @@ struct super_block {
 	const struct quotactl_ops	*s_qcop;
 	const struct export_operations *s_export_op;
 	unsigned long		s_flags;
+	unsigned long		s_iflags;	/* internal SB_I_* flags */
 	unsigned long		s_magic;
 	struct dentry		*s_root;
 	struct rw_semaphore	s_umount;
@@ -1912,7 +1915,6 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
-#define FS_CGROUP_WRITEBACK	32	/* Supports cgroup-aware writeback */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);

commit ce5c5d554dc47a4fb4360c84b72231fea081e7a0
Author: Dave Chinner <dchinner@redhat.com>
Date:   Thu Jun 4 09:18:18 2015 +1000

    dax: expose __dax_fault for filesystems with locking constraints
    
    Some filesystems cannot call dax_fault() directly because they have
    different locking and/or allocation constraints in the page fault IO
    path. To handle this, we need to follow the same model as the
    generic block_page_mkwrite code, where the internals are exposed via
    __block_page_mkwrite() so that filesystems can wrap the correct
    locking and operations around the outside.
    
    This is loosely based on a patch originally from Matthew Willcox.
    Unlike the original patch, it does not change ext4 code, error
    returns or unwritten extent conversion handling.  It also adds a
    __dax_mkwrite() wrapper for .page_mkwrite implementations to do the
    right thing, too.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c9b4cca9e08d..5784377e7c56 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2630,8 +2630,11 @@ int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 int dax_truncate_page(struct inode *, loff_t from, get_block_t);
 int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
 		dax_iodone_t);
+int __dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
+		dax_iodone_t);
 int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);
-#define dax_mkwrite(vma, vmf, gb, iod)	dax_fault(vma, vmf, gb, iod)
+#define dax_mkwrite(vma, vmf, gb, iod)		dax_fault(vma, vmf, gb, iod)
+#define __dax_mkwrite(vma, vmf, gb, iod)	__dax_fault(vma, vmf, gb, iod)
 
 #ifdef CONFIG_BLOCK
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,

commit e842f2903908934187af7232fb5b21da527d1757
Author: Dave Chinner <dchinner@redhat.com>
Date:   Thu Jun 4 09:18:18 2015 +1000

    dax: don't abuse get_block mapping for endio callbacks
    
    dax_fault() currently relies on the get_block callback to attach an
    io completion callback to the mapping buffer head so that it can
    run unwritten extent conversion after zeroing allocated blocks.
    
    Instead of this hack, pass the conversion callback directly into
    dax_fault() similar to the get_block callback. When the filesystem
    allocates unwritten extents, it will set the buffer_unwritten()
    flag, and hence the dax_fault code can call the completion function
    in the contexts where it is necessary without overloading the
    mapping buffer head.
    
    Note: The changes to ext4 to use this interface are suspect at best.
    In fact, the way ext4 did this end_io assignment in the first place
    looks suspect because it only set a completion callback when there
    wasn't already some other write() call taking place on the same
    inode. The ext4 end_io code looks rather intricate and fragile with
    all it's reference counting and passing to different contexts for
    modification via inode private pointers that aren't protected by
    locks...
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 35ec87e490b1..c9b4cca9e08d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -70,6 +70,7 @@ typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
 typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private);
+typedef void (dax_iodone_t)(struct buffer_head *bh_map, int uptodate);
 
 #define MAY_EXEC		0x00000001
 #define MAY_WRITE		0x00000002
@@ -2627,9 +2628,10 @@ ssize_t dax_do_io(struct kiocb *, struct inode *, struct iov_iter *, loff_t,
 int dax_clear_blocks(struct inode *, sector_t block, long size);
 int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 int dax_truncate_page(struct inode *, loff_t from, get_block_t);
-int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
+int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
+		dax_iodone_t);
 int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);
-#define dax_mkwrite(vma, vmf, gb)	dax_fault(vma, vmf, gb)
+#define dax_mkwrite(vma, vmf, gb, iod)	dax_fault(vma, vmf, gb, iod)
 
 #ifdef CONFIG_BLOCK
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,

commit 682aa8e1a6a1504a4caaa62e6c2c9daae3757210
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 28 14:50:53 2015 -0400

    writeback: implement unlocked_inode_to_wb transaction and use it for stat updates
    
    The mechanism for detecting whether an inode should switch its wb
    (bdi_writeback) association is now in place.  This patch build the
    framework for the actual switching.
    
    This patch adds a new inode flag I_WB_SWITCHING, which has two
    functions.  First, the easy one, it ensures that there's only one
    switching in progress for a give inode.  Second, it's used as a
    mechanism to synchronize wb stat updates.
    
    The two stats, WB_RECLAIMABLE and WB_WRITEBACK, aren't event counters
    but track the current number of dirty pages and pages under writeback
    respectively.  As such, when an inode is moved from one wb to another,
    the inode's portion of those stats have to be transferred together;
    unfortunately, this is a bit tricky as those stat updates are percpu
    operations which are performed without holding any lock in some
    places.
    
    This patch solves the problem in a similar way as memcg.  Each such
    lockless stat updates are wrapped in transaction surrounded by
    unlocked_inode_to_wb_begin/end().  During normal operation, they map
    to rcu_read_lock/unlock(); however, if I_WB_SWITCHING is asserted,
    mapping->tree_lock is grabbed across the transaction.
    
    In turn, the switching path sets I_WB_SWITCHING and waits for a RCU
    grace period to pass before actually starting to switch, which
    guarantees that all stat update paths are synchronizing against
    mapping->tree_lock.
    
    This patch still doesn't implement the actual switching.
    
    v3: Updated on top of the recent cancel_dirty_page() updates.
        unlocked_inode_to_wb_begin() now nests inside
        mem_cgroup_begin_page_stat() to match the locking order.
    
    v2: The i_wb access transaction will be used for !stat accesses too.
        Function names and comments updated accordingly.
    
        s/inode_wb_stat_unlocked_{begin|end}/unlocked_inode_to_wb_{begin|end}/
        s/switch_wb/switch_wbs/
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Greg Thelen <gthelen@google.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 740126d7c44e..b5e1dcfbc5e3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1815,6 +1815,11 @@ struct super_operations {
  *
  * I_DIO_WAKEUP		Never set.  Only used as a key for wait_on_bit().
  *
+ * I_WB_SWITCH		Cgroup bdi_writeback switching in progress.  Used to
+ *			synchronize competing switching instances and to tell
+ *			wb stat updates to grab mapping->tree_lock.  See
+ *			inode_switch_wb_work_fn() for details.
+ *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
 #define I_DIRTY_SYNC		(1 << 0)
@@ -1834,6 +1839,7 @@ struct super_operations {
 #define I_DIRTY_TIME		(1 << 11)
 #define __I_DIRTY_TIME_EXPIRED	12
 #define I_DIRTY_TIME_EXPIRED	(1 << __I_DIRTY_TIME_EXPIRED)
+#define I_WB_SWITCH		(1 << 13)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 #define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)

commit 2a81490811d0296d390c571bb64eaa93e5ed7def
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 28 14:50:51 2015 -0400

    writeback: implement foreign cgroup inode detection
    
    As concurrent write sharing of an inode is expected to be very rare
    and memcg only tracks page ownership on first-use basis severely
    confining the usefulness of such sharing, cgroup writeback tracks
    ownership per-inode.  While the support for concurrent write sharing
    of an inode is deemed unnecessary, an inode being written to by
    different cgroups at different points in time is a lot more common,
    and, more importantly, charging only by first-use can too readily lead
    to grossly incorrect behaviors (single foreign page can lead to
    gigabytes of writeback to be incorrectly attributed).
    
    To resolve this issue, cgroup writeback detects the majority dirtier
    of an inode and will transfer the ownership to it.  To avoid
    unnnecessary oscillation, the detection mechanism keeps track of
    history and gives out the switch verdict only if the foreign usage
    pattern is stable over a certain amount of time and/or writeback
    attempts.
    
    The detection mechanism has fairly low space and computation overhead.
    It adds 8 bytes to struct inode (one int and two u16's) and minimal
    amount of calculation per IO.  The detection mechanism converges to
    the correct answer usually in several seconds of IO time when there's
    a clear majority dirtier.  Even when there isn't, it can reach an
    acceptable answer fairly quickly under most circumstances.
    
    Please see wb_detach_inode() for more details.
    
    This patch only implements detection.  Following patches will
    implement actual switching.
    
    v2: wbc_account_io() now checks whether the wbc is associated with a
        wb before dereferencing it.  This can happen when pageout() is
        writing pages directly without going through the usual writeback
        path.  As pageout() path is single-threaded, we don't want it to
        be blocked behind a slow cgroup and ultimately want it to delegate
        actual writing to the usual writeback path.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Greg Thelen <gthelen@google.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 67a42ec95065..740126d7c44e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -638,6 +638,11 @@ struct inode {
 	struct list_head	i_wb_list;	/* backing dev IO list */
 #ifdef CONFIG_CGROUP_WRITEBACK
 	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */
+
+	/* foreign inode detection, see wbc_detach_inode() */
+	int			i_wb_frn_winner;
+	u16			i_wb_frn_avg_time;
+	u16			i_wb_frn_history;
 #endif
 	struct list_head	i_lru;		/* inode LRU list */
 	struct list_head	i_sb_list;

commit 52ebea749aaed195245701a8f90a23d672c7a933
Author: Tejun Heo <tj@kernel.org>
Date:   Fri May 22 17:13:37 2015 -0400

    writeback: make backing_dev_info host cgroup-specific bdi_writebacks
    
    For the planned cgroup writeback support, on each bdi
    (backing_dev_info), each memcg will be served by a separate wb
    (bdi_writeback).  This patch updates bdi so that a bdi can host
    multiple wbs (bdi_writebacks).
    
    On the default hierarchy, blkcg implicitly enables memcg.  This allows
    using memcg's page ownership for attributing writeback IOs, and every
    memcg - blkcg combination can be served by its own wb by assigning a
    dedicated wb to each memcg.  This means that there may be multiple
    wb's of a bdi mapped to the same blkcg.  As congested state is per
    blkcg - bdi combination, those wb's should share the same congested
    state.  This is achieved by tracking congested state via
    bdi_writeback_congested structs which are keyed by blkcg.
    
    bdi->wb remains unchanged and will keep serving the root cgroup.
    cgwb's (cgroup wb's) for non-root cgroups are created on-demand or
    looked up while dirtying an inode according to the memcg of the page
    being dirtied or current task.  Each cgwb is indexed on bdi->cgwb_tree
    by its memcg id.  Once an inode is associated with its wb, it can be
    retrieved using inode_to_wb().
    
    Currently, none of the filesystems has FS_CGROUP_WRITEBACK and all
    pages will keep being associated with bdi->wb.
    
    v3: inode_attach_wb() in account_page_dirtied() moved inside
        mapping_cap_account_dirty() block where it's known to be !NULL.
        Also, an unnecessary NULL check before kfree() removed.  Both
        detected by the kbuild bot.
    
    v2: Updated so that wb association is per inode and wb is per memcg
        rather than blkcg.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: kbuild test robot <fengguang.wu@intel.com>
    Cc: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 74e0ae0626a8..67a42ec95065 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -35,6 +35,7 @@
 #include <uapi/linux/fs.h>
 
 struct backing_dev_info;
+struct bdi_writeback;
 struct export_operations;
 struct hd_geometry;
 struct iovec;
@@ -635,6 +636,9 @@ struct inode {
 
 	struct hlist_node	i_hash;
 	struct list_head	i_wb_list;	/* backing dev IO list */
+#ifdef CONFIG_CGROUP_WRITEBACK
+	struct bdi_writeback	*i_wb;		/* the associated cgroup wb */
+#endif
 	struct list_head	i_lru;		/* inode LRU list */
 	struct list_head	i_sb_list;
 	union {

commit 89e9b9e07a390c50980d10aa37a04631db5a23ab
Author: Tejun Heo <tj@kernel.org>
Date:   Fri May 22 17:13:36 2015 -0400

    writeback: add {CONFIG|BDI_CAP|FS}_CGROUP_WRITEBACK
    
    cgroup writeback requires support from both bdi and filesystem sides.
    Add BDI_CAP_CGROUP_WRITEBACK and FS_CGROUP_WRITEBACK to indicate
    support and enable BDI_CAP_CGROUP_WRITEBACK on block based bdi's by
    default.  Also, define CONFIG_CGROUP_WRITEBACK which is enabled if
    both MEMCG and BLK_CGROUP are enabled.
    
    inode_cgwb_enabled() which determines whether a given inode's both bdi
    and fs support cgroup writeback is added.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ce100b87fba3..74e0ae0626a8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1897,6 +1897,7 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
+#define FS_CGROUP_WRITEBACK	32	/* Supports cgroup-aware writeback */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);

commit a212b105b07d75b48b1a166378282e8a77fbf53d
Author: Tejun Heo <tj@kernel.org>
Date:   Fri May 22 17:13:33 2015 -0400

    bdi: make inode_to_bdi() inline
    
    Now that bdi definitions are moved to backing-dev-defs.h,
    backing-dev.h can include blkdev.h and inline inode_to_bdi() without
    worrying about introducing circular include dependency.  The function
    gets called from hot paths and fairly trivial.
    
    This patch makes inode_to_bdi() and sb_is_blkdev_sb() that the
    function calls inline.  blockdev_superblock and noop_backing_dev_info
    are EXPORT_GPL'd to allow the inline functions to be used from
    modules.
    
    While at it, make sb_is_blkdev_sb() return bool instead of int.
    
    v2: Fixed typo in description as suggested by Jan.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ef63900243c..ce100b87fba3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2240,7 +2240,13 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
-extern int sb_is_blkdev_sb(struct super_block *sb);
+
+extern struct super_block *blockdev_superblock;
+
+static inline bool sb_is_blkdev_sb(struct super_block *sb)
+{
+	return sb == blockdev_superblock;
+}
 #else
 static inline void bd_forget(struct inode *inode) {}
 static inline int sync_blockdev(struct block_device *bdev) { return 0; }

commit be32417796c2b8a83fe4cbece83bea96ab9e378f
Author: Jarod Wilson <jarod@redhat.com>
Date:   Wed May 6 12:26:22 2015 +0800

    block: export blkdev_reread_part() and __blkdev_reread_part()
    
    This patch exports blkdev_reread_part() for block drivers, also
    introduce __blkdev_reread_part().
    
    For some drivers, such as loop, reread of partitions can be run
    from the release path, and bd_mutex may already be held prior to
    calling ioctl_by_bdev(bdev, BLKRRPART, 0), so introduce
    __blkdev_reread_part for use in such cases.
    
    CC: Christoph Hellwig <hch@lst.de>
    CC: Jens Axboe <axboe@kernel.dk>
    CC: Tejun Heo <tj@kernel.org>
    CC: Alexander Viro <viro@zeniv.linux.org.uk>
    CC: Markus Pargmann <mpa@pengutronix.de>
    CC: Stefan Weinhuber <wein@de.ibm.com>
    CC: Stefan Haberland <stefan.haberland@de.ibm.com>
    CC: Sebastian Ott <sebott@linux.vnet.ibm.com>
    CC: Fabian Frederick <fabf@skynet.be>
    CC: Ming Lei <ming.lei@canonical.com>
    CC: David Herrmann <dh.herrmann@gmail.com>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Peter Zijlstra <peterz@infradead.org>
    CC: nbd-general@lists.sourceforge.net
    CC: linux-s390@vger.kernel.org
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 35ec87e490b1..1ef63900243c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2279,6 +2279,9 @@ extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
 extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
 					      void *holder);
 extern void blkdev_put(struct block_device *bdev, fmode_t mode);
+extern int __blkdev_reread_part(struct block_device *bdev);
+extern int blkdev_reread_part(struct block_device *bdev);
+
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
 extern void bd_unlink_disk_holder(struct block_device *bdev,

commit 89076bc31950eee576ecc06460c23466e2d50939
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue May 12 08:29:38 2015 -0400

    get rid of assorted nameidata-related debris
    
    pointless forward declarations, stale comments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1426c435d455..b577e801b4af 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -38,7 +38,6 @@ struct backing_dev_info;
 struct export_operations;
 struct hd_geometry;
 struct iovec;
-struct nameidata;
 struct kiocb;
 struct kobject;
 struct pipe_inode_info;

commit 8fa9dd24667f2d6997ec21341019657342859d31
Author: NeilBrown <neilb@suse.de>
Date:   Mon Mar 23 13:37:40 2015 +1100

    VFS/namei: make the use of touch_atime() in get_link() RCU-safe.
    
    touch_atime is not RCU-safe, and so cannot be called on an RCU walk.
    However, in situations where RCU-walk makes a difference, the symlink
    will likely to accessed much more often than it is useful to update
    the atime.
    
    So split out the test of "Does the atime actually need to be updated"
    into  atime_needs_update(), and have get_link() unlazy if it finds that
    it will need to do that update.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8f738512c874..1426c435d455 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1880,6 +1880,7 @@ enum file_time_flags {
 	S_VERSION = 8,
 };
 
+extern bool atime_needs_update(const struct path *, struct inode *);
 extern void touch_atime(const struct path *);
 static inline void file_accessed(struct file *file)
 {

commit 1b852bceb0d111e510d1a15826ecc4a19358d512
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri May 8 23:22:29 2015 -0500

    mnt: Refactor the logic for mounting sysfs and proc in a user namespace
    
    Fresh mounts of proc and sysfs are a very special case that works very
    much like a bind mount.  Unfortunately the current structure can not
    preserve the MNT_LOCK... mount flags.  Therefore refactor the logic
    into a form that can be modified to preserve those lock bits.
    
    Add a new filesystem flag FS_USERNS_VISIBLE that requires some mount
    of the filesystem be fully visible in the current mount namespace,
    before the filesystem may be mounted.
    
    Move the logic for calling fs_fully_visible from proc and sysfs into
    fs/namespace.c where it has greater access to mount namespace state.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 35ec87e490b1..2d24eeb8e59c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1897,6 +1897,7 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
+#define FS_USERNS_VISIBLE	32	/* FS must already be visible */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
@@ -1984,7 +1985,6 @@ extern int vfs_ustat(dev_t, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
-extern bool fs_fully_visible(struct file_system_type *);
 
 extern int current_umask(void);
 

commit ecc087ff14352aed52b8e775b4511e7f9cfc64ec
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 7 11:19:14 2015 -0400

    new helper: free_page_put_link()
    
    similar to kfree_put_link()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f21e3328f991..8f738512c874 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2712,6 +2712,7 @@ extern int __page_symlink(struct inode *inode, const char *symname, int len,
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern void kfree_put_link(struct inode *, void *);
+extern void free_page_put_link(struct inode *, void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat);

commit 5f2c4179e129bdc47870a81a65d0aff85aa18293
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 7 11:14:26 2015 -0400

    switch ->put_link() from dentry to inode
    
    only one instance looks at that argument at all; that sole
    exception wants inode rather than dentry.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed7c9f298759..f21e3328f991 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1613,7 +1613,7 @@ struct inode_operations {
 	struct posix_acl * (*get_acl)(struct inode *, int);
 
 	int (*readlink) (struct dentry *, char __user *,int);
-	void (*put_link) (struct dentry *, void *);
+	void (*put_link) (struct inode *, void *);
 
 	int (*create) (struct inode *,struct dentry *, umode_t, bool);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
@@ -2706,12 +2706,12 @@ extern const struct file_operations generic_ro_fops;
 extern int readlink_copy(char __user *, int, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
 extern const char *page_follow_link_light(struct dentry *, void **);
-extern void page_put_link(struct dentry *, void *);
+extern void page_put_link(struct inode *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
-extern void kfree_put_link(struct dentry *, void *);
+extern void kfree_put_link(struct inode *, void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat);

commit 6e77137b363b8d866ac29c5a0c95e953614fb2d8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 13:37:52 2015 -0400

    don't pass nameidata to ->follow_link()
    
    its only use is getting passed to nd_jump_link(), which can obtain
    it from current->nameidata
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab934113a28..ed7c9f298759 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1608,7 +1608,7 @@ struct file_operations {
 
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
-	const char * (*follow_link) (struct dentry *, void **, struct nameidata *);
+	const char * (*follow_link) (struct dentry *, void **);
 	int (*permission) (struct inode *, int);
 	struct posix_acl * (*get_acl)(struct inode *, int);
 
@@ -2705,7 +2705,7 @@ extern const struct file_operations generic_ro_fops;
 
 extern int readlink_copy(char __user *, int, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
-extern const char *page_follow_link_light(struct dentry *, void **, struct nameidata *);
+extern const char *page_follow_link_light(struct dentry *, void **);
 extern void page_put_link(struct dentry *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		int nofs);
@@ -2722,7 +2722,7 @@ void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
-const char *simple_follow_link(struct dentry *, void **, struct nameidata *);
+const char *simple_follow_link(struct dentry *, void **);
 extern const struct inode_operations simple_symlink_inode_operations;
 
 extern int iterate_dir(struct file *, struct dir_context *);

commit 680baacbca69d18a6d7315374ad83d05ac9c0977
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 13:32:22 2015 -0400

    new ->follow_link() and ->put_link() calling conventions
    
    a) instead of storing the symlink body (via nd_set_link()) and returning
    an opaque pointer later passed to ->put_link(), ->follow_link() _stores_
    that opaque pointer (into void * passed by address by caller) and returns
    the symlink body.  Returning ERR_PTR() on error, NULL on jump (procfs magic
    symlinks) and pointer to symlink body for normal symlinks.  Stored pointer
    is ignored in all cases except the last one.
    
    Storing NULL for opaque pointer (or not storing it at all) means no call
    of ->put_link().
    
    b) the body used to be passed to ->put_link() implicitly (via nameidata).
    Now only the opaque pointer is.  In the cases when we used the symlink body
    to free stuff, ->follow_link() now should store it as opaque pointer in addition
    to returning it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0ac758fcff00..9ab934113a28 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1608,12 +1608,12 @@ struct file_operations {
 
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
-	void * (*follow_link) (struct dentry *, struct nameidata *);
+	const char * (*follow_link) (struct dentry *, void **, struct nameidata *);
 	int (*permission) (struct inode *, int);
 	struct posix_acl * (*get_acl)(struct inode *, int);
 
 	int (*readlink) (struct dentry *, char __user *,int);
-	void (*put_link) (struct dentry *, struct nameidata *, void *);
+	void (*put_link) (struct dentry *, void *);
 
 	int (*create) (struct inode *,struct dentry *, umode_t, bool);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
@@ -2705,13 +2705,13 @@ extern const struct file_operations generic_ro_fops;
 
 extern int readlink_copy(char __user *, int, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
-extern void *page_follow_link_light(struct dentry *, struct nameidata *);
-extern void page_put_link(struct dentry *, struct nameidata *, void *);
+extern const char *page_follow_link_light(struct dentry *, void **, struct nameidata *);
+extern void page_put_link(struct dentry *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
-extern void kfree_put_link(struct dentry *, struct nameidata *, void *);
+extern void kfree_put_link(struct dentry *, void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 int vfs_getattr_nosec(struct path *path, struct kstat *stat);
@@ -2722,7 +2722,7 @@ void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
-void *simple_follow_link(struct dentry *, struct nameidata *);
+const char *simple_follow_link(struct dentry *, void **, struct nameidata *);
 extern const struct inode_operations simple_symlink_inode_operations;
 
 extern int iterate_dir(struct file *, struct dir_context *);

commit 61ba64fc0768879a300599b011c176203bdf27d9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat May 2 09:54:06 2015 -0400

    libfs: simple_follow_link()
    
    let "fast" symlinks store the pointer to the body into ->i_link and
    use simple_follow_link for ->follow_link()
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 35ec87e490b1..0ac758fcff00 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -656,6 +656,7 @@ struct inode {
 		struct pipe_inode_info	*i_pipe;
 		struct block_device	*i_bdev;
 		struct cdev		*i_cdev;
+		char			*i_link;
 	};
 
 	__u32			i_generation;
@@ -2721,6 +2722,8 @@ void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
+void *simple_follow_link(struct dentry *, struct nameidata *);
+extern const struct inode_operations simple_symlink_inode_operations;
 
 extern int iterate_dir(struct file *, struct dir_context *);
 

commit 9ec3a646fe09970f801ab15e0f1694060b9f19af
Merge: c8b3fd0ce313 3cab989afd8d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 26 15:48:49 2015 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull fourth vfs update from Al Viro:
     "d_inode() annotations from David Howells (sat in for-next since before
      the beginning of merge window) + four assorted fixes"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      RCU pathwalk breakage when running into a symlink overmounting something
      fix I_DIO_WAKEUP definition
      direct-io: only inc/dec inode->i_dio_count for file systems
      fs/9p: fix readdir()
      VFS: assorted d_backing_inode() annotations
      VFS: fs/inode.c helpers: d_inode() annotations
      VFS: fs/cachefiles: d_backing_inode() annotations
      VFS: fs library helpers: d_inode() annotations
      VFS: assorted weird filesystems: d_inode() annotations
      VFS: normal filesystems (and lustre): d_inode() annotations
      VFS: security/: d_inode() annotations
      VFS: security/: d_backing_inode() annotations
      VFS: net/: d_inode() annotations
      VFS: net/unix: d_backing_inode() annotations
      VFS: kernel/: d_inode() annotations
      VFS: audit: d_backing_inode() annotations
      VFS: Fix up some ->d_inode accesses in the chelsio driver
      VFS: Cachefiles should perform fs modifications on the top layer only
      VFS: AF_UNIX sockets should call mknod on the top layer only

commit ac74d8d65c83d8061034d0908e1eab6a0c24f923
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Thu Apr 16 15:04:56 2015 -0500

    fix I_DIO_WAKEUP definition
    
    I_DIO_WAKEUP is never directly used, but fix it up anyway.
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9055eefa92c7..43565607088e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1812,7 +1812,7 @@ struct super_operations {
 #define I_SYNC			(1 << __I_SYNC)
 #define I_REFERENCED		(1 << 8)
 #define __I_DIO_WAKEUP		9
-#define I_DIO_WAKEUP		(1 << I_DIO_WAKEUP)
+#define I_DIO_WAKEUP		(1 << __I_DIO_WAKEUP)
 #define I_LINKABLE		(1 << 10)
 #define I_DIRTY_TIME		(1 << 11)
 #define __I_DIRTY_TIME_EXPIRED	12

commit fe0f07d08ee35fb13d2cb048970072fe4f71ad14
Author: Jens Axboe <axboe@fb.com>
Date:   Wed Apr 15 17:05:48 2015 -0600

    direct-io: only inc/dec inode->i_dio_count for file systems
    
    do_blockdev_direct_IO() increments and decrements the inode
    ->i_dio_count for each IO operation. It does this to protect against
    truncate of a file. Block devices don't need this sort of protection.
    
    For a capable multiqueue setup, this atomic int is the only shared
    state between applications accessing the device for O_DIRECT, and it
    presents a scaling wall for that. In my testing, as much as 30% of
    system time is spent incrementing and decrementing this value. A mixed
    read/write workload improved from ~2.5M IOPS to ~9.6M IOPS, with
    better latencies too. Before:
    
    clat percentiles (usec):
     |  1.00th=[   33],  5.00th=[   34], 10.00th=[   34], 20.00th=[   34],
     | 30.00th=[   34], 40.00th=[   34], 50.00th=[   35], 60.00th=[   35],
     | 70.00th=[   35], 80.00th=[   35], 90.00th=[   37], 95.00th=[   80],
     | 99.00th=[   98], 99.50th=[  151], 99.90th=[  155], 99.95th=[  155],
     | 99.99th=[  165]
    
    After:
    
    clat percentiles (usec):
     |  1.00th=[   95],  5.00th=[  108], 10.00th=[  129], 20.00th=[  149],
     | 30.00th=[  155], 40.00th=[  161], 50.00th=[  167], 60.00th=[  171],
     | 70.00th=[  177], 80.00th=[  185], 90.00th=[  201], 95.00th=[  270],
     | 99.00th=[  390], 99.50th=[  398], 99.90th=[  418], 99.95th=[  422],
     | 99.99th=[  438]
    
    In other setups, Robert Elliott reported seeing good performance
    improvements:
    
    https://lkml.org/lkml/2015/4/3/557
    
    The more applications accessing the device, the worse it gets.
    
    Add a new direct-io flags, DIO_SKIP_DIO_COUNT, which tells
    do_blockdev_direct_IO() that it need not worry about incrementing
    or decrementing the inode i_dio_count for this caller.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Elliott, Robert (Server Storage) <elliott@hp.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jens Axboe <axboe@fb.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b1d7db28c13c..9055eefa92c7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2635,6 +2635,9 @@ enum {
 
 	/* filesystem can handle aio writes beyond i_size */
 	DIO_ASYNC_EXTEND = 0x04,
+
+	/* inode/fs/bdev does not need truncate protection */
+	DIO_SKIP_DIO_COUNT = 0x08,
 };
 
 void dio_end_io(struct bio *bio, int error);
@@ -2657,7 +2660,31 @@ static inline ssize_t blockdev_direct_IO(struct kiocb *iocb,
 #endif
 
 void inode_dio_wait(struct inode *inode);
-void inode_dio_done(struct inode *inode);
+
+/*
+ * inode_dio_begin - signal start of a direct I/O requests
+ * @inode: inode the direct I/O happens on
+ *
+ * This is called once we've finished processing a direct I/O request,
+ * and is used to wake up callers waiting for direct I/O to be quiesced.
+ */
+static inline void inode_dio_begin(struct inode *inode)
+{
+	atomic_inc(&inode->i_dio_count);
+}
+
+/*
+ * inode_dio_end - signal finish of a direct I/O requests
+ * @inode: inode the direct I/O happens on
+ *
+ * This is called once we've finished processing a direct I/O request,
+ * and is used to wake up callers waiting for direct I/O to be quiesced.
+ */
+static inline void inode_dio_end(struct inode *inode)
+{
+	if (atomic_dec_and_test(&inode->i_dio_count))
+		wake_up_bit(&inode->i_state, __I_DIO_WAKEUP);
+}
 
 extern void inode_set_flags(struct inode *inode, unsigned int flags,
 			    unsigned int mask);

commit 54e514b91b95d6441c12a7955addfb9f9d2afc65
Merge: 4fc8adcfec3d 6c8c90319c0b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 17 09:04:38 2015 -0400

    Merge branch 'akpm' (patches from Andrew)
    
    Merge third patchbomb from Andrew Morton:
    
     - various misc things
    
     - a couple of lib/ optimisations
    
     - provide DIV_ROUND_CLOSEST_ULL()
    
     - checkpatch updates
    
     - rtc tree
    
     - befs, nilfs2, hfs, hfsplus, fatfs, adfs, affs, bfs
    
     - ptrace fixes
    
     - fork() fixes
    
     - seccomp cleanups
    
     - more mmap_sem hold time reductions from Davidlohr
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (138 commits)
      proc: show locks in /proc/pid/fdinfo/X
      docs: add missing and new /proc/PID/status file entries, fix typos
      drivers/rtc/rtc-at91rm9200.c: make IO endian agnostic
      Documentation/spi/spidev_test.c: fix warning
      drivers/rtc/rtc-s5m.c: allow usage on device type different than main MFD type
      .gitignore: ignore *.tar
      MAINTAINERS: add Mediatek SoC mailing list
      tomoyo: reduce mmap_sem hold for mm->exe_file
      powerpc/oprofile: reduce mmap_sem hold for exe_file
      oprofile: reduce mmap_sem hold for mm->exe_file
      mips: ip32: add platform data hooks to use DS1685 driver
      lib/Kconfig: fix up HAVE_ARCH_BITREVERSE help text
      x86: switch to using asm-generic for seccomp.h
      sparc: switch to using asm-generic for seccomp.h
      powerpc: switch to using asm-generic for seccomp.h
      parisc: switch to using asm-generic for seccomp.h
      mips: switch to using asm-generic for seccomp.h
      microblaze: use asm-generic for seccomp.h
      arm: use asm-generic for seccomp.h
      seccomp: allow COMPAT sigreturn overrides
      ...

commit 6c8c90319c0bb1c9e0b68e721359b89ae4f28465
Author: Andrey Vagin <avagin@openvz.org>
Date:   Thu Apr 16 12:49:38 2015 -0700

    proc: show locks in /proc/pid/fdinfo/X
    
    Let's show locks which are associated with a file descriptor in
    its fdinfo file.
    
    Currently we don't have a reliable way to determine who holds a lock.  We
    can find some information in /proc/locks, but PID which is reported there
    can be wrong.  For example, a process takes a lock, then forks a child and
    dies.  In this case /proc/locks contains the parent pid, which can be
    reused by another process.
    
    $ cat /proc/locks
    ...
    6: FLOCK  ADVISORY  WRITE 324 00:13:13431 0 EOF
    ...
    
    $ ps -C rpcbind
      PID TTY          TIME CMD
      332 ?        00:00:00 rpcbind
    
    $ cat /proc/332/fdinfo/4
    pos:    0
    flags:  0100000
    mnt_id: 22
    lock:   1: FLOCK  ADVISORY  WRITE 324 00:13:13431 0 EOF
    
    $ ls -l /proc/332/fd/4
    lr-x------ 1 root root 64 Mar  5 14:43 /proc/332/fd/4 -> /run/rpcbind.lock
    
    $ ls -l /proc/324/fd/
    total 0
    lrwx------ 1 root root 64 Feb 27 14:50 0 -> /dev/pts/0
    lrwx------ 1 root root 64 Feb 27 14:50 1 -> /dev/pts/0
    lrwx------ 1 root root 64 Feb 27 14:49 2 -> /dev/pts/0
    
    You can see that the process with the 324 pid doesn't hold the lock.
    
    This information is required for proper dumping and restoring file
    locks.
    
    Signed-off-by: Andrey Vagin <avagin@openvz.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Acked-by: Jeff Layton <jlayton@poochiereds.net>
    Acked-by: "J. Bruce Fields" <bfields@fieldses.org>
    Acked-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: Pavel Emelyanov <xemul@parallels.com>
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6bf7ab7c1573..c4e927358503 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1042,6 +1042,9 @@ extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
 extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
 extern int lease_modify(struct file_lock *, int, struct list_head *);
+struct files_struct;
+extern void show_fd_locks(struct seq_file *f,
+			 struct file *filp, struct files_struct *files);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, unsigned int cmd,
 			      struct flock __user *user)
@@ -1178,6 +1181,10 @@ static inline int lease_modify(struct file_lock *fl, int arg,
 {
 	return -EINVAL;
 }
+
+struct files_struct;
+static inline void show_fd_locks(struct seq_file *f,
+			struct file *filp, struct files_struct *files) {}
 #endif /* !CONFIG_FILE_LOCKING */
 
 

commit 90f31d0ea88880f780574f3d0bb1a227c4c66ca3
Author: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
Date:   Thu Apr 16 12:47:56 2015 -0700

    mm: rcu-protected get_mm_exe_file()
    
    This patch removes mm->mmap_sem from mm->exe_file read side.
    Also it kills dup_mm_exe_file() and moves exe_file duplication into
    dup_mmap() where both mmap_sems are locked.
    
    [akpm@linux-foundation.org: fix comment typo]
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f4fc60727b8d..6bf7ab7c1573 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -870,6 +870,7 @@ static inline struct file *get_file(struct file *f)
 	atomic_long_inc(&f->f_count);
 	return f;
 }
+#define get_file_rcu(x) atomic_long_inc_not_zero(&(x)->f_count)
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 

commit 4fc8adcfec3da639da76e8314c9ccefe5bf9a045
Merge: 84588e7a5d82 aa4d86163e4e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 16 23:27:56 2015 -0400

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull third hunk of vfs changes from Al Viro:
     "This contains the ->direct_IO() changes from Omar + saner
      generic_write_checks() + dealing with fcntl()/{read,write}() races
      (mirroring O_APPEND/O_DIRECT into iocb->ki_flags and instead of
      repeatedly looking at ->f_flags, which can be changed by fcntl(2),
      check ->ki_flags - which cannot) + infrastructure bits for dhowells'
      d_inode annotations + Christophs switch of /dev/loop to
      vfs_iter_write()"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (30 commits)
      block: loop: switch to VFS ITER_BVEC
      configfs: Fix inconsistent use of file_inode() vs file->f_path.dentry->d_inode
      VFS: Make pathwalk use d_is_reg() rather than S_ISREG()
      VFS: Fix up debugfs to use d_is_dir() in place of S_ISDIR()
      VFS: Combine inode checks with d_is_negative() and d_is_positive() in pathwalk
      NFS: Don't use d_inode as a variable name
      VFS: Impose ordering on accesses of d_inode and d_flags
      VFS: Add owner-filesystem positive/negative dentry checks
      nfs: generic_write_checks() shouldn't be done on swapout...
      ocfs2: use __generic_file_write_iter()
      mirror O_APPEND and O_DIRECT into iocb->ki_flags
      switch generic_write_checks() to iocb and iter
      ocfs2: move generic_write_checks() before the alignment checks
      ocfs2_file_write_iter: stop messing with ppos
      udf_file_write_iter: reorder and simplify
      fuse: ->direct_IO() doesn't need generic_write_checks()
      ext4_file_write_iter: move generic_write_checks() up
      xfs_file_aio_write_checks: switch to iocb/iov_iter
      generic_write_checks(): drop isblk argument
      blkdev_write_iter: expand generic_file_checks() call in there
      ...

commit eea3a00264cf243a28e4331566ce67b86059339d
Merge: e7c82412433a e693d73c20ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 15 16:39:15 2015 -0700

    Merge branch 'akpm' (patches from Andrew)
    
    Merge second patchbomb from Andrew Morton:
    
     - the rest of MM
    
     - various misc bits
    
     - add ability to run /sbin/reboot at reboot time
    
     - printk/vsprintf changes
    
     - fiddle with seq_printf() return value
    
    * akpm: (114 commits)
      parisc: remove use of seq_printf return value
      lru_cache: remove use of seq_printf return value
      tracing: remove use of seq_printf return value
      cgroup: remove use of seq_printf return value
      proc: remove use of seq_printf return value
      s390: remove use of seq_printf return value
      cris fasttimer: remove use of seq_printf return value
      cris: remove use of seq_printf return value
      openrisc: remove use of seq_printf return value
      ARM: plat-pxa: remove use of seq_printf return value
      nios2: cpuinfo: remove use of seq_printf return value
      microblaze: mb: remove use of seq_printf return value
      ipc: remove use of seq_printf return value
      rtc: remove use of seq_printf return value
      power: wakeup: remove use of seq_printf return value
      x86: mtrr: if: remove use of seq_printf return value
      linux/bitmap.h: improve BITMAP_{LAST,FIRST}_WORD_MASK
      MAINTAINERS: CREDITS: remove Stefano Brivio from B43
      .mailmap: add Ricardo Ribalda
      CREDITS: add Ricardo Ribalda Delgado
      ...

commit 0e3b210ce1722168227cb3bc7746256d0c0afece
Author: Boaz Harrosh <boaz@plexistor.com>
Date:   Wed Apr 15 16:15:14 2015 -0700

    dax: use pfn_mkwrite to update c/mtime + freeze protection
    
    From: Yigal Korman <yigal@plexistor.com>
    
    [v1]
    Without this patch, c/mtime is not updated correctly when mmap'ed page is
    first read from and then written to.
    
    A new xfstest is submitted for testing this (generic/080)
    
    [v2]
    Jan Kara has pointed out that if we add the
    sb_start/end_pagefault pair in the new pfn_mkwrite we
    are then fixing another bug where: A user could start
    writing to the page while filesystem is frozen.
    
    Signed-off-by: Yigal Korman <yigal@plexistor.com>
    Signed-off-by: Boaz Harrosh <boaz@plexistor.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 60733bdc74b4..0f696328f218 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2620,6 +2620,7 @@ int dax_clear_blocks(struct inode *, sector_t block, long size);
 int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 int dax_truncate_page(struct inode *, loff_t from, get_block_t);
 int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
+int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);
 #define dax_mkwrite(vma, vmf, gb)	dax_fault(vma, vmf, gb)
 
 #ifdef CONFIG_BLOCK

commit f2b91d8d385d2cef3a1e3b3846f2dde4a6720c43
Author: Zhang Zhen <zhenzhang.zhang@huawei.com>
Date:   Wed Apr 15 16:12:51 2015 -0700

    vfs: delete vfs_readdir function declaration
    
    vfs_readdir() was replaced by iterate_dir() in commit 5c0ba4e0762e
    ("[readdir] introduce iterate_dir() and dir_context").
    
    Signed-off-by: Zhang Zhen <zhenzhang.zhang@huawei.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d502e5436c84..60733bdc74b4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2684,7 +2684,6 @@ void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
 
-extern int vfs_readdir(struct file *, filldir_t, void *);
 extern int iterate_dir(struct file *, struct dir_context *);
 
 extern int vfs_stat(const char __user *, struct kstat *);

commit 6d50ff91d9780263160262daeb6adfdda8ddbc6c
Merge: eccd02f32a2c 0429c2b5c1c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 15 14:22:45 2015 -0700

    Merge tag 'locks-v4.1-1' of git://git.samba.org/jlayton/linux
    
    Pull file locking related changes from Jeff Layton:
     "This set is mostly minor cleanups to the overhaul that went in last
      cycle.  The other noticeable items are the changes to the lm_get_owner
      and lm_put_owner prototypes, and the fact that we no longer need to
      use the i_lock to protect the i_flctx pointer"
    
    * tag 'locks-v4.1-1' of git://git.samba.org/jlayton/linux:
      locks: use cmpxchg to assign i_flctx pointer
      locks: get rid of WE_CAN_BREAK_LSLK_NOW dead code
      locks: change lm_get_owner and lm_put_owner prototypes
      locks: don't allocate a lock context for an F_UNLCK request
      locks: Add lockdep assertion for blocked_lock_lock
      locks: remove extraneous IS_POSIX and IS_FLOCK tests
      locks: Remove unnecessary IS_POSIX test

commit fa927894bbb4a4c7669c72bad1924991022fda38
Merge: c841e12add69 8436318205b9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 15 13:22:56 2015 -0700

    Merge branch 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull second vfs update from Al Viro:
     "Now that net-next went in...  Here's the next big chunk - killing
      ->aio_read() and ->aio_write().
    
      There'll be one more pile today (direct_IO changes and
      generic_write_checks() cleanups/fixes), but I'd prefer to keep that
      one separate"
    
    * 'for-linus-2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (37 commits)
      ->aio_read and ->aio_write removed
      pcm: another weird API abuse
      infinibad: weird APIs switched to ->write_iter()
      kill do_sync_read/do_sync_write
      fuse: use iov_iter_get_pages() for non-splice path
      fuse: switch to ->read_iter/->write_iter
      switch drivers/char/mem.c to ->read_iter/->write_iter
      make new_sync_{read,write}() static
      coredump: accept any write method
      switch /dev/loop to vfs_iter_write()
      serial2002: switch to __vfs_read/__vfs_write
      ashmem: use __vfs_read()
      export __vfs_read()
      autofs: switch to __vfs_write()
      new helper: __vfs_write()
      switch hugetlbfs to ->read_iter()
      coda: switch to ->read_iter/->write_iter
      ncpfs: switch to ->read_iter/->write_iter
      net/9p: remove (now-)unused helpers
      p9_client_attach(): set fid->uid correctly
      ...

commit ca2ec32658db160745990496f0f4580056a5dc9f
Merge: 6c8a53c9e6a1 fdc81f45e9f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 15:31:03 2015 -0700

    Merge branch 'for-linus-1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs update from Al Viro:
     "Part one:
    
       - struct filename-related cleanups
    
       - saner iov_iter_init() replacements (and switching the syscalls to
         use of those)
    
       - ntfs switch to ->write_iter() (Anton)
    
       - aio cleanups and splitting iocb into common and async parts
         (Christoph)
    
       - assorted fixes (me, bfields, Andrew Elble)
    
      There's a lot more, including the completion of switchover to
      ->{read,write}_iter(), d_inode/d_backing_inode annotations, f_flags
      race fixes, etc, but that goes after #for-davem merge.  David has
      pulled it, and once it's in I'll send the next vfs pull request"
    
    * 'for-linus-1' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (35 commits)
      sg_start_req(): use import_iovec()
      sg_start_req(): make sure that there's not too many elements in iovec
      blk_rq_map_user(): use import_single_range()
      sg_io(): use import_iovec()
      process_vm_access: switch to {compat_,}import_iovec()
      switch keyctl_instantiate_key_common() to iov_iter
      switch {compat_,}do_readv_writev() to {compat_,}import_iovec()
      aio_setup_vectored_rw(): switch to {compat_,}import_iovec()
      vmsplice_to_user(): switch to import_iovec()
      kill aio_setup_single_vector()
      aio: simplify arguments of aio_setup_..._rw()
      aio: lift iov_iter_init() into aio_setup_..._rw()
      lift iov_iter into {compat_,}do_readv_writev()
      NFS: fix BUG() crash in notify_change() with patch to chown_common()
      dcache: return -ESTALE not -EBUSY on distributed fs race
      NTFS: Version 2.1.32 - Update file write from aio_write to write_iter.
      VFS: Add iov_iter_fault_in_multipages_readable()
      drop bogus check in file_open_root()
      switch security_inode_getattr() to struct path *
      constify tomoyo_realpath_from_path()
      ...

commit 2ba48ce513c4e545318d22b138861d5876edf906
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 9 13:52:01 2015 -0400

    mirror O_APPEND and O_DIRECT into iocb->ki_flags
    
    ... avoiding write_iter/fcntl races.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b4aa400ac723..b1d7db28c13c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -315,6 +315,8 @@ struct address_space;
 struct writeback_control;
 
 #define IOCB_EVENTFD		(1 << 0)
+#define IOCB_APPEND		(1 << 1)
+#define IOCB_DIRECT		(1 << 2)
 
 struct kiocb {
 	struct file		*ki_filp;
@@ -329,10 +331,13 @@ static inline bool is_sync_kiocb(struct kiocb *kiocb)
 	return kiocb->ki_complete == NULL;
 }
 
+static inline int iocb_flags(struct file *file);
+
 static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
 {
 	*kiocb = (struct kiocb) {
 		.ki_filp = filp,
+		.ki_flags = iocb_flags(filp),
 	};
 }
 
@@ -2779,6 +2784,16 @@ static inline bool io_is_direct(struct file *filp)
 	return (filp->f_flags & O_DIRECT) || IS_DAX(file_inode(filp));
 }
 
+static inline int iocb_flags(struct file *file)
+{
+	int res = 0;
+	if (file->f_flags & O_APPEND)
+		res |= IOCB_APPEND;
+	if (io_is_direct(file))
+		res |= IOCB_DIRECT;
+	return res;
+}
+
 static inline ino_t parent_ino(struct dentry *dentry)
 {
 	ino_t res;

commit 3309dd04cbcd2cdad168485af5cf3576b5051e49
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 9 12:55:47 2015 -0400

    switch generic_write_checks() to iocb and iter
    
    ... returning -E... upon error and amount of data left in iter after
    (possible) truncation upon success.  Note, that normal case gives
    a non-zero (positive) return value, so any tests for != 0 _must_ be
    updated.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    
    Conflicts:
            fs/ext4/file.c

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c7b21db7782f..b4aa400ac723 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2566,7 +2566,7 @@ extern int sb_min_blocksize(struct super_block *, int);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
-int generic_write_checks(struct file *file, loff_t *pos, size_t *count);
+extern ssize_t generic_write_checks(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit dfea934575164497a9e36074ebce606a1a278ed9
Merge: 165f1a6e300d 64b4e2526d1c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 11 22:29:51 2015 -0400

    Merge branch 'for-linus' into for-next

commit 0fa6b005afdb3152ce85df963302e59b61115f9b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 4 04:05:48 2015 -0400

    generic_write_checks(): drop isblk argument
    
    all remaining callers are passing 0; some just obscure that fact.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 72e3759de8c3..492948ea4c9b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2566,7 +2566,7 @@ extern int sb_min_blocksize(struct super_block *, int);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
-int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
+int generic_write_checks(struct file *file, loff_t *pos, size_t *count);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit 22c6186ecea0be9eff1c399298ad36e94a59995f
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon Mar 16 04:33:53 2015 -0700

    direct_IO: remove rw from a_ops->direct_IO()
    
    Now that no one is using rw, remove it completely.
    
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 295bc589fe1b..72e3759de8c3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -383,7 +383,7 @@ struct address_space_operations {
 	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 	int (*releasepage) (struct page *, gfp_t);
 	void (*freepage)(struct page *);
-	ssize_t (*direct_IO)(int, struct kiocb *, struct iov_iter *iter, loff_t offset);
+	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter, loff_t offset);
 	/*
 	 * migrate the contents of a page to the specified target. If
 	 * migrate_mode is MIGRATE_ASYNC, it must not block.

commit a95cd6311512bd954e88684eb39373f7f4b0a984
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon Mar 16 04:33:51 2015 -0700

    Remove rw from dax_{do_,}io()
    
    And use iov_iter_rw() instead.
    
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c67b6de8be33..295bc589fe1b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2609,8 +2609,8 @@ extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
-ssize_t dax_do_io(int rw, struct kiocb *, struct inode *, struct iov_iter *,
-		loff_t, get_block_t, dio_iodone_t, int flags);
+ssize_t dax_do_io(struct kiocb *, struct inode *, struct iov_iter *, loff_t,
+		  get_block_t, dio_iodone_t, int flags);
 int dax_clear_blocks(struct inode *, sector_t block, long size);
 int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 int dax_truncate_page(struct inode *, loff_t from, get_block_t);

commit 17f8c842d24ac054e4212c82b5bd6ae455a334f3
Author: Omar Sandoval <osandov@osandov.com>
Date:   Mon Mar 16 04:33:50 2015 -0700

    Remove rw from {,__,do_}blockdev_direct_IO()
    
    Most filesystems call through to these at some point, so we'll start
    here.
    
    Signed-off-by: Omar Sandoval <osandov@osandov.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f1e3f65255a8..c67b6de8be33 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2634,16 +2634,18 @@ enum {
 
 void dio_end_io(struct bio *bio, int error);
 
-ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
-	struct block_device *bdev, struct iov_iter *iter, loff_t offset,
-	get_block_t get_block, dio_iodone_t end_io,
-	dio_submit_t submit_io,	int flags);
-
-static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
-		struct inode *inode, struct iov_iter *iter, loff_t offset,
-		get_block_t get_block)
-{
-	return __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iter,
+ssize_t __blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,
+			     struct block_device *bdev, struct iov_iter *iter,
+			     loff_t offset, get_block_t get_block,
+			     dio_iodone_t end_io, dio_submit_t submit_io,
+			     int flags);
+
+static inline ssize_t blockdev_direct_IO(struct kiocb *iocb,
+					 struct inode *inode,
+					 struct iov_iter *iter, loff_t offset,
+					 get_block_t get_block)
+{
+	return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter,
 				    offset, get_block, NULL, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }

commit 8436318205b9f29e45db88850ec60e326327e241
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 4 01:14:53 2015 -0400

    ->aio_read and ->aio_write removed
    
    no remaining users
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 83e122c1a902..f1e3f65255a8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1562,8 +1562,6 @@ struct file_operations {
 	loff_t (*llseek) (struct file *, loff_t, int);
 	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
-	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
-	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
 	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 	int (*iterate) (struct file *, struct dir_context *);

commit 9a219bc70b54523c8f14a3c957179854785ee97c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 3 22:10:20 2015 -0400

    kill do_sync_read/do_sync_write
    
    all remaining instances of aio_{read,write} (all 4 of them) have explicit
    ->read and ->write resp.; do_sync_read/do_sync_write is never called by
    __vfs_read/__vfs_write anymore and no other users had been left.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cade1304d27b..83e122c1a902 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2574,8 +2574,6 @@ extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff_t);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
-extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
-extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 
 ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos);
 ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos);

commit 5d5d568975307877e9195f5305f4240e506a2807
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 3 15:41:18 2015 -0400

    make new_sync_{read,write}() static
    
    All places outside of core VFS that checked ->read and ->write for being NULL or
    called the methods directly are gone now, so NULL {read,write} with non-NULL
    {read,write}_iter will do the right thing in all cases.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a1cb00bd805..cade1304d27b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2576,8 +2576,6 @@ extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
-extern ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
-extern ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 
 ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos);
 ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos);

commit 493c84c0722ac991a96df2fd6c7798b2126b626c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 3 15:06:43 2015 -0400

    new helper: __vfs_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 20fe15fe236d..4a1cb00bd805 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1639,6 +1639,7 @@ ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      struct iovec **ret_pointer);
 
 extern ssize_t __vfs_read(struct file *, char __user *, size_t, loff_t *);
+extern ssize_t __vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,

commit 39c853ebfe169f187a760b34f9cbf54751bfce00
Merge: fdc81f45e9f5 01e97e651705
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 11 22:27:19 2015 -0400

    Merge branch 'for-davem' into for-next

commit c0fec3a98bd6c4d992f191ee1aa0b3599213f3d4
Merge: c1b8940b42bb e2e40f2c1ed4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 11 22:24:41 2015 -0400

    Merge branch 'iocb' into for-next

commit fd2f7cb5bcac58b63717cd45366bff9a6ab961c6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 22 20:07:13 2015 -0500

    kill struct filename.separate
    
    just make const char iname[] the last member and compare name->name with
    name->iname instead of checking name->separate
    
    We need to make sure that out-of-line name doesn't end up allocated adjacent
    to struct filename refering to it; fortunately, it's easy to achieve - just
    allocate that struct filename with one byte in ->iname[], so that ->iname[0]
    will be inside the same object and thus have an address different from that
    of out-of-line name [spotted by Boqun Feng <boqun.feng@gmail.com>]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b4d71b5e1ff2..d70e333988f1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2144,7 +2144,7 @@ struct filename {
 	const __user char	*uptr;	/* original userland pointer */
 	struct audit_names	*aname;
 	int			refcnt;
-	bool			separate; /* should "name" be freed? */
+	const char		iname[];
 };
 
 extern long vfs_truncate(struct path *, loff_t);

commit 237dae889051ed4ebf438b08ca6c0e7c54b97774
Merge: 7abccdba25be e2e40f2c1ed4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 9 00:00:30 2015 -0400

    Merge branch 'iocb' into for-davem
    
    trivial conflict in net/socket.c and non-trivial one in crypto -
    that one had evaded aio_complete() removal.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

commit b2edffdd912b4205899a8efa0974dfbbc3216109
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 6 17:48:54 2015 -0400

    fix mremap() vs. ioctx_kill() race
    
    teach ->mremap() method to return an error and have it fail for
    aio mappings in process of being killed
    
    Note that in case of ->mremap() failure we need to undo move_page_tables()
    we'd already done; we could call ->mremap() first, but then the failure of
    move_page_tables() would require undoing whatever _successful_ ->mremap()
    has done, which would be a lot more headache in general.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f4131e8ead74..52cc4492cb3a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1549,7 +1549,7 @@ struct file_operations {
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);
-	void (*mremap)(struct file *, struct vm_area_struct *);
+	int (*mremap)(struct file *, struct vm_area_struct *);
 	int (*open) (struct inode *, struct file *);
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);

commit cae80b305e1c3944746dd93e33e9b2ccd5a490c1
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Fri Apr 3 09:04:04 2015 -0400

    locks: change lm_get_owner and lm_put_owner prototypes
    
    The current prototypes for these operations are somewhat awkward as they
    deal with fl_owners but take struct file_lock arguments. In the future,
    we'll want to be able to take references without necessarily dealing
    with a struct file_lock.
    
    Change them to take fl_owner_t arguments instead and have the callers
    deal with assigning the values to the file_lock structs.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f4131e8ead74..e4111a29697e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -893,8 +893,8 @@ struct file_lock_operations {
 struct lock_manager_operations {
 	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
 	unsigned long (*lm_owner_key)(struct file_lock *);
-	void (*lm_get_owner)(struct file_lock *, struct file_lock *);
-	void (*lm_put_owner)(struct file_lock *);
+	fl_owner_t (*lm_get_owner)(fl_owner_t);
+	void (*lm_put_owner)(fl_owner_t);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, int);
 	bool (*lm_break)(struct file_lock *);

commit e2e40f2c1ed433c5e224525c8c862fd32e5d3df2
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Feb 22 08:58:50 2015 -0800

    fs: move struct kiocb to fs.h
    
    struct kiocb now is a generic I/O container, so move it to fs.h.
    Also do a #include diet for aio.h while we're at it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 447932aed1e1..48c1472bde4a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -314,6 +314,28 @@ struct page;
 struct address_space;
 struct writeback_control;
 
+#define IOCB_EVENTFD		(1 << 0)
+
+struct kiocb {
+	struct file		*ki_filp;
+	loff_t			ki_pos;
+	void (*ki_complete)(struct kiocb *iocb, long ret, long ret2);
+	void			*private;
+	int			ki_flags;
+};
+
+static inline bool is_sync_kiocb(struct kiocb *kiocb)
+{
+	return kiocb->ki_complete == NULL;
+}
+
+static inline void init_sync_kiocb(struct kiocb *kiocb, struct file *filp)
+{
+	*kiocb = (struct kiocb) {
+		.ki_filp = filp,
+	};
+}
+
 /*
  * "descriptor" for what we're up to with a read.
  * This allows us to use the same read code yet

commit a2f4870697a5bcf4a87073ec6b32dd2928c1211d
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Tue Mar 17 12:23:19 2015 -0400

    fs: make sure the timestamps for lazytime inodes eventually get written
    
    Jan Kara pointed out that if there is an inode which is constantly
    getting dirtied with I_DIRTY_PAGES, an inode with an updated timestamp
    will never be written since inode->dirtied_when is constantly getting
    updated.  We fix this by adding an extra field to the inode,
    dirtied_time_when, so inodes with a stale dirtytime can get detected
    and handled.
    
    In addition, if we have a dirtytime inode caused by an atime update,
    and there is no write activity on the file system, we need to have a
    secondary system to make sure these inodes get written out.  We do
    this by setting up a second delayed work structure which wakes up the
    CPU much more rarely compared to writeback_expire_centisecs.
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Reviewed-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b4d71b5e1ff2..f4131e8ead74 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -604,6 +604,7 @@ struct inode {
 	struct mutex		i_mutex;
 
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
+	unsigned long		dirtied_time_when;
 
 	struct hlist_node	i_hash;
 	struct list_head	i_wb_list;	/* backing dev IO list */

commit b2b89ebfc0f0287e20516a5443d93af309b800cf
Merge: eaa0eda56223 2e2f756f81ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 18 10:21:47 2015 -0800

    Merge tag 'locks-v3.20-2' of git://git.samba.org/jlayton/linux
    
    Pull file locking fixes from Jeff Layton:
     "A small set of patches to fix problems with the recent file locking
      changes that we discussed earlier this week"
    "
    
    * tag 'locks-v3.20-2' of git://git.samba.org/jlayton/linux:
      locks: fix list insertion when lock is split in two
      locks: remove conditional lock release in middle of flock_lock_file
      locks: only remove leases associated with the file being closed
      Revert "locks: keep a count of locks on the flctx lists"

commit 038911597e17017cee55fe93d521164a27056866
Merge: 66dc830d14a2 a26f49926da9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 16:12:34 2015 -0800

    Merge branch 'lazytime' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull lazytime mount option support from Al Viro:
     "Lazytime stuff from tytso"
    
    * 'lazytime' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      ext4: add optimization for the lazytime mount option
      vfs: add find_inode_nowait() function
      vfs: add support for a lazytime mount option

commit 66dc830d14a222c9214a8557e9feb1e4a67a3857
Merge: 05016b0f0a9d dbe4e192a234
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 15:48:33 2015 -0800

    Merge branch 'iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull iov_iter updates from Al Viro:
     "More iov_iter work - missing counterpart of iov_iter_init() for
      bvec-backed ones and vfs_read_iter()/vfs_write_iter() - wrappers for
      sync calls of ->read_iter()/->write_iter()"
    
    * 'iov_iter' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fs: add vfs_iter_{read,write} helpers
      new helper: iov_iter_bvec()

commit 05016b0f0a9d900e976db7f50a7761c0aefe5a1c
Merge: c6b1de1b646f 55422d0bd292
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 17 15:27:47 2015 -0800

    Merge branch 'getname2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull getname/putname updates from Al Viro:
     "Rework of getname/getname_kernel/etc., mostly from Paul Moore.  Gets
      rid of quite a pile of kludges between namei and audit..."
    
    * 'getname2' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      audit: replace getname()/putname() hacks with reference counters
      audit: fix filename matching in __audit_inode() and __audit_inode_child()
      audit: enable filename recording via getname_kernel()
      simpler calling conventions for filename_mountpoint()
      fs: create proper filename objects using getname_kernel()
      fs: rework getname_kernel to handle up to PATH_MAX sized filenames
      cut down the number of do_path_lookup() callers

commit 25726bc15731d42112b579cf73f30edbc43d3973
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:59:35 2015 -0800

    dax: add dax_zero_page_range
    
    This new function allows us to support hole-punch for DAX files by zeroing
    a partial page, as opposed to the dax_truncate_page() function which can
    only truncate to the end of the page.  Reimplement dax_truncate_page() to
    call dax_zero_page_range().
    
    [ross.zwisler@linux.intel.com: ported to 3.13-rc2]
    [akpm@linux-foundation.org: fix typos in comments]
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d46f8fe6a0ea..ed5a0900b94d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2589,6 +2589,7 @@ extern int nonseekable_open(struct inode * inode, struct file * filp);
 ssize_t dax_do_io(int rw, struct kiocb *, struct inode *, struct iov_iter *,
 		loff_t, get_block_t, dio_iodone_t, int flags);
 int dax_clear_blocks(struct inode *, sector_t block, long size);
+int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
 int dax_truncate_page(struct inode *, loff_t from, get_block_t);
 int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
 #define dax_mkwrite(vma, vmf, gb)	dax_fault(vma, vmf, gb)

commit 6cd176a51e52e5218b1aa97e1ec916bac25a9b7e
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:59:25 2015 -0800

    vfs,ext2: remove CONFIG_EXT2_FS_XIP and rename CONFIG_FS_XIP to CONFIG_FS_DAX
    
    The fewer Kconfig options we have the better.  Use the generic
    CONFIG_FS_DAX to enable XIP support in ext2 as well as in the core.
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9772d655f444..d46f8fe6a0ea 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1676,7 +1676,7 @@ struct super_operations {
 #define S_IMA		1024	/* Inode has an associated IMA struct */
 #define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
 #define S_NOSEC		4096	/* no suid or xattr security attributes */
-#ifdef CONFIG_FS_XIP
+#ifdef CONFIG_FS_DAX
 #define S_DAX		8192	/* Direct Access, avoiding the page cache */
 #else
 #define S_DAX		0	/* Make all the DAX code disappear */

commit e748dcd095ddee50e7a7deda2e26247715318a2e
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:59:12 2015 -0800

    vfs: remove get_xip_mem
    
    All callers of get_xip_mem() are now gone.  Remove checks for it,
    initialisers of it, documentation of it and the only implementation of it.
     Also remove mm/filemap_xip.c as it is now empty.  Also remove
    documentation of the long-gone get_xip_page().
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c8f9055af38..9772d655f444 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -362,8 +362,6 @@ struct address_space_operations {
 	int (*releasepage) (struct page *, gfp_t);
 	void (*freepage)(struct page *);
 	ssize_t (*direct_IO)(int, struct kiocb *, struct iov_iter *iter, loff_t offset);
-	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
-						void **, unsigned long *);
 	/*
 	 * migrate the contents of a page to the specified target. If
 	 * migrate_mode is MIGRATE_ASYNC, it must not block.

commit 4c0ccfef2e9f7418a6eb0bf07a2fc8f216365b18
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:59:06 2015 -0800

    dax,ext2: replace xip_truncate_page with dax_truncate_page
    
    It takes a get_block parameter just like nobh_truncate_page() and
    block_truncate_page()
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6bad6d4c579b..2c8f9055af38 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2591,18 +2591,10 @@ extern int nonseekable_open(struct inode * inode, struct file * filp);
 ssize_t dax_do_io(int rw, struct kiocb *, struct inode *, struct iov_iter *,
 		loff_t, get_block_t, dio_iodone_t, int flags);
 int dax_clear_blocks(struct inode *, sector_t block, long size);
+int dax_truncate_page(struct inode *, loff_t from, get_block_t);
 int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
 #define dax_mkwrite(vma, vmf, gb)	dax_fault(vma, vmf, gb)
 
-#ifdef CONFIG_FS_XIP
-extern int xip_truncate_page(struct address_space *mapping, loff_t from);
-#else
-static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
-{
-	return 0;
-}
-#endif
-
 #ifdef CONFIG_BLOCK
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
 			    loff_t file_offset);

commit f7ca90b160307d63aaedab8bd451c24a182db20f
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:59:02 2015 -0800

    dax,ext2: replace the XIP page fault handler with the DAX page fault handler
    
    Instead of calling aops->get_xip_mem from the fault handler, the
    filesystem passes a get_block_t that is used to find the appropriate
    blocks.
    
    This requires that all architectures implement copy_user_page().  At the
    time of writing, mips and arm do not.  Patches exist and are in progress.
    
    [akpm@linux-foundation.org: remap_file_pages went away]
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8084934a5676..6bad6d4c579b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -51,6 +51,7 @@ struct swap_info_struct;
 struct seq_file;
 struct workqueue_struct;
 struct iov_iter;
+struct vm_fault;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2590,9 +2591,10 @@ extern int nonseekable_open(struct inode * inode, struct file * filp);
 ssize_t dax_do_io(int rw, struct kiocb *, struct inode *, struct iov_iter *,
 		loff_t, get_block_t, dio_iodone_t, int flags);
 int dax_clear_blocks(struct inode *, sector_t block, long size);
+int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
+#define dax_mkwrite(vma, vmf, gb)	dax_fault(vma, vmf, gb)
 
 #ifdef CONFIG_FS_XIP
-extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
 extern int xip_truncate_page(struct address_space *mapping, loff_t from);
 #else
 static inline int xip_truncate_page(struct address_space *mapping, loff_t from)

commit 289c6aedac981533331428bc933fff21ae332c9e
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:58:59 2015 -0800

    dax,ext2: replace ext2_clear_xip_target with dax_clear_blocks
    
    This is practically generic code; other filesystems will want to call it
    from other places, but there's nothing ext2-specific about it.
    
    Make it a little more generic by allowing it to take a count of the number
    of bytes to zero rather than fixing it to a single page.  Thanks to Dave
    Hansen for suggesting that I need to call cond_resched() if zeroing more
    than one page.
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 241c3c030fb5..8084934a5676 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2589,6 +2589,7 @@ extern int nonseekable_open(struct inode * inode, struct file * filp);
 
 ssize_t dax_do_io(int rw, struct kiocb *, struct inode *, struct iov_iter *,
 		loff_t, get_block_t, dio_iodone_t, int flags);
+int dax_clear_blocks(struct inode *, sector_t block, long size);
 
 #ifdef CONFIG_FS_XIP
 extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);

commit d475c6346a38aef3058eba96867bfa726a3cc940
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:58:56 2015 -0800

    dax,ext2: replace XIP read and write with DAX I/O
    
    Use the generic AIO infrastructure instead of custom read and write
    methods.  In addition to giving us support for AIO, this adds the missing
    locking between read() and truncate().
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fb373bb5cf03..241c3c030fb5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2587,12 +2587,11 @@ extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
+ssize_t dax_do_io(int rw, struct kiocb *, struct inode *, struct iov_iter *,
+		loff_t, get_block_t, dio_iodone_t, int flags);
+
 #ifdef CONFIG_FS_XIP
-extern ssize_t xip_file_read(struct file *filp, char __user *buf, size_t len,
-			     loff_t *ppos);
 extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
-extern ssize_t xip_file_write(struct file *filp, const char __user *buf,
-			      size_t len, loff_t *ppos);
 extern int xip_truncate_page(struct address_space *mapping, loff_t from);
 #else
 static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
@@ -2756,6 +2755,11 @@ extern int generic_show_options(struct seq_file *m, struct dentry *root);
 extern void save_mount_options(struct super_block *sb, char *options);
 extern void replace_mount_options(struct super_block *sb, char *options);
 
+static inline bool io_is_direct(struct file *filp)
+{
+	return (filp->f_flags & O_DIRECT) || IS_DAX(file_inode(filp));
+}
+
 static inline ino_t parent_ino(struct dentry *dentry)
 {
 	ino_t res;

commit fbbbad4bc2101e452b24e6e65d3d5e11314a0b5f
Author: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date:   Mon Feb 16 15:58:53 2015 -0800

    vfs,ext2: introduce IS_DAX(inode)
    
    Use an inode flag to tag inodes which should avoid using the page cache.
    Convert ext2 to use it instead of mapping_is_xip().  Prevent I/Os to files
    tagged with the DAX flag from falling back to buffered I/O.
    
    Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
    Cc: Andreas Dilger <andreas.dilger@intel.com>
    Cc: Boaz Harrosh <boaz@plexistor.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Ross Zwisler <ross.zwisler@linux.intel.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e49f10cc8a73..fb373bb5cf03 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1677,6 +1677,11 @@ struct super_operations {
 #define S_IMA		1024	/* Inode has an associated IMA struct */
 #define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
 #define S_NOSEC		4096	/* no suid or xattr security attributes */
+#ifdef CONFIG_FS_XIP
+#define S_DAX		8192	/* Direct Access, avoiding the page cache */
+#else
+#define S_DAX		0	/* Make all the DAX code disappear */
+#endif
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -1714,6 +1719,7 @@ struct super_operations {
 #define IS_IMA(inode)		((inode)->i_flags & S_IMA)
 #define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
 #define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
+#define IS_DAX(inode)		((inode)->i_flags & S_DAX)
 
 #define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
 				 (inode)->i_rdev == WHITEOUT_DEV)

commit e084c1bd40926938ff8d26af3bde34396dd4d06d
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Mon Feb 16 14:32:03 2015 -0500

    Revert "locks: keep a count of locks on the flctx lists"
    
    This reverts commit 9bd0f45b7037fcfa8b575c7e27d0431d6e6dc3bb.
    
    Linus rightly pointed out that I failed to initialize the counters
    when adding them, so they don't work as expected. Just revert this
    patch for now.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e49f10cc8a73..a5a303e8a33c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -969,9 +969,6 @@ struct file_lock_context {
 	struct list_head	flc_flock;
 	struct list_head	flc_posix;
 	struct list_head	flc_lease;
-	int			flc_flock_cnt;
-	int			flc_posix_cnt;
-	int			flc_lease_cnt;
 };
 
 /* The following constant reflects the upper bound of the file/locking space */

commit 818099574b04c5301eacbbcd441022b353a65466
Merge: 802ea9d8645d 6016daed58ee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 18:54:28 2015 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge third set of updates from Andrew Morton:
    
     - the rest of MM
    
       [ This includes getting rid of the numa hinting bits, in favor of
         just generic protnone logic.  Yay.     - Linus ]
    
     - core kernel
    
     - procfs
    
     - some of lib/ (lots of lib/ material this time)
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (104 commits)
      lib/lcm.c: replace include
      lib/percpu_ida.c: remove redundant includes
      lib/strncpy_from_user.c: replace module.h include
      lib/stmp_device.c: replace module.h include
      lib/sort.c: move include inside #if 0
      lib/show_mem.c: remove redundant include
      lib/radix-tree.c: change to simpler include
      lib/plist.c: remove redundant include
      lib/nlattr.c: remove redundant include
      lib/kobject_uevent.c: remove redundant include
      lib/llist.c: remove redundant include
      lib/md5.c: simplify include
      lib/list_sort.c: rearrange includes
      lib/genalloc.c: remove redundant include
      lib/idr.c: remove redundant include
      lib/halfmd4.c: simplify includes
      lib/dynamic_queue_limits.c: simplify includes
      lib/sort.c: use simpler includes
      lib/interval_tree.c: simplify includes
      hexdump: make it return number of bytes placed in buffer
      ...

commit 4101b624352fddb5ed72e7a1b6f8be8cffaa20fa
Author: Vladimir Davydov <vdavydov@parallels.com>
Date:   Thu Feb 12 14:58:51 2015 -0800

    fs: consolidate {nr,free}_cached_objects args in shrink_control
    
    We are going to make FS shrinkers memcg-aware.  To achieve that, we will
    have to pass the memcg to scan to the nr_cached_objects and
    free_cached_objects VFS methods, which currently take only the NUMA node
    to scan.  Since the shrink_control structure already holds the node, and
    the memcg to scan will be added to it when we introduce memcg-aware
    vmscan, let us consolidate the methods' arguments in this structure to
    keep things clean.
    
    Signed-off-by: Vladimir Davydov <vdavydov@parallels.com>
    Suggested-by: Dave Chinner <david@fromorbit.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Glauber Costa <glommer@gmail.com>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: Pekka Enberg <penberg@kernel.org>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cdcb1e9d9613..a20d6586e517 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1635,8 +1635,10 @@ struct super_operations {
 	struct dquot **(*get_dquots)(struct inode *);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
-	long (*nr_cached_objects)(struct super_block *, int);
-	long (*free_cached_objects)(struct super_block *, long, int);
+	long (*nr_cached_objects)(struct super_block *,
+				  struct shrink_control *);
+	long (*free_cached_objects)(struct super_block *,
+				    struct shrink_control *);
 };
 
 /*

commit 6bec0035286119eefc32a5b1102127e6a4032cb2
Merge: 5d8e7fb69165 15d0f5ea348b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 13:50:21 2015 -0800

    Merge branch 'for-3.20/bdi' of git://git.kernel.dk/linux-block
    
    Pull backing device changes from Jens Axboe:
     "This contains a cleanup of how the backing device is handled, in
      preparation for a rework of the life time rules.  In this part, the
      most important change is to split the unrelated nommu mmap flags from
      it, but also removing a backing_dev_info pointer from the
      address_space (and inode), and a cleanup of other various minor bits.
    
      Christoph did all the work here, I just fixed an oops with pages that
      have a swap backing.  Arnd fixed a missing export, and Oleg killed the
      lustre backing_dev_info from staging.  Last patch was from Al,
      unexporting parts that are now no longer needed outside"
    
    * 'for-3.20/bdi' of git://git.kernel.dk/linux-block:
      Make super_blocks and sb_lock static
      mtd: export new mtd_mmap_capabilities
      fs: make inode_to_bdi() handle NULL inode
      staging/lustre/llite: get rid of backing_dev_info
      fs: remove default_backing_dev_info
      fs: don't reassign dirty inodes to default_backing_dev_info
      nfs: don't call bdi_unregister
      ceph: remove call to bdi_unregister
      fs: remove mapping->backing_dev_info
      fs: export inode_to_bdi and use it in favor of mapping->backing_dev_info
      nilfs2: set up s_bdi like the generic mount_bdev code
      block_dev: get bdev inode bdi directly from the block device
      block_dev: only write bdev inode on close
      fs: introduce f_op->mmap_capabilities for nommu mmap support
      fs: kill BDI_CAP_SWAP_BACKED
      fs: deduplicate noop_backing_dev_info

commit 61845143febe6b88349acad4732adc54894009a3
Merge: a26be149facb c23ae6017835
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 10:39:41 2015 -0800

    Merge branch 'for-3.20' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "The main change is the pNFS block server support from Christoph, which
      allows an NFS client connected to shared disk to do block IO to the
      shared disk in place of NFS reads and writes.  This also requires xfs
      patches, which should arrive soon through the xfs tree, barring
      unexpected problems.  Support for other filesystems is also possible
      if there's interest.
    
      Thanks also to Chuck Lever for continuing work to get NFS/RDMA into
      shape"
    
    * 'for-3.20' of git://linux-nfs.org/~bfields/linux: (32 commits)
      nfsd: default NFSv4.2 to on
      nfsd: pNFS block layout driver
      exportfs: add methods for block layout exports
      nfsd: add trace events
      nfsd: update documentation for pNFS support
      nfsd: implement pNFS layout recalls
      nfsd: implement pNFS operations
      nfsd: make find_any_file available outside nfs4state.c
      nfsd: make find/get/put file available outside nfs4state.c
      nfsd: make lookup/alloc/unhash_stid available outside nfs4state.c
      nfsd: add fh_fsid_match helper
      nfsd: move nfsd_fh_match to nfsfh.h
      fs: add FL_LAYOUT lease type
      fs: track fl_owner for leases
      nfs: add LAYOUT_TYPE_MAX enum value
      nfsd: factor out a helper to decode nfstime4 values
      sunrpc/lockd: fix references to the BKL
      nfsd: fix year-2038 nfs4 state problem
      svcrdma: Handle additional inline content
      svcrdma: Move read list XDR round-up logic
      ...

commit 992de5a8eca7cbd3215e3eb2c439b2c11582a58b
Merge: b2718bffb408 d5b3cf7139b8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 10 16:45:56 2015 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge misc updates from Andrew Morton:
     "Bite-sized chunks this time, to avoid the MTA ratelimiting woes.
    
       - fs/notify updates
    
       - ocfs2
    
       - some of MM"
    
    That laconic "some MM" is mainly the removal of remap_file_pages(),
    which is a big simplification of the VM, and which gets rid of a *lot*
    of random cruft and special cases because we no longer support the
    non-linear mappings that it used.
    
    From a user interface perspective, nothing has changed, because the
    remap_file_pages() syscall still exists, it's just done by emulating the
    old behavior by creating a lot of individual small mappings instead of
    one non-linear one.
    
    The emulation is slower than the old "native" non-linear mappings, but
    nobody really uses or cares about remap_file_pages(), and simplifying
    the VM is a big advantage.
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (78 commits)
      memcg: zap memcg_slab_caches and memcg_slab_mutex
      memcg: zap memcg_name argument of memcg_create_kmem_cache
      memcg: zap __memcg_{charge,uncharge}_slab
      mm/page_alloc.c: place zone_id check before VM_BUG_ON_PAGE check
      mm: hugetlb: fix type of hugetlb_treat_as_movable variable
      mm, hugetlb: remove unnecessary lower bound on sysctl handlers"?
      mm: memory: merge shared-writable dirtying branches in do_wp_page()
      mm: memory: remove ->vm_file check on shared writable vmas
      xtensa: drop _PAGE_FILE and pte_file()-related helpers
      x86: drop _PAGE_FILE and pte_file()-related helpers
      unicore32: drop pte_file()-related helpers
      um: drop _PAGE_FILE and pte_file()-related helpers
      tile: drop pte_file()-related helpers
      sparc: drop pte_file()-related helpers
      sh: drop _PAGE_FILE and pte_file()-related helpers
      score: drop _PAGE_FILE and pte_file()-related helpers
      s390: drop pte_file()-related helpers
      parisc: drop _PAGE_FILE and pte_file()-related helpers
      openrisc: drop _PAGE_FILE and pte_file()-related helpers
      nios2: drop _PAGE_FILE and pte_file()-related helpers
      ...

commit 27ba0644ea9dfe6e7693abc85837b60e40583b96
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Tue Feb 10 14:09:59 2015 -0800

    rmap: drop support of non-linear mappings
    
    We don't create non-linear mappings anymore.  Let's drop code which
    handles them in rmap.
    
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 47f557c7ef7e..60acab209701 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -401,7 +401,6 @@ struct address_space {
 	spinlock_t		tree_lock;	/* and lock protecting it */
 	atomic_t		i_mmap_writable;/* count VM_SHARED mappings */
 	struct rb_root		i_mmap;		/* tree of private and shared mappings */
-	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
 	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
 	/* Protected by tree_lock together with the radix tree */
 	unsigned long		nrpages;	/* number of total pages */
@@ -493,8 +492,7 @@ static inline void i_mmap_unlock_read(struct address_space *mapping)
  */
 static inline int mapping_mapped(struct address_space *mapping)
 {
-	return	!RB_EMPTY_ROOT(&mapping->i_mmap) ||
-		!list_empty(&mapping->i_mmap_nonlinear);
+	return	!RB_EMPTY_ROOT(&mapping->i_mmap);
 }
 
 /*

commit d83a08db5ba6072caa658745881f4baa9bad6a08
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Tue Feb 10 14:09:54 2015 -0800

    mm: drop vm_ops->remap_pages and generic_file_remap_pages() stub
    
    Nobody uses it anymore.
    
    [akpm@linux-foundation.org: fix filemap_xip.c]
    Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 60c4996df7f3..47f557c7ef7e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2481,12 +2481,6 @@ extern int sb_min_blocksize(struct super_block *, int);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
-static inline int generic_file_remap_pages(struct vm_area_struct *vma,
-		unsigned long addr, unsigned long size, pgoff_t pgoff)
-{
-	BUG();
-	return 0;
-}
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit c8d78c1823f46519473949d33f0d1d33fe21ea16
Author: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
Date:   Tue Feb 10 14:09:46 2015 -0800

    mm: replace remap_file_pages() syscall with emulation
    
    remap_file_pages(2) was invented to be able efficiently map parts of
    huge file into limited 32-bit virtual address space such as in database
    workloads.
    
    Nonlinear mappings are pain to support and it seems there's no
    legitimate use-cases nowadays since 64-bit systems are widely available.
    
    Let's drop it and get rid of all these special-cased code.
    
    The patch replaces the syscall with emulation which creates new VMA on
    each remap_file_pages(), unless they it can be merged with an adjacent
    one.
    
    I didn't find *any* real code that uses remap_file_pages(2) to test
    emulation impact on.  I've checked Debian code search and source of all
    packages in ALT Linux.  No real users: libc wrappers, mentions in
    strace, gdb, valgrind and this kind of stuff.
    
    There are few basic tests in LTP for the syscall.  They work just fine
    with emulation.
    
    To test performance impact, I've written small test case which
    demonstrate pretty much worst case scenario: map 4G shmfs file, write to
    begin of every page pgoff of the page, remap pages in reverse order,
    read every page.
    
    The test creates 1 million of VMAs if emulation is in use, so I had to
    set vm.max_map_count to 1100000 to avoid -ENOMEM.
    
    Before:         23.3 ( +-  4.31% ) seconds
    After:          43.9 ( +-  0.85% ) seconds
    Slowdown:       1.88x
    
    I believe we can live with that.
    
    Test case:
    
            #define _GNU_SOURCE
            #include <assert.h>
            #include <stdlib.h>
            #include <stdio.h>
            #include <sys/mman.h>
    
            #define MB      (1024UL * 1024)
            #define SIZE    (4096 * MB)
    
            int main(int argc, char **argv)
            {
                    unsigned long *p;
                    long i, pass;
    
                    for (pass = 0; pass < 10; pass++) {
                            p = mmap(NULL, SIZE, PROT_READ|PROT_WRITE,
                                            MAP_SHARED | MAP_ANONYMOUS, -1, 0);
                            if (p == MAP_FAILED) {
                                    perror("mmap");
                                    return -1;
                            }
    
                            for (i = 0; i < SIZE / 4096; i++)
                                    p[i * 4096 / sizeof(*p)] = i;
    
                            for (i = 0; i < SIZE / 4096; i++) {
                                    if (remap_file_pages(p + i * 4096 / sizeof(*p), 4096,
                                                    0, (SIZE - 4096 * (i + 1)) >> 12, 0)) {
                                            perror("remap_file_pages");
                                            return -1;
                                    }
                            }
    
                            for (i = SIZE / 4096 - 1; i >= 0; i--)
                                    assert(p[i * 4096 / sizeof(*p)] == SIZE / 4096 - i - 1);
    
                            munmap(p, SIZE);
                    }
    
                    return 0;
            }
    
    [akpm@linux-foundation.org: fix spello]
    [sasha.levin@oracle.com: initialize populate before usage]
    [sasha.levin@oracle.com: grab file ref to prevent race while mmaping]
    Signed-off-by: "Kirill A. Shutemov" <kirill@shutemov.name>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Armin Rigo <arigo@tunes.org>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 42efe13077b6..60c4996df7f3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2481,8 +2481,12 @@ extern int sb_min_blocksize(struct super_block *, int);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
-extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
-		unsigned long size, pgoff_t pgoff);
+static inline int generic_file_remap_pages(struct vm_area_struct *vma,
+		unsigned long addr, unsigned long size, pgoff_t pgoff)
+{
+	BUG();
+	return 0;
+}
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit fe032c422c5ba562ba9c2d316f55e258e03259c6
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Mon Feb 2 00:37:01 2015 -0500

    vfs: add find_inode_nowait() function
    
    Add a new function find_inode_nowait() which is an even more general
    version of ilookup5_nowait().  It is designed for callers which need
    very fine grained control over when the function is allowed to block
    or increment the inode's reference count.
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cd027ce2c705..5ea8b6e46a3d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2441,6 +2441,11 @@ extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
 
 extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
 extern struct inode * iget_locked(struct super_block *, unsigned long);
+extern struct inode *find_inode_nowait(struct super_block *,
+				       unsigned long,
+				       int (*match)(struct inode *,
+						    unsigned long, void *),
+				       void *data);
 extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
 extern int insert_inode_locked(struct inode *);
 #ifdef CONFIG_DEBUG_LOCK_ALLOC

commit 0ae45f63d4ef8d8eeec49c7d8b44a1775fff13e8
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Mon Feb 2 00:37:00 2015 -0500

    vfs: add support for a lazytime mount option
    
    Add a new mount option which enables a new "lazytime" mode.  This mode
    causes atime, mtime, and ctime updates to only be made to the
    in-memory version of the inode.  The on-disk times will only get
    updated when (a) if the inode needs to be updated for some non-time
    related change, (b) if userspace calls fsync(), syncfs() or sync(), or
    (c) just before an undeleted inode is evicted from memory.
    
    This is OK according to POSIX because there are no guarantees after a
    crash unless userspace explicitly requests via a fsync(2) call.
    
    For workloads which feature a large number of random write to a
    preallocated file, the lazytime mount option significantly reduces
    writes to the inode table.  The repeated 4k writes to a single block
    will result in undesirable stress on flash devices and SMR disk
    drives.  Even on conventional HDD's, the repeated writes to the inode
    table block will trigger Adjacent Track Interference (ATI) remediation
    latencies, which very negatively impact long tail latencies --- which
    is a very big deal for web serving tiers (for example).
    
    Google-Bug-Id: 18297052
    
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 42efe13077b6..cd027ce2c705 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1746,8 +1746,12 @@ struct super_operations {
 #define __I_DIO_WAKEUP		9
 #define I_DIO_WAKEUP		(1 << I_DIO_WAKEUP)
 #define I_LINKABLE		(1 << 10)
+#define I_DIRTY_TIME		(1 << 11)
+#define __I_DIRTY_TIME_EXPIRED	12
+#define I_DIRTY_TIME_EXPIRED	(1 << __I_DIRTY_TIME_EXPIRED)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
+#define I_DIRTY_ALL (I_DIRTY | I_DIRTY_TIME)
 
 extern void __mark_inode_dirty(struct inode *, int);
 static inline void mark_inode_dirty(struct inode *inode)
@@ -1910,6 +1914,7 @@ extern int current_umask(void);
 
 extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
+extern int generic_update_time(struct inode *, struct timespec *, int);
 
 static inline struct inode *file_inode(const struct file *f)
 {

commit 11afe9f76e121e960445deee5b7f26f0787a1990
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 21 19:17:03 2015 +0100

    fs: add FL_LAYOUT lease type
    
    This (ab-)uses the file locking code to allow filesystems to recall
    outstanding pNFS layouts on a file.  This new lease type is similar but
    not quite the same as FL_DELEG.  A FL_LAYOUT lease can always be granted,
    an a per-filesystem lock (XFS iolock for the initial implementation)
    ensures not FL_LAYOUT leases granted when we would need to recall them.
    
    Also included are changes that allow multiple outstanding read
    leases of different types on the same file as long as they have a
    differnt owner.  This wasn't a problem until now as nfsd never set
    FL_LEASE leases, and no one else used FL_DELEG leases, but given that
    nfsd will also issues FL_LAYOUT leases we will have to handle it now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ddd2fa7cefd3..84740145f835 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -875,6 +875,7 @@ static inline struct file *get_file(struct file *f)
 #define FL_DOWNGRADE_PENDING	256 /* Lease is being downgraded */
 #define FL_UNLOCK_PENDING	512 /* Lease is being broken */
 #define FL_OFDLCK	1024	/* lock is "owned" by struct file */
+#define FL_LAYOUT	2048	/* outstanding pNFS layout */
 
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for
@@ -2037,6 +2038,16 @@ static inline int break_deleg_wait(struct inode **delegated_inode)
 	return ret;
 }
 
+static inline int break_layout(struct inode *inode, bool wait)
+{
+	smp_mb();
+	if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
+		return __break_lease(inode,
+				wait ? O_WRONLY : O_WRONLY | O_NONBLOCK,
+				FL_LAYOUT);
+	return 0;
+}
+
 #else /* !CONFIG_FILE_LOCKING */
 static inline int locks_mandatory_locked(struct file *file)
 {
@@ -2092,6 +2103,11 @@ static inline int break_deleg_wait(struct inode **delegated_inode)
 	return 0;
 }
 
+static inline int break_layout(struct inode *inode, bool wait)
+{
+	return 0;
+}
+
 #endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */

commit 15d0f5ea348b9c4e6d41df294dde38a56a39c7bf
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Mon Feb 2 10:07:59 2015 -0700

    Make super_blocks and sb_lock static
    
    The only user outside of fs/super.c is gone now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65d02de342e1..2f717baefdf8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1183,8 +1183,6 @@ struct mm_struct;
 #define UMOUNT_NOFOLLOW	0x00000008	/* Don't follow symlink on umount */
 #define UMOUNT_UNUSED	0x80000000	/* Flag guaranteed to be unused */
 
-extern struct list_head super_blocks;
-extern spinlock_t sb_lock;
 
 /* Possible states of 'frozen' field */
 enum {

commit dbe4e192a234cd6133d86fffb965d0f032c12ccc
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jan 25 21:11:59 2015 +0100

    fs: add vfs_iter_{read,write} helpers
    
    Simple helpers that pass an arbitrary iov_iter to filesystems.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 42efe13077b6..1f3c43952540 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2494,6 +2494,9 @@ extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t l
 extern ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 
+ssize_t vfs_iter_read(struct file *file, struct iov_iter *iter, loff_t *ppos);
+ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos);
+
 /* fs/block_dev.c */
 extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);
 extern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);

commit 55422d0bd292f5ad143cc32cb8bb8505257274c4
Author: Paul Moore <pmoore@redhat.com>
Date:   Thu Jan 22 00:00:23 2015 -0500

    audit: replace getname()/putname() hacks with reference counters
    
    In order to ensure that filenames are not released before the audit
    subsystem is done with the strings there are a number of hacks built
    into the fs and audit subsystems around getname() and putname().  To
    say these hacks are "ugly" would be kind.
    
    This patch removes the filename hackery in favor of a more
    conventional reference count based approach.  The diffstat below tells
    most of the story; lots of audit/fs specific code is replaced with a
    traditional reference count based approach that is easily understood,
    even by those not familiar with the audit and/or fs subsystems.
    
    CC: viro@zeniv.linux.org.uk
    CC: linux-fsdevel@vger.kernel.org
    Signed-off-by: Paul Moore <pmoore@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f90c0282c114..b49842fe203f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2080,6 +2080,7 @@ struct filename {
 	const char		*name;	/* pointer to actual string */
 	const __user char	*uptr;	/* original userland pointer */
 	struct audit_names	*aname;
+	int			refcnt;
 	bool			separate; /* should "name" be freed? */
 };
 
@@ -2101,6 +2102,7 @@ extern int filp_close(struct file *, fl_owner_t id);
 extern struct filename *getname_flags(const char __user *, int, int *);
 extern struct filename *getname(const char __user *);
 extern struct filename *getname_kernel(const char *);
+extern void putname(struct filename *name);
 
 enum {
 	FILE_CREATED = 1,
@@ -2121,15 +2123,8 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
-extern void final_putname(struct filename *name);
-
 #define __getname()		kmem_cache_alloc(names_cachep, GFP_KERNEL)
 #define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
-#ifndef CONFIG_AUDITSYSCALL
-#define putname(name)		final_putname(name)
-#else
-extern void putname(struct filename *name);
-#endif
 
 #ifdef CONFIG_BLOCK
 extern int register_blkdev(unsigned int, const char *);

commit 8116bf4cb62d337c953cfa5369ef4cf83e73140c
Author: Jeff Layton <jeff.layton@primarydata.com>
Date:   Wed Jan 21 20:44:01 2015 -0500

    locks: update comments that refer to inode->i_flock
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f87cb2f03103..ddd2fa7cefd3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -925,12 +925,11 @@ int locks_in_grace(struct net *);
  * FIXME: should we create a separate "struct lock_request" to help distinguish
  * these two uses?
  *
- * The i_flock list is ordered by:
+ * The varous i_flctx lists are ordered by:
  *
- * 1) lock type -- FL_LEASEs first, then FL_FLOCK, and finally FL_POSIX
- * 2) lock owner
- * 3) lock range start
- * 4) lock range end
+ * 1) lock owner
+ * 2) lock range start
+ * 3) lock range end
  *
  * Obviously, the last two criteria only matter for POSIX locks.
  */
@@ -1992,8 +1991,9 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 {
 	/*
 	 * Since this check is lockless, we must ensure that any refcounts
-	 * taken are done before checking inode->i_flock. Otherwise, we could
-	 * end up racing with tasks trying to set a new lease on this file.
+	 * taken are done before checking i_flctx->flc_lease. Otherwise, we
+	 * could end up racing with tasks trying to set a new lease on this
+	 * file.
 	 */
 	smp_mb();
 	if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
@@ -2005,8 +2005,9 @@ static inline int break_deleg(struct inode *inode, unsigned int mode)
 {
 	/*
 	 * Since this check is lockless, we must ensure that any refcounts
-	 * taken are done before checking inode->i_flock. Otherwise, we could
-	 * end up racing with tasks trying to set a new lease on this file.
+	 * taken are done before checking i_flctx->flc_lease. Otherwise, we
+	 * could end up racing with tasks trying to set a new lease on this
+	 * file.
 	 */
 	smp_mb();
 	if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))

commit b83ae6d421435c6204150300f1c25bfbd39cd62b
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:37 2015 +0100

    fs: remove mapping->backing_dev_info
    
    Now that we never use the backing_dev_info pointer in struct address_space
    we can simply remove it and save 4 to 8 bytes in every inode.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1dada399aa23..65d02de342e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -34,6 +34,7 @@
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
 
+struct backing_dev_info;
 struct export_operations;
 struct hd_geometry;
 struct iovec;
@@ -394,7 +395,6 @@ int pagecache_write_end(struct file *, struct address_space *mapping,
 				loff_t pos, unsigned len, unsigned copied,
 				struct page *page, void *fsdata);
 
-struct backing_dev_info;
 struct address_space {
 	struct inode		*host;		/* owner: inode, block_device */
 	struct radix_tree_root	page_tree;	/* radix tree of all pages */
@@ -409,7 +409,6 @@ struct address_space {
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */
 	unsigned long		flags;		/* error bits/gfp mask */
-	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
 	spinlock_t		private_lock;	/* for use by the address_space */
 	struct list_head	private_list;	/* ditto */
 	void			*private_data;	/* ditto */

commit b4caecd48005fbed3949dde6c1cb233142fd69e9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:32 2015 +0100

    fs: introduce f_op->mmap_capabilities for nommu mmap support
    
    Since "BDI: Provide backing device capability information [try #3]" the
    backing_dev_info structure also provides flags for the kind of mmap
    operation available in a nommu environment, which is entirely unrelated
    to it's original purpose.
    
    Introduce a new nommu-only file operation to provide this information to
    the nommu mmap code instead.  Splitting this from the backing_dev_info
    structure allows to remove lots of backing_dev_info instance that aren't
    otherwise needed, and entirely gets rid of the concept of providing a
    backing_dev_info for a character device.  It also removes the need for
    the mtd_inodefs filesystem.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 42efe13077b6..1dada399aa23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1502,6 +1502,26 @@ struct block_device_operations;
 #define HAVE_COMPAT_IOCTL 1
 #define HAVE_UNLOCKED_IOCTL 1
 
+/*
+ * These flags let !MMU mmap() govern direct device mapping vs immediate
+ * copying more easily for MAP_PRIVATE, especially for ROM filesystems.
+ *
+ * NOMMU_MAP_COPY:	Copy can be mapped (MAP_PRIVATE)
+ * NOMMU_MAP_DIRECT:	Can be mapped directly (MAP_SHARED)
+ * NOMMU_MAP_READ:	Can be mapped for reading
+ * NOMMU_MAP_WRITE:	Can be mapped for writing
+ * NOMMU_MAP_EXEC:	Can be mapped for execution
+ */
+#define NOMMU_MAP_COPY		0x00000001
+#define NOMMU_MAP_DIRECT	0x00000008
+#define NOMMU_MAP_READ		VM_MAYREAD
+#define NOMMU_MAP_WRITE		VM_MAYWRITE
+#define NOMMU_MAP_EXEC		VM_MAYEXEC
+
+#define NOMMU_VMFLAGS \
+	(NOMMU_MAP_READ | NOMMU_MAP_WRITE | NOMMU_MAP_EXEC)
+
+
 struct iov_iter;
 
 struct file_operations {
@@ -1536,6 +1556,9 @@ struct file_operations {
 	long (*fallocate)(struct file *file, int mode, loff_t offset,
 			  loff_t len);
 	void (*show_fdinfo)(struct seq_file *m, struct file *f);
+#ifndef CONFIG_MMU
+	unsigned (*mmap_capabilities)(struct file *);
+#endif
 };
 
 struct inode_operations {

commit 9bd0f45b7037fcfa8b575c7e27d0431d6e6dc3bb
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:57 2015 -0500

    locks: keep a count of locks on the flctx lists
    
    This makes things a bit more efficient in the cifs and ceph lock
    pushing code.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 94e706a0a408..f87cb2f03103 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -972,6 +972,9 @@ struct file_lock_context {
 	struct list_head	flc_flock;
 	struct list_head	flc_posix;
 	struct list_head	flc_lease;
+	int			flc_flock_cnt;
+	int			flc_posix_cnt;
+	int			flc_lease_cnt;
 };
 
 /* The following constant reflects the upper bound of the file/locking space */

commit 7448cc37b1a6b620d948aaee3bb30960c06d5d5d
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:57 2015 -0500

    locks: clean up the lm_change prototype
    
    Now that we use standard list_heads for tracking leases, we can have
    lm_change take a pointer to the lease to be modified instead of a
    double pointer.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 32eafa9b5c9f..94e706a0a408 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -900,7 +900,7 @@ struct lock_manager_operations {
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, int);
 	bool (*lm_break)(struct file_lock *);
-	int (*lm_change)(struct file_lock **, int, struct list_head *);
+	int (*lm_change)(struct file_lock *, int, struct list_head *);
 	void (*lm_setup)(struct file_lock *, void **);
 };
 
@@ -1021,7 +1021,7 @@ extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int t
 extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
 extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
-extern int lease_modify(struct file_lock **, int, struct list_head *);
+extern int lease_modify(struct file_lock *, int, struct list_head *);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, unsigned int cmd,
 			      struct flock __user *user)
@@ -1153,7 +1153,7 @@ static inline int vfs_setlease(struct file *filp, long arg,
 	return -EINVAL;
 }
 
-static inline int lease_modify(struct file_lock **before, int arg,
+static inline int lease_modify(struct file_lock *fl, int arg,
 			       struct list_head *dispose)
 {
 	return -EINVAL;

commit 6109c85037e53443f29fd39c0de69f578a1cf285
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:57 2015 -0500

    locks: add a dedicated spinlock to protect i_flctx lists
    
    We can now add a dedicated spinlock without expanding struct inode.
    Change to using that to protect the various i_flctx lists.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ce0873af0b97..32eafa9b5c9f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -968,6 +968,7 @@ struct file_lock {
 };
 
 struct file_lock_context {
+	spinlock_t		flc_lock;
 	struct list_head	flc_flock;
 	struct list_head	flc_posix;
 	struct list_head	flc_lease;

commit a7231a97467d5a0c36f82f581c76c12c034e4b80
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:56 2015 -0500

    locks: remove i_flock field from struct inode
    
    Nothing uses it anymore. Also add a forward declaration for struct
    file_lock to silence some compiler warnings that the removal triggers.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2ddec3cf81b9..ce0873af0b97 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -625,7 +625,6 @@ struct inode {
 	atomic_t		i_readcount; /* struct files open RO */
 #endif
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
-	struct file_lock	*i_flock;
 	struct file_lock_context	*i_flctx;
 	struct address_space	i_data;
 	struct list_head	i_devices;
@@ -886,6 +885,8 @@ static inline struct file *get_file(struct file *f)
 /* legacy typedef, should eventually be removed */
 typedef void *fl_owner_t;
 
+struct file_lock;
+
 struct file_lock_operations {
 	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 	void (*fl_release_private)(struct file_lock *);

commit 8634b51f6ca298fb8b07aa4847340764903533ab
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:55 2015 -0500

    locks: convert lease handling to file_lock_context
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 571f113588e9..2ddec3cf81b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -969,6 +969,7 @@ struct file_lock {
 struct file_lock_context {
 	struct list_head	flc_flock;
 	struct list_head	flc_posix;
+	struct list_head	flc_lease;
 };
 
 /* The following constant reflects the upper bound of the file/locking space */
@@ -1990,7 +1991,7 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 	 * end up racing with tasks trying to set a new lease on this file.
 	 */
 	smp_mb();
-	if (inode->i_flock)
+	if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
 		return __break_lease(inode, mode, FL_LEASE);
 	return 0;
 }
@@ -2003,7 +2004,7 @@ static inline int break_deleg(struct inode *inode, unsigned int mode)
 	 * end up racing with tasks trying to set a new lease on this file.
 	 */
 	smp_mb();
-	if (inode->i_flock)
+	if (inode->i_flctx && !list_empty_careful(&inode->i_flctx->flc_lease))
 		return __break_lease(inode, mode, FL_DELEG);
 	return 0;
 }

commit bd61e0a9c852de2d705b6f1bb2cc54c5774db570
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:55 2015 -0500

    locks: convert posix locks to file_lock_context
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dec0d38b05de..571f113588e9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -968,6 +968,7 @@ struct file_lock {
 
 struct file_lock_context {
 	struct list_head	flc_flock;
+	struct list_head	flc_posix;
 };
 
 /* The following constant reflects the upper bound of the file/locking space */
@@ -1971,7 +1972,7 @@ static inline int locks_verify_truncate(struct inode *inode,
 				    struct file *filp,
 				    loff_t size)
 {
-	if (inode->i_flock && mandatory_lock(inode))
+	if (inode->i_flctx && mandatory_lock(inode))
 		return locks_mandatory_area(
 			FLOCK_VERIFY_WRITE, inode, filp,
 			size < inode->i_size ? size : inode->i_size,

commit 4a075e39c86490cc0f0c10ac6abe3592d1689463
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:54 2015 -0500

    locks: add a new struct file_locking_context pointer to struct inode
    
    The current scheme of using the i_flock list is really difficult to
    manage. There is also a legitimate desire for a per-inode spinlock to
    manage these lists that isn't the i_lock.
    
    Start conversion to a new scheme to eventually replace the old i_flock
    list with a new "file_lock_context" object.
    
    We start by adding a new i_flctx to struct inode. For now, it lives in
    parallel with i_flock list, but will eventually replace it. The idea is
    to allocate a structure to sit in that pointer and act as a locus for
    all things file locking.
    
    We allocate a file_lock_context for an inode when the first lock is
    added to it, and it's only freed when the inode is freed. We use the
    i_lock to protect the assignment, but afterward it should mostly be
    accessed locklessly.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cd6818115162..dec0d38b05de 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -626,6 +626,7 @@ struct inode {
 #endif
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock	*i_flock;
+	struct file_lock_context	*i_flctx;
 	struct address_space	i_data;
 	struct list_head	i_devices;
 	union {
@@ -965,6 +966,10 @@ struct file_lock {
 	} fl_u;
 };
 
+struct file_lock_context {
+	struct list_head	flc_flock;
+};
+
 /* The following constant reflects the upper bound of the file/locking space */
 #ifndef OFFSET_MAX
 #define INT_LIMIT(x)	(~((x)1 << (sizeof(x)*8 - 1)))
@@ -991,6 +996,7 @@ extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
 /* fs/locks.c */
+void locks_free_lock_context(struct file_lock_context *ctx);
 void locks_free_lock(struct file_lock *fl);
 extern void locks_init_lock(struct file_lock *);
 extern struct file_lock * locks_alloc_lock(void);
@@ -1048,6 +1054,11 @@ static inline int fcntl_getlease(struct file *filp)
 	return F_UNLCK;
 }
 
+static inline void
+locks_free_lock_context(struct file_lock_context *ctx)
+{
+}
+
 static inline void locks_init_lock(struct file_lock *fl)
 {
 	return;

commit 6dee60f69d48fcef021b4b53b3431797ec440764
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Jan 16 15:05:54 2015 -0500

    locks: add new struct list_head to struct file_lock
    
    ...that we can use to queue file_locks to per-ctx list_heads. Go ahead
    and convert locks_delete_lock and locks_dispose_list to use it instead
    of the fl_block list.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 42efe13077b6..cd6818115162 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -934,6 +934,7 @@ int locks_in_grace(struct net *);
  */
 struct file_lock {
 	struct file_lock *fl_next;	/* singly linked list for this inode  */
+	struct list_head fl_list;	/* link into file_lock_context */
 	struct hlist_node fl_link;	/* node in global lists */
 	struct list_head fl_block;	/* circular list of blocked processes */
 	fl_owner_t fl_owner;

commit 75069f2b5bfb5164beafaf3da597279c25b5535a
Author: David Drysdale <drysdale@google.com>
Date:   Thu Jan 8 14:32:29 2015 -0800

    vfs: renumber FMODE_NONOTIFY and add to uniqueness check
    
    Fix clashing values for O_PATH and FMODE_NONOTIFY on sparc.  The
    clashing O_PATH value was added in commit 5229645bdc35 ("vfs: add
    nonconflicting values for O_PATH") but this can't be changed as it is
    user-visible.
    
    FMODE_NONOTIFY is only used internally in the kernel, but it is in the
    same numbering space as the other O_* flags, as indicated by the comment
    at the top of include/uapi/asm-generic/fcntl.h (and its use in
    fs/notify/fanotify/fanotify_user.c).  So renumber it to avoid the clash.
    
    All of this has happened before (commit 12ed2e36c98a: "fanotify:
    FMODE_NONOTIFY and __O_SYNC in sparc conflict"), and all of this will
    happen again -- so update the uniqueness check in fcntl_init() to
    include __FMODE_NONOTIFY.
    
    Signed-off-by: David Drysdale <drysdale@google.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Jan Kara <jack@suse.cz>
    Cc: Heinrich Schuchardt <xypron.glpk@gmx.de>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f90c0282c114..42efe13077b6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -135,7 +135,7 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
-#define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
+#define FMODE_NONOTIFY		((__force fmode_t)0x4000000)
 
 /*
  * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector

commit 603ba7e41bf5d405aba22294af5d075d8898176d
Merge: 31f48fc8f226 93fe74b2e2b5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 16 15:53:03 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile #2 from Al Viro:
     "Next pile (and there'll be one or two more).
    
      The large piece in this one is getting rid of /proc/*/ns/* weirdness;
      among other things, it allows to (finally) make nameidata completely
      opaque outside of fs/namei.c, making for easier further cleanups in
      there"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      coda_venus_readdir(): use file_inode()
      fs/namei.c: fold link_path_walk() call into path_init()
      path_init(): don't bother with LOOKUP_PARENT in argument
      fs/namei.c: new helper (path_cleanup())
      path_init(): store the "base" pointer to file in nameidata itself
      make default ->i_fop have ->open() fail with ENXIO
      make nameidata completely opaque outside of fs/namei.c
      kill proc_ns completely
      take the targets of /proc/*/ns/* symlinks to separate fs
      bury struct proc_ns in fs/proc
      copy address of proc_ns_ops into ns_common
      new helpers: ns_alloc_inum/ns_free_inum
      make proc_ns_operations work with struct ns_common * instead of void *
      switch the rest of proc_ns_operations to working with &...->ns
      netns: switch ->get()/->put()/->install()/->inum() to working with &net->ns
      make mntns ->get()/->put()/->install()/->inum() work with &mnt_ns->ns
      common object embedded into various struct ....ns

commit 0b233b7c79d2ba92c7fb5d60d4116693f1b3b0fe
Merge: 6f51ee709e4c bf7491f1be5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 16 15:25:31 2014 -0800

    Merge branch 'for-3.19' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd updates from Bruce Fields:
     "A comparatively quieter cycle for nfsd this time, but still with two
      larger changes:
    
       - RPC server scalability improvements from Jeff Layton (using RCU
         instead of a spinlock to find idle threads).
    
       - server-side NFSv4.2 ALLOCATE/DEALLOCATE support from Anna
         Schumaker, enabling fallocate on new clients"
    
    * 'for-3.19' of git://linux-nfs.org/~bfields/linux: (32 commits)
      nfsd4: fix xdr4 count of server in fs_location4
      nfsd4: fix xdr4 inclusion of escaped char
      sunrpc/cache: convert to use string_escape_str()
      sunrpc: only call test_bit once in svc_xprt_received
      fs: nfsd: Fix signedness bug in compare_blob
      sunrpc: add some tracepoints around enqueue and dequeue of svc_xprt
      sunrpc: convert to lockless lookup of queued server threads
      sunrpc: fix potential races in pool_stats collection
      sunrpc: add a rcu_head to svc_rqst and use kfree_rcu to free it
      sunrpc: require svc_create callers to pass in meaningful shutdown routine
      sunrpc: have svc_wake_up only deal with pool 0
      sunrpc: convert sp_task_pending flag to use atomic bitops
      sunrpc: move rq_cachetype field to better optimize space
      sunrpc: move rq_splice_ok flag into rq_flags
      sunrpc: move rq_dropme flag into rq_flags
      sunrpc: move rq_usedeferral flag to rq_flags
      sunrpc: move rq_local field to rq_flags
      sunrpc: add a generic rq_flags field to svc_rqst and move rq_secure to it
      nfsd: minor off by one checks in __write_versions()
      sunrpc: release svc_pool_map reference when serv allocation fails
      ...

commit 67e2c3883828b39548cee2091b36656787775d95
Merge: 6ae840e7cc4b b2d1965dcea1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 20:36:37 2014 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security layer updates from James Morris:
     "In terms of changes, there's general maintenance to the Smack,
      SELinux, and integrity code.
    
      The IMA code adds a new kconfig option, IMA_APPRAISE_SIGNED_INIT,
      which allows IMA appraisal to require signatures.  Support for reading
      keys from rootfs before init is call is also added"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (23 commits)
      selinux: Remove security_ops extern
      security: smack: fix out-of-bounds access in smk_parse_smack()
      VFS: refactor vfs_read()
      ima: require signature based appraisal
      integrity: provide a hook to load keys when rootfs is ready
      ima: load x509 certificate from the kernel
      integrity: provide a function to load x509 certificate from the kernel
      integrity: define a new function integrity_read_file()
      Security: smack: replace kzalloc with kmem_cache for inode_smack
      Smack: Lock mode for the floor and hat labels
      ima: added support for new kernel cmdline parameter ima_template_fmt
      ima: allocate field pointers array on demand in template_desc_init_fields()
      ima: don't allocate a copy of template_fmt in template_desc_init_fields()
      ima: display template format in meas. list if template name length is zero
      ima: added error messages to template-related functions
      ima: use atomic bit operations to protect policy update interface
      ima: ignore empty and with whitespaces policy lines
      ima: no need to allocate entry for comment
      ima: report policy load status
      ima: use path names cache
      ...

commit 7d22286ff757586f3cdbd70ded88b98250285ec5
Merge: 96895199c864 5f785de58873
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 13:36:57 2014 -0800

    Merge git://git.kvack.org/~bcrl/aio-next
    
    Pull aio updates from Benjamin LaHaise.
    
    * git://git.kvack.org/~bcrl/aio-next:
      aio: Skip timer for io_getevents if timeout=0
      aio: Make it possible to remap aio ring

commit e4a0d3e720e7e508749c1439b5ba3aff56c92976
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Thu Sep 18 19:56:17 2014 +0400

    aio: Make it possible to remap aio ring
    
    There are actually two issues this patch addresses. Let me start with
    the one I tried to solve in the beginning.
    
    So, in the checkpoint-restore project (criu) we try to dump tasks'
    state and restore one back exactly as it was. One of the tasks' state
    bits is rings set up with io_setup() call. There's (almost) no problems
    in dumping them, there's a problem restoring them -- if I dump a task
    with aio ring originally mapped at address A, I want to restore one
    back at exactly the same address A. Unfortunately, the io_setup() does
    not allow for that -- it mmaps the ring at whatever place mm finds
    appropriate (it calls do_mmap_pgoff() with zero address and without
    the MAP_FIXED flag).
    
    To make restore possible I'm going to mremap() the freshly created ring
    into the address A (under which it was seen before dump). The problem is
    that the ring's virtual address is passed back to the user-space as the
    context ID and this ID is then used as search key by all the other io_foo()
    calls. Reworking this ID to be just some integer doesn't seem to work, as
    this value is already used by libaio as a pointer using which this library
    accesses memory for aio meta-data.
    
    So, to make restore work we need to make sure that
    
    a) ring is mapped at desired virtual address
    b) kioctx->user_id matches this value
    
    Having said that, the patch makes mremap() on aio region update the
    kioctx's user_id and mmap_base values.
    
    Here appears the 2nd issue I mentioned in the beginning of this mail.
    If (regardless of the C/R dances I do) someone creates an io context
    with io_setup(), then mremap()-s the ring and then destroys the context,
    the kill_ioctx() routine will call munmap() on wrong (old) address.
    This will result in a) aio ring remaining in memory and b) some other
    vma get unexpectedly unmapped.
    
    What do you think?
    
    Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
    Acked-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Benjamin LaHaise <bcrl@kvack.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab779e8a63c..85f378c55c26 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1497,6 +1497,7 @@ struct file_operations {
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);
+	void (*mremap)(struct file *, struct vm_area_struct *);
 	int (*open) (struct inode *, struct file *);
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);

commit 51f39a1f0cea1cacf8c787f652f26dfee9611874
Author: David Drysdale <drysdale@google.com>
Date:   Fri Dec 12 16:57:29 2014 -0800

    syscalls: implement execveat() system call
    
    This patchset adds execveat(2) for x86, and is derived from Meredydd
    Luff's patch from Sept 2012 (https://lkml.org/lkml/2012/9/11/528).
    
    The primary aim of adding an execveat syscall is to allow an
    implementation of fexecve(3) that does not rely on the /proc filesystem,
    at least for executables (rather than scripts).  The current glibc version
    of fexecve(3) is implemented via /proc, which causes problems in sandboxed
    or otherwise restricted environments.
    
    Given the desire for a /proc-free fexecve() implementation, HPA suggested
    (https://lkml.org/lkml/2006/7/11/556) that an execveat(2) syscall would be
    an appropriate generalization.
    
    Also, having a new syscall means that it can take a flags argument without
    back-compatibility concerns.  The current implementation just defines the
    AT_EMPTY_PATH and AT_SYMLINK_NOFOLLOW flags, but other flags could be
    added in future -- for example, flags for new namespaces (as suggested at
    https://lkml.org/lkml/2006/7/11/474).
    
    Related history:
     - https://lkml.org/lkml/2006/12/27/123 is an example of someone
       realizing that fexecve() is likely to fail in a chroot environment.
     - http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=514043 covered
       documenting the /proc requirement of fexecve(3) in its manpage, to
       "prevent other people from wasting their time".
     - https://bugzilla.redhat.com/show_bug.cgi?id=241609 described a
       problem where a process that did setuid() could not fexecve()
       because it no longer had access to /proc/self/fd; this has since
       been fixed.
    
    This patch (of 4):
    
    Add a new execveat(2) system call.  execveat() is to execve() as openat()
    is to open(): it takes a file descriptor that refers to a directory, and
    resolves the filename relative to that.
    
    In addition, if the filename is empty and AT_EMPTY_PATH is specified,
    execveat() executes the file to which the file descriptor refers.  This
    replicates the functionality of fexecve(), which is a system call in other
    UNIXen, but in Linux glibc it depends on opening "/proc/self/fd/<fd>" (and
    so relies on /proc being mounted).
    
    The filename fed to the executed program as argv[0] (or the name of the
    script fed to a script interpreter) will be of the form "/dev/fd/<fd>"
    (for an empty filename) or "/dev/fd/<fd>/<filename>", effectively
    reflecting how the executable was found.  This does however mean that
    execution of a script in a /proc-less environment won't work; also, script
    execution via an O_CLOEXEC file descriptor fails (as the file will not be
    accessible after exec).
    
    Based on patches by Meredydd Luff.
    
    Signed-off-by: David Drysdale <drysdale@google.com>
    Cc: Meredydd Luff <meredydd@senatehouse.org>
    Cc: Shuah Khan <shuah.kh@samsung.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rich Felker <dalias@aerifal.cx>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1d1838de6882..4193a0bd99b0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2096,6 +2096,7 @@ extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 
+extern struct filename *getname_flags(const char __user *, int, int *);
 extern struct filename *getname(const char __user *);
 extern struct filename *getname_kernel(const char *);
 

commit 3dec0ba0be6a532cac949e02b853021bf6d57dad
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Dec 12 16:54:27 2014 -0800

    mm/rmap: share the i_mmap_rwsem
    
    Similarly to the anon memory counterpart, we can share the mapping's lock
    ownership as the interval tree is not modified when doing doing the walk,
    only the file page.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Acked-by: "Kirill A. Shutemov" <kirill@shutemov.name>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6abcd0b72ae0..1d1838de6882 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -478,6 +478,16 @@ static inline void i_mmap_unlock_write(struct address_space *mapping)
 	up_write(&mapping->i_mmap_rwsem);
 }
 
+static inline void i_mmap_lock_read(struct address_space *mapping)
+{
+	down_read(&mapping->i_mmap_rwsem);
+}
+
+static inline void i_mmap_unlock_read(struct address_space *mapping)
+{
+	up_read(&mapping->i_mmap_rwsem);
+}
+
 /*
  * Might pages of this file be mapped into userspace?
  */

commit c8c06efa8b552608493b7066c234cfa82c47fcea
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Dec 12 16:54:24 2014 -0800

    mm: convert i_mmap_mutex to rwsem
    
    The i_mmap_mutex is a close cousin of the anon vma lock, both protecting
    similar data, one for file backed pages and the other for anon memory.  To
    this end, this lock can also be a rwsem.  In addition, there are some
    important opportunities to share the lock when there are no tree
    modifications.
    
    This conversion is straightforward.  For now, all users take the write
    lock.
    
    [sfr@canb.auug.org.au: update fremap.c]
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Acked-by: "Kirill A. Shutemov" <kirill@shutemov.name>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd0a1b2f3c02..6abcd0b72ae0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -18,6 +18,7 @@
 #include <linux/pid.h>
 #include <linux/bug.h>
 #include <linux/mutex.h>
+#include <linux/rwsem.h>
 #include <linux/capability.h>
 #include <linux/semaphore.h>
 #include <linux/fiemap.h>
@@ -401,7 +402,7 @@ struct address_space {
 	atomic_t		i_mmap_writable;/* count VM_SHARED mappings */
 	struct rb_root		i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
-	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
+	struct rw_semaphore	i_mmap_rwsem;	/* protect tree, count, list */
 	/* Protected by tree_lock together with the radix tree */
 	unsigned long		nrpages;	/* number of total pages */
 	unsigned long		nrshadows;	/* number of shadow entries */
@@ -469,12 +470,12 @@ int mapping_tagged(struct address_space *mapping, int tag);
 
 static inline void i_mmap_lock_write(struct address_space *mapping)
 {
-	mutex_lock(&mapping->i_mmap_mutex);
+	down_write(&mapping->i_mmap_rwsem);
 }
 
 static inline void i_mmap_unlock_write(struct address_space *mapping)
 {
-	mutex_unlock(&mapping->i_mmap_mutex);
+	up_write(&mapping->i_mmap_rwsem);
 }
 
 /*

commit 8b28f621bea6f84d44adf7e804b73aff1e09105b
Author: Davidlohr Bueso <dave@stgolabs.net>
Date:   Fri Dec 12 16:54:18 2014 -0800

    mm,fs: introduce helpers around the i_mmap_mutex
    
    This series is a continuation of the conversion of the i_mmap_mutex to
    rwsem, following what we have for the anon memory counterpart.  With
    Hugh's feedback from the first iteration.
    
    Ultimately, the most obvious paths that require exclusive ownership of the
    lock is when we modify the VMA interval tree, via
    vma_interval_tree_insert() and vma_interval_tree_remove() families.  Cases
    such as unmapping, where the ptes content is changed but the tree remains
    untouched should make it safe to share the i_mmap_rwsem.
    
    As such, the code of course is straightforward, however the devil is very
    much in the details.  While its been tested on a number of workloads
    without anything exploding, I would not be surprised if there are some
    less documented/known assumptions about the lock that could suffer from
    these changes.  Or maybe I'm just missing something, but either way I
    believe its at the point where it could use more eyes and hopefully some
    time in linux-next.
    
    Because the lock type conversion is the heart of this patchset,
    its worth noting a few comparisons between mutex vs rwsem (xadd):
    
      (i) Same size, no extra footprint.
    
      (ii) Both have CONFIG_XXX_SPIN_ON_OWNER capabilities for
           exclusive lock ownership.
    
      (iii) Both can be slightly unfair wrt exclusive ownership, with
            writer lock stealing properties, not necessarily respecting
            FIFO order for granting the lock when contended.
    
      (iv) Mutexes can be slightly faster than rwsems when
           the lock is non-contended.
    
      (v) Both suck at performance for debug (slowpaths), which
          shouldn't matter anyway.
    
    Sharing the lock is obviously beneficial, and sem writer ownership is
    close enough to mutexes.  The biggest winner of these changes is
    migration.
    
    As for concrete numbers, the following performance results are for a
    4-socket 60-core IvyBridge-EX with 130Gb of RAM.
    
    Both alltests and disk (xfs+ramdisk) workloads of aim7 suite do quite well
    with this set, with a steady ~60% throughput (jpm) increase for alltests
    and up to ~30% for disk for high amounts of concurrency.  Lower counts of
    workload users (< 100) does not show much difference at all, so at least
    no regressions.
    
                        3.18-rc1            3.18-rc1-i_mmap_rwsem
    alltests-100     17918.72 (  0.00%)    28417.97 ( 58.59%)
    alltests-200     16529.39 (  0.00%)    26807.92 ( 62.18%)
    alltests-300     16591.17 (  0.00%)    26878.08 ( 62.00%)
    alltests-400     16490.37 (  0.00%)    26664.63 ( 61.70%)
    alltests-500     16593.17 (  0.00%)    26433.72 ( 59.30%)
    alltests-600     16508.56 (  0.00%)    26409.20 ( 59.97%)
    alltests-700     16508.19 (  0.00%)    26298.58 ( 59.31%)
    alltests-800     16437.58 (  0.00%)    26433.02 ( 60.81%)
    alltests-900     16418.35 (  0.00%)    26241.61 ( 59.83%)
    alltests-1000    16369.00 (  0.00%)    26195.76 ( 60.03%)
    alltests-1100    16330.11 (  0.00%)    26133.46 ( 60.03%)
    alltests-1200    16341.30 (  0.00%)    26084.03 ( 59.62%)
    alltests-1300    16304.75 (  0.00%)    26024.74 ( 59.61%)
    alltests-1400    16231.08 (  0.00%)    25952.35 ( 59.89%)
    alltests-1500    16168.06 (  0.00%)    25850.58 ( 59.89%)
    alltests-1600    16142.56 (  0.00%)    25767.42 ( 59.62%)
    alltests-1700    16118.91 (  0.00%)    25689.58 ( 59.38%)
    alltests-1800    16068.06 (  0.00%)    25599.71 ( 59.32%)
    alltests-1900    16046.94 (  0.00%)    25525.92 ( 59.07%)
    alltests-2000    16007.26 (  0.00%)    25513.07 ( 59.38%)
    
    disk-100          7582.14 (  0.00%)     7257.48 ( -4.28%)
    disk-200          6962.44 (  0.00%)     7109.15 (  2.11%)
    disk-300          6435.93 (  0.00%)     6904.75 (  7.28%)
    disk-400          6370.84 (  0.00%)     6861.26 (  7.70%)
    disk-500          6353.42 (  0.00%)     6846.71 (  7.76%)
    disk-600          6368.82 (  0.00%)     6806.75 (  6.88%)
    disk-700          6331.37 (  0.00%)     6796.01 (  7.34%)
    disk-800          6324.22 (  0.00%)     6788.00 (  7.33%)
    disk-900          6253.52 (  0.00%)     6750.43 (  7.95%)
    disk-1000         6242.53 (  0.00%)     6855.11 (  9.81%)
    disk-1100         6234.75 (  0.00%)     6858.47 ( 10.00%)
    disk-1200         6312.76 (  0.00%)     6845.13 (  8.43%)
    disk-1300         6309.95 (  0.00%)     6834.51 (  8.31%)
    disk-1400         6171.76 (  0.00%)     6787.09 (  9.97%)
    disk-1500         6139.81 (  0.00%)     6761.09 ( 10.12%)
    disk-1600         4807.12 (  0.00%)     6725.33 ( 39.90%)
    disk-1700         4669.50 (  0.00%)     5985.38 ( 28.18%)
    disk-1800         4663.51 (  0.00%)     5972.99 ( 28.08%)
    disk-1900         4674.31 (  0.00%)     5949.94 ( 27.29%)
    disk-2000         4668.36 (  0.00%)     5834.93 ( 24.99%)
    
    In addition, a 67.5% increase in successfully migrated NUMA pages, thus
    improving node locality.
    
    The patch layout is simple but designed for bisection (in case reversion
    is needed if the changes break upstream) and easier review:
    
    o Patches 1-4 convert the i_mmap lock from mutex to rwsem.
    o Patches 5-10 share the lock in specific paths, each patch
      details the rationale behind why it should be safe.
    
    This patchset has been tested with: postgres 9.4 (with brand new hugetlb
    support), hugetlbfs test suite (all tests pass, in fact more tests pass
    with these changes than with an upstream kernel), ltp, aim7 benchmarks,
    memcached and iozone with the -B option for mmap'ing.  *Untested* paths
    are nommu, memory-failure, uprobes and xip.
    
    This patch (of 8):
    
    Various parts of the kernel acquire and release this mutex, so add
    i_mmap_lock_write() and immap_unlock_write() helper functions that will
    encapsulate this logic.  The next patch will make use of these.
    
    Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Acked-by: "Kirill A. Shutemov" <kirill@shutemov.name>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bb29b02d9bb6..bd0a1b2f3c02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -467,6 +467,16 @@ struct block_device {
 
 int mapping_tagged(struct address_space *mapping, int tag);
 
+static inline void i_mmap_lock_write(struct address_space *mapping)
+{
+	mutex_lock(&mapping->i_mmap_mutex);
+}
+
+static inline void i_mmap_unlock_write(struct address_space *mapping)
+{
+	mutex_unlock(&mapping->i_mmap_mutex);
+}
+
 /*
  * Might pages of this file be mapped into userspace?
  */

commit bd9b51e79cb0b8bc00a7e0076a4a8963ca4a797c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Nov 18 23:38:21 2014 -0500

    make default ->i_fop have ->open() fail with ENXIO
    
    As it is, default ->i_fop has NULL ->open() (along with all other methods).
    The only case where it matters is reopening (via procfs symlink) a file that
    didn't get its ->f_op from ->i_fop - anything else will have ->i_fop assigned
    to something sane (default would fail on read/write/ioctl/etc.).
    
            Unfortunately, such case exists - alloc_file() users, especially
    anon_get_file() ones.  There we have tons of opened files of very different
    kinds sharing the same inode.  As the result, attempt to reopen those via
    procfs succeeds and you get a descriptor you can't do anything with.
    
            Moreover, in case of sockets we set ->i_fop that will only be used
    on such reopen attempts - and put a failing ->open() into it to make sure
    those do not succeed.
    
            It would be simpler to put such ->open() into default ->i_fop and leave
    it unchanged both for anon inode (as we do anyway) and for socket ones.  Result:
            * everything going through do_dentry_open() works as it used to
            * sock_no_open() kludge is gone
            * attempts to reopen anon-inode files fail as they really ought to
            * ditto for aio_private_file()
            * ditto for perfmon - this one actually tried to imitate sock_no_open()
    trick, but failed to set ->i_fop, so in the current tree reopens succeed and
    yield completely useless descriptor.  Intent clearly had been to fail with
    -ENXIO on such reopens; now it actually does.
            * everything else that used alloc_file() keeps working - it has ->i_fop
    set for its inodes anyway
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2beddc284bc2..b37beaf7a3a5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2151,7 +2151,6 @@ static inline int sb_is_blkdev_sb(struct super_block *sb)
 extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
-extern const struct file_operations bad_sock_fops;
 #ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);

commit cbfe0de303a55ed96d8831c2d5f56f8131cd6612
Merge: 8322b6fddfd2 ba00410b8131
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 16:10:49 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS changes from Al Viro:
     "First pile out of several (there _definitely_ will be more).  Stuff in
      this one:
    
       - unification of d_splice_alias()/d_materialize_unique()
    
       - iov_iter rewrite
    
       - killing a bunch of ->f_path.dentry users (and f_dentry macro).
    
         Getting that completed will make life much simpler for
         unionmount/overlayfs, since then we'll be able to limit the places
         sensitive to file _dentry_ to reasonably few.  Which allows to have
         file_inode(file) pointing to inode in a covered layer, with dentry
         pointing to (negative) dentry in union one.
    
         Still not complete, but much closer now.
    
       - crapectomy in lustre (dead code removal, mostly)
    
       - "let's make seq_printf return nothing" preparations
    
       - assorted cleanups and fixes
    
      There _definitely_ will be more piles"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      copy_from_iter_nocache()
      new helper: iov_iter_kvec()
      csum_and_copy_..._iter()
      iov_iter.c: handle ITER_KVEC directly
      iov_iter.c: convert copy_to_iter() to iterate_and_advance
      iov_iter.c: convert copy_from_iter() to iterate_and_advance
      iov_iter.c: get rid of bvec_copy_page_{to,from}_iter()
      iov_iter.c: convert iov_iter_zero() to iterate_and_advance
      iov_iter.c: convert iov_iter_get_pages_alloc() to iterate_all_kinds
      iov_iter.c: convert iov_iter_get_pages() to iterate_all_kinds
      iov_iter.c: convert iov_iter_npages() to iterate_all_kinds
      iov_iter.c: iterate_and_advance
      iov_iter.c: macros for iterating over iov_iter
      kill f_dentry macro
      dcache: fix kmemcheck warning in switch_names
      new helper: audit_file()
      nfsd_vfs_write(): use file_inode()
      ncpfs: use file_inode()
      kill f_dentry uses
      lockd: get rid of ->f_path.dentry->d_sb
      ...

commit 1366f5d3129f2abde606214de7afc3dd61781fa3
Merge: 4b0a268eecca fdf2657bc81b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 15:43:30 2014 -0800

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs
    
    Pull quota updates from Jan Kara:
     "Quota improvements and some minor cleanups.
    
      The main portion in the pull request are changes which move i_dquot
      array from struct inode into fs-private part of an inode which saves
      memory for filesystems which don't use VFS quotas"
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jack/linux-fs:
      udf: One function call less in udf_fill_super() after error detection
      udf: Deletion of unnecessary checks before the function call "iput"
      jbd: Deletion of an unnecessary check before the function call "iput"
      vfs: Remove i_dquot field from inode
      jfs: Convert to private i_dquot field
      reiserfs: Convert to private i_dquot field
      ocfs2: Convert to private i_dquot field
      ext4: Convert to private i_dquot field
      ext3: Convert to private i_dquot field
      ext2: Convert to private i_dquot field
      quota: Use function to provide i_dquot pointers
      xfs: Set allowed quota types
      gfs2: Set allowed quota types
      quota: Allow each filesystem to specify which quota types it supports
      quota: Remove const from function declarations
      quota: Add log level to printk

commit 8ce74dd6057832618957fc2cbd38fa959c3a0a6c
Merge: 78d28e651f97 9761536e1d9e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 19 13:02:53 2014 -0500

    Merge tag 'trace-seq-file-cleanup' of git://git.kernel.org/pub/scm/linux/kernel/git/rostedt/linux-trace into for-next
    
    Pull the beginning of seq_file cleanup from Steven:
      "I'm looking to clean up the seq_file code and to eventually merge the
      trace_seq code with seq_file as well, since they basically do the same thing.
    
      Part of this process is to remove the return code of seq_printf() and friends
      as they are rather inconsistent. It is better to use the new function
      seq_has_overflowed() if you want to stop processing when the buffer
      is full. Note, if the buffer is full, the seq_file code will throw away
      the contents, allocate a bigger buffer, and then call your code again
      to fill in the data. The only thing that breaking out of the function
      early does is to save a little time which is probably never noticed.
    
      I started with patches from Joe Perches and modified them as well.
      There's many more places that need to be updated before we can convert
      seq_printf() and friends to return void. But this patch set introduces
      the seq_has_overflowed() and does some initial updates."

commit 78d28e651f97866d608d9b41f8ad291e65d47dd5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 31 01:22:04 2014 -0400

    kill f_dentry macro
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1c12c681803f..1a8bb3c023a1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -789,7 +789,6 @@ struct file {
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
 	struct path		f_path;
-#define f_dentry	f_path.dentry
 	struct inode		*f_inode;	/* cached value */
 	const struct file_operations	*f_op;
 

commit 56429e9b3be567a173bd05f5594faf8522c34d3a
Merge: 5b095e99928c 093a1468b6ed
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Nov 19 12:06:30 2014 -0500

    merge nfs bugfixes into nfsd for-3.19 branch
    
    In addition to nfsd bugfixes, there are some fixes in -rc5 for client
    bugs that can interfere with my testing.

commit a6aacbde406eeb6f8fc218b2c6172825f5e73fcf
Merge: b10778a00d40 6fb5032ebb1c
Author: James Morris <james.l.morris@oracle.com>
Date:   Wed Nov 19 21:36:07 2014 +1100

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/zohar/linux-integrity into next

commit 6fb5032ebb1c5b852461d64ee33829081de8ca61
Author: Dmitry Kasatkin <d.kasatkin@samsung.com>
Date:   Wed Nov 5 17:01:17 2014 +0200

    VFS: refactor vfs_read()
    
    integrity_kernel_read() duplicates the file read operations code
    in vfs_read(). This patch refactors vfs_read() code creating a
    helper function __vfs_read(). It is used by both vfs_read() and
    integrity_kernel_read().
    
    Signed-off-by: Dmitry Kasatkin <d.kasatkin@samsung.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e11d60cc867b..ac3a36e05da9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1527,6 +1527,7 @@ ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      struct iovec *fast_pointer,
 			      struct iovec **ret_pointer);
 
+extern ssize_t __vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,

commit 48b6bca6b7b8309697fc8a101793befe92d249d9
Author: Benjamin Marzinski <bmarzins@redhat.com>
Date:   Thu Nov 13 20:42:03 2014 -0600

    fs: add freeze_super/thaw_super fs hooks
    
    Currently, freezing a filesystem involves calling freeze_super, which locks
    sb->s_umount and then calls the fs-specific freeze_fs hook. This makes it
    hard for gfs2 (and potentially other cluster filesystems) to use the vfs
    freezing code to do freezes on all the cluster nodes.
    
    In order to communicate that a freeze has been requested, and to make sure
    that only one node is trying to freeze at a time, gfs2 uses a glock
    (sd_freeze_gl). The problem is that there is no hook for gfs2 to acquire
    this lock before calling freeze_super. This means that two nodes can
    attempt to freeze the filesystem by both calling freeze_super, acquiring
    the sb->s_umount lock, and then attempting to grab the cluster glock
    sd_freeze_gl. Only one will succeed, and the other will be stuck in
    freeze_super, making it impossible to finish freezing the node.
    
    To solve this problem, this patch adds the freeze_super and thaw_super
    hooks.  If a filesystem implements these hooks, they are called instead of
    the vfs freeze_super and thaw_super functions. This means that every
    filesystem that implements these hooks must call the vfs freeze_super and
    thaw_super functions itself within the hook function to make use of the vfs
    freezing code.
    
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Benjamin Marzinski <bmarzins@redhat.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab779e8a63c..b4a1d73c0d5d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1577,7 +1577,9 @@ struct super_operations {
 	void (*evict_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
 	int (*sync_fs)(struct super_block *sb, int wait);
+	int (*freeze_super) (struct super_block *);
 	int (*freeze_fs) (struct super_block *);
+	int (*thaw_super) (struct super_block *);
 	int (*unfreeze_fs) (struct super_block *);
 	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);

commit 75cbe701a4251fcd8b846d52ae42f88c9a8e5e93
Author: Jan Kara <jack@suse.cz>
Date:   Mon Sep 29 15:10:26 2014 +0200

    vfs: Remove i_dquot field from inode
    
    All filesystems using VFS quotas are now converted to use their private
    i_dquot fields. Remove the i_dquot field from generic inode structure.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8c093ad49522..6eb5337688bd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -606,9 +606,6 @@ struct inode {
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock	*i_flock;
 	struct address_space	i_data;
-#ifdef CONFIG_QUOTA
-	struct dquot		*i_dquot[MAXQUOTAS];
-#endif
 	struct list_head	i_devices;
 	union {
 		struct pipe_inode_info	*i_pipe;

commit 2d0fa467915ed0c5957c992011b7f142a7dedf8e
Author: Jan Kara <jack@suse.cz>
Date:   Thu Sep 25 16:36:14 2014 +0200

    quota: Use function to provide i_dquot pointers
    
    i_dquot array is used by relatively few filesystems (ext?, ocfs2, jfs,
    reiserfs) so it is beneficial to move this array to fs-private part of
    the inode. We cannot just pass quota pointers from filesystems to quota
    functions because during quotaon and quotaoff we have to traverse list
    of all inodes and manipulate i_dquot pointers for each inode. So we
    provide a function which generic quota code can use to get pointer to
    the i_dquot array from the filesystem.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cf55a5483d40..8c093ad49522 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1591,6 +1591,7 @@ struct super_operations {
 #ifdef CONFIG_QUOTA
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
+	struct dquot **(*get_dquots)(struct inode *);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
 	long (*nr_cached_objects)(struct super_block *, int);

commit 2c5f648aa24a7c8f0668d8ce5722d69da5bef739
Author: Jan Kara <jack@suse.cz>
Date:   Tue Sep 30 10:43:09 2014 +0200

    quota: Allow each filesystem to specify which quota types it supports
    
    Currently all filesystems supporting VFS quota support user and group
    quotas. With introduction of project quotas this is going to change so
    make sure filesystem isn't called for quota type it doesn't support by
    introduction of a bitmask determining which quota types each filesystem
    supports.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab779e8a63c..cf55a5483d40 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1224,6 +1224,7 @@ struct super_block {
 	struct backing_dev_info *s_bdi;
 	struct mtd_info		*s_mtd;
 	struct hlist_node	s_instances;
+	unsigned int		s_quota_types;	/* Bitmask of supported quota types */
 	struct quota_info	s_dquot;	/* Diskquota specific options */
 
 	struct sb_writers	s_writers;

commit 72c72bdf7bf53353d2d8e055194d27f0128be92b
Author: Anna Schumaker <Anna.Schumaker@netapp.com>
Date:   Fri Nov 7 14:44:25 2014 -0500

    VFS: Rename do_fallocate() to vfs_fallocate()
    
    This function needs to be exported so it can be used by the NFSD module
    when responding to the new ALLOCATE and DEALLOCATE operations in NFS
    v4.2.  Christoph Hellwig suggested renaming the function to stay
    consistent with how other vfs functions are named.
    
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a957d4366c24..a88718677579 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2032,7 +2032,7 @@ struct filename {
 extern long vfs_truncate(struct path *, loff_t);
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
-extern int do_fallocate(struct file *file, int mode, loff_t offset,
+extern int vfs_fallocate(struct file *file, int mode, loff_t offset,
 			loff_t len);
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
 			umode_t mode);

commit a3816ab0e8fe542a89a53b82506a8ddac063fbe3
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 29 16:08:25 2014 -0700

    fs: Convert show_fdinfo functions to void
    
    seq_printf functions shouldn't really check the return value.
    Checking seq_has_overflowed() occasionally is used instead.
    
    Update vfs documentation.
    
    Link: http://lkml.kernel.org/p/e37e6e7b76acbdcc3bb4ab2a57c8f8ca1ae11b9a.1412031505.git.joe@perches.com
    
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Joe Perches <joe@perches.com>
    [ did a few clean ups ]
    Signed-off-by: Steven Rostedt <rostedt@goodmis.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a957d4366c24..01dd9052a142 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1491,7 +1491,7 @@ struct file_operations {
 	int (*setlease)(struct file *, long, struct file_lock **, void **);
 	long (*fallocate)(struct file *file, int mode, loff_t offset,
 			  loff_t len);
-	int (*show_fdinfo)(struct seq_file *m, struct file *f);
+	void (*show_fdinfo)(struct seq_file *m, struct file *f);
 };
 
 struct inode_operations {

commit a7400222e3eb7d5ce3820d2234905bbeafabd171
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Oct 21 15:20:42 2014 -0400

    new helper: is_root_inode()
    
    replace open-coded instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 00c8e4f65cb6..1c12c681803f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2789,6 +2789,11 @@ static inline void inode_has_no_xattr(struct inode *inode)
 		inode->i_flags |= S_NOSEC;
 }
 
+static inline bool is_root_inode(struct inode *inode)
+{
+	return inode == inode->i_sb->s_root->d_inode;
+}
+
 static inline bool dir_emit(struct dir_context *ctx,
 			    const char *name, int namelen,
 			    u64 ino, unsigned type)

commit ac7576f4b1da8c9c6bc1ae026c2b9e86ae617ba5
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu Oct 30 17:37:34 2014 +0100

    vfs: make first argument of dir_context.actor typed
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ab779e8a63c..00c8e4f65cb6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1467,7 +1467,10 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
  * This allows the kernel to read directories into kernel space or
  * to have different dirent layouts depending on the binary type.
  */
-typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
+struct dir_context;
+typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,
+			 unsigned);
+
 struct dir_context {
 	const filldir_t actor;
 	loff_t pos;

commit b2de525f095708b2adbadaec3f1e4017a23d1e09
Author: David Jeffery <djeffery@redhat.com>
Date:   Mon Sep 29 10:21:10 2014 -0400

    Return short read or 0 at end of a raw device, not EIO
    
    Author: David Jeffery <djeffery@redhat.com>
    Changes to the basic direct I/O code have broken the raw driver when reading
    to the end of a raw device.  Instead of returning a short read for a read that
    extends partially beyond the device's end or 0 when at the end of the device,
    these reads now return EIO.
    
    The raw driver needs the same end of device handling as was added for normal
    block devices.  Using blkdev_read_iter, which has the needed size checks,
    prevents the EIO conditions at the end of the device.
    
    Signed-off-by: David Jeffery <djeffery@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 01036262095f..9ab779e8a63c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2469,6 +2469,7 @@ extern ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, lo
 extern ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 
 /* fs/block_dev.c */
+extern ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to);
 extern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);
 extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
 			int datasync);

commit d1b72cc6d8cb766c802fdc70a5edc2f0ba8a2b57
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Oct 27 15:42:01 2014 +0100

    overlayfs: fix lockdep misannotation
    
    In an overlay directory that shadows an empty lower directory, say
    /mnt/a/empty102, do:
    
            touch /mnt/a/empty102/x
            unlink /mnt/a/empty102/x
            rmdir /mnt/a/empty102
    
    It's actually harmless, but needs another level of nesting between
    I_MUTEX_CHILD and I_MUTEX_NORMAL.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4e41a4a331bb..01036262095f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -639,11 +639,13 @@ static inline int inode_unhashed(struct inode *inode)
  * 2: child/target
  * 3: xattr
  * 4: second non-directory
- * The last is for certain operations (such as rename) which lock two
+ * 5: second parent (when locking independent directories in rename)
+ *
+ * I_MUTEX_NONDIR2 is for certain operations (such as rename) which lock two
  * non-directories at once.
  *
  * The locking order between these classes is
- * parent -> child -> normal -> xattr -> second non-directory
+ * parent[2] -> child -> grandchild -> normal -> xattr -> second non-directory
  */
 enum inode_i_mutex_lock_class
 {
@@ -651,7 +653,8 @@ enum inode_i_mutex_lock_class
 	I_MUTEX_PARENT,
 	I_MUTEX_CHILD,
 	I_MUTEX_XATTR,
-	I_MUTEX_NONDIR2
+	I_MUTEX_NONDIR2,
+	I_MUTEX_PARENT2,
 };
 
 void lock_two_nondirectories(struct inode *, struct inode*);

commit 69c433ed2ecd2d3264efd7afec4439524b319121
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:39 2014 +0200

    fs: limit filesystem stacking depth
    
    Add a simple read-only counter to super_block that indicates how deep this
    is in the stack of filesystems.  Previously ecryptfs was the only stackable
    filesystem and it explicitly disallowed multiple layers of itself.
    
    Overlayfs, however, can be stacked recursively and also may be stacked
    on top of ecryptfs or vice versa.
    
    To limit the kernel stack usage we must limit the depth of the
    filesystem stack.  Initially the limit is set to 2.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 69118b3cb917..4e41a4a331bb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -261,6 +261,12 @@ struct iattr {
  */
 #include <linux/quota.h>
 
+/*
+ * Maximum number of layers of fs stack.  Needs to be limited to
+ * prevent kernel stack overflow
+ */
+#define FILESYSTEM_MAX_STACK_DEPTH 2
+
 /** 
  * enum positive_aop_returns - aop return codes with specific semantics
  *
@@ -1273,6 +1279,11 @@ struct super_block {
 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 	struct rcu_head		rcu;
+
+	/*
+	 * Indicates how deep in a filesystem stack this SB is
+	 */
+	int s_stack_depth;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:36 2014 +0200

    vfs: add whiteout support
    
    Whiteout isn't actually a new file type, but is represented as a char
    device (Linus's idea) with 0/0 device number.
    
    This has several advantages compared to introducing a new whiteout file
    type:
    
     - no userspace API changes (e.g. trivial to make backups of upper layer
       filesystem, without losing whiteouts)
    
     - no fs image format changes (you can boot an old kernel/fsck without
       whiteout support and things won't break)
    
     - implementation is trivial
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 55cc0a319baa..69118b3cb917 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -222,6 +222,13 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
 #define ATTR_TIMES_SET	(1 << 16)
 
+/*
+ * Whiteout is represented by a char device.  The following constants define the
+ * mode and device number to use.
+ */
+#define WHITEOUT_MODE 0
+#define WHITEOUT_DEV 0
+
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
  * uses the above definitions as flags, to know which values have changed.
@@ -1398,6 +1405,7 @@ extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct ino
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
+extern int vfs_whiteout(struct inode *, struct dentry *);
 
 /*
  * VFS dentry helper functions.
@@ -1628,6 +1636,9 @@ struct super_operations {
 #define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
 #define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
 
+#define IS_WHITEOUT(inode)	(S_ISCHR(inode->i_mode) && \
+				 (inode)->i_rdev == WHITEOUT_DEV)
+
 /*
  * Inode state bits.  Protected by inode->i_lock
  *

commit cbdf35bcb833bfd00f0925d7a9a33a21f41ea582
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:36 2014 +0200

    vfs: export check_sticky()
    
    It's already duplicated in btrfs and about to be used in overlayfs too.
    
    Move the sticky bit check to an inline helper and call the out-of-line
    helper only in the unlikly case of the sticky bit being set.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5419df70a835..55cc0a319baa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2259,6 +2259,7 @@ extern int notify_change(struct dentry *, struct iattr *, struct inode **);
 extern int inode_permission(struct inode *, int);
 extern int __inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int);
+extern int __check_sticky(struct inode *dir, struct inode *inode);
 
 static inline bool execute_ok(struct inode *inode)
 {
@@ -2745,6 +2746,14 @@ static inline int is_sxid(umode_t mode)
 	return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));
 }
 
+static inline int check_sticky(struct inode *dir, struct inode *inode)
+{
+	if (!(dir->i_mode & S_ISVTX))
+		return 0;
+
+	return __check_sticky(dir, inode);
+}
+
 static inline void inode_has_no_xattr(struct inode *inode)
 {
 	if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & MS_NOSEC))

commit bd5d08569cc379f8366663a61558a9ce17c2e460
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:35 2014 +0200

    vfs: export __inode_permission() to modules
    
    We need to be able to check inode permissions (but not filesystem implied
    permissions) for stackable filesystems.  Expose this interface for overlayfs.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 10ed65b2c31d..5419df70a835 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2257,6 +2257,7 @@ extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct iattr *, struct inode **);
 extern int inode_permission(struct inode *, int);
+extern int __inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int);
 
 static inline bool execute_ok(struct inode *inode)

commit 1c118596a7682912106c80007102ce0184c77780
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:35 2014 +0200

    vfs: export do_splice_direct() to modules
    
    Export do_splice_direct() to modules.  Needed by overlay filesystem.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5cf7f6759679..10ed65b2c31d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2456,6 +2456,9 @@ extern ssize_t iter_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
 		struct file *out, loff_t *, size_t len, unsigned int flags);
+extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
+		loff_t *opos, size_t len, unsigned int flags);
+
 
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);

commit 4aa7c6346be395bdf776f82bbb2e3e2bc60bdd2b
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 24 00:14:35 2014 +0200

    vfs: add i_op->dentry_open()
    
    Add a new inode operation i_op->dentry_open().  This is for stacked filesystems
    that want to return a struct file from a different filesystem.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a957d4366c24..5cf7f6759679 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1528,6 +1528,9 @@ struct inode_operations {
 			   umode_t create_mode, int *opened);
 	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 	int (*set_acl)(struct inode *, struct posix_acl *, int);
+
+	/* WARNING: probably going away soon, do not use! */
+	int (*dentry_open)(struct dentry *, struct file *, const struct cred *);
 } ____cacheline_aligned;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
@@ -2040,6 +2043,7 @@ extern struct file *file_open_name(struct filename *, int, umode_t);
 extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int);
+extern int vfs_open(const struct path *, struct file *, const struct cred *);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 

commit d3dc366bbaf07c125561e90d6da4bb147741101a
Merge: 511c41d9e666 e19a8a0ad2d2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 18 11:53:51 2014 -0700

    Merge branch 'for-3.18/core' of git://git.kernel.dk/linux-block
    
    Pull core block layer changes from Jens Axboe:
     "This is the core block IO pull request for 3.18.  Apart from the new
      and improved flush machinery for blk-mq, this is all mostly bug fixes
      and cleanups.
    
       - blk-mq timeout updates and fixes from Christoph.
    
       - Removal of REQ_END, also from Christoph.  We pass it through the
         ->queue_rq() hook for blk-mq instead, freeing up one of the request
         bits.  The space was overly tight on 32-bit, so Martin also killed
         REQ_KERNEL since it's no longer used.
    
       - blk integrity updates and fixes from Martin and Gu Zheng.
    
       - Update to the flush machinery for blk-mq from Ming Lei.  Now we
         have a per hardware context flush request, which both cleans up the
         code should scale better for flush intensive workloads on blk-mq.
    
       - Improve the error printing, from Rob Elliott.
    
       - Backing device improvements and cleanups from Tejun.
    
       - Fixup of a misplaced rq_complete() tracepoint from Hannes.
    
       - Make blk_get_request() return error pointers, fixing up issues
         where we NULL deref when a device goes bad or missing.  From Joe
         Lawrence.
    
       - Prep work for drastically reducing the memory consumption of dm
         devices from Junichi Nomura.  This allows creating clone bio sets
         without preallocating a lot of memory.
    
       - Fix a blk-mq hang on certain combinations of queue depths and
         hardware queues from me.
    
       - Limit memory consumption for blk-mq devices for crash dump
         scenarios and drivers that use crazy high depths (certain SCSI
         shared tag setups).  We now just use a single queue and limited
         depth for that"
    
    * 'for-3.18/core' of git://git.kernel.dk/linux-block: (58 commits)
      block: Remove REQ_KERNEL
      blk-mq: allocate cpumask on the home node
      bio-integrity: remove the needless fail handle of bip_slab creating
      block: include func name in __get_request prints
      block: make blk_update_request print prefix match ratelimited prefix
      blk-merge: don't compute bi_phys_segments from bi_vcnt for cloned bio
      block: fix alignment_offset math that assumes io_min is a power-of-2
      blk-mq: Make bt_clear_tag() easier to read
      blk-mq: fix potential hang if rolling wakeup depth is too high
      block: add bioset_create_nobvec()
      block: use bio_clone_fast() in blk_rq_prep_clone()
      block: misplaced rq_complete tracepoint
      sd: Honor block layer integrity handling flags
      block: Replace strnicmp with strncasecmp
      block: Add T10 Protection Information functions
      block: Don't merge requests if integrity flags differ
      block: Integrity checksum flag
      block: Relocate bio integrity flags
      block: Add a disk flag to block integrity profile
      block: Add prefix to block integrity profile flags
      ...

commit e19a8a0ad2d255316830ead05b59c5a704434cbb
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Tue Oct 14 09:00:44 2014 -0600

    block: Remove REQ_KERNEL
    
    REQ_KERNEL is no longer used. Remove it and drop the redundant uio
    argument to nfs_file_direct_{read,write}.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 94187721ad41..9b5bc1cacb8e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -192,8 +192,6 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define READ			0
 #define WRITE			RW_MASK
 #define READA			RWA_MASK
-#define KERNEL_READ		(READ|REQ_KERNEL)
-#define KERNEL_WRITE		(WRITE|REQ_KERNEL)
 
 #define READ_SYNC		(READ | REQ_SYNC)
 #define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)

commit 77c688ac87183537ed0fb84ec2cb8fa8ec97c458
Merge: 5e40d331bd72 a457606a6f81
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 13 11:28:42 2014 +0200

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "The big thing in this pile is Eric's unmount-on-rmdir series; we
      finally have everything we need for that.  The final piece of prereqs
      is delayed mntput() - now filesystem shutdown always happens on
      shallow stack.
    
      Other than that, we have several new primitives for iov_iter (Matt
      Wilcox, culled from his XIP-related series) pushing the conversion to
      ->read_iter()/ ->write_iter() a bit more, a bunch of fs/dcache.c
      cleanups and fixes (including the external name refcounting, which
      gives consistent behaviour of d_move() wrt procfs symlinks for long
      and short names alike) and assorted cleanups and fixes all over the
      place.
    
      This is just the first pile; there's a lot of stuff from various
      people that ought to go in this window.  Starting with
      unionmount/overlayfs mess...  ;-/"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (60 commits)
      fs/file_table.c: Update alloc_file() comment
      vfs: Deduplicate code shared by xattr system calls operating on paths
      reiserfs: remove pointless forward declaration of struct nameidata
      don't need that forward declaration of struct nameidata in dcache.h anymore
      take dname_external() into fs/dcache.c
      let path_init() failures treated the same way as subsequent link_path_walk()
      fix misuses of f_count() in ppp and netlink
      ncpfs: use list_for_each_entry() for d_subdirs walk
      vfs: move getname() from callers to do_mount()
      gfs2_atomic_open(): skip lookups on hashed dentry
      [infiniband] remove pointless assignments
      gadgetfs: saner API for gadgetfs_create_file()
      f_fs: saner API for ffs_sb_create_file()
      jfs: don't hash direct inode
      [s390] remove pointless assignment of ->f_op in vmlogrdr ->open()
      ecryptfs: ->f_op is never NULL
      android: ->f_op is never NULL
      nouveau: __iomem misannotations
      missing annotation in fs/file.c
      fs: namespace: suppress 'may be used uninitialized' warnings
      ...

commit 5e6123f3477e4260fb14392f0a88f1a842fa4d42
Author: Seunghun Lee <waydi1@gmail.com>
Date:   Sun Sep 14 22:15:10 2014 +0900

    vfs: move getname() from callers to do_mount()
    
    It would make more sense to pass char __user * instead of
    char * in callers of do_mount() and do getname() inside do_mount().
    
    Suggested-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Seunghun Lee <waydi1@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 75bdd51ec9b8..92148361bef8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1855,7 +1855,8 @@ extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
 extern void kern_unmount(struct vfsmount *mnt);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
-extern long do_mount(const char *, const char *, const char *, unsigned long, void *);
+extern long do_mount(const char *, const char __user *,
+		     const char *, unsigned long, void *);
 extern struct vfsmount *collect_mounts(struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,

commit 1fa97e8b1f327059aa98089abd8c3378cdf43017
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 7 20:47:49 2014 -0400

    constify file_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 94187721ad41..75bdd51ec9b8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1874,7 +1874,7 @@ extern int current_umask(void);
 extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
 
-static inline struct inode *file_inode(struct file *f)
+static inline struct inode *file_inode(const struct file *f)
 {
 	return f->f_inode;
 }

commit 1b2b32dcdb3df28dd103033c73cac2417fa05845
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Sep 24 08:38:44 2014 -0400

    locks: fix fcntl_setlease/getlease return when !CONFIG_FILE_LOCKING
    
    Currently they both just return 0. Fix them to return more appropriate
    values instead.
    
    For better or worse, most places in the kernel return -EINVAL when
    leases aren't available. -ENOLCK would probably have been better, but
    let's follow suit here in the case of F_SETLEASE.
    
    In the F_GETLEASE case, just return F_UNLCK since we know that no
    lease will have been set.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bb9484ae1eef..2023306c620e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1008,12 +1008,12 @@ static inline int fcntl_setlk64(unsigned int fd, struct file *file,
 #endif
 static inline int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 {
-	return 0;
+	return -EINVAL;
 }
 
 static inline int fcntl_getlease(struct file *filp)
 {
-	return 0;
+	return F_UNLCK;
 }
 
 static inline void locks_init_lock(struct file_lock *fl)

commit 7ca76311fe6c397e9f332e5e6c79e3310d5ee98a
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Mon Sep 1 19:04:48 2014 -0400

    locks: set fl_owner for leases to filp instead of current->files
    
    Like flock locks, leases are owned by the file description. Now that the
    i_have_this_lease check in __break_lease is gone, we don't actually use
    the fl_owner for leases for anything. So, it's now safe to set this more
    appropriately to the same value as the fl_file.
    
    While we're at it, fix up the comments over the fl_owner_t definition
    since they're rather out of date.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed4e1897099c..bb9484ae1eef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -851,13 +851,7 @@ static inline struct file *get_file(struct file *f)
  */
 #define FILE_LOCK_DEFERRED 1
 
-/*
- * The POSIX file lock owner is determined by
- * the "struct files_struct" in the thread group
- * (or NULL for no owner - BSD locks).
- *
- * Lockd stuffs a "host" pointer into this.
- */
+/* legacy typedef, should eventually be removed */
 typedef void *fl_owner_t;
 
 struct file_lock_operations {

commit 4d01b7f5e7576858b71cbaa72b541e17a229cb91
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Mon Sep 1 15:06:54 2014 -0400

    locks: give lm_break a return value
    
    Christoph suggests:
    
       "Add a return value to lm_break so that the lock manager can tell the
        core code "you can delete this lease right now".  That gets rid of
        the games with the timeout which require all kinds of race avoidance
        code in the users."
    
    Do that here and have the nfsd lease break routine use it when it detects
    that there was a race between setting up the lease and it being broken.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f419f718e447..ed4e1897099c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -872,7 +872,7 @@ struct lock_manager_operations {
 	void (*lm_put_owner)(struct file_lock *);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, int);
-	void (*lm_break)(struct file_lock *);
+	bool (*lm_break)(struct file_lock *);
 	int (*lm_change)(struct file_lock **, int, struct list_head *);
 	void (*lm_setup)(struct file_lock *, void **);
 };

commit c45198eda2794bb72601c9f96266d8b95db66dd5
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Mon Sep 1 07:12:07 2014 -0400

    locks: move freeing of leases outside of i_lock
    
    There was only one place where we still could free a file_lock while
    holding the i_lock -- lease_modify. Add a new list_head argument to the
    lm_change operation, pass in a private list when calling it, and fix
    those callers to dispose of the list once the lock has been dropped.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9a6d56154dd5..f419f718e447 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -873,7 +873,7 @@ struct lock_manager_operations {
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, int);
 	void (*lm_break)(struct file_lock *);
-	int (*lm_change)(struct file_lock **, int);
+	int (*lm_change)(struct file_lock **, int, struct list_head *);
 	void (*lm_setup)(struct file_lock *, void **);
 };
 
@@ -985,7 +985,7 @@ extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int t
 extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
 extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
-extern int lease_modify(struct file_lock **, int);
+extern int lease_modify(struct file_lock **, int, struct list_head *);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, unsigned int cmd,
 			      struct flock __user *user)
@@ -1112,7 +1112,8 @@ static inline int vfs_setlease(struct file *filp, long arg,
 	return -EINVAL;
 }
 
-static inline int lease_modify(struct file_lock **before, int arg)
+static inline int lease_modify(struct file_lock **before, int arg,
+			       struct list_head *dispose)
 {
 	return -EINVAL;
 }

commit 1c7dd2ff430fa14b45c9def54468e3a25ab8342b
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Aug 22 10:55:47 2014 -0400

    locks: define a lm_setup handler for leases
    
    ...and move the fasync setup into it for fcntl lease calls. At the same
    time, change the semantics of how the file_lock double-pointer is
    handled. Up until now, on a successful lease return you got a pointer to
    the lock on the list. This is bad, since that pointer can no longer be
    relied on as valid once the inode->i_lock has been released.
    
    Change the code to instead just zero out the pointer if the lease we
    passed in ended up being used. Then the callers can just check to see
    if it's NULL after the call and free it if it isn't.
    
    The priv argument has the same semantics. The lm_setup function can
    zero the pointer out to signal to the caller that it should not be
    freed after the function returns.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f1870eb67b02..9a6d56154dd5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -874,6 +874,7 @@ struct lock_manager_operations {
 	int (*lm_grant)(struct file_lock *, int);
 	void (*lm_break)(struct file_lock *);
 	int (*lm_change)(struct file_lock **, int);
+	void (*lm_setup)(struct file_lock *, void **);
 };
 
 struct lock_manager {

commit e6f5c78930e409f3a6b37f5484313a416359ac7f
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Aug 22 10:40:25 2014 -0400

    locks: plumb a "priv" pointer into the setlease routines
    
    In later patches, we're going to add a new lock_manager_operation to
    finish setting up the lease while still holding the i_lock.  To do
    this, we'll need to pass a little bit of info in the fcntl setlease
    case (primarily an fasync structure). Plumb the extra pointer into
    there in advance of that.
    
    We declare this pointer as a void ** to make it clear that this is
    private info, and that the caller isn't required to set this unless
    the lm_setup specifically requires it.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 96528f73dda4..f1870eb67b02 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -982,8 +982,8 @@ extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
-extern int generic_setlease(struct file *, long, struct file_lock **);
-extern int vfs_setlease(struct file *, long, struct file_lock **);
+extern int generic_setlease(struct file *, long, struct file_lock **, void **priv);
+extern int vfs_setlease(struct file *, long, struct file_lock **, void **);
 extern int lease_modify(struct file_lock **, int);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, unsigned int cmd,
@@ -1100,13 +1100,13 @@ static inline void lease_get_mtime(struct inode *inode, struct timespec *time)
 }
 
 static inline int generic_setlease(struct file *filp, long arg,
-				    struct file_lock **flp)
+				    struct file_lock **flp, void **priv)
 {
 	return -EINVAL;
 }
 
 static inline int vfs_setlease(struct file *filp, long arg,
-			       struct file_lock **lease)
+			       struct file_lock **lease, void **priv)
 {
 	return -EINVAL;
 }
@@ -1494,7 +1494,7 @@ struct file_operations {
 	int (*flock) (struct file *, int, struct file_lock *);
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
-	int (*setlease)(struct file *, long, struct file_lock **);
+	int (*setlease)(struct file *, long, struct file_lock **, void **);
 	long (*fallocate)(struct file *file, int mode, loff_t offset,
 			  loff_t len);
 	int (*show_fdinfo)(struct seq_file *m, struct file *f);
@@ -2599,7 +2599,7 @@ extern int simple_write_end(struct file *file, struct address_space *mapping,
 			struct page *page, void *fsdata);
 extern int always_delete_dentry(const struct dentry *);
 extern struct inode *alloc_anon_inode(struct super_block *);
-extern int simple_nosetlease(struct file *, long, struct file_lock **);
+extern int simple_nosetlease(struct file *, long, struct file_lock **, void **);
 extern const struct dentry_operations simple_dentry_operations;
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);

commit e0b93eddfe17dcb7d644eb5d6ad02a86fc41a977
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Aug 22 11:27:32 2014 -0400

    security: make security_file_set_fowner, f_setown and __f_setown void return
    
    security_file_set_fowner always returns 0, so make it f_setown and
    __f_setown void return functions and fix up the error handling in the
    callers.
    
    Cc: linux-security-module@vger.kernel.org
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 435e3d9ec5cf..96528f73dda4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1139,8 +1139,8 @@ extern void fasync_free(struct fasync_struct *);
 /* can be called from interrupts */
 extern void kill_fasync(struct fasync_struct **, int, int);
 
-extern int __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
-extern int f_setown(struct file *filp, unsigned long arg, int force);
+extern void __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
+extern void f_setown(struct file *filp, unsigned long arg, int force);
 extern void f_delown(struct file *filp);
 extern pid_t f_getown(struct file *filp);
 extern int send_sigurg(struct fown_struct *fown);

commit 1c994a0909a556508c2cc26ab5d9e13c5ce33aa0
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Wed Aug 27 06:49:41 2014 -0400

    locks: consolidate "nolease" routines
    
    GFS2 and NFS have setlease routines that always just return -EINVAL.
    Turn that into a generic routine that can live in fs/libfs.c.
    
    Cc: <linux-nfs@vger.kernel.org>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: <cluster-devel@redhat.com>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>
    Acked-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 458f733c96bd..435e3d9ec5cf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2599,6 +2599,7 @@ extern int simple_write_end(struct file *file, struct address_space *mapping,
 			struct page *page, void *fsdata);
 extern int always_delete_dentry(const struct dentry *);
 extern struct inode *alloc_anon_inode(struct super_block *);
+extern int simple_nosetlease(struct file *, long, struct file_lock **);
 extern const struct dentry_operations simple_dentry_operations;
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);

commit 699688a416524c3cea9eafaca69fc6c06c13c02e
Author: Jeff Layton <jlayton@primarydata.com>
Date:   Fri Aug 22 10:18:44 2014 -0400

    locks: remove lock_may_read and lock_may_write
    
    There are no callers of these functions.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3b07ce2698de..458f733c96bd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -985,8 +985,6 @@ extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **);
 extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
-extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
-extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, unsigned int cmd,
 			      struct flock __user *user)
@@ -1117,18 +1115,6 @@ static inline int lease_modify(struct file_lock **before, int arg)
 {
 	return -EINVAL;
 }
-
-static inline int lock_may_read(struct inode *inode, loff_t start,
-				unsigned long len)
-{
-	return 1;
-}
-
-static inline int lock_may_write(struct inode *inode, loff_t start,
-				 unsigned long len)
-{
-	return 1;
-}
 #endif /* !CONFIG_FILE_LOCKING */
 
 

commit 5c97d7b1479982a48cf2129062b880c2555049ac
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Fri Aug 22 10:18:43 2014 -0400

    locks: New ops in lock_manager_operations for get/put owner
    
    NFSD or other lockmanager may increase the owner's reference,
    so adds two new options for copying and releasing owner.
    
    v5: change order from 2/6 to 3/6
    v4: rename lm_copy_owner/lm_release_owner to lm_get_owner/lm_put_owner
    
    Reviewed-by: Jeff Layton <jlayton@primarydata.com>
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5ab86f44b697..3b07ce2698de 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -868,6 +868,8 @@ struct file_lock_operations {
 struct lock_manager_operations {
 	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
 	unsigned long (*lm_owner_key)(struct file_lock *);
+	void (*lm_get_owner)(struct file_lock *, struct file_lock *);
+	void (*lm_put_owner)(struct file_lock *);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, int);
 	void (*lm_break)(struct file_lock *);

commit 3fe0fff18fe87c6a2179837de68d1174903c6367
Author: Kinglong Mee <kinglongmee@gmail.com>
Date:   Fri Aug 22 10:18:42 2014 -0400

    locks: Rename __locks_copy_lock() to locks_copy_conflock()
    
    Jeff advice, " Right now __locks_copy_lock is only used to copy
    conflocks. It would be good to rename that to something more
    distinct (i.e.locks_copy_conflock), to make it clear that we're
    generating a conflock there."
    
    v5: change order from 3/6 to 2/6
    v4: new patch only renaming function name
    
    Signed-off-by: Kinglong Mee <kinglongmee@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 908af4f81680..5ab86f44b697 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -966,7 +966,7 @@ void locks_free_lock(struct file_lock *fl);
 extern void locks_init_lock(struct file_lock *);
 extern struct file_lock * locks_alloc_lock(void);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
-extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
+extern void locks_copy_conflock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_file(struct file *);
 extern void locks_release_private(struct file_lock *);
@@ -1026,7 +1026,7 @@ static inline void locks_init_lock(struct file_lock *fl)
 	return;
 }
 
-static inline void __locks_copy_lock(struct file_lock *new, struct file_lock *fl)
+static inline void locks_copy_conflock(struct file_lock *new, struct file_lock *fl)
 {
 	return;
 }

commit d0449b90f80f263e17e8b3ce31442e45121dc46c
Author: Joe Perches <joe@perches.com>
Date:   Fri Aug 22 10:18:42 2014 -0400

    locks: Remove unused conf argument from lm_grant
    
    This argument is always NULL so don't pass it around.
    
    [jlayton: remove dependencies on previous patches in series]
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 94187721ad41..908af4f81680 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -869,7 +869,7 @@ struct lock_manager_operations {
 	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
 	unsigned long (*lm_owner_key)(struct file_lock *);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
-	int (*lm_grant)(struct file_lock *, struct file_lock *, int);
+	int (*lm_grant)(struct file_lock *, int);
 	void (*lm_break)(struct file_lock *);
 	int (*lm_change)(struct file_lock **, int);
 };

commit f6f993328b2abcab86a3c99d7bd9f2066ab03d36
Merge: c7a19c795b4b 12a5b5294cb1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 11 11:44:11 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "Stuff in here:
    
       - acct.c fixes and general rework of mnt_pin mechanism.  That allows
         to go for delayed-mntput stuff, which will permit mntput() on deep
         stack without worrying about stack overflows - fs shutdown will
         happen on shallow stack.  IOW, we can do Eric's umount-on-rmdir
         series without introducing tons of stack overflows on new mntput()
         call chains it introduces.
       - Bruce's d_splice_alias() patches
       - more Miklos' rename() stuff.
       - a couple of regression fixes (stable fodder, in the end of branch)
         and a fix for API idiocy in iov_iter.c.
    
      There definitely will be another pile, maybe even two.  I'd like to
      get Eric's series in this time, but even if we miss it, it'll go right
      in the beginning of for-next in the next cycle - the tricky part of
      prereqs is in this pile"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (40 commits)
      fix copy_tree() regression
      __generic_file_write_iter(): fix handling of sync error after DIO
      switch iov_iter_get_pages() to passing maximal number of pages
      fs: mark __d_obtain_alias static
      dcache: d_splice_alias should detect loops
      exportfs: update Exporting documentation
      dcache: d_find_alias needn't recheck IS_ROOT && DCACHE_DISCONNECTED
      dcache: remove unused d_find_alias parameter
      dcache: d_obtain_alias callers don't all want DISCONNECTED
      dcache: d_splice_alias should ignore DCACHE_DISCONNECTED
      dcache: d_splice_alias mustn't create directory aliases
      dcache: close d_move race in d_splice_alias
      dcache: move d_splice_alias
      namei: trivial fix to vfs_rename_dir comment
      VFS: allow ->d_manage() to declare -EISDIR in rcu_walk mode.
      cifs: support RENAME_NOREPLACE
      hostfs: support rename flags
      shmem: support RENAME_EXCHANGE
      shmem: support RENAME_NOREPLACE
      btrfs: add RENAME_NOREPLACE
      ...

commit 4bb5f5d9395bc112d93a134d8f5b05611eddc9c0
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Fri Aug 8 14:25:25 2014 -0700

    mm: allow drivers to prevent new writable mappings
    
    This patch (of 6):
    
    The i_mmap_writable field counts existing writable mappings of an
    address_space.  To allow drivers to prevent new writable mappings, make
    this counter signed and prevent new writable mappings if it is negative.
    This is modelled after i_writecount and DENYWRITE.
    
    This will be required by the shmem-sealing infrastructure to prevent any
    new writable mappings after the WRITE seal has been set.  In case there
    exists a writable mapping, this operation will fail with EBUSY.
    
    Note that we rely on the fact that iff you already own a writable mapping,
    you can increase the counter without using the helpers.  This is the same
    that we do for i_writecount.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Ryan Lortie <desrt@desrt.ca>
    Cc: Lennart Poettering <lennart@poettering.net>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ab6c6913040..f0890e4a7c25 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -387,7 +387,7 @@ struct address_space {
 	struct inode		*host;		/* owner: inode, block_device */
 	struct radix_tree_root	page_tree;	/* radix tree of all pages */
 	spinlock_t		tree_lock;	/* and lock protecting it */
-	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
+	atomic_t		i_mmap_writable;/* count VM_SHARED mappings */
 	struct rb_root		i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
 	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
@@ -470,10 +470,35 @@ static inline int mapping_mapped(struct address_space *mapping)
  * Note that i_mmap_writable counts all VM_SHARED vmas: do_mmap_pgoff
  * marks vma as VM_SHARED if it is shared, and the file was opened for
  * writing i.e. vma may be mprotected writable even if now readonly.
+ *
+ * If i_mmap_writable is negative, no new writable mappings are allowed. You
+ * can only deny writable mappings, if none exists right now.
  */
 static inline int mapping_writably_mapped(struct address_space *mapping)
 {
-	return mapping->i_mmap_writable != 0;
+	return atomic_read(&mapping->i_mmap_writable) > 0;
+}
+
+static inline int mapping_map_writable(struct address_space *mapping)
+{
+	return atomic_inc_unless_negative(&mapping->i_mmap_writable) ?
+		0 : -EPERM;
+}
+
+static inline void mapping_unmap_writable(struct address_space *mapping)
+{
+	atomic_dec(&mapping->i_mmap_writable);
+}
+
+static inline int mapping_deny_writable(struct address_space *mapping)
+{
+	return atomic_dec_unless_positive(&mapping->i_mmap_writable) ?
+		0 : -EBUSY;
+}
+
+static inline void mapping_allow_writable(struct address_space *mapping)
+{
+	atomic_inc(&mapping->i_mmap_writable);
 }
 
 /*

commit 215752fce31c80f3b3a1530bc7cddb3ba6a69b3a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Aug 7 06:23:41 2014 -0400

    acct: get rid of acct_list
    
    Put these suckers on per-vfsmount and per-superblock lists instead.
    Note: right now it's still acct_lock for everything, but that's
    going to change.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b7d57cf7863..17f70872a4a5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1250,6 +1250,7 @@ struct super_block {
 
 	/* AIO completions deferred from interrupt context */
 	struct workqueue_struct *s_dio_done_wq;
+	struct hlist_head s_pins;
 
 	/*
 	 * Keep the lru lists last in the structure so they always sit on their

commit ed44724b79d8e03a40665436019cf22baba80d30
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 19 14:37:20 2014 -0400

    acct: switch to __kernel_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e11d60cc867b..4b7d57cf7863 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2335,6 +2335,7 @@ extern int do_pipe_flags(int *, int);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
+extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
 extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */

commit 68be302963230fa76600cd598935a830ac95dca2
Author: Joe Perches <joe@perches.com>
Date:   Wed Aug 6 16:08:45 2014 -0700

    fs.h, drivers/hwmon/asus_atk0110.c: fix DEFINE_SIMPLE_ATTRIBUTE semicolon definition and use
    
    The DEFINE_SIMPLE_ATTRIBUTE macro should not end in a ; Fix the one use
    in the kernel tree that did not have a semicolon.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Luca Tettamanti <kronos.it@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2daccaf4b547..1ab6c6913040 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2688,7 +2688,7 @@ static const struct file_operations __fops = {				\
 	.read	 = simple_attr_read,					\
 	.write	 = simple_attr_write,					\
 	.llseek	 = generic_file_llseek,					\
-};
+}
 
 static inline __printf(1, 2)
 void __simple_attr_check_format(const char *fmt, ...)

commit 17fa388ddceb89e9673d83d82cf28ef79e8225d5
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jul 13 17:00:37 2014 +0200

    locks: typedef fl_owner_t to void *
    
    fl_owner_t is a cookie that can store all kinds of different pointers,
    so don't pretends it points to a file structure.
    
    For now just change the typedef, but as a follow on this will allow
    to get rids of lots of casts and eventually the typedef itself.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e11d60cc867b..2daccaf4b547 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -833,7 +833,7 @@ static inline struct file *get_file(struct file *f)
  *
  * Lockd stuffs a "host" pointer into this.
  */
-typedef struct files_struct *fl_owner_t;
+typedef void *fl_owner_t;
 
 struct file_lock_operations {
 	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);

commit 2dfded821097be62dc7ba20d53a9c96d0de13134
Merge: 532f51388b04 0c27362998a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 21 16:40:30 2014 -1000

    Merge tag 'locks-v3.16-2' of git://git.samba.org/jlayton/linux
    
    Pull file locking fixes from Jeff Layton:
     "File locking related bugfixes
    
      Nothing too earth-shattering here.  A fix for a potential regression
      due to a patch in pile #1, and the addition of a memory barrier to
      prevent a race condition between break_deleg and generic_add_lease"
    
    * tag 'locks-v3.16-2' of git://git.samba.org/jlayton/linux:
      locks: set fl_owner for leases back to current->files
      locks: add missing memory barrier in break_deleg

commit 16b9057804c02e2d351e9c8f606e909b43cbd9e7
Merge: 5c02c392cd23 c2338f2dc7c1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 10:30:18 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "This the bunch that sat in -next + lock_parent() fix.  This is the
      minimal set; there's more pending stuff.
    
      In particular, I really hope to get acct.c fixes merged this cycle -
      we need that to deal sanely with delayed-mntput stuff.  In the next
      pile, hopefully - that series is fairly short and localized
      (kernel/acct.c, fs/super.c and fs/namespace.c).  In this pile: more
      iov_iter work.  Most of prereqs for ->splice_write with sane locking
      order are there and Kent's dio rewrite would also fit nicely on top of
      this pile"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (70 commits)
      lock_parent: don't step on stale ->d_parent of all-but-freed one
      kill generic_file_splice_write()
      ceph: switch to iter_file_splice_write()
      shmem: switch to iter_file_splice_write()
      nfs: switch to iter_splice_write_file()
      fs/splice.c: remove unneeded exports
      ocfs2: switch to iter_file_splice_write()
      ->splice_write() via ->write_iter()
      bio_vec-backed iov_iter
      optimize copy_page_{to,from}_iter()
      bury generic_file_aio_{read,write}
      lustre: get rid of messing with iovecs
      ceph: switch to ->write_iter()
      ceph_sync_direct_write: stop poking into iov_iter guts
      ceph_sync_read: stop poking into iov_iter guts
      new helper: copy_page_from_iter()
      fuse: switch to ->write_iter()
      btrfs: switch to ->write_iter()
      ocfs2: switch to ->write_iter()
      xfs: switch to ->write_iter()
      ...

commit 5f073850602084fbcbb987948ff3e70ae273f7d2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 5 13:31:50 2014 -0400

    kill generic_file_splice_write()
    
    no callers left
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8bd8ed357c7b..4e92d551518d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2432,8 +2432,6 @@ extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t default_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
-extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
-		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t iter_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,

commit 8d0207652cbe27d1f962050737848e5ad4671958
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 5 04:27:08 2014 -0400

    ->splice_write() via ->write_iter()
    
    iter_file_splice_write() - a ->splice_write() instance that gathers the
    pipe buffers, builds a bio_vec-based iov_iter covering those and feeds
    it to ->write_iter().  A bunch of simple cases coverted to that...
    
    [AV: fixed the braino spotted by Cyrill]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a6448849dbce..8bd8ed357c7b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2434,6 +2434,8 @@ extern ssize_t default_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
+extern ssize_t iter_file_splice_write(struct pipe_inode_info *,
+		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
 		struct file *out, loff_t *, size_t len, unsigned int flags);
 

commit 962bd40bc30e412828e091bfda041b7547e779c8
Author: Jeff Layton <jlayton@poochiereds.net>
Date:   Tue Jun 10 12:24:40 2014 -0400

    locks: add missing memory barrier in break_deleg
    
    break_deleg is subject to the same potential race as break_lease. Add
    a memory barrier to prevent it.
    
    Signed-off-by: Jeff Layton <jlayton@primarydata.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c3f46e499dd0..22ae79650b82 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1914,6 +1914,12 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 
 static inline int break_deleg(struct inode *inode, unsigned int mode)
 {
+	/*
+	 * Since this check is lockless, we must ensure that any refcounts
+	 * taken are done before checking inode->i_flock. Otherwise, we could
+	 * end up racing with tasks trying to set a new lease on this file.
+	 */
+	smp_mb();
 	if (inode->i_flock)
 		return __break_lease(inode, mode, FL_DELEG);
 	return 0;

commit ac13a829f6adb674015ab399594c089990104af7
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 4 16:06:27 2014 -0700

    fs/libfs.c: add generic data flush to fsync
    
    Description by Jan Kara:
     "A lot of older filesystems don't properly flush volatile disk caches
      on fsync(2) which can lead to loss of fsynced data after power failure.
    
    This patch makes generic_file_fsync() issue proper cache flush to fix the
    problem.  Sysadmin can use /sys/devices/.../cache_type to tell the system
    it should not send the cache flush."
    
    [akpm@linux-foundation.org: nuke ifdef]
    [akpm@linux-foundation.org: fix warning]
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Suggested-by: Jan Kara <jack@suse.cz>
    Suggested-by: Christoph Hellwig <hch@infradead.org>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 878031227c57..c3f46e499dd0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2590,6 +2590,7 @@ extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
 		const void __user *from, size_t count);
 
+extern int __generic_file_fsync(struct file *, loff_t, loff_t, int);
 extern int generic_file_fsync(struct file *, loff_t, loff_t, int);
 
 extern int generic_check_addressable(unsigned, u64);

commit 6abd232274fd652e4a57f486d14e52ffee6f72e9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 4 14:20:57 2014 -0400

    bury generic_file_aio_{read,write}
    
    no callers left
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 99817c9e665e..a6448849dbce 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2411,10 +2411,8 @@ extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
 		unsigned long size, pgoff_t pgoff);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
-extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
-extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff_t);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);

commit a8f3550cd228b6edc5d17fce1a9af8cc7004f185
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 03:32:25 2014 -0400

    bury __generic_file_aio_write()
    
    all users converted to __generic_file_write_iter() now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1b9b6c59abdd..99817c9e665e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2413,7 +2413,6 @@ extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
-extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
 extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);

commit 1456c0a87c4241d3a801651019e66983c69ad17d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 03:21:50 2014 -0400

    blkdev_aio_write() - turn into blkdev_write_iter()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b221637f09e..1b9b6c59abdd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2425,8 +2425,7 @@ extern ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, lo
 extern ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 
 /* fs/block_dev.c */
-extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
-				unsigned long nr_segs, loff_t pos);
+extern ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from);
 extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
 			int datasync);
 extern void block_sync_page(struct page *page);

commit 8174202b34c30e0c07231bf63f18ab29af634f0b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 3 03:17:43 2014 -0400

    write_iter variants of {__,}generic_file_aio_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 17535e0a4547..4b221637f09e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2414,7 +2414,9 @@ int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isbl
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
+extern ssize_t __generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+extern ssize_t generic_file_write_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff_t);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);

commit 293bc9822fa9b3c9d4b7893bcb241e085580771a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 11 18:37:41 2014 -0500

    new methods: ->read_iter() and ->write_iter()
    
    Beginning to introduce those.  Just the callers for now, and it's
    clumsier than it'll eventually become; once we finish converting
    aio_read and aio_write instances, the things will get nicer.
    
    For now, these guys are in parallel to ->aio_read() and ->aio_write();
    they take iocb and iov_iter, with everything in iov_iter already
    validated.  File offset is passed in iocb->ki_pos, iov/nr_segs -
    in iov_iter.
    
    Main concerns in that series are stack footprint and ability to
    split the damn thing cleanly.
    
    [fix from Peter Ujfalusi <peter.ujfalusi@ti.com> folded]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 75eb71357adf..17535e0a4547 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1451,6 +1451,8 @@ struct block_device_operations;
 #define HAVE_COMPAT_IOCTL 1
 #define HAVE_UNLOCKED_IOCTL 1
 
+struct iov_iter;
+
 struct file_operations {
 	struct module *owner;
 	loff_t (*llseek) (struct file *, loff_t, int);
@@ -1458,6 +1460,8 @@ struct file_operations {
 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
+	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
+	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
 	int (*iterate) (struct file *, struct dir_context *);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
@@ -2415,6 +2419,8 @@ extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
+extern ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
+extern ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,

commit 7f7f25e82d54870df24d415a7007fbd327da027b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 11 17:49:24 2014 -0500

    replace checking for ->read/->aio_read presence with check in ->f_mode
    
    Since we are about to introduce new methods (read_iter/write_iter), the
    tests in a bunch of places would have to grow inconveniently.  Check
    once (at open() time) and store results in ->f_mode as FMODE_CAN_READ
    and FMODE_CAN_WRITE resp.  It might end up being a temporary measure -
    once everything switches from ->aio_{read,write} to ->{read,write}_iter
    it might make sense to return to open-coded checks.  We'll see...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8153396d19b4..75eb71357adf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -128,6 +128,10 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define FMODE_ATOMIC_POS	((__force fmode_t)0x8000)
 /* Write access to underlying fs */
 #define FMODE_WRITER		((__force fmode_t)0x10000)
+/* Has read method(s) */
+#define FMODE_CAN_READ          ((__force fmode_t)0x20000)
+/* Has write method(s) */
+#define FMODE_CAN_WRITE         ((__force fmode_t)0x40000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)

commit 0c949334a9e2581646c6ff0d1470a805b1e5be99
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 22 06:51:37 2014 -0400

    iov_iter_truncate()
    
    Now It Can Be Done(tm) - we don't need to do iov_shorten() in
    generic_file_direct_write() anymore, now that all ->direct_IO()
    instances are converted to proper iov_iter methods and honour
    iter->count and iter->iov_offset properly.
    
    Get rid of count/ocount arguments of generic_file_direct_write(),
    while we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d096ebc7f348..8153396d19b4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2407,8 +2407,7 @@ extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsig
 extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
-extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *,
-		loff_t, size_t, size_t);
+extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *, loff_t);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);

commit ed978a811ec528dbe40243605c3afab55892f722
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 5 22:53:04 2014 -0500

    new helper: generic_file_read_iter()
    
    iov_iter-using variant of generic_file_aio_read().  Some callers
    converted.  Note that it's still not quite there for use as ->read_iter() -
    we depend on having zero iter->iov_offset in O_DIRECT case.  Fortunately,
    that's true for all converted callers (and for generic_file_aio_read() itself).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 946a9484844f..d096ebc7f348 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2404,6 +2404,7 @@ extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
 		unsigned long size, pgoff_t pgoff);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+extern ssize_t generic_file_read_iter(struct kiocb *, struct iov_iter *);
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *,

commit 31b140398ce56ab41646eda7f02bcb78d6a4c916
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 5 01:33:16 2014 -0500

    switch {__,}blockdev_direct_IO() to iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 399a338c92b5..946a9484844f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2474,16 +2474,16 @@ enum {
 void dio_end_io(struct bio *bio, int error);
 
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
-	struct block_device *bdev, const struct iovec *iov, loff_t offset,
-	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
+	struct block_device *bdev, struct iov_iter *iter, loff_t offset,
+	get_block_t get_block, dio_iodone_t end_io,
 	dio_submit_t submit_io,	int flags);
 
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
-		struct inode *inode, const struct iovec *iov, loff_t offset,
-		unsigned long nr_segs, get_block_t get_block)
+		struct inode *inode, struct iov_iter *iter, loff_t offset,
+		get_block_t get_block)
 {
-	return __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
-				    offset, nr_segs, get_block, NULL, NULL,
+	return __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iter,
+				    offset, get_block, NULL, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
 #endif

commit d8d3d94b80aa1a1c0ca75c58b8abdc7356f38418
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 4 21:27:34 2014 -0500

    pass iov_iter to ->direct_IO()
    
    unmodified, for now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 796de742fe4a..399a338c92b5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -343,8 +343,7 @@ struct address_space_operations {
 	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 	int (*releasepage) (struct page *, gfp_t);
 	void (*freepage)(struct page *);
-	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
-			loff_t offset, unsigned long nr_segs);
+	ssize_t (*direct_IO)(int, struct kiocb *, struct iov_iter *iter, loff_t offset);
 	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
 						void **, unsigned long *);
 	/*

commit cb66a7a1f149ff705fa37cad6d1252b046e0ad4f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 4 15:24:06 2014 -0500

    kill generic_segment_checks()
    
    all callers of ->aio_read() and ->aio_write() have iov/nr_segs already
    checked - generic_segment_checks() done after that is just an odd way
    to spell iov_length().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 262f96e579b8..796de742fe4a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2412,8 +2412,6 @@ extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *,
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
-extern int generic_segment_checks(const struct iovec *iov,
-		unsigned long *nr_segs, size_t *count, int access_flags);
 
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,

commit f8579f8673b7ecdb7a81d5d5bb1d981093d9aa94
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 3 22:03:20 2014 -0500

    generic_file_direct_write(): switch to iov_iter
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 878031227c57..262f96e579b8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2407,8 +2407,8 @@ int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isbl
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
-extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
-		unsigned long *, loff_t, size_t, size_t);
+extern ssize_t generic_file_direct_write(struct kiocb *, struct iov_iter *,
+		loff_t, size_t, size_t);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);

commit cff2fce58b2b0f59089e7edcdc38803d65057b9f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Tue Apr 22 08:24:32 2014 -0400

    locks: rename FL_FILE_PVT and IS_FILE_PVT to use "*_OFDLCK" instead
    
    File-private locks have been re-christened as "open file description"
    locks.  Finish the symbol name cleanup in the internal implementation.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a9c5bca2b76..878031227c57 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -815,7 +815,7 @@ static inline struct file *get_file(struct file *f)
 #define FL_SLEEP	128	/* A blocking lock */
 #define FL_DOWNGRADE_PENDING	256 /* Lease is being downgraded */
 #define FL_UNLOCK_PENDING	512 /* Lease is being broken */
-#define FL_FILE_PVT	1024	/* lock is private to the file */
+#define FL_OFDLCK	1024	/* lock is "owned" by struct file */
 
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for

commit 5166701b368caea89d57b14bf41cf39e819dad51
Merge: 0a7418f5f569 a786c06d9f27
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 12 14:49:50 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "The first vfs pile, with deep apologies for being very late in this
      window.
    
      Assorted cleanups and fixes, plus a large preparatory part of iov_iter
      work.  There's a lot more of that, but it'll probably go into the next
      merge window - it *does* shape up nicely, removes a lot of
      boilerplate, gets rid of locking inconsistencie between aio_write and
      splice_write and I hope to get Kent's direct-io rewrite merged into
      the same queue, but some of the stuff after this point is having
      (mostly trivial) conflicts with the things already merged into
      mainline and with some I want more testing.
    
      This one passes LTP and xfstests without regressions, in addition to
      usual beating.  BTW, readahead02 in ltp syscalls testsuite has started
      giving failures since "mm/readahead.c: fix readahead failure for
      memoryless NUMA nodes and limit readahead pages" - might be a false
      positive, might be a real regression..."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      missing bits of "splice: fix racy pipe->buffers uses"
      cifs: fix the race in cifs_writev()
      ceph_sync_{,direct_}write: fix an oops on ceph_osdc_new_request() failure
      kill generic_file_buffered_write()
      ocfs2_file_aio_write(): switch to generic_perform_write()
      ceph_aio_write(): switch to generic_perform_write()
      xfs_file_buffered_aio_write(): switch to generic_perform_write()
      export generic_perform_write(), start getting rid of generic_file_buffer_write()
      generic_file_direct_write(): get rid of ppos argument
      btrfs_file_aio_write(): get rid of ppos
      kill the 5th argument of generic_file_buffered_write()
      kill the 4th argument of __generic_file_aio_write()
      lustre: don't open-code kernel_recvmsg()
      ocfs2: don't open-code kernel_recvmsg()
      drbd: don't open-code kernel_recvmsg()
      constify blk_rq_map_user_iov() and friends
      lustre: switch to kernel_sendmsg()
      ocfs2: don't open-code kernel_sendmsg()
      take iov_iter stuff to mm/iov_iter.c
      process_vm_access: tidy up a bit
      ...

commit d15e03104eb9a4f8e244ab6ed3ca5a107e46db13
Merge: 24e7ea3bea94 a6cf33bc566c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 15:50:08 2014 -0700

    Merge tag 'xfs-for-linus-3.15-rc1' of git://oss.sgi.com/xfs/xfs
    
    Pull xfs update from Dave Chinner:
     "There are a couple of new fallocate features in this request - it was
      decided that it was easiest to push them through the XFS tree using
      topic branches and have the ext4 support be based on those branches.
      Hence you may see some overlap with the ext4 tree merge depending on
      how they including those topic branches into their tree.  Other than
      that, there is O_TMPFILE support, some cleanups and bug fixes.
    
      The main changes in the XFS tree for 3.15-rc1 are:
    
       - O_TMPFILE support
       - allowing AIO+DIO writes beyond EOF
       - FALLOC_FL_COLLAPSE_RANGE support for fallocate syscall and XFS
         implementation
       - FALLOC_FL_ZERO_RANGE support for fallocate syscall and XFS
         implementation
       - IO verifier cleanup and rework
       - stack usage reduction changes
       - vm_map_ram NOIO context fixes to remove lockdep warings
       - various bug fixes and cleanups"
    
    * tag 'xfs-for-linus-3.15-rc1' of git://oss.sgi.com/xfs/xfs: (34 commits)
      xfs: fix directory hash ordering bug
      xfs: extra semi-colon breaks a condition
      xfs: Add support for FALLOC_FL_ZERO_RANGE
      fs: Introduce FALLOC_FL_ZERO_RANGE flag for fallocate
      xfs: inode log reservations are still too small
      xfs: xfs_check_page_type buffer checks need help
      xfs: avoid AGI/AGF deadlock scenario for inode chunk allocation
      xfs: use NOIO contexts for vm_map_ram
      xfs: don't leak EFSBADCRC to userspace
      xfs: fix directory inode iolock lockdep false positive
      xfs: allocate xfs_da_args to reduce stack footprint
      xfs: always do log forces via the workqueue
      xfs: modify verifiers to differentiate CRC from other errors
      xfs: print useful caller information in xfs_error_report
      xfs: add xfs_verifier_error()
      xfs: add helper for updating checksums on xfs_bufs
      xfs: add helper for verifying checksums on xfs_bufs
      xfs: Use defines for CRC offsets in all cases
      xfs: skip pointless CRC updates after verifier failures
      xfs: Add support FALLOC_FL_COLLAPSE_RANGE for fallocate
      ...

commit 24e7ea3bea94fe05eae5019f5f12bcdc98fc5157
Merge: 8e343c8b5c2e ad6599ab3ac9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 15:39:39 2014 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates from Ted Ts'o:
     "Major changes for 3.14 include support for the newly added ZERO_RANGE
      and COLLAPSE_RANGE fallocate operations, and scalability improvements
      in the jbd2 layer and in xattr handling when the extended attributes
      spill over into an external block.
    
      Other than that, the usual clean ups and minor bug fixes"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (42 commits)
      ext4: fix premature freeing of partial clusters split across leaf blocks
      ext4: remove unneeded test of ret variable
      ext4: fix comment typo
      ext4: make ext4_block_zero_page_range static
      ext4: atomically set inode->i_flags in ext4_set_inode_flags()
      ext4: optimize Hurd tests when reading/writing inodes
      ext4: kill i_version support for Hurd-castrated file systems
      ext4: each filesystem creates and uses its own mb_cache
      fs/mbcache.c: doucple the locking of local from global data
      fs/mbcache.c: change block and index hash chain to hlist_bl_node
      ext4: Introduce FALLOC_FL_ZERO_RANGE flag for fallocate
      ext4: refactor ext4_fallocate code
      ext4: Update inode i_size after the preallocation
      ext4: fix partial cluster handling for bigalloc file systems
      ext4: delete path dealloc code in ext4_ext_handle_uninitialized_extents
      ext4: only call sync_filesystm() when remounting read-only
      fs: push sync_filesystem() down to the file system's remount_fs()
      jbd2: improve error messages for inconsistent journal heads
      jbd2: minimize region locked by j_list_lock in jbd2_journal_forget()
      jbd2: minimize region locked by j_list_lock in journal_get_create_access()
      ...

commit f7789dc0d476e597b0fba52871e777f97d8e3f6e
Merge: 7df934526c0b 29723adee118
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 14:21:20 2014 -0700

    Merge branch 'locks-3.15' of git://git.samba.org/jlayton/linux
    
    Pull file locking updates from Jeff Layton:
     "Highlights:
    
       - maintainership change for fs/locks.c.  Willy's not interested in
         maintaining it these days, and is OK with Bruce and I taking it.
       - fix for open vs setlease race that Al ID'ed
       - cleanup and consolidation of file locking code
       - eliminate unneeded BUG() call
       - merge of file-private lock implementation"
    
    * 'locks-3.15' of git://git.samba.org/jlayton/linux:
      locks: make locks_mandatory_area check for file-private locks
      locks: fix locks_mandatory_locked to respect file-private locks
      locks: require that flock->l_pid be set to 0 for file-private locks
      locks: add new fcntl cmd values for handling file private locks
      locks: skip deadlock detection on FL_FILE_PVT locks
      locks: pass the cmd value to fcntl_getlk/getlk64
      locks: report l_pid as -1 for FL_FILE_PVT locks
      locks: make /proc/locks show IS_FILE_PVT locks as type "FLPVT"
      locks: rename locks_remove_flock to locks_remove_file
      locks: consolidate checks for compatible filp->f_mode values in setlk handlers
      locks: fix posix lock range overflow handling
      locks: eliminate BUG() call when there's an unexpected lock on file close
      locks: add __acquires and __releases annotations to locks_start and locks_stop
      locks: remove "inline" qualifier from fl_link manipulation functions
      locks: clean up comment typo
      locks: close potential race between setlease and open
      MAINTAINERS: update entry for fs/locks.c

commit 7df934526c0b3775613502dcd19ab6d2da8cce1e
Merge: 3c83e61e6725 bd42998a6bcb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 14:03:05 2014 -0700

    Merge branch 'cross-rename' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs
    
    Pull renameat2 system call from Miklos Szeredi:
     "This adds a new syscall, renameat2(), which is the same as renameat()
      but with a flags argument.
    
      The purpose of extending rename is to add cross-rename, a symmetric
      variant of rename, which exchanges the two files.  This allows
      interesting things, which were not possible before, for example
      atomically replacing a directory tree with a symlink, etc...  This
      also allows overlayfs and friends to operate on whiteouts atomically.
    
      Andy Lutomirski also suggested a "noreplace" flag, which disables the
      overwriting behavior of rename.
    
      These two flags, RENAME_EXCHANGE and RENAME_NOREPLACE are only
      implemented for ext4 as an example and for testing"
    
    * 'cross-rename' of git://git.kernel.org/pub/scm/linux/kernel/git/mszeredi/vfs:
      ext4: add cross rename support
      ext4: rename: split out helper functions
      ext4: rename: move EMLINK check up
      ext4: rename: create ext4_renament structure for local vars
      vfs: add cross-rename
      vfs: lock_two_nondirectories: allow directory args
      security: add flags to rename hooks
      vfs: add RENAME_NOREPLACE flag
      vfs: add renameat2 syscall
      vfs: rename: use common code for dir and non-dir
      vfs: rename: move d_move() up
      vfs: add d_is_dir()

commit 91b0abe36a7b2b3b02d7500925a5f8455334f0e5
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Thu Apr 3 14:47:49 2014 -0700

    mm + fs: store shadow entries in page cache
    
    Reclaim will be leaving shadow entries in the page cache radix tree upon
    evicting the real page.  As those pages are found from the LRU, an
    iput() can lead to the inode being freed concurrently.  At this point,
    reclaim must no longer install shadow pages because the inode freeing
    code needs to ensure the page tree is really empty.
    
    Add an address_space flag, AS_EXITING, that the inode freeing code sets
    under the tree lock before doing the final truncate.  Reclaim will check
    for this flag before installing shadow pages.
    
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Reviewed-by: Minchan Kim <minchan@kernel.org>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Bob Liu <bob.liu@oracle.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Luigi Semenzato <semenzato@google.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Metin Doslu <metin@citusdata.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Ozgun Erdogan <ozgun@citusdata.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Roman Gushchin <klamm@yandex-team.ru>
    Cc: Ryan Mallon <rmallon@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e765d28841b..3ca9420f627e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -419,6 +419,7 @@ struct address_space {
 	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
 	/* Protected by tree_lock together with the radix tree */
 	unsigned long		nrpages;	/* number of total pages */
+	unsigned long		nrshadows;	/* number of shadow entries */
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */
 	unsigned long		flags;		/* error bits/gfp mask */

commit bea803183e12a1c78a12ec70907174d13d958333
Merge: cd6362befe4c f64410ec6654
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 3 09:26:18 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security
    
    Pull security subsystem updates from James Morris:
     "Apart from reordering the SELinux mmap code to ensure DAC is called
      before MAC, these are minor maintenance updates"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/linux-security: (23 commits)
      selinux: correctly label /proc inodes in use before the policy is loaded
      selinux: put the mmap() DAC controls before the MAC controls
      selinux: fix the output of ./scripts/get_maintainer.pl for SELinux
      evm: enable key retention service automatically
      ima: skip memory allocation for empty files
      evm: EVM does not use MD5
      ima: return d_name.name if d_path fails
      integrity: fix checkpatch errors
      ima: fix erroneous removal of security.ima xattr
      security: integrity: Use a more current logging style
      MAINTAINERS: email updates and other misc. changes
      ima: reduce memory usage when a template containing the n field is used
      ima: restore the original behavior for sending data with ima template
      Integrity: Pass commname via get_task_comm()
      fs: move i_readcount
      ima: use static const char array definitions
      security: have cap_dentry_init_security return error
      ima: new helper: file_inode(file)
      kernel: Mark function as static in kernel/seccomp.c
      capability: Use current logging styles
      ...

commit ccad2365668f12336dd497d9039e8584af836070
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 11 22:36:48 2014 -0500

    kill generic_file_buffered_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 87be51aff9d7..c309b7a0da2d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2398,8 +2398,6 @@ extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsi
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
 		unsigned long *, loff_t, size_t, size_t);
 extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
-extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
-		unsigned long, loff_t, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 extern int generic_segment_checks(const struct iovec *iov,

commit 3b93f911d55cf8b3540f82fac4eeddfee7b5de0c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 11 21:34:08 2014 -0500

    export generic_perform_write(), start getting rid of generic_file_buffer_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9dfd7c7ff8e3..87be51aff9d7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -48,6 +48,7 @@ struct cred;
 struct swap_info_struct;
 struct seq_file;
 struct workqueue_struct;
+struct iov_iter;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -2396,6 +2397,7 @@ extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, un
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
 		unsigned long *, loff_t, size_t, size_t);
+extern ssize_t generic_perform_write(struct file *, struct iov_iter *, loff_t);
 extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);

commit 5cb6c6c7eb1ed24744b41fad47d9a25b72207098
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Feb 11 20:58:20 2014 -0500

    generic_file_direct_write(): get rid of ppos argument
    
    always equal to &iocb->ki_pos.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 830e37420f5e..9dfd7c7ff8e3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2395,7 +2395,7 @@ extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsig
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
-		unsigned long *, loff_t, loff_t *, size_t, size_t);
+		unsigned long *, loff_t, size_t, size_t);
 extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);

commit fcacafd269adc88f41b68cb77a3f957a66563428
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 9 13:37:49 2014 -0500

    kill the 5th argument of generic_file_buffered_write()
    
    same story - it's &iocb->ki_pos in all cases
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e677d1e1189f..830e37420f5e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2397,7 +2397,7 @@ extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsi
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
 		unsigned long *, loff_t, loff_t *, size_t, size_t);
 extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
-		unsigned long, loff_t, loff_t *, size_t, ssize_t);
+		unsigned long, loff_t, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
 extern int generic_segment_checks(const struct iovec *iov,

commit 41fc56d573c35a212688b12b48af8c303f9bb6d2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 9 12:58:52 2014 -0500

    kill the 4th argument of __generic_file_aio_write()
    
    It's always equal to &iocb->ki_pos, where iocb is the value of the 1st
    argument.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2a5b1744f80a..e677d1e1189f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2392,8 +2392,7 @@ extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
 		unsigned long size, pgoff_t pgoff);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
-extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long,
-		loff_t *);
+extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
 		unsigned long *, loff_t, loff_t *, size_t, size_t);

commit 6e58e79db8a16222b31fc8da1ca2ac2dccfc4237
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Feb 3 17:07:03 2014 -0500

    introduce copy_page_to_iter, kill loop over iovec in generic_file_aio_read()
    
    generic_file_aio_read() was looping over the target iovec, with loop over
    (source) pages nested inside that.  Just set an iov_iter up and pass *that*
    to do_generic_file_aio_read().  With copy_page_to_iter() doing all work
    of mapping and copying a page to iovec and advancing iov_iter.
    
    Switch shmem_file_aio_read() to the same and kill file_read_actor(), while
    we are at it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2261ac8f0534..2a5b1744f80a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2390,7 +2390,6 @@ extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
 		unsigned long size, pgoff_t pgoff);
-extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long,

commit 9223687863ffa63fa655f52ef64148ee08dee4d1
Author: Kent Overstreet <kmo@daterainc.com>
Date:   Wed Nov 27 16:29:46 2013 -0800

    iov_iter: Move iov_iter to uio.h
    
    Signed-off-by: Kent Overstreet <kmo@daterainc.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ddfff2ecef0b..2261ac8f0534 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -295,38 +295,6 @@ struct page;
 struct address_space;
 struct writeback_control;
 
-struct iov_iter {
-	const struct iovec *iov;
-	unsigned long nr_segs;
-	size_t iov_offset;
-	size_t count;
-};
-
-size_t iov_iter_copy_from_user_atomic(struct page *page,
-		struct iov_iter *i, unsigned long offset, size_t bytes);
-size_t iov_iter_copy_from_user(struct page *page,
-		struct iov_iter *i, unsigned long offset, size_t bytes);
-void iov_iter_advance(struct iov_iter *i, size_t bytes);
-int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
-size_t iov_iter_single_seg_count(const struct iov_iter *i);
-
-static inline void iov_iter_init(struct iov_iter *i,
-			const struct iovec *iov, unsigned long nr_segs,
-			size_t count, size_t written)
-{
-	i->iov = iov;
-	i->nr_segs = nr_segs;
-	i->iov_offset = 0;
-	i->count = count + written;
-
-	iov_iter_advance(i, written);
-}
-
-static inline size_t iov_iter_count(struct iov_iter *i)
-{
-	return i->count;
-}
-
 /*
  * "descriptor" for what we're up to with a read.
  * This allows us to use the same read code yet

commit c186afb4dbd0050a537b96c7fbee2dba3b57fc38
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 2 21:16:54 2014 -0500

    switch ->is_partially_uptodate() to saner arguments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index db181b542db1..ddfff2ecef0b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -385,7 +385,7 @@ struct address_space_operations {
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *, enum migrate_mode);
 	int (*launder_page) (struct page *);
-	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
+	int (*is_partially_uptodate) (struct page *, unsigned long,
 					unsigned long);
 	void (*is_dirty_writeback) (struct page *, bool *, bool *);
 	int (*error_remove_page)(struct address_space *, struct page *);

commit 5d826c847b34de6415b4f1becd88a57ff619af50
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 14 13:42:45 2014 -0400

    new helper: readlink_copy()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d9d88a0b456e..db181b542db1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2517,7 +2517,7 @@ extern const struct file_operations generic_ro_fops;
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
-extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
+extern int readlink_copy(char __user *, int, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
 extern void *page_follow_link_light(struct dentry *, struct nameidata *);
 extern void page_put_link(struct dentry *, struct nameidata *, void *);

commit 83f936c75e3689a63253d89c47a4d239c56d7410
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 14 12:02:47 2014 -0400

    mark struct file that had write access grabbed by open()
    
    new flag in ->f_mode - FMODE_WRITER.  Set by do_dentry_open() in case
    when it has grabbed write access, checked by __fput() to decide whether
    it wants to drop the sucker.  Allows to stop bothering with mnt_clone_write()
    in alloc_file(), along with fewer special_file() checks.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e80659ed78fc..d9d88a0b456e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -125,6 +125,8 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 
 /* File needs atomic accesses to f_pos */
 #define FMODE_ATOMIC_POS	((__force fmode_t)0x8000)
+/* Write access to underlying fs */
+#define FMODE_WRITER		((__force fmode_t)0x10000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)

commit 4597e695b8baa3e2620da89c7593be70cf20566b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 14 10:06:32 2014 -0400

    get rid of DEBUG_WRITECOUNT
    
    it only makes control flow in __fput() and friends more convoluted.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 23b2a35d712e..e80659ed78fc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -769,9 +769,6 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
 		index <  ra->start + ra->size);
 }
 
-#define FILE_MNT_WRITE_TAKEN	1
-#define FILE_MNT_WRITE_RELEASED	2
-
 struct file {
 	union {
 		struct llist_node	fu_llist;
@@ -809,9 +806,6 @@ struct file {
 	struct list_head	f_tfile_llink;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
-#ifdef CONFIG_DEBUG_WRITECOUNT
-	unsigned long f_mnt_write_state;
-#endif
 } __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
 struct file_handle {
@@ -829,49 +823,6 @@ static inline struct file *get_file(struct file *f)
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 
-#ifdef CONFIG_DEBUG_WRITECOUNT
-static inline void file_take_write(struct file *f)
-{
-	WARN_ON(f->f_mnt_write_state != 0);
-	f->f_mnt_write_state = FILE_MNT_WRITE_TAKEN;
-}
-static inline void file_release_write(struct file *f)
-{
-	f->f_mnt_write_state |= FILE_MNT_WRITE_RELEASED;
-}
-static inline void file_reset_write(struct file *f)
-{
-	f->f_mnt_write_state = 0;
-}
-static inline void file_check_state(struct file *f)
-{
-	/*
-	 * At this point, either both or neither of these bits
-	 * should be set.
-	 */
-	WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN);
-	WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_RELEASED);
-}
-static inline int file_check_writeable(struct file *f)
-{
-	if (f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN)
-		return 0;
-	printk(KERN_WARNING "writeable file with no "
-			    "mnt_want_write()\n");
-	WARN_ON(1);
-	return -EINVAL;
-}
-#else /* !CONFIG_DEBUG_WRITECOUNT */
-static inline void file_take_write(struct file *filp) {}
-static inline void file_release_write(struct file *filp) {}
-static inline void file_reset_write(struct file *filp) {}
-static inline void file_check_state(struct file *filp) {}
-static inline int file_check_writeable(struct file *filp)
-{
-	return 0;
-}
-#endif /* CONFIG_DEBUG_WRITECOUNT */
-
 #define	MAX_NON_LFS	((1UL<<31) - 1)
 
 /* Page cache limit. The filesystems should put that into their s_maxbytes 

commit 520c8b16505236fc82daa352e6c5e73cd9870cff
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Apr 1 17:08:42 2014 +0200

    vfs: add renameat2 syscall
    
    Add new renameat2 syscall, which is the same as renameat with an added
    flags argument.
    
    Pass flags to vfs_rename() and to i_op->rename() as well.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reviewed-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 23b2a35d712e..3b3670e97da6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1460,7 +1460,7 @@ extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
 
 /*
  * VFS dentry helper functions.
@@ -1571,6 +1571,8 @@ struct inode_operations {
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct dentry *,
+			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);

commit d7a06983a01a33605191c0766857b832ac32a2b6
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Mar 10 09:54:15 2014 -0400

    locks: fix locks_mandatory_locked to respect file-private locks
    
    As Trond pointed out, you can currently deadlock yourself by setting a
    file-private lock on a file that requires mandatory locking and then
    trying to do I/O on it.
    
    Avoid this problem by plumbing some knowledge of file-private locks into
    the mandatory locking code. In order to do this, we must pass down
    information about the struct file that's being used to
    locks_verify_locked.
    
    Reported-by: Trond Myklebust <trond.myklebust@primarydata.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ae91dce8a547..4aa81e6ae067 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1912,6 +1912,11 @@ extern int current_umask(void);
 extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
 
+static inline struct inode *file_inode(struct file *f)
+{
+	return f->f_inode;
+}
+
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 
@@ -1921,7 +1926,7 @@ extern struct kobject *fs_kobj;
 #define FLOCK_VERIFY_WRITE 2
 
 #ifdef CONFIG_FILE_LOCKING
-extern int locks_mandatory_locked(struct inode *);
+extern int locks_mandatory_locked(struct file *);
 extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
 
 /*
@@ -1944,10 +1949,10 @@ static inline int mandatory_lock(struct inode *ino)
 	return IS_MANDLOCK(ino) && __mandatory_lock(ino);
 }
 
-static inline int locks_verify_locked(struct inode *inode)
+static inline int locks_verify_locked(struct file *file)
 {
-	if (mandatory_lock(inode))
-		return locks_mandatory_locked(inode);
+	if (mandatory_lock(file_inode(file)))
+		return locks_mandatory_locked(file);
 	return 0;
 }
 
@@ -2008,7 +2013,7 @@ static inline int break_deleg_wait(struct inode **delegated_inode)
 }
 
 #else /* !CONFIG_FILE_LOCKING */
-static inline int locks_mandatory_locked(struct inode *inode)
+static inline int locks_mandatory_locked(struct file *file)
 {
 	return 0;
 }
@@ -2030,7 +2035,7 @@ static inline int mandatory_lock(struct inode *inode)
 	return 0;
 }
 
-static inline int locks_verify_locked(struct inode *inode)
+static inline int locks_verify_locked(struct file *file)
 {
 	return 0;
 }
@@ -2297,11 +2302,6 @@ static inline bool execute_ok(struct inode *inode)
 	return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
 }
 
-static inline struct inode *file_inode(struct file *f)
-{
-	return f->f_inode;
-}
-
 static inline void file_start_write(struct file *file)
 {
 	if (!S_ISREG(file_inode(file)->i_mode))

commit c1e62b8fc355e0c3706f1ae0dacb72d1c514dc80
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Feb 3 12:13:09 2014 -0500

    locks: pass the cmd value to fcntl_getlk/getlk64
    
    Once we introduce file private locks, we'll need to know what cmd value
    was used, as that affects the ownership and whether a conflict would
    arise.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5ddeb8de5e77..ae91dce8a547 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -993,12 +993,12 @@ struct file_lock {
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
 #ifdef CONFIG_FILE_LOCKING
-extern int fcntl_getlk(struct file *, struct flock __user *);
+extern int fcntl_getlk(struct file *, unsigned int, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
 			struct flock __user *);
 
 #if BITS_PER_LONG == 32
-extern int fcntl_getlk64(struct file *, struct flock64 __user *);
+extern int fcntl_getlk64(struct file *, unsigned int, struct flock64 __user *);
 extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
 			struct flock64 __user *);
 #endif
@@ -1031,7 +1031,8 @@ extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
 #else /* !CONFIG_FILE_LOCKING */
-static inline int fcntl_getlk(struct file *file, struct flock __user *user)
+static inline int fcntl_getlk(struct file *file, unsigned int cmd,
+			      struct flock __user *user)
 {
 	return -EINVAL;
 }
@@ -1043,7 +1044,8 @@ static inline int fcntl_setlk(unsigned int fd, struct file *file,
 }
 
 #if BITS_PER_LONG == 32
-static inline int fcntl_getlk64(struct file *file, struct flock64 __user *user)
+static inline int fcntl_getlk64(struct file *file, unsigned int cmd,
+				struct flock64 __user *user)
 {
 	return -EINVAL;
 }

commit c918d42a27a9be0d78be490997d16d79cd5b9193
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Feb 3 12:13:09 2014 -0500

    locks: make /proc/locks show IS_FILE_PVT locks as type "FLPVT"
    
    In a later patch, we'll be adding a new type of lock that's owned by
    the struct file instead of the files_struct. Those sorts of locks
    will be flagged with a new FL_FILE_PVT flag.
    
    Report these types of locks as "FLPVT" in /proc/locks to distinguish
    them from "classic" POSIX locks.
    
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7527d96913d3..5ddeb8de5e77 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -888,6 +888,7 @@ static inline int file_check_writeable(struct file *filp)
 #define FL_SLEEP	128	/* A blocking lock */
 #define FL_DOWNGRADE_PENDING	256 /* Lease is being downgraded */
 #define FL_UNLOCK_PENDING	512 /* Lease is being broken */
+#define FL_FILE_PVT	1024	/* lock is private to the file */
 
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for

commit 78ed8a13382b1354e95d0f2233577eba15cb8171
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Feb 3 12:13:08 2014 -0500

    locks: rename locks_remove_flock to locks_remove_file
    
    This function currently removes leases in addition to flock locks and in
    a later patch we'll have it deal with file-private locks too. Rename it
    to locks_remove_file to indicate that it removes locks that are
    associated with a particular struct file, and not just flock locks.
    
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index df8474408331..7527d96913d3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1012,7 +1012,7 @@ extern struct file_lock * locks_alloc_lock(void);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
-extern void locks_remove_flock(struct file *);
+extern void locks_remove_file(struct file *);
 extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
@@ -1083,7 +1083,7 @@ static inline void locks_remove_posix(struct file *filp, fl_owner_t owner)
 	return;
 }
 
-static inline void locks_remove_flock(struct file *filp)
+static inline void locks_remove_file(struct file *filp)
 {
 	return;
 }

commit 24cbe7845ea50b636ab2218b9d648270ff55f148
Author: Jeff Layton <jlayton@redhat.com>
Date:   Mon Feb 3 12:13:06 2014 -0500

    locks: close potential race between setlease and open
    
    As Al Viro points out, there is an unlikely, but possible race between
    opening a file and setting a lease on it. generic_add_lease is done with
    the i_lock held, but the inode->i_flock check in break_lease is
    lockless. It's possible for another task doing an open to do the entire
    pathwalk and call break_lease between the point where generic_add_lease
    checks for a conflicting open and adds the lease to the list. If this
    occurs, we can end up with a lease set on the file with a conflicting
    open.
    
    To guard against that, check again for a conflicting open after adding
    the lease to the i_flock list. If the above race occurs, then we can
    simply unwind the lease setting and return -EAGAIN.
    
    Because we take dentry references and acquire write access on the file
    before calling break_lease, we know that if the i_flock list is empty
    when the open caller goes to check it then the necessary refcounts have
    already been incremented. Thus the additional check for a conflicting
    open will see that there is one and the setlease call will fail.
    
    Cc: Bruce Fields <bfields@fieldses.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@fieldses.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 09f553c59813..df8474408331 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1964,6 +1964,12 @@ static inline int locks_verify_truncate(struct inode *inode,
 
 static inline int break_lease(struct inode *inode, unsigned int mode)
 {
+	/*
+	 * Since this check is lockless, we must ensure that any refcounts
+	 * taken are done before checking inode->i_flock. Otherwise, we could
+	 * end up racing with tasks trying to set a new lease on this file.
+	 */
+	smp_mb();
 	if (inode->i_flock)
 		return __break_lease(inode, mode, FL_LEASE);
 	return 0;

commit 5f16f3225b06242a9ee876f07c1c9b6ed36a22b6
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Mon Mar 24 14:43:12 2014 -0400

    ext4: atomically set inode->i_flags in ext4_set_inode_flags()
    
    Use cmpxchg() to atomically set i_flags instead of clearing out the
    S_IMMUTABLE, S_APPEND, etc. flags and then setting them from the
    EXT4_IMMUTABLE_FL, EXT4_APPEND_FL flags, since this opens up a race
    where an immutable file has the immutable flag cleared for a brief
    window of time.
    
    Reported-by: John Sullivan <jsrhbz@kanargh.force9.co.uk>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: stable@kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 60829565e552..5d1f6fa8daed 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2556,6 +2556,9 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 void inode_dio_wait(struct inode *inode);
 void inode_dio_done(struct inode *inode);
 
+extern void inode_set_flags(struct inode *inode, unsigned int flags,
+			    unsigned int mask);
+
 extern const struct file_operations generic_ro_fops;
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))

commit bd2a31d522344b3ac2fb680bd2366e77a9bd8209
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 4 14:54:22 2014 -0500

    get rid of fget_light()
    
    instead of returning the flags by reference, we can just have the
    low-level primitive return those in lower bits of unsigned long,
    with struct file * derived from the rest.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ebfde04bca06..23b2a35d712e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -812,7 +812,7 @@ struct file {
 #ifdef CONFIG_DEBUG_WRITECOUNT
 	unsigned long f_mnt_write_state;
 #endif
-};
+} __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
 
 struct file_handle {
 	__u32 handle_bytes;

commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 3 09:36:58 2014 -0800

    vfs: atomic f_pos accesses as per POSIX
    
    Our write() system call has always been atomic in the sense that you get
    the expected thread-safe contiguous write, but we haven't actually
    guaranteed that concurrent writes are serialized wrt f_pos accesses, so
    threads (or processes) that share a file descriptor and use "write()"
    concurrently would quite likely overwrite each others data.
    
    This violates POSIX.1-2008/SUSv4 Section XSI 2.9.7 that says:
    
     "2.9.7 Thread Interactions with Regular File Operations
    
      All of the following functions shall be atomic with respect to each
      other in the effects specified in POSIX.1-2008 when they operate on
      regular files or symbolic links: [...]"
    
    and one of the effects is the file position update.
    
    This unprotected file position behavior is not new behavior, and nobody
    has ever cared.  Until now.  Yongzhi Pan reported unexpected behavior to
    Michael Kerrisk that was due to this.
    
    This resolves the issue with a f_pos-specific lock that is taken by
    read/write/lseek on file descriptors that may be shared across threads
    or processes.
    
    Reported-by: Yongzhi Pan <panyongzhi@gmail.com>
    Reported-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 60829565e552..ebfde04bca06 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -123,6 +123,9 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 /* File is opened with O_PATH; almost nothing can be done with it */
 #define FMODE_PATH		((__force fmode_t)0x4000)
 
+/* File needs atomic accesses to f_pos */
+#define FMODE_ATOMIC_POS	((__force fmode_t)0x8000)
+
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
 
@@ -780,13 +783,14 @@ struct file {
 	const struct file_operations	*f_op;
 
 	/*
-	 * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.
+	 * Protects f_ep_links, f_flags.
 	 * Must not be taken from IRQ context.
 	 */
 	spinlock_t		f_lock;
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
+	struct mutex		f_pos_lock;
 	loff_t			f_pos;
 	struct fown_struct	f_owner;
 	const struct cred	*f_cred;

commit d984ea604943bbeedde4e9715984eb942a298383
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Wed Dec 11 15:20:54 2013 -0500

    fs: move i_readcount
    
    On a 64-bit system, a hole exists in the 'inode' structure after
    i_writecount.  This patch moves i_readcount to fill this hole.
    
    Reported-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Acked-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 121f11f001c0..e88219d3f42b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -586,6 +586,9 @@ struct inode {
 	atomic_t		i_count;
 	atomic_t		i_dio_count;
 	atomic_t		i_writecount;
+#ifdef CONFIG_IMA
+	atomic_t		i_readcount; /* struct files open RO */
+#endif
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock	*i_flock;
 	struct address_space	i_data;
@@ -606,9 +609,6 @@ struct inode {
 	struct hlist_head	i_fsnotify_marks;
 #endif
 
-#ifdef CONFIG_IMA
-	atomic_t		i_readcount; /* struct files open RO */
-#endif
 	void			*i_private; /* fs or device private pointer */
 };
 

commit f94aa7c7f1fc474be776e4bf88088d5a007d3575
Merge: 9c1db7798141 c9efe51165fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 9 18:12:07 2014 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs fixes from Al Viro:
     "A couple of fixes, both -stable fodder.  The O_SYNC bug is fairly
      old..."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      fix a kmap leak in virtio_console
      fix O_SYNC|O_APPEND syncing the wrong range on write()

commit 6039257378e4c84da06e68230b14fef955508ce6
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Feb 10 10:27:11 2014 +1100

    direct-io: add flag to allow aio writes beyond i_size
    
    Some filesystems can handle direct I/O writes beyond i_size safely,
    so allow them to opt into receiving them.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Dave Chinner <david@fromorbit.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 09f553c59813..f7faefcf4843 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2527,6 +2527,9 @@ enum {
 
 	/* filesystem does not support filling holes */
 	DIO_SKIP_HOLES	= 0x02,
+
+	/* filesystem can handle aio writes beyond i_size */
+	DIO_ASYNC_EXTEND = 0x04,
 };
 
 void dio_end_io(struct bio *bio, int error);

commit d311d79de305f1ada47cadd672e6ed1b28a949eb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 9 15:18:09 2014 -0500

    fix O_SYNC|O_APPEND syncing the wrong range on write()
    
    It actually goes back to 2004 ([PATCH] Concurrent O_SYNC write support)
    when sync_page_range() had been introduced; generic_file_write{,v}() correctly
    synced
            pos_after_write - written .. pos_after_write - 1
    but generic_file_aio_write() synced
            pos_before_write .. pos_before_write + written - 1
    instead.  Which is not the same thing with O_APPEND, obviously.
    A couple of years later correct variant had been killed off when
    everything switched to use of generic_file_aio_write().
    
    All users of generic_file_aio_write() are affected, and the same bug
    has been copied into other instances of ->aio_write().
    
    The fix is trivial; the only subtle point is that generic_write_sync()
    ought to be inlined to avoid calculations useless for the majority of
    calls.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 09f553c59813..75ff961be051 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2273,7 +2273,13 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
-extern int generic_write_sync(struct file *file, loff_t pos, loff_t count);
+static inline int generic_write_sync(struct file *file, loff_t pos, loff_t count)
+{
+	if (!(file->f_flags & O_DSYNC) && !IS_SYNC(file->f_mapping->host))
+		return 0;
+	return vfs_fsync_range(file, pos, pos + count - 1,
+			       (file->f_flags & __O_SYNC) ? 0 : 1);
+}
 extern void emergency_sync(void);
 extern void emergency_remount(void);
 #ifdef CONFIG_BLOCK

commit c4ad8f98bef77c7356aa6a9ad9188a6acc6b849d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 5 12:54:53 2014 -0800

    execve: use 'struct filename *' for executable name passing
    
    This changes 'do_execve()' to get the executable name as a 'struct
    filename', and to free it when it is done.  This is what the normal
    users want, and it simplifies and streamlines their error handling.
    
    The controlled lifetime of the executable name also fixes a
    use-after-free problem with the trace_sched_process_exec tracepoint: the
    lifetime of the passed-in string for kernel users was not at all
    obvious, and the user-mode helper code used UMH_WAIT_EXEC to serialize
    the pathname allocation lifetime with the execve() having finished,
    which in turn meant that the trace point that happened after
    mm_release() of the old process VM ended up using already free'd memory.
    
    To solve the kernel string lifetime issue, this simply introduces
    "getname_kernel()" that works like the normal user-space getname()
    function, except with the source coming from kernel memory.
    
    As Oleg points out, this also means that we could drop the tcomm[] array
    from 'struct linux_binprm', since the pathname lifetime now covers
    setup_new_exec().  That would be a separate cleanup.
    
    Reported-by: Igor Zhbanov <i.zhbanov@samsung.com>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 09f553c59813..d79678c188ad 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2079,6 +2079,7 @@ extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 
 extern struct filename *getname(const char __user *);
+extern struct filename *getname_kernel(const char *);
 
 enum {
 	FILE_CREATED = 1,

commit 893d46e443346370cd4ea81d9d35f72952c62a37
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Dec 20 05:16:39 2013 -0800

    fs: add a set_acl inode operation
    
    This will allow moving all the Posix ACL handling into the VFS and clean
    up tons of cruft in the filesystems.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 121f11f001c0..09f553c59813 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1580,6 +1580,7 @@ struct inode_operations {
 			   struct file *, unsigned open_flag,
 			   umode_t create_mode, int *opened);
 	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
+	int (*set_acl)(struct inode *, struct posix_acl *, int);
 } ____cacheline_aligned;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,

commit b26d4cd385fc51e8844e2cdf9ba2051f5bba11a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 25 18:47:37 2013 -0400

    consolidate simple ->d_delete() instances
    
    Rename simple_delete_dentry() to always_delete_dentry() and export it.
    Export simple_dentry_operations, while we are at it, and get rid of
    their duplicates
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bf5d574ebdf4..121f11f001c0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2622,7 +2622,9 @@ extern int simple_write_begin(struct file *file, struct address_space *mapping,
 extern int simple_write_end(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned copied,
 			struct page *page, void *fsdata);
+extern int always_delete_dentry(const struct dentry *);
 extern struct inode *alloc_anon_inode(struct super_block *);
+extern const struct dentry_operations simple_dentry_operations;
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);

commit 9bc9ccd7db1c9f043f75380b5a5b94912046a60e
Merge: f0230294271f bdd353661844
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 13 15:34:18 2013 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "All kinds of stuff this time around; some more notable parts:
    
       - RCU'd vfsmounts handling
       - new primitives for coredump handling
       - files_lock is gone
       - Bruce's delegations handling series
       - exportfs fixes
    
      plus misc stuff all over the place"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (101 commits)
      ecryptfs: ->f_op is never NULL
      locks: break delegations on any attribute modification
      locks: break delegations on link
      locks: break delegations on rename
      locks: helper functions for delegation breaking
      locks: break delegations on unlink
      namei: minor vfs_unlink cleanup
      locks: implement delegations
      locks: introduce new FL_DELEG lock flag
      vfs: take i_mutex on renamed file
      vfs: rename I_MUTEX_QUOTA now that it's not used for quotas
      vfs: don't use PARENT/CHILD lock classes for non-directories
      vfs: pull ext4's double-i_mutex-locking into common code
      exportfs: fix quadratic behavior in filehandle lookup
      exportfs: better variable name
      exportfs: move most of reconnect_path to helper function
      exportfs: eliminate unused "noprogress" counter
      exportfs: stop retrying once we race with rename/remove
      exportfs: clear DISCONNECTED on all parents sooner
      exportfs: more detailed comment for path_reconnect
      ...

commit 27ac0ffeac80ba6b9580529568d06144df044366
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Sep 20 17:19:26 2011 -0400

    locks: break delegations on any attribute modification
    
    NFSv4 uses leases to guarantee that clients can cache metadata as well
    as data.
    
    Cc: Mikulas Patocka <mikulas@artax.karlin.mff.cuni.cz>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Tyler Hicks <tyhicks@canonical.com>
    Cc: Dustin Kirkland <dustin.kirkland@gazzang.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e36e7118ec1..ab2a0ca82dc5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2278,7 +2278,7 @@ extern void emergency_remount(void);
 #ifdef CONFIG_BLOCK
 extern sector_t bmap(struct inode *, sector_t);
 #endif
-extern int notify_change(struct dentry *, struct iattr *);
+extern int notify_change(struct dentry *, struct iattr *, struct inode **);
 extern int inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int);
 

commit 146a8595c6399ee6ab4b5cc34c0d28aa4835fdc5
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Sep 20 17:14:31 2011 -0400

    locks: break delegations on link
    
    Cc: Tyler Hicks <tyhicks@canonical.com>
    Cc: Dustin Kirkland <dustin.kirkland@gazzang.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bcff883fa90..6e36e7118ec1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1453,7 +1453,7 @@ extern int vfs_create(struct inode *, struct dentry *, umode_t, bool);
 extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
 extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
-extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
+extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **);

commit 8e6d782cab50884ba94324632700e6233a252f6a
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Sep 20 16:59:58 2011 -0400

    locks: break delegations on rename
    
    Cc: David Howells <dhowells@redhat.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 931f919f44e1..5bcff883fa90 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1456,7 +1456,7 @@ extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **);
 
 /*
  * VFS dentry helper functions.

commit 5a14696c1795d3843673b5cf1982d0e5357a5bbf
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Aug 28 07:50:40 2012 -0700

    locks: helper functions for delegation breaking
    
    We'll need the same logic for rename and link.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a5799233142a..931f919f44e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1905,6 +1905,9 @@ extern bool fs_fully_visible(struct file_system_type *);
 
 extern int current_umask(void);
 
+extern void ihold(struct inode * inode);
+extern void iput(struct inode *);
+
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 
@@ -1972,6 +1975,28 @@ static inline int break_deleg(struct inode *inode, unsigned int mode)
 	return 0;
 }
 
+static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
+{
+	int ret;
+
+	ret = break_deleg(inode, O_WRONLY|O_NONBLOCK);
+	if (ret == -EWOULDBLOCK && delegated_inode) {
+		*delegated_inode = inode;
+		ihold(inode);
+	}
+	return ret;
+}
+
+static inline int break_deleg_wait(struct inode **delegated_inode)
+{
+	int ret;
+
+	ret = break_deleg(*delegated_inode, O_WRONLY);
+	iput(*delegated_inode);
+	*delegated_inode = NULL;
+	return ret;
+}
+
 #else /* !CONFIG_FILE_LOCKING */
 static inline int locks_mandatory_locked(struct inode *inode)
 {
@@ -2015,6 +2040,18 @@ static inline int break_deleg(struct inode *inode, unsigned int mode)
 {
 	return 0;
 }
+
+static inline int try_break_deleg(struct inode *inode, struct inode **delegated_inode)
+{
+	return 0;
+}
+
+static inline int break_deleg_wait(struct inode **delegated_inode)
+{
+	BUG();
+	return 0;
+}
+
 #endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */
@@ -2350,8 +2387,6 @@ extern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);
 extern int inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
 extern void address_space_init_once(struct address_space *mapping);
-extern void ihold(struct inode * inode);
-extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);
 extern int inode_needs_sync(struct inode *inode);

commit b21996e36c8e3b92a84e972378bde80b43acd890
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Sep 20 09:14:34 2011 -0400

    locks: break delegations on unlink
    
    We need to break delegations on any operation that changes the set of
    links pointing to an inode.  Start with unlink.
    
    Such operations also hold the i_mutex on a parent directory.  Breaking a
    delegation may require waiting for a timeout (by default 90 seconds) in
    the case of a unresponsive NFS client.  To avoid blocking all directory
    operations, we therefore drop locks before waiting for the delegation.
    The logic then looks like:
    
            acquire locks
            ...
            test for delegation; if found:
                    take reference on inode
                    release locks
                    wait for delegation break
                    drop reference on inode
                    retry
    
    It is possible this could never terminate.  (Even if we take precautions
    to prevent another delegation being acquired on the same inode, we could
    get a different inode on each retry.)  But this seems very unlikely.
    
    The initial test for a delegation happens after the lock on the target
    inode is acquired, but the directory inode may have been acquired
    further up the call stack.  We therefore add a "struct inode **"
    argument to any intervening functions, which we use to pass the inode
    back up to the caller in the case it needs a delegation synchronously
    broken.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: Tyler Hicks <tyhicks@canonical.com>
    Cc: Dustin Kirkland <dustin.kirkland@gazzang.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8e4be1be1a62..a5799233142a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1455,7 +1455,7 @@ extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
-extern int vfs_unlink(struct inode *, struct dentry *);
+extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
 extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
 
 /*

commit df4e8d2c1d2bbbbace706bfe5417320c9e3fbee3
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Mon Mar 5 13:18:59 2012 -0500

    locks: implement delegations
    
    Implement NFSv4 delegations at the vfs level using the new FL_DELEG lock
    type.
    
    Note nfsd is the only delegation user and is only using read
    delegations.  Warn on any attempt to set a write delegation for now.
    We'll come back to that case later.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 129e150f9e94..8e4be1be1a62 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1022,7 +1022,7 @@ extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
-extern int __break_lease(struct inode *inode, unsigned int flags);
+extern int __break_lease(struct inode *inode, unsigned int flags, unsigned int type);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
 extern int generic_setlease(struct file *, long, struct file_lock **);
 extern int vfs_setlease(struct file *, long, struct file_lock **);
@@ -1131,7 +1131,7 @@ static inline int flock_lock_file_wait(struct file *filp,
 	return -ENOLCK;
 }
 
-static inline int __break_lease(struct inode *inode, unsigned int mode)
+static inline int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)
 {
 	return 0;
 }
@@ -1961,9 +1961,17 @@ static inline int locks_verify_truncate(struct inode *inode,
 static inline int break_lease(struct inode *inode, unsigned int mode)
 {
 	if (inode->i_flock)
-		return __break_lease(inode, mode);
+		return __break_lease(inode, mode, FL_LEASE);
 	return 0;
 }
+
+static inline int break_deleg(struct inode *inode, unsigned int mode)
+{
+	if (inode->i_flock)
+		return __break_lease(inode, mode, FL_DELEG);
+	return 0;
+}
+
 #else /* !CONFIG_FILE_LOCKING */
 static inline int locks_mandatory_locked(struct inode *inode)
 {
@@ -2003,6 +2011,10 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 	return 0;
 }
 
+static inline int break_deleg(struct inode *inode, unsigned int mode)
+{
+	return 0;
+}
 #endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */

commit 617588d5186c887eb94321b021bb5a46f896f4b3
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Fri Jul 1 15:18:34 2011 -0400

    locks: introduce new FL_DELEG lock flag
    
    For now FL_DELEG is just a synonym for FL_LEASE.  So this patch doesn't
    change behavior.
    
    Next we'll modify break_lease to treat FL_DELEG leases differently, to
    account for the fact that NFSv4 delegations should be broken in more
    situations than Windows oplocks.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed7f94af1ab2..129e150f9e94 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -880,6 +880,7 @@ static inline int file_check_writeable(struct file *filp)
 
 #define FL_POSIX	1
 #define FL_FLOCK	2
+#define FL_DELEG	4	/* NFSv4 delegation */
 #define FL_ACCESS	8	/* not trying to lock, just looking */
 #define FL_EXISTS	16	/* when unlocking, test for existence */
 #define FL_LEASE	32	/* lease held on this file */

commit 40bd22c9f8617ddd5da06044c81f72a2cf700791
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Apr 18 15:21:34 2012 -0400

    vfs: rename I_MUTEX_QUOTA now that it's not used for quotas
    
    I_MUTEX_QUOTA is now just being used whenever we want to lock two
    non-directories.  So the name isn't right.  I_MUTEX_NONDIR2 isn't
    especially elegant but it's the best I could think of.
    
    Also fix some outdated documentation.
    
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4e1a0b41f966..ed7f94af1ab2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -623,10 +623,13 @@ static inline int inode_unhashed(struct inode *inode)
  * 0: the object of the current VFS operation
  * 1: parent
  * 2: child/target
- * 3: quota file
+ * 3: xattr
+ * 4: second non-directory
+ * The last is for certain operations (such as rename) which lock two
+ * non-directories at once.
  *
  * The locking order between these classes is
- * parent -> child -> normal -> xattr -> quota
+ * parent -> child -> normal -> xattr -> second non-directory
  */
 enum inode_i_mutex_lock_class
 {
@@ -634,7 +637,7 @@ enum inode_i_mutex_lock_class
 	I_MUTEX_PARENT,
 	I_MUTEX_CHILD,
 	I_MUTEX_XATTR,
-	I_MUTEX_QUOTA
+	I_MUTEX_NONDIR2
 };
 
 void lock_two_nondirectories(struct inode *, struct inode*);

commit 375e289ea85166c5241c570940e7e7e966c63a9f
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Apr 18 15:16:33 2012 -0400

    vfs: pull ext4's double-i_mutex-locking into common code
    
    We want to do this elsewhere as well.
    
    Also catch any attempts to use it for directories (where this ordering
    would conflict with ancestor-first directory ordering in lock_rename).
    
    Cc: Andreas Dilger <adilger.kernel@dilger.ca>
    Cc: Dave Chinner <david@fromorbit.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5e44b0893db8..4e1a0b41f966 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -637,6 +637,9 @@ enum inode_i_mutex_lock_class
 	I_MUTEX_QUOTA
 };
 
+void lock_two_nondirectories(struct inode *, struct inode*);
+void unlock_two_nondirectories(struct inode *, struct inode*);
+
 /*
  * NOTE: in a 32bit arch with a preemptable kernel and
  * an UP compile the i_size_read/write must be atomic

commit b7a6ec52dd4eced4a9bcda9ca85b3c8af84d3c90
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Oct 2 17:01:18 2013 -0400

    vfs: split out vfs_getattr_nosec
    
    The filehandle lookup code wants this version of getattr.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e190326ac212..5e44b0893db8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2504,6 +2504,7 @@ extern const struct inode_operations page_symlink_inode_operations;
 extern void kfree_put_link(struct dentry *, struct nameidata *, void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
+int vfs_getattr_nosec(struct path *path, struct kstat *stat);
 extern int vfs_getattr(struct path *, struct kstat *);
 void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);

commit 6987843ff7e836ea65b554905aec34d2fad05c94
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 2 22:35:11 2013 -0400

    take anon inode allocation to libfs.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2b0f4e974480..e190326ac212 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2562,6 +2562,7 @@ extern int simple_write_begin(struct file *file, struct address_space *mapping,
 extern int simple_write_end(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned copied,
 			struct page *page, void *fsdata);
+extern struct inode *alloc_anon_inode(struct super_block *);
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);

commit eee5cc2702929fd41cce28058dc6d6717f723f87
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 4 11:06:42 2013 -0400

    get rid of s_files and files_lock
    
    The only thing we need it for is alt-sysrq-r (emergency remount r/o)
    and these days we can do just as well without going through the
    list of files.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2ab8a67ee054..2b0f4e974480 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -764,12 +764,7 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
 #define FILE_MNT_WRITE_RELEASED	2
 
 struct file {
-	/*
-	 * fu_list becomes invalid after file_free is called and queued via
-	 * fu_rcuhead for RCU freeing
-	 */
 	union {
-		struct list_head	fu_list;
 		struct llist_node	fu_llist;
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
@@ -783,9 +778,6 @@ struct file {
 	 * Must not be taken from IRQ context.
 	 */
 	spinlock_t		f_lock;
-#ifdef CONFIG_SMP
-	int			f_sb_list_cpu;
-#endif
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
@@ -1264,11 +1256,6 @@ struct super_block {
 
 	struct list_head	s_inodes;	/* all inodes */
 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
-#ifdef CONFIG_SMP
-	struct list_head __percpu *s_files;
-#else
-	struct list_head	s_files;
-#endif
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;

commit e2fec7c35582e7bb41cccc1761faa2af4dc17627
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 4 17:06:56 2013 -0400

    make freeing super_block rcu-delayed
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b09e4e1d747a..2ab8a67ee054 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1330,6 +1330,7 @@ struct super_block {
 	 */
 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
+	struct rcu_head		rcu;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit e84f9e57b90ca89664d733a7cef19aa7ccd832f3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Sep 22 14:17:15 2013 -0400

    consolidate the reassignments of ->f_op in ->open() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d80c2437d624..b09e4e1d747a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1875,6 +1875,17 @@ extern struct dentry *mount_pseudo(struct file_system_type *, char *,
 	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))
 #define fops_put(fops) \
 	do { if (fops) module_put((fops)->owner); } while(0)
+/*
+ * This one is to be used *ONLY* from ->open() instances.
+ * fops must be non-NULL, pinned down *and* module dependencies
+ * should be sufficient to pin the caller down as well.
+ */
+#define replace_fops(f, fops) \
+	do {	\
+		struct file *__file = (f); \
+		fops_put(__file->f_op); \
+		BUG_ON(!(__file->f_op = (fops))); \
+	} while(0)
 
 extern int register_filesystem(struct file_system_type *);
 extern int unregister_filesystem(struct file_system_type *);

commit 87dc800be2499128efb3a6f059d75dc8e1e6d503
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Sep 16 10:30:04 2013 -0400

    new helper: kfree_put_link()
    
    duplicated to hell and back...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f40547ba191..d80c2437d624 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2502,6 +2502,7 @@ extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
+extern void kfree_put_link(struct dentry *, struct nameidata *, void *);
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 extern int vfs_getattr(struct path *, struct kstat *);

commit f1fe29b4a02d0805aa7d0ff6b73410a9f9316d69
Author: David Howells <dhowells@redhat.com>
Date:   Fri Sep 27 11:20:03 2013 +0100

    NFS: Use i_writecount to control whether to get an fscache cookie in nfs_open()
    
    Use i_writecount to control whether to get an fscache cookie in nfs_open() as
    NFS does not do write caching yet.  I *think* this is the cause of a problem
    encountered by Mark Moseley whereby __fscache_uncache_page() gets a NULL
    pointer dereference because cookie->def is NULL:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
    IP: [<ffffffff812a1903>] __fscache_uncache_page+0x23/0x160
    PGD 0
    Thread overran stack, or stack corrupted
    Oops: 0000 [#1] SMP
    Modules linked in: ...
    CPU: 7 PID: 18993 Comm: php Not tainted 3.11.1 #1
    Hardware name: Dell Inc. PowerEdge R420/072XWF, BIOS 1.3.5 08/21/2012
    task: ffff8804203460c0 ti: ffff880420346640
    RIP: 0010:[<ffffffff812a1903>] __fscache_uncache_page+0x23/0x160
    RSP: 0018:ffff8801053af878 EFLAGS: 00210286
    RAX: 0000000000000000 RBX: ffff8800be2f8780 RCX: ffff88022ffae5e8
    RDX: 0000000000004c66 RSI: ffffea00055ff440 RDI: ffff8800be2f8780
    RBP: ffff8801053af898 R08: 0000000000000001 R09: 0000000000000003
    R10: 0000000000000000 R11: 0000000000000000 R12: ffffea00055ff440
    R13: 0000000000001000 R14: ffff8800c50be538 R15: 0000000000000000
    FS: 0000000000000000(0000) GS:ffff88042fc60000(0063) knlGS:00000000e439c700
    CS: 0010 DS: 002b ES: 002b CR0: 0000000080050033
    CR2: 0000000000000010 CR3: 0000000001d8f000 CR4: 00000000000607f0
    Stack:
    ...
    Call Trace:
    [<ffffffff81365a72>] __nfs_fscache_invalidate_page+0x42/0x70
    [<ffffffff813553d5>] nfs_invalidate_page+0x75/0x90
    [<ffffffff811b8f5e>] truncate_inode_page+0x8e/0x90
    [<ffffffff811b90ad>] truncate_inode_pages_range.part.12+0x14d/0x620
    [<ffffffff81d6387d>] ? __mutex_lock_slowpath+0x1fd/0x2e0
    [<ffffffff811b95d3>] truncate_inode_pages_range+0x53/0x70
    [<ffffffff811b969d>] truncate_inode_pages+0x2d/0x40
    [<ffffffff811b96ff>] truncate_pagecache+0x4f/0x70
    [<ffffffff81356840>] nfs_setattr_update_inode+0xa0/0x120
    [<ffffffff81368de4>] nfs3_proc_setattr+0xc4/0xe0
    [<ffffffff81357f78>] nfs_setattr+0xc8/0x150
    [<ffffffff8122d95b>] notify_change+0x1cb/0x390
    [<ffffffff8120a55b>] do_truncate+0x7b/0xc0
    [<ffffffff8121f96c>] do_last+0xa4c/0xfd0
    [<ffffffff8121ffbc>] path_openat+0xcc/0x670
    [<ffffffff81220a0e>] do_filp_open+0x4e/0xb0
    [<ffffffff8120ba1f>] do_sys_open+0x13f/0x2b0
    [<ffffffff8126aaf6>] compat_SyS_open+0x36/0x50
    [<ffffffff81d7204c>] sysenter_dispatch+0x7/0x24
    
    The code at the instruction pointer was disassembled:
    
    > (gdb) disas __fscache_uncache_page
    > Dump of assembler code for function __fscache_uncache_page:
    > ...
    > 0xffffffff812a18ff <+31>: mov 0x48(%rbx),%rax
    > 0xffffffff812a1903 <+35>: cmpb $0x0,0x10(%rax)
    > 0xffffffff812a1907 <+39>: je 0xffffffff812a19cd <__fscache_uncache_page+237>
    
    These instructions make up:
    
            ASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);
    
    That cmpb is the faulting instruction (%rax is 0).  So cookie->def is NULL -
    which presumably means that the cookie has already been at least partway
    through __fscache_relinquish_cookie().
    
    What I think may be happening is something like a three-way race on the same
    file:
    
            PROCESS 1       PROCESS 2       PROCESS 3
            =============== =============== ===============
            open(O_TRUNC|O_WRONLY)
                            open(O_RDONLY)
                                            open(O_WRONLY)
            -->nfs_open()
            -->nfs_fscache_set_inode_cookie()
            nfs_fscache_inode_lock()
            nfs_fscache_disable_inode_cookie()
            __fscache_relinquish_cookie()
            nfs_inode->fscache = NULL
            <--nfs_fscache_set_inode_cookie()
    
                            -->nfs_open()
                            -->nfs_fscache_set_inode_cookie()
                            nfs_fscache_inode_lock()
                            nfs_fscache_enable_inode_cookie()
                            __fscache_acquire_cookie()
                            nfs_inode->fscache = cookie
                            <--nfs_fscache_set_inode_cookie()
            <--nfs_open()
            -->nfs_setattr()
            ...
            ...
            -->nfs_invalidate_page()
            -->__nfs_fscache_invalidate_page()
            cookie = nfsi->fscache
                                            -->nfs_open()
                                            -->nfs_fscache_set_inode_cookie()
                                            nfs_fscache_inode_lock()
                                            nfs_fscache_disable_inode_cookie()
                                            -->__fscache_relinquish_cookie()
            -->__fscache_uncache_page(cookie)
            <crash>
                                            <--__fscache_relinquish_cookie()
                                            nfs_inode->fscache = NULL
                                            <--nfs_fscache_set_inode_cookie()
    
    What is needed is something to prevent process #2 from reacquiring the cookie
    - and I think checking i_writecount should do the trick.
    
    It's also possible to have a two-way race on this if the file is opened
    O_TRUNC|O_RDONLY instead.
    
    Reported-by: Mark Moseley <moseleymark@gmail.com>
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f40547ba191..955dff5da56a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2292,6 +2292,11 @@ static inline void allow_write_access(struct file *file)
 	if (file)
 		atomic_inc(&file_inode(file)->i_writecount);
 }
+static inline bool inode_is_open_for_write(const struct inode *inode)
+{
+	return atomic_read(&inode->i_writecount) > 0;
+}
+
 #ifdef CONFIG_IMA
 static inline void i_readcount_dec(struct inode *inode)
 {

commit 3711d86a2de17e967b576af8b8a1e9351a7d1466
Merge: 89dc77bcdabf a8855990e382
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 13 23:06:40 2013 -0400

    Merge tag 'writeback-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/wfg/linux
    
    Pull writeback fix from Wu Fengguang:
     "A trivial writeback fix"
    
    * tag 'writeback-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/wfg/linux:
      writeback: Do not sort b_io list only because of block device inode

commit 9b17c62382dd2e7507984b9890bf44e070cdd8bb
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:18:05 2013 +1000

    fs: convert inode and dentry shrinking to be node aware
    
    Now that the shrinker is passing a node in the scan control structure, we
    can pass this to the the generic LRU list code to isolate reclaim to the
    lists on matching nodes.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@parallels.com>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 36e45df87f6e..a4acd3c61190 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1624,8 +1624,8 @@ struct super_operations {
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
-	long (*nr_cached_objects)(struct super_block *);
-	long (*free_cached_objects)(struct super_block *, long);
+	long (*nr_cached_objects)(struct super_block *, int);
+	long (*free_cached_objects)(struct super_block *, long, int);
 };
 
 /*

commit f604156751db77e08afe47ce29fe8f3d51ad9b04
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:18:00 2013 +1000

    dcache: convert to use new lru list infrastructure
    
    [glommer@openvz.org: don't reintroduce double decrement of nr_unused_dentries, adapted for new LRU return codes]
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e04786569c28..36e45df87f6e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1270,14 +1270,6 @@ struct super_block {
 	struct list_head	s_files;
 #endif
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
-
-	/* s_dentry_lru_lock protects s_dentry_lru and s_nr_dentry_unused */
-	spinlock_t		s_dentry_lru_lock ____cacheline_aligned_in_smp;
-	struct list_head	s_dentry_lru;	/* unused dentry lru */
-	long			s_nr_dentry_unused;	/* # of dentry on lru */
-
-	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
-
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;
 	struct mtd_info		*s_mtd;
@@ -1331,6 +1323,13 @@ struct super_block {
 
 	/* AIO completions deferred from interrupt context */
 	struct workqueue_struct *s_dio_done_wq;
+
+	/*
+	 * Keep the lru lists last in the structure so they always sit on their
+	 * own individual cachelines.
+	 */
+	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
+	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit bc3b14cb2d505dda969dbe3a31038dbb24aca945
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:17:58 2013 +1000

    inode: convert inode lru list to generic lru list code.
    
    [glommer@openvz.org: adapted for new LRU return codes]
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0ae0bc3c1fde..e04786569c28 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/cache.h>
 #include <linux/list.h>
+#include <linux/list_lru.h>
 #include <linux/llist.h>
 #include <linux/radix-tree.h>
 #include <linux/rbtree.h>
@@ -1275,10 +1276,7 @@ struct super_block {
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	long			s_nr_dentry_unused;	/* # of dentry on lru */
 
-	/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */
-	spinlock_t		s_inode_lru_lock ____cacheline_aligned_in_smp;
-	struct list_head	s_inode_lru;		/* unused inode lru */
-	long			s_nr_inodes_unused;	/* # of inodes on lru */
+	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
 
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;

commit 0a234c6dcb79a270803f5c9773ed650b78730962
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:17:57 2013 +1000

    shrinker: convert superblock shrinkers to new API
    
    Convert superblock shrinker to use the new count/scan API, and propagate
    the API changes through to the filesystem callouts.  The filesystem
    callouts already use a count/scan API, so it's just changing counters to
    longs to match the VM API.
    
    This requires the dentry and inode shrinker callouts to be converted to
    the count/scan API.  This is mainly a mechanical change.
    
    [glommer@openvz.org: use mult_frac for fractional proportions, build fixes]
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a90f6886fa..0ae0bc3c1fde 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1335,10 +1335,6 @@ struct super_block {
 	struct workqueue_struct *s_dio_done_wq;
 };
 
-/* superblock cache pruning functions */
-extern void prune_icache_sb(struct super_block *sb, int nr_to_scan);
-extern void prune_dcache_sb(struct super_block *sb, int nr_to_scan);
-
 extern struct timespec current_fs_time(struct super_block *sb);
 
 /*
@@ -1631,8 +1627,8 @@ struct super_operations {
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
-	int (*nr_cached_objects)(struct super_block *);
-	void (*free_cached_objects)(struct super_block *, int);
+	long (*nr_cached_objects)(struct super_block *);
+	long (*free_cached_objects)(struct super_block *, long);
 };
 
 /*

commit 19156840e33a23eeb1a749c0f991dab6588b077d
Author: Dave Chinner <dchinner@redhat.com>
Date:   Wed Aug 28 10:17:55 2013 +1000

    dentry: move to per-sb LRU locks
    
    With the dentry LRUs being per-sb structures, there is no real need for
    a global dentry_lru_lock. The locking can be made more fine-grained by
    moving to a per-sb LRU lock, isolating the LRU operations of different
    filesytsems completely from each other. The need for this is independent
    of any performance consideration that may arise: in the interest of
    abstracting the lru operations away, it is mandatory that each lru works
    around its own lock instead of a global lock for all of them.
    
    [glommer@openvz.org: updated changelog ]
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3b3edac75df2..14a90f6886fa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1269,7 +1269,9 @@ struct super_block {
 	struct list_head	s_files;
 #endif
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
-	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */
+
+	/* s_dentry_lru_lock protects s_dentry_lru and s_nr_dentry_unused */
+	spinlock_t		s_dentry_lru_lock ____cacheline_aligned_in_smp;
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	long			s_nr_dentry_unused;	/* # of dentry on lru */
 

commit 3942c07ccf98e66b8893f396dca98f5b076f905f
Author: Glauber Costa <glommer@openvz.org>
Date:   Wed Aug 28 10:17:53 2013 +1000

    fs: bump inode and dentry counters to long
    
    This series reworks our current object cache shrinking infrastructure in
    two main ways:
    
     * Noticing that a lot of users copy and paste their own version of LRU
       lists for objects, we put some effort in providing a generic version.
       It is modeled after the filesystem users: dentries, inodes, and xfs
       (for various tasks), but we expect that other users could benefit in
       the near future with little or no modification.  Let us know if you
       have any issues.
    
     * The underlying list_lru being proposed automatically and
       transparently keeps the elements in per-node lists, and is able to
       manipulate the node lists individually.  Given this infrastructure, we
       are able to modify the up-to-now hammer called shrink_slab to proceed
       with node-reclaim instead of always searching memory from all over like
       it has been doing.
    
    Per-node lru lists are also expected to lead to less contention in the lru
    locks on multi-node scans, since we are now no longer fighting for a
    global lock.  The locks usually disappear from the profilers with this
    change.
    
    Although we have no official benchmarks for this version - be our guest to
    independently evaluate this - earlier versions of this series were
    performance tested (details at
    http://permalink.gmane.org/gmane.linux.kernel.mm/100537) yielding no
    visible performance regressions while yielding a better qualitative
    behavior in NUMA machines.
    
    With this infrastructure in place, we can use the list_lru entry point to
    provide memcg isolation and per-memcg targeted reclaim.  Historically,
    those two pieces of work have been posted together.  This version presents
    only the infrastructure work, deferring the memcg work for a later time,
    so we can focus on getting this part tested.  You can see more about the
    history of such work at http://lwn.net/Articles/552769/
    
    Dave Chinner (18):
      dcache: convert dentry_stat.nr_unused to per-cpu counters
      dentry: move to per-sb LRU locks
      dcache: remove dentries from LRU before putting on dispose list
      mm: new shrinker API
      shrinker: convert superblock shrinkers to new API
      list: add a new LRU list type
      inode: convert inode lru list to generic lru list code.
      dcache: convert to use new lru list infrastructure
      list_lru: per-node list infrastructure
      shrinker: add node awareness
      fs: convert inode and dentry shrinking to be node aware
      xfs: convert buftarg LRU to generic code
      xfs: rework buffer dispose list tracking
      xfs: convert dquot cache lru to list_lru
      fs: convert fs shrinkers to new scan/count API
      drivers: convert shrinkers to new count/scan API
      shrinker: convert remaining shrinkers to count/scan API
      shrinker: Kill old ->shrink API.
    
    Glauber Costa (7):
      fs: bump inode and dentry counters to long
      super: fix calculation of shrinkable objects for small numbers
      list_lru: per-node API
      vmscan: per-node deferred work
      i915: bail out earlier when shrinker cannot acquire mutex
      hugepage: convert huge zero page shrinker to new shrinker API
      list_lru: dynamically adjust node arrays
    
    This patch:
    
    There are situations in very large machines in which we can have a large
    quantity of dirty inodes, unused dentries, etc.  This is particularly true
    when umounting a filesystem, where eventually since every live object will
    eventually be discarded.
    
    Dave Chinner reported a problem with this while experimenting with the
    shrinker revamp patchset.  So we believe it is time for a change.  This
    patch just moves int to longs.  Machines where it matters should have a
    big long anyway.
    
    Signed-off-by: Glauber Costa <glommer@openvz.org>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Arve Hjnnevg <arve@android.com>
    Cc: Carlos Maiolino <cmaiolino@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: J. Bruce Fields <bfields@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jerome Glisse <jglisse@redhat.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Kent Overstreet <koverstreet@google.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Thomas Hellstrom <thellstrom@vmware.com>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 49e71b0f0e9f..3b3edac75df2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1271,12 +1271,12 @@ struct super_block {
 	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
-	int			s_nr_dentry_unused;	/* # of dentry on lru */
+	long			s_nr_dentry_unused;	/* # of dentry on lru */
 
 	/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */
 	spinlock_t		s_inode_lru_lock ____cacheline_aligned_in_smp;
 	struct list_head	s_inode_lru;		/* unused inode lru */
-	int			s_nr_inodes_unused;	/* # of inodes on lru */
+	long			s_nr_inodes_unused;	/* # of inodes on lru */
 
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;

commit aac34df11791d25417f7d756dc277b6f95996b47
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Sep 9 07:16:41 2013 -0700

    fs: remove vfs_follow_link
    
    For a long time no filesystem has been using vfs_follow_link, and as seen
    by recent filesystem submissions any new use is accidental as well.
    
    Remove vfs_follow_link, document the replacement in
    Documentation/filesystems/porting and also rename __vfs_follow_link
    to match its only caller better.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 529d8711baba..49e71b0f0e9f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2494,7 +2494,6 @@ extern const struct file_operations generic_ro_fops;
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
 extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
-extern int vfs_follow_link(struct nameidata *, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
 extern void *page_follow_link_light(struct dentry *, struct nameidata *);
 extern void page_put_link(struct dentry *, struct nameidata *, void *);

commit c7c4591db64dbd1e504bc4e2806d7ef290a3c81b
Merge: 11c7b03d42a8 c7b96acf1456
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 7 14:35:32 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull namespace changes from Eric Biederman:
     "This is an assorted mishmash of small cleanups, enhancements and bug
      fixes.
    
      The major theme is user namespace mount restrictions.  nsown_capable
      is killed as it encourages not thinking about details that need to be
      considered.  A very hard to hit pid namespace exiting bug was finally
      tracked and fixed.  A couple of cleanups to the basic namespace
      infrastructure.
    
      Finally there is an enhancement that makes per user namespace
      capabilities usable as capabilities, and an enhancement that allows
      the per userns root to nice other processes in the user namespace"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace:
      userns:  Kill nsown_capable it makes the wrong thing easy
      capabilities: allow nice if we are privileged
      pidns: Don't have unshare(CLONE_NEWPID) imply CLONE_THREAD
      userns: Allow PR_CAPBSET_DROP in a user namespace.
      namespaces: Simplify copy_namespaces so it is clear what is going on.
      pidns: Fix hang in zap_pid_ns_processes by sending a potentially extra wakeup
      sysfs: Restrict mounting sysfs
      userns: Better restrictions on when proc and sysfs can be mounted
      vfs: Don't copy mount bind mounts of /proc/<pid>/ns/mnt between namespaces
      kernel/nsproxy.c: Improving a snippet of code.
      proc: Restrict mounting the proc filesystem
      vfs: Lock in place mounts from more privileged users

commit 45d9a2220f6004b47c362cc7fc7cf9a73cb6353a
Merge: 2386a3b0fbb0 02afc27faec9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 5 08:50:26 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile 1 from Al Viro:
     "Unfortunately, this merge window it'll have a be a lot of small piles -
      my fault, actually, for not keeping #for-next in anything that would
      resemble a sane shape ;-/
    
      This pile: assorted fixes (the first 3 are -stable fodder, IMO) and
      cleanups + %pd/%pD formats (dentry/file pathname, up to 4 last
      components) + several long-standing patches from various folks.
    
      There definitely will be a lot more (starting with Miklos'
      check_submount_and_drop() series)"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (26 commits)
      direct-io: Handle O_(D)SYNC AIO
      direct-io: Implement generic deferred AIO completions
      add formats for dentry/file pathnames
      kvm eventfd: switch to fdget
      powerpc kvm: use fdget
      switch fchmod() to fdget
      switch epoll_ctl() to fdget
      switch copy_module_from_fd() to fdget
      git simplify nilfs check for busy subtree
      ibmasmfs: don't bother passing superblock when not needed
      don't pass superblock to hypfs_{mkdir,create*}
      don't pass superblock to hypfs_diag_create_files
      don't pass superblock to hypfs_vm_create_files()
      oprofile: get rid of pointless forward declarations of struct super_block
      oprofilefs_create_...() do not need superblock argument
      oprofilefs_mkdir() doesn't need superblock argument
      don't bother with passing superblock to oprofile_create_stats_files()
      oprofile: don't bother with passing superblock to ->create_files()
      don't bother passing sb to oprofile_create_files()
      coh901318: don't open-code simple_read_from_buffer()
      ...

commit 7b7a8665edd8db733980389b098530f9e4f630b2
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Sep 4 15:04:39 2013 +0200

    direct-io: Implement generic deferred AIO completions
    
    Add support to the core direct-io code to defer AIO completions to user
    context using a workqueue.  This replaces opencoded and less efficient
    code in XFS and ext4 (we save a memory allocation for each direct IO)
    and will be needed to properly support O_(D)SYNC for AIO.
    
    The communication between the filesystem and the direct I/O code requires
    a new buffer head flag, which is a bit ugly but not avoidable until the
    direct I/O code stops abusing the buffer_head structure for communicating
    with the filesystems.
    
    Currently this creates a per-superblock unbound workqueue for these
    completions, which is taken from an earlier patch by Jan Kara.  I'm
    not really convinced about this use and would prefer a "normal" global
    workqueue with a high concurrency limit, but this needs further discussion.
    
    JK: Fixed ext4 part, dynamic allocation of the workqueue.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65c9929cd340..c9013876eb29 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -46,6 +46,7 @@ struct vfsmount;
 struct cred;
 struct swap_info_struct;
 struct seq_file;
+struct workqueue_struct;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -63,8 +64,7 @@ struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
 typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
-			ssize_t bytes, void *private, int ret,
-			bool is_async);
+			ssize_t bytes, void *private);
 
 #define MAY_EXEC		0x00000001
 #define MAY_WRITE		0x00000002
@@ -1328,6 +1328,9 @@ struct super_block {
 
 	/* Being remounted read-only */
 	int s_readonly_remount;
+
+	/* AIO completions deferred from interrupt context */
+	struct workqueue_struct *s_dio_done_wq;
 };
 
 /* superblock cache pruning functions */

commit badcf2b7b816130a60152d9f5a06705176596925
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 16 18:15:46 2013 +0400

    constify touch_atime()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 981874773e85..65c9929cd340 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1804,7 +1804,7 @@ enum file_time_flags {
 	S_VERSION = 8,
 };
 
-extern void touch_atime(struct path *);
+extern void touch_atime(const struct path *);
 static inline void file_accessed(struct file *file)
 {
 	if (!(file->f_flags & O_NOATIME))

commit e51db73532955dc5eaba4235e62b74b460709d5b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Mar 30 19:57:41 2013 -0700

    userns: Better restrictions on when proc and sysfs can be mounted
    
    Rely on the fact that another flavor of the filesystem is already
    mounted and do not rely on state in the user namespace.
    
    Verify that the mounted filesystem is not covered in any significant
    way.  I would love to verify that the previously mounted filesystem
    has no mounts on top but there are at least the directories
    /proc/sys/fs/binfmt_misc and /sys/fs/cgroup/ that exist explicitly
    for other filesystems to mount on top of.
    
    Refactor the test into a function named fs_fully_visible and call that
    function from the mount routines of proc and sysfs.  This makes this
    test local to the filesystems involved and the results current of when
    the mounts take place, removing a weird threading of the user
    namespace, the mount namespace and the filesystems themselves.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 981874773e85..3050c620f062 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1897,6 +1897,7 @@ extern int vfs_ustat(dev_t, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
+extern bool fs_fully_visible(struct file_system_type *);
 
 extern int current_umask(void);
 

commit 1c8924eb106c1ac755d5d35ce9b3ff42e89e2511
Author: Jan Kara <jack@suse.cz>
Date:   Sat Aug 17 09:32:32 2013 -0400

    quota: provide interface for readding allocated space into reserved space
    
    ext4 needs to convert allocated (metadata) blocks back into blocks
    reserved for delayed allocation. Add functions into quota code for
    supporting such operation.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 981874773e85..e7893523f81f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2503,6 +2503,7 @@ extern void generic_fillattr(struct inode *, struct kstat *);
 extern int vfs_getattr(struct path *, struct kstat *);
 void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
+void __inode_sub_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);

commit 41d9884c44237cd66e2bdbc412028b29196b344c
Merge: 63345b4794ae dae3794fd603
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 14 11:42:26 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull more vfs stuff from Al Viro:
     "O_TMPFILE ABI changes, Oleg's fput() series, misc cleanups, including
      making simple_lookup() usable for filesystems with non-NULL s_d_op,
      which allows us to get rid of quite a bit of ugliness"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      sunrpc: now we can just set ->s_d_op
      cgroup: we can use simple_lookup() now
      efivarfs: we can use simple_lookup() now
      make simple_lookup() usable for filesystems that set ->s_d_op
      configfs: don't open-code d_alloc_name()
      __rpc_lookup_create_exclusive: pass string instead of qstr
      rpc_create_*_dir: don't bother with qstr
      llist: llist_add() can use llist_add_batch()
      llist: fix/simplify llist_add() and llist_add_batch()
      fput: turn "list_head delayed_fput_list" into llist_head
      fs/file_table.c:fput(): add comment
      Safer ABI for O_TMPFILE

commit 4f5e65a1cc90bbb15b9f6cdc362922af1bcc155a
Author: Oleg Nesterov <oleg@redhat.com>
Date:   Mon Jul 8 14:24:16 2013 -0700

    fput: turn "list_head delayed_fput_list" into llist_head
    
    fput() and delayed_fput() can use llist and avoid the locking.
    
    This is unlikely path, it is not that this change can improve
    the performance, but this way the code looks simpler.
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Suggested-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andrey Vagin <avagin@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Huang Ying <ying.huang@intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 834c9e5113d9..d40e8e78bbd1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,6 +10,7 @@
 #include <linux/stat.h>
 #include <linux/cache.h>
 #include <linux/list.h>
+#include <linux/llist.h>
 #include <linux/radix-tree.h>
 #include <linux/rbtree.h>
 #include <linux/init.h>
@@ -768,6 +769,7 @@ struct file {
 	 */
 	union {
 		struct list_head	fu_list;
+		struct llist_node	fu_llist;
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
 	struct path		f_path;

commit a82a729f04232ccd0b59406574ba4cf20027a49d
Merge: 899dd3888530 27daabd9b6a1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 9 13:33:36 2013 -0700

    Merge branch 'akpm' (updates from Andrew Morton)
    
    Merge second patch-bomb from Andrew Morton:
     - misc fixes
     - audit stuff
     - fanotify/inotify/dnotify things
     - most of the rest of MM.  The new cache shrinker code from Glauber and
       Dave Chinner probably isn't quite stabilized yet.
     - ptrace
     - ipc
     - partitions
     - reboot cleanups
     - add LZ4 decompressor, use it for kernel compression
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (118 commits)
      lib/scatterlist: error handling in __sg_alloc_table()
      scsi_debug: fix do_device_access() with wrap around range
      crypto: talitos: use sg_pcopy_to_buffer()
      lib/scatterlist: introduce sg_pcopy_from_buffer() and sg_pcopy_to_buffer()
      lib/scatterlist: factor out sg_miter_get_next_page() from sg_miter_next()
      crypto: add lz4 Cryptographic API
      lib: add lz4 compressor module
      arm: add support for LZ4-compressed kernel
      lib: add support for LZ4-compressed kernel
      decompressor: add LZ4 decompressor module
      lib: add weak clz/ctz functions
      reboot: move arch/x86 reboot= handling to generic kernel
      reboot: arm: change reboot_mode to use enum reboot_mode
      reboot: arm: prepare reboot_mode for moving to generic kernel code
      reboot: arm: remove unused restart_mode fields from some arm subarchs
      reboot: unicore32: prepare reboot_mode for moving to generic kernel code
      reboot: x86: prepare reboot_mode for moving to generic kernel code
      reboot: checkpatch.pl the new kernel/reboot.c file
      reboot: move shutdown/reboot related functions to kernel/reboot.c
      reboot: remove -stable friendly PF_THREAD_BOUND define
      ...

commit ef277c73ca3b1aade278036ae11640090681d558
Author: Tang Chen <tangchen@cn.fujitsu.com>
Date:   Mon Jul 8 16:00:21 2013 -0700

    page migration: fix wrong comment in address_space_operations.migratepage()
    
    There is no parameter "sync" in address_space_operations->migratepage().
    It should be migrate_mode.  And the comment is for MIGRATE_ASYNC.
    
    Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 99be011e00de..cb771ecc2362 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -372,8 +372,8 @@ struct address_space_operations {
 	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
 						void **, unsigned long *);
 	/*
-	 * migrate the contents of a page to the specified target. If sync
-	 * is false, it must not block.
+	 * migrate the contents of a page to the specified target. If
+	 * migrate_mode is MIGRATE_ASYNC, it must not block.
 	 */
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *, enum migrate_mode);

commit a8855990e382fc81c04187c5fdb48743307baf32
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jul 9 22:36:45 2013 +0800

    writeback: Do not sort b_io list only because of block device inode
    
    It is very likely that block device inode will be part of BDI dirty list
    as well. However it doesn't make sence to sort inodes on the b_io list
    just because of this inode (as it contains buffers all over the device
    anyway). So save some CPU cycles which is valuable since we hold relatively
    contented wb->list_lock.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65c2be22b601..61da2f1c8056 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2058,6 +2058,7 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
+extern int sb_is_blkdev_sb(struct super_block *sb);
 #else
 static inline void bd_forget(struct inode *inode) {}
 static inline int sync_blockdev(struct block_device *bdev) { return 0; }
@@ -2077,6 +2078,11 @@ static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
 static inline void iterate_bdevs(void (*f)(struct block_device *, void *), void *arg)
 {
 }
+
+static inline int sb_is_blkdev_sb(struct super_block *sb)
+{
+	return 0;
+}
 #endif
 extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;

commit 7012b02a2b2c42bb1e1d95040a6e3bb59c7284f7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:22 2013 -0400

    locks: move file_lock_list to a set of percpu hlist_heads and convert file_lock_lock to an lglock
    
    The file_lock_list is only used for /proc/locks. The vastly common case
    is for locks to be put onto the list and come off again, without ever
    being traversed.
    
    Help optimize for this use-case by moving to percpu hlist_head-s. At the
    same time, we can make the locking less contentious by moving to an
    lglock. When iterating over the lists for /proc/locks, we must take the
    global lock and then iterate over each CPU's list in turn.
    
    This change necessitates a new fl_link_cpu field to keep track of which
    CPU the entry is on. On x86_64 at least, this field is placed within an
    existing hole in the struct to avoid growing the size.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 99be011e00de..834c9e5113d9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -954,6 +954,7 @@ struct file_lock {
 	unsigned int fl_flags;
 	unsigned char fl_type;
 	unsigned int fl_pid;
+	int fl_link_cpu;		/* what cpu's list is this on? */
 	struct pid *fl_nspid;
 	wait_queue_head_t fl_wait;
 	struct file *fl_file;

commit b45972265f823ed01eae0867a176320071665787
Author: Mel Gorman <mgorman@suse.de>
Date:   Wed Jul 3 15:02:05 2013 -0700

    mm: vmscan: take page buffers dirty and locked state into account
    
    Page reclaim keeps track of dirty and under writeback pages and uses it
    to determine if wait_iff_congested() should stall or if kswapd should
    begin writing back pages.  This fails to account for buffer pages that
    can be under writeback but not PageWriteback which is the case for
    filesystems like ext3 ordered mode.  Furthermore, PageDirty buffer pages
    can have all the buffers clean and writepage does no IO so it should not
    be accounted as congested.
    
    This patch adds an address_space operation that filesystems may
    optionally use to check if a page is really dirty or really under
    writeback.  An implementation is provided for for buffer_heads is added
    and used for block operations and ext3 in ordered mode.  By default the
    page flags are obeyed.
    
    Credit goes to Jan Kara for identifying that the page flags alone are
    not sufficient for ext3 and sanity checking a number of ideas on how the
    problem could be addressed.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
    Cc: Zlatko Calusic <zcalusic@bitsync.net>
    Cc: dormando <dormando@rydia.net>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2b82c8041490..99be011e00de 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -380,6 +380,7 @@ struct address_space_operations {
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
 					unsigned long);
+	void (*is_dirty_writeback) (struct page *, bool *, bool *);
 	int (*error_remove_page)(struct address_space *, struct page *);
 
 	/* swapfile support */

commit 790eac5640abf7a57fa3a644386df330e18c11b0
Merge: 0b0585c3e192 48bde8d3620f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 09:10:19 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull second set of VFS changes from Al Viro:
     "Assorted f_pos race fixes, making do_splice_direct() safe to call with
      i_mutex on parent, O_TMPFILE support, Jeff's locks.c series,
      ->d_hash/->d_compare calling conventions changes from Linus, misc
      stuff all over the place."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (63 commits)
      Document ->tmpfile()
      ext4: ->tmpfile() support
      vfs: export lseek_execute() to modules
      lseek_execute() doesn't need an inode passed to it
      block_dev: switch to fixed_size_llseek()
      cpqphp_sysfs: switch to fixed_size_llseek()
      tile-srom: switch to fixed_size_llseek()
      proc_powerpc: switch to fixed_size_llseek()
      ubi/cdev: switch to fixed_size_llseek()
      pci/proc: switch to fixed_size_llseek()
      isapnp: switch to fixed_size_llseek()
      lpfc: switch to fixed_size_llseek()
      locks: give the blocked_hash its own spinlock
      locks: add a new "lm_owner_key" lock operation
      locks: turn the blocked_list into a hashtable
      locks: convert fl_link to a hlist_node
      locks: avoid taking global lock if possible when waking up blocked waiters
      locks: protect most of the file_lock handling with i_lock
      locks: encapsulate the fl_link list handling
      locks: make "added" in __posix_lock_file a bool
      ...

commit 46a1c2c7ae53de2a5676754b54a73c591a3951d2
Author: Jie Liu <jeff.liu@oracle.com>
Date:   Tue Jun 25 12:02:13 2013 +0800

    vfs: export lseek_execute() to modules
    
    For those file systems(btrfs/ext4/ocfs2/tmpfs) that support
    SEEK_DATA/SEEK_HOLE functions, we end up handling the similar
    matter in lseek_execute() to update the current file offset
    to the desired offset if it is valid, ceph also does the
    simliar things at ceph_llseek().
    
    To reduce the duplications, this patch make lseek_execute()
    public accessible so that we can call it directly from the
    underlying file systems.
    
    Thanks Dave Chinner for this suggestion.
    
    [AV: call it vfs_setpos(), don't bring the removed 'inode' argument back]
    
    v2->v1:
    - Add kernel-doc comments for lseek_execute()
    - Call lseek_execute() in ceph->llseek()
    
    Signed-off-by: Jie Liu <jeff.liu@oracle.com>
    Cc: Dave Chinner <dchinner@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Chris Mason <chris.mason@fusionio.com>
    Cc: Josef Bacik <jbacik@fusionio.com>
    Cc: Ben Myers <bpm@sgi.com>
    Cc: Ted Tso <tytso@mit.edu>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Cc: Sage Weil <sage@inktank.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a137a73fc1fe..bccb1924ec93 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2426,6 +2426,7 @@ extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern loff_t noop_llseek(struct file *file, loff_t offset, int whence);
 extern loff_t no_llseek(struct file *file, loff_t offset, int whence);
+extern loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);
 extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
 		int whence, loff_t maxsize, loff_t eof);

commit 9e239bb93914e1c832d54161c7f8f398d0c914ab
Merge: 63580e51bb3e 6ae06ff51eab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 2 09:39:34 2013 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 update from Ted Ts'o:
     "Lots of bug fixes, cleanups and optimizations.  In the bug fixes
      category, of note is a fix for on-line resizing file systems where the
      block size is smaller than the page size (i.e., file systems 1k blocks
      on x86, or more interestingly file systems with 4k blocks on Power or
      ia64 systems.)
    
      In the cleanup category, the ext4's punch hole implementation was
      significantly improved by Lukas Czerner, and now supports bigalloc
      file systems.  In addition, Jan Kara significantly cleaned up the
      write submission code path.  We also improved error checking and added
      a few sanity checks.
    
      In the optimizations category, two major optimizations deserve
      mention.  The first is that ext4_writepages() is now used for
      nodelalloc and ext3 compatibility mode.  This allows writes to be
      submitted much more efficiently as a single bio request, instead of
      being sent as individual 4k writes into the block layer (which then
      relied on the elevator code to coalesce the requests in the block
      queue).  Secondly, the extent cache shrink mechanism, which was
      introduce in 3.9, no longer has a scalability bottleneck caused by the
      i_es_lru spinlock.  Other optimizations include some changes to reduce
      CPU usage and to avoid issuing empty commits unnecessarily."
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (86 commits)
      ext4: optimize starting extent in ext4_ext_rm_leaf()
      jbd2: invalidate handle if jbd2_journal_restart() fails
      ext4: translate flag bits to strings in tracepoints
      ext4: fix up error handling for mpage_map_and_submit_extent()
      jbd2: fix theoretical race in jbd2__journal_restart
      ext4: only zero partial blocks in ext4_zero_partial_blocks()
      ext4: check error return from ext4_write_inline_data_end()
      ext4: delete unnecessary C statements
      ext3,ext4: don't mess with dir_file->f_pos in htree_dirblock_to_tree()
      jbd2: move superblock checksum calculation to jbd2_write_superblock()
      ext4: pass inode pointer instead of file pointer to punch hole
      ext4: improve free space calculation for inline_data
      ext4: reduce object size when !CONFIG_PRINTK
      ext4: improve extent cache shrink mechanism to avoid to burn CPU time
      ext4: implement error handling of ext4_mb_new_preallocation()
      ext4: fix corruption when online resizing a fs with 1K block size
      ext4: delete unused variables
      ext4: return FIEMAP_EXTENT_UNKNOWN for delalloc extents
      jbd2: remove debug dependency on debug_fs and update Kconfig help text
      jbd2: use a single printk for jbd_debug()
      ...

commit 3999e49364193f7dbbba66e2be655fe91ba1fced
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:19 2013 -0400

    locks: add a new "lm_owner_key" lock operation
    
    Currently, the hashing that the locking code uses to add these values
    to the blocked_hash is simply calculated using fl_owner field. That's
    valid in most cases except for server-side lockd, which validates the
    owner of a lock based on fl_owner and fl_pid.
    
    In the case where you have a small number of NFS clients doing a lot
    of locking between different processes, you could end up with all
    the blocked requests sitting in a very small number of hash buckets.
    
    Add a new lm_owner_key operation to the lock_manager_operations that
    will generate an unsigned long to use as the key in the hashtable.
    That function is only implemented for server-side lockd, and simply
    XORs the fl_owner and fl_pid.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fab064a3b65f..a137a73fc1fe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -908,6 +908,7 @@ struct file_lock_operations {
 
 struct lock_manager_operations {
 	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
+	unsigned long (*lm_owner_key)(struct file_lock *);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, struct file_lock *, int);
 	void (*lm_break)(struct file_lock *);

commit 139ca04ee572fea6c0c105e88aba3a534efcd7c4
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:17 2013 -0400

    locks: convert fl_link to a hlist_node
    
    Testing has shown that iterating over the blocked_list for deadlock
    detection turns out to be a bottleneck. In order to alleviate that,
    begin the process of turning it into a hashtable. We start by turning
    the fl_link into a hlist_node and the global lists into hlists. A later
    patch will do the conversion of the blocked_list to a hashtable.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 24fe998795e1..fab064a3b65f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -946,7 +946,7 @@ int locks_in_grace(struct net *);
  */
 struct file_lock {
 	struct file_lock *fl_next;	/* singly linked list for this inode  */
-	struct list_head fl_link;	/* doubly linked list of all locks */
+	struct hlist_node fl_link;	/* node in global lists */
 	struct list_head fl_block;	/* circular list of blocked processes */
 	fl_owner_t fl_owner;
 	unsigned int fl_flags;

commit 1c8c601a8c0dc59fe64907dcd9d512a3d181ddc7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:15 2013 -0400

    locks: protect most of the file_lock handling with i_lock
    
    Having a global lock that protects all of this code is a clear
    scalability problem. Instead of doing that, move most of the code to be
    protected by the i_lock instead. The exceptions are the global lists
    that the ->fl_link sits on, and the ->fl_block list.
    
    ->fl_link is what connects these structures to the
    global lists, so we must ensure that we hold those locks when iterating
    over or updating these lists.
    
    Furthermore, sound deadlock detection requires that we hold the
    blocked_list state steady while checking for loops. We also must ensure
    that the search and update to the list are atomic.
    
    For the checking and insertion side of the blocked_list, push the
    acquisition of the global lock into __posix_lock_file and ensure that
    checking and update of the  blocked_list is done without dropping the
    lock in between.
    
    On the removal side, when waking up blocked lock waiters, take the
    global lock before walking the blocked list and dequeue the waiters from
    the global list prior to removal from the fl_block list.
    
    With this, deadlock detection should be race free while we minimize
    excessive file_lock_lock thrashing.
    
    Finally, in order to avoid a lock inversion problem when handling
    /proc/locks output we must ensure that manipulations of the fl_block
    list are also protected by the file_lock_lock.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed9fdaaf3223..24fe998795e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1024,8 +1024,6 @@ extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
-extern void lock_flocks(void);
-extern void unlock_flocks(void);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, struct flock __user *user)
 {
@@ -1166,15 +1164,6 @@ static inline int lock_may_write(struct inode *inode, loff_t start,
 {
 	return 1;
 }
-
-static inline void lock_flocks(void)
-{
-}
-
-static inline void unlock_flocks(void)
-{
-}
-
 #endif /* !CONFIG_FILE_LOCKING */
 
 

commit 1cb360125966cb6cb594e414ea80a0154617b846
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:12 2013 -0400

    locks: comment cleanups and clarifications
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6cfc9a29a783..ed9fdaaf3223 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -926,6 +926,24 @@ int locks_in_grace(struct net *);
 /* that will die - we need it for nfs_lock_info */
 #include <linux/nfs_fs_i.h>
 
+/*
+ * struct file_lock represents a generic "file lock". It's used to represent
+ * POSIX byte range locks, BSD (flock) locks, and leases. It's important to
+ * note that the same struct is used to represent both a request for a lock and
+ * the lock itself, but the same object is never used for both.
+ *
+ * FIXME: should we create a separate "struct lock_request" to help distinguish
+ * these two uses?
+ *
+ * The i_flock list is ordered by:
+ *
+ * 1) lock type -- FL_LEASEs first, then FL_FLOCK, and finally FL_POSIX
+ * 2) lock owner
+ * 3) lock range start
+ * 4) lock range end
+ *
+ * Obviously, the last two criteria only matter for POSIX locks.
+ */
 struct file_lock {
 	struct file_lock *fl_next;	/* singly linked list for this inode  */
 	struct list_head fl_link;	/* doubly linked list of all locks */

commit 1a9e64a7118c5ad13dd5119da18375a5bd45b330
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:10 2013 -0400

    cifs: use posix_unblock_lock instead of locks_delete_block
    
    commit 66189be74 (CIFS: Fix VFS lock usage for oplocked files) exported
    the locks_delete_block symbol. There's already an exported helper
    function that provides this capability however, so make cifs use that
    instead and turn locks_delete_block back into a static function.
    
    Note that if fl->fl_next == NULL then this lock has already been through
    locks_delete_block(), so we should be OK to ignore an ENOENT error here
    and simply not retry the lock.
    
    Cc: Pavel Shilovsky <piastryyy@gmail.com>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Acked-by: J. Bruce Fields <bfields@fieldses.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 172303655702..6cfc9a29a783 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1006,7 +1006,6 @@ extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
-extern void locks_delete_block(struct file_lock *waiter);
 extern void lock_flocks(void);
 extern void unlock_flocks(void);
 #else /* !CONFIG_FILE_LOCKING */
@@ -1150,10 +1149,6 @@ static inline int lock_may_write(struct inode *inode, loff_t start,
 	return 1;
 }
 
-static inline void locks_delete_block(struct file_lock *waiter)
-{
-}
-
 static inline void lock_flocks(void)
 {
 }

commit f891a29f46553a384edbaa0f6ac446b1d03bccac
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Jun 21 08:58:09 2013 -0400

    locks: drop the unused filp argument to posix_unblock_lock
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 68f10204ab29..172303655702 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -994,7 +994,7 @@ extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
-extern int posix_unblock_lock(struct file *, struct file_lock *);
+extern int posix_unblock_lock(struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
@@ -1084,8 +1084,7 @@ static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
 	return -ENOLCK;
 }
 
-static inline int posix_unblock_lock(struct file *filp,
-				     struct file_lock *waiter)
+static inline int posix_unblock_lock(struct file_lock *waiter)
 {
 	return -ENOENT;
 }

commit 68d70d03f8f5bd10a0e7337210b13f536fd4aeb9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 19 15:26:04 2013 +0400

    constify rw_verify_area()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 803b7fa2520a..68f10204ab29 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1898,7 +1898,6 @@ extern int current_umask(void);
 extern struct kobject *fs_kobj;
 
 #define MAX_RW_COUNT (INT_MAX & PAGE_CACHE_MASK)
-extern int rw_verify_area(int, struct file *, loff_t *, size_t);
 
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2

commit 1bf9d14dff4a2c4de6152c6f751bdaf6896b68bb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 16 20:27:42 2013 +0400

    new helper: fixed_size_llseek()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1db01c13ddce..803b7fa2520a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2428,6 +2428,8 @@ extern loff_t no_llseek(struct file *file, loff_t offset, int whence);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);
 extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
 		int whence, loff_t maxsize, loff_t eof);
+extern loff_t fixed_size_llseek(struct file *file, loff_t offset,
+		int whence, loff_t size);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit 0b3fca1fd1499f0f5a7486d494f96538f2b7e5b9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 15 11:37:47 2013 +0400

    kill find_inode_number()
    
    the only remaining caller (in ncpfs) is guaranteed to return 0 -
    we only hit it if we'd just checked that there's no dentry with
    such name.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ab11c44b0697..1db01c13ddce 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2311,7 +2311,6 @@ extern struct file * open_exec(const char *);
 /* fs/dcache.c -- generic fs support functions */
 extern int is_subdir(struct dentry *, struct dentry *);
 extern int path_is_under(struct path *, struct path *);
-extern ino_t find_inode_number(struct dentry *, struct qstr *);
 
 #include <linux/err.h>
 

commit f4e0c30c191f87851c4a53454abb55ee276f4a7e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 11 08:34:36 2013 +0400

    allow the temp files created by open() to be linked to
    
    O_TMPFILE | O_CREAT => linkat() with AT_SYMLINK_FOLLOW and /proc/self/fd/<n>
    as oldpath (i.e. flink()) will create a link
    O_TMPFILE | O_CREAT | O_EXCL => ENOENT on attempt to link those guys
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dd6615f0fd13..ab11c44b0697 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1744,6 +1744,7 @@ struct super_operations {
 #define I_REFERENCED		(1 << 8)
 #define __I_DIO_WAKEUP		9
 #define I_DIO_WAKEUP		(1 << I_DIO_WAKEUP)
+#define I_LINKABLE		(1 << 10)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 

commit 60545d0d4610b02e55f65d141c95b18ccf855b6e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 7 01:20:27 2013 -0400

    [O_TMPFILE] it's still short a few helpers, but infrastructure should be OK now...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7c30e3a62baf..dd6615f0fd13 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1580,6 +1580,7 @@ struct inode_operations {
 	int (*atomic_open)(struct inode *, struct dentry *,
 			   struct file *, unsigned open_flag,
 			   umode_t create_mode, int *opened);
+	int (*tmpfile) (struct inode *, struct dentry *, umode_t);
 } ____cacheline_aligned;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,

commit ac6614b76478e68173ccf7ad4e9e98035cc9c21d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 22 22:22:04 2013 -0400

    [readdir] constify ->actor
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 237af62976a6..7c30e3a62baf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1507,7 +1507,7 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
  */
 typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
 struct dir_context {
-	filldir_t actor;
+	const filldir_t actor;
 	loff_t pos;
 };
 

commit 2233f31aade393641f0eaed43a71110e629bb900
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 22 21:44:23 2013 -0400

    [readdir] ->readdir() is gone
    
    everything's converted to ->iterate()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa9770c7e8df..237af62976a6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1526,7 +1526,6 @@ struct file_operations {
 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
 	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
-	int (*readdir) (struct file *, void *, filldir_t);
 	int (*iterate) (struct file *, struct dir_context *);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);

commit 5ded75ec4c576577cae7d556e671d11d0c80c2fc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 15 21:02:48 2013 -0400

    [readdir] convert ext3
    
    new helper: dir_relax(inode).  Call when you are in location that will
    _not_ be invalidated by directory modifications (block boundary, in case
    of ext*).  Returns whether the directory has survived (dropping i_mutex
    allows rmdir to kill the sucker; if it returns false to us, ->iterate()
    is obviously done)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 40293a6ce804..aa9770c7e8df 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2725,5 +2725,11 @@ static inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)
 	}
 	return true;
 }
+static inline bool dir_relax(struct inode *inode)
+{
+	mutex_unlock(&inode->i_mutex);
+	mutex_lock(&inode->i_mutex);
+	return !IS_DEADDIR(inode);
+}
 
 #endif /* _LINUX_FS_H */

commit 5f99f4e79abc64ed9d93a4b0158b21c64ff7f478
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 15 20:23:06 2013 -0400

    [readdir] switch dcache_readdir() users to ->iterate()
    
    new helpers - dir_emit_dot(file, ctx, dentry), dir_emit_dotdot(file, ctx),
    dir_emit_dots(file, ctx).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b9641ae68da8..40293a6ce804 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1511,12 +1511,6 @@ struct dir_context {
 	loff_t pos;
 };
 
-static inline bool dir_emit(struct dir_context *ctx,
-			    const char *name, int namelen,
-			    u64 ino, unsigned type)
-{
-	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
-}
 struct block_device_operations;
 
 /* These macros are for out of kernel modules to test that
@@ -2537,7 +2531,7 @@ extern void iterate_supers_type(struct file_system_type *,
 extern int dcache_dir_open(struct inode *, struct file *);
 extern int dcache_dir_close(struct inode *, struct file *);
 extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
-extern int dcache_readdir(struct file *, void *, filldir_t);
+extern int dcache_readdir(struct file *, struct dir_context *);
 extern int simple_setattr(struct dentry *, struct iattr *);
 extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
 extern int simple_statfs(struct dentry *, struct kstatfs *);
@@ -2701,4 +2695,35 @@ static inline void inode_has_no_xattr(struct inode *inode)
 		inode->i_flags |= S_NOSEC;
 }
 
+static inline bool dir_emit(struct dir_context *ctx,
+			    const char *name, int namelen,
+			    u64 ino, unsigned type)
+{
+	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
+}
+static inline bool dir_emit_dot(struct file *file, struct dir_context *ctx)
+{
+	return ctx->actor(ctx, ".", 1, ctx->pos,
+			  file->f_path.dentry->d_inode->i_ino, DT_DIR) == 0;
+}
+static inline bool dir_emit_dotdot(struct file *file, struct dir_context *ctx)
+{
+	return ctx->actor(ctx, "..", 2, ctx->pos,
+			  parent_ino(file->f_path.dentry), DT_DIR) == 0;
+}
+static inline bool dir_emit_dots(struct file *file, struct dir_context *ctx)
+{
+	if (ctx->pos == 0) {
+		if (!dir_emit_dot(file, ctx))
+			return false;
+		ctx->pos = 1;
+	}
+	if (ctx->pos == 1) {
+		if (!dir_emit_dotdot(file, ctx))
+			return false;
+		ctx->pos = 2;
+	}
+	return true;
+}
+
 #endif /* _LINUX_FS_H */

commit bb6f619b3a49f940d7478112500da312d70866eb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 15 18:49:12 2013 -0400

    [readdir] introduce ->iterate(), ctx->pos, dir_emit()
    
    New method - ->iterate(file, ctx).  That's the replacement for ->readdir();
    it takes callback from ctx->actor, uses ctx->pos instead of file->f_pos and
    calls dir_emit(ctx, ...) instead of filldir(data, ...).  It does *not*
    update file->f_pos (or look at it, for that matter); iterate_dir() does the
    update.
    
    Note that dir_emit() takes the offset from ctx->pos (and eventually
    filldir_t will lose that argument).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 643e5b6cbaf5..b9641ae68da8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1508,7 +1508,15 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
 typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
 struct dir_context {
 	filldir_t actor;
+	loff_t pos;
 };
+
+static inline bool dir_emit(struct dir_context *ctx,
+			    const char *name, int namelen,
+			    u64 ino, unsigned type)
+{
+	return ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;
+}
 struct block_device_operations;
 
 /* These macros are for out of kernel modules to test that
@@ -1525,6 +1533,7 @@ struct file_operations {
 	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	int (*readdir) (struct file *, void *, filldir_t);
+	int (*iterate) (struct file *, struct dir_context *);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);

commit 5c0ba4e0762e6dabd14a5c276652e2defec38de7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 15 13:52:59 2013 -0400

    [readdir] introduce iterate_dir() and dir_context
    
    iterate_dir(): new helper, replacing vfs_readdir().
    
    struct dir_context: contains the readdir callback (and will get more stuff
    in it), embedded into whatever data that callback wants to deal with;
    eventually, we'll be passing it to ->readdir() replacement instead of
    (data,filldir) pair.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65c2be22b601..643e5b6cbaf5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1506,6 +1506,9 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
  * to have different dirent layouts depending on the binary type.
  */
 typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
+struct dir_context {
+	filldir_t actor;
+};
 struct block_device_operations;
 
 /* These macros are for out of kernel modules to test that
@@ -2494,6 +2497,7 @@ loff_t inode_get_bytes(struct inode *inode);
 void inode_set_bytes(struct inode *inode, loff_t bytes);
 
 extern int vfs_readdir(struct file *, filldir_t, void *);
+extern int iterate_dir(struct file *, struct dir_context *);
 
 extern int vfs_stat(const char __user *, struct kstat *);
 extern int vfs_lstat(const char __user *, struct kstat *);

commit 7995bd287134f6c8f80d94bebe7396f05a9bc42b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 20 18:58:36 2013 +0400

    splice: don't pass the address of ->f_pos to methods
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 43db02e9c9fa..65c2be22b601 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2414,8 +2414,6 @@ extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
 		struct file *out, loff_t *, size_t len, unsigned int flags);
-extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
-		size_t len, unsigned int flags);
 
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);

commit d47992f86b307985b3215bcf141d56d1849d71df
Author: Lukas Czerner <lczerner@redhat.com>
Date:   Tue May 21 23:17:23 2013 -0400

    mm: change invalidatepage prototype to accept length
    
    Currently there is no way to truncate partial page where the end
    truncate point is not at the end of the page. This is because it was not
    needed and the functionality was enough for file system truncate
    operation to work properly. However more file systems now support punch
    hole feature and it can benefit from mm supporting truncating page just
    up to the certain point.
    
    Specifically, with this functionality truncate_inode_pages_range() can
    be changed so it supports truncating partial page at the end of the
    range (currently it will BUG_ON() if 'end' is not at the end of the
    page).
    
    This commit changes the invalidatepage() address space operation
    prototype to accept range to be invalidated and update all the instances
    for it.
    
    We also change the block_invalidatepage() in the same way and actually
    make a use of the new length argument implementing range invalidation.
    
    Actual file system implementations will follow except the file systems
    where the changes are really simple and should not change the behaviour
    in any way .Implementation for truncate_page_range() which will be able
    to accept page unaligned ranges will follow as well.
    
    Signed-off-by: Lukas Czerner <lczerner@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Hugh Dickins <hughd@google.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 43db02e9c9fa..9f696014988d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -364,7 +364,7 @@ struct address_space_operations {
 
 	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
 	sector_t (*bmap)(struct address_space *, sector_t);
-	void (*invalidatepage) (struct page *, unsigned long);
+	void (*invalidatepage) (struct page *, unsigned int, unsigned int);
 	int (*releasepage) (struct page *, gfp_t);
 	void (*freepage)(struct page *);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,

commit 4385bab128911df14ab25f0b5ae1a48d7b53dd94
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 5 22:11:03 2013 -0400

    make blkdev_put() return void
    
    same story as with the previous patches - note that return
    value of blkdev_close() is lost, since there's nowhere the
    caller (__fput()) could return it to.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b5a24ba83b6f..43db02e9c9fa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2091,7 +2091,7 @@ extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
 					       void *holder);
 extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
 					      void *holder);
-extern int blkdev_put(struct block_device *bdev, fmode_t mode);
+extern void blkdev_put(struct block_device *bdev, fmode_t mode);
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
 extern void bd_unlink_disk_holder(struct block_device *bdev,

commit 5ae98f1589e076e4b314fc54ae2beac58842ddc2
Author: Jan Kara <jack@suse.cz>
Date:   Sat May 4 00:11:23 2013 +0200

    fs: Fix hang with BSD accounting on frozen filesystem
    
    When BSD process accounting is enabled and logs information to a
    filesystem which gets frozen, system easily becomes unusable because
    each attempt to account process information blocks. Thus e.g. every task
    gets blocked in exit.
    
    It seems better to drop accounting information (which can already happen
    when filesystem is running out of space) instead of locking system up.
    So we just skip the write if the filesystem is frozen.
    
    Reported-by: Nikola Ciprich <nikola.ciprich@linuxbox.cz>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e8cd6b839675..b5a24ba83b6f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2227,6 +2227,13 @@ static inline void file_start_write(struct file *file)
 	__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);
 }
 
+static inline bool file_start_write_trylock(struct file *file)
+{
+	if (!S_ISREG(file_inode(file)->i_mode))
+		return true;
+	return __sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, false);
+}
+
 static inline void file_end_write(struct file *file)
 {
 	if (!S_ISREG(file_inode(file)->i_mode))

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit 74e3d1e17b2e11d175970b85acd44f5927000ba2
Author: Fan Du <fan.du@windriver.com>
Date:   Tue Apr 30 15:27:27 2013 -0700

    include/linux/fs.h: disable preempt when acquire i_size_seqcount write lock
    
    Two rt tasks bind to one CPU core.
    
    The higher priority rt task A preempts a lower priority rt task B which
    has already taken the write seq lock, and then the higher priority rt
    task A try to acquire read seq lock, it's doomed to lockup.
    
    rt task A with lower priority: call write
    i_size_write                                        rt task B with higher priority: call sync, and preempt task A
      write_seqcount_begin(&inode->i_size_seqcount);    i_size_read
      inode->i_size = i_size;                             read_seqcount_begin <-- lockup here...
    
    So disable preempt when acquiring every i_size_seqcount *write* lock will
    cure the problem.
    
    Signed-off-by: Fan Du <fan.du@windriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c28271ab9d4..17d8b1596215 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -675,9 +675,11 @@ static inline loff_t i_size_read(const struct inode *inode)
 static inline void i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	preempt_disable();
 	write_seqcount_begin(&inode->i_size_seqcount);
 	inode->i_size = i_size;
 	write_seqcount_end(&inode->i_size_seqcount);
+	preempt_enable();
 #elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
 	preempt_disable();
 	inode->i_size = i_size;

commit 599a0ac14e065b7c08471ef2e75a504b7dec9267
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 12 09:58:10 2013 -0400

    pipe: fold file_operations instances in one
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 578a66e6ee72..b1f28b02ede6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2080,7 +2080,6 @@ extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
 extern const struct file_operations bad_sock_fops;
-extern const struct file_operations def_fifo_fops;
 #ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
@@ -2152,10 +2151,6 @@ extern void init_special_inode(struct inode *, umode_t, dev_t);
 extern void make_bad_inode(struct inode *);
 extern int is_bad_inode(struct inode *);
 
-extern const struct file_operations read_pipefifo_fops;
-extern const struct file_operations write_pipefifo_fops;
-extern const struct file_operations rdwr_pipefifo_fops;
-
 #ifdef CONFIG_BLOCK
 /*
  * return READ, READA, or WRITE

commit 8d71db4f0890605d44815a2b2da4ca003f1bb142
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 19 21:01:03 2013 -0400

    lift sb_start_write/sb_end_write out of ->aio_write()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c28271ab9d4..578a66e6ee72 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2223,6 +2223,20 @@ static inline struct inode *file_inode(struct file *f)
 	return f->f_inode;
 }
 
+static inline void file_start_write(struct file *file)
+{
+	if (!S_ISREG(file_inode(file)->i_mode))
+		return;
+	__sb_start_write(file_inode(file)->i_sb, SB_FREEZE_WRITE, true);
+}
+
+static inline void file_end_write(struct file *file)
+{
+	if (!S_ISREG(file_inode(file)->i_mode))
+		return;
+	__sb_end_write(file_inode(file)->i_sb, SB_FREEZE_WRITE);
+}
+
 /*
  * get_write_access() gets write permission for a file.
  * put_write_access() releases this write permission.

commit 7f78e0351394052e1a6293e175825eb5c7869507
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Mar 2 19:39:14 2013 -0800

    fs: Limit sys_mount to only request filesystem modules.
    
    Modify the request_module to prefix the file system type with "fs-"
    and add aliases to all of the filesystems that can be built as modules
    to match.
    
    A common practice is to build all of the kernel code and leave code
    that is not commonly needed as modules, with the result that many
    users are exposed to any bug anywhere in the kernel.
    
    Looking for filesystems with a fs- prefix limits the pool of possible
    modules that can be loaded by mount to just filesystems trivially
    making things safer with no real cost.
    
    Using aliases means user space can control the policy of which
    filesystem modules are auto-loaded by editing /etc/modprobe.d/*.conf
    with blacklist and alias directives.  Allowing simple, safe,
    well understood work-arounds to known problematic software.
    
    This also addresses a rare but unfortunate problem where the filesystem
    name is not the same as it's module name and module auto-loading
    would not work.  While writing this patch I saw a handful of such
    cases.  The most significant being autofs that lives in the module
    autofs4.
    
    This is relevant to user namespaces because we can reach the request
    module in get_fs_type() without having any special permissions, and
    people get uncomfortable when a user specified string (in this case
    the filesystem type) goes all of the way to request_module.
    
    After having looked at this issue I don't think there is any
    particular reason to perform any filtering or permission checks beyond
    making it clear in the module request that we want a filesystem
    module.  The common pattern in the kernel is to call request_module()
    without regards to the users permissions.  In general all a filesystem
    module does once loaded is call register_filesystem() and go to sleep.
    Which means there is not much attack surface exposed by loading a
    filesytem module unless the filesystem is mounted.  In a user
    namespace filesystems are not mounted unless .fs_flags = FS_USERNS_MOUNT,
    which most filesystems do not set today.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reported-by: Kees Cook <keescook@google.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 74a907b8b950..2c28271ab9d4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1825,6 +1825,8 @@ struct file_system_type {
 	struct lock_class_key i_mutex_dir_key;
 };
 
+#define MODULE_ALIAS_FS(NAME) MODULE_ALIAS("fs-" NAME)
+
 extern struct dentry *mount_ns(struct file_system_type *fs_type, int flags,
 	void *data, int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,

commit dd37978c50bc8b354e5c4633f69387f16572fdac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 1 19:48:30 2013 -0500

    cache the value of file_inode() in struct file
    
    Note that this thing does *not* contribute to inode refcount;
    it's pinned down by dentry.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4e686a099465..74a907b8b950 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -769,6 +769,7 @@ struct file {
 	} f_u;
 	struct path		f_path;
 #define f_dentry	f_path.dentry
+	struct inode		*f_inode;	/* cached value */
 	const struct file_operations	*f_op;
 
 	/*
@@ -2217,7 +2218,7 @@ static inline bool execute_ok(struct inode *inode)
 
 static inline struct inode *file_inode(struct file *f)
 {
-	return f->f_path.dentry->d_inode;
+	return f->f_inode;
 }
 
 /*

commit d895cb1af15c04c522a25c79cc429076987c089b
Merge: 9626357371b5 d3d009cb965e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 20:16:07 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile (part one) from Al Viro:
     "Assorted stuff - cleaning namei.c up a bit, fixing ->d_name/->d_parent
      locking violations, etc.
    
      The most visible changes here are death of FS_REVAL_DOT (replaced with
      "has ->d_weak_revalidate()") and a new helper getting from struct file
      to inode.  Some bits of preparation to xattr method interface changes.
    
      Misc patches by various people sent this cycle *and* ocfs2 fixes from
      several cycles ago that should've been upstream right then.
    
      PS: the next vfs pile will be xattr stuff."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (46 commits)
      saner proc_get_inode() calling conventions
      proc: avoid extra pde_put() in proc_fill_super()
      fs: change return values from -EACCES to -EPERM
      fs/exec.c: make bprm_mm_init() static
      ocfs2/dlm: use GFP_ATOMIC inside a spin_lock
      ocfs2: fix possible use-after-free with AIO
      ocfs2: Fix oops in ocfs2_fast_symlink_readpage() code path
      get_empty_filp()/alloc_file() leave both ->f_pos and ->f_version zero
      target: writev() on single-element vector is pointless
      export kernel_write(), convert open-coded instances
      fs: encode_fh: return FILEID_INVALID if invalid fid_type
      kill f_vfsmnt
      vfs: kill FS_REVAL_DOT by adding a d_weak_revalidate dentry op
      nfsd: handle vfs_getattr errors in acl protocol
      switch vfs_getattr() to struct path
      default SET_PERSONALITY() in linux/elf.h
      ceph: prepopulate inodes only when request is aborted
      d_hash_and_lookup(): export, switch open-coded instances
      9p: switch v9fs_set_create_acl() to inode+fid, do it before d_instantiate()
      9p: split dropping the acls from v9fs_set_create_acl()
      ...

commit 7bb307e894d51308aa0582a8c4cc5875bbc645b9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Feb 23 14:51:48 2013 -0500

    export kernel_write(), convert open-coded instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c766afd1e684..d858363a7c17 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2277,6 +2277,7 @@ static inline void i_readcount_inc(struct inode *inode)
 extern int do_pipe_flags(int *, int);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
+extern ssize_t kernel_write(struct file *, const char *, size_t, loff_t);
 extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */

commit 182be684784334598eee1d90274e7f7aa0063616
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 24 02:21:54 2013 -0500

    kill f_vfsmnt
    
    very few users left...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index da94011ae83c..c766afd1e684 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -769,7 +769,6 @@ struct file {
 	} f_u;
 	struct path		f_path;
 #define f_dentry	f_path.dentry
-#define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
 
 	/*

commit ecf3d1f1aa74da0d632b651a2e05a911f60e92c0
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Feb 20 11:19:05 2013 -0500

    vfs: kill FS_REVAL_DOT by adding a d_weak_revalidate dentry op
    
    The following set of operations on a NFS client and server will cause
    
        server# mkdir a
        client# cd a
        server# mv a a.bak
        client# sleep 30  # (or whatever the dir attrcache timeout is)
        client# stat .
        stat: cannot stat `.': Stale NFS file handle
    
    Obviously, we should not be getting an ESTALE error back there since the
    inode still exists on the server. The problem is that the lookup code
    will call d_revalidate on the dentry that "." refers to, because NFS has
    FS_REVAL_DOT set.
    
    nfs_lookup_revalidate will see that the parent directory has changed and
    will try to reverify the dentry by redoing a LOOKUP. That of course
    fails, so the lookup code returns ESTALE.
    
    The problem here is that d_revalidate is really a bad fit for this case.
    What we really want to know at this point is whether the inode is still
    good or not, but we don't really care what name it goes by or whether
    the dcache is still valid.
    
    Add a new d_op->d_weak_revalidate operation and have complete_walk call
    that instead of d_revalidate. The intent there is to allow for a
    "weaker" d_revalidate that just checks to see whether the inode is still
    good. This is also gives us an opportunity to kill off the FS_REVAL_DOT
    special casing.
    
    [AV: changed method name, added note in porting, fixed confusion re
    having it possibly called from RCU mode (it won't be)]
    
    Cc: NeilBrown <neilb@suse.de>
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7f471520b88b..da94011ae83c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1807,7 +1807,6 @@ struct file_system_type {
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
-#define FS_REVAL_DOT		16384	/* Check the paths ".", ".." for staleness */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);

commit 3dadecce20603aa380023c65e6f55f108fd5e952
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jan 24 02:18:08 2013 -0500

    switch vfs_getattr() to struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3ab69777b4d8..7f471520b88b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2468,7 +2468,7 @@ extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
-extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+extern int vfs_getattr(struct path *, struct kstat *);
 void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7617ee04f066..3ab69777b4d8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2217,6 +2217,11 @@ static inline bool execute_ok(struct inode *inode)
 	return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
 }
 
+static inline struct inode *file_inode(struct file *f)
+{
+	return f->f_path.dentry->d_inode;
+}
+
 /*
  * get_write_access() gets write permission for a file.
  * put_write_access() releases this write permission.
@@ -2239,7 +2244,7 @@ static inline int get_write_access(struct inode *inode)
 }
 static inline int deny_write_access(struct file *file)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
+	struct inode *inode = file_inode(file);
 	return atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -ETXTBSY;
 }
 static inline void put_write_access(struct inode * inode)
@@ -2249,7 +2254,7 @@ static inline void put_write_access(struct inode * inode)
 static inline void allow_write_access(struct file *file)
 {
 	if (file)
-		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
+		atomic_inc(&file_inode(file)->i_writecount);
 }
 #ifdef CONFIG_IMA
 static inline void i_readcount_dec(struct inode *inode)

commit d28574e043e8b7cb35482de6e9a553118a32803d
Author: Maxim Patlasov <mpatlasov@parallels.com>
Date:   Fri Oct 26 19:50:04 2012 +0400

    mm: minor cleanup of iov_iter_single_seg_count()
    
    The function does not modify iov_iter which 'i' points to.
    
    Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7617ee04f066..7d2e893ec3d1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -301,7 +301,7 @@ size_t iov_iter_copy_from_user(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
 int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
-size_t iov_iter_single_seg_count(struct iov_iter *i);
+size_t iov_iter_single_seg_count(const struct iov_iter *i);
 
 static inline void iov_iter_init(struct iov_iter *i,
 			const struct iovec *iov, unsigned long nr_segs,

commit 21e89c0c48bb799beb09181740796fc80c9676e2
Merge: b911a6bdeef5 91c7fbbf63f3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 20 18:49:14 2012 -0500

    Merge branch 'fscache' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-fs into for-linus

commit 471667391a92bf7bf2cd4ff31a3ad88e5dec934b
Author: Alessio Igor Bogani <abogani@kernel.org>
Date:   Thu Dec 13 12:22:39 2012 +0100

    vfs: Remove useless function prototypes
    
    Commit 8e22cc88d68ca1a46d7d582938f979eb640ed30f removes the (un)lock_super
    function definitions but forgets to remove their prototypes.
    
    Signed-off-by: Alessio Igor Bogani <abogani@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a0c5ba57ffc5..05cd238ad941 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1445,10 +1445,6 @@ static inline void sb_start_intwrite(struct super_block *sb)
 
 extern bool inode_owner_or_capable(const struct inode *inode);
 
-/* not quite ready to be deprecated, but... */
-extern void lock_super(struct super_block *);
-extern void unlock_super(struct super_block *);
-
 /*
  * VFS helper functions..
  */

commit d30357f2f0ec0bfb67fd39f8f76d22d02d78631e
Author: Marco Stornelli <marco.stornelli@gmail.com>
Date:   Sat Dec 15 11:59:20 2012 +0100

    vfs: drop vmtruncate
    
    Removed vmtruncate
    
    Signed-off-by: Marco Stornelli <marco.stornelli@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a823d4be38e7..a0c5ba57ffc5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1565,7 +1565,6 @@ struct inode_operations {
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
-	void (*truncate) (struct inode *);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);

commit a02de9608595c8ef649ef03ae735b0b45e3d4396
Author: David Howells <dhowells@redhat.com>
Date:   Thu Dec 20 21:52:36 2012 +0000

    VFS: Make more complete truncate operation available to CacheFiles
    
    Make a more complete truncate operation available to CacheFiles (including
    security checks and suchlike) so that it can use this to clear invalidated
    cache files.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a823d4be38e7..017a15b707e2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1999,6 +1999,7 @@ struct filename {
 	bool			separate; /* should "name" be freed? */
 };
 
+extern long vfs_truncate(struct path *, loff_t);
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
 extern int do_fallocate(struct file *file, int mode, loff_t offset,

commit 848b81415c42ff3dc9a4204749087b015c37ef66
Merge: 992956189de5 6fd59a83b926
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 17 20:58:12 2012 -0800

    Merge branch 'akpm' (Andrew's patch-bomb)
    
    Merge misc patches from Andrew Morton:
     "Incoming:
    
       - lots of misc stuff
    
       - backlight tree updates
    
       - lib/ updates
    
       - Oleg's percpu-rwsem changes
    
       - checkpatch
    
       - rtc
    
       - aoe
    
       - more checkpoint/restart support
    
      I still have a pile of MM stuff pending - Pekka should be merging
      later today after which that is good to go.  A number of other things
      are twiddling thumbs awaiting maintainer merges."
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (180 commits)
      scatterlist: don't BUG when we can trivially return a proper error.
      docs: update documentation about /proc/<pid>/fdinfo/<fd> fanotify output
      fs, fanotify: add @mflags field to fanotify output
      docs: add documentation about /proc/<pid>/fdinfo/<fd> output
      fs, notify: add procfs fdinfo helper
      fs, exportfs: add exportfs_encode_inode_fh() helper
      fs, exportfs: escape nil dereference if no s_export_op present
      fs, epoll: add procfs fdinfo helper
      fs, eventfd: add procfs fdinfo helper
      procfs: add ability to plug in auxiliary fdinfo providers
      tools/testing/selftests/kcmp/kcmp_test.c: print reason for failure in kcmp_test
      breakpoint selftests: print failure status instead of cause make error
      kcmp selftests: print fail status instead of cause make error
      kcmp selftests: make run_tests fix
      mem-hotplug selftests: print failure status instead of cause make error
      cpu-hotplug selftests: print failure status instead of cause make error
      mqueue selftests: print failure status instead of cause make error
      vm selftests: print failure status instead of cause make error
      ubifs: use prandom_bytes
      mtd: nandsim: use prandom_bytes
      ...

commit 55985dd72ab27b47530dcc8bdddd28b69f4abe8b
Author: Cyrill Gorcunov <gorcunov@openvz.org>
Date:   Mon Dec 17 16:04:55 2012 -0800

    procfs: add ability to plug in auxiliary fdinfo providers
    
    This patch brings ability to print out auxiliary data associated with
    file in procfs interface /proc/pid/fdinfo/fd.
    
    In particular further patches make eventfd, evenpoll, signalfd and
    fsnotify to print additional information complete enough to restore
    these objects after checkpoint.
    
    To simplify the code we add show_fdinfo callback inside struct
    file_operations (as Al and Pavel are proposing).
    
    Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Acked-by: Pavel Emelyanov <xemul@parallels.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Andrey Vagin <avagin@openvz.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: James Bottomley <jbottomley@parallels.com>
    Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.vnet.ibm.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Matthew Helsley <matt.helsley@gmail.com>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.vnet.ibm.com>
    Cc: Tvrtko Ursulin <tvrtko.ursulin@onelan.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 029552ff774c..5abf703d06ba 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -44,6 +44,7 @@ struct vm_area_struct;
 struct vfsmount;
 struct cred;
 struct swap_info_struct;
+struct seq_file;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -1543,6 +1544,7 @@ struct file_operations {
 	int (*setlease)(struct file *, long, struct file_lock **);
 	long (*fallocate)(struct file *file, int mode, loff_t offset,
 			  loff_t len);
+	int (*show_fdinfo)(struct seq_file *m, struct file *f);
 };
 
 struct inode_operations {
@@ -1578,8 +1580,6 @@ struct inode_operations {
 			   umode_t create_mode, int *opened);
 } ____cacheline_aligned;
 
-struct seq_file;
-
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,

commit 965c8e59cfcf845ecde2265a1d1bfee5f011d302
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Dec 17 15:59:39 2012 -0800

    lseek: the "whence" argument is called "whence"
    
    But the kernel decided to call it "origin" instead.  Fix most of the
    sites.
    
    Acked-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 408fb1e77a0a..029552ff774c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2286,9 +2286,9 @@ extern ino_t find_inode_number(struct dentry *, struct qstr *);
 #include <linux/err.h>
 
 /* needed for stackable file system support */
-extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t default_llseek(struct file *file, loff_t offset, int whence);
 
-extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t vfs_llseek(struct file *file, loff_t offset, int whence);
 
 extern int inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
@@ -2396,11 +2396,11 @@ extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
 
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
-extern loff_t noop_llseek(struct file *file, loff_t offset, int origin);
-extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
-extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t noop_llseek(struct file *file, loff_t offset, int whence);
+extern loff_t no_llseek(struct file *file, loff_t offset, int whence);
+extern loff_t generic_file_llseek(struct file *file, loff_t offset, int whence);
 extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
-		int origin, loff_t maxsize, loff_t eof);
+		int whence, loff_t maxsize, loff_t eof);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit 6a2b60b17b3e48a418695a94bd2420f6ab32e519
Merge: 9228ff90387e 98f842e675f9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 17 15:44:47 2012 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace changes from Eric Biederman:
     "While small this set of changes is very significant with respect to
      containers in general and user namespaces in particular.  The user
      space interface is now complete.
    
      This set of changes adds support for unprivileged users to create user
      namespaces and as a user namespace root to create other namespaces.
      The tyranny of supporting suid root preventing unprivileged users from
      using cool new kernel features is broken.
    
      This set of changes completes the work on setns, adding support for
      the pid, user, mount namespaces.
    
      This set of changes includes a bunch of basic pid namespace
      cleanups/simplifications.  Of particular significance is the rework of
      the pid namespace cleanup so it no longer requires sending out
      tendrils into all kinds of unexpected cleanup paths for operation.  At
      least one case of broken error handling is fixed by this cleanup.
    
      The files under /proc/<pid>/ns/ have been converted from regular files
      to magic symlinks which prevents incorrect caching by the VFS,
      ensuring the files always refer to the namespace the process is
      currently using and ensuring that the ptrace_mayaccess permission
      checks are always applied.
    
      The files under /proc/<pid>/ns/ have been given stable inode numbers
      so it is now possible to see if different processes share the same
      namespaces.
    
      Through the David Miller's net tree are changes to relax many of the
      permission checks in the networking stack to allowing the user
      namespace root to usefully use the networking stack.  Similar changes
      for the mount namespace and the pid namespace are coming through my
      tree.
    
      Two small changes to add user namespace support were commited here adn
      in David Miller's -net tree so that I could complete the work on the
      /proc/<pid>/ns/ files in this tree.
    
      Work remains to make it safe to build user namespaces and 9p, afs,
      ceph, cifs, coda, gfs2, ncpfs, nfs, nfsd, ocfs2, and xfs so the
      Kconfig guard remains in place preventing that user namespaces from
      being built when any of those filesystems are enabled.
    
      Future design work remains to allow root users outside of the initial
      user namespace to mount more than just /proc and /sys."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (38 commits)
      proc: Usable inode numbers for the namespace file descriptors.
      proc: Fix the namespace inode permission checks.
      proc: Generalize proc inode allocation
      userns: Allow unprivilged mounts of proc and sysfs
      userns: For /proc/self/{uid,gid}_map derive the lower userns from the struct file
      procfs: Print task uids and gids in the userns that opened the proc file
      userns: Implement unshare of the user namespace
      userns: Implent proc namespace operations
      userns: Kill task_user_ns
      userns: Make create_new_namespaces take a user_ns parameter
      userns: Allow unprivileged use of setns.
      userns: Allow unprivileged users to create new namespaces
      userns: Allow setting a userns mapping to your current uid.
      userns: Allow chown and setgid preservation
      userns: Allow unprivileged users to create user namespaces.
      userns: Ignore suid and sgid on binaries if the uid or gid can not be mapped
      userns: fix return value on mntns_install() failure
      vfs: Allow unprivileged manipulation of the mount namespace.
      vfs: Only support slave subtrees across different user namespaces
      vfs: Add a user namespace reference from struct mnt_namespace
      ...

commit 252aa6f5be64c90c67b9f066ccff880f6b487d32
Author: Rafael Aquini <aquini@redhat.com>
Date:   Tue Dec 11 16:02:35 2012 -0800

    mm: redefine address_space.assoc_mapping
    
    Overhaul struct address_space.assoc_mapping renaming it to
    address_space.private_data and its type is redefined to void*.  By this
    approach we consistently name the .private_* elements from struct
    address_space as well as allow extended usage for address_space
    association with other data structures through ->private_data.
    
    Also, all users of old ->assoc_mapping element are converted to reflect
    its new name and type change (->private_data).
    
    Signed-off-by: Rafael Aquini <aquini@redhat.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: "Michael S. Tsirkin" <mst@redhat.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Minchan Kim <minchan@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 75fe9a134803..408fb1e77a0a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -418,7 +418,7 @@ struct address_space {
 	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
 	spinlock_t		private_lock;	/* for use by the address_space */
 	struct list_head	private_list;	/* ditto */
-	struct address_space	*assoc_mapping;	/* ditto */
+	void			*private_data;	/* ditto */
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but

commit bbec0270bdd887f96377065ee38b8848b5afa395
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 29 12:31:52 2012 -0800

    blkdev_max_block: make private to fs/buffer.c
    
    We really don't want to look at the block size for the raw block device
    accesses in fs/block-dev.c, because it may be changing from under us.
    So get rid of the max_block logic entirely, since the caller should
    already have done it anyway.
    
    That leaves the only user of this function in fs/buffer.c, so move the
    whole function there and make it static.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 44f288e9726d..75fe9a134803 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2047,7 +2047,6 @@ extern void unregister_blkdev(unsigned int, const char *);
 extern struct block_device *bdget(dev_t);
 extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);
-extern sector_t blkdev_max_block(struct block_device *bdev);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern void invalidate_bdev(struct block_device *);

commit 1e8b33328a5407b447ff80953655a47014a6dcb9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 29 10:49:50 2012 -0800

    blockdev: remove bd_block_size_semaphore again
    
    This reverts the block-device direct access code to the previous
    unlocked code, now that fs/buffer.c no longer needs external locking.
    
    With this, fs/block_dev.c is back to the original version, apart from a
    whitespace cleanup that I didn't want to revert.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b33cfc97b9ca..44f288e9726d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -462,8 +462,6 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
-	/* A semaphore that prevents I/O while block size is being changed */
-	struct percpu_rw_semaphore	bd_block_size_semaphore;
 };
 
 /*
@@ -2379,8 +2377,6 @@ extern int generic_segment_checks(const struct iovec *iov,
 		unsigned long *nr_segs, size_t *count, int access_flags);
 
 /* fs/block_dev.c */
-extern ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
-			       unsigned long nr_segs, loff_t pos);
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
 extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,

commit 0c55cfc4166d9a0f38de779bd4d75a90afbe7734
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Jul 26 21:42:03 2012 -0700

    vfs: Allow unprivileged manipulation of the mount namespace.
    
    - Add a filesystem flag to mark filesystems that are safe to mount as
      an unprivileged user.
    
    - Add a filesystem flag to mark filesystems that don't need MNT_NODEV
      when mounted by an unprivileged user.
    
    - Relax the permission checks to allow unprivileged users that have
      CAP_SYS_ADMIN permissions in the user namespace referred to by the
      current mount namespace to be allowed to mount, unmount, and move
      filesystems.
    
    Acked-by: "Serge E. Hallyn" <serge@hallyn.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b33cfc97b9ca..5037aa6817fd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1812,6 +1812,8 @@ struct file_system_type {
 #define FS_REQUIRES_DEV		1 
 #define FS_BINARY_MOUNTDATA	2
 #define FS_HAS_SUBTYPE		4
+#define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
+#define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
 #define FS_REVAL_DOT		16384	/* Check the paths ".", ".." for staleness */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,

commit c54d0dc35324300cdc502137f5c0ee44f53d7a8b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Oct 16 13:37:17 2012 -0400

    bury SEL_{IN,OUT,EX}
    
            Had not been used for more than a decade and half; it used
    to be a part of (in-kernel) ->select() API and it has been pining
    for fjords since 2.1.23pre1.  This is an ex-parrot...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8b53931b5a74..b33cfc97b9ca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -131,10 +131,6 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  */
 #define CHECK_IOVEC_ONLY -1
 
-#define SEL_IN		1
-#define SEL_OUT		2
-#define SEL_EX		4
-
 /*
  * The below are the various read and write types that we support. Some of
  * them include behavioral modifiers that send information down to the

commit bbc1096ad8e9875a025bbcf012605da49129e8b8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 15 16:40:35 2012 +0100

    Unexport some bits of linux/fs.h
    
    There are some bits of linux/fs.h which are only used within the kernel and
    shouldn't be in the UAPI.  Move these from uapi/linux/fs.h into linux/fs.h.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 001c7cff2d48..8b53931b5a74 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -64,6 +64,77 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private, int ret,
 			bool is_async);
 
+#define MAY_EXEC		0x00000001
+#define MAY_WRITE		0x00000002
+#define MAY_READ		0x00000004
+#define MAY_APPEND		0x00000008
+#define MAY_ACCESS		0x00000010
+#define MAY_OPEN		0x00000020
+#define MAY_CHDIR		0x00000040
+/* called from RCU mode, don't block */
+#define MAY_NOT_BLOCK		0x00000080
+
+/*
+ * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
+ * to O_WRONLY and O_RDWR via the strange trick in __dentry_open()
+ */
+
+/* file is open for reading */
+#define FMODE_READ		((__force fmode_t)0x1)
+/* file is open for writing */
+#define FMODE_WRITE		((__force fmode_t)0x2)
+/* file is seekable */
+#define FMODE_LSEEK		((__force fmode_t)0x4)
+/* file can be accessed using pread */
+#define FMODE_PREAD		((__force fmode_t)0x8)
+/* file can be accessed using pwrite */
+#define FMODE_PWRITE		((__force fmode_t)0x10)
+/* File is opened for execution with sys_execve / sys_uselib */
+#define FMODE_EXEC		((__force fmode_t)0x20)
+/* File is opened with O_NDELAY (only set for block devices) */
+#define FMODE_NDELAY		((__force fmode_t)0x40)
+/* File is opened with O_EXCL (only set for block devices) */
+#define FMODE_EXCL		((__force fmode_t)0x80)
+/* File is opened using open(.., 3, ..) and is writeable only for ioctls
+   (specialy hack for floppy.c) */
+#define FMODE_WRITE_IOCTL	((__force fmode_t)0x100)
+/* 32bit hashes as llseek() offset (for directories) */
+#define FMODE_32BITHASH         ((__force fmode_t)0x200)
+/* 64bit hashes as llseek() offset (for directories) */
+#define FMODE_64BITHASH         ((__force fmode_t)0x400)
+
+/*
+ * Don't update ctime and mtime.
+ *
+ * Currently a special hack for the XFS open_by_handle ioctl, but we'll
+ * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
+ */
+#define FMODE_NOCMTIME		((__force fmode_t)0x800)
+
+/* Expect random access pattern */
+#define FMODE_RANDOM		((__force fmode_t)0x1000)
+
+/* File is huge (eg. /dev/kmem): treat loff_t as unsigned */
+#define FMODE_UNSIGNED_OFFSET	((__force fmode_t)0x2000)
+
+/* File is opened with O_PATH; almost nothing can be done with it */
+#define FMODE_PATH		((__force fmode_t)0x4000)
+
+/* File was opened by fanotify and shouldn't generate fanotify events */
+#define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
+
+/*
+ * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
+ * that indicates that they should check the contents of the iovec are
+ * valid, but not check the memory that the iovec elements
+ * points too.
+ */
+#define CHECK_IOVEC_ONLY -1
+
+#define SEL_IN		1
+#define SEL_OUT		2
+#define SEL_EX		4
+
 /*
  * The below are the various read and write types that we support. Some of
  * them include behavioral modifiers that send information down to the
@@ -1556,6 +1627,60 @@ struct super_operations {
 	void (*free_cached_objects)(struct super_block *, int);
 };
 
+/*
+ * Inode flags - they have no relation to superblock flags now
+ */
+#define S_SYNC		1	/* Writes are synced at once */
+#define S_NOATIME	2	/* Do not update access times */
+#define S_APPEND	4	/* Append-only file */
+#define S_IMMUTABLE	8	/* Immutable file */
+#define S_DEAD		16	/* removed, but still open directory */
+#define S_NOQUOTA	32	/* Inode is not counted to quota */
+#define S_DIRSYNC	64	/* Directory modifications are synchronous */
+#define S_NOCMTIME	128	/* Do not update file c/mtime */
+#define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
+#define S_PRIVATE	512	/* Inode is fs-internal */
+#define S_IMA		1024	/* Inode has an associated IMA struct */
+#define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
+#define S_NOSEC		4096	/* no suid or xattr security attributes */
+
+/*
+ * Note that nosuid etc flags are inode-specific: setting some file-system
+ * flags just means all the inodes inherit those flags by default. It might be
+ * possible to override it selectively if you really wanted to with some
+ * ioctl() that is not currently implemented.
+ *
+ * Exception: MS_RDONLY is always applied to the entire file system.
+ *
+ * Unfortunately, it is possible to change a filesystems flags with it mounted
+ * with files in use.  This means that all of the inodes will not have their
+ * i_flags updated.  Hence, i_flags no longer inherit the superblock mount
+ * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org
+ */
+#define __IS_FLG(inode, flg)	((inode)->i_sb->s_flags & (flg))
+
+#define IS_RDONLY(inode)	((inode)->i_sb->s_flags & MS_RDONLY)
+#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
+					((inode)->i_flags & S_SYNC))
+#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
+					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
+#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
+#define IS_NOATIME(inode)	__IS_FLG(inode, MS_RDONLY|MS_NOATIME)
+#define IS_I_VERSION(inode)	__IS_FLG(inode, MS_I_VERSION)
+
+#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
+#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
+#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
+#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+
+#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
+#define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
+#define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
+#define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
+#define IS_IMA(inode)		((inode)->i_flags & S_IMA)
+#define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
+#define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
+
 /*
  * Inode state bits.  Protected by inode->i_lock
  *
@@ -1688,6 +1813,11 @@ int sync_inode_metadata(struct inode *inode, int wait);
 struct file_system_type {
 	const char *name;
 	int fs_flags;
+#define FS_REQUIRES_DEV		1 
+#define FS_BINARY_MOUNTDATA	2
+#define FS_HAS_SUBTYPE		4
+#define FS_REVAL_DOT		16384	/* Check the paths ".", ".." for staleness */
+#define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
 	void (*kill_sb) (struct super_block *);

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8cb86cfc9719..001c7cff2d48 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1,337 +1,6 @@
 #ifndef _LINUX_FS_H
 #define _LINUX_FS_H
 
-/*
- * This file has definitions for some important file table
- * structures etc.
- */
-
-#include <linux/limits.h>
-#include <linux/ioctl.h>
-#include <linux/types.h>
-
-/*
- * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
- * the file limit at runtime and only root can increase the per-process
- * nr_file rlimit, so it's safe to set up a ridiculously high absolute
- * upper limit on files-per-process.
- *
- * Some programs (notably those using select()) may have to be 
- * recompiled to take full advantage of the new limits..  
- */
-
-/* Fixed constants first: */
-#undef NR_OPEN
-#define INR_OPEN_CUR 1024	/* Initial setting for nfile rlimits */
-#define INR_OPEN_MAX 4096	/* Hard limit for nfile rlimits */
-
-#define BLOCK_SIZE_BITS 10
-#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
-
-#define SEEK_SET	0	/* seek relative to beginning of file */
-#define SEEK_CUR	1	/* seek relative to current file position */
-#define SEEK_END	2	/* seek relative to end of file */
-#define SEEK_DATA	3	/* seek to the next data */
-#define SEEK_HOLE	4	/* seek to the next hole */
-#define SEEK_MAX	SEEK_HOLE
-
-struct fstrim_range {
-	__u64 start;
-	__u64 len;
-	__u64 minlen;
-};
-
-/* And dynamically-tunable limits and defaults: */
-struct files_stat_struct {
-	unsigned long nr_files;		/* read only */
-	unsigned long nr_free_files;	/* read only */
-	unsigned long max_files;		/* tunable */
-};
-
-struct inodes_stat_t {
-	int nr_inodes;
-	int nr_unused;
-	int dummy[5];		/* padding for sysctl ABI compatibility */
-};
-
-
-#define NR_FILE  8192	/* this can well be larger on a larger system */
-
-#define MAY_EXEC		0x00000001
-#define MAY_WRITE		0x00000002
-#define MAY_READ		0x00000004
-#define MAY_APPEND		0x00000008
-#define MAY_ACCESS		0x00000010
-#define MAY_OPEN		0x00000020
-#define MAY_CHDIR		0x00000040
-/* called from RCU mode, don't block */
-#define MAY_NOT_BLOCK		0x00000080
-
-/*
- * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
- * to O_WRONLY and O_RDWR via the strange trick in __dentry_open()
- */
-
-/* file is open for reading */
-#define FMODE_READ		((__force fmode_t)0x1)
-/* file is open for writing */
-#define FMODE_WRITE		((__force fmode_t)0x2)
-/* file is seekable */
-#define FMODE_LSEEK		((__force fmode_t)0x4)
-/* file can be accessed using pread */
-#define FMODE_PREAD		((__force fmode_t)0x8)
-/* file can be accessed using pwrite */
-#define FMODE_PWRITE		((__force fmode_t)0x10)
-/* File is opened for execution with sys_execve / sys_uselib */
-#define FMODE_EXEC		((__force fmode_t)0x20)
-/* File is opened with O_NDELAY (only set for block devices) */
-#define FMODE_NDELAY		((__force fmode_t)0x40)
-/* File is opened with O_EXCL (only set for block devices) */
-#define FMODE_EXCL		((__force fmode_t)0x80)
-/* File is opened using open(.., 3, ..) and is writeable only for ioctls
-   (specialy hack for floppy.c) */
-#define FMODE_WRITE_IOCTL	((__force fmode_t)0x100)
-/* 32bit hashes as llseek() offset (for directories) */
-#define FMODE_32BITHASH         ((__force fmode_t)0x200)
-/* 64bit hashes as llseek() offset (for directories) */
-#define FMODE_64BITHASH         ((__force fmode_t)0x400)
-
-/*
- * Don't update ctime and mtime.
- *
- * Currently a special hack for the XFS open_by_handle ioctl, but we'll
- * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
- */
-#define FMODE_NOCMTIME		((__force fmode_t)0x800)
-
-/* Expect random access pattern */
-#define FMODE_RANDOM		((__force fmode_t)0x1000)
-
-/* File is huge (eg. /dev/kmem): treat loff_t as unsigned */
-#define FMODE_UNSIGNED_OFFSET	((__force fmode_t)0x2000)
-
-/* File is opened with O_PATH; almost nothing can be done with it */
-#define FMODE_PATH		((__force fmode_t)0x4000)
-
-/* File was opened by fanotify and shouldn't generate fanotify events */
-#define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
-
-/*
- * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
- * that indicates that they should check the contents of the iovec are
- * valid, but not check the memory that the iovec elements
- * points too.
- */
-#define CHECK_IOVEC_ONLY -1
-
-#define SEL_IN		1
-#define SEL_OUT		2
-#define SEL_EX		4
-
-/* public flags for file_system_type */
-#define FS_REQUIRES_DEV 1 
-#define FS_BINARY_MOUNTDATA 2
-#define FS_HAS_SUBTYPE 4
-#define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
-#define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move()
-					 * during rename() internally.
-					 */
-
-/*
- * These are the fs-independent mount-flags: up to 32 flags are supported
- */
-#define MS_RDONLY	 1	/* Mount read-only */
-#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
-#define MS_NODEV	 4	/* Disallow access to device special files */
-#define MS_NOEXEC	 8	/* Disallow program execution */
-#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
-#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
-#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
-#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
-#define MS_NOATIME	1024	/* Do not update access times. */
-#define MS_NODIRATIME	2048	/* Do not update directory access times */
-#define MS_BIND		4096
-#define MS_MOVE		8192
-#define MS_REC		16384
-#define MS_VERBOSE	32768	/* War is peace. Verbosity is silence.
-				   MS_VERBOSE is deprecated. */
-#define MS_SILENT	32768
-#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
-#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
-#define MS_PRIVATE	(1<<18)	/* change to private */
-#define MS_SLAVE	(1<<19)	/* change to slave */
-#define MS_SHARED	(1<<20)	/* change to shared */
-#define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
-#define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
-#define MS_I_VERSION	(1<<23) /* Update inode I_version field */
-#define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
-#define MS_NOSEC	(1<<28)
-#define MS_BORN		(1<<29)
-#define MS_ACTIVE	(1<<30)
-#define MS_NOUSER	(1<<31)
-
-/*
- * Superblock flags that can be altered by MS_REMOUNT
- */
-#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)
-
-/*
- * Old magic mount flag and mask
- */
-#define MS_MGC_VAL 0xC0ED0000
-#define MS_MGC_MSK 0xffff0000
-
-/* Inode flags - they have nothing to superblock flags now */
-
-#define S_SYNC		1	/* Writes are synced at once */
-#define S_NOATIME	2	/* Do not update access times */
-#define S_APPEND	4	/* Append-only file */
-#define S_IMMUTABLE	8	/* Immutable file */
-#define S_DEAD		16	/* removed, but still open directory */
-#define S_NOQUOTA	32	/* Inode is not counted to quota */
-#define S_DIRSYNC	64	/* Directory modifications are synchronous */
-#define S_NOCMTIME	128	/* Do not update file c/mtime */
-#define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
-#define S_PRIVATE	512	/* Inode is fs-internal */
-#define S_IMA		1024	/* Inode has an associated IMA struct */
-#define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
-#define S_NOSEC		4096	/* no suid or xattr security attributes */
-
-/*
- * Note that nosuid etc flags are inode-specific: setting some file-system
- * flags just means all the inodes inherit those flags by default. It might be
- * possible to override it selectively if you really wanted to with some
- * ioctl() that is not currently implemented.
- *
- * Exception: MS_RDONLY is always applied to the entire file system.
- *
- * Unfortunately, it is possible to change a filesystems flags with it mounted
- * with files in use.  This means that all of the inodes will not have their
- * i_flags updated.  Hence, i_flags no longer inherit the superblock mount
- * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org
- */
-#define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))
-
-#define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
-#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
-					((inode)->i_flags & S_SYNC))
-#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
-					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
-#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
-#define IS_NOATIME(inode)   __IS_FLG(inode, MS_RDONLY|MS_NOATIME)
-#define IS_I_VERSION(inode)   __IS_FLG(inode, MS_I_VERSION)
-
-#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
-#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
-#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
-#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
-
-#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
-#define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
-#define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
-#define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
-#define IS_IMA(inode)		((inode)->i_flags & S_IMA)
-#define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
-#define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
-
-/* the read-only stuff doesn't really belong here, but any other place is
-   probably as bad and I don't want to create yet another include file. */
-
-#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
-#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
-#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
-#define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
-#define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
-#define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
-#define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
-#define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
-#define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
-#define BLKSECTSET _IO(0x12,102)/* set max sectors per request (ll_rw_blk.c) */
-#define BLKSECTGET _IO(0x12,103)/* get max sectors per request (ll_rw_blk.c) */
-#define BLKSSZGET  _IO(0x12,104)/* get block device sector size */
-#if 0
-#define BLKPG      _IO(0x12,105)/* See blkpg.h */
-
-/* Some people are morons.  Do not use sizeof! */
-
-#define BLKELVGET  _IOR(0x12,106,size_t)/* elevator get */
-#define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */
-/* This was here just to show that the number is taken -
-   probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */
-#endif
-/* A jump here: 108-111 have been used for various private purposes. */
-#define BLKBSZGET  _IOR(0x12,112,size_t)
-#define BLKBSZSET  _IOW(0x12,113,size_t)
-#define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
-#define BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)
-#define BLKTRACESTART _IO(0x12,116)
-#define BLKTRACESTOP _IO(0x12,117)
-#define BLKTRACETEARDOWN _IO(0x12,118)
-#define BLKDISCARD _IO(0x12,119)
-#define BLKIOMIN _IO(0x12,120)
-#define BLKIOOPT _IO(0x12,121)
-#define BLKALIGNOFF _IO(0x12,122)
-#define BLKPBSZGET _IO(0x12,123)
-#define BLKDISCARDZEROES _IO(0x12,124)
-#define BLKSECDISCARD _IO(0x12,125)
-#define BLKROTATIONAL _IO(0x12,126)
-#define BLKZEROOUT _IO(0x12,127)
-
-#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
-#define FIBMAP	   _IO(0x00,1)	/* bmap access */
-#define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
-#define FIFREEZE	_IOWR('X', 119, int)	/* Freeze */
-#define FITHAW		_IOWR('X', 120, int)	/* Thaw */
-#define FITRIM		_IOWR('X', 121, struct fstrim_range)	/* Trim */
-
-#define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
-#define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
-#define	FS_IOC_GETVERSION		_IOR('v', 1, long)
-#define	FS_IOC_SETVERSION		_IOW('v', 2, long)
-#define FS_IOC_FIEMAP			_IOWR('f', 11, struct fiemap)
-#define FS_IOC32_GETFLAGS		_IOR('f', 1, int)
-#define FS_IOC32_SETFLAGS		_IOW('f', 2, int)
-#define FS_IOC32_GETVERSION		_IOR('v', 1, int)
-#define FS_IOC32_SETVERSION		_IOW('v', 2, int)
-
-/*
- * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)
- */
-#define	FS_SECRM_FL			0x00000001 /* Secure deletion */
-#define	FS_UNRM_FL			0x00000002 /* Undelete */
-#define	FS_COMPR_FL			0x00000004 /* Compress file */
-#define FS_SYNC_FL			0x00000008 /* Synchronous updates */
-#define FS_IMMUTABLE_FL			0x00000010 /* Immutable file */
-#define FS_APPEND_FL			0x00000020 /* writes to file may only append */
-#define FS_NODUMP_FL			0x00000040 /* do not dump file */
-#define FS_NOATIME_FL			0x00000080 /* do not update atime */
-/* Reserved for compression usage... */
-#define FS_DIRTY_FL			0x00000100
-#define FS_COMPRBLK_FL			0x00000200 /* One or more compressed clusters */
-#define FS_NOCOMP_FL			0x00000400 /* Don't compress */
-#define FS_ECOMPR_FL			0x00000800 /* Compression error */
-/* End compression flags --- maybe not all used */
-#define FS_BTREE_FL			0x00001000 /* btree format dir */
-#define FS_INDEX_FL			0x00001000 /* hash-indexed directory */
-#define FS_IMAGIC_FL			0x00002000 /* AFS directory */
-#define FS_JOURNAL_DATA_FL		0x00004000 /* Reserved for ext3 */
-#define FS_NOTAIL_FL			0x00008000 /* file tail should not be merged */
-#define FS_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
-#define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
-#define FS_EXTENT_FL			0x00080000 /* Extents */
-#define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
-#define FS_NOCOW_FL			0x00800000 /* Do not cow file */
-#define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
-
-#define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
-#define FS_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
-
-
-#define SYNC_FILE_RANGE_WAIT_BEFORE	1
-#define SYNC_FILE_RANGE_WRITE		2
-#define SYNC_FILE_RANGE_WAIT_AFTER	4
-
-#ifdef __KERNEL__
 
 #include <linux/linkage.h>
 #include <linux/wait.h>
@@ -360,6 +29,7 @@ struct inodes_stat_t {
 #include <linux/blk_types.h>
 
 #include <asm/byteorder.h>
+#include <uapi/linux/fs.h>
 
 struct export_operations;
 struct hd_geometry;
@@ -2876,5 +2546,4 @@ static inline void inode_has_no_xattr(struct inode *inode)
 		inode->i_flags |= S_NOSEC;
 }
 
-#endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit 08cce05c5a91f5017f4edc9866cf026908c73f9f
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:45:06 2012 +0100

    UAPI: Unexport linux/blk_types.h
    
    It seems that was linux/blk_types.h incorrectly exported to fix up some missing
    bits required by the exported parts of linux/fs.h (READ, WRITE, READA, etc.).
    
    So unexport linux/blk_types.h and unexport the relevant bits of linux/fs.h.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Jens Axboe <jaxboe@fusionio.com>
    cc: Tejun Heo <tj@kernel.org>
    cc: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65fbf571023f..8cb86cfc9719 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -8,7 +8,6 @@
 
 #include <linux/limits.h>
 #include <linux/ioctl.h>
-#include <linux/blk_types.h>
 #include <linux/types.h>
 
 /*
@@ -117,65 +116,6 @@ struct inodes_stat_t {
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
 
-/*
- * The below are the various read and write types that we support. Some of
- * them include behavioral modifiers that send information down to the
- * block layer and IO scheduler. Terminology:
- *
- *	The block layer uses device plugging to defer IO a little bit, in
- *	the hope that we will see more IO very shortly. This increases
- *	coalescing of adjacent IO and thus reduces the number of IOs we
- *	have to send to the device. It also allows for better queuing,
- *	if the IO isn't mergeable. If the caller is going to be waiting
- *	for the IO, then he must ensure that the device is unplugged so
- *	that the IO is dispatched to the driver.
- *
- *	All IO is handled async in Linux. This is fine for background
- *	writes, but for reads or writes that someone waits for completion
- *	on, we want to notify the block layer and IO scheduler so that they
- *	know about it. That allows them to make better scheduling
- *	decisions. So when the below references 'sync' and 'async', it
- *	is referencing this priority hint.
- *
- * With that in mind, the available types are:
- *
- * READ			A normal read operation. Device will be plugged.
- * READ_SYNC		A synchronous read. Device is not plugged, caller can
- *			immediately wait on this read without caring about
- *			unplugging.
- * READA		Used for read-ahead operations. Lower priority, and the
- *			block layer could (in theory) choose to ignore this
- *			request if it runs into resource problems.
- * WRITE		A normal async write. Device will be plugged.
- * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down
- *			the hint that someone will be waiting on this IO
- *			shortly. The write equivalent of READ_SYNC.
- * WRITE_ODIRECT	Special case write for O_DIRECT only.
- * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
- * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
- *			non-volatile media on completion.
- * WRITE_FLUSH_FUA	Combination of WRITE_FLUSH and FUA. The IO is preceded
- *			by a cache flush and data is guaranteed to be on
- *			non-volatile media on completion.
- *
- */
-#define RW_MASK			REQ_WRITE
-#define RWA_MASK		REQ_RAHEAD
-
-#define READ			0
-#define WRITE			RW_MASK
-#define READA			RWA_MASK
-#define KERNEL_READ		(READ|REQ_KERNEL)
-#define KERNEL_WRITE		(WRITE|REQ_KERNEL)
-
-#define READ_SYNC		(READ | REQ_SYNC)
-#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)
-#define WRITE_ODIRECT		(WRITE | REQ_SYNC)
-#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
-#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)
-#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
-
-
 /*
  * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
  * that indicates that they should check the contents of the iovec are
@@ -417,6 +357,7 @@ struct inodes_stat_t {
 #include <linux/uidgid.h>
 #include <linux/lockdep.h>
 #include <linux/percpu-rwsem.h>
+#include <linux/blk_types.h>
 
 #include <asm/byteorder.h>
 
@@ -453,6 +394,64 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private, int ret,
 			bool is_async);
 
+/*
+ * The below are the various read and write types that we support. Some of
+ * them include behavioral modifiers that send information down to the
+ * block layer and IO scheduler. Terminology:
+ *
+ *	The block layer uses device plugging to defer IO a little bit, in
+ *	the hope that we will see more IO very shortly. This increases
+ *	coalescing of adjacent IO and thus reduces the number of IOs we
+ *	have to send to the device. It also allows for better queuing,
+ *	if the IO isn't mergeable. If the caller is going to be waiting
+ *	for the IO, then he must ensure that the device is unplugged so
+ *	that the IO is dispatched to the driver.
+ *
+ *	All IO is handled async in Linux. This is fine for background
+ *	writes, but for reads or writes that someone waits for completion
+ *	on, we want to notify the block layer and IO scheduler so that they
+ *	know about it. That allows them to make better scheduling
+ *	decisions. So when the below references 'sync' and 'async', it
+ *	is referencing this priority hint.
+ *
+ * With that in mind, the available types are:
+ *
+ * READ			A normal read operation. Device will be plugged.
+ * READ_SYNC		A synchronous read. Device is not plugged, caller can
+ *			immediately wait on this read without caring about
+ *			unplugging.
+ * READA		Used for read-ahead operations. Lower priority, and the
+ *			block layer could (in theory) choose to ignore this
+ *			request if it runs into resource problems.
+ * WRITE		A normal async write. Device will be plugged.
+ * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down
+ *			the hint that someone will be waiting on this IO
+ *			shortly. The write equivalent of READ_SYNC.
+ * WRITE_ODIRECT	Special case write for O_DIRECT only.
+ * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
+ * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
+ *			non-volatile media on completion.
+ * WRITE_FLUSH_FUA	Combination of WRITE_FLUSH and FUA. The IO is preceded
+ *			by a cache flush and data is guaranteed to be on
+ *			non-volatile media on completion.
+ *
+ */
+#define RW_MASK			REQ_WRITE
+#define RWA_MASK		REQ_RAHEAD
+
+#define READ			0
+#define WRITE			RW_MASK
+#define READA			RWA_MASK
+#define KERNEL_READ		(READ|REQ_KERNEL)
+#define KERNEL_WRITE		(WRITE|REQ_KERNEL)
+
+#define READ_SYNC		(READ | REQ_SYNC)
+#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)
+#define WRITE_ODIRECT		(WRITE | REQ_SYNC)
+#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
+#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)
+#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
+
 /*
  * Attribute flags.  These should be or-ed together to figure out what
  * has been changed!

commit 7950e3852ab86826b7349a535d2e8b0000340d7f
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 16:43:13 2012 -0400

    vfs: embed struct filename inside of names_cache allocation if possible
    
    In the common case where a name is much smaller than PATH_MAX, an extra
    allocation for struct filename is unnecessary. Before allocating a
    separate one, try to embed the struct filename inside the buffer first. If
    it turns out that that's not long enough, then fall back to allocating a
    separate struct filename and redoing the copy.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4aa7160a51ce..65fbf571023f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2201,6 +2201,7 @@ struct filename {
 	const char		*name;	/* pointer to actual string */
 	const __user char	*uptr;	/* original userland pointer */
 	struct audit_names	*aname;
+	bool			separate; /* should "name" be freed? */
 };
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,

commit adb5c2473d3f91526c79db972aafb20a56d3fbb3
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 16:43:13 2012 -0400

    audit: make audit_inode take struct filename
    
    Keep a pointer to the audit_names "slot" in struct filename.
    
    Have all of the audit_inode callers pass a struct filename ponter to
    audit_inode instead of a string pointer. If the aname field is already
    populated, then we can skip walking the list altogether and just use it
    directly.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b6b10e7f0ac0..4aa7160a51ce 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2196,9 +2196,11 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 #endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */
+struct audit_names;
 struct filename {
-	const char *name;		/* pointer to actual string */
-	const __user char *uptr;	/* original userland pointer */
+	const char		*name;	/* pointer to actual string */
+	const __user char	*uptr;	/* original userland pointer */
+	struct audit_names	*aname;
 };
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,

commit 669abf4e5539c8aa48bf28c965be05c0a7b58a27
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 16:43:10 2012 -0400

    vfs: make path_openat take a struct filename pointer
    
    ...and fix up the callers. For do_file_open_root, just declare a
    struct filename on the stack and fill out the .name field. For
    do_filp_open, make it also take a struct filename pointer, and fix up its
    callers to call it appropriately.
    
    For filp_open, add a variant that takes a struct filename pointer and turn
    filp_open into a wrapper around it.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c93b46f46dc..b6b10e7f0ac0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2207,6 +2207,7 @@ extern int do_fallocate(struct file *file, int mode, loff_t offset,
 			loff_t len);
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
 			umode_t mode);
+extern struct file *file_open_name(struct filename *, int, umode_t);
 extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int);

commit 91a27b2a756784714e924e5e854b919273082d26
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:28 2012 -0400

    vfs: define struct filename and have getname() return it
    
    getname() is intended to copy pathname strings from userspace into a
    kernel buffer. The result is just a string in kernel space. It would
    however be quite helpful to be able to attach some ancillary info to
    the string.
    
    For instance, we could attach some audit-related info to reduce the
    amount of audit-related processing needed. When auditing is enabled,
    we could also call getname() on the string more than once and not
    need to recopy it from userspace.
    
    This patchset converts the getname()/putname() interfaces to return
    a struct instead of a string. For now, the struct just tracks the
    string in kernel space and the original userland pointer for it.
    
    Later, we'll add other information to the struct as it becomes
    convenient.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b44b4ca82164..6c93b46f46dc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2196,6 +2196,10 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 #endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */
+struct filename {
+	const char *name;		/* pointer to actual string */
+	const __user char *uptr;	/* original userland pointer */
+};
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
@@ -2208,7 +2212,9 @@ extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int);
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
-extern char * getname(const char __user *);
+
+extern struct filename *getname(const char __user *);
+
 enum {
 	FILE_CREATED = 1,
 	FILE_OPENED = 2
@@ -2228,12 +2234,14 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
+extern void final_putname(struct filename *name);
+
 #define __getname()		kmem_cache_alloc(names_cachep, GFP_KERNEL)
 #define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL
-#define putname(name)   __putname(name)
+#define putname(name)		final_putname(name)
 #else
-extern void putname(const char *name);
+extern void putname(struct filename *name);
 #endif
 
 #ifdef CONFIG_BLOCK

commit a608ca21f58ee44df5a71ba140e98498f3ebc2cd
Author: Jeff Layton <jlayton@redhat.com>
Date:   Wed Oct 10 15:25:26 2012 -0400

    vfs: allocate page instead of names_cache buffer in mount_block_root
    
    First, it's incorrect to call putname() after __getname_gfp() since the
    bare __getname_gfp() call skips the auditing code, while putname()
    doesn't.
    
    mount_block_root allocates a PATH_MAX buffer via __getname_gfp, and then
    calls get_fs_names to fill the buffer. That function can call
    get_filesystem_list which assumes that that buffer is a full page in
    size. On arches where PAGE_SIZE != 4k, then this could potentially
    overrun.
    
    In practice, it's hard to imagine the list of filesystem names even
    approaching 4k, but it's best to be safe. Just allocate a page for this
    purpose instead.
    
    With this, we can also remove the __getname_gfp() definition since there
    are no more callers.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8ef2fc9f1f08..b44b4ca82164 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2228,8 +2228,7 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
-#define __getname_gfp(gfp)	kmem_cache_alloc(names_cachep, (gfp))
-#define __getname()		__getname_gfp(GFP_KERNEL)
+#define __getname()		kmem_cache_alloc(names_cachep, GFP_KERNEL)
 #define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL
 #define putname(name)   __putname(name)

commit 79360ddd73dfe9a26f49ef4e27b8c26612929b0e
Merge: 8213a2f3eeaf 98f6ef64b15a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 12 10:52:03 2012 +0900

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull pile 2 of vfs updates from Al Viro:
     "Stuff in this one - assorted fixes, lglock tidy-up, death to
      lock_super().
    
      There'll be a VFS pile tomorrow (with patches from Jeff Layton,
      sanitizing getname() and related parts of audit and preparing for
      ESTALE fixes), but I'd rather push the stuff in this one ASAP - some
      of the bugs closed here are quite unpleasant."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      vfs: bogus warnings in fs/namei.c
      consitify do_mount() arguments
      lglock: add DEFINE_STATIC_LGLOCK()
      lglock: make the per_cpu locks static
      lglock: remove unused DEFINE_LGLOCK_LOCKDEP()
      MAX_LFS_FILESIZE definition for 64bit needs LL...
      tmpfs,ceph,gfs2,isofs,reiserfs,xfs: fix fh_len checking
      vfs: drop lock/unlock super
      ufs: drop lock/unlock super
      sysv: drop lock/unlock super
      hpfs: drop lock/unlock super
      fat: drop lock/unlock super
      ext3: drop lock/unlock super
      exofs: drop lock/unlock super
      dup3: Return an error when oldfd == newfd.
      fs: handle failed audit_log_start properly
      fs: prevent use after free in auditing when symlink following was denied

commit 808d4e3cfdcc52b19276175464f6dbca4df13b09
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Oct 11 11:42:01 2012 -0400

    consitify do_mount() arguments
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ec911aeea968..9baf8270f9d1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2075,7 +2075,7 @@ extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
 extern void kern_unmount(struct vfsmount *mnt);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
-extern long do_mount(char *, char *, char *, unsigned long, void *);
+extern long do_mount(const char *, const char *, const char *, unsigned long, void *);
 extern struct vfsmount *collect_mounts(struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,

commit ce40be7a820bb393ac4ac69865f018d2f4038cf0
Merge: ba0a5a36f60e 02f3939e1a93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 11 09:04:23 2012 +0900

    Merge branch 'for-3.7/core' of git://git.kernel.dk/linux-block
    
    Pull block IO update from Jens Axboe:
     "Core block IO bits for 3.7.  Not a huge round this time, it contains:
    
       - First series from Kent cleaning up and generalizing bio allocation
         and freeing.
    
       - WRITE_SAME support from Martin.
    
       - Mikulas patches to prevent O_DIRECT crashes when someone changes
         the block size of a device.
    
       - Make bio_split() work on data-less bio's (like trim/discards).
    
       - A few other minor fixups."
    
    Fixed up silent semantic mis-merge as per Mikulas Patocka and Andrew
    Morton.  It is due to the VM no longer using a prio-tree (see commit
    6b2dbba8b6ac: "mm: replace vma prio_tree with an interval tree").
    
    So make set_blocksize() use mapping_mapped() instead of open-coding the
    internal VM knowledge that has changed.
    
    * 'for-3.7/core' of git://git.kernel.dk/linux-block: (26 commits)
      block: makes bio_split support bio without data
      scatterlist: refactor the sg_nents
      scatterlist: add sg_nents
      fs: fix include/percpu-rwsem.h export error
      percpu-rw-semaphore: fix documentation typos
      fs/block_dev.c:1644:5: sparse: symbol 'blkdev_mmap' was not declared
      blockdev: turn a rw semaphore into a percpu rw semaphore
      Fix a crash when block device is read and block size is changed at the same time
      block: fix request_queue->flags initialization
      block: lift the initial queue bypass mode on blk_register_queue() instead of blk_init_allocated_queue()
      block: ioctl to zero block ranges
      block: Make blkdev_issue_zeroout use WRITE SAME
      block: Implement support for WRITE SAME
      block: Consolidate command flag and queue limit checks for merges
      block: Clean up special command handling logic
      block/blk-tag.c: Remove useless kfree
      block: remove the duplicated setting for congestion_threshold
      block: reject invalid queue attribute values
      block: Add bio_clone_bioset(), bio_clone_kmalloc()
      block: Consolidate bio_alloc_bioset(), bio_kmalloc()
      ...

commit 614c321f4bf130766ff66fd142b1da47ab037303
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 10 01:06:20 2012 -0400

    MAX_LFS_FILESIZE definition for 64bit needs LL...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b7e70609243d..ec911aeea968 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1132,7 +1132,7 @@ static inline int file_check_writeable(struct file *filp)
 #if BITS_PER_LONG==32
 #define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
 #elif BITS_PER_LONG==64
-#define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffff)
+#define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)
 #endif
 
 #define FL_POSIX	1

commit 8e22cc88d68ca1a46d7d582938f979eb640ed30f
Author: Marco Stornelli <marco.stornelli@gmail.com>
Date:   Sat Oct 6 12:43:09 2012 +0200

    vfs: drop lock/unlock super
    
    Removed s_lock from super_block and removed lock/unlock super.
    
    Signed-off-by: Marco Stornelli <marco.stornelli@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c617ed024df8..b7e70609243d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1507,7 +1507,6 @@ struct super_block {
 	unsigned long		s_magic;
 	struct dentry		*s_root;
 	struct rw_semaphore	s_umount;
-	struct mutex		s_lock;
 	int			s_count;
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY

commit 6b2dbba8b6ac4df26f72eda1e5ea7bab9f950e08
Author: Michel Lespinasse <walken@google.com>
Date:   Mon Oct 8 16:31:25 2012 -0700

    mm: replace vma prio_tree with an interval tree
    
    Implement an interval tree as a replacement for the VMA prio_tree.  The
    algorithms are similar to lib/interval_tree.c; however that code can't be
    directly reused as the interval endpoints are not explicitly stored in the
    VMA.  So instead, the common algorithm is moved into a template and the
    details (node type, how to get interval endpoints from the node, etc) are
    filled in using the C preprocessor.
    
    Once the interval tree functions are available, using them as a
    replacement to the VMA prio tree is a relatively simple, mechanical job.
    
    Signed-off-by: Michel Lespinasse <walken@google.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Hillf Danton <dhillf@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5a8a273d5b2f..c617ed024df8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -401,7 +401,7 @@ struct inodes_stat_t {
 #include <linux/cache.h>
 #include <linux/list.h>
 #include <linux/radix-tree.h>
-#include <linux/prio_tree.h>
+#include <linux/rbtree.h>
 #include <linux/init.h>
 #include <linux/pid.h>
 #include <linux/bug.h>
@@ -669,7 +669,7 @@ struct address_space {
 	struct radix_tree_root	page_tree;	/* radix tree of all pages */
 	spinlock_t		tree_lock;	/* and lock protecting it */
 	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
-	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
+	struct rb_root		i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
 	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
 	/* Protected by tree_lock together with the radix tree */
@@ -741,7 +741,7 @@ int mapping_tagged(struct address_space *mapping, int tag);
  */
 static inline int mapping_mapped(struct address_space *mapping)
 {
-	return	!prio_tree_empty(&mapping->i_mmap) ||
+	return	!RB_EMPTY_ROOT(&mapping->i_mmap) ||
 		!list_empty(&mapping->i_mmap_nonlinear);
 }
 

commit 0b173bc4daa8f8ec03a85abf5e47b23502ff80af
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Mon Oct 8 16:28:46 2012 -0700

    mm: kill vma flag VM_CAN_NONLINEAR
    
    Move actual pte filling for non-linear file mappings into the new special
    vma operation: ->remap_pages().
    
    Filesystems must implement this method to get non-linear mapping support,
    if it uses filemap_fault() then generic_file_remap_pages() can be used.
    
    Now device drivers can implement this method and obtain nonlinear vma support.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Carsten Otte <cotte@de.ibm.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com> #arch/tile
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: James Morris <james.l.morris@oracle.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: Kentaro Takeda <takedakn@nttdata.co.jp>
    Cc: Matt Helsley <matthltc@us.ibm.com>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Venkatesh Pallipadi <venki@google.com>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ca6d8c806f47..5a8a273d5b2f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2552,6 +2552,8 @@ extern int sb_min_blocksize(struct super_block *, int);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
+extern int generic_file_remap_pages(struct vm_area_struct *, unsigned long addr,
+		unsigned long size, pgoff_t pgoff);
 extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);

commit 2bd2c1941f141ad780135ccc1cd08ca71a24f10a
Author: Chuck Lever <chuck.lever@oracle.com>
Date:   Mon Sep 24 14:51:48 2012 -0400

    MAX_LFS_FILESIZE should be a loff_t
    
    fs/nfs/internal.h: In function nfs_super_set_maxbytes:
    fs/nfs/internal.h:547:21: warning: comparison between signed and
        unsigned integer expressions [-Wsign-compare]
    
    Seen with gcc (GCC) 4.6.3 20120306 (Red Hat 4.6.3-2).
    
    Commit 42cb56ae made s_maxbytes a loff_t, thus the type of
    MAX_LFS_FILESIZE should also be a loff_t.
    
    Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index de1db1c12080..ca6d8c806f47 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1130,9 +1130,9 @@ static inline int file_check_writeable(struct file *filp)
 /* Page cache limit. The filesystems should put that into their s_maxbytes 
    limits, otherwise bad things can happen in VM. */ 
 #if BITS_PER_LONG==32
-#define MAX_LFS_FILESIZE	(((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
 #elif BITS_PER_LONG==64
-#define MAX_LFS_FILESIZE 	0x7fffffffffffffffUL
+#define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffff)
 #endif
 
 #define FL_POSIX	1

commit c2b1ad800b66f62105a7fd250604d72e07202e66
Author: Jens Axboe <axboe@kernel.dk>
Date:   Thu Sep 27 09:35:03 2012 +0200

    fs: fix include/percpu-rwsem.h export error
    
    We get the following export error on the include file:
    
    usr/include/linux/fs.h:13: included file 'linux/percpu-rwsem.h' is not exported
    
    Move the include inside the __KERNEL__ section.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 24e1229cdfe0..cefa9645fc85 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,7 +10,6 @@
 #include <linux/ioctl.h>
 #include <linux/blk_types.h>
 #include <linux/types.h>
-#include <linux/percpu-rwsem.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -417,6 +416,7 @@ struct inodes_stat_t {
 #include <linux/migrate_mode.h>
 #include <linux/uidgid.h>
 #include <linux/lockdep.h>
+#include <linux/percpu-rwsem.h>
 
 #include <asm/byteorder.h>
 

commit cb0942b81249798e15c3f04eee2946ef543e8115
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Aug 27 14:48:26 2012 -0400

    make get_file() return its argument
    
    simplifies a bunch of callers...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa110476a95b..de1db1c12080 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1074,7 +1074,11 @@ struct file_handle {
 	unsigned char f_handle[0];
 };
 
-#define get_file(x)	atomic_long_inc(&(x)->f_count)
+static inline struct file *get_file(struct file *f)
+{
+	atomic_long_inc(&f->f_count);
+	return f;
+}
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 

commit 62ac665ff9fc07497ca524bd20d6a96893d11071
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Wed Sep 26 07:46:43 2012 +0200

    blockdev: turn a rw semaphore into a percpu rw semaphore
    
    This avoids cache line bouncing when many processes lock the semaphore
    for read.
    
    New percpu lock implementation
    
    The lock consists of an array of percpu unsigned integers, a boolean
    variable and a mutex.
    
    When we take the lock for read, we enter rcu read section, check for a
    "locked" variable. If it is false, we increase a percpu counter on the
    current cpu and exit the rcu section. If "locked" is true, we exit the
    rcu section, take the mutex and drop it (this waits until a writer
    finished) and retry.
    
    Unlocking for read just decreases percpu variable. Note that we can
    unlock on a difference cpu than where we locked, in this case the
    counter underflows. The sum of all percpu counters represents the number
    of processes that hold the lock for read.
    
    When we need to lock for write, we take the mutex, set "locked" variable
    to true and synchronize rcu. Since RCU has been synchronized, no
    processes can create new read locks. We wait until the sum of percpu
    counters is zero - when it is, there are no readers in the critical
    section.
    
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e60bbd0225d5..24e1229cdfe0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,6 +10,7 @@
 #include <linux/ioctl.h>
 #include <linux/blk_types.h>
 #include <linux/types.h>
+#include <linux/percpu-rwsem.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -726,7 +727,7 @@ struct block_device {
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
 	/* A semaphore that prevents I/O while block size is being changed */
-	struct rw_semaphore	bd_block_size_semaphore;
+	struct percpu_rw_semaphore	bd_block_size_semaphore;
 };
 
 /*

commit b87570f5d349661814b262dd5fc40787700f80d6
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Wed Sep 26 07:46:40 2012 +0200

    Fix a crash when block device is read and block size is changed at the same time
    
    The kernel may crash when block size is changed and I/O is issued
    simultaneously.
    
    Because some subsystems (udev or lvm) may read any block device anytime,
    the bug actually puts any code that changes a block device size in
    jeopardy.
    
    The crash can be reproduced if you place "msleep(1000)" to
    blkdev_get_blocks just before "bh->b_size = max_blocks <<
    inode->i_blkbits;".
    Then, run "dd if=/dev/ram0 of=/dev/null bs=4k count=1 iflag=direct"
    While it is waiting in msleep, run "blockdev --setbsz 2048 /dev/ram0"
    You get a BUG.
    
    The direct and non-direct I/O is written with the assumption that block
    size does not change. It doesn't seem practical to fix these crashes
    one-by-one there may be many crash possibilities when block size changes
    at a certain place and it is impossible to find them all and verify the
    code.
    
    This patch introduces a new rw-lock bd_block_size_semaphore. The lock is
    taken for read during I/O. It is taken for write when changing block
    size. Consequently, block size can't be changed while I/O is being
    submitted.
    
    For asynchronous I/O, the patch only prevents block size change while
    the I/O is being submitted. The block size can change when the I/O is in
    progress or when the I/O is being finished. This is acceptable because
    there are no accesses to block size when asynchronous I/O is being
    finished.
    
    The patch prevents block size changing while the device is mapped with
    mmap.
    
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd6f6e7ca48e..e60bbd0225d5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -725,6 +725,8 @@ struct block_device {
 	int			bd_fsfreeze_count;
 	/* Mutex for freeze */
 	struct mutex		bd_fsfreeze_mutex;
+	/* A semaphore that prevents I/O while block size is being changed */
+	struct rw_semaphore	bd_block_size_semaphore;
 };
 
 /*
@@ -2565,6 +2567,8 @@ extern int generic_segment_checks(const struct iovec *iov,
 		unsigned long *nr_segs, size_t *count, int access_flags);
 
 /* fs/block_dev.c */
+extern ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
+			       unsigned long nr_segs, loff_t pos);
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
 extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,

commit 66ba32dc167202c3cf8c86806581a9393ec7f488
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Tue Sep 18 12:19:29 2012 -0400

    block: ioctl to zero block ranges
    
    Introduce a BLKZEROOUT ioctl which can be used to clear block ranges by
    way of blkdev_issue_zeroout().
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa110476a95b..bd6f6e7ca48e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -335,6 +335,7 @@ struct inodes_stat_t {
 #define BLKDISCARDZEROES _IO(0x12,124)
 #define BLKSECDISCARD _IO(0x12,125)
 #define BLKROTATIONAL _IO(0x12,126)
+#define BLKZEROOUT _IO(0x12,127)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit f0cd2dbb6cf387c11f87265462e370bb5469299e
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Jul 25 18:11:59 2012 +0300

    vfs: kill write_super and sync_supers
    
    Finally we can kill the 'sync_supers' kernel thread along with the
    '->write_super()' superblock operation because all the users are gone.
    Now every file-system is supposed to self-manage own superblock and
    its dirty state.
    
    The nice thing about killing this thread is that it improves power management.
    Indeed, 'sync_supers' is a source of monotonic system wake-ups - it woke up
    every 5 seconds no matter what - even if there were no dirty superblocks and
    even if there were no file-systems using this service (e.g., btrfs and
    journalled ext4 do not need it). So it was wasting power most of the time. And
    because the thread was in the core of the kernel, all systems had to have it.
    So I am quite happy to make it go away.
    
    Interestingly, this thread is a left-over from the pdflush kernel thread which
    was a self-forking kernel thread responsible for all the write-back in old
    Linux kernels. It was turned into per-block device BDI threads, and
    'sync_supers' was a left-over. Thus, R.I.P, pdflush as well.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 38dba16c4176..aa110476a95b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1491,7 +1491,6 @@ struct sb_writers {
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */
 	dev_t			s_dev;		/* search index; _not_ kdev_t */
-	unsigned char		s_dirt;
 	unsigned char		s_blocksize_bits;
 	unsigned long		s_blocksize;
 	loff_t			s_maxbytes;	/* Max file size */
@@ -1861,7 +1860,6 @@ struct super_operations {
 	int (*drop_inode) (struct inode *);
 	void (*evict_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
-	void (*write_super) (struct super_block *);
 	int (*sync_fs)(struct super_block *sb, int wait);
 	int (*freeze_fs) (struct super_block *);
 	int (*unfreeze_fs) (struct super_block *);
@@ -2397,7 +2395,6 @@ extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
 extern int generic_write_sync(struct file *file, loff_t pos, loff_t count);
-extern void sync_supers(void);
 extern void emergency_sync(void);
 extern void emergency_remount(void);
 #ifdef CONFIG_BLOCK

commit a0e881b7c189fa2bd76c024dbff91e79511c971d
Merge: eff0d13f3823 dbc6e0222d79
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 1 10:26:23 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull second vfs pile from Al Viro:
     "The stuff in there: fsfreeze deadlock fixes by Jan (essentially, the
      deadlock reproduced by xfstests 068), symlink and hardlink restriction
      patches, plus assorted cleanups and fixes.
    
      Note that another fsfreeze deadlock (emergency thaw one) is *not*
      dealt with - the series by Fernando conflicts a lot with Jan's, breaks
      userland ABI (FIFREEZE semantics gets changed) and trades the deadlock
      for massive vfsmount leak; this is going to be handled next cycle.
      There probably will be another pull request, but that stuff won't be
      in it."
    
    Fix up trivial conflicts due to unrelated changes next to each other in
    drivers/{staging/gdm72xx/usb_boot.c, usb/gadget/storage_common.c}
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (54 commits)
      delousing target_core_file a bit
      Documentation: Correct s_umount state for freeze_fs/unfreeze_fs
      fs: Remove old freezing mechanism
      ext2: Implement freezing
      btrfs: Convert to new freezing mechanism
      nilfs2: Convert to new freezing mechanism
      ntfs: Convert to new freezing mechanism
      fuse: Convert to new freezing mechanism
      gfs2: Convert to new freezing mechanism
      ocfs2: Convert to new freezing mechanism
      xfs: Convert to new freezing code
      ext4: Convert to new freezing mechanism
      fs: Protect write paths by sb_start_write - sb_end_write
      fs: Skip atime update on frozen filesystem
      fs: Add freezing handling to mnt_want_write() / mnt_drop_write()
      fs: Improve filesystem freezing handling
      switch the protection of percpu_counter list to spinlock
      nfsd: Push mnt_want_write() outside of i_mutex
      btrfs: Push mnt_want_write() outside of i_mutex
      fat: Push mnt_want_write() outside of i_mutex
      ...

commit 068535f1fef4c90aee23eb7b9b9a71c5b72d7cd0
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Aug 1 07:56:16 2012 -0400

    locks: remove unused lm_release_private
    
    In commit 3b6e2723f32d ("locks: prevent side-effects of
    locks_release_private before file_lock is initialized") we removed the
    last user of lm_release_private without removing the field itself.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d7eed5b98ae2..4ba5c8715523 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1162,7 +1162,6 @@ struct lock_manager_operations {
 	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
 	void (*lm_notify)(struct file_lock *);	/* unblock callback */
 	int (*lm_grant)(struct file_lock *, struct file_lock *, int);
-	void (*lm_release_private)(struct file_lock *);
 	void (*lm_break)(struct file_lock *);
 	int (*lm_change)(struct file_lock **, int);
 };

commit ac694dbdbc403c00e2c14d10bc7b8412cc378259
Merge: a40a1d3d0a2f 437ea90cc3af
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 31 19:25:39 2012 -0700

    Merge branch 'akpm' (Andrew's patch-bomb)
    
    Merge Andrew's second set of patches:
     - MM
     - a few random fixes
     - a couple of RTC leftovers
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (120 commits)
      rtc/rtc-88pm80x: remove unneed devm_kfree
      rtc/rtc-88pm80x: assign ret only when rtc_register_driver fails
      mm: hugetlbfs: close race during teardown of hugetlbfs shared page tables
      tmpfs: distribute interleave better across nodes
      mm: remove redundant initialization
      mm: warn if pg_data_t isn't initialized with zero
      mips: zero out pg_data_t when it's allocated
      memcg: gix memory accounting scalability in shrink_page_list
      mm/sparse: remove index_init_lock
      mm/sparse: more checks on mem_section number
      mm/sparse: optimize sparse_index_alloc
      memcg: add mem_cgroup_from_css() helper
      memcg: further prevent OOM with too many dirty pages
      memcg: prevent OOM with too many dirty pages
      mm: mmu_notifier: fix freed page still mapped in secondary MMU
      mm: memcg: only check anon swapin page charges for swap cache
      mm: memcg: only check swap cache pages for repeated charging
      mm: memcg: split swapin charge function into private and public part
      mm: memcg: remove needless !mm fixup to init_mm when charging
      mm: memcg: remove unneeded shmem charge type
      ...

commit a509bc1a9e487d952d9404318f7f990166ab57a7
Author: Mel Gorman <mgorman@suse.de>
Date:   Tue Jul 31 16:44:57 2012 -0700

    mm: swap: implement generic handler for swap_activate
    
    The version of swap_activate introduced is sufficient for swap-over-NFS
    but would not provide enough information to implement a generic handler.
    This patch shuffles things slightly to ensure the same information is
    available for aops->swap_activate() as is available to the core.
    
    No functionality change.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Eric B Munson <emunson@mgebm.net>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 38356ab827c9..c8667f8b5358 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -429,6 +429,7 @@ struct kstatfs;
 struct vm_area_struct;
 struct vfsmount;
 struct cred;
+struct swap_info_struct;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -640,8 +641,9 @@ struct address_space_operations {
 	int (*error_remove_page)(struct address_space *, struct page *);
 
 	/* swapfile support */
-	int (*swap_activate)(struct file *file);
-	int (*swap_deactivate)(struct file *file);
+	int (*swap_activate)(struct swap_info_struct *sis, struct file *file,
+				sector_t *span);
+	void (*swap_deactivate)(struct file *file);
 };
 
 extern const struct address_space_operations empty_aops;

commit 62c230bc1790923a1b35da03596a68a6c9b5b100
Author: Mel Gorman <mgorman@suse.de>
Date:   Tue Jul 31 16:44:55 2012 -0700

    mm: add support for a filesystem to activate swap files and use direct_IO for writing swap pages
    
    Currently swapfiles are managed entirely by the core VM by using ->bmap to
    allocate space and write to the blocks directly.  This effectively ensures
    that the underlying blocks are allocated and avoids the need for the swap
    subsystem to locate what physical blocks store offsets within a file.
    
    If the swap subsystem is to use the filesystem information to locate the
    blocks, it is critical that information such as block groups, block
    bitmaps and the block descriptor table that map the swap file were
    resident in memory.  This patch adds address_space_operations that the VM
    can call when activating or deactivating swap backed by a file.
    
      int swap_activate(struct file *);
      int swap_deactivate(struct file *);
    
    The ->swap_activate() method is used to communicate to the file that the
    VM relies on it, and the address_space should take adequate measures such
    as reserving space in the underlying device, reserving memory for mempools
    and pinning information such as the block descriptor table in memory.  The
    ->swap_deactivate() method is called on sys_swapoff() if ->swap_activate()
    returned success.
    
    After a successful swapfile ->swap_activate, the swapfile is marked
    SWP_FILE and swapper_space.a_ops will proxy to
    sis->swap_file->f_mappings->a_ops using ->direct_io to write swapcache
    pages and ->readpage to read.
    
    It is perfectly possible that direct_IO be used to read the swap pages but
    it is an unnecessary complication.  Similarly, it is possible that
    ->writepage be used instead of direct_io to write the pages but filesystem
    developers have stated that calling writepage from the VM is undesirable
    for a variety of reasons and using direct_IO opens up the possibility of
    writing back batches of swap pages in the future.
    
    [a.p.zijlstra@chello.nl: Original patch]
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Eric B Munson <emunson@mgebm.net>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Xiaotian Feng <dfeng@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9d77309da153..38356ab827c9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -638,6 +638,10 @@ struct address_space_operations {
 	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
 					unsigned long);
 	int (*error_remove_page)(struct address_space *, struct page *);
+
+	/* swapfile support */
+	int (*swap_activate)(struct file *file);
+	int (*swap_deactivate)(struct file *file);
 };
 
 extern const struct address_space_operations empty_aops;

commit 18022c5d8627a7a9ba8097a0f238b513fae6f5b8
Author: Mel Gorman <mgorman@suse.de>
Date:   Tue Jul 31 16:44:51 2012 -0700

    mm: add get_kernel_page[s] for pinning of kernel addresses for I/O
    
    This patch adds two new APIs get_kernel_pages() and get_kernel_page() that
    may be used to pin a vector of kernel addresses for IO.  The initial user
    is expected to be NFS for allowing pages to be written to swap using
    aops->direct_IO().  Strictly speaking, swap-over-NFS only needs to pin one
    page for IO but it makes sense to express the API in terms of a vector and
    add a helper for pinning single pages.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Eric B Munson <emunson@mgebm.net>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Mike Christie <michaelc@cs.wisc.edu>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Xiaotian Feng <dfeng@redhat.com>
    Cc: Mark Salter <msalter@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8fabb037a48d..9d77309da153 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -165,6 +165,8 @@ struct inodes_stat_t {
 #define READ			0
 #define WRITE			RW_MASK
 #define READA			RWA_MASK
+#define KERNEL_READ		(READ|REQ_KERNEL)
+#define KERNEL_WRITE		(WRITE|REQ_KERNEL)
 
 #define READ_SYNC		(READ | REQ_SYNC)
 #define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)

commit 08843b79fb35d33859e0f8f11a7318341076e4d1
Merge: cc8362b1f6d7 2c142baa7b23
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 31 14:42:28 2012 -0700

    Merge branch 'nfsd-next' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd changes from J. Bruce Fields:
     "This has been an unusually quiet cycle--mostly bugfixes and cleanup.
      The one large piece is Stanislav's work to containerize the server's
      grace period--but that in itself is just one more step in a
      not-yet-complete project to allow fully containerized nfs service.
    
      There are a number of outstanding delegation, container, v4 state, and
      gss patches that aren't quite ready yet; 3.7 may be wilder."
    
    * 'nfsd-next' of git://linux-nfs.org/~bfields/linux: (35 commits)
      NFSd: make boot_time variable per network namespace
      NFSd: make grace end flag per network namespace
      Lockd: move grace period management from lockd() to per-net functions
      LockD: pass actual network namespace to grace period management functions
      LockD: manage grace list per network namespace
      SUNRPC: service request network namespace helper introduced
      NFSd: make nfsd4_manager allocated per network namespace context.
      LockD: make lockd manager allocated per network namespace
      LockD: manage grace period per network namespace
      Lockd: add more debug to host shutdown functions
      Lockd: host complaining function introduced
      LockD: manage used host count per networks namespace
      LockD: manage garbage collection timeout per networks namespace
      LockD: make garbage collector network namespace aware.
      LockD: mark host per network namespace on garbage collect
      nfsd4: fix missing fault_inject.h include
      locks: move lease-specific code out of locks_delete_lock
      locks: prevent side-effects of locks_release_private before file_lock is initialized
      NFSd: set nfsd_serv to NULL after service destruction
      NFSd: introduce nfsd_destroy() helper
      ...

commit d9c95bdd53a8d9116d269c91ce3d151472e6bcd6
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jun 12 16:20:47 2012 +0200

    fs: Remove old freezing mechanism
    
    Now that all users are converted, we can remove functions, variables, and
    constants defined by the old freezing mechanism.
    
    BugLink: https://bugs.launchpad.net/bugs/897421
    Tested-by: Kamal Mostafa <kamal@canonical.com>
    Tested-by: Peter M. Petrakis <peter.petrakis@canonical.com>
    Tested-by: Dann Frazier <dann.frazier@canonical.com>
    Tested-by: Massimo Morana <massimo.morana@canonical.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aefed9426b03..0f4b79be8717 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1459,7 +1459,6 @@ extern spinlock_t sb_lock;
 enum {
 	SB_UNFROZEN = 0,		/* FS is unfrozen */
 	SB_FREEZE_WRITE	= 1,		/* Writes, dir ops, ioctls frozen */
-	SB_FREEZE_TRANS = 2,
 	SB_FREEZE_PAGEFAULT = 2,	/* Page faults stopped as well */
 	SB_FREEZE_FS = 3,		/* For internal FS use (e.g. to stop
 					 * internal threads if needed) */
@@ -1528,8 +1527,6 @@ struct super_block {
 	struct hlist_node	s_instances;
 	struct quota_info	s_dquot;	/* Diskquota specific options */
 
-	int			s_frozen;
-	wait_queue_head_t	s_wait_unfrozen;
 	struct sb_writers	s_writers;
 
 	char s_id[32];				/* Informational name */
@@ -1585,8 +1582,6 @@ extern struct timespec current_fs_time(struct super_block *sb);
 /*
  * Snapshotting support.
  */
-/* Will go away when all users are converted */
-#define vfs_check_frozen(sb, level) do { } while (0)
 
 void __sb_end_write(struct super_block *sb, int level);
 int __sb_start_write(struct super_block *sb, int level, bool wait);

commit 5accdf82ba25cacefd6c1867f1704beb4d244cdd
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jun 12 16:20:34 2012 +0200

    fs: Improve filesystem freezing handling
    
    vfs_check_frozen() tests are racy since the filesystem can be frozen just after
    the test is performed. Thus in write paths we can end up marking some pages or
    inodes dirty even though the file system is already frozen. This creates
    problems with flusher thread hanging on frozen filesystem.
    
    Another problem is that exclusion between ->page_mkwrite() and filesystem
    freezing has been handled by setting page dirty and then verifying s_frozen.
    This guaranteed that either the freezing code sees the faulted page, writes it,
    and writeprotects it again or we see s_frozen set and bail out of page fault.
    This works to protect from page being marked writeable while filesystem
    freezing is running but has an unpleasant artefact of leaving dirty (although
    unmodified and writeprotected) pages on frozen filesystem resulting in similar
    problems with flusher thread as the first problem.
    
    This patch aims at providing exclusion between write paths and filesystem
    freezing. We implement a writer-freeze read-write semaphore in the superblock.
    Actually, there are three such semaphores because of lock ranking reasons - one
    for page fault handlers (->page_mkwrite), one for all other writers, and one of
    internal filesystem purposes (used e.g. to track running transactions).  Write
    paths which should block freezing (e.g. directory operations, ->aio_write(),
    ->page_mkwrite) hold reader side of the semaphore. Code freezing the filesystem
    takes the writer side.
    
    Only that we don't really want to bounce cachelines of the semaphores between
    CPUs for each write happening. So we implement the reader side of the semaphore
    as a per-cpu counter and the writer side is implemented using s_writers.frozen
    superblock field.
    
    [AV: microoptimize sb_start_write(); we want it fast in normal case]
    
    BugLink: https://bugs.launchpad.net/bugs/897421
    Tested-by: Kamal Mostafa <kamal@canonical.com>
    Tested-by: Peter M. Petrakis <peter.petrakis@canonical.com>
    Tested-by: Dann Frazier <dann.frazier@canonical.com>
    Tested-by: Massimo Morana <massimo.morana@canonical.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 80c819cbe272..aefed9426b03 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -412,6 +412,7 @@ struct inodes_stat_t {
 #include <linux/shrinker.h>
 #include <linux/migrate_mode.h>
 #include <linux/uidgid.h>
+#include <linux/lockdep.h>
 
 #include <asm/byteorder.h>
 
@@ -1439,6 +1440,8 @@ extern void f_delown(struct file *filp);
 extern pid_t f_getown(struct file *filp);
 extern int send_sigurg(struct fown_struct *fown);
 
+struct mm_struct;
+
 /*
  *	Umount options
  */
@@ -1452,6 +1455,32 @@ extern int send_sigurg(struct fown_struct *fown);
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
 
+/* Possible states of 'frozen' field */
+enum {
+	SB_UNFROZEN = 0,		/* FS is unfrozen */
+	SB_FREEZE_WRITE	= 1,		/* Writes, dir ops, ioctls frozen */
+	SB_FREEZE_TRANS = 2,
+	SB_FREEZE_PAGEFAULT = 2,	/* Page faults stopped as well */
+	SB_FREEZE_FS = 3,		/* For internal FS use (e.g. to stop
+					 * internal threads if needed) */
+	SB_FREEZE_COMPLETE = 4,		/* ->freeze_fs finished successfully */
+};
+
+#define SB_FREEZE_LEVELS (SB_FREEZE_COMPLETE - 1)
+
+struct sb_writers {
+	/* Counters for counting writers at each level */
+	struct percpu_counter	counter[SB_FREEZE_LEVELS];
+	wait_queue_head_t	wait;		/* queue for waiting for
+						   writers / faults to finish */
+	int			frozen;		/* Is sb frozen? */
+	wait_queue_head_t	wait_unfrozen;	/* queue for waiting for
+						   sb to be thawed */
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+	struct lockdep_map	lock_map[SB_FREEZE_LEVELS];
+#endif
+};
+
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */
 	dev_t			s_dev;		/* search index; _not_ kdev_t */
@@ -1501,6 +1530,7 @@ struct super_block {
 
 	int			s_frozen;
 	wait_queue_head_t	s_wait_unfrozen;
+	struct sb_writers	s_writers;
 
 	char s_id[32];				/* Informational name */
 	u8 s_uuid[16];				/* UUID */
@@ -1555,14 +1585,119 @@ extern struct timespec current_fs_time(struct super_block *sb);
 /*
  * Snapshotting support.
  */
-enum {
-	SB_UNFROZEN = 0,
-	SB_FREEZE_WRITE	= 1,
-	SB_FREEZE_TRANS = 2,
-};
+/* Will go away when all users are converted */
+#define vfs_check_frozen(sb, level) do { } while (0)
+
+void __sb_end_write(struct super_block *sb, int level);
+int __sb_start_write(struct super_block *sb, int level, bool wait);
+
+/**
+ * sb_end_write - drop write access to a superblock
+ * @sb: the super we wrote to
+ *
+ * Decrement number of writers to the filesystem. Wake up possible waiters
+ * wanting to freeze the filesystem.
+ */
+static inline void sb_end_write(struct super_block *sb)
+{
+	__sb_end_write(sb, SB_FREEZE_WRITE);
+}
+
+/**
+ * sb_end_pagefault - drop write access to a superblock from a page fault
+ * @sb: the super we wrote to
+ *
+ * Decrement number of processes handling write page fault to the filesystem.
+ * Wake up possible waiters wanting to freeze the filesystem.
+ */
+static inline void sb_end_pagefault(struct super_block *sb)
+{
+	__sb_end_write(sb, SB_FREEZE_PAGEFAULT);
+}
+
+/**
+ * sb_end_intwrite - drop write access to a superblock for internal fs purposes
+ * @sb: the super we wrote to
+ *
+ * Decrement fs-internal number of writers to the filesystem.  Wake up possible
+ * waiters wanting to freeze the filesystem.
+ */
+static inline void sb_end_intwrite(struct super_block *sb)
+{
+	__sb_end_write(sb, SB_FREEZE_FS);
+}
+
+/**
+ * sb_start_write - get write access to a superblock
+ * @sb: the super we write to
+ *
+ * When a process wants to write data or metadata to a file system (i.e. dirty
+ * a page or an inode), it should embed the operation in a sb_start_write() -
+ * sb_end_write() pair to get exclusion against file system freezing. This
+ * function increments number of writers preventing freezing. If the file
+ * system is already frozen, the function waits until the file system is
+ * thawed.
+ *
+ * Since freeze protection behaves as a lock, users have to preserve
+ * ordering of freeze protection and other filesystem locks. Generally,
+ * freeze protection should be the outermost lock. In particular, we have:
+ *
+ * sb_start_write
+ *   -> i_mutex			(write path, truncate, directory ops, ...)
+ *   -> s_umount		(freeze_super, thaw_super)
+ */
+static inline void sb_start_write(struct super_block *sb)
+{
+	__sb_start_write(sb, SB_FREEZE_WRITE, true);
+}
+
+static inline int sb_start_write_trylock(struct super_block *sb)
+{
+	return __sb_start_write(sb, SB_FREEZE_WRITE, false);
+}
+
+/**
+ * sb_start_pagefault - get write access to a superblock from a page fault
+ * @sb: the super we write to
+ *
+ * When a process starts handling write page fault, it should embed the
+ * operation into sb_start_pagefault() - sb_end_pagefault() pair to get
+ * exclusion against file system freezing. This is needed since the page fault
+ * is going to dirty a page. This function increments number of running page
+ * faults preventing freezing. If the file system is already frozen, the
+ * function waits until the file system is thawed.
+ *
+ * Since page fault freeze protection behaves as a lock, users have to preserve
+ * ordering of freeze protection and other filesystem locks. It is advised to
+ * put sb_start_pagefault() close to mmap_sem in lock ordering. Page fault
+ * handling code implies lock dependency:
+ *
+ * mmap_sem
+ *   -> sb_start_pagefault
+ */
+static inline void sb_start_pagefault(struct super_block *sb)
+{
+	__sb_start_write(sb, SB_FREEZE_PAGEFAULT, true);
+}
+
+/*
+ * sb_start_intwrite - get write access to a superblock for internal fs purposes
+ * @sb: the super we write to
+ *
+ * This is the third level of protection against filesystem freezing. It is
+ * free for use by a filesystem. The only requirement is that it must rank
+ * below sb_start_pagefault.
+ *
+ * For example filesystem can call sb_start_intwrite() when starting a
+ * transaction which somewhat eases handling of freezing for internal sources
+ * of filesystem changes (internal fs threads, discarding preallocation on file
+ * close, etc.).
+ */
+static inline void sb_start_intwrite(struct super_block *sb)
+{
+	__sb_start_write(sb, SB_FREEZE_FS, true);
+}
 
-#define vfs_check_frozen(sb, level) \
-	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
 
 extern bool inode_owner_or_capable(const struct inode *inode);
 
@@ -1886,6 +2021,7 @@ struct file_system_type {
 	struct lock_class_key s_lock_key;
 	struct lock_class_key s_umount_key;
 	struct lock_class_key s_vfs_rename_key;
+	struct lock_class_key s_writers_key[SB_FREEZE_LEVELS];
 
 	struct lock_class_key i_lock_key;
 	struct lock_class_key i_mutex_key;

commit 800179c9b8a1e796e441674776d11cd4c05d61d7
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 25 17:29:07 2012 -0700

    fs: add link restrictions
    
    This adds symlink and hardlink restrictions to the Linux VFS.
    
    Symlinks:
    
    A long-standing class of security issues is the symlink-based
    time-of-check-time-of-use race, most commonly seen in world-writable
    directories like /tmp. The common method of exploitation of this flaw
    is to cross privilege boundaries when following a given symlink (i.e. a
    root process follows a symlink belonging to another user). For a likely
    incomplete list of hundreds of examples across the years, please see:
    http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=/tmp
    
    The solution is to permit symlinks to only be followed when outside
    a sticky world-writable directory, or when the uid of the symlink and
    follower match, or when the directory owner matches the symlink's owner.
    
    Some pointers to the history of earlier discussion that I could find:
    
     1996 Aug, Zygo Blaxell
      http://marc.info/?l=bugtraq&m=87602167419830&w=2
     1996 Oct, Andrew Tridgell
      http://lkml.indiana.edu/hypermail/linux/kernel/9610.2/0086.html
     1997 Dec, Albert D Cahalan
      http://lkml.org/lkml/1997/12/16/4
     2005 Feb, Lorenzo Hernndez Garca-Hierro
      http://lkml.indiana.edu/hypermail/linux/kernel/0502.0/1896.html
     2010 May, Kees Cook
      https://lkml.org/lkml/2010/5/30/144
    
    Past objections and rebuttals could be summarized as:
    
     - Violates POSIX.
       - POSIX didn't consider this situation and it's not useful to follow
         a broken specification at the cost of security.
     - Might break unknown applications that use this feature.
       - Applications that break because of the change are easy to spot and
         fix. Applications that are vulnerable to symlink ToCToU by not having
         the change aren't. Additionally, no applications have yet been found
         that rely on this behavior.
     - Applications should just use mkstemp() or O_CREATE|O_EXCL.
       - True, but applications are not perfect, and new software is written
         all the time that makes these mistakes; blocking this flaw at the
         kernel is a single solution to the entire class of vulnerability.
     - This should live in the core VFS.
       - This should live in an LSM. (https://lkml.org/lkml/2010/5/31/135)
     - This should live in an LSM.
       - This should live in the core VFS. (https://lkml.org/lkml/2010/8/2/188)
    
    Hardlinks:
    
    On systems that have user-writable directories on the same partition
    as system files, a long-standing class of security issues is the
    hardlink-based time-of-check-time-of-use race, most commonly seen in
    world-writable directories like /tmp. The common method of exploitation
    of this flaw is to cross privilege boundaries when following a given
    hardlink (i.e. a root process follows a hardlink created by another
    user). Additionally, an issue exists where users can "pin" a potentially
    vulnerable setuid/setgid file so that an administrator will not actually
    upgrade a system fully.
    
    The solution is to permit hardlinks to only be created when the user is
    already the existing file's owner, or if they already have read/write
    access to the existing file.
    
    Many Linux users are surprised when they learn they can link to files
    they have no access to, so this change appears to follow the doctrine
    of "least surprise". Additionally, this change does not violate POSIX,
    which states "the implementation may require that the calling process
    has permission to access the existing file"[1].
    
    This change is known to break some implementations of the "at" daemon,
    though the version used by Fedora and Ubuntu has been fixed[2] for
    a while. Otherwise, the change has been undisruptive while in use in
    Ubuntu for the last 1.5 years.
    
    [1] http://pubs.opengroup.org/onlinepubs/9699919799/functions/linkat.html
    [2] http://anonscm.debian.org/gitweb/?p=collab-maint/at.git;a=commitdiff;h=f4114656c3a6c6f6070e315ffdf940a49eda3279
    
    This patch is based on the patches in Openwall and grsecurity, along with
    suggestions from Al Viro. I have added a sysctl to enable the protected
    behavior, and documentation.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 478237844648..80c819cbe272 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -437,6 +437,8 @@ extern unsigned long get_max_files(void);
 extern int sysctl_nr_open;
 extern struct inodes_stat_t inodes_stat;
 extern int leases_enable, lease_break_time;
+extern int sysctl_protected_symlinks;
+extern int sysctl_protected_hardlinks;
 
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,

commit e4fad8e5d220e3dfb1050eee752ee5058f29a232
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 21 15:33:25 2012 +0400

    consolidate pipe file creation
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8fabb037a48d..478237844648 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2326,9 +2326,6 @@ static inline void i_readcount_inc(struct inode *inode)
 }
 #endif
 extern int do_pipe_flags(int *, int);
-extern struct file *create_read_pipe(struct file *f, int flags);
-extern struct file *create_write_pipe(int flags);
-extern void free_write_pipe(struct file *);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern struct file * open_exec(const char *);

commit 5ccb0066f2d561549cc4d73d7f56b4ce3ca7a8a1
Author: Stanislav Kinsbursky <skinsbursky@parallels.com>
Date:   Wed Jul 25 16:57:22 2012 +0400

    LockD: pass actual network namespace to grace period management functions
    
    Passed network namespace replaced hard-coded init_net
    
    Signed-off-by: Stanislav Kinsbursky <skinsbursky@parallels.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 17fd887c798f..a1e77270f5a5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1163,9 +1163,10 @@ struct lock_manager {
 	struct list_head list;
 };
 
-void locks_start_grace(struct lock_manager *);
+struct net;
+void locks_start_grace(struct net *, struct lock_manager *);
 void locks_end_grace(struct lock_manager *);
-int locks_in_grace(void);
+int locks_in_grace(struct net *);
 
 /* that will die - we need it for nfs_lock_info */
 #include <linux/nfs_fs_i.h>

commit 765927b2d508712d320c8934db963bbe14c3fcec
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 26 21:58:53 2012 +0400

    switch dentry_open() to struct path, make it grab references itself
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 34acf51273dd..8fabb037a48d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2060,8 +2060,7 @@ extern long do_sys_open(int dfd, const char __user *filename, int flags,
 extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int);
-extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
-				 const struct cred *);
+extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 enum {

commit e8b96eb5034a0ccebf36760f88e31ea3e3cdf1e4
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Mon Apr 30 13:11:29 2012 -0500

    vfs: allow custom EOF in generic_file_llseek code
    
    For ext3/4 htree directories, using the vfs llseek function with
    SEEK_END goes to i_size like for any other file, but in reality
    we want the maximum possible hash value.  Recent changes
    in ext4 have cut & pasted generic_file_llseek() back into fs/ext4/dir.c,
    but replicating this core code seems like a bad idea, especially
    since the copy has already diverged from the vfs.
    
    This patch updates generic_file_llseek_size to accept
    both a custom maximum offset, and a custom EOF position.  With this
    in place, ext4_dir_llseek can pass in the appropriate maximum hash
    position for both maxsize and eof, and get what it wants.
    
    As far as I know, this does not fix any bugs - nfs in the kernel
    doesn't use SEEK_END, and I don't know of any user who does.  But
    some ext4 folks seem keen on doing the right thing here, and I can't
    really argue.
    
    (Patch also fixes up some comments slightly)
    
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6a6ca85bee23..34acf51273dd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2454,7 +2454,7 @@ extern loff_t noop_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
-		int origin, loff_t maxsize);
+		int origin, loff_t maxsize, loff_t eof);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit 5c0d6b60a0ba46d45020547eacf7199171920935
Author: Jan Kara <jack@suse.cz>
Date:   Tue Jul 3 16:45:31 2012 +0200

    vfs: Create function for iterating over block devices
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 48548bdd7722..6a6ca85bee23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2102,6 +2102,7 @@ extern sector_t blkdev_max_block(struct block_device *bdev);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern void invalidate_bdev(struct block_device *);
+extern void iterate_bdevs(void (*)(struct block_device *, void *), void *);
 extern int sync_blockdev(struct block_device *bdev);
 extern void kill_bdev(struct block_device *);
 extern struct super_block *freeze_bdev(struct block_device *);
@@ -2123,6 +2124,10 @@ static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
 {
 	return 0;
 }
+
+static inline void iterate_bdevs(void (*f)(struct block_device *, void *), void *arg)
+{
+}
 #endif
 extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;

commit 9249e17fe094d853d1ef7475dd559a2cc7e23d42
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jun 25 12:55:37 2012 +0100

    VFS: Pass mount flags to sget()
    
    Pass mount flags to sget() so that it can use them in initialising a new
    superblock before the set function is called.  They could also be passed to the
    compare function.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2f857e9eeb3a..48548bdd7722 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1914,7 +1914,7 @@ void free_anon_bdev(dev_t);
 struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),
-			void *data);
+			int flags, void *data);
 extern struct dentry *mount_pseudo(struct file_system_type *, char *,
 	const struct super_operations *ops,
 	const struct dentry_operations *dops,

commit 312b63fba9e88a0dcf800834b8ede8716bcc1e17
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 18:09:36 2012 -0400

    don't pass nameidata * to vfs_create()
    
    all we want is a boolean flag, same as the method gets now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index df869d248e7c..2f857e9eeb3a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1571,7 +1571,7 @@ extern void unlock_super(struct super_block *);
 /*
  * VFS helper functions..
  */
-extern int vfs_create(struct inode *, struct dentry *, umode_t, struct nameidata *);
+extern int vfs_create(struct inode *, struct dentry *, umode_t, bool);
 extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
 extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);

commit ebfc3b49a7ac25920cb5be5445f602e51d2ea559
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 18:05:36 2012 -0400

    don't pass nameidata to ->create()
    
    boolean "does it have to be exclusive?" flag is passed instead;
    Local filesystem should just ignore it - the object is guaranteed
    not to be there yet.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a71709b7fa7..df869d248e7c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1674,7 +1674,7 @@ struct inode_operations {
 	int (*readlink) (struct dentry *, char __user *,int);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
 
-	int (*create) (struct inode *,struct dentry *,umode_t,struct nameidata *);
+	int (*create) (struct inode *,struct dentry *, umode_t, bool);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);

commit 00cd8dd3bf95f2cc8435b4cac01d9995635c6d0b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 17:13:09 2012 -0400

    stop passing nameidata to ->lookup()
    
    Just the flags; only NFS cares even about that, but there are
    legitimate uses for such argument.  And getting rid of that
    completely would require splitting ->lookup() into a couple
    of methods (at least), so let's leave that alone for now...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 17ee20dba86c..7a71709b7fa7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1666,7 +1666,7 @@ struct file_operations {
 };
 
 struct inode_operations {
-	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
 	void * (*follow_link) (struct dentry *, struct nameidata *);
 	int (*permission) (struct inode *, int);
 	struct posix_acl * (*get_acl)(struct inode *, int);
@@ -2571,7 +2571,7 @@ extern int simple_write_end(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned copied,
 			struct page *page, void *fsdata);
 
-extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned int flags);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
 extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;

commit e45198a6ac24bd2c4ad4a43b670c2f1a23dd2df3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 06:48:09 2012 -0400

    make finish_no_open() return int
    
    namely, 1 ;-)  That's what we want to return from ->atomic_open()
    instances after finish_no_open().
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1dcc75c95763..17ee20dba86c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2071,7 +2071,7 @@ enum {
 extern int finish_open(struct file *file, struct dentry *dentry,
 			int (*open)(struct inode *, struct file *),
 			int *opened);
-extern void finish_no_open(struct file *file, struct dentry *dentry);
+extern int finish_no_open(struct file *file, struct dentry *dentry);
 
 /* fs/ioctl.c */
 

commit 30d904947459cca2beb69e0110716f5248b31f2a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 22 12:40:19 2012 +0400

    kill struct opendata
    
    Just pass struct file *.  Methods are happier that way...
    There's no need to return struct file * from finish_open() now,
    so let it return int.  Next: saner prototypes for parts in
    namei.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 33bda922988a..1dcc75c95763 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -427,7 +427,6 @@ struct kstatfs;
 struct vm_area_struct;
 struct vfsmount;
 struct cred;
-struct opendata;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -1695,7 +1694,7 @@ struct inode_operations {
 		      u64 len);
 	int (*update_time)(struct inode *, struct timespec *, int);
 	int (*atomic_open)(struct inode *, struct dentry *,
-			   struct opendata *, unsigned open_flag,
+			   struct file *, unsigned open_flag,
 			   umode_t create_mode, int *opened);
 } ____cacheline_aligned;
 
@@ -2069,10 +2068,10 @@ enum {
 	FILE_CREATED = 1,
 	FILE_OPENED = 2
 };
-extern struct file *finish_open(struct opendata *od, struct dentry *dentry,
-				int (*open)(struct inode *, struct file *),
-				int *opened);
-extern void finish_no_open(struct opendata *od, struct dentry *dentry);
+extern int finish_open(struct file *file, struct dentry *dentry,
+			int (*open)(struct inode *, struct file *),
+			int *opened);
+extern void finish_no_open(struct file *file, struct dentry *dentry);
 
 /* fs/ioctl.c */
 

commit d95852777bc8ba6b3ad3397d495c5f9dd8ca8383
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 22 12:39:14 2012 +0400

    make ->atomic_open() return int
    
    Change of calling conventions:
    old             new
    NULL            1
    file            0
    ERR_PTR(-ve)    -ve
    
    Caller *knows* that struct file *; no need to return it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a7618cf28d0e..33bda922988a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1694,9 +1694,9 @@ struct inode_operations {
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
 	int (*update_time)(struct inode *, struct timespec *, int);
-	struct file * (*atomic_open)(struct inode *, struct dentry *,
-				     struct opendata *, unsigned open_flag,
-				     umode_t create_mode, int *opened);
+	int (*atomic_open)(struct inode *, struct dentry *,
+			   struct opendata *, unsigned open_flag,
+			   umode_t create_mode, int *opened);
 } ____cacheline_aligned;
 
 struct seq_file;

commit 47237687d73cbeae1dd7a133c3fc3d7239094568
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 10 05:01:45 2012 -0400

    ->atomic_open() prototype change - pass int * instead of bool *
    
    ... and let finish_open() report having opened the file via that sucker.
    Next step: don't modify od->filp at all.
    
    [AV: FILE_CREATE was already used by cifs; Miklos' fix folded]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0314635cf833..a7618cf28d0e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1696,7 +1696,7 @@ struct inode_operations {
 	int (*update_time)(struct inode *, struct timespec *, int);
 	struct file * (*atomic_open)(struct inode *, struct dentry *,
 				     struct opendata *, unsigned open_flag,
-				     umode_t create_mode, bool *created);
+				     umode_t create_mode, int *opened);
 } ____cacheline_aligned;
 
 struct seq_file;
@@ -2065,8 +2065,13 @@ extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
 				 const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
+enum {
+	FILE_CREATED = 1,
+	FILE_OPENED = 2
+};
 extern struct file *finish_open(struct opendata *od, struct dentry *dentry,
-				int (*open)(struct inode *, struct file *));
+				int (*open)(struct inode *, struct file *),
+				int *opened);
 extern void finish_no_open(struct opendata *od, struct dentry *dentry);
 
 /* fs/ioctl.c */

commit d18e9008c377dc6a6d2166a6840bf3a23a5867fd
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 5 15:10:17 2012 +0200

    vfs: add i_op->atomic_open()
    
    Add a new inode operation which is called on the last component of an open.
    Using this the filesystem can look up, possibly create and open the file in one
    atomic operation.  If it cannot perform this (e.g. the file type turned out to
    be wrong) it may signal this by returning NULL instead of an open struct file
    pointer.
    
    i_op->atomic_open() is only called if the last component is negative or needs
    lookup.  Handling cached positive dentries here doesn't add much value: these
    can be opened using f_op->open().  If the cached file turns out to be invalid,
    the open can be retried, this time using ->atomic_open() with a fresh dentry.
    
    For now leave the old way of using open intents in lookup and revalidate in
    place.  This will be removed once all the users are converted.
    
    David Howells noticed that if ->atomic_open() opens the file but does not create
    it, handle_truncate() will be called on it even if it is not a regular file.
    Fix this by checking the file type in this case too.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f06db6bd5a74..0314635cf833 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -427,6 +427,7 @@ struct kstatfs;
 struct vm_area_struct;
 struct vfsmount;
 struct cred;
+struct opendata;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -1693,6 +1694,9 @@ struct inode_operations {
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
 	int (*update_time)(struct inode *, struct timespec *, int);
+	struct file * (*atomic_open)(struct inode *, struct dentry *,
+				     struct opendata *, unsigned open_flag,
+				     umode_t create_mode, bool *created);
 } ____cacheline_aligned;
 
 struct seq_file;
@@ -2061,6 +2065,9 @@ extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
 				 const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
+extern struct file *finish_open(struct opendata *od, struct dentry *dentry,
+				int (*open)(struct inode *, struct file *));
+extern void finish_no_open(struct opendata *od, struct dentry *dentry);
 
 /* fs/ioctl.c */
 

commit b3d9b7a3c752dc4b6976a4ff7b8298887a5b734d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jun 9 13:51:19 2012 -0400

    vfs: switch i_dentry/d_alias to hlist
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 17fd887c798f..f06db6bd5a74 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -826,7 +826,7 @@ struct inode {
 	struct list_head	i_lru;		/* inode LRU list */
 	struct list_head	i_sb_list;
 	union {
-		struct list_head	i_dentry;
+		struct hlist_head	i_dentry;
 		struct rcu_head		i_rcu;
 	};
 	u64			i_version;

commit 2f9d3df8aa1cc3c6db5cfa0bad3f0745e04cc27d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 3 14:50:19 2012 -0700

    vfs: move inode stat information closer together
    
    The comment above it says "Stat data, not accessed from path walking",
    but in fact some of inode fields we use for the common stat data was way
    down at the end of the inode, causing unnecessary cache misses for the
    common stat operations.
    
    The inode structure is pretty big, and this can change padding depending
    on field width, but at least on the common 64-bit configurations this
    doesn't change the size.  Some of our inode layout has historically been
    to tro to avoid unnecessary padding fields, but cache locality is at
    least as important for layout, if not more.
    
    Noticed by looking at kernel profiles, and noticing that the "i_blkbits"
    access stood out like a sore thumb.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51978ed43e97..17fd887c798f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -802,13 +802,14 @@ struct inode {
 		unsigned int __i_nlink;
 	};
 	dev_t			i_rdev;
+	loff_t			i_size;
 	struct timespec		i_atime;
 	struct timespec		i_mtime;
 	struct timespec		i_ctime;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	unsigned short          i_bytes;
+	unsigned int		i_blkbits;
 	blkcnt_t		i_blocks;
-	loff_t			i_size;
 
 #ifdef __NEED_I_SIZE_ORDERED
 	seqcount_t		i_size_seqcount;
@@ -828,9 +829,8 @@ struct inode {
 		struct list_head	i_dentry;
 		struct rcu_head		i_rcu;
 	};
-	atomic_t		i_count;
-	unsigned int		i_blkbits;
 	u64			i_version;
+	atomic_t		i_count;
 	atomic_t		i_dio_count;
 	atomic_t		i_writecount;
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */

commit 1193755ac6328ad240ba987e6ec41d5e8baf0680
Merge: 4edebed86690 0ef97dcfce41
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 1 10:34:35 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs changes from Al Viro.
     "A lot of misc stuff.  The obvious groups:
       * Miklos' atomic_open series; kills the damn abuse of
         ->d_revalidate() by NFS, which was the major stumbling block for
         all work in that area.
       * ripping security_file_mmap() and dealing with deadlocks in the
         area; sanitizing the neighborhood of vm_mmap()/vm_munmap() in
         general.
       * ->encode_fh() switched to saner API; insane fake dentry in
         mm/cleancache.c gone.
       * assorted annotations in fs (endianness, __user)
       * parts of Artem's ->s_dirty work (jff2 and reiserfs parts)
       * ->update_time() work from Josef.
       * other bits and pieces all over the place.
    
      Normally it would've been in two or three pull requests, but
      signal.git stuff had eaten a lot of time during this cycle ;-/"
    
    Fix up trivial conflicts in Documentation/filesystems/vfs.txt (the
    'truncate_range' inode method was removed by the VM changes, the VFS
    update adds an 'update_time()' method), and in fs/btrfs/ulist.[ch] (due
    to sparse fix added twice, with other changes nearby).
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (95 commits)
      nfs: don't open in ->d_revalidate
      vfs: retry last component if opening stale dentry
      vfs: nameidata_to_filp(): don't throw away file on error
      vfs: nameidata_to_filp(): inline __dentry_open()
      vfs: do_dentry_open(): don't put filp
      vfs: split __dentry_open()
      vfs: do_last() common post lookup
      vfs: do_last(): add audit_inode before open
      vfs: do_last(): only return EISDIR for O_CREAT
      vfs: do_last(): check LOOKUP_DIRECTORY
      vfs: do_last(): make ENOENT exit RCU safe
      vfs: make follow_link check RCU safe
      vfs: do_last(): use inode variable
      vfs: do_last(): inline walk_component()
      vfs: do_last(): make exit RCU safe
      vfs: split do_lookup()
      Btrfs: move over to use ->update_time
      fs: introduce inode operation ->update_time
      reiserfs: get rid of resierfs_sync_super
      reiserfs: mark the superblock as dirty a bit later
      ...

commit c3b2da314834499f34cba94f7053e55f6d6f92d8
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Mar 26 09:59:21 2012 -0400

    fs: introduce inode operation ->update_time
    
    Btrfs has to make sure we have space to allocate new blocks in order to modify
    the inode, so updating time can fail.  We've gotten around this by having our
    own file_update_time but this is kind of a pain, and Christoph has indicated he
    would like to make xfs do something different with atime updates.  So introduce
    ->update_time, where we will deal with i_version an a/m/c time updates and
    indicate which changes need to be made.  The normal version just does what it
    has always done, updates the time and marks the inode dirty, and then
    filesystems can choose to do something different.
    
    I've gone through all of the users of file_update_time and made them check for
    errors with the exception of the fault code since it's complicated and I wasn't
    quite sure what to do there, also Jan is going to be pushing the file time
    updates into page_mkwrite for those who have it so that should satisfy btrfs and
    make it not a big deal to check the file_update_time() return code in the
    generic fault path. Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cdc1a9630948..57fc70574d20 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1684,6 +1684,7 @@ struct inode_operations {
 	void (*truncate_range)(struct inode *, loff_t, loff_t);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
+	int (*update_time)(struct inode *, struct timespec *, int);
 } ____cacheline_aligned;
 
 struct seq_file;
@@ -1843,6 +1844,13 @@ static inline void inode_inc_iversion(struct inode *inode)
        spin_unlock(&inode->i_lock);
 }
 
+enum file_time_flags {
+	S_ATIME = 1,
+	S_MTIME = 2,
+	S_CTIME = 4,
+	S_VERSION = 8,
+};
+
 extern void touch_atime(struct path *);
 static inline void file_accessed(struct file *file)
 {
@@ -2579,7 +2587,7 @@ extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
-extern void file_update_time(struct file *file);
+extern int file_update_time(struct file *file);
 
 extern int generic_show_options(struct seq_file *m, struct dentry *root);
 extern void save_mount_options(struct super_block *sb, char *options);

commit 08615d7d85e5aa02c05bf6c4dde87d940e7f85f6
Merge: 9fdadb2cbaf4 0a4dd35c67b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 31 18:10:18 2012 -0700

    Merge branch 'akpm' (Andrew's patch-bomb)
    
    Merge misc patches from Andrew Morton:
    
     - the "misc" tree - stuff from all over the map
    
     - checkpatch updates
    
     - fatfs
    
     - kmod changes
    
     - procfs
    
     - cpumask
    
     - UML
    
     - kexec
    
     - mqueue
    
     - rapidio
    
     - pidns
    
     - some checkpoint-restore feature work.  Reluctantly.  Most of it
       delayed a release.  I'm still rather worried that we don't have a
       clear roadmap to completion for this work.
    
    * emailed from Andrew Morton <akpm@linux-foundation.org>: (78 patches)
      kconfig: update compression algorithm info
      c/r: prctl: add ability to set new mm_struct::exe_file
      c/r: prctl: extend PR_SET_MM to set up more mm_struct entries
      c/r: procfs: add arg_start/end, env_start/end and exit_code members to /proc/$pid/stat
      syscalls, x86: add __NR_kcmp syscall
      fs, proc: introduce /proc/<pid>/task/<tid>/children entry
      sysctl: make kernel.ns_last_pid control dependent on CHECKPOINT_RESTORE
      aio/vfs: cleanup of rw_copy_check_uvector() and compat_rw_copy_check_uvector()
      eventfd: change int to __u64 in eventfd_signal()
      fs/nls: add Apple NLS
      pidns: make killed children autoreap
      pidns: use task_active_pid_ns in do_notify_parent
      rapidio/tsi721: add DMA engine support
      rapidio: add DMA engine support for RIO data transfers
      ipc/mqueue: add rbtree node caching support
      tools/selftests: add mq_perf_tests
      ipc/mqueue: strengthen checks on mqueue creation
      ipc/mqueue: correct mq_attr_ok test
      ipc/mqueue: improve performance of send/recv
      selftests: add mq_open_tests
      ...

commit ac34ebb3a67e699edcb5ac72f19d31679369dfaa
Author: Christopher Yeoh <cyeoh@au1.ibm.com>
Date:   Thu May 31 16:26:42 2012 -0700

    aio/vfs: cleanup of rw_copy_check_uvector() and compat_rw_copy_check_uvector()
    
    A cleanup of rw_copy_check_uvector and compat_rw_copy_check_uvector after
    changes made to support CMA in an earlier patch.
    
    Rather than having an additional check_access parameter to these
    functions, the first paramater type is overloaded to allow the caller to
    specify CHECK_IOVEC_ONLY which means check that the contents of the iovec
    are valid, but do not check the memory that they point to.  This is used
    by process_vm_readv/writev where we need to validate that a iovec passed
    to the syscall is valid but do not want to check the memory that it points
    to at this point because it refers to an address space in another process.
    
    Signed-off-by: Chris Yeoh <yeohc@au1.ibm.com>
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 038076b27ea4..cf2c5611b19b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -173,6 +173,15 @@ struct inodes_stat_t {
 #define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)
 #define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
 
+
+/*
+ * Flag for rw_copy_check_uvector and compat_rw_copy_check_uvector
+ * that indicates that they should check the contents of the iovec are
+ * valid, but not check the memory that the iovec elements
+ * points too.
+ */
+#define CHECK_IOVEC_ONLY -1
+
 #define SEL_IN		1
 #define SEL_OUT		2
 #define SEL_EX		4
@@ -1690,8 +1699,7 @@ struct seq_file;
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,
-			      struct iovec **ret_pointer,
-			      int check_access);
+			      struct iovec **ret_pointer);
 
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);

commit 1d59d61f606547f0712aa6971f91f71154071c99
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu May 31 12:22:33 2012 -0400

    NFS: Ensure that setattr and getattr wait for O_DIRECT write completion
    
    Use the same mechanism as the block devices are using, but move the
    helper functions from fs/direct-io.c into fs/inode.c to remove the
    dependency on CONFIG_BLOCK.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Fred Isaman <iisaman@netapp.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 038076b27ea4..598a5892ff2b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2453,8 +2453,6 @@ enum {
 };
 
 void dio_end_io(struct bio *bio, int error);
-void inode_dio_wait(struct inode *inode);
-void inode_dio_done(struct inode *inode);
 
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
@@ -2469,12 +2467,11 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 				    offset, nr_segs, get_block, NULL, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
-#else
-static inline void inode_dio_wait(struct inode *inode)
-{
-}
 #endif
 
+void inode_dio_wait(struct inode *inode);
+void inode_dio_done(struct inode *inode);
+
 extern const struct file_operations generic_ro_fops;
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))

commit 17cf28afea2a1112f240a3a2da8af883be024811
Author: Hugh Dickins <hughd@google.com>
Date:   Tue May 29 15:06:41 2012 -0700

    mm/fs: remove truncate_range
    
    Remove vmtruncate_range(), and remove the truncate_range method from
    struct inode_operations: only tmpfs ever supported it, and tmpfs has now
    converted over to using the fallocate method of file_operations.
    
    Update Documentation accordingly, adding (setlease and) fallocate lines.
    And while we're in mm.h, remove duplicate declarations of shmem_lock() and
    shmem_file_setup(): everyone is now using the ones in shmem_fs.h.
    
    Based-on-patch-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: Hugh Dickins <hughd@google.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Cong Wang <amwang@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cdc1a9630948..038076b27ea4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1681,7 +1681,6 @@ struct inode_operations {
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*removexattr) (struct dentry *, const char *);
-	void (*truncate_range)(struct inode *, loff_t, loff_t);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
 } ____cacheline_aligned;

commit 90324cc1b11a211e37eabd8cb863e1a1561d6b1d
Merge: fb8b00675eb6 169ebd90131b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 28 09:54:45 2012 -0700

    Merge tag 'writeback' of git://git.kernel.org/pub/scm/linux/kernel/git/wfg/linux
    
    Pull writeback tree from Wu Fengguang:
     "Mainly from Jan Kara to avoid iput() in the flusher threads."
    
    * tag 'writeback' of git://git.kernel.org/pub/scm/linux/kernel/git/wfg/linux:
      writeback: Avoid iput() from flusher thread
      vfs: Rename end_writeback() to clear_inode()
      vfs: Move waiting for inode writeback from end_writeback() to evict_inode()
      writeback: Refactor writeback_single_inode()
      writeback: Remove wb->list_lock from writeback_single_inode()
      writeback: Separate inode requeueing after writeback
      writeback: Move I_DIRTY_PAGES handling
      writeback: Move requeueing when I_SYNC set to writeback_sb_inodes()
      writeback: Move clearing of I_SYNC into inode_sync_complete()
      writeback: initialize global_dirty_limit
      fs: remove 8 bytes of padding from struct writeback_control on 64 bit builds
      mm: page-writeback.c: local functions should not be exposed globally

commit 644473e9c60c1ff4f6351fed637a6e5551e3dce7
Merge: fb827ec68446 4b06a81f1dae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 23 17:42:39 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace
    
    Pull user namespace enhancements from Eric Biederman:
     "This is a course correction for the user namespace, so that we can
      reach an inexpensive, maintainable, and reasonably complete
      implementation.
    
      Highlights:
       - Config guards make it impossible to enable the user namespace and
         code that has not been converted to be user namespace safe.
    
       - Use of the new kuid_t type ensures the if you somehow get past the
         config guards the kernel will encounter type errors if you enable
         user namespaces and attempt to compile in code whose permission
         checks have not been updated to be user namespace safe.
    
       - All uids from child user namespaces are mapped into the initial
         user namespace before they are processed.  Removing the need to add
         an additional check to see if the user namespace of the compared
         uids remains the same.
    
       - With the user namespaces compiled out the performance is as good or
         better than it is today.
    
       - For most operations absolutely nothing changes performance or
         operationally with the user namespace enabled.
    
       - The worst case performance I could come up with was timing 1
         billion cache cold stat operations with the user namespace code
         enabled.  This went from 156s to 164s on my laptop (or 156ns to
         164ns per stat operation).
    
       - (uid_t)-1 and (gid_t)-1 are reserved as an internal error value.
         Most uid/gid setting system calls treat these value specially
         anyway so attempting to use -1 as a uid would likely cause
         entertaining failures in userspace.
    
       - If setuid is called with a uid that can not be mapped setuid fails.
         I have looked at sendmail, login, ssh and every other program I
         could think of that would call setuid and they all check for and
         handle the case where setuid fails.
    
       - If stat or a similar system call is called from a context in which
         we can not map a uid we lie and return overflowuid.  The LFS
         experience suggests not lying and returning an error code might be
         better, but the historical precedent with uids is different and I
         can not think of anything that would break by lying about a uid we
         can't map.
    
       - Capabilities are localized to the current user namespace making it
         safe to give the initial user in a user namespace all capabilities.
    
      My git tree covers all of the modifications needed to convert the core
      kernel and enough changes to make a system bootable to runlevel 1."
    
    Fix up trivial conflicts due to nearby independent changes in fs/stat.c
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/ebiederm/user-namespace: (46 commits)
      userns:  Silence silly gcc warning.
      cred: use correct cred accessor with regards to rcu read lock
      userns: Convert the move_pages, and migrate_pages permission checks to use uid_eq
      userns: Convert cgroup permission checks to use uid_eq
      userns: Convert tmpfs to use kuid and kgid where appropriate
      userns: Convert sysfs to use kgid/kuid where appropriate
      userns: Convert sysctl permission checks to use kuid and kgids.
      userns: Convert proc to use kuid/kgid where appropriate
      userns: Convert ext4 to user kuid/kgid where appropriate
      userns: Convert ext3 to use kuid/kgid where appropriate
      userns: Convert ext2 to use kuid/kgid where appropriate.
      userns: Convert devpts to use kuid/kgid where appropriate
      userns: Convert binary formats to use kuid/kgid where appropriate
      userns: Add negative depends on entries to avoid building code that is userns unsafe
      userns: signal remove unnecessary map_cred_ns
      userns: Teach inode_capable to understand inodes whose uids map to other namespaces.
      userns: Fail exec for suid and sgid binaries with ids outside our user namespace.
      userns: Convert stat to return values mapped from kuids and kgids
      userns: Convert user specfied uids and gids in chown into kuids and kgid
      userns: Use uid_eq gid_eq helpers when comparing kuids and kgids in the vfs
      ...

commit 080399aaaf3531f5b8761ec0ac30ff98891e8686
Author: Jeff Moyer <jmoyer@redhat.com>
Date:   Fri May 11 16:34:10 2012 +0200

    block: don't mark buffers beyond end of disk as mapped
    
    Hi,
    
    We have a bug report open where a squashfs image mounted on ppc64 would
    exhibit errors due to trying to read beyond the end of the disk.  It can
    easily be reproduced by doing the following:
    
    [root@ibm-p750e-02-lp3 ~]# ls -l install.img
    -rw-r--r-- 1 root root 142032896 Apr 30 16:46 install.img
    [root@ibm-p750e-02-lp3 ~]# mount -o loop ./install.img /mnt/test
    [root@ibm-p750e-02-lp3 ~]# dd if=/dev/loop0 of=/dev/null
    dd: reading `/dev/loop0': Input/output error
    277376+0 records in
    277376+0 records out
    142016512 bytes (142 MB) copied, 0.9465 s, 150 MB/s
    
    In dmesg, you'll find the following:
    
    squashfs: version 4.0 (2009/01/31) Phillip Lougher
    [   43.106012] attempt to access beyond end of device
    [   43.106029] loop0: rw=0, want=277410, limit=277408
    [   43.106039] Buffer I/O error on device loop0, logical block 138704
    [   43.106053] attempt to access beyond end of device
    [   43.106057] loop0: rw=0, want=277412, limit=277408
    [   43.106061] Buffer I/O error on device loop0, logical block 138705
    [   43.106066] attempt to access beyond end of device
    [   43.106070] loop0: rw=0, want=277414, limit=277408
    [   43.106073] Buffer I/O error on device loop0, logical block 138706
    [   43.106078] attempt to access beyond end of device
    [   43.106081] loop0: rw=0, want=277416, limit=277408
    [   43.106085] Buffer I/O error on device loop0, logical block 138707
    [   43.106089] attempt to access beyond end of device
    [   43.106093] loop0: rw=0, want=277418, limit=277408
    [   43.106096] Buffer I/O error on device loop0, logical block 138708
    [   43.106101] attempt to access beyond end of device
    [   43.106104] loop0: rw=0, want=277420, limit=277408
    [   43.106108] Buffer I/O error on device loop0, logical block 138709
    [   43.106112] attempt to access beyond end of device
    [   43.106116] loop0: rw=0, want=277422, limit=277408
    [   43.106120] Buffer I/O error on device loop0, logical block 138710
    [   43.106124] attempt to access beyond end of device
    [   43.106128] loop0: rw=0, want=277424, limit=277408
    [   43.106131] Buffer I/O error on device loop0, logical block 138711
    [   43.106135] attempt to access beyond end of device
    [   43.106139] loop0: rw=0, want=277426, limit=277408
    [   43.106143] Buffer I/O error on device loop0, logical block 138712
    [   43.106147] attempt to access beyond end of device
    [   43.106151] loop0: rw=0, want=277428, limit=277408
    [   43.106154] Buffer I/O error on device loop0, logical block 138713
    [   43.106158] attempt to access beyond end of device
    [   43.106162] loop0: rw=0, want=277430, limit=277408
    [   43.106166] attempt to access beyond end of device
    [   43.106169] loop0: rw=0, want=277432, limit=277408
    ...
    [   43.106307] attempt to access beyond end of device
    [   43.106311] loop0: rw=0, want=277470, limit=2774
    
    Squashfs manages to read in the end block(s) of the disk during the
    mount operation.  Then, when dd reads the block device, it leads to
    block_read_full_page being called with buffers that are beyond end of
    disk, but are marked as mapped.  Thus, it would end up submitting read
    I/O against them, resulting in the errors mentioned above.  I fixed the
    problem by modifying init_page_buffers to only set the buffer mapped if
    it fell inside of i_size.
    
    Cheers,
    Jeff
    
    Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
    Acked-by: Nick Piggin <npiggin@kernel.dk>
    
    --
    
    Changes from v1->v2: re-used max_block, as suggested by Nick Piggin.
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8de675523e46..25c40b9f848a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2051,6 +2051,7 @@ extern void unregister_blkdev(unsigned int, const char *);
 extern struct block_device *bdget(dev_t);
 extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);
+extern sector_t blkdev_max_block(struct block_device *bdev);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern void invalidate_bdev(struct block_device *);

commit 169ebd90131b2ffca74bb2dbe7eeacd39fb83714
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 3 14:48:03 2012 +0200

    writeback: Avoid iput() from flusher thread
    
    Doing iput() from flusher thread (writeback_sb_inodes()) can create problems
    because iput() can do a lot of work - for example truncate the inode if it's
    the last iput on unlinked file. Some filesystems depend on flusher thread
    progressing (e.g. because they need to flush delay allocated blocks to reduce
    allocation uncertainty) and so flusher thread doing truncate creates
    interesting dependencies and possibilities for deadlocks.
    
    We get rid of iput() in flusher thread by using the fact that I_SYNC inode
    flag effectively pins the inode in memory. So if we take care to either hold
    i_lock or have I_SYNC set, we can get away without taking inode reference
    in writeback_sb_inodes().
    
    As a side effect of these changes, we also fix possible use-after-free in
    wb_writeback() because inode_wait_for_writeback() call could try to reacquire
    i_lock on the inode that was already free.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c79316c79ee3..1c71e7f4d234 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1753,9 +1753,10 @@ struct super_operations {
  *			anew.  Other functions will just ignore such inodes,
  *			if appropriate.  I_NEW is used for waiting.
  *
- * I_SYNC		Synchonized write of dirty inode data.  The bits is
- *			set during data writeback, and cleared with a wakeup
- *			on the bit address once it is done.
+ * I_SYNC		Writeback of inode is running. The bit is set during
+ *			data writeback, and cleared with a wakeup on the bit
+ *			address once it is done. The bit is also used to pin
+ *			the inode in memory for flusher thread.
  *
  * I_REFERENCED		Marks the inode as recently references on the LRU list.
  *

commit dbd5768f87ff6fb0a4fe09c4d7b6c4a24de99430
Author: Jan Kara <jack@suse.cz>
Date:   Thu May 3 14:48:02 2012 +0200

    vfs: Rename end_writeback() to clear_inode()
    
    After we moved inode_sync_wait() from end_writeback() it doesn't make sense
    to call the function end_writeback() anymore. Rename it to clear_inode()
    which well says what the function really does - set I_CLEAR flag.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8de675523e46..c79316c79ee3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1744,8 +1744,8 @@ struct super_operations {
  * I_FREEING		Set when inode is about to be freed but still has dirty
  *			pages or buffers attached or the inode itself is still
  *			dirty.
- * I_CLEAR		Added by end_writeback().  In this state the inode is clean
- *			and can be destroyed.  Inode keeps I_FREEING.
+ * I_CLEAR		Added by clear_inode().  In this state the inode is
+ *			clean and can be destroyed.  Inode keeps I_FREEING.
  *
  *			Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are
  *			prohibited for many purposes.  iget() must wait for
@@ -2328,7 +2328,7 @@ extern unsigned int get_next_ino(void);
 
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
-extern void end_writeback(struct inode *);
+extern void clear_inode(struct inode *);
 extern void __destroy_inode(struct inode *);
 extern struct inode *new_inode_pseudo(struct super_block *sb);
 extern struct inode *new_inode(struct super_block *sb);

commit 92361636e0153bd0cb22e7dfe3fc6287f6537c66
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Feb 8 07:07:50 2012 -0800

    userns: Store uid and gid types in vfs structures with kuid_t and kgid_t types
    
    The conversion of all of the users is not done yet there are too many to change
    in one go and leave the code reviewable. For now I change just the header and
    a few trivial users and rely on CONFIG_UIDGID_STRICT_TYPE_CHECKS not being set
    to ensure that the code will still compile during the transition.
    
    Helper functions i_uid_read, i_uid_write, i_gid_read, i_gid_write are added
    so that in most cases filesystems can avoid the complexities of multiple user
    namespaces and can concentrate on moving their raw numeric values into and
    out of the vfs data structures.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a6c5efbee0d7..797eb262d9f1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -402,6 +402,7 @@ struct inodes_stat_t {
 #include <linux/atomic.h>
 #include <linux/shrinker.h>
 #include <linux/migrate_mode.h>
+#include <linux/uidgid.h>
 
 #include <asm/byteorder.h>
 
@@ -469,8 +470,8 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 struct iattr {
 	unsigned int	ia_valid;
 	umode_t		ia_mode;
-	uid_t		ia_uid;
-	gid_t		ia_gid;
+	kuid_t		ia_uid;
+	kgid_t		ia_gid;
 	loff_t		ia_size;
 	struct timespec	ia_atime;
 	struct timespec	ia_mtime;
@@ -761,8 +762,8 @@ struct posix_acl;
 struct inode {
 	umode_t			i_mode;
 	unsigned short		i_opflags;
-	uid_t			i_uid;
-	gid_t			i_gid;
+	kuid_t			i_uid;
+	kgid_t			i_gid;
 	unsigned int		i_flags;
 
 #ifdef CONFIG_FS_POSIX_ACL
@@ -927,6 +928,31 @@ static inline void i_size_write(struct inode *inode, loff_t i_size)
 #endif
 }
 
+/* Helper functions so that in most cases filesystems will
+ * not need to deal directly with kuid_t and kgid_t and can
+ * instead deal with the raw numeric values that are stored
+ * in the filesystem.
+ */
+static inline uid_t i_uid_read(const struct inode *inode)
+{
+	return from_kuid(&init_user_ns, inode->i_uid);
+}
+
+static inline gid_t i_gid_read(const struct inode *inode)
+{
+	return from_kgid(&init_user_ns, inode->i_gid);
+}
+
+static inline void i_uid_write(struct inode *inode, uid_t uid)
+{
+	inode->i_uid = make_kuid(&init_user_ns, uid);
+}
+
+static inline void i_gid_write(struct inode *inode, gid_t gid)
+{
+	inode->i_gid = make_kgid(&init_user_ns, gid);
+}
+
 static inline unsigned iminor(const struct inode *inode)
 {
 	return MINOR(inode->i_rdev);
@@ -943,7 +969,7 @@ struct fown_struct {
 	rwlock_t lock;          /* protects pid, uid, euid fields */
 	struct pid *pid;	/* pid or -pgrp where SIGIO should be sent */
 	enum pid_type pid_type;	/* Kind of process group SIGIO should be sent to */
-	uid_t uid, euid;	/* uid/euid of process setting the owner */
+	kuid_t uid, euid;	/* uid/euid of process setting the owner */
 	int signum;		/* posix.1b rt signal to be delivered on IO */
 };
 

commit 1a48e2ac034d47ed843081c4523b63c46b46888b
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Nov 14 16:24:06 2011 -0800

    userns: Replace the hard to write inode_userns with inode_capable.
    
    This represents a change in strategy of how to handle user namespaces.
    Instead of tagging everything explicitly with a user namespace and bulking
    up all of the comparisons of uids and gids in the kernel,  all uids and gids
    in use will have a mapping to a flat kuid and kgid spaces respectively.  This
    allows much more of the existing logic to be preserved and in general
    allows for faster code.
    
    In this new and improved world we allow someone to utiliize capabilities
    over an inode if the inodes owner mapps into the capabilities holders user
    namespace and the user has capabilities in their user namespace.  Which
    is simple and efficient.
    
    Moving the fs uid comparisons to be comparisons in a flat kuid space
    follows in later patches, something that is only significant if you
    are using user namespaces.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 135693e79f2b..a6c5efbee0d7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1522,12 +1522,6 @@ enum {
 #define vfs_check_frozen(sb, level) \
 	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
 
-/*
- * until VFS tracks user namespaces for inodes, just make all files
- * belong to init_user_ns
- */
-extern struct user_namespace init_user_ns;
-#define inode_userns(inode) (&init_user_ns)
 extern bool inode_owner_or_capable(const struct inode *inode);
 
 /* not quite ready to be deprecated, but... */

commit 5d32c88f0b94061b3af2e3ade92422407282eb12
Merge: 43f63c8711ce dac23b0d0513
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 5 15:30:34 2012 -0700

    Merge branch 'akpm' (Andrew's patch-bomb)
    
    Merge batch of fixes from Andrew Morton:
     "The simple_open() cleanup was held back while I wanted for laggards to
      merge things.
    
      I still need to send a few checkpoint/restore patches.  I've been
      wobbly about merging them because I'm wobbly about the overall
      prospects for success of the project.  But after speaking with Pavel
      at the LSF conference, it sounds like they're further toward
      completion than I feared - apparently davem is at the "has stopped
      complaining" stage regarding the net changes.  So I need to go back
      and re-review those patchs and their (lengthy) discussion."
    
    * emailed from Andrew Morton <akpm@linux-foundation.org>: (16 patches)
      memcg swap: use mem_cgroup_uncharge_swap fix
      backlight: add driver for DA9052/53 PMIC v1
      C6X: use set_current_blocked() and block_sigmask()
      MAINTAINERS: add entry for sparse checker
      MAINTAINERS: fix REMOTEPROC F: typo
      alpha: use set_current_blocked() and block_sigmask()
      simple_open: automatically convert to simple_open()
      scripts/coccinelle/api/simple_open.cocci: semantic patch for simple_open()
      libfs: add simple_open()
      hugetlbfs: remove unregister_filesystem() when initializing module
      drivers/rtc/rtc-88pm860x.c: fix rtc irq enable callback
      fs/xattr.c:setxattr(): improve handling of allocation failures
      fs/xattr.c:listxattr(): fall back to vmalloc() if kmalloc() failed
      fs/xattr.c: suppress page allocation failure warnings from sys_listxattr()
      sysrq: use SEND_SIG_FORCED instead of force_sig()
      proc: fix mount -t proc -o AAA

commit 20955e891d828b2027281fe3295dae6af8e0423b
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Apr 5 14:25:09 2012 -0700

    libfs: add simple_open()
    
    debugfs and a few other drivers use an open-coded version of
    simple_open() to pass a pointer from the file to the read/write file
    ops.  Add support for this simple case to libfs so that we can remove
    the many duplicate copies of this simple function.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c437f914d537..c64c31d3ab2c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2502,6 +2502,7 @@ extern int dcache_readdir(struct file *, void *, filldir_t);
 extern int simple_setattr(struct dentry *, struct iattr *);
 extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
 extern int simple_statfs(struct dentry *, struct kstatfs *);
+extern int simple_open(struct inode *inode, struct file *file);
 extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);

commit 66189be74ff5f9f3fd6444315b85be210d07cef2
Author: Pavel Shilovsky <piastry@etersoft.ru>
Date:   Wed Mar 28 21:56:19 2012 +0400

    CIFS: Fix VFS lock usage for oplocked files
    
    We can deadlock if we have a write oplock and two processes
    use the same file handle. In this case the first process can't
    unlock its lock if the second process blocked on the lock in the
    same time.
    
    Fix it by using posix_lock_file rather than posix_lock_file_wait
    under cinode->lock_mutex. If we request a blocking lock and
    posix_lock_file indicates that there is another lock that prevents
    us, wait untill that lock is released and restart our call.
    
    Cc: stable@kernel.org
    Acked-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Pavel Shilovsky <piastry@etersoft.ru>
    Signed-off-by: Steve French <sfrench@us.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 135693e79f2b..528611843ba0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1215,6 +1215,7 @@ extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
+extern void locks_delete_block(struct file_lock *waiter);
 extern void lock_flocks(void);
 extern void unlock_flocks(void);
 #else /* !CONFIG_FILE_LOCKING */
@@ -1359,6 +1360,10 @@ static inline int lock_may_write(struct inode *inode, loff_t start,
 	return 1;
 }
 
+static inline void locks_delete_block(struct file_lock *waiter)
+{
+}
+
 static inline void lock_flocks(void)
 {
 }

commit 71db34fc4330f7c784397acb9f1e6ee7f7b32eb2
Merge: 50483c326891 797a9d797f84
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 14:53:25 2012 -0700

    Merge branch 'for-3.4' of git://linux-nfs.org/~bfields/linux
    
    Pull nfsd changes from Bruce Fields:
    
    Highlights:
     - Benny Halevy and Tigran Mkrtchyan implemented some more 4.1 features,
       moving us closer to a complete 4.1 implementation.
     - Bernd Schubert fixed a long-standing problem with readdir cookies on
       ext2/3/4.
     - Jeff Layton performed a long-overdue overhaul of the server reboot
       recovery code which will allow us to deprecate the current code (a
       rather unusual user of the vfs), and give us some needed flexibility
       for further improvements.
     - Like the client, we now support numeric uid's and gid's in the
       auth_sys case, allowing easier upgrades from NFSv2/v3 to v4.x.
    
    Plus miscellaneous bugfixes and cleanup.
    
    Thanks to everyone!
    
    There are also some delegation fixes waiting on vfs review that I
    suppose will have to wait for 3.5.  With that done I think we'll finally
    turn off the "EXPERIMENTAL" dependency for v4 (though that's mostly
    symbolic as it's been on by default in distro's for a while).
    
    And the list of 4.1 todo's should be achievable for 3.5 as well:
    
       http://wiki.linux-nfs.org/wiki/index.php/Server_4.0_and_4.1_issues
    
    though we may still want a bit more experience with it before turning it
    on by default.
    
    * 'for-3.4' of git://linux-nfs.org/~bfields/linux: (55 commits)
      nfsd: only register cld pipe notifier when CONFIG_NFSD_V4 is enabled
      nfsd4: use auth_unix unconditionally on backchannel
      nfsd: fix NULL pointer dereference in cld_pipe_downcall
      nfsd4: memory corruption in numeric_name_to_id()
      sunrpc: skip portmap calls on sessions backchannel
      nfsd4: allow numeric idmapping
      nfsd: don't allow legacy client tracker init for anything but init_net
      nfsd: add notifier to handle mount/unmount of rpc_pipefs sb
      nfsd: add the infrastructure to handle the cld upcall
      nfsd: add a header describing upcall to nfsdcld
      nfsd: add a per-net-namespace struct for nfsd
      sunrpc: create nfsd dir in rpc_pipefs
      nfsd: add nfsd4_client_tracking_ops struct and a way to set it
      nfsd: convert nfs4_client->cl_cb_flags to a generic flags field
      NFSD: Fix nfs4_verifier memory alignment
      NFSD: Fix warnings when NFSD_DEBUG is not defined
      nfsd: vfs_llseek() with 32 or 64 bit offsets (hashes)
      nfsd: rename 'int access' to 'int may_flags' in nfsd_open()
      ext4: return 32/64-bit dir name hash according to usage type
      fs: add new FMODE flags: FMODE_32bithash and FMODE_64bithash
      ...

commit 69e1aaddd63104f37021d0b0f6abfd9623c9134c
Merge: 56b59b429b4c 9d547c35799a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 10:02:55 2012 -0700

    Merge tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    Pull ext4 updates for 3.4 from Ted Ts'o:
     "Ext4 commits for 3.3 merge window; mostly cleanups and bug fixes
    
      The changes to export dirty_writeback_interval are from Artem's s_dirt
      cleanup patch series.  The same is true of the change to remove the
      s_dirt helper functions which never got used by anyone in-tree.  I've
      run these changes by Al Viro, and am carrying them so that Artem can
      more easily fix up the rest of the file systems during the next merge
      window.  (Originally we had hopped to remove the use of s_dirt from
      ext4 during this merge window, but his patches had some bugs, so I
      ultimately ended dropping them from the ext4 tree.)"
    
    * tag 'ext4_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (66 commits)
      vfs: remove unused superblock helpers
      mm: export dirty_writeback_interval
      ext4: remove useless s_dirt assignment
      ext4: write superblock only once on unmount
      ext4: do not mark superblock as dirty unnecessarily
      ext4: correct ext4_punch_hole return codes
      ext4: remove restrictive checks for EOFBLOCKS_FL
      ext4: always set then trimmed blocks count into len
      ext4: fix trimmed block count accunting
      ext4: fix start and len arguments handling in ext4_trim_fs()
      ext4: update s_free_{inodes,blocks}_count during online resize
      ext4: change some printk() calls to use ext4_msg() instead
      ext4: avoid output message interleaving in ext4_error_<foo>()
      ext4: remove trailing newlines from ext4_msg() and ext4_error() messages
      ext4: add no_printk argument validation, fix fallout
      ext4: remove redundant "EXT4-fs: " from uses of ext4_msg
      ext4: give more helpful error message in ext4_ext_rm_leaf()
      ext4: remove unused code from ext4_ext_map_blocks()
      ext4: rewrite punch hole to use ext4_ext_remove_space()
      jbd2: cleanup journal tail after transaction commit
      ...

commit ed2d265d1266736bd294332d7f649003943ae36e
Merge: f1d38e423a69 6c03438edeb5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 24 10:08:39 2012 -0700

    Merge tag 'bug-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    Pull <linux/bug.h> cleanup from Paul Gortmaker:
     "The changes shown here are to unify linux's BUG support under the one
      <linux/bug.h> file.  Due to historical reasons, we have some BUG code
      in bug.h and some in kernel.h -- i.e.  the support for BUILD_BUG in
      linux/kernel.h predates the addition of linux/bug.h, but old code in
      kernel.h wasn't moved to bug.h at that time.  As a band-aid, kernel.h
      was including <asm/bug.h> to pseudo link them.
    
      This has caused confusion[1] and general yuck/WTF[2] reactions.  Here
      is an example that violates the principle of least surprise:
    
          CC      lib/string.o
          lib/string.c: In function 'strlcat':
          lib/string.c:225:2: error: implicit declaration of function 'BUILD_BUG_ON'
          make[2]: *** [lib/string.o] Error 1
          $
          $ grep linux/bug.h lib/string.c
          #include <linux/bug.h>
          $
    
      We've included <linux/bug.h> for the BUG infrastructure and yet we
      still get a compile fail! [We've not kernel.h for BUILD_BUG_ON.] Ugh -
      very confusing for someone who is new to kernel development.
    
      With the above in mind, the goals of this changeset are:
    
      1) find and fix any include/*.h files that were relying on the
         implicit presence of BUG code.
      2) find and fix any C files that were consuming kernel.h and hence
         relying on implicitly getting some/all BUG code.
      3) Move the BUG related code living in kernel.h to <linux/bug.h>
      4) remove the asm/bug.h from kernel.h to finally break the chain.
    
      During development, the order was more like 3-4, build-test, 1-2.  But
      to ensure that git history for bisect doesn't get needless build
      failures introduced, the commits have been reorderd to fix the problem
      areas in advance.
    
            [1]  https://lkml.org/lkml/2012/1/3/90
            [2]  https://lkml.org/lkml/2012/1/17/414"
    
    Fix up conflicts (new radeon file, reiserfs header cleanups) as per Paul
    and linux-next.
    
    * tag 'bug-for-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux:
      kernel.h: doesn't explicitly use bug.h, so don't include it.
      bug: consolidate BUILD_BUG_ON with other bug code
      BUG: headers with BUG/BUG_ON etc. need linux/bug.h
      bug.h: add include of it to various implicit C users
      lib: fix implicit users of kernel.h for TAINT_WARN
      spinlock: macroize assert_spin_locked to avoid bug.h dependency
      x86: relocate get/set debugreg fcns to include/asm/debugreg.

commit 9d547c35799a4ddd235f1565cec2fff6c9263504
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Mar 21 22:34:55 2012 -0400

    vfs: remove unused superblock helpers
    
    Remove the 'sb_mark_dirty()', 'sb_mark_clean()' and 'sb_is_dirty()'
    helpers which are not used. I introduced them 2 years and the
    intention was to make all file-systems use them in order to be able to
    optimize 'sync_supers()'.  However, Al Viro vetoed my patches at the
    end and asked me to push superblock management down to file-systems
    and get rid of the 's_dirt' flag completely, as well as kill
    'sync_supers()' altogether. Thus, remove the helpers.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 386da09f229d..526072c073f7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1870,19 +1870,6 @@ extern struct dentry *mount_pseudo(struct file_system_type *, char *,
 	const struct dentry_operations *dops,
 	unsigned long);
 
-static inline void sb_mark_dirty(struct super_block *sb)
-{
-	sb->s_dirt = 1;
-}
-static inline void sb_mark_clean(struct super_block *sb)
-{
-	sb->s_dirt = 0;
-}
-static inline int sb_is_dirty(struct super_block *sb)
-{
-	return sb->s_dirt;
-}
-
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \
 	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))

commit 68ac1234fb949b66941d94dce4157742799fc581
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Mar 15 08:21:57 2012 -0400

    switch touch_atime to struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b89dc4d60d99..9bbe1a9ac432 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1812,11 +1812,11 @@ static inline void inode_inc_iversion(struct inode *inode)
        spin_unlock(&inode->i_lock);
 }
 
-extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
+extern void touch_atime(struct path *);
 static inline void file_accessed(struct file *file)
 {
 	if (!(file->f_flags & O_NOATIME))
-		touch_atime(file->f_path.mnt, file->f_path.dentry);
+		touch_atime(&file->f_path);
 }
 
 int sync_inode(struct inode *inode, struct writeback_control *wbc);

commit 9bcb4b733c22b7dbc4cf847e707ac98f751e9180
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Feb 12 19:43:17 2012 -0500

    vfs: turn generic_drop_inode() into static inline
    
    Once upon a time it used to be much bigger, but these days there's
    no point whatsoever keeping it in fs/inode.c, especially since
    it's not even needed as initializer for ->drop_inode() - it's the
    default and leaving ->drop_inode NULL will do just as well.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0ab89426ba55..b89dc4d60d99 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2305,7 +2305,10 @@ extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);
 extern int inode_needs_sync(struct inode *inode);
 extern int generic_delete_inode(struct inode *inode);
-extern int generic_drop_inode(struct inode *inode);
+static inline int generic_drop_inode(struct inode *inode)
+{
+	return !inode->i_nlink || inode_unhashed(inode);
+}
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,
 		unsigned long hashval, int (*test)(struct inode *, void *),

commit 8de52778798fe39660a8d6b26f290e0c93202761
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Feb 6 12:45:27 2012 -0500

    vfs: check i_nlink limits in vfs_{mkdir,rename_dir,link}
    
    New field of struct super_block - ->s_max_links.  Maximal allowed
    value of ->i_nlink or 0; in the latter case all checks still need
    to be done in ->link/->mkdir/->rename instances.  Note that this
    limit applies both to directoris and to non-directories.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 69cd5bb640f5..0ab89426ba55 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1459,6 +1459,7 @@ struct super_block {
 	u8 s_uuid[16];				/* UUID */
 
 	void 			*s_fs_info;	/* Filesystem private info */
+	unsigned int		s_max_links;
 	fmode_t			s_mode;
 
 	/* Granularity of c/m/atime in ns.

commit 6a8a13e03861c0ab83ab07d573ca793cff0e5d00
Author: Bernd Schubert <bernd.schubert@itwm.fraunhofer.de>
Date:   Tue Mar 13 22:51:38 2012 -0400

    fs: add new FMODE flags: FMODE_32bithash and FMODE_64bithash
    
    Those flags are supposed to be set by NFS readdir() to tell ext3/ext4
    to 32bit (NFSv2) or 64bit hash values (offsets) in seekdir().
    
    Signed-off-by: Bernd Schubert <bernd.schubert@itwm.fraunhofer.de>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 386da09f229d..8975a5602931 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -92,6 +92,10 @@ struct inodes_stat_t {
 /* File is opened using open(.., 3, ..) and is writeable only for ioctls
    (specialy hack for floppy.c) */
 #define FMODE_WRITE_IOCTL	((__force fmode_t)0x100)
+/* 32bit hashes as llseek() offset (for directories) */
+#define FMODE_32BITHASH         ((__force fmode_t)0x200)
+/* 64bit hashes as llseek() offset (for directories) */
+#define FMODE_64BITHASH         ((__force fmode_t)0x400)
 
 /*
  * Don't update ctime and mtime.

commit 187f1882b5b0748b3c4c22274663fdb372ac0452
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Nov 23 20:12:59 2011 -0500

    BUG: headers with BUG/BUG_ON etc. need linux/bug.h
    
    If a header file is making use of BUG, BUG_ON, BUILD_BUG_ON, or any
    other BUG variant in a static inline (i.e. not in a #define) then
    that header really should be including <linux/bug.h> and not just
    expecting it to be implicitly present.
    
    We can make this change risk-free, since if the files using these
    headers didn't have exposure to linux/bug.h already, they would have
    been causing compile failures/warnings.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 69cd5bb640f5..abc92db51e54 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -389,6 +389,7 @@ struct inodes_stat_t {
 #include <linux/prio_tree.h>
 #include <linux/init.h>
 #include <linux/pid.h>
+#include <linux/bug.h>
 #include <linux/mutex.h>
 #include <linux/capability.h>
 #include <linux/semaphore.h>

commit 6b6dc836a195e077e76977b6c020a73de411b46d
Author: Jan Kara <jack@suse.cz>
Date:   Fri Feb 10 11:03:00 2012 +0100

    vfs: Provide function to get superblock and wait for it to thaw
    
    In quota code we need to find a superblock corresponding to a device and wait
    for superblock to be unfrozen. However this waiting has to happen without
    s_umount semaphore because that is required for superblock to thaw. So provide
    a function in VFS for this to keep dances with s_umount where they belong.
    
    [AV: implementation switched to saner variant]
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 386da09f229d..69cd5bb640f5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2496,6 +2496,7 @@ extern void get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);
+extern struct super_block *get_super_thawed(struct block_device *);
 extern struct super_block *get_active_super(struct block_device *bdev);
 extern void drop_super(struct super_block *sb);
 extern void iterate_supers(void (*)(struct super_block *, void *), void *);

commit c1aab02dac690af7ff634d8e1cb3be6a04387eef
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Jan 24 11:41:32 2012 +1100

    migrate_mode.h is not exported to user mode
    
    so move its include into fs.h inside the __KERNEL__ protection.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b3a41fe22bf..386da09f229d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,7 +10,6 @@
 #include <linux/ioctl.h>
 #include <linux/blk_types.h>
 #include <linux/types.h>
-#include <linux/migrate_mode.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -397,6 +396,7 @@ struct inodes_stat_t {
 #include <linux/rculist_bl.h>
 #include <linux/atomic.h>
 #include <linux/shrinker.h>
+#include <linux/migrate_mode.h>
 
 #include <asm/byteorder.h>
 

commit 6536e3123e5d3371a6f52e32a3d0694bcc987702
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Jan 20 14:33:53 2012 -0800

    mm: fix warnings regarding enum migrate_mode
    
    sparc64 allmodconfig:
    
    In file included from include/linux/compat.h:15,
                     from /usr/src/25/arch/sparc/include/asm/siginfo.h:19,
                     from include/linux/signal.h:5,
                     from include/linux/sched.h:73,
                     from arch/sparc/kernel/asm-offsets.c:13:
    include/linux/fs.h:618: warning: parameter has incomplete type
    
    It seems that my sparc64 compiler (gcc-3.4.5) doesn't like the forward
    declaration of enums.
    
    Fix this by moving the "enum migrate_mode" definition into its own header
    file.
    
    Acked-by: Mel Gorman <mgorman@suse.de>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andy Isaacson <adi@hexapodia.org>
    Cc: Nai Xia <nai.xia@gmail.com>
    Cc: Johannes Weiner <jweiner@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0244082d42c5..4b3a41fe22bf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -10,6 +10,7 @@
 #include <linux/ioctl.h>
 #include <linux/blk_types.h>
 #include <linux/types.h>
+#include <linux/migrate_mode.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -526,7 +527,6 @@ enum positive_aop_returns {
 struct page;
 struct address_space;
 struct writeback_control;
-enum migrate_mode;
 
 struct iov_iter {
 	const struct iovec *iov;

commit b3c9dd182ed3bdcdaf0e42625a35924b0497afdc
Merge: 83c2f912b43c 5d381efb3d1f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 15 12:24:45 2012 -0800

    Merge branch 'for-3.3/core' of git://git.kernel.dk/linux-block
    
    * 'for-3.3/core' of git://git.kernel.dk/linux-block: (37 commits)
      Revert "block: recursive merge requests"
      block: Stop using macro stubs for the bio data integrity calls
      blockdev: convert some macros to static inlines
      fs: remove unneeded plug in mpage_readpages()
      block: Add BLKROTATIONAL ioctl
      block: Introduce blk_set_stacking_limits function
      block: remove WARN_ON_ONCE() in exit_io_context()
      block: an exiting task should be allowed to create io_context
      block: ioc_cgroup_changed() needs to be exported
      block: recursive merge requests
      block, cfq: fix empty queue crash caused by request merge
      block, cfq: move icq creation and rq->elv.icq association to block core
      block, cfq: restructure io_cq creation path for io_context interface cleanup
      block, cfq: move io_cq exit/release to blk-ioc.c
      block, cfq: move icq cache management to block core
      block, cfq: move io_cq lookup to blk-ioc.c
      block, cfq: move cfqd->icq_list to request_queue and add request->elv.icq
      block, cfq: reorganize cfq_io_context into generic and cfq specific parts
      block: remove elevator_queue->ops
      block: reorder elevator switch sequence
      ...
    
    Fix up conflicts in:
     - block/blk-cgroup.c
            Switch from can_attach_task to can_attach
     - block/cfq-iosched.c
            conflict with now removed cic index changes (we now use q->id instead)

commit 87192a2a49c475cf322cb143e0fa63b0102d8567
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Jan 12 17:20:34 2012 -0800

    vfs: cache request_queue in struct block_device
    
    This makes it possible to get from the inode to the request_queue with one
    less cache miss.  Used in followon optimization.
    
    The livetime of the pointer is the same as the gendisk.
    
    This assumes that the queue will always stay the same in the gendisk while
    it's visible to block_devices.  I think that's safe correct?
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e694bd4434a4..4bc8169fb5a1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -660,6 +660,7 @@ struct address_space {
 	 * must be enforced here for CRIS, to let the least significant bit
 	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
 	 */
+struct request_queue;
 
 struct block_device {
 	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
@@ -682,6 +683,7 @@ struct block_device {
 	unsigned		bd_part_count;
 	int			bd_invalidated;
 	struct gendisk *	bd_disk;
+	struct request_queue *  bd_queue;
 	struct list_head	bd_list;
 	/*
 	 * Private data.  You must have bd_claim'ed the block_device

commit a6bc32b899223a877f595ef9ddc1e89ead5072b8
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Jan 12 17:19:43 2012 -0800

    mm: compaction: introduce sync-light migration for use by compaction
    
    This patch adds a lightweight sync migrate operation MIGRATE_SYNC_LIGHT
    mode that avoids writing back pages to backing storage.  Async compaction
    maps to MIGRATE_ASYNC while sync compaction maps to MIGRATE_SYNC_LIGHT.
    For other migrate_pages users such as memory hotplug, MIGRATE_SYNC is
    used.
    
    This avoids sync compaction stalling for an excessive length of time,
    particularly when copying files to a USB stick where there might be a
    large number of dirty pages backed by a filesystem that does not support
    ->writepages.
    
    [aarcange@redhat.com: This patch is heavily based on Andrea's work]
    [akpm@linux-foundation.org: fix fs/nfs/write.c build]
    [akpm@linux-foundation.org: fix fs/btrfs/disk-io.c build]
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andy Isaacson <adi@hexapodia.org>
    Cc: Nai Xia <nai.xia@gmail.com>
    Cc: Johannes Weiner <jweiner@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b92b73d0b2b9..e694bd4434a4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -525,6 +525,7 @@ enum positive_aop_returns {
 struct page;
 struct address_space;
 struct writeback_control;
+enum migrate_mode;
 
 struct iov_iter {
 	const struct iovec *iov;
@@ -614,7 +615,7 @@ struct address_space_operations {
 	 * is false, it must not block.
 	 */
 	int (*migratepage) (struct address_space *,
-			struct page *, struct page *, bool);
+			struct page *, struct page *, enum migrate_mode);
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
 					unsigned long);
@@ -2540,7 +2541,8 @@ extern int generic_check_addressable(unsigned, u64);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,
-				struct page *, struct page *, bool);
+				struct page *, struct page *,
+				enum migrate_mode);
 #else
 #define buffer_migrate_page NULL
 #endif

commit b969c4ab9f182a6e1b2a0848be349f99714947b0
Author: Mel Gorman <mgorman@suse.de>
Date:   Thu Jan 12 17:19:34 2012 -0800

    mm: compaction: determine if dirty pages can be migrated without blocking within ->migratepage
    
    Asynchronous compaction is used when allocating transparent hugepages to
    avoid blocking for long periods of time.  Due to reports of stalling,
    there was a debate on disabling synchronous compaction but this severely
    impacted allocation success rates.  Part of the reason was that many dirty
    pages are skipped in asynchronous compaction by the following check;
    
            if (PageDirty(page) && !sync &&
                    mapping->a_ops->migratepage != migrate_page)
                            rc = -EBUSY;
    
    This skips over all mapping aops using buffer_migrate_page() even though
    it is possible to migrate some of these pages without blocking.  This
    patch updates the ->migratepage callback with a "sync" parameter.  It is
    the responsibility of the callback to fail gracefully if migration would
    block.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Reviewed-by: Rik van Riel <riel@redhat.com>
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andy Isaacson <adi@hexapodia.org>
    Cc: Nai Xia <nai.xia@gmail.com>
    Cc: Johannes Weiner <jweiner@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a7409bc157e0..b92b73d0b2b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -609,9 +609,12 @@ struct address_space_operations {
 			loff_t offset, unsigned long nr_segs);
 	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
 						void **, unsigned long *);
-	/* migrate the contents of a page to the specified target */
+	/*
+	 * migrate the contents of a page to the specified target. If sync
+	 * is false, it must not block.
+	 */
 	int (*migratepage) (struct address_space *,
-			struct page *, struct page *);
+			struct page *, struct page *, bool);
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
 					unsigned long);
@@ -2537,7 +2540,7 @@ extern int generic_check_addressable(unsigned, u64);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,
-				struct page *, struct page *);
+				struct page *, struct page *, bool);
 #else
 #define buffer_migrate_page NULL
 #endif

commit 28d82dc1c4edbc352129f97f4ca22624d1fe61de
Author: Jason Baron <jbaron@redhat.com>
Date:   Thu Jan 12 17:17:43 2012 -0800

    epoll: limit paths
    
    The current epoll code can be tickled to run basically indefinitely in
    both loop detection path check (on ep_insert()), and in the wakeup paths.
    The programs that tickle this behavior set up deeply linked networks of
    epoll file descriptors that cause the epoll algorithms to traverse them
    indefinitely.  A couple of these sample programs have been previously
    posted in this thread: https://lkml.org/lkml/2011/2/25/297.
    
    To fix the loop detection path check algorithms, I simply keep track of
    the epoll nodes that have been already visited.  Thus, the loop detection
    becomes proportional to the number of epoll file descriptor and links.
    This dramatically decreases the run-time of the loop check algorithm.  In
    one diabolical case I tried it reduced the run-time from 15 mintues (all
    in kernel time) to .3 seconds.
    
    Fixing the wakeup paths could be done at wakeup time in a similar manner
    by keeping track of nodes that have already been visited, but the
    complexity is harder, since there can be multiple wakeups on different
    cpus...Thus, I've opted to limit the number of possible wakeup paths when
    the paths are created.
    
    This is accomplished, by noting that the end file descriptor points that
    are found during the loop detection pass (from the newly added link), are
    actually the sources for wakeup events.  I keep a list of these file
    descriptors and limit the number and length of these paths that emanate
    from these 'source file descriptors'.  In the current implemetation I
    allow 1000 paths of length 1, 500 of length 2, 100 of length 3, 50 of
    length 4 and 10 of length 5.  Note that it is sufficient to check the
    'source file descriptors' reachable from the newly added link, since no
    other 'source file descriptors' will have newly added links.  This allows
    us to check only the wakeup paths that may have gotten too long, and not
    re-check all possible wakeup paths on the system.
    
    In terms of the path limit selection, I think its first worth noting that
    the most common case for epoll, is probably the model where you have 1
    epoll file descriptor that is monitoring n number of 'source file
    descriptors'.  In this case, each 'source file descriptor' has a 1 path of
    length 1.  Thus, I believe that the limits I'm proposing are quite
    reasonable and in fact may be too generous.  Thus, I'm hoping that the
    proposed limits will not prevent any workloads that currently work to
    fail.
    
    In terms of locking, I have extended the use of the 'epmutex' to all
    epoll_ctl add and remove operations.  Currently its only used in a subset
    of the add paths.  I need to hold the epmutex, so that we can correctly
    traverse a coherent graph, to check the number of paths.  I believe that
    this additional locking is probably ok, since its in the setup/teardown
    paths, and doesn't affect the running paths, but it certainly is going to
    add some extra overhead.  Also, worth noting is that the epmuex was
    recently added to the ep_ctl add operations in the initial path loop
    detection code using the argument that it was not on a critical path.
    
    Another thing to note here, is the length of epoll chains that is allowed.
    Currently, eventpoll.c defines:
    
    /* Maximum number of nesting allowed inside epoll sets */
    #define EP_MAX_NESTS 4
    
    This basically means that I am limited to a graph depth of 5 (EP_MAX_NESTS
    + 1).  However, this limit is currently only enforced during the loop
    check detection code, and only when the epoll file descriptors are added
    in a certain order.  Thus, this limit is currently easily bypassed.  The
    newly added check for wakeup paths, stricly limits the wakeup paths to a
    length of 5, regardless of the order in which ep's are linked together.
    Thus, a side-effect of the new code is a more consistent enforcement of
    the graph depth.
    
    Thus far, I've tested this, using the sample programs previously
    mentioned, which now either return quickly or return -EINVAL.  I've also
    testing using the piptest.c epoll tester, which showed no difference in
    performance.  I've also created a number of different epoll networks and
    tested that they behave as expectded.
    
    I believe this solves the original diabolical test cases, while still
    preserving the sane epoll nesting.
    
    Signed-off-by: Jason Baron <jbaron@redhat.com>
    Cc: Nelson Elhage <nelhage@ksplice.com>
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7aacf31418fe..a7409bc157e0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1001,6 +1001,7 @@ struct file {
 #ifdef CONFIG_EPOLL
 	/* Used by fs/eventpoll.c to link all the hooks to this file */
 	struct list_head	f_ep_links;
+	struct list_head	f_tfile_llink;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
 #ifdef CONFIG_DEBUG_WRITECOUNT

commit ef00f59c95fe6e002e7c6e3663cdea65e253f4cc
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Wed Jan 11 16:29:31 2012 +0100

    block: Add BLKROTATIONAL ioctl
    
    Introduce an ioctl which permits applications to query whether a block
    device is rotational.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0bc4ffb8e7f..95dd911506f1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -319,6 +319,7 @@ struct inodes_stat_t {
 #define BLKPBSZGET _IO(0x12,123)
 #define BLKDISCARDZEROES _IO(0x12,124)
 #define BLKSECDISCARD _IO(0x12,125)
+#define BLKROTATIONAL _IO(0x12,126)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit 8e8b87964bc8dc5c14b6543fc933b7725f07d3ac
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Nov 21 12:11:33 2011 +0100

    vfs: prevent remount read-only if pending removes
    
    If there are any inodes on the super block that have been unlinked
    (i_nlink == 0) but have not yet been deleted then prevent the
    remounting the super block read-only.
    
    Reported-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8ac40921f5ac..7aacf31418fe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2150,8 +2150,6 @@ extern const struct file_operations read_pipefifo_fops;
 extern const struct file_operations write_pipefifo_fops;
 extern const struct file_operations rdwr_pipefifo_fops;
 
-extern int fs_may_remount_ro(struct super_block *);
-
 #ifdef CONFIG_BLOCK
 /*
  * return READ, READA, or WRITE

commit 7ada4db88634429f4da690ad1c4eb73c93085f0c
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Nov 21 12:11:32 2011 +0100

    vfs: count unlinked inodes
    
    Add a new counter to the superblock that keeps track of unlinked but
    not yet deleted inodes.
    
    Do not WARN_ON if set_nlink is called with zero count, just do a
    ratelimited printk.  This happens on xfs and probably other
    filesystems after an unclean shutdown when the filesystem reads inodes
    which already have zero i_nlink.  Reported by Christoph Hellwig.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b8a681b1ef4..8ac40921f5ac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1483,6 +1483,9 @@ struct super_block {
 
 	struct shrinker s_shrink;	/* per-sb shrinker handle */
 
+	/* Number of inodes with nlink == 0 but still referenced */
+	atomic_long_t s_remove_count;
+
 	/* Being remounted read-only */
 	int s_readonly_remount;
 };
@@ -1768,31 +1771,10 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
 	__mark_inode_dirty(inode, I_DIRTY_SYNC);
 }
 
-/**
- * set_nlink - directly set an inode's link count
- * @inode: inode
- * @nlink: new nlink (should be non-zero)
- *
- * This is a low-level filesystem helper to replace any
- * direct filesystem manipulation of i_nlink.
- */
-static inline void set_nlink(struct inode *inode, unsigned int nlink)
-{
-	inode->__i_nlink = nlink;
-}
-
-/**
- * inc_nlink - directly increment an inode's link count
- * @inode: inode
- *
- * This is a low-level filesystem helper to replace any
- * direct filesystem manipulation of i_nlink.  Currently,
- * it is only here for parity with dec_nlink().
- */
-static inline void inc_nlink(struct inode *inode)
-{
-	inode->__i_nlink++;
-}
+extern void inc_nlink(struct inode *inode);
+extern void drop_nlink(struct inode *inode);
+extern void clear_nlink(struct inode *inode);
+extern void set_nlink(struct inode *inode, unsigned int nlink);
 
 static inline void inode_inc_link_count(struct inode *inode)
 {
@@ -1800,35 +1782,6 @@ static inline void inode_inc_link_count(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
-/**
- * drop_nlink - directly drop an inode's link count
- * @inode: inode
- *
- * This is a low-level filesystem helper to replace any
- * direct filesystem manipulation of i_nlink.  In cases
- * where we are attempting to track writes to the
- * filesystem, a decrement to zero means an imminent
- * write when the file is truncated and actually unlinked
- * on the filesystem.
- */
-static inline void drop_nlink(struct inode *inode)
-{
-	inode->__i_nlink--;
-}
-
-/**
- * clear_nlink - directly zero an inode's link count
- * @inode: inode
- *
- * This is a low-level filesystem helper to replace any
- * direct filesystem manipulation of i_nlink.  See
- * drop_nlink() for why we care about i_nlink hitting zero.
- */
-static inline void clear_nlink(struct inode *inode)
-{
-	inode->__i_nlink = 0;
-}
-
 static inline void inode_dec_link_count(struct inode *inode)
 {
 	drop_nlink(inode);

commit 4ed5e82fe77f4147cf386327c9a63a2dd7eff518
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Nov 21 12:11:31 2011 +0100

    vfs: protect remounting superblock read-only
    
    Currently remouting superblock read-only is racy in a major way.
    
    With the per mount read-only infrastructure it is now possible to
    prevent most races, which this patch attempts.
    
    Before starting the remount read-only, iterate through all mounts
    belonging to the superblock and if none of them have any pending
    writes, set sb->s_readonly_remount.  This indicates that remount is in
    progress and no further write requests are allowed.  If the remount
    succeeds set MS_RDONLY and reset s_readonly_remount.
    
    If the remounting is unsuccessful just reset s_readonly_remount.
    This can result in transient EROFS errors, despite the fact the
    remount failed.  Unfortunately hodling off writes is difficult as
    remount itself may touch the filesystem (e.g. through load_nls())
    which would deadlock.
    
    A later patch deals with delayed writes due to nlink going to zero.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 03385acd71e8..7b8a681b1ef4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1482,6 +1482,9 @@ struct super_block {
 	int cleancache_poolid;
 
 	struct shrinker s_shrink;	/* per-sb shrinker handle */
+
+	/* Being remounted read-only */
+	int s_readonly_remount;
 };
 
 /* superblock cache pruning functions */

commit 39f7c4db1d2d9e2e2a90abdf34811783089d217d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Mon Nov 21 12:11:30 2011 +0100

    vfs: keep list of mounts for each superblock
    
    Keep track of vfsmounts belonging to a superblock.  List is protected
    by vfsmount_lock.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc1021fd19ef..03385acd71e8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1428,6 +1428,7 @@ struct super_block {
 #else
 	struct list_head	s_files;
 #endif
+	struct list_head	s_mounts;	/* list of mounts; _not_ for fs use */
 	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	int			s_nr_dentry_unused;	/* # of dentry on lru */

commit 34c80b1d93e6e20ca9dea0baf583a5b5510d92d4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 21:32:45 2011 -0500

    vfs: switch ->show_options() to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 13721b073407..cc1021fd19ef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1672,7 +1672,7 @@ struct super_operations {
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*umount_begin) (struct super_block *);
 
-	int (*show_options)(struct seq_file *, struct vfsmount *);
+	int (*show_options)(struct seq_file *, struct dentry *);
 	int (*show_devname)(struct seq_file *, struct dentry *);
 	int (*show_path)(struct seq_file *, struct dentry *);
 	int (*show_stats)(struct seq_file *, struct dentry *);
@@ -2592,7 +2592,7 @@ extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern void file_update_time(struct file *file);
 
-extern int generic_show_options(struct seq_file *m, struct vfsmount *mnt);
+extern int generic_show_options(struct seq_file *m, struct dentry *root);
 extern void save_mount_options(struct super_block *sb, char *options);
 extern void replace_mount_options(struct super_block *sb, char *options);
 

commit a6322de67b58a00e3a783ad9c87c2a11b2d67b47
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 21:37:57 2011 -0500

    vfs: switch ->show_path() to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a8dff43d1b9d..13721b073407 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1674,7 +1674,7 @@ struct super_operations {
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 	int (*show_devname)(struct seq_file *, struct dentry *);
-	int (*show_path)(struct seq_file *, struct vfsmount *);
+	int (*show_path)(struct seq_file *, struct dentry *);
 	int (*show_stats)(struct seq_file *, struct dentry *);
 #ifdef CONFIG_QUOTA
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);

commit d861c630e99febe5ce6055290085556c5b714b06
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 21:32:45 2011 -0500

    vfs: switch ->show_devname() to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b2e4b6f639e4..a8dff43d1b9d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1673,7 +1673,7 @@ struct super_operations {
 	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
-	int (*show_devname)(struct seq_file *, struct vfsmount *);
+	int (*show_devname)(struct seq_file *, struct dentry *);
 	int (*show_path)(struct seq_file *, struct vfsmount *);
 	int (*show_stats)(struct seq_file *, struct dentry *);
 #ifdef CONFIG_QUOTA

commit 64132379d509184425672e0dce1ac0a031e3f2a5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 8 20:51:13 2011 -0500

    vfs: switch ->show_stats to struct dentry *
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 659be7d82617..b2e4b6f639e4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1675,7 +1675,7 @@ struct super_operations {
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 	int (*show_devname)(struct seq_file *, struct vfsmount *);
 	int (*show_path)(struct seq_file *, struct vfsmount *);
-	int (*show_stats)(struct seq_file *, struct vfsmount *);
+	int (*show_stats)(struct seq_file *, struct dentry *);
 #ifdef CONFIG_QUOTA
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);

commit ece2ccb668046610189d88d6aaf05aeb09c988a1
Merge: d10577a8d86a a218d0fdc5f9 ff01bb483265
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 6 23:15:54 2012 -0500

    Merge branches 'vfsmount-guts', 'umode_t' and 'partitions' into Z

commit a218d0fdc5f9004164ff151d274487f6799907d0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Nov 21 14:59:34 2011 -0500

    switch open and mkdir syscalls to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9d02fab420c6..f0e57b7e4297 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2054,8 +2054,8 @@ extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 extern int do_fallocate(struct file *file, int mode, loff_t offset,
 			loff_t len);
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
-			int mode);
-extern struct file *filp_open(const char *, int, int);
+			umode_t mode);
+extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
 				   const char *, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,

commit 8d334acdd2c1f57c7a574c6f24d08e4c95582ff0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 24 23:21:59 2011 -0400

    switch is_sxid() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9db9f6e6c98b..9d02fab420c6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2690,7 +2690,7 @@ int __init get_filesystem_list(char *buf);
 #define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \
 					    (flag & __FMODE_NONOTIFY)))
 
-static inline int is_sxid(mode_t mode)
+static inline int is_sxid(umode_t mode)
 {
 	return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));
 }

commit 62bb109170375f82eb3c51c8080b72954f02dca7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 24 23:20:18 2011 -0400

    switch inode_init_owner() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b89eef1d1752..9db9f6e6c98b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1534,7 +1534,7 @@ extern void dentry_unhash(struct dentry *dentry);
  * VFS file helper functions.
  */
 extern void inode_init_owner(struct inode *inode, const struct inode *dir,
-			mode_t mode);
+			umode_t mode);
 /*
  * VFS FS_IOC_FIEMAP helper definitions.
  */

commit 1a67aafb5f72a436ca044293309fa7e6351d6a35
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:52:52 2011 -0400

    switch ->mknod() to umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e40321a6e239..b89eef1d1752 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1518,7 +1518,7 @@ extern void unlock_super(struct super_block *);
  */
 extern int vfs_create(struct inode *, struct dentry *, umode_t, struct nameidata *);
 extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
-extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
+extern int vfs_mknod(struct inode *, struct dentry *, umode_t, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
@@ -1625,7 +1625,7 @@ struct inode_operations {
 	int (*symlink) (struct inode *,struct dentry *,const char *);
 	int (*mkdir) (struct inode *,struct dentry *,umode_t);
 	int (*rmdir) (struct inode *,struct dentry *);
-	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
 	void (*truncate) (struct inode *);

commit 4acdaf27ebe2034c342f3be57ef49aed1ad885ef
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:42:34 2011 -0400

    switch ->create() to umode_t
    
    vfs_create() ignores everything outside of 16bit subset of its
    mode argument; switching it to umode_t is obviously equivalent
    and it's the only caller of the method
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f7bd8b12e37..e40321a6e239 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1516,7 +1516,7 @@ extern void unlock_super(struct super_block *);
 /*
  * VFS helper functions..
  */
-extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
+extern int vfs_create(struct inode *, struct dentry *, umode_t, struct nameidata *);
 extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
 extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
@@ -1619,7 +1619,7 @@ struct inode_operations {
 	int (*readlink) (struct dentry *, char __user *,int);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
 
-	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
+	int (*create) (struct inode *,struct dentry *,umode_t,struct nameidata *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);

commit 18bb1db3e7607e4a997d50991a6f9fa5b0f8722c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 01:41:39 2011 -0400

    switch vfs_mkdir() and ->mkdir() to umode_t
    
    vfs_mkdir() gets int, but immediately drops everything that might not
    fit into umode_t and that's the only caller of ->mkdir()...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cec429d76ab0..3f7bd8b12e37 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1517,7 +1517,7 @@ extern void unlock_super(struct super_block *);
  * VFS helper functions..
  */
 extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
-extern int vfs_mkdir(struct inode *, struct dentry *, int);
+extern int vfs_mkdir(struct inode *, struct dentry *, umode_t);
 extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
 extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
@@ -1623,7 +1623,7 @@ struct inode_operations {
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
-	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*mkdir) (struct inode *,struct dentry *,umode_t);
 	int (*rmdir) (struct inode *,struct dentry *);
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,

commit ff01bb4832651c6d25ac509a06a10fcbd75c461c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Sep 16 02:31:11 2011 -0400

    fs: move code out of buffer.c
    
    Move invalidate_bdev, block_sync_page into fs/block_dev.c.  Export
    kill_bdev as well, so brd doesn't have to open code it.  Reduce
    buffer_head.h requirement accordingly.
    
    Removed a rather large comment from invalidate_bdev, as it looked a bit
    obsolete to bother moving.  The small comment replacing it says enough.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cec429d76ab0..e853ba5eddd4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2092,6 +2092,7 @@ extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern void invalidate_bdev(struct block_device *);
 extern int sync_blockdev(struct block_device *bdev);
+extern void kill_bdev(struct block_device *);
 extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
@@ -2099,6 +2100,7 @@ extern int fsync_bdev(struct block_device *);
 #else
 static inline void bd_forget(struct inode *inode) {}
 static inline int sync_blockdev(struct block_device *bdev) { return 0; }
+static inline void kill_bdev(struct block_device *bdev) {}
 static inline void invalidate_bdev(struct block_device *bdev) {}
 
 static inline struct super_block *freeze_bdev(struct block_device *sb)
@@ -2415,6 +2417,7 @@ extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
 extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
 			int datasync);
+extern void block_sync_page(struct page *page);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,

commit cf31e70d6cf93f19fe9bf1144966ef40991ac723
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jan 2 22:28:36 2012 -0500

    vfs: new helper - vfs_ustat()
    
    ... and bury user_get_super()/statfs_by_dentry() - they are
    purely internal now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed17e54fd204..cec429d76ab0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1939,7 +1939,7 @@ extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 extern int vfs_statfs(struct path *, struct kstatfs *);
 extern int user_statfs(const char __user *, struct kstatfs *);
 extern int fd_statfs(int, struct kstatfs *);
-extern int statfs_by_dentry(struct dentry *, struct kstatfs *);
+extern int vfs_ustat(dev_t, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
@@ -2531,7 +2531,6 @@ extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);
 extern struct super_block *get_active_super(struct block_device *bdev);
-extern struct super_block *user_get_super(dev_t);
 extern void drop_super(struct super_block *sb);
 extern void iterate_supers(void (*)(struct super_block *, void *), void *);
 extern void iterate_supers_type(struct file_system_type *,

commit a5166169f9b920cae3c503910cb66a3ac5dd846d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 12 22:53:00 2011 -0500

    vfs: convert fs_supers to hlist
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0bc4ffb8e7f..ed17e54fd204 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1440,7 +1440,7 @@ struct super_block {
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;
 	struct mtd_info		*s_mtd;
-	struct list_head	s_instances;
+	struct hlist_node	s_instances;
 	struct quota_info	s_dquot;	/* Diskquota specific options */
 
 	int			s_frozen;
@@ -1864,7 +1864,7 @@ struct file_system_type {
 	void (*kill_sb) (struct super_block *);
 	struct module *owner;
 	struct file_system_type * next;
-	struct list_head fs_supers;
+	struct hlist_head fs_supers;
 
 	struct lock_class_key s_lock_key;
 	struct lock_class_key s_umount_key;

commit 83aeeada7c69f35e5100b27ec354335597a7a488
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Thu Dec 8 14:33:54 2011 -0800

    vmscan: use atomic-long for shrinker batching
    
    Use atomic-long operations instead of looping around cmpxchg().
    
    [akpm@linux-foundation.org: massage atomic.h inclusions]
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Cc: Dave Chinner <david@fromorbit.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 019dc558df1a..e0bc4ffb8e7f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -393,8 +393,8 @@ struct inodes_stat_t {
 #include <linux/semaphore.h>
 #include <linux/fiemap.h>
 #include <linux/rculist_bl.h>
-#include <linux/shrinker.h>
 #include <linux/atomic.h>
+#include <linux/shrinker.h>
 
 #include <asm/byteorder.h>
 

commit 02125a826459a6ad142f8d91c5b6357562f96615
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Dec 5 08:43:34 2011 -0500

    fix apparmor dereferencing potentially freed dentry, sanitize __d_path() API
    
    __d_path() API is asking for trouble and in case of apparmor d_namespace_path()
    getting just that.  The root cause is that when __d_path() misses the root
    it had been told to look for, it stores the location of the most remote ancestor
    in *root.  Without grabbing references.  Sure, at the moment of call it had
    been pinned down by what we have in *path.  And if we raced with umount -l, we
    could have very well stopped at vfsmount/dentry that got freed as soon as
    prepend_path() dropped vfsmount_lock.
    
    It is safe to compare these pointers with pre-existing (and known to be still
    alive) vfsmount and dentry, as long as all we are asking is "is it the same
    address?".  Dereferencing is not safe and apparmor ended up stepping into
    that.  d_namespace_path() really wants to examine the place where we stopped,
    even if it's not connected to our namespace.  As the result, it looked
    at ->d_sb->s_magic of a dentry that might've been already freed by that point.
    All other callers had been careful enough to avoid that, but it's really
    a bad interface - it invites that kind of trouble.
    
    The fix is fairly straightforward, even though it's bigger than I'd like:
            * prepend_path() root argument becomes const.
            * __d_path() is never called with NULL/NULL root.  It was a kludge
    to start with.  Instead, we have an explicit function - d_absolute_root().
    Same as __d_path(), except that it doesn't get root passed and stops where
    it stops.  apparmor and tomoyo are using it.
            * __d_path() returns NULL on path outside of root.  The main
    caller is show_mountinfo() and that's precisely what we pass root for - to
    skip those outside chroot jail.  Those who don't want that can (and do)
    use d_path().
            * __d_path() root argument becomes const.  Everyone agrees, I hope.
            * apparmor does *NOT* try to use __d_path() or any of its variants
    when it sees that path->mnt is an internal vfsmount.  In that case it's
    definitely not mounted anywhere and dentry_path() is exactly what we want
    there.  Handling of sysctl()-triggered weirdness is moved to that place.
            * if apparmor is asked to do pathname relative to chroot jail
    and __d_path() tells it we it's not in that jail, the sucker just calls
    d_absolute_path() instead.  That's the other remaining caller of __d_path(),
    BTW.
            * seq_path_root() does _NOT_ return -ENAMETOOLONG (it's stupid anyway -
    the normal seq_file logics will take care of growing the buffer and redoing
    the call of ->show() just fine).  However, if it gets path not reachable
    from root, it returns SEQ_SKIP.  The only caller adjusted (i.e. stopped
    ignoring the return value as it used to do).
    
    Reviewed-by: John Johansen <john.johansen@canonical.com>
    ACKed-by: John Johansen <john.johansen@canonical.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@vger.kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e3130220ce3e..019dc558df1a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1942,6 +1942,7 @@ extern int fd_statfs(int, struct kstatfs *);
 extern int statfs_by_dentry(struct dentry *, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
+extern bool our_mnt(struct vfsmount *mnt);
 
 extern int current_umask(void);
 

commit ea441d1104cf1efb471fa81bc91e9fd1e6ae29fd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Nov 16 21:43:59 2011 -0500

    new helper: mount_subtree()
    
    takes vfsmount and relative path, does lookup within that vfsmount
    (possibly triggering automounts) and returns the result as root
    of subtree suitable for return by ->mount() (i.e. a reference to
    dentry and an active reference to its superblock grabbed, superblock
    locked exclusive).
    
    btrfs and nfs switched to it instead of open-coding the sucker.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0c4df261af7e..e3130220ce3e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1886,6 +1886,7 @@ extern struct dentry *mount_single(struct file_system_type *fs_type,
 extern struct dentry *mount_nodev(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int));
+extern struct dentry *mount_subtree(struct vfsmount *mnt, const char *path);
 void generic_shutdown_super(struct super_block *sb);
 void kill_block_super(struct super_block *sb);
 void kill_anon_super(struct super_block *sb);

commit d211858837ff8d8e31942ca7d27e6e08b3b46f5e
Merge: f1f8935a5c38 f0023bc617ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 2 11:41:01 2011 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/hch/vfs-queue
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/hch/vfs-queue:
      vfs: add d_prune dentry operation
      vfs: protect i_nlink
      filesystems: add set_nlink()
      filesystems: add missing nlink wrappers
      logfs: remove unnecessary nlink setting
      ocfs2: remove unnecessary nlink setting
      jfs: remove unnecessary nlink setting
      hypfs: remove unnecessary nlink setting
      vfs: ignore error on forced remount
      readlinkat: ensure we return ENOENT for the empty pathname for normal lookups
      vfs: fix dentry leak in simple_fill_super()

commit f1f8935a5c38a2c61e86a42bc971a2539eef2211
Merge: 34116645d912 f2a44523b20f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 2 10:06:20 2011 -0700

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (97 commits)
      jbd2: Unify log messages in jbd2 code
      jbd/jbd2: validate sb->s_first in journal_get_superblock()
      ext4: let ext4_ext_rm_leaf work with EXT_DEBUG defined
      ext4: fix a syntax error in ext4_ext_insert_extent when debugging enabled
      ext4: fix a typo in struct ext4_allocation_context
      ext4: Don't normalize an falloc request if it can fit in 1 extent.
      ext4: remove comments about extent mount option in ext4_new_inode()
      ext4: let ext4_discard_partial_buffers handle unaligned range correctly
      ext4: return ENOMEM if find_or_create_pages fails
      ext4: move vars to local scope in ext4_discard_partial_page_buffers_no_lock()
      ext4: Create helper function for EXT4_IO_END_UNWRITTEN and i_aiodio_unwritten
      ext4: optimize locking for end_io extent conversion
      ext4: remove unnecessary call to waitqueue_active()
      ext4: Use correct locking for ext4_end_io_nolock()
      ext4: fix race in xattr block allocation path
      ext4: trace punch_hole correctly in ext4_ext_map_blocks
      ext4: clean up AGGRESSIVE_TEST code
      ext4: move variables to their scope
      ext4: fix quota accounting during migration
      ext4: migrate cleanup
      ...

commit a78ef704a8dd430225955f0709b22d4a6ba21deb
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 28 14:13:30 2011 +0200

    vfs: protect i_nlink
    
    Prevent direct modification of i_nlink by making it const and adding a
    non-const __i_nlink alias.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 48c1f5fc7411..23467d768cab 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -768,7 +768,17 @@ struct inode {
 
 	/* Stat data, not accessed from path walking */
 	unsigned long		i_ino;
-	unsigned int		i_nlink;
+	/*
+	 * Filesystems may only read i_nlink directly.  They shall use the
+	 * following functions for modification:
+	 *
+	 *    (set|clear|inc|drop)_nlink
+	 *    inode_(inc|dec)_link_count
+	 */
+	union {
+		const unsigned int i_nlink;
+		unsigned int __i_nlink;
+	};
 	dev_t			i_rdev;
 	loff_t			i_size;
 	struct timespec		i_atime;
@@ -1764,7 +1774,7 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
  */
 static inline void set_nlink(struct inode *inode, unsigned int nlink)
 {
-	inode->i_nlink = nlink;
+	inode->__i_nlink = nlink;
 }
 
 /**
@@ -1777,7 +1787,7 @@ static inline void set_nlink(struct inode *inode, unsigned int nlink)
  */
 static inline void inc_nlink(struct inode *inode)
 {
-	inode->i_nlink++;
+	inode->__i_nlink++;
 }
 
 static inline void inode_inc_link_count(struct inode *inode)
@@ -1799,7 +1809,7 @@ static inline void inode_inc_link_count(struct inode *inode)
  */
 static inline void drop_nlink(struct inode *inode)
 {
-	inode->i_nlink--;
+	inode->__i_nlink--;
 }
 
 /**
@@ -1812,7 +1822,7 @@ static inline void drop_nlink(struct inode *inode)
  */
 static inline void clear_nlink(struct inode *inode)
 {
-	inode->i_nlink = 0;
+	inode->__i_nlink = 0;
 }
 
 static inline void inode_dec_link_count(struct inode *inode)

commit bfe8684869601dacfcb2cd69ef8cfd9045f62170
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 28 14:13:29 2011 +0200

    filesystems: add set_nlink()
    
    Replace remaining direct i_nlink updates with a new set_nlink()
    updater function.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Tested-by: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a049fd2aa4c..48c1f5fc7411 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1754,6 +1754,19 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
 	__mark_inode_dirty(inode, I_DIRTY_SYNC);
 }
 
+/**
+ * set_nlink - directly set an inode's link count
+ * @inode: inode
+ * @nlink: new nlink (should be non-zero)
+ *
+ * This is a low-level filesystem helper to replace any
+ * direct filesystem manipulation of i_nlink.
+ */
+static inline void set_nlink(struct inode *inode, unsigned int nlink)
+{
+	inode->i_nlink = nlink;
+}
+
 /**
  * inc_nlink - directly increment an inode's link count
  * @inode: inode

commit b9075fa968a0a4347aef35e235e2995c0e57dddd
Author: Joe Perches <joe@perches.com>
Date:   Mon Oct 31 17:11:33 2011 -0700

    treewide: use __printf not __attribute__((format(printf,...)))
    
    Standardize the style for compiler based printf format verification.
    Standardized the location of __printf too.
    
    Done via script and a little typing.
    
    $ grep -rPl --include=*.[ch] -w "__attribute__" * | \
      grep -vP "^(tools|scripts|include/linux/compiler-gcc.h)" | \
      xargs perl -n -i -e 'local $/; while (<>) { s/\b__attribute__\s*\(\s*\(\s*format\s*\(\s*printf\s*,\s*(.+)\s*,\s*(.+)\s*\)\s*\)\s*\)/__printf($1, $2)/g ; print; }'
    
    [akpm@linux-foundation.org: revert arch bits]
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 87b4c6b9692d..7a049fd2aa4c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2635,8 +2635,8 @@ static const struct file_operations __fops = {				\
 	.llseek	 = generic_file_llseek,					\
 };
 
-static inline void __attribute__((format(printf, 1, 2)))
-__simple_attr_check_format(const char *fmt, ...)
+static inline __printf(1, 2)
+void __simple_attr_check_format(const char *fmt, ...)
 {
 	/* don't do anything, just let the compiler check the arguments; */
 }

commit fcf634098c00dd9cd247447368495f0b79be12d1
Author: Christopher Yeoh <cyeoh@au1.ibm.com>
Date:   Mon Oct 31 17:06:39 2011 -0700

    Cross Memory Attach
    
    The basic idea behind cross memory attach is to allow MPI programs doing
    intra-node communication to do a single copy of the message rather than a
    double copy of the message via shared memory.
    
    The following patch attempts to achieve this by allowing a destination
    process, given an address and size from a source process, to copy memory
    directly from the source process into its own address space via a system
    call.  There is also a symmetrical ability to copy from the current
    process's address space into a destination process's address space.
    
    - Use of /proc/pid/mem has been considered, but there are issues with
      using it:
      - Does not allow for specifying iovecs for both src and dest, assuming
        preadv or pwritev was implemented either the area read from or
      written to would need to be contiguous.
      - Currently mem_read allows only processes who are currently
      ptrace'ing the target and are still able to ptrace the target to read
      from the target. This check could possibly be moved to the open call,
      but its not clear exactly what race this restriction is stopping
      (reason  appears to have been lost)
      - Having to send the fd of /proc/self/mem via SCM_RIGHTS on unix
      domain socket is a bit ugly from a userspace point of view,
      especially when you may have hundreds if not (eventually) thousands
      of processes  that all need to do this with each other
      - Doesn't allow for some future use of the interface we would like to
      consider adding in the future (see below)
      - Interestingly reading from /proc/pid/mem currently actually
      involves two copies! (But this could be fixed pretty easily)
    
    As mentioned previously use of vmsplice instead was considered, but has
    problems.  Since you need the reader and writer working co-operatively if
    the pipe is not drained then you block.  Which requires some wrapping to
    do non blocking on the send side or polling on the receive.  In all to all
    communication it requires ordering otherwise you can deadlock.  And in the
    example of many MPI tasks writing to one MPI task vmsplice serialises the
    copying.
    
    There are some cases of MPI collectives where even a single copy interface
    does not get us the performance gain we could.  For example in an
    MPI_Reduce rather than copy the data from the source we would like to
    instead use it directly in a mathops (say the reduce is doing a sum) as
    this would save us doing a copy.  We don't need to keep a copy of the data
    from the source.  I haven't implemented this, but I think this interface
    could in the future do all this through the use of the flags - eg could
    specify the math operation and type and the kernel rather than just
    copying the data would apply the specified operation between the source
    and destination and store it in the destination.
    
    Although we don't have a "second user" of the interface (though I've had
    some nibbles from people who may be interested in using it for intra
    process messaging which is not MPI).  This interface is something which
    hardware vendors are already doing for their custom drivers to implement
    fast local communication.  And so in addition to this being useful for
    OpenMPI it would mean the driver maintainers don't have to fix things up
    when the mm changes.
    
    There was some discussion about how much faster a true zero copy would
    go. Here's a link back to the email with some testing I did on that:
    
    http://marc.info/?l=linux-mm&m=130105930902915&w=2
    
    There is a basic man page for the proposed interface here:
    
    http://ozlabs.org/~cyeoh/cma/process_vm_readv.txt
    
    This has been implemented for x86 and powerpc, other architecture should
    mainly (I think) just need to add syscall numbers for the process_vm_readv
    and process_vm_writev. There are 32 bit compatibility versions for
    64-bit kernels.
    
    For arch maintainers there are some simple tests to be able to quickly
    verify that the syscalls are working correctly here:
    
    http://ozlabs.org/~cyeoh/cma/cma-test-20110718.tgz
    
    Signed-off-by: Chris Yeoh <yeohc@au1.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Cc: <linux-man@vger.kernel.org>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14493a2d5a03..87b4c6b9692d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1633,9 +1633,10 @@ struct inode_operations {
 struct seq_file;
 
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
-				unsigned long nr_segs, unsigned long fast_segs,
-				struct iovec *fast_pointer,
-				struct iovec **ret_pointer);
+			      unsigned long nr_segs, unsigned long fast_segs,
+			      struct iovec *fast_pointer,
+			      struct iovec **ret_pointer,
+			      int check_access);
 
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);

commit 6cdbb0effc2f511ced23e46f2117e4b31d3d4a50
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Oct 29 08:24:18 2011 -0400

    fs: optimize out 16 bytes worth of padding in struct inode
    
    Rearrange the fields in struct inode so that on an x86_64 system,
    fields that require 8-byte alignment don't end up causing 4-byte holes
    in the structure.  It reduces the size of struct inode from 568 bytes
    to 552 bytes.
    
    Also move the fields protected by i_lock (i_blocks, i_bytes, and
    i_size) into the same cache line as i_lock.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 178cdb4f1d4a..fbda9a662f57 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -771,12 +771,13 @@ struct inode {
 	unsigned long		i_ino;
 	unsigned int		i_nlink;
 	dev_t			i_rdev;
-	loff_t			i_size;
 	struct timespec		i_atime;
 	struct timespec		i_mtime;
 	struct timespec		i_ctime;
-	unsigned int		i_blkbits;
+	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
+	unsigned short          i_bytes;
 	blkcnt_t		i_blocks;
+	loff_t			i_size;
 
 #ifdef __NEED_I_SIZE_ORDERED
 	seqcount_t		i_size_seqcount;
@@ -784,7 +785,6 @@ struct inode {
 
 	/* Misc */
 	unsigned long		i_state;
-	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	struct mutex		i_mutex;
 
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
@@ -798,9 +798,10 @@ struct inode {
 		struct rcu_head		i_rcu;
 	};
 	atomic_t		i_count;
+	unsigned int		i_blkbits;
 	u64			i_version;
-	unsigned short          i_bytes;
 	atomic_t		i_dio_count;
+	atomic_t		i_writecount;
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock	*i_flock;
 	struct address_space	i_data;
@@ -824,7 +825,6 @@ struct inode {
 #ifdef CONFIG_IMA
 	atomic_t		i_readcount; /* struct files open RO */
 #endif
-	atomic_t		i_writecount;
 	void			*i_private; /* fs or device private pointer */
 };
 

commit f362f98e7c445643d27c610bb7a86b79727b592e
Merge: f793f2961170 f3c7691e8d30
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 10:49:34 2011 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/hch/vfs-queue
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/hch/vfs-queue: (21 commits)
      leases: fix write-open/read-lease race
      nfs: drop unnecessary locking in llseek
      ext4: replace cut'n'pasted llseek code with generic_file_llseek_size
      vfs: add generic_file_llseek_size
      vfs: do (nearly) lockless generic_file_llseek
      direct-io: merge direct_io_walker into __blockdev_direct_IO
      direct-io: inline the complete submission path
      direct-io: separate map_bh from dio
      direct-io: use a slab cache for struct dio
      direct-io: rearrange fields in dio/dio_submit to avoid holes
      direct-io: fix a wrong comment
      direct-io: separate fields only used in the submission path from struct dio
      vfs: fix spinning prevention in prune_icache_sb
      vfs: add a comment to inode_permission()
      vfs: pass all mask flags check_acl and posix_acl_permission
      vfs: add hex format for MAY_* flag values
      vfs: indicate that the permission functions take all the MAY_* flags
      compat: sync compat_stats with statfs.
      vfs: add "device" tag to /proc/self/mountstats
      cleanup: vfs: small comment fix for block_invalidatepage
      ...
    
    Fix up trivial conflict in fs/gfs2/file.c (llseek changes)

commit 5760495a872d63a182962680a13c2af29235237c
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Sep 15 16:06:50 2011 -0700

    vfs: add generic_file_llseek_size
    
    Add a generic_file_llseek variant to the VFS that allows passing in
    the maximum file size of the file system, instead of always
    using maxbytes from the superblock.
    
    This can be used to eliminate some cut'n'paste seek code in ext4.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index db85196f6308..d055cc7d7240 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2403,6 +2403,8 @@ file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern loff_t noop_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t generic_file_llseek_size(struct file *file, loff_t offset,
+		int origin, loff_t maxsize);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit ef3d0fd27e90f67e35da516dafc1482c82939a60
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Sep 15 16:06:48 2011 -0700

    vfs: do (nearly) lockless generic_file_llseek
    
    The i_mutex lock use of generic _file_llseek hurts.  Independent processes
    accessing the same file synchronize over a single lock, even though
    they have no need for synchronization at all.
    
    Under high utilization this can cause llseek to scale very poorly on larger
    systems.
    
    This patch does some rethinking of the llseek locking model:
    
    First the 64bit f_pos is not necessarily atomic without locks
    on 32bit systems. This can already cause races with read() today.
    This was discussed on linux-kernel in the past and deemed acceptable.
    The patch does not change that.
    
    Let's look at the different seek variants:
    
    SEEK_SET: Doesn't really need any locking.
    If there's a race one writer wins, the other loses.
    
    For 32bit the non atomic update races against read()
    stay the same. Without a lock they can also happen
    against write() now.  The read() race was deemed
    acceptable in past discussions, and I think if it's
    ok for read it's ok for write too.
    
    => Don't need a lock.
    
    SEEK_END: This behaves like SEEK_SET plus it reads
    the maximum size too. Reading the maximum size would have the
    32bit atomic problem. But luckily we already have a way to read
    the maximum size without locking (i_size_read), so we
    can just use that instead.
    
    Without i_mutex there is no synchronization with write() anymore,
    however since the write() update is atomic on 64bit it just behaves
    like another racy SEEK_SET.  On non atomic 32bit it's the same
    as SEEK_SET.
    
    => Don't need a lock, but need to use i_size_read()
    
    SEEK_CUR: This has a read-modify-write race window
    on the same file. One could argue that any application
    doing unsynchronized seeks on the same file is already broken.
    But for the sake of not adding a regression here I'm
    using the file->f_lock to synchronize this. Using this
    lock is much better than the inode mutex because it doesn't
    synchronize between processes.
    
    => So still need a lock, but can use a f_lock.
    
    This patch implements this new scheme in generic_file_llseek.
    I dropped generic_file_llseek_unlocked and changed all callers.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c1884e974ff4..db85196f6308 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -964,7 +964,12 @@ struct file {
 #define f_dentry	f_path.dentry
 #define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
-	spinlock_t		f_lock;  /* f_ep_links, f_flags, no IRQ */
+
+	/*
+	 * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.
+	 * Must not be taken from IRQ context.
+	 */
+	spinlock_t		f_lock;
 #ifdef CONFIG_SMP
 	int			f_sb_list_cpu;
 #endif
@@ -2398,8 +2403,6 @@ file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern loff_t noop_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
-extern loff_t generic_file_llseek_unlocked(struct file *file, loff_t offset,
-			int origin);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit 8522ca5818652c4da6808c66a307abce75462212
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Sun Oct 23 23:13:31 2011 +0530

    vfs: add hex format for MAY_* flag values
    
    We are going to add more flags and having them in hex format
    make it simpler
    
    Acked-by: J. Bruce Fields <bfields@redhat.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 277f497923a2..c1884e974ff4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -58,14 +58,15 @@ struct inodes_stat_t {
 
 #define NR_FILE  8192	/* this can well be larger on a larger system */
 
-#define MAY_EXEC 1
-#define MAY_WRITE 2
-#define MAY_READ 4
-#define MAY_APPEND 8
-#define MAY_ACCESS 16
-#define MAY_OPEN 32
-#define MAY_CHDIR 64
-#define MAY_NOT_BLOCK 128	/* called from RCU mode, don't block */
+#define MAY_EXEC		0x00000001
+#define MAY_WRITE		0x00000002
+#define MAY_READ		0x00000004
+#define MAY_APPEND		0x00000008
+#define MAY_ACCESS		0x00000010
+#define MAY_OPEN		0x00000020
+#define MAY_CHDIR		0x00000040
+/* called from RCU mode, don't block */
+#define MAY_NOT_BLOCK		0x00000080
 
 /*
  * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond

commit 1442d1678ca7e53574fd403ba7bee6f4125d920c
Merge: 7e0bb71e7502 345c284290ca
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 25 15:42:01 2011 +0200

    Merge branch 'for-3.2' of git://linux-nfs.org/~bfields/linux
    
    * 'for-3.2' of git://linux-nfs.org/~bfields/linux: (103 commits)
      nfs41: implement DESTROY_CLIENTID operation
      nfsd4: typo logical vs bitwise negate for want_mask
      nfsd4: allow NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL | NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED
      nfsd4: seq->status_flags may be used unitialized
      nfsd41: use SEQ4_STATUS_BACKCHANNEL_FAULT when cb_sequence is invalid
      nfsd4: implement new 4.1 open reclaim types
      nfsd4: remove unneeded CLAIM_DELEGATE_CUR workaround
      nfsd4: warn on open failure after create
      nfsd4: preallocate open stateid in process_open1()
      nfsd4: do idr preallocation with stateid allocation
      nfsd4: preallocate nfs4_file in process_open1()
      nfsd4: clean up open owners on OPEN failure
      nfsd4: simplify process_open1 logic
      nfsd4: make is_open_owner boolean
      nfsd4: centralize renew_client() calls
      nfsd4: typo logical vs bitwise negate
      nfs: fix bug about IPv6 address scope checking
      nfsd4: more robust ignoring of WANT bits in OPEN
      nfsd4: move name-length checks to xdr
      nfsd4: move access/deny validity checks to xdr code
      ...

commit fed678dc8a8b839c8189b5d889a94e865cd327dd
Merge: 808bf29b9195 6c4867f64699
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 21 13:20:21 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.dk/linux-block
    
    * 'for-linus' of git://git.kernel.dk/linux-block:
      floppy: use del_timer_sync() in init cleanup
      blk-cgroup: be able to remove the record of unplugged device
      block: Don't check QUEUE_FLAG_SAME_COMP in __blk_complete_request
      mm: Add comment explaining task state setting in bdi_forker_thread()
      mm: Cleanup clearing of BDI_pending bit in bdi_forker_thread()
      block: simplify force plug flush code a little bit
      block: change force plug flush call order
      block: Fix queue_flag update when rq_affinity goes from 2 to 1
      block: separate priority boosting from REQ_META
      block: remove READ_META and WRITE_META
      xen-blkback: fixed indentation and comments
      xen-blkback: Don't disconnect backend until state switched to XenbusStateClosed.

commit e096d0c7e2e4e5893792db865dd065ac73cf1f00
Author: Josh Boyer <jwboyer@redhat.com>
Date:   Thu Aug 25 07:48:12 2011 -0400

    lockdep: Add helper function for dir vs file i_mutex annotation
    
    Purely in-memory filesystems do not use the inode hash as the dcache
    tells us if an entry already exists.  As a result, they do not call
    unlock_new_inode, and thus directory inodes do not get put into a
    different lockdep class for i_sem.
    
    We need the different lockdep classes, because the locking order for
    i_mutex is different for directory inodes and regular inodes.  Directory
    inodes can do "readdir()", which takes i_mutex *before* possibly taking
    mm->mmap_sem (due to a page fault while copying the directory entry to
    user space).
    
    In contrast, regular inodes can be mmap'ed, which takes mm->mmap_sem
    before accessing i_mutex.
    
    The two cases can never happen for the same inode, so no real deadlock
    can occur, but without the different lockdep classes, lockdep cannot
    understand that.  As a result, if CONFIG_DEBUG_LOCK_ALLOC is set, this
    can lead to false positives from lockdep like below:
    
        find/645 is trying to acquire lock:
         (&mm->mmap_sem){++++++}, at: [<ffffffff81109514>] might_fault+0x5c/0xac
    
        but task is already holding lock:
         (&sb->s_type->i_mutex_key#15){+.+.+.}, at: [<ffffffff81149f34>]
        vfs_readdir+0x5b/0xb4
    
        which lock already depends on the new lock.
    
        the existing dependency chain (in reverse order) is:
    
        -> #1 (&sb->s_type->i_mutex_key#15){+.+.+.}:
              [<ffffffff8108ac26>] lock_acquire+0xbf/0x103
              [<ffffffff814db822>] __mutex_lock_common+0x4c/0x361
              [<ffffffff814dbc46>] mutex_lock_nested+0x40/0x45
              [<ffffffff811daa87>] hugetlbfs_file_mmap+0x82/0x110
              [<ffffffff81111557>] mmap_region+0x258/0x432
              [<ffffffff811119dd>] do_mmap_pgoff+0x2ac/0x306
              [<ffffffff81111b4f>] sys_mmap_pgoff+0x118/0x16a
              [<ffffffff8100c858>] sys_mmap+0x22/0x24
              [<ffffffff814e3ec2>] system_call_fastpath+0x16/0x1b
    
        -> #0 (&mm->mmap_sem){++++++}:
              [<ffffffff8108a4bc>] __lock_acquire+0xa1a/0xcf7
              [<ffffffff8108ac26>] lock_acquire+0xbf/0x103
              [<ffffffff81109541>] might_fault+0x89/0xac
              [<ffffffff81149cff>] filldir+0x6f/0xc7
              [<ffffffff811586ea>] dcache_readdir+0x67/0x205
              [<ffffffff81149f54>] vfs_readdir+0x7b/0xb4
              [<ffffffff8114a073>] sys_getdents+0x7e/0xd1
              [<ffffffff814e3ec2>] system_call_fastpath+0x16/0x1b
    
    This patch moves the directory vs file lockdep annotation into a helper
    function that can be called by in-memory filesystems and has hugetlbfs
    call it.
    
    Signed-off-by: Josh Boyer <jwboyer@redhat.com>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 178cdb4f1d4a..c2bd68f2277a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2318,6 +2318,11 @@ extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*te
 extern struct inode * iget_locked(struct super_block *, unsigned long);
 extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
 extern int insert_inode_locked(struct inode *);
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+extern void lockdep_annotate_inode_mutex_key(struct inode *inode);
+#else
+static inline void lockdep_annotate_inode_mutex_key(struct inode *inode) { };
+#endif
 extern void unlock_new_inode(struct inode *);
 extern unsigned int get_next_ino(void);
 

commit 5dc06c5a70b79a323152bec7e55783e705767e63
Author: Christoph Hellwig <hch@infradead.org>
Date:   Tue Aug 23 14:49:55 2011 +0200

    block: remove READ_META and WRITE_META
    
    Replace all occurnanced of the undocumented READ_META with READ | REQ_META
    and remove the unused WRITE_META define.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 178cdb4f1d4a..eae44c981173 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -162,10 +162,8 @@ struct inodes_stat_t {
 #define READA			RWA_MASK
 
 #define READ_SYNC		(READ | REQ_SYNC)
-#define READ_META		(READ | REQ_META)
 #define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)
 #define WRITE_ODIRECT		(WRITE | REQ_SYNC)
-#define WRITE_META		(WRITE | REQ_META)
 #define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
 #define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)
 #define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)

commit 778fc546f749c588aa2f6cd50215d2715c374252
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Jul 26 18:25:49 2011 -0400

    locks: fix tracking of inprogress lease breaks
    
    We currently use a bit in fl_flags to record whether a lease is being
    broken, and set fl_type to the type (RDLCK or UNLCK) that it will
    eventually have.  This means that once the lease break starts, we forget
    what the lease's type *used* to be.  Breaking a read lease will then
    result in blocking read opens, even though there's no conflict--because
    the lease type is now F_UNLCK and we can no longer tell whether it was
    previously a read or write lease.
    
    So, instead keep fl_type as the original type (the type which we
    enforce), and keep track of whether we're unlocking or merely
    downgrading by replacing the single FL_INPROGRESS flag by
    FL_UNLOCK_PENDING and FL_DOWNGRADE_PENDING flags.
    
    To get this right we also need to track separate downgrade and break
    times, to handle the case where a write-leased file gets conflicting
    opens first for read, then later for write.
    
    (I first considered just eliminating the downgrade behavior
    completely--nfsv4 doesn't need it, and nobody as far as I can tell
    actually uses it currently--but Jeremy Allison tells me that Windows
    oplocks do behave this way, so Samba will probably use this some day.)
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 327fdd4de85f..76460edf1648 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1065,7 +1065,8 @@ static inline int file_check_writeable(struct file *filp)
 #define FL_LEASE	32	/* lease held on this file */
 #define FL_CLOSE	64	/* unlock on close */
 #define FL_SLEEP	128	/* A blocking lock */
-#define FL_INPROGRESS	256	/* Lease is being broken */
+#define FL_DOWNGRADE_PENDING	256 /* Lease is being downgraded */
+#define FL_UNLOCK_PENDING	512 /* Lease is being broken */
 
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for
@@ -1122,7 +1123,9 @@ struct file_lock {
 	loff_t fl_end;
 
 	struct fasync_struct *	fl_fasync; /* for lease break notifications */
-	unsigned long fl_break_time;	/* for nonblocking lease breaks */
+	/* for lease breaks: */
+	unsigned long fl_break_time;
+	unsigned long fl_downgrade_time;
 
 	const struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
 	const struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */

commit 710b7216964d6455cf1b215c43b03a1a79008c7d
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Tue Jul 26 16:28:29 2011 -0400

    locks: move F_INPROGRESS from fl_type to fl_flags field
    
    F_INPROGRESS isn't exposed to userspace.  To me it makes more sense in
    fl_flags....
    
    Reviewed-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 178cdb4f1d4a..327fdd4de85f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1065,6 +1065,7 @@ static inline int file_check_writeable(struct file *filp)
 #define FL_LEASE	32	/* lease held on this file */
 #define FL_CLOSE	64	/* unlock on close */
 #define FL_SLEEP	128	/* A blocking lock */
+#define FL_INPROGRESS	256	/* Lease is being broken */
 
 /*
  * Special return value from posix_lock_file() and vfs_lock_file() for
@@ -1111,7 +1112,7 @@ struct file_lock {
 	struct list_head fl_link;	/* doubly linked list of all locks */
 	struct list_head fl_block;	/* circular list of blocked processes */
 	fl_owner_t fl_owner;
-	unsigned char fl_flags;
+	unsigned int fl_flags;
 	unsigned char fl_type;
 	unsigned int fl_pid;
 	struct pid *fl_nspid;

commit 3ddcd0569cd68f00f3beae9a7959b72918bb91f4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 6 22:45:50 2011 -0700

    vfs: optimize inode cache access patterns
    
    The inode structure layout is largely random, and some of the vfs paths
    really do care.  The path lookup in particular is already quite D$
    intensive, and profiles show that accessing the 'inode->i_op->xyz'
    fields is quite costly.
    
    We already optimized the dcache to not unnecessarily load the d_op
    structure for members that are often NULL using the DCACHE_OP_xyz bits
    in dentry->d_flags, and this does something very similar for the inode
    ops that are used during pathname lookup.
    
    It also re-orders the fields so that the fields accessed by 'stat' are
    together at the beginning of the inode structure, and roughly in the
    order accessed.
    
    The effect of this seems to be in the 1-2% range for an empty kernel
    "make -j" run (which is fairly kernel-intensive, mostly in filename
    lookup), so it's visible.  The numbers are fairly noisy, though, and
    likely depend a lot on exact microarchitecture.  So there's more tuning
    to be done.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 786b3b1113cf..178cdb4f1d4a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -738,22 +738,54 @@ static inline int mapping_writably_mapped(struct address_space *mapping)
 struct posix_acl;
 #define ACL_NOT_CACHED ((void *)(-1))
 
+#define IOP_FASTPERM	0x0001
+#define IOP_LOOKUP	0x0002
+#define IOP_NOFOLLOW	0x0004
+
+/*
+ * Keep mostly read-only and often accessed (especially for
+ * the RCU path lookup and 'stat' data) fields at the beginning
+ * of the 'struct inode'
+ */
 struct inode {
-	/* RCU path lookup touches following: */
 	umode_t			i_mode;
+	unsigned short		i_opflags;
 	uid_t			i_uid;
 	gid_t			i_gid;
+	unsigned int		i_flags;
+
+#ifdef CONFIG_FS_POSIX_ACL
+	struct posix_acl	*i_acl;
+	struct posix_acl	*i_default_acl;
+#endif
+
 	const struct inode_operations	*i_op;
 	struct super_block	*i_sb;
+	struct address_space	*i_mapping;
 
-	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
-	unsigned int		i_flags;
-	unsigned long		i_state;
 #ifdef CONFIG_SECURITY
 	void			*i_security;
 #endif
-	struct mutex		i_mutex;
 
+	/* Stat data, not accessed from path walking */
+	unsigned long		i_ino;
+	unsigned int		i_nlink;
+	dev_t			i_rdev;
+	loff_t			i_size;
+	struct timespec		i_atime;
+	struct timespec		i_mtime;
+	struct timespec		i_ctime;
+	unsigned int		i_blkbits;
+	blkcnt_t		i_blocks;
+
+#ifdef __NEED_I_SIZE_ORDERED
+	seqcount_t		i_size_seqcount;
+#endif
+
+	/* Misc */
+	unsigned long		i_state;
+	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
+	struct mutex		i_mutex;
 
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
 
@@ -765,25 +797,12 @@ struct inode {
 		struct list_head	i_dentry;
 		struct rcu_head		i_rcu;
 	};
-	unsigned long		i_ino;
 	atomic_t		i_count;
-	unsigned int		i_nlink;
-	dev_t			i_rdev;
-	unsigned int		i_blkbits;
 	u64			i_version;
-	loff_t			i_size;
-#ifdef __NEED_I_SIZE_ORDERED
-	seqcount_t		i_size_seqcount;
-#endif
-	struct timespec		i_atime;
-	struct timespec		i_mtime;
-	struct timespec		i_ctime;
-	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;
 	atomic_t		i_dio_count;
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock	*i_flock;
-	struct address_space	*i_mapping;
 	struct address_space	i_data;
 #ifdef CONFIG_QUOTA
 	struct dquot		*i_dquot[MAXQUOTAS];
@@ -806,10 +825,6 @@ struct inode {
 	atomic_t		i_readcount; /* struct files open RO */
 #endif
 	atomic_t		i_writecount;
-#ifdef CONFIG_FS_POSIX_ACL
-	struct posix_acl	*i_acl;
-	struct posix_acl	*i_default_acl;
-#endif
 	void			*i_private; /* fs or device private pointer */
 };
 

commit f2ee7abf4c40c8e6bffced923a7c01ea2d1f6c97
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Jul 28 06:41:09 2011 +0200

    vfs: avoid taking inode_hash_lock on pipes and sockets
    
    Some inodes (pipes, sockets, ...) are not hashed, no need to take
    contended inode_hash_lock at dismantle time.
    
    nice speedup on SMP machines on socket intensive workloads.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f23bcb77260c..786b3b1113cf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2317,11 +2317,18 @@ extern int should_remove_suid(struct dentry *);
 extern int file_remove_suid(struct file *);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
-extern void remove_inode_hash(struct inode *);
 static inline void insert_inode_hash(struct inode *inode)
 {
 	__insert_inode_hash(inode, inode->i_ino);
 }
+
+extern void __remove_inode_hash(struct inode *);
+static inline void remove_inode_hash(struct inode *inode)
+{
+	if (!inode_unhashed(inode))
+		__remove_inode_hash(inode);
+}
+
 extern void inode_sb_list_add(struct inode *inode);
 
 #ifdef CONFIG_BLOCK

commit e371d46ae45488bcb112a99a7de462e9e3aa6764
Merge: b0189cd087aa e57712ebebbb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 26 18:30:20 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      merge fchmod() and fchmodat() guts, kill ancient broken kludge
      xfs: fix misspelled S_IS...()
      xfs: get rid of open-coded S_ISREG(), etc.
      vfs: document locking requirements for d_move, __d_move and d_materialise_unique
      omfs: fix (mode & S_IFDIR) abuse
      btrfs: S_ISREG(mode) is not mode & S_IFREG...
      ima: fmode_t misspelled as mode_t...
      pci-label.c: size_t misspelled as mode_t
      jffs2: S_ISLNK(mode & S_IFMT) is pointless
      snd_msnd ->mode is fmode_t, not mode_t
      v9fs_iop_get_acl: get rid of unused variable
      vfs: dont chain pipe/anon/socket on superblock s_inodes list
      Documentation: Exporting: update description of d_splice_alias
      fs: add missing unlock in default_llseek()

commit a209dfc7b0d94bd6fa94553c097836a2e6d0f0ba
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Jul 26 11:36:34 2011 +0200

    vfs: dont chain pipe/anon/socket on superblock s_inodes list
    
    Workloads using pipes and sockets hit inode_sb_list_lock contention.
    
    superblock s_inodes list is needed for quota, dirty, pagecache and
    fsnotify management. pipe/anon/socket fs are clearly not candidates for
    these.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a6658043258a..cc363fa7bb82 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2310,7 +2310,8 @@ extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
 extern void end_writeback(struct inode *);
 extern void __destroy_inode(struct inode *);
-extern struct inode *new_inode(struct super_block *);
+extern struct inode *new_inode_pseudo(struct super_block *sb);
+extern struct inode *new_inode(struct super_block *sb);
 extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_suid(struct file *);

commit 2dad3206db5c3832cde1f58650027fea3ff7adf3
Merge: 84635d68be4b 0c12eaffdf09
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 22:49:19 2011 -0700

    Merge branch 'for-3.1' of git://linux-nfs.org/~bfields/linux
    
    * 'for-3.1' of git://linux-nfs.org/~bfields/linux:
      nfsd: don't break lease on CLAIM_DELEGATE_CUR
      locks: rename lock-manager ops
      nfsd4: update nfsv4.1 implementation notes
      nfsd: turn on reply cache for NFSv4
      nfsd4: call nfsd4_release_compoundargs from pc_release
      nfsd41: Deny new lock before RECLAIM_COMPLETE done
      fs: locks: remove init_once
      nfsd41: check the size of request
      nfsd41: error out when client sets maxreq_sz or maxresp_sz too small
      nfsd4: fix file leak on open_downgrade
      nfsd4: remember to put RW access on stateid destruction
      NFSD: Added TEST_STATEID operation
      NFSD: added FREE_STATEID operation
      svcrpc: fix list-corrupting race on nfsd shutdown
      rpc: allow autoloading of gss mechanisms
      svcauth_unix.c: quiet sparse noise
      svcsock.c: include sunrpc.h to quiet sparse noise
      nfsd: Remove deprecated nfsctl system call and related code.
      NFSD: allow OP_DESTROY_CLIENTID to be only op in COMPOUND
    
    Fix up trivial conflicts in Documentation/feature-removal-schedule.txt

commit d3ec4844d449cf7af9e749f73ba2052fb7b72fc2
Merge: 0003230e8200 df2e301fee3c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 13:56:39 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (43 commits)
      fs: Merge split strings
      treewide: fix potentially dangerous trailing ';' in #defined values/expressions
      uwb: Fix misspelling of neighbourhood in comment
      net, netfilter: Remove redundant goto in ebt_ulog_packet
      trivial: don't touch files that are removed in the staging tree
      lib/vsprintf: replace link to Draft by final RFC number
      doc: Kconfig: `to be' -> `be'
      doc: Kconfig: Typo: square -> squared
      doc: Konfig: Documentation/power/{pm => apm-acpi}.txt
      drivers/net: static should be at beginning of declaration
      drivers/media: static should be at beginning of declaration
      drivers/i2c: static should be at beginning of declaration
      XTENSA: static should be at beginning of declaration
      SH: static should be at beginning of declaration
      MIPS: static should be at beginning of declaration
      ARM: static should be at beginning of declaration
      rcu: treewide: Do not use rcu_read_lock_held when calling rcu_dereference_check
      Update my e-mail address
      PCIe ASPM: forcedly -> forcibly
      gma500: push through device driver tree
      ...
    
    Fix up trivial conflicts:
     - arch/arm/mach-ep93xx/dma-m2p.c (deleted)
     - drivers/gpio/gpio-ep93xx.c (renamed and context nearby)
     - drivers/net/r8169.c (just context changes)

commit 0003230e8200699860f0b10af524dc47bf8aecad
Merge: 4b478cedcdc1 4e34e719e457
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 12:53:15 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      fs: take the ACL checks to common code
      bury posix_acl_..._masq() variants
      kill boilerplates around posix_acl_create_masq()
      generic_acl: no need to clone acl just to push it to set_cached_acl()
      kill boilerplate around posix_acl_chmod_masq()
      reiserfs: cache negative ACLs for v1 stat format
      xfs: cache negative ACLs if there is no attribute fork
      9p: do no return 0 from ->check_acl without actually checking
      vfs: move ACL cache lookup into generic code
      CIFS: Fix oops while mounting with prefixpath
      xfs: Fix wrong return value of xfs_file_aio_write
      fix devtmpfs race
      caam: don't pass bogus S_IFCHR to debugfs_create_...()
      get rid of create_proc_entry() abuses - proc_mkdir() is there for purpose
      asus-wmi: ->is_visible() can't return negative
      fix jffs2 ACLs on big-endian with 16bit mode_t
      9p: close ACL leaks
      ocfs2_init_acl(): fix a leak
      VFS : mount lock scalability for internal mounts

commit 4e34e719e457f2e031297175410fc0bd4016a085
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jul 23 17:37:31 2011 +0200

    fs: take the ACL checks to common code
    
    Replace the ->check_acl method with a ->get_acl method that simply reads an
    ACL from disk after having a cache miss.  This means we can replace the ACL
    checking boilerplate code with a single implementation in namei.c.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a757a48a5c6..12f84b30c3ca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1586,7 +1586,7 @@ struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	void * (*follow_link) (struct dentry *, struct nameidata *);
 	int (*permission) (struct inode *, int);
-	int (*check_acl)(struct inode *, int);
+	struct posix_acl * (*get_acl)(struct inode *, int);
 
 	int (*readlink) (struct dentry *, char __user *,int);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);

commit 096a705bbc080a4041636d07514560da8d78acbe
Merge: fea80311a939 5757a6d76cdf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 25 10:33:36 2011 -0700

    Merge branch 'for-3.1/core' of git://git.kernel.dk/linux-block
    
    * 'for-3.1/core' of git://git.kernel.dk/linux-block: (24 commits)
      block: strict rq_affinity
      backing-dev: use synchronize_rcu_expedited instead of synchronize_rcu
      block: fix patch import error in max_discard_sectors check
      block: reorder request_queue to remove 64 bit alignment padding
      CFQ: add think time check for group
      CFQ: add think time check for service tree
      CFQ: move think time check variables to a separate struct
      fixlet: Remove fs_excl from struct task.
      cfq: Remove special treatment for metadata rqs.
      block: document blk_plug list access
      block: avoid building too big plug list
      compat_ioctl: fix make headers_check regression
      block: eliminate potential for infinite loop in blkdev_issue_discard
      compat_ioctl: fix warning caused by qemu
      block: flush MEDIA_CHANGE from drivers on close(2)
      blk-throttle: Make total_nr_queued unsigned
      block: Add __attribute__((format(printf...) and fix fallout
      fs/partitions/check.c: make local symbols static
      block:remove some spare spaces in genhd.c
      block:fix the comment error in blkdev.h
      ...

commit 423e0ab086ad8b33626e45fa94ac7613146b7ffa
Author: Tim Chen <tim.c.chen@linux.intel.com>
Date:   Tue Jul 19 09:32:38 2011 -0700

    VFS : mount lock scalability for internal mounts
    
    For a number of file systems that don't have a mount point (e.g. sockfs
    and pipefs), they are not marked as long term. Therefore in
    mntput_no_expire, all locks in vfs_mount lock are taken instead of just
    local cpu's lock to aggregate reference counts when we release
    reference to file objects.  In fact, only local lock need to have been
    taken to update ref counts as these file systems are in no danger of
    going away until we are ready to unregister them.
    
    The attached patch marks file systems using kern_mount without
    mount point as long term.  The contentions of vfs_mount lock
    is now eliminated.  Before un-registering such file system,
    kern_unmount should be called to remove the long term flag and
    make the mount point ready to be freed.
    
    Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b224dc468a23..7a757a48a5c6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1885,6 +1885,7 @@ extern int register_filesystem(struct file_system_type *);
 extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
 #define kern_mount(type) kern_mount_data(type, NULL)
+extern void kern_unmount(struct vfsmount *mnt);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);

commit ed70afcd6e795e3de98df56f1cd0f898fbf641a7
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Jul 21 13:55:37 2011 -0700

    mm/truncate.c: fix build for CONFIG_BLOCK not enabled
    
    Fix build error when CONFIG_BLOCK is not enabled by providing a stub
    inode_dio_wait() function.
    
    mm/truncate.c:612: error: implicit declaration of function 'inode_dio_wait'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0569e4ab2d5..b224dc468a23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2423,6 +2423,10 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 				    offset, nr_segs, get_block, NULL, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
+#else
+static inline void inode_dio_wait(struct inode *inode)
+{
+}
 #endif
 
 extern const struct file_operations generic_ro_fops;

commit 295cc522c2b2834b302424e41ebb5846df6d61bd
Author: Wanlong Gao <gaowanlong@cn.fujitsu.com>
Date:   Tue Jul 19 09:48:39 2011 +0800

    fs:update the NOTE of the file_operations structure
    
    Big kernel lock had been removed and setlease now use the lock_flocks()
    to hold a special spin lock file_lock_lock by Matthew.
    So just remove the out-of-date NOTE.
    
    Signed-off-by: Wanlong Gao <gaowanlong@cn.fujitsu.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9cd2075c4a39..e0569e4ab2d5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1552,11 +1552,6 @@ struct block_device_operations;
 #define HAVE_COMPAT_IOCTL 1
 #define HAVE_UNLOCKED_IOCTL 1
 
-/*
- * NOTE:
- * all file operations except setlease can be called without
- * the big kernel lock held in all filesystems.
- */
 struct file_operations {
 	struct module *owner;
 	loff_t (*llseek) (struct file *, loff_t, int);

commit 02c24a82187d5a628c68edfe71ae60dc135cd178
Author: Josef Bacik <josef@redhat.com>
Date:   Sat Jul 16 20:44:56 2011 -0400

    fs: push i_mutex and filemap_write_and_wait down into ->fsync() handlers
    
    Btrfs needs to be able to control how filemap_write_and_wait_range() is called
    in fsync to make it less of a painful operation, so push down taking i_mutex and
    the calling of filemap_write_and_wait() down into the ->fsync() handlers.  Some
    file systems can drop taking the i_mutex altogether it seems, like ext3 and
    ocfs2.  For correctness sake I just pushed everything down in all cases to make
    sure that we keep the current behavior the same for everybody, and then each
    individual fs maintainer can make up their mind about what to do from there.
    Thanks,
    
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a61f98823a6..9cd2075c4a39 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1572,7 +1572,7 @@ struct file_operations {
 	int (*open) (struct inode *, struct file *);
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);
-	int (*fsync) (struct file *, int datasync);
+	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
 	int (*aio_fsync) (struct kiocb *, int datasync);
 	int (*fasync) (int, struct file *, int);
 	int (*lock) (struct file *, int, struct file_lock *);
@@ -2360,7 +2360,8 @@ extern int generic_segment_checks(const struct iovec *iov,
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
-extern int blkdev_fsync(struct file *filp, int datasync);
+extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
+			int datasync);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,
@@ -2490,7 +2491,7 @@ extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
-extern int noop_fsync(struct file *, int);
+extern int noop_fsync(struct file *, loff_t, loff_t, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
@@ -2515,7 +2516,7 @@ extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
 		const void __user *from, size_t count);
 
-extern int generic_file_fsync(struct file *, int);
+extern int generic_file_fsync(struct file *, loff_t, loff_t, int);
 
 extern int generic_check_addressable(unsigned, u64);
 

commit 982d816581eeeacfe5b2b7c6d47d13a157616eff
Author: Josef Bacik <josef@redhat.com>
Date:   Mon Jul 18 13:21:35 2011 -0400

    fs: add SEEK_HOLE and SEEK_DATA flags
    
    This just gets us ready to support the SEEK_HOLE and SEEK_DATA flags.  Turns out
    using fiemap in things like cp cause more problems than it solves, so lets try
    and give userspace an interface that doesn't suck.  We need to match solaris
    here, and the definitions are
    
    *o* If /whence/ is SEEK_HOLE, the offset of the start of the
    next hole greater than or equal to the supplied offset
    is returned. The definition of a hole is provided near
    the end of the DESCRIPTION.
    
    *o* If /whence/ is SEEK_DATA, the file pointer is set to the
    start of the next non-hole file region greater than or
    equal to the supplied offset.
    
    So in the generic case the entire file is data and there is a virtual hole at
    the end.  That means we will just return i_size for SEEK_HOLE and will return
    the same offset for SEEK_DATA.  This is how Solaris does it so we have to do it
    the same way.
    
    Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 824453be9fee..4a61f98823a6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -32,7 +32,9 @@
 #define SEEK_SET	0	/* seek relative to beginning of file */
 #define SEEK_CUR	1	/* seek relative to current file position */
 #define SEEK_END	2	/* seek relative to end of file */
-#define SEEK_MAX	SEEK_END
+#define SEEK_DATA	3	/* seek to the next data */
+#define SEEK_HOLE	4	/* seek to the next hole */
+#define SEEK_MAX	SEEK_HOLE
 
 struct fstrim_range {
 	__u64 start;

commit aacfc19c626ebd3daa675652457d71019a1f583f
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Jun 24 14:29:47 2011 -0400

    fs: simplify the blockdev_direct_IO prototype
    
    Simple filesystems always pass inode->i_sb_bdev as the block device
    argument, and never need a end_io handler.  Let's simply things for
    them and for my grepping activity by dropping these arguments.  The
    only thing not falling into that scheme is ext4, which passes and
    end_io handler without needing special flags (yet), but given how
    messy the direct I/O code there is use of __blockdev_direct_IO
    in one instead of two out of three cases isn't going to make a large
    difference anyway.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2fe920774abf..824453be9fee 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2418,12 +2418,11 @@ ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	dio_submit_t submit_io,	int flags);
 
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
+		struct inode *inode, const struct iovec *iov, loff_t offset,
+		unsigned long nr_segs, get_block_t get_block)
 {
-	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				    nr_segs, get_block, end_io, NULL,
+	return __blockdev_direct_IO(rw, iocb, inode, inode->i_sb->s_bdev, iov,
+				    offset, nr_segs, get_block, NULL, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
 #endif

commit bd5fe6c5eb9c548d7f07fe8f89a150bb6705e8e3
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri Jun 24 14:29:43 2011 -0400

    fs: kill i_alloc_sem
    
    i_alloc_sem is a rather special rw_semaphore.  It's the last one that may
    be released by a non-owner, and it's write side is always mirrored by
    real exclusion.  It's intended use it to wait for all pending direct I/O
    requests to finish before starting a truncate.
    
    Replace it with a hand-grown construct:
    
     - exclusion for truncates is already guaranteed by i_mutex, so it can
       simply fall way
     - the reader side is replaced by an i_dio_count member in struct inode
       that counts the number of pending direct I/O requests.  Truncate can't
       proceed as long as it's non-zero
     - when i_dio_count reaches non-zero we wake up a pending truncate using
       wake_up_bit on a new bit in i_flags
     - new references to i_dio_count can't appear while we are waiting for
       it to read zero because the direct I/O count always needs i_mutex
       (or an equivalent like XFS's i_iolock) for starting a new operation.
    
    This scheme is much simpler, and saves the space of a spinlock_t and a
    struct list_head in struct inode (typically 160 bits on a non-debug 64-bit
    system).
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1393742bba9b..2fe920774abf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -779,7 +779,7 @@ struct inode {
 	struct timespec		i_ctime;
 	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;
-	struct rw_semaphore	i_alloc_sem;
+	atomic_t		i_dio_count;
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct file_lock	*i_flock;
 	struct address_space	*i_mapping;
@@ -1705,6 +1705,10 @@ struct super_operations {
  *			set during data writeback, and cleared with a wakeup
  *			on the bit address once it is done.
  *
+ * I_REFERENCED		Marks the inode as recently references on the LRU list.
+ *
+ * I_DIO_WAKEUP		Never set.  Only used as a key for wait_on_bit().
+ *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
 #define I_DIRTY_SYNC		(1 << 0)
@@ -1718,6 +1722,8 @@ struct super_operations {
 #define __I_SYNC		7
 #define I_SYNC			(1 << __I_SYNC)
 #define I_REFERENCED		(1 << 8)
+#define __I_DIO_WAKEUP		9
+#define I_DIO_WAKEUP		(1 << I_DIO_WAKEUP)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 
@@ -1828,7 +1834,6 @@ struct file_system_type {
 	struct lock_class_key i_lock_key;
 	struct lock_class_key i_mutex_key;
 	struct lock_class_key i_mutex_dir_key;
-	struct lock_class_key i_alloc_sem_key;
 };
 
 extern struct dentry *mount_ns(struct file_system_type *fs_type, int flags,
@@ -2404,6 +2409,8 @@ enum {
 };
 
 void dio_end_io(struct bio *bio, int error);
+void inode_dio_wait(struct inode *inode);
+void inode_dio_done(struct inode *inode);
 
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,

commit 0e1fdafd93980eac62e778798549ce0f6073905c
Author: Dave Chinner <dchinner@redhat.com>
Date:   Fri Jul 8 14:14:44 2011 +1000

    superblock: add filesystem shrinker operations
    
    Now we have a per-superblock shrinker implementation, we can add a
    filesystem specific callout to it to allow filesystem internal
    caches to be shrunk by the superblock shrinker.
    
    Rather than perpetuate the multipurpose shrinker callback API (i.e.
    nr_to_scan == 0 meaning "tell me how many objects freeable in the
    cache), two operations will be added. The first will return the
    number of objects that are freeable, the second is the actual
    shrinker call.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d7f35e90b84a..1393742bba9b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1655,6 +1655,8 @@ struct super_operations {
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
+	int (*nr_cached_objects)(struct super_block *);
+	void (*free_cached_objects)(struct super_block *, int);
 };
 
 /*

commit b0d40c92adafde7c2d81203ce7c1c69275f41140
Author: Dave Chinner <dchinner@redhat.com>
Date:   Fri Jul 8 14:14:42 2011 +1000

    superblock: introduce per-sb cache shrinker infrastructure
    
    With context based shrinkers, we can implement a per-superblock
    shrinker that shrinks the caches attached to the superblock. We
    currently have global shrinkers for the inode and dentry caches that
    split up into per-superblock operations via a coarse proportioning
    method that does not batch very well.  The global shrinkers also
    have a dependency - dentries pin inodes - so we have to be very
    careful about how we register the global shrinkers so that the
    implicit call order is always correct.
    
    With a per-sb shrinker callout, we can encode this dependency
    directly into the per-sb shrinker, hence avoiding the need for
    strictly ordering shrinker registrations. We also have no need for
    any proportioning code for the shrinker subsystem already provides
    this functionality across all shrinkers. Allowing the shrinker to
    operate on a single superblock at a time means that we do less
    superblock list traversals and locking and reclaim should batch more
    effectively. This should result in less CPU overhead for reclaim and
    potentially faster reclaim of items from each filesystem.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 460d2cc21ec6..d7f35e90b84a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -393,6 +393,7 @@ struct inodes_stat_t {
 #include <linux/semaphore.h>
 #include <linux/fiemap.h>
 #include <linux/rculist_bl.h>
+#include <linux/shrinker.h>
 #include <linux/atomic.h>
 
 #include <asm/byteorder.h>
@@ -1444,8 +1445,14 @@ struct super_block {
 	 * Saved pool identifier for cleancache (-1 means none)
 	 */
 	int cleancache_poolid;
+
+	struct shrinker s_shrink;	/* per-sb shrinker handle */
 };
 
+/* superblock cache pruning functions */
+extern void prune_icache_sb(struct super_block *sb, int nr_to_scan);
+extern void prune_dcache_sb(struct super_block *sb, int nr_to_scan);
+
 extern struct timespec current_fs_time(struct super_block *sb);
 
 /*

commit 8fb47a4fbf858a164e973b8ea8ef5e83e61f2e50
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Wed Jul 20 20:21:59 2011 -0400

    locks: rename lock-manager ops
    
    Both the filesystem and the lock manager can associate operations with a
    lock.  Confusingly, one of them (fl_release_private) actually has the
    same name in both operation structures.
    
    It would save some confusion to give the lock-manager ops different
    names.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b5b979247863..cf719beb2016 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1069,12 +1069,12 @@ struct file_lock_operations {
 };
 
 struct lock_manager_operations {
-	int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
-	void (*fl_notify)(struct file_lock *);	/* unblock callback */
-	int (*fl_grant)(struct file_lock *, struct file_lock *, int);
-	void (*fl_release_private)(struct file_lock *);
-	void (*fl_break)(struct file_lock *);
-	int (*fl_change)(struct file_lock **, int);
+	int (*lm_compare_owner)(struct file_lock *, struct file_lock *);
+	void (*lm_notify)(struct file_lock *);	/* unblock callback */
+	int (*lm_grant)(struct file_lock *, struct file_lock *, int);
+	void (*lm_release_private)(struct file_lock *);
+	void (*lm_break)(struct file_lock *);
+	int (*lm_change)(struct file_lock **, int);
 };
 
 struct lock_manager {

commit 09cc9fc7a7c3d872065426d7fb0f0ad6d3eb90fc
Author: Dave Chinner <dchinner@redhat.com>
Date:   Fri Jul 8 14:14:40 2011 +1000

    inode: move to per-sb LRU locks
    
    With the inode LRUs moving to per-sb structures, there is no longer
    a need for a global inode_lru_lock. The locking can be made more
    fine-grained by moving to a per-sb LRU lock, isolating the LRU
    operations of different filesytsems completely from each other.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9724f0a48742..460d2cc21ec6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1397,7 +1397,8 @@ struct super_block {
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	int			s_nr_dentry_unused;	/* # of dentry on lru */
 
-	/* inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */
+	/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */
+	spinlock_t		s_inode_lru_lock ____cacheline_aligned_in_smp;
 	struct list_head	s_inode_lru;		/* unused inode lru */
 	int			s_nr_inodes_unused;	/* # of inodes on lru */
 

commit 98b745c647a5a90c3c21ea43cbfad9a47b0dfad7
Author: Dave Chinner <dchinner@redhat.com>
Date:   Fri Jul 8 14:14:39 2011 +1000

    inode: Make unused inode LRU per superblock
    
    The inode unused list is currently a global LRU. This does not match
    the other global filesystem cache - the dentry cache - which uses
    per-superblock LRU lists. Hence we have related filesystem object
    types using different LRU reclaimation schemes.
    
    To enable a per-superblock filesystem cache shrinker, both of these
    caches need to have per-sb unused object LRU lists. Hence this patch
    converts the global inode LRU to per-sb LRUs.
    
    The patch only does rudimentary per-sb propotioning in the shrinker
    infrastructure, as this gets removed when the per-sb shrinker
    callouts are introduced later on.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a0011aef4338..9724f0a48742 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1397,6 +1397,10 @@ struct super_block {
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	int			s_nr_dentry_unused;	/* # of dentry on lru */
 
+	/* inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */
+	struct list_head	s_inode_lru;		/* unused inode lru */
+	int			s_nr_inodes_unused;	/* # of inodes on lru */
+
 	struct block_device	*s_bdev;
 	struct backing_dev_info *s_bdi;
 	struct mtd_info		*s_mtd;

commit 0ee5dc676a5f8fadede608c7281dfedb1ae714ea
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jul 7 15:44:25 2011 -0400

    btrfs: kill magical embedded struct superblock
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8494aac189f0..a0011aef4338 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1835,6 +1835,8 @@ void kill_litter_super(struct super_block *sb);
 void deactivate_super(struct super_block *sb);
 void deactivate_locked_super(struct super_block *sb);
 int set_anon_super(struct super_block *s, void *data);
+int get_anon_bdev(dev_t *);
+void free_anon_bdev(dev_t);
 struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),

commit 729cdb3a1ee03a4363f9c7e66ddd979727e99e1f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jun 21 01:01:22 2011 -0400

    kill IPERM_FLAG_RCU
    
    not used anymore
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1fdefe3995fd..8494aac189f0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1573,8 +1573,6 @@ struct file_operations {
 			  loff_t len);
 };
 
-#define IPERM_FLAG_RCU	0x0001
-
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	void * (*follow_link) (struct dentry *, struct nameidata *);

commit 10556cb21a0d0b24d95f00ea6df16f599a3345b2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:28:19 2011 -0400

    ->permission() sanitizing: don't pass flags to ->permission()
    
    not used by the instances anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a1689c13eb77..1fdefe3995fd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1578,7 +1578,7 @@ struct file_operations {
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	void * (*follow_link) (struct dentry *, struct nameidata *);
-	int (*permission) (struct inode *, int, unsigned int);
+	int (*permission) (struct inode *, int);
 	int (*check_acl)(struct inode *, int);
 
 	int (*readlink) (struct dentry *, char __user *,int);

commit 2830ba7f34ebb27c4e5b8b6ef408cd6d74860890
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:16:29 2011 -0400

    ->permission() sanitizing: don't pass flags to generic_permission()
    
    redundant; all callers get it duplicated in mask & MAY_NOT_BLOCK and none of
    them removes that bit.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f218b42718aa..a1689c13eb77 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2188,7 +2188,7 @@ extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct iattr *);
 extern int inode_permission(struct inode *, int);
-extern int generic_permission(struct inode *, int, unsigned int);
+extern int generic_permission(struct inode *, int);
 
 static inline bool execute_ok(struct inode *inode)
 {

commit 7e40145eb111a5192e6d819f764db9d6828d1abb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 19:12:17 2011 -0400

    ->permission() sanitizing: don't pass flags to ->check_acl()
    
    not used in the instances anymore.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 60c1fe65bb2d..f218b42718aa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1579,7 +1579,7 @@ struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	void * (*follow_link) (struct dentry *, struct nameidata *);
 	int (*permission) (struct inode *, int, unsigned int);
-	int (*check_acl)(struct inode *, int, unsigned int);
+	int (*check_acl)(struct inode *, int);
 
 	int (*readlink) (struct dentry *, char __user *,int);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);

commit 1fc0f78ca9f311c6277e2f1b7655bb4d43ceb311
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 18:59:02 2011 -0400

    ->permission() sanitizing: MAY_NOT_BLOCK
    
    Duplicate the flags argument into mask bitmap.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0c15d5e459d5..60c1fe65bb2d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -63,6 +63,7 @@ struct inodes_stat_t {
 #define MAY_ACCESS 16
 #define MAY_OPEN 32
 #define MAY_CHDIR 64
+#define MAY_NOT_BLOCK 128	/* called from RCU mode, don't block */
 
 /*
  * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond

commit 178ea73521d64ba41d7aa5488fb9f549c6d4507d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 11:31:30 2011 -0400

    kill check_acl callback of generic_permission()
    
    its value depends only on inode and does not change; we might as
    well store it in ->i_op->check_acl and be done with that.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8c84ed930389..0c15d5e459d5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2187,8 +2187,7 @@ extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct iattr *);
 extern int inode_permission(struct inode *, int);
-extern int generic_permission(struct inode *, int, unsigned int,
-		int (*check_acl)(struct inode *, int, unsigned int));
+extern int generic_permission(struct inode *, int, unsigned int);
 
 static inline bool execute_ok(struct inode *inode)
 {

commit 07b8ce1ee87d291ff564c02cf878fae973317a52
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 20 10:52:57 2011 -0400

    lockless get_write_access/deny_write_access
    
    new helpers: atomic_inc_unless_negative()/atomic_dec_unless_positive()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d04e55586a17..8c84ed930389 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -392,8 +392,8 @@ struct inodes_stat_t {
 #include <linux/semaphore.h>
 #include <linux/fiemap.h>
 #include <linux/rculist_bl.h>
+#include <linux/atomic.h>
 
-#include <asm/atomic.h>
 #include <asm/byteorder.h>
 
 struct export_operations;
@@ -2195,8 +2195,31 @@ static inline bool execute_ok(struct inode *inode)
 	return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
 }
 
-extern int get_write_access(struct inode *);
-extern int deny_write_access(struct file *);
+/*
+ * get_write_access() gets write permission for a file.
+ * put_write_access() releases this write permission.
+ * This is used for regular files.
+ * We cannot support write (and maybe mmap read-write shared) accesses and
+ * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode
+ * can have the following values:
+ * 0: no writers, no VM_DENYWRITE mappings
+ * < 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist
+ * > 0: (i_writecount) users are writing to the file.
+ *
+ * Normally we operate on that counter with atomic_{inc,dec} and it's safe
+ * except for the cases where we don't hold i_writecount yet. Then we need to
+ * use {get,deny}_write_access() - these functions check the sign and refuse
+ * to do the change if sign is wrong.
+ */
+static inline int get_write_access(struct inode *inode)
+{
+	return atomic_inc_unless_negative(&inode->i_writecount) ? 0 : -ETXTBSY;
+}
+static inline int deny_write_access(struct file *file)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	return atomic_dec_unless_positive(&inode->i_writecount) ? 0 : -ETXTBSY;
+}
 static inline void put_write_access(struct inode * inode)
 {
 	atomic_dec(&inode->i_writecount);

commit 3bfa784a6539f91a27d7ffdd408efdb638e3bebd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 19 12:55:10 2011 -0400

    kill file_permission() completely
    
    convert the last remaining caller to inode_permission()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a8735e7e1b35..d04e55586a17 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1490,7 +1490,6 @@ extern void dentry_unhash(struct dentry *dentry);
 /*
  * VFS file helper functions.
  */
-extern int file_permission(struct file *, int);
 extern void inode_init_owner(struct inode *inode, const struct inode *dir,
 			mode_t mode);
 /*

commit 43e15cdbefea4ce6d68113de98d4f61c0cf45687
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 3 20:16:57 2011 -0400

    new helper: iterate_supers_type()
    
    Call the given function for all superblocks of given type.  Function
    gets a superblock (with s_umount locked shared) and (void *) argument
    supplied by caller of iterator.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b5b979247863..a8735e7e1b35 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2432,6 +2432,8 @@ extern struct super_block *get_active_super(struct block_device *bdev);
 extern struct super_block *user_get_super(dev_t);
 extern void drop_super(struct super_block *sb);
 extern void iterate_supers(void (*)(struct super_block *, void *), void *);
+extern void iterate_supers_type(struct file_system_type *,
+			        void (*)(struct super_block *, void *), void *);
 
 extern int dcache_dir_open(struct inode *, struct file *);
 extern int dcache_dir_close(struct inode *, struct file *);

commit 4aede84b33d6beb401136a3deca0651ae07c5e99
Author: Justin TerAvest <teravest@google.com>
Date:   Tue Jul 12 08:31:45 2011 +0200

    fixlet: Remove fs_excl from struct task.
    
    fs_excl is a poor man's priority inheritance for filesystems to hint to
    the block layer that an operation is important. It was never clearly
    specified, not widely adopted, and will not prevent starvation in many
    cases (like across cgroups).
    
    fs_excl was introduced with the time sliced CFQ IO scheduler, to
    indicate when a process held FS exclusive resources and thus needed
    a boost.
    
    It doesn't cover all file systems, and it was never fully complete.
    Lets kill it.
    
    Signed-off-by: Justin TerAvest <teravest@google.com>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e73e2e9ae33..f6c866c287b5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1453,10 +1453,6 @@ enum {
 #define vfs_check_frozen(sb, level) \
 	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
 
-#define get_fs_excl() atomic_inc(&current->fs_excl)
-#define put_fs_excl() atomic_dec(&current->fs_excl)
-#define has_fs_excl() atomic_read(&current->fs_excl)
-
 /*
  * until VFS tracks user namespaces for inodes, just make all files
  * belong to init_user_ns

commit b7e9c223be8ce335e30f2cf6ba588e6a4092275c
Merge: c172d82500a6 e3bbfa78bab1
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Mon Jul 11 14:15:48 2011 +0200

    Merge branch 'master' into for-next
    
    Sync with Linus' tree to be able to apply pending patches that
    are based on newer code already present upstream.

commit 08142579b6ca35883c1ed066a2681de6f6917062
Author: Jan Kara <jack@suse.cz>
Date:   Mon Jun 27 16:18:10 2011 -0700

    mm: fix assertion mapping->nrpages == 0 in end_writeback()
    
    Under heavy memory and filesystem load, users observe the assertion
    mapping->nrpages == 0 in end_writeback() trigger.  This can be caused by
    page reclaim reclaiming the last page from a mapping in the following
    race:
    
            CPU0                            CPU1
      ...
      shrink_page_list()
        __remove_mapping()
          __delete_from_page_cache()
            radix_tree_delete()
                                            evict_inode()
                                              truncate_inode_pages()
                                                truncate_inode_pages_range()
                                                  pagevec_lookup() - finds nothing
                                              end_writeback()
                                                mapping->nrpages != 0 -> BUG
            page->mapping = NULL
            mapping->nrpages--
    
    Fix the problem by doing a reliable check of mapping->nrpages under
    mapping->tree_lock in end_writeback().
    
    Analyzed by Jay <jinshan.xiong@whamcloud.com>, lost in LKML, and dug out
    by Miklos Szeredi <mszeredi@suse.de>.
    
    Cc: Jay <jinshan.xiong@whamcloud.com>
    Cc: Miklos Szeredi <mszeredi@suse.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6e73e2e9ae33..b5b979247863 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -639,6 +639,7 @@ struct address_space {
 	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
 	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
+	/* Protected by tree_lock together with the radix tree */
 	unsigned long		nrpages;	/* number of total pages */
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */

commit 79568f5be06c91071697c065f01f3ebfbeb25a61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 20 20:13:49 2011 -0700

    vfs: i_state needs to be 'unsigned long' for now
    
    Commit 13e12d14e2dc ("vfs: reorganize 'struct inode' layout a bit")
    moved things around a bit changed i_state to be unsigned int instead of
    unsigned long.  That was to help structure layout for the 64-bit case,
    and shrink 'struct inode' a bit (admittedly that only happened when
    spinlock debugging was on and i_flags didn't pack with i_lock).
    
    However, Meelis Roos reports that this results in unaligned exceptions
    on sprc, and it turns out that the bit-locking primitives that we use
    for the I_NEW bit want to use the bitops.  Which want 'unsigned long',
    not 'unsigned int'.
    
    We really should fix the bit locking code to not have that kind of
    requirement, but that's a much bigger change.  So for now, revert that
    field back to 'unsigned long' (but keep the other re-ordering changes
    from the commit that caused this).
    
    Andi points out that we have played games with this in 'struct page', so
    it's solvable with other hacks too, but since right now the struct inode
    size advantage only happens with some rare config options, it's not
    worth fighting.
    
    It _would_ be worth fixing the bitlocking code, though.  Especially
    since there is no type safety in the bitlocking code (this never caused
    any warnings, and worked fine on x86-64, because the bitlocks take a
    'void *' and x86-64 doesn't care that deeply about alignment).  So it's
    currently a very easy problem to trigger by mistake and never notice.
    
    Reported-by: Meelis Roos <mroos@linux.ee>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1c777878f1ea..6e73e2e9ae33 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -744,7 +744,7 @@ struct inode {
 
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	unsigned int		i_flags;
-	unsigned int		i_state;
+	unsigned long		i_state;
 #ifdef CONFIG_SECURITY
 	void			*i_security;
 #endif

commit e44ba033c5654dbfda53461c9b1f7dd9bd1d198f
Author: Vitaliy Ivanov <vitalivanov@gmail.com>
Date:   Mon Jun 20 16:08:07 2011 +0200

    treewide: remove duplicate includes
    
    Many stupid corrections of duplicated includes based on the output of
    scripts/checkincludes.pl.
    
    Signed-off-by: Vitaliy Ivanov <vitalivanov@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1c777878f1ea..450ca245df84 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -376,7 +376,6 @@ struct inodes_stat_t {
 
 #include <linux/linkage.h>
 #include <linux/wait.h>
-#include <linux/types.h>
 #include <linux/kdev_t.h>
 #include <linux/dcache.h>
 #include <linux/path.h>

commit 13e12d14e2dccc7995b8f15a5678a338ab4e6a8c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 8 15:18:19 2011 -0700

    vfs: reorganize 'struct inode' layout a bit
    
    This tries to make the 'struct inode' accesses denser in the data cache
    by moving a commonly accessed field (i_security) closer to other fields
    that are accessed often.
    
    It also makes 'i_state' just an 'unsigned int' rather than 'unsigned
    long', since we only use a few bits of that field, and moves it next to
    the existing 'i_flags' so that we potentially get better structure
    layout (although depending on config options, i_flags may already have
    packed in the same word as i_lock, so this improves packing only for the
    case of spinlock debugging)
    
    Out 'struct inode' is still way too big, and we should probably move
    some other fields around too (the acl fields in particular) for better
    data cache access density.  Other fields (like the inode hash) are
    likely to be entirely irrelevant under most loads.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 646a1836152a..1c777878f1ea 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -744,9 +744,13 @@ struct inode {
 
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	unsigned int		i_flags;
+	unsigned int		i_state;
+#ifdef CONFIG_SECURITY
+	void			*i_security;
+#endif
 	struct mutex		i_mutex;
 
-	unsigned long		i_state;
+
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
 
 	struct hlist_node	i_hash;
@@ -798,9 +802,6 @@ struct inode {
 	atomic_t		i_readcount; /* struct files open RO */
 #endif
 	atomic_t		i_writecount;
-#ifdef CONFIG_SECURITY
-	void			*i_security;
-#endif
 #ifdef CONFIG_FS_POSIX_ACL
 	struct posix_acl	*i_acl;
 	struct posix_acl	*i_default_acl;

commit 9e1f1de02c2275d7172e18dc4e7c2065777611bf
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 3 18:24:58 2011 -0400

    more conservative S_NOSEC handling
    
    Caching "we have already removed suid/caps" was overenthusiastic as merged.
    On network filesystems we might have had suid/caps set on another client,
    silently picked by this client on revalidate, all of that *without* clearing
    the S_NOSEC flag.
    
    AFAICS, the only reasonably sane way to deal with that is
            * new superblock flag; unless set, S_NOSEC is not going to be set.
            * local block filesystems set it in their ->mount() (more accurately,
    mount_bdev() does, so does btrfs ->mount(), users of mount_bdev() other than
    local block ones clear it)
            * if any network filesystem (or a cluster one) wants to use S_NOSEC,
    it'll need to set MS_NOSEC in sb->s_flags *AND* take care to clear S_NOSEC when
    inode attribute changes are picked from other clients.
    
    It's not an earth-shattering hole (anybody that can set suid on another client
    will almost certainly be able to write to the file before doing that anyway),
    but it's a bug that needs fixing.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c55d6b7cd5d6..646a1836152a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -208,6 +208,7 @@ struct inodes_stat_t {
 #define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
 #define MS_I_VERSION	(1<<23) /* Update inode I_version field */
 #define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
+#define MS_NOSEC	(1<<28)
 #define MS_BORN		(1<<29)
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
@@ -2591,7 +2592,7 @@ static inline int is_sxid(mode_t mode)
 
 static inline void inode_has_no_xattr(struct inode *inode)
 {
-	if (!is_sxid(inode->i_mode))
+	if (!is_sxid(inode->i_mode) && (inode->i_sb->s_flags & MS_NOSEC))
 		inode->i_flags |= S_NOSEC;
 }
 

commit 69b4573296469fd3f70cf7044693074980517067
Author: Andi Kleen <ak@linux.intel.com>
Date:   Sat May 28 08:25:51 2011 -0700

    Cache xattr security drop check for write v2
    
    Some recent benchmarking on btrfs showed that a major scaling bottleneck
    on large systems on btrfs is currently the xattr lookup on every write.
    
    Why xattr lookup on every write I hear you ask?
    
    write wants to drop suid and security related xattrs that could set o
    capabilities for executables.  To do that it currently looks up
    security.capability on EVERY write (even for non executables) to decide
    whether to drop it or not.
    
    In btrfs this causes an additional tree walk, hitting some per file system
    locks and quite bad scalability. In a simple read workload on a 8S
    system I saw over 90% CPU time in spinlocks related to that.
    
    Chris Mason tells me this is also a problem in ext4, where it hits
    the global mbcache lock.
    
    This patch adds a simple per inode to avoid this problem.  We only
    do the lookup once per file and then if there is no xattr cache
    the decision. All xattr changes clear the flag.
    
    I also used the same flag to avoid the suid check, although
    that one is pretty cheap.
    
    A file system can also set this flag when it creates the inode,
    if it has a cheap way to do so.  This is done for some common file systems
    in followon patches.
    
    With this patch a major part of the lock contention disappears
    for btrfs. Some testing on smaller systems didn't show significant
    performance changes, but at least it helps the larger systems
    and is generally more efficient.
    
    v2: Rename is_sgid. add file system helper.
    Cc: chris.mason@oracle.com
    Cc: josef@redhat.com
    Cc: viro@zeniv.linux.org.uk
    Cc: agruen@linbit.com
    Cc: Serge E. Hallyn <serue@us.ibm.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 573028df050d..c55d6b7cd5d6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -237,6 +237,7 @@ struct inodes_stat_t {
 #define S_PRIVATE	512	/* Inode is fs-internal */
 #define S_IMA		1024	/* Inode has an associated IMA struct */
 #define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
+#define S_NOSEC		4096	/* no suid or xattr security attributes */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -273,6 +274,7 @@ struct inodes_stat_t {
 #define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
 #define IS_IMA(inode)		((inode)->i_flags & S_IMA)
 #define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
+#define IS_NOSEC(inode)		((inode)->i_flags & S_NOSEC)
 
 /* the read-only stuff doesn't really belong here, but any other place is
    probably as bad and I don't want to create yet another include file. */
@@ -2582,5 +2584,16 @@ int __init get_filesystem_list(char *buf);
 #define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \
 					    (flag & __FMODE_NONOTIFY)))
 
+static inline int is_sxid(mode_t mode)
+{
+	return (mode & S_ISUID) || ((mode & S_ISGID) && (mode & S_IXGRP));
+}
+
+static inline void inode_has_no_xattr(struct inode *inode)
+{
+	if (!is_sxid(inode->i_mode))
+		inode->i_flags |= S_NOSEC;
+}
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit aa38572954ade525817fe88c54faebf85e5a61c0
Author: Christoph Hellwig <hch@infradead.org>
Date:   Fri May 27 06:53:02 2011 -0400

    fs: pass exact type of data dirties to ->dirty_inode
    
    Tell the filesystem if we just updated timestamp (I_DIRTY_SYNC) or
    anything else, so that the filesystem can track internally if it
    needs to push out a transaction for fdatasync or not.
    
    This is just the prototype change with no user for it yet.  I plan
    to push large XFS changes for the next merge window, and getting
    this trivial infrastructure in this window would help a lot to avoid
    tree interdependencies.
    
    Also remove incorrect comments that ->dirty_inode can't block.  That
    has been changed a long time ago, and many implementations rely on it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 241609346dfb..573028df050d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1618,7 +1618,7 @@ struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);
 	void (*destroy_inode)(struct inode *);
 
-   	void (*dirty_inode) (struct inode *);
+   	void (*dirty_inode) (struct inode *, int flags);
 	int (*write_inode) (struct inode *, struct writeback_control *wbc);
 	int (*drop_inode) (struct inode *);
 	void (*evict_inode) (struct inode *);

commit f8d613e2a665bf1be9628a3c3f9bafe7599b32c0
Merge: 8a0599dd2471 5bc20fc59706
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 26 10:50:56 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/djm/tmem
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/djm/tmem:
      xen: cleancache shim to Xen Transcendent Memory
      ocfs2: add cleancache support
      ext4: add cleancache support
      btrfs: add cleancache support
      ext3: add cleancache support
      mm/fs: add hooks to support cleancache
      mm: cleancache core ops functions and config
      fs: add field to superblock to support cleancache
      mm/fs: cleancache documentation
    
    Fix up trivial conflict in fs/btrfs/extent_io.c due to includes

commit 9fdfdcf17151e8326c4d18cc133abc6e58f47568
Author: Dan Magenheimer <dan.magenheimer@oracle.com>
Date:   Thu May 26 10:01:19 2011 -0600

    fs: add field to superblock to support cleancache
    
    This second patch of eight in this cleancache series adds a field to
    the generic superblock to squirrel away a pool identifier that is
    dynamically provided by cleancache-enabled filesystems at mount time
    to uniquely identify files and pages belonging to this mounted filesystem.
    
    Details and a FAQ can be found in Documentation/vm/cleancache.txt
    
    [v8: trivial merge conflict update]
    Signed-off-by: Dan Magenheimer <dan.magenheimer@oracle.com>
    Reviewed-by: Jeremy Fitzhardinge <jeremy@goop.org>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: Rik Van Riel <riel@redhat.com>
    Cc: Jan Beulich <JBeulich@novell.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Andreas Dilger <adilger@sun.com>
    Cc: Ted Ts'o <tytso@mit.edu>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <joel.becker@oracle.com>
    Cc: Nitin Gupta <ngupta@vflare.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cdf9495df204..0169ed3f106e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1429,6 +1429,11 @@ struct super_block {
 	 */
 	char __rcu *s_options;
 	const struct dentry_operations *s_d_op; /* default d_op for dentries */
+
+	/*
+	 * Saved pool identifier for cleancache (-1 means none)
+	 */
+	int cleancache_poolid;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 0ac1ee0bfec2a4ad118f907ce586d0dfd8db7641
Author: Tim Gardner <tim.gardner@canonical.com>
Date:   Tue May 24 17:13:05 2011 -0700

    ulimit: raise default hard ulimit on number of files to 4096
    
    Apps are increasingly using more than 1024 file descriptors.  See
    discussion in several distro bug trackers, e.g.  BugLink:
    http://bugs.launchpad.net/bugs/663090
    https://issues.rpath.com/browse/RPL-2054
    
    You don't want to raise the default soft limit, since that might break
    apps that use select(), but it's safe to raise the default hard limit;
    that way, apps that know they need lots of file descriptors can raise
    their soft limit without needing root, and without user intervention.
    
    Ubuntu is doing this with a kernel change because they have a policy of
    not changing kernel defaults in userland.
    
    While 4096 might not be enough for *all* apps, it seems to be plenty for
    the apps I've seen lately that are unhappy with 1024.
    
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Cc: Dan Kegel <dank@kegel.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bb9e826019b..3f9d3251790d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -23,7 +23,8 @@
 
 /* Fixed constants first: */
 #undef NR_OPEN
-#define INR_OPEN 1024		/* Initial setting for nfile rlimits */
+#define INR_OPEN_CUR 1024	/* Initial setting for nfile rlimits */
+#define INR_OPEN_MAX 4096	/* Hard limit for nfile rlimits */
 
 #define BLOCK_SIZE_BITS 10
 #define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)

commit 3d48ae45e72390ddf8cc5256ac32ed6f7a19cbea
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Tue May 24 17:12:06 2011 -0700

    mm: Convert i_mmap_lock to a mutex
    
    Straightforward conversion of i_mmap_lock to a mutex.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5d2c86bdf5ba..5bb9e826019b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -634,7 +634,7 @@ struct address_space {
 	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
 	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
-	spinlock_t		i_mmap_lock;	/* protect tree, count, list */
+	struct mutex		i_mmap_mutex;	/* protect tree, count, list */
 	unsigned long		nrpages;	/* number of total pages */
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */

commit 97a894136f29802da19a15541de3c019e1ca147e
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Tue May 24 17:12:04 2011 -0700

    mm: Remove i_mmap_lock lockbreak
    
    Hugh says:
     "The only significant loser, I think, would be page reclaim (when
      concurrent with truncation): could spin for a long time waiting for
      the i_mmap_mutex it expects would soon be dropped? "
    
    Counter points:
     - cpu contention makes the spin stop (need_resched())
     - zap pages should be freeing pages at a higher rate than reclaim
       ever can
    
    I think the simplification of the truncate code is definitely worth it.
    
    Effectively reverts: 2aa15890f3c ("mm: prevent concurrent
    unmap_mapping_range() on the same inode") and takes out the code that
    caused its problem.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Namhyung Kim <namhyung@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cdf9495df204..5d2c86bdf5ba 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -635,7 +635,6 @@ struct address_space {
 	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
 	spinlock_t		i_mmap_lock;	/* protect tree, count, list */
-	unsigned int		truncate_count;	/* Cover race condition with truncate */
 	unsigned long		nrpages;	/* number of total pages */
 	pgoff_t			writeback_index;/* writeback starts here */
 	const struct address_space_operations *a_ops;	/* methods */
@@ -644,7 +643,6 @@ struct address_space {
 	spinlock_t		private_lock;	/* for use by the address_space */
 	struct list_head	private_list;	/* ditto */
 	struct address_space	*assoc_mapping;	/* ditto */
-	struct mutex		unmap_mutex;    /* to protect unmapping */
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but

commit eed631e0d741d1a1067cfc6d709fdf2363126f9c
Merge: bd1a643e10eb ebcb904dfe31
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun May 15 10:22:10 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable:
      Btrfs: fix FS_IOC_SETFLAGS ioctl
      Btrfs: fix FS_IOC_GETFLAGS ioctl
      fs: remove FS_COW_FL
      Btrfs: fix easily get into ENOSPC in mixed case
      Prevent oopsing in posix_acl_valid()

commit e1e8fb6a1ff3f9487e03a4cbf85b81d1316068ce
Author: Li Zefan <lizf@cn.fujitsu.com>
Date:   Fri Apr 15 03:02:49 2011 +0000

    fs: remove FS_COW_FL
    
    FS_COW_FL and FS_NOCOW_FL were newly introduced to control per file
    COW in btrfs, but FS_NOCOW_FL is sufficient.
    
    The fact is we don't have corresponding BTRFS_INODE_COW flag.
    
    COW is default, and FS_NOCOW_FL can be used to switch off COW for
    a single file.
    
    If we mount btrfs with nodatacow, a newly created file will be set with
    the FS_NOCOW_FL flag. So to turn on COW for it, we can just clear the
    FS_NOCOW_FL flag.
    
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index de9dd8119b71..56a41412903d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -365,7 +365,6 @@ struct inodes_stat_t {
 #define FS_EXTENT_FL			0x00080000 /* Extents */
 #define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
 #define FS_NOCOW_FL			0x00800000 /* Do not cow file */
-#define FS_COW_FL			0x02000000 /* Cow file */
 #define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
 
 #define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */

commit 0bba01695b74fdd2f9286243bb39f88544d81401
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 12 15:21:04 2011 -0700

    vfs: Re-introduce s_uuid in the superblock
    
    Gaah.  When commit be85bccaa5aa reverted the export of file system uuid
    via /proc/<pid>/mountinfo, it also unintentionally removed the s_uuid
    field in struct super_block.
    
    I didn't mean to do that, since filesystems have been taught to fill it
    in (and we want to keep it for future re-introduction in the mountinfo
    file).
    
    Stupid of me. This adds it back in.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5b14843af9f9..dbd860af0804 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1403,6 +1403,7 @@ struct super_block {
 	wait_queue_head_t	s_wait_unfrozen;
 
 	char s_id[32];				/* Informational name */
+	u8 s_uuid[16];				/* UUID */
 
 	void 			*s_fs_info;	/* Filesystem private info */
 	fmode_t			s_mode;

commit be85bccaa5aa5a11dcaf85f9e945ffefd253f631
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 12 13:35:56 2011 -0700

    Revert "vfs: Export file system uuid via /proc/<pid>/mountinfo"
    
    This reverts commit 93f1c20bc8cdb757be50566eff88d65c3b26881f.
    
    It turns out that libmount misparses it because it adds a '-' character
    in the uuid string, which libmount then incorrectly confuses with the
    separator string (" - ") at the end of all the optional arguments.
    
    Upstream libmount (in the util-linux tree) has been fixed, but until
    that fix actually percolates up to users, we'd better not expose this
    change in the kernel.
    
    Let's revisit this later (possibly by exposing the UUID without any '-'
    characters in it, avoiding the user-space bug).
    
    Reported-by: Dave Jones <davej@redhat.com>
    Cc: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Karel Zak <kzak@redhat.com>
    Cc: Ram Pai <linuxram@us.ibm.com>
    Cc: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Eric Sandeen <sandeen@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dbd860af0804..5b14843af9f9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1403,7 +1403,6 @@ struct super_block {
 	wait_queue_head_t	s_wait_unfrozen;
 
 	char s_id[32];				/* Informational name */
-	u8 s_uuid[16];				/* UUID */
 
 	void 			*s_fs_info;	/* Filesystem private info */
 	fmode_t			s_mode;

commit 42933bac11e811f02200c944d8562a15f8ec4ff0
Merge: 2b9accbee563 25985edcedea
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 7 11:14:49 2011 -0700

    Merge branch 'for-linus2' of git://git.profusion.mobi/users/lucas/linux-2.6
    
    * 'for-linus2' of git://git.profusion.mobi/users/lucas/linux-2.6:
      Fix common misspellings

commit 7dcda1c96d7c643101d4a05579ef4512a4baa7ef
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Tue Apr 5 23:51:48 2011 +0200

    fs: export empty_aops
    
    With the ->sync_page() hook gone, we have a few users that
    add their own static address_space_operations without any
    functions defined.
    
    fs/inode.c already has an empty_aops that it uses for init
    purposes. Lets export that and use it in the places where
    an otherwise empty aops was defined.
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 52f283c1edb2..1b95af37e3b3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -613,6 +613,8 @@ struct address_space_operations {
 	int (*error_remove_page)(struct address_space *, struct page *);
 };
 
+extern const struct address_space_operations empty_aops;
+
 /*
  * pagecache_write_begin/pagecache_write_end must be used by general code
  * to write into the pagecache.

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 52f283c1edb2..f03632d2ac18 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -465,7 +465,7 @@ struct iattr {
 	struct timespec	ia_ctime;
 
 	/*
-	 * Not an attribute, but an auxilary info for filesystems wanting to
+	 * Not an attribute, but an auxiliary info for filesystems wanting to
 	 * implement an ftruncate() like method.  NOTE: filesystem should
 	 * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).
 	 */
@@ -647,7 +647,7 @@ struct address_space {
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but
-	 * must be enforced here for CRIS, to let the least signficant bit
+	 * must be enforced here for CRIS, to let the least significant bit
 	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
 	 */
 

commit 212a17ab878305600e607f637d2d8a49d9f7ef25
Merge: baaca1a61497 d9d04879321a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 28 15:31:05 2011 -0700

    Merge branch 'for-linus-unmerged' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * 'for-linus-unmerged' of git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (45 commits)
      Btrfs: fix __btrfs_map_block on 32 bit machines
      btrfs: fix possible deadlock by clearing __GFP_FS flag
      btrfs: check link counter overflow in link(2)
      btrfs: don't mess with i_nlink of unlocked inode in rename()
      Btrfs: check return value of btrfs_alloc_path()
      Btrfs: fix OOPS of empty filesystem after balance
      Btrfs: fix memory leak of empty filesystem after balance
      Btrfs: fix return value of setflags ioctl
      Btrfs: fix uncheck memory allocations
      btrfs: make inode ref log recovery faster
      Btrfs: add btrfs_trim_fs() to handle FITRIM
      Btrfs: adjust btrfs_discard_extent() return errors and trimmed bytes
      Btrfs: make btrfs_map_block() return entire free extent for each device of RAID0/1/10/DUP
      Btrfs: make update_reserved_bytes() public
      btrfs: return EXDEV when linking from different subvolumes
      Btrfs: Per file/directory controls for COW and compression
      Btrfs: add datacow flag in inode flag
      btrfs: use GFP_NOFS instead of GFP_KERNEL
      Btrfs: check return value of read_tree_block()
      btrfs: properly access unaligned checksum buffer
      ...
    
    Fix up trivial conflicts in fs/btrfs/volumes.c due to plug removal in
    the block layer.

commit 32471f6e1983922473573da62cbee58699574aa4
Author: liubo <liubo2009@cn.fujitsu.com>
Date:   Mon Mar 21 08:54:27 2011 +0000

    Btrfs: add datacow flag in inode flag
    
    For datacow control, the corresponding inode flags are needed.
    This is for btrfs use.
    
    v1->v2:
    Change FS_COW_FL to another bit due to conflict with the upstream e2fsprogs
    
    Signed-off-by: Liu Bo <liubo2009@cn.fujitsu.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e38b50a4b9d2..de9dd8119b71 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -364,6 +364,8 @@ struct inodes_stat_t {
 #define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
 #define FS_EXTENT_FL			0x00080000 /* Extents */
 #define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
+#define FS_NOCOW_FL			0x00800000 /* Do not cow file */
+#define FS_COW_FL			0x02000000 /* Cow file */
 #define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
 
 #define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */

commit d39dd11c3e6a7af5c20bfac40594db36cf270f42
Merge: 30f5b28e7f93 0b2d0724e26a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 24 19:01:30 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      fs: simplify iget & friends
      fs: pull inode->i_lock up out of writeback_single_inode
      fs: rename inode_lock to inode_hash_lock
      fs: move i_wb_list out from under inode_lock
      fs: move i_sb_list out from under inode_lock
      fs: remove inode_lock from iput_final and prune_icache
      fs: Lock the inode LRU list separately
      fs: factor inode disposal
      fs: protect inode->i_state with inode->i_lock
      autofs4: Do not potentially dereference NULL pointer returned by fget() in autofs_dev_ioctl_setpipefd()
      autofs4 - remove autofs4_lock
      autofs4 - fix d_manage() return on rcu-walk
      autofs4 - fix autofs4_expire_indirect() traversal
      autofs4 - fix dentry leak in autofs4_expire_direct()
      autofs4 - reinstate last used update on access
      vfs - check non-mountpoint dentry might block in __follow_mount_rcu()

commit 250df6ed274d767da844a5d9f05720b804240197
Author: Dave Chinner <dchinner@redhat.com>
Date:   Tue Mar 22 22:23:36 2011 +1100

    fs: protect inode->i_state with inode->i_lock
    
    Protect inode state transitions and validity checks with the
    inode->i_lock. This enables us to make inode state transitions
    independently of the inode_lock and is the first step to peeling
    away the inode_lock from the code.
    
    This requires that __iget() is done atomically with i_state checks
    during list traversals so that we don't race with another thread
    marking the inode I_FREEING between the state check and grabbing the
    reference.
    
    Also remove the unlock_new_inode() memory barrier optimisation
    required to avoid taking the inode_lock when clearing I_NEW.
    Simplify the code by simply taking the inode->i_lock around the
    state change and wakeup. Because the wakeup is no longer tricky,
    remove the wake_up_inode() function and open code the wakeup where
    necessary.
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4dda076c24a1..ed6fdcc1484c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1647,7 +1647,7 @@ struct super_operations {
 };
 
 /*
- * Inode state bits.  Protected by inode_lock.
+ * Inode state bits.  Protected by inode->i_lock
  *
  * Three bits determine the dirty state of the inode, I_DIRTY_SYNC,
  * I_DIRTY_DATASYNC and I_DIRTY_PAGES.

commit 6c5103890057b1bb781b26b7aae38d33e4c517d8
Merge: 3dab04e6978e 9d2e157d970a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 24 10:16:26 2011 -0700

    Merge branch 'for-2.6.39/core' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.39/core' of git://git.kernel.dk/linux-2.6-block: (65 commits)
      Documentation/iostats.txt: bit-size reference etc.
      cfq-iosched: removing unnecessary think time checking
      cfq-iosched: Don't clear queue stats when preempt.
      blk-throttle: Reset group slice when limits are changed
      blk-cgroup: Only give unaccounted_time under debug
      cfq-iosched: Don't set active queue in preempt
      block: fix non-atomic access to genhd inflight structures
      block: attempt to merge with existing requests on plug flush
      block: NULL dereference on error path in __blkdev_get()
      cfq-iosched: Don't update group weights when on service tree
      fs: assign sb->s_bdi to default_backing_dev_info if the bdi is going away
      block: Require subsystems to explicitly allocate bio_set integrity mempool
      jbd2: finish conversion from WRITE_SYNC_PLUG to WRITE_SYNC and explicit plugging
      jbd: finish conversion from WRITE_SYNC_PLUG to WRITE_SYNC and explicit plugging
      fs: make fsync_buffers_list() plug
      mm: make generic_writepages() use plugging
      blk-cgroup: Add unaccounted time to timeslice_used.
      block: fixup plugging stubs for !CONFIG_BLOCK
      block: remove obsolete comments for blkdev_issue_zeroout.
      blktrace: Use rq->cmd_flags directly in blk_add_trace_rq.
      ...
    
    Fix up conflicts in fs/{aio.c,super.c}

commit 2e1496707560ecf98e9b0604622c0990f94861d3
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:26 2011 -0700

    userns: rename is_owner_or_cap to inode_owner_or_capable
    
    And give it a kernel-doc comment.
    
    [akpm@linux-foundation.org: btrfs changed in linux-next]
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9eebc646d14a..4dda076c24a1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1463,7 +1463,7 @@ enum {
  */
 extern struct user_namespace init_user_ns;
 #define inode_userns(inode) (&init_user_ns)
-extern bool is_owner_or_cap(const struct inode *inode);
+extern bool inode_owner_or_capable(const struct inode *inode);
 
 /* not quite ready to be deprecated, but... */
 extern void lock_super(struct super_block *);

commit e795b71799ff0b27365020c9ddaa25d0d83f99c8
Author: Serge E. Hallyn <serge@hallyn.com>
Date:   Wed Mar 23 16:43:25 2011 -0700

    userns: userns: check user namespace for task->file uid equivalence checks
    
    Cheat for now and say all files belong to init_user_ns.  Next step will be
    to let superblocks belong to a user_ns, and derive inode_userns(inode)
    from inode->i_sb->s_user_ns.  Finally we'll introduce more flexible
    arrangements.
    
    Changelog:
            Feb 15: make is_owner_or_cap take const struct inode
            Feb 23: make is_owner_or_cap bool
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Serge E. Hallyn <serge.hallyn@canonical.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Daniel Lezcano <daniel.lezcano@free.fr>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 12529e966350..9eebc646d14a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1457,8 +1457,13 @@ enum {
 #define put_fs_excl() atomic_dec(&current->fs_excl)
 #define has_fs_excl() atomic_read(&current->fs_excl)
 
-#define is_owner_or_cap(inode)	\
-	((current_fsuid() == (inode)->i_uid) || capable(CAP_FOWNER))
+/*
+ * until VFS tracks user namespaces for inodes, just make all files
+ * belong to init_user_ns
+ */
+extern struct user_namespace init_user_ns;
+#define inode_userns(inode) (&init_user_ns)
+extern bool is_owner_or_cap(const struct inode *inode);
 
 /* not quite ready to be deprecated, but... */
 extern void lock_super(struct super_block *);

commit f3ccfcdaf3986f8c541886606e950de52cab7ad3
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Tue Mar 22 16:33:56 2011 -0700

    fs.h: remove 8 bytes of padding from block_device on 64bit builds
    
    Re-ordering struct block_inode to remove 8 bytes of padding on 64 bit
    builds, which also shrinks bdev_inode by 8 bytes (776 -> 768) allowing it
    to fit into one fewer cache lines.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7061a8587ee3..12529e966350 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -662,9 +662,9 @@ struct address_space {
 
 struct block_device {
 	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
+	int			bd_openers;
 	struct inode *		bd_inode;	/* will die */
 	struct super_block *	bd_super;
-	int			bd_openers;
 	struct mutex		bd_mutex;	/* open/close mutex */
 	struct list_head	bd_inodes;
 	void *			bd_claiming;

commit 474a00ee1306eb7e82329fdc28b6471a99facba1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Mar 17 21:31:32 2011 -0400

    kill simple_set_mnt()
    
    not needed anymore, since all users (->get_sb() instances) are gone.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 92f7e04aea11..7061a8587ee3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1839,7 +1839,6 @@ extern struct dentry *mount_pseudo(struct file_system_type *, char *,
 	const struct super_operations *ops,
 	const struct dentry_operations *dops,
 	unsigned long);
-extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 
 static inline void sb_mark_dirty(struct super_block *sb)
 {

commit 054cfaacf88865bff1dd58d305443d5d6c068a08
Merge: dc113c1f1d4b 1a102ff92579
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 19:09:57 2011 -0700

    Merge branch 'mnt_devname' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'mnt_devname' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      vfs: bury ->get_sb()
      nfs: switch NFS from ->get_sb() to ->mount()
      nfs: stop mangling ->mnt_devname on NFS
      vfs: new superblock methods to override /proc/*/mount{s,info}
      nfs: nfs_do_{ref,sub}mount() superblock argument is redundant
      nfs: make nfs_path() work without vfsmount
      nfs: store devname at disconnected NFS roots
      nfs: propagate devname to nfs{,4}_get_root()

commit 1a102ff92579edeff5e3d5d3c76ca49977898f00
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 16 09:07:58 2011 -0400

    vfs: bury ->get_sb()
    
    This is an ex-parrot.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e6d3fe45981b..ffaa0e4926ed 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1797,8 +1797,6 @@ int sync_inode_metadata(struct inode *inode, int wait);
 struct file_system_type {
 	const char *name;
 	int fs_flags;
-	int (*get_sb) (struct file_system_type *, int,
-		       const char *, void *, struct vfsmount *);
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
 	void (*kill_sb) (struct super_block *);
@@ -1821,24 +1819,12 @@ extern struct dentry *mount_ns(struct file_system_type *fs_type, int flags,
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int));
-extern int get_sb_bdev(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data,
-	int (*fill_super)(struct super_block *, void *, int),
-	struct vfsmount *mnt);
 extern struct dentry *mount_single(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int));
-extern int get_sb_single(struct file_system_type *fs_type,
-	int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int),
-	struct vfsmount *mnt);
 extern struct dentry *mount_nodev(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int));
-extern int get_sb_nodev(struct file_system_type *fs_type,
-	int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int),
-	struct vfsmount *mnt);
 void generic_shutdown_super(struct super_block *sb);
 void kill_block_super(struct super_block *sb);
 void kill_anon_super(struct super_block *sb);

commit c7f404b40a3665d9f4e9a927cc5c1ee0479ed8f9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Mar 16 06:59:40 2011 -0400

    vfs: new superblock methods to override /proc/*/mount{s,info}
    
    a) ->show_devname(m, mnt) - what to put into devname columns in mounts,
    mountinfo and mountstats
    b) ->show_path(m, mnt) - what to put into relative path column in mountinfo
    
    Leaving those NULL gives old behaviour.  NFS switched to using those.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 13df14e2c42e..e6d3fe45981b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1632,6 +1632,8 @@ struct super_operations {
 	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
+	int (*show_devname)(struct seq_file *, struct vfsmount *);
+	int (*show_path)(struct seq_file *, struct vfsmount *);
 	int (*show_stats)(struct seq_file *, struct vfsmount *);
 #ifdef CONFIG_QUOTA
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);

commit 0f6e0e8448a16d8d22119ce91d8dd24b44865b51
Merge: 0d2ecee2bdb2 a002951c97ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 09:15:43 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6: (33 commits)
      AppArmor: kill unused macros in lsm.c
      AppArmor: cleanup generated files correctly
      KEYS: Add an iovec version of KEYCTL_INSTANTIATE
      KEYS: Add a new keyctl op to reject a key with a specified error code
      KEYS: Add a key type op to permit the key description to be vetted
      KEYS: Add an RCU payload dereference macro
      AppArmor: Cleanup make file to remove cruft and make it easier to read
      SELinux: implement the new sb_remount LSM hook
      LSM: Pass -o remount options to the LSM
      SELinux: Compute SID for the newly created socket
      SELinux: Socket retains creator role and MLS attribute
      SELinux: Auto-generate security_is_socket_class
      TOMOYO: Fix memory leak upon file open.
      Revert "selinux: simplify ioctl checking"
      selinux: drop unused packet flow permissions
      selinux: Fix packet forwarding checks on postrouting
      selinux: Fix wrong checks for selinux_policycap_netpeer
      selinux: Fix check for xfrm selinux context algorithm
      ima: remove unnecessary call to ima_must_measure
      IMA: remove IMA imbalance checking
      ...

commit 1abf0c718f15a56a0a435588d1b104c7a37dc9bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 13 03:51:11 2011 -0400

    New kind of open files - "location only".
    
    New flag for open(2) - O_PATH.  Semantics:
            * pathname is resolved, but the file itself is _NOT_ opened
    as far as filesystem is concerned.
            * almost all operations on the resulting descriptors shall
    fail with -EBADF.  Exceptions are:
            1) operations on descriptors themselves (i.e.
                    close(), dup(), dup2(), dup3(), fcntl(fd, F_DUPFD),
                    fcntl(fd, F_DUPFD_CLOEXEC, ...), fcntl(fd, F_GETFD),
                    fcntl(fd, F_SETFD, ...))
            2) fcntl(fd, F_GETFL), for a common non-destructive way to
                    check if descriptor is open
            3) "dfd" arguments of ...at(2) syscalls, i.e. the starting
                    points of pathname resolution
            * closing such descriptor does *NOT* affect dnotify or
    posix locks.
            * permissions are checked as usual along the way to file;
    no permission checks are applied to the file itself.  Of course,
    giving such thing to syscall will result in permission checks (at
    the moment it means checking that starting point of ....at() is
    a directory and caller has exec permissions on it).
    
    fget() and fget_light() return NULL on such descriptors; use of
    fget_raw() and fget_raw_light() is needed to get them.  That protects
    existing code from dealing with those things.
    
    There are two things still missing (they come in the next commits):
    one is handling of symlinks (right now we refuse to open them that
    way; see the next commit for semantics related to those) and another
    is descriptor passing via SCM_RIGHTS datagrams.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f2143e0942c2..13df14e2c42e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -102,6 +102,9 @@ struct inodes_stat_t {
 /* File is huge (eg. /dev/kmem): treat loff_t as unsigned */
 #define FMODE_UNSIGNED_OFFSET	((__force fmode_t)0x2000)
 
+/* File is opened with O_PATH; almost nothing can be done with it */
+#define FMODE_PATH		((__force fmode_t)0x4000)
+
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
 

commit 93f1c20bc8cdb757be50566eff88d65c3b26881f
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Sat Jan 29 18:43:38 2011 +0530

    vfs: Export file system uuid via /proc/<pid>/mountinfo
    
    We add a per superblock uuid field. File systems should
    update the uuid in the fill_super callback
    
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f64630c0e10..f2143e0942c2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1408,6 +1408,7 @@ struct super_block {
 	wait_queue_head_t	s_wait_unfrozen;
 
 	char s_id[32];				/* Informational name */
+	u8 s_uuid[16];				/* UUID */
 
 	void 			*s_fs_info;	/* Filesystem private info */
 	fmode_t			s_mode;

commit 990d6c2d7aee921e3bce22b2d6a750fd552262be
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Sat Jan 29 18:43:26 2011 +0530

    vfs: Add name to file handle conversion support
    
    The syscall also return mount id which can be used
    to lookup file system specific information such as uuid
    in /proc/<pid>/mountinfo
    
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b7178b05cf3a..3f64630c0e10 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -978,6 +978,13 @@ struct file {
 #endif
 };
 
+struct file_handle {
+	__u32 handle_bytes;
+	int handle_type;
+	/* file identifier */
+	unsigned char f_handle[0];
+};
+
 #define get_file(x)	atomic_long_inc(&(x)->f_count)
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)

commit c8b91accfa1059d5565443193d89572eca2f5dd6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 12 10:41:39 2011 -0500

    clean statfs-like syscalls up
    
    New helpers: user_statfs() and fd_statfs(), taking userland pathname and
    descriptor resp. and filling struct kstatfs.  Syscalls of statfs family
    (native, compat and foreign - osf and hpux on alpha and parisc resp.)
    switched to those.  Removes some boilerplate code, simplifies cleanup
    on errors...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bf5c3c896072..b7178b05cf3a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1874,6 +1874,8 @@ extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 			  struct vfsmount *);
 extern int vfs_statfs(struct path *, struct kstatfs *);
+extern int user_statfs(const char __user *, struct kstatfs *);
+extern int fd_statfs(int, struct kstatfs *);
 extern int statfs_by_dentry(struct dentry *, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);

commit 73d049a40fc6269189c4e2ba6792cb5dd054883c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 11 12:08:24 2011 -0500

    open-style analog of vfs_path_lookup()
    
    new function: file_open_root(dentry, mnt, name, flags) opens the file
    vfs_path_lookup would arrive to.
    
    Note that name can be empty; in that case the usual requirement that
    dentry should be a directory is lifted.
    
    open-coded equivalents switched to it, may_open() got down exactly
    one caller and became static.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9c75714f92c1..bf5c3c896072 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1990,6 +1990,8 @@ extern int do_fallocate(struct file *file, int mode, loff_t offset,
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
 			int mode);
 extern struct file *filp_open(const char *, int, int);
+extern struct file *file_open_root(struct dentry *, struct vfsmount *,
+				   const char *, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
 				 const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
@@ -2205,8 +2207,6 @@ extern struct file *create_read_pipe(struct file *f, int flags);
 extern struct file *create_write_pipe(int flags);
 extern void free_write_pipe(struct file *);
 
-extern int may_open(struct path *, int, int);
-
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern struct file * open_exec(const char *);
  

commit 47c805dc2d2dff686962f5f0baa6bac2d703ba19
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Feb 23 17:44:09 2011 -0500

    switch do_filp_open() to struct open_flags
    
    take calculation of open_flags by open(2) arguments into new helper
    in fs/open.c, move filp_open() over there, have it and do_sys_open()
    use that helper, switch exec.c callers of do_filp_open() to explicit
    (and constant) struct open_flags.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e38b50a4b9d2..9c75714f92c1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2205,8 +2205,6 @@ extern struct file *create_read_pipe(struct file *f, int flags);
 extern struct file *create_write_pipe(int flags);
 extern void free_write_pipe(struct file *);
 
-extern struct file *do_filp_open(int dfd, const char *pathname,
-		int open_flag, int mode, int acc_mode);
 extern int may_open(struct path *, int, int);
 
 extern int kernel_read(struct file *, loff_t, char *, unsigned long);

commit 4c63f5646e405b5010cc9499419060bf2e838f5b
Merge: cafb0bfca1a7 69d60eb96ae8
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Thu Mar 10 08:58:35 2011 +0100

    Merge branch 'for-2.6.39/stack-plug' into for-2.6.39/core
    
    Conflicts:
            block/blk-core.c
            block/blk-flush.c
            drivers/md/raid1.c
            drivers/md/raid10.c
            drivers/md/raid5.c
            fs/nilfs2/btnode.c
            fs/nilfs2/mdt.c
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

commit 721a9602e6607417c6bc15b18e97a2f35266c690
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Wed Mar 9 11:56:30 2011 +0100

    block: kill off REQ_UNPLUG
    
    With the plugging now being explicitly controlled by the
    submitter, callers need not pass down unplugging hints
    to the block layer. If they want to unplug, it's because they
    manually plugged on their own - in which case, they should just
    unplug at will.
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9f2cf69911b8..543e226ea6a3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -135,16 +135,10 @@ struct inodes_stat_t {
  *			block layer could (in theory) choose to ignore this
  *			request if it runs into resource problems.
  * WRITE		A normal async write. Device will be plugged.
- * WRITE_SYNC_PLUG	Synchronous write. Identical to WRITE, but passes down
+ * WRITE_SYNC		Synchronous write. Identical to WRITE, but passes down
  *			the hint that someone will be waiting on this IO
- *			shortly. The device must still be unplugged explicitly,
- *			WRITE_SYNC_PLUG does not do this as we could be
- *			submitting more writes before we actually wait on any
- *			of them.
- * WRITE_SYNC		Like WRITE_SYNC_PLUG, but also unplugs the device
- *			immediately after submission. The write equivalent
- *			of READ_SYNC.
- * WRITE_ODIRECT_PLUG	Special case write for O_DIRECT only.
+ *			shortly. The write equivalent of READ_SYNC.
+ * WRITE_ODIRECT	Special case write for O_DIRECT only.
  * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
  * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
  *			non-volatile media on completion.
@@ -160,18 +154,14 @@ struct inodes_stat_t {
 #define WRITE			RW_MASK
 #define READA			RWA_MASK
 
-#define READ_SYNC		(READ | REQ_SYNC | REQ_UNPLUG)
+#define READ_SYNC		(READ | REQ_SYNC)
 #define READ_META		(READ | REQ_META)
-#define WRITE_SYNC_PLUG		(WRITE | REQ_SYNC | REQ_NOIDLE)
-#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG)
-#define WRITE_ODIRECT_PLUG	(WRITE | REQ_SYNC)
+#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE)
+#define WRITE_ODIRECT		(WRITE | REQ_SYNC)
 #define WRITE_META		(WRITE | REQ_META)
-#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
-				 REQ_FLUSH)
-#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
-				 REQ_FUA)
-#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
-				 REQ_FLUSH | REQ_FUA)
+#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH)
+#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FUA)
+#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_FLUSH | REQ_FUA)
 
 #define SEL_IN		1
 #define SEL_OUT		2

commit 7eaceaccab5f40bbfda044629a6298616aeaed50
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Thu Mar 10 08:52:07 2011 +0100

    block: remove per-queue plugging
    
    Code has been converted over to the new explicit on-stack plugging,
    and delay users have been converted to use the new API for that.
    So lets kill off the old plugging along with aops->sync_page().
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd3215940c37..9f2cf69911b8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -583,7 +583,6 @@ typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
 struct address_space_operations {
 	int (*writepage)(struct page *page, struct writeback_control *wbc);
 	int (*readpage)(struct file *, struct page *);
-	void (*sync_page)(struct page *);
 
 	/* Write back some dirty pages from this mapping. */
 	int (*writepages)(struct address_space *, struct writeback_control *);

commit 1cc26bada9f6807814806db2f0d78792eecdac71
Merge: eae61f3c8294 214d93b02c4f
Author: James Morris <jmorris@namei.org>
Date:   Tue Mar 8 10:55:06 2011 +1100

    Merge branch 'master'; commit 'v2.6.38-rc7' into next

commit 638691a7a46a4ae9a7b56c603299e42d7f6e722e
Merge: 0a93ea2e897b f0b4f7e2f29a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 25 11:13:26 2011 -0800

    Merge branch 'for-linus' of git://neil.brown.name/md
    
    * 'for-linus' of git://neil.brown.name/md:
      md: Fix - again - partition detection when array becomes active
      Fix over-zealous flush_disk when changing device size.
      md: avoid spinlock problem in blk_throtl_exit
      md: correctly handle probe of an 'mdp' device.
      md: don't set_capacity before array is active.
      md: Fix raid1->raid0 takeover

commit 93b270f76e7ef3b81001576860c2701931cdc78b
Author: NeilBrown <neilb@suse.de>
Date:   Thu Feb 24 17:25:47 2011 +1100

    Fix over-zealous flush_disk when changing device size.
    
    There are two cases when we call flush_disk.
    In one, the device has disappeared (check_disk_change) so any
    data will hold becomes irrelevant.
    In the oter, the device has changed size (check_disk_size_change)
    so data we hold may be irrelevant.
    
    In both cases it makes sense to discard any 'clean' buffers,
    so they will be read back from the device if needed.
    
    In the former case it makes sense to discard 'dirty' buffers
    as there will never be anywhere safe to write the data.  In the
    second case it *does*not* make sense to discard dirty buffers
    as that will lead to file system corruption when you simply enlarge
    the containing devices.
    
    flush_disk calls __invalidate_devices.
    __invalidate_device calls both invalidate_inodes and invalidate_bdev.
    
    invalidate_inodes *does* discard I_DIRTY inodes and this does lead
    to fs corruption.
    
    invalidate_bev *does*not* discard dirty pages, but I don't really care
    about that at present.
    
    So this patch adds a flag to __invalidate_device (calling it
    __invalidate_device2) to indicate whether dirty buffers should be
    killed, and this is passed to invalidate_inodes which can choose to
    skip dirty inodes.
    
    flusk_disk then passes true from check_disk_change and false from
    check_disk_size_change.
    
    dm avoids tripping over this problem by calling i_size_write directly
    rathher than using check_disk_size_change.
    
    md does use check_disk_size_change and so is affected.
    
    This regression was introduced by commit 608aeef17a which causes
    check_disk_size_change to call flush_disk, so it is suitable for any
    kernel since 2.6.27.
    
    Cc: stable@kernel.org
    Acked-by: Jeff Moyer <jmoyer@redhat.com>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 32b38cd829d3..683f4c566c82 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2139,7 +2139,7 @@ extern void check_disk_size_change(struct gendisk *disk,
 				   struct block_device *bdev);
 extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
-extern int __invalidate_device(struct block_device *);
+extern int __invalidate_device(struct block_device *, bool);
 extern int invalidate_partition(struct gendisk *, int);
 #endif
 unsigned long invalidate_mapping_pages(struct address_space *mapping,

commit 2aa15890f3c191326678f1bd68af61ec6b8753ec
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Feb 23 13:49:47 2011 +0100

    mm: prevent concurrent unmap_mapping_range() on the same inode
    
    Michael Leun reported that running parallel opens on a fuse filesystem
    can trigger a "kernel BUG at mm/truncate.c:475"
    
    Gurudas Pai reported the same bug on NFS.
    
    The reason is, unmap_mapping_range() is not prepared for more than
    one concurrent invocation per inode.  For example:
    
      thread1: going through a big range, stops in the middle of a vma and
         stores the restart address in vm_truncate_count.
    
      thread2: comes in with a small (e.g. single page) unmap request on
         the same vma, somewhere before restart_address, finds that the
         vma was already unmapped up to the restart address and happily
         returns without doing anything.
    
    Another scenario would be two big unmap requests, both having to
    restart the unmapping and each one setting vm_truncate_count to its
    own value.  This could go on forever without any of them being able to
    finish.
    
    Truncate and hole punching already serialize with i_mutex.  Other
    callers of unmap_mapping_range() do not, and it's difficult to get
    i_mutex protection for all callers.  In particular ->d_revalidate(),
    which calls invalidate_inode_pages2_range() in fuse, may be called
    with or without i_mutex.
    
    This patch adds a new mutex to 'struct address_space' to prevent
    running multiple concurrent unmap_mapping_range() on the same mapping.
    
    [ We'll hopefully get rid of all this with the upcoming mm
      preemptibility series by Peter Zijlstra, the "mm: Remove i_mmap_mutex
      lockbreak" patch in particular.  But that is for 2.6.39 ]
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Reported-by: Michael Leun <lkml20101129@newton.leun.net>
    Reported-by: Gurudas Pai <gurudas.pai@oracle.com>
    Tested-by: Gurudas Pai <gurudas.pai@oracle.com>
    Acked-by: Hugh Dickins <hughd@google.com>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd3215940c37..97d08d8a7de8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -649,6 +649,7 @@ struct address_space {
 	spinlock_t		private_lock;	/* for use by the address_space */
 	struct list_head	private_list;	/* ditto */
 	struct address_space	*assoc_mapping;	/* ditto */
+	struct mutex		unmap_mutex;    /* to protect unmapping */
 } __attribute__((aligned(sizeof(long))));
 	/*
 	 * On most architectures that alignment is already the case; but
@@ -2225,6 +2226,7 @@ extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
 
 extern int inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
+extern void address_space_init_once(struct address_space *mapping);
 extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);

commit a5c96ebf1d71df0c5fb77ab58c9aeb307cf02372
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Nov 2 10:11:37 2010 -0400

    IMA: define readcount functions
    
    Define i_readcount_inc/dec() functions to be called from the VFS layer.
    
    Changelog:
    - renamed iget/iput_readcount to i_readcount_inc/dec (Dave Chinner's suggestion)
    - removed i_lock in iput_readcount() (based on comments:Dave Chinner,Eric Paris)
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ef85322863b9..a3e8f02b727d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2186,6 +2186,26 @@ static inline void allow_write_access(struct file *file)
 	if (file)
 		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
 }
+#ifdef CONFIG_IMA
+static inline void i_readcount_dec(struct inode *inode)
+{
+	BUG_ON(!atomic_read(&inode->i_readcount));
+	atomic_dec(&inode->i_readcount);
+}
+static inline void i_readcount_inc(struct inode *inode)
+{
+	atomic_inc(&inode->i_readcount);
+}
+#else
+static inline void i_readcount_dec(struct inode *inode)
+{
+	return;
+}
+static inline void i_readcount_inc(struct inode *inode)
+{
+	return;
+}
+#endif
 extern int do_pipe_flags(int *, int);
 extern struct file *create_read_pipe(struct file *f, int flags);
 extern struct file *create_write_pipe(int flags);

commit a68a27b6f2354273bacc39c3dd06456edb202230
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Tue Nov 2 10:10:56 2010 -0400

    IMA: convert i_readcount to atomic
    
    Convert the inode's i_readcount from an unsigned int to atomic.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Acked-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index baf3e556ff0e..ef85322863b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -794,8 +794,7 @@ struct inode {
 #endif
 
 #ifdef CONFIG_IMA
-	/* protected by i_lock */
-	unsigned int		i_readcount; /* struct files open RO */
+	atomic_t		i_readcount; /* struct files open RO */
 #endif
 	atomic_t		i_writecount;
 #ifdef CONFIG_SECURITY

commit 3cd90ea42f2c15f928b70ed66f6d8ed0a8e7aadd
Author: Namhyung Kim <namhyung@gmail.com>
Date:   Tue Feb 1 15:52:46 2011 -0800

    vfs: sparse: add __FMODE_EXEC
    
    FMODE_EXEC is a constant type of fmode_t but was used with normal integer
    constants.  This results in following warnings from sparse.  Fix it using
    new macro __FMODE_EXEC.
    
     fs/exec.c:116:58: warning: restricted fmode_t degrades to integer
     fs/exec.c:689:58: warning: restricted fmode_t degrades to integer
     fs/fcntl.c:777:9: warning: restricted fmode_t degrades to integer
    
    Signed-off-by: Namhyung Kim <namhyung@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 675678a01f50..bd3215940c37 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2555,6 +2555,7 @@ int proc_nr_inodes(struct ctl_table *table, int write,
 		   void __user *buffer, size_t *lenp, loff_t *ppos);
 int __init get_filesystem_list(char *buf);
 
+#define __FMODE_EXEC		((__force int) FMODE_EXEC)
 #define __FMODE_NONOTIFY	((__force int) FMODE_NONOTIFY)
 
 #define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])

commit 1a44bc8c7cfe69756a116d38aef992d50fc1969d
Author: Namhyung Kim <namhyung@gmail.com>
Date:   Tue Feb 1 15:52:46 2011 -0800

    vfs: sparse: remove a warning on OPEN_FMODE()
    
    AND-ing FMODE_* constant with normal integer results in following
    sparse warnings. Fix it.
    
     fs/open.c:662:21: warning: restricted fmode_t degrades to integer
     fs/anon_inodes.c:123:34: warning: restricted fmode_t degrades to integer
    
    Signed-off-by: Namhyung Kim <namhyung@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 32b38cd829d3..675678a01f50 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2555,9 +2555,11 @@ int proc_nr_inodes(struct ctl_table *table, int write,
 		   void __user *buffer, size_t *lenp, loff_t *ppos);
 int __init get_filesystem_list(char *buf);
 
+#define __FMODE_NONOTIFY	((__force int) FMODE_NONOTIFY)
+
 #define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])
 #define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \
-					    (flag & FMODE_NONOTIFY)))
+					    (flag & __FMODE_NONOTIFY)))
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit ecf5632dd189ab4c366cef853d6e5fe7adfe52e5
Author: Namhyung Kim <namhyung@gmail.com>
Date:   Sun Jan 16 23:28:17 2011 +0900

    fs: fix address space warnings in ioctl_fiemap()
    
    The fi_extents_start field of struct fiemap_extent_info is a
    user pointer but was not marked as __user. This makes sparse
    emit following warnings:
    
      CHECK   fs/ioctl.c
    fs/ioctl.c:114:26: warning: incorrect type in argument 1 (different address spaces)
    fs/ioctl.c:114:26:    expected void [noderef] <asn:1>*dst
    fs/ioctl.c:114:26:    got struct fiemap_extent *[assigned] dest
    fs/ioctl.c:202:14: warning: incorrect type in argument 1 (different address spaces)
    fs/ioctl.c:202:14:    expected void const volatile [noderef] <asn:1>*<noident>
    fs/ioctl.c:202:14:    got struct fiemap_extent *[assigned] fi_extents_start
    fs/ioctl.c:212:27: warning: incorrect type in argument 1 (different address spaces)
    fs/ioctl.c:212:27:    expected void [noderef] <asn:1>*dst
    fs/ioctl.c:212:27:    got char *<noident>
    
    Also add 'ufiemap' variable to eliminate unnecessary casts.
    
    Signed-off-by: Namhyung Kim <namhyung@gmail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 09b5bd6a7c6b..32b38cd829d3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1483,8 +1483,8 @@ struct fiemap_extent_info {
 	unsigned int fi_flags;		/* Flags as passed from user */
 	unsigned int fi_extents_mapped;	/* Number of mapped extents */
 	unsigned int fi_extents_max;	/* Size of fiemap_extent array */
-	struct fiemap_extent *fi_extents_start; /* Start of fiemap_extent
-						 * array */
+	struct fiemap_extent __user *fi_extents_start; /* Start of
+							fiemap_extent array */
 };
 int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
 			    u64 phys, u64 len, u32 flags);

commit 2fe17c1075836b66678ed2a305fd09b6773883aa
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 14 13:07:43 2011 +0100

    fallocate should be a file operation
    
    Currently all filesystems except XFS implement fallocate asynchronously,
    while XFS forced a commit.  Both of these are suboptimal - in case of O_SYNC
    I/O we really want our allocation on disk, especially for the !KEEP_SIZE
    case where we actually grow the file with user-visible zeroes.  On the
    other hand always commiting the transaction is a bad idea for fast-path
    uses of fallocate like for example in recent Samba versions.   Given
    that block allocation is a data plane operation anyway change it from
    an inode operation to a file operation so that we have the file structure
    available that lets us check for O_SYNC.
    
    This also includes moving the code around for a few of the filesystems,
    and remove the already unnedded S_ISDIR checks given that we only wire
    up fallocate for regular files.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 177b4ddea418..09b5bd6a7c6b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1552,6 +1552,8 @@ struct file_operations {
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 	int (*setlease)(struct file *, long, struct file_lock **);
+	long (*fallocate)(struct file *file, int mode, loff_t offset,
+			  loff_t len);
 };
 
 #define IPERM_FLAG_RCU	0x0001
@@ -1582,8 +1584,6 @@ struct inode_operations {
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*removexattr) (struct dentry *, const char *);
 	void (*truncate_range)(struct inode *, loff_t, loff_t);
-	long (*fallocate)(struct inode *inode, int mode, loff_t offset,
-			  loff_t len);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
 } ____cacheline_aligned;

commit f8206b925fb0eba3a11839419be118b09105d7b1
Merge: 1b59be2a6cdc f03c65993b98
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 16 11:31:50 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (23 commits)
      sanitize vfsmount refcounting changes
      fix old umount_tree() breakage
      autofs4: Merge the remaining dentry ops tables
      Unexport do_add_mount() and add in follow_automount(), not ->d_automount()
      Allow d_manage() to be used in RCU-walk mode
      Remove a further kludge from __do_follow_link()
      autofs4: Bump version
      autofs4: Add v4 pseudo direct mount support
      autofs4: Fix wait validation
      autofs4: Clean up autofs4_free_ino()
      autofs4: Clean up dentry operations
      autofs4: Clean up inode operations
      autofs4: Remove unused code
      autofs4: Add d_manage() dentry operation
      autofs4: Add d_automount() dentry operation
      Remove the automount through follow_link() kludge code from pathwalk
      CIFS: Use d_automount() rather than abusing follow_link()
      NFS: Use d_automount() rather than abusing follow_link()
      AFS: Use d_automount() rather than abusing follow_link()
      Add an AT_NO_AUTOMOUNT flag to suppress terminal automount
      ...

commit 9875cf806403fae66b2410a3c2cc820d97731e04
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jan 14 18:45:21 2011 +0000

    Add a dentry op to handle automounting rather than abusing follow_link()
    
    Add a dentry op (d_automount) to handle automounting directories rather than
    abusing the follow_link() inode operation.  The operation is keyed off a new
    dentry flag (DCACHE_NEED_AUTOMOUNT).
    
    This also makes it easier to add an AT_ flag to suppress terminal segment
    automount during pathwalk and removes the need for the kludge code in the
    pathwalk algorithm to handle directories with follow_link() semantics.
    
    The ->d_automount() dentry operation:
    
            struct vfsmount *(*d_automount)(struct path *mountpoint);
    
    takes a pointer to the directory to be mounted upon, which is expected to
    provide sufficient data to determine what should be mounted.  If successful, it
    should return the vfsmount struct it creates (which it should also have added
    to the namespace using do_add_mount() or similar).  If there's a collision with
    another automount attempt, NULL should be returned.  If the directory specified
    by the parameter should be used directly rather than being mounted upon,
    -EISDIR should be returned.  In any other case, an error code should be
    returned.
    
    The ->d_automount() operation is called with no locks held and may sleep.  At
    this point the pathwalk algorithm will be in ref-walk mode.
    
    Within fs/namei.c itself, a new pathwalk subroutine (follow_automount()) is
    added to handle mountpoints.  It will return -EREMOTE if the automount flag was
    set, but no d_automount() op was supplied, -ELOOP if we've encountered too many
    symlinks or mountpoints, -EISDIR if the walk point should be used without
    mounting and 0 if successful.  The path will be updated to point to the mounted
    filesystem if a successful automount took place.
    
    __follow_mount() is replaced by follow_managed() which is more generic
    (especially with the patch that adds ->d_manage()).  This handles transits from
    directories during pathwalk, including automounting and skipping over
    mountpoints (and holding processes with the next patch).
    
    __follow_mount_rcu() will jump out of RCU-walk mode if it encounters an
    automount point with nothing mounted on it.
    
    follow_dotdot*() does not handle automounts as you don't want to trigger them
    whilst following "..".
    
    I've also extracted the mount/don't-mount logic from autofs4 and included it
    here.  It makes the mount go ahead anyway if someone calls open() or creat(),
    tries to traverse the directory, tries to chdir/chroot/etc. into the directory,
    or sticks a '/' on the end of the pathname.  If they do a stat(), however,
    they'll only trigger the automount if they didn't also say O_NOFOLLOW.
    
    I've also added an inode flag (S_AUTOMOUNT) so that filesystems can mark their
    inodes as automount points.  This flag is automatically propagated to the
    dentry as DCACHE_NEED_AUTOMOUNT by __d_instantiate().  This saves NFS and could
    save AFS a private flag bit apiece, but is not strictly necessary.  It would be
    preferable to do the propagation in d_set_d_op(), but that doesn't normally
    have access to the inode.
    
    [AV: fixed breakage in case if __follow_mount_rcu() fails and nameidata_drop_rcu()
    succeeds in RCU case of do_lookup(); we need to fall through to non-RCU case after
    that, rather than just returning with ungrabbed *path]
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Was-Acked-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3984f2358d1f..4c00ed53be8f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -242,6 +242,7 @@ struct inodes_stat_t {
 #define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
 #define S_PRIVATE	512	/* Inode is fs-internal */
 #define S_IMA		1024	/* Inode has an associated IMA struct */
+#define S_AUTOMOUNT	2048	/* Automount/referral quasi-directory */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -277,6 +278,7 @@ struct inodes_stat_t {
 #define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
 #define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
 #define IS_IMA(inode)		((inode)->i_flags & S_IMA)
+#define IS_AUTOMOUNT(inode)	((inode)->i_flags & S_AUTOMOUNT)
 
 /* the read-only stuff doesn't really belong here, but any other place is
    probably as bad and I don't want to create yet another include file. */

commit 6ab82196492a0b6968a654a06aae923b28afef0d
Merge: 6f7f7caab259 49731baa41df
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 14 13:32:07 2011 -0800

    Merge branch 'for-linus' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-linus' of git://git.kernel.dk/linux-2.6-block:
      block: restore multiple bd_link_disk_holder() support
      block cfq: compensate preempted queue even if it has no slice assigned
      block cfq: make queue preempt work for queues from different workload

commit 18bce371ae09af6c20ee62c1092a4d1d0e84dd49
Merge: ec08bdb14876 a8f2800b4f7b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 14 13:17:26 2011 -0800

    Merge branch 'for-2.6.38' of git://linux-nfs.org/~bfields/linux
    
    * 'for-2.6.38' of git://linux-nfs.org/~bfields/linux: (62 commits)
      nfsd4: fix callback restarting
      nfsd: break lease on unlink, link, and rename
      nfsd4: break lease on nfsd setattr
      nfsd: don't support msnfs export option
      nfsd4: initialize cb_per_client
      nfsd4: allow restarting callbacks
      nfsd4: simplify nfsd4_cb_prepare
      nfsd4: give out delegations more quickly in 4.1 case
      nfsd4: add helper function to run callbacks
      nfsd4: make sure sequence flags are set after destroy_session
      nfsd4: re-probe callback on connection loss
      nfsd4: set sequence flag when backchannel is down
      nfsd4: keep finer-grained callback status
      rpc: allow xprt_class->setup to return a preexisting xprt
      rpc: keep backchannel xprt as long as server connection
      rpc: move sk_bc_xprt to svc_xprt
      nfsd4: allow backchannel recovery
      nfsd4: support BIND_CONN_TO_SESSION
      nfsd4: modify session list under cl_lock
      Documentation: fl_mylease no longer exists
      ...
    
    Fix up conflicts in fs/nfsd/vfs.c with the vfs-scale work.  The
    vfs-scale work touched some msnfs cases, and this merge removes support
    for that entirely, so the conflict was trivial to resolve.

commit 49731baa41df404c2c3f44555869ab387363af43
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jan 14 18:43:57 2011 +0100

    block: restore multiple bd_link_disk_holder() support
    
    Commit e09b457b (block: simplify holder symlink handling) incorrectly
    assumed that there is only one link at maximum.  dm may use multiple
    links and expects block layer to track reference count for each link,
    which is different from and unrelated to the exclusive device holder
    identified by @holder when the device is opened.
    
    Remove the single holder assumption and automatic removal of the link
    and revive the per-link reference count tracking.  The code
    essentially behaves the same as before commit e09b457b sans the
    unnecessary kobject reference count dancing.
    
    While at it, note that this facility should not be used by anyone else
    than the current ones.  Sysfs symlinks shouldn't be abused like this
    and the whole thing doesn't belong in the block layer at all.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Milan Broz <mbroz@redhat.com>
    Cc: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
    Cc: Neil Brown <neilb@suse.de>
    Cc: linux-raid@vger.kernel.org
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3984f2358d1f..fb2190349cdf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -666,7 +666,7 @@ struct block_device {
 	int			bd_holders;
 	bool			bd_write_holder;
 #ifdef CONFIG_SYSFS
-	struct gendisk *	bd_holder_disk;	/* for sysfs slave linkng */
+	struct list_head	bd_holder_disks;
 #endif
 	struct block_device *	bd_contains;
 	unsigned		bd_block_size;
@@ -2058,12 +2058,18 @@ extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
 extern int blkdev_put(struct block_device *bdev, fmode_t mode);
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
+extern void bd_unlink_disk_holder(struct block_device *bdev,
+				  struct gendisk *disk);
 #else
 static inline int bd_link_disk_holder(struct block_device *bdev,
 				      struct gendisk *disk)
 {
 	return 0;
 }
+static inline void bd_unlink_disk_holder(struct block_device *bdev,
+					 struct gendisk *disk)
+{
+}
 #endif
 #endif
 

commit 275220f0fcff1adf28a717076e00f575edf05fda
Merge: fe3c560b8a22 81c5e2ae33c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 13 10:45:01 2011 -0800

    Merge branch 'for-2.6.38/core' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.38/core' of git://git.kernel.dk/linux-2.6-block: (43 commits)
      block: ensure that completion error gets properly traced
      blktrace: add missing probe argument to block_bio_complete
      block cfq: don't use atomic_t for cfq_group
      block cfq: don't use atomic_t for cfq_queue
      block: trace event block fix unassigned field
      block: add internal hd part table references
      block: fix accounting bug on cross partition merges
      kref: add kref_test_and_get
      bio-integrity: mark kintegrityd_wq highpri and CPU intensive
      block: make kblockd_workqueue smarter
      Revert "sd: implement sd_check_events()"
      block: Clean up exit_io_context() source code.
      Fix compile warnings due to missing removal of a 'ret' variable
      fs/block: type signature of major_to_index(int) to major_to_index(unsigned)
      block: convert !IS_ERR(p) && p to !IS_ERR_NOR_NULL(p)
      cfq-iosched: don't check cfqg in choose_service_tree()
      fs/splice: Pull buf->ops->confirm() from splice_from_pipe actors
      cdrom: export cdrom_check_events()
      sd: implement sd_check_events()
      sr: implement sr_check_events()
      ...

commit c74a1cbb3cac348f276fabc381758f5b0b4713b2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 12 16:59:34 2011 -0500

    pass default dentry_operations to mount_pseudo()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3e4c27486e74..c0701288d204 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1835,7 +1835,9 @@ struct super_block *sget(struct file_system_type *type,
 			int (*set)(struct super_block *,void *),
 			void *data);
 extern struct dentry *mount_pseudo(struct file_system_type *, char *,
-	const struct super_operations *ops, unsigned long);
+	const struct super_operations *ops,
+	const struct dentry_operations *dops,
+	unsigned long);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 
 static inline void sb_mark_dirty(struct super_block *sb)

commit c8aebb0c9f8c7471643d5f8ba68328de8013005f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 18 10:22:30 2010 -0500

    per-superblock default ->d_op
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f84d9928bdb1..3e4c27486e74 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1423,6 +1423,7 @@ struct super_block {
 	 * generic_show_options()
 	 */
 	char __rcu *s_options;
+	const struct dentry_operations *s_d_op; /* default d_op for dentries */
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 57cc7215b70856dc6bae8e55b00ecd7b1d7429b1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jan 10 08:18:25 2011 +0200

    headers: kobject.h redux
    
    Remove kobject.h from files which don't need it, notably,
    sched.h and fs.h.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index baf3e556ff0e..f84d9928bdb1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -382,7 +382,6 @@ struct inodes_stat_t {
 #include <linux/path.h>
 #include <linux/stat.h>
 #include <linux/cache.h>
-#include <linux/kobject.h>
 #include <linux/list.h>
 #include <linux/radix-tree.h>
 #include <linux/prio_tree.h>
@@ -402,6 +401,7 @@ struct hd_geometry;
 struct iovec;
 struct nameidata;
 struct kiocb;
+struct kobject;
 struct pipe_inode_info;
 struct poll_table_struct;
 struct kstatfs;

commit ceb5bdc2d246f6d81cf61ed70f325308a11821d2
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:50:05 2011 +1100

    fs: dcache per-bucket dcache hash locking
    
    We can turn the dcache hash locking from a global dcache_hash_lock into
    per-bucket locking.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d5a4d42f655b..baf3e556ff0e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -392,6 +392,7 @@ struct inodes_stat_t {
 #include <linux/capability.h>
 #include <linux/semaphore.h>
 #include <linux/fiemap.h>
+#include <linux/rculist_bl.h>
 
 #include <asm/atomic.h>
 #include <asm/byteorder.h>
@@ -1377,7 +1378,7 @@ struct super_block {
 	const struct xattr_handler **s_xattr;
 
 	struct list_head	s_inodes;	/* all inodes */
-	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
+	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */
 #ifdef CONFIG_SMP
 	struct list_head __percpu *s_files;
 #else

commit b74c79e99389cd79b31fcc08f82c24e492e63c7e
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:58 2011 +1100

    fs: provide rcu-walk aware permission i_ops
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a04aa96acb71..d5a4d42f655b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1550,11 +1550,13 @@ struct file_operations {
 	int (*setlease)(struct file *, long, struct file_lock **);
 };
 
+#define IPERM_FLAG_RCU	0x0001
+
 struct inode_operations {
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
 	void * (*follow_link) (struct dentry *, struct nameidata *);
-	int (*permission) (struct inode *, int);
-	int (*check_acl)(struct inode *, int);
+	int (*permission) (struct inode *, int, unsigned int);
+	int (*check_acl)(struct inode *, int, unsigned int);
 
 	int (*readlink) (struct dentry *, char __user *,int);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
@@ -2165,8 +2167,8 @@ extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct iattr *);
 extern int inode_permission(struct inode *, int);
-extern int generic_permission(struct inode *, int,
-		int (*check_acl)(struct inode *, int));
+extern int generic_permission(struct inode *, int, unsigned int,
+		int (*check_acl)(struct inode *, int, unsigned int));
 
 static inline bool execute_ok(struct inode *inode)
 {

commit 44a7d7a878c9cbb74f236ea755b25b6b2e26a9a9
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:56 2011 +1100

    fs: cache optimise dentry and inode for rcu-walk
    
    Put dentry and inode fields into top of data structure.  This allows RCU path
    traversal to perform an RCU dentry lookup in a path walk by touching only the
    first 56 bytes of the dentry.
    
    We also fit in 8 bytes of inline name in the first 64 bytes, so for short
    names, only 64 bytes needs to be touched to perform the lookup. We should
    get rid of the hash->prev pointer from the first 64 bytes, and fit 16 bytes
    of name in there, which will take care of 81% rather than 32% of the kernel
    tree.
    
    inode is also rearranged so that RCU lookup will only touch a single cacheline
    in the inode, plus one in the i_ops structure.
    
    This is important for directory component lookups in RCU path walking. In the
    kernel source, directory names average is around 6 chars, so this works.
    
    When we reach the last element of the lookup, we need to lock it and take its
    refcount which requires another cacheline access.
    
    Align dentry and inode operations structs, so members will be at predictable
    offsets and we can group common operations into head of structure.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ea202fff44f8..a04aa96acb71 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -733,6 +733,20 @@ struct posix_acl;
 #define ACL_NOT_CACHED ((void *)(-1))
 
 struct inode {
+	/* RCU path lookup touches following: */
+	umode_t			i_mode;
+	uid_t			i_uid;
+	gid_t			i_gid;
+	const struct inode_operations	*i_op;
+	struct super_block	*i_sb;
+
+	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
+	unsigned int		i_flags;
+	struct mutex		i_mutex;
+
+	unsigned long		i_state;
+	unsigned long		dirtied_when;	/* jiffies of first dirtying */
+
 	struct hlist_node	i_hash;
 	struct list_head	i_wb_list;	/* backing dev IO list */
 	struct list_head	i_lru;		/* inode LRU list */
@@ -744,8 +758,6 @@ struct inode {
 	unsigned long		i_ino;
 	atomic_t		i_count;
 	unsigned int		i_nlink;
-	uid_t			i_uid;
-	gid_t			i_gid;
 	dev_t			i_rdev;
 	unsigned int		i_blkbits;
 	u64			i_version;
@@ -758,13 +770,8 @@ struct inode {
 	struct timespec		i_ctime;
 	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;
-	umode_t			i_mode;
-	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
-	struct mutex		i_mutex;
 	struct rw_semaphore	i_alloc_sem;
-	const struct inode_operations	*i_op;
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
-	struct super_block	*i_sb;
 	struct file_lock	*i_flock;
 	struct address_space	*i_mapping;
 	struct address_space	i_data;
@@ -785,11 +792,6 @@ struct inode {
 	struct hlist_head	i_fsnotify_marks;
 #endif
 
-	unsigned long		i_state;
-	unsigned long		dirtied_when;	/* jiffies of first dirtying */
-
-	unsigned int		i_flags;
-
 #ifdef CONFIG_IMA
 	/* protected by i_lock */
 	unsigned int		i_readcount; /* struct files open RO */
@@ -1549,8 +1551,15 @@ struct file_operations {
 };
 
 struct inode_operations {
-	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
 	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+	void * (*follow_link) (struct dentry *, struct nameidata *);
+	int (*permission) (struct inode *, int);
+	int (*check_acl)(struct inode *, int);
+
+	int (*readlink) (struct dentry *, char __user *,int);
+	void (*put_link) (struct dentry *, struct nameidata *, void *);
+
+	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
 	int (*link) (struct dentry *,struct inode *,struct dentry *);
 	int (*unlink) (struct inode *,struct dentry *);
 	int (*symlink) (struct inode *,struct dentry *,const char *);
@@ -1559,12 +1568,7 @@ struct inode_operations {
 	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
-	int (*readlink) (struct dentry *, char __user *,int);
-	void * (*follow_link) (struct dentry *, struct nameidata *);
-	void (*put_link) (struct dentry *, struct nameidata *, void *);
 	void (*truncate) (struct inode *);
-	int (*permission) (struct inode *, int);
-	int (*check_acl)(struct inode *, int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
@@ -1576,7 +1580,7 @@ struct inode_operations {
 			  loff_t len);
 	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
 		      u64 len);
-};
+} ____cacheline_aligned;
 
 struct seq_file;
 

commit ff0c7d15f9787b7e8c601533c015295cc68329f8
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:50 2011 +1100

    fs: avoid inode RCU freeing for pseudo fs
    
    Pseudo filesystems that don't put inode on RCU list or reachable by
    rcu-walk dentries do not need to RCU free their inodes.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ff4d0a33b25..ea202fff44f8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2233,6 +2233,7 @@ extern void iget_failed(struct inode *);
 extern void end_writeback(struct inode *);
 extern void __destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
+extern void free_inode_nonrcu(struct inode *inode);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_suid(struct file *);
 

commit fa0d7e3de6d6fc5004ad9dea0dd6b286af8f03e9
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:49 2011 +1100

    fs: icache RCU free inodes
    
    RCU free the struct inode. This will allow:
    
    - Subsequent store-free path walking patch. The inode must be consulted for
      permissions when walking, so an RCU inode reference is a must.
    - sb_inode_list_lock to be moved inside i_lock because sb list walkers who want
      to take i_lock no longer need to take sb_inode_list_lock to walk the list in
      the first place. This will simplify and optimize locking.
    - Could remove some nested trylock loops in dcache code
    - Could potentially simplify things a bit in VM land. Do not need to take the
      page lock to follow page->mapping.
    
    The downsides of this is the performance cost of using RCU. In a simple
    creat/unlink microbenchmark, performance drops by about 10% due to inability to
    reuse cache-hot slab objects. As iterations increase and RCU freeing starts
    kicking over, this increases to about 20%.
    
    In cases where inode lifetimes are longer (ie. many inodes may be allocated
    during the average life span of a single inode), a lot of this cache reuse is
    not applicable, so the regression caused by this patch is smaller.
    
    The cache-hot regression could largely be avoided by using SLAB_DESTROY_BY_RCU,
    however this adds some complexity to list walking and store-free path walking,
    so I prefer to implement this at a later date, if it is shown to be a win in
    real situations. I haven't found a regression in any non-micro benchmark so I
    doubt it will be a problem.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 296cf2fde945..1ff4d0a33b25 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -737,7 +737,10 @@ struct inode {
 	struct list_head	i_wb_list;	/* backing dev IO list */
 	struct list_head	i_lru;		/* inode LRU list */
 	struct list_head	i_sb_list;
-	struct list_head	i_dentry;
+	union {
+		struct list_head	i_dentry;
+		struct rcu_head		i_rcu;
+	};
 	unsigned long		i_ino;
 	atomic_t		i_count;
 	unsigned int		i_nlink;

commit b5c84bf6f6fa3a7dfdcb556023a62953574b60ee
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:49:38 2011 +1100

    fs: dcache remove dcache_lock
    
    dcache_lock no longer protects anything. remove it.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 090f0eacde29..296cf2fde945 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1378,7 +1378,7 @@ struct super_block {
 #else
 	struct list_head	s_files;
 #endif
-	/* s_dentry_lru and s_nr_dentry_unused are protected by dcache_lock */
+	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	int			s_nr_dentry_unused;	/* # of dentry on lru */
 
@@ -2446,6 +2446,10 @@ static inline ino_t parent_ino(struct dentry *dentry)
 {
 	ino_t res;
 
+	/*
+	 * Don't strictly need d_lock here? If the parent ino could change
+	 * then surely we'd have a deeper race in the caller?
+	 */
 	spin_lock(&dentry->d_lock);
 	res = dentry->d_parent->d_inode->i_ino;
 	spin_unlock(&dentry->d_lock);

commit c45821d263a8a5109d69a9e8942b8d65bcd5f31a
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Sun Oct 31 00:04:44 2010 -0400

    locks: eliminate fl_mylease callback
    
    The nfs server only supports read delegations for now, so we don't care
    how conflicts are determined.  All we care is that unlocks are
    recognized as matching the leases they are meant to remove.  After the
    last patch, a comparison of struct files will work for that purpose.  So
    we no longer need this callback.
    
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 090f0eacde29..73ce69f728e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1059,7 +1059,6 @@ struct lock_manager_operations {
 	int (*fl_grant)(struct file_lock *, struct file_lock *, int);
 	void (*fl_release_private)(struct file_lock *);
 	void (*fl_break)(struct file_lock *);
-	int (*fl_mylease)(struct file_lock *, struct file_lock *);
 	int (*fl_change)(struct file_lock **, int);
 };
 

commit 77ea887e433ad8389d416826936c110fa7910f80
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Dec 8 20:57:37 2010 +0100

    implement in-kernel gendisk events handling
    
    Currently, media presence polling for removeable block devices is done
    from userland.  There are several issues with this.
    
    * Polling is done by periodically opening the device.  For SCSI
      devices, the command sequence generated by such action involves a
      few different commands including TEST_UNIT_READY.  This behavior,
      while perfectly legal, is different from Windows which only issues
      single command, GET_EVENT_STATUS_NOTIFICATION.  Unfortunately, some
      ATAPI devices lock up after being periodically queried such command
      sequences.
    
    * There is no reliable and unintrusive way for a userland program to
      tell whether the target device is safe for media presence polling.
      For example, polling for media presence during an on-going burning
      session can make it fail.  The polling program can avoid this by
      opening the device with O_EXCL but then it risks making a valid
      exclusive user of the device fail w/ -EBUSY.
    
    * Userland polling is unnecessarily heavy and in-kernel implementation
      is lighter and better coordinated (workqueue, timer slack).
    
    This patch implements framework for in-kernel disk event handling,
    which includes media presence polling.
    
    * bdops->check_events() is added, which supercedes ->media_changed().
      It should check whether there's any pending event and return if so.
      Currently, two events are defined - DISK_EVENT_MEDIA_CHANGE and
      DISK_EVENT_EJECT_REQUEST.  ->check_events() is guaranteed not to be
      called parallelly.
    
    * gendisk->events and ->async_events are added.  These should be
      initialized by block driver before passing the device to add_disk().
      The former contains the mask of all supported events and the latter
      the mask of all events which the device can report without polling.
      /sys/block/*/events[_async] export these to userland.
    
    * Kernel parameter block.events_dfl_poll_msecs controls the system
      polling interval (default is 0 which means disable) and
      /sys/block/*/events_poll_msecs control polling intervals for
      individual devices (default is -1 meaning use system setting).  Note
      that if a device can report all supported events asynchronously and
      its polling interval isn't explicitly set, the device won't be
      polled regardless of the system polling interval.
    
    * If a device is opened exclusively with write access, event checking
      is automatically disabled until all write exclusive accesses are
      released.
    
    * There are event 'clearing' events.  For example, both of currently
      defined events are cleared after the device has been successfully
      opened.  This information is passed to ->check_events() callback
      using @clearing argument as a hint.
    
    * Event checking is always performed from system_nrt_wq and timer
      slack is set to 25% for polling.
    
    * Nothing changes for drivers which implement ->media_changed() but
      not ->check_events().  Going forward, all drivers will be converted
      to ->check_events() and ->media_change() will be dropped.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f48501563917..997d22efdef0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -662,6 +662,7 @@ struct block_device {
 	void *			bd_claiming;
 	void *			bd_holder;
 	int			bd_holders;
+	bool			bd_write_holder;
 #ifdef CONFIG_SYSFS
 	struct gendisk *	bd_holder_disk;	/* for sysfs slave linkng */
 #endif

commit 6072d13c429373c5d63b69dadbbef40a9b035552
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 1 13:35:19 2010 -0500

    Call the filesystem back whenever a page is removed from the page cache
    
    NFS needs to be able to release objects that are stored in the page
    cache once the page itself is no longer visible from the page cache.
    
    This patch adds a callback to the address space operations that allows
    filesystems to perform page cleanups once the page has been removed
    from the page cache.
    
    Original patch by: Linus Torvalds <torvalds@linux-foundation.org>
    [trondmy: cover the cases of invalidate_inode_pages2() and
              truncate_inode_pages()]
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c9e06cc70dad..090f0eacde29 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -602,6 +602,7 @@ struct address_space_operations {
 	sector_t (*bmap)(struct address_space *, sector_t);
 	void (*invalidatepage) (struct page *, unsigned long);
 	int (*releasepage) (struct page *, gfp_t);
+	void (*freepage)(struct page *);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
 	int (*get_xip_mem)(struct address_space *, pgoff_t, int,

commit 3a3a1af37f0405d15c0b64a6ce7f4878084442e0
Author: Loc Minier <loic.minier@linaro.org>
Date:   Wed Nov 24 12:56:53 2010 -0800

    include/linux/fs.h: fix userspace build
    
    dpkg uses fiemap but didn't particularly need to include stdint.h so far.
    Since 367a51a33902 ("fs: Add FITRIM ioctl"), build of linux/fs.h failed in
    dpkg with:
    
      In file included from ../../src/filesdb.c:27:0:
      /usr/include/linux/fs.h:37:2: error: expected specifier-qualifier-list before 'uint64_t'
    
    Use exportable type __u64 to avoid the dependency on stdint.h.
    
    b31d42a5af18 ("Fix compile brekage with !CONFIG_BLOCK") fixed only the
    kernel build by including linux/types.h, but this also fixed "make
    headers_check", so don't revert it.
    
    Signed-off-by: Loc Minier <loic.minier@linaro.org>
    Tested-by: Arnd Bergmann <arnd.bergmann@linaro.org>
    Cc: Lukas Czerner <lczerner@redhat.com>
    Cc: Dmitry Monakhov <dmonakhov@openvz.org>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eedc00b7b1ee..c9e06cc70dad 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -34,9 +34,9 @@
 #define SEEK_MAX	SEEK_END
 
 struct fstrim_range {
-	uint64_t start;
-	uint64_t len;
-	uint64_t minlen;
+	__u64 start;
+	__u64 len;
+	__u64 minlen;
 };
 
 /* And dynamically-tunable limits and defaults: */

commit 93bb41f4f8b89ac8b4d0a734bc59634cb0a29a89
Author: Lukas Czerner <lczerner@redhat.com>
Date:   Fri Nov 19 21:18:35 2010 -0500

    fs: Do not dispatch FITRIM through separate super_operation
    
    There was concern that FITRIM ioctl is not common enough to be included
    in core vfs ioctl, as Christoph Hellwig pointed out there's no real point
    in dispatching this out to a separate vector instead of just through
    ->ioctl.
    
    So this commit removes ioctl_fstrim() from vfs ioctl and trim_fs
    from super_operation structure.
    
    Signed-off-by: Lukas Czerner <lczerner@redhat.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 334d68a17108..eedc00b7b1ee 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1612,7 +1612,6 @@ struct super_operations {
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
-	int (*trim_fs) (struct super_block *, struct fstrim_range *);
 };
 
 /*

commit d4d77629953eabd3c14f6fa5746f6b28babfc55f
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 13 11:55:18 2010 +0100

    block: clean up blkdev_get() wrappers and their users
    
    After recent blkdev_get() modifications, open_by_devnum() and
    open_bdev_exclusive() are simple wrappers around blkdev_get().
    Replace them with blkdev_get_by_dev() and blkdev_get_by_path().
    
    blkdev_get_by_dev() is identical to open_by_devnum().
    blkdev_get_by_path() is slightly different in that it doesn't
    automatically add %FMODE_EXCL to @mode.
    
    All users are converted.  Most conversions are mechanical and don't
    introduce any behavior difference.  There are several exceptions.
    
    * btrfs now sets FMODE_EXCL in btrfs_device->mode, so there's no
      reason to OR it explicitly on blkdev_put().
    
    * gfs2, nilfs2 and the generic mount_bdev() now set FMODE_EXCL in
      sb->s_mode.
    
    * With the above changes, sb->s_mode now always should contain
      FMODE_EXCL.  WARN_ON_ONCE() added to kill_block_super() to detect
      errors.
    
    The new blkdev_get_*() functions are with proper docbook comments.
    While at it, add function description to blkdev_get() too.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Philipp Reisner <philipp.reisner@linbit.com>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Joern Engel <joern@lazybastard.org>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: KONISHI Ryusuke <konishi.ryusuke@lab.ntt.co.jp>
    Cc: reiserfs-devel@vger.kernel.org
    Cc: xfs-masters@oss.sgi.com
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1a033e8ebe4c..f48501563917 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2006,8 +2006,6 @@ extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
-extern struct block_device *open_by_devnum(dev_t dev, fmode_t mode,
-					   void *holder);
 extern void invalidate_bdev(struct block_device *);
 extern int sync_blockdev(struct block_device *bdev);
 extern struct super_block *freeze_bdev(struct block_device *);
@@ -2039,6 +2037,10 @@ extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder);
+extern struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,
+					       void *holder);
+extern struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode,
+					      void *holder);
 extern int blkdev_put(struct block_device *bdev, fmode_t mode);
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
@@ -2083,7 +2085,6 @@ static inline void unregister_chrdev(unsigned int major, const char *name)
 extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
-extern struct block_device *open_bdev_exclusive(const char *, fmode_t, void *);
 extern void blkdev_show(struct seq_file *,off_t);
 
 #else

commit e525fd89d380c4a94c0d63913a1dd1a593ed25e7
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 13 11:55:17 2010 +0100

    block: make blkdev_get/put() handle exclusive access
    
    Over time, block layer has accumulated a set of APIs dealing with bdev
    open, close, claim and release.
    
    * blkdev_get/put() are the primary open and close functions.
    
    * bd_claim/release() deal with exclusive open.
    
    * open/close_bdev_exclusive() are combination of open and claim and
      the other way around, respectively.
    
    * bd_link/unlink_disk_holder() to create and remove holder/slave
      symlinks.
    
    * open_by_devnum() wraps bdget() + blkdev_get().
    
    The interface is a bit confusing and the decoupling of open and claim
    makes it impossible to properly guarantee exclusive access as
    in-kernel open + claim sequence can disturb the existing exclusive
    open even before the block layer knows the current open if for another
    exclusive access.  Reorganize the interface such that,
    
    * blkdev_get() is extended to include exclusive access management.
      @holder argument is added and, if is @FMODE_EXCL specified, it will
      gain exclusive access atomically w.r.t. other exclusive accesses.
    
    * blkdev_put() is similarly extended.  It now takes @mode argument and
      if @FMODE_EXCL is set, it releases an exclusive access.  Also, when
      the last exclusive claim is released, the holder/slave symlinks are
      removed automatically.
    
    * bd_claim/release() and close_bdev_exclusive() are no longer
      necessary and either made static or removed.
    
    * bd_link_disk_holder() remains the same but bd_unlink_disk_holder()
      is no longer necessary and removed.
    
    * open_bdev_exclusive() becomes a simple wrapper around lookup_bdev()
      and blkdev_get().  It also has an unexpected extra bdev_read_only()
      test which probably should be moved into blkdev_get().
    
    * open_by_devnum() is modified to take @holder argument and pass it to
      blkdev_get().
    
    Most of bdev open/close operations are unified into blkdev_get/put()
    and most exclusive accesses are tested atomically at the open time (as
    it should).  This cleans up code and removes some, both valid and
    invalid, but unnecessary all the same, corner cases.
    
    open_bdev_exclusive() and open_by_devnum() can use further cleanup -
    rename to blkdev_get_by_path() and blkdev_get_by_devt() and drop
    special features.  Well, let's leave them for another day.
    
    Most conversions are straight-forward.  drbd conversion is a bit more
    involved as there was some reordering, but the logic should stay the
    same.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Neil Brown <neilb@suse.de>
    Acked-by: Ryusuke Konishi <konishi.ryusuke@lab.ntt.co.jp>
    Acked-by: Mike Snitzer <snitzer@redhat.com>
    Acked-by: Philipp Reisner <philipp.reisner@linbit.com>
    Cc: Peter Osterlund <petero2@telia.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andreas Dilger <adilger.kernel@dilger.ca>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <joel.becker@oracle.com>
    Cc: Alex Elder <aelder@sgi.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: dm-devel@redhat.com
    Cc: drbd-dev@lists.linbit.com
    Cc: Leo Chen <leochen@broadcom.com>
    Cc: Scott Branden <sbranden@broadcom.com>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Cc: Joern Engel <joern@logfs.org>
    Cc: reiserfs-devel@vger.kernel.org
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 66b7f2c5d7e9..1a033e8ebe4c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2006,7 +2006,8 @@ extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
-extern struct block_device *open_by_devnum(dev_t, fmode_t);
+extern struct block_device *open_by_devnum(dev_t dev, fmode_t mode,
+					   void *holder);
 extern void invalidate_bdev(struct block_device *);
 extern int sync_blockdev(struct block_device *bdev);
 extern struct super_block *freeze_bdev(struct block_device *);
@@ -2037,22 +2038,16 @@ extern const struct file_operations def_fifo_fops;
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
-extern int blkdev_get(struct block_device *, fmode_t);
-extern int blkdev_put(struct block_device *, fmode_t);
-extern int bd_claim(struct block_device *, void *);
-extern void bd_release(struct block_device *);
+extern int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder);
+extern int blkdev_put(struct block_device *bdev, fmode_t mode);
 #ifdef CONFIG_SYSFS
 extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
-extern void bd_unlink_disk_holder(struct block_device *bdev);
 #else
 static inline int bd_link_disk_holder(struct block_device *bdev,
 				      struct gendisk *disk)
 {
 	return 0;
 }
-static inline void bd_unlink_disk_holder(struct block_device *bdev)
-{
-}
 #endif
 #endif
 
@@ -2089,7 +2084,6 @@ extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern struct block_device *open_bdev_exclusive(const char *, fmode_t, void *);
-extern void close_bdev_exclusive(struct block_device *, fmode_t);
 extern void blkdev_show(struct seq_file *,off_t);
 
 #else

commit e09b457bdb7e8d23fc54dcef0930ac697d8de895
Author: Tejun Heo <tj@kernel.org>
Date:   Sat Nov 13 11:55:17 2010 +0100

    block: simplify holder symlink handling
    
    Code to manage symlinks in /sys/block/*/{holders|slaves} are overly
    complex with multiple holder considerations, redundant extra
    references to all involved kobjects, unused generic kobject holder
    support and unnecessary mixup with bd_claim/release functionalities.
    
    Strip it down to what's necessary (single gendisk holder) and make it
    use a separate interface.  This is a step for cleaning up
    bd_claim/release.  This patch makes dm-table slightly more complex but
    it will be simplified again with further changes.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Neil Brown <neilb@suse.de>
    Acked-by: Mike Snitzer <snitzer@redhat.com>
    Cc: dm-devel@redhat.com

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 334d68a17108..66b7f2c5d7e9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -663,7 +663,7 @@ struct block_device {
 	void *			bd_holder;
 	int			bd_holders;
 #ifdef CONFIG_SYSFS
-	struct list_head	bd_holder_list;
+	struct gendisk *	bd_holder_disk;	/* for sysfs slave linkng */
 #endif
 	struct block_device *	bd_contains;
 	unsigned		bd_block_size;
@@ -2042,11 +2042,17 @@ extern int blkdev_put(struct block_device *, fmode_t);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);
 #ifdef CONFIG_SYSFS
-extern int bd_claim_by_disk(struct block_device *, void *, struct gendisk *);
-extern void bd_release_from_disk(struct block_device *, struct gendisk *);
+extern int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk);
+extern void bd_unlink_disk_holder(struct block_device *bdev);
 #else
-#define bd_claim_by_disk(bdev, holder, disk)	bd_claim(bdev, holder)
-#define bd_release_from_disk(bdev, disk)	bd_release(bdev)
+static inline int bd_link_disk_holder(struct block_device *bdev,
+				      struct gendisk *disk)
+{
+	return 0;
+}
+static inline void bd_unlink_disk_holder(struct block_device *bdev)
+{
+}
 #endif
 #endif
 

commit bb8430a2c8fe2b726033017daadf73c69b0348ea
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sun Oct 31 08:35:31 2010 -0400

    locks: remove fl_copy_lock lock_manager operation
    
    This one was only used for a nasty hack in nfsd, which has recently
    been removed.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1eb29399a4ff..334d68a17108 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1056,7 +1056,6 @@ struct lock_manager_operations {
 	int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
 	void (*fl_notify)(struct file_lock *);	/* unblock callback */
 	int (*fl_grant)(struct file_lock *, struct file_lock *, int);
-	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 	void (*fl_release_private)(struct file_lock *);
 	void (*fl_break)(struct file_lock *);
 	int (*fl_mylease)(struct file_lock *, struct file_lock *);

commit 05fa3135fdc7b9b510b502a35b6b97d2b38c6f48
Author: J. Bruce Fields <bfields@redhat.com>
Date:   Sat Oct 30 17:31:15 2010 -0400

    locks: fix setlease methods to free passed-in lock
    
    We modified setlease to require the caller to allocate the new lease in
    the case of creating a new lease, but forgot to fix up the filesystem
    methods.
    
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Steve French <sfrench@samba.org>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: J. Bruce Fields <bfields@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b7b507ffa1c..1eb29399a4ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1129,6 +1129,7 @@ extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
 /* fs/locks.c */
+void locks_free_lock(struct file_lock *fl);
 extern void locks_init_lock(struct file_lock *);
 extern struct file_lock * locks_alloc_lock(void);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);

commit 435f49a518c78eec8e2edbbadd912737246cbe20
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 29 10:36:49 2010 -0700

    readv/writev: do the same MAX_RW_COUNT truncation that read/write does
    
    We used to protect against overflow, but rather than return an error, do
    what read/write does, namely to limit the total size to MAX_RW_COUNT.
    This is not only more consistent, but it also means that any broken
    low-level read/write routine that still keeps counts in 'int' can't
    break.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4d07902bc50c..7b7b507ffa1c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1867,6 +1867,7 @@ extern int current_umask(void);
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 
+#define MAX_RW_COUNT (INT_MAX & PAGE_CACHE_MASK)
 extern int rw_verify_area(int, struct file *, loff_t *, size_t);
 
 #define FLOCK_VERIFY_READ  1

commit ceefda6931806972ecf550bd8231dce4a4178953
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 26 13:16:50 2010 +0400

    switch get_sb_ns() users
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 43e6cfb5cbb3..4d07902bc50c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1789,9 +1789,8 @@ struct file_system_type {
 	struct lock_class_key i_alloc_sem_key;
 };
 
-extern int get_sb_ns(struct file_system_type *fs_type, int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int),
-	struct vfsmount *mnt);
+extern struct dentry *mount_ns(struct file_system_type *fs_type, int flags,
+	void *data, int (*fill_super)(struct super_block *, void *, int));
 extern struct dentry *mount_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int));

commit 51139adac92f7160ad3ca1cab2de1b4b8d19dc96
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 25 23:47:46 2010 +0400

    convert get_sb_pseudo() users
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4c3a29ddcacb..43e6cfb5cbb3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1824,9 +1824,8 @@ struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),
 			void *data);
-extern int get_sb_pseudo(struct file_system_type *, char *,
-	const struct super_operations *ops, unsigned long,
-	struct vfsmount *mnt);
+extern struct dentry *mount_pseudo(struct file_system_type *, char *,
+	const struct super_operations *ops, unsigned long);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 
 static inline void sb_mark_dirty(struct super_block *sb)

commit 3c26ff6e499ee7e6f9f2bc7da5f2f30d80862ecf
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 25 11:46:36 2010 +0400

    convert get_sb_nodev() users
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0aa2f1202afa..4c3a29ddcacb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1806,6 +1806,9 @@ extern int get_sb_single(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int),
 	struct vfsmount *mnt);
+extern struct dentry *mount_nodev(struct file_system_type *fs_type,
+	int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
 extern int get_sb_nodev(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int),

commit fc14f2fef682df677d64a145256dbd263df2aa7b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 25 01:48:30 2010 +0400

    convert get_sb_single() users
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2fab5a24ca51..0aa2f1202afa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1799,6 +1799,9 @@ extern int get_sb_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int),
 	struct vfsmount *mnt);
+extern struct dentry *mount_single(struct file_system_type *fs_type,
+	int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
 extern int get_sb_single(struct file_system_type *fs_type,
 	int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int),

commit 152a08366671080f27b32e0c411ad620c5f88b57
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 25 00:46:55 2010 +0400

    new helper: mount_bdev()
    
    ... and switch of the obvious get_sb_bdev() users to ->mount()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c6b474311690..2fab5a24ca51 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1792,6 +1792,9 @@ struct file_system_type {
 extern int get_sb_ns(struct file_system_type *fs_type, int flags, void *data,
 	int (*fill_super)(struct super_block *, void *, int),
 	struct vfsmount *mnt);
+extern struct dentry *mount_bdev(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
 extern int get_sb_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int),

commit c96e41e92b4aaf11e1f9775ecf0d1c8cbff829ed
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 25 00:17:56 2010 +0400

    beginning of transtion: ->mount()
    
    eventual replacement for ->get_sb() - does *not* get vfsmount,
    return ERR_PTR(error) or root of subtree to be mounted.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1c73b50e81ff..c6b474311690 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1772,6 +1772,8 @@ struct file_system_type {
 	int fs_flags;
 	int (*get_sb) (struct file_system_type *, int,
 		       const char *, void *, struct vfsmount *);
+	struct dentry *(*mount) (struct file_system_type *, int,
+		       const char *, void *);
 	void (*kill_sb) (struct super_block *);
 	struct module *owner;
 	struct file_system_type * next;

commit b31d42a5af1818bdf31a5f023abe4d8b212542f2
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Oct 28 16:39:24 2010 +0200

    Fix compile brekage with !CONFIG_BLOCK
    
    Today's git tree fails to build on !CONFIG_BLOCK, due to upstream commit
    367a51a33902 ("fs: Add FITRIM ioctl"):
    
     include/linux/fs.h:36: error: expected specifier-qualifier-list before uint64_t
     include/linux/fs.h:36: error: expected specifier-qualifier-list before uint64_t
     include/linux/fs.h:36: error: expected specifier-qualifier-list before uint64_t
    
    The commit adds uint64_t type usage to fs.h, but linux/types.h is not included
    explicitly - it's only included implicitly via linux/blk_types.h, and there only if
    CONFIG_BLOCK is enabled.
    
    Add the explicit #include to fix this.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6ed7ace74b7c..1c73b50e81ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -9,6 +9,7 @@
 #include <linux/limits.h>
 #include <linux/ioctl.h>
 #include <linux/blk_types.h>
+#include <linux/types.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change

commit a107e5a3a473a2ea62bd5af24e11b84adf1486ff
Merge: e3e1288e86a0 a269029d0e21
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Oct 27 23:44:47 2010 -0400

    Merge branch 'next' into upstream-merge
    
    Conflicts:
            fs/ext4/inode.c
            fs/ext4/mballoc.c
            include/trace/events/ext4.h

commit 367a51a339020ba4d9edb0ce0f21d65bd50b00c9
Author: Lukas Czerner <lczerner@redhat.com>
Date:   Wed Oct 27 21:30:11 2010 -0400

    fs: Add FITRIM ioctl
    
    Adds an filesystem independent ioctl to allow implementation of file
    system batched discard support. I takes fstrim_range structure as an
    argument. fstrim_range is definec in the include/fs.h and its
    definition is as follows.
    
    struct fstrim_range {
            start;
            len;
            minlen;
    }
    
    start   - first Byte to trim
    len     - number of Bytes to trim from start
    minlen  - minimum extent length to trim, free extents shorter than this
              number of Bytes will be ignored. This will be rounded up to fs
              block size.
    
    It is also possible to specify NULL as an argument. In this case the
    arguments will set itself as follows:
    
    start = 0;
    len = ULLONG_MAX;
    minlen = 0;
    
    So it will trim the whole file system at one run.
    
    After the FITRIM is done, the number of actually discarded Bytes is stored
    in fstrim_range.len to give the user better insight on how much storage
    space has been really released for wear-leveling.
    
    Signed-off-by: Lukas Czerner <lczerner@redhat.com>
    Reviewed-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 63d069bd80b7..7008268e9b5a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -32,6 +32,12 @@
 #define SEEK_END	2	/* seek relative to end of file */
 #define SEEK_MAX	SEEK_END
 
+struct fstrim_range {
+	uint64_t start;
+	uint64_t len;
+	uint64_t minlen;
+};
+
 /* And dynamically-tunable limits and defaults: */
 struct files_stat_struct {
 	int nr_files;		/* read only */
@@ -316,6 +322,7 @@ struct inodes_stat_t {
 #define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
 #define FIFREEZE	_IOWR('X', 119, int)	/* Freeze */
 #define FITHAW		_IOWR('X', 120, int)	/* Thaw */
+#define FITRIM		_IOWR('X', 121, struct fstrim_range)	/* Trim */
 
 #define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
 #define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
@@ -1581,6 +1588,7 @@ struct super_operations {
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
+	int (*trim_fs) (struct super_block *, struct fstrim_range *);
 };
 
 /*

commit 7420a8c0de8d99b201aeeab6fed16ca95ebf55a5
Merge: 12ba8d1e9262 72f98e72551f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 27 18:13:34 2010 -0700

    Merge branch 'flock' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'flock' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      locks: turn lock_flocks into a spinlock
      fasync: re-organize fasync entry insertion to allow it under a spinlock
      locks/nfsd: allocate file lock outside of spinlock
      lockd: fix nlmsvc_notify_blocked locking
      lockd: push lock_flocks down

commit f7347ce4ee7c65415f84be915c018473e7076f31
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 27 12:38:12 2010 -0400

    fasync: re-organize fasync entry insertion to allow it under a spinlock
    
    You currently cannot use "fasync_helper()" in an atomic environment to
    insert a new fasync entry, because it will need to allocate the new
    "struct fasync_struct".
    
    Yet fcntl_setlease() wants to call this under lock_flocks(), which is in
    the process of being converted from the BKL to a spinlock.
    
    In order to fix this, this abstracts out the actual fasync list
    insertion and the fasync allocations into functions of their own, and
    teaches fs/locks.c to pre-allocate the fasync_struct entry.  That way
    the actual list insertion can happen while holding the required
    spinlock.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    [bfields@redhat.com: rebase on top of my changes to Arnd's patch]
    Tested-by: J. Bruce Fields <bfields@redhat.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8d7de08ab546..56285e5e1de4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1302,6 +1302,11 @@ struct fasync_struct {
 
 /* SMP safe fasync helpers: */
 extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
+extern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);
+extern int fasync_remove_entry(struct file *, struct fasync_struct **);
+extern struct fasync_struct *fasync_alloc(void);
+extern void fasync_free(struct fasync_struct *);
+
 /* can be called from interrupts */
 extern void kill_fasync(struct fasync_struct **, int, int);
 

commit c5b1f0d92c36851aca09ac6c7c0c4f9690ac14f3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Oct 27 15:46:08 2010 +0200

    locks/nfsd: allocate file lock outside of spinlock
    
    As suggested by Christoph Hellwig, this moves allocation
    of new file locks out of generic_setlease into the
    callers, nfs4_open_delegation and fcntl_setlease in order
    to allow GFP_KERNEL allocations when lock_flocks has
    become a spinlock.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: J. Bruce Fields <bfields@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bb20373d0b46..8d7de08ab546 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1113,6 +1113,7 @@ extern int fcntl_getlease(struct file *filp);
 
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
+extern struct file_lock * locks_alloc_lock(void);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);

commit 426e1f5cec4821945642230218876b0e89aafab1
Merge: 9e5fca251f44 63997e98a3be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 26 17:58:44 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (52 commits)
      split invalidate_inodes()
      fs: skip I_FREEING inodes in writeback_sb_inodes
      fs: fold invalidate_list into invalidate_inodes
      fs: do not drop inode_lock in dispose_list
      fs: inode split IO and LRU lists
      fs: switch bdev inode bdi's correctly
      fs: fix buffer invalidation in invalidate_list
      fsnotify: use dget_parent
      smbfs: use dget_parent
      exportfs: use dget_parent
      fs: use RCU read side protection in d_validate
      fs: clean up dentry lru modification
      fs: split __shrink_dcache_sb
      fs: improve DCACHE_REFERENCED usage
      fs: use percpu counter for nr_dentry and nr_dentry_unused
      fs: simplify __d_free
      fs: take dcache_lock inside __d_path
      fs: do not assign default i_ino in new_inode
      fs: introduce a per-cpu last_ino allocator
      new helper: ihold()
      ...

commit 31453a9764f7e2a72a6e2c502ace586e2663a68c
Merge: f9ba5375a8aa 93ed0e2d07b2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 26 17:15:20 2010 -0700

    Merge branch 'akpm-incoming-1'
    
    * akpm-incoming-1: (176 commits)
      scripts/checkpatch.pl: add check for declaration of pci_device_id
      scripts/checkpatch.pl: add warnings for static char that could be static const char
      checkpatch: version 0.31
      checkpatch: statement/block context analyser should look at sanitised lines
      checkpatch: handle EXPORT_SYMBOL for DEVICE_ATTR and similar
      checkpatch: clean up structure definition macro handline
      checkpatch: update copyright dates
      checkpatch: Add additional attribute #defines
      checkpatch: check for incorrect permissions
      checkpatch: ensure kconfig help checks only apply when we are adding help
      checkpatch: simplify and consolidate "missing space after" checks
      checkpatch: add check for space after struct, union, and enum
      checkpatch: returning errno typically should be negative
      checkpatch: handle casts better fixing false categorisation of : as binary
      checkpatch: ensure we do not collapse bracketed sections into constants
      checkpatch: suggest cleanpatch and cleanfile when appropriate
      checkpatch: types may sit on a line on their own
      checkpatch: fix regressions in "fix handling of leading spaces"
      div64_u64(): improve precision on 32bit platforms
      lib/parser: cleanup match_number()
      ...

commit 518de9b39e854542de59bfb8b9f61c8f7ecf808b
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Oct 26 14:22:44 2010 -0700

    fs: allow for more than 2^31 files
    
    Robin Holt tried to boot a 16TB system and found af_unix was overflowing
    a 32bit value :
    
    <quote>
    
    We were seeing a failure which prevented boot.  The kernel was incapable
    of creating either a named pipe or unix domain socket.  This comes down
    to a common kernel function called unix_create1() which does:
    
            atomic_inc(&unix_nr_socks);
            if (atomic_read(&unix_nr_socks) > 2 * get_max_files())
                    goto out;
    
    The function get_max_files() is a simple return of files_stat.max_files.
    files_stat.max_files is a signed integer and is computed in
    fs/file_table.c's files_init().
    
            n = (mempages * (PAGE_SIZE / 1024)) / 10;
            files_stat.max_files = n;
    
    In our case, mempages (total_ram_pages) is approx 3,758,096,384
    (0xe0000000).  That leaves max_files at approximately 1,503,238,553.
    This causes 2 * get_max_files() to integer overflow.
    
    </quote>
    
    Fix is to let /proc/sys/fs/file-nr & /proc/sys/fs/file-max use long
    integers, and change af_unix to use an atomic_long_t instead of atomic_t.
    
    get_max_files() is changed to return an unsigned long.  get_nr_files() is
    changed to return a long.
    
    unix_nr_socks is changed from atomic_t to atomic_long_t, while not
    strictly needed to address Robin problem.
    
    Before patch (on a 64bit kernel) :
    # echo 2147483648 >/proc/sys/fs/file-max
    # cat /proc/sys/fs/file-max
    -18446744071562067968
    
    After patch:
    # echo 2147483648 >/proc/sys/fs/file-max
    # cat /proc/sys/fs/file-max
    2147483648
    # cat /proc/sys/fs/file-nr
    704     0       2147483648
    
    Reported-by: Robin Holt <holt@sgi.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: David Miller <davem@davemloft.net>
    Reviewed-by: Robin Holt <holt@sgi.com>
    Tested-by: Robin Holt <holt@sgi.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f34ff6e5558..b2cdb6bc8287 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -34,9 +34,9 @@
 
 /* And dynamically-tunable limits and defaults: */
 struct files_stat_struct {
-	int nr_files;		/* read only */
-	int nr_free_files;	/* read only */
-	int max_files;		/* tunable */
+	unsigned long nr_files;		/* read only */
+	unsigned long nr_free_files;	/* read only */
+	unsigned long max_files;		/* tunable */
 };
 
 struct inodes_stat_t {
@@ -400,7 +400,7 @@ extern void __init inode_init_early(void);
 extern void __init files_init(unsigned long);
 
 extern struct files_stat_struct files_stat;
-extern int get_max_files(void);
+extern unsigned long get_max_files(void);
 extern int sysctl_nr_open;
 extern struct inodes_stat_t inodes_stat;
 extern int leases_enable, lease_break_time;

commit f9ba5375a8aae4aeea6be15df77e24707a429812
Merge: 45352bbf48e9 bade72d607c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 26 11:37:48 2010 -0700

    Merge branch 'ima-memory-use-fixes'
    
    * ima-memory-use-fixes:
      IMA: fix the ToMToU logic
      IMA: explicit IMA i_flag to remove global lock on inode_delete
      IMA: drop refcnt from ima_iint_cache since it isn't needed
      IMA: only allocate iint when needed
      IMA: move read counter into struct inode
      IMA: use i_writecount rather than a private counter
      IMA: use inode->i_lock to protect read and write counters
      IMA: convert internal flags from long to char
      IMA: use unsigned int instead of long for counters
      IMA: drop the inode opencount since it isn't needed for operation
      IMA: use rbtree instead of radix tree for inode information cache

commit 196f518128d2ee6e0028b50e6fec0313640db142
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Oct 25 14:42:19 2010 -0400

    IMA: explicit IMA i_flag to remove global lock on inode_delete
    
    Currently for every removed inode IMA must take a global lock and search
    the IMA rbtree looking for an associated integrity structure.  Instead
    we explicitly mark an inode when we add an integrity structure so we
    only have to take the global lock and do the removal if it exists.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 01e3a0047fed..bb77843de9d6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -235,6 +235,7 @@ struct inodes_stat_t {
 #define S_NOCMTIME	128	/* Do not update file c/mtime */
 #define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
 #define S_PRIVATE	512	/* Inode is fs-internal */
+#define S_IMA		1024	/* Inode has an associated IMA struct */
 
 /*
  * Note that nosuid etc flags are inode-specific: setting some file-system
@@ -269,6 +270,7 @@ struct inodes_stat_t {
 #define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
 #define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
 #define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
+#define IS_IMA(inode)		((inode)->i_flags & S_IMA)
 
 /* the read-only stuff doesn't really belong here, but any other place is
    probably as bad and I don't want to create yet another include file. */

commit a178d2027d3198b0a04517d764326ab71cd73da2
Author: Eric Paris <eparis@redhat.com>
Date:   Mon Oct 25 14:41:59 2010 -0400

    IMA: move read counter into struct inode
    
    IMA currently allocated an inode integrity structure for every inode in
    core.  This stucture is about 120 bytes long.  Most files however
    (especially on a system which doesn't make use of IMA) will never need
    any of this space.  The problem is that if IMA is enabled we need to
    know information about the number of readers and the number of writers
    for every inode on the box.  At the moment we collect that information
    in the per inode iint structure and waste the rest of the space.  This
    patch moves those counters into the struct inode so we can eventually
    stop allocating an IMA integrity structure except when absolutely
    needed.
    
    This patch does the minimum needed to move the location of the data.
    Further cleanups, especially the location of counter updates, may still
    be possible.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 63d069bd80b7..01e3a0047fed 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -776,6 +776,10 @@ struct inode {
 
 	unsigned int		i_flags;
 
+#ifdef CONFIG_IMA
+	/* protected by i_lock */
+	unsigned int		i_readcount; /* struct files open RO */
+#endif
 	atomic_t		i_writecount;
 #ifdef CONFIG_SECURITY
 	void			*i_security;

commit 7ccf19a8042e343f8159f8a5fdd6a9422aa90c78
Author: Nick Piggin <npiggin@suse.de>
Date:   Thu Oct 21 11:49:30 2010 +1100

    fs: inode split IO and LRU lists
    
    The use of the same inode list structure (inode->i_list) for two
    different list constructs with different lifecycles and purposes
    makes it impossible to separate the locking of the different
    operations. Therefore, to enable the separation of the locking of
    the writeback and reclaim lists, split the inode->i_list into two
    separate lists dedicated to their specific tracking functions.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d58059944801..f300a6508818 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -723,7 +723,8 @@ struct posix_acl;
 
 struct inode {
 	struct hlist_node	i_hash;
-	struct list_head	i_list;		/* backing dev IO list */
+	struct list_head	i_wb_list;	/* backing dev IO list */
+	struct list_head	i_lru;		/* inode LRU list */
 	struct list_head	i_sb_list;
 	struct list_head	i_dentry;
 	unsigned long		i_ino;

commit 312d3ca856d369bb04d0443846b85b4cdde6fa8a
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sun Oct 10 05:36:23 2010 -0400

    fs: use percpu counter for nr_dentry and nr_dentry_unused
    
    The nr_dentry stat is a globally touched cacheline and atomic operation
    twice over the lifetime of a dentry. It is used for the benfit of userspace
    only. Turn it into a per-cpu counter and always decrement it in d_free instead
    of doing various batching operations to reduce lock hold times in the callers.
    
    Based on an earlier patch from Nick Piggin <npiggin@suse.de>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a573cf13f51..d58059944801 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2490,6 +2490,8 @@ ssize_t simple_attr_write(struct file *file, const char __user *buf,
 struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
+int proc_nr_dentry(struct ctl_table *table, int write,
+		  void __user *buffer, size_t *lenp, loff_t *ppos);
 int proc_nr_inodes(struct ctl_table *table, int write,
 		   void __user *buffer, size_t *lenp, loff_t *ppos);
 int __init get_filesystem_list(char *buf);

commit 85fe4025c616a7c0ed07bc2fc8c5371b07f3888c
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 23 11:19:54 2010 -0400

    fs: do not assign default i_ino in new_inode
    
    Instead of always assigning an increasing inode number in new_inode
    move the call to assign it into those callers that actually need it.
    For now callers that need it is estimated conservatively, that is
    the call is added to all filesystems that do not assign an i_ino
    by themselves.  For a few more filesystems we can avoid assigning
    any inode number given that they aren't user visible, and for others
    it could be done lazily when an inode number is actually needed,
    but that's left for later patches.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd6ae6c71fc8..4a573cf13f51 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2191,6 +2191,7 @@ extern struct inode * iget_locked(struct super_block *, unsigned long);
 extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
 extern int insert_inode_locked(struct inode *);
 extern void unlock_new_inode(struct inode *);
+extern unsigned int get_next_ino(void);
 
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);

commit 7de9c6ee3ecffd99e1628e81a5ea5468f7581a1f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 23 11:11:40 2010 -0400

    new helper: ihold()
    
    Clones an existing reference to inode; caller must already hold one.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d43e8b6685a2..bd6ae6c71fc8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2171,6 +2171,7 @@ extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
 
 extern int inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
+extern void ihold(struct inode * inode);
 extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);

commit 646ec4615cd05972581c9c5342ed7a1e77df17bb
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 23 07:15:32 2010 -0400

    fs: remove inode_add_to_list/__inode_add_to_list
    
    Split up inode_add_to_list/__inode_add_to_list.  Locking for the two
    lists will be split soon so these helpers really don't buy us much
    anymore.
    
    The __ prefixes for the sb list helpers will go away soon, but until
    inode_lock is gone we'll need them to distinguish between the locked
    and unlocked variants.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 876275fc0638..d43e8b6685a2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2171,7 +2171,6 @@ extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
 
 extern int inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
-extern void inode_add_to_lists(struct super_block *, struct inode *);
 extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);
@@ -2202,9 +2201,11 @@ extern int file_remove_suid(struct file *);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 extern void remove_inode_hash(struct inode *);
-static inline void insert_inode_hash(struct inode *inode) {
+static inline void insert_inode_hash(struct inode *inode)
+{
 	__insert_inode_hash(inode, inode->i_ino);
 }
+extern void inode_sb_list_add(struct inode *inode);
 
 #ifdef CONFIG_BLOCK
 extern void submit_bio(int, struct bio *);

commit 9e38d86ff2d8a8db99570e982230861046df32b5
Author: Nick Piggin <npiggin@suse.de>
Date:   Sat Oct 23 06:55:17 2010 -0400

    fs: Implement lazy LRU updates for inodes
    
    Convert the inode LRU to use lazy updates to reduce lock and
    cacheline traffic.  We avoid moving inodes around in the LRU list
    during iget/iput operations so these frequent operations don't need
    to access the LRUs. Instead, we defer the refcount checks to
    reclaim-time and use a per-inode state flag, I_REFERENCED, to tell
    reclaim that iget has touched the inode in the past. This means that
    only reclaim should be touching the LRU with any frequency, hence
    significantly reducing lock acquisitions and the amount contention
    on LRU updates.
    
    This also removes the inode_in_use list, which means we now only
    have one list for tracking the inode LRU status. This makes it much
    simpler to split out the LRU list operations under it's own lock.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a3937a8ee95e..876275fc0638 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1641,16 +1641,17 @@ struct super_operations {
  *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  */
-#define I_DIRTY_SYNC		1
-#define I_DIRTY_DATASYNC	2
-#define I_DIRTY_PAGES		4
+#define I_DIRTY_SYNC		(1 << 0)
+#define I_DIRTY_DATASYNC	(1 << 1)
+#define I_DIRTY_PAGES		(1 << 2)
 #define __I_NEW			3
 #define I_NEW			(1 << __I_NEW)
-#define I_WILL_FREE		16
-#define I_FREEING		32
-#define I_CLEAR			64
+#define I_WILL_FREE		(1 << 4)
+#define I_FREEING		(1 << 5)
+#define I_CLEAR			(1 << 6)
 #define __I_SYNC		7
 #define I_SYNC			(1 << __I_SYNC)
+#define I_REFERENCED		(1 << 8)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 

commit cffbc8aa334f55c9ed42d25202eb3ebf3a97c195
Author: Dave Chinner <dchinner@redhat.com>
Date:   Sat Oct 23 05:03:02 2010 -0400

    fs: Convert nr_inodes and nr_unused to per-cpu counters
    
    The number of inodes allocated does not need to be tied to the
    addition or removal of an inode to/from a list. If we are not tied
    to a list lock, we could update the counters when inodes are
    initialised or destroyed, but to do that we need to convert the
    counters to be per-cpu (i.e. independent of a lock). This means that
    we have the freedom to change the list/locking implementation
    without needing to care about the counters.
    
    Based on a patch originally from Eric Dumazet.
    
    [AV: cleaned up a bit, fixed build breakage on weird configs
    
    Signed-off-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 78043da85e1f..a3937a8ee95e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2486,7 +2486,8 @@ ssize_t simple_attr_write(struct file *file, const char __user *buf,
 struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
-
+int proc_nr_inodes(struct ctl_table *table, int write,
+		   void __user *buffer, size_t *lenp, loff_t *ppos);
 int __init get_filesystem_list(char *buf);
 
 #define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])

commit 1d3382cbf02986e4833849f528d451367ea0b4cb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 23 15:19:20 2010 -0400

    new helper: inode_unhashed()
    
    note: for race-free uses you inode_lock held
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c3f6daf749cc..78043da85e1f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -786,6 +786,11 @@ struct inode {
 	void			*i_private; /* fs or device private pointer */
 };
 
+static inline int inode_unhashed(struct inode *inode)
+{
+	return hlist_unhashed(&inode->i_hash);
+}
+
 /*
  * inode->i_mutex nesting subclasses for the lock validator:
  *

commit a8dade34e3df581bc36ca2afe6e27055e178801c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Oct 24 11:13:10 2010 -0400

    unexport invalidate_inodes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7fc126df1c42..c3f6daf749cc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2082,7 +2082,6 @@ extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *);
 extern int invalidate_partition(struct gendisk *, int);
 #endif
-extern int invalidate_inodes(struct super_block *);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
 

commit 4a3956c790290efeb647bbb0c3a90476bb57800e
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Fri Oct 1 14:20:22 2010 -0700

    vfs: introduce FMODE_UNSIGNED_OFFSET for allowing negative f_pos
    
    Now, rw_verify_area() checsk f_pos is negative or not.  And if negative,
    returns -EINVAL.
    
    But, some special files as /dev/(k)mem and /proc/<pid>/mem etc..  has
    negative offsets.  And we can't do any access via read/write to the
    file(device).
    
    So introduce FMODE_UNSIGNED_OFFSET to allow negative file offsets.
    
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0cd6821013a0..7fc126df1c42 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -92,6 +92,9 @@ struct inodes_stat_t {
 /* Expect random access pattern */
 #define FMODE_RANDOM		((__force fmode_t)0x1000)
 
+/* File is huge (eg. /dev/kmem): treat loff_t as unsigned */
+#define FMODE_UNSIGNED_OFFSET	((__force fmode_t)0x2000)
+
 /* File was opened by fanotify and shouldn't generate fanotify events */
 #define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
 

commit 7e360c38abe2c70eae3ba5a8a17f17671d8b77c5
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Oct 5 09:32:55 2010 +0200

    fs: allow for more than 2^31 files
    
    Andrew,
    
    Could you please review this patch, you probably are the right guy to
    take it, because it crosses fs and net trees.
    
    Note : /proc/sys/fs/file-nr is a read-only file, so this patch doesnt
    depend on previous patch (sysctl: fix min/max handling in
    __do_proc_doulongvec_minmax())
    
    Thanks !
    
    [PATCH V4] fs: allow for more than 2^31 files
    
    Robin Holt tried to boot a 16TB system and found af_unix was overflowing
    a 32bit value :
    
    <quote>
    
    We were seeing a failure which prevented boot.  The kernel was incapable
    of creating either a named pipe or unix domain socket.  This comes down
    to a common kernel function called unix_create1() which does:
    
            atomic_inc(&unix_nr_socks);
            if (atomic_read(&unix_nr_socks) > 2 * get_max_files())
                    goto out;
    
    The function get_max_files() is a simple return of files_stat.max_files.
    files_stat.max_files is a signed integer and is computed in
    fs/file_table.c's files_init().
    
            n = (mempages * (PAGE_SIZE / 1024)) / 10;
            files_stat.max_files = n;
    
    In our case, mempages (total_ram_pages) is approx 3,758,096,384
    (0xe0000000).  That leaves max_files at approximately 1,503,238,553.
    This causes 2 * get_max_files() to integer overflow.
    
    </quote>
    
    Fix is to let /proc/sys/fs/file-nr & /proc/sys/fs/file-max use long
    integers, and change af_unix to use an atomic_long_t instead of
    atomic_t.
    
    get_max_files() is changed to return an unsigned long.
    get_nr_files() is changed to return a long.
    
    unix_nr_socks is changed from atomic_t to atomic_long_t, while not
    strictly needed to address Robin problem.
    
    Before patch (on a 64bit kernel) :
    # echo 2147483648 >/proc/sys/fs/file-max
    # cat /proc/sys/fs/file-max
    -18446744071562067968
    
    After patch:
    # echo 2147483648 >/proc/sys/fs/file-max
    # cat /proc/sys/fs/file-max
    2147483648
    # cat /proc/sys/fs/file-nr
    704     0       2147483648
    
    Reported-by: Robin Holt <holt@sgi.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: David Miller <davem@davemloft.net>
    Reviewed-by: Robin Holt <holt@sgi.com>
    Tested-by: Robin Holt <holt@sgi.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0a5d83633884..0cd6821013a0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -34,9 +34,9 @@
 
 /* And dynamically-tunable limits and defaults: */
 struct files_stat_struct {
-	int nr_files;		/* read only */
-	int nr_free_files;	/* read only */
-	int max_files;		/* tunable */
+	unsigned long nr_files;		/* read only */
+	unsigned long nr_free_files;	/* read only */
+	unsigned long max_files;		/* tunable */
 };
 
 struct inodes_stat_t {
@@ -400,7 +400,7 @@ extern void __init inode_init_early(void);
 extern void __init files_init(unsigned long);
 
 extern struct files_stat_struct files_stat;
-extern int get_max_files(void);
+extern unsigned long get_max_files(void);
 extern int sysctl_nr_open;
 extern struct inodes_stat_t inodes_stat;
 extern int leases_enable, lease_break_time;

commit 56b0dacfa2b8416815a2f2a5f4f51e46be4cf14c
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 6 10:48:55 2010 +0200

    fs: mark destroy_inode static
    
    Hugetlbfs used to need it, but after the destroy_inode and evict_inode
    changes it's not required anymore.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0b03f490572f..0a5d83633884 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2187,7 +2187,6 @@ extern void unlock_new_inode(struct inode *);
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
 extern void end_writeback(struct inode *);
-extern void destroy_inode(struct inode *);
 extern void __destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
 extern int should_remove_suid(struct dentry *);

commit c37650161a53c01ddd88587675f9a4adc909a73e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 6 10:48:20 2010 +0200

    fs: add sync_inode_metadata
    
    Add a new helper to write out the inode using the writeback code,
    that is including the correct dirty bit and list manipulation.  A few
    of filesystems already opencode this, and a lot of others should be
    using it instead of using write_inode_now which also writes out the
    data.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f34ff6e5558..0b03f490572f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1734,6 +1734,7 @@ static inline void file_accessed(struct file *file)
 }
 
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
+int sync_inode_metadata(struct inode *inode, int wait);
 
 struct file_system_type {
 	const char *name;

commit a2887097f25cd38cadfc11d10769e2b349fb5eca
Merge: 8abfc6e7a45e 005a1d15f5a6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 17:07:18 2010 -0700

    Merge branch 'for-2.6.37/barrier' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.37/barrier' of git://git.kernel.dk/linux-2.6-block: (46 commits)
      xen-blkfront: disable barrier/flush write support
      Added blk-lib.c and blk-barrier.c was renamed to blk-flush.c
      block: remove BLKDEV_IFL_WAIT
      aic7xxx_old: removed unused 'req' variable
      block: remove the BH_Eopnotsupp flag
      block: remove the BLKDEV_IFL_BARRIER flag
      block: remove the WRITE_BARRIER flag
      swap: do not send discards as barriers
      fat: do not send discards as barriers
      ext4: do not send discards as barriers
      jbd2: replace barriers with explicit flush / FUA usage
      jbd2: Modify ASYNC_COMMIT code to not rely on queue draining on barrier
      jbd: replace barriers with explicit flush / FUA usage
      nilfs2: replace barriers with explicit flush / FUA usage
      reiserfs: replace barriers with explicit flush / FUA usage
      gfs2: replace barriers with explicit flush / FUA usage
      btrfs: replace barriers with explicit flush / FUA usage
      xfs: replace barriers with explicit flush / FUA usage
      block: pass gfp_mask and flags to sb_issue_discard
      dm: convey that all flushes are processed as empty
      ...

commit 092e0e7e520a1fca03e13c9f2d157432a8657ff2
Merge: 79f14b7c56d3 776c163b1b93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:52:56 2010 -0700

    Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      vfs: make no_llseek the default
      vfs: don't use BKL in default_llseek
      llseek: automatically add .llseek fop
      libfs: use generic_file_llseek for simple_attr
      mac80211: disallow seeks in minstrel debug code
      lirc: make chardev nonseekable
      viotape: use noop_llseek
      raw: use explicit llseek file operations
      ibmasmfs: use generic_file_llseek
      spufs: use llseek in all file operations
      arm/omap: use generic_file_llseek in iommu_debug
      lkdtm: use generic_file_llseek in debugfs
      net/wireless: use generic_file_llseek in debugfs
      drm: use noop_llseek

commit 79f14b7c56d3b3ba58f8b43d1f70b9b71477a800
Merge: c37927d4359e 6d7bccc2215c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:52:01 2010 -0700

    Merge branch 'vfs' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'vfs' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl: (30 commits)
      BKL: remove BKL from freevxfs
      BKL: remove BKL from qnx4
      autofs4: Only declare function when CONFIG_COMPAT is defined
      autofs: Only declare function when CONFIG_COMPAT is defined
      ncpfs: Lock socket in ncpfs while setting its callbacks
      fs/locks.c: prepare for BKL removal
      BKL: Remove BKL from ncpfs
      BKL: Remove BKL from OCFS2
      BKL: Remove BKL from squashfs
      BKL: Remove BKL from jffs2
      BKL: Remove BKL from ecryptfs
      BKL: Remove BKL from afs
      BKL: Remove BKL from USB gadgetfs
      BKL: Remove BKL from autofs4
      BKL: Remove BKL from isofs
      BKL: Remove BKL from fat
      BKL: Remove BKL from ext2 filesystem
      BKL: Remove BKL from do_new_mount()
      BKL: Remove BKL from cgroup
      BKL: Remove BKL from NTFS
      ...

commit f3270b16e00f0614fa418dcc50883da5949375b4
Merge: 3044100e58c8 2decd65a2630
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 21 19:01:34 2010 -0700

    Merge branch 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2
    
    * 'upstream-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jlbec/ocfs2: (48 commits)
      ocfs2: Avoid to evaluate xattr block flags again.
      ocfs2/cluster: Release debugfs file elapsed_time_in_ms
      ocfs2: Add a mount option "coherency=*" to handle cluster coherency for O_DIRECT writes.
      Initialize max_slots early
      When I tried to compile I got the following warning: fs/ocfs2/slot_map.c: In function ocfs2_init_slot_info: fs/ocfs2/slot_map.c:360: warning: bytes may be used uninitialized in this function fs/ocfs2/slot_map.c:360: note: bytes was declared here Compiler: gcc version 4.4.3 (GCC) on Mandriva I'm not sure why this warning occurs, I think compiler don't know that variable "bytes" is initialized when it is sent by reference to ocfs2_slot_map_physical_size and it throws that ugly warning. However, a simple initialization of "bytes" variable with 0 will fix it.
      ocfs2: validate bg_free_bits_count after update
      ocfs2/cluster: Bump up dlm protocol to version 1.1
      ocfs2/cluster: Show per region heartbeat elapsed time
      ocfs2/cluster: Add mlogs for heartbeat up/down events
      ocfs2/cluster: Create debugfs dir/files for each region
      ocfs2/cluster: Create debugfs files for live, quorum and failed region bitmaps
      ocfs2/cluster: Maintain bitmap of failed regions
      ocfs2/cluster: Maintain bitmap of quorum regions
      ocfs2/cluster: Track bitmap of live heartbeat regions
      ocfs2/cluster: Track number of global heartbeat regions
      ocfs2/cluster: Maintain live node bitmap per heartbeat region
      ocfs2/cluster: Reorganize o2hb debugfs init
      ocfs2/cluster: Check slots for unconfigured live nodes
      ocfs2/cluster: Print messages when adding/removing nodes
      ocfs2/cluster: Print messages when adding/removing heartbeat regions
      ...

commit fa251f89903d73989e2f63e13d0eaed1e07ce0da
Merge: dd3932eddf42 cd07202cc826
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Tue Oct 19 09:13:04 2010 +0200

    Merge branch 'v2.6.36-rc8' into for-2.6.37/barrier
    
    Conflicts:
            block/blk-core.c
            drivers/block/loop.c
            mm/swapfile.c
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

commit fc3718918f13ad72827d62d36ea0f5fb55090644
Merge: 7bdb0d18bfd3 d4396eafe402
Author: Joel Becker <joel.becker@oracle.com>
Date:   Fri Oct 15 13:03:09 2010 -0700

    Merge branch 'globalheartbeat-2' of git://oss.oracle.com/git/smushran/linux-2.6 into ocfs2-merge-window
    
    Conflicts:
            fs/ocfs2/ocfs2.h

commit 556ef63255f1a6f82910a637c4164dbf7d3d1af2
Merge: d4f8f217b8a5 cb655d0f3d57
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Oct 7 09:43:38 2010 +0200

    Merge commit 'v2.6.36-rc7' into core/rcu
    
    Merge reason: Update from -rc3 to -rc7.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit b89f432133851a01c0d28822f11cbdcc15781a75
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Sep 18 15:09:31 2010 +0200

    fs/locks.c: prepare for BKL removal
    
    This prepares the removal of the big kernel lock from the
    file locking code. We still use the BKL as long as fs/lockd
    uses it and ceph might sleep, but we can flip the definition
    to a private spinlock as soon as that's done.
    All users outside of fs/lockd get converted to use
    lock_flocks() instead of lock_kernel() where appropriate.
    
    Based on an earlier patch to use a spinlock from Matthew
    Wilcox, who has attempted this a few times before, the
    earliest patch from over 10 years ago turned it into
    a semaphore, which ended up being slower than the BKL
    and was subsequently reverted.
    
    Someone should do some serious performance testing when
    this becomes a spinlock, since this has caused problems
    before. Using a spinlock should be at least as good
    as the BKL in theory, but who knows...
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: John Kacur <jkacur@redhat.com>
    Cc: Sage Weil <sage@newdream.net>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-fsdevel@vger.kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 63d069bd80b7..180325268237 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1093,10 +1093,6 @@ struct file_lock {
 
 #include <linux/fcntl.h>
 
-/* temporary stubs for BKL removal */
-#define lock_flocks() lock_kernel()
-#define unlock_flocks() unlock_kernel()
-
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
 #ifdef CONFIG_FILE_LOCKING
@@ -1135,6 +1131,8 @@ extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
+extern void lock_flocks(void);
+extern void unlock_flocks(void);
 #else /* !CONFIG_FILE_LOCKING */
 static inline int fcntl_getlk(struct file *file, struct flock __user *user)
 {
@@ -1277,6 +1275,14 @@ static inline int lock_may_write(struct inode *inode, loff_t start,
 	return 1;
 }
 
+static inline void lock_flocks(void)
+{
+}
+
+static inline void unlock_flocks(void)
+{
+}
+
 #endif /* !CONFIG_FILE_LOCKING */
 
 

commit 8b15575cae7a93a784c3005c42b069edd9ba64dd
Author: Sage Weil <sage@newdream.net>
Date:   Tue Sep 21 14:35:37 2010 -0700

    fs: {lock,unlock}_flocks() stubs to prepare for BKL removal
    
    The lock structs are currently protected by the BKL, but are accessed by
    code in fs/locks.c and misc file system and DLM code.  These stubs will
    allow all users to switch to the new interface before the implementation
    is changed to a spinlock.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Sage Weil <sage@newdream.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 76041b614758..63d069bd80b7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1093,6 +1093,10 @@ struct file_lock {
 
 #include <linux/fcntl.h>
 
+/* temporary stubs for BKL removal */
+#define lock_flocks() lock_kernel()
+#define unlock_flocks() unlock_kernel()
+
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
 #ifdef CONFIG_FILE_LOCKING

commit 1ec5584e3edf9c4bf2c88c846534d19cf986ba11
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 21:50:52 2010 +0200

    libfs: use generic_file_llseek for simple_attr
    
    Simple attribute files need to be seekable to
    allow resetting the file for another read.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 76041b614758..c8effc81f0c9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2450,6 +2450,7 @@ static const struct file_operations __fops = {				\
 	.release = simple_attr_release,					\
 	.read	 = simple_attr_read,					\
 	.write	 = simple_attr_write,					\
+	.llseek	 = generic_file_llseek,					\
 };
 
 static inline void __attribute__((format(printf, 1, 2)))

commit 30ca22c70e3ef0a96ff84de69cd7e8561b416cb2
Author: Patrick J. LoPresti <lopresti@gmail.com>
Date:   Thu Jul 22 15:03:41 2010 -0700

    ext3/ext4: Factor out disk addressability check
    
    As part of adding support for OCFS2 to mount huge volumes, we need to
    check that the sector_t and page cache of the system are capable of
    addressing the entire volume.
    
    An identical check already appears in ext3 and ext4.  This patch moves
    the addressability check into its own function in fs/libfs.c and
    modifies ext3 and ext4 to invoke it.
    
    [Edited to -EINVAL instead of BUG_ON() for bad blocksize_bits -- Joel]
    
    Signed-off-by: Patrick LoPresti <lopresti@gmail.com>
    Cc: linux-ext4@vger.kernel.org
    Acked-by: Andreas Dilger <adilger@dilger.ca>
    Signed-off-by: Joel Becker <joel.becker@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 76041b614758..1a759f40ab9e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2374,6 +2374,8 @@ extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
 
 extern int generic_file_fsync(struct file *, int);
 
+extern int generic_check_addressable(unsigned, u64);
+
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,
 				struct page *, struct page *);

commit 8c5553678237b7121355108e03c36086037d8975
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Aug 18 05:29:22 2010 -0400

    block: remove the BLKDEV_IFL_BARRIER flag
    
    Remove support for barriers on discards, which is unused now.  Also
    remove the DISCARD_NOBARRIER I/O type in favour of just setting the
    rw flags up locally in blkdev_issue_discard.
    
    tj: Also remove DISCARD_SECURE and use REQ_SECURE directly.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Mike Snitzer <snitzer@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d6add69bc170..6b0f6e9993a3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -163,14 +163,6 @@ struct inodes_stat_t {
 #define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
 				 REQ_FLUSH | REQ_FUA)
 
-/*
- * These aren't really reads or writes, they pass down information about
- * parts of device that are now unused by the file system.
- */
-#define DISCARD_NOBARRIER	(WRITE | REQ_DISCARD)
-#define DISCARD_BARRIER		(WRITE | REQ_DISCARD | REQ_HARDBARRIER)
-#define DISCARD_SECURE		(DISCARD_NOBARRIER | REQ_SECURE)
-
 #define SEL_IN		1
 #define SEL_OUT		2
 #define SEL_EX		4

commit 31725e65c7214b52b607eba705fc4f306be4d5a5
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Aug 18 05:29:21 2010 -0400

    block: remove the WRITE_BARRIER flag
    
    It's unused now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 352c48627381..d6add69bc170 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -135,7 +135,6 @@ struct inodes_stat_t {
  *			immediately after submission. The write equivalent
  *			of READ_SYNC.
  * WRITE_ODIRECT_PLUG	Special case write for O_DIRECT only.
- * WRITE_BARRIER	DEPRECATED. Always fails. Use FLUSH/FUA instead.
  * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
  * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
  *			non-volatile media on completion.
@@ -157,8 +156,6 @@ struct inodes_stat_t {
 #define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG)
 #define WRITE_ODIRECT_PLUG	(WRITE | REQ_SYNC)
 #define WRITE_META		(WRITE | REQ_META)
-#define WRITE_BARRIER		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
-				 REQ_HARDBARRIER)
 #define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
 				 REQ_FLUSH)
 #define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \

commit 4fed947cb311e5aa51781d316cefca836352f6ce
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Sep 3 11:56:17 2010 +0200

    block: implement REQ_FLUSH/FUA based interface for FLUSH/FUA requests
    
    Now that the backend conversion is complete, export sequenced
    FLUSH/FUA capability through REQ_FLUSH/FUA flags.  REQ_FLUSH means the
    device cache should be flushed before executing the request.  REQ_FUA
    means that the data in the request should be on non-volatile media on
    completion.
    
    Block layer will choose the correct way of implementing the semantics
    and execute it.  The request may be passed to the device directly if
    the device can handle it; otherwise, it will be sequenced using one or
    more proxy requests.  Devices will never see REQ_FLUSH and/or FUA
    which it doesn't support.
    
    Also, unlike the original REQ_HARDBARRIER, REQ_FLUSH/FUA requests are
    never failed with -EOPNOTSUPP.  If the underlying device doesn't
    support FLUSH/FUA, the block layer simply make those noop.  IOW, it no
    longer distinguishes between writeback cache which doesn't support
    cache flush and writethrough/no cache.  Devices which have WB cache
    w/o flush are very difficult to come by these days and there's nothing
    much we can do anyway, so it doesn't make sense to require everyone to
    implement -EOPNOTSUPP handling.  This will simplify filesystems and
    block drivers as they can drop -EOPNOTSUPP retry logic for barriers.
    
    * QUEUE_ORDERED_* are removed and QUEUE_FSEQ_* are moved into
      blk-flush.c.
    
    * REQ_FLUSH w/o data can also be directly passed to drivers without
      sequencing but some drivers assume that zero length requests don't
      have rq->bio which isn't true for these requests requiring the use
      of proxy requests.
    
    * REQ_COMMON_MASK now includes REQ_FLUSH | REQ_FUA so that they are
      copied from bio to request.
    
    * WRITE_BARRIER is marked deprecated and WRITE_FLUSH, WRITE_FUA and
      WRITE_FLUSH_FUA are added.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 76041b614758..352c48627381 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -135,12 +135,13 @@ struct inodes_stat_t {
  *			immediately after submission. The write equivalent
  *			of READ_SYNC.
  * WRITE_ODIRECT_PLUG	Special case write for O_DIRECT only.
- * WRITE_BARRIER	Like WRITE_SYNC, but tells the block layer that all
- *			previously submitted writes must be safely on storage
- *			before this one is started. Also guarantees that when
- *			this write is complete, it itself is also safely on
- *			storage. Prevents reordering of writes on both sides
- *			of this IO.
+ * WRITE_BARRIER	DEPRECATED. Always fails. Use FLUSH/FUA instead.
+ * WRITE_FLUSH		Like WRITE_SYNC but with preceding cache flush.
+ * WRITE_FUA		Like WRITE_SYNC but data is guaranteed to be on
+ *			non-volatile media on completion.
+ * WRITE_FLUSH_FUA	Combination of WRITE_FLUSH and FUA. The IO is preceded
+ *			by a cache flush and data is guaranteed to be on
+ *			non-volatile media on completion.
  *
  */
 #define RW_MASK			REQ_WRITE
@@ -158,6 +159,12 @@ struct inodes_stat_t {
 #define WRITE_META		(WRITE | REQ_META)
 #define WRITE_BARRIER		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
 				 REQ_HARDBARRIER)
+#define WRITE_FLUSH		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
+				 REQ_FLUSH)
+#define WRITE_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
+				 REQ_FUA)
+#define WRITE_FLUSH_FUA		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
+				 REQ_FLUSH | REQ_FUA)
 
 /*
  * These aren't really reads or writes, they pass down information about

commit 4d2deb40b20c2608486598364e63e37b09a9ac2f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Feb 24 20:01:56 2010 +0100

    kernel: __rcu annotations
    
    This adds annotations for RCU operations in core kernel components
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 76041b614758..aa3dc8d20436 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1380,7 +1380,7 @@ struct super_block {
 	 * Saved mount options for lazy filesystems using
 	 * generic_show_options()
 	 */
-	char *s_options;
+	char __rcu *s_options;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 6416ccb7899960868f5016751fb81bf25213d24f
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Wed Aug 18 04:37:38 2010 +1000

    fs: scale files_lock
    
    fs: scale files_lock
    
    Improve scalability of files_lock by adding per-cpu, per-sb files lists,
    protected with an lglock. The lglock provides fast access to the per-cpu lists
    to add and remove files. It also provides a snapshot of all the per-cpu lists
    (although this is very slow).
    
    One difficulty with this approach is that a file can be removed from the list
    by another CPU. We must track which per-cpu list the file is on with a new
    variale in the file struct (packed into a hole on 64-bit archs). Scalability
    could suffer if files are frequently removed from different cpu's list.
    
    However loads with frequent removal of files imply short interval between
    adding and removing the files, and the scheduler attempts to avoid moving
    processes too far away. Also, even in the case of cross-CPU removal, the
    hardware has much more opportunity to parallelise cacheline transfers with N
    cachelines than with 1.
    
    A worst-case test of 1 CPU allocating files subsequently being freed by N CPUs
    degenerates to contending on a single lock, which is no worse than before. When
    more than one CPU are allocating files, even if they are always freed by
    different CPUs, there will be more parallelism than the single-lock case.
    
    Testing results:
    
    On a 2 socket, 8 core opteron, I measure the number of times the lock is taken
    to remove the file, the number of times it is removed by the same CPU that
    added it, and the number of times it is removed by the same node that added it.
    
    Booting:    locks=  25049 cpu-hits=  23174 (92.5%) node-hits=  23945 (95.6%)
    kbuild -j16 locks=2281913 cpu-hits=2208126 (96.8%) node-hits=2252674 (98.7%)
    dbench 64   locks=4306582 cpu-hits=4287247 (99.6%) node-hits=4299527 (99.8%)
    
    So a file is removed from the same CPU it was added by over 90% of the time.
    It remains within the same node 95% of the time.
    
    Tim Chen ran some numbers for a 64 thread Nehalem system performing a compile.
    
                    throughput
    2.6.34-rc2      24.5
    +patch          24.9
    
                    us      sys     idle    IO wait (in %)
    2.6.34-rc2      51.25   28.25   17.25   3.25
    +patch          53.75   18.5    19      8.75
    
    So significantly less CPU time spent in kernel code, higher idle time and
    slightly higher throughput.
    
    Single threaded performance difference was within the noise of microbenchmarks.
    That is not to say penalty does not exist, the code is larger and more memory
    accesses required so it will be slightly slower.
    
    Cc: linux-kernel@vger.kernel.org
    Cc: Tim Chen <tim.c.chen@linux.intel.com>
    Cc: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5e65add0f163..76041b614758 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -920,6 +920,9 @@ struct file {
 #define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
 	spinlock_t		f_lock;  /* f_ep_links, f_flags, no IRQ */
+#ifdef CONFIG_SMP
+	int			f_sb_list_cpu;
+#endif
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
@@ -1334,7 +1337,11 @@ struct super_block {
 
 	struct list_head	s_inodes;	/* all inodes */
 	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
+#ifdef CONFIG_SMP
+	struct list_head __percpu *s_files;
+#else
 	struct list_head	s_files;
+#endif
 	/* s_dentry_lru and s_nr_dentry_unused are protected by dcache_lock */
 	struct list_head	s_dentry_lru;	/* unused dentry lru */
 	int			s_nr_dentry_unused;	/* # of dentry on lru */

commit d996b62a8df1d935b01319bf8defb95b5709f7b8
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Wed Aug 18 04:37:36 2010 +1000

    tty: fix fu_list abuse
    
    tty: fix fu_list abuse
    
    tty code abuses fu_list, which causes a bug in remount,ro handling.
    
    If a tty device node is opened on a filesystem, then the last link to the inode
    removed, the filesystem will be allowed to be remounted readonly. This is
    because fs_may_remount_ro does not find the 0 link tty inode on the file sb
    list (because the tty code incorrectly removed it to use for its own purpose).
    This can result in a filesystem with errors after it is marked "clean".
    
    Taking idea from Christoph's initial patch, allocate a tty private struct
    at file->private_data and put our required list fields in there, linking
    file and tty. This makes tty nodes behave the same way as other device nodes
    and avoid meddling with the vfs, and avoids this bug.
    
    The error handling is not trivial in the tty code, so for this bugfix, I take
    the simple approach of using __GFP_NOFAIL and don't worry about memory errors.
    This is not a problem because our allocator doesn't fail small allocs as a rule
    anyway. So proper error handling is left as an exercise for tty hackers.
    
    [ Arguably filesystem's device inode would ideally be divorced from the
    driver's pseudo inode when it is opened, but in practice it's not clear whether
    that will ever be worth implementing. ]
    
    Cc: linux-kernel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5a9a9e5a3705..5e65add0f163 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2185,8 +2185,6 @@ static inline void insert_inode_hash(struct inode *inode) {
 	__insert_inode_hash(inode, inode->i_ino);
 }
 
-extern void file_sb_list_add(struct file *f, struct super_block *sb);
-extern void file_sb_list_del(struct file *f);
 #ifdef CONFIG_BLOCK
 extern void submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);

commit ee2ffa0dfdd2db19705f2ba1c6a4c0bfe8122dd8
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Wed Aug 18 04:37:35 2010 +1000

    fs: cleanup files_lock locking
    
    fs: cleanup files_lock locking
    
    Lock tty_files with a new spinlock, tty_files_lock; provide helpers to
    manipulate the per-sb files list; unexport the files_lock spinlock.
    
    Cc: linux-kernel@vger.kernel.org
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Andi Kleen <ak@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 29f7c975304c..5a9a9e5a3705 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -944,9 +944,6 @@ struct file {
 	unsigned long f_mnt_write_state;
 #endif
 };
-extern spinlock_t files_lock;
-#define file_list_lock() spin_lock(&files_lock);
-#define file_list_unlock() spin_unlock(&files_lock);
 
 #define get_file(x)	atomic_long_inc(&(x)->f_count)
 #define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
@@ -2188,8 +2185,8 @@ static inline void insert_inode_hash(struct inode *inode) {
 	__insert_inode_hash(inode, inode->i_ino);
 }
 
-extern void file_move(struct file *f, struct list_head *list);
-extern void file_kill(struct file *f);
+extern void file_sb_list_add(struct file *f, struct super_block *sb);
+extern void file_sb_list_del(struct file *f);
 #ifdef CONFIG_BLOCK
 extern void submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);

commit 9cb569d601e0b93e01c20a22872270ec663b75f6
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Aug 11 17:06:24 2010 +0200

    remove SWRITE* I/O types
    
    These flags aren't real I/O types, but tell ll_rw_block to always
    lock the buffer instead of giving up on a failed trylock.
    
    Instead add a new write_dirty_buffer helper that implements this semantic
    and use it from the existing SWRITE* callers.  Note that the ll_rw_block
    code had a bug where it didn't promote WRITE_SYNC_PLUG properly, which
    this patch fixes.
    
    In the ufs code clean up the helper that used to call ll_rw_block
    to mirror sync_dirty_buffer, which is the function it implements for
    compound buffers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9a96b4d83fc1..29f7c975304c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -125,9 +125,6 @@ struct inodes_stat_t {
  *			block layer could (in theory) choose to ignore this
  *			request if it runs into resource problems.
  * WRITE		A normal async write. Device will be plugged.
- * SWRITE		Like WRITE, but a special case for ll_rw_block() that
- *			tells it to lock the buffer first. Normally a buffer
- *			must be locked before doing IO.
  * WRITE_SYNC_PLUG	Synchronous write. Identical to WRITE, but passes down
  *			the hint that someone will be waiting on this IO
  *			shortly. The device must still be unplugged explicitly,
@@ -138,9 +135,6 @@ struct inodes_stat_t {
  *			immediately after submission. The write equivalent
  *			of READ_SYNC.
  * WRITE_ODIRECT_PLUG	Special case write for O_DIRECT only.
- * SWRITE_SYNC
- * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
- *			See SWRITE.
  * WRITE_BARRIER	Like WRITE_SYNC, but tells the block layer that all
  *			previously submitted writes must be safely on storage
  *			before this one is started. Also guarantees that when
@@ -155,7 +149,6 @@ struct inodes_stat_t {
 #define READ			0
 #define WRITE			RW_MASK
 #define READA			RWA_MASK
-#define SWRITE			(WRITE | READA)
 
 #define READ_SYNC		(READ | REQ_SYNC | REQ_UNPLUG)
 #define READ_META		(READ | REQ_META)
@@ -165,8 +158,6 @@ struct inodes_stat_t {
 #define WRITE_META		(WRITE | REQ_META)
 #define WRITE_BARRIER		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
 				 REQ_HARDBARRIER)
-#define SWRITE_SYNC_PLUG	(SWRITE | REQ_SYNC | REQ_NOIDLE)
-#define SWRITE_SYNC		(SWRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG)
 
 /*
  * These aren't really reads or writes, they pass down information about

commit 10041d2d14688e207d0d829095147aa82c1f211b
Merge: 4914c7f88184 b19dd42faf41
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 13 17:52:35 2010 -0700

    Merge branch 'bkl/ioctl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing
    
    * 'bkl/ioctl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing:
      bkl: Remove locked .ioctl file operation
      v4l: Remove reference to bkl ioctl in compat ioctl handling
      logfs: kill BKL

commit c7887325230aec47d47a32562a6e26014a0fafca
Author: David Howells <dhowells@redhat.com>
Date:   Wed Aug 11 11:26:22 2010 +0100

    Mark arguments to certain syscalls as being const
    
    Mark arguments to certain system calls as being const where they should be but
    aren't.  The list includes:
    
     (*) The filename arguments of various stat syscalls, execve(), various utimes
         syscalls and some mount syscalls.
    
     (*) The filename arguments of some syscall helpers relating to the above.
    
     (*) The buffer argument of various write syscalls.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a0625e26a39..5f0ca2fbb2a0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2320,10 +2320,10 @@ void inode_set_bytes(struct inode *inode, loff_t bytes);
 
 extern int vfs_readdir(struct file *, filldir_t, void *);
 
-extern int vfs_stat(char __user *, struct kstat *);
-extern int vfs_lstat(char __user *, struct kstat *);
+extern int vfs_stat(const char __user *, struct kstat *);
+extern int vfs_lstat(const char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
-extern int vfs_fstatat(int , char __user *, struct kstat *, int);
+extern int vfs_fstatat(int , const char __user *, struct kstat *, int);
 
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);

commit b19dd42faf413b4705d4adb38521e82d73fa4249
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Jul 4 00:15:10 2010 +0200

    bkl: Remove locked .ioctl file operation
    
    The last user is gone, so we can safely remove this
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: John Kacur <jkacur@redhat.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a0625e26a39..3c786fdaeab6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1483,8 +1483,8 @@ struct block_device_operations;
 
 /*
  * NOTE:
- * read, write, poll, fsync, readv, writev, unlocked_ioctl and compat_ioctl
- * can be called without the big kernel lock held in all filesystems.
+ * all file operations except setlease can be called without
+ * the big kernel lock held in all filesystems.
  */
 struct file_operations {
 	struct module *owner;
@@ -1495,7 +1495,6 @@ struct file_operations {
 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	int (*readdir) (struct file *, void *, filldir_t);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
-	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);

commit 8d57a98ccd0b4489003473979da8f5a1363ba7a3
Author: Adrian Hunter <adrian.hunter@nokia.com>
Date:   Wed Aug 11 14:17:49 2010 -0700

    block: add secure discard
    
    Secure discard is the same as discard except that all copies of the
    discarded sectors (perhaps created by garbage collection) must also be
    erased.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@nokia.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Cc: Kyungmin Park <kmpark@infradead.org>
    Cc: Madhusudhan Chikkature <madhu.cr@ti.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Ben Gardiner <bengardiner@nanometrics.ca>
    Cc: <linux-mmc@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 267d02630517..7a0625e26a39 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -174,6 +174,7 @@ struct inodes_stat_t {
  */
 #define DISCARD_NOBARRIER	(WRITE | REQ_DISCARD)
 #define DISCARD_BARRIER		(WRITE | REQ_DISCARD | REQ_HARDBARRIER)
+#define DISCARD_SECURE		(DISCARD_NOBARRIER | REQ_SECURE)
 
 #define SEL_IN		1
 #define SEL_OUT		2
@@ -317,6 +318,7 @@ struct inodes_stat_t {
 #define BLKALIGNOFF _IO(0x12,122)
 #define BLKPBSZGET _IO(0x12,123)
 #define BLKDISCARDZEROES _IO(0x12,124)
+#define BLKSECDISCARD _IO(0x12,125)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit 13bcbc008790b05413c9a16763b423c206528c0a
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Aug 10 18:01:09 2010 -0700

    include/linux/fs.h: complete hexification of FMODE_* constants
    
    One straggler which was missed due to merge ordering issues.
    
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Eric Paris <eparis@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1542e0e52b2e..267d02630517 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -93,7 +93,7 @@ struct inodes_stat_t {
 #define FMODE_RANDOM		((__force fmode_t)0x1000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
-#define FMODE_NONOTIFY		((__force fmode_t)16777216) /* 0x1000000 */
+#define FMODE_NONOTIFY		((__force fmode_t)0x1000000)
 
 /*
  * The below are the various read and write types that we support. Some of

commit 2f9e825d3e0e2b407ae8f082de5c00afcf7378fb
Merge: 7ae0dea900b0 de75d60d5ea2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 15:22:42 2010 -0700

    Merge branch 'for-2.6.36' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.36' of git://git.kernel.dk/linux-2.6-block: (149 commits)
      block: make sure that REQ_* types are seen even with CONFIG_BLOCK=n
      xen-blkfront: fix missing out label
      blkdev: fix blkdev_issue_zeroout return value
      block: update request stacking methods to support discards
      block: fix missing export of blk_types.h
      writeback: fix bad _bh spinlock nesting
      drbd: revert "delay probes", feature is being re-implemented differently
      drbd: Initialize all members of sync_conf to their defaults [Bugz 315]
      drbd: Disable delay probes for the upcomming release
      writeback: cleanup bdi_register
      writeback: add new tracepoints
      writeback: remove unnecessary init_timer call
      writeback: optimize periodic bdi thread wakeups
      writeback: prevent unnecessary bdi threads wakeups
      writeback: move bdi threads exiting logic to the forker thread
      writeback: restructure bdi forker loop a little
      writeback: move last_active to bdi
      writeback: do not remove bdi from bdi_list
      writeback: simplify bdi code a little
      writeback: do not lose wake-ups in bdi threads
      ...
    
    Fixed up pretty trivial conflicts in drivers/block/virtio_blk.c and
    drivers/scsi/scsi_error.c as per Jens.

commit 8c8946f509a494769a8c602b5ed189df01917d39
Merge: 5f248c9c251c 1968f5eed54c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 11:39:13 2010 -0700

    Merge branch 'for-linus' of git://git.infradead.org/users/eparis/notify
    
    * 'for-linus' of git://git.infradead.org/users/eparis/notify: (132 commits)
      fanotify: use both marks when possible
      fsnotify: pass both the vfsmount mark and inode mark
      fsnotify: walk the inode and vfsmount lists simultaneously
      fsnotify: rework ignored mark flushing
      fsnotify: remove global fsnotify groups lists
      fsnotify: remove group->mask
      fsnotify: remove the global masks
      fsnotify: cleanup should_send_event
      fanotify: use the mark in handler functions
      audit: use the mark in handler functions
      dnotify: use the mark in handler functions
      inotify: use the mark in handler functions
      fsnotify: send fsnotify_mark to groups in event handling functions
      fsnotify: Exchange list heads instead of moving elements
      fsnotify: srcu to protect read side of inode and vfsmount locks
      fsnotify: use an explicit flag to indicate fsnotify_destroy_mark has been called
      fsnotify: use _rcu functions for mark list traversal
      fsnotify: place marks on object in order of group memory address
      vfs/fsnotify: fsnotify_close can delay the final work in fput
      fsnotify: store struct file not struct path
      ...
    
    Fix up trivial delete/modify conflict in fs/notify/inotify/inotify.c.

commit 5f248c9c251c60af3403902b26e08de43964ea0b
Merge: f6cec0ae58c1 dca332528bc6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 11:26:52 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (96 commits)
      no need for list_for_each_entry_safe()/resetting with superblock list
      Fix sget() race with failing mount
      vfs: don't hold s_umount over close_bdev_exclusive() call
      sysv: do not mark superblock dirty on remount
      sysv: do not mark superblock dirty on mount
      btrfs: remove junk sb_dirt change
      BFS: clean up the superblock usage
      AFFS: wait for sb synchronization when needed
      AFFS: clean up dirty flag usage
      cifs: truncate fallout
      mbcache: fix shrinker function return value
      mbcache: Remove unused features
      add f_flags to struct statfs(64)
      pass a struct path to vfs_statfs
      update VFS documentation for method changes.
      All filesystems that need invalidate_inode_buffers() are doing that explicitly
      convert remaining ->clear_inode() to ->evict_inode()
      Make ->drop_inode() just return whether inode needs to be dropped
      fs/inode.c:clear_inode() is gone
      fs/inode.c:evict() doesn't care about delete vs. non-delete paths now
      ...
    
    Fix up trivial conflicts in fs/nilfs2/super.c

commit f446daaea9d4a420d16c606f755f3689dcb2d0ce
Author: Jan Kara <jack@suse.cz>
Date:   Mon Aug 9 17:19:12 2010 -0700

    mm: implement writeback livelock avoidance using page tagging
    
    We try to avoid livelocks of writeback when some steadily creates dirty
    pages in a mapping we are writing out.  For memory-cleaning writeback,
    using nr_to_write works reasonably well but we cannot really use it for
    data integrity writeback.  This patch tries to solve the problem.
    
    The idea is simple: Tag all pages that should be written back with a
    special tag (TOWRITE) in the radix tree.  This can be done rather quickly
    and thus livelocks should not happen in practice.  Then we start doing the
    hard work of locking pages and sending them to disk only for those pages
    that have TOWRITE tag set.
    
    Note: Adding new radix tree tag grows radix tree node from 288 to 296
    bytes for 32-bit archs and from 552 to 560 bytes for 64-bit archs.
    However, the number of slab/slub items per page remains the same (13 and 7
    respectively).
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: Chris Mason <chris.mason@oracle.com>
    Cc: Theodore Ts'o <tytso@mit.edu>
    Cc: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e5106e49bd2c..488efec09d14 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -687,6 +687,7 @@ struct block_device {
  */
 #define PAGECACHE_TAG_DIRTY	0
 #define PAGECACHE_TAG_WRITEBACK	1
+#define PAGECACHE_TAG_TOWRITE	2
 
 int mapping_tagged(struct address_space *mapping, int tag);
 

commit 7a4dec53897ecd3367efb1e12fe8a4edc47dc0e9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Aug 9 12:05:43 2010 -0400

    Fix sget() race with failing mount
    
    If sget() finds a matching superblock being set up, it'll
    grab an active reference to it and grab s_umount.  That's
    fine - we'll wait for completion of foofs_get_sb() that way.
    However, if said foofs_get_sb() fails we'll end up holding
    the halfway-created superblock.  deactivate_locked_super()
    called by foofs_get_sb() will just unlock the sucker since
    we are holding another active reference to it.
    
    What we need is a way to tell if superblock has been successfully
    set up.  Unfortunately, neither ->s_root nor the check for
    MS_ACTIVE quite fit.  Cheap and easy way, suitable for backport:
    new flag set by the (only) caller of ->get_sb().  If that flag
    isn't present by the time sget() grabbed s_umount on preexisting
    superblock it has found, it's seeing a stillborn and should
    just bury it with deactivate_locked_super() (and repeat the search).
    
    Longer term we want to set that flag in ->get_sb() instances (and
    check for it to distinguish between "sget() found us a live sb"
    and "sget() has allocated an sb, we need to set it up" in there,
    instead of checking ->s_root as we do now).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: stable@kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9bedf4219f83..58e4b035e282 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -209,6 +209,7 @@ struct inodes_stat_t {
 #define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
 #define MS_I_VERSION	(1<<23) /* Update inode I_version field */
 #define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
+#define MS_BORN		(1<<29)
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 

commit ebabe9a9001af0af56c0c2780ca1576246e7a74b
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jul 7 18:53:11 2010 +0200

    pass a struct path to vfs_statfs
    
    We'll need the path to implement the flags field for statvfs support.
    We do have it available in all callers except:
    
     - ecryptfs_statfs.  This one doesn't actually need vfs_statfs but just
       needs to do a caller to the lower filesystem statfs method.
     - sys_ustat.  Add a non-exported statfs_by_dentry helper for it which
       doesn't won't be able to fill out the flags field later on.
    
    In addition rename the helpers for statfs vs fstatfs to do_*statfs instead
    of the misleading vfs prefix.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index dec9ac598859..9bedf4219f83 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1813,7 +1813,8 @@ extern struct vfsmount *collect_mounts(struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 			  struct vfsmount *);
-extern int vfs_statfs(struct dentry *, struct kstatfs *);
+extern int vfs_statfs(struct path *, struct kstatfs *);
+extern int statfs_by_dentry(struct dentry *, struct kstatfs *);
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 

commit b57922d97fd6f79b6dbe6db0c4fd30d219fa08c1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 14:34:48 2010 -0400

    convert remaining ->clear_inode() to ->evict_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8553adbda57b..dec9ac598859 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1571,7 +1571,6 @@ struct super_operations {
 	int (*unfreeze_fs) (struct super_block *);
 	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
-	void (*clear_inode) (struct inode *);
 	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
@@ -1616,7 +1615,7 @@ struct super_operations {
  * I_FREEING		Set when inode is about to be freed but still has dirty
  *			pages or buffers attached or the inode itself is still
  *			dirty.
- * I_CLEAR		Added by clear_inode().  In this state the inode is clean
+ * I_CLEAR		Added by end_writeback().  In this state the inode is clean
  *			and can be destroyed.  Inode keeps I_FREEING.
  *
  *			Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are

commit 45321ac54316eaeeebde0b5f728a1791e500974c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 13:43:19 2010 -0400

    Make ->drop_inode() just return whether inode needs to be dropped
    
    ... and let iput_final() do the actual eviction or retention
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4eaa6b2e35db..8553adbda57b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1562,7 +1562,7 @@ struct super_operations {
 
    	void (*dirty_inode) (struct inode *);
 	int (*write_inode) (struct inode *, struct writeback_control *wbc);
-	void (*drop_inode) (struct inode *);
+	int (*drop_inode) (struct inode *);
 	void (*evict_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
 	void (*write_super) (struct super_block *);
@@ -2164,8 +2164,8 @@ extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);
 extern int inode_needs_sync(struct inode *inode);
-extern void generic_delete_inode(struct inode *inode);
-extern void generic_drop_inode(struct inode *inode);
+extern int generic_delete_inode(struct inode *inode);
+extern int generic_drop_inode(struct inode *inode);
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,
 		unsigned long hashval, int (*test)(struct inode *, void *),

commit 30140837f256558c943636245ab90897a9455a70
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 13:23:20 2010 -0400

    fs/inode.c:clear_inode() is gone
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2b1254771e46..4eaa6b2e35db 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2182,7 +2182,6 @@ extern void unlock_new_inode(struct inode *);
 
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
-extern void clear_inode(struct inode *);
 extern void end_writeback(struct inode *);
 extern void destroy_inode(struct inode *);
 extern void __destroy_inode(struct inode *);

commit 07958f9f5b9e8422c15368a1733a52ea99009896
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 7 13:20:09 2010 -0400

    ->delete_inode() is gone
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3c23c1dcb1bd..2b1254771e46 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1564,7 +1564,6 @@ struct super_operations {
 	int (*write_inode) (struct inode *, struct writeback_control *wbc);
 	void (*drop_inode) (struct inode *);
 	void (*evict_inode) (struct inode *);
-	void (*delete_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
 	void (*write_super) (struct super_block *);
 	int (*sync_fs)(struct super_block *sb, int wait);

commit b0683aa638b3326c6fc22e5290dfa75e08bd83f5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 4 20:55:25 2010 -0400

    new helper: end_writeback()
    
    Essentially, the minimal variant of ->evict_inode().  It's
    a trimmed-down clear_inode(), sans any fs callbacks.  Once
    it returns we know that no async writeback will be happening;
    every ->evict_inode() instance should do that once and do that
    before doing anything ->write_inode() could interfere with
    (e.g. freeing the on-disk inode).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0ecb8e75ebf..3c23c1dcb1bd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2184,6 +2184,7 @@ extern void unlock_new_inode(struct inode *);
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
 extern void clear_inode(struct inode *);
+extern void end_writeback(struct inode *);
 extern void destroy_inode(struct inode *);
 extern void __destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);

commit c6287315cb958e740466555ca5e9d007f25b39bd
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 4 19:56:17 2010 -0400

    generic_detach_inode() can be static now
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ce50be4b0b41..e0ecb8e75ebf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2167,7 +2167,6 @@ extern ino_t iunique(struct super_block *, ino_t);
 extern int inode_needs_sync(struct inode *inode);
 extern void generic_delete_inode(struct inode *inode);
 extern void generic_drop_inode(struct inode *inode);
-extern int generic_detach_inode(struct inode *inode);
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,
 		unsigned long hashval, int (*test)(struct inode *, void *),

commit be7ce4161f9e6bf2497f90337d1214aa6ee06e15
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jun 4 19:40:39 2010 -0400

    New method - evict_inode()
    
    Hybrid of ->clear_inode() and ->delete_inode(); if present, does
    all fs work to be done when in-core inode is about to be gone,
    for whatever reason.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 218693d8d446..ce50be4b0b41 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1563,6 +1563,7 @@ struct super_operations {
    	void (*dirty_inode) (struct inode *);
 	int (*write_inode) (struct inode *, struct writeback_control *wbc);
 	void (*drop_inode) (struct inode *);
+	void (*evict_inode) (struct inode *);
 	void (*delete_inode) (struct inode *);
 	void (*put_super) (struct super_block *);
 	void (*write_super) (struct super_block *);

commit a4ffdde6e56fdf8c34ddadc2674d6eb978083369
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jun 2 17:38:30 2010 -0400

    simplify checks for I_CLEAR/I_FREEING
    
    add I_CLEAR instead of replacing I_FREEING with it.  I_CLEAR is
    equivalent to I_FREEING for almost all code looking at either;
    it's there to keep track of having called clear_inode() exactly
    once per inode lifetime, at some point after having set I_FREEING.
    I_CLEAR and I_FREEING never get set at the same time with the
    current code, so we can switch to setting i_flags to I_FREEING | I_CLEAR
    instead of I_CLEAR without loss of information.  As the result of
    such change, checks become simpler and the amount of code that needs
    to know about I_CLEAR shrinks a lot.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5547b1b027db..218693d8d446 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1616,8 +1616,8 @@ struct super_operations {
  * I_FREEING		Set when inode is about to be freed but still has dirty
  *			pages or buffers attached or the inode itself is still
  *			dirty.
- * I_CLEAR		Set by clear_inode().  In this state the inode is clean
- *			and can be destroyed.
+ * I_CLEAR		Added by clear_inode().  In this state the inode is clean
+ *			and can be destroyed.  Inode keeps I_FREEING.
  *
  *			Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are
  *			prohibited for many purposes.  iget() must wait for

commit 2c27c65ed0696f0b5df2dad2cf6462d72164d547
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:30:04 2010 +0200

    check ATTR_SIZE contraints in inode_change_ok
    
    Make sure we check the truncate constraints early on in ->setattr by adding
    those checks to inode_change_ok.  Also clean up and document inode_change_ok
    to make this obvious.
    
    As a fallout we don't have to call inode_newsize_ok from simple_setsize and
    simplify it down to a truncate_setsize which doesn't return an error.  This
    simplifies a lot of setattr implementations and means we use truncate_setsize
    almost everywhere.  Get rid of fat_setsize now that it's trivial and mark
    ext2_setsize static to make the calling convention obvious.
    
    Keep the inode_newsize_ok in vmtruncate for now as all callers need an
    audit for its removal anyway.
    
    Note: setattr code in ecryptfs doesn't call inode_change_ok at all and
    needs a deeper audit, but that is left for later.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6ecb83c00a6d..5547b1b027db 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2355,7 +2355,6 @@ extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
-extern int simple_setsize(struct inode *, loff_t);
 extern int noop_fsync(struct file *, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);

commit 1025774ce411f2bd4b059ad7b53f0003569b74fa
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:30:02 2010 +0200

    remove inode_setattr
    
    Replace inode_setattr with opencoded variants of it in all callers.  This
    moves the remaining call to vmtruncate into the filesystem methods where it
    can be replaced with the proper truncate sequence.
    
    In a few cases it was obvious that we would never end up calling vmtruncate
    so it was left out in the opencoded variant:
    
     spufs: explicitly checks for ATTR_SIZE earlier
     btrfs,hugetlbfs,logfs,dlmfs: explicitly clears ATTR_SIZE earlier
     ufs: contains an opencoded simple_seattr + truncate that sets the filesize just above
    
    In addition to that ncpfs called inode_setattr with handcrafted iattrs,
    which allowed to trim down the opencoded variant.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8ebb5f01a418..6ecb83c00a6d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2392,7 +2392,6 @@ extern int buffer_migrate_page(struct address_space *,
 
 extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
-extern int __must_check inode_setattr(struct inode *, const struct iattr *);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern void file_update_time(struct file *file);

commit 6a1a90ad1b0edb556a7550a6ef8a8756f0304dd5
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:30:00 2010 +0200

    rename generic_setattr
    
    Despite its name it's now a generic implementation of ->setattr, but
    rather a helper to copy attributes from a struct iattr to the inode.
    Rename it to setattr_copy to reflect this fact.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b347b2d5666f..8ebb5f01a418 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2393,7 +2393,7 @@ extern int buffer_migrate_page(struct address_space *,
 extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern int __must_check inode_setattr(struct inode *, const struct iattr *);
-extern void generic_setattr(struct inode *inode, const struct iattr *attr);
+extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
 extern void file_update_time(struct file *file);
 

commit eafdc7d190a944c755a9fe68573c193e6e0217e7
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 4 11:29:53 2010 +0200

    sort out blockdev_direct_IO variants
    
    Move the call to vmtruncate to get rid of accessive blocks to the callers
    in prepearation of the new truncate calling sequence.  This was only done
    for DIO_LOCKING filesystems, so the __blockdev_direct_IO_newtrunc variant
    was not needed anyway.  Get rid of blockdev_direct_IO_no_locking and
    its _newtrunc variant while at it as just opencoding the two additional
    paramters is shorted than the name suffix.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f91affb7d530..b347b2d5666f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2269,16 +2269,6 @@ static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
 struct bio;
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
 			    loff_t file_offset);
-void dio_end_io(struct bio *bio, int error);
-
-ssize_t __blockdev_direct_IO_newtrunc(int rw, struct kiocb *iocb, struct inode *inode,
-	struct block_device *bdev, const struct iovec *iov, loff_t offset,
-	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
-	dio_submit_t submit_io, int lock_type);
-ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
-	struct block_device *bdev, const struct iovec *iov, loff_t offset,
-	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
-	dio_submit_t submit_io,	int lock_type);
 
 enum {
 	/* need locking between buffered and direct access */
@@ -2288,24 +2278,13 @@ enum {
 	DIO_SKIP_HOLES	= 0x02,
 };
 
-static inline ssize_t blockdev_direct_IO_newtrunc(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
-{
-	return __blockdev_direct_IO_newtrunc(rw, iocb, inode, bdev, iov, offset,
-				    nr_segs, get_block, end_io, NULL,
-				    DIO_LOCKING | DIO_SKIP_HOLES);
-}
+void dio_end_io(struct bio *bio, int error);
+
+ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
+	struct block_device *bdev, const struct iovec *iov, loff_t offset,
+	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
+	dio_submit_t submit_io,	int flags);
 
-static inline ssize_t blockdev_direct_IO_no_locking_newtrunc(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
-{
-	return __blockdev_direct_IO_newtrunc(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, NULL, 0);
-}
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
 	loff_t offset, unsigned long nr_segs, get_block_t get_block,
@@ -2315,15 +2294,6 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 				    nr_segs, get_block, end_io, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
-
-static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
-{
-	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				    nr_segs, get_block, end_io, NULL, 0);
-}
 #endif
 
 extern const struct file_operations generic_ro_fops;

commit 7cc015811ef8992dfcce314d0ed9642bc18143d1
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Aug 3 13:14:58 2010 +0200

    bio, fs: separate out bio_types.h and define READ/WRITE constants in terms of BIO_RW_* flags
    
    linux/fs.h hard coded READ/WRITE constants which should match BIO_RW_*
    flags.  This is fragile and caused breakage during BIO_RW_* flag
    rearrangement.  The hardcoding is to avoid include dependency hell.
    
    Create linux/bio_types.h which contatins definitions for bio data
    structures and flags and include it from bio.h and fs.h, and make fs.h
    define all READ/WRITE related constants in terms of BIO_RW_* flags.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 55dad7bca25b..c53911277210 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -8,6 +8,7 @@
 
 #include <linux/limits.h>
 #include <linux/ioctl.h>
+#include <linux/blk_types.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -117,7 +118,7 @@ struct inodes_stat_t {
  *			immediately wait on this read without caring about
  *			unplugging.
  * READA		Used for read-ahead operations. Lower priority, and the
- *			 block layer could (in theory) choose to ignore this
+ *			block layer could (in theory) choose to ignore this
  *			request if it runs into resource problems.
  * WRITE		A normal async write. Device will be plugged.
  * SWRITE		Like WRITE, but a special case for ll_rw_block() that
@@ -144,13 +145,13 @@ struct inodes_stat_t {
  *			of this IO.
  *
  */
-#define RW_MASK			1
-#define RWA_MASK		16
+#define RW_MASK			REQ_WRITE
+#define RWA_MASK		REQ_RAHEAD
 
 #define READ			0
-#define WRITE			1
-#define READA			16 /* readahead - don't block if no resources */
-#define SWRITE			17 /* for ll_rw_block(), wait for buffer lock */
+#define WRITE			RW_MASK
+#define READA			RWA_MASK
+#define SWRITE			(WRITE | READA)
 
 #define READ_SYNC		(READ | REQ_SYNC | REQ_UNPLUG)
 #define READ_META		(READ | REQ_META)
@@ -2200,7 +2201,6 @@ static inline void insert_inode_hash(struct inode *inode) {
 extern void file_move(struct file *f, struct list_head *list);
 extern void file_kill(struct file *f);
 #ifdef CONFIG_BLOCK
-struct bio;
 extern void submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);
 #endif
@@ -2267,7 +2267,6 @@ static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
 #endif
 
 #ifdef CONFIG_BLOCK
-struct bio;
 typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
 			    loff_t file_offset);
 void dio_end_io(struct bio *bio, int error);

commit aca27ba9618276dd2f777bcd5a1419589ccf1ca8
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Aug 3 13:14:33 2010 +0200

    bio, fs: update RWA_MASK, READA and SWRITE to match the corresponding BIO_RW_* bits
    
    Commit a82afdf (block: use the same failfast bits for bio and request)
    moved BIO_RW_* bits around such that they match up with REQ_* bits.
    Unfortunately, fs.h hard coded RW_MASK, RWA_MASK, READ, WRITE, READA
    and SWRITE as 0, 1, 2 and 3, and expected them to match with BIO_RW_*
    bits.  READ/WRITE didn't change but BIO_RW_AHEAD was moved to bit 4
    instead of bit 1, breaking RWA_MASK, READA and SWRITE.
    
    This patch updates RWA_MASK, READA and SWRITE such that they match the
    BIO_RW_* bits again.  A follow up patch will update the definitions to
    directly use BIO_RW_* bits so that this kind of breakage won't happen
    again.
    
    Neil also spotted missing RWA_MASK conversion.
    
    Stable: The offending commit a82afdf was released with v2.6.32, so
    this patch should be applied to all kernels since then but it must
    _NOT_ be applied to kernels earlier than that.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-and-bisected-by: Vladislav Bolkhovitin <vst@vlnb.net>
    Root-caused-by: Neil Brown <neilb@suse.de>
    Cc: stable@kernel.org
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c5c92943c767..55dad7bca25b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -145,12 +145,12 @@ struct inodes_stat_t {
  *
  */
 #define RW_MASK			1
-#define RWA_MASK		2
+#define RWA_MASK		16
 
 #define READ			0
 #define WRITE			1
-#define READA			2 /* readahead  - don't block if no resources */
-#define SWRITE			3 /* for ll_rw_block() - wait for buffer lock */
+#define READA			16 /* readahead - don't block if no resources */
+#define SWRITE			17 /* for ll_rw_block(), wait for buffer lock */
 
 #define READ_SYNC		(READ | REQ_SYNC | REQ_UNPLUG)
 #define READ_META		(READ | REQ_META)

commit 7b6d91daee5cac6402186ff224c3af39d79f4a0e
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Aug 7 18:20:39 2010 +0200

    block: unify flags for struct bio and struct request
    
    Remove the current bio flags and reuse the request flags for the bio, too.
    This allows to more easily trace the type of I/O from the filesystem
    down to the block driver.  There were two flags in the bio that were
    missing in the requests:  BIO_RW_UNPLUG and BIO_RW_AHEAD.  Also I've
    renamed two request flags that had a superflous RW in them.
    
    Note that the flags are in bio.h despite having the REQ_ name - as
    blkdev.h includes bio.h that is the only way to go for now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 598878831497..c5c92943c767 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -144,29 +144,31 @@ struct inodes_stat_t {
  *			of this IO.
  *
  */
-#define RW_MASK		1
-#define RWA_MASK	2
-#define READ 0
-#define WRITE 1
-#define READA 2		/* read-ahead  - don't block if no resources */
-#define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
-#define READ_SYNC	(READ | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
-#define READ_META	(READ | (1 << BIO_RW_META))
-#define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
-#define WRITE_SYNC	(WRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
-#define WRITE_ODIRECT_PLUG	(WRITE | (1 << BIO_RW_SYNCIO))
-#define WRITE_META	(WRITE | (1 << BIO_RW_META))
-#define SWRITE_SYNC_PLUG	\
-			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
-#define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
-#define WRITE_BARRIER	(WRITE_SYNC | (1 << BIO_RW_BARRIER))
+#define RW_MASK			1
+#define RWA_MASK		2
+
+#define READ			0
+#define WRITE			1
+#define READA			2 /* readahead  - don't block if no resources */
+#define SWRITE			3 /* for ll_rw_block() - wait for buffer lock */
+
+#define READ_SYNC		(READ | REQ_SYNC | REQ_UNPLUG)
+#define READ_META		(READ | REQ_META)
+#define WRITE_SYNC_PLUG		(WRITE | REQ_SYNC | REQ_NOIDLE)
+#define WRITE_SYNC		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG)
+#define WRITE_ODIRECT_PLUG	(WRITE | REQ_SYNC)
+#define WRITE_META		(WRITE | REQ_META)
+#define WRITE_BARRIER		(WRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG | \
+				 REQ_HARDBARRIER)
+#define SWRITE_SYNC_PLUG	(SWRITE | REQ_SYNC | REQ_NOIDLE)
+#define SWRITE_SYNC		(SWRITE | REQ_SYNC | REQ_NOIDLE | REQ_UNPLUG)
 
 /*
  * These aren't really reads or writes, they pass down information about
  * parts of device that are now unused by the file system.
  */
-#define DISCARD_NOBARRIER (WRITE | (1 << BIO_RW_DISCARD))
-#define DISCARD_BARRIER (DISCARD_NOBARRIER | (1 << BIO_RW_BARRIER))
+#define DISCARD_NOBARRIER	(WRITE | REQ_DISCARD)
+#define DISCARD_BARRIER		(WRITE | REQ_DISCARD | REQ_HARDBARRIER)
 
 #define SEL_IN		1
 #define SEL_OUT		2

commit 41f2df62894bfcd3bf868af916b32b90aa7168dc
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 17 08:54:16 2010 +0200

    block: BARRIER request should imply SYNC
    
    A barrier request should by defintion have priority in get_request
    and let the queue be unplugged immediately as it's blocking all forward
    progress due to the queue draining.
    
    Most filesystems already get this implicitly by the way how submit_bh
    treats the buffer_ordered flag, and gfs2 sets it explicitly.  But btrfs
    and XFS are still forgetting to set the flag, as is blkdev_issue_flush
    and some places in DM/MD.
    
    For XFS on metadata heavy workloads this gives a consistent speedup
    in the 2-3% range.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 68ca1b0491af..598878831497 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -136,7 +136,7 @@ struct inodes_stat_t {
  * SWRITE_SYNC
  * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
  *			See SWRITE.
- * WRITE_BARRIER	Like WRITE, but tells the block layer that all
+ * WRITE_BARRIER	Like WRITE_SYNC, but tells the block layer that all
  *			previously submitted writes must be safely on storage
  *			before this one is started. Also guarantees that when
  *			this write is complete, it itself is also safely on
@@ -159,7 +159,7 @@ struct inodes_stat_t {
 #define SWRITE_SYNC_PLUG	\
 			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
-#define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
+#define WRITE_BARRIER	(WRITE_SYNC | (1 << BIO_RW_BARRIER))
 
 /*
  * These aren't really reads or writes, they pass down information about

commit 7e6880951da86928c7f6cecf26dcb8e8d9f826da
Merge: 3a09b1be53d2 77c80e6b2fd0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 4 10:28:39 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jmorris/security-testing-2.6: (90 commits)
      AppArmor: fix build warnings for non-const use of get_task_cred
      selinux: convert the policy type_attr_map to flex_array
      AppArmor: Enable configuring and building of the AppArmor security module
      TOMOYO: Use pathname specified by policy rather than execve()
      AppArmor: update path_truncate method to latest version
      AppArmor: core policy routines
      AppArmor: policy routines for loading and unpacking policy
      AppArmor: mediation of non file objects
      AppArmor: LSM interface, and security module initialization
      AppArmor: Enable configuring and building of the AppArmor security module
      AppArmor: update Maintainer and Documentation
      AppArmor: functions for domain transitions
      AppArmor: file enforcement routines
      AppArmor: userspace interfaces
      AppArmor: dfa match engine
      AppArmor: contexts used in attaching policy to system objects
      AppArmor: basic auditing infrastructure.
      AppArmor: misc. base functions and defines
      TOMOYO: Update version to 2.3.0
      TOMOYO: Fix quota check.
      ...

commit 9cfcac810e8993fa7a5bfd24b1a21f1dbbb03a7b
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Jul 23 11:43:51 2010 -0400

    vfs: re-introduce MAY_CHDIR
    
    Currently MAY_ACCESS means that filesystems must check the permissions
    right then and not rely on cached results or the results of future
    operations on the object.  This can be because of a call to sys_access() or
    because of a call to chdir() which needs to check search without relying on
    any future operations inside that dir.  I plan to use MAY_ACCESS for other
    purposes in the security system, so I split the MAY_ACCESS and the
    MAY_CHDIR cases.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by:  Stephen D. Smalley <sds@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 68ca1b0491af..7d94b72f0346 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -53,6 +53,7 @@ struct inodes_stat_t {
 #define MAY_APPEND 8
 #define MAY_ACCESS 16
 #define MAY_OPEN 32
+#define MAY_CHDIR 64
 
 /*
  * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond

commit 6e006701ccc1590500186ef21e074bd900c5dd67
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Jan 20 22:27:56 2010 +0200

    dnotify: move dir_notify_enable declaration
    
    Move dir_notify_enable declaration to where it belongs -- dnotify.h .
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f9a003278758..d92c212476f9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -410,9 +410,6 @@ extern int get_max_files(void);
 extern int sysctl_nr_open;
 extern struct inodes_stat_t inodes_stat;
 extern int leases_enable, lease_break_time;
-#ifdef CONFIG_DNOTIFY
-extern int dir_notify_enable;
-#endif
 
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,

commit 12ed2e36c98aec6c41559222e311f4aa15d254b6
Author: Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
Date:   Mon Feb 8 12:31:29 2010 -0500

    fanotify: FMODE_NONOTIFY and __O_SYNC in sparc conflict
    
    sparc used the same value as FMODE_NONOTIFY so change FMODE_NONOTIFY to be
    something unique.
    
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 50ef4d4c95bf..f9a003278758 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -91,7 +91,7 @@ struct inodes_stat_t {
 #define FMODE_RANDOM		((__force fmode_t)0x1000)
 
 /* File was opened by fanotify and shouldn't generate fanotify events */
-#define FMODE_NONOTIFY		((__force fmode_t)8388608)
+#define FMODE_NONOTIFY		((__force fmode_t)16777216) /* 0x1000000 */
 
 /*
  * The below are the various read and write types that we support. Some of

commit ecf081d1a73b077916f514f2ec744ded32b88ca1
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:25 2009 -0500

    vfs: introduce FMODE_NONOTIFY
    
    This is a new f_mode which can only be set by the kernel.  It indicates
    that the fd was opened by fanotify and should not cause future fanotify
    events.  This is needed to prevent fanotify livelock.  An example of
    obvious livelock is from fanotify close events.
    
    Process A closes file1
    This creates a close event for file1.
    fanotify opens file1 for Listener X
    Listener X deals with the event and closes its fd for file1.
    This creates a close event for file1.
    fanotify opens file1 for Listener X
    Listener X deals with the event and closes its fd for file1.
    This creates a close event for file1.
    fanotify opens file1 for Listener X
    Listener X deals with the event and closes its fd for file1.
    notice a pattern?
    
    The fix is to add the FMODE_NONOTIFY bit to the open filp done by the kernel
    for fanotify.  Thus when that file is used it will not generate future
    events.
    
    This patch simply defines the bit.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 85fe89c43487..50ef4d4c95bf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -90,6 +90,9 @@ struct inodes_stat_t {
 /* Expect random access pattern */
 #define FMODE_RANDOM		((__force fmode_t)0x1000)
 
+/* File was opened by fanotify and shouldn't generate fanotify events */
+#define FMODE_NONOTIFY		((__force fmode_t)8388608)
+
 /*
  * The below are the various read and write types that we support. Some of
  * them include behavioral modifiers that send information down to the
@@ -2508,7 +2511,8 @@ int proc_nr_files(struct ctl_table *table, int write,
 int __init get_filesystem_list(char *buf);
 
 #define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])
-#define OPEN_FMODE(flag) ((__force fmode_t)((flag + 1) & O_ACCMODE))
+#define OPEN_FMODE(flag) ((__force fmode_t)(((flag + 1) & O_ACCMODE) | \
+					    (flag & FMODE_NONOTIFY)))
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit e61ce86737b4d60521e4e71f9892fe4bdcfb688b
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 21:24:24 2009 -0500

    fsnotify: rename fsnotify_mark_entry to just fsnotify_mark
    
    The name is long and it serves no real purpose.  So rename
    fsnotify_mark_entry to just fsnotify_mark.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e5598d2f99b9..85fe89c43487 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -768,7 +768,7 @@ struct inode {
 
 #ifdef CONFIG_FSNOTIFY
 	__u32			i_fsnotify_mask; /* all events this inode cares about */
-	struct hlist_head	i_fsnotify_mark_entries; /* fsnotify mark entries */
+	struct hlist_head	i_fsnotify_marks;
 #endif
 
 	unsigned long		i_state;

commit 2dfc1cae4c42b93b831b2417540df2b895ab7108
Author: Eric Paris <eparis@redhat.com>
Date:   Thu Dec 17 20:30:52 2009 -0500

    inotify: remove inotify in kernel interface
    
    nothing uses inotify in the kernel, drop it!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 68ca1b0491af..e5598d2f99b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -771,11 +771,6 @@ struct inode {
 	struct hlist_head	i_fsnotify_mark_entries; /* fsnotify mark entries */
 #endif
 
-#ifdef CONFIG_INOTIFY
-	struct list_head	inotify_watches; /* watches on this inode */
-	struct mutex		inotify_mutex;	/* protects the watches list */
-#endif
-
 	unsigned long		i_state;
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
 

commit 40e2e97316af6e62affab7a392e792494b8d9dde
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sun Jul 18 21:17:09 2010 +0000

    direct-io: move aio_complete into ->end_io
    
    Filesystems with unwritten extent support must not complete an AIO request
    until the transaction to convert the extent has been commited.  That means
    the aio_complete calls needs to be moved into the ->end_io callback so
    that the filesystem can control when to call it exactly.
    
    This makes a bit of a mess out of dio_complete and the ->end_io callback
    prototype even more complicated.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Alex Elder <aelder@sgi.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 68ca1b0491af..f91affb7d530 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -415,7 +415,8 @@ struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
 typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
-			ssize_t bytes, void *private);
+			ssize_t bytes, void *private, int ret,
+			bool is_async);
 
 /*
  * Attribute flags.  These should be or-ed together to figure out what

commit 140236b4b1c749c9b795ea3d11558a0eb5a3a080
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Thu Jun 10 13:56:33 2010 +0300

    VFS: introduce s_dirty accessors
    
    This patch introduces 3 VFS accessors: 'sb_mark_dirty()',
    'sb_mark_clean()', and 'sb_is_dirty()'. They simply
    set 'sb->s_dirt' or test 'sb->s_dirt'. The plan is to make
    every FS use these accessors later instead of manipulating
    the 'sb->s_dirt' flag directly.
    
    Ultimately, this change is a preparation for the periodic
    superblock synchronization optimization which is about
    preventing the "sync_supers" kernel thread from waking up
    even if there is nothing to synchronize.
    
    This patch does not do any functional change, just adds
    accessor functions.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 471e1ff5079a..68ca1b0491af 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1783,6 +1783,19 @@ extern int get_sb_pseudo(struct file_system_type *, char *,
 	struct vfsmount *mnt);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 
+static inline void sb_mark_dirty(struct super_block *sb)
+{
+	sb->s_dirt = 1;
+}
+static inline void sb_mark_clean(struct super_block *sb)
+{
+	sb->s_dirt = 0;
+}
+static inline int sb_is_dirty(struct super_block *sb)
+{
+	return sb->s_dirt;
+}
+
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \
 	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))

commit 7d683a09990ff095a91b6e724ecee0ff8733274a
Author: Roberto Sassu <roberto.sassu@polito.it>
Date:   Thu Jun 3 11:58:28 2010 +0200

    wrong type for 'magic' argument in simple_fill_super()
    
    It's used to superblock ->s_magic, which is unsigned long.
    
    Signed-off-by: Roberto Sassu <roberto.sassu@polito.it>
    Reviewed-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>
    CC: stable@kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3428393942a6..471e1ff5079a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2388,7 +2388,7 @@ extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;
 struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
-extern int simple_fill_super(struct super_block *, int, struct tree_descr *);
+extern int simple_fill_super(struct super_block *, unsigned long, struct tree_descr *);
 extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
 extern void simple_release_fs(struct vfsmount **mount, int *count);
 

commit 7bb46a6734a7e1ad4beaecc11cae7ed3ff81d30f
Author: npiggin@suse.de <npiggin@suse.de>
Date:   Thu May 27 01:05:33 2010 +1000

    fs: introduce new truncate sequence
    
    Introduce a new truncate calling sequence into fs/mm subsystems. Rather than
    setattr > vmtruncate > truncate, have filesystems call their truncate sequence
    from ->setattr if filesystem specific operations are required. vmtruncate is
    deprecated, and truncate_pagecache and inode_newsize_ok helpers introduced
    previously should be used.
    
    simple_setattr is introduced for simple in-ram filesystems to implement
    the new truncate sequence. Eventually all filesystems should be converted
    to implement a setattr, and the default code in notify_change should go
    away.
    
    simple_setsize is also introduced to perform just the ATTR_SIZE portion
    of simple_setattr (ie. changing i_size and trimming pagecache).
    
    To implement the new truncate sequence:
    - filesystem specific manipulations (eg freeing blocks) must be done in
      the setattr method rather than ->truncate.
    - vmtruncate can not be used by core code to trim blocks past i_size in
      the event of write failure after allocation, so this must be performed
      in the fs code.
    - convert usage of helpers block_write_begin, nobh_write_begin,
      cont_write_begin, and *blockdev_direct_IO* to use _newtrunc postfixed
      variants. These avoid calling vmtruncate to trim blocks (see previous).
    - inode_setattr should not be used. generic_setattr is a new function
      to be used to copy simple attributes into the generic inode.
    - make use of the better opportunity to handle errors with the new sequence.
    
    Big problem with the previous calling sequence: the filesystem is not called
    until i_size has already changed.  This means it is not allowed to fail the
    call, and also it does not know what the previous i_size was. Also, generic
    code calling vmtruncate to truncate allocated blocks in case of error had
    no good way to return a meaningful error (or, for example, atomically handle
    block deallocation).
    
    Cc: Christoph Hellwig <hch@lst.de>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index acf6c52a50dd..3428393942a6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2257,6 +2257,10 @@ typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
 			    loff_t file_offset);
 void dio_end_io(struct bio *bio, int error);
 
+ssize_t __blockdev_direct_IO_newtrunc(int rw, struct kiocb *iocb, struct inode *inode,
+	struct block_device *bdev, const struct iovec *iov, loff_t offset,
+	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
+	dio_submit_t submit_io, int lock_type);
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
 	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
@@ -2270,6 +2274,24 @@ enum {
 	DIO_SKIP_HOLES	= 0x02,
 };
 
+static inline ssize_t blockdev_direct_IO_newtrunc(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_block_t get_block,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO_newtrunc(rw, iocb, inode, bdev, iov, offset,
+				    nr_segs, get_block, end_io, NULL,
+				    DIO_LOCKING | DIO_SKIP_HOLES);
+}
+
+static inline ssize_t blockdev_direct_IO_no_locking_newtrunc(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_block_t get_block,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO_newtrunc(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_block, end_io, NULL, 0);
+}
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
 	loff_t offset, unsigned long nr_segs, get_block_t get_block,
@@ -2342,12 +2364,14 @@ extern int dcache_dir_open(struct inode *, struct file *);
 extern int dcache_dir_close(struct inode *, struct file *);
 extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
 extern int dcache_readdir(struct file *, void *, filldir_t);
+extern int simple_setattr(struct dentry *, struct iattr *);
 extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
 extern int simple_statfs(struct dentry *, struct kstatfs *);
 extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int simple_setsize(struct inode *, loff_t);
 extern int noop_fsync(struct file *, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
@@ -2384,7 +2408,8 @@ extern int buffer_migrate_page(struct address_space *,
 
 extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
-extern int __must_check inode_setattr(struct inode *, struct iattr *);
+extern int __must_check inode_setattr(struct inode *, const struct iattr *);
+extern void generic_setattr(struct inode *inode, const struct iattr *attr);
 
 extern void file_update_time(struct file *file);
 

commit 1b061d9247f71cd15edc4c4c4600191a903642c0
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 26 17:53:41 2010 +0200

    rename the generic fsync implementations
    
    We don't name our generic fsync implementations very well currently.
    The no-op implementation for in-memory filesystems currently is called
    simple_sync_file which doesn't make too much sense to start with,
    the the generic one for simple filesystems is called simple_fsync
    which can lead to some confusion.
    
    This patch renames the generic file fsync method to generic_file_fsync
    to match the other generic_file_* routines it is supposed to be used
    with, and the no-op implementation to noop_fsync to make it obvious
    what to expect.  In addition add some documentation for both methods.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eb39e5eb77f5..acf6c52a50dd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2348,7 +2348,7 @@ extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
-extern int simple_sync_file(struct file *, int);
+extern int noop_fsync(struct file *, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
@@ -2373,7 +2373,7 @@ extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
 		const void __user *from, size_t count);
 
-extern int simple_fsync(struct file *, int);
+extern int generic_file_fsync(struct file *, int);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,

commit 7ea8085910ef3dd4f3cad6845aaa2b580d39b115
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 26 17:53:25 2010 +0200

    drop unused dentry argument to ->fsync
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3d9ed8302402..eb39e5eb77f5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1498,7 +1498,7 @@ struct file_operations {
 	int (*open) (struct inode *, struct file *);
 	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);
-	int (*fsync) (struct file *, struct dentry *, int datasync);
+	int (*fsync) (struct file *, int datasync);
 	int (*aio_fsync) (struct kiocb *, int datasync);
 	int (*fasync) (int, struct file *, int);
 	int (*lock) (struct file *, int, struct file_lock *);
@@ -2213,7 +2213,7 @@ extern int generic_segment_checks(const struct iovec *iov,
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
-extern int blkdev_fsync(struct file *filp, struct dentry *dentry, int datasync);
+extern int blkdev_fsync(struct file *filp, int datasync);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,
@@ -2348,7 +2348,7 @@ extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);
 extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
-extern int simple_sync_file(struct file *, struct dentry *, int);
+extern int simple_sync_file(struct file *, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
@@ -2373,7 +2373,7 @@ extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
 		const void __user *from, size_t count);
 
-extern int simple_fsync(struct file *, struct dentry *, int);
+extern int simple_fsync(struct file *, int);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,

commit d7065da038227a4d09a244e6014e0186a6bd21d0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 26 15:13:55 2010 -0400

    get rid of the magic around f_count in aio
    
    __aio_put_req() plays sick games with file refcount.  What
    it wants is fput() from atomic context; it's almost always
    done with f_count > 1, so they only have to deal with delayed
    work in rare cases when their reference happens to be the
    last one.  Current code decrements f_count and if it hasn't
    hit 0, everything is fine.  Otherwise it keeps a pointer
    to struct file (with zero f_count!) around and has delayed
    work do __fput() on it.
    
    Better way to do it: use atomic_long_add_unless( , -1, 1)
    instead of !atomic_long_dec_and_test().  IOW, decrement it
    only if it's not the last reference, leave refcount alone
    if it was.  And use normal fput() in delayed work.
    
    I've made that atomic_long_add_unless call a new helper -
    fput_atomic().  Drops a reference to file if it's safe to
    do in atomic (i.e. if that's not the last one), tells if
    it had been able to do that.  aio.c converted to it, __fput()
    use is gone.  req->ki_file *always* contributes to refcount
    now.  And __fput() became static.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 85e823adcd4a..3d9ed8302402 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -954,6 +954,7 @@ extern spinlock_t files_lock;
 #define file_list_unlock() spin_unlock(&files_lock);
 
 #define get_file(x)	atomic_long_inc(&(x)->f_count)
+#define fput_atomic(x)	atomic_long_add_unless(&(x)->f_count, -1, 1)
 #define file_count(x)	atomic_long_read(&(x)->f_count)
 
 #ifdef CONFIG_DEBUG_WRITECOUNT

commit 105a048a4f35f7a74c7cc20b36dd83658b6ec232
Merge: 00b9b0af5887 9aeead73782c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 27 10:43:44 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mason/btrfs-unstable: (27 commits)
      Btrfs: add more error checking to btrfs_dirty_inode
      Btrfs: allow unaligned DIO
      Btrfs: drop verbose enospc printk
      Btrfs: Fix block generation verification race
      Btrfs: fix preallocation and nodatacow checks in O_DIRECT
      Btrfs: avoid ENOSPC errors in btrfs_dirty_inode
      Btrfs: move O_DIRECT space reservation to btrfs_direct_IO
      Btrfs: rework O_DIRECT enospc handling
      Btrfs: use async helpers for DIO write checksumming
      Btrfs: don't walk around with task->state != TASK_RUNNING
      Btrfs: do aio_write instead of write
      Btrfs: add basic DIO read/write support
      direct-io: do not merge logically non-contiguous requests
      direct-io: add a hook for the fs to provide its own submit_bio function
      fs: allow short direct-io reads to be completed via buffered IO
      Btrfs: Metadata ENOSPC handling for balance
      Btrfs: Pre-allocate space for data relocation
      Btrfs: Metadata ENOSPC handling for tree log
      Btrfs: Metadata reservation for orphan inodes
      Btrfs: Introduce global metadata reservation
      ...

commit ae6afc3f5cf53fb97bac2d0a209bb465952742e7
Author: jan Blunck <jblunck@suse.de>
Date:   Wed May 26 14:44:48 2010 -0700

    vfs: introduce noop_llseek()
    
    This is an implementation of ->llseek useable for the rare special case
    when userspace expects the seek to succeed but the (device) file is
    actually not able to perform the seek.  In this case you use noop_llseek()
    instead of falling back to the default implementation of ->llseek.
    
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b336cb9ca9a0..9682d52d1507 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2228,6 +2228,7 @@ extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
 
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
+extern loff_t noop_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek_unlocked(struct file *file, loff_t offset,

commit facd07b07d2a7988f5ce849558838cc953847637
Author: Josef Bacik <josef@redhat.com>
Date:   Sun May 23 11:00:55 2010 -0400

    direct-io: add a hook for the fs to provide its own submit_bio function
    
    Because BTRFS can do RAID and such, we need our own submit hook so we can setup
    the bio's in the correct fashion, and handle checksum errors properly.  So there
    are a few changes here
    
    1) The submit_io hook.  This is straightforward, just call this instead of
    submit_bio.
    
    2) Allow the fs to return -ENOTBLK for reads.  Usually this has only worked for
    writes, since writes can fallback onto buffered IO.  But BTRFS needs the option
    of falling back on buffered IO if it encounters a compressed extent, since we
    need to read the entire extent in and decompress it.  So if we get -ENOTBLK back
    from get_block we'll return back and fallback on buffered just like the write
    case.
    
    I've tested these changes with fsx and everything seems to work.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 44f35aea2f1f..10704f0086c8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2250,10 +2250,15 @@ static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
 #endif
 
 #ifdef CONFIG_BLOCK
+struct bio;
+typedef void (dio_submit_t)(int rw, struct bio *bio, struct inode *inode,
+			    loff_t file_offset);
+void dio_end_io(struct bio *bio, int error);
+
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
 	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
-	int lock_type);
+	dio_submit_t submit_io,	int lock_type);
 
 enum {
 	/* need locking between buffered and direct access */
@@ -2269,7 +2274,7 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				    nr_segs, get_block, end_io,
+				    nr_segs, get_block, end_io, NULL,
 				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
 
@@ -2279,7 +2284,7 @@ static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, 0);
+				    nr_segs, get_block, end_io, NULL, 0);
 }
 #endif
 

commit e8bebe2f71d26871b0970ae1d9cf0ed3cdd9569d
Merge: 6109e2ce2600 82f3952c02ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 21 19:37:45 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (69 commits)
      fix handling of offsets in cris eeprom.c, get rid of fake on-stack files
      get rid of home-grown mutex in cris eeprom.c
      switch ecryptfs_write() to struct inode *, kill on-stack fake files
      switch ecryptfs_get_locked_page() to struct inode *
      simplify access to ecryptfs inodes in ->readpage() and friends
      AFS: Don't put struct file on the stack
      Ban ecryptfs over ecryptfs
      logfs: replace inode uid,gid,mode initialization with helper function
      ufs: replace inode uid,gid,mode initialization with helper function
      udf: replace inode uid,gid,mode init with helper
      ubifs: replace inode uid,gid,mode initialization with helper function
      sysv: replace inode uid,gid,mode initialization with helper function
      reiserfs: replace inode uid,gid,mode initialization with helper function
      ramfs: replace inode uid,gid,mode initialization with helper function
      omfs: replace inode uid,gid,mode initialization with helper function
      bfs: replace inode uid,gid,mode initialization with helper function
      ocfs2: replace inode uid,gid,mode initialization with helper function
      nilfs2: replace inode uid,gid,mode initialization with helper function
      minix: replace inode uid,gid,mode init with helper
      ext4: replace inode uid,gid,mode init with helper
      ...
    
    Trivial conflict in fs/fs-writeback.c (mark bitfields unsigned)

commit a1bd120d13e586ea1c424048fd2c8420a442852a
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Thu Mar 4 17:29:14 2010 +0300

    vfs: Add inode uid,gid,mode init helper
    
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9626c5fbb0e1..8a733862a411 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1428,7 +1428,8 @@ extern void dentry_unhash(struct dentry *dentry);
  * VFS file helper functions.
  */
 extern int file_permission(struct file *, int);
-
+extern void inode_init_owner(struct inode *inode, const struct inode *dir,
+			mode_t mode);
 /*
  * VFS FS_IOC_FIEMAP helper definitions.
  */

commit 51ee049e771c14a29aaee8ecd6cbbe14db088f3a
Author: Roland Dreier <rdreier@cisco.com>
Date:   Tue Apr 27 14:23:57 2010 -0700

    vfs: add lockdep annotation to s_vfs_rename_key for ecryptfs
    
     >  =============================================
     >  [ INFO: possible recursive locking detected ]
     >  2.6.31-2-generic #14~rbd3
     >  ---------------------------------------------
     >  firefox-3.5/4162 is trying to acquire lock:
     >   (&s->s_vfs_rename_mutex){+.+.+.}, at: [<ffffffff81139d31>] lock_rename+0x41/0xf0
     >
     >  but task is already holding lock:
     >   (&s->s_vfs_rename_mutex){+.+.+.}, at: [<ffffffff81139d31>] lock_rename+0x41/0xf0
     >
     >  other info that might help us debug this:
     >  3 locks held by firefox-3.5/4162:
     >   #0:  (&s->s_vfs_rename_mutex){+.+.+.}, at: [<ffffffff81139d31>] lock_rename+0x41/0xf0
     >   #1:  (&sb->s_type->i_mutex_key#11/1){+.+.+.}, at: [<ffffffff81139d5a>] lock_rename+0x6a/0xf0
     >   #2:  (&sb->s_type->i_mutex_key#11/2){+.+.+.}, at: [<ffffffff81139d6f>] lock_rename+0x7f/0xf0
     >
     >  stack backtrace:
     >  Pid: 4162, comm: firefox-3.5 Tainted: G         C 2.6.31-2-generic #14~rbd3
     >  Call Trace:
     >   [<ffffffff8108ae74>] print_deadlock_bug+0xf4/0x100
     >   [<ffffffff8108ce26>] validate_chain+0x4c6/0x750
     >   [<ffffffff8108d2e7>] __lock_acquire+0x237/0x430
     >   [<ffffffff8108d585>] lock_acquire+0xa5/0x150
     >   [<ffffffff81139d31>] ? lock_rename+0x41/0xf0
     >   [<ffffffff815526ad>] __mutex_lock_common+0x4d/0x3d0
     >   [<ffffffff81139d31>] ? lock_rename+0x41/0xf0
     >   [<ffffffff81139d31>] ? lock_rename+0x41/0xf0
     >   [<ffffffff8120eaf9>] ? ecryptfs_rename+0x99/0x170
     >   [<ffffffff81552b36>] mutex_lock_nested+0x46/0x60
     >   [<ffffffff81139d31>] lock_rename+0x41/0xf0
     >   [<ffffffff8120eb2a>] ecryptfs_rename+0xca/0x170
     >   [<ffffffff81139a9e>] vfs_rename_dir+0x13e/0x160
     >   [<ffffffff8113ac7e>] vfs_rename+0xee/0x290
     >   [<ffffffff8113c212>] ? __lookup_hash+0x102/0x160
     >   [<ffffffff8113d512>] sys_renameat+0x252/0x280
     >   [<ffffffff81133eb4>] ? cp_new_stat+0xe4/0x100
     >   [<ffffffff8101316a>] ? sysret_check+0x2e/0x69
     >   [<ffffffff8108c34d>] ? trace_hardirqs_on_caller+0x14d/0x190
     >   [<ffffffff8113d55b>] sys_rename+0x1b/0x20
     >   [<ffffffff81013132>] system_call_fastpath+0x16/0x1b
    
    The trace above is totally reproducible by doing a cross-directory
    rename on an ecryptfs directory.
    
    The issue seems to be that sys_renameat() does lock_rename() then calls
    into the filesystem; if the filesystem is ecryptfs, then
    ecryptfs_rename() again does lock_rename() on the lower filesystem, and
    lockdep can't tell that the two s_vfs_rename_mutexes are different.  It
    seems an annotation like the following is sufficient to fix this (it
    does get rid of the lockdep trace in my simple tests); however I would
    like to make sure I'm not misunderstanding the locking, hence the CC
    list...
    
    Signed-off-by: Roland Dreier <rdreier@cisco.com>
    Cc: Tyler Hicks <tyhicks@linux.vnet.ibm.com>
    Cc: Dustin Kirkland <kirkland@canonical.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f3e108314c93..9626c5fbb0e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1741,6 +1741,7 @@ struct file_system_type {
 
 	struct lock_class_key s_lock_key;
 	struct lock_class_key s_umount_key;
+	struct lock_class_key s_vfs_rename_key;
 
 	struct lock_class_key i_lock_key;
 	struct lock_class_key i_mutex_key;

commit 8018ab057480974e7f26a387bf4ce040e9a5f6f1
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Mar 22 17:32:25 2010 +0100

    sanitize vfs_fsync calling conventions
    
    Now that the last user passing a NULL file pointer is gone we can remove
    the redundant dentry argument and associated hacks inside vfs_fsynmc_range.
    
    The next step will be removig the dentry argument from ->fsync, but given
    the luck with the last round of method prototype changes I'd rather
    defer this until after the main merge window.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6660db898c41..f3e108314c93 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2084,9 +2084,9 @@ extern int __filemap_fdatawrite_range(struct address_space *mapping,
 extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
 
-extern int vfs_fsync_range(struct file *file, struct dentry *dentry,
-			   loff_t start, loff_t end, int datasync);
-extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
+extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
+			   int datasync);
+extern int vfs_fsync(struct file *file, int datasync);
 extern int generic_write_sync(struct file *file, loff_t pos, loff_t count);
 extern void sync_supers(void);
 extern void emergency_sync(void);

commit bb4354538eb7b92f32cfedbad68c7be266c0b467
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Thu May 13 17:53:14 2010 -0700

    fs: xattr_handler table should be const
    
    The entries in xattr handler table should be immutable (ie const)
    like other operation tables.
    
    Later patches convert common filesystems. Uncoverted filesystems
    will still work, but will generate a compiler warning.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d51256bc6328..6660db898c41 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1336,7 +1336,7 @@ struct super_block {
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
 #endif
-	struct xattr_handler	**s_xattr;
+	const struct xattr_handler **s_xattr;
 
 	struct list_head	s_inodes;	/* all inodes */
 	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */

commit 18e9e5104fcd9a973ffe3eed3816c87f2a1b6cd2
Author: Josef Bacik <josef@redhat.com>
Date:   Tue Mar 23 10:34:56 2010 -0400

    Introduce freeze_super and thaw_super for the fsfreeze ioctl
    
    Currently the way we do freezing is by passing sb>s_bdev to freeze_bdev and then
    letting it do all the work.  But freezing is more of an fs thing, and doesn't
    really have much to do with the bdev at all, all the work gets done with the
    super.  In btrfs we do not populate s_bdev, since we can have multiple bdev's
    for one fs and setting s_bdev makes removing devices from a pool kind of tricky.
    This means that freezing a btrfs filesystem fails, which causes us to corrupt
    with things like tux-on-ice which use the fsfreeze mechanism.  So instead of
    populating sb->s_bdev with a random bdev in our pool, I've broken the actual fs
    freezing stuff into freeze_super and thaw_super.  These just take the
    super_block that we're freezing and does the appropriate work.  It's basically
    just copy and pasted from freeze_bdev.  I've then converted freeze_bdev over to
    use the new super helpers.  I've tested this with ext4 and btrfs and verified
    everything continues to work the same as before.
    
    The only new gotcha is multiple calls to the fsfreeze ioctl will return EBUSY if
    the fs is already frozen.  I thought this was a better solution than adding a
    freeze counter to the super_block, but if everybody hates this idea I'm open to
    suggestions.  Thanks,
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eeb04ba17b63..d51256bc6328 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1797,6 +1797,8 @@ extern void drop_collected_mounts(struct vfsmount *);
 extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
 			  struct vfsmount *);
 extern int vfs_statfs(struct dentry *, struct kstatfs *);
+extern int freeze_super(struct super_block *super);
+extern int thaw_super(struct super_block *super);
 
 extern int current_umask(void);
 

commit 01a05b337a5b647909e1d6670f57e7202318a5fb
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 23 06:06:58 2010 -0400

    new helper: iterate_supers()
    
    ... and switch the simple "loop over superblocks and do something"
    loops to it.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 523086714c74..eeb04ba17b63 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2324,6 +2324,7 @@ extern struct super_block *get_super(struct block_device *);
 extern struct super_block *get_active_super(struct block_device *bdev);
 extern struct super_block *user_get_super(dev_t);
 extern void drop_super(struct super_block *sb);
+extern void iterate_supers(void (*)(struct super_block *, void *), void *);
 
 extern int dcache_dir_open(struct inode *, struct file *);
 extern int dcache_dir_close(struct inode *, struct file *);

commit 35cf7ba0b46dc3582a01c3860b14bff122662aa3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 22 21:13:53 2010 -0400

    Bury __put_super_and_need_restart()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e1c7427802b8..523086714c74 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1778,9 +1778,6 @@ extern int get_sb_pseudo(struct file_system_type *, char *,
 	const struct super_operations *ops, unsigned long,
 	struct vfsmount *mnt);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
-int __put_super_and_need_restart(struct super_block *sb);
-int __put_super(struct super_block *sb);
-void put_super(struct super_block *sb);
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \

commit 8edd64bd6089e21f47dcdebb14b598b713213ddc
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 22 19:56:42 2010 -0400

    get rid of restarts in sync_filesystems()
    
    At the same time we can kill s_need_restart and local mutex in there.
    __put_super() made public for a while; will be gone later.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 62f84d955b83..e1c7427802b8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1332,7 +1332,6 @@ struct super_block {
 	struct rw_semaphore	s_umount;
 	struct mutex		s_lock;
 	int			s_count;
-	int			s_need_sync;
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
@@ -1780,6 +1779,7 @@ extern int get_sb_pseudo(struct file_system_type *, char *,
 	struct vfsmount *mnt);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
+int __put_super(struct super_block *sb);
 void put_super(struct super_block *sb);
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */

commit b20bd1a5e78af267dc4b6e1ffed48d5d776302c5
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Mar 22 08:53:19 2010 -0400

    get rid of S_BIAS
    
    use atomic_inc_not_zero(&sb->s_active) instead of playing games with
    checking ->s_count > S_BIAS
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d13a6b83ad0c..62f84d955b83 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1314,7 +1314,6 @@ extern int send_sigurg(struct fown_struct *fown);
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
 
-#define S_BIAS (1<<30)
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */
 	dev_t			s_dev;		/* search index; _not_ kdev_t */

commit 79d7e39ee1d4b423206f6cfd2cd2eed6253d95fe
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 21 19:24:23 2010 -0400

    sb_entry() has been killed a couple of years ago and resurrected on mismerge
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4079ef99900f..d13a6b83ad0c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1314,7 +1314,6 @@ extern int send_sigurg(struct fown_struct *fown);
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
 
-#define sb_entry(list)  list_entry((list), struct super_block, s_list)
 #define S_BIAS (1<<30)
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */

commit ee9a3607fb03e804ddf624544105f4e34260c380
Merge: b492e95be0ae d515e86e6398
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Fri May 21 21:27:26 2010 +0200

    Merge branch 'master' into for-2.6.35
    
    Conflicts:
            fs/ext3/fsync.c
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

commit f8965467f366fd18f01feafb5db10512d7b4422c
Merge: a26272e52007 2ec8c6bb5d8f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 20 21:04:44 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1674 commits)
      qlcnic: adding co maintainer
      ixgbe: add support for active DA cables
      ixgbe: dcb, do not tag tc_prio_control frames
      ixgbe: fix ixgbe_tx_is_paused logic
      ixgbe: always enable vlan strip/insert when DCB is enabled
      ixgbe: remove some redundant code in setting FCoE FIP filter
      ixgbe: fix wrong offset to fc_frame_header in ixgbe_fcoe_ddp
      ixgbe: fix header len when unsplit packet overflows to data buffer
      ipv6: Never schedule DAD timer on dead address
      ipv6: Use POSTDAD state
      ipv6: Use state_lock to protect ifa state
      ipv6: Replace inet6_ifaddr->dead with state
      cxgb4: notify upper drivers if the device is already up when they load
      cxgb4: keep interrupts available when the ports are brought down
      cxgb4: fix initial addition of MAC address
      cnic: Return SPQ credit to bnx2x after ring setup and shutdown.
      cnic: Convert cnic_local_flags to atomic ops.
      can: Fix SJA1000 command register writes on SMP systems
      bridge: fix build for CONFIG_SYSFS disabled
      ARCNET: Limit com20020 PCI ID matches for SOHARD cards
      ...
    
    Fix up various conflicts with pcmcia tree drivers/net/
    {pcmcia/3c589_cs.c, wireless/orinoco/orinoco_cs.c and
    wireless/orinoco/spectrum_cs.c} and feature removal
    (Documentation/feature-removal-schedule.txt).
    
    Also fix a non-content conflict due to pm_qos_requirement getting
    renamed in the PM tree (now pm_qos_request) in net/mac80211/scan.c

commit 278554bd6579206921f5d8a523649a7a57f8850d
Merge: 5a147e8bf982 cea0d767c296
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 12 00:05:35 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            Documentation/feature-removal-schedule.txt
            drivers/net/wireless/ath/ar9170/usb.c
            drivers/scsi/iscsi_tcp.c
            net/ipv4/ipmr.c

commit 6a727b43be8b005609e893a80af980808012cfdb
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Sat May 1 23:51:22 2010 +0200

    FS / libfs: Implement simple_write_to_buffer
    
    It will be used in suspend code and serves as an easy wrap around
    copy_from_user. Similar to simple_read_from_buffer, it takes care
    of transfers with proper lengths depending on available and count
    parameters and advances ppos appropriately.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 44f35aea2f1f..948bd2bfb1de 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2362,6 +2362,8 @@ extern void simple_release_fs(struct vfsmount **mount, int *count);
 
 extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 			loff_t *ppos, const void *from, size_t available);
+extern ssize_t simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
+		const void __user *from, size_t count);
 
 extern int simple_fsync(struct file *, struct dentry *, int);
 

commit 7407cf355fdf5500430be966dbbde84a27293bad
Merge: 6a47dc141868 79dba2eaa771
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Thu Apr 29 09:36:24 2010 +0200

    Merge branch 'master' into for-2.6.35
    
    Conflicts:
            fs/block_dev.c
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

commit 6b4517a7913a09d3259bb1d21c9cb300f12294bd
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Apr 7 18:53:59 2010 +0900

    block: implement bd_claiming and claiming block
    
    Currently, device claiming for exclusive open is done after low level
    open - disk->fops->open() - has completed successfully.  This means
    that exclusive open attempts while a device is already exclusively
    open will fail only after disk->fops->open() is called.
    
    cdrom driver issues commands during open() which means that O_EXCL
    open attempt can unintentionally inject commands to in-progress
    command stream for burning thus disturbing burning process.  In most
    cases, this doesn't cause problems because the first command to be
    issued is TUR which most devices can process in the middle of burning.
    However, depending on how a device replies to TUR during burning,
    cdrom driver may end up issuing further commands.
    
    This can't be resolved trivially by moving bd_claim() before doing
    actual open() because that means an open attempt which will end up
    failing could interfere other legit O_EXCL open attempts.
    ie. unconfirmed open attempts can fail others.
    
    This patch resolves the problem by introducing claiming block which is
    started by bd_start_claiming() and terminated either by bd_claim() or
    bd_abort_claiming().  bd_claim() from inside a claiming block is
    guaranteed to succeed and once a claiming block is started, other
    bd_start_claiming() or bd_claim() attempts block till the current
    claiming block is terminated.
    
    bd_claim() can still be used standalone although now it always
    synchronizes against claiming blocks, so the existing users will keep
    working without any change.
    
    blkdev_open() and open_bdev_exclusive() are converted to use claiming
    blocks so that exclusive open attempts from these functions don't
    interfere with the existing exclusive open.
    
    This problem was discovered while investigating bko#15403.
    
      https://bugzilla.kernel.org/show_bug.cgi?id=15403
    
    The burning problem itself can be resolved by updating userspace
    probing tools to always open w/ O_EXCL.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Matthias-Christian Ott <ott@mirix.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 39d57bc6cc71..31ee31be51e9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -651,6 +651,7 @@ struct block_device {
 	int			bd_openers;
 	struct mutex		bd_mutex;	/* open/close mutex */
 	struct list_head	bd_inodes;
+	void *			bd_claiming;
 	void *			bd_holder;
 	int			bd_holders;
 #ifdef CONFIG_SYSFS

commit 3a3076f4d6e2fa31338a0b007df42a3b32f079e0
Author: Josef Bacik <josef@redhat.com>
Date:   Fri Apr 23 12:17:17 2010 -0400

    Cleanup generic block based fiemap
    
    This cleans up a few of the complaints of __generic_block_fiemap.  I've
    fixed all the typing stuff, used inline functions instead of macros,
    gotten rid of a couple of variables, and made sure the size and block
    requests are all block aligned.  It also fixes a problem where sometimes
    FIEMAP_EXTENT_LAST wasn't being set properly.
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 39d57bc6cc71..44f35aea2f1f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2315,8 +2315,9 @@ extern int vfs_fstatat(int , char __user *, struct kstat *, int);
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
 extern int __generic_block_fiemap(struct inode *inode,
-				  struct fiemap_extent_info *fieinfo, u64 start,
-				  u64 len, get_block_t *get_block);
+				  struct fiemap_extent_info *fieinfo,
+				  loff_t start, loff_t len,
+				  get_block_t *get_block);
 extern int generic_block_fiemap(struct inode *inode,
 				struct fiemap_extent_info *fieinfo, u64 start,
 				u64 len, get_block_t *get_block);

commit 989a2979205dd34269382b357e6d4b4b6956b889
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Apr 14 09:55:35 2010 +0000

    fasync: RCU and fine grained locking
    
    kill_fasync() uses a central rwlock, candidate for RCU conversion, to
    avoid cache line ping pongs on SMP.
    
    fasync_remove_entry() and fasync_add_entry() can disable IRQS on a short
    section instead during whole list scan.
    
    Use a spinlock per fasync_struct to synchronize kill_fasync_rcu() and
    fasync_{remove|add}_entry(). This spinlock is IRQ safe, so sock_fasync()
    doesnt need its own implementation and can use fasync_helper(), to
    reduce code size and complexity.
    
    We can remove __kill_fasync() direct use in net/socket.c, and rename it
    to kill_fasync_rcu().
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Lai Jiangshan <laijs@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 39d57bc6cc71..018d382f6f92 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1280,10 +1280,12 @@ static inline int lock_may_write(struct inode *inode, loff_t start,
 
 
 struct fasync_struct {
-	int	magic;
-	int	fa_fd;
-	struct	fasync_struct	*fa_next; /* singly linked list */
-	struct	file 		*fa_file;
+	spinlock_t		fa_lock;
+	int			magic;
+	int			fa_fd;
+	struct fasync_struct	*fa_next; /* singly linked list */
+	struct file		*fa_file;
+	struct rcu_head		fa_rcu;
 };
 
 #define FASYNC_MAGIC 0x4601
@@ -1292,8 +1294,6 @@ struct fasync_struct {
 extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
 /* can be called from interrupts */
 extern void kill_fasync(struct fasync_struct **, int, int);
-/* only for net: no internal synchronization */
-extern void __kill_fasync(struct fasync_struct *, int, int);
 
 extern int __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
 extern int f_setown(struct file *filp, unsigned long arg, int force);

commit b1dd3b2843b3b73b7fc2ee47d96310cd1c051371
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Apr 6 14:35:00 2010 -0700

    vfs: rename block_fsync() to blkdev_fsync()
    
    Requested by hch, for consistency now it is exported.
    
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5d9c7e27c5a4..39d57bc6cc71 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2212,7 +2212,7 @@ extern int generic_segment_checks(const struct iovec *iov,
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
-extern int block_fsync(struct file *filp, struct dentry *dentry, int datasync);
+extern int blkdev_fsync(struct file *filp, struct dentry *dentry, int datasync);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,

commit 55ab3a1ff843e3f0e24d2da44e71bffa5d853010
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Apr 6 14:34:58 2010 -0700

    raw: fsync method is now required
    
    Commit 148f948ba877f4d3cdef036b1ff6d9f68986706a (vfs: Introduce new
    helpers for syncing after writing to O_SYNC file or IS_SYNC inode) broke
    the raw driver.
    
    We now call through generic_file_aio_write -> generic_write_sync ->
    vfs_fsync_range.  vfs_fsync_range has:
    
            if (!fop || !fop->fsync) {
                    ret = -EINVAL;
                    goto out;
            }
    
    But drivers/char/raw.c doesn't set an fsync method.
    
    We have two options: fix it or remove the raw driver completely.  I'm
    happy to do either, the fact this has been broken for so long suggests it
    is rarely used.
    
    The patch below adds an fsync method to the raw driver.  My knowledge of
    the block layer is pretty sketchy so this could do with a once over.
    
    If we instead decide to remove the raw driver, this patch might still be
    useful as a backport to 2.6.33 and 2.6.32.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
    Tested-by: Jeff Moyer <jmoyer@redhat.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 10b8dedcd18b..5d9c7e27c5a4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2212,6 +2212,7 @@ extern int generic_segment_checks(const struct iovec *iov,
 /* fs/block_dev.c */
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
+extern int block_fsync(struct file *filp, struct dentry *dentry, int datasync);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,

commit 19adf9c5d5793657118f2002237c0ee49c3b6185
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Mar 5 13:42:03 2010 -0800

    include/linux/fs.h: convert FMODE_* constants to hex
    
    It was tolerable until Eric went and added 8388608.
    
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index be87edcaba06..10b8dedcd18b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -60,24 +60,24 @@ struct inodes_stat_t {
  */
 
 /* file is open for reading */
-#define FMODE_READ		((__force fmode_t)1)
+#define FMODE_READ		((__force fmode_t)0x1)
 /* file is open for writing */
-#define FMODE_WRITE		((__force fmode_t)2)
+#define FMODE_WRITE		((__force fmode_t)0x2)
 /* file is seekable */
-#define FMODE_LSEEK		((__force fmode_t)4)
+#define FMODE_LSEEK		((__force fmode_t)0x4)
 /* file can be accessed using pread */
-#define FMODE_PREAD		((__force fmode_t)8)
+#define FMODE_PREAD		((__force fmode_t)0x8)
 /* file can be accessed using pwrite */
-#define FMODE_PWRITE		((__force fmode_t)16)
+#define FMODE_PWRITE		((__force fmode_t)0x10)
 /* File is opened for execution with sys_execve / sys_uselib */
-#define FMODE_EXEC		((__force fmode_t)32)
+#define FMODE_EXEC		((__force fmode_t)0x20)
 /* File is opened with O_NDELAY (only set for block devices) */
-#define FMODE_NDELAY		((__force fmode_t)64)
+#define FMODE_NDELAY		((__force fmode_t)0x40)
 /* File is opened with O_EXCL (only set for block devices) */
-#define FMODE_EXCL		((__force fmode_t)128)
+#define FMODE_EXCL		((__force fmode_t)0x80)
 /* File is opened using open(.., 3, ..) and is writeable only for ioctls
    (specialy hack for floppy.c) */
-#define FMODE_WRITE_IOCTL	((__force fmode_t)256)
+#define FMODE_WRITE_IOCTL	((__force fmode_t)0x100)
 
 /*
  * Don't update ctime and mtime.
@@ -85,10 +85,10 @@ struct inodes_stat_t {
  * Currently a special hack for the XFS open_by_handle ioctl, but we'll
  * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
  */
-#define FMODE_NOCMTIME		((__force fmode_t)2048)
+#define FMODE_NOCMTIME		((__force fmode_t)0x800)
 
 /* Expect random access pattern */
-#define FMODE_RANDOM		((__force fmode_t)4096)
+#define FMODE_RANDOM		((__force fmode_t)0x1000)
 
 /*
  * The below are the various read and write types that we support. Some of

commit 0141450f66c3c12a3aaa869748caa64241885cdf
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Fri Mar 5 13:42:03 2010 -0800

    readahead: introduce FMODE_RANDOM for POSIX_FADV_RANDOM
    
    This fixes inefficient page-by-page reads on POSIX_FADV_RANDOM.
    
    POSIX_FADV_RANDOM used to set ra_pages=0, which leads to poor performance:
    a 16K read will be carried out in 4 _sync_ 1-page reads.
    
    In other places, ra_pages==0 means
    - it's ramfs/tmpfs/hugetlbfs/sysfs/configfs
    - some IO error happened
    where multi-page read IO won't help or should be avoided.
    
    POSIX_FADV_RANDOM actually want a different semantics: to disable the
    *heuristic* readahead algorithm, and to use a dumb one which faithfully
    submit read IO for whatever application requests.
    
    So introduce a flag FMODE_RANDOM for POSIX_FADV_RANDOM.
    
    Note that the random hint is not likely to help random reads performance
    noticeably.  And it may be too permissive on huge request size (its IO
    size is not limited by read_ahead_kb).
    
    In Quentin's report (http://lkml.org/lkml/2009/12/24/145), the overall
    (NFS read) performance of the application increased by 313%!
    
    Tested-by: Quentin Barnes <qbarnes+nfs@yahoo-inc.com>
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Nick Piggin <npiggin@suse.de>
    Cc: Andi Kleen <andi@firstfloor.org>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: Chuck Lever <chuck.lever@oracle.com>
    Cc: <stable@kernel.org>                 [2.6.33.x]
    Cc: <qbarnes+nfs@yahoo-inc.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45689621a851..be87edcaba06 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -87,6 +87,9 @@ struct inodes_stat_t {
  */
 #define FMODE_NOCMTIME		((__force fmode_t)2048)
 
+/* Expect random access pattern */
+#define FMODE_RANDOM		((__force fmode_t)4096)
+
 /*
  * The below are the various read and write types that we support. Some of
  * them include behavioral modifiers that send information down to the

commit a9185b41a4f84971b930c519f0c63bd450c4810d
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Mar 5 09:21:37 2010 +0100

    pass writeback_control to ->write_inode
    
    This gives the filesystem more information about the writeback that
    is happening.  Trond requested this for the NFS unstable write handling,
    and other filesystems might benefit from this too by beeing able to
    distinguish between the different callers in more detail.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5b3182c7eb5f..45689621a851 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1557,7 +1557,7 @@ struct super_operations {
 	void (*destroy_inode)(struct inode *);
 
    	void (*dirty_inode) (struct inode *);
-	int (*write_inode) (struct inode *, int);
+	int (*write_inode) (struct inode *, struct writeback_control *wbc);
 	void (*drop_inode) (struct inode *);
 	void (*delete_inode) (struct inode *);
 	void (*put_super) (struct super_block *);

commit db1f05bb85d7966b9176e293f3ceead1cb8b5d79
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed Feb 10 12:15:53 2010 +0100

    vfs: add NOFOLLOW flag to umount(2)
    
    Add a new UMOUNT_NOFOLLOW flag to umount(2).  This is needed to prevent
    symlink attacks in unprivileged unmounts (fuse, samba, ncpfs).
    
    Additionally, return -EINVAL if an unknown flag is used (and specify
    an explicitly unused flag: UMOUNT_UNUSED).  This makes it possible for
    the caller to determine if a flag is supported or not.
    
    CC: Eugene Teo <eugene@redhat.com>
    CC: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e764f247d0ab..5b3182c7eb5f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1305,6 +1305,8 @@ extern int send_sigurg(struct fown_struct *fown);
 #define MNT_FORCE	0x00000001	/* Attempt to forcibily umount */
 #define MNT_DETACH	0x00000002	/* Just detach from the tree */
 #define MNT_EXPIRE	0x00000004	/* Mark for expiry */
+#define UMOUNT_NOFOLLOW	0x00000008	/* Don't follow symlink on umount */
+#define UMOUNT_UNUSED	0x80000000	/* Flag guaranteed to be unused */
 
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;

commit 1f707137b55764740981d022d29c622832a61880
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 30 22:51:25 2010 -0500

    new helper: iterate_mounts()
    
    apply function to vfsmounts in set returned by collect_mounts(),
    stop if it returns non-zero.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8d53bc17f93f..e764f247d0ab 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1794,7 +1794,8 @@ extern int may_umount(struct vfsmount *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 extern struct vfsmount *collect_mounts(struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
-
+extern int iterate_mounts(int (*)(struct vfsmount *, void *), void *,
+			  struct vfsmount *);
 extern int vfs_statfs(struct dentry *, struct kstatfs *);
 
 extern int current_umask(void);

commit 2096f759abcb42200a81d776f597362fd9265024
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jan 30 13:16:21 2010 -0500

    New helper: path_is_under(path1, path2)
    
    Analog of is_subdir for vfsmount,dentry pairs, moved from audit_tree.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d443c9dd3caa..8d53bc17f93f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2126,6 +2126,7 @@ extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */
 extern int is_subdir(struct dentry *, struct dentry *);
+extern int path_is_under(struct path *, struct path *);
 extern ino_t find_inode_number(struct dentry *, struct qstr *);
 
 #include <linux/err.h>

commit 2ecdc82ef0b03e67ce5ecee79d0d108177a704df
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 26 17:27:20 2010 +0100

    kill unused invalidate_inode_pages helper
    
    No one is calling this anymore as everyone has switched to
    invalidate_mapping_pages long time ago.  Also update a few
    references to it in comments.  nfs has two more, but I can't
    easily figure what they are actually referring to, so I left
    them as-is.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa76dae673eb..d443c9dd3caa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2058,12 +2058,6 @@ extern int invalidate_inodes(struct super_block *);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
 
-static inline unsigned long __deprecated
-invalidate_inode_pages(struct address_space *mapping)
-{
-	return invalidate_mapping_pages(mapping, 0, ~0UL);
-}
-
 static inline void invalidate_remote_inode(struct inode *inode)
 {
 	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||

commit 270ba5f7c5dac0bfb564aa35a536fb31ad4075bd
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Tue Jan 26 14:12:43 2010 +0000

    fs: re-order super_block to remove 16 bytes of padding on 64bit builds
    
    re-order structure super_block to remove 16 bytes of alignment padding
    on 64bit builds.
    
    This shrinks the size of super_block from 712 to 696 bytes so requiring
    one fewer 64 byte cache lines.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    
    -----
    patch against 2.6.33-rc5
    compiled & tested on x86_64 AMDX2 desktop machine.
    
    I've been running with this patch applied for several weeks with no
    problems.
    
    regards
    Richard
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2b124c825e38..aa76dae673eb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1314,9 +1314,9 @@ extern spinlock_t sb_lock;
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */
 	dev_t			s_dev;		/* search index; _not_ kdev_t */
-	unsigned long		s_blocksize;
-	unsigned char		s_blocksize_bits;
 	unsigned char		s_dirt;
+	unsigned char		s_blocksize_bits;
+	unsigned long		s_blocksize;
 	loff_t			s_maxbytes;	/* Max file size */
 	struct file_system_type	*s_type;
 	const struct super_operations	*s_op;
@@ -1357,16 +1357,16 @@ struct super_block {
 	void 			*s_fs_info;	/* Filesystem private info */
 	fmode_t			s_mode;
 
+	/* Granularity of c/m/atime in ns.
+	   Cannot be worse than a second */
+	u32		   s_time_gran;
+
 	/*
 	 * The next field is for VFS *only*. No filesystems have any business
 	 * even looking at it. You had been warned.
 	 */
 	struct mutex s_vfs_rename_mutex;	/* Kludge */
 
-	/* Granularity of c/m/atime in ns.
-	   Cannot be worse than a second */
-	u32		   s_time_gran;
-
 	/*
 	 * Filesystem subtype.  If non-empty the filesystem type field
 	 * in /proc/mounts will be "type.subtype"

commit 193cf4b99113a4550598ba9e8343e591fc062e23
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Tue Jan 12 16:18:08 2010 +0200

    libfs: Unexport and kill simple_prepare_write
    
    Remove the EXPORT_UNUSED_SYMBOL of simple_prepare_write
    
    Collapse simple_prepare_write into it's only caller, though
    making it simpler and clearer to understand.
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ebb1cd5bc241..2b124c825e38 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2340,8 +2340,6 @@ extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct
 extern int simple_sync_file(struct file *, struct dentry *, int);
 extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
-extern int simple_prepare_write(struct file *file, struct page *page,
-			unsigned offset, unsigned to);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned flags,
 			struct page **pagep, void **fsdata);

commit 4e70af56319e56423d6eb1ce25fc321cdf8cd41d
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Mon Feb 15 11:16:11 2010 +0000

    fs: inode - remove 8 bytes of padding on 64bits allowing 1 more objects/slab under slub
    
    This removes 8 bytes of padding from struct inode on 64bit builds, and
    so allows 1 more object/slab in the inode_cache when using slub.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    ----
    patch against 2.6.33-rc8
    compiled & tested on x86_64 AMDX2
    
    I've been running this patch for over a week with no obvious problems
    regards
    Richard
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b1bcb275b596..ebb1cd5bc241 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -729,6 +729,7 @@ struct inode {
 	uid_t			i_uid;
 	gid_t			i_gid;
 	dev_t			i_rdev;
+	unsigned int		i_blkbits;
 	u64			i_version;
 	loff_t			i_size;
 #ifdef __NEED_I_SIZE_ORDERED
@@ -738,7 +739,6 @@ struct inode {
 	struct timespec		i_mtime;
 	struct timespec		i_ctime;
 	blkcnt_t		i_blocks;
-	unsigned int		i_blkbits;
 	unsigned short          i_bytes;
 	umode_t			i_mode;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */

commit 6d125529c6cbfe570ce3bf9a0728548f087499da
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 24 06:58:56 2009 -0500

    Fix ACC_MODE() for real
    
    commit 5300990c0370e804e49d9a59d928c5d53fb73487 had stepped on a rather
    nasty mess: definitions of ACC_MODE used to be different.  Fixed the
    resulting breakage, converting them to variant that takes O_... value;
    all callers have that and it actually simplifies life (see tomoyo part
    of changes).
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9147ca88f253..b1bcb275b596 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2463,7 +2463,7 @@ int proc_nr_files(struct ctl_table *table, int write,
 
 int __init get_filesystem_list(char *buf);
 
-#define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
+#define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])
 #define OPEN_FMODE(flag) ((__force fmode_t)((flag + 1) & O_ACCMODE))
 
 #endif /* __KERNEL__ */

commit b462707e7ccad058ae151e5c5b06eb5cadcb737f
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Mon Dec 14 15:21:12 2009 +0300

    Add unlocked version of inode_add_bytes() function
    
    Quota code requires unlocked version of this function. Off course
    we can just copy-paste the code, but copy-pasting is always an evil.
    
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7e3012e0ac06..9147ca88f253 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2297,6 +2297,7 @@ extern const struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+void __inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_add_bytes(struct inode *inode, loff_t bytes);
 void inode_sub_bytes(struct inode *inode, loff_t bytes);
 loff_t inode_get_bytes(struct inode *inode);

commit 95ebc3a7930d5965b00bbedbf36bfd3eb9124d65
Author: Andreas Gruenbacher <agruen@suse.de>
Date:   Wed Oct 28 01:46:33 2009 +0100

    Remove obsolete comment in fs.h
    
    This question was determined to be a bug which was fixed in
    commit 4a3b0a49.
    
    Signed-off-by: Andreas Gruenbacher <agruen@suse.de>
    Cc: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9e13b533aaef..7e3012e0ac06 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1624,8 +1624,6 @@ struct super_operations {
  *			on the bit address once it is done.
  *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
- * Q: igrab() only checks on (I_FREEING|I_WILL_FREE).  Should it also check on
- *    I_CLEAR?  If not, why?
  */
 #define I_DIRTY_SYNC		1
 #define I_DIRTY_DATASYNC	2

commit 5300990c0370e804e49d9a59d928c5d53fb73487
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 19 10:15:07 2009 -0500

    Sanitize f_flags helpers
    
    * pull ACC_MODE to fs.h; we have several copies all over the place
    * nightmarish expression calculating f_mode by f_flags deserves a helper
    too (OPEN_FMODE(flags))
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cca191933ff6..9e13b533aaef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2464,5 +2464,8 @@ int proc_nr_files(struct ctl_table *table, int write,
 
 int __init get_filesystem_list(char *buf);
 
+#define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
+#define OPEN_FMODE(flag) ((__force fmode_t)((flag + 1) & O_ACCMODE))
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit eaff8079d4f1016a12e34ab323737314f24127dd
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 17 14:25:01 2009 +0100

    kill I_LOCK
    
    After I_SYNC was split from I_LOCK the leftover is always used together with
    I_NEW and thus superflous.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 77a975089d9a..cca191933ff6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1587,7 +1587,7 @@ struct super_operations {
  * until that flag is cleared.  I_WILL_FREE, I_FREEING and I_CLEAR are set at
  * various stages of removing an inode.
  *
- * Two bits are used for locking and completion notification, I_LOCK and I_SYNC.
+ * Two bits are used for locking and completion notification, I_NEW and I_SYNC.
  *
  * I_DIRTY_SYNC		Inode is dirty, but doesn't have to be written on
  *			fdatasync().  i_atime is the usual cause.
@@ -1596,8 +1596,14 @@ struct super_operations {
  *			don't have to write inode on fdatasync() when only
  *			mtime has changed in it.
  * I_DIRTY_PAGES	Inode has dirty pages.  Inode itself may be clean.
- * I_NEW		get_new_inode() sets i_state to I_LOCK|I_NEW.  Both
- *			are cleared by unlock_new_inode(), called from iget().
+ * I_NEW		Serves as both a mutex and completion notification.
+ *			New inodes set I_NEW.  If two processes both create
+ *			the same inode, one of them will release its inode and
+ *			wait for I_NEW to be released before returning.
+ *			Inodes in I_WILL_FREE, I_FREEING or I_CLEAR state can
+ *			also cause waiting on I_NEW, without I_NEW actually
+ *			being set.  find_inode() uses this to prevent returning
+ *			nearly-dead inodes.
  * I_WILL_FREE		Must be set when calling write_inode_now() if i_count
  *			is zero.  I_FREEING must be set when I_WILL_FREE is
  *			cleared.
@@ -1611,20 +1617,11 @@ struct super_operations {
  *			prohibited for many purposes.  iget() must wait for
  *			the inode to be completely released, then create it
  *			anew.  Other functions will just ignore such inodes,
- *			if appropriate.  I_LOCK is used for waiting.
+ *			if appropriate.  I_NEW is used for waiting.
  *
- * I_LOCK		Serves as both a mutex and completion notification.
- *			New inodes set I_LOCK.  If two processes both create
- *			the same inode, one of them will release its inode and
- *			wait for I_LOCK to be released before returning.
- *			Inodes in I_WILL_FREE, I_FREEING or I_CLEAR state can
- *			also cause waiting on I_LOCK, without I_LOCK actually
- *			being set.  find_inode() uses this to prevent returning
- *			nearly-dead inodes.
- * I_SYNC		Similar to I_LOCK, but limited in scope to writeback
- *			of inode dirty data.  Having a separate lock for this
- *			purpose reduces latency and prevents some filesystem-
- *			specific deadlocks.
+ * I_SYNC		Synchonized write of dirty inode data.  The bits is
+ *			set during data writeback, and cleared with a wakeup
+ *			on the bit address once it is done.
  *
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  * Q: igrab() only checks on (I_FREEING|I_WILL_FREE).  Should it also check on
@@ -1633,13 +1630,12 @@ struct super_operations {
 #define I_DIRTY_SYNC		1
 #define I_DIRTY_DATASYNC	2
 #define I_DIRTY_PAGES		4
-#define I_NEW			8
+#define __I_NEW			3
+#define I_NEW			(1 << __I_NEW)
 #define I_WILL_FREE		16
 #define I_FREEING		32
 #define I_CLEAR			64
-#define __I_LOCK		7
-#define I_LOCK			(1 << __I_LOCK)
-#define __I_SYNC		8
+#define __I_SYNC		7
 #define I_SYNC			(1 << __I_SYNC)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)

commit 7a0ad10c367ab57c899d340372f37880cbe6ab52
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 17 14:24:40 2009 +0100

    fold do_sync_file_range into sys_sync_file_range
    
    We recently go rid of all callers of do_sync_file_range as they're better
    served with vfs_fsync or the filemap_write_and_wait.  Now that
    do_sync_file_range is down to a single caller fold it into it so that people
    don't start using it again accidentally.  While at it also switch it from
    using __filemap_fdatawrite_range(..., WB_SYNC_ALL) to the more clear
    filemap_fdatawrite_range().
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 66bc0a54b284..77a975089d9a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1095,10 +1095,6 @@ struct file_lock {
 
 extern void send_sigio(struct fown_struct *fown, int fd, int band);
 
-/* fs/sync.c */
-extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
-			loff_t endbyte, unsigned int flags);
-
 #ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,

commit bea4c899f2b5fad80099aea979780ef19f9b1987
Merge: 73efc4681cb5 3fc98b1ac036
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 16 13:29:39 2009 -0800

    Merge branch 'for-linus' of git://oss.sgi.com/xfs/xfs
    
    * 'for-linus' of git://oss.sgi.com/xfs/xfs:
      XFS: Free buffer pages array unconditionally
      xfs: kill xfs_bmbt_rec_32/64 types
      xfs: improve metadata I/O merging in the elevator
      xfs: check for not fully initialized inodes in xfs_ireclaim

commit 2ee1abad73a12df5521cd3f017f081f1f684a361
Author: Dave Chinner <dgc@sgi.com>
Date:   Tue Nov 24 18:03:15 2009 +0000

    xfs: improve metadata I/O merging in the elevator
    
    Change all async metadata buffers to use [READ|WRITE]_META I/O types
    so that the I/O doesn't get issued immediately. This allows merging of
    adjacent metadata requests but still prioritises them over bulk data.
    This shows a 10-15% improvement in sequential create speed of small
    files.
    
    Don't include the log buffers in this classification - leave them as
    sync types so they are issued immediately.
    
    Signed-off-by: Dave Chinner <dgc@sgi.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Alex Elder <aelder@sgi.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b23a7018eb90..cf7fc8a7fe6a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -152,6 +152,7 @@ struct inodes_stat_t {
 #define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define WRITE_SYNC	(WRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
 #define WRITE_ODIRECT_PLUG	(WRITE | (1 << BIO_RW_SYNCIO))
+#define WRITE_META	(WRITE | (1 << BIO_RW_META))
 #define SWRITE_SYNC_PLUG	\
 			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))

commit 1e431f5ce78f3ae8254d725060288b78ff74f086
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 3 16:44:53 2009 +0100

    cleanup blockdev_direct_IO locking
    
    Currently the locking in blockdev_direct_IO is a mess, we have three different
    locking types and very confusing checks for some of them.  The most
    complicated one is DIO_OWN_LOCKING for reads, which happens to not actually be
    used.
    
    This patch gets rid of the DIO_OWN_LOCKING - as mentioned above the read case
    is unused anyway, and the write side is almost identical to DIO_NO_LOCKING.
    The difference is that DIO_NO_LOCKING always sets the create argument for
    the get_blocks callback to zero, but we can easily move that to the actual
    get_blocks callbacks.  There are four users of the DIO_NO_LOCKING mode:
    gfs already ignores the create argument and thus is fine with the new
    version, ocfs2 only errors out if create were ever set, and we can remove
    this dead code now, the block device code only ever uses create for an
    error message if we are fully beyond the device which can never happen,
    and last but not least XFS will need the new behavour for writes.
    
    Now we can replace the lock_type variable with a flags one, where no flag
    means the DIO_NO_LOCKING behaviour and DIO_LOCKING is kept as the first
    flag.  Separate out the check for not allowing to fill holes into a separate
    flag, although for now both flags always get set at the same time.
    
    Also revamp the documentation of the locking scheme to actually make sense.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cdc23be4edde..7c8ff12d1995 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2263,9 +2263,11 @@ ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	int lock_type);
 
 enum {
-	DIO_LOCKING = 1, /* need locking between buffered and direct access */
-	DIO_NO_LOCKING,  /* bdev; no locking at all between buffered/direct */
-	DIO_OWN_LOCKING, /* filesystem locks buffered and direct internally */
+	/* need locking between buffered and direct access */
+	DIO_LOCKING	= 0x01,
+
+	/* filesystem does not support filling holes */
+	DIO_SKIP_HOLES	= 0x02,
 };
 
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
@@ -2274,7 +2276,8 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, DIO_LOCKING);
+				    nr_segs, get_block, end_io,
+				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
 
 static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
@@ -2283,16 +2286,7 @@ static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, DIO_NO_LOCKING);
-}
-
-static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
-{
-	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, DIO_OWN_LOCKING);
+				nr_segs, get_block, end_io, 0);
 }
 #endif
 

commit e81e3f4dca6c54116a24aec217d2c15c6f58ada5
Author: Eric Paris <eparis@redhat.com>
Date:   Fri Dec 4 15:47:36 2009 -0500

    fs: move get_empty_filp() deffinition to internal.h
    
    All users outside of fs/ of get_empty_filp() have been removed.  This patch
    moves the definition from the include/ directory to internal.h so no new
    users crop up and removes the EXPORT_SYMBOL.  I'd love to see open intents
    stop using it too, but that's a problem for another day and a smarter
    developer!
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a057f48eb156..cdc23be4edde 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2189,7 +2189,6 @@ static inline void insert_inode_hash(struct inode *inode) {
 	__insert_inode_hash(inode, inode->i_ino);
 }
 
-extern struct file * get_empty_filp(void);
 extern void file_move(struct file *f, struct list_head *list);
 extern void file_kill(struct file *f);
 #ifdef CONFIG_BLOCK

commit 5fe878ae7f82fbf0830dbfaee4c5ca18f3aee442
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Dec 15 16:47:50 2009 -0800

    direct-io: cleanup blockdev_direct_IO locking
    
    Currently the locking in blockdev_direct_IO is a mess, we have three
    different locking types and very confusing checks for some of them.  The
    most complicated one is DIO_OWN_LOCKING for reads, which happens to not
    actually be used.
    
    This patch gets rid of the DIO_OWN_LOCKING - as mentioned above the read
    case is unused anyway, and the write side is almost identical to
    DIO_NO_LOCKING.  The difference is that DIO_NO_LOCKING always sets the
    create argument for the get_blocks callback to zero, but we can easily
    move that to the actual get_blocks callbacks.  There are four users of the
    DIO_NO_LOCKING mode: gfs already ignores the create argument and thus is
    fine with the new version, ocfs2 only errors out if create were ever set,
    and we can remove this dead code now, the block device code only ever uses
    create for an error message if we are fully beyond the device which can
    never happen, and last but not least XFS will need the new behavour for
    writes.
    
    Now we can replace the lock_type variable with a flags one, where no flag
    means the DIO_NO_LOCKING behaviour and DIO_LOCKING is kept as the first
    flag.  Separate out the check for not allowing to fill holes into a
    separate flag, although for now both flags always get set at the same
    time.
    
    Also revamp the documentation of the locking scheme to actually make
    sense.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Badari Pulavarty <pbadari@us.ibm.com>
    Cc: Jeff Moyer <jmoyer@redhat.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Zach Brown <zach.brown@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Alex Elder <aelder@sgi.com>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <joel.becker@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a057f48eb156..b23a7018eb90 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2264,9 +2264,11 @@ ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	int lock_type);
 
 enum {
-	DIO_LOCKING = 1, /* need locking between buffered and direct access */
-	DIO_NO_LOCKING,  /* bdev; no locking at all between buffered/direct */
-	DIO_OWN_LOCKING, /* filesystem locks buffered and direct internally */
+	/* need locking between buffered and direct access */
+	DIO_LOCKING	= 0x01,
+
+	/* filesystem does not support filling holes */
+	DIO_SKIP_HOLES	= 0x02,
 };
 
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
@@ -2275,7 +2277,8 @@ static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, DIO_LOCKING);
+				    nr_segs, get_block, end_io,
+				    DIO_LOCKING | DIO_SKIP_HOLES);
 }
 
 static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
@@ -2284,16 +2287,7 @@ static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, DIO_NO_LOCKING);
-}
-
-static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
-	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_block_t get_block,
-	dio_iodone_t end_io)
-{
-	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_block, end_io, DIO_OWN_LOCKING);
+				nr_segs, get_block, end_io, 0);
 }
 #endif
 

commit 94004ed726f38a841cc51f97c4a3f9eda9fbd0d9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Sep 30 22:16:33 2009 +0200

    kill wait_on_page_writeback_range
    
    All callers really want the more logical filemap_fdatawait_range interface,
    so convert them to use it and merge wait_on_page_writeback_range into
    filemap_fdatawait_range.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 891f7d642e5c..a057f48eb156 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2091,8 +2091,6 @@ extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);
-extern int wait_on_page_writeback_range(struct address_space *mapping,
-				pgoff_t start, pgoff_t end);
 extern int __filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end, int sync_mode);
 extern int filemap_fdatawrite_range(struct address_space *mapping,

commit 98262f2762f0067375f83824d81ea929e37e6bfe
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Thu Dec 3 09:24:48 2009 +0100

    block: Allow devices to indicate whether discarded blocks are zeroed
    
    The discard ioctl is used by mkfs utilities to clear a block device
    prior to putting metadata down.  However, not all devices return zeroed
    blocks after a discard.  Some drives return stale data, potentially
    containing old superblocks.  It is therefore important to know whether
    discarded blocks are properly zeroed.
    
    Both ATA and SCSI drives have configuration bits that indicate whether
    zeroes are returned after a discard operation.  Implement a block level
    interface that allows this information to be bubbled up the stack and
    queried via a new block device ioctl.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 79cea8051736..891f7d642e5c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -304,6 +304,7 @@ struct inodes_stat_t {
 #define BLKIOOPT _IO(0x12,121)
 #define BLKALIGNOFF _IO(0x12,122)
 #define BLKPBSZGET _IO(0x12,123)
+#define BLKDISCARDZEROES _IO(0x12,124)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit d9449ce35a1e8fb58dd2d419f9215562a14ecca0
Author: Vivek Goyal <vgoyal@redhat.com>
Date:   Thu Nov 26 09:45:40 2009 +0100

    Fix regression in direct writes performance due to WRITE_ODIRECT flag removal
    
    There seems to be a regression in direct write path due to following
    commit in for-2.6.33 branch of block tree.
    
    commit 1af60fbd759d31f565552fea315c2033947cfbe6
    Author: Jeff Moyer <jmoyer@redhat.com>
    Date:   Fri Oct 2 18:56:53 2009 -0400
    
        block: get rid of the WRITE_ODIRECT flag
    
    Marking direct writes as WRITE_SYNC_PLUG instead of WRITE_ODIRECT, sets
    the NOIDLE flag in bio and hence in request. This tells CFQ to not expect
    more request from the queue and not idle on it (despite the fact that
    queue's think time is less and it is not seeky).
    
    So direct writers lose big time when competing with sequential readers.
    
    Using fio, I have run one direct writer and two sequential readers and
    following are the results with 2.6.32-rc7 kernel and with for-2.6.33
    branch.
    
    Test
    ====
    1 direct writer and 2 sequential reader running simultaneously.
    
    [global]
    directory=/mnt/sdc/fio/
    runtime=10
    
    [seqwrite]
    rw=write
    size=4G
    direct=1
    
    [seqread]
    rw=read
    size=2G
    numjobs=2
    
    2.6.32-rc7
    ==========
    direct writes: aggrb=2,968KB/s
    readers      : aggrb=101MB/s
    
    for-2.6.33 branch
    =================
    direct write: aggrb=19KB/s
    readers       aggrb=137MB/s
    
    This patch brings back the WRITE_ODIRECT flag, with the difference that we
    don't set the BIO_RW_UNPLUG flag so that device is not unplugged after
    submission of request and an explicit unplug from submitter is required.
    
    That way we fix the jeff's issue of not enough merging taking place in aio
    path as well as make sure direct writes get their fair share.
    
    After the fix
    =============
    for-2.6.33 + fix
    ----------------
    direct writes: aggrb=2,728KB/s
    reads: aggrb=103MB/s
    
    Thanks
    Vivek
    
    Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2f5fca4147c2..79cea8051736 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -129,6 +129,7 @@ struct inodes_stat_t {
  * WRITE_SYNC		Like WRITE_SYNC_PLUG, but also unplugs the device
  *			immediately after submission. The write equivalent
  *			of READ_SYNC.
+ * WRITE_ODIRECT_PLUG	Special case write for O_DIRECT only.
  * SWRITE_SYNC
  * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
  *			See SWRITE.
@@ -150,6 +151,7 @@ struct inodes_stat_t {
 #define READ_META	(READ | (1 << BIO_RW_META))
 #define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define WRITE_SYNC	(WRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
+#define WRITE_ODIRECT_PLUG	(WRITE | (1 << BIO_RW_SYNCIO))
 #define SWRITE_SYNC_PLUG	\
 			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))

commit 1af60fbd759d31f565552fea315c2033947cfbe6
Author: Jeff Moyer <jmoyer@redhat.com>
Date:   Fri Oct 2 18:56:53 2009 -0400

    block: get rid of the WRITE_ODIRECT flag
    
    Hi,
    
    The WRITE_ODIRECT flag is only used in one place, and that code path
    happens to also call blk_run_address_space.  The introduction of this
    flag, then, could result in the device being unplugged twice for every
    I/O.
    
    Further, with the batching changes in the next patch, we don't want an
    O_DIRECT write to imply a queue unplug.
    
    Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2620a8c63571..2f5fca4147c2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -129,7 +129,6 @@ struct inodes_stat_t {
  * WRITE_SYNC		Like WRITE_SYNC_PLUG, but also unplugs the device
  *			immediately after submission. The write equivalent
  *			of READ_SYNC.
- * WRITE_ODIRECT	Special case write for O_DIRECT only.
  * SWRITE_SYNC
  * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
  *			See SWRITE.
@@ -151,7 +150,6 @@ struct inodes_stat_t {
 #define READ_META	(READ | (1 << BIO_RW_META))
 #define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define WRITE_SYNC	(WRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
-#define WRITE_ODIRECT	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
 #define SWRITE_SYNC_PLUG	\
 			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))

commit 58e57fbd1c7e8833314459555e337364fe5521f3
Merge: 8a0382f6fcea 0f78ab9899e9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 4 12:39:14 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-linus' of git://git.kernel.dk/linux-2.6-block: (41 commits)
      Revert "Seperate read and write statistics of in_flight requests"
      cfq-iosched: don't delay async queue if it hasn't dispatched at all
      block: Topology ioctls
      cfq-iosched: use assigned slice sync value, not default
      cfq-iosched: rename 'desktop' sysfs entry to 'low_latency'
      cfq-iosched: implement slower async initiate and queue ramp up
      cfq-iosched: delay async IO dispatch, if sync IO was just done
      cfq-iosched: add a knob for desktop interactiveness
      Add a tracepoint for block request remapping
      block: allow large discard requests
      block: use normal I/O path for discard requests
      swapfile: avoid NULL pointer dereference in swapon when s_bdev is NULL
      fs/bio.c: move EXPORT* macros to line after function
      Add missing blk_trace_remove_sysfs to be in pair with blk_trace_init_sysfs
      cciss: fix build when !PROC_FS
      block: Do not clamp max_hw_sectors for stacking devices
      block: Set max_sectors correctly for stacking devices
      cciss: cciss_host_attr_groups should be const
      cciss: Dynamically allocate the drive_info_struct for each logical drive.
      cciss: Add usage_count attribute to each logical drive in /sys
      ...

commit ac481c20ef8f6c6f2be75d581863f40c43874ef7
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Sat Oct 3 20:52:01 2009 +0200

    block: Topology ioctls
    
    Not all users of the topology information want to use libblkid.  Provide
    the topology information through bdev ioctls.
    
    Also clarify sector size comments for existing BLK ioctls.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2adaa2529f18..883eaacfd924 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -300,6 +300,10 @@ struct inodes_stat_t {
 #define BLKTRACESTOP _IO(0x12,117)
 #define BLKTRACETEARDOWN _IO(0x12,118)
 #define BLKDISCARD _IO(0x12,119)
+#define BLKIOMIN _IO(0x12,120)
+#define BLKIOOPT _IO(0x12,121)
+#define BLKALIGNOFF _IO(0x12,122)
+#define BLKPBSZGET _IO(0x12,123)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit 828c09509b9695271bcbdc53e9fc9a6a737148d2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Oct 1 15:43:56 2009 -0700

    const: constify remaining file_operations
    
    [akpm@linux-foundation.org: fix KVM]
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2adaa2529f18..a1e6899d4b6c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2446,7 +2446,7 @@ static int __fops ## _open(struct inode *inode, struct file *file)	\
 	__simple_attr_check_format(__fmt, 0ull);			\
 	return simple_attr_open(inode, file, __get, __set, __fmt);	\
 }									\
-static struct file_operations __fops = {				\
+static const struct file_operations __fops = {				\
 	.owner	 = THIS_MODULE,						\
 	.open	 = __fops ## _open,					\
 	.release = simple_attr_release,					\

commit 6c5daf012c9155aafd2c7973e4278766c30dfad0
Merge: 6d39b27f0ac7 c08d3b0e33ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 24 08:32:11 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      truncate: use new helpers
      truncate: new helpers
      fs: fix overflow in sys_mount() for in-kernel calls
      fs: Make unload_nls() NULL pointer safe
      freeze_bdev: grab active reference to frozen superblocks
      freeze_bdev: kill bd_mount_sem
      exofs: remove BKL from super operations
      fs/romfs: correct error-handling code
      vfs: seq_file: add helpers for data filling
      vfs: remove redundant position check in do_sendfile
      vfs: change sb->s_maxbytes to a loff_t
      vfs: explicitly cast s_maxbytes in fiemap_check_ranges
      libfs: return error code on failed attr set
      seq_file: return a negative error code when seq_path_root() fails.
      vfs: optimize touch_time() too
      vfs: optimization for touch_atime()
      vfs: split generic_forget_inode() so that hugetlbfs does not have to copy it
      fs/inode.c: add dev-id and inode number for debugging in init_special_inode()
      libfs: make simple_read_from_buffer conventional

commit db16826367fefcb0ddb93d76b66adc52eb4e6339
Merge: cd6045138ed1 465fdd97cbe1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 24 07:53:22 2009 -0700

    Merge branch 'hwpoison' of git://git.kernel.org/pub/scm/linux/kernel/git/ak/linux-mce-2.6
    
    * 'hwpoison' of git://git.kernel.org/pub/scm/linux/kernel/git/ak/linux-mce-2.6: (21 commits)
      HWPOISON: Enable error_remove_page on btrfs
      HWPOISON: Add simple debugfs interface to inject hwpoison on arbitary PFNs
      HWPOISON: Add madvise() based injector for hardware poisoned pages v4
      HWPOISON: Enable error_remove_page for NFS
      HWPOISON: Enable .remove_error_page for migration aware file systems
      HWPOISON: The high level memory error handler in the VM v7
      HWPOISON: Add PR_MCE_KILL prctl to control early kill behaviour per process
      HWPOISON: shmem: call set_page_dirty() with locked page
      HWPOISON: Define a new error_remove_page address space op for async truncation
      HWPOISON: Add invalidate_inode_page
      HWPOISON: Refactor truncate to allow direct truncating of page v2
      HWPOISON: check and isolate corrupted free pages v2
      HWPOISON: Handle hardware poisoned pages in try_to_unmap
      HWPOISON: Use bitmask/action code for try_to_unmap behaviour
      HWPOISON: x86: Add VM_FAULT_HWPOISON handling to x86 page fault handler v2
      HWPOISON: Add poison check to page fault handling
      HWPOISON: Add basic support for poisoned pages in fault handler v3
      HWPOISON: Add new SIGBUS error codes for hardware poison signals
      HWPOISON: Add support for poison swap entries v2
      HWPOISON: Export some rmap vma locking to outside world
      ...

commit 8d65af789f3e2cf4cfbdbf71a0f7a61ebcd41d38
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Sep 23 15:57:19 2009 -0700

    sysctl: remove "struct file *" argument of ->proc_handler
    
    It's unused.
    
    It isn't needed -- read or write flag is already passed and sysctl
    shouldn't care about the rest.
    
    It _was_ used in two places at arch/frv for some reason.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51803528b095..33ed6644abd0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2467,7 +2467,7 @@ ssize_t simple_attr_write(struct file *file, const char __user *buf,
 			  size_t len, loff_t *ppos);
 
 struct ctl_table;
-int proc_nr_files(struct ctl_table *table, int write, struct file *filp,
+int proc_nr_files(struct ctl_table *table, int write,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
 int __init get_filesystem_list(char *buf);

commit 25d9e2d15286281ec834b829a4aaf8969011f1cd
Author: npiggin@suse.de <npiggin@suse.de>
Date:   Fri Aug 21 02:35:05 2009 +1000

    truncate: new helpers
    
    Introduce new truncate helpers truncate_pagecache and inode_newsize_ok.
    vmtruncate is also consolidated from mm/memory.c and mm/nommu.c and
    into mm/truncate.c.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 502d96ef345d..2b08b5ce09b6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2382,7 +2382,8 @@ extern int buffer_migrate_page(struct address_space *,
 #define buffer_migrate_page NULL
 #endif
 
-extern int inode_change_ok(struct inode *, struct iattr *);
+extern int inode_change_ok(const struct inode *, struct iattr *);
+extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern int __must_check inode_setattr(struct inode *, struct iattr *);
 
 extern void file_update_time(struct file *file);

commit 4504230a71566785a05d3e6b53fa1ee071b864eb
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Aug 3 23:28:35 2009 +0200

    freeze_bdev: grab active reference to frozen superblocks
    
    Currently we held s_umount while a filesystem is frozen, despite that we
    might return to userspace and unlock it from a different process.  Instead
    grab an active reference to keep the file system busy and add an explicit
    check for frozen filesystems in remount and reject the remount instead
    of blocking on s_umount.
    
    Add a new get_active_super helper to super.c for use by freeze_bdev that
    grabs an active reference to a superblock from a given block device.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 72dfbd423974..502d96ef345d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2334,6 +2334,7 @@ extern void get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);
+extern struct super_block *get_active_super(struct block_device *bdev);
 extern struct super_block *user_get_super(dev_t);
 extern void drop_super(struct super_block *sb);
 

commit 4fadd7bb20a1e7c774ed88dc703d8fbcd00ff917
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Aug 3 23:28:06 2009 +0200

    freeze_bdev: kill bd_mount_sem
    
    Now that we have the freeze count there is not much reason for bd_mount_sem
    anymore.  The actual freeze/thaw operations are serialized using the
    bd_fsfreeze_mutex, and the only other place we take bd_mount_sem is
    get_sb_bdev which tries to prevent mounting a filesystem while the block
    device is frozen.  Instead of add a check for bd_fsfreeze_count and
    return -EBUSY if a filesystem is frozen.  While that is a change in user
    visible behaviour a failing mount is much better for this case rather
    than having the mount process stuck uninterruptible for a long time.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cbb7724c11d3..72dfbd423974 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -640,7 +640,6 @@ struct block_device {
 	struct super_block *	bd_super;
 	int			bd_openers;
 	struct mutex		bd_mutex;	/* open/close mutex */
-	struct semaphore	bd_mount_sem;
 	struct list_head	bd_inodes;
 	void *			bd_holder;
 	int			bd_holders;

commit 42cb56ae2ab67390da34906b27bedc3f2ff1393b
Author: Jeff Layton <jlayton@redhat.com>
Date:   Fri Sep 18 13:05:53 2009 -0700

    vfs: change sb->s_maxbytes to a loff_t
    
    sb->s_maxbytes is supposed to indicate the maximum size of a file that can
    exist on the filesystem.  It's declared as an unsigned long long.
    
    Even if a filesystem has no inherent limit that prevents it from using
    every bit in that unsigned long long, it's still problematic to set it to
    anything larger than MAX_LFS_FILESIZE.  There are places in the kernel
    that cast s_maxbytes to a signed value.  If it's set too large then this
    cast makes it a negative number and generally breaks the comparison.
    
    Change s_maxbytes to be loff_t instead.  That should help eliminate the
    temptation to set it too large by making it a signed value.
    
    Also, add a warning for couple of releases to help catch filesystems that
    set s_maxbytes too large.  Eventually we can either convert this to a
    BUG() or just remove it and in the hope that no one will get it wrong now
    that it's a signed value.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Cc: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Robert Love <rlove@google.com>
    Cc: Mandeep Singh Baines <msb@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 955e34615cb7..cbb7724c11d3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1315,7 +1315,7 @@ struct super_block {
 	unsigned long		s_blocksize;
 	unsigned char		s_blocksize_bits;
 	unsigned char		s_dirt;
-	unsigned long long	s_maxbytes;	/* Max file size */
+	loff_t			s_maxbytes;	/* Max file size */
 	struct file_system_type	*s_type;
 	const struct super_operations	*s_op;
 	const struct dquot_operations	*dq_op;

commit 22fe404218156328a27e66349b1175cd0baa4990
Author: Jan Kara <jack@suse.cz>
Date:   Fri Sep 18 13:05:44 2009 -0700

    vfs: split generic_forget_inode() so that hugetlbfs does not have to copy it
    
    Hugetlbfs needs to do special things instead of truncate_inode_pages().
     Currently, it copied generic_forget_inode() except for
    truncate_inode_pages() call which is asking for trouble (the code there
    isn't trivial).  So create a separate function generic_detach_inode()
    which does all the list magic done in generic_forget_inode() and call
    it from hugetlbfs_forget_inode().
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51803528b095..955e34615cb7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2156,6 +2156,7 @@ extern ino_t iunique(struct super_block *, ino_t);
 extern int inode_needs_sync(struct inode *inode);
 extern void generic_delete_inode(struct inode *inode);
 extern void generic_drop_inode(struct inode *inode);
+extern int generic_detach_inode(struct inode *inode);
 
 extern struct inode *ilookup5_nowait(struct super_block *sb,
 		unsigned long hashval, int (*test)(struct inode *, void *),

commit 7b021967c5e1463936042c8da72b550d3cabe9ac
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:12 2009 -0700

    const: make lock_manager_operations const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6146dec21c35..51803528b095 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1067,7 +1067,7 @@ struct file_lock {
 	unsigned long fl_break_time;	/* for nonblocking lease breaks */
 
 	const struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
-	struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
+	const struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
 	union {
 		struct nfs_lock_info	nfs_fl;
 		struct nfs4_lock_info	nfs4_fl;

commit 6aed62853c72e29f2c97bbac7712cb398e8c9437
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:11 2009 -0700

    const: make file_lock_operations const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 13c030ebfd28..6146dec21c35 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1066,7 +1066,7 @@ struct file_lock {
 	struct fasync_struct *	fl_fasync; /* for lease break notifications */
 	unsigned long fl_break_time;	/* for nonblocking lease breaks */
 
-	struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
+	const struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
 	struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
 	union {
 		struct nfs_lock_info	nfs_fl;

commit 0d54b217a247f39605361f867fefbb9e099a5432
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:09 2009 -0700

    const: make struct super_block::s_qcop const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 83e1a0cea97a..13c030ebfd28 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1319,7 +1319,7 @@ struct super_block {
 	struct file_system_type	*s_type;
 	const struct super_operations	*s_op;
 	const struct dquot_operations	*dq_op;
- 	struct quotactl_ops	*s_qcop;
+	const struct quotactl_ops	*s_qcop;
 	const struct export_operations *s_export_op;
 	unsigned long		s_flags;
 	unsigned long		s_magic;

commit 61e225dc341107be304fd1088146c2a5e88ff9e0
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 21 17:01:08 2009 -0700

    const: make struct super_block::dq_op const
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 90162fb3bf04..83e1a0cea97a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1318,7 +1318,7 @@ struct super_block {
 	unsigned long long	s_maxbytes;	/* Max file size */
 	struct file_system_type	*s_type;
 	const struct super_operations	*s_op;
-	struct dquot_operations	*dq_op;
+	const struct dquot_operations	*dq_op;
  	struct quotactl_ops	*s_qcop;
 	const struct export_operations *s_export_op;
 	unsigned long		s_flags;

commit 32a88aa1b6dfb901cec64e1898cac78d0f25028a
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Sep 16 15:02:33 2009 +0200

    fs: Assign bdi in super_block
    
    We do this automatically in get_sb_bdev() from the set_bdev_super()
    callback. Filesystems that have their own private backing_dev_info
    must assign that in ->fill_super().
    
    Note that ->s_bdi assignment is required for proper writeback!
    
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index db29588874ac..90162fb3bf04 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1342,6 +1342,7 @@ struct super_block {
 	int			s_nr_dentry_unused;	/* # of dentry on lru */
 
 	struct block_device	*s_bdev;
+	struct backing_dev_info *s_bdi;
 	struct mtd_info		*s_mtd;
 	struct list_head	s_instances;
 	struct quota_info	s_dquot;	/* Diskquota specific options */

commit 2c96ce9f2084c1e04d02883e622f74a537a63aea
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Sep 15 09:43:56 2009 +0200

    fs: remove bdev->bd_inode_backing_dev_info
    
    It has been unused since it was introduced in:
    
    commit 520808bf20e90fdbdb320264ba7dd5cf9d47dcac
    Author: Andrew Morton <akpm@osdl.org>
    Date:   Fri May 21 00:46:17 2004 -0700
    
        [PATCH] block device layer: separate backing_dev_info infrastructure
    
    So lets just kill it.
    
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b21cf6b9c80b..db29588874ac 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -655,7 +655,6 @@ struct block_device {
 	int			bd_invalidated;
 	struct gendisk *	bd_disk;
 	struct list_head	bd_list;
-	struct backing_dev_info *bd_inode_backing_dev_info;
 	/*
 	 * Private data.  You must have bd_claim'ed the block_device
 	 * to use this.  NOTE:  bd_claim allows an owner to claim

commit 257187362123f15d9d1e09918cf87cebbea4e786
Author: Andi Kleen <andi@firstfloor.org>
Date:   Wed Sep 16 11:50:13 2009 +0200

    HWPOISON: Define a new error_remove_page address space op for async truncation
    
    Truncating metadata pages is not safe right now before
    we haven't audited all file systems.
    
    To enable truncation only for data address space define
    a new address_space callback error_remove_page.
    
    This is used for memory_failure.c memory error handling.
    
    This can be then set to truncate_inode_page()
    
    This patch just defines the new operation and adds documentation.
    
    Callers and users come in followon patches.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b21cf6b9c80b..4f47afd37647 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -595,6 +595,7 @@ struct address_space_operations {
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
 					unsigned long);
+	int (*error_remove_page)(struct address_space *, struct page *);
 };
 
 /*

commit 355bbd8cb82e60a592f6cd86ce6dbe5677615cf4
Merge: 39695224bd84 746cd1e7e4a5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 14 17:55:15 2009 -0700

    Merge branch 'for-2.6.32' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.32' of git://git.kernel.dk/linux-2.6-block: (29 commits)
      block: use blkdev_issue_discard in blk_ioctl_discard
      Make DISCARD_BARRIER and DISCARD_NOBARRIER writes instead of reads
      block: don't assume device has a request list backing in nr_requests store
      block: Optimal I/O limit wrapper
      cfq: choose a new next_req when a request is dispatched
      Seperate read and write statistics of in_flight requests
      aoe: end barrier bios with EOPNOTSUPP
      block: trace bio queueing trial only when it occurs
      block: enable rq CPU completion affinity by default
      cfq: fix the log message after dispatched a request
      block: use printk_once
      cciss: memory leak in cciss_init_one()
      splice: update mtime and atime on files
      block: make blk_iopoll_prep_sched() follow normal 0/1 return convention
      cfq-iosched: get rid of must_alloc flag
      block: use interrupts disabled version of raise_softirq_irqoff()
      block: fix comment in blk-iopoll.c
      block: adjust default budget for blk-iopoll
      block: fix long lines in block/blk-iopoll.c
      block: add blk-iopoll, a NAPI like approach for block devices
      ...

commit 18f2ee705d98034b0f229a3202d827468d4bffd9
Author: Jan Kara <jack@suse.cz>
Date:   Tue Aug 18 18:43:15 2009 +0200

    vfs: Remove generic_osync_inode() and sync_page_range{_nolock}()
    
    Remove these three functions since nobody uses them anymore.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e2c7f5167662..37f53216998a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1455,11 +1455,6 @@ int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
 #define DT_SOCK		12
 #define DT_WHT		14
 
-#define OSYNC_METADATA	(1<<0)
-#define OSYNC_DATA	(1<<1)
-#define OSYNC_INODE	(1<<2)
-int generic_osync_inode(struct inode *, struct address_space *, int);
-
 /*
  * This is the "filldir" function type, used by readdir() to let
  * the kernel specify what kind of dirent layout it wants to have.

commit 148f948ba877f4d3cdef036b1ff6d9f68986706a
Author: Jan Kara <jack@suse.cz>
Date:   Mon Aug 17 19:52:36 2009 +0200

    vfs: Introduce new helpers for syncing after writing to O_SYNC file or IS_SYNC inode
    
    Introduce new function for generic inode syncing (vfs_fsync_range) and use
    it from fsync() path. Introduce also new helper for syncing after a sync
    write (generic_write_sync) using the generic function.
    
    Use these new helpers for syncing from generic VFS functions. This makes
    O_SYNC writes to block devices acquire i_mutex for syncing. If we really
    care about this, we can make block_fsync() drop the i_mutex and reacquire
    it before it returns.
    
    CC: Evgeniy Polyakov <zbr@ioremap.net>
    CC: ocfs2-devel@oss.oracle.com
    CC: Joel Becker <joel.becker@oracle.com>
    CC: Felix Blyakher <felixb@sgi.com>
    CC: xfs@oss.sgi.com
    CC: Anton Altaparmakov <aia21@cantab.net>
    CC: linux-ntfs-dev@lists.sourceforge.net
    CC: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    CC: linux-ext4@vger.kernel.org
    CC: tytso@mit.edu
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c1be3a4edea..e2c7f5167662 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2098,7 +2098,10 @@ extern int __filemap_fdatawrite_range(struct address_space *mapping,
 extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
 
+extern int vfs_fsync_range(struct file *file, struct dentry *dentry,
+			   loff_t start, loff_t end, int datasync);
 extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
+extern int generic_write_sync(struct file *file, loff_t pos, loff_t count);
 extern void sync_supers(void);
 extern void emergency_sync(void);
 extern void emergency_remount(void);

commit eef99380679e20e7edc096aa4d8a98b875404d79
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Aug 20 17:43:41 2009 +0200

    vfs: Rename generic_file_aio_write_nolock
    
    generic_file_aio_write_nolock() is now used only by block devices and raw
    character device. Filesystems should use __generic_file_aio_write() in case
    generic_file_aio_write() doesn't suit them. So rename the function to
    blkdev_aio_write() and move it to fs/blockdev.c.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ea099d3a18d9..6c1be3a4edea 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2207,8 +2207,6 @@ extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsig
 extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long,
 		loff_t *);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
-extern ssize_t generic_file_aio_write_nolock(struct kiocb *, const struct iovec *,
-		unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
 		unsigned long *, loff_t, loff_t *, size_t, size_t);
 extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
@@ -2218,6 +2216,10 @@ extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t l
 extern int generic_segment_checks(const struct iovec *iov,
 		unsigned long *nr_segs, size_t *count, int access_flags);
 
+/* fs/block_dev.c */
+extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
+				unsigned long nr_segs, loff_t pos);
+
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);

commit e4dd9de3c66bc7e26c5c7f149a060c5a67cf06a0
Author: Jan Kara <jack@suse.cz>
Date:   Mon Aug 17 18:10:06 2009 +0200

    vfs: Export __generic_file_aio_write() and add some comments
    
    Rename __generic_file_aio_write_nolock() to __generic_file_aio_write(), add
    comments to write helpers explaining how they should be used and export
    __generic_file_aio_write() since it will be used by some filesystems.
    
    CC: ocfs2-devel@oss.oracle.com
    CC: Joel Becker <joel.becker@oracle.com>
    Acked-by: Evgeniy Polyakov <zbr@ioremap.net>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index beb0e2774b2e..ea099d3a18d9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2204,6 +2204,8 @@ extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
+extern ssize_t __generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long,
+		loff_t *);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_aio_write_nolock(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t);

commit d3bccb6f4b886060aa0f58976b92b77d951f5434
Author: Jan Kara <jack@suse.cz>
Date:   Mon Aug 17 19:30:27 2009 +0200

    vfs: Introduce filemap_fdatawait_range
    
    This simple helper saves some filesystems conversion from byte offset
    to page numbers and also makes the fdata* interface more complete.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a79f48373e7e..beb0e2774b2e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2086,6 +2086,8 @@ extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
+extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
+				   loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);

commit 3d2257f157c2324acbc0fa0fa54e8626a987edd2
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat Sep 12 07:35:37 2009 +0200

    Make DISCARD_BARRIER and DISCARD_NOBARRIER writes instead of reads
    
    The commands are conceptually writes, and in the case of IDE and SCSI
    commands actually are writes.  They were only reads because we thought
    that would interact better with the elevators.  Now the elevators know
    about discard requests, that advantage no longer exists.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c1f993515f51..7f5a8ad25008 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -161,8 +161,8 @@ struct inodes_stat_t {
  * These aren't really reads or writes, they pass down information about
  * parts of device that are now unused by the file system.
  */
-#define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
-#define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))
+#define DISCARD_NOBARRIER (WRITE | (1 << BIO_RW_DISCARD))
+#define DISCARD_BARRIER (DISCARD_NOBARRIER | (1 << BIO_RW_BARRIER))
 
 #define SEL_IN		1
 #define SEL_OUT		2

commit a9c86d42599519f3d83b5f46bdab25046fe47b84
Merge: a12e4d304ce7 1110afbe7288
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 11 09:19:35 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6: (377 commits)
      ASoC: au1x: PSC-AC97 bugfixes
      ALSA: dummy - Increase MAX_PCM_SUBSTREAMS to 128
      ALSA: dummy - Add debug proc file
      ALSA: Add const prefix to proc helper functions
      ALSA: Re-export snd_pcm_format_name() function
      ALSA: hda - Use auto model for HP laptops with ALC268 codec
      ALSA: cs46xx - Fix minimum period size
      ASoC: Fix WM835x Out4 capture enumeration
      ALSA: Remove unneeded ifdef from sound/core.h
      ALSA: Remove struct snd_monitor_file from public sound/core.h
      ASoC: Remove unuused hw_read_t
      sound: oxygen: work around MCE when changing volume
      ALSA: dummy - Fake buffer allocations
      ALSA: hda/realtek: Added support for CLEVO M540R subsystem, 6 channel + digital
      ASoC: fix pxa2xx-ac97.c breakage
      ALSA: dummy - Fix the timer calculation in systimer mode
      ALSA: dummy - Add more description
      ALSA: dummy - Better jiffies handling
      ALSA: dummy - Support high-res timer mode
      ALSA: Release v1.0.21
      ...

commit 03ba3782e8dcc5b0e1efe440d33084f066e38cae
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Sep 9 09:08:54 2009 +0200

    writeback: switch to per-bdi threads for flushing data
    
    This gets rid of pdflush for bdi writeout and kupdated style cleaning.
    pdflush writeout suffers from lack of locality and also requires more
    threads to handle the same workload, since it has to work in a
    non-blocking fashion against each queue. This also introduces lumpy
    behaviour and potential request starvation, since pdflush can be starved
    for queue access if others are accessing it. A sample ffsb workload that
    does random writes to files is about 8% faster here on a simple SATA drive
    during the benchmark phase. File layout also seems a LOT more smooth in
    vmstat:
    
     r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa
     0  1      0 608848   2652 375372    0    0     0 71024  604    24  1 10 48 42
     0  1      0 549644   2712 433736    0    0     0 60692  505    27  1  8 48 44
     1  0      0 476928   2784 505192    0    0     4 29540  553    24  0  9 53 37
     0  1      0 457972   2808 524008    0    0     0 54876  331    16  0  4 38 58
     0  1      0 366128   2928 614284    0    0     4 92168  710    58  0 13 53 34
     0  1      0 295092   3000 684140    0    0     0 62924  572    23  0  9 53 37
     0  1      0 236592   3064 741704    0    0     4 58256  523    17  0  8 48 44
     0  1      0 165608   3132 811464    0    0     0 57460  560    21  0  8 54 38
     0  1      0 102952   3200 873164    0    0     4 74748  540    29  1 10 48 41
     0  1      0  48604   3252 926472    0    0     0 53248  469    29  0  7 47 45
    
    where vanilla tends to fluctuate a lot in the creation phase:
    
     r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa
     1  1      0 678716   5792 303380    0    0     0 74064  565    50  1 11 52 36
     1  0      0 662488   5864 319396    0    0     4   352  302   329  0  2 47 51
     0  1      0 599312   5924 381468    0    0     0 78164  516    55  0  9 51 40
     0  1      0 519952   6008 459516    0    0     4 78156  622    56  1 11 52 37
     1  1      0 436640   6092 541632    0    0     0 82244  622    54  0 11 48 41
     0  1      0 436640   6092 541660    0    0     0     8  152    39  0  0 51 49
     0  1      0 332224   6200 644252    0    0     4 102800  728    46  1 13 49 36
     1  0      0 274492   6260 701056    0    0     4 12328  459    49  0  7 50 43
     0  1      0 211220   6324 763356    0    0     0 106940  515    37  1 10 51 39
     1  0      0 160412   6376 813468    0    0     0  8224  415    43  0  6 49 45
     1  1      0  85980   6452 886556    0    0     4 113516  575    39  1 11 54 34
     0  2      0  85968   6452 886620    0    0     0  1640  158   211  0  0 46 54
    
    A 10 disk test with btrfs performs 26% faster with per-bdi flushing. A
    SSD based writeback test on XFS performs over 20% better as well, with
    the throughput being very stable around 1GB/sec, where pdflush only
    manages 750MB/sec and fluctuates wildly while doing so. Random buffered
    writes to many files behave a lot better as well, as does random mmap'ed
    writes.
    
    A separate thread is added to sync the super blocks. In the long term,
    adding sync_supers_bdi() functionality could get rid of this thread again.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56371be1be65..26da98f61116 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1786,6 +1786,7 @@ extern int get_sb_pseudo(struct file_system_type *, char *,
 	struct vfsmount *mnt);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
+void put_super(struct super_block *sb);
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \
@@ -2182,7 +2183,6 @@ extern int bdev_read_only(struct block_device *);
 extern int set_blocksize(struct block_device *, int);
 extern int sb_set_blocksize(struct super_block *, int);
 extern int sb_min_blocksize(struct super_block *, int);
-extern int sb_has_dirty_inodes(struct super_block *);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);

commit 66f3b8e2e103a0b93b945764d98e9ba46cb926dd
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Sep 2 09:19:46 2009 +0200

    writeback: move dirty inodes from super_block to backing_dev_info
    
    This is a first step at introducing per-bdi flusher threads. We should
    have no change in behaviour, although sb_has_dirty_inodes() is now
    ridiculously expensive, as there's no easy way to answer that question.
    Not a huge problem, since it'll be deleted in subsequent patches.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 46ff7dd6e164..56371be1be65 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -715,7 +715,7 @@ struct posix_acl;
 
 struct inode {
 	struct hlist_node	i_hash;
-	struct list_head	i_list;
+	struct list_head	i_list;		/* backing dev IO list */
 	struct list_head	i_sb_list;
 	struct list_head	i_dentry;
 	unsigned long		i_ino;
@@ -1336,9 +1336,6 @@ struct super_block {
 	struct xattr_handler	**s_xattr;
 
 	struct list_head	s_inodes;	/* all inodes */
-	struct list_head	s_dirty;	/* dirty inodes */
-	struct list_head	s_io;		/* parked for writeback */
-	struct list_head	s_more_io;	/* parked for more writeback */
 	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
 	struct list_head	s_files;
 	/* s_dentry_lru and s_nr_dentry_unused are protected by dcache_lock */

commit d8a8559cd7a9ccac98d5f6f13297a2ff68a43627
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Sep 2 12:34:32 2009 +0200

    writeback: get rid of generic_sync_sb_inodes() export
    
    This adds two new exported functions:
    
    - writeback_inodes_sb(), which only attempts to writeback dirty inodes on
      this super_block, for WB_SYNC_NONE writeout.
    - sync_inodes_sb(), which writes out all dirty inodes on this super_block
      and also waits for the IO to complete.
    
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c1f993515f51..46ff7dd6e164 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2071,8 +2071,6 @@ static inline void invalidate_remote_inode(struct inode *inode)
 extern int invalidate_inode_pages2(struct address_space *mapping);
 extern int invalidate_inode_pages2_range(struct address_space *mapping,
 					 pgoff_t start, pgoff_t end);
-extern void generic_sync_sb_inodes(struct super_block *sb,
-				struct writeback_control *wbc);
 extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);

commit 3827119e207823ff0f3e85271bef7a0dc953ee38
Merge: 9d416811f8ca 93fe4483e6fd
Author: Takashi Iwai <tiwai@suse.de>
Date:   Thu Sep 10 15:33:04 2009 +0200

    Merge branch 'topic/soundcore-preclaim' into for-linus
    
    * topic/soundcore-preclaim:
      sound: make OSS device number claiming optional and schedule its removal
      sound: request char-major-* module aliases for missing OSS devices
      chrdev: implement __[un]register_chrdev()

commit 5909ccaa300a4a834ffa275327af4df0b9cb5295
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 28 11:51:25 2009 -0700

    Make 'check_acl()' a first-class filesystem op
    
    This is stage one in flattening out the callchains for the common
    permission testing.  Rather than have most filesystem implement their
    own inode->i_op->permission function that just calls back down to the
    VFS layers 'generic_permission()' with the per-filesystem ACL checking
    function, the filesystem can just expose its 'check_acl' function
    directly, and let the VFS layer do everything for it.
    
    This is all just preparatory - no filesystem actually enables this yet.
    
    Reviewed-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 73e9b643e455..c1f993515f51 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1528,6 +1528,7 @@ struct inode_operations {
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int);
+	int (*check_acl)(struct inode *, int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);

commit 6777d773a463ac045d333b989d4e44660f8d92ad
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Fri Aug 21 14:32:48 2009 -0400

    kernel_read: redefine offset type
    
    vfs_read() offset is defined as loff_t, but kernel_read()
    offset is only defined as unsigned long. Redefine
    kernel_read() offset as loff_t.
    
    Cc: stable@kernel.org
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 67888a9e0655..73e9b643e455 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2123,7 +2123,7 @@ extern struct file *do_filp_open(int dfd, const char *pathname,
 		int open_flag, int mode, int acc_mode);
 extern int may_open(struct path *, int, int);
 
-extern int kernel_read(struct file *, unsigned long, char *, unsigned long);
+extern int kernel_read(struct file *, loff_t, char *, unsigned long);
 extern struct file * open_exec(const char *);
  
 /* fs/dcache.c -- generic fs support functions */

commit 1905b1bfc0de6f69a61dc03cac0d86a04b3216bd
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Aug 6 18:13:23 2009 +0900

    chrdev: implement __[un]register_chrdev()
    
    [un]register_chrdev() assume minor range 0-255.  This patch adds __
    prefixed versions which take @minorbase and @count explicitly.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a36ffa5a77a4..6c36ab788854 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1998,12 +1998,25 @@ extern void bd_release_from_disk(struct block_device *, struct gendisk *);
 #define CHRDEV_MAJOR_HASH_SIZE	255
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
-extern int register_chrdev(unsigned int, const char *,
-			   const struct file_operations *);
-extern void unregister_chrdev(unsigned int, const char *);
+extern int __register_chrdev(unsigned int major, unsigned int baseminor,
+			     unsigned int count, const char *name,
+			     const struct file_operations *fops);
+extern void __unregister_chrdev(unsigned int major, unsigned int baseminor,
+				unsigned int count, const char *name);
 extern void unregister_chrdev_region(dev_t, unsigned);
 extern void chrdev_show(struct seq_file *,off_t);
 
+static inline int register_chrdev(unsigned int major, const char *name,
+				  const struct file_operations *fops)
+{
+	return __register_chrdev(major, 0, 256, name, fops);
+}
+
+static inline void unregister_chrdev(unsigned int major, const char *name)
+{
+	__unregister_chrdev(major, 0, 256, name);
+}
+
 /* fs/block_dev.c */
 #define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
 #define BDEVT_SIZE	10	/* Largest string for MAJ:MIN for blkdev */

commit 2e00c97e2c1d2ffc9e26252ca26b237678b0b772
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 7 14:38:29 2009 -0300

    vfs: add __destroy_inode
    
    When we want to tear down an inode that lost the add to the cache race
    in XFS we must not call into ->destroy_inode because that would delete
    the inode that won the race from the inode cache radix tree.
    
    This patch provides the __destroy_inode helper needed to fix this,
    the actual fix will be in th next patch.  As XFS was the only reason
    destroy_inode was exported we shift the export to the new __destroy_inode.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Eric Sandeen <sandeen@sandeen.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0c3b5e58a986..67888a9e0655 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2164,6 +2164,7 @@ extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
 extern void clear_inode(struct inode *);
 extern void destroy_inode(struct inode *);
+extern void __destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
 extern int should_remove_suid(struct dentry *);
 extern int file_remove_suid(struct file *);

commit 54e346215e4fe2ca8c94c54e546cc61902060510
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 7 14:38:25 2009 -0300

    vfs: fix inode_init_always calling convention
    
    Currently inode_init_always calls into ->destroy_inode if the additional
    initialization fails.  That's not only counter-intuitive because
    inode_init_always did not allocate the inode structure, but in case of
    XFS it's actively harmful as ->destroy_inode might delete the inode from
    a radix-tree that has never been added.  This in turn might end up
    deleting the inode for the same inum that has been instanciated by
    another process and cause lots of cause subtile problems.
    
    Also in the case of re-initializing a reclaimable inode in XFS it would
    free an inode we still want to keep alive.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Eric Sandeen <sandeen@sandeen.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a36ffa5a77a4..0c3b5e58a986 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2137,7 +2137,7 @@ extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
 
-extern struct inode * inode_init_always(struct super_block *, struct inode *);
+extern int inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
 extern void inode_add_to_lists(struct super_block *, struct inode *);
 extern void iput(struct inode *);

commit dddac6a7b445de95515f64fdf82fe5dc36c02f26
Author: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
Date:   Wed Jul 29 21:07:55 2009 +0200

    PM / Hibernate: Replace bdget call with simple atomic_inc of i_count
    
    Create bdgrab().  This function copies an existing reference to a
    block_device.  It is safe to call from any context.
    
    Hibernation code wishes to copy a reference to the active swap device.
    Right now it calls bdget() under a spinlock, but this is wrong because
    bdget() can sleep.  It doesn't need a full bdget() because we already
    hold a reference to active swap devices (and the spinlock protects
    against swapoff).
    
    Fixes http://bugzilla.kernel.org/show_bug.cgi?id=13827
    
    Signed-off-by: Alan Jenkins <alan-jenkins@tuffmail.co.uk>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0872372184fe..a36ffa5a77a4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1946,6 +1946,7 @@ extern void putname(const char *name);
 extern int register_blkdev(unsigned int, const char *);
 extern void unregister_blkdev(unsigned int, const char *);
 extern struct block_device *bdget(dev_t);
+extern struct block_device *bdgrab(struct block_device *bdev);
 extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);

commit f19d4a8fa6f9b6ccf54df0971c97ffcaa390b7b0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jun 8 19:50:45 2009 -0400

    add caching of ACLs in struct inode
    
    No helpers, no conversions yet.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 79e302ddde0f..0872372184fe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -710,6 +710,9 @@ static inline int mapping_writably_mapped(struct address_space *mapping)
 #define i_size_ordered_init(inode) do { } while (0)
 #endif
 
+struct posix_acl;
+#define ACL_NOT_CACHED ((void *)(-1))
+
 struct inode {
 	struct hlist_node	i_hash;
 	struct list_head	i_list;
@@ -772,6 +775,10 @@ struct inode {
 	atomic_t		i_writecount;
 #ifdef CONFIG_SECURITY
 	void			*i_security;
+#endif
+#ifdef CONFIG_FS_POSIX_ACL
+	struct posix_acl	*i_acl;
+	struct posix_acl	*i_default_acl;
 #endif
 	void			*i_private; /* fs or device private pointer */
 };

commit 3e63cbb1efca7dd3137de1bb475e2e068e38ef23
Author: Ankit Jain <me@ankitjain.org>
Date:   Fri Jun 19 14:28:07 2009 -0400

    fs: Add new pre-allocation ioctls to vfs for compatibility with legacy xfs ioctls
    
    This patch adds ioctls to vfs for compatibility with legacy XFS
    pre-allocation ioctls (XFS_IOC_*RESVP*). The implementation
    effectively invokes sys_fallocate for the new ioctls.
    Also handles the compat_ioctl case.
    Note: These legacy ioctls are also implemented by OCFS2.
    
    [AV: folded fixes from hch]
    
    Signed-off-by: Ankit Jain <me@ankitjain.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1ff5e4e01952..79e302ddde0f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1906,6 +1906,8 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
+extern int do_fallocate(struct file *file, int mode, loff_t offset,
+			loff_t len);
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
 			int mode);
 extern struct file *filp_open(const char *, int, int);
@@ -1914,6 +1916,10 @@ extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 
+/* fs/ioctl.c */
+
+extern int ioctl_preallocate(struct file *filp, void __user *argp);
+
 /* fs/dcache.c */
 extern void __init vfs_caches_init_early(void);
 extern void __init vfs_caches_init(unsigned long);

commit 7e0338c0de18c50f09aea1fbef45110cf7d64a3c
Merge: df36b439c5fe 47fcb03fefee
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 12:55:50 2009 -0700

    Merge branch 'for-2.6.31' of git://fieldses.org/git/linux-nfsd
    
    * 'for-2.6.31' of git://fieldses.org/git/linux-nfsd: (60 commits)
      SUNRPC: Fix the TCP server's send buffer accounting
      nfsd41: Backchannel: minorversion support for the back channel
      nfsd41: Backchannel: cleanup nfs4.0 callback encode routines
      nfsd41: Remove ip address collision detection case
      nfsd: optimise the starting of zero threads when none are running.
      nfsd: don't take nfsd_mutex twice when setting number of threads.
      nfsd41: sanity check client drc maxreqs
      nfsd41: move channel attributes from nfsd4_session to a nfsd4_channel_attr struct
      NFS: kill off complicated macro 'PROC'
      sunrpc: potential memory leak in function rdma_read_xdr
      nfsd: minor nfsd_vfs_write cleanup
      nfsd: Pull write-gathering code out of nfsd_vfs_write
      nfsd: track last inode only in use_wgather case
      sunrpc: align cache_clean work's timer
      nfsd: Use write gathering only with NFSv2
      NFSv4: kill off complicated macro 'PROC'
      NFSv4: do exact check about attribute specified
      knfsd: remove unreported filehandle stats counters
      knfsd: fix reply cache memory corruption
      knfsd: reply cache cleanups
      ...

commit 517d08699b250021303f9a7cf0d758b6dc0748ed
Merge: 8eeee4e2f04f a34601c5d841
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 16 19:50:13 2009 -0700

    Merge branch 'akpm'
    
    * akpm: (182 commits)
      fbdev: bf54x-lq043fb: use kzalloc over kmalloc/memset
      fbdev: *bfin*: fix __dev{init,exit} markings
      fbdev: *bfin*: drop unnecessary calls to memset
      fbdev: bfin-t350mcqb-fb: drop unused local variables
      fbdev: blackfin has __raw I/O accessors, so use them in fb.h
      fbdev: s1d13xxxfb: add accelerated bitblt functions
      tcx: use standard fields for framebuffer physical address and length
      fbdev: add support for handoff from firmware to hw framebuffers
      intelfb: fix a bug when changing video timing
      fbdev: use framebuffer_release() for freeing fb_info structures
      radeon: P2G2CLK_ALWAYS_ONb tested twice, should 2nd be P2G2CLK_DAC_ALWAYS_ONb?
      s3c-fb: CPUFREQ frequency scaling support
      s3c-fb: fix resource releasing on error during probing
      carminefb: fix possible access beyond end of carmine_modedb[]
      acornfb: remove fb_mmap function
      mb862xxfb: use CONFIG_OF instead of CONFIG_PPC_OF
      mb862xxfb: restrict compliation of platform driver to PPC
      Samsung SoC Framebuffer driver: add Alpha Channel support
      atmel-lcdc: fix pixclock upper bound detection
      offb: use framebuffer_alloc() to allocate fb_info struct
      ...
    
    Manually fix up conflicts due to kmemcheck in mm/slab.c

commit 286973552f051404abdb58dd9b2f8f7558efe4e5
Author: Mike Waychison <mikew@google.com>
Date:   Tue Jun 16 15:32:59 2009 -0700

    mm: remove __invalidate_mapping_pages variant
    
    Remove __invalidate_mapping_pages atomic variant now that its sole caller
    can sleep (fixed in eccb95cee4f0d56faa46ef22fb94dd4a3578d3eb ("vfs: fix
    lock inversion in drop_pagecache_sb()")).
    
    This fixes softlockups that can occur while in the drop_caches path.
    
    Signed-off-by: Mike Waychison <mikew@google.com>
    Cc: Jan Kara <jack@suse.cz>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8146e0264ef9..f5ae9f19b8a3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2036,9 +2036,6 @@ extern int __invalidate_device(struct block_device *);
 extern int invalidate_partition(struct gendisk *, int);
 #endif
 extern int invalidate_inodes(struct super_block *);
-unsigned long __invalidate_mapping_pages(struct address_space *mapping,
-					pgoff_t start, pgoff_t end,
-					bool be_atomic);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
 

commit 1ebf26a9b338534def47f307c6c8694b6dfc0a79
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Tue Jun 16 15:31:19 2009 -0700

    readahead: make mmap_miss an unsigned int
    
    This makes the performance impact of possible mmap_miss wrap around to be
    temporary and tolerable: i.e.  MMAP_LOTSAMISS=100 extra readarounds.
    
    Otherwise if ever mmap_miss wraps around to negative, it takes INT_MAX
    cache misses to bring it back to normal state.  During the time mmap
    readaround will be _enabled_ for whatever wild random workload.  That's
    almost permanent performance impact.
    
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Ying Han <yinghan@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ede84fa7da5d..8146e0264ef9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -879,7 +879,7 @@ struct file_ra_state {
 					   there are only # of pages ahead */
 
 	unsigned int ra_pages;		/* Maximum readahead window */
-	int mmap_miss;			/* Cache miss stat for mmap accesses */
+	unsigned int mmap_miss;		/* Cache miss stat for mmap accesses */
 	loff_t prev_pos;		/* Cache last read() position */
 };
 

commit 7eef4091a653c243a87e5375c54504cc03bec4d8
Merge: 0a93a47f042c 07a2039b8eb0
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Mon Jun 15 18:08:07 2009 -0700

    Merge commit 'v2.6.30' into for-2.6.31

commit 3446a8aa7ebcbc0a799e5e8fc4f2da0738d6bc21
Author: Vegard Nossum <vegard.nossum@gmail.com>
Date:   Sat May 16 11:22:14 2009 +0200

    fs: introduce __getname_gfp()
    
    The purpose of this change is to allow __getname() users to pass a
    custom GFP mask to kmem_cache_alloc(). This is needed for annotating
    a certain kmemcheck false positive.
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Vegard Nossum <vegard.nossum@gmail.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ede84fa7da5d..6d12174fbe11 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1919,8 +1919,9 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
-#define __getname()	kmem_cache_alloc(names_cachep, GFP_KERNEL)
-#define __putname(name) kmem_cache_free(names_cachep, (void *)(name))
+#define __getname_gfp(gfp)	kmem_cache_alloc(names_cachep, (gfp))
+#define __getname()		__getname_gfp(GFP_KERNEL)
+#define __putname(name)		kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL
 #define putname(name)   __putname(name)
 #else

commit d5aacad548db1ff547adf35d0a77eb2a8ed4fe14
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 7 14:56:44 2009 -0400

    New helper - simple_fsync()
    
    writes associated buffers, then does sync_inode() to write
    the inode itself (and to make it clean).  Depends on
    ->write_inode() honouring the second argument.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d883aa1fc2eb..ede84fa7da5d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2345,6 +2345,8 @@ extern void simple_release_fs(struct vfsmount **mount, int *count);
 extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 			loff_t *ppos, const void *from, size_t available);
 
+extern int simple_fsync(struct file *, struct dentry *, int);
+
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,
 				struct page *, struct page *);

commit 28ad0c118b0ed98b042d362acfe0017591921138
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu May 21 16:01:02 2009 -0400

    fs: Rearrange inode structure elements to avoid waste due to padding
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bcd63706db87..d883aa1fc2eb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -729,8 +729,8 @@ struct inode {
 	struct timespec		i_atime;
 	struct timespec		i_mtime;
 	struct timespec		i_ctime;
-	unsigned int		i_blkbits;
 	blkcnt_t		i_blocks;
+	unsigned int		i_blkbits;
 	unsigned short          i_bytes;
 	umode_t			i_mode;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */

commit 9fd5746fd3d7838bf6ff991d50f1257057d1156f
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Thu May 21 16:01:00 2009 -0400

    fs: Remove i_cindex from struct inode
    
    The only user of the i_cindex element in the inode structure is used
    is by the firewire drivers.  As part of an attempt to slim down the
    inode structure to save memory --- since a typical Linux system will
    have hundreds of thousands if not millions of inodes cached, a
    reduction in the size inode has high leverage.
    
    The firewire driver does not need i_cindex in any fast path, so it's
    simple enough to calculate when it is needed, instead of wasting space
    in the inode structure.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: krh@redhat.com
    Cc: stefanr@s5r6.in-berlin.de
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e7833ef5d1d6..bcd63706db87 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -751,7 +751,6 @@ struct inode {
 		struct block_device	*i_bdev;
 		struct cdev		*i_cdev;
 	};
-	int			i_cindex;
 
 	__u32			i_generation;
 

commit 62c6943b4b1e818aea60c11c5a68a50785b83119
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu May 7 03:12:29 2009 -0400

    Trim a bit of crap from fs.h
    
    do_remount_sb() is fs/internal.h fodder, fsync_no_super() is long gone.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fb1822bed7c8..e7833ef5d1d6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1942,7 +1942,6 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
-extern int fsync_no_super(struct block_device *);
 #else
 static inline void bd_forget(struct inode *inode) {}
 static inline int sync_blockdev(struct block_device *bdev) { return 0; }
@@ -2079,8 +2078,6 @@ extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
 extern void sync_supers(void);
 extern void emergency_sync(void);
 extern void emergency_remount(void);
-extern int do_remount_sb(struct super_block *sb, int flags,
-			 void *data, int force);
 #ifdef CONFIG_BLOCK
 extern sector_t bmap(struct inode *, sector_t);
 #endif

commit 60b0680fa236ac4e17ce31a50048c9d75f9ec831
Author: Jan Kara <jack@suse.cz>
Date:   Mon Apr 27 16:43:53 2009 +0200

    vfs: Rename fsync_super() to sync_filesystem() (version 4)
    
    Rename the function so that it better describe what it really does. Also
    remove the unnecessary include of buffer_head.h.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d3f7159993cf..fb1822bed7c8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1958,7 +1958,7 @@ static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
 	return 0;
 }
 #endif
-extern int fsync_super(struct super_block *);
+extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
 extern const struct file_operations bad_sock_fops;

commit c15c54f5f056ee4819da9fde59a5f2cd45445f23
Author: Jan Kara <jack@suse.cz>
Date:   Mon Apr 27 16:43:52 2009 +0200

    vfs: Move syncing code from super.c to sync.c (version 4)
    
    Move sync_filesystems(), __fsync_super(), fsync_super() from
    super.c to sync.c where it fits better.
    
    [build fixes folded]
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f00df653cf2b..d3f7159993cf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1942,7 +1942,6 @@ extern struct super_block *freeze_bdev(struct block_device *);
 extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
-extern int fsync_super(struct super_block *);
 extern int fsync_no_super(struct block_device *);
 #else
 static inline void bd_forget(struct inode *inode) {}
@@ -1959,6 +1958,7 @@ static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
 	return 0;
 }
 #endif
+extern int fsync_super(struct super_block *);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
 extern const struct file_operations bad_sock_fops;
@@ -2077,7 +2077,6 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 
 extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
 extern void sync_supers(void);
-extern void sync_filesystems(int wait);
 extern void emergency_sync(void);
 extern void emergency_remount(void);
 extern int do_remount_sb(struct super_block *sb, int flags,

commit 5cee5815d1564bbbd505fea86f4550f1efdb5cd0
Author: Jan Kara <jack@suse.cz>
Date:   Mon Apr 27 16:43:51 2009 +0200

    vfs: Make sys_sync() use fsync_super() (version 4)
    
    It is unnecessarily fragile to have two places (fsync_super() and do_sync())
    doing data integrity sync of the filesystem. Alter __fsync_super() to
    accommodate needs of both callers and use it. So after this patch
    __fsync_super() is the only place where we gather all the calls needed to
    properly send all data on a filesystem to disk.
    
    Nice bonus is that we get a complete livelock avoidance and write_supers()
    is now only used for periodic writeback of superblocks.
    
    sync_blockdevs() introduced a couple of patches ago is gone now.
    
    [build fixes folded]
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 41a9907f342e..f00df653cf2b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1321,7 +1321,7 @@ struct super_block {
 	struct rw_semaphore	s_umount;
 	struct mutex		s_lock;
 	int			s_count;
-	int			s_need_sync_fs;
+	int			s_need_sync;
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY
 	void                    *s_security;

commit 429479f031322a0cc5c921ffb2321a51718dc875
Author: Jan Kara <jack@suse.cz>
Date:   Mon Apr 27 16:43:50 2009 +0200

    vfs: Make __fsync_super() a static function (version 4)
    
    __fsync_super() does the same thing as fsync_super(). So change the only
    caller to use fsync_super() and make __fsync_super() static. This removes
    unnecessarily duplicated call to sync_blockdev() and prepares ground
    for the changes to __fsync_super() in the following patches.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 36bcff7036ef..41a9907f342e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2078,7 +2078,6 @@ extern int filemap_fdatawrite_range(struct address_space *mapping,
 extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
 extern void sync_supers(void);
 extern void sync_filesystems(int wait);
-extern void __fsync_super(struct super_block *sb);
 extern void emergency_sync(void);
 extern void emergency_remount(void);
 extern int do_remount_sb(struct super_block *sb, int flags,

commit 876a9f76abbcb775f8d21cbc99fa161f9e5937f1
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 28 18:05:55 2009 +0200

    remove s_async_list
    
    Remove the unused s_async_list in the superblock, a leftover of the
    broken async inode deletion code that leaked into mainline.  Having this
    in the middle of the sync/unmount path is not helpful for the following
    cleanups.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 03fb2102b8f3..36bcff7036ef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1372,11 +1372,6 @@ struct super_block {
 	 * generic_show_options()
 	 */
 	char *s_options;
-
-	/*
-	 * storage for asynchronous operations
-	 */
-	struct list_head s_async_list;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 589ff870ed60a9ebdd5ec99ec3f5afe1282fe151
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Apr 18 03:28:19 2009 -0400

    Switch collect_mounts() to struct path
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 323b5ce474c1..03fb2102b8f3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1800,7 +1800,7 @@ extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
-extern struct vfsmount *collect_mounts(struct vfsmount *, struct dentry *);
+extern struct vfsmount *collect_mounts(struct path *);
 extern void drop_collected_mounts(struct vfsmount *);
 
 extern int vfs_statfs(struct dentry *, struct kstatfs *);

commit 3c5119c05d624f95f4967d16b38c9624b816bdb9
Author: Eric Paris <eparis@redhat.com>
Date:   Thu May 21 17:01:33 2009 -0400

    dnotify: reimplement dnotify using fsnotify
    
    Reimplement dnotify using fsnotify.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 275b0860044c..323b5ce474c1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -760,11 +760,6 @@ struct inode {
 	struct hlist_head	i_fsnotify_mark_entries; /* fsnotify mark entries */
 #endif
 
-#ifdef CONFIG_DNOTIFY
-	unsigned long		i_dnotify_mask; /* Directory notify events */
-	struct dnotify_struct	*i_dnotify; /* for directory notifications */
-#endif
-
 #ifdef CONFIG_INOTIFY
 	struct list_head	inotify_watches; /* watches on this inode */
 	struct mutex		inotify_mutex;	/* protects the watches list */

commit 3be25f49b9d6a97eae9bcb96d3292072b7658bd8
Author: Eric Paris <eparis@redhat.com>
Date:   Thu May 21 17:01:26 2009 -0400

    fsnotify: add marks to inodes so groups can interpret how to handle those inodes
    
    This patch creates a way for fsnotify groups to attach marks to inodes.
    These marks have little meaning to the generic fsnotify infrastructure
    and thus their meaning should be interpreted by the group that attached
    them to the inode's list.
    
    dnotify and inotify  will make use of these markings to indicate which
    inodes are of interest to their respective groups.  But this implementation
    has the useful property that in the future other listeners could actually
    use the marks for the exact opposite reason, aka to indicate which inodes
    it had NO interest in.
    
    Signed-off-by: Eric Paris <eparis@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 83d6b4397245..275b0860044c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -755,6 +755,11 @@ struct inode {
 
 	__u32			i_generation;
 
+#ifdef CONFIG_FSNOTIFY
+	__u32			i_fsnotify_mask; /* all events this inode cares about */
+	struct hlist_head	i_fsnotify_mark_entries; /* fsnotify mark entries */
+#endif
+
 #ifdef CONFIG_DNOTIFY
 	unsigned long		i_dnotify_mask; /* Directory notify events */
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */

commit e4b636366c00738b9609cda307014d71b1225b7f
Merge: b9ed7252d219 279e677faa77
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Fri May 22 20:25:34 2009 +0200

    Merge branch 'master' into for-2.6.31
    
    Conflicts:
            drivers/block/hd.c
            drivers/block/mg_disk.c
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

commit 6818173bd658439b83896a2a7586f64ab51bf29c
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu May 7 15:37:36 2009 +0200

    splice: implement default splice_read method
    
    If f_op->splice_read() is not implemented, fall back to a plain read.
    Use vfs_readv() to read into previously allocated pages.
    
    This will allow splice and functions using splice, such as the loop
    device, to work on all filesystems.  This includes "direct_io" files
    in fuse which bypass the page cache.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bed436f4353..d926c2bea166 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2204,6 +2204,8 @@ extern int generic_segment_checks(const struct iovec *iov,
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
+extern ssize_t default_file_splice_read(struct file *, loff_t *,
+		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,

commit 2a32cebd6cbcc43996c3e2d114fa32ba1e71192a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri May 8 16:05:57 2009 -0400

    Fix races around the access to ->s_options
    
    Put generic_show_options read access to s_options under rcu_read_lock,
    split save_mount_options() into "we are setting it the first time"
    (uses in foo_fill_super()) and "we are relacing and freeing the old one",
    synchronize_rcu() before kfree() in the latter.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed788426f464..3b534e527e09 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2368,6 +2368,7 @@ extern void file_update_time(struct file *file);
 
 extern int generic_show_options(struct seq_file *m, struct vfsmount *mnt);
 extern void save_mount_options(struct super_block *sb, char *options);
+extern void replace_mount_options(struct super_block *sb, char *options);
 
 static inline ino_t parent_ino(struct dentry *dentry)
 {

commit 6e8341a11eb21826b7192d0bb88cb5b44900a9af
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 6 11:16:22 2009 -0400

    Switch open_exec() and sys_uselib() to do_open_filp()
    
    ... and make path_lookup_open() static
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 11484d08042c..ed788426f464 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2118,7 +2118,7 @@ extern struct file *create_write_pipe(int flags);
 extern void free_write_pipe(struct file *);
 
 extern struct file *do_filp_open(int dfd, const char *pathname,
-		int open_flag, int mode);
+		int open_flag, int mode, int acc_mode);
 extern int may_open(struct path *, int, int);
 
 extern int kernel_read(struct file *, unsigned long, char *, unsigned long);

commit 74dbbdd7fdc11763f4698d2f3e684cf4446951e6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 6 01:07:50 2009 -0400

    New helper: deactivate_locked_super()
    
    Does equivalent of up_write(&s->s_umount); deactivate_super(s);
    However, it does not does not unlock it until it's all over.
    As the result, it's safe to use to dispose of new superblock on ->get_sb()
    failure exits - nobody will see the sucker until it's all over.
    Equivalent using up_write/deactivate_super is safe for that purpose
    if superblock is either safe to use or has NULL ->s_root when we unlock.
    Normally filesystems take the required precautions, but
            a) we do have bugs in that area in some of them.
            b) up_write/deactivate_super sequence is extremely common,
    so the helper makes sense anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bed436f4353..11484d08042c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1775,6 +1775,7 @@ void kill_block_super(struct super_block *sb);
 void kill_anon_super(struct super_block *sb);
 void kill_litter_super(struct super_block *sb);
 void deactivate_super(struct super_block *sb);
+void deactivate_locked_super(struct super_block *sb);
 int set_anon_super(struct super_block *s, void *data);
 struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),

commit a9e61e25f9d2e7e43bf17625f5cb56c9e0a89b17
Author: Felix Blyakher <felixb@sgi.com>
Date:   Tue Mar 31 15:12:56 2009 -0500

    lockd: call locks_release_private to cleanup per-filesystem state
    
    For every lock request lockd creates a new file_lock object
    in nlmsvc_setgrantargs() by copying the passed in file_lock with
    locks_copy_lock(). A filesystem can attach it's own lock_operations
    vector to the file_lock. It has to be cleaned up at the end of the
    file_lock's life. However, lockd doesn't do it today, yet it
    asserts in nlmclnt_release_lockargs() that the per-filesystem
    state is clean.
    This patch fixes it by exporting locks_release_private() and adding
    it to nlmsvc_freegrantargs(), to be symmetrical to creating a
    file_lock in nlmsvc_setgrantargs().
    
    Signed-off-by: Felix Blyakher <felixb@sgi.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5bed436f4353..5ba615e8f533 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1108,6 +1108,7 @@ extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
+extern void locks_release_private(struct file_lock *);
 extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);

commit 38e23c95f92a84fb8505a9f572b8a209c9c372c1
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Thu Apr 9 20:17:52 2009 +0900

    fs: Mark get_filesystem_list() as __init function.
    
    "int get_filesystem_list(char * buf)" is called by only
    "static void __init get_fs_names(char *page)".
    We can mark get_filesystem_list() as "__init".
    
    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8f42b35a7565..5bed436f4353 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2448,7 +2448,7 @@ struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
-int get_filesystem_list(char * buf);
+int __init get_filesystem_list(char *buf);
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit 2eae7a1874ca5be3232765d89e0250a449f1bc90
Author: Christoph Hellwig <hch@infradead.org>
Date:   Wed Apr 8 16:34:03 2009 -0400

    kill vfs_stat_fd / vfs_lstat_fd
    
    There's really no reason to keep vfs_stat_fd and vfs_lstat_fd with
    Oleg's vfs_fstatat.  Use vfs_fstatat for the few cases having the
    directory fd, and switch all others to vfs_stat / vfs_lstat.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 257f4d37ad23..8f42b35a7565 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2299,8 +2299,6 @@ extern int vfs_readdir(struct file *, filldir_t, void *);
 
 extern int vfs_stat(char __user *, struct kstat *);
 extern int vfs_lstat(char __user *, struct kstat *);
-extern int vfs_stat_fd(int dfd, char __user *, struct kstat *);
-extern int vfs_lstat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 extern int vfs_fstatat(int , char __user *, struct kstat *, int);
 

commit 0112fc2229847feb6c4eb011e6833d8f1742a375
Author: Oleg Drokin <green@linuxhacker.ru>
Date:   Wed Apr 8 20:05:42 2009 +0400

    Separate out common fstatat code into vfs_fstatat
    
    This is a version incorporating Christoph's suggestion.
    
    Separate out common *fstatat functionality into a single function
    instead of duplicating it all over the code.
    
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e766be0d4329..257f4d37ad23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2302,6 +2302,7 @@ extern int vfs_lstat(char __user *, struct kstat *);
 extern int vfs_stat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_lstat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
+extern int vfs_fstatat(int , char __user *, struct kstat *, int);
 
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);

commit 61e0d47c33cc371f725bcda4a47ae0efe652dba8
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Apr 14 19:48:41 2009 +0200

    splice: add helpers for locking pipe inode
    
    There are lots of sequences like this, especially in splice code:
    
            if (pipe->inode)
                    mutex_lock(&pipe->inode->i_mutex);
            /* do something */
            if (pipe->inode)
                    mutex_unlock(&pipe->inode->i_mutex);
    
    so introduce helpers which do the conditional locking and unlocking.
    Also replace the inode_double_lock() call with a pipe_double_lock()
    helper to avoid spreading the use of this functionality beyond the
    pipe code.
    
    This patch is just a cleanup, and should cause no behavioral changes.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 907d8f56c6fa..e766be0d4329 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -797,9 +797,6 @@ enum inode_i_mutex_lock_class
 	I_MUTEX_QUOTA
 };
 
-extern void inode_double_lock(struct inode *inode1, struct inode *inode2);
-extern void inode_double_unlock(struct inode *inode1, struct inode *inode2);
-
 /*
  * NOTE: in a 32bit arch with a preemptable kernel and
  * an UP compile the i_size_read/write must be atomic

commit f8cc774ce4844811a55e2352f1443055e3994e28
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Apr 14 19:48:40 2009 +0200

    splice: remove generic_file_splice_write_nolock()
    
    Remove the now unused generic_file_splice_write_nolock() function.
    It's conceptually broken anyway, because splice may need to wait for
    pipe events so holding locks across the whole operation is wrong.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b535aec4406b..907d8f56c6fa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2209,8 +2209,6 @@ extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
-extern ssize_t generic_file_splice_write_nolock(struct pipe_inode_info *,
-		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
 		struct file *out, loff_t *, size_t len, unsigned int flags);
 extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,

commit 48e70bc18ac81881dedd3aa327c55b924fc41ecf
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Apr 14 08:19:27 2009 +0200

    Document and move the various READ/WRITE types
    
    It's a somewhat twisty maze of hints and behavioural modifiers, try
    and clear it up a bit with some documentation.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 562d2855cf30..b535aec4406b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -87,6 +87,60 @@ struct inodes_stat_t {
  */
 #define FMODE_NOCMTIME		((__force fmode_t)2048)
 
+/*
+ * The below are the various read and write types that we support. Some of
+ * them include behavioral modifiers that send information down to the
+ * block layer and IO scheduler. Terminology:
+ *
+ *	The block layer uses device plugging to defer IO a little bit, in
+ *	the hope that we will see more IO very shortly. This increases
+ *	coalescing of adjacent IO and thus reduces the number of IOs we
+ *	have to send to the device. It also allows for better queuing,
+ *	if the IO isn't mergeable. If the caller is going to be waiting
+ *	for the IO, then he must ensure that the device is unplugged so
+ *	that the IO is dispatched to the driver.
+ *
+ *	All IO is handled async in Linux. This is fine for background
+ *	writes, but for reads or writes that someone waits for completion
+ *	on, we want to notify the block layer and IO scheduler so that they
+ *	know about it. That allows them to make better scheduling
+ *	decisions. So when the below references 'sync' and 'async', it
+ *	is referencing this priority hint.
+ *
+ * With that in mind, the available types are:
+ *
+ * READ			A normal read operation. Device will be plugged.
+ * READ_SYNC		A synchronous read. Device is not plugged, caller can
+ *			immediately wait on this read without caring about
+ *			unplugging.
+ * READA		Used for read-ahead operations. Lower priority, and the
+ *			 block layer could (in theory) choose to ignore this
+ *			request if it runs into resource problems.
+ * WRITE		A normal async write. Device will be plugged.
+ * SWRITE		Like WRITE, but a special case for ll_rw_block() that
+ *			tells it to lock the buffer first. Normally a buffer
+ *			must be locked before doing IO.
+ * WRITE_SYNC_PLUG	Synchronous write. Identical to WRITE, but passes down
+ *			the hint that someone will be waiting on this IO
+ *			shortly. The device must still be unplugged explicitly,
+ *			WRITE_SYNC_PLUG does not do this as we could be
+ *			submitting more writes before we actually wait on any
+ *			of them.
+ * WRITE_SYNC		Like WRITE_SYNC_PLUG, but also unplugs the device
+ *			immediately after submission. The write equivalent
+ *			of READ_SYNC.
+ * WRITE_ODIRECT	Special case write for O_DIRECT only.
+ * SWRITE_SYNC
+ * SWRITE_SYNC_PLUG	Like WRITE_SYNC/WRITE_SYNC_PLUG, but locks the buffer.
+ *			See SWRITE.
+ * WRITE_BARRIER	Like WRITE, but tells the block layer that all
+ *			previously submitted writes must be safely on storage
+ *			before this one is started. Also guarantees that when
+ *			this write is complete, it itself is also safely on
+ *			storage. Prevents reordering of writes on both sides
+ *			of this IO.
+ *
+ */
 #define RW_MASK		1
 #define RWA_MASK	2
 #define READ 0
@@ -102,6 +156,11 @@ struct inodes_stat_t {
 			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
 #define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
 #define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
+
+/*
+ * These aren't really reads or writes, they pass down information about
+ * parts of device that are now unused by the file system.
+ */
 #define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
 #define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))
 

commit 909e6d94795654040ed416ac69858d5d2ce66dd3
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon Apr 6 19:01:07 2009 -0700

    namespaces: move proc_net_get_sb to a generic fs/super.c helper
    
    The mqueuefs filesystem will use this helper as well.  Proc's main get_sb
    could also be made to use it, but that will require a bit more rework.
    
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Cedric Le Goater <clg@fr.ibm.com>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bce40a2207ee..562d2855cf30 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1699,6 +1699,9 @@ struct file_system_type {
 	struct lock_class_key i_alloc_sem_key;
 };
 
+extern int get_sb_ns(struct file_system_type *fs_type, int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int),
+	struct vfsmount *mnt);
 extern int get_sb_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
 	int (*fill_super)(struct super_block *, void *, int),

commit 12fe32e4f942ac5c71a4ab70b039fee65c0dc29d
Merge: a63856252d21 2121db74ba0f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 6 13:30:00 2009 -0700

    Merge branch 'kmemtrace-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'kmemtrace-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      kmemtrace: trace kfree() calls with NULL or zero-length objects
      kmemtrace: small cleanups
      kmemtrace: restore original tracing data binary format, improve ABI
      kmemtrace: kmemtrace_alloc() must fill type_id
      kmemtrace: use tracepoints
      kmemtrace, rcu: don't include unnecessary headers, allow kmemtrace w/ tracepoints
      kmemtrace, rcu: fix rcupreempt.c data structure dependencies
      kmemtrace, rcu: fix rcu_tree_trace.c data structure dependencies
      kmemtrace, rcu: fix linux/rcutree.h and linux/rcuclassic.h dependencies
      kmemtrace, mm: fix slab.h dependency problem in mm/failslab.c
      kmemtrace, kbuild: fix slab.h dependency problem in lib/decompress_unlzma.c
      kmemtrace, kbuild: fix slab.h dependency problem in lib/decompress_bunzip2.c
      kmemtrace, kbuild: fix slab.h dependency problem in lib/decompress_inflate.c
      kmemtrace, squashfs: fix slab.h dependency problem in squasfs
      kmemtrace, befs: fix slab.h dependency problem
      kmemtrace, security: fix linux/key.h header file dependencies
      kmemtrace, fs: fix linux/fdtable.h header file dependencies
      kmemtrace, fs: uninline simple_transaction_set()
      kmemtrace, fs, security: move alloc_secdata() and free_secdata() to linux/security.h

commit aeb6fafb8fa53266d70ca7474fcda2bdaf96524a
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Apr 6 14:48:07 2009 +0200

    block: Add flag for telling the IO schedulers NOT to anticipate more IO
    
    By default, CFQ will anticipate more IO from a given io context if the
    previously completed IO was sync. This used to be fine, since the only
    sync IO was reads and O_DIRECT writes. But with more "normal" sync writes
    being used now, we don't want to anticipate for those.
    
    Add a bio/request flag that informs the IO scheduler that this is a sync
    request that we should not idle for. Introduce WRITE_ODIRECT specifically
    for O_DIRECT writes, and make sure that the other sync writes set this
    flag.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ea0510978f76..cae5720f431c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -95,11 +95,12 @@ struct inodes_stat_t {
 #define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
 #define READ_SYNC	(READ | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
 #define READ_META	(READ | (1 << BIO_RW_META))
-#define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
-#define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO))
-#define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
+#define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
+#define WRITE_SYNC	(WRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
+#define WRITE_ODIRECT	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
 #define SWRITE_SYNC_PLUG	\
-	(SWRITE | (1 << BIO_RW_SYNCIO))
+			(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_NOIDLE))
+#define SWRITE_SYNC	(SWRITE_SYNC_PLUG | (1 << BIO_RW_UNPLUG))
 #define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
 #define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
 #define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))

commit a1f242524c3c1f5d40f1c9c343427e34d1aadd6e
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Apr 6 14:48:02 2009 +0200

    Add WRITE_SYNC_PLUG and SWRITE_SYNC_PLUG
    
    (S)WRITE_SYNC always unplugs the device right after IO submission.
    Sometimes we want to build up a queue before doing so, so add
    variants that explicitly DON'T unplug the queue. The caller must
    then do that after submitting all the IO.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a09e17c8f5fd..ea0510978f76 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -96,7 +96,10 @@ struct inodes_stat_t {
 #define READ_SYNC	(READ | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
 #define READ_META	(READ | (1 << BIO_RW_META))
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
+#define WRITE_SYNC_PLUG	(WRITE | (1 << BIO_RW_SYNCIO))
 #define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
+#define SWRITE_SYNC_PLUG	\
+	(SWRITE | (1 << BIO_RW_SYNCIO))
 #define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
 #define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
 #define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))

commit 76791ab2d5e00c1eef728a8df4347ba133760fb8
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Mar 25 16:48:35 2009 +0100

    kmemtrace, fs: uninline simple_transaction_set()
    
    Impact: cleanup
    
    We want to remove percpu.h from rcupdate.h (for upcoming kmemtrace
    changes), but this is not possible currently without breaking the
    build because fs.h has an implicit include file depedency: it
    uses PAGE_SIZE but does not include asm/page.h which defines it.
    
    This problem gets masked in practice because most fs.h using sites
    use rcupreempt.h (and other headers) which includes percpu.h which
    brings in asm/page.h indirectly.
    
    We cannot add asm/page.h to asm/fs.h because page.h is not an
    exported header.
    
    Move simple_transaction_set() to the other simple-transaction
    file helpers in fs/libfs.c.
    
    This removes the include file hell and also reduces
    kernel size a bit.
    
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Pekka Enberg <penberg@cs.helsinki.fi>
    Cc: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
    Cc: paulmck@linux.vnet.ibm.com
    LKML-Reference: <1237898630.25315.83.camel@penberg-laptop>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fc4dc28c5735..e4de2b543a73 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2323,19 +2323,7 @@ ssize_t simple_transaction_read(struct file *file, char __user *buf,
 				size_t size, loff_t *pos);
 int simple_transaction_release(struct inode *inode, struct file *file);
 
-static inline void simple_transaction_set(struct file *file, size_t n)
-{
-	struct simple_transaction_argresp *ar = file->private_data;
-
-	BUG_ON(n > SIMPLE_TRANSACTION_LIMIT);
-
-	/*
-	 * The barrier ensures that ar->size will really remain zero until
-	 * ar->data is ready for reading.
-	 */
-	smp_mb();
-	ar->size = n;
-}
+void simple_transaction_set(struct file *file, size_t n);
 
 /*
  * simple attribute files

commit 3d544f411f2971eb82f5c52322251eb04494542a
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Tue Mar 24 11:59:23 2009 +0200

    kmemtrace, fs, security: move alloc_secdata() and free_secdata() to linux/security.h
    
    Impact: cleanup
    
    We want to remove percpu.h from rcupdate.h (for upcoming kmemtrace
    changes), but this is not possible currently without breaking the
    build because fs.h has implicit include file depedencies: it uses
    GFP_* types in inlines but does not include gfp.h.
    
    In practice most fs.h using .c files get gfp.h included implicitly,
    via an indirect route: via rcupdate.h inclusion - so this underlying
    problem gets masked in practice.
    
    So we want to solve fs.h's dependency on gfp.h.
    
    gfp.h can not be included here directly because it is not exported and it
    would break the build the following way:
    
      /home/mingo/tip/usr/include/linux/bsg.h:11: found __[us]{8,16,32,64} type without #include <linux/types.h>
      /home/mingo/tip/usr/include/linux/fs.h:11: included file 'linux/gfp.h' is not exported
      make[3]: *** [/home/mingo/tip/usr/include/linux/.check] Error 1
      make[2]: *** [linux] Error 2
    
    As suggested by Alexey Dobriyan, move alloc_secdata() and free_secdata()
    to linux/security.h - they belong there. This also cleans fs.h of GFP_*
    usage.
    
    Suggested-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Cc: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
    LKML-Reference: <1237906803.25315.96.camel@penberg-laptop>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 61211ad823fe..fc4dc28c5735 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2382,27 +2382,6 @@ ssize_t simple_attr_read(struct file *file, char __user *buf,
 ssize_t simple_attr_write(struct file *file, const char __user *buf,
 			  size_t len, loff_t *ppos);
 
-
-#ifdef CONFIG_SECURITY
-static inline char *alloc_secdata(void)
-{
-	return (char *)get_zeroed_page(GFP_KERNEL);
-}
-
-static inline void free_secdata(void *secdata)
-{
-	free_page((unsigned long)secdata);
-}
-#else
-static inline char *alloc_secdata(void)
-{
-	return (char *)1;
-}
-
-static inline void free_secdata(void *secdata)
-{ }
-#endif	/* CONFIG_SECURITY */
-
 struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);

commit 8fe74cf053de7ad2124a894996f84fa890a81093
Merge: c2eb2fa6d2b6 ced117c73edc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 2 21:09:10 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      Remove two unneeded exports and make two symbols static in fs/mpage.c
      Cleanup after commit 585d3bc06f4ca57f975a5a1f698f65a45ea66225
      Trim includes of fdtable.h
      Don't crap into descriptor table in binfmt_som
      Trim includes in binfmt_elf
      Don't mess with descriptor table in load_elf_binary()
      Get rid of indirect include of fs_struct.h
      New helper - current_umask()
      check_unsafe_exec() doesn't care about signal handlers sharing
      New locking/refcounting for fs_struct
      Take fs_struct handling to new file (fs/fs_struct.c)
      Get rid of bumping fs_struct refcount in pivot_root(2)
      Kill unsharing fs_struct in __set_personality()

commit c2d7543851849a6923680cdd7e1047ed1a84a1c5
Author: Eric Sandeen <sandeen@redhat.com>
Date:   Tue Mar 31 15:23:46 2009 -0700

    filesystem freeze: allow SysRq emergency thaw to thaw frozen filesystems
    
    Now that the filesystem freeze operation has been elevated to the VFS, and
    is just an ioctl away, some sort of safety net for unintentionally frozen
    root filesystems may be in order.
    
    The timeout thaw originally proposed did not get merged, but perhaps
    something like this would be useful in emergencies.
    
    For example, freeze /path/to/mountpoint may freeze your root filesystem if
    you forgot that you had that unmounted.
    
    I chose 'j' as the last remaining character other than 'h' which is sort
    of reserved for help (because help is generated on any unknown character).
    
    I've tested this on a non-root fs with multiple (nested) freezers, as well
    as on a system rendered unresponsive due to a frozen root fs.
    
    [randy.dunlap@oracle.com: emergency thaw only if CONFIG_BLOCK enabled]
    Signed-off-by: Eric Sandeen <sandeen@redhat.com>
    Cc: Takashi Sato <t-sato@yk.jp.nec.com>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 87e7bfc5ebd7..61211ad823fe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1878,6 +1878,7 @@ extern struct block_device *open_by_devnum(dev_t, fmode_t);
 extern void invalidate_bdev(struct block_device *);
 extern int sync_blockdev(struct block_device *bdev);
 extern struct super_block *freeze_bdev(struct block_device *);
+extern void emergency_thaw_all(void);
 extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
 extern int fsync_bdev(struct block_device *);
 extern int fsync_super(struct super_block *);

commit 47e4491b40df73c3b117e3d80b31b5b512a4b19f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Apr 1 07:07:16 2009 -0400

    Cleanup after commit 585d3bc06f4ca57f975a5a1f698f65a45ea66225
    
    fsync_bdev() export and a bunch of stubs for !CONFIG_BLOCK case had
    been left behind
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3d7bd5447ca3..674134725597 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1886,6 +1886,18 @@ extern int fsync_super(struct super_block *);
 extern int fsync_no_super(struct block_device *);
 #else
 static inline void bd_forget(struct inode *inode) {}
+static inline int sync_blockdev(struct block_device *bdev) { return 0; }
+static inline void invalidate_bdev(struct block_device *bdev) {}
+
+static inline struct super_block *freeze_bdev(struct block_device *sb)
+{
+	return NULL;
+}
+
+static inline int thaw_bdev(struct block_device *bdev, struct super_block *sb)
+{
+	return 0;
+}
 #endif
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;

commit ce3b0f8d5c2203301fc87f3aaaed73e5819e2a48
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 29 19:08:22 2009 -0400

    New helper - current_umask()
    
    current->fs->umask is what most of fs_struct users are doing.
    Put that into a helper function.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 87e7bfc5ebd7..3d7bd5447ca3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1741,6 +1741,8 @@ extern void drop_collected_mounts(struct vfsmount *);
 
 extern int vfs_statfs(struct dentry *, struct kstatfs *);
 
+extern int current_umask(void);
+
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 

commit 2d25ee36c84d5b2d6be8bfaf80256ecad69a06ca
Merge: 915db32ddbc9 4a6a4499693a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 11:31:47 2009 -0700

    Merge branch 'bkl-removal' of git://git.lwn.net/linux-2.6
    
    * 'bkl-removal' of git://git.lwn.net/linux-2.6:
      Fix a lockdep warning in fasync_helper()
      Add a missing unlock_kernel() in raw_open()

commit 4a6a4499693a419a20559c41e33a7bd70bf20a6f
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri Mar 27 12:24:31 2009 -0600

    Fix a lockdep warning in fasync_helper()
    
    Lockdep gripes if file->f_lock is taken in a no-IRQ situation, since that
    is not always the case.  We don't really want to disable IRQs for every
    acquisition of f_lock; instead, just move it outside of fasync_lock.
    
    Reported-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Reported-by: Larry Finger <Larry.Finger@lwfinger.net>
    Reported-by: Wu Fengguang <fengguang.wu@intel.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7428c6d35e65..2f13c1d77812 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -848,7 +848,7 @@ struct file {
 #define f_dentry	f_path.dentry
 #define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
-	spinlock_t		f_lock;  /* f_ep_links, f_flags */
+	spinlock_t		f_lock;  /* f_ep_links, f_flags, no IRQ */
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;

commit 3ae5080f4c2e293229508dabe7c8a90af4e4c460
Merge: 2c9e15a011c5 aabb8fdb4112
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 27 16:23:12 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6: (37 commits)
      fs: avoid I_NEW inodes
      Merge code for single and multiple-instance mounts
      Remove get_init_pts_sb()
      Move common mknod_ptmx() calls into caller
      Parse mount options just once and copy them to super block
      Unroll essentials of do_remount_sb() into devpts
      vfs: simple_set_mnt() should return void
      fs: move bdev code out of buffer.c
      constify dentry_operations: rest
      constify dentry_operations: configfs
      constify dentry_operations: sysfs
      constify dentry_operations: JFS
      constify dentry_operations: OCFS2
      constify dentry_operations: GFS2
      constify dentry_operations: FAT
      constify dentry_operations: FUSE
      constify dentry_operations: procfs
      constify dentry_operations: ecryptfs
      constify dentry_operations: CIFS
      constify dentry_operations: AFS
      ...

commit a3ec947c85ec339884b30ef6a08133e9311fdae1
Author: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
Date:   Wed Mar 4 12:06:34 2009 -0800

    vfs: simple_set_mnt() should return void
    
    simple_set_mnt() is defined as returning 'int' but always returns 0.
    Callers assume simple_set_mnt() never fails and don't properly cleanup if
    it were to _ever_ fail.  For instance, get_sb_single() and get_sb_nodev()
    should:
    
            up_write(sb->s_unmount);
            deactivate_super(sb);
    
    if simple_set_mnt() fails.
    
    Since simple_set_mnt() never fails, would be cleaner if it did not
    return anything.
    
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c2c4454a268a..a7d73914a9f7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1719,7 +1719,7 @@ struct super_block *sget(struct file_system_type *type,
 extern int get_sb_pseudo(struct file_system_type *, char *,
 	const struct super_operations *ops, unsigned long,
 	struct vfsmount *mnt);
-extern int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
+extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */

commit 585d3bc06f4ca57f975a5a1f698f65a45ea66225
Author: Nick Piggin <npiggin@suse.de>
Date:   Wed Feb 25 10:44:19 2009 +0100

    fs: move bdev code out of buffer.c
    
    Move some block device related code out from buffer.c and put it in
    block_dev.c. I'm trying to move non-buffer_head code out of buffer.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5f74d616cd7d..c2c4454a268a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1874,6 +1874,13 @@ extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, fmode_t);
+extern void invalidate_bdev(struct block_device *);
+extern int sync_blockdev(struct block_device *bdev);
+extern struct super_block *freeze_bdev(struct block_device *);
+extern int thaw_bdev(struct block_device *bdev, struct super_block *sb);
+extern int fsync_bdev(struct block_device *);
+extern int fsync_super(struct super_block *);
+extern int fsync_no_super(struct block_device *);
 #else
 static inline void bd_forget(struct inode *inode) {}
 #endif

commit af5df56688acfb75c1b15b4e000ec5e82a9cdc29
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jan 20 10:29:46 2009 +0000

    vfs: Further changes from macro to inline function in fs.h
    
    There is a second set of macros for when CONFIG_FILE_LOCKING is
    not set. This patch updates those to become inline functions
    as well.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d84020b7e676..5f74d616cd7d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1800,13 +1800,44 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 	return 0;
 }
 #else /* !CONFIG_FILE_LOCKING */
-#define locks_mandatory_locked(a) ({ 0; })
-#define locks_mandatory_area(a, b, c, d, e) ({ 0; })
-#define __mandatory_lock(a) ({ 0; })
-#define mandatory_lock(a) ({ 0; })
-#define locks_verify_locked(a) ({ 0; })
-#define locks_verify_truncate(a, b, c) ({ 0; })
-#define break_lease(a, b) ({ 0; })
+static inline int locks_mandatory_locked(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int locks_mandatory_area(int rw, struct inode *inode,
+				       struct file *filp, loff_t offset,
+				       size_t count)
+{
+	return 0;
+}
+
+static inline int __mandatory_lock(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int mandatory_lock(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int locks_verify_locked(struct inode *inode)
+{
+	return 0;
+}
+
+static inline int locks_verify_truncate(struct inode *inode, struct file *filp,
+					size_t size)
+{
+	return 0;
+}
+
+static inline int break_lease(struct inode *inode, unsigned int mode)
+{
+	return 0;
+}
+
 #endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */

commit c2aca5e529a2499d454c41e01f59f1d5fe4a1364
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Jan 20 10:29:45 2009 +0000

    vfs: Update fs.h to use inline functions when no file locking set
    
    This avoids various issues which might give rise to compiler warnings
    about missing functions and/or unused variable with the previous
    macros. This also fixes a bug where one of the macros was returning
    0, but it should have been void.
    
    Reported-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Tested-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51de83bd8a87..d84020b7e676 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1063,34 +1063,147 @@ extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
 #else /* !CONFIG_FILE_LOCKING */
-#define fcntl_getlk(a, b) ({ -EINVAL; })
-#define fcntl_setlk(a, b, c, d) ({ -EACCES; })
+static inline int fcntl_getlk(struct file *file, struct flock __user *user)
+{
+	return -EINVAL;
+}
+
+static inline int fcntl_setlk(unsigned int fd, struct file *file,
+			      unsigned int cmd, struct flock __user *user)
+{
+	return -EACCES;
+}
+
 #if BITS_PER_LONG == 32
-#define fcntl_getlk64(a, b) ({ -EINVAL; })
-#define fcntl_setlk64(a, b, c, d) ({ -EACCES; })
+static inline int fcntl_getlk64(struct file *file, struct flock64 __user *user)
+{
+	return -EINVAL;
+}
+
+static inline int fcntl_setlk64(unsigned int fd, struct file *file,
+				unsigned int cmd, struct flock64 __user *user)
+{
+	return -EACCES;
+}
 #endif
-#define fcntl_setlease(a, b, c) ({ 0; })
-#define fcntl_getlease(a) ({ 0; })
-#define locks_init_lock(a) ({ })
-#define __locks_copy_lock(a, b) ({ })
-#define locks_copy_lock(a, b) ({ })
-#define locks_remove_posix(a, b) ({ })
-#define locks_remove_flock(a) ({ })
-#define posix_test_lock(a, b) ({ 0; })
-#define posix_lock_file(a, b, c) ({ -ENOLCK; })
-#define posix_lock_file_wait(a, b) ({ -ENOLCK; })
-#define posix_unblock_lock(a, b) (-ENOENT)
-#define vfs_test_lock(a, b) ({ 0; })
-#define vfs_lock_file(a, b, c, d) (-ENOLCK)
-#define vfs_cancel_lock(a, b) ({ 0; })
-#define flock_lock_file_wait(a, b) ({ -ENOLCK; })
-#define __break_lease(a, b) ({ 0; })
-#define lease_get_mtime(a, b) ({ })
-#define generic_setlease(a, b, c) ({ -EINVAL; })
-#define vfs_setlease(a, b, c) ({ -EINVAL; })
-#define lease_modify(a, b) ({ -EINVAL; })
-#define lock_may_read(a, b, c) ({ 1; })
-#define lock_may_write(a, b, c) ({ 1; })
+static inline int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
+{
+	return 0;
+}
+
+static inline int fcntl_getlease(struct file *filp)
+{
+	return 0;
+}
+
+static inline void locks_init_lock(struct file_lock *fl)
+{
+	return;
+}
+
+static inline void __locks_copy_lock(struct file_lock *new, struct file_lock *fl)
+{
+	return;
+}
+
+static inline void locks_copy_lock(struct file_lock *new, struct file_lock *fl)
+{
+	return;
+}
+
+static inline void locks_remove_posix(struct file *filp, fl_owner_t owner)
+{
+	return;
+}
+
+static inline void locks_remove_flock(struct file *filp)
+{
+	return;
+}
+
+static inline void posix_test_lock(struct file *filp, struct file_lock *fl)
+{
+	return;
+}
+
+static inline int posix_lock_file(struct file *filp, struct file_lock *fl,
+				  struct file_lock *conflock)
+{
+	return -ENOLCK;
+}
+
+static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
+{
+	return -ENOLCK;
+}
+
+static inline int posix_unblock_lock(struct file *filp,
+				     struct file_lock *waiter)
+{
+	return -ENOENT;
+}
+
+static inline int vfs_test_lock(struct file *filp, struct file_lock *fl)
+{
+	return 0;
+}
+
+static inline int vfs_lock_file(struct file *filp, unsigned int cmd,
+				struct file_lock *fl, struct file_lock *conf)
+{
+	return -ENOLCK;
+}
+
+static inline int vfs_cancel_lock(struct file *filp, struct file_lock *fl)
+{
+	return 0;
+}
+
+static inline int flock_lock_file_wait(struct file *filp,
+				       struct file_lock *request)
+{
+	return -ENOLCK;
+}
+
+static inline int __break_lease(struct inode *inode, unsigned int mode)
+{
+	return 0;
+}
+
+static inline void lease_get_mtime(struct inode *inode, struct timespec *time)
+{
+	return;
+}
+
+static inline int generic_setlease(struct file *filp, long arg,
+				    struct file_lock **flp)
+{
+	return -EINVAL;
+}
+
+static inline int vfs_setlease(struct file *filp, long arg,
+			       struct file_lock **lease)
+{
+	return -EINVAL;
+}
+
+static inline int lease_modify(struct file_lock **before, int arg)
+{
+	return -EINVAL;
+}
+
+static inline int lock_may_read(struct inode *inode, loff_t start,
+				unsigned long len)
+{
+	return 1;
+}
+
+static inline int lock_may_write(struct inode *inode, loff_t start,
+				 unsigned long len)
+{
+	return 1;
+}
+
 #endif /* !CONFIG_FILE_LOCKING */
 
 

commit 10f303ae1e5e77a9f7cb053e6329906afb132c67
Author: Cheng Renquan <crquan@gmail.com>
Date:   Wed Jan 14 17:01:33 2009 +0800

    do_pipe cleanup: drop its last user in arch/alpha/
    
    The last user of do_pipe is in arch/alpha/, after replacing it with
    do_pipe_flags, the do_pipe can be totally dropped.
    
    Signed-off-by: Cheng Renquan <crquan@gmail.com>
    Acked-by: Richard Henderson <rth@twiddle.net>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 92734c0012e6..51de83bd8a87 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1881,7 +1881,6 @@ static inline void allow_write_access(struct file *file)
 	if (file)
 		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
 }
-extern int do_pipe(int *);
 extern int do_pipe_flags(int *, int);
 extern struct file *create_read_pipe(struct file *f, int flags);
 extern struct file *create_write_pipe(int flags);

commit 8e9d2089723d08d51e66c5eea49253d76e27941e
Merge: ba1eb95cf3cc 60aa49243d09
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 26 16:14:02 2009 -0700

    Merge branch 'bkl-removal' of git://git.lwn.net/linux-2.6
    
    * 'bkl-removal' of git://git.lwn.net/linux-2.6:
      Rationalize fasync return values
      Move FASYNC bit handling to f_op->fasync()
      Use f_lock to protect f_flags
      Rename struct file->f_ep_lock

commit d0adde574b8487ef30f69e2d08bba769e4be513f
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Mar 26 17:49:56 2009 +0000

    Add a strictatime mount option
    
    Add support for explicitly requesting full atime updates. This makes it
    possible for kernels to default to relatime but still allow userspace to
    override it.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 92734c0012e6..5bc81c4a98c1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -141,6 +141,7 @@ struct inodes_stat_t {
 #define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
 #define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
 #define MS_I_VERSION	(1<<23) /* Update inode I_version field */
+#define MS_STRICTATIME	(1<<24) /* Always perform atime updates */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 

commit db1dd4d376134eba0e08af523b61cc566a4ea1cd
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri Feb 6 15:25:24 2009 -0700

    Use f_lock to protect f_flags
    
    Traditionally, changes to struct file->f_flags have been done under BKL
    protection, or with no protection at all.  This patch causes all f_flags
    changes after file open/creation time to be done under protection of
    f_lock.  This allows the removal of some BKL usage and fixes a number of
    longstanding (if microscopic) races.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2011600d12c7..7428c6d35e65 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -848,7 +848,7 @@ struct file {
 #define f_dentry	f_path.dentry
 #define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
-	spinlock_t		f_lock;  /* f_ep_links */
+	spinlock_t		f_lock;  /* f_ep_links, f_flags */
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;

commit 684999149002dd046269666a390458e0acb38280
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri Feb 6 13:52:43 2009 -0700

    Rename struct file->f_ep_lock
    
    This lock moves out of the CONFIG_EPOLL ifdef and becomes f_lock.  For now,
    epoll remains the only user, but a future patch will use it to protect
    f_flags as well.
    
    Cc: Davide Libenzi <davidel@xmailserver.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 92734c0012e6..2011600d12c7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -848,6 +848,7 @@ struct file {
 #define f_dentry	f_path.dentry
 #define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
+	spinlock_t		f_lock;  /* f_ep_links */
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	fmode_t			f_mode;
@@ -866,7 +867,6 @@ struct file {
 #ifdef CONFIG_EPOLL
 	/* Used by fs/eventpoll.c to link all the hooks to this file */
 	struct list_head	f_ep_links;
-	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
 #ifdef CONFIG_DEBUG_WRITECOUNT

commit ba95fd47d177d46743ad94055908d22840370e06
Merge: 59af0a0b5848 be987fdb55a4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 18 18:33:04 2009 -0800

    Merge branch 'for-linus' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-linus' of git://git.kernel.dk/linux-2.6-block:
      block: fix deadlock in blk_abort_queue() for drivers that readd to timeout list
      block: fix booting from partitioned md array
      block: revert part of 18ce3751ccd488c78d3827e9f6bf54e6322676fb
      cciss: PCI power management reset for kexec
      paride/pg.c: xs(): &&/|| confusion
      fs/bio: bio_alloc_bioset: pass right object ptr to mempool_free
      block: fix bad definition of BIO_RW_SYNC
      bsg: Fix sense buffer bug in SG_IO

commit 55ec82176eca52e4e0530a82a0eb59160a1a95a1
Author: Paul Turner <pjt@google.com>
Date:   Wed Feb 18 14:48:15 2009 -0800

    vfs: separate FMODE_PREAD/FMODE_PWRITE into separate flags
    
    Separate FMODE_PREAD and FMODE_PWRITE into separate flags to reflect the
    reality that the read and write paths may have independent restrictions.
    
    A git grep verifies that these flags are always cleared together so this
    new behavior will only apply to interfaces that change to clear flags
    individually.
    
    This is required for "seq_file: properly cope with pread", a post-2.6.25
    regression fix.
    
    [akpm@linux-foundation.org: add comment]
    Signed-off-by: Paul Turner <pjt@google.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc:  Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@kernel.org>         [2.6.25.x, 2.6.26.x, 2.6.27.x, 2.6.28.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6022f44043f2..5852bd6afbe4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -54,24 +54,30 @@ struct inodes_stat_t {
 #define MAY_ACCESS 16
 #define MAY_OPEN 32
 
+/*
+ * flags in file.f_mode.  Note that FMODE_READ and FMODE_WRITE must correspond
+ * to O_WRONLY and O_RDWR via the strange trick in __dentry_open()
+ */
+
 /* file is open for reading */
 #define FMODE_READ		((__force fmode_t)1)
 /* file is open for writing */
 #define FMODE_WRITE		((__force fmode_t)2)
 /* file is seekable */
 #define FMODE_LSEEK		((__force fmode_t)4)
-/* file can be accessed using pread/pwrite */
+/* file can be accessed using pread */
 #define FMODE_PREAD		((__force fmode_t)8)
-#define FMODE_PWRITE		FMODE_PREAD	/* These go hand in hand */
+/* file can be accessed using pwrite */
+#define FMODE_PWRITE		((__force fmode_t)16)
 /* File is opened for execution with sys_execve / sys_uselib */
-#define FMODE_EXEC		((__force fmode_t)16)
+#define FMODE_EXEC		((__force fmode_t)32)
 /* File is opened with O_NDELAY (only set for block devices) */
-#define FMODE_NDELAY		((__force fmode_t)32)
+#define FMODE_NDELAY		((__force fmode_t)64)
 /* File is opened with O_EXCL (only set for block devices) */
-#define FMODE_EXCL		((__force fmode_t)64)
+#define FMODE_EXCL		((__force fmode_t)128)
 /* File is opened using open(.., 3, ..) and is writeable only for ioctls
    (specialy hack for floppy.c) */
-#define FMODE_WRITE_IOCTL	((__force fmode_t)128)
+#define FMODE_WRITE_IOCTL	((__force fmode_t)256)
 
 /*
  * Don't update ctime and mtime.

commit 93dbb393503d53cd226e5e1f0088fe8f4dbaa2b8
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Feb 16 10:25:40 2009 +0100

    block: fix bad definition of BIO_RW_SYNC
    
    We can't OR shift values, so get rid of BIO_RW_SYNC and use BIO_RW_SYNCIO
    and BIO_RW_UNPLUG explicitly. This brings back the behaviour from before
    213d9417fec62ef4c3675621b9364a667954d4dd.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6022f44043f2..67857dc16365 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -87,10 +87,10 @@ struct inodes_stat_t {
 #define WRITE 1
 #define READA 2		/* read-ahead  - don't block if no resources */
 #define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
-#define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
+#define READ_SYNC	(READ | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
 #define READ_META	(READ | (1 << BIO_RW_META))
-#define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
-#define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNC))
+#define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
+#define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNCIO) | (1 << BIO_RW_UNPLUG))
 #define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
 #define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
 #define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))

commit fcccf502540e3d752d33b2d8e976034dee81f9f7
Author: Takashi Sato <t-sato@yk.jp.nec.com>
Date:   Fri Jan 9 16:40:59 2009 -0800

    filesystem freeze: implement generic freeze feature
    
    The ioctls for the generic freeze feature are below.
    o Freeze the filesystem
      int ioctl(int fd, int FIFREEZE, arg)
        fd: The file descriptor of the mountpoint
        FIFREEZE: request code for the freeze
        arg: Ignored
        Return value: 0 if the operation succeeds. Otherwise, -1
    
    o Unfreeze the filesystem
      int ioctl(int fd, int FITHAW, arg)
        fd: The file descriptor of the mountpoint
        FITHAW: request code for unfreeze
        arg: Ignored
        Return value: 0 if the operation succeeds. Otherwise, -1
        Error number: If the filesystem has already been unfrozen,
                      errno is set to EINVAL.
    
    [akpm@linux-foundation.org: fix CONFIG_BLOCK=n]
    Signed-off-by: Takashi Sato <t-sato@yk.jp.nec.com>
    Signed-off-by: Masayuki Hamaguchi <m-hamaguchi@ys.jp.nec.com>
    Cc: <xfs-masters@oss.sgi.com>
    Cc: <linux-ext4@vger.kernel.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Alasdair G Kergon <agk@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3e59182de9df..6022f44043f2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -234,6 +234,8 @@ struct inodes_stat_t {
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */
 #define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
+#define FIFREEZE	_IOWR('X', 119, int)	/* Freeze */
+#define FITHAW		_IOWR('X', 120, int)	/* Thaw */
 
 #define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
 #define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
@@ -591,6 +593,11 @@ struct block_device {
 	 * care to not mess up bd_private for that case.
 	 */
 	unsigned long		bd_private;
+
+	/* The counter of freeze processes */
+	int			bd_fsfreeze_count;
+	/* Mutex for freeze */
+	struct mutex		bd_fsfreeze_mutex;
 };
 
 /*

commit c4be0c1dc4cdc37b175579be1460f15ac6495e9a
Author: Takashi Sato <t-sato@yk.jp.nec.com>
Date:   Fri Jan 9 16:40:58 2009 -0800

    filesystem freeze: add error handling of write_super_lockfs/unlockfs
    
    Currently, ext3 in mainline Linux doesn't have the freeze feature which
    suspends write requests.  So, we cannot take a backup which keeps the
    filesystem's consistency with the storage device's features (snapshot and
    replication) while it is mounted.
    
    In many case, a commercial filesystem (e.g.  VxFS) has the freeze feature
    and it would be used to get the consistent backup.
    
    If Linux's standard filesystem ext3 has the freeze feature, we can do it
    without a commercial filesystem.
    
    So I have implemented the ioctls of the freeze feature.
    I think we can take the consistent backup with the following steps.
    1. Freeze the filesystem with the freeze ioctl.
    2. Separate the replication volume or create the snapshot
       with the storage device's feature.
    3. Unfreeze the filesystem with the unfreeze ioctl.
    4. Take the backup from the separated replication volume
       or the snapshot.
    
    This patch:
    
    VFS:
    Changed the type of write_super_lockfs and unlockfs from "void"
    to "int" so that they can return an error.
    Rename write_super_lockfs and unlockfs of the super block operation
    freeze_fs and unfreeze_fs to avoid a confusion.
    
    ext3, ext4, xfs, gfs2, jfs:
    Changed the type of write_super_lockfs and unlockfs from "void"
    to "int" so that write_super_lockfs returns an error if needed,
    and unlockfs always returns 0.
    
    reiserfs:
    Changed the type of write_super_lockfs and unlockfs from "void"
    to "int" so that they always return 0 (success) to keep a current behavior.
    
    Signed-off-by: Takashi Sato <t-sato@yk.jp.nec.com>
    Signed-off-by: Masayuki Hamaguchi <m-hamaguchi@ys.jp.nec.com>
    Cc: <xfs-masters@oss.sgi.com>
    Cc: <linux-ext4@vger.kernel.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Cc: Dave Chinner <david@fromorbit.com>
    Cc: Alasdair G Kergon <agk@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0b87b29f4797..3e59182de9df 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1377,8 +1377,8 @@ struct super_operations {
 	void (*put_super) (struct super_block *);
 	void (*write_super) (struct super_block *);
 	int (*sync_fs)(struct super_block *sb, int wait);
-	void (*write_super_lockfs) (struct super_block *);
-	void (*unlockfs) (struct super_block *);
+	int (*freeze_fs) (struct super_block *);
+	int (*unfreeze_fs) (struct super_block *);
 	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);

commit 2150edc6c5cf00f7adb54538b9ea2a3e9cedca3f
Merge: cd764695b673 4b905671d2ea
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 8 17:14:59 2009 -0800

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (57 commits)
      jbd2: Fix oops in jbd2_journal_init_inode() on corrupted fs
      ext4: Remove "extents" mount option
      block: Add Kconfig help which notes that ext4 needs CONFIG_LBD
      ext4: Make printk's consistently prefixed with "EXT4-fs: "
      ext4: Add sanity checks for the superblock before mounting the filesystem
      ext4: Add mount option to set kjournald's I/O priority
      jbd2: Submit writes to the journal using WRITE_SYNC
      jbd2: Add pid and journal device name to the "kjournald2 starting" message
      ext4: Add markers for better debuggability
      ext4: Remove code to create the journal inode
      ext4: provide function to release metadata pages under memory pressure
      ext3: provide function to release metadata pages under memory pressure
      add releasepage hooks to block devices which can be used by file systems
      ext4: Fix s_dirty_blocks_counter if block allocation failed with nodelalloc
      ext4: Init the complete page while building buddy cache
      ext4: Don't allow new groups to be added during block allocation
      ext4: mark the blocks/inode bitmap beyond end of group as used
      ext4: Use new buffer_head flag to check uninit group bitmaps initialization
      ext4: Fix the race between read_inode_bitmap() and ext4_new_inode()
      ext4: code cleanup
      ...

commit efaee192063a54749c56b7383803e16fe553630e
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Tue Jan 6 07:20:54 2009 -0800

    async: make the final inode deletion an asynchronous event
    
    this makes "rm -rf" on a (names cached) kernel tree go from
    11.6 to 8.6 seconds on an ext3 filesystem
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d7eba77f666e..e38a64d71eff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1184,6 +1184,11 @@ struct super_block {
 	 * generic_show_options()
 	 */
 	char *s_options;
+
+	/*
+	 * storage for asynchronous operations
+	 */
+	struct list_head s_async_list;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 856bf4d717feb8c55d4e2f817b71ebb70cfbc67b
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Jan 6 14:40:26 2009 -0800

    fs: sys_sync fix
    
    s_syncing livelock avoidance was breaking data integrity guarantee of
    sys_sync, by allowing sys_sync to skip writing or waiting for superblocks
    if there is a concurrent sys_sync happening.
    
    This livelock avoidance is much less important now that we don't have the
    get_super_to_sync() call after every sb that we sync.  This was replaced
    by __put_super_and_need_restart.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fb59673c60b1..d7eba77f666e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1133,7 +1133,6 @@ struct super_block {
 	struct rw_semaphore	s_umount;
 	struct mutex		s_lock;
 	int			s_count;
-	int			s_syncing;
 	int			s_need_sync_fs;
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY

commit c54febae996d36c630f09209cd9983ecfda3fcad
Merge: e42e4ba07bc7 eb8374e71f94
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 5 18:52:54 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-2.6-nmw
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-2.6-nmw: (27 commits)
      GFS2: Use DEFINE_SPINLOCK
      GFS2: Fix use-after-free bug on umount (try #2)
      Revert "GFS2: Fix use-after-free bug on umount"
      GFS2: Streamline alloc calculations for writes
      GFS2: Send useful information with uevent messages
      GFS2: Fix use-after-free bug on umount
      GFS2: Remove ancient, unused code
      GFS2: Move four functions from super.c
      GFS2: Fix bug in gfs2_lock_fs_check_clean()
      GFS2: Send some sensible sysfs stuff
      GFS2: Kill two daemons with one patch
      GFS2: Move gfs2_recoverd into recovery.c
      GFS2: Fix "truncate in progress" hang
      GFS2: Clean up & move gfs2_quotad
      GFS2: Add more detail to debugfs glock dumps
      GFS2: Banish struct gfs2_rgrpd_host
      GFS2: Move rg_free from gfs2_rgrpd_host to gfs2_rgrpd
      GFS2: Move rg_igeneration into struct gfs2_rgrpd
      GFS2: Banish struct gfs2_dinode_host
      GFS2: Move i_size from gfs2_dinode_host and rename it to i_disksize
      ...

commit 520c85346666d4d9a6fcaaa8450542302dc28b91
Merge: e8c82c2e23e3 4ae8978cf92a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 5 18:32:06 2009 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      inotify: fix type errors in interfaces
      fix breakage in reiserfs_new_inode()
      fix the treatment of jfs special inodes
      vfs: remove duplicate code in get_fs_type()
      add a vfs_fsync helper
      sys_execve and sys_uselib do not call into fsnotify
      zero i_uid/i_gid on inode allocation
      inode->i_op is never NULL
      ntfs: don't NULL i_op
      isofs check for NULL ->i_op in root directory is dead code
      affs: do not zero ->i_op
      kill suid bit only for regular files
      vfs: lseek(fd, 0, SEEK_CUR) race condition

commit 4c728ef583b3d82266584da5cb068294c09df31e
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Dec 22 21:11:15 2008 +0100

    add a vfs_fsync helper
    
    Fsync currently has a fdatawrite/fdatawait pair around the method call,
    and a mutex_lock/unlock of the inode mutex.  All callers of fsync have
    to duplicate this, but we have a few and most of them don't quite get
    it right.  This patch adds a new vfs_fsync that takes care of this.
    It's a little more complicated as usual as ->fsync might get a NULL file
    pointer and just a dentry from nfsd, but otherwise gets afile and we
    want to take the mapping and file operations from it when it is there.
    
    Notes on the fsync callers:
    
     - ecryptfs wasn't calling filemap_fdatawrite / filemap_fdatawait on the
            lower file
     - coda wasn't calling filemap_fdatawrite / filemap_fdatawait on the host
            file, and returning 0 when ->fsync was missing
     - shm wasn't calling either filemap_fdatawrite / filemap_fdatawait nor
       taking i_mutex.  Now given that shared memory doesn't have disk
       backing not doing anything in fsync seems fine and I left it out of
       the vfs_fsync conversion for now, but in that case we might just
       not pass it through to the lower file at all but just call the no-op
       simple_sync_file directly.
    
    [and now actually export vfs_fsync]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e2170ee21e18..9ad9eac9eb0c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1827,7 +1827,7 @@ extern int __filemap_fdatawrite_range(struct address_space *mapping,
 extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
 
-extern long do_fsync(struct file *file, int datasync);
+extern int vfs_fsync(struct file *file, struct dentry *dentry, int datasync);
 extern void sync_supers(void);
 extern void sync_filesystems(int wait);
 extern void __fsync_super(struct super_block *sb);

commit e9079cce201784632aed4b1a3121ee38c1ced0b6
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Tue Oct 14 14:43:29 2008 +0100

    GFS2: Support for FIEMAP ioctl
    
    This patch implements the FIEMAP ioctl for GFS2. We can use the generic
    code (aside from a lock order issue, solved as per Ted Tso's suggestion)
    for which I've introduced a new variant of the generic function. We also
    have one exception to deal with, namely stuffed files, so we do that
    "by hand", setting all the required flags.
    
    This has been tested with a modified (I could only find an old version) of
    Eric's test program, and appears to work correctly.
    
    This patch does not currently support FIEMAP of xattrs, but the plan is to add
    that feature at some future point.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Theodore Tso <tytso@mit.edu>
    Cc: Eric Sandeen <sandeen@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f2a3010140e3..e34bc6925fdf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2059,6 +2059,9 @@ extern int vfs_fstat(unsigned int, struct kstat *);
 
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
+extern int __generic_block_fiemap(struct inode *inode,
+				  struct fiemap_extent_info *fieinfo, u64 start,
+				  u64 len, get_block_t *get_block);
 extern int generic_block_fiemap(struct inode *inode,
 				struct fiemap_extent_info *fieinfo, u64 start,
 				u64 len, get_block_t *get_block);

commit 54566b2c1594c2326a645a3551f9d989f7ba3c5e
Author: Nick Piggin <npiggin@suse.de>
Date:   Sun Jan 4 12:00:53 2009 -0800

    fs: symlink write_begin allocation context fix
    
    With the write_begin/write_end aops, page_symlink was broken because it
    could no longer pass a GFP_NOFS type mask into the point where the
    allocations happened.  They are done in write_begin, which would always
    assume that the filesystem can be entered from reclaim.  This bug could
    cause filesystem deadlocks.
    
    The funny thing with having a gfp_t mask there is that it doesn't really
    allow the caller to arbitrarily tinker with the context in which it can be
    called.  It couldn't ever be GFP_ATOMIC, for example, because it needs to
    take the page lock.  The only thing any callers care about is __GFP_FS
    anyway, so turn that into a single flag.
    
    Add a new flag for write_begin, AOP_FLAG_NOFS.  Filesystems can now act on
    this flag in their write_begin function.  Change __grab_cache_page to
    accept a nofs argument as well, to honour that flag (while we're there,
    change the name to grab_cache_page_write_begin which is more instructive
    and does away with random leading underscores).
    
    This is really a more flexible way to go in the end anyway -- if a
    filesystem happens to want any extra allocations aside from the pagecache
    ones in ints write_begin function, it may now use GFP_KERNEL (rather than
    GFP_NOFS) for common case allocations (eg.  ocfs2_alloc_write_ctxt, for a
    random example).
    
    [kosaki.motohiro@jp.fujitsu.com: fix ubifs]
    [kosaki.motohiro@jp.fujitsu.com: fix fuse]
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Reviewed-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Cc: <stable@kernel.org>         [2.6.28.x]
    Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    [ Cleaned up the calling convention: just pass in the AOP flags
      untouched to the grab_cache_page_write_begin() function.  That
      just simplifies everybody, and may even allow future expansion of the
      logic.   - Linus ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e2170ee21e18..f2a3010140e3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -423,6 +423,9 @@ enum positive_aop_returns {
 
 #define AOP_FLAG_UNINTERRUPTIBLE	0x0001 /* will not do a short write */
 #define AOP_FLAG_CONT_EXPAND		0x0002 /* called from cont_expand */
+#define AOP_FLAG_NOFS			0x0004 /* used by filesystem to direct
+						* helper code (eg buffer layer)
+						* to clear GFP_FS from alloc */
 
 /*
  * oh the beauties of C type declarations.
@@ -2035,7 +2038,7 @@ extern int page_readlink(struct dentry *, char __user *, int);
 extern void *page_follow_link_light(struct dentry *, struct nameidata *);
 extern void page_put_link(struct dentry *, struct nameidata *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
-		gfp_t gfp_mask);
+		int nofs);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern const struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);

commit 87d8fe1ee6b8d2f95076142d58c440dba4e7bdc2
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Jan 3 09:47:09 2009 -0500

    add releasepage hooks to block devices which can be used by file systems
    
    Implement blkdev_releasepage() to release the buffer_heads and pages
    after we release private data belonging to a mounted filesystem.
    
    Cc: Toshiyuki Okajima <toshi.okajima@jp.fujitsu.com>
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f2a3010140e3..0f54ae0f0ccd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -565,6 +565,7 @@ struct address_space {
 struct block_device {
 	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
 	struct inode *		bd_inode;	/* will die */
+	struct super_block *	bd_super;
 	int			bd_openers;
 	struct mutex		bd_mutex;	/* open/close mutex */
 	struct semaphore	bd_mount_sem;
@@ -1385,6 +1386,7 @@ struct super_operations {
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
+	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
 };
 
 /*

commit 261bca86ed4f7f391d1938167624e78da61dcc6b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 30 01:48:21 2008 -0500

    nfsd/create race fixes, infrastructure
    
    new helpers - insert_inode_locked() and insert_inode_locked4().
    Hash new inode, making sure that there's no such inode in icache
    already.  If there is and it does not end up unhashed (as would
    happen if we have nfsd trying to resolve a bogus fhandle), fail.
    Otherwise insert our inode into hash and succeed.
    
    In either case have i_state set to new+locked; cleanup ends up
    being simpler with such calling conventions.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index be16ce01fb1b..e2170ee21e18 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1902,6 +1902,8 @@ extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
 
 extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
 extern struct inode * iget_locked(struct super_block *, unsigned long);
+extern int insert_inode_locked4(struct inode *, unsigned long, int (*test)(struct inode *, void *), void *);
+extern int insert_inode_locked(struct inode *);
 extern void unlock_new_inode(struct inode *);
 
 extern void __iget(struct inode * inode);

commit 6badd79bd002788aaec27b50a74ab69ef65ab8ee
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 26 00:57:40 2008 -0500

    kill ->dir_notify()
    
    Remove the hopelessly misguided ->dir_notify().  The only instance (cifs)
    has been broken by design from the very beginning; the objects it creates
    are never destroyed, keep references to struct file they can outlive, nothing
    that could possibly evict them exists on close(2) path *and* no locking
    whatsoever is done to prevent races with close(), should the previous, er,
    deficiencies someday be dealt with.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fd615986a41c..be16ce01fb1b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1309,7 +1309,6 @@ struct file_operations {
 	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
 	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
 	int (*check_flags)(int);
-	int (*dir_notify)(struct file *filp, unsigned long arg);
 	int (*flock) (struct file *, int, struct file_lock *);
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);

commit cb23beb55100171646e69e248fb45f10db6e99a4
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Oct 24 09:59:29 2008 +0200

    kill vfs_permission
    
    With all the nameidata removal there's no point anymore for this helper.
    Of the three callers left two will go away with the next lookup series
    anyway.
    
    Also add proper kerneldoc to inode_permission as this is the main
    permission check routine now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3468df5a06e0..fd615986a41c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1212,7 +1212,6 @@ extern void unlock_super(struct super_block *);
 /*
  * VFS helper functions..
  */
-extern int vfs_permission(struct nameidata *, int);
 extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
 extern int vfs_mkdir(struct inode *, struct dentry *, int);
 extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);

commit 3fb64190aa3c23c10e6e9fd0124ac030115c99bf
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Oct 24 09:58:10 2008 +0200

    pass a struct path * to may_open
    
    No need for the nameidata in may_open - a struct path is enough.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c5e4c5c74034..3468df5a06e0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1869,7 +1869,7 @@ extern void free_write_pipe(struct file *);
 
 extern struct file *do_filp_open(int dfd, const char *pathname,
 		int open_flag, int mode);
-extern int may_open(struct nameidata *, int, int);
+extern int may_open(struct path *, int, int);
 
 extern int kernel_read(struct file *, unsigned long, char *, unsigned long);
 extern struct file * open_exec(const char *);

commit dded4f4d5048e64a01cf52eed4d27c8cb2600525
Author: Jan Engelhardt <jengelh@medozas.de>
Date:   Mon Dec 1 14:34:50 2008 -0800

    include: linux/fs.h: put declarations in __KERNEL__
    
    include/linux/fs.h contains externs for a bunch of variables.  That obviously
    belongs under ifdef __KERNEL__.
    
    Signed-off-by: Jan Engelhardt <jengelh@medozas.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 001ded4845b4..c5e4c5c74034 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -21,7 +21,6 @@
 
 /* Fixed constants first: */
 #undef NR_OPEN
-extern int sysctl_nr_open;
 #define INR_OPEN 1024		/* Initial setting for nfile rlimits */
 
 #define BLOCK_SIZE_BITS 10
@@ -38,21 +37,13 @@ struct files_stat_struct {
 	int nr_free_files;	/* read only */
 	int max_files;		/* tunable */
 };
-extern struct files_stat_struct files_stat;
-extern int get_max_files(void);
 
 struct inodes_stat_t {
 	int nr_inodes;
 	int nr_unused;
 	int dummy[5];		/* padding for sysctl ABI compatibility */
 };
-extern struct inodes_stat_t inodes_stat;
 
-extern int leases_enable, lease_break_time;
-
-#ifdef CONFIG_DNOTIFY
-extern int dir_notify_enable;
-#endif
 
 #define NR_FILE  8192	/* this can well be larger on a larger system */
 
@@ -330,6 +321,15 @@ extern void __init inode_init(void);
 extern void __init inode_init_early(void);
 extern void __init files_init(unsigned long);
 
+extern struct files_stat_struct files_stat;
+extern int get_max_files(void);
+extern int sysctl_nr_open;
+extern struct inodes_stat_t inodes_stat;
+extern int leases_enable, lease_break_time;
+#ifdef CONFIG_DNOTIFY
+extern int dir_notify_enable;
+#endif
+
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);

commit 0a8c5395f90f06d128247844b2515c8bf3f2826b
Merge: 25051158bbed 3c92ec8ae91e
Author: Lachlan McIlroy <lachlan@redback.melbourne.sgi.com>
Date:   Mon Dec 29 16:47:18 2008 +1100

    [XFS] Fix merge failures
    
    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            fs/xfs/linux-2.6/xfs_cred.h
            fs/xfs/linux-2.6/xfs_globals.h
            fs/xfs/linux-2.6/xfs_ioctl.c
            fs/xfs/xfs_vnodeops.h
    
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>

commit cbacc2c7f066a1e01b33b0e27ae5efbf534bc2db
Merge: 4a6908a3a050 74192246910f
Author: James Morris <jmorris@namei.org>
Date:   Thu Dec 25 11:40:09 2008 +1100

    Merge branch 'next' into for-linus

commit 27a0464a6cb837d3a90b6e69365dfc01cb0dff2f
Merge: 4d9d4ebf5de8 3d44cc3e01ee
Author: Lachlan McIlroy <lachlan@redback.melbourne.sgi.com>
Date:   Mon Dec 22 17:34:26 2008 +1100

    [XFS] Fix merge conflict in fs/xfs/xfs_rename.c
    
    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            fs/xfs/xfs_rename.c
    
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>

commit 4d4be482a4d78ca906f45e99fd9fdb91e907f5ad
Author: Christoph Hellwig <hch@infradead.org>
Date:   Tue Dec 9 04:47:33 2008 -0500

    [XFS] add a FMODE flag to make XFS invisible I/O less hacky
    
    XFS has a mode called invisble I/O that doesn't update any of the
    timestamps.  It's used for HSM-style applications and exposed through
    the nasty open by handle ioctl.
    
    Instead of doing directly assignment of file operations that set an
    internal flag for it add a new FMODE_NOCMTIME flag that we can check
    in the normal file operations.
    
    (addition of the generic VFS flag has been ACKed by Al as an interims
     solution)
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51bd9370d437..965b9ba3865d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -81,6 +81,14 @@ extern int dir_notify_enable;
 #define FMODE_WRITE_IOCTL	((__force fmode_t)128)
 #define FMODE_NDELAY_NOW	((__force fmode_t)256)
 
+/*
+ * Don't update ctime and mtime.
+ *
+ * Currently a special hack for the XFS open_by_handle ioctl, but we'll
+ * hopefully graduate it to a proper O_CMTIME flag supported by open(2) soon.
+ */
+#define FMODE_NOCMTIME		((__force fmode_t)2048)
+
 #define RW_MASK		1
 #define RWA_MASK	2
 #define READ 0

commit fc9161e54d0dbf799beff9692ea1cc6237162b85
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 5 14:58:46 2008 +0100

    [PATCH 2/2] documnt FMODE_ constants
    
    Make sure all FMODE_ constants are documents, and ensure a coherent
    style for the already existing comments.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b3345a90e11a..4a853ef6fd35 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -63,21 +63,23 @@ extern int dir_notify_enable;
 #define MAY_ACCESS 16
 #define MAY_OPEN 32
 
-#define FMODE_READ ((__force fmode_t)1)
-#define FMODE_WRITE ((__force fmode_t)2)
-
-/* Internal kernel extensions */
-#define FMODE_LSEEK	((__force fmode_t)4)
-#define FMODE_PREAD	((__force fmode_t)8)
-#define FMODE_PWRITE	FMODE_PREAD	/* These go hand in hand */
-
-/* File is being opened for execution. Primary users of this flag are
-   distributed filesystems that can use it to achieve correct ETXTBUSY
-   behavior for cross-node execution/opening_for_writing of files */
-#define FMODE_EXEC	((__force fmode_t)16)
-
-#define FMODE_NDELAY	((__force fmode_t)32)
-#define FMODE_EXCL	((__force fmode_t)64)
+/* file is open for reading */
+#define FMODE_READ		((__force fmode_t)1)
+/* file is open for writing */
+#define FMODE_WRITE		((__force fmode_t)2)
+/* file is seekable */
+#define FMODE_LSEEK		((__force fmode_t)4)
+/* file can be accessed using pread/pwrite */
+#define FMODE_PREAD		((__force fmode_t)8)
+#define FMODE_PWRITE		FMODE_PREAD	/* These go hand in hand */
+/* File is opened for execution with sys_execve / sys_uselib */
+#define FMODE_EXEC		((__force fmode_t)16)
+/* File is opened with O_NDELAY (only set for block devices) */
+#define FMODE_NDELAY		((__force fmode_t)32)
+/* File is opened with O_EXCL (only set for block devices) */
+#define FMODE_EXCL		((__force fmode_t)64)
+/* File is opened using open(.., 3, ..) and is writeable only for ioctls
+   (specialy hack for floppy.c) */
 #define FMODE_WRITE_IOCTL	((__force fmode_t)128)
 
 #define RW_MASK		1

commit fd4ce1acd0f8558033b1a6968001552bd7671e6d
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 5 14:58:42 2008 +0100

    [PATCH 1/2] kill FMODE_NDELAY_NOW
    
    Update FMODE_NDELAY before each ioctl call so that we can kill the
    magic FMODE_NDELAY_NOW.  It would be even better to do this directly
    in setfl(), but for that we'd need to have FMODE_NDELAY for all files,
    not just block special files.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0dcdd9458f4b..b3345a90e11a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -79,7 +79,6 @@ extern int dir_notify_enable;
 #define FMODE_NDELAY	((__force fmode_t)32)
 #define FMODE_EXCL	((__force fmode_t)64)
 #define FMODE_WRITE_IOCTL	((__force fmode_t)128)
-#define FMODE_NDELAY_NOW	((__force fmode_t)256)
 
 #define RW_MASK		1
 #define RWA_MASK	2

commit d76b0d9b2d87cfc95686e148767cbf7d0e22bdc0
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:25 2008 +1100

    CRED: Use creds in file structs
    
    Attach creds to file structs and discard f_uid/f_gid.
    
    file_operations::open() methods (such as hppfs_open()) should use file->f_cred
    rather than current_cred().  At the moment file->f_cred will be current_cred()
    at this point.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3bfec1327b8d..c0fb6d81d89b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -827,7 +827,7 @@ struct file {
 	fmode_t			f_mode;
 	loff_t			f_pos;
 	struct fown_struct	f_owner;
-	unsigned int		f_uid, f_gid;
+	const struct cred	*f_cred;
 	struct file_ra_state	f_ra;
 
 	u64			f_version;

commit 745ca2475a6ac596e3d8d37c2759c0fbe2586227
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:22 2008 +1100

    CRED: Pass credentials through dentry_open()
    
    Pass credentials through dentry_open() so that the COW creds patch can have
    SELinux's flush_unauthorized_files() pass the appropriate creds back to itself
    when it opens its null chardev.
    
    The security_dentry_open() call also now takes a creds pointer, as does the
    dentry_open hook in struct security_operations.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b3d404aaabed..3bfec1327b8d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -315,6 +315,7 @@ struct poll_table_struct;
 struct kstatfs;
 struct vm_area_struct;
 struct vfsmount;
+struct cred;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
@@ -1673,7 +1674,8 @@ extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 extern long do_sys_open(int dfd, const char __user *filename, int flags,
 			int mode);
 extern struct file *filp_open(const char *, int, int);
-extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern struct file * dentry_open(struct dentry *, struct vfsmount *, int,
+				 const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 extern char * getname(const char __user *);
 

commit da9592edebceeba1b9301beafe80ec8b9c2db0ce
Author: David Howells <dhowells@redhat.com>
Date:   Fri Nov 14 10:39:05 2008 +1100

    CRED: Wrap task credential accesses in the filesystem subsystem
    
    Wrap access to task credentials so that they can be separated more easily from
    the task_struct during the introduction of COW creds.
    
    Change most current->(|e|s|fs)[ug]id to current_(|e|s|fs)[ug]id().
    
    Change some task->e?[ug]id to task_e?[ug]id().  In some places it makes more
    sense to use RCU directly rather than a convenient wrapper; these will be
    addressed by later patches.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Reviewed-by: James Morris <jmorris@namei.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: James Morris <jmorris@namei.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0dcdd9458f4b..b3d404aaabed 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1193,7 +1193,7 @@ enum {
 #define has_fs_excl() atomic_read(&current->fs_excl)
 
 #define is_owner_or_cap(inode)	\
-	((current->fsuid == (inode)->i_uid) || capable(CAP_FOWNER))
+	((current_fsuid() == (inode)->i_uid) || capable(CAP_FOWNER))
 
 /* not quite ready to be deprecated, but... */
 extern void lock_super(struct super_block *);

commit dcd7b4e5c0649b1d2219399529b20de1df517e55
Merge: 75fa67706cce 91b777125175
Author: Niv Sardi <xaiki@debian.org>
Date:   Fri Nov 7 15:07:12 2008 +1100

    Merge branch 'master' of git://oss.sgi.com:8090/xfs/linux-2.6

commit 4e02ed4b4a2fae34aae766a5bb93ae235f60adb8
Author: Nick Piggin <npiggin@suse.de>
Date:   Wed Oct 29 14:00:55 2008 -0700

    fs: remove prepare_write/commit_write
    
    Nothing uses prepare_write or commit_write. Remove them from the tree
    completely.
    
    [akpm@linux-foundation.org: schedule simple_prepare_write() for unexporting]
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5b248d61430c..0dcdd9458f4b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -489,13 +489,6 @@ struct address_space_operations {
 	int (*readpages)(struct file *filp, struct address_space *mapping,
 			struct list_head *pages, unsigned nr_pages);
 
-	/*
-	 * ext3 requires that a successful prepare_write() call be followed
-	 * by a commit_write() call - they must be balanced
-	 */
-	int (*prepare_write)(struct file *, struct page *, unsigned, unsigned);
-	int (*commit_write)(struct file *, struct page *, unsigned, unsigned);
-
 	int (*write_begin)(struct file *, struct address_space *mapping,
 				loff_t pos, unsigned len, unsigned flags,
 				struct page **pagep, void **fsdata);

commit 8290c35f87304a6b73d4fd17b03580b4f7425de8
Author: David Chinner <david@fromorbit.com>
Date:   Thu Oct 30 17:35:24 2008 +1100

    Inode: Allow external list initialisation
    
    To allow XFS to combine the XFS and linux inodes into a single
    structure, we need to drive inode lookup from the XFS inode cache,
    not the generic inode cache. This means that we need initialise a
    struct inode from a context outside alloc_inode() as it is no longer
    used by XFS.
    
    After inode allocation and initialisation, we need to add the inode
    to the superblock list, the in-use list, hash it and do some
    accounting. This all needs to be done with the inode_lock held and
    there are already several places in fs/inode.c that do this list
    manipulation.  Factor out the common code, add a locking wrapper and
    export the function so ti can be called from XFS.
    
    Signed-off-by: Dave Chinner <david@fromorbit.com>
    Signed-off-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 04abead4b021..1deedf235d55 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1883,6 +1883,7 @@ extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
 
 extern struct inode * inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
+extern void inode_add_to_lists(struct super_block *, struct inode *);
 extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);

commit 2cb1599f9b2ecdd7a9e59feeee647eb258966839
Author: David Chinner <david@fromorbit.com>
Date:   Thu Oct 30 17:32:23 2008 +1100

    Inode: Allow external initialisers
    
    To allow XFS to combine the XFS and linux inodes into a single
    structure, we need to drive inode lookup from the XFS inode cache,
    not the generic inode cache. This means that we need initialise a
    struct inode from a context outside alloc_inode() as it is no longer
    used by XFS.
    
    Factor and export the struct inode initialisation code from
    alloc_inode() to inode_init_always() as a counterpart to
    inode_init_once().  i.e. we have to call this init function for each
    inode instantiation (always), as opposed inode_init_once() which is
    only called on slab object instantiation (once).
    
    Signed-off-by: Dave Chinner <david@fromorbit.com>
    Signed-off-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5b248d61430c..04abead4b021 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1881,6 +1881,7 @@ extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
 
 extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
 
+extern struct inode * inode_init_always(struct super_block *, struct inode *);
 extern void inode_init_once(struct inode *);
 extern void iput(struct inode *);
 extern struct inode * igrab(struct inode *);

commit 88ed86fee6651033de9b7038dac7869a9f19775a
Merge: 3856d30ded1f 59c7572e82d6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 23 12:04:37 2008 -0700

    Merge branch 'proc' of git://git.kernel.org/pub/scm/linux/kernel/git/adobriyan/proc
    
    * 'proc' of git://git.kernel.org/pub/scm/linux/kernel/git/adobriyan/proc: (35 commits)
      proc: remove fs/proc/proc_misc.c
      proc: move /proc/vmcore creation to fs/proc/vmcore.c
      proc: move pagecount stuff to fs/proc/page.c
      proc: move all /proc/kcore stuff to fs/proc/kcore.c
      proc: move /proc/schedstat boilerplate to kernel/sched_stats.h
      proc: move /proc/modules boilerplate to kernel/module.c
      proc: move /proc/diskstats boilerplate to block/genhd.c
      proc: move /proc/zoneinfo boilerplate to mm/vmstat.c
      proc: move /proc/vmstat boilerplate to mm/vmstat.c
      proc: move /proc/pagetypeinfo boilerplate to mm/vmstat.c
      proc: move /proc/buddyinfo boilerplate to mm/vmstat.c
      proc: move /proc/vmallocinfo to mm/vmalloc.c
      proc: move /proc/slabinfo boilerplate to mm/slub.c, mm/slab.c
      proc: move /proc/slab_allocators boilerplate to mm/slab.c
      proc: move /proc/interrupts boilerplate code to fs/proc/interrupts.c
      proc: move /proc/stat to fs/proc/stat.c
      proc: move rest of /proc/partitions code to block/genhd.c
      proc: move /proc/cpuinfo code to fs/proc/cpuinfo.c
      proc: move /proc/devices code to fs/proc/devices.c
      proc: move rest of /proc/locks to fs/locks.c
      ...

commit 22484856402bfa1ff3defe47f6029ab0418240d9
Merge: 5ed487bc2c44 56b26add02b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 23 10:23:07 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/viro/bdev
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/viro/bdev: (66 commits)
      [PATCH] kill the rest of struct file propagation in block ioctls
      [PATCH] get rid of struct file use in blkdev_ioctl() BLKBSZSET
      [PATCH] get rid of blkdev_locked_ioctl()
      [PATCH] get rid of blkdev_driver_ioctl()
      [PATCH] sanitize blkdev_get() and friends
      [PATCH] remember mode of reiserfs journal
      [PATCH] propagate mode through swsusp_close()
      [PATCH] propagate mode through open_bdev_excl/close_bdev_excl
      [PATCH] pass fmode_t to blkdev_put()
      [PATCH] kill the unused bsize on the send side of /dev/loop
      [PATCH] trim file propagation in block/compat_ioctl.c
      [PATCH] end of methods switch: remove the old ones
      [PATCH] switch sr
      [PATCH] switch sd
      [PATCH] switch ide-scsi
      [PATCH] switch tape_block
      [PATCH] switch dcssblk
      [PATCH] switch dasd
      [PATCH] switch mtd_blkdevs
      [PATCH] switch mmc
      ...

commit d8ba7a363393f803c93c8cffabd6d0362618bc2a
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Oct 4 22:34:18 2008 +0400

    proc: move rest of /proc/locks to fs/locks.c
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a6a625be13fc..024049543ae1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1037,7 +1037,6 @@ extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
-extern struct seq_operations locks_seq_operations;
 #else /* !CONFIG_FILE_LOCKING */
 #define fcntl_getlk(a, b) ({ -EINVAL; })
 #define fcntl_setlk(a, b, c, d) ({ -EACCES; })

commit 08b9fe6b12d32324f311c46b88102b6b9067d434
Author: Mimi Zohar <zohar@linux.vnet.ibm.com>
Date:   Mon Oct 13 00:09:50 2008 -0400

    [PATCH] i_version: remount support
    
    Add support for remounting a filesystem with the i_version option.
    
    Signed-off-by: Mimi Zohar <zohar@us.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 025a4a251b64..7d719c1a18e3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -136,7 +136,7 @@ extern int dir_notify_enable;
 /*
  * Superblock flags that can be altered by MS_REMOUNT
  */
-#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK)
+#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION)
 
 /*
  * Old magic mount flag and mask

commit f696a3659fc4b3a3bf4bc83d9dbec5e5a2ffd929
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu Jul 31 13:41:58 2008 +0200

    [PATCH] move executable checking into ->permission()
    
    For execute permission on a regular files we need to check if file has
    any execute bits at all, regardless of capabilites.
    
    This check is normally performed by generic_permission() but was also
    added to the case when the filesystem defines its own ->permission()
    method.  In the latter case the filesystem should be responsible for
    performing this check.
    
    Move the check from inode_permission() inside filesystems which are
    not calling generic_permission().
    
    Create a helper function execute_ok() that returns true if the inode
    is a directory or if any execute bits are present in i_mode.
    
    Also fix up the following code:
    
     - coda control file is never executable
     - sysctl files are never executable
     - hfs_permission seems broken on MAY_EXEC, remove
     - hfsplus_permission is eqivalent to generic_permission(), remove
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5f70aa62cf0f..025a4a251b64 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1851,6 +1851,11 @@ extern int inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int,
 		int (*check_acl)(struct inode *, int));
 
+static inline bool execute_ok(struct inode *inode)
+{
+	return (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode);
+}
+
 extern int get_write_access(struct inode *);
 extern int deny_write_access(struct file *);
 static inline void put_write_access(struct inode * inode)

commit 6de24f0ed08054b2a202902e4d63beff27654db8
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Aug 28 06:25:49 2008 +0400

    [PATCH 1/2] anondev: init IDR statically
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a6a625be13fc..5f70aa62cf0f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1593,7 +1593,6 @@ extern int get_sb_pseudo(struct file_system_type *, char *,
 	struct vfsmount *mnt);
 extern int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
-void unnamed_dev_init(void);
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
 #define fops_get(fops) \

commit 56b26add02b4bdea81d5e0ebda60db1fe3311ad4
Author: Al Viro <al@aretha.pdmi.ras.ru>
Date:   Fri Sep 19 03:17:36 2008 -0400

    [PATCH] kill the rest of struct file propagation in block ioctls
    
    Now we can switch blkdev_ioctl() block_device/mode
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 11de682c65a1..ff536e106b4e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1717,7 +1717,7 @@ extern const struct file_operations bad_sock_fops;
 extern const struct file_operations def_fifo_fops;
 #ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
-extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
+extern int blkdev_ioctl(struct block_device *, fmode_t, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, fmode_t);
 extern int blkdev_put(struct block_device *, fmode_t);

commit e436fdae70a31102d2be32969b80fe8545edebd9
Author: Al Viro <al@aretha.pdmi.ras.ru>
Date:   Thu Sep 18 03:38:12 2008 -0400

    [PATCH] get rid of blkdev_driver_ioctl()
    
    convert remaining callers to __blkdev_driver_ioctl()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cb78e389699b..11de682c65a1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1718,9 +1718,6 @@ extern const struct file_operations def_fifo_fops;
 #ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
-extern int blkdev_driver_ioctl(struct inode *inode, struct file *file,
-			       struct gendisk *disk, unsigned cmd,
-			       unsigned long arg);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, fmode_t);
 extern int blkdev_put(struct block_device *, fmode_t);

commit 572c48921574dbe6dceb958cf965aa962baefde4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 8 13:24:05 2007 -0400

    [PATCH] sanitize blkdev_get() and friends
    
    * get rid of fake struct file/struct dentry in __blkdev_get()
    * merge __blkdev_get() and do_open()
    * get rid of flags argument of blkdev_get()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c6766314dc5e..cb78e389699b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1722,7 +1722,7 @@ extern int blkdev_driver_ioctl(struct inode *inode, struct file *file,
 			       struct gendisk *disk, unsigned cmd,
 			       unsigned long arg);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
-extern int blkdev_get(struct block_device *, fmode_t, unsigned);
+extern int blkdev_get(struct block_device *, fmode_t);
 extern int blkdev_put(struct block_device *, fmode_t);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);

commit 30c40d2c01f68c7eb1a41ab3552bdaf5dbf300d4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 22 19:50:45 2008 -0500

    [PATCH] propagate mode through open_bdev_excl/close_bdev_excl
    
    replace open_bdev_excl/close_bdev_excl with variants taking fmode_t.
    superblock gets the value used to mount it stored in sb->s_mode
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 04c8dc41f454..c6766314dc5e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1157,6 +1157,7 @@ struct super_block {
 	char s_id[32];				/* Informational name */
 
 	void 			*s_fs_info;	/* Filesystem private info */
+	fmode_t			s_mode;
 
 	/*
 	 * The next field is for VFS *only*. No filesystems have any business
@@ -1753,9 +1754,10 @@ extern void chrdev_show(struct seq_file *,off_t);
 extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
-extern struct block_device *open_bdev_excl(const char *, int, void *);
-extern void close_bdev_excl(struct block_device *);
+extern struct block_device *open_bdev_exclusive(const char *, fmode_t, void *);
+extern void close_bdev_exclusive(struct block_device *, fmode_t);
 extern void blkdev_show(struct seq_file *,off_t);
+
 #else
 #define BLKDEV_MAJOR_HASH_SIZE	0
 #endif

commit 9a1c3542768b5a58e45a9216921cd10a3bae1205
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Feb 22 20:40:24 2008 -0500

    [PATCH] pass fmode_t to blkdev_put()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b5894604ba5e..04c8dc41f454 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1722,7 +1722,7 @@ extern int blkdev_driver_ioctl(struct inode *inode, struct file *file,
 			       unsigned long arg);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, fmode_t, unsigned);
-extern int blkdev_put(struct block_device *);
+extern int blkdev_put(struct block_device *, fmode_t);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);
 #ifdef CONFIG_SYSFS

commit d4430d62fa77208824a37fe6f85ab2831d274769
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 2 09:09:22 2008 -0500

    [PATCH] beginning of methods conversion
    
    To keep the size of changesets sane we split the switch by drivers;
    to keep the damn thing bisectable we do the following:
            1) rename the affected methods, add ones with correct
    prototypes, make (few) callers handle both.  That's this changeset.
            2) for each driver convert to new methods.  *ALL* drivers
    are converted in this series.
            3) kill the old (renamed) methods.
    
    Note that it _is_ a flagday; all in-tree drivers are converted and by the
    end of this series no trace of old methods remain.  The only reason why
    we do that this way is to keep the damn thing bisectable and allow per-driver
    debugging if anything goes wrong.
    
    New methods:
            open(bdev, mode)
            release(disk, mode)
            ioctl(bdev, mode, cmd, arg)             /* Called without BKL */
            compat_ioctl(bdev, mode, cmd, arg)
            locked_ioctl(bdev, mode, cmd, arg)      /* Called with BKL, legacy */
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 58bbf689fef7..b5894604ba5e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -79,6 +79,7 @@ extern int dir_notify_enable;
 #define FMODE_NDELAY	((__force fmode_t)32)
 #define FMODE_EXCL	((__force fmode_t)64)
 #define FMODE_WRITE_IOCTL	((__force fmode_t)128)
+#define FMODE_NDELAY_NOW	((__force fmode_t)256)
 
 #define RW_MASK		1
 #define RWA_MASK	2

commit 08f85851215100d0eebf026810955ee6ad456c38
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 8 13:26:20 2007 -0400

    [PATCH] move block_device_operations to blkdev.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5ab5579a5162..58bbf689fef7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1270,20 +1270,7 @@ int generic_osync_inode(struct inode *, struct address_space *, int);
  * to have different dirent layouts depending on the binary type.
  */
 typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
-
-struct block_device_operations {
-	int (*open) (struct inode *, struct file *);
-	int (*release) (struct inode *, struct file *);
-	int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
-	long (*unlocked_ioctl) (struct file *, unsigned, unsigned long);
-	long (*compat_ioctl) (struct file *, unsigned, unsigned long);
-	int (*direct_access) (struct block_device *, sector_t,
-						void **, unsigned long *);
-	int (*media_changed) (struct gendisk *);
-	int (*revalidate_disk) (struct gendisk *);
-	int (*getgeo)(struct block_device *, struct hd_geometry *);
-	struct module *owner;
-};
+struct block_device_operations;
 
 /* These macros are for out of kernel modules to test that
  * the kernel supports the unlocked_ioctl and compat_ioctl

commit 86d434dede14108dd917b25af0f29c0cb28b8d18
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Aug 26 19:50:05 2007 -0400

    [PATCH] eliminate use of ->f_flags in block methods
    
    store needed information in f_mode
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 60a7a581ba91..5ab5579a5162 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -76,6 +76,10 @@ extern int dir_notify_enable;
    behavior for cross-node execution/opening_for_writing of files */
 #define FMODE_EXEC	((__force fmode_t)16)
 
+#define FMODE_NDELAY	((__force fmode_t)32)
+#define FMODE_EXCL	((__force fmode_t)64)
+#define FMODE_WRITE_IOCTL	((__force fmode_t)128)
+
 #define RW_MASK		1
 #define RWA_MASK	2
 #define READ 0

commit aeb5d727062a0238a2f96c9c380fbd2be4640c6f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 2 15:28:45 2008 -0400

    [PATCH] introduce fmode_t, do annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a6a625be13fc..60a7a581ba91 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -63,18 +63,18 @@ extern int dir_notify_enable;
 #define MAY_ACCESS 16
 #define MAY_OPEN 32
 
-#define FMODE_READ 1
-#define FMODE_WRITE 2
+#define FMODE_READ ((__force fmode_t)1)
+#define FMODE_WRITE ((__force fmode_t)2)
 
 /* Internal kernel extensions */
-#define FMODE_LSEEK	4
-#define FMODE_PREAD	8
+#define FMODE_LSEEK	((__force fmode_t)4)
+#define FMODE_PREAD	((__force fmode_t)8)
 #define FMODE_PWRITE	FMODE_PREAD	/* These go hand in hand */
 
 /* File is being opened for execution. Primary users of this flag are
    distributed filesystems that can use it to achieve correct ETXTBUSY
    behavior for cross-node execution/opening_for_writing of files */
-#define FMODE_EXEC	16
+#define FMODE_EXEC	((__force fmode_t)16)
 
 #define RW_MASK		1
 #define RWA_MASK	2
@@ -825,7 +825,7 @@ struct file {
 	const struct file_operations	*f_op;
 	atomic_long_t		f_count;
 	unsigned int 		f_flags;
-	mode_t			f_mode;
+	fmode_t			f_mode;
 	loff_t			f_pos;
 	struct fown_struct	f_owner;
 	unsigned int		f_uid, f_gid;
@@ -1714,7 +1714,7 @@ extern struct block_device *bdget(dev_t);
 extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
-extern struct block_device *open_by_devnum(dev_t, unsigned);
+extern struct block_device *open_by_devnum(dev_t, fmode_t);
 #else
 static inline void bd_forget(struct inode *inode) {}
 #endif
@@ -1729,7 +1729,7 @@ extern int blkdev_driver_ioctl(struct inode *inode, struct file *file,
 			       struct gendisk *disk, unsigned cmd,
 			       unsigned long arg);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
-extern int blkdev_get(struct block_device *, mode_t, unsigned);
+extern int blkdev_get(struct block_device *, fmode_t, unsigned);
 extern int blkdev_put(struct block_device *);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);

commit 8acd3a60bcca17c6d89c73cee3ad6057eb83ba1e
Merge: c269bc00fcb8 107e0008dfb8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 14 12:31:14 2008 -0700

    Merge branch 'for-2.6.28' of git://linux-nfs.org/~bfields/linux
    
    * 'for-2.6.28' of git://linux-nfs.org/~bfields/linux: (59 commits)
      svcrdma: Fix IRD/ORD polarity
      svcrdma: Update svc_rdma_send_error to use DMA LKEY
      svcrdma: Modify the RPC reply path to use FRMR when available
      svcrdma: Modify the RPC recv path to use FRMR when available
      svcrdma: Add support to svc_rdma_send to handle chained WR
      svcrdma: Modify post recv path to use local dma key
      svcrdma: Add a service to register a Fast Reg MR with the device
      svcrdma: Query device for Fast Reg support during connection setup
      svcrdma: Add FRMR get/put services
      NLM: Remove unused argument from svc_addsock() function
      NLM: Remove "proto" argument from lockd_up()
      NLM: Always start both UDP and TCP listeners
      lockd: Remove unused fields in the nlm_reboot structure
      lockd: Add helper to sanity check incoming NOTIFY requests
      lockd: change nlmclnt_grant() to take a "struct sockaddr *"
      lockd: Adjust nlmsvc_lookup_host() to accomodate AF_INET6 addresses
      lockd: Adjust nlmclnt_lookup_host() signature to accomodate non-AF_INET
      lockd: Support non-AF_INET addresses in nlm_lookup_host()
      NLM: Convert nlm_lookup_host() to use a single argument
      svcrdma: Add Fast Reg MR Data Types
      ...

commit fd048088306656824958e7783ffcee27e241b361
Merge: 5c3c4d9b5810 03010a335030
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 11 13:23:48 2008 -0700

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (43 commits)
      ext4: Rename ext4dev to ext4
      ext4: Avoid double dirtying of super block in ext4_put_super()
      Update ext4 MAINTAINERS file
      Hook ext4 to the vfs fiemap interface.
      generic block based fiemap implementation
      ocfs2: fiemap support
      vfs: vfs-level fiemap interface
      ext4: fix xattr deadlock
      jbd2: Fix buffer head leak when writing the commit block
      ext4: Add debugging markers that can be used by systemtap
      jbd2: abort instead of waiting for nonexistent transaction
      ext4: fix initialization of UNINIT bitmap blocks
      ext4: Remove old legacy block allocator
      ext4: Use readahead when reading an inode from the inode table
      ext4: Improve the documentation for ext4's /proc tunables
      ext4: Combine proc file handling into a single set of functions
      ext4: move /proc setup and teardown out of mballoc.c
      ext4: Don't use 'struct dentry' for internal lookups
      ext4/jbd2: Avoid WARN() messages when failing to write to the superblock
      ext4: use percpu data structures for lg_prealloc_list
      ...

commit c3279d1454cdfed02a557d789d8a6d08ab4cbe70
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Thu Sep 4 14:27:25 2008 -0600

    Adjust block device size after an online resize of a disk.
    
    The revalidate_disk routine now checks if a disk has been resized by
    comparing the gendisk capacity to the bdev inode size.  If they are
    different (usually because the disk has been resized underneath the kernel)
    the bdev inode size is adjusted to match the capacity.
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d63461f97983..32477e8872d5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1722,6 +1722,8 @@ extern int fs_may_remount_ro(struct super_block *);
  */
 #define bio_data_dir(bio)	((bio)->bi_rw & 1)
 
+extern void check_disk_size_change(struct gendisk *disk,
+				   struct block_device *bdev);
 extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *);

commit 0c002c2f74e10baa9021d3ecc50585c6eafea568
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Thu Sep 4 14:27:20 2008 -0600

    Wrapper for lower-level revalidate_disk routines.
    
    This is a wrapper for the lower-level revalidate_disk call-backs such
    as sd_revalidate_disk(). It allows us to perform pre and post
    operations when calling them.
    
    We will use this wrapper in a later patch to adjust block device sizes
    after an online resize (a _post_ operation).
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 02a9fb5a830c..d63461f97983 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1722,6 +1722,7 @@ extern int fs_may_remount_ro(struct super_block *);
  */
 #define bio_data_dir(bio)	((bio)->bi_rw & 1)
 
+extern int revalidate_disk(struct gendisk *);
 extern int check_disk_change(struct block_device *);
 extern int __invalidate_device(struct block_device *);
 extern int invalidate_partition(struct gendisk *, int);

commit 1f0142905d4812966831613847db38a66da29eb8
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 25 19:47:23 2008 +0900

    block: adjust formatting for large minors and add ext_range sysfs attr
    
    With extended minors and the soon-to-follow debug feature, large minor
    numbers for block devices will be common.  This patch does the
    followings to make printouts pretty.
    
    * Adapt print formats such that large minors don't break the
      formatting.
    
    * For extended MAJ:MIN, %02x%02x for MAJ:MIN used in
      printk_all_partitions() doesn't cut it anymore.  Update it such that
      %03x:%05x is used if either MAJ or MIN doesn't fit in %02x.
    
    * Implement ext_range sysfs attribute which shows total minors the
      device can use including both conventional minor space and the
      extended one.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 860689f541b1..02a9fb5a830c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1685,6 +1685,7 @@ extern void chrdev_show(struct seq_file *,off_t);
 
 /* fs/block_dev.c */
 #define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
+#define BDEVT_SIZE	10	/* Largest string for MAJ:MIN for blkdev */
 
 #ifdef CONFIG_BLOCK
 #define BLKDEV_MAJOR_HASH_SIZE	255

commit e17fc0a1ccf88f6d4dcb363729f3141b0958c325
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sat Aug 9 16:42:20 2008 +0100

    Allow elevators to sort/merge discard requests
    
    But blkdev_issue_discard() still emits requests which are interpreted as
    soft barriers, because nave callers might otherwise issue subsequent
    writes to those same sectors, which might cross on the queue (if they're
    reallocated quickly enough).
    
    Callers still _can_ issue non-barrier discard requests, but they have to
    take care of queue ordering for themselves.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 88358ca6af25..860689f541b1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -87,7 +87,8 @@ extern int dir_notify_enable;
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
 #define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNC))
 #define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
-#define WRITE_DISCARD	(WRITE | (1 << BIO_RW_DISCARD))
+#define DISCARD_NOBARRIER (1 << BIO_RW_DISCARD)
+#define DISCARD_BARRIER ((1 << BIO_RW_DISCARD) | (1 << BIO_RW_BARRIER))
 
 #define SEL_IN		1
 #define SEL_OUT		2

commit d30a2605be9d5132d95944916e8f578fcfe4f976
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Aug 11 15:58:42 2008 +0100

    Add BLKDISCARD ioctl to allow userspace to discard sectors
    
    We may well want mkfs tools to use this to mark the whole device as
    unwanted before they format it, for example.
    
    The ioctl takes a pair of uint64_ts, which are start offset and length
    in _bytes_. Although at the moment it might make sense for them both to
    be in 512-byte sectors, I don't want to limit the ABI to that.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eb0131319134..88358ca6af25 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -223,6 +223,7 @@ extern int dir_notify_enable;
 #define BLKTRACESTART _IO(0x12,116)
 #define BLKTRACESTOP _IO(0x12,117)
 #define BLKTRACETEARDOWN _IO(0x12,118)
+#define BLKDISCARD _IO(0x12,119)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit fb2dce862d9f9a68e6b9374579056ec9eca02a63
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Tue Aug 5 18:01:53 2008 +0100

    Add 'discard' request handling
    
    Some block devices benefit from a hint that they can forget the contents
    of certain sectors. Add basic support for this to the block core, along
    with a 'blkdev_issue_discard()' helper function which issues such
    requests.
    
    The caller doesn't get to provide an end_io functio, since
    blkdev_issue_discard() will automatically split the request up into
    multiple bios if appropriate. Neither does the function wait for
    completion -- it's expected that callers won't care about when, or even
    _if_, the request completes. It's only a hint to the device anyway. By
    definition, the file system doesn't _care_ about these sectors any more.
    
    [With feedback from OGAWA Hirofumi <hirofumi@mail.parknet.co.jp> and
    Jens Axboe <jens.axboe@oracle.com]
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 580b513668fe..eb0131319134 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -86,7 +86,8 @@ extern int dir_notify_enable;
 #define READ_META	(READ | (1 << BIO_RW_META))
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
 #define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNC))
-#define WRITE_BARRIER	((1 << BIO_RW) | (1 << BIO_RW_BARRIER))
+#define WRITE_BARRIER	(WRITE | (1 << BIO_RW_BARRIER))
+#define WRITE_DISCARD	(WRITE | (1 << BIO_RW_DISCARD))
 
 #define SEL_IN		1
 #define SEL_OUT		2

commit 68c9d702bb72f367f3b148963ec6cf5e07ff7f65
Author: Josef Bacik <jbacik@redhat.com>
Date:   Fri Oct 3 17:32:43 2008 -0400

    generic block based fiemap implementation
    
    Any block based fs (this patch includes ext3) just has to declare its own
    fiemap() function and then call this generic function with its own
    get_block_t. This works well for block based filesystems that will map
    multiple contiguous blocks at one time, but will work for filesystems that
    only map one block at a time, you will just end up with an "extent" for each
    block. One gotcha is this will not play nicely where there is hole+data
    after the EOF. This function will assume its hit the end of the data as soon
    as it hits a hole after the EOF, so if there is any data past that it will
    not pick that up. AFAIK no block based fs does this anyway, but its in the
    comments of the function anyway just in case.
    
    Signed-off-by: Josef Bacik <jbacik@redhat.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: linux-fsdevel@vger.kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 194fb237a307..385c9a197df1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1998,6 +1998,9 @@ extern int vfs_fstat(unsigned int, struct kstat *);
 
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
+extern int generic_block_fiemap(struct inode *inode,
+				struct fiemap_extent_info *fieinfo, u64 start,
+				u64 len, get_block_t *get_block);
 
 extern void get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);

commit c4b929b85bdb64afacbbf6453b1f2bf7e14c9e89
Author: Mark Fasheh <mfasheh@suse.com>
Date:   Wed Oct 8 19:44:18 2008 -0400

    vfs: vfs-level fiemap interface
    
    Basic vfs-level fiemap infrastructure, which sets up a new ->fiemap
    inode operation.
    
    Userspace can get extent information on a file via fiemap ioctl. As input,
    the fiemap ioctl takes a struct fiemap which includes an array of struct
    fiemap_extent (fm_extents). Size of the extent array is passed as
    fm_extent_count and number of extents returned will be written into
    fm_mapped_extents. Offset and length fields on the fiemap structure
    (fm_start, fm_length) describe a logical range which will be searched for
    extents. All extents returned will at least partially contain this range.
    The actual extent offsets and ranges returned will be unmodified from their
    offset and range on-disk.
    
    The fiemap ioctl returns '0' on success. On error, -1 is returned and errno
    is set. If errno is equal to EBADR, then fm_flags will contain those flags
    which were passed in which the kernel did not understand. On all other
    errors, the contents of fm_extents is undefined.
    
    As fiemap evolved, there have been many authors of the vfs patch. As far as
    I can tell, the list includes:
    Kalpak Shah <kalpak.shah@sun.com>
    Andreas Dilger <adilger@sun.com>
    Eric Sandeen <sandeen@redhat.com>
    Mark Fasheh <mfasheh@suse.com>
    
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: linux-api@vger.kernel.org
    Cc: linux-fsdevel@vger.kernel.org

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 580b513668fe..194fb237a307 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -231,6 +231,7 @@ extern int dir_notify_enable;
 #define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
 #define	FS_IOC_GETVERSION		_IOR('v', 1, long)
 #define	FS_IOC_SETVERSION		_IOW('v', 2, long)
+#define FS_IOC_FIEMAP			_IOWR('f', 11, struct fiemap)
 #define FS_IOC32_GETFLAGS		_IOR('f', 1, int)
 #define FS_IOC32_SETFLAGS		_IOW('f', 2, int)
 #define FS_IOC32_GETVERSION		_IOR('v', 1, int)
@@ -291,6 +292,7 @@ extern int dir_notify_enable;
 #include <linux/mutex.h>
 #include <linux/capability.h>
 #include <linux/semaphore.h>
+#include <linux/fiemap.h>
 
 #include <asm/atomic.h>
 #include <asm/byteorder.h>
@@ -1178,6 +1180,20 @@ extern void dentry_unhash(struct dentry *dentry);
  */
 extern int file_permission(struct file *, int);
 
+/*
+ * VFS FS_IOC_FIEMAP helper definitions.
+ */
+struct fiemap_extent_info {
+	unsigned int fi_flags;		/* Flags as passed from user */
+	unsigned int fi_extents_mapped;	/* Number of mapped extents */
+	unsigned int fi_extents_max;	/* Size of fiemap_extent array */
+	struct fiemap_extent *fi_extents_start; /* Start of fiemap_extent
+						 * array */
+};
+int fiemap_fill_next_extent(struct fiemap_extent_info *info, u64 logical,
+			    u64 phys, u64 len, u32 flags);
+int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags);
+
 /*
  * File types
  *
@@ -1287,6 +1303,8 @@ struct inode_operations {
 	void (*truncate_range)(struct inode *, loff_t, loff_t);
 	long (*fallocate)(struct inode *inode, int mode, loff_t offset,
 			  loff_t len);
+	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,
+		      u64 len);
 };
 
 struct seq_file;

commit af558e33bedab672f5cfd3260bce7445e353fe21
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Sep 6 12:34:25 2007 -0400

    nfsd: common grace period control
    
    Rewrite grace period code to unify management of grace period across
    lockd and nfsd.  The current code has lockd and nfsd cooperate to
    compute a grace period which is satisfactory to them both, and then
    individually enforce it.  This creates a slight race condition, since
    the enforcement is not coordinated.  It's also more complicated than
    necessary.
    
    Here instead we have lockd and nfsd each inform common code when they
    enter the grace period, and when they're ready to leave the grace
    period, and allow normal locking only after both of them are ready to
    leave.
    
    We also expect the locks_start_grace()/locks_end_grace() interface here
    to be simpler to build on for future cluster/high-availability work,
    which may require (for example) putting individual filesystems into
    grace, or enforcing grace periods across multiple cluster nodes.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9f540165a078..27cfa723b92a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -942,6 +942,14 @@ struct lock_manager_operations {
 	int (*fl_change)(struct file_lock **, int);
 };
 
+struct lock_manager {
+	struct list_head list;
+};
+
+void locks_start_grace(struct lock_manager *);
+void locks_end_grace(struct lock_manager *);
+int locks_in_grace(void);
+
 /* that will die - we need it for nfs_lock_info */
 #include <linux/nfs_fs_i.h>
 

commit bfcd17a6c5529bc37234cfa720a047cf9397bcfc
Author: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
Date:   Wed Aug 6 15:12:22 2008 +0200

    Configure out file locking features
    
    This patch adds the CONFIG_FILE_LOCKING option which allows to remove
    support for advisory locks. With this patch enabled, the flock()
    system call, the F_GETLK, F_SETLK and F_SETLKW operations of fcntl()
    and NFS support are disabled. These features are not necessarly needed
    on embedded systems. It allows to save ~11 Kb of kernel code and data:
    
       text          data     bss     dec     hex filename
    1125436        118764  212992 1457192  163c28 vmlinux.old
    1114299        118564  212992 1445855  160fdf vmlinux
     -11137    -200       0  -11337   -2C49 +/-
    
    This patch has originally been written by Matt Mackall
    <mpm@selenic.com>, and is part of the Linux Tiny project.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Cc: matthew@wil.cx
    Cc: linux-fsdevel@vger.kernel.org
    Cc: mpm@selenic.com
    Cc: akpm@linux-foundation.org
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 580b513668fe..9f540165a078 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -983,6 +983,13 @@ struct file_lock {
 
 #include <linux/fcntl.h>
 
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+
+/* fs/sync.c */
+extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
+			loff_t endbyte, unsigned int flags);
+
+#ifdef CONFIG_FILE_LOCKING
 extern int fcntl_getlk(struct file *, struct flock __user *);
 extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
 			struct flock __user *);
@@ -993,14 +1000,9 @@ extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
 			struct flock64 __user *);
 #endif
 
-extern void send_sigio(struct fown_struct *fown, int fd, int band);
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
-/* fs/sync.c */
-extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
-			loff_t endbyte, unsigned int flags);
-
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
@@ -1023,6 +1025,37 @@ extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
 extern struct seq_operations locks_seq_operations;
+#else /* !CONFIG_FILE_LOCKING */
+#define fcntl_getlk(a, b) ({ -EINVAL; })
+#define fcntl_setlk(a, b, c, d) ({ -EACCES; })
+#if BITS_PER_LONG == 32
+#define fcntl_getlk64(a, b) ({ -EINVAL; })
+#define fcntl_setlk64(a, b, c, d) ({ -EACCES; })
+#endif
+#define fcntl_setlease(a, b, c) ({ 0; })
+#define fcntl_getlease(a) ({ 0; })
+#define locks_init_lock(a) ({ })
+#define __locks_copy_lock(a, b) ({ })
+#define locks_copy_lock(a, b) ({ })
+#define locks_remove_posix(a, b) ({ })
+#define locks_remove_flock(a) ({ })
+#define posix_test_lock(a, b) ({ 0; })
+#define posix_lock_file(a, b, c) ({ -ENOLCK; })
+#define posix_lock_file_wait(a, b) ({ -ENOLCK; })
+#define posix_unblock_lock(a, b) (-ENOENT)
+#define vfs_test_lock(a, b) ({ 0; })
+#define vfs_lock_file(a, b, c, d) (-ENOLCK)
+#define vfs_cancel_lock(a, b) ({ 0; })
+#define flock_lock_file_wait(a, b) ({ -ENOLCK; })
+#define __break_lease(a, b) ({ 0; })
+#define lease_get_mtime(a, b) ({ })
+#define generic_setlease(a, b, c) ({ -EINVAL; })
+#define vfs_setlease(a, b, c) ({ -EINVAL; })
+#define lease_modify(a, b) ({ -EINVAL; })
+#define lock_may_read(a, b, c) ({ 1; })
+#define lock_may_write(a, b, c) ({ 1; })
+#endif /* !CONFIG_FILE_LOCKING */
+
 
 struct fasync_struct {
 	int	magic;
@@ -1554,9 +1587,12 @@ extern int vfs_statfs(struct dentry *, struct kstatfs *);
 /* /sys/fs */
 extern struct kobject *fs_kobj;
 
+extern int rw_verify_area(int, struct file *, loff_t *, size_t);
+
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2
 
+#ifdef CONFIG_FILE_LOCKING
 extern int locks_mandatory_locked(struct inode *);
 extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
 
@@ -1587,8 +1623,6 @@ static inline int locks_verify_locked(struct inode *inode)
 	return 0;
 }
 
-extern int rw_verify_area(int, struct file *, loff_t *, size_t);
-
 static inline int locks_verify_truncate(struct inode *inode,
 				    struct file *filp,
 				    loff_t size)
@@ -1609,6 +1643,15 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 		return __break_lease(inode, mode);
 	return 0;
 }
+#else /* !CONFIG_FILE_LOCKING */
+#define locks_mandatory_locked(a) ({ 0; })
+#define locks_mandatory_area(a, b, c, d, e) ({ 0; })
+#define __mandatory_lock(a) ({ 0; })
+#define mandatory_lock(a) ({ 0; })
+#define locks_verify_locked(a) ({ 0; })
+#define locks_verify_truncate(a, b, c) ({ 0; })
+#define break_lease(a, b) ({ 0; })
+#endif /* CONFIG_FILE_LOCKING */
 
 /* fs/open.c */
 

commit 8ab22b9abb5c55413802e4adc9aa6223324547c3
Author: Hisashi Hifumi <hifumi.hisashi@oss.ntt.co.jp>
Date:   Mon Jul 28 15:46:36 2008 -0700

    vfs: pagecache usage optimization for pagesize!=blocksize
    
    When we read some part of a file through pagecache, if there is a
    pagecache of corresponding index but this page is not uptodate, read IO
    is issued and this page will be uptodate.
    
    I think this is good for pagesize == blocksize environment but there is
    room for improvement on pagesize != blocksize environment.  Because in
    this case a page can have multiple buffers and even if a page is not
    uptodate, some buffers can be uptodate.
    
    So I suggest that when all buffers which correspond to a part of a file
    that we want to read are uptodate, use this pagecache and copy data from
    this pagecache to user buffer even if a page is not uptodate.  This can
    reduce read IO and improve system throughput.
    
    I wrote a benchmark program and got result number with this program.
    
    This benchmark do:
    
      1: mount and open a test file.
    
      2: create a 512MB file.
    
      3: close a file and umount.
    
      4: mount and again open a test file.
    
      5: pwrite randomly 300000 times on a test file.  offset is aligned
         by IO size(1024bytes).
    
      6: measure time of preading randomly 100000 times on a test file.
    
    The result was:
            2.6.26
            330 sec
    
            2.6.26-patched
            226 sec
    
    Arch:i386
    Filesystem:ext3
    Blocksize:1024 bytes
    Memory: 1GB
    
    On ext3/4, a file is written through buffer/block.  So random read/write
    mixed workloads or random read after random write workloads are optimized
    with this patch under pagesize != blocksize environment.  This test result
    showed this.
    
    The benchmark program is as follows:
    
    #include <stdio.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <time.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/mount.h>
    
    #define LEN 1024
    #define LOOP 1024*512 /* 512MB */
    
    main(void)
    {
            unsigned long i, offset, filesize;
            int fd;
            char buf[LEN];
            time_t t1, t2;
    
            if (mount("/dev/sda1", "/root/test1/", "ext3", 0, 0) < 0) {
                    perror("cannot mount\n");
                    exit(1);
            }
            memset(buf, 0, LEN);
            fd = open("/root/test1/testfile", O_CREAT|O_RDWR|O_TRUNC);
            if (fd < 0) {
                    perror("cannot open file\n");
                    exit(1);
            }
            for (i = 0; i < LOOP; i++)
                    write(fd, buf, LEN);
            close(fd);
            if (umount("/root/test1/") < 0) {
                    perror("cannot umount\n");
                    exit(1);
            }
            if (mount("/dev/sda1", "/root/test1/", "ext3", 0, 0) < 0) {
                    perror("cannot mount\n");
                    exit(1);
            }
            fd = open("/root/test1/testfile", O_RDWR);
            if (fd < 0) {
                    perror("cannot open file\n");
                    exit(1);
            }
    
            filesize = LEN * LOOP;
            for (i = 0; i < 300000; i++){
                    offset = (random() % filesize) & (~(LEN - 1));
                    pwrite(fd, buf, LEN, offset);
            }
            printf("start test\n");
            time(&t1);
            for (i = 0; i < 100000; i++){
                    offset = (random() % filesize) & (~(LEN - 1));
                    pread(fd, buf, LEN, offset);
            }
            time(&t2);
            printf("%ld sec\n", t2-t1);
            close(fd);
            if (umount("/root/test1/") < 0) {
                    perror("cannot umount\n");
                    exit(1);
            }
    }
    
    Signed-off-by: Hisashi Hifumi <hifumi.hisashi@oss.ntt.co.jp>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: <linux-ext4@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8252b045e624..580b513668fe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -443,6 +443,27 @@ static inline size_t iov_iter_count(struct iov_iter *i)
 	return i->count;
 }
 
+/*
+ * "descriptor" for what we're up to with a read.
+ * This allows us to use the same read code yet
+ * have multiple different users of the data that
+ * we read from a file.
+ *
+ * The simplest case just copies the data to user
+ * mode.
+ */
+typedef struct {
+	size_t written;
+	size_t count;
+	union {
+		char __user *buf;
+		void *data;
+	} arg;
+	int error;
+} read_descriptor_t;
+
+typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
+		unsigned long, unsigned long);
 
 struct address_space_operations {
 	int (*writepage)(struct page *page, struct writeback_control *wbc);
@@ -484,6 +505,8 @@ struct address_space_operations {
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *);
 	int (*launder_page) (struct page *);
+	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
+					unsigned long);
 };
 
 /*
@@ -1198,27 +1221,6 @@ struct block_device_operations {
 	struct module *owner;
 };
 
-/*
- * "descriptor" for what we're up to with a read.
- * This allows us to use the same read code yet
- * have multiple different users of the data that
- * we read from a file.
- *
- * The simplest case just copies the data to user
- * mode.
- */
-typedef struct {
-	size_t written;
-	size_t count;
-	union {
-		char __user * buf;
-		void *data;
-	} arg;
-	int error;
-} read_descriptor_t;
-
-typedef int (*read_actor_t)(read_descriptor_t *, struct page *, unsigned long, unsigned long);
-
 /* These macros are for out of kernel modules to test that
  * the kernel supports the unlocked_ioctl and compat_ioctl
  * fields in struct file_operations. */

commit 3f8206d496e9e9495afb1d4e70d29712b4d403c9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 26 03:46:43 2008 -0400

    [PATCH] get rid of indirect users of namei.h
    
    fs.h needs path.h, not namei.h; nfs_fs.h doesn't need it at all.
    Several places in the tree needed direct include.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7676fa1c20ae..8252b045e624 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -279,7 +279,7 @@ extern int dir_notify_enable;
 #include <linux/types.h>
 #include <linux/kdev_t.h>
 #include <linux/dcache.h>
-#include <linux/namei.h>
+#include <linux/path.h>
 #include <linux/stat.h>
 #include <linux/cache.h>
 #include <linux/kobject.h>

commit 516e0cc5646f377ab80fcc2ee639892eccb99853
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Jul 26 00:39:17 2008 -0400

    [PATCH] f_count may wrap around
    
    make it atomic_long_t; while we are at it, get rid of useless checks in affs,
    hfs and hpfs - ->open() always has it equal to 1, ->release() - to 0.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9d2de4cadabd..7676fa1c20ae 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -795,7 +795,7 @@ struct file {
 #define f_dentry	f_path.dentry
 #define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
-	atomic_t		f_count;
+	atomic_long_t		f_count;
 	unsigned int 		f_flags;
 	mode_t			f_mode;
 	loff_t			f_pos;
@@ -824,8 +824,8 @@ extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
 #define file_list_unlock() spin_unlock(&files_lock);
 
-#define get_file(x)	atomic_inc(&(x)->f_count)
-#define file_count(x)	atomic_read(&(x)->f_count)
+#define get_file(x)	atomic_long_inc(&(x)->f_count)
+#define file_count(x)	atomic_long_read(&(x)->f_count)
 
 #ifdef CONFIG_DEBUG_WRITECOUNT
 static inline void file_take_write(struct file *f)

commit f419a2e3b64def707e1384ee38abb77f99af5f6d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 22 00:07:17 2008 -0400

    [PATCH] kill nameidata passing to permission(), rename to inode_permission()
    
    Incidentally, the name that gives hundreds of false positives on grep
    is not a good idea...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 527b9e482f99..9d2de4cadabd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1770,7 +1770,7 @@ extern int do_remount_sb(struct super_block *sb, int flags,
 extern sector_t bmap(struct inode *, sector_t);
 #endif
 extern int notify_change(struct dentry *, struct iattr *);
-extern int permission(struct inode *, int, struct nameidata *);
+extern int inode_permission(struct inode *, int);
 extern int generic_permission(struct inode *, int,
 		int (*check_acl)(struct inode *, int));
 

commit 9767d74957450da6365c363d69e3d02d605d7375
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jul 1 15:01:26 2008 +0200

    [patch 1/4] vfs: utimes: move owner check into inode_change_ok()
    
    Add a new ia_valid flag: ATTR_TIMES_SET, to handle the
    UTIMES_OMIT/UTIMES_NOW and UTIMES_NOW/UTIMES_OMIT cases.  In these
    cases neither ATTR_MTIME_SET nor ATTR_ATIME_SET is in the flags, yet
    the POSIX draft specifies that permission checking is performed the
    same way as if one or both of the times was explicitly set to a
    timestamp.
    
    See the path "vfs: utimensat(): fix error checking for
    {UTIME_NOW,UTIME_OMIT} case" by Michael Kerrisk for the patch
    introducing this behavior.
    
    This is a cleanup, as well as allowing filesystems (NFS/fuse/...) to
    perform their own permission checking instead of the default.
    
    CC: Ulrich Drepper <drepper@redhat.com>
    CC: Michael Kerrisk <mtk.manpages@gmail.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d8721e818b45..527b9e482f99 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -320,22 +320,23 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
  * Attribute flags.  These should be or-ed together to figure out what
  * has been changed!
  */
-#define ATTR_MODE	1
-#define ATTR_UID	2
-#define ATTR_GID	4
-#define ATTR_SIZE	8
-#define ATTR_ATIME	16
-#define ATTR_MTIME	32
-#define ATTR_CTIME	64
-#define ATTR_ATIME_SET	128
-#define ATTR_MTIME_SET	256
-#define ATTR_FORCE	512	/* Not a change, but a change it */
-#define ATTR_ATTR_FLAG	1024
-#define ATTR_KILL_SUID	2048
-#define ATTR_KILL_SGID	4096
-#define ATTR_FILE	8192
-#define ATTR_KILL_PRIV	16384
-#define ATTR_OPEN	32768	/* Truncating from open(O_TRUNC) */
+#define ATTR_MODE	(1 << 0)
+#define ATTR_UID	(1 << 1)
+#define ATTR_GID	(1 << 2)
+#define ATTR_SIZE	(1 << 3)
+#define ATTR_ATIME	(1 << 4)
+#define ATTR_MTIME	(1 << 5)
+#define ATTR_CTIME	(1 << 6)
+#define ATTR_ATIME_SET	(1 << 7)
+#define ATTR_MTIME_SET	(1 << 8)
+#define ATTR_FORCE	(1 << 9) /* Not a change, but a change it */
+#define ATTR_ATTR_FLAG	(1 << 10)
+#define ATTR_KILL_SUID	(1 << 11)
+#define ATTR_KILL_SGID	(1 << 12)
+#define ATTR_FILE	(1 << 13)
+#define ATTR_KILL_PRIV	(1 << 14)
+#define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
+#define ATTR_TIMES_SET	(1 << 16)
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It

commit a110343f0d6d41f68b7cf8c00b57a3172c67f816
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jul 17 09:19:08 2008 -0400

    [PATCH] fix MAY_CHDIR/MAY_ACCESS/LOOKUP_ACCESS mess
    
    * MAY_CHDIR is redundant - it's an equivalent of MAY_ACCESS
    * MAY_ACCESS on fuse should affect only the last step of pathname resolution
    * fchdir() and chroot() should pass MAY_ACCESS, for the same reason why
      chdir() needs that.
    * now that we pass MAY_ACCESS explicitly in all cases, LOOKUP_ACCESS can be
      removed; it has no business being in nameidata.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 25998e803fc2..d8721e818b45 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -61,8 +61,7 @@ extern int dir_notify_enable;
 #define MAY_READ 4
 #define MAY_APPEND 8
 #define MAY_ACCESS 16
-#define MAY_CHDIR 32
-#define MAY_OPEN 64
+#define MAY_OPEN 32
 
 #define FMODE_READ 1
 #define FMODE_WRITE 2

commit db2e747b14991a4c6a5c98b0e5f552a193237c03
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 24 16:50:16 2008 +0200

    [patch 5/5] vfs: remove mode parameter from vfs_symlink()
    
    Remove the unused mode parameter from vfs_symlink and callers.
    
    Thanks to Tetsuo Handa for noticing.
    
    CC: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1a3546e69f9e..25998e803fc2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1139,7 +1139,7 @@ extern int vfs_permission(struct nameidata *, int);
 extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
 extern int vfs_mkdir(struct inode *, struct dentry *, int);
 extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
-extern int vfs_symlink(struct inode *, struct dentry *, const char *, int);
+extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *);

commit 2f1936b87783a3a56c9441b27b9ba7a747f11e8e
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue Jun 24 16:50:14 2008 +0200

    [patch 3/5] vfs: change remove_suid() to file_remove_suid()
    
    All calls to remove_suid() are made with a file pointer, because
    (similarly to file_update_time) it is called when the file is written.
    
    Clean up callers by passing in a file instead of a dentry.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c923c9b79bc..1a3546e69f9e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1834,7 +1834,7 @@ extern void clear_inode(struct inode *);
 extern void destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
 extern int should_remove_suid(struct dentry *);
-extern int remove_suid(struct dentry *);
+extern int file_remove_suid(struct file *);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 extern void remove_inode_hash(struct inode *);

commit e6305c43eda10ebfd2ad9e35d6e172ccc7bb3695
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 15 21:03:57 2008 -0400

    [PATCH] sanitize ->permission() prototype
    
    * kill nameidata * argument; map the 3 bits in ->flags anybody cares
      about to new MAY_... ones and pass with the mask.
    * kill redundant gfs2_iop_permission()
    * sanitize ecryptfs_permission()
    * fix remaining places where ->permission() instances might barf on new
      MAY_... found in mask.
    
    The obvious next target in that direction is permission(9)
    
    folded fix for nfs_permission() breakage from Miklos Szeredi <mszeredi@suse.cz>
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7721a2ac9c0e..6c923c9b79bc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -60,6 +60,9 @@ extern int dir_notify_enable;
 #define MAY_WRITE 2
 #define MAY_READ 4
 #define MAY_APPEND 8
+#define MAY_ACCESS 16
+#define MAY_CHDIR 32
+#define MAY_OPEN 64
 
 #define FMODE_READ 1
 #define FMODE_WRITE 2
@@ -1272,7 +1275,7 @@ struct inode_operations {
 	void * (*follow_link) (struct dentry *, struct nameidata *);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
 	void (*truncate) (struct inode *);
-	int (*permission) (struct inode *, int, struct nameidata *);
+	int (*permission) (struct inode *, int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);

commit d2d9648ec6858e19d16a0b16da62534e85888653
Author: Denys Vlasenko <vda.linux@googlemail.com>
Date:   Tue Jul 1 14:16:09 2008 +0200

    [PATCH] reuse xxx_fifo_fops for xxx_pipe_fops
    
    Merge fifo and pipe file_operations.
    
    Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 53d2edb709b3..7721a2ac9c0e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1696,9 +1696,9 @@ extern void init_special_inode(struct inode *, umode_t, dev_t);
 extern void make_bad_inode(struct inode *);
 extern int is_bad_inode(struct inode *);
 
-extern const struct file_operations read_fifo_fops;
-extern const struct file_operations write_fifo_fops;
-extern const struct file_operations rdwr_fifo_fops;
+extern const struct file_operations read_pipefifo_fops;
+extern const struct file_operations write_pipefifo_fops;
+extern const struct file_operations rdwr_pipefifo_fops;
 
 extern int fs_may_remount_ro(struct super_block *);
 

commit 19fd6231279be3c3bdd02ed99f9b0eb195978064
Author: Nick Piggin <npiggin@suse.de>
Date:   Fri Jul 25 19:45:32 2008 -0700

    mm: spinlock tree_lock
    
    mapping->tree_lock has no read lockers.  convert the lock from an rwlock
    to a spinlock.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Reviewed-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 49d8eb7a71be..53d2edb709b3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -499,7 +499,7 @@ struct backing_dev_info;
 struct address_space {
 	struct inode		*host;		/* owner: inode, block_device */
 	struct radix_tree_root	page_tree;	/* radix tree of all pages */
-	rwlock_t		tree_lock;	/* and rwlock protecting it */
+	spinlock_t		tree_lock;	/* and lock protecting it */
 	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
 	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
 	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */

commit bde74e4bc64415b142e556a34d295a52a1b7da9d
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Jul 25 01:48:57 2008 -0700

    locks: add special return value for asynchronous locks
    
    Use a special error value FILE_LOCK_DEFERRED to mean that a locking
    operation returned asynchronously.  This is returned by
    
      posix_lock_file() for sleeping locks to mean that the lock has been
      queued on the block list, and will be woken up when it might become
      available and needs to be retried (either fl_lmops->fl_notify() is
      called or fl_wait is woken up).
    
      f_op->lock() to mean either the above, or that the filesystem will
      call back with fl_lmops->fl_grant() when the result of the locking
      operation is known.  The filesystem can do this for sleeping as well
      as non-sleeping locks.
    
    This is to make sure, that return values of -EAGAIN and -EINPROGRESS by
    filesystems are not mistaken to mean an asynchronous locking.
    
    This also makes error handling in fs/locks.c and lockd/svclock.c slightly
    cleaner.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: David Teigland <teigland@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4b86f806014c..49d8eb7a71be 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -885,6 +885,12 @@ static inline int file_check_writeable(struct file *filp)
 #define FL_CLOSE	64	/* unlock on close */
 #define FL_SLEEP	128	/* A blocking lock */
 
+/*
+ * Special return value from posix_lock_file() and vfs_lock_file() for
+ * asynchronous locking.
+ */
+#define FILE_LOCK_DEFERRED 1
+
 /*
  * The POSIX file lock owner is determined by
  * the "struct files_struct" in the thread group

commit be61a86d7237dd80510615f38ae21d6e1e98660c
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:40 2008 -0700

    flag parameters: NONBLOCK in pipe
    
    This patch adds O_NONBLOCK support to pipe2.  It is minimally more involved
    than the patches for eventfd et.al but still trivial.  The interfaces of the
    create_write_pipe and create_read_pipe helper functions were changed and the
    one other caller as well.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_pipe2
    # ifdef __x86_64__
    #  define __NR_pipe2 293
    # elif defined __i386__
    #  define __NR_pipe2 331
    # else
    #  error "need __NR_pipe2"
    # endif
    #endif
    
    int
    main (void)
    {
      int fds[2];
      if (syscall (__NR_pipe2, fds, 0) == -1)
        {
          puts ("pipe2(0) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          int fl = fcntl (fds[i], F_GETFL);
          if (fl == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if (fl & O_NONBLOCK)
            {
              printf ("pipe2(0) set non-blocking mode for fds[%d]\n", i);
              return 1;
            }
          close (fds[i]);
        }
    
      if (syscall (__NR_pipe2, fds, O_NONBLOCK) == -1)
        {
          puts ("pipe2(O_NONBLOCK) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          int fl = fcntl (fds[i], F_GETFL);
          if (fl == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if ((fl & O_NONBLOCK) == 0)
            {
              printf ("pipe2(O_NONBLOCK) does not set non-blocking mode for fds[%d]\n", i);
              return 1;
            }
          close (fds[i]);
        }
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0e80cd717d32..4b86f806014c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1778,8 +1778,8 @@ static inline void allow_write_access(struct file *file)
 }
 extern int do_pipe(int *);
 extern int do_pipe_flags(int *, int);
-extern struct file *create_read_pipe(struct file *f);
-extern struct file *create_write_pipe(void);
+extern struct file *create_read_pipe(struct file *f, int flags);
+extern struct file *create_write_pipe(int flags);
 extern void free_write_pipe(struct file *);
 
 extern struct file *do_filp_open(int dfd, const char *pathname,

commit ed8cae8ba01348bfd83333f4648dd807b04d7f08
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jul 23 21:29:30 2008 -0700

    flag parameters: pipe
    
    This patch introduces the new syscall pipe2 which is like pipe but it also
    takes an additional parameter which takes a flag value.  This patch implements
    the handling of O_CLOEXEC for the flag.  I did not add support for the new
    syscall for the architectures which have a special sys_pipe implementation.  I
    think the maintainers of those archs have the chance to go with the unified
    implementation but that's up to them.
    
    The implementation introduces do_pipe_flags.  I did that instead of changing
    all callers of do_pipe because some of the callers are written in assembler.
    I would probably screw up changing the assembly code.  To avoid breaking code
    do_pipe is now a small wrapper around do_pipe_flags.  Once all callers are
    changed over to do_pipe_flags the old do_pipe function can be removed.
    
    The following test must be adjusted for architectures other than x86 and
    x86-64 and in case the syscall numbers changed.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #include <fcntl.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    
    #ifndef __NR_pipe2
    # ifdef __x86_64__
    #  define __NR_pipe2 293
    # elif defined __i386__
    #  define __NR_pipe2 331
    # else
    #  error "need __NR_pipe2"
    # endif
    #endif
    
    int
    main (void)
    {
      int fd[2];
      if (syscall (__NR_pipe2, fd, 0) != 0)
        {
          puts ("pipe2(0) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          int coe = fcntl (fd[i], F_GETFD);
          if (coe == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if (coe & FD_CLOEXEC)
            {
              printf ("pipe2(0) set close-on-exit for fd[%d]\n", i);
              return 1;
            }
        }
      close (fd[0]);
      close (fd[1]);
    
      if (syscall (__NR_pipe2, fd, O_CLOEXEC) != 0)
        {
          puts ("pipe2(O_CLOEXEC) failed");
          return 1;
        }
      for (int i = 0; i < 2; ++i)
        {
          int coe = fcntl (fd[i], F_GETFD);
          if (coe == -1)
            {
              puts ("fcntl failed");
              return 1;
            }
          if ((coe & FD_CLOEXEC) == 0)
            {
              printf ("pipe2(O_CLOEXEC) does not set close-on-exit for fd[%d]\n", i);
              return 1;
            }
        }
      close (fd[0]);
      close (fd[1]);
    
      puts ("OK");
    
      return 0;
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Acked-by: Davide Libenzi <davidel@xmailserver.org>
    Cc: Michael Kerrisk <mtk.manpages@googlemail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e5e6a244096c..0e80cd717d32 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1777,6 +1777,7 @@ static inline void allow_write_access(struct file *file)
 		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
 }
 extern int do_pipe(int *);
+extern int do_pipe_flags(int *, int);
 extern struct file *create_read_pipe(struct file *f);
 extern struct file *create_write_pipe(void);
 extern void free_write_pipe(struct file *);

commit da3bbdd4632c0171406b2677e31494afa5bde2f8
Author: Kentaro Makita <k-makita@np.css.fujitsu.com>
Date:   Wed Jul 23 21:27:13 2008 -0700

    fix soft lock up at NFS mount via per-SB LRU-list of unused dentries
    
    [Summary]
    
     Split LRU-list of unused dentries to one per superblock to avoid soft
     lock up during NFS mounts and remounting of any filesystem.
    
     Previously I posted here:
     http://lkml.org/lkml/2008/3/5/590
    
    [Descriptions]
    
    - background
    
      dentry_unused is a list of dentries which are not referenced.
      dentry_unused grows up when references on directories or files are
      released.  This list can be very long if there is huge free memory.
    
    - the problem
    
      When shrink_dcache_sb() is called, it scans all dentry_unused linearly
      under spin_lock(), and if dentry->d_sb is differnt from given
      superblock, scan next dentry.  This scan costs very much if there are
      many entries, and very ineffective if there are many superblocks.
    
      IOW, When we need to shrink unused dentries on one dentry, but scans
      unused dentries on all superblocks in the system.  For example, we scan
      500 dentries to unmount a filesystem, but scans 1,000,000 or more unused
      dentries on other superblocks.
    
      In our case , At mounting NFS*, shrink_dcache_sb() is called to shrink
      unused dentries on NFS, but scans 100,000,000 unused dentries on
      superblocks in the system such as local ext3 filesystems.  I hear NFS
      mounting took 1 min on some system in use.
    
    * : NFS uses virtual filesystem in rpc layer, so NFS is affected by
      this problem.
    
      100,000,000 is possible number on large systems.
    
      Per-superblock LRU of unused dentried can reduce the cost in
      reasonable manner.
    
    - How to fix
    
      I found this problem is solved by David Chinner's "Per-superblock
      unused dentry LRU lists V3"(1), so I rebase it and add some fix to
      reclaim with fairness, which is in Andrew Morton's comments(2).
    
      1) http://lkml.org/lkml/2006/5/25/318
      2) http://lkml.org/lkml/2006/5/25/320
    
      Split LRU-list of unused dentries to each superblocks.  Then, NFS
      mounting will check dentries under a superblock instead of all.  But
      this spliting will break LRU of dentry-unused.  So, I've attempted to
      make reclaim unused dentrins with fairness by calculate number of
      dentries to scan on this sb based on following way
    
      number of dentries to scan on this sb =
      count * (number of dentries on this sb / number of dentries in the machine)
    
    - ToDo
     - I have to measuring performance number and do stress tests.
    
     - When unmount occurs during prune_dcache(), scanning on same
      superblock, It is unable to reach next superblock because it is gone
      away.  We restart scannig superblock from first one, it causes
      unfairness of reclaim unused dentries on first superblock.  But I think
      this happens very rarely.
    
    - Test Results
    
      Result on 6GB boxes with excessive unused dentries.
    
    Without patch:
    
    $ cat /proc/sys/fs/dentry-state
    10181835        10180203        45      0       0       0
    # mount -t nfs 10.124.60.70:/work/kernel-src nfs
    real    0m1.830s
    user    0m0.001s
    sys     0m1.653s
    
     With this patch:
    $ cat /proc/sys/fs/dentry-state
    10236610        10234751        45      0       0       0
    # mount -t nfs 10.124.60.70:/work/kernel-src nfs
    real    0m0.106s
    user    0m0.002s
    sys     0m0.032s
    
    [akpm@linux-foundation.org: fix comments]
    Signed-off-by: Kentaro Makita <k-makita@np.css.fujitsu.com>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: David Chinner <dgc@sgi.com>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ff54ae4933f3..e5e6a244096c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1025,6 +1025,7 @@ extern int send_sigurg(struct fown_struct *fown);
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
 
+#define sb_entry(list)  list_entry((list), struct super_block, s_list)
 #define S_BIAS (1<<30)
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */
@@ -1058,6 +1059,9 @@ struct super_block {
 	struct list_head	s_more_io;	/* parked for more writeback */
 	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
 	struct list_head	s_files;
+	/* s_dentry_lru and s_nr_dentry_unused are protected by dcache_lock */
+	struct list_head	s_dentry_lru;	/* unused dentry lru */
+	int			s_nr_dentry_unused;	/* # of dentry on lru */
 
 	struct block_device	*s_bdev;
 	struct mtd_info		*s_mtd;

commit e108526e77aa41c89b3be96f75d97615db2b751c
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Jul 23 21:26:44 2008 -0700

    move memory_read_from_buffer() from fs.h to string.h
    
    James Bottomley warns that inclusion of linux/fs.h in a low level
    driver was always a danger signal.  This patch moves
    memory_read_from_buffer() from fs.h to string.h and fixes includes in
    existing memory_read_from_buffer() users.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: James Bottomley <James.Bottomley@hansenpartnership.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Bob Moore <robert.moore@intel.com>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9c2ac5c0ef5c..ff54ae4933f3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2006,8 +2006,6 @@ extern void simple_release_fs(struct vfsmount **mount, int *count);
 
 extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
 			loff_t *ppos, const void *from, size_t available);
-extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
-			const void *from, size_t available);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,

commit 14b395e35d1afdd8019d11b92e28041fad591b71
Merge: 734b397cd14f 5108b2765172
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jul 20 21:21:46 2008 -0700

    Merge branch 'for-2.6.27' of git://linux-nfs.org/~bfields/linux
    
    * 'for-2.6.27' of git://linux-nfs.org/~bfields/linux: (51 commits)
      nfsd: nfs4xdr.c do-while is not a compound statement
      nfsd: Use C99 initializers in fs/nfsd/nfs4xdr.c
      lockd: Pass "struct sockaddr *" to new failover-by-IP function
      lockd: get host reference in nlmsvc_create_block() instead of callers
      lockd: minor svclock.c style fixes
      lockd: eliminate duplicate nlmsvc_lookup_host call from nlmsvc_lock
      lockd: eliminate duplicate nlmsvc_lookup_host call from nlmsvc_testlock
      lockd: nlm_release_host() checks for NULL, caller needn't
      file lock: reorder struct file_lock to save space on 64 bit builds
      nfsd: take file and mnt write in nfs4_upgrade_open
      nfsd: document open share bit tracking
      nfsd: tabulate nfs4 xdr encoding functions
      nfsd: dprint operation names
      svcrdma: Change WR context get/put to use the kmem cache
      svcrdma: Create a kmem cache for the WR contexts
      svcrdma: Add flush_scheduled_work to module exit function
      svcrdma: Limit ORD based on client's advertised IRD
      svcrdma: Remove unused wait q from svcrdma_xprt structure
      svcrdma: Remove unneeded spin locks from __svc_rdma_free
      svcrdma: Add dma map count and WARN_ON
      ...

commit 9c1be0c4712fe760d8969427ef91107e9c062d91
Merge: 42fdd144a40f 0d7eff873caa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 16 15:02:57 2008 -0700

    Merge branch 'for_linus' of git://git.infradead.org/~dedekind/ubifs-2.6
    
    * 'for_linus' of git://git.infradead.org/~dedekind/ubifs-2.6:
      UBIFS: include to compilation
      UBIFS: add new flash file system
      UBIFS: add brief documentation
      MAINTAINERS: add UBIFS section
      do_mounts: allow UBI root device name
      VFS: export sync_sb_inodes
      VFS: move inode_lock into sync_sb_inodes

commit 8d2567a620ae8c24968a2bdc1c906c724fac1f6a
Merge: bcf559e385ba 49f1487b2e41
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 15 08:36:38 2008 -0700

    Merge branch 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4
    
    * 'for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4: (61 commits)
      ext4: Documention update for new ordered mode and delayed allocation
      ext4: do not set extents feature from the kernel
      ext4: Don't allow nonextenst mount option for large filesystem
      ext4: Enable delalloc by default.
      ext4: delayed allocation i_blocks fix for stat
      ext4: fix delalloc i_disksize early update issue
      ext4: Handle page without buffers in ext4_*_writepage()
      ext4: Add ordered mode support for delalloc
      ext4: Invert lock ordering of page_lock and transaction start in delalloc
      mm: Add range_cont mode for writeback
      ext4: delayed allocation ENOSPC handling
      percpu_counter: new function percpu_counter_sum_and_set
      ext4: Add delayed allocation support in data=writeback mode
      vfs: add hooks for ext4's delayed allocation support
      jbd2: Remove data=ordered mode support using jbd buffer heads
      ext4: Use new framework for data=ordered mode in JBD2
      jbd2: Implement data=ordered mode handling via inodes
      vfs: export filemap_fdatawrite_range()
      ext4: Fix lock inversion in ext4_ext_truncate()
      ext4: Invert the locking order of page_lock and transaction start
      ...

commit 2fceef397f9880b212a74c418290ce69e7ac00eb
Merge: feae1ef116ed bce7f793daec
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Mon Jul 14 15:29:34 2008 -0600

    Merge commit 'v2.6.26' into bkl-removal

commit 4ee6afd34409d296782a5b667d7991b1050e910a
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Wed May 7 21:01:30 2008 +0300

    VFS: export sync_sb_inodes
    
    This patch exports the 'sync_sb_inodes()' which is needed for
    UBIFS because it has to force write-back from time to time.
    Namely, the UBIFS budgeting subsystem forces write-back when
    its pessimistic callculations show that there is no free
    space on the media.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d8e2762ed14d..f9d2aab47eda 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1729,6 +1729,8 @@ static inline void invalidate_remote_inode(struct inode *inode)
 extern int invalidate_inode_pages2(struct address_space *mapping);
 extern int invalidate_inode_pages2_range(struct address_space *mapping,
 					 pgoff_t start, pgoff_t end);
+extern void generic_sync_sb_inodes(struct super_block *sb,
+				struct writeback_control *wbc);
 extern int write_inode_now(struct inode *, int);
 extern int filemap_fdatawrite(struct address_space *);
 extern int filemap_flush(struct address_space *);

commit afc1246f917c664b0df98b3c22fa62db74d2ca33
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Fri Jul 11 17:20:49 2008 -0700

    file lock: reorder struct file_lock to save space on 64 bit builds
    
    Reduce sizeof struct file_lock by 8 on 64 bit builds allowing +1 objects
    per slab in the file_lock_cache
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7c1080826832..87f89bd0f6ee 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -917,12 +917,12 @@ struct file_lock {
 	struct list_head fl_link;	/* doubly linked list of all locks */
 	struct list_head fl_block;	/* circular list of blocked processes */
 	fl_owner_t fl_owner;
+	unsigned char fl_flags;
+	unsigned char fl_type;
 	unsigned int fl_pid;
 	struct pid *fl_nspid;
 	wait_queue_head_t fl_wait;
 	struct file *fl_file;
-	unsigned char fl_flags;
-	unsigned char fl_type;
 	loff_t fl_start;
 	loff_t fl_end;
 

commit f4c0a0fdfae708f7aa438c27a380ed4071294e11
Author: Jan Kara <jack@suse.cz>
Date:   Fri Jul 11 19:27:31 2008 -0400

    vfs: export filemap_fdatawrite_range()
    
    Make filemap_fdatawrite_range() function public, so that it can later
    be used in ordered mode rewrite by JBD/JBD2.
    
    Signed-off-by: Jan Kara <jack@suse.cz>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d8e2762ed14d..97f992adc62d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1740,6 +1740,8 @@ extern int wait_on_page_writeback_range(struct address_space *mapping,
 				pgoff_t start, pgoff_t end);
 extern int __filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end, int sync_mode);
+extern int filemap_fdatawrite_range(struct address_space *mapping,
+				loff_t start, loff_t end);
 
 extern long do_fsync(struct file *file, int datasync);
 extern void sync_supers(void);

commit 9465efc9e96135a2cec8154c0c766fa59984a298
Author: Andi Kleen <andi@firstfloor.org>
Date:   Fri Jun 27 11:05:24 2008 +0200

    Remove BKL from remote_llseek v2
    
    - Replace remote_llseek with generic_file_llseek_unlocked (to force compilation
    failures in all users)
    - Change all users to either use generic_file_llseek_unlocked directly or
    take the BKL around. I changed the file systems who don't use the BKL
    for anything (CIFS, GFS) to call it directly. NCPFS and SMBFS and NFS
    take the BKL, but explicitely in their own source now.
    
    I moved them all over in a single patch to avoid unbisectable sections.
    
    Open problem: 32bit kernels can corrupt fpos because its modification
    is not atomic, but they can do that anyways because there's other paths who
    modify it without BKL.
    
    Do we need a special lock for the pos/f_version = 0 checks?
    
    Trond says the NFS BKL is likely not needed, but keep it for now
    until his full audit.
    
    v2: Use generic_file_llseek_unlocked instead of remote_llseek_unlocked
        and factor duplicated code (suggested by hch)
    
    Cc: Trond.Myklebust@netapp.com
    Cc: swhiteho@redhat.com
    Cc: sfrench@samba.org
    Cc: vandrove@vc.cvut.cz
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f413085f748e..b158e5161bca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1871,7 +1871,8 @@ extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
-extern loff_t remote_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t generic_file_llseek_unlocked(struct file *file, loff_t offset,
+			int origin);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 

commit 18ce3751ccd488c78d3827e9f6bf54e6322676fb
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Jul 1 09:07:34 2008 +0200

    Properly notify block layer of sync writes
    
    fsync_buffers_list() and sync_dirty_buffer() both issue async writes and
    then immediately wait on them. Conceptually, that makes them sync writes
    and we should treat them as such so that the IO schedulers can handle
    them appropriately.
    
    This patch fixes a write starvation issue that Lin Ming reported, where
    xx is stuck for more than 2 minutes because of a large number of
    synchronous IO in the system:
    
    INFO: task kjournald:20558 blocked for more than 120 seconds.
    "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this
    message.
    kjournald     D ffff810010820978  6712 20558      2
    ffff81022ddb1d10 0000000000000046 ffff81022e7baa10 ffffffff803ba6f2
    ffff81022ecd0000 ffff8101e6dc9160 ffff81022ecd0348 000000008048b6cb
    0000000000000086 ffff81022c4e8d30 0000000000000000 ffffffff80247537
    Call Trace:
    [<ffffffff803ba6f2>] kobject_get+0x12/0x17
    [<ffffffff80247537>] getnstimeofday+0x2f/0x83
    [<ffffffff8029c1ac>] sync_buffer+0x0/0x3f
    [<ffffffff8066d195>] io_schedule+0x5d/0x9f
    [<ffffffff8029c1e7>] sync_buffer+0x3b/0x3f
    [<ffffffff8066d3f0>] __wait_on_bit+0x40/0x6f
    [<ffffffff8029c1ac>] sync_buffer+0x0/0x3f
    [<ffffffff8066d48b>] out_of_line_wait_on_bit+0x6c/0x78
    [<ffffffff80243909>] wake_bit_function+0x0/0x23
    [<ffffffff8029e3ad>] sync_dirty_buffer+0x98/0xcb
    [<ffffffff8030056b>] journal_commit_transaction+0x97d/0xcb6
    [<ffffffff8023a676>] lock_timer_base+0x26/0x4b
    [<ffffffff8030300a>] kjournald+0xc1/0x1fb
    [<ffffffff802438db>] autoremove_wake_function+0x0/0x2e
    [<ffffffff80302f49>] kjournald+0x0/0x1fb
    [<ffffffff802437bb>] kthread+0x47/0x74
    [<ffffffff8022de51>] schedule_tail+0x28/0x5d
    [<ffffffff8020cac8>] child_rip+0xa/0x12
    [<ffffffff80243774>] kthread+0x0/0x74
    [<ffffffff8020cabe>] child_rip+0x0/0x12
    
    Lin Ming confirms that this patch fixes the issue. I've run tests with
    it for the past week and no ill effects have been observed, so I'm
    proposing it for inclusion into 2.6.26.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7c1080826832..d8e2762ed14d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -83,6 +83,7 @@ extern int dir_notify_enable;
 #define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
 #define READ_META	(READ | (1 << BIO_RW_META))
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
+#define SWRITE_SYNC	(SWRITE | (1 << BIO_RW_SYNC))
 #define WRITE_BARRIER	((1 << BIO_RW) | (1 << BIO_RW_BARRIER))
 
 #define SEL_IN		1

commit f9f48ec72bfc9489a30bc6ddbfcf27d86a8bc651
Author: Denis V. Lunev <den@openvz.org>
Date:   Mon Jun 9 16:40:38 2008 -0700

    [patch 4/4] flock: remove unused fields from file_lock_operations
    
    fl_insert and fl_remove are not used right now in the kernel. Remove them.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d490779f18d9..7c1080826832 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -894,8 +894,6 @@ static inline int file_check_writeable(struct file *filp)
 typedef struct files_struct *fl_owner_t;
 
 struct file_lock_operations {
-	void (*fl_insert)(struct file_lock *);	/* lock insertion callback */
-	void (*fl_remove)(struct file_lock *);	/* lock removal callback */
 	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 	void (*fl_release_private)(struct file_lock *);
 };

commit 93b071139a956e51c98cdefd50a47981a4eb852e
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jun 5 22:46:21 2008 -0700

    introduce memory_read_from_buffer()
    
    This patch introduces memory_read_from_buffer().
    
    The only difference between memory_read_from_buffer() and
    simple_read_from_buffer() is which address space the function copies to.
    
    simple_read_from_buffer copies to user space memory.
    memory_read_from_buffer copies to normal memory.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Doug Warzecha <Douglas_Warzecha@dell.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Matt Domsch <Matt_Domsch@dell.com>
    Cc: Abhay Salunke <Abhay_Salunke@dell.com>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Markus Rechberger <markus.rechberger@amd.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Bob Moore <robert.moore@intel.com>
    Cc: Thomas Renninger <trenn@suse.de>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Krzysztof Helt <krzysztof.h1@poczta.fm>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
    Cc: Michael Holzheu <holzheu@de.ibm.com>
    Cc: Brian King <brking@us.ibm.com>
    Cc: James E.J. Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Andrew Vasquez <linux-driver@qlogic.com>
    Cc: Seokmann Ju <seokmann.ju@qlogic.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f413085f748e..d490779f18d9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2000,7 +2000,10 @@ extern int simple_fill_super(struct super_block *, int, struct tree_descr *);
 extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
 extern void simple_release_fs(struct vfsmount **mount, int *count);
 
-extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const void *, size_t);
+extern ssize_t simple_read_from_buffer(void __user *to, size_t count,
+			loff_t *ppos, const void *from, size_t available);
+extern ssize_t memory_read_from_buffer(void *to, size_t count, loff_t *ppos,
+			const void *from, size_t available);
 
 #ifdef CONFIG_MIGRATION
 extern int buffer_migrate_page(struct address_space *,

commit 7f3d4ee108c184ab215036051087aaaaa8de7661
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Wed May 7 09:22:39 2008 +0200

    vfs: splice remove_suid() cleanup
    
    generic_file_splice_write() duplicates remove_suid() just because it
    doesn't hold i_mutex.  But it grabs i_mutex inside splice_from_pipe()
    anyway, so this is rather pointless.
    
    Move locking to generic_file_splice_write() and call remove_suid() and
    __splice_from_pipe() instead.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7e0fa9e64479..f413085f748e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1816,7 +1816,6 @@ extern void iget_failed(struct inode *);
 extern void clear_inode(struct inode *);
 extern void destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
-extern int __remove_suid(struct dentry *, int);
 extern int should_remove_suid(struct dentry *);
 extern int remove_suid(struct dentry *);
 

commit 33dcdac2df54e66c447ae03f58c95c7251aa5649
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 29 17:46:26 2008 +0200

    [PATCH] kill ->put_inode
    
    And with that last patch to affs killing the last put_inode instance we
    can finally, after many years of transition kill this racy and awkward
    interface.
    
    (It's kinda funny that even the description in
    Documentation/filesystems/vfs.txt was entirely wrong..)
    
    Also remove a very misleading comment above the defintion of
    struct super_operations.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a1ba005d08e7..7e0fa9e64479 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1289,17 +1289,12 @@ extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
 extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
 		unsigned long, loff_t *);
 
-/*
- * NOTE: write_inode, delete_inode, clear_inode, put_inode can be called
- * without the big kernel lock held in all filesystems.
- */
 struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);
 	void (*destroy_inode)(struct inode *);
 
    	void (*dirty_inode) (struct inode *);
 	int (*write_inode) (struct inode *, int);
-	void (*put_inode) (struct inode *);
 	void (*drop_inode) (struct inode *);
 	void (*delete_inode) (struct inode *);
 	void (*put_super) (struct super_block *);

commit 67cde595374dd0e4e4a537dbf9dff70fd3d7bd7b
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Apr 29 00:58:55 2008 -0700

    make vfs_ioctl() static
    
    Make the needlessly global vfs_ioctl() static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1de9d72178e1..a1ba005d08e7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1964,7 +1964,6 @@ extern int vfs_stat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_lstat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 
-extern long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
 extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 		    unsigned long arg);
 

commit 6b09ae66922ca198e5830c0a4d74400a507a9170
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Apr 29 00:58:54 2008 -0700

    make __put_super() static
    
    Make the needlessly global __put_super() static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c925747bc49..1de9d72178e1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1521,7 +1521,6 @@ extern int get_sb_pseudo(struct file_system_type *, char *,
 	const struct super_operations *ops, unsigned long,
 	struct vfsmount *mnt);
 extern int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
-int __put_super(struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
 void unnamed_dev_init(void);
 

commit 70688e4dd1647f0ceb502bbd5964fa344c5eb411
Author: Nick Piggin <npiggin@suse.de>
Date:   Mon Apr 28 02:13:02 2008 -0700

    xip: support non-struct page backed memory
    
    Convert XIP to support non-struct page backed memory, using VM_MIXEDMAP for
    the user mappings.
    
    This requires the get_xip_page API to be changed to an address based one.
    Improve the API layering a little bit too, while we're here.
    
    This is required in order to support XIP filesystems on memory that isn't
    backed with struct page (but memory with struct page is still supported too).
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Acked-by: Carsten Otte <cotte@de.ibm.com>
    Cc: Jared Hulbert <jaredeh@gmail.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bd05f5678045..2c925747bc49 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -474,8 +474,8 @@ struct address_space_operations {
 	int (*releasepage) (struct page *, gfp_t);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
-	struct page* (*get_xip_page)(struct address_space *, sector_t,
-			int);
+	int (*get_xip_mem)(struct address_space *, pgoff_t, int,
+						void **, unsigned long *);
 	/* migrate the contents of a page to the specified target */
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *);

commit 30afcb4bd2762fa4b87b17ada9500aa46dc10b1b
Author: Jared Hulbert <jaredeh@gmail.com>
Date:   Mon Apr 28 02:13:02 2008 -0700

    return pfn from direct_access, for XIP
    
    Alter the block device ->direct_access() API to work with the new
    get_xip_mem() API (that requires both kaddr and pfn are returned).
    
    Some architectures will not do the right thing in their virt_to_page() for use
    by XIP (to translate from the kernel virtual address returned by
    direct_access(), to a user mappable pfn in XIP's page fault handler.
    
    However, we can't switch it to just return the pfn and not the kaddr, because
    we have no good way to get a kva from a pfn, and XIP requires the kva for its
    read(2) and write(2) handlers.  So we have to return both.
    
    Signed-off-by: Jared Hulbert <jaredeh@gmail.com>
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Carsten Otte <cotte@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: linux-mm@kvack.org
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d6d7c52055c6..bd05f5678045 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1178,7 +1178,8 @@ struct block_device_operations {
 	int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
 	long (*unlocked_ioctl) (struct file *, unsigned, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned, unsigned long);
-	int (*direct_access) (struct block_device *, sector_t, unsigned long *);
+	int (*direct_access) (struct block_device *, sector_t,
+						void **, unsigned long *);
 	int (*media_changed) (struct gendisk *);
 	int (*revalidate_disk) (struct gendisk *);
 	int (*getgeo)(struct block_device *, struct hd_geometry *);

commit bc84e0a160e383deb56568f4e03bc51b1ce16775
Merge: a92910723a5a f8f95702f0c4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 25 19:05:55 2008 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs-2.6:
      [PATCH] sanitize locate_fd()
      [PATCH] sanitize unshare_files/reset_files_struct
      [PATCH] sanitize handling of shared descriptor tables in failing execve()
      [PATCH] close race in unshare_files()
      [PATCH] restore sane ->umount_begin() API
      cifs: timeout dfs automounts +little fix.

commit 1a747ee0cc11a198f9e2435add821bd0dfedb7c1
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Apr 24 10:08:22 2008 -0400

    locks: don't call ->copy_lock methods on return of conflicting locks
    
    The file_lock structure is used both as a heavy-weight representation of
    an active lock, with pointers to reference-counted structures, etc., and
    as a simple container for parameters that describe a file lock.
    
    The conflicting lock returned from __posix_lock_file is an example of
    the latter; so don't call the filesystem or lock manager callbacks when
    copying to it.  This also saves the need for an unnecessary
    locks_init_lock in the nfsv4 server.
    
    Thanks to Trond for pointing out the error.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc2be2cf7d41..6556f2f967e5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -973,6 +973,7 @@ extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
+extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
 extern void posix_test_lock(struct file *, struct file_lock *);

commit 3b1253880b7a9e6db54b943b2d40bcf2202f58ab
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Apr 22 05:31:30 2008 -0400

    [PATCH] sanitize unshare_files/reset_files_struct
    
    * let unshare_files() give caller the displaced files_struct
    * don't bother with grabbing reference only to drop it in the
      caller if it hadn't been shared in the first place
    * in that form unshare_files() is trivially implemented via
      unshare_fd(), so we eliminate the duplicate logics in fork.c
    * reset_files_struct() is not just only called for current;
      it will break the system if somebody ever calls it for anything
      else (we can't modify ->files of somebody else).  Lose the
      task_struct * argument.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ad41d0bbcb4d..e057438a05ad 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2033,9 +2033,6 @@ static inline ino_t parent_ino(struct dentry *dentry)
 	return res;
 }
 
-/* kernel/fork.c */
-extern int unshare_files(void);
-
 /* Transaction based IO helpers */
 
 /*

commit 42faad99658eed7ca8bd328ffa4bcb7d78c9bcca
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Apr 24 07:21:56 2008 -0400

    [PATCH] restore sane ->umount_begin() API
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc2be2cf7d41..ad41d0bbcb4d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1308,7 +1308,7 @@ struct super_operations {
 	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);
-	void (*umount_begin) (struct vfsmount *, int);
+	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 	int (*show_stats)(struct seq_file *, struct vfsmount *);

commit 6d59e7f582ef1c1988542d0fc3b36d0087b757ce
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Mar 22 15:48:17 2008 -0400

    [PATCH] move a bunch of declarations to fs/internal.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0c609e71c379..cc2be2cf7d41 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -305,7 +305,6 @@ struct vfsmount;
 
 extern void __init inode_init(void);
 extern void __init inode_init_early(void);
-extern void __init mnt_init(void);
 extern void __init files_init(unsigned long);
 
 struct buffer_head;
@@ -1536,12 +1535,7 @@ extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
 #define kern_mount(type) kern_mount_data(type, NULL)
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
-extern void umount_tree(struct vfsmount *, int, struct list_head *);
-extern void release_mounts(struct list_head *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
-extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
-extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
-				  struct vfsmount *);
 extern struct vfsmount *collect_mounts(struct vfsmount *, struct dentry *);
 extern void drop_collected_mounts(struct vfsmount *);
 

commit 429f731dea577bdd43693940cdca524135287e6a
Merge: 85b375a61308 d2f5e80862d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:41:27 2008 -0700

    Merge branch 'semaphore' of git://git.kernel.org/pub/scm/linux/kernel/git/willy/misc
    
    * 'semaphore' of git://git.kernel.org/pub/scm/linux/kernel/git/willy/misc:
      Deprecate the asm/semaphore.h files in feature-removal-schedule.
      Convert asm/semaphore.h users to linux/semaphore.h
      security: Remove unnecessary inclusions of asm/semaphore.h
      lib: Remove unnecessary inclusions of asm/semaphore.h
      kernel: Remove unnecessary inclusions of asm/semaphore.h
      include: Remove unnecessary inclusions of asm/semaphore.h
      fs: Remove unnecessary inclusions of asm/semaphore.h
      drivers: Remove unnecessary inclusions of asm/semaphore.h
      net: Remove unnecessary inclusions of asm/semaphore.h
      arch: Remove unnecessary inclusions of asm/semaphore.h

commit ad775f5a8faa5845377f093ca11caf577404add9
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Fri Feb 15 14:38:01 2008 -0800

    [PATCH] r/o bind mounts: debugging for missed calls
    
    There have been a few oopses caused by 'struct file's with NULL f_vfsmnts.
    There was also a set of potentially missed mnt_want_write()s from
    dentry_open() calls.
    
    This patch provides a very simple debugging framework to catch these kinds of
    bugs.  It will WARN_ON() them, but should stop us from having any oopses or
    mnt_writer count imbalances.
    
    I'm quite convinced that this is a good thing because it found bugs in the
    stuff I was working on as soon as I wrote it.
    
    [hch: made it conditional on a debug option.
          But it's still a little bit too ugly]
    
    [hch: merged forced remount r/o fix from Dave and akpm's fix for the fix]
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Acked-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 013b9c2b88e6..d1eeea669d2c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -776,6 +776,9 @@ static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
 		index <  ra->start + ra->size);
 }
 
+#define FILE_MNT_WRITE_TAKEN	1
+#define FILE_MNT_WRITE_RELEASED	2
+
 struct file {
 	/*
 	 * fu_list becomes invalid after file_free is called and queued via
@@ -810,6 +813,9 @@ struct file {
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
+#ifdef CONFIG_DEBUG_WRITECOUNT
+	unsigned long f_mnt_write_state;
+#endif
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
@@ -818,6 +824,49 @@ extern spinlock_t files_lock;
 #define get_file(x)	atomic_inc(&(x)->f_count)
 #define file_count(x)	atomic_read(&(x)->f_count)
 
+#ifdef CONFIG_DEBUG_WRITECOUNT
+static inline void file_take_write(struct file *f)
+{
+	WARN_ON(f->f_mnt_write_state != 0);
+	f->f_mnt_write_state = FILE_MNT_WRITE_TAKEN;
+}
+static inline void file_release_write(struct file *f)
+{
+	f->f_mnt_write_state |= FILE_MNT_WRITE_RELEASED;
+}
+static inline void file_reset_write(struct file *f)
+{
+	f->f_mnt_write_state = 0;
+}
+static inline void file_check_state(struct file *f)
+{
+	/*
+	 * At this point, either both or neither of these bits
+	 * should be set.
+	 */
+	WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN);
+	WARN_ON(f->f_mnt_write_state == FILE_MNT_WRITE_RELEASED);
+}
+static inline int file_check_writeable(struct file *f)
+{
+	if (f->f_mnt_write_state == FILE_MNT_WRITE_TAKEN)
+		return 0;
+	printk(KERN_WARNING "writeable file with no "
+			    "mnt_want_write()\n");
+	WARN_ON(1);
+	return -EINVAL;
+}
+#else /* !CONFIG_DEBUG_WRITECOUNT */
+static inline void file_take_write(struct file *filp) {}
+static inline void file_release_write(struct file *filp) {}
+static inline void file_reset_write(struct file *filp) {}
+static inline void file_check_state(struct file *filp) {}
+static inline int file_check_writeable(struct file *filp)
+{
+	return 0;
+}
+#endif /* CONFIG_DEBUG_WRITECOUNT */
+
 #define	MAX_NON_LFS	((1UL<<31) - 1)
 
 /* Page cache limit. The filesystems should put that into their s_maxbytes 

commit a70e65df8812c52252fa07a2eb92a46451a4427f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 15 14:37:28 2008 -0800

    [PATCH] merge open_namei() and do_filp_open()
    
    open_namei() will, in the future, need to take mount write counts
    over its creation and truncation (via may_open()) operations.  It
    needs to keep these write counts until any potential filp that is
    created gets __fput()'d.
    
    This gets complicated in the error handling and becomes very murky
    as to how far open_namei() actually got, and whether or not that
    mount write count was taken.  That makes it a bad interface.
    
    All that the current do_filp_open() really does is allocate the
    nameidata on the stack, then call open_namei().
    
    So, this merges those two functions and moves filp_open() over
    to namei.c so it can be close to its buddy: do_filp_open().  It
    also gets a kerneldoc comment in the process.
    
    Acked-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b84b848431f2..013b9c2b88e6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1735,7 +1735,8 @@ extern struct file *create_read_pipe(struct file *f);
 extern struct file *create_write_pipe(void);
 extern void free_write_pipe(struct file *);
 
-extern int open_namei(int dfd, const char *, int, int, struct nameidata *);
+extern struct file *do_filp_open(int dfd, const char *pathname,
+		int open_flag, int mode);
 extern int may_open(struct nameidata *, int, int);
 
 extern int kernel_read(struct file *, unsigned long, char *, unsigned long);

commit 6188e10d38b8d7244ee7776d5f1f88c837b4b93f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Apr 18 22:21:05 2008 -0400

    Convert asm/semaphore.h users to linux/semaphore.h
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b84b848431f2..91e8dec9e42b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -287,9 +287,9 @@ extern int dir_notify_enable;
 #include <linux/pid.h>
 #include <linux/mutex.h>
 #include <linux/capability.h>
+#include <linux/semaphore.h>
 
 #include <asm/atomic.h>
-#include <asm/semaphore.h>
 #include <asm/byteorder.h>
 
 struct export_operations;

commit 4c54ac62dceecedd82d4a865017bba0b738e2897
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 18 13:48:31 2008 +0100

    make struct def_blk_aops static
    
    This patch makes the needlessly global struct def_blk_aops static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jens Axboe <axboe@carl.home.kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98ffb6ead434..b84b848431f2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1590,7 +1590,6 @@ extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, unsigned);
-extern const struct address_space_operations def_blk_aops;
 #else
 static inline void bd_forget(struct inode *inode) {}
 #endif

commit 000cb48ee18165776b5a2beb72ed18f66bc61878
Author: Jan Kara <jack@suse.cz>
Date:   Thu Feb 14 19:31:32 2008 -0800

    vfs: add explanation of I_DIRTY_DATASYNC bit
    
    Add explanation of I_DIRTY_DATASYNC bit.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: Joern Engel <joern@logfs.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 18cfbf76ec5b..98ffb6ead434 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1284,8 +1284,10 @@ struct super_operations {
  *
  * I_DIRTY_SYNC		Inode is dirty, but doesn't have to be written on
  *			fdatasync().  i_atime is the usual cause.
- * I_DIRTY_DATASYNC	Inode is dirty and must be written on fdatasync(), f.e.
- *			because i_size changed.
+ * I_DIRTY_DATASYNC	Data-related inode changes pending. We keep track of
+ *			these changes separately from I_DIRTY_SYNC so that we
+ *			don't have to write inode on fdatasync() when only
+ *			mtime has changed in it.
  * I_DIRTY_PAGES	Inode has dirty pages.  Inode itself may be clean.
  * I_NEW		get_new_inode() sets i_state to I_LOCK|I_NEW.  Both
  *			are cleared by unlock_new_inode(), called from iget().

commit 922f9cfa79b52c85b6002d96cb0eefd13437c58c
Author: Denis Cheng <crquan@gmail.com>
Date:   Fri Feb 8 04:22:00 2008 -0800

    fs/char_dev.c: chrdev_open marked static and removed from fs.h
    
    There is an outdated comment in serial_core.c also fixed.
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cb3a9001f3b9..18cfbf76ec5b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1624,7 +1624,6 @@ extern int register_chrdev(unsigned int, const char *,
 			   const struct file_operations *);
 extern void unregister_chrdev(unsigned int, const char *);
 extern void unregister_chrdev_region(dev_t, unsigned);
-extern int chrdev_open(struct inode *, struct file *);
 extern void chrdev_show(struct seq_file *,off_t);
 
 /* fs/block_dev.c */

commit b3b304a23a8f7ae4c40c7b512ee45afae0010a70
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Feb 8 04:21:35 2008 -0800

    mount options: add generic_show_options()
    
    Add a new s_options field to struct super_block.  Filesystems can save
    mount options passed to them in mount or remount.  It is automatically
    freed when the superblock is destroyed.
    
    A new helper function, generic_show_options() is introduced, which uses
    this field to display the mount options in /proc/mounts.
    
    Another helper function, save_mount_options() may be used by
    filesystems to save the options in the super block.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3db22fc2249a..cb3a9001f3b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1038,6 +1038,12 @@ struct super_block {
 	 * in /proc/mounts will be "type.subtype"
 	 */
 	char *s_subtype;
+
+	/*
+	 * Saved mount options for lazy filesystems using
+	 * generic_show_options()
+	 */
+	char *s_options;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);
@@ -1970,6 +1976,9 @@ extern int __must_check inode_setattr(struct inode *, struct iattr *);
 
 extern void file_update_time(struct file *file);
 
+extern int generic_show_options(struct seq_file *m, struct vfsmount *mnt);
+extern void save_mount_options(struct super_block *sb, char *options);
+
 static inline ino_t parent_ino(struct dentry *dentry)
 {
 	ino_t res;

commit 36e789144267105e0b3f2b9bca7db3184fce50dc
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 8 04:21:24 2008 -0800

    kill do_generic_mapping_read
    
    do_generic_mapping_read was used by gfs2 for internals reads, but this use
    of the interface was rather suboptimal (as was the whole interface) and has
    been replaced by an internal helper now.  This patch kills
    do_generic_mapping_read and surrounding damage in preparation of additional
    cleanups for the buffered read path.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1137a8828089..3db22fc2249a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1807,9 +1807,6 @@ extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t, loff_t *, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
-extern void do_generic_mapping_read(struct address_space *mapping,
-				    struct file_ra_state *, struct file *,
-				    loff_t *, read_descriptor_t *, read_actor_t);
 extern int generic_segment_checks(const struct iovec *iov,
 		unsigned long *nr_segs, size_t *count, int access_flags);
 
@@ -1847,18 +1844,6 @@ static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
 }
 #endif
 
-static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
-					read_descriptor_t * desc,
-					read_actor_t actor)
-{
-	do_generic_mapping_read(filp->f_mapping,
-				&filp->f_ra,
-				filp,
-				ppos,
-				desc,
-				actor);
-}
-
 #ifdef CONFIG_BLOCK
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,

commit 74bedc4d56211b30686c6f2f574bf6c6a9654887
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 8 04:20:28 2008 -0800

    libfs: rename simple_attr_close to simple_attr_release
    
    simple_attr_close implementes ->release so it should be named accordingly.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: <stefano.brivio@polimi.it>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg KH <greg@kroah.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ebe996ac2589..1137a8828089 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2056,7 +2056,7 @@ static int __fops ## _open(struct inode *inode, struct file *file)	\
 static struct file_operations __fops = {				\
 	.owner	 = THIS_MODULE,						\
 	.open	 = __fops ## _open,					\
-	.release = simple_attr_close,					\
+	.release = simple_attr_release,					\
 	.read	 = simple_attr_read,					\
 	.write	 = simple_attr_write,					\
 };
@@ -2070,7 +2070,7 @@ __simple_attr_check_format(const char *fmt, ...)
 int simple_attr_open(struct inode *inode, struct file *file,
 		     int (*get)(void *, u64 *), int (*set)(void *, u64),
 		     const char *fmt);
-int simple_attr_close(struct inode *inode, struct file *file);
+int simple_attr_release(struct inode *inode, struct file *file);
 ssize_t simple_attr_read(struct file *file, char __user *buf,
 			 size_t len, loff_t *ppos);
 ssize_t simple_attr_write(struct file *file, const char __user *buf,

commit 8b88b0998e35d239e74446cc30f354bdab86df89
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 8 04:20:26 2008 -0800

    libfs: allow error return from simple attributes
    
    Sometimes simple attributes might need to return an error, e.g. for
    acquiring a mutex interruptibly.  In fact we have that situation in
    spufs already which is the original user of the simple attributes.  This
    patch merged the temporarily forked attributes in spufs back into the
    main ones and allows to return errors.
    
    [akpm@linux-foundation.org: build fix]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: <stefano.brivio@polimi.it>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg KH <greg@kroah.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 36b7abefacbe..ebe996ac2589 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2068,7 +2068,7 @@ __simple_attr_check_format(const char *fmt, ...)
 }
 
 int simple_attr_open(struct inode *inode, struct file *file,
-		     u64 (*get)(void *), void (*set)(void *, u64),
+		     int (*get)(void *, u64 *), int (*set)(void *, u64),
 		     const char *fmt);
 int simple_attr_close(struct inode *inode, struct file *file);
 ssize_t simple_attr_read(struct file *file, char __user *buf,

commit 12debc4248a4a7f1873e47cda2cdd7faca80b099
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:52 2008 -0800

    iget: remove iget() and the read_inode() super op as being obsolete
    
    Remove the old iget() call and the read_inode() superblock operation it uses
    as these are really obsolete, and the use of read_inode() does not produce
    proper error handling (no distinction between ENOMEM and EIO when marking an
    inode bad).
    
    Furthermore, this removes the temptation to use iget() to find an inode by
    number in a filesystem from code outside that filesystem.
    
    iget_locked() should be used instead.  A new function is added in an earlier
    patch (iget_failed) that is to be called to mark an inode as bad, unlock it
    and release it should the get routine fail.  Mark iget() and read_inode() as
    being obsolete and remove references to them from the documentation.
    
    Typically a filesystem will be modified such that the read_inode function
    becomes an internal iget function, for example the following:
    
            void thingyfs_read_inode(struct inode *inode)
            {
                    ...
            }
    
    would be changed into something like:
    
            struct inode *thingyfs_iget(struct super_block *sp, unsigned long ino)
            {
                    struct inode *inode;
                    int ret;
    
                    inode = iget_locked(sb, ino);
                    if (!inode)
                            return ERR_PTR(-ENOMEM);
                    if (!(inode->i_state & I_NEW))
                            return inode;
    
                    ...
                    unlock_new_inode(inode);
                    return inode;
            error:
                    iget_failed(inode);
                    return ERR_PTR(ret);
            }
    
    and then thingyfs_iget() would be called rather than iget(), for example:
    
            ret = -EINVAL;
            inode = iget(sb, ino);
            if (!inode || is_bad_inode(inode))
                    goto error;
    
    becomes:
    
            inode = thingyfs_iget(sb, ino);
            if (IS_ERR(inode)) {
                    ret = PTR_ERR(inode);
                    goto error;
            }
    
    Note that is_bad_inode() does not need to be called.  The error returned by
    thingyfs_iget() should render it unnecessary.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d202600d36bd..36b7abefacbe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1241,8 +1241,6 @@ struct super_operations {
    	struct inode *(*alloc_inode)(struct super_block *sb);
 	void (*destroy_inode)(struct inode *);
 
-	void (*read_inode) (struct inode *);
-  
    	void (*dirty_inode) (struct inode *);
 	int (*write_inode) (struct inode *, int);
 	void (*put_inode) (struct inode *);
@@ -1767,18 +1765,6 @@ extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*te
 extern struct inode * iget_locked(struct super_block *, unsigned long);
 extern void unlock_new_inode(struct inode *);
 
-static inline struct inode *iget(struct super_block *sb, unsigned long ino)
-{
-	struct inode *inode = iget_locked(sb, ino);
-	
-	if (inode && (inode->i_state & I_NEW)) {
-		sb->s_op->read_inode(inode);
-		unlock_new_inode(inode);
-	}
-
-	return inode;
-}
-
 extern void __iget(struct inode * inode);
 extern void iget_failed(struct inode *);
 extern void clear_inode(struct inode *);

commit b46980feed937868d3333514028bfbe9a651e4ca
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 7 00:15:27 2008 -0800

    iget: introduce a function to register iget failure
    
    Introduce a function to register failure in an inode construction path.  This
    includes marking the inode under construction as bad, unlocking it and
    releasing it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2925f7011ece..d202600d36bd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1780,6 +1780,7 @@ static inline struct inode *iget(struct super_block *sb, unsigned long ino)
 }
 
 extern void __iget(struct inode * inode);
+extern void iget_failed(struct inode *);
 extern void clear_inode(struct inode *);
 extern void destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);

commit deb21db7788b97a2bccdefe605433ef97f482689
Author: Erez Zadok <ezk@cs.sunysb.edu>
Date:   Thu Feb 7 00:13:25 2008 -0800

    VFS: swap do_ioctl and vfs_ioctl names
    
    Rename old vfs_ioctl to do_ioctl, because the comment above it clearly
    indicates that it is an internal function not to be exported to modules;
    therefore it should have a more traditional do_XXX name.  The new do_ioctl
    is exported in fs.h but not to modules.
    
    Rename the old do_ioctl to vfs_ioctl because the names vfs_XXX should
    preferably be reserved to callable VFS functions which modules may call, as
    many other vfs_XXX functions already do.  Export the new vfs_ioctl to GPL
    modules so others can use it (including Unionfs and eCryptfs).  Add DocBook
    for new vfs_ioctl.
    
    [akpm@linux-foundation.org: fix build]
    Signed-off-by: Erez Zadok <ezk@cs.sunysb.edu>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 109734bf6377..2925f7011ece 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1941,7 +1941,9 @@ extern int vfs_stat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_lstat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 
-extern int vfs_ioctl(struct file *, unsigned int, unsigned int, unsigned long);
+extern long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+extern int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
+		    unsigned long arg);
 
 extern void get_filesystem(struct file_system_type *fs);
 extern void put_filesystem(struct file_system_type *fs);

commit 9cfe015aa424b3c003baba3841a60dd9b5ad319b
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Wed Feb 6 01:37:16 2008 -0800

    get rid of NR_OPEN and introduce a sysctl_nr_open
    
    NR_OPEN (historically set to 1024*1024) actually forbids processes to open
    more than 1024*1024 handles.
    
    Unfortunatly some production servers hit the not so 'ridiculously high
    value' of 1024*1024 file descriptors per process.
    
    Changing NR_OPEN is not considered safe because of vmalloc space potential
    exhaust.
    
    This patch introduces a new sysctl (/proc/sys/fs/nr_open) wich defaults to
    1024*1024, so that admins can decide to change this limit if their workload
    needs it.
    
    [akpm@linux-foundation.org: export it for sparc64]
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 19aab50c3b8e..109734bf6377 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -21,7 +21,7 @@
 
 /* Fixed constants first: */
 #undef NR_OPEN
-#define NR_OPEN (1024*1024)	/* Absolute upper limit on fd num */
+extern int sysctl_nr_open;
 #define INR_OPEN 1024		/* Initial setting for nfile rlimits */
 
 #define BLOCK_SIZE_BITS 10

commit 797074e44d78835adbde2ca527718b0e50226b95
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Feb 6 01:37:08 2008 -0800

    fs: use list_for_each_entry_reverse and kill sb_entry
    
    Use list_for_each_entry_reverse for super_blocks list and remove
    unused sb_entry macro.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e260d9a32c21..19aab50c3b8e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -977,7 +977,6 @@ extern int send_sigurg(struct fown_struct *fown);
 extern struct list_head super_blocks;
 extern spinlock_t sb_lock;
 
-#define sb_entry(list)	list_entry((list), struct super_block, s_list)
 #define S_BIAS (1<<30)
 struct super_block {
 	struct list_head	s_list;		/* Keep this first */

commit e7ca2d41a029577a8cff453d1445951d4f96bfd8
Author: Joern Engel <joern@logfs.org>
Date:   Wed Feb 6 01:36:59 2008 -0800

    Document I_SYNC and I_DATASYNC
    
    After some archeology (see http://logfs.org/logfs/inode_state_bits) I
    finally figured out what the three I_DIRTY bits do.  Maybe others would
    prefer less effort to reach this insight.
    
    Signed-off-by: Joern Engel <joern@logfs.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed289a9c5ccb..e260d9a32c21 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1279,8 +1279,10 @@ struct super_operations {
  *
  * Two bits are used for locking and completion notification, I_LOCK and I_SYNC.
  *
- * I_DIRTY_SYNC		Inode itself is dirty.
- * I_DIRTY_DATASYNC	Data-related inode changes pending
+ * I_DIRTY_SYNC		Inode is dirty, but doesn't have to be written on
+ *			fdatasync().  i_atime is the usual cause.
+ * I_DIRTY_DATASYNC	Inode is dirty and must be written on fdatasync(), f.e.
+ *			because i_size changed.
  * I_DIRTY_PAGES	Inode has dirty pages.  Inode itself may be clean.
  * I_NEW		get_new_inode() sets i_state to I_LOCK|I_NEW.  Both
  *			are cleared by unlock_new_inode(), called from iget().
@@ -1312,8 +1314,6 @@ struct super_operations {
  *			purpose reduces latency and prevents some filesystem-
  *			specific deadlocks.
  *
- * Q: Why does I_DIRTY_DATASYNC exist?  It appears as if it could be replaced
- *    by (I_DIRTY_SYNC|I_DIRTY_PAGES).
  * Q: What is the difference between I_WILL_FREE and I_FREEING?
  * Q: igrab() only checks on (I_FREEING|I_WILL_FREE).  Should it also check on
  *    I_CLEAR?  If not, why?

commit 011e3fcd1e1f14ef54db30b93404ab7caa726477
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 6 01:36:47 2008 -0800

    proper prototype for get_filesystem_list()
    
    Ad a proper prototype for migration_init() in include/linux/fs.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56bd421c1208..ed289a9c5ccb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2113,6 +2113,7 @@ struct ctl_table;
 int proc_nr_files(struct ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
+int get_filesystem_list(char * buf);
 
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit f5bb3a5e9dcdb8435471562b6cada89525cf4df1
Merge: 9853832c49dc 1560a79a2c2e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 4 07:58:52 2008 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/bunk/trivial
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/bunk/trivial: (79 commits)
      Jesper Juhl is the new trivial patches maintainer
      Documentation: mention email-clients.txt in SubmittingPatches
      fs/binfmt_elf.c: spello fix
      do_invalidatepage() comment typo fix
      Documentation/filesystems/porting fixes
      typo fixes in net/core/net_namespace.c
      typo fix in net/rfkill/rfkill.c
      typo fixes in net/sctp/sm_statefuns.c
      lib/: Spelling fixes
      kernel/: Spelling fixes
      include/scsi/: Spelling fixes
      include/linux/: Spelling fixes
      include/asm-m68knommu/: Spelling fixes
      include/asm-frv/: Spelling fixes
      fs/: Spelling fixes
      drivers/watchdog/: Spelling fixes
      drivers/video/: Spelling fixes
      drivers/ssb/: Spelling fixes
      drivers/serial/: Spelling fixes
      drivers/scsi/: Spelling fixes
      ...

commit ab1f16116527e42dec8aee176d673a41a881b809
Author: Vitaliy Gusev <vgusev@openvz.org>
Date:   Thu Jan 17 00:07:08 2008 +0000

    pid-namespaces-vs-locks-interaction
    
    fcntl(F_GETLK,..) can return pid of process for not current pid namespace
    (if process is belonged to the several namespaces).  It is true also for
    pids in /proc/locks.  So correct behavior is saving pointer to the struct
    pid of the process lock owner.
    
    Signed-off-by: Vitaliy Gusev <vgusev@openvz.org>
    Acked-by: Serge Hallyn <serue@us.ibm.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a516b6716870..b7736ab8bb5e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -872,6 +872,7 @@ struct file_lock {
 	struct list_head fl_block;	/* circular list of blocked processes */
 	fl_owner_t fl_owner;
 	unsigned int fl_pid;
+	struct pid *fl_nspid;
 	wait_queue_head_t fl_wait;
 	struct file *fl_file;
 	unsigned char fl_flags;

commit fd3f8984f6fa1ad1a6c2283eef48ba6e5242bcc5
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 17:45:46 2008 +0200

    include/linux/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a516b6716870..bcae3acab288 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1307,7 +1307,7 @@ struct super_operations {
  *			being set.  find_inode() uses this to prevent returning
  *			nearly-dead inodes.
  * I_SYNC		Similar to I_LOCK, but limited in scope to writeback
- *			of inode dirty data.  Having a seperate lock for this
+ *			of inode dirty data.  Having a separate lock for this
  *			purpose reduces latency and prevents some filesystem-
  *			specific deadlocks.
  *

commit 25ec56b518257a56d2ff41a941d288e4b5ff9488
Author: Jean Noel Cordenner <jean-noel.cordenner@bull.net>
Date:   Mon Jan 28 23:58:27 2008 -0500

    ext4: Add inode version support in ext4
    
    This patch adds 64-bit inode version support to ext4. The lower 32 bits
    are stored in the osd1.linux1.l_i_version field while the high 32 bits
    are stored in the i_version_hi field newly created in the ext4_inode.
    This field is incremented in case the ext4_inode is large enough. A
    i_version mount option has been added to enable the feature.
    
    Signed-off-by: Mingming Cao <cmm@us.ibm.com>
    Signed-off-by: Andreas Dilger <adilger@clusterfs.com>
    Signed-off-by: Kalpak Shah <kalpak@clusterfs.com>
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Jean Noel Cordenner <jean-noel.cordenner@bull.net>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9608839552b3..a516b6716870 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1396,7 +1396,21 @@ static inline void inode_dec_link_count(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
-extern void inode_inc_iversion(struct inode *inode);
+/**
+ * inode_inc_iversion - increments i_version
+ * @inode: inode that need to be updated
+ *
+ * Every time the inode is modified, the i_version field will be incremented.
+ * The filesystem has to be mounted with i_version flag
+ */
+
+static inline void inode_inc_iversion(struct inode *inode)
+{
+       spin_lock(&inode->i_lock);
+       inode->i_version++;
+       spin_unlock(&inode->i_lock);
+}
+
 extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {

commit 7a224228ed79d587ece2304869000aad1b8e97dd
Author: Jean Noel Cordenner <jean-noel.cordenner@bull.net>
Date:   Mon Jan 28 23:58:27 2008 -0500

    vfs: Add 64 bit i_version support
    
    The i_version field of the inode is changed to be a 64-bit counter that
    is set on every inode creation and that is incremented every time the
    inode data is modified (similarly to the "ctime" time-stamp).
    The aim is to fulfill a NFSv4 requirement for rfc3530.
    This first part concerns the vfs, it converts the 32-bit i_version in
    the generic inode to a 64-bit, a flag is added in the super block in
    order to check if the feature is enabled and the i_version is
    incremented in the vfs.
    
    Signed-off-by: Mingming Cao <cmm@us.ibm.com>
    Signed-off-by: Jean Noel Cordenner <jean-noel.cordenner@bull.net>
    Signed-off-by: Kalpak Shah <kalpak@clusterfs.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 21398a5d688d..9608839552b3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -124,6 +124,7 @@ extern int dir_notify_enable;
 #define MS_SHARED	(1<<20)	/* change to shared */
 #define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
 #define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
+#define MS_I_VERSION	(1<<23) /* Update inode I_version field */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 
@@ -173,6 +174,7 @@ extern int dir_notify_enable;
 					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
 #define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
 #define IS_NOATIME(inode)   __IS_FLG(inode, MS_RDONLY|MS_NOATIME)
+#define IS_I_VERSION(inode)   __IS_FLG(inode, MS_I_VERSION)
 
 #define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
 #define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
@@ -599,7 +601,7 @@ struct inode {
 	uid_t			i_uid;
 	gid_t			i_gid;
 	dev_t			i_rdev;
-	unsigned long		i_version;
+	u64			i_version;
 	loff_t			i_size;
 #ifdef __NEED_I_SIZE_ORDERED
 	seqcount_t		i_size_seqcount;
@@ -1394,6 +1396,7 @@ static inline void inode_dec_link_count(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
+extern void inode_inc_iversion(struct inode *inode);
 extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {

commit 00d2666623368ffd39afc875ff8a2eead2a0436c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Oct 29 14:17:23 2007 -0600

    kobject: convert main fs kobject to use kobject_create
    
    This also renames fs_subsys to fs_kobj to catch all current users with a
    build error instead of a build warning which can easily be missed.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b3ec4a496d64..21398a5d688d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1476,7 +1476,7 @@ extern void drop_collected_mounts(struct vfsmount *);
 extern int vfs_statfs(struct dentry *, struct kstatfs *);
 
 /* /sys/fs */
-extern struct kset fs_subsys;
+extern struct kobject *fs_kobj;
 
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2

commit 39655164405940d4818224a085e35420e2f97aed
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Oct 21 16:42:17 2007 -0700

    exportfs: make struct export_operations const
    
    Now that nfsd has stopped writing to the find_exported_dentry member we an
    mark the export_operations const
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Neil Brown <neilb@suse.de>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: <linux-ext4@vger.kernel.org>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Cc: Anton Altaparmakov <aia21@cantab.net>
    Cc: David Chinner <dgc@sgi.com>
    Cc: Timothy Shimmin <tes@sgi.com>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: Chris Mason <mason@suse.com>
    Cc: Jeff Mahoney <jeffm@suse.com>
    Cc: "Vladimir V. Saveliev" <vs@namesys.com>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 50078bb30a1c..b3ec4a496d64 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -987,7 +987,7 @@ struct super_block {
 	const struct super_operations	*s_op;
 	struct dquot_operations	*dq_op;
  	struct quotactl_ops	*s_qcop;
-	struct export_operations *s_export_op;
+	const struct export_operations *s_export_op;
 	unsigned long		s_flags;
 	unsigned long		s_magic;
 	struct dentry		*s_root;

commit 8aec08094570562bc305df33b088926d983c3540
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 7 12:20:32 2007 -0400

    [PATCH] new helpers - collect_mounts() and release_collected_mounts()
    
    Get a snapshot of a subtree, creating private clones of vfsmounts
    for all its components and release such snapshot resp.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1bcce660cf03..50078bb30a1c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1470,6 +1470,8 @@ extern long do_mount(char *, char *, char *, unsigned long, void *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 				  struct vfsmount *);
+extern struct vfsmount *collect_mounts(struct vfsmount *, struct dentry *);
+extern void drop_collected_mounts(struct vfsmount *);
 
 extern int vfs_statfs(struct dentry *, struct kstatfs *);
 

commit 8e8a1407ac23b43cec0412338c1b4f5e1c664550
Author: Jason Uhlenkott <juhlenko@akamai.com>
Date:   Sat Oct 20 03:16:18 2007 +0200

    fix do_sys_open() prototype
    
    Fix an argument name in do_sys_open()'s prototype.
    
    Signed-off-by: Jason Uhlenkott <juhlenko@akamai.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1657e995f72c..1bcce660cf03 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1536,7 +1536,7 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
-extern long do_sys_open(int fdf, const char __user *filename, int flags,
+extern long do_sys_open(int dfd, const char __user *filename, int flags,
 			int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);

commit 8bf9725c29f2589237dd696d06a204230add0ba3
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Thu Oct 18 23:40:02 2007 -0700

    pid namespaces: introduce MS_KERNMOUNT flag
    
    This flag tells the .get_sb callback that this is a kern_mount() call so that
    it can trust *data pointer to be valid in-kernel one.  If this flag is passed
    from the user process, it is cleared since the *data pointer is not a valid
    kernel object.
    
    Running a few steps forward - this will be needed for proc to create the
    superblock and store a valid pid namespace on it during the namespace
    creation.  The reason, why the namespace cannot live without proc mount is
    described in the appropriate patch.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Cc: Sukadev Bhattiprolu <sukadev@us.ibm.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3efff12049c6..1657e995f72c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -123,6 +123,7 @@ extern int dir_notify_enable;
 #define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */
 #define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
+#define MS_KERNMOUNT	(1<<22) /* this is a kern_mount call */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 
@@ -1459,7 +1460,8 @@ void unnamed_dev_init(void);
 
 extern int register_filesystem(struct file_system_type *);
 extern int unregister_filesystem(struct file_system_type *);
-extern struct vfsmount *kern_mount(struct file_system_type *);
+extern struct vfsmount *kern_mount_data(struct file_system_type *, void *data);
+#define kern_mount(type) kern_mount_data(type, NULL)
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
 extern void umount_tree(struct vfsmount *, int, struct list_head *);

commit c18479fe017b9d3b65b7682f2b9e711389441186
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 23:39:11 2007 -0700

    put declaration of put_filesystem() in fs.h
    
    Declarations go into headers.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Ram Pai <linuxram@us.ibm.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6a4d170ad9a5..3efff12049c6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1922,6 +1922,8 @@ extern int vfs_fstat(unsigned int, struct kstat *);
 
 extern int vfs_ioctl(struct file *, unsigned int, unsigned int, unsigned long);
 
+extern void get_filesystem(struct file_system_type *fs);
+extern void put_filesystem(struct file_system_type *fs);
 extern struct file_system_type *get_fs_type(const char *name);
 extern struct super_block *get_super(struct block_device *);
 extern struct super_block *user_get_super(dev_t);

commit d139d7ffd0c1e81e2a809909b4f8b121a0dc119a
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Thu Oct 18 03:07:00 2007 -0700

    VFS: allow filesystems to implement atomic open+truncate
    
    Add a new attribute flag ATTR_OPEN, with the meaning: "truncation was
    initiated by open() due to the O_TRUNC flag".
    
    This way filesystems wanting to implement truncation within their ->open()
    method can ignore such truncate requests.
    
    This is a quick & dirty hack, but it comes for free.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Andreas Dilger <adilger@clusterfs.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e3fc5dbb2246..6a4d170ad9a5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -330,6 +330,7 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define ATTR_KILL_SGID	4096
 #define ATTR_FILE	8192
 #define ATTR_KILL_PRIV	16384
+#define ATTR_OPEN	32768	/* Truncating from open(O_TRUNC) */
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It

commit b53767719b6cd8789392ea3e7e2eb7b8906898f0
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Tue Oct 16 23:31:36 2007 -0700

    Implement file posix capabilities
    
    Implement file posix capabilities.  This allows programs to be given a
    subset of root's powers regardless of who runs them, without having to use
    setuid and giving the binary all of root's powers.
    
    This version works with Kaigai Kohei's userspace tools, found at
    http://www.kaigai.gr.jp/index.php.  For more information on how to use this
    patch, Chris Friedhoff has posted a nice page at
    http://www.friedhoff.org/fscaps.html.
    
    Changelog:
            Nov 27:
            Incorporate fixes from Andrew Morton
            (security-introduce-file-caps-tweaks and
            security-introduce-file-caps-warning-fix)
            Fix Kconfig dependency.
            Fix change signaling behavior when file caps are not compiled in.
    
            Nov 13:
            Integrate comments from Alexey: Remove CONFIG_ ifdef from
            capability.h, and use %zd for printing a size_t.
    
            Nov 13:
            Fix endianness warnings by sparse as suggested by Alexey
            Dobriyan.
    
            Nov 09:
            Address warnings of unused variables at cap_bprm_set_security
            when file capabilities are disabled, and simultaneously clean
            up the code a little, by pulling the new code into a helper
            function.
    
            Nov 08:
            For pointers to required userspace tools and how to use
            them, see http://www.friedhoff.org/fscaps.html.
    
            Nov 07:
            Fix the calculation of the highest bit checked in
            check_cap_sanity().
    
            Nov 07:
            Allow file caps to be enabled without CONFIG_SECURITY, since
            capabilities are the default.
            Hook cap_task_setscheduler when !CONFIG_SECURITY.
            Move capable(TASK_KILL) to end of cap_task_kill to reduce
            audit messages.
    
            Nov 05:
            Add secondary calls in selinux/hooks.c to task_setioprio and
            task_setscheduler so that selinux and capabilities with file
            cap support can be stacked.
    
            Sep 05:
            As Seth Arnold points out, uid checks are out of place
            for capability code.
    
            Sep 01:
            Define task_setscheduler, task_setioprio, cap_task_kill, and
            task_setnice to make sure a user cannot affect a process in which
            they called a program with some fscaps.
    
            One remaining question is the note under task_setscheduler: are we
            ok with CAP_SYS_NICE being sufficient to confine a process to a
            cpuset?
    
            It is a semantic change, as without fsccaps, attach_task doesn't
            allow CAP_SYS_NICE to override the uid equivalence check.  But since
            it uses security_task_setscheduler, which elsewhere is used where
            CAP_SYS_NICE can be used to override the uid equivalence check,
            fixing it might be tough.
    
                 task_setscheduler
                     note: this also controls cpuset:attach_task.  Are we ok with
                         CAP_SYS_NICE being used to confine to a cpuset?
                 task_setioprio
                 task_setnice
                     sys_setpriority uses this (through set_one_prio) for another
                     process.  Need same checks as setrlimit
    
            Aug 21:
            Updated secureexec implementation to reflect the fact that
            euid and uid might be the same and nonzero, but the process
            might still have elevated caps.
    
            Aug 15:
            Handle endianness of xattrs.
            Enforce capability version match between kernel and disk.
            Enforce that no bits beyond the known max capability are
            set, else return -EPERM.
            With this extra processing, it may be worth reconsidering
            doing all the work at bprm_set_security rather than
            d_instantiate.
    
            Aug 10:
            Always call getxattr at bprm_set_security, rather than
            caching it at d_instantiate.
    
    [morgan@kernel.org: file-caps clean up for linux/capability.h]
    [bunk@kernel.org: unexport cap_inode_killpriv]
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: James Morris <jmorris@namei.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Andrew Morgan <morgan@kernel.org>
    Signed-off-by: Andrew Morgan <morgan@kernel.org>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 365586a4c4de..e3fc5dbb2246 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -329,6 +329,7 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
 #define ATTR_FILE	8192
+#define ATTR_KILL_PRIV	16384
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It

commit 1c0eeaf5698597146ed9b873e2f9e0961edcf0f9
Author: Joern Engel <joern@wohnheim.fh-wedel.de>
Date:   Tue Oct 16 23:30:44 2007 -0700

    introduce I_SYNC
    
    I_LOCK was used for several unrelated purposes, which caused deadlock
    situations in certain filesystems as a side effect.  One of the purposes
    now uses the new I_SYNC bit.
    
    Also document the various bits and change their order from historical to
    logical.
    
    [bunk@stusta.de: make fs/inode.c:wake_up_inode() static]
    Signed-off-by: Joern Engel <joern@wohnheim.fh-wedel.de>
    Cc: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Cc: David Chinner <dgc@sgi.com>
    Cc: Anton Altaparmakov <aia21@cam.ac.uk>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b70331f9f5b7..365586a4c4de 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1261,16 +1261,68 @@ struct super_operations {
 #endif
 };
 
-/* Inode state bits.  Protected by inode_lock. */
-#define I_DIRTY_SYNC		1 /* Not dirty enough for O_DATASYNC */
-#define I_DIRTY_DATASYNC	2 /* Data-related inode changes pending */
-#define I_DIRTY_PAGES		4 /* Data-related inode changes pending */
-#define __I_LOCK		3
+/*
+ * Inode state bits.  Protected by inode_lock.
+ *
+ * Three bits determine the dirty state of the inode, I_DIRTY_SYNC,
+ * I_DIRTY_DATASYNC and I_DIRTY_PAGES.
+ *
+ * Four bits define the lifetime of an inode.  Initially, inodes are I_NEW,
+ * until that flag is cleared.  I_WILL_FREE, I_FREEING and I_CLEAR are set at
+ * various stages of removing an inode.
+ *
+ * Two bits are used for locking and completion notification, I_LOCK and I_SYNC.
+ *
+ * I_DIRTY_SYNC		Inode itself is dirty.
+ * I_DIRTY_DATASYNC	Data-related inode changes pending
+ * I_DIRTY_PAGES	Inode has dirty pages.  Inode itself may be clean.
+ * I_NEW		get_new_inode() sets i_state to I_LOCK|I_NEW.  Both
+ *			are cleared by unlock_new_inode(), called from iget().
+ * I_WILL_FREE		Must be set when calling write_inode_now() if i_count
+ *			is zero.  I_FREEING must be set when I_WILL_FREE is
+ *			cleared.
+ * I_FREEING		Set when inode is about to be freed but still has dirty
+ *			pages or buffers attached or the inode itself is still
+ *			dirty.
+ * I_CLEAR		Set by clear_inode().  In this state the inode is clean
+ *			and can be destroyed.
+ *
+ *			Inodes that are I_WILL_FREE, I_FREEING or I_CLEAR are
+ *			prohibited for many purposes.  iget() must wait for
+ *			the inode to be completely released, then create it
+ *			anew.  Other functions will just ignore such inodes,
+ *			if appropriate.  I_LOCK is used for waiting.
+ *
+ * I_LOCK		Serves as both a mutex and completion notification.
+ *			New inodes set I_LOCK.  If two processes both create
+ *			the same inode, one of them will release its inode and
+ *			wait for I_LOCK to be released before returning.
+ *			Inodes in I_WILL_FREE, I_FREEING or I_CLEAR state can
+ *			also cause waiting on I_LOCK, without I_LOCK actually
+ *			being set.  find_inode() uses this to prevent returning
+ *			nearly-dead inodes.
+ * I_SYNC		Similar to I_LOCK, but limited in scope to writeback
+ *			of inode dirty data.  Having a seperate lock for this
+ *			purpose reduces latency and prevents some filesystem-
+ *			specific deadlocks.
+ *
+ * Q: Why does I_DIRTY_DATASYNC exist?  It appears as if it could be replaced
+ *    by (I_DIRTY_SYNC|I_DIRTY_PAGES).
+ * Q: What is the difference between I_WILL_FREE and I_FREEING?
+ * Q: igrab() only checks on (I_FREEING|I_WILL_FREE).  Should it also check on
+ *    I_CLEAR?  If not, why?
+ */
+#define I_DIRTY_SYNC		1
+#define I_DIRTY_DATASYNC	2
+#define I_DIRTY_PAGES		4
+#define I_NEW			8
+#define I_WILL_FREE		16
+#define I_FREEING		32
+#define I_CLEAR			64
+#define __I_LOCK		7
 #define I_LOCK			(1 << __I_LOCK)
-#define I_FREEING		16
-#define I_CLEAR			32
-#define I_NEW			64
-#define I_WILL_FREE		128
+#define __I_SYNC		8
+#define I_SYNC			(1 << __I_SYNC)
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 

commit 08d8e9749e7f0435ba4683b620e8d30d59276b4c
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Tue Oct 16 23:30:39 2007 -0700

    writeback: fix ntfs with sb_has_dirty_inodes()
    
    NTFS's if-condition on dirty inodes is not complete.  Fix it with
    sb_has_dirty_inodes().
    
    Cc: Anton Altaparmakov <aia21@cantab.net>
    Cc: Ken Chen <kenchen@google.com>
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0b38a897c114..b70331f9f5b7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1729,6 +1729,7 @@ extern int bdev_read_only(struct block_device *);
 extern int set_blocksize(struct block_device *, int);
 extern int sb_set_blocksize(struct super_block *, int);
 extern int sb_min_blocksize(struct super_block *, int);
+extern int sb_has_dirty_inodes(struct super_block *);
 
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);

commit 0e0f4fc22ece8e593167eccbb1a4154565c11faa
Author: Ken Chen <kenchen@google.com>
Date:   Tue Oct 16 23:30:38 2007 -0700

    writeback: fix periodic superblock dirty inode flushing
    
    Current -mm tree has bucketful of bug fixes in periodic writeback path.
    However, we still hit a glitch where dirty pages on a given inode aren't
    completely flushed to the disk, and system will accumulate large amount of
    dirty pages beyond what dirty_expire_interval is designed for.
    
    The problem is __sync_single_inode() will move an inode to sb->s_dirty list
    even when there are more pending dirty pages on that inode.  If there is
    another inode with a small number of dirty pages, we hit a case where the loop
    iteration in wb_kupdate() terminates prematurely because wbc.nr_to_write > 0.
    Thus leaving the inode that has large amount of dirty pages behind and it has
    to wait for another dirty_writeback_interval before we flush it again.  We
    effectively only write out MAX_WRITEBACK_PAGES every dirty_writeback_interval.
    If the rate of dirtying is sufficiently high, the system will start
    accumulate a large number of dirty pages.
    
    So fix it by having another sb->s_more_io list on which to park the inode
    while we iterate through sb->s_io and to allow each dirty inode which resides
    on that sb to have an equal chance of flushing some amount of dirty pages.
    
    Signed-off-by: Ken Chen <kenchen@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 30aca3399450..0b38a897c114 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1002,6 +1002,7 @@ struct super_block {
 	struct list_head	s_inodes;	/* all inodes */
 	struct list_head	s_dirty;	/* dirty inodes */
 	struct list_head	s_io;		/* parked for writeback */
+	struct list_head	s_more_io;	/* parked for more writeback */
 	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
 	struct list_head	s_files;
 

commit 2b47c3611de05c585e2d81204f6c7e3e255a3461
Author: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date:   Tue Oct 16 23:27:21 2007 -0700

    Fix f_version type: should be u64 instead of unsigned long
    
    Fix f_version type: should be u64 instead of long
    
    There is a type inconsistency between struct inode i_version and struct file
    f_version.
    
    fs.h:
    
    struct inode
      u64                     i_version;
    
    and
    
    struct file
      unsigned long           f_version;
    
    Users do:
    
    fs/ext3/dir.c:
    
    if (filp->f_version != inode->i_version) {
    
    So why isn't f_version a u64 ? It becomes a problem if versions gets
    higher than 2^32 and we are on an architecture where longs are 32 bits.
    
    This patch changes the f_version type to u64, and updates the users accordingly.
    
    It applies to 2.6.23-rc2-mm2.
    
    Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Martin Bligh <mbligh@google.com>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Cc: <linux-ext4@vger.kernel.org>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bb89a5dfe9ad..30aca3399450 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -792,7 +792,7 @@ struct file {
 	unsigned int		f_uid, f_gid;
 	struct file_ra_state	f_ra;
 
-	unsigned long		f_version;
+	u64			f_version;
 #ifdef CONFIG_SECURITY
 	void			*f_security;
 #endif

commit 4a239427f23c7850a33445178ec5f71e19d040b2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Oct 16 23:27:16 2007 -0700

    make fs/libfs.c:simple_commit_write() static
    
    simple_commit_write() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 73f0bdbe436a..bb89a5dfe9ad 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1886,8 +1886,6 @@ extern int simple_empty(struct dentry *);
 extern int simple_readpage(struct file *file, struct page *page);
 extern int simple_prepare_write(struct file *file, struct page *page,
 			unsigned offset, unsigned to);
-extern int simple_commit_write(struct file *file, struct page *page,
-				unsigned offset, unsigned to);
 extern int simple_write_begin(struct file *file, struct address_space *mapping,
 			loff_t pos, unsigned len, unsigned flags,
 			struct page **pagep, void **fsdata);

commit 74bf17cffc32511c7c6d70fe7f376b92662e186e
Author: Denis Cheng <crquan@gmail.com>
Date:   Tue Oct 16 23:26:30 2007 -0700

    fs: remove the unused mempages parameter
    
    Since the mempages parameter is actually not used, they should be removed.
    
    Now there is only files_init use the mempages parameter,
    
            files_init(mempages);
    
    but I don't think the adaptation to mempages in files_init is really
    useful; and if files_init also changed to the prototype void (*func)(void),
    the wrapper vfs_caches_init would also not need the mempages parameter.
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8b3580d0664e..73f0bdbe436a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -300,9 +300,9 @@ struct kstatfs;
 struct vm_area_struct;
 struct vfsmount;
 
-extern void __init inode_init(unsigned long);
+extern void __init inode_init(void);
 extern void __init inode_init_early(void);
-extern void __init mnt_init(unsigned long);
+extern void __init mnt_init(void);
 extern void __init files_init(unsigned long);
 
 struct buffer_head;

commit 4be28540ee2f5af6f21764cde25154208750611e
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Oct 16 23:26:21 2007 -0700

    Remove sysctl.h from fs.h
    
    Rrrr, addition of sysctl.h to fs.h was't very smart, because simple
    editing of the former will buy you big recompile, where it shouldn't
    have to.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f70d52c46617..8b3580d0664e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -283,7 +283,6 @@ extern int dir_notify_enable;
 #include <linux/init.h>
 #include <linux/pid.h>
 #include <linux/mutex.h>
-#include <linux/sysctl.h>
 #include <linux/capability.h>
 
 #include <asm/atomic.h>
@@ -2032,7 +2031,8 @@ static inline void free_secdata(void *secdata)
 { }
 #endif	/* CONFIG_SECURITY */
 
-int proc_nr_files(ctl_table *table, int write, struct file *filp,
+struct ctl_table;
+int proc_nr_files(struct ctl_table *table, int write, struct file *filp,
 		  void __user *buffer, size_t *lenp, loff_t *ppos);
 
 

commit 55144768e100b68447f44c5e5c9deb155ad661bd
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Oct 16 01:25:26 2007 -0700

    fs: remove some AOP_TRUNCATED_PAGE
    
    prepare/commit_write no longer returns AOP_TRUNCATED_PAGE since OCFS2 and
    GFS2 were converted to the new aops, so we can make some simplifications
    for that.
    
    [michal.k.k.piotrowski@gmail.com: fix warning]
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Michael Halcrow <mhalcrow@us.ibm.com>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Michal Piotrowski <michal.k.k.piotrowski@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a40557eae2ed..f70d52c46617 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -381,7 +381,7 @@ struct iattr {
  *  			trying again.  The aop will be taking reasonable
  *  			precautions not to livelock.  If the caller held a page
  *  			reference, it should drop it before retrying.  Returned
- *  			by readpage(), prepare_write(), and commit_write().
+ *  			by readpage().
  *
  * address_space_operation functions return these large constants to indicate
  * special semantics to the caller.  These are much larger than the bytes in a

commit 89e107877b65bf6eff1d63a1302dee9a091586f5
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Oct 16 01:25:07 2007 -0700

    fs: new cont helpers
    
    Rework the generic block "cont" routines to handle the new aops.  Supporting
    cont_prepare_write would take quite a lot of code to support, so remove it
    instead (and we later convert all filesystems to use it).
    
    write_begin gets passed AOP_FLAG_CONT_EXPAND when called from
    generic_cont_expand, so filesystems can avoid the old hacks they used.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e9344e6f877d..a40557eae2ed 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -395,6 +395,7 @@ enum positive_aop_returns {
 };
 
 #define AOP_FLAG_UNINTERRUPTIBLE	0x0001 /* will not do a short write */
+#define AOP_FLAG_CONT_EXPAND		0x0002 /* called from cont_expand */
 
 /*
  * oh the beauties of C type declarations.

commit afddba49d18f346e5cc2938b6ed7c512db18ca68
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Oct 16 01:25:01 2007 -0700

    fs: introduce write_begin, write_end, and perform_write aops
    
    These are intended to replace prepare_write and commit_write with more
    flexible alternatives that are also able to avoid the buffered write
    deadlock problems efficiently (which prepare_write is unable to do).
    
    [mark.fasheh@oracle.com: API design contributions, code review and fixes]
    [akpm@linux-foundation.org: various fixes]
    [dmonakhov@sw.ru: new aop block_write_begin fix]
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Dmitriy Monakhov <dmonakhov@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 86ce27c72554..e9344e6f877d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -394,6 +394,8 @@ enum positive_aop_returns {
 	AOP_TRUNCATED_PAGE	= 0x80001,
 };
 
+#define AOP_FLAG_UNINTERRUPTIBLE	0x0001 /* will not do a short write */
+
 /*
  * oh the beauties of C type declarations.
  */
@@ -413,7 +415,7 @@ size_t iov_iter_copy_from_user_atomic(struct page *page,
 size_t iov_iter_copy_from_user(struct page *page,
 		struct iov_iter *i, unsigned long offset, size_t bytes);
 void iov_iter_advance(struct iov_iter *i, size_t bytes);
-int iov_iter_fault_in_readable(struct iov_iter *i);
+int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes);
 size_t iov_iter_single_seg_count(struct iov_iter *i);
 
 static inline void iov_iter_init(struct iov_iter *i,
@@ -454,6 +456,14 @@ struct address_space_operations {
 	 */
 	int (*prepare_write)(struct file *, struct page *, unsigned, unsigned);
 	int (*commit_write)(struct file *, struct page *, unsigned, unsigned);
+
+	int (*write_begin)(struct file *, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata);
+	int (*write_end)(struct file *, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *page, void *fsdata);
+
 	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
 	sector_t (*bmap)(struct address_space *, sector_t);
 	void (*invalidatepage) (struct page *, unsigned long);
@@ -468,6 +478,18 @@ struct address_space_operations {
 	int (*launder_page) (struct page *);
 };
 
+/*
+ * pagecache_write_begin/pagecache_write_end must be used by general code
+ * to write into the pagecache.
+ */
+int pagecache_write_begin(struct file *, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata);
+
+int pagecache_write_end(struct file *, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *page, void *fsdata);
+
 struct backing_dev_info;
 struct address_space {
 	struct inode		*host;		/* owner: inode, block_device */
@@ -1866,6 +1888,12 @@ extern int simple_prepare_write(struct file *file, struct page *page,
 			unsigned offset, unsigned to);
 extern int simple_commit_write(struct file *file, struct page *page,
 				unsigned offset, unsigned to);
+extern int simple_write_begin(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata);
+extern int simple_write_end(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned copied,
+			struct page *page, void *fsdata);
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);

commit 2f718ffc16c43a435d12919c75dbfad518abd056
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Oct 16 01:24:59 2007 -0700

    mm: buffered write iterator
    
    Add an iterator data structure to operate over an iovec.  Add usercopy
    operators needed by generic_file_buffered_write, and convert that function
    over.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 500ffc0e4ac7..86ce27c72554 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -401,6 +401,39 @@ struct page;
 struct address_space;
 struct writeback_control;
 
+struct iov_iter {
+	const struct iovec *iov;
+	unsigned long nr_segs;
+	size_t iov_offset;
+	size_t count;
+};
+
+size_t iov_iter_copy_from_user_atomic(struct page *page,
+		struct iov_iter *i, unsigned long offset, size_t bytes);
+size_t iov_iter_copy_from_user(struct page *page,
+		struct iov_iter *i, unsigned long offset, size_t bytes);
+void iov_iter_advance(struct iov_iter *i, size_t bytes);
+int iov_iter_fault_in_readable(struct iov_iter *i);
+size_t iov_iter_single_seg_count(struct iov_iter *i);
+
+static inline void iov_iter_init(struct iov_iter *i,
+			const struct iovec *iov, unsigned long nr_segs,
+			size_t count, size_t written)
+{
+	i->iov = iov;
+	i->nr_segs = nr_segs;
+	i->iov_offset = 0;
+	i->count = count + written;
+
+	iov_iter_advance(i, written);
+}
+
+static inline size_t iov_iter_count(struct iov_iter *i)
+{
+	return i->count;
+}
+
+
 struct address_space_operations {
 	int (*writepage)(struct page *page, struct writeback_control *wbc);
 	int (*readpage)(struct file *, struct page *);

commit f4e6b498d6e06742d72706ef50593a9c4dd72214
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Tue Oct 16 01:24:33 2007 -0700

    readahead: combine file_ra_state.prev_index/prev_offset into prev_pos
    
    Combine the file_ra_state members
                                    unsigned long prev_index
                                    unsigned int prev_offset
    into
                                    loff_t prev_pos
    
    It is more consistent and better supports huge files.
    
    Thanks to Peter for the nice proposal!
    
    [akpm@linux-foundation.org: fix shift overflow]
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8250811081ff..500ffc0e4ac7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -704,8 +704,7 @@ struct file_ra_state {
 
 	unsigned int ra_pages;		/* Maximum readahead window */
 	int mmap_miss;			/* Cache miss stat for mmap accesses */
-	unsigned long prev_index;	/* Cache last read() position */
-	unsigned int prev_offset;	/* Offset where last read() ended in a page */
+	loff_t prev_pos;		/* Cache last read() position */
 };
 
 /*

commit 0bb7ba6b9c358c12084a3cbc6ac08c8d1e973937
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Tue Oct 16 01:24:32 2007 -0700

    readahead: mmap read-around simplification
    
    Fold file_ra_state.mmap_hit into file_ra_state.mmap_miss and make it an int.
    
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7a998c49a086..8250811081ff 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -703,8 +703,7 @@ struct file_ra_state {
 					   there are only # of pages ahead */
 
 	unsigned int ra_pages;		/* Maximum readahead window */
-	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
-	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
+	int mmap_miss;			/* Cache miss stat for mmap accesses */
 	unsigned long prev_index;	/* Cache last read() position */
 	unsigned int prev_offset;	/* Offset where last read() ended in a page */
 };

commit 937085aa35cc873d427d250a1e304d641af24628
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Tue Oct 16 01:24:31 2007 -0700

    readahead: compacting file_ra_state
    
    Use 'unsigned int' instead of 'unsigned long' for readahead sizes.
    
    This helps reduce memory consumption on 64bit CPU when a lot of files are
    opened.
    
    CC: Andi Kleen <andi@firstfloor.org>
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4a6a21077bae..7a998c49a086 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -697,12 +697,12 @@ struct fown_struct {
  * Track a single file's readahead state
  */
 struct file_ra_state {
-	pgoff_t start;                  /* where readahead started */
-	unsigned long size;             /* # of readahead pages */
-	unsigned long async_size;       /* do asynchronous readahead when
+	pgoff_t start;			/* where readahead started */
+	unsigned int size;		/* # of readahead pages */
+	unsigned int async_size;	/* do asynchronous readahead when
 					   there are only # of pages ahead */
 
-	unsigned long ra_pages;		/* Maximum readahead window */
+	unsigned int ra_pages;		/* Maximum readahead window */
 	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
 	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
 	unsigned long prev_index;	/* Cache last read() position */

commit 541010e4b8921cd781ff02ae68028501457045b6
Merge: e457f790d8b0 5e7fc436426b
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Oct 15 16:07:40 2007 -0700

    Merge branch 'locks' of git://linux-nfs.org/~bfields/linux
    
    * 'locks' of git://linux-nfs.org/~bfields/linux:
      nfsd: remove IS_ISMNDLCK macro
      Rework /proc/locks via seq_files and seq_list helpers
      fs/locks.c: use list_for_each_entry() instead of list_for_each()
      NFS: clean up explicit check for mandatory locks
      AFS: clean up explicit check for mandatory locks
      9PFS: clean up explicit check for mandatory locks
      GFS2: clean up explicit check for mandatory locks
      Cleanup macros for distinguishing mandatory locks
      Documentation: move locks.txt in filesystems/
      locks: add warning about mandatory locking races
      Documentation: move mandatory locking documentation to filesystems/
      locks: Fix potential OOPS in generic_setlease()
      Use list_first_entry in locks_wake_up_blocks
      locks: fix flock_lock_file() comment
      Memory shortage can result in inconsistent flocks state
      locks: kill redundant local variable
      locks: reverse order of posix_locks_conflict() arguments

commit 14358e6ddaed27499d7d366b3e65c3e46b39e1c4
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Sun Oct 14 01:38:33 2007 +0200

    lockdep: annotate dir vs file i_mutex
    
    On Mon, 2007-09-24 at 22:13 -0400, Steven Rostedt wrote:
    > The circular lock seems to be this:
    >
    > #1:
    >
    >   sys_mmap2:              down_write(&mm->mmap_sem);
    >   nfs_revalidate_mapping: mutex_lock(&inode->i_mutex);
    >
    >
    > #0:
    >
    >   vfs_readdir:     mutex_lock(&inode->i_mutex);
    >    - during the readdir (filldir64), we take a user fault (missing page?)
    >     and call do_page_fault -
    >   do_page_fault:   down_read(&mm->mmap_sem);
    >
    >
    > So it does indeed look like a circular locking. Now the question is, "is
    > this a bug?".  Looking like the inode of #1 must be a file or something
    > else that you can mmap and the inode of #0 seems it must be a directory.
    > I would say "no".
    >
    > Now if you can readdir on a file or mmap a directory, then this could be
    > an issue.
    >
    > Otherwise, I'd love to see someone teach lockdep about this issue! ;-)
    
    Make a distinction between file and dir usage of i_mutex.
    The inode should be complete and unused at unlock_new_inode(), re-init
    i_mutex depending on its type.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0cad20e12585..6d760f1ad875 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1308,6 +1308,7 @@ struct file_system_type {
 
 	struct lock_class_key i_lock_key;
 	struct lock_class_key i_mutex_key;
+	struct lock_class_key i_mutex_dir_key;
 	struct lock_class_key i_alloc_sem_key;
 };
 

commit d475fd428ce77aa2a8bc650d230e17663a4f49c3
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Mon Oct 15 14:51:31 2007 +0200

    lockdep: per filesystem inode lock class
    Give each filesystem its own inode lock class. The various filesystems have
    different locking order wrt the inode locks; esp. the pseudo filesystems differ
    from the rest.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 16421f662a7a..0cad20e12585 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1302,8 +1302,13 @@ struct file_system_type {
 	struct module *owner;
 	struct file_system_type * next;
 	struct list_head fs_supers;
+
 	struct lock_class_key s_lock_key;
 	struct lock_class_key s_umount_key;
+
+	struct lock_class_key i_lock_key;
+	struct lock_class_key i_mutex_key;
+	struct lock_class_key i_alloc_sem_key;
 };
 
 extern int get_sb_bdev(struct file_system_type *fs_type,

commit 7f8ada98d9edd83d6ebd01e431e15b024a4a3dc4
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Mon Oct 1 14:41:15 2007 -0700

    Rework /proc/locks via seq_files and seq_list helpers
    
    Currently /proc/locks is shown with a proc_read function, but its behavior
    is rather complex as it has to manually handle current offset and buffer
    length.  On the other hand, files that show objects from lists can be
    easily reimplemented using the sequential files and the seq_list_XXX()
    helpers.
    
    This saves (as usually) 16 lines of code and more than 200 from
    the .text section.
    
    [akpm@linux-foundation.org: no externs in C]
    [akpm@linux-foundation.org: warning fixes]
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f5075e0e7301..4f1e8cebea78 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -883,6 +883,7 @@ extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
+extern struct seq_operations locks_seq_operations;
 
 struct fasync_struct {
 	int	magic;

commit a16877ca9cec211708a161057a7cbfbf2cbc3a53
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Mon Oct 1 14:41:11 2007 -0700

    Cleanup macros for distinguishing mandatory locks
    
    The combination of S_ISGID bit set and S_IXGRP bit unset is used to mark the
    inode as "mandatory lockable" and there's a macro for this check called
    MANDATORY_LOCK(inode).  However, fs/locks.c and some filesystems still perform
    the explicit i_mode checking.  Besides, Andrew pointed out, that this macro is
    buggy itself, as it dereferences the inode arg twice.
    
    Convert this macro into static inline function and switch its users to it,
    making the code shorter and more readable.
    
    The __mandatory_lock() helper is to be used in places where the IS_MANDLOCK()
    for superblock is already known to be true.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: "J. Bruce Fields" <bfields@fieldses.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Eric Van Hensbergen <ericvh@gmail.com>
    Cc: Ron Minnich <rminnich@sandia.gov>
    Cc: Latchesar Ionkov <lucho@ionkov.net>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 16421f662a7a..f5075e0e7301 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1369,12 +1369,25 @@ extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size
  * Candidates for mandatory locking have the setgid bit set
  * but no group execute bit -  an otherwise meaningless combination.
  */
-#define MANDATORY_LOCK(inode) \
-	(IS_MANDLOCK(inode) && ((inode)->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID)
+
+static inline int __mandatory_lock(struct inode *ino)
+{
+	return (ino->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID;
+}
+
+/*
+ * ... and these candidates should be on MS_MANDLOCK mounted fs,
+ * otherwise these will be advisory locks
+ */
+
+static inline int mandatory_lock(struct inode *ino)
+{
+	return IS_MANDLOCK(ino) && __mandatory_lock(ino);
+}
 
 static inline int locks_verify_locked(struct inode *inode)
 {
-	if (MANDATORY_LOCK(inode))
+	if (mandatory_lock(inode))
 		return locks_mandatory_locked(inode);
 	return 0;
 }
@@ -1385,7 +1398,7 @@ static inline int locks_verify_truncate(struct inode *inode,
 				    struct file *filp,
 				    loff_t size)
 {
-	if (inode->i_flock && MANDATORY_LOCK(inode))
+	if (inode->i_flock && mandatory_lock(inode))
 		return locks_mandatory_area(
 			FLOCK_VERIFY_WRITE, inode, filp,
 			size < inode->i_size ? size : inode->i_size,

commit ec05b297f91a443aa26b74059b573bfad49c9ebb
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Jul 30 08:24:27 2007 +0200

    [PATCH] remove mm/filemap.c:file_send_actor()
    
    This patch removes the no longer used file_send_actor().
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6bf139562947..16421f662a7a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1659,7 +1659,6 @@ extern int sb_min_blocksize(struct super_block *, int);
 extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
-extern int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);

commit 0af1a4504699524c876361845bc2e301ecc45d0f
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jul 31 00:39:22 2007 -0700

    rename setlease to generic_setlease
    
    Make it a little more clear that this is the default implementation for
    the setleast operation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Acked-by: "J. Bruce Fields" <bfields@fieldses.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d33beadd9a43..6bf139562947 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -878,7 +878,7 @@ extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
-extern int setlease(struct file *, long, struct file_lock **);
+extern int generic_setlease(struct file *, long, struct file_lock **);
 extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);

commit f9acc8c7b35a100f3a9e0e6977f7807b0169f9a5
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Thu Jul 19 01:48:08 2007 -0700

    readahead: sanify file_ra_state names
    
    Rename some file_ra_state variables and remove some accessors.
    
    It results in much simpler code.
    Kudos to Rusty!
    
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 29cb32d3a849..d33beadd9a43 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -695,16 +695,12 @@ struct fown_struct {
 
 /*
  * Track a single file's readahead state
- *
- *  ================#============|==================#==================|
- *                  ^            ^                  ^                  ^
- *  file_ra_state.la_index    .ra_index   .lookahead_index   .readahead_index
  */
 struct file_ra_state {
-	pgoff_t la_index;               /* enqueue time */
-	pgoff_t ra_index;               /* begin offset */
-	pgoff_t lookahead_index;        /* time to do next readahead */
-	pgoff_t readahead_index;        /* end offset */
+	pgoff_t start;                  /* where readahead started */
+	unsigned long size;             /* # of readahead pages */
+	unsigned long async_size;       /* do asynchronous readahead when
+					   there are only # of pages ahead */
 
 	unsigned long ra_pages;		/* Maximum readahead window */
 	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
@@ -713,60 +709,15 @@ struct file_ra_state {
 	unsigned int prev_offset;	/* Offset where last read() ended in a page */
 };
 
-/*
- * Measuring read-ahead sizes.
- *
- *                  |----------- readahead size ------------>|
- *  ===#============|==================#=====================|
- *     |------- invoke interval ------>|-- lookahead size -->|
- */
-static inline unsigned long ra_readahead_size(struct file_ra_state *ra)
-{
-	return ra->readahead_index - ra->ra_index;
-}
-
-static inline unsigned long ra_lookahead_size(struct file_ra_state *ra)
-{
-	return ra->readahead_index - ra->lookahead_index;
-}
-
-static inline unsigned long ra_invoke_interval(struct file_ra_state *ra)
-{
-	return ra->lookahead_index - ra->la_index;
-}
-
 /*
  * Check if @index falls in the readahead windows.
  */
 static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
 {
-	return (index >= ra->la_index &&
-		index <  ra->readahead_index);
-}
-
-/*
- * Where is the old read-ahead and look-ahead?
- */
-static inline void ra_set_index(struct file_ra_state *ra,
-				pgoff_t la_index, pgoff_t ra_index)
-{
-	ra->la_index = la_index;
-	ra->ra_index = ra_index;
+	return (index >= ra->start &&
+		index <  ra->start + ra->size);
 }
 
-/*
- * Where is the new read-ahead and look-ahead?
- */
-static inline void ra_set_size(struct file_ra_state *ra,
-				unsigned long ra_size, unsigned long la_size)
-{
-	ra->readahead_index = ra->ra_index + ra_size;
-	ra->lookahead_index = ra->ra_index + ra_size - la_size;
-}
-
-unsigned long ra_submit(struct file_ra_state *ra,
-		       struct address_space *mapping, struct file *filp);
-
 struct file {
 	/*
 	 * fu_list becomes invalid after file_free is called and queued via

commit c743d96b6d2ff55a94df7b5ac7c74987bb9c343b
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Thu Jul 19 01:48:04 2007 -0700

    readahead: remove the old algorithm
    
    Remove the old readahead algorithm.
    
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Cc: Steven Pratt <slpratt@austin.ibm.com>
    Cc: Ram Pai <linuxram@us.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9a5f562abc77..29cb32d3a849 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -701,14 +701,6 @@ struct fown_struct {
  *  file_ra_state.la_index    .ra_index   .lookahead_index   .readahead_index
  */
 struct file_ra_state {
-	unsigned long start;		/* Current window */
-	unsigned long size;
-	unsigned long flags;		/* ra flags RA_FLAG_xxx*/
-	unsigned long cache_hit;	/* cache hit count*/
-	unsigned long prev_index;	/* Cache last read() position */
-	unsigned long ahead_start;	/* Ahead window */
-	unsigned long ahead_size;
-
 	pgoff_t la_index;               /* enqueue time */
 	pgoff_t ra_index;               /* begin offset */
 	pgoff_t lookahead_index;        /* time to do next readahead */
@@ -717,10 +709,9 @@ struct file_ra_state {
 	unsigned long ra_pages;		/* Maximum readahead window */
 	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
 	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
+	unsigned long prev_index;	/* Cache last read() position */
 	unsigned int prev_offset;	/* Offset where last read() ended in a page */
 };
-#define RA_FLAG_MISS 0x01	/* a cache miss occured against this file */
-#define RA_FLAG_INCACHE 0x02	/* file is already in cache */
 
 /*
  * Measuring read-ahead sizes.

commit 5ce1110b92b31d079aa443e967f43a2294e01194
Author: Fengguang Wu <wfg@mail.ustc.edu.cn>
Date:   Thu Jul 19 01:47:59 2007 -0700

    readahead: data structure and routines
    
    Extend struct file_ra_state to support the on-demand readahead logic.  Also
    define some helpers for it.
    
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Cc: Steven Pratt <slpratt@austin.ibm.com>
    Cc: Ram Pai <linuxram@us.ibm.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 75dd16efc9b6..9a5f562abc77 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -695,6 +695,10 @@ struct fown_struct {
 
 /*
  * Track a single file's readahead state
+ *
+ *  ================#============|==================#==================|
+ *                  ^            ^                  ^                  ^
+ *  file_ra_state.la_index    .ra_index   .lookahead_index   .readahead_index
  */
 struct file_ra_state {
 	unsigned long start;		/* Current window */
@@ -704,6 +708,12 @@ struct file_ra_state {
 	unsigned long prev_index;	/* Cache last read() position */
 	unsigned long ahead_start;	/* Ahead window */
 	unsigned long ahead_size;
+
+	pgoff_t la_index;               /* enqueue time */
+	pgoff_t ra_index;               /* begin offset */
+	pgoff_t lookahead_index;        /* time to do next readahead */
+	pgoff_t readahead_index;        /* end offset */
+
 	unsigned long ra_pages;		/* Maximum readahead window */
 	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
 	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
@@ -712,6 +722,60 @@ struct file_ra_state {
 #define RA_FLAG_MISS 0x01	/* a cache miss occured against this file */
 #define RA_FLAG_INCACHE 0x02	/* file is already in cache */
 
+/*
+ * Measuring read-ahead sizes.
+ *
+ *                  |----------- readahead size ------------>|
+ *  ===#============|==================#=====================|
+ *     |------- invoke interval ------>|-- lookahead size -->|
+ */
+static inline unsigned long ra_readahead_size(struct file_ra_state *ra)
+{
+	return ra->readahead_index - ra->ra_index;
+}
+
+static inline unsigned long ra_lookahead_size(struct file_ra_state *ra)
+{
+	return ra->readahead_index - ra->lookahead_index;
+}
+
+static inline unsigned long ra_invoke_interval(struct file_ra_state *ra)
+{
+	return ra->lookahead_index - ra->la_index;
+}
+
+/*
+ * Check if @index falls in the readahead windows.
+ */
+static inline int ra_has_index(struct file_ra_state *ra, pgoff_t index)
+{
+	return (index >= ra->la_index &&
+		index <  ra->readahead_index);
+}
+
+/*
+ * Where is the old read-ahead and look-ahead?
+ */
+static inline void ra_set_index(struct file_ra_state *ra,
+				pgoff_t la_index, pgoff_t ra_index)
+{
+	ra->la_index = la_index;
+	ra->ra_index = ra_index;
+}
+
+/*
+ * Where is the new read-ahead and look-ahead?
+ */
+static inline void ra_set_size(struct file_ra_state *ra,
+				unsigned long ra_size, unsigned long la_size)
+{
+	ra->readahead_index = ra->ra_index + ra_size;
+	ra->lookahead_index = ra->ra_index + ra_size - la_size;
+}
+
+unsigned long ra_submit(struct file_ra_state *ra,
+		       struct address_space *mapping, struct file *filp);
+
 struct file {
 	/*
 	 * fu_list becomes invalid after file_free is called and queued via

commit e53252d97e670a38b1d2e9723b48077bba11ddda
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jul 19 01:47:51 2007 -0700

    unregister_chrdev() return void
    
    unregister_chrdev() does not return meaningful value.  This patch makes it
    return void like most unregister_* functions.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9562a59b3703..75dd16efc9b6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1463,7 +1463,7 @@ extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
 extern int register_chrdev(unsigned int, const char *,
 			   const struct file_operations *);
-extern int unregister_chrdev(unsigned int, const char *);
+extern void unregister_chrdev(unsigned int, const char *);
 extern void unregister_chrdev_region(dev_t, unsigned);
 extern int chrdev_open(struct inode *, struct file *);
 extern void chrdev_show(struct seq_file *,off_t);

commit a8dcf12f9e8ba113251c04d602f1695d537fb142
Merge: d796e641a3ee 6924c55492c9
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Jul 18 18:27:00 2007 -0700

    Merge branch 'for-linus' of git://linux-nfs.org/~bfields/linux
    
    * 'for-linus' of git://linux-nfs.org/~bfields/linux:
      locks: fix vfs_test_lock() comment
      locks: make posix_test_lock() interface more consistent
      nfs: disable leases over NFS
      gfs2: stop giving out non-cluster-coherent leases
      locks: export setlease to filesystems
      locks: provide a file lease method enabling cluster-coherent leases
      locks: rename lease functions to reflect locks.c conventions
      locks: share more common lease code
      locks: clean up lease_alloc()
      locks: convert an -EINVAL return to a BUG
      leases: minor break_lease() comment clarification

commit 6d34ac199a4af5c678a3a8f3275aeb2586b72da3
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Fri May 11 16:09:32 2007 -0400

    locks: make posix_test_lock() interface more consistent
    
    Since posix_test_lock(), like fcntl() and ->lock(), indicates absence or
    presence of a conflict lock by setting fl_type to, respectively, F_UNLCK
    or something other than F_UNLCK, the return value is no longer needed.
    
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b188c2e5338d..80deaaf1b746 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -862,7 +862,7 @@ extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
-extern int posix_test_lock(struct file *, struct file_lock *);
+extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);

commit 4698afe8e3a725576366f86560a8a8242b21b9f7
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Jul 4 17:21:37 2007 -0400

    locks: export setlease to filesystems
    
    Export setlease so it can used by filesystems to implement their lease
    methods.
    
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c8ddf34e9710..b188c2e5338d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -872,6 +872,7 @@ extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
+extern int setlease(struct file *, long, struct file_lock **);
 extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);

commit f9ffed26d6f3e6ac9988947242821579d615fda7
Author: J. Bruce Fields <bfields@fieldses.org>
Date:   Tue Nov 14 15:51:40 2006 -0500

    locks: provide a file lease method enabling cluster-coherent leases
    
    Currently leases are only kept locally, so there's no way for a distributed
    filesystem to enforce them against multiple clients.  We're particularly
    interested in the case of nfsd exporting a cluster filesystem, in which
    case nfsd needs cluster-coherent leases in order to implement delegations
    correctly.
    
    Also add some documentation.
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a24f029accc0..c8ddf34e9710 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1122,6 +1122,7 @@ struct file_operations {
 	int (*flock) (struct file *, int, struct file_lock *);
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
+	int (*setlease)(struct file *, long, struct file_lock **);
 };
 
 struct inode_operations {

commit a9933cea7a1d80dd9efae9f1acd857f5dce742b9
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Thu Jun 7 17:09:49 2007 -0400

    locks: rename lease functions to reflect locks.c conventions
    
    We've been using the convention that vfs_foo is the function that calls
    a filesystem-specific foo method if it exists, or falls back on a
    generic method if it doesn't; thus vfs_foo is what is called when some
    other part of the kernel (normally lockd or nfsd) wants to get a lock,
    whereas foo is what filesystems call to use the underlying local
    functionality as part of their lock implementation.
    
    So rename setlease to vfs_setlease (which will call a
    filesystem-specific setlease after a later patch) and __setlease to
    setlease.
    
    Also, vfs_setlease need only be GPL-exported as long as it's only needed
    by lockd and nfsd.
    
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98205f680476..a24f029accc0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -872,7 +872,7 @@ extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
-extern int setlease(struct file *, long, struct file_lock **);
+extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);

commit 97ac73506c0ba93f30239bb57b4cfc5d73e68a62
Author: Amit Arora <aarora@in.ibm.com>
Date:   Tue Jul 17 21:42:44 2007 -0400

    sys_fallocate() implementation on i386, x86_64 and powerpc
    
    fallocate() is a new system call being proposed here which will allow
    applications to preallocate space to any file(s) in a file system.
    Each file system implementation that wants to use this feature will need
    to support an inode operation called ->fallocate().
    Applications can use this feature to avoid fragmentation to certain
    level and thus get faster access speed. With preallocation, applications
    also get a guarantee of space for particular file(s) - even if later the
    the system becomes full.
    
    Currently, glibc provides an interface called posix_fallocate() which
    can be used for similar cause. Though this has the advantage of working
    on all file systems, but it is quite slow (since it writes zeroes to
    each block that has to be preallocated). Without a doubt, file systems
    can do this more efficiently within the kernel, by implementing
    the proposed fallocate() system call. It is expected that
    posix_fallocate() will be modified to call this new system call first
    and incase the kernel/filesystem does not implement it, it should fall
    back to the current implementation of writing zeroes to the new blocks.
    ToDos:
    1. Implementation on other architectures (other than i386, x86_64,
       and ppc). Patches for s390(x) and ia64 are already available from
       previous posts, but it was decided that they should be added later
       once fallocate is in the mainline. Hence not including those patches
       in this take.
    2. Changes to glibc,
       a) to support fallocate() system call
       b) to make posix_fallocate() and posix_fallocate64() call fallocate()
    
    Signed-off-by: Amit Arora <aarora@in.ibm.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98205f680476..0b806c5e32eb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1147,6 +1147,8 @@ struct inode_operations {
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*removexattr) (struct dentry *, const char *);
 	void (*truncate_range)(struct inode *, loff_t, loff_t);
+	long (*fallocate)(struct inode *inode, int mode, loff_t offset,
+			  loff_t len);
 };
 
 struct seq_file;

commit 3bd858ab1c451725c07a805dcb315215dc85b86e
Author: Satyam Sharma <ssatyam@cse.iitk.ac.in>
Date:   Tue Jul 17 15:00:08 2007 +0530

    Introduce is_owner_or_cap() to wrap CAP_FOWNER use with fsuid check
    
    Introduce is_owner_or_cap() macro in fs.h, and convert over relevant
    users to it. This is done because we want to avoid bugs in the future
    where we check for only effective fsuid of the current task against a
    file's owning uid, without simultaneously checking for CAP_FOWNER as
    well, thus violating its semantics.
    [ XFS uses special macros and structures, and in general looked ...
    untouchable, so we leave it alone -- but it has been looked over. ]
    
    The (current->fsuid != inode->i_uid) check in generic_permission() and
    exec_permission_lite() is left alone, because those operations are
    covered by CAP_DAC_OVERRIDE and CAP_DAC_READ_SEARCH. Similarly operations
    falling under the purview of CAP_CHOWN and CAP_LEASE are also left alone.
    
    Signed-off-by: Satyam Sharma <ssatyam@cse.iitk.ac.in>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Acked-by: Serge E. Hallyn <serge@hallyn.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 58ce336d4a6b..98205f680476 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -284,6 +284,7 @@ extern int dir_notify_enable;
 #include <linux/pid.h>
 #include <linux/mutex.h>
 #include <linux/sysctl.h>
+#include <linux/capability.h>
 
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
@@ -990,6 +991,9 @@ enum {
 #define put_fs_excl() atomic_dec(&current->fs_excl)
 #define has_fs_excl() atomic_read(&current->fs_excl)
 
+#define is_owner_or_cap(inode)	\
+	((current->fsuid == (inode)->i_uid) || capable(CAP_FOWNER))
+
 /* not quite ready to be deprecated, but... */
 extern void lock_super(struct super_block *);
 extern void unlock_super(struct super_block *);

commit a569425512253992cc64ebf8b6d00a62f986db3e
Author: Christoph Hellwig <hch@infradead.org>
Date:   Tue Jul 17 04:04:28 2007 -0700

    knfsd: exportfs: add exportfs.h header
    
    currently the export_operation structure and helpers related to it are in
    fs.h.  fs.h is already far too large and there are very few places needing the
    export bits, so split them off into a separate header.
    
    [akpm@linux-foundation.org: fix cifs build]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Neil Brown <neilb@suse.de>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa74f7de9dcd..58ce336d4a6b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -289,6 +289,7 @@ extern int dir_notify_enable;
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 
+struct export_operations;
 struct hd_geometry;
 struct iovec;
 struct nameidata;
@@ -1278,119 +1279,6 @@ static inline void file_accessed(struct file *file)
 
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
 
-/**
- * struct export_operations - for nfsd to communicate with file systems
- * @decode_fh:      decode a file handle fragment and return a &struct dentry
- * @encode_fh:      encode a file handle fragment from a dentry
- * @get_name:       find the name for a given inode in a given directory
- * @get_parent:     find the parent of a given directory
- * @get_dentry:     find a dentry for the inode given a file handle sub-fragment
- * @find_exported_dentry:
- *	set by the exporting module to a standard helper function.
- *
- * Description:
- *    The export_operations structure provides a means for nfsd to communicate
- *    with a particular exported file system  - particularly enabling nfsd and
- *    the filesystem to co-operate when dealing with file handles.
- *
- *    export_operations contains two basic operation for dealing with file
- *    handles, decode_fh() and encode_fh(), and allows for some other
- *    operations to be defined which standard helper routines use to get
- *    specific information from the filesystem.
- *
- *    nfsd encodes information use to determine which filesystem a filehandle
- *    applies to in the initial part of the file handle.  The remainder, termed
- *    a file handle fragment, is controlled completely by the filesystem.  The
- *    standard helper routines assume that this fragment will contain one or
- *    two sub-fragments, one which identifies the file, and one which may be
- *    used to identify the (a) directory containing the file.
- *
- *    In some situations, nfsd needs to get a dentry which is connected into a
- *    specific part of the file tree.  To allow for this, it passes the
- *    function acceptable() together with a @context which can be used to see
- *    if the dentry is acceptable.  As there can be multiple dentrys for a
- *    given file, the filesystem should check each one for acceptability before
- *    looking for the next.  As soon as an acceptable one is found, it should
- *    be returned.
- *
- * decode_fh:
- *    @decode_fh is given a &struct super_block (@sb), a file handle fragment
- *    (@fh, @fh_len) and an acceptability testing function (@acceptable,
- *    @context).  It should return a &struct dentry which refers to the same
- *    file that the file handle fragment refers to,  and which passes the
- *    acceptability test.  If it cannot, it should return a %NULL pointer if
- *    the file was found but no acceptable &dentries were available, or a
- *    %ERR_PTR error code indicating why it couldn't be found (e.g. %ENOENT or
- *    %ENOMEM).
- *
- * encode_fh:
- *    @encode_fh should store in the file handle fragment @fh (using at most
- *    @max_len bytes) information that can be used by @decode_fh to recover the
- *    file refered to by the &struct dentry @de.  If the @connectable flag is
- *    set, the encode_fh() should store sufficient information so that a good
- *    attempt can be made to find not only the file but also it's place in the
- *    filesystem.   This typically means storing a reference to de->d_parent in
- *    the filehandle fragment.  encode_fh() should return the number of bytes
- *    stored or a negative error code such as %-ENOSPC
- *
- * get_name:
- *    @get_name should find a name for the given @child in the given @parent
- *    directory.  The name should be stored in the @name (with the
- *    understanding that it is already pointing to a a %NAME_MAX+1 sized
- *    buffer.   get_name() should return %0 on success, a negative error code
- *    or error.  @get_name will be called without @parent->i_mutex held.
- *
- * get_parent:
- *    @get_parent should find the parent directory for the given @child which
- *    is also a directory.  In the event that it cannot be found, or storage
- *    space cannot be allocated, a %ERR_PTR should be returned.
- *
- * get_dentry:
- *    Given a &super_block (@sb) and a pointer to a file-system specific inode
- *    identifier, possibly an inode number, (@inump) get_dentry() should find
- *    the identified inode and return a dentry for that inode.  Any suitable
- *    dentry can be returned including, if necessary, a new dentry created with
- *    d_alloc_root.  The caller can then find any other extant dentrys by
- *    following the d_alias links.  If a new dentry was created using
- *    d_alloc_root, DCACHE_NFSD_DISCONNECTED should be set, and the dentry
- *    should be d_rehash()ed.
- *
- *    If the inode cannot be found, either a %NULL pointer or an %ERR_PTR code
- *    can be returned.  The @inump will be whatever was passed to
- *    nfsd_find_fh_dentry() in either the @obj or @parent parameters.
- *
- * Locking rules:
- *    get_parent is called with child->d_inode->i_mutex down
- *    get_name is not (which is possibly inconsistent)
- */
-
-struct export_operations {
-	struct dentry *(*decode_fh)(struct super_block *sb, __u32 *fh, int fh_len, int fh_type,
-			 int (*acceptable)(void *context, struct dentry *de),
-			 void *context);
-	int (*encode_fh)(struct dentry *de, __u32 *fh, int *max_len,
-			 int connectable);
-
-	/* the following are only called from the filesystem itself */
-	int (*get_name)(struct dentry *parent, char *name,
-			struct dentry *child);
-	struct dentry * (*get_parent)(struct dentry *child);
-	struct dentry * (*get_dentry)(struct super_block *sb, void *inump);
-
-	/* This is set by the exporting module to a standard helper */
-	struct dentry * (*find_exported_dentry)(
-		struct super_block *sb, void *obj, void *parent,
-		int (*acceptable)(void *context, struct dentry *de),
-		void *context);
-
-
-};
-
-extern struct dentry *
-find_exported_dentry(struct super_block *sb, void *obj, void *parent,
-		     int (*acceptable)(void *context, struct dentry *de),
-		     void *context);
-
 struct file_system_type {
 	const char *name;
 	int fs_flags;

commit f4480240f700587c15507b7815e75989b16825b2
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Tue Jul 17 04:03:47 2007 -0700

    unregister_blkdev(): return void
    
    Put WARN_ON and fixed all callers of unregister_blkdev().  Now we can make
    unregister_blkdev return void.
    
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b3a9f0db9d80..aa74f7de9dcd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1527,7 +1527,7 @@ extern void putname(const char *name);
 
 #ifdef CONFIG_BLOCK
 extern int register_blkdev(unsigned int, const char *);
-extern int unregister_blkdev(unsigned int, const char *);
+extern void unregister_blkdev(unsigned int, const char *);
 extern struct block_device *bdget(dev_t);
 extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);

commit 62239ac2b301abc397e70986649666cfb7835907
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Jul 17 04:03:45 2007 -0700

    proper prototype for proc_nr_files()
    
    Add a proper prototype for proc_nr_files() in include/linux/fs.h
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e68780810279..b3a9f0db9d80 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -283,6 +283,7 @@ extern int dir_notify_enable;
 #include <linux/init.h>
 #include <linux/pid.h>
 #include <linux/mutex.h>
+#include <linux/sysctl.h>
 
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
@@ -2050,5 +2051,9 @@ static inline void free_secdata(void *secdata)
 { }
 #endif	/* CONFIG_SECURITY */
 
+int proc_nr_files(ctl_table *table, int write, struct file *filp,
+		  void __user *buffer, size_t *lenp, loff_t *ppos);
+
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_FS_H */

commit 9e7bf24b1b979db256ddc84d0d4ac6040d706da6
Author: Stefan Richter <stefanr@s5r6.in-berlin.de>
Date:   Sun Jul 15 23:40:25 2007 -0700

    fs: clarify "dummy" member in struct inodes_stat_t
    
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index aa4530c1ff7a..e68780810279 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -44,7 +44,7 @@ extern int get_max_files(void);
 struct inodes_stat_t {
 	int nr_inodes;
 	int nr_unused;
-	int dummy[5];
+	int dummy[5];		/* padding for sysctl ABI compatibility */
 };
 extern struct inodes_stat_t inodes_stat;
 

commit e8d6c554126b830217c5e9f549e0e21f865a0a8a
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jul 15 23:40:12 2007 -0700

    AFS: implement file locking
    
    Implement file locking for AFS.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51c938a71dec..aa4530c1ff7a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -820,6 +820,10 @@ struct file_lock {
 	union {
 		struct nfs_lock_info	nfs_fl;
 		struct nfs4_lock_info	nfs4_fl;
+		struct {
+			struct list_head link;	/* link in AFS vnode's pending_locks list */
+			int state;		/* state of grant or error if -ve */
+		} afs;
 	} fl_u;
 };
 

commit fc9a07e7bf1a76e710f5df017abb07628db1781d
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Sun Jul 15 23:38:14 2007 -0700

    invalidate_mapping_pages(): add cond_resched
    
    invalidate_mapping_pages() can sometimes take a long time (millions of pages
    to free).  Long enough for the softlockup detector to trigger.
    
    We used to have a cond_resched() in there but I took it out because the
    drop_caches code calls invalidate_mapping_pages() under inode_lock.
    
    The patch adds a nasty flag and puts the cond_resched() back.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f0b3bf5983c..51c938a71dec 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1610,6 +1610,9 @@ extern int __invalidate_device(struct block_device *);
 extern int invalidate_partition(struct gendisk *, int);
 #endif
 extern int invalidate_inodes(struct super_block *);
+unsigned long __invalidate_mapping_pages(struct address_space *mapping,
+					pgoff_t start, pgoff_t end,
+					bool be_atomic);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
 

commit d96e6e71647846e0dab097efd9b8bf3a3a556dca
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Jun 11 12:18:52 2007 +0200

    Remove remnants of sendfile()
    
    There are now zero users of .sendfile() in the kernel, so kill
    it from the file_operations structure and in do_sendfile().
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 894620e9402c..4f0b3bf5983c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1054,7 +1054,7 @@ struct block_device_operations {
 };
 
 /*
- * "descriptor" for what we're up to with a read for sendfile().
+ * "descriptor" for what we're up to with a read.
  * This allows us to use the same read code yet
  * have multiple different users of the data that
  * we read from a file.
@@ -1105,7 +1105,6 @@ struct file_operations {
 	int (*aio_fsync) (struct kiocb *, int datasync);
 	int (*fasync) (int, struct file *, int);
 	int (*lock) (struct file *, int, struct file_lock *);
-	ssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);
 	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
 	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
 	int (*check_flags)(int);

commit d054fe3d10cc1f9aec01378c38caa32dffdd0090
Author: Carsten Otte <cotte@de.ibm.com>
Date:   Fri Jun 15 08:16:22 2007 +0200

    xip sendfile removal
    
    This patch removes xip_file_sendfile, the sendfile implementation for
    xip without replacement. Those customers that use xip on s390 are not
    using sendfile() as far as we know, and so far s390 is the only platform
    this could potentially be used on so far.
    Having sendfile is not a popular feature for execute in place file
    systems, however we have a working implementation of splice_read() based
    on fs/splice.c if anyone asks for it.
    At this point in time, it does not seem preferable to merge
    splice_read() for xip because it causes extra maintenence effort due to
    code duplication and it requires struct page behind the xip memory
    segment. We'd like to get rid of that in favor of supporting flash based
    embedded platforms (Monta Vista work) soon.
    
    Signed-off-by: Carsten Otte <cotte@de.ibm.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 87c1d3e9d6cb..894620e9402c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1791,9 +1791,6 @@ extern int nonseekable_open(struct inode * inode, struct file * filp);
 #ifdef CONFIG_FS_XIP
 extern ssize_t xip_file_read(struct file *filp, char __user *buf, size_t len,
 			     loff_t *ppos);
-extern ssize_t xip_file_sendfile(struct file *in_file, loff_t *ppos,
-				 size_t count, read_actor_t actor,
-				 void *target);
 extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
 extern ssize_t xip_file_write(struct file *filp, const char __user *buf,
 			      size_t len, loff_t *ppos);

commit 0452a4e5d021900b07ebdeecb9ed03b49f164f3f
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Fri Jun 1 11:55:49 2007 +0200

    sendfile: kill generic_file_sendfile()
    
    It's no longer used.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6a41f4cab14c..87c1d3e9d6cb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1762,7 +1762,6 @@ extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t, loff_t *, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
-extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor_t, void *);
 extern void do_generic_mapping_read(struct address_space *mapping,
 				    struct file_ra_state *, struct file *,
 				    loff_t *, read_descriptor_t *, read_actor_t);

commit 71c42157904404a37f89fff3b2536c55115823a5
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Sat Jun 23 17:16:42 2007 -0700

    document nlink function
    
    These should have been documented from the beginning.  Fix it.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b3ae77cccbb6..6a41f4cab14c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1211,6 +1211,14 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
 	__mark_inode_dirty(inode, I_DIRTY_SYNC);
 }
 
+/**
+ * inc_nlink - directly increment an inode's link count
+ * @inode: inode
+ *
+ * This is a low-level filesystem helper to replace any
+ * direct filesystem manipulation of i_nlink.  Currently,
+ * it is only here for parity with dec_nlink().
+ */
 static inline void inc_nlink(struct inode *inode)
 {
 	inode->i_nlink++;
@@ -1222,11 +1230,30 @@ static inline void inode_inc_link_count(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
+/**
+ * drop_nlink - directly drop an inode's link count
+ * @inode: inode
+ *
+ * This is a low-level filesystem helper to replace any
+ * direct filesystem manipulation of i_nlink.  In cases
+ * where we are attempting to track writes to the
+ * filesystem, a decrement to zero means an imminent
+ * write when the file is truncated and actually unlinked
+ * on the filesystem.
+ */
 static inline void drop_nlink(struct inode *inode)
 {
 	inode->i_nlink--;
 }
 
+/**
+ * clear_nlink - directly zero an inode's link count
+ * @inode: inode
+ *
+ * This is a low-level filesystem helper to replace any
+ * direct filesystem manipulation of i_nlink.  See
+ * drop_nlink() for why we care about i_nlink hitting zero.
+ */
 static inline void clear_nlink(struct inode *inode)
 {
 	inode->i_nlink = 0;

commit ec4883b015c3212f6f6d04fb2ff45f528492f598
Merge: 464cf177df77 0477d24e2a87
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Jun 4 17:54:09 2007 -0700

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6:
      [JFFS2] Fix obsoletion of metadata nodes in jffs2_add_tn_to_tree()
      [MTD] Fix error checking after get_mtd_device() in get_sb_mtd functions
      [JFFS2] Fix buffer length calculations in jffs2_get_inode_nodes()
      [JFFS2] Fix potential memory leak of dead xattrs on unmount.
      [JFFS2] Fix BUG() caused by failing to discard xattrs on deleted files.
      [MTD] generalise the handling of MTD-specific superblocks
      [MTD] [MAPS] don't force uclinux mtd map to be root dev

commit acaebfd8a7af0019b2edfcf4045c56c3e18375c5
Author: David Howells <dhowells@redhat.com>
Date:   Thu May 10 22:51:50 2007 -0700

    [MTD] generalise the handling of MTD-specific superblocks
    
    Generalise the handling of MTD-specific superblocks so that JFFS2 and ROMFS
    can both share it.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 095a9c9a64fb..151739a55eaf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -937,6 +937,7 @@ struct super_block {
 	struct list_head	s_files;
 
 	struct block_device	*s_bdev;
+	struct mtd_info		*s_mtd;
 	struct list_head	s_instances;
 	struct quota_info	s_dquot;	/* Diskquota specific options */
 

commit ef51c97623b94f51e439ac91d2736aab3d1b6594
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Tue May 8 00:27:10 2007 -0700

    Remove do_sync_file_range()
    
    Remove do_sync_file_range() and convert callers to just use
    do_sync_mapping_range().
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 527a09a82297..7cf0c54a46a7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -849,11 +849,6 @@ extern int fcntl_getlease(struct file *filp);
 /* fs/sync.c */
 extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
 			loff_t endbyte, unsigned int flags);
-static inline int do_sync_file_range(struct file *file, loff_t offset,
-			loff_t endbyte, unsigned int flags)
-{
-	return do_sync_mapping_range(file->f_mapping, offset, endbyte, flags);
-}
 
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);

commit 79c0b2df79eb56fc71e54c75cd7fb3acf84370f9
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Tue May 8 00:25:43 2007 -0700

    add filesystem subtype support
    
    There's a slight problem with filesystem type representation in fuse
    based filesystems.
    
    From the kernel's view, there are just two filesystem types: fuse and
    fuseblk.  From the user's view there are lots of different filesystem
    types.  The user is not even much concerned if the filesystem is fuse based
    or not.  So there's a conflict of interest in how this should be
    represented in fstab, mtab and /proc/mounts.
    
    The current scheme is to encode the real filesystem type in the mount
    source.  So an sshfs mount looks like this:
    
      sshfs#user@server:/   /mnt/server    fuse   rw,nosuid,nodev,...
    
    This url-ish syntax works OK for sshfs and similar filesystems.  However
    for block device based filesystems (ntfs-3g, zfs) it doesn't work, since
    the kernel expects the mount source to be a real device name.
    
    A possibly better scheme would be to encode the real type in the type
    field as "type.subtype".  So fuse mounts would look like this:
    
      /dev/hda1       /mnt/windows   fuseblk.ntfs-3g   rw,...
      user@server:/   /mnt/server    fuse.sshfs        rw,nosuid,nodev,...
    
    This patch adds the necessary code to the kernel so that this can be
    correctly displayed in /proc/mounts.
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 986b5d5d369f..527a09a82297 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -92,6 +92,7 @@ extern int dir_notify_enable;
 /* public flags for file_system_type */
 #define FS_REQUIRES_DEV 1 
 #define FS_BINARY_MOUNTDATA 2
+#define FS_HAS_SUBTYPE 4
 #define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move()
 					 * during rename() internally.
@@ -961,6 +962,12 @@ struct super_block {
 	/* Granularity of c/m/atime in ns.
 	   Cannot be worse than a second */
 	u32		   s_time_gran;
+
+	/*
+	 * Filesystem subtype.  If non-empty the filesystem type field
+	 * in /proc/mounts will be "type.subtype"
+	 */
+	char *s_subtype;
 };
 
 extern struct timespec current_fs_time(struct super_block *sb);

commit 1ae7075bcd805c3aa5e8f53effc63a4562d6110e
Author: Chris Snook <csnook@redhat.com>
Date:   Tue May 8 00:24:15 2007 -0700

    use use SEEK_MAX to validate user lseek arguments
    
    Add SEEK_MAX and use it to validate lseek arguments from userspace.
    
    Signed-off-by: Chris Snook <csnook@redhat.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 020a8426e10a..986b5d5d369f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -30,6 +30,7 @@
 #define SEEK_SET	0	/* seek relative to beginning of file */
 #define SEEK_CUR	1	/* seek relative to current file position */
 #define SEEK_END	2	/* seek relative to end of file */
+#define SEEK_MAX	SEEK_END
 
 /* And dynamically-tunable limits and defaults: */
 struct files_stat_struct {

commit 0ceb331433e8aad9c5f441a965d7c681f8b9046f
Author: Dmitriy Monakhov <dmonakhov@openvz.org>
Date:   Tue May 8 00:23:02 2007 -0700

    mm: move common segment checks to separate helper function
    
    [akpm@linux-foundation.org: cleanup]
    Signed-off-by: Monakhov Dmitriy <dmonakhov@openvz.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Acked-by: Anton Altaparmakov <aia21@cam.ac.uk>
    Acked-by: David Chinner <dgc@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bc6d27cecaac..020a8426e10a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1735,6 +1735,8 @@ extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor
 extern void do_generic_mapping_read(struct address_space *mapping,
 				    struct file_ra_state *, struct file *,
 				    loff_t *, read_descriptor_t *, read_actor_t);
+extern int generic_segment_checks(const struct iovec *iov,
+		unsigned long *nr_segs, size_t *count, int access_flags);
 
 /* fs/splice.c */
 extern ssize_t generic_file_splice_read(struct file *, loff_t *,

commit 2d56d3c43cc97ae48586745556f5a5b564d61582
Merge: 0f9008ef38d5 586759f03e2e
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon May 7 12:34:24 2007 -0700

    Merge branch 'server-cluster-locking-api' of git://linux-nfs.org/~bfields/linux
    
    * 'server-cluster-locking-api' of git://linux-nfs.org/~bfields/linux:
      gfs2: nfs lock support for gfs2
      lockd: add code to handle deferred lock requests
      lockd: always preallocate block in nlmsvc_lock()
      lockd: handle test_lock deferrals
      lockd: pass cookie in nlmsvc_testlock
      lockd: handle fl_grant callbacks
      lockd: save lock state on deferral
      locks: add fl_grant callback for asynchronous lock return
      nfsd4: Convert NFSv4 to new lock interface
      locks: add lock cancel command
      locks: allow {vfs,posix}_lock_file to return conflicting lock
      locks: factor out generic/filesystem switch from setlock code
      locks: factor out generic/filesystem switch from test_lock
      locks: give posix_test_lock same interface as ->lock
      locks: make ->lock release private data before returning in GETLK case
      locks: create posix-to-flock helper functions
      locks: trivial removal of unnecessary parentheses

commit 6ce745ed39d35f9d547d00d406db2be7c6c175b3
Author: Jan Kara <jack@suse.cz>
Date:   Sun May 6 14:49:26 2007 -0700

    readahead: code cleanup
    
    Rename file_ra_state.prev_page to prev_index and file_ra_state.offset to
    prev_offset.  Also update of prev_index in do_generic_mapping_read() is now
    moved close to the update of prev_offset.
    
    [wfg@mail.ustc.edu.cn: fix it]
    Signed-off-by: Jan Kara <jack@suse.cz>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: WU Fengguang <wfg@mail.ustc.edu.cn>
    Signed-off-by: Fengguang Wu <wfg@mail.ustc.edu.cn>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0949e243b8b9..55a74ffa7e3b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -696,13 +696,13 @@ struct file_ra_state {
 	unsigned long size;
 	unsigned long flags;		/* ra flags RA_FLAG_xxx*/
 	unsigned long cache_hit;	/* cache hit count*/
-	unsigned long prev_page;	/* Cache last read() position */
+	unsigned long prev_index;	/* Cache last read() position */
 	unsigned long ahead_start;	/* Ahead window */
 	unsigned long ahead_size;
 	unsigned long ra_pages;		/* Maximum readahead window */
 	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
 	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
-	unsigned int offset;		/* Offset where last read() ended in a page */
+	unsigned int prev_offset;	/* Offset where last read() ended in a page */
 };
 #define RA_FLAG_MISS 0x01	/* a cache miss occured against this file */
 #define RA_FLAG_INCACHE 0x02	/* file is already in cache */

commit ec0f16372277052a29a6c17527c6cae5e898b3fd
Author: Jan Kara <jack@suse.cz>
Date:   Sun May 6 14:49:25 2007 -0700

    readahead: improve heuristic detecting sequential reads
    
    Introduce ra.offset and store in it an offset where the previous read
    ended.  This way we can detect whether reads are really sequential (and
    thus we should not mark the page as accessed repeatedly) or whether they
    are random and just happen to be in the same page (and the page should
    really be marked accessed again).
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Acked-by: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: WU Fengguang <wfg@mail.ustc.edu.cn>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7c0077f06e24..0949e243b8b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -702,6 +702,7 @@ struct file_ra_state {
 	unsigned long ra_pages;		/* Maximum readahead window */
 	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
 	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
+	unsigned int offset;		/* Offset where last read() ended in a page */
 };
 #define RA_FLAG_MISS 0x01	/* a cache miss occured against this file */
 #define RA_FLAG_INCACHE 0x02	/* file is already in cache */

commit 2beb6614f5e36c6165b704c167d82ef3e4ceaa0c
Author: Marc Eshel <eshel@almaden.ibm.com>
Date:   Tue Dec 5 23:31:28 2006 -0500

    locks: add fl_grant callback for asynchronous lock return
    
    Acquiring a lock on a cluster filesystem may require communication with
    remote hosts, and to avoid blocking lockd or nfsd threads during such
    communication, we allow the results to be returned asynchronously.
    
    When a ->lock() call needs to block, the file system will return
    -EINPROGRESS, and then later return the results with a call to the
    routine in the fl_grant field of the lock_manager_operations struct.
    
    This differs from the case when ->lock returns -EAGAIN to a blocking
    lock request; in that case, the filesystem calls fl_notify when the lock
    is granted, and the caller retries the original lock.  So while
    fl_notify is merely a hint to the caller that it should retry, fl_grant
    actually communicates the final result of the lock operation (with the
    lock already acquired in the succesful case).
    
    Therefore fl_grant takes a lock, a status and, for the test lock case, a
    conflicting lock.  We also allow fl_grant to return an error to the
    filesystem, to handle the case where the fl_grant requests arrives after
    the lock manager has already given up waiting for it.
    
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 64b8ae205309..b22991d5f16b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -785,6 +785,7 @@ struct file_lock_operations {
 struct lock_manager_operations {
 	int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
 	void (*fl_notify)(struct file_lock *);	/* unblock callback */
+	int (*fl_grant)(struct file_lock *, struct file_lock *, int);
 	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
 	void (*fl_release_private)(struct file_lock *);
 	void (*fl_break)(struct file_lock *);

commit 9b9d2ab4154a42ea4a119f7d3e4e0288bfe0bb79
Author: Marc Eshel <eshel@almaden.ibm.com>
Date:   Thu Jan 18 17:52:58 2007 -0500

    locks: add lock cancel command
    
    Lock managers need to be able to cancel pending lock requests.  In the case
    where the exported filesystem manages its own locks, it's not sufficient just
    to call posix_unblock_lock(); we need to let the filesystem know what's
    happening too.
    
    We do this by adding a new fcntl lock command: FL_CANCELLK.  Some day this
    might also be made available to userspace applications that could benefit from
    an asynchronous locking api.
    
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c92d0bdff39f..64b8ae205309 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -857,6 +857,7 @@ extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
+extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);

commit 150b393456e5a23513cace286a019e87151e47f0
Author: Marc Eshel <eshel@almaden.ibm.com>
Date:   Thu Jan 18 16:15:35 2007 -0500

    locks: allow {vfs,posix}_lock_file to return conflicting lock
    
    The nfsv4 protocol's lock operation, in the case of a conflict, returns
    information about the conflicting lock.
    
    It's unclear how clients can use this, so for now we're not going so far as to
    add a filesystem method that can return a conflicting lock, but we may as well
    return something in the local case when it's easy to.
    
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1d5ccdd7c68d..c92d0bdff39f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -852,12 +852,11 @@ extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
 extern int posix_test_lock(struct file *, struct file_lock *);
-extern int posix_lock_file_conf(struct file *, struct file_lock *, struct file_lock *);
-extern int posix_lock_file(struct file *, struct file_lock *);
+extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
-extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *);
+extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);

commit 7723ec9777d9832849b76475b1a21a2872a40d20
Author: Marc Eshel <eshel@almaden.ibm.com>
Date:   Thu Jan 18 15:08:55 2007 -0500

    locks: factor out generic/filesystem switch from setlock code
    
    Factor out the code that switches between generic and filesystem-specific lock
    methods; eventually we want to call this from lock managers (lockd and nfsd)
    too; currently they only call the generic methods.
    
    This patch does that for all the setlk code.
    
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2a2a43988f50..1d5ccdd7c68d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -857,6 +857,7 @@ extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
 extern int vfs_test_lock(struct file *, struct file_lock *);
+extern int vfs_lock_file(struct file *, unsigned int, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);

commit 3ee17abd14c728d4e0ca7a991c58f2250cb091af
Author: J. Bruce Fields <bfields@citi.umich.edu>
Date:   Wed Feb 21 00:58:50 2007 -0500

    locks: factor out generic/filesystem switch from test_lock
    
    Factor out the code that switches between generic and filesystem-specific lock
    methods; eventually we want to call this from lock managers (lockd and nfsd)
    too; currently they only call the generic methods.
    
    This patch does that for test_lock.
    
    Note that this hasn't been necessary until recently, because the few
    filesystems that define ->lock() (nfs, cifs...) aren't exportable via NFS.
    However GFS (and, in the future, other cluster filesystems) need to implement
    their own locking to get cluster-coherent locking, and also want to be able to
    export locking to NFS (lockd and NFSv4).
    
    So we accomplish this by factoring out code such as this and exporting it for
    the use of lockd and nfsd.
    
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9e1ddffe3884..2a2a43988f50 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -856,6 +856,7 @@ extern int posix_lock_file_conf(struct file *, struct file_lock *, struct file_l
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
+extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);

commit 9d6a8c5c213e34c475e72b245a8eb709258e968c
Author: Marc Eshel <eshel@almaden.ibm.com>
Date:   Wed Feb 21 00:55:18 2007 -0500

    locks: give posix_test_lock same interface as ->lock
    
    posix_test_lock() and ->lock() do the same job but have gratuitously
    different interfaces.  Modify posix_test_lock() so the two agree,
    simplifying some code in the process.
    
    Signed-off-by: Marc Eshel <eshel@almaden.ibm.com>
    Signed-off-by: "J. Bruce Fields" <bfields@citi.umich.edu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 86ec3f4a7da6..9e1ddffe3884 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -851,7 +851,7 @@ extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
-extern int posix_test_lock(struct file *, struct file_lock *, struct file_lock *);
+extern int posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file_conf(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 095a9c9a64fb..7c0077f06e24 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1416,7 +1416,7 @@ extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 extern int vfs_statfs(struct dentry *, struct kstatfs *);
 
 /* /sys/fs */
-extern struct subsystem fs_subsys;
+extern struct kset fs_subsys;
 
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2

commit 5b04aa3a64f854244bc40a6f528176ed50b5c4f6
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Mar 1 11:01:55 2007 -0800

    [PATCH] Turn do_sync_file_range() into do_sync_mapping_range()
    
    do_sync_file_range() accepts a file * from which it takes an address_space to
    sync.  Abstract out the bulk of the function into do_sync_mapping_range()
    which takes the address_space directly.  This way callers who want to sync an
    address_space directly can take advantage of the functionality provided.
    
    do_sync_file_range() is preserved as a small wrapper around
    do_sync_mapping_range().
    
    Ocfs2 in particular would like to use this to initiate a sync of a specific
    inode range during truncate, where a file * may not be available.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 86ec3f4a7da6..095a9c9a64fb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -843,8 +843,13 @@ extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
 /* fs/sync.c */
-extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
-			unsigned int flags);
+extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
+			loff_t endbyte, unsigned int flags);
+static inline int do_sync_file_range(struct file *file, loff_t offset,
+			loff_t endbyte, unsigned int flags)
+{
+	return do_sync_mapping_range(file->f_mapping, offset, endbyte, flags);
+}
 
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);

commit ee9b6d61a2a43c5952eb43283f8db284a4e70b8a
Author: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
Date:   Mon Feb 12 00:55:41 2007 -0800

    [PATCH] Mark struct super_operations const
    
    This patch is inspired by Arjan's "Patch series to mark struct
    file_operations and struct inode_operations const".
    
    Compile tested with gcc & sparse.
    
    Signed-off-by: Josef 'Jeff' Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index bab891bb2270..86ec3f4a7da6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -907,7 +907,7 @@ struct super_block {
 	unsigned char		s_dirt;
 	unsigned long long	s_maxbytes;	/* Max file size */
 	struct file_system_type	*s_type;
-	struct super_operations	*s_op;
+	const struct super_operations	*s_op;
 	struct dquot_operations	*dq_op;
  	struct quotactl_ops	*s_qcop;
 	struct export_operations *s_export_op;
@@ -1383,7 +1383,7 @@ struct super_block *sget(struct file_system_type *type,
 			int (*set)(struct super_block *,void *),
 			void *data);
 extern int get_sb_pseudo(struct file_system_type *, char *,
-	struct super_operations *ops, unsigned long,
+	const struct super_operations *ops, unsigned long,
 	struct vfsmount *mnt);
 extern int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super(struct super_block *sb);

commit c5ef1c42c51b1b5b4a401a6517bdda30933ddbaf
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:40 2007 -0800

    [PATCH] mark struct inode_operations const 3
    
    Many struct inode_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 990adcbc0df2..bab891bb2270 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -551,7 +551,7 @@ struct inode {
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	struct mutex		i_mutex;
 	struct rw_semaphore	i_alloc_sem;
-	struct inode_operations	*i_op;
+	const struct inode_operations	*i_op;
 	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct super_block	*i_sb;
 	struct file_lock	*i_flock;
@@ -1828,7 +1828,7 @@ extern void page_put_link(struct dentry *, struct nameidata *, void *);
 extern int __page_symlink(struct inode *inode, const char *symname, int len,
 		gfp_t gfp_mask);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
-extern struct inode_operations page_symlink_inode_operations;
+extern const struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);
 extern void generic_fillattr(struct inode *, struct kstat *);
 extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
@@ -1873,7 +1873,7 @@ extern int simple_commit_write(struct file *file, struct page *page,
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
 extern const struct file_operations simple_dir_operations;
-extern struct inode_operations simple_dir_inode_operations;
+extern const struct inode_operations simple_dir_inode_operations;
 struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
 extern int simple_fill_super(struct super_block *, int, struct tree_descr *);

commit fb58b7316a99703afb8d076b0e5f3e1e387e4b30
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Feb 12 00:51:57 2007 -0800

    [PATCH] move remove_dquot_ref to dqout.c
    
    Remove_dquot_ref can move to dqout.c instead of beeing in inode.c under
    #ifdef CONFIG_QUOTA.  Also clean the resulting code up a tiny little bit by
    testing sb->dq_op earlier - it's constant over a filesystems lifetime.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Jan Kara <jack@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 20fd1619ccfb..990adcbc0df2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1688,7 +1688,6 @@ extern struct inode *new_inode(struct super_block *);
 extern int __remove_suid(struct dentry *, int);
 extern int should_remove_suid(struct dentry *);
 extern int remove_suid(struct dentry *);
-extern void remove_dquot_ref(struct super_block *, int, struct list_head *);
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 extern void remove_inode_hash(struct inode *);

commit fc0ecff698165ae8e178efa086e0dd1f385206b1
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Feb 10 01:45:39 2007 -0800

    [PATCH] remove invalidate_inode_pages()
    
    Convert all calls to invalidate_inode_pages() into open-coded calls to
    invalidate_mapping_pages().
    
    Leave the invalidate_inode_pages() wrapper in place for now, marked as
    deprecated.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a1180d05ed96..20fd1619ccfb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1574,7 +1574,7 @@ extern int invalidate_inodes(struct super_block *);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
 
-static inline unsigned long
+static inline unsigned long __deprecated
 invalidate_inode_pages(struct address_space *mapping)
 {
 	return invalidate_mapping_pages(mapping, 0, ~0UL);
@@ -1584,7 +1584,7 @@ static inline void invalidate_remote_inode(struct inode *inode)
 {
 	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode))
-		invalidate_inode_pages(inode->i_mapping);
+		invalidate_mapping_pages(inode->i_mapping, 0, -1);
 }
 extern int invalidate_inode_pages2(struct address_space *mapping);
 extern int invalidate_inode_pages2_range(struct address_space *mapping,

commit 54bc485522afdac33de5504da2ea8cdcc690674e
Author: Anton Altaparmakov <aia21@cam.ac.uk>
Date:   Sat Feb 10 01:45:38 2007 -0800

    [PATCH] Export invalidate_mapping_pages() to modules
    
    It makes no sense to me to export invalidate_inode_pages() and not
    invalidate_mapping_pages() and I actually need invalidate_mapping_pages()
    because of its range specification ability...
    
    akpm: also remove the export of invalidate_inode_pages() by making it an
    inlined wrapper.
    
    Signed-off-by: Anton Altaparmakov <aia21@cantab.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 822c545c7209..a1180d05ed96 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1573,7 +1573,13 @@ extern int invalidate_partition(struct gendisk *, int);
 extern int invalidate_inodes(struct super_block *);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
-unsigned long invalidate_inode_pages(struct address_space *mapping);
+
+static inline unsigned long
+invalidate_inode_pages(struct address_space *mapping)
+{
+	return invalidate_mapping_pages(mapping, 0, ~0UL);
+}
+
 static inline void invalidate_remote_inode(struct inode *inode)
 {
 	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||

commit 37756ced1f145aec18917812c3b8a96dbb47990d
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Sat Feb 10 01:44:49 2007 -0800

    [PATCH] avoid one conditional branch in touch_atime()
    
    I added IS_NOATIME(inode) macro definition in include/linux/fs.h, true if
    the inode superblock is marked readonly or noatime.
    
    This new macro is then used in touch_atime() instead of separatly testing
    MS_RDONLY and MS_NOATIME
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1410e5330c8d..822c545c7209 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -169,6 +169,7 @@ extern int dir_notify_enable;
 #define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
 					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
 #define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
+#define IS_NOATIME(inode)   __IS_FLG(inode, MS_RDONLY|MS_NOATIME)
 
 #define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
 #define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)

commit f73ca1b76c6880b934d3ef566c1592efc80bb759
Author: David Chinner <dgc@sgi.com>
Date:   Wed Jan 10 23:15:41 2007 -0800

    [PATCH] Revert bd_mount_mutex back to a semaphore
    
    Revert bd_mount_mutex back to a semaphore so that xfs_freeze -f /mnt/newtest;
    xfs_freeze -u /mnt/newtest works safely and doesn't produce lockdep warnings.
    
    (XFS unlocks the semaphore from a different task, by design.  The mutex
    code warns about this)
    
    Signed-off-by: Dave Chinner <dgc@sgi.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 14a337cc3464..1410e5330c8d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -459,7 +459,7 @@ struct block_device {
 	struct inode *		bd_inode;	/* will die */
 	int			bd_openers;
 	struct mutex		bd_mutex;	/* open/close mutex */
-	struct mutex		bd_mount_mutex;	/* mount mutex */
+	struct semaphore	bd_mount_sem;
 	struct list_head	bd_inodes;
 	void *			bd_holder;
 	int			bd_holders;

commit e3db7691e9f3dff3289f64e3d98583e28afe03db
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jan 10 23:15:39 2007 -0800

    [PATCH] NFS: Fix race in nfs_release_page()
    
        NFS: Fix race in nfs_release_page()
    
        invalidate_inode_pages2() may find the dirty bit has been set on a page
        owing to the fact that the page may still be mapped after it was locked.
        Only after the call to unmap_mapping_range() are we sure that the page
        can no longer be dirtied.
        In order to fix this, NFS has hooked the releasepage() method and tries
        to write the page out between the call to unmap_mapping_range() and the
        call to remove_mapping(). This, however leads to deadlocks in the page
        reclaim code, where the page may be locked without holding a reference
        to the inode or dentry.
    
        Fix is to add a new address_space_operation, launder_page(), which will
        attempt to write out a dirty page without releasing the page lock.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    
        Also, the bare SetPageDirty() can skew all sort of accounting leading to
        other nasties.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 186da813541e..14a337cc3464 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -426,6 +426,7 @@ struct address_space_operations {
 	/* migrate the contents of a page to the specified target */
 	int (*migratepage) (struct address_space *,
 			struct page *, struct page *);
+	int (*launder_page) (struct page *);
 };
 
 struct backing_dev_info;

commit 47ae32d6a54955a041cdc30b06d0bb16e75f68d5
Author: Valerie Henson <val_henson@linux.intel.com>
Date:   Wed Dec 13 00:34:34 2006 -0800

    [PATCH] relative atime
    
    Add "relatime" (relative atime) support.  Relative atime only updates the
    atime if the previous atime is older than the mtime or ctime.  Like
    noatime, but useful for applications like mutt that need to know when a
    file has been read since it was last modified.
    
    A corresponding patch against mount(8) is available at
    http://userweb.kernel.org/~akpm/mount-relative-atime.txt
    
    Signed-off-by: Valerie Henson <val_henson@linux.intel.com>
    Cc: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Karel Zak <kzak@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index adce6e1d70c2..186da813541e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -120,6 +120,7 @@ extern int dir_notify_enable;
 #define MS_PRIVATE	(1<<18)	/* change to private */
 #define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */
+#define MS_RELATIME	(1<<21)	/* Update atime relative to mtime/ctime. */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 

commit 0f7fc9e4d03987fe29f6dd4aa67e4c56eb7ecb05
Author: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
Date:   Fri Dec 8 02:36:35 2006 -0800

    [PATCH] VFS: change struct file to use struct path
    
    This patch changes struct file to use struct path instead of having
    independent pointers to struct dentry and struct vfsmount, and converts all
    users of f_{dentry,vfsmnt} in fs/ to use f_path.{dentry,mnt}.
    
    Additionally, it adds two #define's to make the transition easier for users of
    the f_dentry and f_vfsmnt.
    
    Signed-off-by: Josef "Jeff" Sipek <jsipek@cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 45f2cabb8c75..adce6e1d70c2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -269,6 +269,7 @@ extern int dir_notify_enable;
 #include <linux/types.h>
 #include <linux/kdev_t.h>
 #include <linux/dcache.h>
+#include <linux/namei.h>
 #include <linux/stat.h>
 #include <linux/cache.h>
 #include <linux/kobject.h>
@@ -711,8 +712,9 @@ struct file {
 		struct list_head	fu_list;
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
-	struct dentry		*f_dentry;
-	struct vfsmount         *f_vfsmnt;
+	struct path		f_path;
+#define f_dentry	f_path.dentry
+#define f_vfsmnt	f_path.mnt
 	const struct file_operations	*f_op;
 	atomic_t		f_count;
 	unsigned int 		f_flags;
@@ -1224,7 +1226,7 @@ extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {
 	if (!(file->f_flags & O_NOATIME))
-		touch_atime(file->f_vfsmnt, file->f_dentry);
+		touch_atime(file->f_path.mnt, file->f_path.dentry);
 }
 
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
@@ -1615,7 +1617,7 @@ static inline void put_write_access(struct inode * inode)
 static inline void allow_write_access(struct file *file)
 {
 	if (file)
-		atomic_inc(&file->f_dentry->d_inode->i_writecount);
+		atomic_inc(&file->f_path.dentry->d_inode->i_writecount);
 }
 extern int do_pipe(int *);
 extern struct file *create_read_pipe(struct file *f);

commit 2e7b651df113c8a463853e4169951c52c39f9d19
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Fri Dec 8 02:36:13 2006 -0800

    [PATCH] remove the old bd_mutex lockdep annotation
    
    Remove the old complex and crufty bd_mutex annotation.
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 70b99fbb560b..45f2cabb8c75 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -481,21 +481,6 @@ struct block_device {
 	unsigned long		bd_private;
 };
 
-/*
- * bdev->bd_mutex nesting subclasses for the lock validator:
- *
- * 0: normal
- * 1: 'whole'
- * 2: 'partition'
- */
-enum bdev_bd_mutex_lock_class
-{
-	BD_MUTEX_NORMAL,
-	BD_MUTEX_WHOLE,
-	BD_MUTEX_PARTITION
-};
-
-
 /*
  * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
  * radix trees
@@ -1499,7 +1484,6 @@ extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, unsigned);
-extern struct block_device *open_partition_by_devnum(dev_t, unsigned);
 extern const struct address_space_operations def_blk_aops;
 #else
 static inline void bd_forget(struct inode *inode) {}
@@ -1517,7 +1501,6 @@ extern int blkdev_driver_ioctl(struct inode *inode, struct file *file,
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, mode_t, unsigned);
 extern int blkdev_put(struct block_device *);
-extern int blkdev_put_partition(struct block_device *);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);
 #ifdef CONFIG_SYSFS

commit 12d40e43d251de4fa1f982567fc8b4ee5e858367
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Wed Dec 6 20:39:53 2006 -0800

    [PATCH] Save some bytes in struct inode
    
    [acme@newtoy net-2.6.20]$ pahole --cacheline 64 fs/inode.o inode
    /* /pub/scm/linux/kernel/git/acme/net-2.6.20/include/linux/dcache.h:86 */
    struct inode {
            struct hlist_node          i_hash;               /*     0     8 */
            struct list_head           i_list;               /*     8     8 */
            struct list_head           i_sb_list;            /*    16     8 */
            struct list_head           i_dentry;             /*    24     8 */
            long unsigned int          i_ino;                /*    32     4 */
            atomic_t                   i_count;              /*    36     4 */
            umode_t                    i_mode;               /*    40     2 */
    
            /* XXX 2 bytes hole, try to pack */
    
            unsigned int               i_nlink;              /*    44     4 */
            uid_t                      i_uid;                /*    48     4 */
            gid_t                      i_gid;                /*    52     4 */
            dev_t                      i_rdev;               /*    56     4 */
            loff_t                     i_size;               /*    60     8 */
            struct timespec            i_atime;              /*    68     8 */
            struct timespec            i_mtime;              /*    76     8 */
            struct timespec            i_ctime;              /*    84     8 */
            unsigned int               i_blkbits;            /*    92     4 */
            long unsigned int          i_version;            /*    96     4 */
            blkcnt_t                   i_blocks;             /*   100     4 */
            short unsigned int         i_bytes;              /*   104     2 */
    
            /* XXX 2 bytes hole, try to pack */
    
            spinlock_t                 i_lock;               /*   108    40 */
            struct mutex               i_mutex;              /*   148    76 */
            struct rw_semaphore        i_alloc_sem;          /*   224    64 */
            struct inode_operations *  i_op;                 /*   288     4 */
            const struct file_operations  * i_fop;           /*   292     4 */
            struct super_block *       i_sb;                 /*   296     4 */
            struct file_lock *         i_flock;              /*   300     4 */
            struct address_space *     i_mapping;            /*   304     4 */
            struct address_space       i_data;               /*   308   188 */
            struct list_head           i_devices;            /*   496     8 */
            union                      ;                     /*   504     4 */
            int                        i_cindex;             /*   508     4 */
            __u32                      i_generation;         /*   512     4 */
            /* ---------- cacheline 8 boundary ---------- */
            long unsigned int          i_dnotify_mask;       /*   516     4 */
            struct dnotify_struct *    i_dnotify;            /*   520     4 */
            struct list_head           inotify_watches;      /*   524     8 */
            struct mutex               inotify_mutex;        /*   532    76 */
            long unsigned int          i_state;              /*   608     4 */
            long unsigned int          dirtied_when;         /*   612     4 */
            unsigned int               i_flags;              /*   616     4 */
            atomic_t                   i_writecount;         /*   620     4 */
            void *                     i_security;           /*   624     4 */
            void *                     i_private;            /*   628     4 */
    }; /* size: 632, sum members: 628, holes: 2, sum holes: 4 */
    
    [acme@newtoy net-2.6.20]$
    
    So just moving i_mode to after i_bytes we save 4 bytes by nuking both holes:
    
    [acme@newtoy net-2.6.20]$ codiff -V /tmp/inode.o.before fs/inode.o
    /pub/scm/linux/kernel/git/acme/net-2.6.20/fs/inode.c:
      struct inode |   -4
        i_mode;
         from: umode_t               /*    40(0)     2(0) */
         to:   umode_t               /*   102(0)     2(0) */
     1 struct changed
    [acme@newtoy net-2.6.20]$
    
    I've prunned all the other offset changes, only this one is of interest here.
    
    So now we have:
    
    [acme@newtoy net-2.6.20]$ pahole --cacheline 64 ../OUTPUT/qemu/net-2.6.20/fs/inode.o inode
    /* /pub/scm/linux/kernel/git/acme/net-2.6.20/include/linux/dcache.h:86 */
    struct inode {
            struct hlist_node          i_hash;               /*     0     8 */
            struct list_head           i_list;               /*     8     8 */
            struct list_head           i_sb_list;            /*    16     8 */
            struct list_head           i_dentry;             /*    24     8 */
            long unsigned int          i_ino;                /*    32     4 */
            atomic_t                   i_count;              /*    36     4 */
            unsigned int               i_nlink;              /*    40     4 */
            uid_t                      i_uid;                /*    44     4 */
            gid_t                      i_gid;                /*    48     4 */
            dev_t                      i_rdev;               /*    52     4 */
            loff_t                     i_size;               /*    56     8 */
            /* ---------- cacheline 1 boundary ---------- */
            struct timespec            i_atime;              /*    64     8 */
            struct timespec            i_mtime;              /*    72     8 */
            struct timespec            i_ctime;              /*    80     8 */
            unsigned int               i_blkbits;            /*    88     4 */
            long unsigned int          i_version;            /*    92     4 */
            blkcnt_t                   i_blocks;             /*    96     4 */
            short unsigned int         i_bytes;              /*   100     2 */
            umode_t                    i_mode;               /*   102     2 */
            spinlock_t                 i_lock;               /*   104    40 */
            struct mutex               i_mutex;              /*   144    76 */
            struct rw_semaphore        i_alloc_sem;          /*   220    64 */
            struct inode_operations *  i_op;                 /*   284     4 */
            const struct file_operations  * i_fop;           /*   288     4 */
            struct super_block *       i_sb;                 /*   292     4 */
            struct file_lock *         i_flock;              /*   296     4 */
            struct address_space *     i_mapping;            /*   300     4 */
            struct address_space       i_data;               /*   304   188 */
            struct list_head           i_devices;            /*   492     8 */
            union                      ;                     /*   500     4 */
            int                        i_cindex;             /*   504     4 */
            __u32                      i_generation;         /*   508     4 */
            /* ---------- cacheline 8 boundary ---------- */
            long unsigned int          i_dnotify_mask;       /*   512     4 */
            struct dnotify_struct *    i_dnotify;            /*   516     4 */
            struct list_head           inotify_watches;      /*   520     8 */
            struct mutex               inotify_mutex;        /*   528    76 */
            long unsigned int          i_state;              /*   604     4 */
            long unsigned int          dirtied_when;         /*   608     4 */
            unsigned int               i_flags;              /*   612     4 */
            atomic_t                   i_writecount;         /*   616     4 */
            void *                     i_security;           /*   620     4 */
            void *                     i_private;            /*   624     4 */
    }; /* size: 628 */
    
    [acme@newtoy net-2.6.20]$
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3a1927e516d0..70b99fbb560b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -543,7 +543,6 @@ struct inode {
 	struct list_head	i_dentry;
 	unsigned long		i_ino;
 	atomic_t		i_count;
-	umode_t			i_mode;
 	unsigned int		i_nlink;
 	uid_t			i_uid;
 	gid_t			i_gid;
@@ -559,6 +558,7 @@ struct inode {
 	unsigned int		i_blkbits;
 	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;
+	umode_t			i_mode;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	struct mutex		i_mutex;
 	struct rw_semaphore	i_alloc_sem;

commit 83b7b44e1c1e9e493ccd4146558481ab5af0116a
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Wed Dec 6 20:38:53 2006 -0800

    [PATCH] fs: reorder some 'struct inode' fields to speedup i_size manipulations
    
    On 32bits SMP platforms, 64bits i_size is protected by a seqcount
    (i_size_seqcount).
    
    When i_size is read or written, i_size_seqcount is read/written as well, so
    it make sense to group these two fields together in the same cache line.
    
    This patch moves i_size_seqcount next to i_size, and also moves i_version
    to let offsetof(struct inode, i_size) being 0x40 instead of 0x3c (for
    32bits platforms).
    
    For 64 bits platforms, i_size_seqcount doesnt exist, and the move of a
    'long i_version' should not introduce a new hole because of padding.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d791bae9de9c..3a1927e516d0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -548,12 +548,15 @@ struct inode {
 	uid_t			i_uid;
 	gid_t			i_gid;
 	dev_t			i_rdev;
+	unsigned long		i_version;
 	loff_t			i_size;
+#ifdef __NEED_I_SIZE_ORDERED
+	seqcount_t		i_size_seqcount;
+#endif
 	struct timespec		i_atime;
 	struct timespec		i_mtime;
 	struct timespec		i_ctime;
 	unsigned int		i_blkbits;
-	unsigned long		i_version;
 	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
@@ -598,9 +601,6 @@ struct inode {
 	void			*i_security;
 #endif
 	void			*i_private; /* fs or device private pointer */
-#ifdef __NEED_I_SIZE_ORDERED
-	seqcount_t		i_size_seqcount;
-#endif
 };
 
 /*

commit 48ed214d10ae3c3999af938970f7b5b58df77be3
Author: Jan Engelhardt <jengelh@linux01.gwdg.de>
Date:   Wed Dec 6 20:35:37 2006 -0800

    [PATCH] constify inode accessors
    
    Change the signature of i_size_read(), IMINOR() and IMAJOR() because they,
    or the functions they call, will never modify the argument.
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 94b831b8157c..d791bae9de9c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -636,7 +636,7 @@ extern void inode_double_unlock(struct inode *inode1, struct inode *inode2);
  * cmpxchg8b without the need of the lock prefix). For SMP compiles
  * and 64bit archs it makes no difference if preempt is enabled or not.
  */
-static inline loff_t i_size_read(struct inode *inode)
+static inline loff_t i_size_read(const struct inode *inode)
 {
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)
 	loff_t i_size;
@@ -679,12 +679,12 @@ static inline void i_size_write(struct inode *inode, loff_t i_size)
 #endif
 }
 
-static inline unsigned iminor(struct inode *inode)
+static inline unsigned iminor(const struct inode *inode)
 {
 	return MINOR(inode->i_rdev);
 }
 
-static inline unsigned imajor(struct inode *inode)
+static inline unsigned imajor(const struct inode *inode)
 {
 	return MAJOR(inode->i_rdev);
 }

commit e94b1766097d53e6f3ccfb36c8baa562ffeda3fc
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:17 2006 -0800

    [PATCH] slab: remove SLAB_KERNEL
    
    SLAB_KERNEL is an alias of GFP_KERNEL.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a8039c8d8cbb..94b831b8157c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1483,7 +1483,7 @@ extern void __init vfs_caches_init(unsigned long);
 
 extern struct kmem_cache *names_cachep;
 
-#define __getname()	kmem_cache_alloc(names_cachep, SLAB_KERNEL)
+#define __getname()	kmem_cache_alloc(names_cachep, GFP_KERNEL)
 #define __putname(name) kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL
 #define putname(name)   __putname(name)

commit b86c089b83b8ae2bc814db865057768a9ba787b5
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:32:57 2006 -0800

    [PATCH] Move names_cachep to linux/fs.h
    
    The names_cachep is used for getname() and putname().  So lets put it into
    fs.h near those two definitions.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cac7b1ef9543..a8039c8d8cbb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1481,6 +1481,8 @@ extern char * getname(const char __user *);
 extern void __init vfs_caches_init_early(void);
 extern void __init vfs_caches_init(unsigned long);
 
+extern struct kmem_cache *names_cachep;
+
 #define __getname()	kmem_cache_alloc(names_cachep, SLAB_KERNEL)
 #define __putname(name) kmem_cache_free(names_cachep, (void *)(name))
 #ifndef CONFIG_AUDITSYSCALL

commit 914e26379decf1fd984b22e51fd2e4209b7a7f1b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 18 13:55:46 2006 -0400

    [PATCH] severing fs.h, radix-tree.h -> sched.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2fe6e3f900ba..cac7b1ef9543 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -276,7 +276,7 @@ extern int dir_notify_enable;
 #include <linux/radix-tree.h>
 #include <linux/prio_tree.h>
 #include <linux/init.h>
-#include <linux/sched.h>
+#include <linux/pid.h>
 #include <linux/mutex.h>
 
 #include <asm/atomic.h>
@@ -977,36 +977,13 @@ enum {
 #define vfs_check_frozen(sb, level) \
 	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
 
-static inline void get_fs_excl(void)
-{
-	atomic_inc(&current->fs_excl);
-}
-
-static inline void put_fs_excl(void)
-{
-	atomic_dec(&current->fs_excl);
-}
-
-static inline int has_fs_excl(void)
-{
-	return atomic_read(&current->fs_excl);
-}
+#define get_fs_excl() atomic_inc(&current->fs_excl)
+#define put_fs_excl() atomic_dec(&current->fs_excl)
+#define has_fs_excl() atomic_read(&current->fs_excl)
 
-
-/*
- * Superblock locking.
- */
-static inline void lock_super(struct super_block * sb)
-{
-	get_fs_excl();
-	mutex_lock(&sb->s_lock);
-}
-
-static inline void unlock_super(struct super_block * sb)
-{
-	put_fs_excl();
-	mutex_unlock(&sb->s_lock);
-}
+/* not quite ready to be deprecated, but... */
+extern void lock_super(struct super_block *);
+extern void unlock_super(struct super_block *);
 
 /*
  * VFS helper functions..

commit 01de85e057328ecbef36e108673b1e81059d54c1
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Oct 17 19:50:36 2006 +0200

    [PATCH] Add lockless helpers for remove_suid()
    
    Right now users have to grab i_mutex before calling remove_suid(), in the
    unlikely event that a call to ->setattr() may be needed. Split up the
    function in two parts:
    
    - One to check if we need to remove suid
    - One to actually remove it
    
    The first we can call lockless.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d695ba2346a3..2fe6e3f900ba 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1712,6 +1712,8 @@ extern void __iget(struct inode * inode);
 extern void clear_inode(struct inode *);
 extern void destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
+extern int __remove_suid(struct dentry *, int);
+extern int should_remove_suid(struct dentry *);
 extern int remove_suid(struct dentry *);
 extern void remove_dquot_ref(struct super_block *, int, struct list_head *);
 

commit 6da61809822c22634a3de2dcb3c60283b836a88a
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Tue Oct 17 18:43:07 2006 +0200

    [PATCH] Introduce generic_file_splice_write_nolock()
    
    This allows file systems to manage their own i_mutex locking while
    still re-using the generic_file_splice_write() logic.
    
    OCFS2 in particular wants this so that it can order cluster locks within
    i_mutex.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 853a02f23936..d695ba2346a3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1758,6 +1758,8 @@ extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
 		struct file *, loff_t *, size_t, unsigned int);
+extern ssize_t generic_file_splice_write_nolock(struct pipe_inode_info *,
+		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
 		struct file *out, loff_t *, size_t len, unsigned int flags);
 extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,

commit 62752ee198dca9209b7dee504763e51b11e9e0ca
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Tue Oct 17 10:31:38 2006 +0200

    [PATCH] Take i_mutex in splice_from_pipe()
    
    The splice_actor may be calling ->prepare_write() and ->commit_write(). We
    want i_mutex on the inode being written to before calling those so that we
    don't race i_size changes.
    
    The double locking behavior is done elsewhere in splice.c, and if we
    eventually want _nolock variants of generic_file_splice_write(), fs modules
    might have to replicate the nasty locking code. We introduce
    inode_double_lock() and inode_double_unlock() to consolidate the locking
    rules into one set of functions.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 661c7c572149..853a02f23936 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -623,6 +623,9 @@ enum inode_i_mutex_lock_class
 	I_MUTEX_QUOTA
 };
 
+extern void inode_double_lock(struct inode *inode1, struct inode *inode2);
+extern void inode_double_unlock(struct inode *inode1, struct inode *inode2);
+
 /*
  * NOTE: in a 32bit arch with a preemptable kernel and
  * an UP compile the i_size_read/write must be atomic

commit 7762f5a0b709b415fda132258ad37b9f2a1db994
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Oct 17 00:10:07 2006 -0700

    [PATCH] document i_size_write locking rules
    
    Unless someone reads the documentation for write_seqcount_{begin,end} it is
    not obvious, that i_size_write() needs locking.  Especially, that lack of such
    locking can result in a system hang.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 34406ed467c3..661c7c572149 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -656,7 +656,11 @@ static inline loff_t i_size_read(struct inode *inode)
 #endif
 }
 
-
+/*
+ * NOTE: unlike i_size_read(), i_size_write() does need locking around it
+ * (normally i_mutex), otherwise on 32bit/SMP an update of i_size_seqcount
+ * can be lost, resulting in subsequent i_size_read() calls spinning forever.
+ */
 static inline void i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG==32 && defined(CONFIG_SMP)

commit 4a61f17378c2cdd9bd8f34ef8bd7422861d0c1f1
Merge: d002ec481c24 7ecdb70a0ea4
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Oct 4 09:06:16 2006 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/steve/gfs2-2.6: (292 commits)
      [GFS2] Fix endian bug for de_type
      [GFS2] Initialize SELinux extended attributes at inode creation time.
      [GFS2] Move logging code into log.c (mostly)
      [GFS2] Mark nlink cleared so VFS sees it happen
      [GFS2] Two redundant casts removed
      [GFS2] Remove uneeded endian conversion
      [GFS2] Remove duplicate sb reading code
      [GFS2] Mark metadata reads for blktrace
      [GFS2] Remove iflags.h, use FS_
      [GFS2] Fix code style/indent in ops_file.c
      [GFS2] streamline-generic_file_-interfaces-and-filemap gfs fix
      [GFS2] Remove readv/writev methods and use aio_read/aio_write instead (gfs bits)
      [GFS2] inode-diet: Eliminate i_blksize from the inode structure
      [GFS2] inode_diet: Replace inode.u.generic_ip with inode.i_private (gfs)
      [GFS2] Fix typo in last patch
      [GFS2] Fix direct i/o logic in filemap.c
      [GFS2] Fix bug in Makefiles for lock modules
      [GFS2] Remove (extra) fs_subsys declaration
      [GFS2/DLM] Fix trailing whitespace
      [GFS2] Tidy up meta_io code
      ...

commit 7006f6eca874cd44d37ccb8cfeb8bed04e3bff22
Author: Alasdair G Kergon <agk@redhat.com>
Date:   Tue Oct 3 01:15:21 2006 -0700

    [PATCH] dm: export blkdev_driver_ioctl
    
    Export blkdev_driver_ioctl for device-mapper.
    
    If we get as far as the device-mapper ioctl handler, we know the ioctl is not
    a standard block layer BLK* one, so we don't need to check for them a second
    time and can call blkdev_driver_ioctl() directly.
    
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7b61e94bf8fc..f53bf4ff1955 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1523,6 +1523,9 @@ extern const struct file_operations def_fifo_fops;
 #ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
+extern int blkdev_driver_ioctl(struct inode *inode, struct file *file,
+			       struct gendisk *disk, unsigned cmd,
+			       unsigned long arg);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, mode_t, unsigned);
 extern int blkdev_put(struct block_device *);

commit afefdbb28a0a2af689926c30b94a14aea6036719
Author: David Howells <dhowells@redhat.com>
Date:   Tue Oct 3 01:13:46 2006 -0700

    [PATCH] VFS: Make filldir_t and struct kstat deal in 64-bit inode numbers
    
    These patches make the kernel pass 64-bit inode numbers internally when
    communicating to userspace, even on a 32-bit system.  They are required
    because some filesystems have intrinsic 64-bit inode numbers: NFS3+ and XFS
    for example.  The 64-bit inode numbers are then propagated to userspace
    automatically where the arch supports it.
    
    Problems have been seen with userspace (eg: ld.so) using the 64-bit inode
    number returned by stat64() or getdents64() to differentiate files, and
    failing because the 64-bit inode number space was compressed to 32-bits, and
    so overlaps occur.
    
    This patch:
    
    Make filldir_t take a 64-bit inode number and struct kstat carry a 64-bit
    inode number so that 64-bit inode numbers can be passed back to userspace.
    
    The stat functions then returns the full 64-bit inode number where
    available and where possible.  If it is not possible to represent the inode
    number supplied by the filesystem in the field provided by userspace, then
    error EOVERFLOW will be issued.
    
    Similarly, the getdents/readdir functions now pass the full 64-bit inode
    number to userspace where possible, returning EOVERFLOW instead when a
    directory entry is encountered that can't be properly represented.
    
    Note that this means that some inodes will not be stat'able on a 32-bit
    system with old libraries where they were before - but it does mean that
    there will be no ambiguity over what a 32-bit inode number refers to.
    
    Note similarly that directory scans may be cut short with an error on a
    32-bit system with old libraries where the scan would work before for the
    same reasons.
    
    It is judged unlikely that this situation will occur because modern glibc
    uses 64-bit capable versions of stat and getdents class functions
    exclusively, and that older systems are unlikely to encounter
    unrepresentable inode numbers anyway.
    
    [akpm: alpha build fix]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 91c0b2a32a90..7b61e94bf8fc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1049,7 +1049,7 @@ int generic_osync_inode(struct inode *, struct address_space *, int);
  * This allows the kernel to read directories into kernel space or
  * to have different dirent layouts depending on the binary type.
  */
-typedef int (*filldir_t)(void *, const char *, int, loff_t, ino_t, unsigned);
+typedef int (*filldir_t)(void *, const char *, int, loff_t, u64, unsigned);
 
 struct block_device_operations {
 	int (*open) (struct inode *, struct file *);

commit 128e5ebaf8abbda375bba82690b09630003c9213
Author: Steven Whitehouse <swhiteho@redhat.com>
Date:   Mon Oct 2 11:24:43 2006 -0400

    [GFS2] Remove iflags.h, use FS_
    
    Update GFS2 in the light of David Howells' patch:
    
    [PATCH] BLOCK: Move common FS-specific ioctls to linux/fs.h [try #6]
    36695673b012096228ebdc1b39a6a5850daa474e
    
    which calls the filesystem independant flags FS_..._FL. As a result
    we no longer need the flags.h file and the conversion routine is
    moved into the GFS2 source code.
    
    Userland programs which used to include iflags.h should now include
    fs.h and use the new flag names.
    
    Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2e29a2edaeec..bc0e645abb80 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -250,6 +250,8 @@ extern int dir_notify_enable;
 #define FS_NOTAIL_FL			0x00008000 /* file tail should not be merged */
 #define FS_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
 #define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
+#define FS_EXTENT_FL			0x00080000 /* Extents */
+#define FS_DIRECTIO_FL			0x00100000 /* Use direct i/o */
 #define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
 
 #define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */

commit 609d7fa9565c754428d2520cac2accc9052e1245
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Oct 2 02:17:15 2006 -0700

    [PATCH] file: modify struct fown_struct to use a struct pid
    
    File handles can be requested to send sigio and sigurg to processes.  By
    tracking the destination processes using struct pid instead of pid_t we make
    the interface safe from all potential pid wrap around problems.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2e29a2edaeec..91c0b2a32a90 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -684,7 +684,8 @@ extern struct block_device *I_BDEV(struct inode *inode);
 
 struct fown_struct {
 	rwlock_t lock;          /* protects pid, uid, euid fields */
-	int pid;		/* pid or -pgrp where SIGIO should be sent */
+	struct pid *pid;	/* pid or -pgrp where SIGIO should be sent */
+	enum pid_type pid_type;	/* Kind of process group SIGIO should be sent to */
 	uid_t uid, euid;	/* uid/euid of process setting the owner */
 	int signum;		/* posix.1b rt signal to be delivered on IO */
 };
@@ -880,8 +881,10 @@ extern void kill_fasync(struct fasync_struct **, int, int);
 /* only for net: no internal synchronization */
 extern void __kill_fasync(struct fasync_struct *, int, int);
 
+extern int __f_setown(struct file *filp, struct pid *, enum pid_type, int force);
 extern int f_setown(struct file *filp, unsigned long arg, int force);
 extern void f_delown(struct file *filp);
+extern pid_t f_getown(struct file *filp);
 extern int send_sigurg(struct fown_struct *fown);
 
 /*

commit d6cbd281d189977b38eac7eb2a4678de19b6b483
Author: Andi Kleen <ak@suse.de>
Date:   Sat Sep 30 23:29:26 2006 -0700

    [PATCH] Some cleanup in the pipe code
    
    Split the big and hard to read do_pipe function into smaller pieces.
    
    This creates new create_write_pipe/free_write_pipe/create_read_pipe
    functions.  These functions are made global so that they can be used by
    other parts of the kernel.
    
    The resulting code is more generic and easier to read and has cleaner error
    handling and less gotos.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3493d2828f7d..2e29a2edaeec 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1641,6 +1641,9 @@ static inline void allow_write_access(struct file *file)
 		atomic_inc(&file->f_dentry->d_inode->i_writecount);
 }
 extern int do_pipe(int *);
+extern struct file *create_read_pipe(struct file *f);
+extern struct file *create_write_pipe(void);
+extern void free_write_pipe(struct file *);
 
 extern int open_namei(int dfd, const char *, int, int, struct nameidata *);
 extern int may_open(struct nameidata *, int, int);

commit ce71ec36840368b877fb63bd14c8e67ab62d08b1
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Sat Sep 30 23:29:06 2006 -0700

    [PATCH] r/o bind mounts: monitor zeroing of i_nlink
    
    Some filesystems, instead of simply decrementing i_nlink, simply zero it
    during an unlink operation.  We need to catch these in addition to the
    decrement operations.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6a5267da565f..3493d2828f7d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1235,6 +1235,11 @@ static inline void drop_nlink(struct inode *inode)
 	inode->i_nlink--;
 }
 
+static inline void clear_nlink(struct inode *inode)
+{
+	inode->i_nlink = 0;
+}
+
 static inline void inode_dec_link_count(struct inode *inode)
 {
 	drop_nlink(inode);

commit d8c76e6f45c111c32a4b3e50a2adc9210737b0d8
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Sat Sep 30 23:29:04 2006 -0700

    [PATCH] r/o bind mount prepwork: inc_nlink() helper
    
    This is mostly included for parity with dec_nlink(), where we will have some
    more hooks.  This one should stay pretty darn straightforward for now.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 26d3c61116c0..6a5267da565f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1219,9 +1219,14 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
 	__mark_inode_dirty(inode, I_DIRTY_SYNC);
 }
 
-static inline void inode_inc_link_count(struct inode *inode)
+static inline void inc_nlink(struct inode *inode)
 {
 	inode->i_nlink++;
+}
+
+static inline void inode_inc_link_count(struct inode *inode)
+{
+	inc_nlink(inode);
 	mark_inode_dirty(inode);
 }
 

commit 9a53c3a783c2fa9b969628e65695c11c3e51e673
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Sat Sep 30 23:29:03 2006 -0700

    [PATCH] r/o bind mounts: unlink: monitor i_nlink
    
    When a filesystem decrements i_nlink to zero, it means that a write must be
    performed in order to drop the inode from the filesystem.
    
    We're shortly going to have keep filesystems from being remounted r/o between
    the time that this i_nlink decrement and that write occurs.
    
    So, add a little helper function to do the decrements.  We'll tie into it in a
    bit to note when i_nlink hits zero.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4bb70871873f..26d3c61116c0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1225,9 +1225,14 @@ static inline void inode_inc_link_count(struct inode *inode)
 	mark_inode_dirty(inode);
 }
 
-static inline void inode_dec_link_count(struct inode *inode)
+static inline void drop_nlink(struct inode *inode)
 {
 	inode->i_nlink--;
+}
+
+static inline void inode_dec_link_count(struct inode *inode)
+{
+	drop_nlink(inode);
 	mark_inode_dirty(inode);
 }
 

commit eed4e51fb60c3863c134a5e9f6006b29805ead97
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sat Sep 30 23:28:49 2006 -0700

    [PATCH] Add vector AIO support
    
    This work is initially done by Zach Brown to add support for vectored aio.
    These are the core changes for AIO to support
    IOCB_CMD_PREADV/IOCB_CMD_PWRITEV.
    
    [akpm@osdl.org: huge build fix]
    Signed-off-by: Zach Brown <zach.brown@oracle.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Acked-by: Benjamin LaHaise <bcrl@kvack.org>
    Acked-by: James Morris <jmorris@namei.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 011129f8803e..4bb70871873f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1150,6 +1150,11 @@ struct inode_operations {
 
 struct seq_file;
 
+ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
+				unsigned long nr_segs, unsigned long fast_segs,
+				struct iovec *fast_pointer,
+				struct iovec **ret_pointer);
+
 extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
 extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t vfs_readv(struct file *, const struct iovec __user *,

commit 543ade1fc901db4c3dbe9fb27241fb977f1f3eea
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sat Sep 30 23:28:48 2006 -0700

    [PATCH] Streamline generic_file_* interfaces and filemap cleanups
    
    This patch cleans up generic_file_*_read/write() interfaces.  Christoph
    Hellwig gave me the idea for this clean ups.
    
    In a nutshell, all filesystems should set .aio_read/.aio_write methods and use
    do_sync_read/ do_sync_write() as their .read/.write methods.  This allows us
    to cleanup all variants of generic_file_* routines.
    
    Final available interfaces:
    
    generic_file_aio_read() - read handler
    generic_file_aio_write() - write handler
    generic_file_aio_write_nolock() - no lock write handler
    
    __generic_file_aio_write_nolock() - internal worker routine
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index afb6e6f89a01..011129f8803e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1699,11 +1699,8 @@ extern int generic_file_mmap(struct file *, struct vm_area_struct *);
 extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
 extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
 extern int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
-extern ssize_t generic_file_read(struct file *, char __user *, size_t, loff_t *);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
-extern ssize_t generic_file_write(struct file *, const char __user *, size_t, loff_t *);
 extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
-extern ssize_t __generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t *);
 extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_aio_write_nolock(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t);
@@ -1713,8 +1710,6 @@ extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
 		unsigned long, loff_t, loff_t *, size_t, ssize_t);
 extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
 extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
-ssize_t generic_file_write_nolock(struct file *file, const struct iovec *iov,
-				unsigned long nr_segs, loff_t *ppos);
 extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor_t, void *);
 extern void do_generic_mapping_read(struct address_space *mapping,
 				    struct file_ra_state *, struct file *,

commit ee0b3e671baff681d69fbf0db33b47603c0a8280
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sat Sep 30 23:28:47 2006 -0700

    [PATCH] Remove readv/writev methods and use aio_read/aio_write instead
    
    This patch removes readv() and writev() methods and replaces them with
    aio_read()/aio_write() methods.
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 257bae16f545..afb6e6f89a01 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1113,8 +1113,6 @@ struct file_operations {
 	int (*aio_fsync) (struct kiocb *, int datasync);
 	int (*fasync) (int, struct file *, int);
 	int (*lock) (struct file *, int, struct file_lock *);
-	ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
-	ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
 	ssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);
 	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
 	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
@@ -1734,10 +1732,6 @@ extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
 
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
-extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 
-	unsigned long nr_segs, loff_t *ppos);
-ssize_t generic_file_writev(struct file *filp, const struct iovec *iov, 
-			unsigned long nr_segs, loff_t *ppos);
 extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
 extern loff_t remote_llseek(struct file *file, loff_t offset, int origin);

commit 027445c37282bc1ed26add45e573ad2d3e4860a5
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sat Sep 30 23:28:46 2006 -0700

    [PATCH] Vectorize aio_read/aio_write fileop methods
    
    This patch vectorizes aio_read() and aio_write() methods to prepare for
    collapsing all aio & vectored operations into one interface - which is
    aio_read()/aio_write().
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Michael Holzheu <HOLZHEU@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5baf3a153403..257bae16f545 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1097,9 +1097,9 @@ struct file_operations {
 	struct module *owner;
 	loff_t (*llseek) (struct file *, loff_t, int);
 	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
-	ssize_t (*aio_read) (struct kiocb *, char __user *, size_t, loff_t);
 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
-	ssize_t (*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);
+	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
+	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
 	int (*readdir) (struct file *, void *, filldir_t);
 	unsigned int (*poll) (struct file *, struct poll_table_struct *);
 	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
@@ -1704,11 +1704,11 @@ extern int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned
 extern ssize_t generic_file_read(struct file *, char __user *, size_t, loff_t *);
 int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
 extern ssize_t generic_file_write(struct file *, const char __user *, size_t, loff_t *);
-extern ssize_t generic_file_aio_read(struct kiocb *, char __user *, size_t, loff_t);
+extern ssize_t generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t __generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t *);
-extern ssize_t generic_file_aio_write(struct kiocb *, const char __user *, size_t, loff_t);
+extern ssize_t generic_file_aio_write(struct kiocb *, const struct iovec *, unsigned long, loff_t);
 extern ssize_t generic_file_aio_write_nolock(struct kiocb *, const struct iovec *,
-		unsigned long, loff_t *);
+		unsigned long, loff_t);
 extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
 		unsigned long *, loff_t, loff_t *, size_t, size_t);
 extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,

commit 9361401eb7619c033e2394e4f9f6d410d6719ac7
Author: David Howells <dhowells@redhat.com>
Date:   Sat Sep 30 20:45:40 2006 +0200

    [PATCH] BLOCK: Make it possible to disable the block layer [try #6]
    
    Make it possible to disable the block layer.  Not all embedded devices require
    it, some can make do with just JFFS2, NFS, ramfs, etc - none of which require
    the block layer to be present.
    
    This patch does the following:
    
     (*) Introduces CONFIG_BLOCK to disable the block layer, buffering and blockdev
         support.
    
     (*) Adds dependencies on CONFIG_BLOCK to any configuration item that controls
         an item that uses the block layer.  This includes:
    
         (*) Block I/O tracing.
    
         (*) Disk partition code.
    
         (*) All filesystems that are block based, eg: Ext3, ReiserFS, ISOFS.
    
         (*) The SCSI layer.  As far as I can tell, even SCSI chardevs use the
             block layer to do scheduling.  Some drivers that use SCSI facilities -
             such as USB storage - end up disabled indirectly from this.
    
         (*) Various block-based device drivers, such as IDE and the old CDROM
             drivers.
    
         (*) MTD blockdev handling and FTL.
    
         (*) JFFS - which uses set_bdev_super(), something it could avoid doing by
             taking a leaf out of JFFS2's book.
    
     (*) Makes most of the contents of linux/blkdev.h, linux/buffer_head.h and
         linux/elevator.h contingent on CONFIG_BLOCK being set.  sector_div() is,
         however, still used in places, and so is still available.
    
     (*) Also made contingent are the contents of linux/mpage.h, linux/genhd.h and
         parts of linux/fs.h.
    
     (*) Makes a number of files in fs/ contingent on CONFIG_BLOCK.
    
     (*) Makes mm/bounce.c (bounce buffering) contingent on CONFIG_BLOCK.
    
     (*) set_page_dirty() doesn't call __set_page_dirty_buffers() if CONFIG_BLOCK
         is not enabled.
    
     (*) fs/no-block.c is created to hold out-of-line stubs and things that are
         required when CONFIG_BLOCK is not set:
    
         (*) Default blockdev file operations (to give error ENODEV on opening).
    
     (*) Makes some /proc changes:
    
         (*) /proc/devices does not list any blockdevs.
    
         (*) /proc/diskstats and /proc/partitions are contingent on CONFIG_BLOCK.
    
     (*) Makes some compat ioctl handling contingent on CONFIG_BLOCK.
    
     (*) If CONFIG_BLOCK is not defined, makes sys_quotactl() return -ENODEV if
         given command other than Q_SYNC or if a special device is specified.
    
     (*) In init/do_mounts.c, no reference is made to the blockdev routines if
         CONFIG_BLOCK is not defined.  This does not prohibit NFS roots or JFFS2.
    
     (*) The bdflush, ioprio_set and ioprio_get syscalls can now be absent (return
         error ENOSYS by way of cond_syscall if so).
    
     (*) The seclvl_bd_claim() and seclvl_bd_release() security calls do nothing if
         CONFIG_BLOCK is not set, since they can't then happen.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b73a47582dbe..5baf3a153403 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1482,6 +1482,7 @@ extern void __init vfs_caches_init(unsigned long);
 extern void putname(const char *name);
 #endif
 
+#ifdef CONFIG_BLOCK
 extern int register_blkdev(unsigned int, const char *);
 extern int unregister_blkdev(unsigned int, const char *);
 extern struct block_device *bdget(dev_t);
@@ -1490,11 +1491,15 @@ extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, unsigned);
 extern struct block_device *open_partition_by_devnum(dev_t, unsigned);
-extern const struct file_operations def_blk_fops;
 extern const struct address_space_operations def_blk_aops;
+#else
+static inline void bd_forget(struct inode *inode) {}
+#endif
+extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
 extern const struct file_operations bad_sock_fops;
 extern const struct file_operations def_fifo_fops;
+#ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
@@ -1510,6 +1515,7 @@ extern void bd_release_from_disk(struct block_device *, struct gendisk *);
 #define bd_claim_by_disk(bdev, holder, disk)	bd_claim(bdev, holder)
 #define bd_release_from_disk(bdev, disk)	bd_release(bdev)
 #endif
+#endif
 
 /* fs/char_dev.c */
 #define CHRDEV_MAJOR_HASH_SIZE	255
@@ -1523,14 +1529,19 @@ extern int chrdev_open(struct inode *, struct file *);
 extern void chrdev_show(struct seq_file *,off_t);
 
 /* fs/block_dev.c */
-#define BLKDEV_MAJOR_HASH_SIZE	255
 #define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
+
+#ifdef CONFIG_BLOCK
+#define BLKDEV_MAJOR_HASH_SIZE	255
 extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern struct block_device *open_bdev_excl(const char *, int, void *);
 extern void close_bdev_excl(struct block_device *);
 extern void blkdev_show(struct seq_file *,off_t);
+#else
+#define BLKDEV_MAJOR_HASH_SIZE	0
+#endif
 
 extern void init_special_inode(struct inode *, umode_t, dev_t);
 
@@ -1544,6 +1555,7 @@ extern const struct file_operations rdwr_fifo_fops;
 
 extern int fs_may_remount_ro(struct super_block *);
 
+#ifdef CONFIG_BLOCK
 /*
  * return READ, READA, or WRITE
  */
@@ -1555,9 +1567,10 @@ extern int fs_may_remount_ro(struct super_block *);
 #define bio_data_dir(bio)	((bio)->bi_rw & 1)
 
 extern int check_disk_change(struct block_device *);
-extern int invalidate_inodes(struct super_block *);
 extern int __invalidate_device(struct block_device *);
 extern int invalidate_partition(struct gendisk *, int);
+#endif
+extern int invalidate_inodes(struct super_block *);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);
 unsigned long invalidate_inode_pages(struct address_space *mapping);
@@ -1590,7 +1603,9 @@ extern void emergency_sync(void);
 extern void emergency_remount(void);
 extern int do_remount_sb(struct super_block *sb, int flags,
 			 void *data, int force);
+#ifdef CONFIG_BLOCK
 extern sector_t bmap(struct inode *, sector_t);
+#endif
 extern int notify_change(struct dentry *, struct iattr *);
 extern int permission(struct inode *, int, struct nameidata *);
 extern int generic_permission(struct inode *, int,
@@ -1673,9 +1688,11 @@ static inline void insert_inode_hash(struct inode *inode) {
 extern struct file * get_empty_filp(void);
 extern void file_move(struct file *f, struct list_head *list);
 extern void file_kill(struct file *f);
+#ifdef CONFIG_BLOCK
 struct bio;
 extern void submit_bio(int, struct bio *);
 extern int bdev_read_only(struct block_device *);
+#endif
 extern int set_blocksize(struct block_device *, int);
 extern int sb_set_blocksize(struct super_block *, int);
 extern int sb_min_blocksize(struct super_block *, int);
@@ -1756,6 +1773,7 @@ static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
 				actor);
 }
 
+#ifdef CONFIG_BLOCK
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
 	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
@@ -1793,6 +1811,7 @@ static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
 				nr_segs, get_block, end_io, DIO_OWN_LOCKING);
 }
+#endif
 
 extern const struct file_operations generic_ro_fops;
 

commit 36695673b012096228ebdc1b39a6a5850daa474e
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 29 19:06:16 2006 +0100

    [PATCH] BLOCK: Move common FS-specific ioctls to linux/fs.h [try #6]
    
    Move common FS-specific ioctls from linux/ext2_fs.h to linux/fs.h as FS_IOC_*
    and FS_IOC32_* and have the users of them use those as a base.
    
    Also move the GETFLAGS/SETFLAGS flags to linux/fs.h as FS_*_FL macros, and then
    have the other users use them as a base.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1728142ec4b6..b73a47582dbe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -217,6 +217,45 @@ extern int dir_notify_enable;
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */
 #define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
 
+#define	FS_IOC_GETFLAGS			_IOR('f', 1, long)
+#define	FS_IOC_SETFLAGS			_IOW('f', 2, long)
+#define	FS_IOC_GETVERSION		_IOR('v', 1, long)
+#define	FS_IOC_SETVERSION		_IOW('v', 2, long)
+#define FS_IOC32_GETFLAGS		_IOR('f', 1, int)
+#define FS_IOC32_SETFLAGS		_IOW('f', 2, int)
+#define FS_IOC32_GETVERSION		_IOR('v', 1, int)
+#define FS_IOC32_SETVERSION		_IOW('v', 2, int)
+
+/*
+ * Inode flags (FS_IOC_GETFLAGS / FS_IOC_SETFLAGS)
+ */
+#define	FS_SECRM_FL			0x00000001 /* Secure deletion */
+#define	FS_UNRM_FL			0x00000002 /* Undelete */
+#define	FS_COMPR_FL			0x00000004 /* Compress file */
+#define FS_SYNC_FL			0x00000008 /* Synchronous updates */
+#define FS_IMMUTABLE_FL			0x00000010 /* Immutable file */
+#define FS_APPEND_FL			0x00000020 /* writes to file may only append */
+#define FS_NODUMP_FL			0x00000040 /* do not dump file */
+#define FS_NOATIME_FL			0x00000080 /* do not update atime */
+/* Reserved for compression usage... */
+#define FS_DIRTY_FL			0x00000100
+#define FS_COMPRBLK_FL			0x00000200 /* One or more compressed clusters */
+#define FS_NOCOMP_FL			0x00000400 /* Don't compress */
+#define FS_ECOMPR_FL			0x00000800 /* Compression error */
+/* End compression flags --- maybe not all used */
+#define FS_BTREE_FL			0x00001000 /* btree format dir */
+#define FS_INDEX_FL			0x00001000 /* hash-indexed directory */
+#define FS_IMAGIC_FL			0x00002000 /* AFS directory */
+#define FS_JOURNAL_DATA_FL		0x00004000 /* Reserved for ext3 */
+#define FS_NOTAIL_FL			0x00008000 /* file tail should not be merged */
+#define FS_DIRSYNC_FL			0x00010000 /* dirsync behaviour (directories only) */
+#define FS_TOPDIR_FL			0x00020000 /* Top of directory hierarchies*/
+#define FS_RESERVED_FL			0x80000000 /* reserved for ext2 lib */
+
+#define FS_FL_USER_VISIBLE		0x0003DFFF /* User visible flags */
+#define FS_FL_USER_MODIFIABLE		0x000380FF /* User modifiable flags */
+
+
 #define SYNC_FILE_RANGE_WAIT_BEFORE	1
 #define SYNC_FILE_RANGE_WRITE		2
 #define SYNC_FILE_RANGE_WAIT_AFTER	4

commit cf9a2ae8d49948f861b56e5333530e491a9da190
Author: David Howells <dhowells@redhat.com>
Date:   Tue Aug 29 19:05:54 2006 +0100

    [PATCH] BLOCK: Move functions out of buffer code [try #6]
    
    Move some functions out of the buffering code that aren't strictly buffering
    specific.  This is a precursor to being able to disable the block layer.
    
     (*) Moved some stuff out of fs/buffer.c:
    
         (*) The file sync and general sync stuff moved to fs/sync.c.
    
         (*) The superblock sync stuff moved to fs/super.c.
    
         (*) do_invalidatepage() moved to mm/truncate.c.
    
         (*) try_to_release_page() moved to mm/filemap.c.
    
     (*) Moved some related declarations between header files:
    
         (*) declarations for do_invalidatepage() and try_to_release_page() moved
             to linux/mm.h.
    
         (*) __set_page_dirty_buffers() moved to linux/buffer_head.h.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d68c37af4dfb..1728142ec4b6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1546,6 +1546,7 @@ extern int __filemap_fdatawrite_range(struct address_space *mapping,
 extern long do_fsync(struct file *file, int datasync);
 extern void sync_supers(void);
 extern void sync_filesystems(int wait);
+extern void __fsync_super(struct super_block *sb);
 extern void emergency_sync(void);
 extern void emergency_remount(void);
 extern int do_remount_sb(struct super_block *sb, int flags,

commit 5404bc7a87b9949cf61e0174b21f80e73239ab25
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Aug 10 09:01:02 2006 +0200

    [PATCH] Allow file systems to differentiate between data and meta reads
    
    We can use this information for making more intelligent priority
    decisions, and it will also be useful for blktrace.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9306f63bf77e..d68c37af4dfb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -80,6 +80,7 @@ extern int dir_notify_enable;
 #define READA 2		/* read-ahead  - don't block if no resources */
 #define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
 #define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
+#define READ_META	(READ | (1 << BIO_RW_META))
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
 #define WRITE_BARRIER	((1 << BIO_RW) | (1 << BIO_RW_BARRIER))
 

commit a3b05e8f58c95dfccbf2c824d0c68e5990571f24
Author: Jens Axboe <axboe@suse.de>
Date:   Fri Jul 28 09:36:46 2006 +0200

    [PATCH] Kill various deprecated/unused block layer defines/functions
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6eafbe309483..9306f63bf77e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -79,7 +79,6 @@ extern int dir_notify_enable;
 #define WRITE 1
 #define READA 2		/* read-ahead  - don't block if no resources */
 #define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
-#define SPECIAL 4	/* For non-blockdevice requests in request queue */
 #define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
 #define WRITE_BARRIER	((1 << BIO_RW) | (1 << BIO_RW_BARRIER))

commit 50462062a02226a698a211d5bd535376c89b8603
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Sep 29 02:00:01 2006 -0700

    [PATCH] fs.h: ifdef security fields
    
    [assuming BSD security levels are deleted]
    The only user of i_security, f_security, s_security fields is SELinux,
    however, quite a few security modules are trying to get into kernel.
    So, wrap them under CONFIG_SECURITY. Adding config option for each
    security field is likely an overkill.
    
    Following Stephen Smalley's suggestion, i_security initialization is
    moved to security_inode_alloc() to not clutter core code with ifdefs
    and make alloc_inode() codepath tiny little bit smaller and faster.
    
    The user of (highly greppable) struct fown_struct::security field is
    still to be found. I've checked every "fown_struct" and every "f_owner"
    occurence. Additionally it's removal doesn't break i386 allmodconfig
    build.
    
    struct inode, struct file, struct super_block, struct fown_struct
    become smaller.
    
    P.S. Combined with two reiserfs inode shrinking patches sent to
    linux-fsdevel, I can finally suck 12 reiserfs inodes into one page.
    
                    /proc/slabinfo
    
            -ext2_inode_cache       388     10
            +ext2_inode_cache       384     10
            -inode_cache            280     14
            +inode_cache            276     14
            -proc_inode_cache       296     13
            +proc_inode_cache       292     13
            -reiser_inode_cache     336     11
            +reiser_inode_cache     332     12 <=
            -shmem_inode_cache      372     10
            +shmem_inode_cache      368     10
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4caec6cebc42..6eafbe309483 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -553,7 +553,9 @@ struct inode {
 	unsigned int		i_flags;
 
 	atomic_t		i_writecount;
+#ifdef CONFIG_SECURITY
 	void			*i_security;
+#endif
 	void			*i_private; /* fs or device private pointer */
 #ifdef __NEED_I_SIZE_ORDERED
 	seqcount_t		i_size_seqcount;
@@ -645,7 +647,6 @@ struct fown_struct {
 	rwlock_t lock;          /* protects pid, uid, euid fields */
 	int pid;		/* pid or -pgrp where SIGIO should be sent */
 	uid_t uid, euid;	/* uid/euid of process setting the owner */
-	void *security;
 	int signum;		/* posix.1b rt signal to be delivered on IO */
 };
 
@@ -688,8 +689,9 @@ struct file {
 	struct file_ra_state	f_ra;
 
 	unsigned long		f_version;
+#ifdef CONFIG_SECURITY
 	void			*f_security;
-
+#endif
 	/* needed for tty driver, and maybe others */
 	void			*private_data;
 
@@ -877,7 +879,9 @@ struct super_block {
 	int			s_syncing;
 	int			s_need_sync_fs;
 	atomic_t		s_active;
+#ifdef CONFIG_SECURITY
 	void                    *s_security;
+#endif
 	struct xattr_handler	**s_xattr;
 
 	struct list_head	s_inodes;	/* all inodes */

commit 0e51a720b9d9ea5ebf0fda39108919c6626bffa3
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Sep 29 01:59:56 2006 -0700

    [PATCH] ifdef ->quota_read, ->quota_write
    
    All suppliers of ->quota_read, ->quota_write (I've found ext2, ext3, UFS,
    reiserfs) already have them properly ifdeffed.  All callers of
    ->quota_read, ->quota_write are under CONFIG_QUOTA umbrella, so...
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8f74dfbb2edd..4caec6cebc42 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1143,9 +1143,10 @@ struct super_operations {
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 	int (*show_stats)(struct seq_file *, struct vfsmount *);
-
+#ifdef CONFIG_QUOTA
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
+#endif
 };
 
 /* Inode state bits.  Protected by inode_lock. */

commit ba52de123d454b57369f291348266d86f4b35070
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:49 2006 -0700

    [PATCH] inode-diet: Eliminate i_blksize from the inode structure
    
    This eliminates the i_blksize field from struct inode.  Filesystems that want
    to provide a per-inode st_blksize can do so by providing their own getattr
    routine instead of using the generic_fillattr() function.
    
    Note that some filesystems were providing pretty much random (and incorrect)
    values for i_blksize.
    
    [bunk@stusta.de: cleanup]
    [akpm@osdl.org: generic_fillattr() fix]
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 192e69bb55b5..8f74dfbb2edd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -512,7 +512,6 @@ struct inode {
 	struct timespec		i_mtime;
 	struct timespec		i_ctime;
 	unsigned int		i_blkbits;
-	unsigned long		i_blksize;
 	unsigned long		i_version;
 	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;

commit 577c4eb09d1034d0739e3135fd2cff50588024be
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:49 2006 -0700

    [PATCH] inode-diet: Move i_cdev into a union
    
    Move the i_cdev pointer in struct inode into a union.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98ff684a5b1c..192e69bb55b5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -532,8 +532,8 @@ struct inode {
 	union {
 		struct pipe_inode_info	*i_pipe;
 		struct block_device	*i_bdev;
+		struct cdev		*i_cdev;
 	};
-	struct cdev		*i_cdev;
 	int			i_cindex;
 
 	__u32			i_generation;

commit eaf796e7ef6014f208c409b2b14fddcfaafe7e3a
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:48 2006 -0700

    [PATCH] inode-diet: Move i_bdev into a union
    
    Move the i_bdev pointer in struct inode into a union.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ca695fc8d69c..98ff684a5b1c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -531,8 +531,8 @@ struct inode {
 	struct list_head	i_devices;
 	union {
 		struct pipe_inode_info	*i_pipe;
+		struct block_device	*i_bdev;
 	};
-	struct block_device	*i_bdev;
 	struct cdev		*i_cdev;
 	int			i_cindex;
 

commit 4c1541680f8d189d21dd07b053bc12996574646e
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:47 2006 -0700

    [PATCH] inode-diet: Move i_pipe into a union
    
    Move the i_pipe pointer into a union that will be shared with i_bdev and
    i_cdev.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4f77ec9c3353..ca695fc8d69c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -528,9 +528,10 @@ struct inode {
 #ifdef CONFIG_QUOTA
 	struct dquot		*i_dquot[MAXQUOTAS];
 #endif
-	/* These three should probably be a union */
 	struct list_head	i_devices;
-	struct pipe_inode_info	*i_pipe;
+	union {
+		struct pipe_inode_info	*i_pipe;
+	};
 	struct block_device	*i_bdev;
 	struct cdev		*i_cdev;
 	int			i_cindex;

commit 8e18e2941c53416aa219708e7dcad21fb4bd6794
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Wed Sep 27 01:50:46 2006 -0700

    [PATCH] inode_diet: Replace inode.u.generic_ip with inode.i_private
    
    The following patches reduce the size of the VFS inode structure by 28 bytes
    on a UP x86.  (It would be more on an x86_64 system).  This is a 10% reduction
    in the inode size on a UP kernel that is configured in a production mode
    (i.e., with no spinlock or other debugging functions enabled; if you want to
    save memory taken up by in-core inodes, the first thing you should do is
    disable the debugging options; they are responsible for a huge amount of bloat
    in the VFS inode structure).
    
    This patch:
    
    The filesystem or device-specific pointer in the inode is inside a union,
    which is pretty pointless given that all 30+ users of this field have been
    using the void pointer.  Get rid of the union and rename it to i_private, with
    a comment to explain who is allowed to use the void pointer.  This is just a
    cleanup, but it allows us to reuse the union 'u' for something something where
    the union will actually be used.
    
    [judith@osdl.org: powerpc build fix]
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Judith Lebzelter <judith@osdl.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1d3e601ece73..4f77ec9c3353 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -554,9 +554,7 @@ struct inode {
 
 	atomic_t		i_writecount;
 	void			*i_security;
-	union {
-		void		*generic_ip;
-	} u;
+	void			*i_private; /* fs or device private pointer */
 #ifdef __NEED_I_SIZE_ORDERED
 	seqcount_t		i_size_seqcount;
 #endif

commit 349457ccf2592c14bdf13b6706170ae2e94931b1
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Fri Sep 8 14:22:21 2006 -0700

    [PATCH] Allow file systems to manually d_move() inside of ->rename()
    
    Some file systems want to manually d_move() the dentries involved in a
    rename.  We can do this by making use of the FS_ODD_RENAME flag if we just
    have nfs_rename() unconditionally do the d_move().  While there, we rename
    the flag to be more descriptive.
    
    OCFS2 uses this to protect that part of the rename operation with a cluster
    lock.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 555bc195c420..1d3e601ece73 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -92,9 +92,10 @@ extern int dir_notify_enable;
 #define FS_REQUIRES_DEV 1 
 #define FS_BINARY_MOUNTDATA 2
 #define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
-#define FS_ODD_RENAME	32768	/* Temporary stuff; will go away as soon
-				  * as nfs_rename() will be cleaned up
-				  */
+#define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move()
+					 * during rename() internally.
+					 */
+
 /*
  * These are the fs-independent mount-flags: up to 32 flags are supported
  */

commit 4df46240a1312161e3c794f6ace50ef7eb5ff3d7
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Aug 27 01:23:56 2006 -0700

    [PATCH] lockdep: annotate reiserfs
    
    reiserfs seems to have another locking level layer for the i_mutex due to the
    xattrs-are-a-directory thing.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 25610205c90d..555bc195c420 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -570,13 +570,14 @@ struct inode {
  * 3: quota file
  *
  * The locking order between these classes is
- * parent -> child -> normal -> quota
+ * parent -> child -> normal -> xattr -> quota
  */
 enum inode_i_mutex_lock_class
 {
 	I_MUTEX_NORMAL,
 	I_MUTEX_PARENT,
 	I_MUTEX_CHILD,
+	I_MUTEX_XATTR,
 	I_MUTEX_QUOTA
 };
 

commit 01bf466e1866feeb7fce0319cbafe0166e29f5e4
Author: David Howells <dhowells@redhat.com>
Date:   Mon Jul 10 04:44:53 2006 -0700

    [PATCH] FDPIC: Define SEEK_* constants in the Linux kernel headers
    
    Add definitions for SEEK_SET, SEEK_CUR and SEEK_END to the kernel header
    files.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 43aef9b230fd..25610205c90d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -27,6 +27,10 @@
 #define BLOCK_SIZE_BITS 10
 #define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
 
+#define SEEK_SET	0	/* seek relative to beginning of file */
+#define SEEK_CUR	1	/* seek relative to current file position */
+#define SEEK_END	2	/* seek relative to end of file */
+
 /* And dynamically-tunable limits and defaults: */
 struct files_stat_struct {
 	int nr_files;		/* read only */

commit f475ae957db66650db66916c62604ac27409d884
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Jun 29 16:38:32 2006 -0400

    VFS: Allow caller to determine if BSD or posix locks were actually freed
    
    Change posix_lock_file_conf(), and flock_lock_file() so that if called
    with an F_UNLCK argument, and the FL_EXISTS flag they will indicate
    whether or not any locks were actually freed by returning 0 or -ENOENT.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 134b32068246..43aef9b230fd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -716,6 +716,7 @@ extern spinlock_t files_lock;
 #define FL_POSIX	1
 #define FL_FLOCK	2
 #define FL_ACCESS	8	/* not trying to lock, just looking */
+#define FL_EXISTS	16	/* when unlocking, test for existence */
 #define FL_LEASE	32	/* lease held on this file */
 #define FL_CLOSE	64	/* unlock on close */
 #define FL_SLEEP	128	/* A blocking lock */

commit 663d440eaa496db903cc58be04b9b602ba45e43b
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:25:33 2006 -0700

    [PATCH] lockdep: annotate blkdev nesting
    
    Teach special (recursive) locking code to the lock validator.
    
    Effects on non-lockdep kernels:
    
    - the introduction of the following function variants:
    
      extern struct block_device *open_partition_by_devnum(dev_t, unsigned);
    
      extern int blkdev_put_partition(struct block_device *);
    
      static int
      blkdev_get_whole(struct block_device *bdev, mode_t mode, unsigned flags);
    
     which on non-lockdep are the same as open_by_devnum(), blkdev_put()
     and blkdev_get().
    
    - a subclass parameter to do_open(). [unused on non-lockdep]
    
    - a subclass parameter to __blkdev_put(), which is a new internal
      function for the main blkdev_put*() functions. [parameter unused
      on non-lockdep kernels, except for two sanity check WARN_ON()s]
    
    these functions carry no semantical difference - they only express
    object dependencies towards the lockdep subsystem.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e26de68059af..134b32068246 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -435,6 +435,21 @@ struct block_device {
 	unsigned long		bd_private;
 };
 
+/*
+ * bdev->bd_mutex nesting subclasses for the lock validator:
+ *
+ * 0: normal
+ * 1: 'whole'
+ * 2: 'partition'
+ */
+enum bdev_bd_mutex_lock_class
+{
+	BD_MUTEX_NORMAL,
+	BD_MUTEX_WHOLE,
+	BD_MUTEX_PARTITION
+};
+
+
 /*
  * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
  * radix trees
@@ -1425,6 +1440,7 @@ extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, unsigned);
+extern struct block_device *open_partition_by_devnum(dev_t, unsigned);
 extern const struct file_operations def_blk_fops;
 extern const struct address_space_operations def_blk_aops;
 extern const struct file_operations def_chr_fops;
@@ -1435,6 +1451,7 @@ extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
 extern int blkdev_get(struct block_device *, mode_t, unsigned);
 extern int blkdev_put(struct block_device *);
+extern int blkdev_put_partition(struct block_device *);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);
 #ifdef CONFIG_SYSFS

commit 897c6ff9568bcb102ffc6b465ebe1def0cba829d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Jul 3 00:25:28 2006 -0700

    [PATCH] lockdep: annotate sb ->s_umount
    
    The s_umount rwsem needs to be classified as per-superblock since it's
    perfectly legit to keep multiple of those recursively in the VFS locking
    rules.
    
    Has no effect on non-lockdep kernels.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0a3ea52d711e..e26de68059af 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1296,6 +1296,7 @@ struct file_system_type {
 	struct file_system_type * next;
 	struct list_head fs_supers;
 	struct lock_class_key s_lock_key;
+	struct lock_class_key s_umount_key;
 };
 
 extern int get_sb_bdev(struct file_system_type *fs_type,

commit cf51624999e56c88154b5f7d451a265db6aabff7
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:25:27 2006 -0700

    [PATCH] lockdep: annotate ->s_lock
    
    Teach special (per-filesystem) locking code to the lock validator.
    
    Minimal effect on non-lockdep kernels: one extra parameter to alloc_super().
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 05ded9e76b23..0a3ea52d711e 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1295,6 +1295,7 @@ struct file_system_type {
 	struct module *owner;
 	struct file_system_type * next;
 	struct list_head fs_supers;
+	struct lock_class_key s_lock_key;
 };
 
 extern int get_sb_bdev(struct file_system_type *fs_type,

commit f2eace23e924bd3f05aedea4fc505eb5508d2d93
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:25:05 2006 -0700

    [PATCH] lockdep: annotate i_mutex
    
    Teach special (recursive) locking code to the lock validator.  Has no effect
    on non-lockdep kernels.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e04a5cfe874f..05ded9e76b23 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -542,6 +542,25 @@ struct inode {
 #endif
 };
 
+/*
+ * inode->i_mutex nesting subclasses for the lock validator:
+ *
+ * 0: the object of the current VFS operation
+ * 1: parent
+ * 2: child/target
+ * 3: quota file
+ *
+ * The locking order between these classes is
+ * parent -> child -> normal -> quota
+ */
+enum inode_i_mutex_lock_class
+{
+	I_MUTEX_NORMAL,
+	I_MUTEX_PARENT,
+	I_MUTEX_CHILD,
+	I_MUTEX_QUOTA
+};
+
 /*
  * NOTE: in a 32bit arch with a preemptable kernel and
  * an UP compile the i_size_read/write must be atomic

commit f5e54d6e53a20cef45af7499e86164f0e0d16bb2
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 28 04:26:44 2006 -0700

    [PATCH] mark address_space_operations const
    
    Same as with already do with the file operations: keep them in .rodata and
    prevents people from doing runtime patching.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2d8b348c1192..e04a5cfe874f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -392,7 +392,7 @@ struct address_space {
 	unsigned int		truncate_count;	/* Cover race condition with truncate */
 	unsigned long		nrpages;	/* number of total pages */
 	pgoff_t			writeback_index;/* writeback starts here */
-	struct address_space_operations *a_ops;	/* methods */
+	const struct address_space_operations *a_ops;	/* methods */
 	unsigned long		flags;		/* error bits/gfp mask */
 	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
 	spinlock_t		private_lock;	/* for use by the address_space */
@@ -1405,7 +1405,7 @@ extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, unsigned);
 extern const struct file_operations def_blk_fops;
-extern struct address_space_operations def_blk_aops;
+extern const struct address_space_operations def_blk_aops;
 extern const struct file_operations def_chr_fops;
 extern const struct file_operations bad_sock_fops;
 extern const struct file_operations def_fifo_fops;

commit 816724e65c72a90a44fbad0ef0b59b186c85fa90
Merge: 70ac4385a13f d384ea691fe4
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Sat Jun 24 08:41:41 2006 -0400

    Merge branch 'master' of /home/trondmy/kernel/linux-2.6/
    
    Conflicts:
    
            fs/nfs/inode.c
            fs/super.c
    
    Fix conflicts between patch 'NFS: Split fs/nfs/inode.c' and patch
    'VFS: Permit filesystem to override root dentry on mount'

commit b0904e147f7cbe4be3b4dae49ddccd627bb66f16
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Jun 23 02:05:13 2006 -0700

    [PATCH] fs/locks.c: make posix_locks_deadlock() static
    
    We can now make posix_locks_deadlock() static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 56d8bf0d0a77..dba4cbd157ee 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -776,7 +776,6 @@ extern int posix_lock_file_conf(struct file *, struct file_lock *, struct file_l
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
-extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);

commit 75e1fcc0b18df0a65ab113198e9dc0e98999a08c
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Fri Jun 23 02:05:12 2006 -0700

    [PATCH] vfs: add lock owner argument to flush operation
    
    Pass the POSIX lock owner ID to the flush operation.
    
    This is useful for filesystems which don't want to store any locking state
    in inode->i_flock but want to handle locking/unlocking POSIX locks
    internally.  FUSE is one such filesystem but I think it possible that some
    network filesystems would need this also.
    
    Also add a flag to indicate that a POSIX locking request was generated by
    close(), so filesystems using the above feature won't send an extra locking
    request in this case.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e917403f4d58..56d8bf0d0a77 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -683,6 +683,7 @@ extern spinlock_t files_lock;
 #define FL_FLOCK	2
 #define FL_ACCESS	8	/* not trying to lock, just looking */
 #define FL_LEASE	32	/* lease held on this file */
+#define FL_CLOSE	64	/* unlock on close */
 #define FL_SLEEP	128	/* A blocking lock */
 
 /*
@@ -1025,7 +1026,7 @@ struct file_operations {
 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
 	int (*mmap) (struct file *, struct vm_area_struct *);
 	int (*open) (struct inode *, struct file *);
-	int (*flush) (struct file *);
+	int (*flush) (struct file *, fl_owner_t id);
 	int (*release) (struct inode *, struct file *);
 	int (*fsync) (struct file *, struct dentry *, int datasync);
 	int (*aio_fsync) (struct kiocb *, int datasync);

commit 2d1db3b1170db4e8bf0531dd636742269c2cf579
Author: Christoph Lameter <clameter@sgi.com>
Date:   Fri Jun 23 02:03:33 2006 -0700

    [PATCH] page migration cleanup: pass "mapping" to migration functions
    
    Change handling of address spaces.
    
    Pass a pointer to the address space in which the page is migrated to all
    migration function.  This avoids repeatedly having to retrieve the address
    space pointer from the page and checking it for validity.  The old page
    mapping will change once migration has gone to a certain step, so it is less
    confusing to have the pointer always available.
    
    Move the setting of the mapping and index for the new page into
    migrate_pages().
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c823a3815e24..e917403f4d58 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -376,7 +376,8 @@ struct address_space_operations {
 	struct page* (*get_xip_page)(struct address_space *, sector_t,
 			int);
 	/* migrate the contents of a page to the specified target */
-	int (*migratepage) (struct page *, struct page *);
+	int (*migratepage) (struct address_space *,
+			struct page *, struct page *);
 };
 
 struct backing_dev_info;
@@ -1772,7 +1773,8 @@ extern void simple_release_fs(struct vfsmount **mount, int *count);
 extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const void *, size_t);
 
 #ifdef CONFIG_MIGRATION
-extern int buffer_migrate_page(struct page *, struct page *);
+extern int buffer_migrate_page(struct address_space *,
+				struct page *, struct page *);
 #else
 #define buffer_migrate_page NULL
 #endif

commit 726c334223180e3c0197cc980a432681370d4baf
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 23 02:02:58 2006 -0700

    [PATCH] VFS: Permit filesystem to perform statfs with a known root dentry
    
    Give the statfs superblock operation a dentry pointer rather than a superblock
    pointer.
    
    This complements the get_sb() patch.  That reduced the significance of
    sb->s_root, allowing NFS to place a fake root there.  However, NFS does
    require a dentry to use as a target for the statfs operation.  This permits
    the root in the vfsmount to be used instead.
    
    linux/mount.h has been added where necessary to make allyesconfig build
    successfully.
    
    Interest has also been expressed for use with the FUSE and XFS filesystems.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Nathan Scott <nathans@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3e50dd24af87..c823a3815e24 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1096,7 +1096,7 @@ struct super_operations {
 	int (*sync_fs)(struct super_block *sb, int wait);
 	void (*write_super_lockfs) (struct super_block *);
 	void (*unlockfs) (struct super_block *);
-	int (*statfs) (struct super_block *, struct kstatfs *);
+	int (*statfs) (struct dentry *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);
 	void (*umount_begin) (struct super_block *);
@@ -1325,7 +1325,7 @@ extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
 extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 				  struct vfsmount *);
 
-extern int vfs_statfs(struct super_block *, struct kstatfs *);
+extern int vfs_statfs(struct dentry *, struct kstatfs *);
 
 /* /sys/fs */
 extern struct subsystem fs_subsys;
@@ -1746,7 +1746,7 @@ extern int dcache_dir_close(struct inode *, struct file *);
 extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
 extern int dcache_readdir(struct file *, void *, filldir_t);
 extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
-extern int simple_statfs(struct super_block *, struct kstatfs *);
+extern int simple_statfs(struct dentry *, struct kstatfs *);
 extern int simple_link(struct dentry *, struct inode *, struct dentry *);
 extern int simple_unlink(struct inode *, struct dentry *);
 extern int simple_rmdir(struct inode *, struct dentry *);

commit 454e2398be9b9fa30433fccc548db34d19aa9958
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 23 02:02:57 2006 -0700

    [PATCH] VFS: Permit filesystem to override root dentry on mount
    
    Extend the get_sb() filesystem operation to take an extra argument that
    permits the VFS to pass in the target vfsmount that defines the mountpoint.
    
    The filesystem is then required to manually set the superblock and root dentry
    pointers.  For most filesystems, this should be done with simple_set_mnt()
    which will set the superblock pointer and then set the root dentry to the
    superblock's s_root (as per the old default behaviour).
    
    The get_sb() op now returns an integer as there's now no need to return the
    superblock pointer.
    
    This patch permits a superblock to be implicitly shared amongst several mount
    points, such as can be done with NFS to avoid potential inode aliasing.  In
    such a case, simple_set_mnt() would not be called, and instead the mnt_root
    and mnt_sb would be set directly.
    
    The patch also makes the following changes:
    
     (*) the get_sb_*() convenience functions in the core kernel now take a vfsmount
         pointer argument and return an integer, so most filesystems have to change
         very little.
    
     (*) If one of the convenience function is not used, then get_sb() should
         normally call simple_set_mnt() to instantiate the vfsmount. This will
         always return 0, and so can be tail-called from get_sb().
    
     (*) generic_shutdown_super() now calls shrink_dcache_sb() to clean up the
         dcache upon superblock destruction rather than shrink_dcache_anon().
    
         This is required because the superblock may now have multiple trees that
         aren't actually bound to s_root, but that still need to be cleaned up. The
         currently called functions assume that the whole tree is rooted at s_root,
         and that anonymous dentries are not the roots of trees which results in
         dentries being left unculled.
    
         However, with the way NFS superblock sharing are currently set to be
         implemented, these assumptions are violated: the root of the filesystem is
         simply a dummy dentry and inode (the real inode for '/' may well be
         inaccessible), and all the vfsmounts are rooted on anonymous[*] dentries
         with child trees.
    
         [*] Anonymous until discovered from another tree.
    
     (*) The documentation has been adjusted, including the additional bit of
         changing ext2_* into foo_* in the documentation.
    
    [akpm@osdl.org: convert ipath_fs, do other stuff]
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Nathan Scott <nathans@sgi.com>
    Cc: Roland Dreier <rolandd@cisco.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 73c7d6f04b31..3e50dd24af87 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1269,23 +1269,26 @@ find_exported_dentry(struct super_block *sb, void *obj, void *parent,
 struct file_system_type {
 	const char *name;
 	int fs_flags;
-	struct super_block *(*get_sb) (struct file_system_type *, int,
-				       const char *, void *);
+	int (*get_sb) (struct file_system_type *, int,
+		       const char *, void *, struct vfsmount *);
 	void (*kill_sb) (struct super_block *);
 	struct module *owner;
 	struct file_system_type * next;
 	struct list_head fs_supers;
 };
 
-struct super_block *get_sb_bdev(struct file_system_type *fs_type,
+extern int get_sb_bdev(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data,
-	int (*fill_super)(struct super_block *, void *, int));
-struct super_block *get_sb_single(struct file_system_type *fs_type,
+	int (*fill_super)(struct super_block *, void *, int),
+	struct vfsmount *mnt);
+extern int get_sb_single(struct file_system_type *fs_type,
 	int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int));
-struct super_block *get_sb_nodev(struct file_system_type *fs_type,
+	int (*fill_super)(struct super_block *, void *, int),
+	struct vfsmount *mnt);
+extern int get_sb_nodev(struct file_system_type *fs_type,
 	int flags, void *data,
-	int (*fill_super)(struct super_block *, void *, int));
+	int (*fill_super)(struct super_block *, void *, int),
+	struct vfsmount *mnt);
 void generic_shutdown_super(struct super_block *sb);
 void kill_block_super(struct super_block *sb);
 void kill_anon_super(struct super_block *sb);
@@ -1296,8 +1299,10 @@ struct super_block *sget(struct file_system_type *type,
 			int (*test)(struct super_block *,void *),
 			int (*set)(struct super_block *,void *),
 			void *data);
-struct super_block *get_sb_pseudo(struct file_system_type *, char *,
-			struct super_operations *ops, unsigned long);
+extern int get_sb_pseudo(struct file_system_type *, char *,
+	struct super_operations *ops, unsigned long,
+	struct vfsmount *mnt);
+extern int simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super(struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
 void unnamed_dev_init(void);

commit c89681ed7d0e4a61d35bdc12c06c6733b718b2cb
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Thu Jun 22 14:47:22 2006 -0700

    [PATCH] remove steal_locks()
    
    This patch removes the steal_locks() function.
    
    steal_locks() doesn't work correctly with any filesystem that does it's own
    lock management, including NFS, CIFS, etc.
    
    In addition it has weird semantics on local filesystems in case tasks
    sharing file-descriptor tables are doing POSIX locking operations in
    parallel to execve().
    
    The steal_locks() function has an effect on applications doing:
    
    clone(CLONE_FILES)
      /* in child */
      lock
      execve
      lock
    
    POSIX locks acquired before execve (by "child", "parent" or any further
    task sharing files_struct) will after the execve be owned exclusively by
    "child".
    
    According to Chris Wright some LSB/LTP kind of suite triggers without the
    stealing behavior, but there's no known real-world application that would
    also fail.
    
    Apps using NPTL are not affected, since all other threads are killed before
    execve.
    
    Apps using LinuxThreads are only affected if they
    
      - have multiple threads during exec (LinuxThreads doesn't kill other
        threads, the app may do it with pthread_kill_other_threads_np())
      - rely on POSIX locks being inherited across exec
    
    Both conditions are documented, but not their interaction.
    
    Apps using clone() natively are affected if they
    
      - use clone(CLONE_FILES)
      - rely on POSIX locks being inherited across exec
    
    The above scenarios are unlikely, but possible.
    
    If the patch is vetoed, there's a plan B, that involves mostly keeping the
    weird stealing semantics, but changing the way lock ownership is handled so
    that network and local filesystems work consistently.
    
    That would add more complexity though, so this solution seems to be
    preferred by most people.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Steven French <sfrench@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ecc8c2c3d8ca..73c7d6f04b31 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -782,7 +782,6 @@ extern int setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
-extern void steal_locks(fl_owner_t from);
 
 struct fasync_struct {
 	int	magic;

commit 70ac4385a13f78bc478f26d317511893741b05bd
Merge: d59bf96cdde5 077e98945db7
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jun 20 20:46:21 2006 -0400

    Merge branch 'master' of /home/trondmy/kernel/linux-2.6/
    
    Conflicts:
    
            include/linux/nfs_fs.h
    
    Fixed up conflict with kernel header updates.

commit 8b512d9a88875affe584bb3d2a7a235f84343b9e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 9 09:34:18 2006 -0400

    VFS: Remove dependency of ->umount_begin() call on MNT_FORCE
    
    Allow filesystems to decide to perform pre-umount processing whether or not
    MNT_FORCE is set.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eca70cfe5b85..1d80ba747484 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1101,7 +1101,7 @@ struct super_operations {
 	int (*statfs) (struct super_block *, struct kstatfs *);
 	int (*remount_fs) (struct super_block *, int *, char *);
 	void (*clear_inode) (struct inode *);
-	void (*umount_begin) (struct super_block *);
+	void (*umount_begin) (struct vfsmount *, int);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
 	int (*show_stats)(struct seq_file *, struct vfsmount *);

commit 1f5ce9e93aa96a867f195ed45f6f77935175f12e
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Fri Jun 9 09:34:16 2006 -0400

    VFS: Unexport do_kern_mount() and clean up simple_pin_fs()
    
    Replace all module uses with the new vfs_kern_mount() interface, and fix up
    simple_pin_fs().
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f813bc8266aa..eca70cfe5b85 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1763,7 +1763,7 @@ extern struct inode_operations simple_dir_inode_operations;
 struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
 extern int simple_fill_super(struct super_block *, int, struct tree_descr *);
-extern int simple_pin_fs(char *name, struct vfsmount **mount, int *count);
+extern int simple_pin_fs(struct file_system_type *, struct vfsmount **mount, int *count);
 extern void simple_release_fs(struct vfsmount **mount, int *count);
 
 extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const void *, size_t);

commit 66643de455c27973ac31ad6de9f859d399916842
Merge: 2c23d62abb82 387e2b043902
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 24 09:22:21 2006 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            include/asm-powerpc/unistd.h
            include/asm-sparc/unistd.h
            include/asm-sparc64/unistd.h
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

commit e46e490368f87032a6e54969194413339b35a385
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon May 22 22:35:24 2006 -0700

    [PATCH] sys_sync_file_range(): move exported flags outside __KERNEL__
    
    These flags are needed by userspace - move them outside __KERNEL__
    
    (Pointed out by dwmw2)
    
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3de2bfb2410f..f813bc8266aa 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -213,6 +213,10 @@ extern int dir_notify_enable;
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */
 #define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
 
+#define SYNC_FILE_RANGE_WAIT_BEFORE	1
+#define SYNC_FILE_RANGE_WRITE		2
+#define SYNC_FILE_RANGE_WAIT_AFTER	4
+
 #ifdef __KERNEL__
 
 #include <linux/linkage.h>
@@ -758,9 +762,6 @@ extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
 /* fs/sync.c */
-#define SYNC_FILE_RANGE_WAIT_BEFORE	1
-#define SYNC_FILE_RANGE_WRITE		2
-#define SYNC_FILE_RANGE_WAIT_AFTER	4
 extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
 			unsigned int flags);
 

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3de2bfb2410f..75a236c268fc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -6,7 +6,6 @@
  * structures etc.
  */
 
-#include <linux/config.h>
 #include <linux/limits.h>
 #include <linux/ioctl.h>
 

commit cbb7e577e732f576b9f399bc2600bdc0626c68dc
Author: Jens Axboe <axboe@suse.de>
Date:   Tue Apr 11 14:57:50 2006 +0200

    [PATCH] splice: pass offset around for ->splice_read() and ->splice_write()
    
    We need not use ->f_pos as the offset for the file input/output. If the
    user passed an offset pointer in through sys_splice(), just use that and
    leave ->f_pos alone.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 162c6e57307a..3de2bfb2410f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1039,8 +1039,8 @@ struct file_operations {
 	int (*check_flags)(int);
 	int (*dir_notify)(struct file *filp, unsigned long arg);
 	int (*flock) (struct file *, int, struct file_lock *);
-	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, size_t, unsigned int);
-	ssize_t (*splice_read)(struct file *, struct pipe_inode_info *, size_t, unsigned int);
+	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
+	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 };
 
 struct inode_operations {
@@ -1613,13 +1613,13 @@ extern void do_generic_mapping_read(struct address_space *mapping,
 				    loff_t *, read_descriptor_t *, read_actor_t);
 
 /* fs/splice.c */
-extern ssize_t generic_file_splice_read(struct file *,
+extern ssize_t generic_file_splice_read(struct file *, loff_t *,
 		struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
-		struct file *, size_t, unsigned int);
+		struct file *, loff_t *, size_t, unsigned int);
 extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
-		struct file *out, size_t len, unsigned int flags);
-extern long do_splice_direct(struct file *in, struct file *out,
+		struct file *out, loff_t *, size_t len, unsigned int flags);
+extern long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,
 		size_t len, unsigned int flags);
 
 extern void

commit 88dd9c16cecbd105bbe7711b6120333f6f7b5474
Merge: 6dde43255355 d1195c516a9a
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Apr 11 06:34:02 2006 -0700

    Merge branch 'splice' of git://brick.kernel.dk/data/git/linux-2.6-block
    
    * 'splice' of git://brick.kernel.dk/data/git/linux-2.6-block:
      [PATCH] vfs: add splice_write and splice_read to documentation
      [PATCH] Remove sys_ prefix of new syscalls from __NR_sys_*
      [PATCH] splice: warning fix
      [PATCH] another round of fs/pipe.c cleanups
      [PATCH] splice: comment styles
      [PATCH] splice: add Ingo as addition copyright holder
      [PATCH] splice: unlikely() optimizations
      [PATCH] splice: speedups and optimizations
      [PATCH] pipe.c/fifo.c code cleanups
      [PATCH] get rid of the PIPE_*() macros
      [PATCH] splice: speedup __generic_file_splice_read
      [PATCH] splice: add direct fd <-> fd splicing support
      [PATCH] splice: add optional input and output offsets
      [PATCH] introduce a "kernel-internal pipe object" abstraction
      [PATCH] splice: be smarter about calling do_page_cache_readahead()
      [PATCH] splice: optimize the splice buffer mapping
      [PATCH] splice: cleanup __generic_file_splice_read()
      [PATCH] splice: only call wake_up_interruptible() when we really have to
      [PATCH] splice: potential !page dereference
      [PATCH] splice: mark the io page as accessed

commit 5246d0503130fa58904c8beb987fcf93b96d8ab6
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Apr 10 22:53:57 2006 -0700

    [PATCH] sync_file_range(): use unsigned for flags
    
    Ulrich suggested that the `flags' arg to sync_file_range() become unsigned.
    
    Cc: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1e9ebaba07b7..504dcf5b297b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -762,7 +762,7 @@ extern int fcntl_getlease(struct file *filp);
 #define SYNC_FILE_RANGE_WRITE		2
 #define SYNC_FILE_RANGE_WAIT_AFTER	4
 extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
-			int flags);
+			unsigned int flags);
 
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);

commit 88e6faefaeed40a162041d85689e94595756d4c3
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Apr 11 13:59:36 2006 +0200

    [PATCH] splice: warning fix
    
    From: Andrew Morton <akpm@osdl.org>
    
    net/socket.c:148: warning: initialization from incompatible pointer type
    
    extern declarations in .c files!  Bad boy.
    
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9e8e2ee353b4..2a629fd88ef0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1611,10 +1611,17 @@ extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor
 extern void do_generic_mapping_read(struct address_space *mapping,
 				    struct file_ra_state *, struct file *,
 				    loff_t *, read_descriptor_t *, read_actor_t);
-extern ssize_t generic_file_splice_read(struct file *, struct pipe_inode_info *, size_t, unsigned int);
-extern ssize_t generic_file_splice_write(struct pipe_inode_info *, struct file *, size_t, unsigned int);
+
+/* fs/splice.c */
+extern ssize_t generic_file_splice_read(struct file *,
+		struct pipe_inode_info *, size_t, unsigned int);
+extern ssize_t generic_file_splice_write(struct pipe_inode_info *,
+		struct file *, size_t, unsigned int);
+extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,
+		struct file *out, size_t len, unsigned int flags);
 extern long do_splice_direct(struct file *in, struct file *out,
-			     size_t len, unsigned int flags);
+		size_t len, unsigned int flags);
+
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 

commit b92ce55893745e011edae70830b8bc863be881f9
Author: Jens Axboe <axboe@suse.de>
Date:   Tue Apr 11 13:52:07 2006 +0200

    [PATCH] splice: add direct fd <-> fd splicing support
    
    It's more efficient for sendfile() emulation. Basically we cache an
    internal private pipe and just use that as the intermediate area for
    pages. Direct splicing is not available from sys_splice(), it is only
    meant to be used for sendfile() emulation.
    
    Additional patch from Ingo Molnar to avoid the PIPE_BUFFERS loop at
    exit for the normal fast path.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7e6454454fbd..9e8e2ee353b4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1613,6 +1613,8 @@ extern void do_generic_mapping_read(struct address_space *mapping,
 				    loff_t *, read_descriptor_t *, read_actor_t);
 extern ssize_t generic_file_splice_read(struct file *, struct pipe_inode_info *, size_t, unsigned int);
 extern ssize_t generic_file_splice_write(struct pipe_inode_info *, struct file *, size_t, unsigned int);
+extern long do_splice_direct(struct file *in, struct file *out,
+			     size_t len, unsigned int flags);
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 

commit 3a326a2ce88e71d00ac0d133e314a3342a7709f8
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Apr 10 15:18:35 2006 +0200

    [PATCH] introduce a "kernel-internal pipe object" abstraction
    
    separate out the 'internal pipe object' abstraction, and make it
    usable to splice. This cleans up and fixes several aspects of the
    internal splice APIs and the pipe code:
    
     - pipes: the allocation and freeing of pipe_inode_info is now more symmetric
       and more streamlined with existing kernel practices.
    
     - splice: small micro-optimization: less pointer dereferencing in splice
       methods
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    
    Update XFS for the ->splice_read/->splice_write changes.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1e9ebaba07b7..7e6454454fbd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1039,8 +1039,8 @@ struct file_operations {
 	int (*check_flags)(int);
 	int (*dir_notify)(struct file *filp, unsigned long arg);
 	int (*flock) (struct file *, int, struct file_lock *);
-	ssize_t (*splice_write)(struct inode *, struct file *, size_t, unsigned int);
-	ssize_t (*splice_read)(struct file *, struct inode *, size_t, unsigned int);
+	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, size_t, unsigned int);
+	ssize_t (*splice_read)(struct file *, struct pipe_inode_info *, size_t, unsigned int);
 };
 
 struct inode_operations {
@@ -1611,8 +1611,8 @@ extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor
 extern void do_generic_mapping_read(struct address_space *mapping,
 				    struct file_ra_state *, struct file *,
 				    loff_t *, read_descriptor_t *, read_actor_t);
-extern ssize_t generic_file_splice_read(struct file *, struct inode *, size_t, unsigned int);
-extern ssize_t generic_file_splice_write(struct inode *, struct file *, size_t, unsigned int);
+extern ssize_t generic_file_splice_read(struct file *, struct pipe_inode_info *, size_t, unsigned int);
+extern ssize_t generic_file_splice_write(struct pipe_inode_info *, struct file *, size_t, unsigned int);
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 

commit 8ba8e95ed14a2771bbcb43300feda094f298853e
Author: Kalin KOZHUHAROV <kalin@thinrope.net>
Date:   Sat Apr 1 01:41:22 2006 +0200

    Fix comments: s/granuality/granularity/
    
    I was grepping through the code and some `grep ganularity -R .` didn't
    catch what I thought. Then looking closer I saw the term "granuality"
    used in only four places (in comments) and granularity in many more
    places describing the same idea. Some other facts:
    
    dictionary.com does not know such a word
    define:granuality on google is not found (and pages for granuality are
    mostly related to patches to the kernel)
    it has not been discussed as a term on LKML, AFAICS (=Can Search)
    
    To be consistent, I think granularity should be used everywhere.
    
    Signed-off-by: Kalin KOZHUHAROV <kalin@thinrope.net>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4ed7e602d703..1e9ebaba07b7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -864,7 +864,7 @@ struct super_block {
 	 */
 	struct mutex s_vfs_rename_mutex;	/* Kludge */
 
-	/* Granuality of c/m/atime in ns.
+	/* Granularity of c/m/atime in ns.
 	   Cannot be worse than a second */
 	u32		   s_time_gran;
 };

commit f79e2abb9bd452d97295f34376dedbec9686b986
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Mar 31 02:30:42 2006 -0800

    [PATCH] sys_sync_file_range()
    
    Remove the recently-added LINUX_FADV_ASYNC_WRITE and LINUX_FADV_WRITE_WAIT
    fadvise() additions, do it in a new sys_sync_file_range() syscall instead.
    Reasons:
    
    - It's more flexible.  Things which would require two or three syscalls with
      fadvise() can be done in a single syscall.
    
    - Using fadvise() in this manner is something not covered by POSIX.
    
    The patch wires up the syscall for x86.
    
    The sycall is implemented in the new fs/sync.c.  The intention is that we can
    move sys_fsync(), sys_fdatasync() and perhaps sys_sync() into there later.
    
    Documentation for the syscall is in fs/sync.c.
    
    A test app (sync_file_range.c) is in
    http://www.zip.com.au/~akpm/linux/patches/stuff/ext3-tools.tar.gz.
    
    The available-to-GPL-modules do_sync_file_range() is for knfsd: "A COMMIT can
    say NFS_DATA_SYNC or NFS_FILE_SYNC.  I can skip the ->fsync call for
    NFS_DATA_SYNC which is hopefully the more common."
    
    Note: the `async' writeout mode SYNC_FILE_RANGE_WRITE will turn synchronous if
    the queue is congested.  This is trivial to fix: add a new flag bit, set
    wbc->nonblocking.  But I'm not sure that we want to expose implementation
    details down to that level.
    
    Note: it's notable that we can sync an fd which wasn't opened for writing.
    Same with fsync() and fdatasync()).
    
    Note: the code takes some care to handle attempts to sync file contents
    outside the 16TB offset on 32-bit machines.  It makes such attempts appear to
    succeed, for best 32-bit/64-bit compatibility.  Perhaps it should make such
    requests fail...
    
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Ulrich Drepper <drepper@redhat.com>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 20a7afd4590c..4ed7e602d703 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -757,6 +757,13 @@ extern void send_sigio(struct fown_struct *fown, int fd, int band);
 extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
 extern int fcntl_getlease(struct file *filp);
 
+/* fs/sync.c */
+#define SYNC_FILE_RANGE_WAIT_BEFORE	1
+#define SYNC_FILE_RANGE_WRITE		2
+#define SYNC_FILE_RANGE_WAIT_AFTER	4
+extern int do_sync_file_range(struct file *file, loff_t offset, loff_t endbyte,
+			int flags);
+
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);

commit 68eef3b4791572ecb70249c7fb145bb3742dd899
Author: Joe Korty <joe.korty@ccur.com>
Date:   Fri Mar 31 02:30:32 2006 -0800

    [PATCH] Simplify proc/devices and fix early termination regression
    
    Make baby-simple the code for /proc/devices.  Based on the proven design
    for /proc/interrupts.
    
    This also fixes the early-termination regression 2.6.16 introduced, as
    demonstrated by:
    
        # dd if=/proc/devices bs=1
        Character devices:
          1 mem
        27+0 records in
        27+0 records out
    
    This should also work (but is untested) when /proc/devices >4096 bytes,
    which I believe is what the original 2.6.16 rewrite fixed.
    
    [akpm@osdl.org: cleanups, simplifications]
    Signed-off-by: Joe Korty <joe.korty@ccur.com>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 20fa5f6d7269..20a7afd4590c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1413,6 +1413,7 @@ extern void bd_release_from_disk(struct block_device *, struct gendisk *);
 #endif
 
 /* fs/char_dev.c */
+#define CHRDEV_MAJOR_HASH_SIZE	255
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
 extern int register_chrdev(unsigned int, const char *,
@@ -1420,25 +1421,17 @@ extern int register_chrdev(unsigned int, const char *,
 extern int unregister_chrdev(unsigned int, const char *);
 extern void unregister_chrdev_region(dev_t, unsigned);
 extern int chrdev_open(struct inode *, struct file *);
-extern int get_chrdev_list(char *);
-extern void *acquire_chrdev_list(void);
-extern int count_chrdev_list(void);
-extern void *get_next_chrdev(void *);
-extern int get_chrdev_info(void *, int *, char **);
-extern void release_chrdev_list(void *);
+extern void chrdev_show(struct seq_file *,off_t);
 
 /* fs/block_dev.c */
+#define BLKDEV_MAJOR_HASH_SIZE	255
 #define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
 extern const char *__bdevname(dev_t, char *buffer);
 extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern struct block_device *open_bdev_excl(const char *, int, void *);
 extern void close_bdev_excl(struct block_device *);
-extern void *acquire_blkdev_list(void);
-extern int count_blkdev_list(void);
-extern void *get_next_blkdev(void *);
-extern int get_blkdev_info(void *, int *, char **);
-extern void release_blkdev_list(void *);
+extern void blkdev_show(struct seq_file *,off_t);
 
 extern void init_special_inode(struct inode *, umode_t, dev_t);
 

commit 5274f052e7b3dbd81935772eb551dfd0325dfa9d
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Mar 30 15:15:30 2006 +0200

    [PATCH] Introduce sys_splice() system call
    
    This adds support for the sys_splice system call. Using a pipe as a
    transport, it can connect to files or sockets (latter as output only).
    
    From the splice.c comments:
    
       "splice": joining two ropes together by interweaving their strands.
    
       This is the "extended pipe" functionality, where a pipe is used as
       an arbitrary in-memory buffer. Think of a pipe as a small kernel
       buffer that you can use to transfer data from one end to the other.
    
       The traditional unix read/write is extended with a "splice()" operation
       that transfers data buffers to or from a pipe buffer.
    
       Named by Larry McVoy, original implementation from Linus, extended by
       Jens to support splicing to files and fixing the initial implementation
       bugs.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 408fe89498f4..20fa5f6d7269 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1032,6 +1032,8 @@ struct file_operations {
 	int (*check_flags)(int);
 	int (*dir_notify)(struct file *filp, unsigned long arg);
 	int (*flock) (struct file *, int, struct file_lock *);
+	ssize_t (*splice_write)(struct inode *, struct file *, size_t, unsigned int);
+	ssize_t (*splice_read)(struct file *, struct inode *, size_t, unsigned int);
 };
 
 struct inode_operations {
@@ -1609,6 +1611,8 @@ extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor
 extern void do_generic_mapping_read(struct address_space *mapping,
 				    struct file_ra_state *, struct file *,
 				    loff_t *, read_descriptor_t *, read_actor_t);
+extern ssize_t generic_file_splice_read(struct file *, struct inode *, size_t, unsigned int);
+extern ssize_t generic_file_splice_write(struct inode *, struct file *, size_t, unsigned int);
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
 extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 

commit 4b6f5d20b04dcbc3d888555522b90ba6d36c4106
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:42 2006 -0800

    [PATCH] Make most file operations structs in fs/ const
    
    This is a conversion to make the various file_operations structs in fs/
    const.  Basically a regexp job, with a few manual fixups
    
    The goal is both to increase correctness (harder to accidentally write to
    shared datastructures) and reducing the false sharing of cachelines with
    things that get dirty in .data (while .rodata is nicely read only and thus
    cache clean)
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ef355bc73714..408fe89498f4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1390,11 +1390,11 @@ extern void bd_set_size(struct block_device *, loff_t size);
 extern void bd_forget(struct inode *inode);
 extern void bdput(struct block_device *);
 extern struct block_device *open_by_devnum(dev_t, unsigned);
-extern struct file_operations def_blk_fops;
+extern const struct file_operations def_blk_fops;
 extern struct address_space_operations def_blk_aops;
-extern struct file_operations def_chr_fops;
-extern struct file_operations bad_sock_fops;
-extern struct file_operations def_fifo_fops;
+extern const struct file_operations def_chr_fops;
+extern const struct file_operations bad_sock_fops;
+extern const struct file_operations def_fifo_fops;
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
 extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
 extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
@@ -1444,9 +1444,9 @@ extern void init_special_inode(struct inode *, umode_t, dev_t);
 extern void make_bad_inode(struct inode *);
 extern int is_bad_inode(struct inode *);
 
-extern struct file_operations read_fifo_fops;
-extern struct file_operations write_fifo_fops;
-extern struct file_operations rdwr_fifo_fops;
+extern const struct file_operations read_fifo_fops;
+extern const struct file_operations write_fifo_fops;
+extern const struct file_operations rdwr_fifo_fops;
 
 extern int fs_may_remount_ro(struct super_block *);
 
@@ -1688,7 +1688,7 @@ static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
 				nr_segs, get_block, end_io, DIO_OWN_LOCKING);
 }
 
-extern struct file_operations generic_ro_fops;
+extern const struct file_operations generic_ro_fops;
 
 #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
 
@@ -1744,9 +1744,9 @@ extern int simple_commit_write(struct file *file, struct page *page,
 
 extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
-extern struct file_operations simple_dir_operations;
+extern const struct file_operations simple_dir_operations;
 extern struct inode_operations simple_dir_inode_operations;
-struct tree_descr { char *name; struct file_operations *ops; int mode; };
+struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
 extern int simple_fill_super(struct super_block *, int, struct tree_descr *);
 extern int simple_pin_fs(char *name, struct vfsmount **mount, int *count);

commit 99ac48f54a91d02140c497edc31dc57d4bc5c85d
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Mar 28 01:56:41 2006 -0800

    [PATCH] mark f_ops const in the inode
    
    Mark the f_ops members of inodes as const, as well as fix the
    ripple-through this causes by places that copy this f_ops and then "do
    stuff" with it.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 680d913350e7..ef355bc73714 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -496,7 +496,7 @@ struct inode {
 	struct mutex		i_mutex;
 	struct rw_semaphore	i_alloc_sem;
 	struct inode_operations	*i_op;
-	struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
+	const struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
 	struct super_block	*i_sb;
 	struct file_lock	*i_flock;
 	struct address_space	*i_mapping;
@@ -636,7 +636,7 @@ struct file {
 	} f_u;
 	struct dentry		*f_dentry;
 	struct vfsmount         *f_vfsmnt;
-	struct file_operations	*f_op;
+	const struct file_operations	*f_op;
 	atomic_t		f_count;
 	unsigned int 		f_flags;
 	mode_t			f_mode;
@@ -1414,7 +1414,7 @@ extern void bd_release_from_disk(struct block_device *, struct gendisk *);
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
 extern int register_chrdev_region(dev_t, unsigned, const char *);
 extern int register_chrdev(unsigned int, const char *,
-			   struct file_operations *);
+			   const struct file_operations *);
 extern int unregister_chrdev(unsigned int, const char *);
 extern void unregister_chrdev_region(dev_t, unsigned);
 extern int chrdev_open(struct inode *, struct file *);

commit 641dc636b0475582e48584340b774bd1e90d40d9
Author: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
Date:   Mon Mar 27 01:17:57 2006 -0800

    [PATCH] dm/md dependency tree in sysfs: bd_claim_by_kobject
    
    Adding bd_claim_by_kobject() function which takes kobject as additional
    signature of holder device and creates sysfs symlinks between holder device
    and claimed device.  bd_release_from_kobject() is a counterpart of
    bd_claim_by_kobject.
    
    Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
    Cc: Alasdair G Kergon <agk@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9d9674946956..680d913350e7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -410,6 +410,9 @@ struct block_device {
 	struct list_head	bd_inodes;
 	void *			bd_holder;
 	int			bd_holders;
+#ifdef CONFIG_SYSFS
+	struct list_head	bd_holder_list;
+#endif
 	struct block_device *	bd_contains;
 	unsigned		bd_block_size;
 	struct hd_struct *	bd_part;
@@ -1399,6 +1402,13 @@ extern int blkdev_get(struct block_device *, mode_t, unsigned);
 extern int blkdev_put(struct block_device *);
 extern int bd_claim(struct block_device *, void *);
 extern void bd_release(struct block_device *);
+#ifdef CONFIG_SYSFS
+extern int bd_claim_by_disk(struct block_device *, void *, struct gendisk *);
+extern void bd_release_from_disk(struct block_device *, struct gendisk *);
+#else
+#define bd_claim_by_disk(bdev, holder, disk)	bd_claim(bdev, holder)
+#define bd_release_from_disk(bdev, disk)	bd_release(bdev)
+#endif
 
 /* fs/char_dev.c */
 extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);

commit 1d8fa7a2b9a39d18727acc5c468e870df606c852
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Sun Mar 26 01:38:02 2006 -0800

    [PATCH] remove ->get_blocks() support
    
    Now that get_block() can handle mapping multiple disk blocks, no need to have
    ->get_blocks().  This patch removes fs specific ->get_blocks() added for DIO
    and makes it users use get_block() instead.
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 155d29d5e5e4..9d9674946956 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -252,9 +252,6 @@ extern void __init files_init(unsigned long);
 struct buffer_head;
 typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 			struct buffer_head *bh_result, int create);
-typedef int (get_blocks_t)(struct inode *inode, sector_t iblock,
-			unsigned long max_blocks,
-			struct buffer_head *bh_result, int create);
 typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private);
 
@@ -1645,7 +1642,7 @@ static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
 
 ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
 	struct block_device *bdev, const struct iovec *iov, loff_t offset,
-	unsigned long nr_segs, get_blocks_t get_blocks, dio_iodone_t end_io,
+	unsigned long nr_segs, get_block_t get_block, dio_iodone_t end_io,
 	int lock_type);
 
 enum {
@@ -1656,29 +1653,29 @@ enum {
 
 static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	loff_t offset, unsigned long nr_segs, get_block_t get_block,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_blocks, end_io, DIO_LOCKING);
+				nr_segs, get_block, end_io, DIO_LOCKING);
 }
 
 static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	loff_t offset, unsigned long nr_segs, get_block_t get_block,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_blocks, end_io, DIO_NO_LOCKING);
+				nr_segs, get_block, end_io, DIO_NO_LOCKING);
 }
 
 static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
 	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
-	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	loff_t offset, unsigned long nr_segs, get_block_t get_block,
 	dio_iodone_t end_io)
 {
 	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
-				nr_segs, get_blocks, end_io, DIO_OWN_LOCKING);
+				nr_segs, get_block, end_io, DIO_OWN_LOCKING);
 }
 
 extern struct file_operations generic_ro_fops;

commit a0f62ac6362c168754cccb36f196b3dfbddc3bc3
Author: Takashi Sato <sho@tnes.nec.co.jp>
Date:   Sun Mar 26 01:37:52 2006 -0800

    [PATCH] 2TB files: add blkcnt_t
    
    Add blkcnt_t as the type of inode.i_blocks.  This enables you to make the size
    of blkcnt_t either 4 bytes or 8 bytes on 32 bits architecture with CONFIG_LSF.
    
    - CONFIG_LSF
      Add new configuration parameter.
    - blkcnt_t
      On h8300, i386, mips, powerpc, s390 and sh that define sector_t,
      blkcnt_t is defined as u64 if CONFIG_LSF is enabled; otherwise it is
      defined as unsigned long.
      On other architectures, it is defined as unsigned long.
    - inode.i_blocks
      Change the type from sector_t to blkcnt_t.
    
    Signed-off-by: Takashi Sato <sho@tnes.nec.co.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 64b0ca4f14e3..155d29d5e5e4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -490,7 +490,7 @@ struct inode {
 	unsigned int		i_blkbits;
 	unsigned long		i_blksize;
 	unsigned long		i_version;
-	sector_t		i_blocks;
+	blkcnt_t		i_blocks;
 	unsigned short          i_bytes;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	struct mutex		i_mutex;

commit abcb6c9fd13fc2ad7757b818924dc8109a0e3775
Author: Takashi Sato <sho@tnes.nec.co.jp>
Date:   Sun Mar 26 01:37:51 2006 -0800

    [PATCH] 2TB files: st_blocks is invalid when calling stat64
    
    This patch series fixes the following problems on 32 bits architecture.
    
    o stat64 returns the lower 32 bits of blocks, although userland st_blocks
      has 64 bits, because i_blocks has only 32 bits.  The ioctl with FIOQSIZE has
      the same problem.
    
    o As Dave Kleikamp said, making >2TB file on JFS results in writing an
      invalid block number to disk inode.  The cause is the same as above too.
    
    o In generic quota code dquot_transfer(), the file usage is calculated from
      i_blocks via inode_get_bytes().  If the file is over 2TB, the change of
      usage is less than expected.  The cause is the same as above too.
    
    o As Trond Myklebust said, statfs64's entries related to blocks are invalid
      on statfs64 for a network filesystem which has more than 2^32-1 blocks with
      CONFIG_LBD disabled.  [PATCH 3/3]
    
    We made patches to fix problems that occur when handling a large filesystem
    and a large file.  It was discussed on the mails titled "stat64 for over 2TB
    file returned invalid st_blocks".
    
    Signed-off-by: Takashi Sato <sho@tnes.nec.co.jp>
    Cc: Dave Kleikamp <shaggy@austin.ibm.com>
    Cc: Jan Kara <jack@ucw.cz>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ab67181a5a55..64b0ca4f14e3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -490,7 +490,7 @@ struct inode {
 	unsigned int		i_blkbits;
 	unsigned long		i_blksize;
 	unsigned long		i_version;
-	unsigned long		i_blocks;
+	sector_t		i_blocks;
 	unsigned short          i_bytes;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
 	struct mutex		i_mutex;

commit 5842add2f3b519111b6401f3a35862bd00a3aa7e
Author: Andy Adamson <andros@citi.umich.edu>
Date:   Sun Mar 26 01:37:26 2006 -0800

    [PATCH] VFS,fs/locks.c,NFSD4: add race_free posix_lock_file_conf() interface
    
    Lockd and the NFSv4 server both exercise a race condition where
    posix_test_lock() is called either before or after posix_lock_file() to
    deal with a denied lock request due to a conflicting lock.
    
    Remove the race condition for the NFSv4 server by adding a new conflicting
    lock parameter to __posix_lock_file() , changing the name to
    __posix_lock_file_conf().
    
    Keep posix_lock_file() interface, add posix_lock_conf() interface, both
    call __posix_lock_file_conf().
    
    [akpm@osdl.org: Put the EXPORT_SYMBOL() where it belongs]
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9674679525f9..ab67181a5a55 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -763,6 +763,7 @@ extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
 extern int posix_test_lock(struct file *, struct file_lock *, struct file_lock *);
+extern int posix_lock_file_conf(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);

commit 2ff28e22bdb8727fbc7d7889807bc5a73aae56c5
Author: NeilBrown <neilb@suse.de>
Date:   Sun Mar 26 01:37:18 2006 -0800

    [PATCH] Make address_space_operations->invalidatepage return void
    
    The return value of this function is never used, so let's be honest and
    declare it as void.
    
    Some places where invalidatepage returned 0, I have inserted comments
    suggesting a BUG_ON.
    
    [akpm@osdl.org: JBD BUG fix]
    [akpm@osdl.org: rework for git-nfs]
    [akpm@osdl.org: don't go BUG in block_invalidate_page()]
    Signed-off-by: Neil Brown <neilb@suse.de>
    Acked-by: Dave Kleikamp <shaggy@austin.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 972435d4df5c..9674679525f9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -369,7 +369,7 @@ struct address_space_operations {
 	int (*commit_write)(struct file *, struct page *, unsigned, unsigned);
 	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
 	sector_t (*bmap)(struct address_space *, sector_t);
-	int (*invalidatepage) (struct page *, unsigned long);
+	void (*invalidatepage) (struct page *, unsigned long);
 	int (*releasepage) (struct page *, gfp_t);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);

commit 3978d7179d3849848df8a37dd0a5acc20bcb8750
Author: NeilBrown <neilb@suse.de>
Date:   Sun Mar 26 01:37:17 2006 -0800

    [PATCH] Make address_space_operations->sync_page return void
    
    The only user ignores the return value, and the only instanace
    (block_sync_page) always returns 0...
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5adf32b90f36..972435d4df5c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -350,7 +350,7 @@ struct writeback_control;
 struct address_space_operations {
 	int (*writepage)(struct page *page, struct writeback_control *wbc);
 	int (*readpage)(struct file *, struct page *);
-	int (*sync_page)(struct page *);
+	void (*sync_page)(struct page *);
 
 	/* Write back some dirty pages from this mapping. */
 	int (*writepages)(struct address_space *, struct writeback_control *);

commit 53846a21c1766326bb14ce8ab6e997a0c120675d
Merge: 2e9abdd9bad4 1ebbe2b20091
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Sat Mar 25 09:18:27 2006 -0800

    Merge git://git.linux-nfs.org/pub/linux/nfs-2.6
    
    * git://git.linux-nfs.org/pub/linux/nfs-2.6: (103 commits)
      SUNRPC,RPCSEC_GSS: spkm3--fix config dependencies
      SUNRPC,RPCSEC_GSS: spkm3: import contexts using NID_cast5_cbc
      LOCKD: Make nlmsvc_traverse_shares return void
      LOCKD: nlmsvc_traverse_blocks return is unused
      SUNRPC,RPCSEC_GSS: fix krb5 sequence numbers.
      NFSv4: Dont list system.nfs4_acl for filesystems that don't support it.
      SUNRPC,RPCSEC_GSS: remove unnecessary kmalloc of a checksum
      SUNRPC: Ensure rpc_call_async() always calls tk_ops->rpc_release()
      SUNRPC: Fix memory barriers for req->rq_received
      NFS: Fix a race in nfs_sync_inode()
      NFS: Clean up nfs_flush_list()
      NFS: Fix a race with PG_private and nfs_release_page()
      NFSv4: Ensure the callback daemon flushes signals
      SUNRPC: Fix a 'Busy inodes' error in rpc_pipefs
      NFS, NLM: Allow blocking locks to respect signals
      NFS: Make nfs_fhget() return appropriate error values
      NFSv4: Fix an oops in nfs4_fill_super
      lockd: blocks should hold a reference to the nlm_file
      NFSv4: SETCLIENTID_CONFIRM should handle NFS4ERR_DELAY/NFS4ERR_RESOURCE
      NFSv4: Send the delegation stateid for SETATTR calls
      ...

commit b500531e6f5f234ed267bd7060ee06d144faf0ca
Author: Oleg Drokin <green@linuxhacker.ru>
Date:   Sat Mar 25 03:07:01 2006 -0800

    [PATCH] Introduce FMODE_EXEC file flag
    
    Introduce FMODE_EXEC file flag, to indicate that file is being opened for
    execution.  This is useful for distributed filesystems to maintain
    consistent behavior for returning ETXTBUSY when opening for write and
    execution happens on different nodes.
    
    akpm:
    
      Needed by Lustre at present.  I assume their objective to to work towards
      being able to install Lustre on an unmodified distro kernel, which seems
      sane.  It should have zero runtime cost.
    
      Trond and Chuck indicate that NFS4 can probably use this too, for the same
      thing.
    
      Steven says it's also on the GFS todo list.
    
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Cc: Chuck Lever <cel@citi.umich.edu>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7c750312261b..21e8cf795c38 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -65,6 +65,11 @@ extern int dir_notify_enable;
 #define FMODE_PREAD	8
 #define FMODE_PWRITE	FMODE_PREAD	/* These go hand in hand */
 
+/* File is being opened for execution. Primary users of this flag are
+   distributed filesystems that can use it to achieve correct ETXTBUSY
+   behavior for cross-node execution/opening_for_writing of files */
+#define FMODE_EXEC	16
+
 #define RW_MASK		1
 #define RWA_MASK	2
 #define READ 0

commit bdfc326614b90e7bc47ee4a8fed05988555f0169
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Mar 25 03:06:56 2006 -0800

    [PATCH] fs/inode.c: make iprune_mutex static
    
    There's no reason for iprune_mutex being global.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 215696a0f16f..7c750312261b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1558,7 +1558,6 @@ extern void destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
 extern int remove_suid(struct dentry *);
 extern void remove_dquot_ref(struct super_block *, int, struct list_head *);
-extern struct mutex iprune_mutex;
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 extern void remove_inode_hash(struct inode *);

commit 18e79b40ed9c5223b88771f805c69f5993fc131b
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Mar 24 03:18:14 2006 -0800

    [PATCH] fsync: extract internal code
    
    Pull the guts out of do_fsync() - we can use it elsewhere.
    
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 092cfaee0cd2..215696a0f16f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1478,6 +1478,7 @@ extern int wait_on_page_writeback_range(struct address_space *mapping,
 extern int __filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end, int sync_mode);
 
+extern long do_fsync(struct file *file, int datasync);
 extern void sync_supers(void);
 extern void sync_filesystems(int wait);
 extern void emergency_sync(void);

commit 4741c9fd36b3bcadd37238321c469049da94a4b9
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Mar 24 03:18:11 2006 -0800

    [PATCH] set_page_dirty() return value fixes
    
    We need set_page_dirty() to return true if it actually transitioned the page
    from a clean to dirty state.  This wasn't right in a couple of places.  Do a
    kernel-wide audit, fix things up.
    
    This leaves open the possibility of returning a negative errno from
    set_page_dirty() sometime in the future.  But we don't do that at present.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0ad70c1e5e55..092cfaee0cd2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -350,7 +350,7 @@ struct address_space_operations {
 	/* Write back some dirty pages from this mapping. */
 	int (*writepages)(struct address_space *, struct writeback_control *);
 
-	/* Set a page dirty */
+	/* Set a page dirty.  Return true if this dirtied it */
 	int (*set_page_dirty)(struct page *page);
 
 	int (*readpages)(struct file *filp, struct address_space *mapping,

commit ebcf28e1c7a295f3321249dd235ad2e45938fdd9
Author: Andrew Morton <akpm@osdl.org>
Date:   Fri Mar 24 03:18:04 2006 -0800

    [PATCH] fadvise(): write commands
    
    Add two new linux-specific fadvise extensions():
    
    LINUX_FADV_ASYNC_WRITE: start async writeout of any dirty pages between file
    offsets `offset' and `offset+len'.  Any pages which are currently under
    writeout are skipped, whether or not they are dirty.
    
    LINUX_FADV_WRITE_WAIT: wait upon writeout of any dirty pages between file
    offsets `offset' and `offset+len'.
    
    By combining these two operations the application may do several things:
    
    LINUX_FADV_ASYNC_WRITE: push some or all of the dirty pages at the disk.
    
    LINUX_FADV_WRITE_WAIT, LINUX_FADV_ASYNC_WRITE: push all of the currently dirty
    pages at the disk.
    
    LINUX_FADV_WRITE_WAIT, LINUX_FADV_ASYNC_WRITE, LINUX_FADV_WRITE_WAIT: push all
    of the currently dirty pages at the disk, wait until they have been written.
    
    It should be noted that none of these operations write out the file's
    metadata.  So unless the application is strictly performing overwrites of
    already-instantiated disk blocks, there are no guarantees here that the data
    will be available after a crash.
    
    To complete this suite of operations I guess we should have a "sync file
    metadata only" operation.  This gives applications access to all the building
    blocks needed for all sorts of sync operations.  But sync-metadata doesn't fit
    well with the fadvise() interface.  Probably it should be a new syscall:
    sys_fmetadatasync().
    
    The patch also diddles with the meaning of `endbyte' in sys_fadvise64_64().
    It is made to represent that last affected byte in the file (ie: it is
    inclusive).  Generally, all these byterange and pagerange functions are
    inclusive so we can easily represent EOF with -1.
    
    As Ulrich notes, these two functions are somewhat abusive of the fadvise()
    concept, which appears to be "set the future policy for this fd".
    
    But these commands are a perfect fit with the fadvise() impementation, and
    several of the existing fadvise() commands are synchronous and don't affect
    future policy either.   I think we can live with the slight incongruity.
    
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 65e6df247ea5..0ad70c1e5e55 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1473,6 +1473,11 @@ extern int filemap_fdatawait(struct address_space *);
 extern int filemap_write_and_wait(struct address_space *mapping);
 extern int filemap_write_and_wait_range(struct address_space *mapping,
 				        loff_t lstart, loff_t lend);
+extern int wait_on_page_writeback_range(struct address_space *mapping,
+				pgoff_t start, pgoff_t end);
+extern int __filemap_fdatawrite_range(struct address_space *mapping,
+				loff_t start, loff_t end, int sync_mode);
+
 extern void sync_supers(void);
 extern void sync_filesystems(int wait);
 extern void emergency_sync(void);

commit 9b04c997b1120feefa1e6ee8e2902270bc055cd2
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Fri Mar 24 03:15:10 2006 -0800

    [PATCH] vfs: MS_VERBOSE should be MS_SILENT
    
    The meaning of MS_VERBOSE is backwards; if the bit is set, it really means,
    "don't be verbose".  This is confusing and counter-intuitive.
    
    In addition, there is also no way to set the MS_VERBOSE flag in the
    mount(8) program in util-linux, but interesting, it does define options
    which would do the right thing if MS_SILENT were defined, which
    unfortunately we do not:
    
    #ifdef MS_SILENT
      { "quiet",    0, 0, MS_SILENT    },   /* be quiet  */
      { "loud",     0, 1, MS_SILENT    },   /* print out messages. */
    #endif
    
    So the obvious fix is to deprecate the use of MS_VERBOSE and replace it
    with MS_SILENT.
    
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9b34a1b03455..65e6df247ea5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -103,7 +103,9 @@ extern int dir_notify_enable;
 #define MS_BIND		4096
 #define MS_MOVE		8192
 #define MS_REC		16384
-#define MS_VERBOSE	32768
+#define MS_VERBOSE	32768	/* War is peace. Verbosity is silence.
+				   MS_VERBOSE is deprecated. */
+#define MS_SILENT	32768
 #define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
 #define MS_PRIVATE	(1<<18)	/* change to private */

commit 1ebbe2b20091d306453a5cf480a87e6cd28ae76f
Merge: ac58c9059da8 674a396c6d2b
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Thu Mar 23 23:44:19 2006 -0500

    Merge branch 'linus'

commit 2056a782f8e7e65fd4bfd027506b4ce1c5e9ccd4
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Mar 23 20:00:26 2006 +0100

    [PATCH] Block queue IO tracing support (blktrace) as of 2006-03-23
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f9c9dea636d0..9b34a1b03455 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -197,6 +197,10 @@ extern int dir_notify_enable;
 #define BLKBSZGET  _IOR(0x12,112,size_t)
 #define BLKBSZSET  _IOW(0x12,113,size_t)
 #define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
+#define BLKTRACESETUP _IOWR(0x12,115,struct blk_user_trace_setup)
+#define BLKTRACESTART _IO(0x12,116)
+#define BLKTRACESTOP _IO(0x12,117)
+#define BLKTRACETEARDOWN _IO(0x12,118)
 
 #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
 #define FIBMAP	   _IO(0x00,1)	/* bmap access */

commit 66d2173053f64121f8dc69a1cf85972e37e1ee75
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Mar 23 03:00:51 2006 -0800

    [PATCH] Extract inode_inc_link_count(), inode_dec_link_count()
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8fd8d9b90b00..f9c9dea636d0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1115,6 +1115,18 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
 	__mark_inode_dirty(inode, I_DIRTY_SYNC);
 }
 
+static inline void inode_inc_link_count(struct inode *inode)
+{
+	inode->i_nlink++;
+	mark_inode_dirty(inode);
+}
+
+static inline void inode_dec_link_count(struct inode *inode)
+{
+	inode->i_nlink--;
+	mark_inode_dirty(inode);
+}
+
 extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {

commit f24075bd0c1cd1cc2cf86d394f960aa0401de573
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 23 03:00:34 2006 -0800

    [PATCH] sem2mutex: iprune
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0f71ee730127..8fd8d9b90b00 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1534,7 +1534,7 @@ extern void destroy_inode(struct inode *);
 extern struct inode *new_inode(struct super_block *);
 extern int remove_suid(struct dentry *);
 extern void remove_dquot_ref(struct super_block *, int, struct list_head *);
-extern struct semaphore iprune_sem;
+extern struct mutex iprune_mutex;
 
 extern void __insert_inode_hash(struct inode *, unsigned long hashval);
 extern void remove_inode_hash(struct inode *);

commit a11f3a0574a5734db3e5de38922430d005d35118
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Thu Mar 23 03:00:33 2006 -0800

    [PATCH] sem2mutex: vfs_rename_mutex
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9ed1f36b6d54..0f71ee730127 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -847,7 +847,7 @@ struct super_block {
 	 * The next field is for VFS *only*. No filesystems have any business
 	 * even looking at it. You had been warned.
 	 */
-	struct semaphore s_vfs_rename_sem;	/* Kludge */
+	struct mutex s_vfs_rename_mutex;	/* Kludge */
 
 	/* Granuality of c/m/atime in ns.
 	   Cannot be worse than a second */

commit d4f9af9dac4ecb75818f909168f87b441cc95653
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Mar 23 03:00:30 2006 -0800

    [PATCH] sem2mutex: inotify
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: John McCutchan <ttb@tentacle.dhs.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Acked-by: Robert Love <rml@novell.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 009ac96053fe..9ed1f36b6d54 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -509,7 +509,7 @@ struct inode {
 
 #ifdef CONFIG_INOTIFY
 	struct list_head	inotify_watches; /* watches on this inode */
-	struct semaphore	inotify_sem;	/* protects the watches list */
+	struct mutex		inotify_mutex;	/* protects the watches list */
 #endif
 
 	unsigned long		i_state;

commit c039e3134ae62863bbc8e8429b29e3c43cf21b2a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Thu Mar 23 03:00:28 2006 -0800

    [PATCH] sem2mutex: blockdev #2
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 128d0082522c..009ac96053fe 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -397,8 +397,8 @@ struct block_device {
 	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
 	struct inode *		bd_inode;	/* will die */
 	int			bd_openers;
-	struct semaphore	bd_sem;	/* open/close mutex */
-	struct semaphore	bd_mount_sem;	/* mount mutex */
+	struct mutex		bd_mutex;	/* open/close mutex */
+	struct mutex		bd_mount_mutex;	/* mount mutex */
 	struct list_head	bd_inodes;
 	void *			bd_holder;
 	int			bd_holders;

commit 26bcbf965f857c710adafd16cf424f043006b5dd
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Mar 20 13:44:40 2006 -0500

    lockd: stop abusing file_lock_list
    
    Currently lockd directly access the file_lock_list from fs/locks.c.
    It does so to mark locks granted or reclaimable.  This is very
    suboptimal, because a) lockd needs to poke into locks.c internals, and
    b) it needs to iterate over all locks in the system for marking locks
    granted or reclaimable.
    
    This patch adds lists for granted and reclaimable locks to the nlm_host
    structure instead, and adds locks to those.
    
    nlmclnt_lock:
            now adds the lock to h_granted instead of setting the
            NFS_LCK_GRANTED, still O(1)
    
    nlmclnt_mark_reclaim:
            goes away completely, replaced by a list_splice_init.
            Complexity reduced from O(locks in the system) to O(1)
    
    reclaimer:
            iterates over h_reclaim now, complexity reduced from
            O(locks in the system) to O(locks per nlm_host)
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d2cffee8fc11..5dc0fa288a4c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -730,8 +730,6 @@ struct file_lock {
 #define OFFT_OFFSET_MAX	INT_LIMIT(off_t)
 #endif
 
-extern struct list_head file_lock_list;
-
 #include <linux/fcntl.h>
 
 extern int fcntl_getlk(struct file *, struct flock __user *);

commit 7117bf3dfb10b534a017260d9fc643bc1d0afd2a
Author: J. Bruce Fields <bfields@fieldses.org>
Date:   Mon Mar 20 13:44:26 2006 -0500

    lockd: Remove FL_LOCKD flag
    
    Currently lockd identifies its own locks using the FL_LOCKD flag.  This
    doesn't scale well to multiple lock managers--if we did this in nfsv4 too,
    for example, we'd be left with only one free flag bit.
    
    Instead, we just check whether the file manager ops (fl_lmops) set on this
    lock are our own.
    
    The only use for this is in nlm_traverse_locks, which uses it to find locks
    that need cleaning up when freeing a host or a file.
    
    In the long run it might be nice to do reference counting instead of
    traversing all the locks like this....
    
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8ef4dd788a83..d2cffee8fc11 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -667,7 +667,6 @@ extern spinlock_t files_lock;
 #define FL_POSIX	1
 #define FL_FLOCK	2
 #define FL_ACCESS	8	/* not trying to lock, just looking */
-#define FL_LOCKD	16	/* lock held by rpc.lockd */
 #define FL_LEASE	32	/* lease held on this file */
 #define FL_SLEEP	128	/* A blocking lock */
 

commit 8dc7c3115b611c00006eac3ee5b108296432aab7
Author: Andy Adamson <andros@citi.umich.edu>
Date:   Mon Mar 20 13:44:26 2006 -0500

    locks,lockd: fix race in nlmsvc_testlock
    
    posix_test_lock() returns a pointer to a struct file_lock which is unprotected
    and can be removed while in use by the caller.  Move the conflicting lock from
    the return to a parameter, and copy the conflicting lock.
    
    In most cases the caller ends up putting the copy of the conflicting lock on
    the stack.  On i386, sizeof(struct file_lock) appears to be about 100 bytes.
    We're assuming that's reasonable.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b01482c721ae..8ef4dd788a83 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -754,7 +754,7 @@ extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
-extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
+extern int posix_test_lock(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);

commit 2e0af86f618c697b44e2d67dff151256c58201c4
Author: Andy Adamson <andros@citi.umich.edu>
Date:   Mon Mar 20 13:44:26 2006 -0500

    locks: remove unused posix_block_lock
    
    posix_lock_file() is used to add a blocked lock to Lockd's block, so
    posix_block_lock() is no longer needed.
    
    Signed-off-by: Andy Adamson <andros@citi.umich.edu>
    Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index be21e860a9f2..b01482c721ae 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -757,7 +757,6 @@ extern void locks_remove_flock(struct file *);
 extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
-extern void posix_block_lock(struct file_lock *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
 extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);

commit b4629fe2f094b719847f31be1ee5ab38300038b2
Author: Chuck Lever <cel@netapp.com>
Date:   Mon Mar 20 13:44:12 2006 -0500

    VFS: New /proc file /proc/self/mountstats
    
    Create a new file under /proc/self, called mountstats, where mounted file
    systems can export information (configuration options, performance counters,
    and so on).  Use a mechanism similar to /proc/mounts and s_ops->show_options.
    
    This mechanism does not violate namespace security, and is safe to use while
    other processes are unmounting file systems.
    
    Thanks to Mike Waychison for his review and comments.
    
    Test-plan:
    Test concurrent mount/unmount operations while cat'ing /proc/self/mountstats.
    
    Signed-off-by: Chuck Lever <cel@netapp.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 128d0082522c..be21e860a9f2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1086,6 +1086,7 @@ struct super_operations {
 	void (*umount_begin) (struct super_block *);
 
 	int (*show_options)(struct seq_file *, struct vfsmount *);
+	int (*show_stats)(struct seq_file *, struct vfsmount *);
 
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);

commit 0adb25d2e71ab047423d6fc63d5d184590d0a66f
Author: Kirill Korotaev <dev@openvz.org>
Date:   Sat Mar 11 03:27:13 2006 -0800

    [PATCH] ext3: ext3_symlink should use GFP_NOFS allocations inside
    
    This patch fixes illegal __GFP_FS allocation inside ext3 transaction in
    ext3_symlink().  Such allocation may re-enter ext3 code from
    try_to_free_pages.  But JBD/ext3 code keeps a pointer to current journal
    handle in task_struct and, hence, is not reentrable.
    
    This bug led to "Assertion failure in journal_dirty_metadata()" messages.
    
    http://bugzilla.openvz.org/show_bug.cgi?id=115
    
    Signed-off-by: Andrey Savochkin <saw@saw.sw.com.sg>
    Signed-off-by: Kirill Korotaev <dev@openvz.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 51c0c93bdf93..128d0082522c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1664,6 +1664,8 @@ extern int vfs_follow_link(struct nameidata *, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
 extern void *page_follow_link_light(struct dentry *, struct nameidata *);
 extern void page_put_link(struct dentry *, struct nameidata *, void *);
+extern int __page_symlink(struct inode *inode, const char *symname, int len,
+		gfp_t gfp_mask);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);

commit 529bf6be5c04f2e869d07bfdb122e9fd98ade714
Author: Dipankar Sarma <dipankar@in.ibm.com>
Date:   Tue Mar 7 21:55:35 2006 -0800

    [PATCH] fix file counting
    
    I have benchmarked this on an x86_64 NUMA system and see no significant
    performance difference on kernbench.  Tested on both x86_64 and powerpc.
    
    The way we do file struct accounting is not very suitable for batched
    freeing.  For scalability reasons, file accounting was
    constructor/destructor based.  This meant that nr_files was decremented
    only when the object was removed from the slab cache.  This is susceptible
    to slab fragmentation.  With RCU based file structure, consequent batched
    freeing and a test program like Serge's, we just speed this up and end up
    with a very fragmented slab -
    
    llm22:~ # cat /proc/sys/fs/file-nr
    587730  0       758844
    
    At the same time, I see only a 2000+ objects in filp cache.  The following
    patch I fixes this problem.
    
    This patch changes the file counting by removing the filp_count_lock.
    Instead we use a separate percpu counter, nr_files, for now and all
    accesses to it are through get_nr_files() api.  In the sysctl handler for
    nr_files, we populate files_stat.nr_files before returning to user.
    
    Counting files as an when they are created and destroyed (as opposed to
    inside slab) allows us to correctly count open files with RCU.
    
    Signed-off-by: Dipankar Sarma <dipankar@in.ibm.com>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0cc34b1c42c9..51c0c93bdf93 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -35,6 +35,7 @@ struct files_stat_struct {
 	int max_files;		/* tunable */
 };
 extern struct files_stat_struct files_stat;
+extern int get_max_files(void);
 
 struct inodes_stat_t {
 	int nr_inodes;

commit a19cbd4bf258840ade3b6ee9e9256006d0644e09
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Mar 8 14:03:09 2006 -0800

    Mark the pipe file operations static
    
    They aren't used (nor even really usable) outside of pipe.c anyway
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e059da947007..0cc34b1c42c9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1418,9 +1418,6 @@ extern int is_bad_inode(struct inode *);
 extern struct file_operations read_fifo_fops;
 extern struct file_operations write_fifo_fops;
 extern struct file_operations rdwr_fifo_fops;
-extern struct file_operations read_pipe_fops;
-extern struct file_operations write_pipe_fops;
-extern struct file_operations rdwr_pipe_fops;
 
 extern int fs_may_remount_ro(struct super_block *);
 

commit e965f9630c651fa4249039fd4b80c9392d07a856
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Feb 1 03:05:41 2006 -0800

    [PATCH] Direct Migration V9: Avoid writeback / page_migrate() method
    
    Migrate a page with buffers without requiring writeback
    
    This introduces a new address space operation migratepage() that may be used
    by a filesystem to implement its own version of page migration.
    
    A version is provided that migrates buffers attached to pages.  Some
    filesystems (ext2, ext3, xfs) are modified to utilize this feature.
    
    The swapper address space operation are modified so that a regular
    migrate_page() will occur for anonymous pages without writeback (migrate_pages
    forces every anonymous page to have a swap entry).
    
    Signed-off-by: Mike Kravetz <kravetz@us.ibm.com>
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 84bb449b9b01..e059da947007 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -363,6 +363,8 @@ struct address_space_operations {
 			loff_t offset, unsigned long nr_segs);
 	struct page* (*get_xip_page)(struct address_space *, sector_t,
 			int);
+	/* migrate the contents of a page to the specified target */
+	int (*migratepage) (struct page *, struct page *);
 };
 
 struct backing_dev_info;
@@ -1719,6 +1721,12 @@ extern void simple_release_fs(struct vfsmount **mount, int *count);
 
 extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const void *, size_t);
 
+#ifdef CONFIG_MIGRATION
+extern int buffer_migrate_page(struct page *, struct page *);
+#else
+#define buffer_migrate_page NULL
+#endif
+
 extern int inode_change_ok(struct inode *, struct iattr *);
 extern int __must_check inode_setattr(struct inode *, struct iattr *);
 

commit 5590ff0d5528b60153c0b4e7b771472b5a95e297
Author: Ulrich Drepper <drepper@redhat.com>
Date:   Wed Jan 18 17:43:53 2006 -0800

    [PATCH] vfs: *at functions: core
    
    Here is a series of patches which introduce in total 13 new system calls
    which take a file descriptor/filename pair instead of a single file
    name.  These functions, openat etc, have been discussed on numerous
    occasions.  They are needed to implement race-free filesystem traversal,
    they are necessary to implement a virtual per-thread current working
    directory (think multi-threaded backup software), etc.
    
    We have in glibc today implementations of the interfaces which use the
    /proc/self/fd magic.  But this code is rather expensive.  Here are some
    results (similar to what Jim Meyering posted before).
    
    The test creates a deep directory hierarchy on a tmpfs filesystem.  Then
    rm -fr is used to remove all directories.  Without syscall support I get
    this:
    
    real    0m31.921s
    user    0m0.688s
    sys     0m31.234s
    
    With syscall support the results are much better:
    
    real    0m20.699s
    user    0m0.536s
    sys     0m20.149s
    
    The interfaces are for obvious reasons currently not much used.  But they'll
    be used.  coreutils (and Jeff's posixutils) are already using them.
    Furthermore, code like ftw/fts in libc (maybe even glob) will also start using
    them.  I expect a patch to make follow soon.  Every program which is walking
    the filesystem tree will benefit.
    
    Signed-off-by: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index b77f2608eef9..84bb449b9b01 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1340,7 +1340,8 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 
 extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
 		       struct file *filp);
-extern long do_sys_open(const char __user *filename, int flags, int mode);
+extern long do_sys_open(int fdf, const char __user *filename, int flags,
+			int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
 extern int filp_close(struct file *, fl_owner_t id);
@@ -1479,7 +1480,7 @@ static inline void allow_write_access(struct file *file)
 }
 extern int do_pipe(int *);
 
-extern int open_namei(const char *, int, int, struct nameidata *);
+extern int open_namei(int dfd, const char *, int, int, struct nameidata *);
 extern int may_open(struct nameidata *, int, int);
 
 extern int kernel_read(struct file *, unsigned long, char *, unsigned long);
@@ -1677,6 +1678,8 @@ extern int vfs_readdir(struct file *, filldir_t, void *);
 
 extern int vfs_stat(char __user *, struct kstat *);
 extern int vfs_lstat(char __user *, struct kstat *);
+extern int vfs_stat_fd(int dfd, char __user *, struct kstat *);
+extern int vfs_lstat_fd(int dfd, char __user *, struct kstat *);
 extern int vfs_fstat(unsigned int, struct kstat *);
 
 extern int vfs_ioctl(struct file *, unsigned int, unsigned int, unsigned long);

commit f87fd4c2a0c4f3baad28057360b36a59591ef751
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Jan 16 22:14:23 2006 -0800

    [PATCH] add /sys/fs
    
    This patch adds an empty /sys/fs, which filesystems can use.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 552cedfa6064..b77f2608eef9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1290,6 +1290,9 @@ extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
 
 extern int vfs_statfs(struct super_block *, struct kstatfs *);
 
+/* /sys/fs */
+extern struct subsystem fs_subsys;
+
 #define FLOCK_VERIFY_READ  1
 #define FLOCK_VERIFY_WRITE 2
 

commit 7170be5f586b59bdcdab082778a5d9203ba7b667
Author: Neil Horman <nhorman@redhat.com>
Date:   Sat Jan 14 13:20:38 2006 -0800

    [PATCH] convert /proc/devices to use seq_file interface
    
    A Christoph suggested that the /proc/devices file be converted to use the
    seq_file interface.  This patch does that.
    
    I've obxerved one or two installation that had sufficiently large sans that
    they overran the 4k limit on /proc/devices.
    
    Signed-off-by: Neil Horman <nhorman@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index d1e370d25f7b..552cedfa6064 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1383,6 +1383,12 @@ extern int register_chrdev(unsigned int, const char *,
 extern int unregister_chrdev(unsigned int, const char *);
 extern void unregister_chrdev_region(dev_t, unsigned);
 extern int chrdev_open(struct inode *, struct file *);
+extern int get_chrdev_list(char *);
+extern void *acquire_chrdev_list(void);
+extern int count_chrdev_list(void);
+extern void *get_next_chrdev(void *);
+extern int get_chrdev_info(void *, int *, char **);
+extern void release_chrdev_list(void *);
 
 /* fs/block_dev.c */
 #define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
@@ -1391,6 +1397,11 @@ extern const char *bdevname(struct block_device *bdev, char *buffer);
 extern struct block_device *lookup_bdev(const char *);
 extern struct block_device *open_bdev_excl(const char *, int, void *);
 extern void close_bdev_excl(struct block_device *);
+extern void *acquire_blkdev_list(void);
+extern int count_blkdev_list(void);
+extern void *get_next_blkdev(void *);
+extern int get_blkdev_info(void *, int *, char **);
+extern void release_blkdev_list(void *);
 
 extern void init_special_inode(struct inode *, umode_t, dev_t);
 

commit fc33a7bb9c6dd8f6e4a014976200f8fdabb3a45c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 9 20:52:17 2006 -0800

    [PATCH] per-mountpoint noatime/nodiratime
    
    Turn noatime and nodiratime into per-mount instead of per-sb flags.
    
    After all the preparations this is a rather trivial patch.  The mount code
    needs to treat the two options as per-mount instead of per-superblock, and
    touch_atime needs to be changed to check the new MNT_ flags in addition to
    the MS_ flags that are kept for filesystems that are always
    noatime/nodiratime but not user settable anymore.  Besides that core code
    only nfs needed an update because it's leaving atime updates to the server
    and thus sets the S_NOATIME flag on every inode, but needs to know whether
    it's a real noatime mount for an getattr optimization.
    
    While we're at it I've killed the IS_NOATIME/IS_NODIRATIME macros that were
    only used by touch_atime.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 85c5656756b6..d1e370d25f7b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -114,8 +114,7 @@ extern int dir_notify_enable;
 /*
  * Superblock flags that can be altered by MS_REMOUNT
  */
-#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_NOATIME|\
-			 MS_NODIRATIME)
+#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK)
 
 /*
  * Old magic mount flag and mask
@@ -161,8 +160,6 @@ extern int dir_notify_enable;
 #define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
 #define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
 #define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
-#define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
-#define IS_NODIRATIME(inode)	__IS_FLG(inode, MS_NODIRATIME)
 #define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
 
 #define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)

commit 869243a0f6143f76e7c847e707eee6ece9cbf821
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 9 20:52:03 2006 -0800

    [PATCH] remove update_atime
    
    All callers use touch_atime now which takes a vfsmount and allows us to
    implement per-mount noatime.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1feee2e7e47b..85c5656756b6 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -235,9 +235,6 @@ struct kstatfs;
 struct vm_area_struct;
 struct vfsmount;
 
-/* Used to be a macro which just called the function, now just a function */
-extern void update_atime (struct inode *);
-
 extern void __init inode_init(unsigned long);
 extern void __init inode_init_early(void);
 extern void __init mnt_init(unsigned long);
@@ -1118,12 +1115,7 @@ static inline void mark_inode_dirty_sync(struct inode *inode)
 	__mark_inode_dirty(inode, I_DIRTY_SYNC);
 }
 
-static inline void touch_atime(struct vfsmount *mnt, struct dentry *dentry)
-{
-	/* per-mountpoint checks will go here */
-	update_atime(dentry->d_inode);
-}
-
+extern void touch_atime(struct vfsmount *mnt, struct dentry *dentry);
 static inline void file_accessed(struct file *file)
 {
 	if (!(file->f_flags & O_NOATIME))

commit 870f481793b585323fbda3e87c54efc116f46351
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 9 20:52:01 2006 -0800

    [PATCH] replace inode_update_time with file_update_time
    
    To allow various options to work per-mount instead of per-sb we need a
    struct vfsmount when updating ctime and mtime.  This preparation patch
    replaces the inode_update_time routine with a file_update_atime routine so
    we can easily get at the vfsmount.  (and the file makes more sense in this
    context anyway).  Also get rid of the unused second argument - we always
    want to update the ctime when calling this routine.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Al Viro <viro@ftp.linux.org.uk>
    Cc: Anton Altaparmakov <aia21@cantab.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 92ae3e2067b0..1feee2e7e47b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1716,7 +1716,7 @@ extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const vo
 extern int inode_change_ok(struct inode *, struct iattr *);
 extern int __must_check inode_setattr(struct inode *, struct iattr *);
 
-extern void inode_update_time(struct inode *inode, int ctime_too);
+extern void file_update_time(struct file *file);
 
 static inline ino_t parent_ino(struct dentry *dentry)
 {

commit 7892f2f48d165a34b0b8130c8a195dfd807b8cb6
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jan 9 15:59:25 2006 -0800

    [PATCH] mutex subsystem, semaphore to mutex: VFS, sb->s_lock
    
    This patch converts the superblock-lock semaphore to a mutex, affecting
    lock_super()/unlock_super(). Tested on ext3 and XFS.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 01654b218e42..92ae3e2067b0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -821,7 +821,7 @@ struct super_block {
 	unsigned long		s_magic;
 	struct dentry		*s_root;
 	struct rw_semaphore	s_umount;
-	struct semaphore	s_lock;
+	struct mutex		s_lock;
 	int			s_count;
 	int			s_syncing;
 	int			s_need_sync_fs;
@@ -893,13 +893,13 @@ static inline int has_fs_excl(void)
 static inline void lock_super(struct super_block * sb)
 {
 	get_fs_excl();
-	down(&sb->s_lock);
+	mutex_lock(&sb->s_lock);
 }
 
 static inline void unlock_super(struct super_block * sb)
 {
 	put_fs_excl();
-	up(&sb->s_lock);
+	mutex_unlock(&sb->s_lock);
 }
 
 /*

commit 1b1dcc1b57a49136f118a0f16367256ff9994a69
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 9 15:59:24 2006 -0800

    [PATCH] mutex subsystem, semaphore to mutex: VFS, ->i_sem
    
    This patch converts the inode semaphore to a mutex. I have tested it on
    XFS and compiled as much as one can consider on an ia64. Anyway your
    luck with it might be different.
    
    Modified-by: Ingo Molnar <mingo@elte.hu>
    
    (finished the conversion)
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4c82219b0fae..01654b218e42 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -219,6 +219,7 @@ extern int dir_notify_enable;
 #include <linux/prio_tree.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/mutex.h>
 
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
@@ -484,7 +485,7 @@ struct inode {
 	unsigned long		i_blocks;
 	unsigned short          i_bytes;
 	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
-	struct semaphore	i_sem;
+	struct mutex		i_mutex;
 	struct rw_semaphore	i_alloc_sem;
 	struct inode_operations	*i_op;
 	struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
@@ -1191,7 +1192,7 @@ int sync_inode(struct inode *inode, struct writeback_control *wbc);
  *    directory.  The name should be stored in the @name (with the
  *    understanding that it is already pointing to a a %NAME_MAX+1 sized
  *    buffer.   get_name() should return %0 on success, a negative error code
- *    or error.  @get_name will be called without @parent->i_sem held.
+ *    or error.  @get_name will be called without @parent->i_mutex held.
  *
  * get_parent:
  *    @get_parent should find the parent directory for the given @child which
@@ -1213,7 +1214,7 @@ int sync_inode(struct inode *inode, struct writeback_control *wbc);
  *    nfsd_find_fh_dentry() in either the @obj or @parent parameters.
  *
  * Locking rules:
- *    get_parent is called with child->d_inode->i_sem down
+ *    get_parent is called with child->d_inode->i_mutex down
  *    get_name is not (which is possibly inconsistent)
  */
 

commit e78c9a004aadebe22306c81d1a7f1d1278dc37f9
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Sun Jan 8 01:03:39 2006 -0800

    [PATCH] fs: remove s_old_blocksize from struct super_block
    
    This patch inlines the single user of struct super_block field
    s_old_blocksize and removes the field.
    
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index a1e28f0895c0..4c82219b0fae 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -808,7 +808,6 @@ struct super_block {
 	struct list_head	s_list;		/* Keep this first */
 	dev_t			s_dev;		/* search index; _not_ kdev_t */
 	unsigned long		s_blocksize;
-	unsigned long		s_old_blocksize;
 	unsigned char		s_blocksize_bits;
 	unsigned char		s_dirt;
 	unsigned long long	s_maxbytes;	/* Max file size */

commit bf066c7db775a04bd761f8ea206f5522d0cf40ff
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Sun Jan 8 01:03:19 2006 -0800

    [PATCH] shared mounts: cleanup
    
    Small cleanups in shared mounts code.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Ram Pai <linuxram@us.ibm.com>
    Cc: <viro@parcelfarce.linux.theplanet.co.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7f140480c6a8..a1e28f0895c0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -103,11 +103,11 @@ extern int dir_notify_enable;
 #define MS_MOVE		8192
 #define MS_REC		16384
 #define MS_VERBOSE	32768
+#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
 #define MS_PRIVATE	(1<<18)	/* change to private */
 #define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */
-#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)
 

commit a885c8c4316e1c1d2d2c8755da3f3d14f852528d
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jan 8 01:02:50 2006 -0800

    [PATCH] Add block_device_operations.getgeo block device method
    
    HDIO_GETGEO is implemented in most block drivers, and all of them have to
    duplicate the code to copy the structure to userspace, as well as getting
    the start sector.  This patch moves that to common code [1] and adds a
    ->getgeo method to fill out the raw kernel hd_geometry structure.  For many
    drivers this means ->ioctl can go away now.
    
    [1] the s390 block drivers are odd in this respect.  xpram sets ->start
        to 4 always which seems more than odd, and the dasd driver shifts
        the start offset around, probably because of it's non-standard
        sector size.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: <mike.miller@hp.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo Giarrusso <blaisorblade@yahoo.it>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Markus Lidel <Markus.Lidel@shadowconnect.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 74c01aabd4ab..7f140480c6a8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -224,6 +224,7 @@ extern int dir_notify_enable;
 #include <asm/semaphore.h>
 #include <asm/byteorder.h>
 
+struct hd_geometry;
 struct iovec;
 struct nameidata;
 struct kiocb;
@@ -962,6 +963,7 @@ struct block_device_operations {
 	int (*direct_access) (struct block_device *, sector_t, unsigned long *);
 	int (*media_changed) (struct gendisk *);
 	int (*revalidate_disk) (struct gendisk *);
+	int (*getgeo)(struct block_device *, struct hd_geometry *);
 	struct module *owner;
 };
 

commit 4a30131e7dbb17e5fec6958bfac9da9aff1fa29b
Author: NeilBrown <neilb@suse.de>
Date:   Sun Jan 8 01:02:39 2006 -0800

    [PATCH] Fix some problems with truncate and mtime semantics.
    
    SUS requires that when truncating a file to the size that it currently
    is:
      truncate and ftruncate should NOT modify ctime or mtime
      O_TRUNC SHOULD modify ctime and mtime.
    
    Currently mtime and ctime are always modified on most local
    filesystems (side effect of ->truncate) or never modified (on NFS).
    
    With this patch:
      ATTR_CTIME|ATTR_MTIME are sent with ATTR_SIZE precisely when
        an update of these times is required whether size changes or not
        (via a new argument to do_truncate).  This allows NFS to do
        the right thing for O_TRUNC.
      inode_setattr nolonger forces ATTR_MTIME|ATTR_CTIME when the ATTR_SIZE
        sets the size to it's current value.  This allows local filesystems
        to do the right thing for f?truncate.
    
    Also, the logic in inode_setattr is changed a bit so there are two return
    points.  One returns the error from vmtruncate if it failed, the other
    returns 0 (there can be no other failure).
    
    Finally, if vmtruncate succeeds, and ATTR_SIZE is the only change
    requested, we now fall-through and mark_inode_dirty.  If a filesystem did
    not have a ->truncate function, then vmtruncate will have changed i_size,
    without marking the inode as 'dirty', and I think this is wrong.
    
    Signed-off-by: Neil Brown <neilb@suse.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ef29500b5df8..74c01aabd4ab 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1344,7 +1344,8 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 
 /* fs/open.c */
 
-extern int do_truncate(struct dentry *, loff_t start, struct file *filp);
+extern int do_truncate(struct dentry *, loff_t start, unsigned int time_attrs,
+		       struct file *filp);
 extern long do_sys_open(const char __user *filename, int flags, int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);

commit 095975da26dba21698582e91e96be10f7417333f
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Sun Jan 8 01:02:19 2006 -0800

    [PATCH] rcu file: use atomic primitives
    
    Use atomic_inc_not_zero for rcu files instead of special case rcuref.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: "Paul E. McKenney" <paulmck@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2c9c48d65630..ef29500b5df8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -9,7 +9,6 @@
 #include <linux/config.h>
 #include <linux/limits.h>
 #include <linux/ioctl.h>
-#include <linux/rcuref.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -653,7 +652,7 @@ extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
 #define file_list_unlock() spin_unlock(&files_lock);
 
-#define get_file(x)	rcuref_inc(&(x)->f_count)
+#define get_file(x)	atomic_inc(&(x)->f_count)
 #define file_count(x)	atomic_read(&(x)->f_count)
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)

commit 64a318ee2af9000df482d7a125c3b3e1f1007404
Author: J. Bruce Fields <bfields@fieldses.org>
Date:   Tue Jan 3 09:55:46 2006 +0100

    NLM: Further cancel fixes
    
     If the server receives an NLM cancel call and finds no waiting lock to
     cancel, then chances are the lock has already been applied, and the client
     just hadn't yet processed the NLM granted callback before it sent the
     cancel.
    
     The Open Group text, for example, perimts a server to return either success
     (LCK_GRANTED) or failure (LCK_DENIED) in this case.  But returning an error
     seems more helpful; the client may be able to use it to recognize that a
     race has occurred and to recover from the race.
    
     So, modify the relevant functions to return an error in this case.
    
     Signed-off-by: J. Bruce Fields <bfields@citi.umich.edu>
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 115e72be25d0..2c9c48d65630 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -760,7 +760,7 @@ extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern void posix_block_lock(struct file_lock *, struct file_lock *);
-extern void posix_unblock_lock(struct file *, struct file_lock *);
+extern int posix_unblock_lock(struct file *, struct file_lock *);
 extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);

commit f6b3ec238d12c8cc6cc71490c6e3127988460349
Author: Badari Pulavarty <pbadari@us.ibm.com>
Date:   Fri Jan 6 00:10:38 2006 -0800

    [PATCH] madvise(MADV_REMOVE): remove pages from tmpfs shm backing store
    
    Here is the patch to implement madvise(MADV_REMOVE) - which frees up a
    given range of pages & its associated backing store.  Current
    implementation supports only shmfs/tmpfs and other filesystems return
    -ENOSYS.
    
    "Some app allocates large tmpfs files, then when some task quits and some
    client disconnect, some memory can be released.  However the only way to
    release tmpfs-swap is to MADV_REMOVE". - Andrea Arcangeli
    
    Databases want to use this feature to drop a section of their bufferpool
    (shared memory segments) - without writing back to disk/swap space.
    
    This feature is also useful for supporting hot-plug memory on UML.
    
    Concerns raised by Andrew Morton:
    
    - "We have no plan for holepunching!  If we _do_ have such a plan (or
      might in the future) then what would the API look like?  I think
      sys_holepunch(fd, start, len), so we should start out with that."
    
    - Using madvise is very weird, because people will ask "why do I need to
      mmap my file before I can stick a hole in it?"
    
    - None of the other madvise operations call into the filesystem in this
      manner.  A broad question is: is this capability an MM operation or a
      filesytem operation?  truncate, for example, is a filesystem operation
      which sometimes has MM side-effects.  madvise is an mm operation and with
      this patch, it gains FS side-effects, only they're really, really
      significant ones."
    
    Comments:
    
    - Andrea suggested the fs operation too but then it's more efficient to
      have it as a mm operation with fs side effects, because they don't
      immediatly know fd and physical offset of the range.  It's possible to
      fixup in userland and to use the fs operation but it's more expensive,
      the vmas are already in the kernel and we can use them.
    
    Short term plan &  Future Direction:
    
    - We seem to need this interface only for shmfs/tmpfs files in the short
      term.  We have to add hooks into the filesystem for correctness and
      completeness.  This is what this patch does.
    
    - In the future, plan is to support both fs and mmap apis also.  This
      also involves (other) filesystem specific functions to be implemented.
    
    - Current patch doesn't support VM_NONLINEAR - which can be addressed in
      the future.
    
    Signed-off-by: Badari Pulavarty <pbadari@us.ibm.com>
    Cc: Hugh Dickins <hugh@veritas.com>
    Cc: Andrea Arcangeli <andrea@suse.de>
    Cc: Michael Kerrisk <mtk-manpages@gmx.net>
    Cc: Ulrich Drepper <drepper@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index ed9a41a71e8b..115e72be25d0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1050,6 +1050,7 @@ struct inode_operations {
 	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
 	ssize_t (*listxattr) (struct dentry *, char *, size_t);
 	int (*removexattr) (struct dentry *, const char *);
+	void (*truncate_range)(struct inode *, loff_t, loff_t);
 };
 
 struct seq_file;

commit 994fc28c7b1e697ac56befe4aecabf23f0689f46
Author: Zach Brown <zach.brown@oracle.com>
Date:   Thu Dec 15 14:28:17 2005 -0800

    [PATCH] add AOP_TRUNCATED_PAGE, prepend AOP_ to WRITEPAGE_ACTIVATE
    
    readpage(), prepare_write(), and commit_write() callers are updated to
    understand the special return code AOP_TRUNCATED_PAGE in the style of
    writepage() and WRITEPAGE_ACTIVATE.  AOP_TRUNCATED_PAGE tells the caller that
    the callee has unlocked the page and that the operation should be tried again
    with a new page.  OCFS2 uses this to detect and work around a lock inversion in
    its aop methods.  There should be no change in behaviour for methods that don't
    return AOP_TRUNCATED_PAGE.
    
    WRITEPAGE_ACTIVATE is also prepended with AOP_ for consistency and they are
    made enums so that kerneldoc can be used to document their semantics.
    
    Signed-off-by: Zach Brown <zach.brown@oracle.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc35b6ac778d..ed9a41a71e8b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -302,6 +302,37 @@ struct iattr {
  */
 #include <linux/quota.h>
 
+/** 
+ * enum positive_aop_returns - aop return codes with specific semantics
+ *
+ * @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has
+ * 			    completed, that the page is still locked, and
+ * 			    should be considered active.  The VM uses this hint
+ * 			    to return the page to the active list -- it won't
+ * 			    be a candidate for writeback again in the near
+ * 			    future.  Other callers must be careful to unlock
+ * 			    the page if they get this return.  Returned by
+ * 			    writepage(); 
+ *
+ * @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has
+ *  			unlocked it and the page might have been truncated.
+ *  			The caller should back up to acquiring a new page and
+ *  			trying again.  The aop will be taking reasonable
+ *  			precautions not to livelock.  If the caller held a page
+ *  			reference, it should drop it before retrying.  Returned
+ *  			by readpage(), prepare_write(), and commit_write().
+ *
+ * address_space_operation functions return these large constants to indicate
+ * special semantics to the caller.  These are much larger than the bytes in a
+ * page to allow for functions that return the number of bytes operated on in a
+ * given page.
+ */
+
+enum positive_aop_returns {
+	AOP_WRITEPAGE_ACTIVATE	= 0x80000,
+	AOP_TRUNCATED_PAGE	= 0x80001,
+};
+
 /*
  * oh the beauties of C type declarations.
  */

commit 8c744fb83da0771afa04695028e3550b798dad90
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 8 21:35:04 2005 -0800

    [PATCH] add a file_permission helper
    
    A few more callers of permission() just want to check for a different access
    pattern on an already open file.  This patch adds a wrapper for permission()
    that takes a file in preparation of per-mount read-only support and to clean
    up the callers a little.  The helper is not intended for new code, everything
    without the interface set in stone should use vfs_permission()
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c3b8c1dc7cdf..cc35b6ac778d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -889,6 +889,11 @@ extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct de
  */
 extern void dentry_unhash(struct dentry *dentry);
 
+/*
+ * VFS file helper functions.
+ */
+extern int file_permission(struct file *, int);
+
 /*
  * File types
  *

commit e4543eddfd3bf3e0d625841377fa695a519edfd4
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 8 21:35:04 2005 -0800

    [PATCH] add a vfs_permission helper
    
    Most permission() calls have a struct nameidata * available.  This helper
    takes that as an argument and thus makes sure we pass it down for lookup
    intents and prepares for per-mount read-only support where we need a struct
    vfsmount for checking whether a file is writeable.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 1b5f502a4b8f..c3b8c1dc7cdf 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -874,6 +874,7 @@ static inline void unlock_super(struct super_block * sb)
 /*
  * VFS helper functions..
  */
+extern int vfs_permission(struct nameidata *, int);
 extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
 extern int vfs_mkdir(struct inode *, struct dentry *, int);
 extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);

commit 9676f0c6389b62bd6b24d77d4b3abdbcfa32d0f2
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:21:20 2005 -0500

    [PATCH] unbindable mounts
    
    An unbindable mount does not forward or receive propagation.  Also
    unbindable mount disallows bind mounts.  The semantics is as follows.
    
    Bind semantics:
      It is invalid to bind mount an unbindable mount.
    
    Move semantics:
      It is invalid to move an unbindable mount under shared mount.
    
    Clone-namespace semantics:
      If a mount is unbindable in the parent namespace, the corresponding
      cloned mount in the child namespace becomes unbindable too.  Note:
      there is subtle difference, unbindable mounts cannot be bind mounted
      but can be cloned during clone-namespace.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index eef66f54c017..1b5f502a4b8f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -104,6 +104,7 @@ extern int dir_notify_enable;
 #define MS_MOVE		8192
 #define MS_REC		16384
 #define MS_VERBOSE	32768
+#define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
 #define MS_PRIVATE	(1<<18)	/* change to private */
 #define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */

commit a58b0eb8e64b78d9315a5491955e78b1391d42e5
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:20:48 2005 -0500

    [PATCH] introduce slave mounts
    
    A slave mount always has a master mount from which it receives
    mount/umount events.  Unlike shared mount the event propagation does not
    flow from the slave mount to the master.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8bdb504be73b..eef66f54c017 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -105,6 +105,7 @@ extern int dir_notify_enable;
 #define MS_REC		16384
 #define MS_VERBOSE	32768
 #define MS_PRIVATE	(1<<18)	/* change to private */
+#define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */
 #define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_ACTIVE	(1<<30)

commit a05964f3917c7c55368c229d7985f8e7c9977e97
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:20:17 2005 -0500

    [PATCH] shared mounts handling: umount
    
    An unmount of a mount creates a umount event on the parent.  If the
    parent is a shared mount, it gets propagated to all mounts in the peer
    group.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5e188b773e9c..8bdb504be73b 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1251,7 +1251,7 @@ extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
-extern void umount_tree(struct vfsmount *, struct list_head *);
+extern void umount_tree(struct vfsmount *, int, struct list_head *);
 extern void release_mounts(struct list_head *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
 extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);

commit b90fa9ae8f51f098ee480bbaabd6867992e9fc58
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:19:50 2005 -0500

    [PATCH] shared mount handling: bind and rbind
    
    Implement handling of MS_BIND in presense of shared mounts (see
    Documentation/sharedsubtree.txt in the end of patch series for detailed
    description).
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 551fba303cf8..5e188b773e9c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1251,7 +1251,12 @@ extern int unregister_filesystem(struct file_system_type *);
 extern struct vfsmount *kern_mount(struct file_system_type *);
 extern int may_umount_tree(struct vfsmount *);
 extern int may_umount(struct vfsmount *);
+extern void umount_tree(struct vfsmount *, struct list_head *);
+extern void release_mounts(struct list_head *);
 extern long do_mount(char *, char *, char *, unsigned long, void *);
+extern struct vfsmount *copy_tree(struct vfsmount *, struct dentry *, int);
+extern void mnt_set_mountpoint(struct vfsmount *, struct dentry *,
+				  struct vfsmount *);
 
 extern int vfs_statfs(struct super_block *, struct kstatfs *);
 

commit 03e06e68ff76294e53ffa898cb844d2a997b043e
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:19:33 2005 -0500

    [PATCH] introduce shared mounts
    
    This creates shared mounts.  A shared mount when bind-mounted to some
    mountpoint, propagates mount/umount events to each other.  All the
    shared mounts that propagate events to each other belong to the same
    peer-group.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6c431086abb3..551fba303cf8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -105,6 +105,7 @@ extern int dir_notify_enable;
 #define MS_REC		16384
 #define MS_VERBOSE	32768
 #define MS_PRIVATE	(1<<18)	/* change to private */
+#define MS_SHARED	(1<<20)	/* change to shared */
 #define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)

commit 07b20889e3052c7e77d6a6a54e7e83446eb1ba84
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Mon Nov 7 17:19:07 2005 -0500

    [PATCH] beginning of the shared-subtree proper
    
    A private mount does not forward or receive propagation.  This patch
    provides user the ability to convert any mount to private.
    
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9a593ef262ef..6c431086abb3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -104,6 +104,7 @@ extern int dir_notify_enable;
 #define MS_MOVE		8192
 #define MS_REC		16384
 #define MS_VERBOSE	32768
+#define MS_PRIVATE	(1<<18)	/* change to private */
 #define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
 #define MS_ACTIVE	(1<<30)
 #define MS_NOUSER	(1<<31)

commit 8f2709b542c96a2b1910ca5f2fe27dc9023b1225
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Mon Nov 7 01:01:05 2005 -0800

    [PATCH] kernel-doc: fix some kernel-api warnings
    
    Fix various warnings in kernel-doc:
    
    Warning(linux-2614-rc4//include/linux/net.h:89): Enum value 'SOCK_DCCP' not described in enum 'sock_type'
    
    usercopy.c: should use !E instead of !I for exported symbols:
    Warning(linux-2614-rc4//arch/i386/lib/usercopy.c): no structured comments found
    
    fs.h does not need to use !E since it has no exported symbols:
    Warning(linux-2614-rc4//include/linux/fs.h:1182): No description found for parameter 'find_exported_dentry'
    Warning(linux-2614-rc4//include/linux/fs.h): no structured comments found
    
    irq/manage.c should use !E for its exported symbols:
    Warning(linux-2614-rc4//kernel/irq/manage.c): no structured comments found
    
    macmodes.c should use !E for its exported symbols:
    Warning(linux-2614-rc4//drivers/video/macmodes.c): no structured comments found
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0c89fc9481a8..9a593ef262ef 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1096,6 +1096,8 @@ int sync_inode(struct inode *inode, struct writeback_control *wbc);
  * @get_name:       find the name for a given inode in a given directory
  * @get_parent:     find the parent of a given directory
  * @get_dentry:     find a dentry for the inode given a file handle sub-fragment
+ * @find_exported_dentry:
+ *	set by the exporting module to a standard helper function.
  *
  * Description:
  *    The export_operations structure provides a means for nfsd to communicate

commit cc4e69dee4a080f6eae3f410daec2593f4fa6f00
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Mon Nov 7 00:59:49 2005 -0800

    [PATCH] VFS: pass file pointer to filesystem from ftruncate()
    
    This patch extends the iattr structure with a file pointer memeber, and adds
    an ATTR_FILE validity flag for this member.
    
    This is set if do_truncate() is invoked from ftruncate() or from
    do_coredump().
    
    The change is source and binary compatible.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 6d6226732c93..0c89fc9481a8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -264,6 +264,7 @@ typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 #define ATTR_ATTR_FLAG	1024
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
+#define ATTR_FILE	8192
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
@@ -283,6 +284,13 @@ struct iattr {
 	struct timespec	ia_atime;
 	struct timespec	ia_mtime;
 	struct timespec	ia_ctime;
+
+	/*
+	 * Not an attribute, but an auxilary info for filesystems wanting to
+	 * implement an ftruncate() like method.  NOTE: filesystem should
+	 * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).
+	 */
+	struct file	*ia_file;
 };
 
 /*
@@ -1288,7 +1296,7 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 
 /* fs/open.c */
 
-extern int do_truncate(struct dentry *, loff_t start);
+extern int do_truncate(struct dentry *, loff_t start, struct file *filp);
 extern long do_sys_open(const char __user *filename, int flags, int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);

commit 2f51201662b28dbf8c15fb7eb972bc51c6cc3fa5
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Sun Oct 30 15:02:16 2005 -0800

    [PATCH] reduce sizeof(struct file)
    
    Now that RCU applied on 'struct file' seems stable, we can place f_rcuhead
    in a memory location that is not anymore used at call_rcu(&f->f_rcuhead,
    file_free_rcu) time, to reduce the size of this critical kernel object.
    
    The trick I used is to move f_rcuhead and f_list in an union called f_u
    
    The callers are changed so that f_rcuhead becomes f_u.fu_rcuhead and f_list
    becomes f_u.f_list
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f83d997c5582..6d6226732c93 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -574,7 +574,14 @@ struct file_ra_state {
 #define RA_FLAG_INCACHE 0x02	/* file is already in cache */
 
 struct file {
-	struct list_head	f_list;
+	/*
+	 * fu_list becomes invalid after file_free is called and queued via
+	 * fu_rcuhead for RCU freeing
+	 */
+	union {
+		struct list_head	fu_list;
+		struct rcu_head 	fu_rcuhead;
+	} f_u;
 	struct dentry		*f_dentry;
 	struct vfsmount         *f_vfsmnt;
 	struct file_operations	*f_op;
@@ -598,7 +605,6 @@ struct file {
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
-	struct rcu_head 	f_rcuhead;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);

commit 27496a8c67bef4d789d8e3c8317ca35813a507ae
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:20:48 2005 -0400

    [PATCH] gfp_t: fs/*
    
     - ->releasepage() annotated (s/int/gfp_t), instances updated
     - missing gfp_t in fs/* added
     - fixed misannotation from the original sweep caught by bitwise checks:
       XFS used __nocast both for gfp_t and for flags used by XFS allocator.
       The latter left with unsigned int __nocast; we might want to add a
       different type for those but for now let's leave them alone.  That,
       BTW, is a case when __nocast use had been actively confusing - it had
       been used in the same code for two different and similar types, with
       no way to catch misuses.  Switch of gfp_t to bitwise had caught that
       immediately...
    
    One tricky bit is left alone to be dealt with later - mapping->flags is
    a mix of gfp_t and error indications.  Left alone for now.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e0b77c5af9a0..f83d997c5582 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -320,7 +320,7 @@ struct address_space_operations {
 	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
 	sector_t (*bmap)(struct address_space *, sector_t);
 	int (*invalidatepage) (struct page *, unsigned long);
-	int (*releasepage) (struct page *, int);
+	int (*releasepage) (struct page *, gfp_t);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
 	struct page* (*get_xip_page)(struct address_space *, sector_t,

commit 5ce7852cdf07ab903fb1c72d0915ac492c6e07c7
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Sep 10 00:26:28 2005 -0700

    [PATCH] mm/filemap.c: make two functions static
    
    With Nick Piggin <npiggin@suse.de>
    
    Give some things static scope.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7f61227827d7..e0b77c5af9a0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1509,8 +1509,6 @@ extern void do_generic_mapping_read(struct address_space *mapping,
 				    loff_t *, read_descriptor_t *, read_actor_t);
 extern void
 file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
-extern ssize_t generic_file_direct_IO(int rw, struct kiocb *iocb,
-	const struct iovec *iov, loff_t offset, unsigned long nr_segs);
 extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 
 	unsigned long nr_segs, loff_t *ppos);
 ssize_t generic_file_writev(struct file *filp, const struct iovec *iov, 

commit ab2af1f5005069321c5d130f09cce577b03f43ef
Author: Dipankar Sarma <dipankar@in.ibm.com>
Date:   Fri Sep 9 13:04:13 2005 -0700

    [PATCH] files: files struct with RCU
    
    Patch to eliminate struct files_struct.file_lock spinlock on the reader side
    and use rcu refcounting rcuref_xxx api for the f_count refcounter.  The
    updates to the fdtable are done by allocating a new fdtable structure and
    setting files->fdt to point to the new structure.  The fdtable structure is
    protected by RCU thereby allowing lock-free lookup.  For fd arrays/sets that
    are vmalloced, we use keventd to free them since RCU callbacks can't sleep.  A
    global list of fdtable to be freed is not scalable, so we use a per-cpu list.
    If keventd is already handling the current cpu's work, we use a timer to defer
    queueing of that work.
    
    Since the last publication, this patch has been re-written to avoid using
    explicit memory barriers and use rcu_assign_pointer(), rcu_dereference()
    premitives instead.  This required that the fd information is kept in a
    separate structure (fdtable) and updated atomically.
    
    Signed-off-by: Dipankar Sarma <dipankar@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index fd93ab7da905..7f61227827d7 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -9,6 +9,7 @@
 #include <linux/config.h>
 #include <linux/limits.h>
 #include <linux/ioctl.h>
+#include <linux/rcuref.h>
 
 /*
  * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
@@ -597,12 +598,13 @@ struct file {
 	spinlock_t		f_ep_lock;
 #endif /* #ifdef CONFIG_EPOLL */
 	struct address_space	*f_mapping;
+	struct rcu_head 	f_rcuhead;
 };
 extern spinlock_t files_lock;
 #define file_list_lock() spin_lock(&files_lock);
 #define file_list_unlock() spin_unlock(&files_lock);
 
-#define get_file(x)	atomic_inc(&(x)->f_count)
+#define get_file(x)	rcuref_inc(&(x)->f_count)
 #define file_count(x)	atomic_read(&(x)->f_count)
 
 #define	MAX_NON_LFS	((1UL<<31) - 1)

commit a7662236253374012d364106b6dc9161bd929e2e
Author: Jan Kara <jack@suse.cz>
Date:   Tue Sep 6 15:19:10 2005 -0700

    [PATCH] Make ll_rw_block() wait for buffer lock
    
    Introduce new ll_rw_block() operation SWRITE meaning that block layer should
    wait for the buffer lock and write-out afterwards.  Hence data in buffers at
    the time of call are guaranteed to be submitted to the disk.
    
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7e1b589842af..fd93ab7da905 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -69,6 +69,7 @@ extern int dir_notify_enable;
 #define READ 0
 #define WRITE 1
 #define READA 2		/* read-ahead  - don't block if no resources */
+#define SWRITE 3	/* for ll_rw_block() - wait for buffer lock */
 #define SPECIAL 4	/* For non-blockdevice requests in request queue */
 #define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
 #define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))

commit e922efc342d565a38eed3af377ff403f52148864
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Sep 6 15:18:25 2005 -0700

    [PATCH] remove duplicated sys_open32() code from 64bit archs
    
    64 bit architectures all implement their own compatibility sys_open(),
    when in fact the difference is simply not forcing the O_LARGEFILE
    flag.  So use the a common function instead.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Cc: <viro@parcelfarce.linux.theplanet.co.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 57e294bf83f4..7e1b589842af 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1280,6 +1280,7 @@ static inline int break_lease(struct inode *inode, unsigned int mode)
 /* fs/open.c */
 
 extern int do_truncate(struct dentry *, loff_t start);
+extern long do_sys_open(const char __user *filename, int flags, int mode);
 extern struct file *filp_open(const char *, int, int);
 extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
 extern int filp_close(struct file *, fl_owner_t id);

commit e89bbd3a0b3c054d9a94feb0db7bbae1cdb99e54
Author: Miklos Szeredi <miklos@szeredi.hu>
Date:   Tue Sep 6 15:18:21 2005 -0700

    [PATCH] remove iattr.ia_attr_flags
    
    Remove unused ia_attr_flags from struct iattr, and related defines.
    
    Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 2036747c7d1f..57e294bf83f4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -281,18 +281,8 @@ struct iattr {
 	struct timespec	ia_atime;
 	struct timespec	ia_mtime;
 	struct timespec	ia_ctime;
-	unsigned int	ia_attr_flags;
 };
 
-/*
- * This is the inode attributes flag definitions
- */
-#define ATTR_FLAG_SYNCRONOUS	1 	/* Syncronous write */
-#define ATTR_FLAG_NOATIME	2 	/* Don't update atime */
-#define ATTR_FLAG_APPEND	4 	/* Append-only file */
-#define ATTR_FLAG_IMMUTABLE	8 	/* Immutable file */
-#define ATTR_FLAG_NODIRATIME	16 	/* Don't update atime for directory */
-
 /*
  * Includes for diskquotas.
  */

commit 2832e9366a1fcd6f76957a42157be041240f994e
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Tue Sep 6 15:17:38 2005 -0700

    [PATCH] remove file.f_maxcount
    
    struct file cleanup: f_maxcount has an unique value (INT_MAX).  Just use
    the hard-wired value.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 67e6732d4fdc..2036747c7d1f 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -594,7 +594,6 @@ struct file {
 	unsigned int		f_uid, f_gid;
 	struct file_ra_state	f_ra;
 
-	size_t			f_maxcount;
 	unsigned long		f_version;
 	void			*f_security;
 

commit cc314eef0128a807e50fa03baf2d0abc0647952c
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Aug 19 18:02:56 2005 -0700

    Fix nasty ncpfs symlink handling bug.
    
    This bug could cause oopses and page state corruption, because ncpfs
    used the generic page-cache symlink handlign functions.  But those
    functions only work if the page cache is guaranteed to be "stable", ie a
    page that was installed when the symlink walk was started has to still
    be installed in the page cache at the end of the walk.
    
    We could have fixed ncpfs to not use the generic helper routines, but it
    is in many ways much cleaner to instead improve on the symlink walking
    helper routines so that they don't require that absolute stability.
    
    We do this by allowing "follow_link()" to return a error-pointer as a
    cookie, which is fed back to the cleanup "put_link()" routine.  This
    also simplifies NFS symlink handling.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index f9adf75fd9b4..67e6732d4fdc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -993,8 +993,8 @@ struct inode_operations {
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
 	int (*readlink) (struct dentry *, char __user *,int);
-	int (*follow_link) (struct dentry *, struct nameidata *);
-	void (*put_link) (struct dentry *, struct nameidata *);
+	void * (*follow_link) (struct dentry *, struct nameidata *);
+	void (*put_link) (struct dentry *, struct nameidata *, void *);
 	void (*truncate) (struct inode *);
 	int (*permission) (struct inode *, int, struct nameidata *);
 	int (*setattr) (struct dentry *, struct iattr *);
@@ -1602,8 +1602,8 @@ extern struct file_operations generic_ro_fops;
 extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
 extern int vfs_follow_link(struct nameidata *, const char *);
 extern int page_readlink(struct dentry *, char __user *, int);
-extern int page_follow_link_light(struct dentry *, struct nameidata *);
-extern void page_put_link(struct dentry *, struct nameidata *);
+extern void *page_follow_link_light(struct dentry *, struct nameidata *);
+extern void page_put_link(struct dentry *, struct nameidata *, void *);
 extern int page_symlink(struct inode *inode, const char *symname, int len);
 extern struct inode_operations page_symlink_inode_operations;
 extern int generic_readlink(struct dentry *, char __user *, int);

commit c293621bbf678a3d85e3ed721c3921c8a670610d
Author: Peter Staubach <staubach@redhat.com>
Date:   Wed Jul 27 11:45:09 2005 -0700

    [PATCH] stale POSIX lock handling
    
    I believe that there is a problem with the handling of POSIX locks, which
    the attached patch should address.
    
    The problem appears to be a race between fcntl(2) and close(2).  A
    multithreaded application could close a file descriptor at the same time as
    it is trying to acquire a lock using the same file descriptor.  I would
    suggest that that multithreaded application is not providing the proper
    synchronization for itself, but the OS should still behave correctly.
    
    SUS3 (Single UNIX Specification Version 3, read: POSIX) indicates that when
    a file descriptor is closed, that all POSIX locks on the file, owned by the
    process which closed the file descriptor, should be released.
    
    The trick here is when those locks are released.  The current code releases
    all locks which exist when close is processing, but any locks in progress
    are handled when the last reference to the open file is released.
    
    There are three cases to consider.
    
    One is the simple case, a multithreaded (mt) process has a file open and
    races to close it and acquire a lock on it.  In this case, the close will
    release one reference to the open file and when the fcntl is done, it will
    release the other reference.  For this situation, no locks should exist on
    the file when both the close and fcntl operations are done.  The current
    system will handle this case because the last reference to the open file is
    being released.
    
    The second case is when the mt process has dup(2)'d the file descriptor.
    The close will release one reference to the file and the fcntl, when done,
    will release another, but there will still be at least one more reference
    to the open file.  One could argue that the existence of a lock on the file
    after the close has completed is okay, because it was acquired after the
    close operation and there is still a way for the application to release the
    lock on the file, using an existing file descriptor.
    
    The third case is when the mt process has forked, after opening the file
    and either before or after becoming an mt process.  In this case, each
    process would hold a reference to the open file.  For each process, this
    degenerates to first case above.  However, the lock continues to exist
    until both processes have released their references to the open file.  This
    lock could block other lock requests.
    
    The changes to release the lock when the last reference to the open file
    aren't quite right because they would allow the lock to exist as long as
    there was a reference to the open file.  This is too long.
    
    The new proposed solution is to add support in the fcntl code path to
    detect a race with close and then to release the lock which was just
    acquired when such as race is detected.  This causes locks to be released
    in a timely fashion and for the system to conform to the POSIX semantic
    specification.
    
    This was tested by instrumenting a kernel to detect the handling locks and
    then running a program which generates case #3 above.  A dangling lock
    could be reliably generated.  When the changes to detect the close/fcntl
    race were added, a dangling lock could no longer be generated.
    
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0f53e0124941..f9adf75fd9b4 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -697,11 +697,13 @@ extern struct list_head file_lock_list;
 #include <linux/fcntl.h>
 
 extern int fcntl_getlk(struct file *, struct flock __user *);
-extern int fcntl_setlk(struct file *, unsigned int, struct flock __user *);
+extern int fcntl_setlk(unsigned int, struct file *, unsigned int,
+			struct flock __user *);
 
 #if BITS_PER_LONG == 32
 extern int fcntl_getlk64(struct file *, struct flock64 __user *);
-extern int fcntl_setlk64(struct file *, unsigned int, struct flock64 __user *);
+extern int fcntl_setlk64(unsigned int, struct file *, unsigned int,
+			struct flock64 __user *);
 #endif
 
 extern void send_sigio(struct fown_struct *fown, int fd, int band);

commit 88bd5121d635136e01369141367f315665534b3c
Author: Anton Altaparmakov <aia21@cam.ac.uk>
Date:   Wed Jul 13 01:10:44 2005 -0700

    [PATCH] Fix soft lockup due to NTFS: VFS part and explanation
    
    Something has changed in the core kernel such that we now get concurrent
    inode write outs, one e.g via pdflush and one via sys_sync or whatever.
    This causes a nasty deadlock in ntfs.  The only clean solution
    unfortunately requires a minor vfs api extension.
    
    First the deadlock analysis:
    
    Prerequisive knowledge: NTFS has a file $MFT (inode 0) loaded at mount
    time.  The NTFS driver uses the page cache for storing the file contents as
    usual.  More interestingly this file contains the table of on-disk inodes
    as a sequence of MFT_RECORDs.  Thus NTFS driver accesses the on-disk inodes
    by accessing the MFT_RECORDs in the page cache pages of the loaded inode
    $MFT.
    
    The situation: VFS inode X on a mounted ntfs volume is dirty.  For same
    inode X, the ntfs_inode is dirty and thus corresponding on-disk inode,
    which is as explained above in a dirty PAGE_CACHE_PAGE belonging to the
    table of inodes ($MFT, inode 0).
    
    What happens:
    
    Process 1: sys_sync()/umount()/whatever...  calls __sync_single_inode() for
    $MFT -> do_writepages() -> write_page for the dirty page containing the
    on-disk inode X, the page is now locked -> ntfs_write_mst_block() which
    clears PageUptodate() on the page to prevent anyone else getting hold of it
    whilst it does the write out (this is necessary as the on-disk inode needs
    "fixups" applied before the write to disk which are removed again after the
    write and PageUptodate is then set again).  It then analyses the page
    looking for dirty on-disk inodes and when it finds one it calls
    ntfs_may_write_mft_record() to see if it is safe to write this on-disk
    inode.  This then calls ilookup5() to check if the corresponding VFS inode
    is in icache().  This in turn calls ifind() which waits on the inode lock
    via wait_on_inode whilst holding the global inode_lock.
    
    Process 2: pdflush results in a call to __sync_single_inode for the same
    VFS inode X on the ntfs volume.  This locks the inode (I_LOCK) then calls
    write-inode -> ntfs_write_inode -> map_mft_record() -> read_cache_page() of
    the page (in page cache of table of inodes $MFT, inode 0) containing the
    on-disk inode.  This page has PageUptodate() clear because of Process 1
    (see above) so read_cache_page() blocks when tries to take the page lock
    for the page so it can call ntfs_read_page().
    
    Thus Process 1 is holding the page lock on the page containing the on-disk
    inode X and it is waiting on the inode X to be unlocked in ifind() so it
    can write the page out and then unlock the page.
    
    And Process 2 is holding the inode lock on inode X and is waiting for the
    page to be unlocked so it can call ntfs_readpage() or discover that
    Process 1 set PageUptodate() again and use the page.
    
    Thus we have a deadlock due to ifind() waiting on the inode lock.
    
    The only sensible solution: NTFS does not care whether the VFS inode is
    locked or not when it calls ilookup5() (it doesn't use the VFS inode at
    all, it just uses it to find the corresponding ntfs_inode which is of
    course attached to the VFS inode (both are one single struct); and it uses
    the ntfs_inode which is subject to its own locking so I_LOCK is irrelevant)
    hence we want a modified ilookup5_nowait() which is the same as ilookup5()
    but it does not wait on the inode lock.
    
    Without such functionality I would have to keep my own ntfs_inode cache in
    the NTFS driver just so I can find ntfs_inodes independent of their VFS
    inodes which would be slow, memory and cpu cycle wasting, and incredibly
    stupid given the icache already exists in the VFS.
    
    Below is a patch that does the ilookup5_nowait() implementation in
    fs/inode.c and exports it.
    
    ilookup5_nowait.diff:
    
    Introduce ilookup5_nowait() which is basically the same as ilookup5() but
    it does not wait on the inode's lock (i.e. it omits the wait_on_inode()
    done in ifind()).
    
    This is needed to avoid a nasty deadlock in NTFS.
    
    Signed-off-by: Anton Altaparmakov <aia21@cantab.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index c9bf3746a9fb..0f53e0124941 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1441,6 +1441,9 @@ extern int inode_needs_sync(struct inode *inode);
 extern void generic_delete_inode(struct inode *inode);
 extern void generic_drop_inode(struct inode *inode);
 
+extern struct inode *ilookup5_nowait(struct super_block *sb,
+		unsigned long hashval, int (*test)(struct inode *, void *),
+		void *data);
 extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
 		int (*test)(struct inode *, void *), void *data);
 extern struct inode *ilookup(struct super_block *sb, unsigned long ino);

commit 0eeca28300df110bd6ed54b31193c83b87921443
Author: Robert Love <rml@novell.com>
Date:   Tue Jul 12 17:06:03 2005 -0400

    [PATCH] inotify
    
    inotify is intended to correct the deficiencies of dnotify, particularly
    its inability to scale and its terrible user interface:
    
            * dnotify requires the opening of one fd per each directory
              that you intend to watch. This quickly results in too many
              open files and pins removable media, preventing unmount.
            * dnotify is directory-based. You only learn about changes to
              directories. Sure, a change to a file in a directory affects
              the directory, but you are then forced to keep a cache of
              stat structures.
            * dnotify's interface to user-space is awful.  Signals?
    
    inotify provides a more usable, simple, powerful solution to file change
    notification:
    
            * inotify's interface is a system call that returns a fd, not SIGIO.
              You get a single fd, which is select()-able.
            * inotify has an event that says "the filesystem that the item
              you were watching is on was unmounted."
            * inotify can watch directories or files.
    
    Inotify is currently used by Beagle (a desktop search infrastructure),
    Gamin (a FAM replacement), and other projects.
    
    See Documentation/filesystems/inotify.txt.
    
    Signed-off-by: Robert Love <rml@novell.com>
    Cc: John McCutchan <ttb@tentacle.dhs.org>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 302ec20838ca..c9bf3746a9fb 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -474,6 +474,11 @@ struct inode {
 	struct dnotify_struct	*i_dnotify; /* for directory notifications */
 #endif
 
+#ifdef CONFIG_INOTIFY
+	struct list_head	inotify_watches; /* watches on this inode */
+	struct semaphore	inotify_sem;	/* protects the watches list */
+#endif
+
 	unsigned long		i_state;
 	unsigned long		dirtied_when;	/* jiffies of first dirtying */
 
@@ -1393,7 +1398,6 @@ extern void emergency_remount(void);
 extern int do_remount_sb(struct super_block *sb, int flags,
 			 void *data, int force);
 extern sector_t bmap(struct inode *, sector_t);
-extern int setattr_mask(unsigned int);
 extern int notify_change(struct dentry *, struct iattr *);
 extern int permission(struct inode *, int, struct nameidata *);
 extern int generic_permission(struct inode *, int,

commit cb2c0233755429037462e16ea0d5497a0092738c
Author: Mark Fasheh <mark.fasheh@oracle.com>
Date:   Thu Jul 7 17:56:03 2005 -0700

    [PATCH] export generic_drop_inode() to modules
    
    OCFS2 wants to mark an inode which has been orphaned by another node so
    that during final iput it takes the correct path through the VFS and can
    pass through the OCFS2 delete_inode callback.  Since i_nlink can get out of
    date with other nodes, the best way I see to accomplish this is by clearing
    i_nlink on those inodes at drop_inode time.  Other than this small amount
    of work, nothing different needs to happen, so I think it would be cleanest
    to be able to just call generic_drop_inode at the end of the OCFS2
    drop_inode callback.
    
    Signed-off-by: Mark Fasheh <mark.fasheh@oracle.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 047bde30836a..302ec20838ca 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1435,6 +1435,7 @@ extern struct inode * igrab(struct inode *);
 extern ino_t iunique(struct super_block *, ino_t);
 extern int inode_needs_sync(struct inode *inode);
 extern void generic_delete_inode(struct inode *inode);
+extern void generic_drop_inode(struct inode *inode);
 
 extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
 		int (*test)(struct inode *, void *), void *data);

commit 22e2c507c301c3dbbcf91b4948b88f78842ee6c9
Author: Jens Axboe <axboe@suse.de>
Date:   Mon Jun 27 10:55:12 2005 +0200

    [PATCH] Update cfq io scheduler to time sliced design
    
    This updates the CFQ io scheduler to the new time sliced design (cfq
    v3).  It provides full process fairness, while giving excellent
    aggregate system throughput even for many competing processes.  It
    supports io priorities, either inherited from the cpu nice value or set
    directly with the ioprio_get/set syscalls.  The latter closely mimic
    set/getpriority.
    
    This import is based on my latest from -mm.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3ae8e37bdfc8..047bde30836a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -213,6 +213,7 @@ extern int dir_notify_enable;
 #include <linux/radix-tree.h>
 #include <linux/prio_tree.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 
 #include <asm/atomic.h>
 #include <asm/semaphore.h>
@@ -822,16 +823,34 @@ enum {
 #define vfs_check_frozen(sb, level) \
 	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
 
+static inline void get_fs_excl(void)
+{
+	atomic_inc(&current->fs_excl);
+}
+
+static inline void put_fs_excl(void)
+{
+	atomic_dec(&current->fs_excl);
+}
+
+static inline int has_fs_excl(void)
+{
+	return atomic_read(&current->fs_excl);
+}
+
+
 /*
  * Superblock locking.
  */
 static inline void lock_super(struct super_block * sb)
 {
+	get_fs_excl();
 	down(&sb->s_lock);
 }
 
 static inline void unlock_super(struct super_block * sb)
 {
+	put_fs_excl();
 	up(&sb->s_lock);
 }
 

commit eb6fe0c388e43b02e261f0fdee60e42f6298d7f7
Author: Carsten Otte <cotte@de.ibm.com>
Date:   Thu Jun 23 22:05:28 2005 -0700

    [PATCH] xip: reduce code duplication
    
    This patch reworks filemap_xip.c with the goal to reduce code duplication
    from mm/filemap.c.  It applies agains 2.6.12-rc6-mm1.  Instead of
    implementing the aio functions, this one implements the synchronous
    read/write functions only.  For readv and writev, the generic fallback is
    used.  For aio, we rely on the application doing the fallback.  Since our
    "synchronous" function does memcpy immediately anyway, there is no
    performance difference between using the fallbacks or implementing each
    operation.
    
    Signed-off-by: Carsten Otte <cotte@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 7e0501895f35..3ae8e37bdfc8 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1500,18 +1500,14 @@ extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
 #ifdef CONFIG_FS_XIP
-extern ssize_t xip_file_aio_read(struct kiocb *iocb, char __user *buf,
-				 size_t count, loff_t pos);
-extern ssize_t xip_file_readv(struct file *filp, const struct iovec *iov,
-			      unsigned long nr_segs, loff_t *ppos);
+extern ssize_t xip_file_read(struct file *filp, char __user *buf, size_t len,
+			     loff_t *ppos);
 extern ssize_t xip_file_sendfile(struct file *in_file, loff_t *ppos,
 				 size_t count, read_actor_t actor,
 				 void *target);
 extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
-extern ssize_t xip_file_aio_write(struct kiocb *iocb, const char __user *buf,
-				  size_t count, loff_t pos);
-extern ssize_t xip_file_writev(struct file *file, const struct iovec *iov,
-			       unsigned long nr_segs, loff_t *ppos);
+extern ssize_t xip_file_write(struct file *filp, const char __user *buf,
+			      size_t len, loff_t *ppos);
 extern int xip_truncate_page(struct address_space *mapping, loff_t from);
 #else
 static inline int xip_truncate_page(struct address_space *mapping, loff_t from)

commit 6d79125bba55ee82701f1c7d4ebbc1aa20ecbe4e
Author: Carsten Otte <cotte@de.ibm.com>
Date:   Thu Jun 23 22:05:26 2005 -0700

    [PATCH] xip: ext2: execute in place
    
    These are the ext2 related parts.  Ext2 now uses the xip_* file operations
    along with the get_xip_page aop when mounted with -o xip.
    
    Signed-off-by: Carsten Otte <cotte@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 79c0fafc0211..7e0501895f35 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1513,6 +1513,11 @@ extern ssize_t xip_file_aio_write(struct kiocb *iocb, const char __user *buf,
 extern ssize_t xip_file_writev(struct file *file, const struct iovec *iov,
 			       unsigned long nr_segs, loff_t *ppos);
 extern int xip_truncate_page(struct address_space *mapping, loff_t from);
+#else
+static inline int xip_truncate_page(struct address_space *mapping, loff_t from)
+{
+	return 0;
+}
 #endif
 
 static inline void do_generic_file_read(struct file * filp, loff_t *ppos,

commit ceffc078528befc008c6f2c2c4decda79eabd534
Author: Carsten Otte <cotte@de.ibm.com>
Date:   Thu Jun 23 22:05:25 2005 -0700

    [PATCH] xip: fs/mm: execute in place
    
    - generic_file* file operations do no longer have a xip/non-xip split
    - filemap_xip.c implements a new set of fops that require get_xip_page
      aop to work proper. all new fops are exported GPL-only (don't like to
      see whatever code use those except GPL modules)
    - __xip_unmap now uses page_check_address, which is no longer static
      in rmap.c, and defined in linux/rmap.h
    - mm/filemap.h is now much more clean, plainly having just Linus'
      inline funcs moved here from filemap.c
    - fix includes in filemap_xip to make it build cleanly on i386
    
    Signed-off-by: Carsten Otte <cotte@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 929bf8d20c87..79c0fafc0211 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -330,6 +330,8 @@ struct address_space_operations {
 	int (*releasepage) (struct page *, int);
 	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
 			loff_t offset, unsigned long nr_segs);
+	struct page* (*get_xip_page)(struct address_space *, sector_t,
+			int);
 };
 
 struct backing_dev_info;
@@ -1497,6 +1499,22 @@ extern loff_t remote_llseek(struct file *file, loff_t offset, int origin);
 extern int generic_file_open(struct inode * inode, struct file * filp);
 extern int nonseekable_open(struct inode * inode, struct file * filp);
 
+#ifdef CONFIG_FS_XIP
+extern ssize_t xip_file_aio_read(struct kiocb *iocb, char __user *buf,
+				 size_t count, loff_t pos);
+extern ssize_t xip_file_readv(struct file *filp, const struct iovec *iov,
+			      unsigned long nr_segs, loff_t *ppos);
+extern ssize_t xip_file_sendfile(struct file *in_file, loff_t *ppos,
+				 size_t count, read_actor_t actor,
+				 void *target);
+extern int xip_file_mmap(struct file * file, struct vm_area_struct * vma);
+extern ssize_t xip_file_aio_write(struct kiocb *iocb, const char __user *buf,
+				  size_t count, loff_t pos);
+extern ssize_t xip_file_writev(struct file *file, const struct iovec *iov,
+			       unsigned long nr_segs, loff_t *ppos);
+extern int xip_truncate_page(struct address_space *mapping, loff_t from);
+#endif
+
 static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
 					read_descriptor_t * desc,
 					read_actor_t actor)

commit 420edbcc09008342c7b2665453f6b370739aadb0
Author: Carsten Otte <cotte@de.ibm.com>
Date:   Thu Jun 23 22:05:23 2005 -0700

    [PATCH] xip: bdev: execute in place
    
    This is the block device related part.  The block device operation
    direct_access now has a struct block_device as first parameter.
    
    Signed-off-by: Carsten Otte <cotte@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 83857d8070d3..929bf8d20c87 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -885,6 +885,7 @@ struct block_device_operations {
 	int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
 	long (*unlocked_ioctl) (struct file *, unsigned, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned, unsigned long);
+	int (*direct_access) (struct block_device *, sector_t, unsigned long *);
 	int (*media_changed) (struct gendisk *);
 	int (*revalidate_disk) (struct gendisk *);
 	struct module *owner;

commit 92198f7eaa5df3479341dd8fa20c2c81aa3b1e25
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 23 22:00:59 2005 -0700

    [PATCH] pass iocb to dio_iodone_t
    
    XFS will have to look at iocb->private to fix aio+dio.  No other filesystem
    is using the blockdev_direct_IO* end_io callback.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 517bf4966bf5..83857d8070d3 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -220,6 +220,7 @@ extern int dir_notify_enable;
 
 struct iovec;
 struct nameidata;
+struct kiocb;
 struct pipe_inode_info;
 struct poll_table_struct;
 struct kstatfs;
@@ -240,7 +241,7 @@ typedef int (get_block_t)(struct inode *inode, sector_t iblock,
 typedef int (get_blocks_t)(struct inode *inode, sector_t iblock,
 			unsigned long max_blocks,
 			struct buffer_head *bh_result, int create);
-typedef void (dio_iodone_t)(struct inode *inode, loff_t offset,
+typedef void (dio_iodone_t)(struct kiocb *iocb, loff_t offset,
 			ssize_t bytes, void *private);
 
 /*
@@ -302,7 +303,6 @@ struct iattr {
 struct page;
 struct address_space;
 struct writeback_control;
-struct kiocb;
 
 struct address_space_operations {
 	int (*writepage)(struct page *page, struct writeback_control *wbc);

commit 45778ca819accab1a4a3378b3566cab0f189164f
Author: Christoph Lameter <christoph@graphe.net>
Date:   Thu Jun 23 00:10:17 2005 -0700

    [PATCH] Remove f_error field from struct file
    
    The following patch removes the f_error field and all checks of f_error.
    
    Trond said:
    
      f_error was introduced for NFS, and made sense when we were guaranteed
      always to have a file pointer around when write errors occurred.  Since
      then, we have (for various reasons) had to introduce the nfs_open_context in
      order to track the file read/write state, and it made sense to move our
      f_error tracking there too.
    
    Signed-off-by: Christoph Lameter <christoph@lameter.com>
    Acked-by: Trond Myklebust <trond.myklebust@fys.uio.no>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9b1278e21279..517bf4966bf5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -581,7 +581,6 @@ struct file {
 	atomic_t		f_count;
 	unsigned int 		f_flags;
 	mode_t			f_mode;
-	int			f_error;
 	loff_t			f_pos;
 	struct fown_struct	f_owner;
 	unsigned int		f_uid, f_gid;

commit bb93e3a52f8db7210258a1a2134cced0b78a46e1
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Jun 23 00:10:15 2005 -0700

    [PATCH] block: add unlocked_ioctl support for block devices
    
    This patch allows block device drivers to convert their ioctl functions to
    unlocked_ioctl() like character devices and other subsystems.  All
    functions that were called with the BKL held before are still used that
    way, but I would not be surprised if it could be removed from the ioctl
    functions in drivers/block/ioctl.c themselves.
    
    As a side note, I found that compat_blkdev_ioctl() acquires the BKL as
    well, which looks like a bug.  I have checked that every user of
    disk->fops->compat_ioctl() in the current git tree gets the BKL itself, so
    it could easily be removed from compat_blkdev_ioctl().
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3622e952e98c..9b1278e21279 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -884,6 +884,7 @@ struct block_device_operations {
 	int (*open) (struct inode *, struct file *);
 	int (*release) (struct inode *, struct file *);
 	int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
+	long (*unlocked_ioctl) (struct file *, unsigned, unsigned long);
 	long (*compat_ioctl) (struct file *, unsigned, unsigned long);
 	int (*media_changed) (struct gendisk *);
 	int (*revalidate_disk) (struct gendisk *);

commit 991114c6fa6a21d1fa4d544abe78592352860c82
Author: Alexander Viro <aviro@redhat.com>
Date:   Thu Jun 23 00:09:01 2005 -0700

    [PATCH] fix for prune_icache()/forced final iput() races
    
    Based on analysis and a patch from Russ Weight <rweight@us.ibm.com>
    
    There is a race condition that can occur if an inode is allocated and then
    released (using iput) during the ->fill_super functions.  The race
    condition is between kswapd and mount.
    
    For most filesystems this can only happen in an error path when kswapd is
    running concurrently.  For isofs, however, the error can occur in a more
    common code path (which is how the bug was found).
    
    The logic here is "we want final iput() to free inode *now* instead of
    letting it sit in cache if fs is going down or had not quite come up".  The
    problem is with kswapd seeing such inodes in the middle of being killed and
    happily taking over.
    
    The clean solution would be to tell kswapd to leave those inodes alone and
    let our final iput deal with them.  I.e.  add a new flag
    (I_FORCED_FREEING), set it before write_inode_now() there and make
    prune_icache() leave those alone.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index e5a8db00df29..3622e952e98c 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1025,6 +1025,7 @@ struct super_operations {
 #define I_FREEING		16
 #define I_CLEAR			32
 #define I_NEW			64
+#define I_WILL_FREE		128
 
 #define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
 

commit 8d0a8a9d0ec790086c64d210af413ac351d89e35
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Wed Jun 22 17:16:32 2005 +0000

    [PATCH] NFSv4: Clean up nfs4 lock state accounting
    
     Ensure that lock owner structures are not released prematurely.
    
     Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9b8b696d4f15..e5a8db00df29 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -674,6 +674,7 @@ struct file_lock {
 	struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
 	union {
 		struct nfs_lock_info	nfs_fl;
+		struct nfs4_lock_info	nfs4_fl;
 	} fl_u;
 };
 

commit acaefc25d21f850e47ecc5098d1e0bc442c526be
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed May 18 14:40:59 2005 +0200

    [PATCH] libfs: add simple attribute files
    
    Based on the discussion about spufs attributes, this is my suggestion
    for a more generic attribute file support that can be used by both
    debugfs and spufs.
    
    Simple attribute files behave similarly to sequential files from
    a kernel programmers perspective in that a standard set of file
    operations is provided and only an open operation needs to
    be written that registers file specific get() and set() functions.
    
    These operations are defined as
    
    void foo_set(void *data, u64 val); and
    u64 foo_get(void *data);
    
    where data is the inode->u.generic_ip pointer of the file and the
    operations just need to make send of that pointer. The infrastructure
    makes sure this works correctly with concurrent access and partial
    read calls.
    
    A macro named DEFINE_SIMPLE_ATTRIBUTE is provided to further simplify
    using the attributes.
    
    This patch already contains the changes for debugfs to use attributes
    for its internal file operations.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0180102dace1..9b8b696d4f15 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1657,6 +1657,52 @@ static inline void simple_transaction_set(struct file *file, size_t n)
 	ar->size = n;
 }
 
+/*
+ * simple attribute files
+ *
+ * These attributes behave similar to those in sysfs:
+ *
+ * Writing to an attribute immediately sets a value, an open file can be
+ * written to multiple times.
+ *
+ * Reading from an attribute creates a buffer from the value that might get
+ * read with multiple read calls. When the attribute has been read
+ * completely, no further read calls are possible until the file is opened
+ * again.
+ *
+ * All attributes contain a text representation of a numeric value
+ * that are accessed with the get() and set() functions.
+ */
+#define DEFINE_SIMPLE_ATTRIBUTE(__fops, __get, __set, __fmt)		\
+static int __fops ## _open(struct inode *inode, struct file *file)	\
+{									\
+	__simple_attr_check_format(__fmt, 0ull);			\
+	return simple_attr_open(inode, file, __get, __set, __fmt);	\
+}									\
+static struct file_operations __fops = {				\
+	.owner	 = THIS_MODULE,						\
+	.open	 = __fops ## _open,					\
+	.release = simple_attr_close,					\
+	.read	 = simple_attr_read,					\
+	.write	 = simple_attr_write,					\
+};
+
+static inline void __attribute__((format(printf, 1, 2)))
+__simple_attr_check_format(const char *fmt, ...)
+{
+	/* don't do anything, just let the compiler check the arguments; */
+}
+
+int simple_attr_open(struct inode *inode, struct file *file,
+		     u64 (*get)(void *), void (*set)(void *, u64),
+		     const char *fmt);
+int simple_attr_close(struct inode *inode, struct file *file);
+ssize_t simple_attr_read(struct file *file, char __user *buf,
+			 size_t len, loff_t *ppos);
+ssize_t simple_attr_write(struct file *file, const char __user *buf,
+			  size_t len, loff_t *ppos);
+
+
 #ifdef CONFIG_SECURITY
 static inline char *alloc_secdata(void)
 {

commit 2ef41634def0fcb0def3e3c90220c651ca478cb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 5 16:15:59 2005 -0700

    [PATCH] remove do_sync parameter from __invalidate_device
    
    The only caller that ever sets it can call fsync_bdev itself easily.  Also
    update some comments.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: <viro@parcelfarce.linux.theplanet.co.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 4edba067a717..0180102dace1 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1341,7 +1341,7 @@ extern int fs_may_remount_ro(struct super_block *);
 
 extern int check_disk_change(struct block_device *);
 extern int invalidate_inodes(struct super_block *);
-extern int __invalidate_device(struct block_device *, int);
+extern int __invalidate_device(struct block_device *);
 extern int invalidate_partition(struct gendisk *, int);
 unsigned long invalidate_mapping_pages(struct address_space *mapping,
 					pgoff_t start, pgoff_t end);

commit 67be2dd1bace0ec7ce2dbc1bba3f8df3d7be597e
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun May 1 08:59:26 2005 -0700

    [PATCH] DocBook: fix some descriptions
    
    Some KernelDoc descriptions are updated to match the current code.
    No code changes.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 3f825b085c8d..4edba067a717 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1065,71 +1065,75 @@ int sync_inode(struct inode *inode, struct writeback_control *wbc);
  *    with a particular exported file system  - particularly enabling nfsd and
  *    the filesystem to co-operate when dealing with file handles.
  *
- *    export_operations contains two basic operation for dealing with file handles,
- *    decode_fh() and encode_fh(), and allows for some other operations to be defined
- *    which standard helper routines use to get specific information from the
- *    filesystem.
+ *    export_operations contains two basic operation for dealing with file
+ *    handles, decode_fh() and encode_fh(), and allows for some other
+ *    operations to be defined which standard helper routines use to get
+ *    specific information from the filesystem.
  *
  *    nfsd encodes information use to determine which filesystem a filehandle
- *    applies to in the initial part of the file handle.  The remainder, termed a
- *    file handle fragment, is controlled completely by the filesystem.
- *    The standard helper routines assume that this fragment will contain one or two
- *    sub-fragments, one which identifies the file, and one which may be used to
- *    identify the (a) directory containing the file.
+ *    applies to in the initial part of the file handle.  The remainder, termed
+ *    a file handle fragment, is controlled completely by the filesystem.  The
+ *    standard helper routines assume that this fragment will contain one or
+ *    two sub-fragments, one which identifies the file, and one which may be
+ *    used to identify the (a) directory containing the file.
  *
  *    In some situations, nfsd needs to get a dentry which is connected into a
- *    specific part of the file tree.  To allow for this, it passes the function
- *    acceptable() together with a @context which can be used to see if the dentry
- *    is acceptable.  As there can be multiple dentrys for a given file, the filesystem
- *    should check each one for acceptability before looking for the next.  As soon
- *    as an acceptable one is found, it should be returned.
+ *    specific part of the file tree.  To allow for this, it passes the
+ *    function acceptable() together with a @context which can be used to see
+ *    if the dentry is acceptable.  As there can be multiple dentrys for a
+ *    given file, the filesystem should check each one for acceptability before
+ *    looking for the next.  As soon as an acceptable one is found, it should
+ *    be returned.
  *
  * decode_fh:
- *    @decode_fh is given a &struct super_block (@sb), a file handle fragment (@fh, @fh_len)
- *    and an acceptability testing function (@acceptable, @context).  It should return
- *    a &struct dentry which refers to the same file that the file handle fragment refers
- *    to,  and which passes the acceptability test.  If it cannot, it should return
- *    a %NULL pointer if the file was found but no acceptable &dentries were available, or
- *    a %ERR_PTR error code indicating why it couldn't be found (e.g. %ENOENT or %ENOMEM).
+ *    @decode_fh is given a &struct super_block (@sb), a file handle fragment
+ *    (@fh, @fh_len) and an acceptability testing function (@acceptable,
+ *    @context).  It should return a &struct dentry which refers to the same
+ *    file that the file handle fragment refers to,  and which passes the
+ *    acceptability test.  If it cannot, it should return a %NULL pointer if
+ *    the file was found but no acceptable &dentries were available, or a
+ *    %ERR_PTR error code indicating why it couldn't be found (e.g. %ENOENT or
+ *    %ENOMEM).
  *
  * encode_fh:
- *    @encode_fh should store in the file handle fragment @fh (using at most @max_len bytes)
- *    information that can be used by @decode_fh to recover the file refered to by the
- *    &struct dentry @de.  If the @connectable flag is set, the encode_fh() should store
- *    sufficient information so that a good attempt can be made to find not only
- *    the file but also it's place in the filesystem.   This typically means storing
- *    a reference to de->d_parent in the filehandle fragment.
- *    encode_fh() should return the number of bytes stored or a negative error code
- *    such as %-ENOSPC
+ *    @encode_fh should store in the file handle fragment @fh (using at most
+ *    @max_len bytes) information that can be used by @decode_fh to recover the
+ *    file refered to by the &struct dentry @de.  If the @connectable flag is
+ *    set, the encode_fh() should store sufficient information so that a good
+ *    attempt can be made to find not only the file but also it's place in the
+ *    filesystem.   This typically means storing a reference to de->d_parent in
+ *    the filehandle fragment.  encode_fh() should return the number of bytes
+ *    stored or a negative error code such as %-ENOSPC
  *
  * get_name:
- *    @get_name should find a name for the given @child in the given @parent directory.
- *    The name should be stored in the @name (with the understanding that it is already
- *    pointing to a a %NAME_MAX+1 sized buffer.   get_name() should return %0 on success,
- *    a negative error code or error.
- *    @get_name will be called without @parent->i_sem held.
+ *    @get_name should find a name for the given @child in the given @parent
+ *    directory.  The name should be stored in the @name (with the
+ *    understanding that it is already pointing to a a %NAME_MAX+1 sized
+ *    buffer.   get_name() should return %0 on success, a negative error code
+ *    or error.  @get_name will be called without @parent->i_sem held.
  *
  * get_parent:
- *    @get_parent should find the parent directory for the given @child which is also
- *    a directory.  In the event that it cannot be found, or storage space cannot be
- *    allocated, a %ERR_PTR should be returned.
+ *    @get_parent should find the parent directory for the given @child which
+ *    is also a directory.  In the event that it cannot be found, or storage
+ *    space cannot be allocated, a %ERR_PTR should be returned.
  *
  * get_dentry:
- *    Given a &super_block (@sb) and a pointer to a file-system specific inode identifier,
- *    possibly an inode number, (@inump) get_dentry() should find the identified inode and
- *    return a dentry for that inode.
- *    Any suitable dentry can be returned including, if necessary, a new dentry created
- *    with d_alloc_root.  The caller can then find any other extant dentrys by following the
- *    d_alias links.  If a new dentry was created using d_alloc_root, DCACHE_NFSD_DISCONNECTED
- *    should be set, and the dentry should be d_rehash()ed.
+ *    Given a &super_block (@sb) and a pointer to a file-system specific inode
+ *    identifier, possibly an inode number, (@inump) get_dentry() should find
+ *    the identified inode and return a dentry for that inode.  Any suitable
+ *    dentry can be returned including, if necessary, a new dentry created with
+ *    d_alloc_root.  The caller can then find any other extant dentrys by
+ *    following the d_alias links.  If a new dentry was created using
+ *    d_alloc_root, DCACHE_NFSD_DISCONNECTED should be set, and the dentry
+ *    should be d_rehash()ed.
  *
- *    If the inode cannot be found, either a %NULL pointer or an %ERR_PTR code can be returned.
- *    The @inump will be whatever was passed to nfsd_find_fh_dentry() in either the
- *    @obj or @parent parameters.
+ *    If the inode cannot be found, either a %NULL pointer or an %ERR_PTR code
+ *    can be returned.  The @inump will be whatever was passed to
+ *    nfsd_find_fh_dentry() in either the @obj or @parent parameters.
  *
  * Locking rules:
- *  get_parent is called with child->d_inode->i_sem down
- *  get_name is not (which is possibly inconsistent)
+ *    get_parent is called with child->d_inode->i_sem down
+ *    get_name is not (which is possibly inconsistent)
  */
 
 struct export_operations {

commit 4dc3b16ba18c0f967ad100c52fa65b01a4f76ff0
Author: Pavel Pisa <pisa@cmp.felk.cvut.cz>
Date:   Sun May 1 08:59:25 2005 -0700

    [PATCH] DocBook: changes and extensions to the kernel documentation
    
    I have recompiled Linux kernel 2.6.11.5 documentation for me and our
    university students again.  The documentation could be extended for more
    sources which are equipped by structured comments for recent 2.6 kernels.  I
    have tried to proceed with that task.  I have done that more times from 2.6.0
    time and it gets boring to do same changes again and again.  Linux kernel
    compiles after changes for i386 and ARM targets.  I have added references to
    some more files into kernel-api book, I have added some section names as well.
     So please, check that changes do not break something and that categories are
    not too much skewed.
    
    I have changed kernel-doc to accept "fastcall" and "asmlinkage" words reserved
    by kernel convention.  Most of the other changes are modifications in the
    comments to make kernel-doc happy, accept some parameters description and do
    not bail out on errors.  Changed <pid> to @pid in the description, moved some
    #ifdef before comments to correct function to comments bindings, etc.
    
    You can see result of the modified documentation build at
      http://cmp.felk.cvut.cz/~pisa/linux/lkdb-2.6.11.tar.gz
    
    Some more sources are ready to be included into kernel-doc generated
    documentation.  Sources has been added into kernel-api for now.  Some more
    section names added and probably some more chaos introduced as result of quick
    cleanup work.
    
    Signed-off-by: Pavel Pisa <pisa@cmp.felk.cvut.cz>
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/fs.h b/include/linux/fs.h
index 5df687d940fa..3f825b085c8d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1053,12 +1053,12 @@ static inline void file_accessed(struct file *file)
 int sync_inode(struct inode *inode, struct writeback_control *wbc);
 
 /**
- * &export_operations - for nfsd to communicate with file systems
- * decode_fh:      decode a file handle fragment and return a &struct dentry
- * encode_fh:      encode a file handle fragment from a dentry
- * get_name:       find the name for a given inode in a given directory
- * get_parent:     find the parent of a given directory
- * get_dentry:     find a dentry for the inode given a file handle sub-fragment
+ * struct export_operations - for nfsd to communicate with file systems
+ * @decode_fh:      decode a file handle fragment and return a &struct dentry
+ * @encode_fh:      encode a file handle fragment from a dentry
+ * @get_name:       find the name for a given inode in a given directory
+ * @get_parent:     find the parent of a given directory
+ * @get_dentry:     find a dentry for the inode given a file handle sub-fragment
  *
  * Description:
  *    The export_operations structure provides a means for nfsd to communicate

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/fs.h b/include/linux/fs.h
new file mode 100644
index 000000000000..5df687d940fa
--- /dev/null
+++ b/include/linux/fs.h
@@ -0,0 +1,1677 @@
+#ifndef _LINUX_FS_H
+#define _LINUX_FS_H
+
+/*
+ * This file has definitions for some important file table
+ * structures etc.
+ */
+
+#include <linux/config.h>
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+
+/*
+ * It's silly to have NR_OPEN bigger than NR_FILE, but you can change
+ * the file limit at runtime and only root can increase the per-process
+ * nr_file rlimit, so it's safe to set up a ridiculously high absolute
+ * upper limit on files-per-process.
+ *
+ * Some programs (notably those using select()) may have to be 
+ * recompiled to take full advantage of the new limits..  
+ */
+
+/* Fixed constants first: */
+#undef NR_OPEN
+#define NR_OPEN (1024*1024)	/* Absolute upper limit on fd num */
+#define INR_OPEN 1024		/* Initial setting for nfile rlimits */
+
+#define BLOCK_SIZE_BITS 10
+#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
+
+/* And dynamically-tunable limits and defaults: */
+struct files_stat_struct {
+	int nr_files;		/* read only */
+	int nr_free_files;	/* read only */
+	int max_files;		/* tunable */
+};
+extern struct files_stat_struct files_stat;
+
+struct inodes_stat_t {
+	int nr_inodes;
+	int nr_unused;
+	int dummy[5];
+};
+extern struct inodes_stat_t inodes_stat;
+
+extern int leases_enable, lease_break_time;
+
+#ifdef CONFIG_DNOTIFY
+extern int dir_notify_enable;
+#endif
+
+#define NR_FILE  8192	/* this can well be larger on a larger system */
+
+#define MAY_EXEC 1
+#define MAY_WRITE 2
+#define MAY_READ 4
+#define MAY_APPEND 8
+
+#define FMODE_READ 1
+#define FMODE_WRITE 2
+
+/* Internal kernel extensions */
+#define FMODE_LSEEK	4
+#define FMODE_PREAD	8
+#define FMODE_PWRITE	FMODE_PREAD	/* These go hand in hand */
+
+#define RW_MASK		1
+#define RWA_MASK	2
+#define READ 0
+#define WRITE 1
+#define READA 2		/* read-ahead  - don't block if no resources */
+#define SPECIAL 4	/* For non-blockdevice requests in request queue */
+#define READ_SYNC	(READ | (1 << BIO_RW_SYNC))
+#define WRITE_SYNC	(WRITE | (1 << BIO_RW_SYNC))
+#define WRITE_BARRIER	((1 << BIO_RW) | (1 << BIO_RW_BARRIER))
+
+#define SEL_IN		1
+#define SEL_OUT		2
+#define SEL_EX		4
+
+/* public flags for file_system_type */
+#define FS_REQUIRES_DEV 1 
+#define FS_BINARY_MOUNTDATA 2
+#define FS_REVAL_DOT	16384	/* Check the paths ".", ".." for staleness */
+#define FS_ODD_RENAME	32768	/* Temporary stuff; will go away as soon
+				  * as nfs_rename() will be cleaned up
+				  */
+/*
+ * These are the fs-independent mount-flags: up to 32 flags are supported
+ */
+#define MS_RDONLY	 1	/* Mount read-only */
+#define MS_NOSUID	 2	/* Ignore suid and sgid bits */
+#define MS_NODEV	 4	/* Disallow access to device special files */
+#define MS_NOEXEC	 8	/* Disallow program execution */
+#define MS_SYNCHRONOUS	16	/* Writes are synced at once */
+#define MS_REMOUNT	32	/* Alter flags of a mounted FS */
+#define MS_MANDLOCK	64	/* Allow mandatory locks on an FS */
+#define MS_DIRSYNC	128	/* Directory modifications are synchronous */
+#define MS_NOATIME	1024	/* Do not update access times. */
+#define MS_NODIRATIME	2048	/* Do not update directory access times */
+#define MS_BIND		4096
+#define MS_MOVE		8192
+#define MS_REC		16384
+#define MS_VERBOSE	32768
+#define MS_POSIXACL	(1<<16)	/* VFS does not apply the umask */
+#define MS_ACTIVE	(1<<30)
+#define MS_NOUSER	(1<<31)
+
+/*
+ * Superblock flags that can be altered by MS_REMOUNT
+ */
+#define MS_RMT_MASK	(MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_NOATIME|\
+			 MS_NODIRATIME)
+
+/*
+ * Old magic mount flag and mask
+ */
+#define MS_MGC_VAL 0xC0ED0000
+#define MS_MGC_MSK 0xffff0000
+
+/* Inode flags - they have nothing to superblock flags now */
+
+#define S_SYNC		1	/* Writes are synced at once */
+#define S_NOATIME	2	/* Do not update access times */
+#define S_APPEND	4	/* Append-only file */
+#define S_IMMUTABLE	8	/* Immutable file */
+#define S_DEAD		16	/* removed, but still open directory */
+#define S_NOQUOTA	32	/* Inode is not counted to quota */
+#define S_DIRSYNC	64	/* Directory modifications are synchronous */
+#define S_NOCMTIME	128	/* Do not update file c/mtime */
+#define S_SWAPFILE	256	/* Do not truncate: swapon got its bmaps */
+#define S_PRIVATE	512	/* Inode is fs-internal */
+
+/*
+ * Note that nosuid etc flags are inode-specific: setting some file-system
+ * flags just means all the inodes inherit those flags by default. It might be
+ * possible to override it selectively if you really wanted to with some
+ * ioctl() that is not currently implemented.
+ *
+ * Exception: MS_RDONLY is always applied to the entire file system.
+ *
+ * Unfortunately, it is possible to change a filesystems flags with it mounted
+ * with files in use.  This means that all of the inodes will not have their
+ * i_flags updated.  Hence, i_flags no longer inherit the superblock mount
+ * flags, so these have to be checked separately. -- rmk@arm.uk.linux.org
+ */
+#define __IS_FLG(inode,flg) ((inode)->i_sb->s_flags & (flg))
+
+#define IS_RDONLY(inode) ((inode)->i_sb->s_flags & MS_RDONLY)
+#define IS_SYNC(inode)		(__IS_FLG(inode, MS_SYNCHRONOUS) || \
+					((inode)->i_flags & S_SYNC))
+#define IS_DIRSYNC(inode)	(__IS_FLG(inode, MS_SYNCHRONOUS|MS_DIRSYNC) || \
+					((inode)->i_flags & (S_SYNC|S_DIRSYNC)))
+#define IS_MANDLOCK(inode)	__IS_FLG(inode, MS_MANDLOCK)
+
+#define IS_NOQUOTA(inode)	((inode)->i_flags & S_NOQUOTA)
+#define IS_APPEND(inode)	((inode)->i_flags & S_APPEND)
+#define IS_IMMUTABLE(inode)	((inode)->i_flags & S_IMMUTABLE)
+#define IS_NOATIME(inode)	(__IS_FLG(inode, MS_NOATIME) || ((inode)->i_flags & S_NOATIME))
+#define IS_NODIRATIME(inode)	__IS_FLG(inode, MS_NODIRATIME)
+#define IS_POSIXACL(inode)	__IS_FLG(inode, MS_POSIXACL)
+
+#define IS_DEADDIR(inode)	((inode)->i_flags & S_DEAD)
+#define IS_NOCMTIME(inode)	((inode)->i_flags & S_NOCMTIME)
+#define IS_SWAPFILE(inode)	((inode)->i_flags & S_SWAPFILE)
+#define IS_PRIVATE(inode)	((inode)->i_flags & S_PRIVATE)
+
+/* the read-only stuff doesn't really belong here, but any other place is
+   probably as bad and I don't want to create yet another include file. */
+
+#define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
+#define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
+#define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
+#define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
+#define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
+#define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
+#define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
+#define BLKFRASET  _IO(0x12,100)/* set filesystem (mm/filemap.c) read-ahead */
+#define BLKFRAGET  _IO(0x12,101)/* get filesystem (mm/filemap.c) read-ahead */
+#define BLKSECTSET _IO(0x12,102)/* set max sectors per request (ll_rw_blk.c) */
+#define BLKSECTGET _IO(0x12,103)/* get max sectors per request (ll_rw_blk.c) */
+#define BLKSSZGET  _IO(0x12,104)/* get block device sector size */
+#if 0
+#define BLKPG      _IO(0x12,105)/* See blkpg.h */
+
+/* Some people are morons.  Do not use sizeof! */
+
+#define BLKELVGET  _IOR(0x12,106,size_t)/* elevator get */
+#define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */
+/* This was here just to show that the number is taken -
+   probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */
+#endif
+/* A jump here: 108-111 have been used for various private purposes. */
+#define BLKBSZGET  _IOR(0x12,112,size_t)
+#define BLKBSZSET  _IOW(0x12,113,size_t)
+#define BLKGETSIZE64 _IOR(0x12,114,size_t)	/* return device size in bytes (u64 *arg) */
+
+#define BMAP_IOCTL 1		/* obsolete - kept for compatibility */
+#define FIBMAP	   _IO(0x00,1)	/* bmap access */
+#define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */
+
+#ifdef __KERNEL__
+
+#include <linux/linkage.h>
+#include <linux/wait.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/dcache.h>
+#include <linux/stat.h>
+#include <linux/cache.h>
+#include <linux/kobject.h>
+#include <linux/list.h>
+#include <linux/radix-tree.h>
+#include <linux/prio_tree.h>
+#include <linux/init.h>
+
+#include <asm/atomic.h>
+#include <asm/semaphore.h>
+#include <asm/byteorder.h>
+
+struct iovec;
+struct nameidata;
+struct pipe_inode_info;
+struct poll_table_struct;
+struct kstatfs;
+struct vm_area_struct;
+struct vfsmount;
+
+/* Used to be a macro which just called the function, now just a function */
+extern void update_atime (struct inode *);
+
+extern void __init inode_init(unsigned long);
+extern void __init inode_init_early(void);
+extern void __init mnt_init(unsigned long);
+extern void __init files_init(unsigned long);
+
+struct buffer_head;
+typedef int (get_block_t)(struct inode *inode, sector_t iblock,
+			struct buffer_head *bh_result, int create);
+typedef int (get_blocks_t)(struct inode *inode, sector_t iblock,
+			unsigned long max_blocks,
+			struct buffer_head *bh_result, int create);
+typedef void (dio_iodone_t)(struct inode *inode, loff_t offset,
+			ssize_t bytes, void *private);
+
+/*
+ * Attribute flags.  These should be or-ed together to figure out what
+ * has been changed!
+ */
+#define ATTR_MODE	1
+#define ATTR_UID	2
+#define ATTR_GID	4
+#define ATTR_SIZE	8
+#define ATTR_ATIME	16
+#define ATTR_MTIME	32
+#define ATTR_CTIME	64
+#define ATTR_ATIME_SET	128
+#define ATTR_MTIME_SET	256
+#define ATTR_FORCE	512	/* Not a change, but a change it */
+#define ATTR_ATTR_FLAG	1024
+#define ATTR_KILL_SUID	2048
+#define ATTR_KILL_SGID	4096
+
+/*
+ * This is the Inode Attributes structure, used for notify_change().  It
+ * uses the above definitions as flags, to know which values have changed.
+ * Also, in this manner, a Filesystem can look at only the values it cares
+ * about.  Basically, these are the attributes that the VFS layer can
+ * request to change from the FS layer.
+ *
+ * Derek Atkins <warlord@MIT.EDU> 94-10-20
+ */
+struct iattr {
+	unsigned int	ia_valid;
+	umode_t		ia_mode;
+	uid_t		ia_uid;
+	gid_t		ia_gid;
+	loff_t		ia_size;
+	struct timespec	ia_atime;
+	struct timespec	ia_mtime;
+	struct timespec	ia_ctime;
+	unsigned int	ia_attr_flags;
+};
+
+/*
+ * This is the inode attributes flag definitions
+ */
+#define ATTR_FLAG_SYNCRONOUS	1 	/* Syncronous write */
+#define ATTR_FLAG_NOATIME	2 	/* Don't update atime */
+#define ATTR_FLAG_APPEND	4 	/* Append-only file */
+#define ATTR_FLAG_IMMUTABLE	8 	/* Immutable file */
+#define ATTR_FLAG_NODIRATIME	16 	/* Don't update atime for directory */
+
+/*
+ * Includes for diskquotas.
+ */
+#include <linux/quota.h>
+
+/*
+ * oh the beauties of C type declarations.
+ */
+struct page;
+struct address_space;
+struct writeback_control;
+struct kiocb;
+
+struct address_space_operations {
+	int (*writepage)(struct page *page, struct writeback_control *wbc);
+	int (*readpage)(struct file *, struct page *);
+	int (*sync_page)(struct page *);
+
+	/* Write back some dirty pages from this mapping. */
+	int (*writepages)(struct address_space *, struct writeback_control *);
+
+	/* Set a page dirty */
+	int (*set_page_dirty)(struct page *page);
+
+	int (*readpages)(struct file *filp, struct address_space *mapping,
+			struct list_head *pages, unsigned nr_pages);
+
+	/*
+	 * ext3 requires that a successful prepare_write() call be followed
+	 * by a commit_write() call - they must be balanced
+	 */
+	int (*prepare_write)(struct file *, struct page *, unsigned, unsigned);
+	int (*commit_write)(struct file *, struct page *, unsigned, unsigned);
+	/* Unfortunately this kludge is needed for FIBMAP. Don't use it */
+	sector_t (*bmap)(struct address_space *, sector_t);
+	int (*invalidatepage) (struct page *, unsigned long);
+	int (*releasepage) (struct page *, int);
+	ssize_t (*direct_IO)(int, struct kiocb *, const struct iovec *iov,
+			loff_t offset, unsigned long nr_segs);
+};
+
+struct backing_dev_info;
+struct address_space {
+	struct inode		*host;		/* owner: inode, block_device */
+	struct radix_tree_root	page_tree;	/* radix tree of all pages */
+	rwlock_t		tree_lock;	/* and rwlock protecting it */
+	unsigned int		i_mmap_writable;/* count VM_SHARED mappings */
+	struct prio_tree_root	i_mmap;		/* tree of private and shared mappings */
+	struct list_head	i_mmap_nonlinear;/*list VM_NONLINEAR mappings */
+	spinlock_t		i_mmap_lock;	/* protect tree, count, list */
+	unsigned int		truncate_count;	/* Cover race condition with truncate */
+	unsigned long		nrpages;	/* number of total pages */
+	pgoff_t			writeback_index;/* writeback starts here */
+	struct address_space_operations *a_ops;	/* methods */
+	unsigned long		flags;		/* error bits/gfp mask */
+	struct backing_dev_info *backing_dev_info; /* device readahead, etc */
+	spinlock_t		private_lock;	/* for use by the address_space */
+	struct list_head	private_list;	/* ditto */
+	struct address_space	*assoc_mapping;	/* ditto */
+} __attribute__((aligned(sizeof(long))));
+	/*
+	 * On most architectures that alignment is already the case; but
+	 * must be enforced here for CRIS, to let the least signficant bit
+	 * of struct page's "mapping" pointer be used for PAGE_MAPPING_ANON.
+	 */
+
+struct block_device {
+	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
+	struct inode *		bd_inode;	/* will die */
+	int			bd_openers;
+	struct semaphore	bd_sem;	/* open/close mutex */
+	struct semaphore	bd_mount_sem;	/* mount mutex */
+	struct list_head	bd_inodes;
+	void *			bd_holder;
+	int			bd_holders;
+	struct block_device *	bd_contains;
+	unsigned		bd_block_size;
+	struct hd_struct *	bd_part;
+	/* number of times partitions within this device have been opened. */
+	unsigned		bd_part_count;
+	int			bd_invalidated;
+	struct gendisk *	bd_disk;
+	struct list_head	bd_list;
+	struct backing_dev_info *bd_inode_backing_dev_info;
+	/*
+	 * Private data.  You must have bd_claim'ed the block_device
+	 * to use this.  NOTE:  bd_claim allows an owner to claim
+	 * the same device multiple times, the owner must take special
+	 * care to not mess up bd_private for that case.
+	 */
+	unsigned long		bd_private;
+};
+
+/*
+ * Radix-tree tags, for tagging dirty and writeback pages within the pagecache
+ * radix trees
+ */
+#define PAGECACHE_TAG_DIRTY	0
+#define PAGECACHE_TAG_WRITEBACK	1
+
+int mapping_tagged(struct address_space *mapping, int tag);
+
+/*
+ * Might pages of this file be mapped into userspace?
+ */
+static inline int mapping_mapped(struct address_space *mapping)
+{
+	return	!prio_tree_empty(&mapping->i_mmap) ||
+		!list_empty(&mapping->i_mmap_nonlinear);
+}
+
+/*
+ * Might pages of this file have been modified in userspace?
+ * Note that i_mmap_writable counts all VM_SHARED vmas: do_mmap_pgoff
+ * marks vma as VM_SHARED if it is shared, and the file was opened for
+ * writing i.e. vma may be mprotected writable even if now readonly.
+ */
+static inline int mapping_writably_mapped(struct address_space *mapping)
+{
+	return mapping->i_mmap_writable != 0;
+}
+
+/*
+ * Use sequence counter to get consistent i_size on 32-bit processors.
+ */
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+#include <linux/seqlock.h>
+#define __NEED_I_SIZE_ORDERED
+#define i_size_ordered_init(inode) seqcount_init(&inode->i_size_seqcount)
+#else
+#define i_size_ordered_init(inode) do { } while (0)
+#endif
+
+struct inode {
+	struct hlist_node	i_hash;
+	struct list_head	i_list;
+	struct list_head	i_sb_list;
+	struct list_head	i_dentry;
+	unsigned long		i_ino;
+	atomic_t		i_count;
+	umode_t			i_mode;
+	unsigned int		i_nlink;
+	uid_t			i_uid;
+	gid_t			i_gid;
+	dev_t			i_rdev;
+	loff_t			i_size;
+	struct timespec		i_atime;
+	struct timespec		i_mtime;
+	struct timespec		i_ctime;
+	unsigned int		i_blkbits;
+	unsigned long		i_blksize;
+	unsigned long		i_version;
+	unsigned long		i_blocks;
+	unsigned short          i_bytes;
+	spinlock_t		i_lock;	/* i_blocks, i_bytes, maybe i_size */
+	struct semaphore	i_sem;
+	struct rw_semaphore	i_alloc_sem;
+	struct inode_operations	*i_op;
+	struct file_operations	*i_fop;	/* former ->i_op->default_file_ops */
+	struct super_block	*i_sb;
+	struct file_lock	*i_flock;
+	struct address_space	*i_mapping;
+	struct address_space	i_data;
+#ifdef CONFIG_QUOTA
+	struct dquot		*i_dquot[MAXQUOTAS];
+#endif
+	/* These three should probably be a union */
+	struct list_head	i_devices;
+	struct pipe_inode_info	*i_pipe;
+	struct block_device	*i_bdev;
+	struct cdev		*i_cdev;
+	int			i_cindex;
+
+	__u32			i_generation;
+
+#ifdef CONFIG_DNOTIFY
+	unsigned long		i_dnotify_mask; /* Directory notify events */
+	struct dnotify_struct	*i_dnotify; /* for directory notifications */
+#endif
+
+	unsigned long		i_state;
+	unsigned long		dirtied_when;	/* jiffies of first dirtying */
+
+	unsigned int		i_flags;
+
+	atomic_t		i_writecount;
+	void			*i_security;
+	union {
+		void		*generic_ip;
+	} u;
+#ifdef __NEED_I_SIZE_ORDERED
+	seqcount_t		i_size_seqcount;
+#endif
+};
+
+/*
+ * NOTE: in a 32bit arch with a preemptable kernel and
+ * an UP compile the i_size_read/write must be atomic
+ * with respect to the local cpu (unlike with preempt disabled),
+ * but they don't need to be atomic with respect to other cpus like in
+ * true SMP (so they need either to either locally disable irq around
+ * the read or for example on x86 they can be still implemented as a
+ * cmpxchg8b without the need of the lock prefix). For SMP compiles
+ * and 64bit archs it makes no difference if preempt is enabled or not.
+ */
+static inline loff_t i_size_read(struct inode *inode)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	loff_t i_size;
+	unsigned int seq;
+
+	do {
+		seq = read_seqcount_begin(&inode->i_size_seqcount);
+		i_size = inode->i_size;
+	} while (read_seqcount_retry(&inode->i_size_seqcount, seq));
+	return i_size;
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+	loff_t i_size;
+
+	preempt_disable();
+	i_size = inode->i_size;
+	preempt_enable();
+	return i_size;
+#else
+	return inode->i_size;
+#endif
+}
+
+
+static inline void i_size_write(struct inode *inode, loff_t i_size)
+{
+#if BITS_PER_LONG==32 && defined(CONFIG_SMP)
+	write_seqcount_begin(&inode->i_size_seqcount);
+	inode->i_size = i_size;
+	write_seqcount_end(&inode->i_size_seqcount);
+#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPT)
+	preempt_disable();
+	inode->i_size = i_size;
+	preempt_enable();
+#else
+	inode->i_size = i_size;
+#endif
+}
+
+static inline unsigned iminor(struct inode *inode)
+{
+	return MINOR(inode->i_rdev);
+}
+
+static inline unsigned imajor(struct inode *inode)
+{
+	return MAJOR(inode->i_rdev);
+}
+
+extern struct block_device *I_BDEV(struct inode *inode);
+
+struct fown_struct {
+	rwlock_t lock;          /* protects pid, uid, euid fields */
+	int pid;		/* pid or -pgrp where SIGIO should be sent */
+	uid_t uid, euid;	/* uid/euid of process setting the owner */
+	void *security;
+	int signum;		/* posix.1b rt signal to be delivered on IO */
+};
+
+/*
+ * Track a single file's readahead state
+ */
+struct file_ra_state {
+	unsigned long start;		/* Current window */
+	unsigned long size;
+	unsigned long flags;		/* ra flags RA_FLAG_xxx*/
+	unsigned long cache_hit;	/* cache hit count*/
+	unsigned long prev_page;	/* Cache last read() position */
+	unsigned long ahead_start;	/* Ahead window */
+	unsigned long ahead_size;
+	unsigned long ra_pages;		/* Maximum readahead window */
+	unsigned long mmap_hit;		/* Cache hit stat for mmap accesses */
+	unsigned long mmap_miss;	/* Cache miss stat for mmap accesses */
+};
+#define RA_FLAG_MISS 0x01	/* a cache miss occured against this file */
+#define RA_FLAG_INCACHE 0x02	/* file is already in cache */
+
+struct file {
+	struct list_head	f_list;
+	struct dentry		*f_dentry;
+	struct vfsmount         *f_vfsmnt;
+	struct file_operations	*f_op;
+	atomic_t		f_count;
+	unsigned int 		f_flags;
+	mode_t			f_mode;
+	int			f_error;
+	loff_t			f_pos;
+	struct fown_struct	f_owner;
+	unsigned int		f_uid, f_gid;
+	struct file_ra_state	f_ra;
+
+	size_t			f_maxcount;
+	unsigned long		f_version;
+	void			*f_security;
+
+	/* needed for tty driver, and maybe others */
+	void			*private_data;
+
+#ifdef CONFIG_EPOLL
+	/* Used by fs/eventpoll.c to link all the hooks to this file */
+	struct list_head	f_ep_links;
+	spinlock_t		f_ep_lock;
+#endif /* #ifdef CONFIG_EPOLL */
+	struct address_space	*f_mapping;
+};
+extern spinlock_t files_lock;
+#define file_list_lock() spin_lock(&files_lock);
+#define file_list_unlock() spin_unlock(&files_lock);
+
+#define get_file(x)	atomic_inc(&(x)->f_count)
+#define file_count(x)	atomic_read(&(x)->f_count)
+
+#define	MAX_NON_LFS	((1UL<<31) - 1)
+
+/* Page cache limit. The filesystems should put that into their s_maxbytes 
+   limits, otherwise bad things can happen in VM. */ 
+#if BITS_PER_LONG==32
+#define MAX_LFS_FILESIZE	(((u64)PAGE_CACHE_SIZE << (BITS_PER_LONG-1))-1) 
+#elif BITS_PER_LONG==64
+#define MAX_LFS_FILESIZE 	0x7fffffffffffffffUL
+#endif
+
+#define FL_POSIX	1
+#define FL_FLOCK	2
+#define FL_ACCESS	8	/* not trying to lock, just looking */
+#define FL_LOCKD	16	/* lock held by rpc.lockd */
+#define FL_LEASE	32	/* lease held on this file */
+#define FL_SLEEP	128	/* A blocking lock */
+
+/*
+ * The POSIX file lock owner is determined by
+ * the "struct files_struct" in the thread group
+ * (or NULL for no owner - BSD locks).
+ *
+ * Lockd stuffs a "host" pointer into this.
+ */
+typedef struct files_struct *fl_owner_t;
+
+struct file_lock_operations {
+	void (*fl_insert)(struct file_lock *);	/* lock insertion callback */
+	void (*fl_remove)(struct file_lock *);	/* lock removal callback */
+	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+	void (*fl_release_private)(struct file_lock *);
+};
+
+struct lock_manager_operations {
+	int (*fl_compare_owner)(struct file_lock *, struct file_lock *);
+	void (*fl_notify)(struct file_lock *);	/* unblock callback */
+	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
+	void (*fl_release_private)(struct file_lock *);
+	void (*fl_break)(struct file_lock *);
+	int (*fl_mylease)(struct file_lock *, struct file_lock *);
+	int (*fl_change)(struct file_lock **, int);
+};
+
+/* that will die - we need it for nfs_lock_info */
+#include <linux/nfs_fs_i.h>
+
+struct file_lock {
+	struct file_lock *fl_next;	/* singly linked list for this inode  */
+	struct list_head fl_link;	/* doubly linked list of all locks */
+	struct list_head fl_block;	/* circular list of blocked processes */
+	fl_owner_t fl_owner;
+	unsigned int fl_pid;
+	wait_queue_head_t fl_wait;
+	struct file *fl_file;
+	unsigned char fl_flags;
+	unsigned char fl_type;
+	loff_t fl_start;
+	loff_t fl_end;
+
+	struct fasync_struct *	fl_fasync; /* for lease break notifications */
+	unsigned long fl_break_time;	/* for nonblocking lease breaks */
+
+	struct file_lock_operations *fl_ops;	/* Callbacks for filesystems */
+	struct lock_manager_operations *fl_lmops;	/* Callbacks for lockmanagers */
+	union {
+		struct nfs_lock_info	nfs_fl;
+	} fl_u;
+};
+
+/* The following constant reflects the upper bound of the file/locking space */
+#ifndef OFFSET_MAX
+#define INT_LIMIT(x)	(~((x)1 << (sizeof(x)*8 - 1)))
+#define OFFSET_MAX	INT_LIMIT(loff_t)
+#define OFFT_OFFSET_MAX	INT_LIMIT(off_t)
+#endif
+
+extern struct list_head file_lock_list;
+
+#include <linux/fcntl.h>
+
+extern int fcntl_getlk(struct file *, struct flock __user *);
+extern int fcntl_setlk(struct file *, unsigned int, struct flock __user *);
+
+#if BITS_PER_LONG == 32
+extern int fcntl_getlk64(struct file *, struct flock64 __user *);
+extern int fcntl_setlk64(struct file *, unsigned int, struct flock64 __user *);
+#endif
+
+extern void send_sigio(struct fown_struct *fown, int fd, int band);
+extern int fcntl_setlease(unsigned int fd, struct file *filp, long arg);
+extern int fcntl_getlease(struct file *filp);
+
+/* fs/locks.c */
+extern void locks_init_lock(struct file_lock *);
+extern void locks_copy_lock(struct file_lock *, struct file_lock *);
+extern void locks_remove_posix(struct file *, fl_owner_t);
+extern void locks_remove_flock(struct file *);
+extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
+extern int posix_lock_file(struct file *, struct file_lock *);
+extern int posix_lock_file_wait(struct file *, struct file_lock *);
+extern void posix_block_lock(struct file_lock *, struct file_lock *);
+extern void posix_unblock_lock(struct file *, struct file_lock *);
+extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
+extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
+extern int __break_lease(struct inode *inode, unsigned int flags);
+extern void lease_get_mtime(struct inode *, struct timespec *time);
+extern int setlease(struct file *, long, struct file_lock **);
+extern int lease_modify(struct file_lock **, int);
+extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
+extern int lock_may_write(struct inode *, loff_t start, unsigned long count);
+extern void steal_locks(fl_owner_t from);
+
+struct fasync_struct {
+	int	magic;
+	int	fa_fd;
+	struct	fasync_struct	*fa_next; /* singly linked list */
+	struct	file 		*fa_file;
+};
+
+#define FASYNC_MAGIC 0x4601
+
+/* SMP safe fasync helpers: */
+extern int fasync_helper(int, struct file *, int, struct fasync_struct **);
+/* can be called from interrupts */
+extern void kill_fasync(struct fasync_struct **, int, int);
+/* only for net: no internal synchronization */
+extern void __kill_fasync(struct fasync_struct *, int, int);
+
+extern int f_setown(struct file *filp, unsigned long arg, int force);
+extern void f_delown(struct file *filp);
+extern int send_sigurg(struct fown_struct *fown);
+
+/*
+ *	Umount options
+ */
+
+#define MNT_FORCE	0x00000001	/* Attempt to forcibily umount */
+#define MNT_DETACH	0x00000002	/* Just detach from the tree */
+#define MNT_EXPIRE	0x00000004	/* Mark for expiry */
+
+extern struct list_head super_blocks;
+extern spinlock_t sb_lock;
+
+#define sb_entry(list)	list_entry((list), struct super_block, s_list)
+#define S_BIAS (1<<30)
+struct super_block {
+	struct list_head	s_list;		/* Keep this first */
+	dev_t			s_dev;		/* search index; _not_ kdev_t */
+	unsigned long		s_blocksize;
+	unsigned long		s_old_blocksize;
+	unsigned char		s_blocksize_bits;
+	unsigned char		s_dirt;
+	unsigned long long	s_maxbytes;	/* Max file size */
+	struct file_system_type	*s_type;
+	struct super_operations	*s_op;
+	struct dquot_operations	*dq_op;
+ 	struct quotactl_ops	*s_qcop;
+	struct export_operations *s_export_op;
+	unsigned long		s_flags;
+	unsigned long		s_magic;
+	struct dentry		*s_root;
+	struct rw_semaphore	s_umount;
+	struct semaphore	s_lock;
+	int			s_count;
+	int			s_syncing;
+	int			s_need_sync_fs;
+	atomic_t		s_active;
+	void                    *s_security;
+	struct xattr_handler	**s_xattr;
+
+	struct list_head	s_inodes;	/* all inodes */
+	struct list_head	s_dirty;	/* dirty inodes */
+	struct list_head	s_io;		/* parked for writeback */
+	struct hlist_head	s_anon;		/* anonymous dentries for (nfs) exporting */
+	struct list_head	s_files;
+
+	struct block_device	*s_bdev;
+	struct list_head	s_instances;
+	struct quota_info	s_dquot;	/* Diskquota specific options */
+
+	int			s_frozen;
+	wait_queue_head_t	s_wait_unfrozen;
+
+	char s_id[32];				/* Informational name */
+
+	void 			*s_fs_info;	/* Filesystem private info */
+
+	/*
+	 * The next field is for VFS *only*. No filesystems have any business
+	 * even looking at it. You had been warned.
+	 */
+	struct semaphore s_vfs_rename_sem;	/* Kludge */
+
+	/* Granuality of c/m/atime in ns.
+	   Cannot be worse than a second */
+	u32		   s_time_gran;
+};
+
+extern struct timespec current_fs_time(struct super_block *sb);
+
+/*
+ * Snapshotting support.
+ */
+enum {
+	SB_UNFROZEN = 0,
+	SB_FREEZE_WRITE	= 1,
+	SB_FREEZE_TRANS = 2,
+};
+
+#define vfs_check_frozen(sb, level) \
+	wait_event((sb)->s_wait_unfrozen, ((sb)->s_frozen < (level)))
+
+/*
+ * Superblock locking.
+ */
+static inline void lock_super(struct super_block * sb)
+{
+	down(&sb->s_lock);
+}
+
+static inline void unlock_super(struct super_block * sb)
+{
+	up(&sb->s_lock);
+}
+
+/*
+ * VFS helper functions..
+ */
+extern int vfs_create(struct inode *, struct dentry *, int, struct nameidata *);
+extern int vfs_mkdir(struct inode *, struct dentry *, int);
+extern int vfs_mknod(struct inode *, struct dentry *, int, dev_t);
+extern int vfs_symlink(struct inode *, struct dentry *, const char *, int);
+extern int vfs_link(struct dentry *, struct inode *, struct dentry *);
+extern int vfs_rmdir(struct inode *, struct dentry *);
+extern int vfs_unlink(struct inode *, struct dentry *);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+
+/*
+ * VFS dentry helper functions.
+ */
+extern void dentry_unhash(struct dentry *dentry);
+
+/*
+ * File types
+ *
+ * NOTE! These match bits 12..15 of stat.st_mode
+ * (ie "(i_mode >> 12) & 15").
+ */
+#define DT_UNKNOWN	0
+#define DT_FIFO		1
+#define DT_CHR		2
+#define DT_DIR		4
+#define DT_BLK		6
+#define DT_REG		8
+#define DT_LNK		10
+#define DT_SOCK		12
+#define DT_WHT		14
+
+#define OSYNC_METADATA	(1<<0)
+#define OSYNC_DATA	(1<<1)
+#define OSYNC_INODE	(1<<2)
+int generic_osync_inode(struct inode *, struct address_space *, int);
+
+/*
+ * This is the "filldir" function type, used by readdir() to let
+ * the kernel specify what kind of dirent layout it wants to have.
+ * This allows the kernel to read directories into kernel space or
+ * to have different dirent layouts depending on the binary type.
+ */
+typedef int (*filldir_t)(void *, const char *, int, loff_t, ino_t, unsigned);
+
+struct block_device_operations {
+	int (*open) (struct inode *, struct file *);
+	int (*release) (struct inode *, struct file *);
+	int (*ioctl) (struct inode *, struct file *, unsigned, unsigned long);
+	long (*compat_ioctl) (struct file *, unsigned, unsigned long);
+	int (*media_changed) (struct gendisk *);
+	int (*revalidate_disk) (struct gendisk *);
+	struct module *owner;
+};
+
+/*
+ * "descriptor" for what we're up to with a read for sendfile().
+ * This allows us to use the same read code yet
+ * have multiple different users of the data that
+ * we read from a file.
+ *
+ * The simplest case just copies the data to user
+ * mode.
+ */
+typedef struct {
+	size_t written;
+	size_t count;
+	union {
+		char __user * buf;
+		void *data;
+	} arg;
+	int error;
+} read_descriptor_t;
+
+typedef int (*read_actor_t)(read_descriptor_t *, struct page *, unsigned long, unsigned long);
+
+/* These macros are for out of kernel modules to test that
+ * the kernel supports the unlocked_ioctl and compat_ioctl
+ * fields in struct file_operations. */
+#define HAVE_COMPAT_IOCTL 1
+#define HAVE_UNLOCKED_IOCTL 1
+
+/*
+ * NOTE:
+ * read, write, poll, fsync, readv, writev, unlocked_ioctl and compat_ioctl
+ * can be called without the big kernel lock held in all filesystems.
+ */
+struct file_operations {
+	struct module *owner;
+	loff_t (*llseek) (struct file *, loff_t, int);
+	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
+	ssize_t (*aio_read) (struct kiocb *, char __user *, size_t, loff_t);
+	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
+	ssize_t (*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);
+	int (*readdir) (struct file *, void *, filldir_t);
+	unsigned int (*poll) (struct file *, struct poll_table_struct *);
+	int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);
+	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
+	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
+	int (*mmap) (struct file *, struct vm_area_struct *);
+	int (*open) (struct inode *, struct file *);
+	int (*flush) (struct file *);
+	int (*release) (struct inode *, struct file *);
+	int (*fsync) (struct file *, struct dentry *, int datasync);
+	int (*aio_fsync) (struct kiocb *, int datasync);
+	int (*fasync) (int, struct file *, int);
+	int (*lock) (struct file *, int, struct file_lock *);
+	ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);
+	ssize_t (*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);
+	ssize_t (*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void *);
+	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
+	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
+	int (*check_flags)(int);
+	int (*dir_notify)(struct file *filp, unsigned long arg);
+	int (*flock) (struct file *, int, struct file_lock *);
+};
+
+struct inode_operations {
+	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);
+	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);
+	int (*link) (struct dentry *,struct inode *,struct dentry *);
+	int (*unlink) (struct inode *,struct dentry *);
+	int (*symlink) (struct inode *,struct dentry *,const char *);
+	int (*mkdir) (struct inode *,struct dentry *,int);
+	int (*rmdir) (struct inode *,struct dentry *);
+	int (*mknod) (struct inode *,struct dentry *,int,dev_t);
+	int (*rename) (struct inode *, struct dentry *,
+			struct inode *, struct dentry *);
+	int (*readlink) (struct dentry *, char __user *,int);
+	int (*follow_link) (struct dentry *, struct nameidata *);
+	void (*put_link) (struct dentry *, struct nameidata *);
+	void (*truncate) (struct inode *);
+	int (*permission) (struct inode *, int, struct nameidata *);
+	int (*setattr) (struct dentry *, struct iattr *);
+	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
+	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
+	ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+	ssize_t (*listxattr) (struct dentry *, char *, size_t);
+	int (*removexattr) (struct dentry *, const char *);
+};
+
+struct seq_file;
+
+extern ssize_t vfs_read(struct file *, char __user *, size_t, loff_t *);
+extern ssize_t vfs_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t vfs_readv(struct file *, const struct iovec __user *,
+		unsigned long, loff_t *);
+extern ssize_t vfs_writev(struct file *, const struct iovec __user *,
+		unsigned long, loff_t *);
+
+/*
+ * NOTE: write_inode, delete_inode, clear_inode, put_inode can be called
+ * without the big kernel lock held in all filesystems.
+ */
+struct super_operations {
+   	struct inode *(*alloc_inode)(struct super_block *sb);
+	void (*destroy_inode)(struct inode *);
+
+	void (*read_inode) (struct inode *);
+  
+   	void (*dirty_inode) (struct inode *);
+	int (*write_inode) (struct inode *, int);
+	void (*put_inode) (struct inode *);
+	void (*drop_inode) (struct inode *);
+	void (*delete_inode) (struct inode *);
+	void (*put_super) (struct super_block *);
+	void (*write_super) (struct super_block *);
+	int (*sync_fs)(struct super_block *sb, int wait);
+	void (*write_super_lockfs) (struct super_block *);
+	void (*unlockfs) (struct super_block *);
+	int (*statfs) (struct super_block *, struct kstatfs *);
+	int (*remount_fs) (struct super_block *, int *, char *);
+	void (*clear_inode) (struct inode *);
+	void (*umount_begin) (struct super_block *);
+
+	int (*show_options)(struct seq_file *, struct vfsmount *);
+
+	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
+	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
+};
+
+/* Inode state bits.  Protected by inode_lock. */
+#define I_DIRTY_SYNC		1 /* Not dirty enough for O_DATASYNC */
+#define I_DIRTY_DATASYNC	2 /* Data-related inode changes pending */
+#define I_DIRTY_PAGES		4 /* Data-related inode changes pending */
+#define __I_LOCK		3
+#define I_LOCK			(1 << __I_LOCK)
+#define I_FREEING		16
+#define I_CLEAR			32
+#define I_NEW			64
+
+#define I_DIRTY (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)
+
+extern void __mark_inode_dirty(struct inode *, int);
+static inline void mark_inode_dirty(struct inode *inode)
+{
+	__mark_inode_dirty(inode, I_DIRTY);
+}
+
+static inline void mark_inode_dirty_sync(struct inode *inode)
+{
+	__mark_inode_dirty(inode, I_DIRTY_SYNC);
+}
+
+static inline void touch_atime(struct vfsmount *mnt, struct dentry *dentry)
+{
+	/* per-mountpoint checks will go here */
+	update_atime(dentry->d_inode);
+}
+
+static inline void file_accessed(struct file *file)
+{
+	if (!(file->f_flags & O_NOATIME))
+		touch_atime(file->f_vfsmnt, file->f_dentry);
+}
+
+int sync_inode(struct inode *inode, struct writeback_control *wbc);
+
+/**
+ * &export_operations - for nfsd to communicate with file systems
+ * decode_fh:      decode a file handle fragment and return a &struct dentry
+ * encode_fh:      encode a file handle fragment from a dentry
+ * get_name:       find the name for a given inode in a given directory
+ * get_parent:     find the parent of a given directory
+ * get_dentry:     find a dentry for the inode given a file handle sub-fragment
+ *
+ * Description:
+ *    The export_operations structure provides a means for nfsd to communicate
+ *    with a particular exported file system  - particularly enabling nfsd and
+ *    the filesystem to co-operate when dealing with file handles.
+ *
+ *    export_operations contains two basic operation for dealing with file handles,
+ *    decode_fh() and encode_fh(), and allows for some other operations to be defined
+ *    which standard helper routines use to get specific information from the
+ *    filesystem.
+ *
+ *    nfsd encodes information use to determine which filesystem a filehandle
+ *    applies to in the initial part of the file handle.  The remainder, termed a
+ *    file handle fragment, is controlled completely by the filesystem.
+ *    The standard helper routines assume that this fragment will contain one or two
+ *    sub-fragments, one which identifies the file, and one which may be used to
+ *    identify the (a) directory containing the file.
+ *
+ *    In some situations, nfsd needs to get a dentry which is connected into a
+ *    specific part of the file tree.  To allow for this, it passes the function
+ *    acceptable() together with a @context which can be used to see if the dentry
+ *    is acceptable.  As there can be multiple dentrys for a given file, the filesystem
+ *    should check each one for acceptability before looking for the next.  As soon
+ *    as an acceptable one is found, it should be returned.
+ *
+ * decode_fh:
+ *    @decode_fh is given a &struct super_block (@sb), a file handle fragment (@fh, @fh_len)
+ *    and an acceptability testing function (@acceptable, @context).  It should return
+ *    a &struct dentry which refers to the same file that the file handle fragment refers
+ *    to,  and which passes the acceptability test.  If it cannot, it should return
+ *    a %NULL pointer if the file was found but no acceptable &dentries were available, or
+ *    a %ERR_PTR error code indicating why it couldn't be found (e.g. %ENOENT or %ENOMEM).
+ *
+ * encode_fh:
+ *    @encode_fh should store in the file handle fragment @fh (using at most @max_len bytes)
+ *    information that can be used by @decode_fh to recover the file refered to by the
+ *    &struct dentry @de.  If the @connectable flag is set, the encode_fh() should store
+ *    sufficient information so that a good attempt can be made to find not only
+ *    the file but also it's place in the filesystem.   This typically means storing
+ *    a reference to de->d_parent in the filehandle fragment.
+ *    encode_fh() should return the number of bytes stored or a negative error code
+ *    such as %-ENOSPC
+ *
+ * get_name:
+ *    @get_name should find a name for the given @child in the given @parent directory.
+ *    The name should be stored in the @name (with the understanding that it is already
+ *    pointing to a a %NAME_MAX+1 sized buffer.   get_name() should return %0 on success,
+ *    a negative error code or error.
+ *    @get_name will be called without @parent->i_sem held.
+ *
+ * get_parent:
+ *    @get_parent should find the parent directory for the given @child which is also
+ *    a directory.  In the event that it cannot be found, or storage space cannot be
+ *    allocated, a %ERR_PTR should be returned.
+ *
+ * get_dentry:
+ *    Given a &super_block (@sb) and a pointer to a file-system specific inode identifier,
+ *    possibly an inode number, (@inump) get_dentry() should find the identified inode and
+ *    return a dentry for that inode.
+ *    Any suitable dentry can be returned including, if necessary, a new dentry created
+ *    with d_alloc_root.  The caller can then find any other extant dentrys by following the
+ *    d_alias links.  If a new dentry was created using d_alloc_root, DCACHE_NFSD_DISCONNECTED
+ *    should be set, and the dentry should be d_rehash()ed.
+ *
+ *    If the inode cannot be found, either a %NULL pointer or an %ERR_PTR code can be returned.
+ *    The @inump will be whatever was passed to nfsd_find_fh_dentry() in either the
+ *    @obj or @parent parameters.
+ *
+ * Locking rules:
+ *  get_parent is called with child->d_inode->i_sem down
+ *  get_name is not (which is possibly inconsistent)
+ */
+
+struct export_operations {
+	struct dentry *(*decode_fh)(struct super_block *sb, __u32 *fh, int fh_len, int fh_type,
+			 int (*acceptable)(void *context, struct dentry *de),
+			 void *context);
+	int (*encode_fh)(struct dentry *de, __u32 *fh, int *max_len,
+			 int connectable);
+
+	/* the following are only called from the filesystem itself */
+	int (*get_name)(struct dentry *parent, char *name,
+			struct dentry *child);
+	struct dentry * (*get_parent)(struct dentry *child);
+	struct dentry * (*get_dentry)(struct super_block *sb, void *inump);
+
+	/* This is set by the exporting module to a standard helper */
+	struct dentry * (*find_exported_dentry)(
+		struct super_block *sb, void *obj, void *parent,
+		int (*acceptable)(void *context, struct dentry *de),
+		void *context);
+
+
+};
+
+extern struct dentry *
+find_exported_dentry(struct super_block *sb, void *obj, void *parent,
+		     int (*acceptable)(void *context, struct dentry *de),
+		     void *context);
+
+struct file_system_type {
+	const char *name;
+	int fs_flags;
+	struct super_block *(*get_sb) (struct file_system_type *, int,
+				       const char *, void *);
+	void (*kill_sb) (struct super_block *);
+	struct module *owner;
+	struct file_system_type * next;
+	struct list_head fs_supers;
+};
+
+struct super_block *get_sb_bdev(struct file_system_type *fs_type,
+	int flags, const char *dev_name, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
+struct super_block *get_sb_single(struct file_system_type *fs_type,
+	int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
+struct super_block *get_sb_nodev(struct file_system_type *fs_type,
+	int flags, void *data,
+	int (*fill_super)(struct super_block *, void *, int));
+void generic_shutdown_super(struct super_block *sb);
+void kill_block_super(struct super_block *sb);
+void kill_anon_super(struct super_block *sb);
+void kill_litter_super(struct super_block *sb);
+void deactivate_super(struct super_block *sb);
+int set_anon_super(struct super_block *s, void *data);
+struct super_block *sget(struct file_system_type *type,
+			int (*test)(struct super_block *,void *),
+			int (*set)(struct super_block *,void *),
+			void *data);
+struct super_block *get_sb_pseudo(struct file_system_type *, char *,
+			struct super_operations *ops, unsigned long);
+int __put_super(struct super_block *sb);
+int __put_super_and_need_restart(struct super_block *sb);
+void unnamed_dev_init(void);
+
+/* Alas, no aliases. Too much hassle with bringing module.h everywhere */
+#define fops_get(fops) \
+	(((fops) && try_module_get((fops)->owner) ? (fops) : NULL))
+#define fops_put(fops) \
+	do { if (fops) module_put((fops)->owner); } while(0)
+
+extern int register_filesystem(struct file_system_type *);
+extern int unregister_filesystem(struct file_system_type *);
+extern struct vfsmount *kern_mount(struct file_system_type *);
+extern int may_umount_tree(struct vfsmount *);
+extern int may_umount(struct vfsmount *);
+extern long do_mount(char *, char *, char *, unsigned long, void *);
+
+extern int vfs_statfs(struct super_block *, struct kstatfs *);
+
+#define FLOCK_VERIFY_READ  1
+#define FLOCK_VERIFY_WRITE 2
+
+extern int locks_mandatory_locked(struct inode *);
+extern int locks_mandatory_area(int, struct inode *, struct file *, loff_t, size_t);
+
+/*
+ * Candidates for mandatory locking have the setgid bit set
+ * but no group execute bit -  an otherwise meaningless combination.
+ */
+#define MANDATORY_LOCK(inode) \
+	(IS_MANDLOCK(inode) && ((inode)->i_mode & (S_ISGID | S_IXGRP)) == S_ISGID)
+
+static inline int locks_verify_locked(struct inode *inode)
+{
+	if (MANDATORY_LOCK(inode))
+		return locks_mandatory_locked(inode);
+	return 0;
+}
+
+extern int rw_verify_area(int, struct file *, loff_t *, size_t);
+
+static inline int locks_verify_truncate(struct inode *inode,
+				    struct file *filp,
+				    loff_t size)
+{
+	if (inode->i_flock && MANDATORY_LOCK(inode))
+		return locks_mandatory_area(
+			FLOCK_VERIFY_WRITE, inode, filp,
+			size < inode->i_size ? size : inode->i_size,
+			(size < inode->i_size ? inode->i_size - size
+			 : size - inode->i_size)
+		);
+	return 0;
+}
+
+static inline int break_lease(struct inode *inode, unsigned int mode)
+{
+	if (inode->i_flock)
+		return __break_lease(inode, mode);
+	return 0;
+}
+
+/* fs/open.c */
+
+extern int do_truncate(struct dentry *, loff_t start);
+extern struct file *filp_open(const char *, int, int);
+extern struct file * dentry_open(struct dentry *, struct vfsmount *, int);
+extern int filp_close(struct file *, fl_owner_t id);
+extern char * getname(const char __user *);
+
+/* fs/dcache.c */
+extern void __init vfs_caches_init_early(void);
+extern void __init vfs_caches_init(unsigned long);
+
+#define __getname()	kmem_cache_alloc(names_cachep, SLAB_KERNEL)
+#define __putname(name) kmem_cache_free(names_cachep, (void *)(name))
+#ifndef CONFIG_AUDITSYSCALL
+#define putname(name)   __putname(name)
+#else
+extern void putname(const char *name);
+#endif
+
+extern int register_blkdev(unsigned int, const char *);
+extern int unregister_blkdev(unsigned int, const char *);
+extern struct block_device *bdget(dev_t);
+extern void bd_set_size(struct block_device *, loff_t size);
+extern void bd_forget(struct inode *inode);
+extern void bdput(struct block_device *);
+extern struct block_device *open_by_devnum(dev_t, unsigned);
+extern struct file_operations def_blk_fops;
+extern struct address_space_operations def_blk_aops;
+extern struct file_operations def_chr_fops;
+extern struct file_operations bad_sock_fops;
+extern struct file_operations def_fifo_fops;
+extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
+extern int blkdev_ioctl(struct inode *, struct file *, unsigned, unsigned long);
+extern long compat_blkdev_ioctl(struct file *, unsigned, unsigned long);
+extern int blkdev_get(struct block_device *, mode_t, unsigned);
+extern int blkdev_put(struct block_device *);
+extern int bd_claim(struct block_device *, void *);
+extern void bd_release(struct block_device *);
+
+/* fs/char_dev.c */
+extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);
+extern int register_chrdev_region(dev_t, unsigned, const char *);
+extern int register_chrdev(unsigned int, const char *,
+			   struct file_operations *);
+extern int unregister_chrdev(unsigned int, const char *);
+extern void unregister_chrdev_region(dev_t, unsigned);
+extern int chrdev_open(struct inode *, struct file *);
+
+/* fs/block_dev.c */
+#define BDEVNAME_SIZE	32	/* Largest string for a blockdev identifier */
+extern const char *__bdevname(dev_t, char *buffer);
+extern const char *bdevname(struct block_device *bdev, char *buffer);
+extern struct block_device *lookup_bdev(const char *);
+extern struct block_device *open_bdev_excl(const char *, int, void *);
+extern void close_bdev_excl(struct block_device *);
+
+extern void init_special_inode(struct inode *, umode_t, dev_t);
+
+/* Invalid inode operations -- fs/bad_inode.c */
+extern void make_bad_inode(struct inode *);
+extern int is_bad_inode(struct inode *);
+
+extern struct file_operations read_fifo_fops;
+extern struct file_operations write_fifo_fops;
+extern struct file_operations rdwr_fifo_fops;
+extern struct file_operations read_pipe_fops;
+extern struct file_operations write_pipe_fops;
+extern struct file_operations rdwr_pipe_fops;
+
+extern int fs_may_remount_ro(struct super_block *);
+
+/*
+ * return READ, READA, or WRITE
+ */
+#define bio_rw(bio)		((bio)->bi_rw & (RW_MASK | RWA_MASK))
+
+/*
+ * return data direction, READ or WRITE
+ */
+#define bio_data_dir(bio)	((bio)->bi_rw & 1)
+
+extern int check_disk_change(struct block_device *);
+extern int invalidate_inodes(struct super_block *);
+extern int __invalidate_device(struct block_device *, int);
+extern int invalidate_partition(struct gendisk *, int);
+unsigned long invalidate_mapping_pages(struct address_space *mapping,
+					pgoff_t start, pgoff_t end);
+unsigned long invalidate_inode_pages(struct address_space *mapping);
+static inline void invalidate_remote_inode(struct inode *inode)
+{
+	if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+	    S_ISLNK(inode->i_mode))
+		invalidate_inode_pages(inode->i_mapping);
+}
+extern int invalidate_inode_pages2(struct address_space *mapping);
+extern int invalidate_inode_pages2_range(struct address_space *mapping,
+					 pgoff_t start, pgoff_t end);
+extern int write_inode_now(struct inode *, int);
+extern int filemap_fdatawrite(struct address_space *);
+extern int filemap_flush(struct address_space *);
+extern int filemap_fdatawait(struct address_space *);
+extern int filemap_write_and_wait(struct address_space *mapping);
+extern int filemap_write_and_wait_range(struct address_space *mapping,
+				        loff_t lstart, loff_t lend);
+extern void sync_supers(void);
+extern void sync_filesystems(int wait);
+extern void emergency_sync(void);
+extern void emergency_remount(void);
+extern int do_remount_sb(struct super_block *sb, int flags,
+			 void *data, int force);
+extern sector_t bmap(struct inode *, sector_t);
+extern int setattr_mask(unsigned int);
+extern int notify_change(struct dentry *, struct iattr *);
+extern int permission(struct inode *, int, struct nameidata *);
+extern int generic_permission(struct inode *, int,
+		int (*check_acl)(struct inode *, int));
+
+extern int get_write_access(struct inode *);
+extern int deny_write_access(struct file *);
+static inline void put_write_access(struct inode * inode)
+{
+	atomic_dec(&inode->i_writecount);
+}
+static inline void allow_write_access(struct file *file)
+{
+	if (file)
+		atomic_inc(&file->f_dentry->d_inode->i_writecount);
+}
+extern int do_pipe(int *);
+
+extern int open_namei(const char *, int, int, struct nameidata *);
+extern int may_open(struct nameidata *, int, int);
+
+extern int kernel_read(struct file *, unsigned long, char *, unsigned long);
+extern struct file * open_exec(const char *);
+ 
+/* fs/dcache.c -- generic fs support functions */
+extern int is_subdir(struct dentry *, struct dentry *);
+extern ino_t find_inode_number(struct dentry *, struct qstr *);
+
+#include <linux/err.h>
+
+/* needed for stackable file system support */
+extern loff_t default_llseek(struct file *file, loff_t offset, int origin);
+
+extern loff_t vfs_llseek(struct file *file, loff_t offset, int origin);
+
+extern void inode_init_once(struct inode *);
+extern void iput(struct inode *);
+extern struct inode * igrab(struct inode *);
+extern ino_t iunique(struct super_block *, ino_t);
+extern int inode_needs_sync(struct inode *inode);
+extern void generic_delete_inode(struct inode *inode);
+
+extern struct inode *ilookup5(struct super_block *sb, unsigned long hashval,
+		int (*test)(struct inode *, void *), void *data);
+extern struct inode *ilookup(struct super_block *sb, unsigned long ino);
+
+extern struct inode * iget5_locked(struct super_block *, unsigned long, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *);
+extern struct inode * iget_locked(struct super_block *, unsigned long);
+extern void unlock_new_inode(struct inode *);
+
+static inline struct inode *iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode = iget_locked(sb, ino);
+	
+	if (inode && (inode->i_state & I_NEW)) {
+		sb->s_op->read_inode(inode);
+		unlock_new_inode(inode);
+	}
+
+	return inode;
+}
+
+extern void __iget(struct inode * inode);
+extern void clear_inode(struct inode *);
+extern void destroy_inode(struct inode *);
+extern struct inode *new_inode(struct super_block *);
+extern int remove_suid(struct dentry *);
+extern void remove_dquot_ref(struct super_block *, int, struct list_head *);
+extern struct semaphore iprune_sem;
+
+extern void __insert_inode_hash(struct inode *, unsigned long hashval);
+extern void remove_inode_hash(struct inode *);
+static inline void insert_inode_hash(struct inode *inode) {
+	__insert_inode_hash(inode, inode->i_ino);
+}
+
+extern struct file * get_empty_filp(void);
+extern void file_move(struct file *f, struct list_head *list);
+extern void file_kill(struct file *f);
+struct bio;
+extern void submit_bio(int, struct bio *);
+extern int bdev_read_only(struct block_device *);
+extern int set_blocksize(struct block_device *, int);
+extern int sb_set_blocksize(struct super_block *, int);
+extern int sb_min_blocksize(struct super_block *, int);
+
+extern int generic_file_mmap(struct file *, struct vm_area_struct *);
+extern int generic_file_readonly_mmap(struct file *, struct vm_area_struct *);
+extern int file_read_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
+extern int file_send_actor(read_descriptor_t * desc, struct page *page, unsigned long offset, unsigned long size);
+extern ssize_t generic_file_read(struct file *, char __user *, size_t, loff_t *);
+int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk);
+extern ssize_t generic_file_write(struct file *, const char __user *, size_t, loff_t *);
+extern ssize_t generic_file_aio_read(struct kiocb *, char __user *, size_t, loff_t);
+extern ssize_t __generic_file_aio_read(struct kiocb *, const struct iovec *, unsigned long, loff_t *);
+extern ssize_t generic_file_aio_write(struct kiocb *, const char __user *, size_t, loff_t);
+extern ssize_t generic_file_aio_write_nolock(struct kiocb *, const struct iovec *,
+		unsigned long, loff_t *);
+extern ssize_t generic_file_direct_write(struct kiocb *, const struct iovec *,
+		unsigned long *, loff_t, loff_t *, size_t, size_t);
+extern ssize_t generic_file_buffered_write(struct kiocb *, const struct iovec *,
+		unsigned long, loff_t, loff_t *, size_t, ssize_t);
+extern ssize_t do_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos);
+extern ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos);
+ssize_t generic_file_write_nolock(struct file *file, const struct iovec *iov,
+				unsigned long nr_segs, loff_t *ppos);
+extern ssize_t generic_file_sendfile(struct file *, loff_t *, size_t, read_actor_t, void *);
+extern void do_generic_mapping_read(struct address_space *mapping,
+				    struct file_ra_state *, struct file *,
+				    loff_t *, read_descriptor_t *, read_actor_t);
+extern void
+file_ra_state_init(struct file_ra_state *ra, struct address_space *mapping);
+extern ssize_t generic_file_direct_IO(int rw, struct kiocb *iocb,
+	const struct iovec *iov, loff_t offset, unsigned long nr_segs);
+extern ssize_t generic_file_readv(struct file *filp, const struct iovec *iov, 
+	unsigned long nr_segs, loff_t *ppos);
+ssize_t generic_file_writev(struct file *filp, const struct iovec *iov, 
+			unsigned long nr_segs, loff_t *ppos);
+extern loff_t no_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t generic_file_llseek(struct file *file, loff_t offset, int origin);
+extern loff_t remote_llseek(struct file *file, loff_t offset, int origin);
+extern int generic_file_open(struct inode * inode, struct file * filp);
+extern int nonseekable_open(struct inode * inode, struct file * filp);
+
+static inline void do_generic_file_read(struct file * filp, loff_t *ppos,
+					read_descriptor_t * desc,
+					read_actor_t actor)
+{
+	do_generic_mapping_read(filp->f_mapping,
+				&filp->f_ra,
+				filp,
+				ppos,
+				desc,
+				actor);
+}
+
+ssize_t __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,
+	struct block_device *bdev, const struct iovec *iov, loff_t offset,
+	unsigned long nr_segs, get_blocks_t get_blocks, dio_iodone_t end_io,
+	int lock_type);
+
+enum {
+	DIO_LOCKING = 1, /* need locking between buffered and direct access */
+	DIO_NO_LOCKING,  /* bdev; no locking at all between buffered/direct */
+	DIO_OWN_LOCKING, /* filesystem locks buffered and direct internally */
+};
+
+static inline ssize_t blockdev_direct_IO(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_blocks, end_io, DIO_LOCKING);
+}
+
+static inline ssize_t blockdev_direct_IO_no_locking(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_blocks, end_io, DIO_NO_LOCKING);
+}
+
+static inline ssize_t blockdev_direct_IO_own_locking(int rw, struct kiocb *iocb,
+	struct inode *inode, struct block_device *bdev, const struct iovec *iov,
+	loff_t offset, unsigned long nr_segs, get_blocks_t get_blocks,
+	dio_iodone_t end_io)
+{
+	return __blockdev_direct_IO(rw, iocb, inode, bdev, iov, offset,
+				nr_segs, get_blocks, end_io, DIO_OWN_LOCKING);
+}
+
+extern struct file_operations generic_ro_fops;
+
+#define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))
+
+extern int vfs_readlink(struct dentry *, char __user *, int, const char *);
+extern int vfs_follow_link(struct nameidata *, const char *);
+extern int page_readlink(struct dentry *, char __user *, int);
+extern int page_follow_link_light(struct dentry *, struct nameidata *);
+extern void page_put_link(struct dentry *, struct nameidata *);
+extern int page_symlink(struct inode *inode, const char *symname, int len);
+extern struct inode_operations page_symlink_inode_operations;
+extern int generic_readlink(struct dentry *, char __user *, int);
+extern void generic_fillattr(struct inode *, struct kstat *);
+extern int vfs_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+void inode_add_bytes(struct inode *inode, loff_t bytes);
+void inode_sub_bytes(struct inode *inode, loff_t bytes);
+loff_t inode_get_bytes(struct inode *inode);
+void inode_set_bytes(struct inode *inode, loff_t bytes);
+
+extern int vfs_readdir(struct file *, filldir_t, void *);
+
+extern int vfs_stat(char __user *, struct kstat *);
+extern int vfs_lstat(char __user *, struct kstat *);
+extern int vfs_fstat(unsigned int, struct kstat *);
+
+extern int vfs_ioctl(struct file *, unsigned int, unsigned int, unsigned long);
+
+extern struct file_system_type *get_fs_type(const char *name);
+extern struct super_block *get_super(struct block_device *);
+extern struct super_block *user_get_super(dev_t);
+extern void drop_super(struct super_block *sb);
+
+extern int dcache_dir_open(struct inode *, struct file *);
+extern int dcache_dir_close(struct inode *, struct file *);
+extern loff_t dcache_dir_lseek(struct file *, loff_t, int);
+extern int dcache_readdir(struct file *, void *, filldir_t);
+extern int simple_getattr(struct vfsmount *, struct dentry *, struct kstat *);
+extern int simple_statfs(struct super_block *, struct kstatfs *);
+extern int simple_link(struct dentry *, struct inode *, struct dentry *);
+extern int simple_unlink(struct inode *, struct dentry *);
+extern int simple_rmdir(struct inode *, struct dentry *);
+extern int simple_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);
+extern int simple_sync_file(struct file *, struct dentry *, int);
+extern int simple_empty(struct dentry *);
+extern int simple_readpage(struct file *file, struct page *page);
+extern int simple_prepare_write(struct file *file, struct page *page,
+			unsigned offset, unsigned to);
+extern int simple_commit_write(struct file *file, struct page *page,
+				unsigned offset, unsigned to);
+
+extern struct dentry *simple_lookup(struct inode *, struct dentry *, struct nameidata *);
+extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
+extern struct file_operations simple_dir_operations;
+extern struct inode_operations simple_dir_inode_operations;
+struct tree_descr { char *name; struct file_operations *ops; int mode; };
+struct dentry *d_alloc_name(struct dentry *, const char *);
+extern int simple_fill_super(struct super_block *, int, struct tree_descr *);
+extern int simple_pin_fs(char *name, struct vfsmount **mount, int *count);
+extern void simple_release_fs(struct vfsmount **mount, int *count);
+
+extern ssize_t simple_read_from_buffer(void __user *, size_t, loff_t *, const void *, size_t);
+
+extern int inode_change_ok(struct inode *, struct iattr *);
+extern int __must_check inode_setattr(struct inode *, struct iattr *);
+
+extern void inode_update_time(struct inode *inode, int ctime_too);
+
+static inline ino_t parent_ino(struct dentry *dentry)
+{
+	ino_t res;
+
+	spin_lock(&dentry->d_lock);
+	res = dentry->d_parent->d_inode->i_ino;
+	spin_unlock(&dentry->d_lock);
+	return res;
+}
+
+/* kernel/fork.c */
+extern int unshare_files(void);
+
+/* Transaction based IO helpers */
+
+/*
+ * An argresp is stored in an allocated page and holds the
+ * size of the argument or response, along with its content
+ */
+struct simple_transaction_argresp {
+	ssize_t size;
+	char data[0];
+};
+
+#define SIMPLE_TRANSACTION_LIMIT (PAGE_SIZE - sizeof(struct simple_transaction_argresp))
+
+char *simple_transaction_get(struct file *file, const char __user *buf,
+				size_t size);
+ssize_t simple_transaction_read(struct file *file, char __user *buf,
+				size_t size, loff_t *pos);
+int simple_transaction_release(struct inode *inode, struct file *file);
+
+static inline void simple_transaction_set(struct file *file, size_t n)
+{
+	struct simple_transaction_argresp *ar = file->private_data;
+
+	BUG_ON(n > SIMPLE_TRANSACTION_LIMIT);
+
+	/*
+	 * The barrier ensures that ar->size will really remain zero until
+	 * ar->data is ready for reading.
+	 */
+	smp_mb();
+	ar->size = n;
+}
+
+#ifdef CONFIG_SECURITY
+static inline char *alloc_secdata(void)
+{
+	return (char *)get_zeroed_page(GFP_KERNEL);
+}
+
+static inline void free_secdata(void *secdata)
+{
+	free_page((unsigned long)secdata);
+}
+#else
+static inline char *alloc_secdata(void)
+{
+	return (char *)1;
+}
+
+static inline void free_secdata(void *secdata)
+{ }
+#endif	/* CONFIG_SECURITY */
+
+#endif /* __KERNEL__ */
+#endif /* _LINUX_FS_H */
